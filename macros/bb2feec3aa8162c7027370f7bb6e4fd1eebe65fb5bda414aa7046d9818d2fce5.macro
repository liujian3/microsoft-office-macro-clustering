Attribute VB_Name = "Advanced"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le istruzioni per modificare le opzioni degli strumenti da base a avanzate e viceversa

Option Explicit
Dim MoveLeft As Single
Dim MoveRight As Single
Dim MoveDown As Single
Dim MoveUp As Single
Dim ctl As control
Dim fScale As Single

Sub ToggleAdvanced(frm As Object)
    
    fScale = (GetSettings("Scale") / 100) * tmpScale
    
    '#' Riposizionamento dei controlli
    For Each ctl In frm.Controls
        If frm.tglAdvanced = False Then
            Select Case True
                Case (ctl.Tag Like "ToLeft*")
                    MoveLeft = Mid(ctl.Tag, 8) * fScale
                    ctl.Left = ctl.Left - MoveLeft
                Case (ctl.Tag Like "ToUp*")
                    MoveUp = Mid(ctl.Tag, 6) * fScale
                    ctl.Top = ctl.Top - MoveUp
                Case (ctl.Tag = "ToHide")
                    ctl.visible = False
            End Select
        Else
            Select Case True
                Case (ctl.Tag Like "ToLeft*")
                    MoveLeft = Mid(ctl.Tag, 8) * fScale
                    ctl.Left = ctl.Left + MoveLeft
                Case (ctl.Tag Like "ToUp*")
                    MoveUp = Mid(ctl.Tag, 6) * fScale
                    ctl.Top = ctl.Top + MoveUp
                Case (ctl.Tag = "ToHide")
                    ctl.visible = True
            End Select
        End If
    Next ctl
    
    '#' Ridimensionamento del form
    If frm.tglAdvanced = False Then
        If frm.Tag Like "ToLeft*" Then
            MoveLeft = Mid(frm.Tag, 8)
            frm.Width = frm.Width - MoveLeft * fScale
        ElseIf frm.Tag Like "ToUp*" Then
            MoveUp = Mid(frm.Tag, 6)
            frm.Height = frm.Height - MoveUp * fScale
        End If
        frm.tglAdvanced.BackColor = &H80C0FF
        frm.tglAdvanced.ControlTipText = IIf(lng = 0, "Mostra le opzioni avanzate", "Toggle advanced options")
    Else
        If frm.Tag Like "ToLeft*" Then
            MoveLeft = Mid(frm.Tag, 8)
            frm.Width = frm.Width + MoveLeft * fScale
        ElseIf frm.Tag Like "ToUp*" Then
            MoveUp = Mid(frm.Tag, 6)
            frm.Height = frm.Height + MoveUp * fScale
        End If
        frm.tglAdvanced.BackColor = &HFF00&
        frm.tglAdvanced.ControlTipText = IIf(lng = 0, "Nascondi le opzioni avanzate", "Toggle advanced options")
    End If
    
End Sub
Attribute VB_Name = "BatchFunctions"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le funzioni per le elaborazioni batch

Option Explicit

Sub BatchRemove(frm As Object)
    Dim i As Long
    Dim counter As Long
    
    counter = 0
    For i = 0 To frm.lbxBatchFiles.ListCount - 1
        If frm.lbxBatchFiles.Selected(i - counter) = True Then
            frm.lbxBatchFiles.RemoveItem (i - counter)
            counter = counter + 1
        End If
    Next i
End Sub

Sub BatchAdd(frm As Object)
    Dim i As Long
    Dim FileList As Collection
    Dim FileName As Variant
    Dim Item As Variant
    Dim MaxColWidth As String
    
    Set FileList = New Collection
    On Error Resume Next
    For i = 0 To frm.lbxBatchFiles.ListCount - 1
        FileList.Add frm.lbxBatchFiles.List(i), CStr(frm.lbxBatchFiles.List(i))
    Next i
    On Error GoTo 0
        
    
    FileName = OpenDialog(frm.txtBatchPath.Text, , IIf(lng = 0, "Seleziona i file da elaborare", "Select files to be processed"), True)
                       
    If IsArray(FileName) = False Then Exit Sub
    
    On Error Resume Next
    For i = LBound(FileName) To UBound(FileName)
        If i = LBound(FileName) Then 'Aggiorno il percorso nella textbox nascosta
            frm.txtBatchPath = Replace(FileName(i), Dir(FileName(i)), "")
        End If
        
        FileList.Add FileName(i), CStr(FileName(i))
    Next i
    
    frm.lbxBatchFiles.Clear
            
    For Each Item In FileList
        frm.lbxBatchFiles.AddItem Item
        If Len(CStr(Item)) * 5 > MaxColWidth Then
            MaxColWidth = Len(CStr(Item)) * 5
            frm.lbxBatchFiles.ColumnWidths = MaxColWidth
        End If
    Next Item
    On Error GoTo 0
    
End Sub

Sub ToggleBatch(frm As Object)
    Dim scalefactor As Double
    
    scalefactor = (GetSettings("Scale") / 100) * tmpScale
    
    If frm.tglBatch = True Then
        frm.Height = Application.WorksheetFunction.Max(frm.Height, (TitleBarHeight + frm.fraBatch.Top + frm.fraBatch.Height + (4 * scalefactor)))
        frm.Width = frm.Width + frm.fraBatch.Width + (8 * scalefactor)
        frm.tglBatch.Font.Weight = 700
        frm.tglBatch.BackColor = &HFF00&
        frm.cmdOK.Caption = "Ok (Batch)"
    Else
        frm.Height = BaseHeight * tmpScale
        frm.Width = frm.Width - frm.fraBatch.Width - (8 * scalefactor)
        frm.tglBatch.Font.Weight = 400
        frm.tglBatch.BackColor = &H80C0FF
        frm.cmdOK.Caption = "Ok"
    End If
    
    frm.fraBatch.visible = frm.tglBatch

End Sub
Attribute VB_Name = "CCommonButtons"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

'RIDIMENSIONA
Public WithEvents cIncreaseSize As MSForms.CommandButton
Attribute cIncreaseSize.VB_VarHelpID = -1
Public WithEvents cDecreaseSize As MSForms.CommandButton
Attribute cDecreaseSize.VB_VarHelpID = -1

'CARICA OPZIONI
Public WithEvents cLatest As MSForms.CommandButton
Attribute cLatest.VB_VarHelpID = -1
Public WithEvents cDefault As MSForms.CommandButton
Attribute cDefault.VB_VarHelpID = -1

'VISUALIZZA SCORCIATOIE-APRI HELP
Public WithEvents cKeys As MSForms.CommandButton
Attribute cKeys.VB_VarHelpID = -1
Public WithEvents cHelp As MSForms.CommandButton
Attribute cHelp.VB_VarHelpID = -1

'TROVA ED ESEGUI
Public WithEvents cHelpFind As MSForms.CommandButton
Attribute cHelpFind.VB_VarHelpID = -1
Public WithEvents cRunFind As MSForms.CommandButton
Attribute cRunFind.VB_VarHelpID = -1

Public WithEvents cToggleAdvanced As MSForms.ToggleButton
Attribute cToggleAdvanced.VB_VarHelpID = -1
Public WithEvents cColKey As MSForms.ComboBox
Attribute cColKey.VB_VarHelpID = -1

'CASELLE DI TESTO SVUOTA CON X
Public WithEvents cBlankTxt As MSForms.Label
Attribute cBlankTxt.VB_VarHelpID = -1
Public WithEvents cTextbox As MSForms.TextBox
Attribute cTextbox.VB_VarHelpID = -1

'SQL
Public WithEvents cSQLCheck As MSForms.CheckBox
Attribute cSQLCheck.VB_VarHelpID = -1
Public WithEvents cSQLText As MSForms.TextBox
Attribute cSQLText.VB_VarHelpID = -1
Public WithEvents cSQLCombo As MSForms.ComboBox
Attribute cSQLCombo.VB_VarHelpID = -1
Public WithEvents cSQLFLen As MSForms.TextBox
Attribute cSQLFLen.VB_VarHelpID = -1

'BACKUP'
Public WithEvents cToggleBackup As MSForms.ToggleButton
Attribute cToggleBackup.VB_VarHelpID = -1

'BATCH'
Public WithEvents cToggleBatch As MSForms.ToggleButton
Attribute cToggleBatch.VB_VarHelpID = -1
Public WithEvents cBatchEmptyList As MSForms.CommandButton
Attribute cBatchEmptyList.VB_VarHelpID = -1
Public WithEvents cBatchRemove As MSForms.CommandButton
Attribute cBatchRemove.VB_VarHelpID = -1
Public WithEvents cBatchAdd As MSForms.CommandButton
Attribute cBatchAdd.VB_VarHelpID = -1
Public WithEvents cBatchActiveFile As MSForms.CheckBox
Attribute cBatchActiveFile.VB_VarHelpID = -1
Public WithEvents cBatchBackup As MSForms.CheckBox
Attribute cBatchBackup.VB_VarHelpID = -1


Private Sub cBlankTxt_Click()
    Dim X As Double
    Dim Y As Double
    Dim ctl As control
    
    'Trova il punto centrale del controllo Label "X"
    X = cBlankTxt.Left + (cBlankTxt.Width / 2)
    Y = cBlankTxt.Top + (cBlankTxt.Height / 2)
    
    'Verifica quale box di testo "contiene" la Label "X"
    For Each ctl In cBlankTxt.Parent.Controls '(.Parent = userform o frame che contiene la X)
        If ctl.Name Like "txt*" And ctl.Parent.Name = cBlankTxt.Parent.Name Then
            If (X > ctl.Left And X < (ctl.Left + ctl.Width)) And _
               (Y > ctl.Top And Y < (ctl.Top + ctl.Height)) Then
                    On Error Resume Next 'Per evitare errori in caso di controllo disabilitato o invisibile
                    ctl.Value = ""
                    ctl.SetFocus
                    On Error GoTo 0
                    Exit For
            End If
        End If
    Next ctl
End Sub


Private Sub cTextbox_Change()
    Dim X As Double
    Dim Y As Double
    Dim ctl As control
    
    'Verifica quale box di testo "contiene" la Label "X"
    For Each ctl In cTextbox.Parent.Controls '(.Parent = userform o frame che contiene la textbox)
        If ctl.Name Like "lblBlank*" And ctl.Parent.Name = cTextbox.Parent.Name Then
    
            'Trova il punto centrale del controllo Label "X"
            X = ctl.Left + (ctl.Width / 2)
            Y = ctl.Top + (ctl.Height / 2)
                        
            If (X > cTextbox.Left And X < (cTextbox.Left + cTextbox.Width)) And _
               (Y > cTextbox.Top And Y < (cTextbox.Top + cTextbox.Height)) Then
                    On Error Resume Next 'Per evitare errori in caso di controllo disabilitato o invisibile
                    If cTextbox.Value = "" Then
                        ctl.visible = False
                    Else
                        ctl.visible = True
                    End If
                    On Error GoTo 0
                    Exit For
            End If
        End If
    Next ctl
    
End Sub

Private Sub cIncreaseSize_Click()
    
    If TypeName(cIncreaseSize.Parent) = "Frame" Then
        Call IncreaseFormSize(cIncreaseSize.Parent.Parent)
    Else
        Call IncreaseFormSize(cIncreaseSize.Parent)
    End If
End Sub

Private Sub cDecreaseSize_Click()
    
    If TypeName(cDecreaseSize.Parent) = "Frame" Then
        Call DecreaseFormSize(cDecreaseSize.Parent.Parent)
    Else
        Call DecreaseFormSize(cDecreaseSize.Parent)
    End If
End Sub

Private Sub cKeys_Click()

    frmKeyShortcuts.Show
    
End Sub

Private Sub cLatest_Click()

    Call LoadOptions(cLatest.Parent.Parent, False)
    
End Sub

Private Sub cDefault_Click()

    Call LoadOptions(cDefault.Parent.Parent, True)
    
End Sub

Private Sub cHelp_Click()
    If TypeName(cHelp.Parent) = "Frame" Then
        Call OpenHelp(cHelp.Parent.Parent.Name)
    Else
        Call OpenHelp(cHelp.Parent.Name)
    End If
End Sub

Private Sub cColKey_Change()
    Call frmJoinFiles.UpdateNewKey(cColKey.Parent.index)
End Sub

'OPZIONI AVANZATE'
Private Sub cToggleAdvanced_Change()
    If TypeName(cToggleAdvanced.Parent) = "Frame" Then
        Call ToggleAdvanced(cToggleAdvanced.Parent.Parent)
    Else
        Call ToggleAdvanced(cToggleAdvanced.Parent)
    End If
End Sub


'BACKUP'
Private Sub cToggleBackup_Change()
    Call UpdateConfigFile("CreateBackup", Abs(CInt(cToggleBackup.Value)))
End Sub

'BATCH'
Private Sub cToggleBatch_Change()
    Call ToggleBatch(cToggleBatch.Parent)
    Call GoodToGo(cToggleBatch.Parent)
End Sub

Private Sub cBatchEmptyList_Click()
    cBatchEmptyList.Parent.Parent.lbxBatchFiles.Clear
    Call GoodToGo(cBatchEmptyList.Parent.Parent)
End Sub

Private Sub cBatchRemove_Click()
    Call BatchRemove(cBatchRemove.Parent.Parent)
    Call GoodToGo(cBatchRemove.Parent.Parent)
End Sub
Private Sub cBatchAdd_Click()
    Call BatchAdd(cBatchAdd.Parent.Parent)
    Call GoodToGo(cBatchAdd.Parent.Parent)
End Sub

Private Sub cBatchActiveFile_Change()
    Call GoodToGo(cBatchActiveFile.Parent.Parent)
End Sub

Private Sub cBatchBackup_Change()
    If cBatchBackup = False Then
        MsgBox TranslateCnst("BatchNoBackup"), vbExclamation, TranslateCnst("BatchNoBackupTitle")
    End If
End Sub


'PULSANTI MASCHERA RICERCA'
Private Sub cHelpFind_Click()
    Call OpenHelp(cHelpFind.Tag, 1)
End Sub

Private Sub cRunFind_Click()
    cRunFind.Parent.Parent.Hide
    Application.Run cRunFind.Tag
    Unload cRunFind.Parent.Parent
End Sub


'SQL
Private Sub cSQLFLen_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    Dim fType As String
    
    fType = UCase(cSQLFLen.Parent.Controls("SQLcbxSQLType" & Mid(cSQLFLen.Name, InStr(1, cSQLFLen.Name, "_"))))
    
    If KeyAscii = 46 Or KeyAscii = 44 Then
        If fType Like "VARCHAR*" Or fType Like "*DATE*" Then
            KeyAscii = 0
        Else
            KeyAscii = 44
        End If
    ElseIf KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub cSQLFLen_Change()
    Dim fType As String
    Dim fDBMS As String
    
    fType = UCase(cSQLFLen.Parent.Controls("SQLcbxSQLType" & Mid(cSQLFLen.Name, InStr(1, cSQLFLen.Name, "_"))))
    fDBMS = UCase(cSQLFLen.Parent.Parent.Controls("cbxDBMS").Text)
    
    If fDBMS = "MS ACCESS" And fType = "VARCHAR" Then
        If Val(cSQLFLen) > 255 Then cSQLFLen = 255
    End If
End Sub

Private Sub cSQLCheck_Change()
    Dim cIndex As Long
    
    cIndex = Mid(cSQLCheck.Name, InStr(1, cSQLCheck.Name, "_") + 1)
    cSQLCheck.Parent.Controls("SQLtxtXLCol_" & cIndex).Enabled = cSQLCheck.Value
    cSQLCheck.Parent.Controls("SQLtxtSQLCol_" & cIndex).Enabled = cSQLCheck.Value
    cSQLCheck.Parent.Controls("SQLcbxSQLType_" & cIndex).Enabled = cSQLCheck.Value
    cSQLCheck.Parent.Controls("SQLtxtFLen_" & cIndex).visible = cSQLCheck.Value * cSQLCheck.Parent.Parent.Controls("chkCreateTable").Value
End Sub

Private Sub cSQLText_Change()
    If cSQLText.Value <> SQLClean(cSQLText.Value, "column") Then
        cSQLText.BackColor = &HC0E0FF
    Else
        cSQLText.BackColor = &H80000005
    End If
End Sub

Private Sub cSQLCombo_Change()
    
    With cSQLCombo.Parent.Controls("SQLtxtFLen" & Mid(cSQLCombo.Name, InStr(1, cSQLCombo.Name, "_")))
        .Enabled = Not (cSQLCombo.ListIndex = 2)
        
        If cSQLCombo.ListIndex = 2 Then
            .Value = ""
            .BackColor = &HC0C0C0
        Else
            .BackColor = &H80000005
        End If
        
    End With
End Sub
Attribute VB_Name = "CExcelEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Public WithEvents App As Application
Attribute App.VB_VarHelpID = -1

Private Sub App_WorkbookBeforeSave(ByVal wb As Workbook, ByVal SaveAsUI As Boolean, Cancel As Boolean)
    Dim sh As Worksheet
    Dim ConfirmDelete As Long
    
    If bCodeSave = True Then
        bCodeSave = False
        Exit Sub
    End If
    
    'Routine per la cancellazione del foglio di backup
    If GetSettings("DeleteBackup") = 1 Then
        For Each sh In wb.Worksheets
            If UCase(sh.Name) = "ESK_BACKUP" Then
                ConfirmDelete = MsgBox(DeleteBackupPrompt, _
                    vbQuestion + vbYesNo, _
                    IIf(lng = 0, "Rilevato foglio di backup", "Backup sheet detected"))
                If ConfirmDelete = vbYes Then
                    Application.DisplayAlerts = False
                    sh.Delete
                    Application.DisplayAlerts = True
                End If
                Exit For
            End If
        Next sh
    End If

End Sub
Attribute VB_Name = "Callbacks"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''


Option Explicit
Public ESKRibbon As IRibbonUI

#If Not Mac Then
    #If VBA7 Then
        Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias _
            "RtlMoveMemory" (destination As Any, source As Any, _
            ByVal length As Long)
    #Else
        Public Declare Sub CopyMemory Lib "kernel32" Alias _
            "RtlMoveMemory" (destination As Any, source As Any, _
            ByVal length As Long)
    #End If
#End If
    


'----------INIZIO DI FUNZIONI DI SERVIZIO
Sub ESKRibbonInit(ByVal ribbon As Office.IRibbonUI)
'Inizializza l'oggetto Ribbon e lo assegna a un Nome definito
    
    Dim lngRibPtr As LongPtr
    
    ' Store pointer to IRibbonUI
    ' Store the custom ribbon UI Id in a static variable.
    ' This is done once during load of UI. I.e. during workbook open.
    Set ESKRibbon = ribbon
    If Val(Application.Version) >= 14 Then
        lngRibPtr = ObjPtr(ribbon)
        ' Write pointer to worksheet for safe keeping
        ThisWorkbook.Names.Add "RibbonXPointer", lngRibPtr, False
    End If

End Sub

Function GetRibbon(lngRibPtr As LongPtr) As Object
   Dim objRibbon As Object
   CopyMemory objRibbon, lngRibPtr, 4
   Set GetRibbon = objRibbon
   ' clean up invalid object
   CopyMemory objRibbon, 0&, 4
   Set objRibbon = Nothing
End Function

Sub GetVisible(control As IRibbonControl, ByRef visible)
'Rende alcuni controlli invisibili se utilizzato su Mac
    If IsWindows = True Then
        visible = True
    Else
        visible = False
    End If
End Sub

Sub GetVisibleLNG(control As IRibbonControl, ByRef visible)
'Rende i controlli invisibili se in lingua inglese
    If lng = 0 Then
        visible = True
    Else
        visible = False
    End If
End Sub

Sub GetLabel(control As IRibbonControl, ByRef Label)
'Imposta le etichette dei controlli Ribbon a seconda della lingua impostata
    Dim uR As Long
    Dim i As Long
        
    With MenuSheet
    
        uR = .Cells(.Rows.Count, 2).End(xlUp).Row
        For i = 2 To uR
            If Replace(Replace(control.ID, "2", ""), "dyn_", "") = .Cells(i, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)) Then
                Label = .Cells(i, Application.WorksheetFunction.Match("label_it", .Rows(1), 0)).Offset(0, lng)
                Exit For
            End If
        Next i
    
    End With

End Sub

Sub GetSuperTip(control As IRibbonControl, ByRef screentip)
'Imposta le etichette dei controlli Ribbon a seconda della lingua impostata
    Dim uR As Long
    Dim i As Long
        
    With MenuSheet
    
        uR = .Cells(.Rows.Count, 2).End(xlUp).Row
        For i = 2 To uR
            If Replace(Replace(control.ID, "2", ""), "dyn_", "") = .Cells(i, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)) Then
                screentip = .Cells(i, Application.WorksheetFunction.Match("supertip_it", .Rows(1), 0)).Offset(0, lng)
                Exit For
            End If
        Next i
    
    End With

End Sub

Sub GetTitle(control As IRibbonControl, ByRef Label)
'Imposta le etichette dei controlli Ribbon a seconda della lingua impostata
    Dim uR As Long
    Dim i As Long
    Dim ctlID As String
        
    With MenuSheet
    
        uR = .Cells(.Rows.Count, 2).End(xlUp).Row
        For i = 2 To uR
            ctlID = control.ID
            If Left(ctlID, 3) <> "Sep" Then ctlID = Replace(ctlID, 2, "")
            If ctlID = .Cells(i, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)) Then
                Label = .Cells(i, Application.WorksheetFunction.Match("label_it", .Rows(1), 0)).Offset(0, lng)
                Exit For
            End If
        Next i
    
    End With

End Sub


'----------INIZIO DI FUNZIONI PERSONALIZZATE
Public Sub btnCONTA_SE_COLORE(control As IRibbonControl)

    udfCONTA_SE_COLORE.Show

End Sub

Public Sub btnCONTA_SE_FONT(control As IRibbonControl)

    udfCONTA_SE_FONT.Show

End Sub

Public Sub btnSOMMA_SE_COLORE(control As IRibbonControl)

    udfSOMMA_SE_COLORE.Show

End Sub

Public Sub btnSOMMA_SE_FONT(control As IRibbonControl)

    udfSOMMA_SE_FONT.Show

End Sub

Public Sub btnGINI(control As IRibbonControl)

    udfGINI.Show

End Sub

Public Sub btnNORMALIZZA_MINMAX(control As IRibbonControl)

    udfNORMALIZZA_MINMAX.Show

End Sub

Public Sub btnORDINE_PAROLE(control As IRibbonControl)

    udfORDINE_PAROLE.Show

End Sub

Public Sub btnESTRAI_NUMERI(control As IRibbonControl)

    udfESTRAI_NUMERI.Show

End Sub

Public Sub btnESTRAI_HYPERLINK(control As IRibbonControl)

    udfESTRAI_HYPERLINK.Show

End Sub

Public Sub btnSTRINGACOMUNE(control As IRibbonControl)

    udfSTRINGACOMUNE.Show

End Sub

Public Sub btnMEDIA_MOBILE(control As IRibbonControl)

    udfMEDIA_MOBILE.Show

End Sub

Public Sub btnMEDIA_MOBILE_SIMMETRICA(control As IRibbonControl)

    udfMEDIA_MOBILE_SIMMETRICA.Show

End Sub

Public Sub btnCERCAVERT_SIMILE(control As IRibbonControl)

    udfCERCAVERT_SIMILE.Show

End Sub

Public Sub btnCONCATENA_INTERVALLI(control As IRibbonControl)

    udfCONCATENA_INTERVALLI.Show

End Sub


'----------INIZIO DI MASCHERE PROGRAMMA
Public Sub btnAbout(control As IRibbonControl)

    frmAbout.Show

End Sub

Public Sub btnKeyShortcuts(control As IRibbonControl)

    frmKeyShortcuts.Show

End Sub

Public Sub btnNewsletter(control As IRibbonControl)

    Call OpenUrl("http://eepurl.com/c7aa1X", 1)

End Sub

Public Sub btnForumExcel(control As IRibbonControl)

    Call OpenUrl("http://rebrand.ly/esk_forumexcel", 1)

End Sub

Public Sub btnWebsite(control As IRibbonControl)

    Call OpenUrl("http://www.excelswissknife.com", 1)

End Sub

Public Sub btnHelp(control As IRibbonControl)

    Call OpenUrl("http://www.excelswissknife.com/help", 1)

End Sub
Public Sub btnEmail(control As IRibbonControl)

    Call OpenUrl("mailto:info@excelswissknife.com")

End Sub

Public Sub btnYouTube(control As IRibbonControl)

    Call OpenUrl("https://rebrand.ly/esk_youtube", 1)

End Sub

Public Sub btnFacebook(control As IRibbonControl)

    Call OpenUrl("http://rebrand.ly/esk_facebook", 1)

End Sub

Public Sub btnInstagram(control As IRibbonControl)

    Call OpenUrl("https://www.instagram.com/excelswissknife", 1)

End Sub
Public Sub btnDonate(control As IRibbonControl)

    Call OpenUrl("http://www.excelswissknife.com/donate", 1)

End Sub

Public Sub btnUpdateCheck(control As IRibbonControl)
    
    If IsWindows = True Then
        frmUpdateCheck.Show
    Else
        Call OpenUrl("http://www.excelswissknife.com/download", 1)
    End If
    
End Sub

Public Sub btnSettings(control As IRibbonControl)

    frmSettings.Show

End Sub

Public Sub btnReadme(control As IRibbonControl)

    frmReadMe.Show
    
End Sub

Public Sub btnChangelog(control As IRibbonControl)
    
    frmChangelog.Show

End Sub

Public Sub btnErrorlog(control As IRibbonControl)

    frmErrorLog.Show

End Sub

Public Sub btnFindUtility(control As IRibbonControl)

    frmFindUtility.Show

End Sub

Public Sub btnSaveSnapshot(control As IRibbonControl)

    Call SaveSnapshot

End Sub

Public Sub btnLoadSnapshot(control As IRibbonControl)
    
    Call SnapShots
    
End Sub

Public Sub btnSnapshotsManager(control As IRibbonControl)
    
    Call SnapShotsManager
    
End Sub

Public Sub btnSnapshotSettings(control As IRibbonControl)
    
    frmSettings.mpgSettings.Value = 1
    frmSettings.cmdSelectFolder.SetFocus
    frmSettings.Show

End Sub



'----------INIZIO DI ALTRI STRUMENTI
Public Sub btnPivotTableClassic(control As IRibbonControl)

    Call PivotTableClassic

End Sub

Public Sub btnSplitSheet(control As IRibbonControl)

    Call SplitSheet

End Sub

Public Sub btnSaveToSeparateFiles(control As IRibbonControl)

    Call SaveToSeparateFiles

End Sub

Public Sub btnAppendSheets(control As IRibbonControl)

    Call AppendSheets

End Sub

Public Sub btnConvertTextToNumbers(control As IRibbonControl)

    Call ConvertTextToNumbers

End Sub

Public Sub btnFill_Cells_Below(control As IRibbonControl)

    Call Fill_Cells_Below

End Sub

Public Sub btnUnFill_Below(control As IRibbonControl)

    Call UnFill_Below

End Sub

Public Sub btnFill_Cells_Right(control As IRibbonControl)

    Call Fill_Cells_Right

End Sub

Public Sub btnUnFill_Right(control As IRibbonControl)

    Call UnFill_Right

End Sub

Sub btnDeleteEmptyHiddenRC(control As IRibbonControl)

    Call DeleteEmptyHiddenRC

End Sub
    
Public Sub btnAddBeforeAfter(control As IRibbonControl)

    Call AddBeforeAfter

End Sub
    
Public Sub btnAddSheets(control As IRibbonControl)

    Call AddSheets

End Sub
    
Public Sub btnUnhide_Multiple_Sheets(control As IRibbonControl)

    Call Unhide_Multiple_Sheets

End Sub
    
Public Sub btnSortWorksheetsASC(control As IRibbonControl)

    Call SortWorksheetsASC

End Sub
    
Public Sub btnSortWorksheetsDESC(control As IRibbonControl)

    Call SortWorksheetsDESC

End Sub

Public Sub btnConvertPct(control As IRibbonControl)

    Call ConvertPct

End Sub

Public Sub btnInvertSelection(control As IRibbonControl)

    Call InvertSelection

End Sub

Public Sub btnSelectRows(control As IRibbonControl)

    Call SelectRows

End Sub

Public Sub btnSelectCols(control As IRibbonControl)

    Call SelectCols

End Sub

Public Sub btnGroupRowsColumns(control As IRibbonControl)

    Call GroupRowsColumns

End Sub

Sub btnInsertRows(control As IRibbonControl)

    Call InsertRows
    
End Sub

Public Sub btnInsertColumns(control As IRibbonControl)

    Call InsertColumns

End Sub

Public Sub btnUnselect(control As IRibbonControl)

    Call Unselect

End Sub

Public Sub btnAdvancedPivot(control As IRibbonControl)

    Call AdvancedPivot

End Sub

Public Sub btnImportMultipleFiles(control As IRibbonControl)

    Call ImportMultipleFiles

End Sub

Public Sub btnAddIfError(control As IRibbonControl)

    Call AddIfError

End Sub

Public Sub btnInsert_international_formula(control As IRibbonControl)

    Call Insert_international_formula

End Sub

Public Sub btnReset_Last_Cell(control As IRibbonControl)

    Call Reset_Last_Cell

End Sub

Public Sub btnPasteRowHeight(control As IRibbonControl)

    Call PasteRowHeight

End Sub

Public Sub btnSplitCol(control As IRibbonControl)

    Call SplitCol

End Sub

Public Sub btnMeasurePrintArea(control As IRibbonControl)

    Call MeasurePrintArea

End Sub

Public Sub btnConditionalSelectCells(control As IRibbonControl)

    Call ConditionalSelectCells

End Sub

Public Sub btnJoinColumns(control As IRibbonControl)

    Call JoinColumns

End Sub

Public Sub btnJoinRows(control As IRibbonControl)

    Call JoinRows

End Sub

Public Sub btnPrintExtLinksIndex(control As IRibbonControl)

    Call PrintExtLinksIndex

End Sub

Public Sub btnMirrorData(control As IRibbonControl)

    Call MirrorData

End Sub

Public Sub btnRandomFill(control As IRibbonControl)

    Call RandomFill

End Sub

Public Sub btnCompute(control As IRibbonControl)

    Call Compute

End Sub

Public Sub btnFilterByTextFormat(control As IRibbonControl)

    Call FilterByTextFormat

End Sub

Public Sub btnConvertCase(control As IRibbonControl)

    Call ConvertCase

End Sub

Public Sub btnRoundToNDecimals(control As IRibbonControl)

    Call RoundToNDecimals

End Sub

Public Sub btnImportPageSetup(control As IRibbonControl)

    Call ImportPageSetup

End Sub

Public Sub btnCompareRanges(control As IRibbonControl)

    Call CompareRanges

End Sub

Public Sub btnAccentedVowels(control As IRibbonControl)

    Call AccentedVowels

End Sub

Public Sub btnAddLeadingZeros(control As IRibbonControl)

    Call AddLeadingZeros

End Sub

Public Sub btnMoveVisibleToRight(control As IRibbonControl)

    Call MoveVisibleToRight

End Sub

Public Sub btnManageDuplicateRows(control As IRibbonControl)

    Call ManageDuplicateRows

End Sub

Public Sub btnManageDuplicateCells(control As IRibbonControl)
    

    Call ManageDuplicateCells

End Sub

Public Sub btnCopyPasteMultipleSelection(control As IRibbonControl)

    Call CopyPasteMultipleSelection

End Sub

Public Sub btnRandomTxtFill(control As IRibbonControl)

    Call RandomTxtFill

End Sub

Public Sub btnSelectShapes(control As IRibbonControl)

    Call SelectShapes

End Sub

Public Sub btnReplaceRemoveChars(control As IRibbonControl)

    Call ReplaceRemoveChars

End Sub

Public Sub btnRecode(control As IRibbonControl)

    Call Recode

End Sub

Public Sub btnJoinFiles(control As IRibbonControl)

    Call JoinFiles

End Sub

Public Sub btnLastRun(control As IRibbonControl)

    Call LastRun

End Sub

Public Sub btnConvertFormulaRef(control As IRibbonControl)

    Call ConvertFormulaRef

End Sub

Public Sub btnShuffleRange(control As IRibbonControl)

    Call ShuffleRange

End Sub

Public Sub btnRandomSort(control As IRibbonControl)

    Call RandomSort

End Sub

Public Sub btnRenameFiles(control As IRibbonControl)

    Call RenameFiles

End Sub

Public Sub btnMakeDir(control As IRibbonControl)
    
    Call MakeDir

End Sub

Public Sub btnExportRangeToImage(control As IRibbonControl)

    Call ExportRangeToImage

End Sub


Public Sub btnCompactRange(control As IRibbonControl)

    Call CompactRange

End Sub


Public Sub btnPivotByGroups(control As IRibbonControl)

    Call PivotByGroups

End Sub

Public Sub btnImportMultipleTXT(control As IRibbonControl)

    Call ImportMultipleTXT

End Sub

Public Sub btnExportRangeToASCII(control As IRibbonControl)

    Call ExportRangeToASCII

End Sub

Public Sub btnImportExportCode(control As IRibbonControl)

    Call ImportExportCode

End Sub

Public Sub btnCopySheets(control As IRibbonControl)

    Call CopySheets

End Sub


Public Sub btnRenameSheets(control As IRibbonControl)

    Call RenameSheets

End Sub

Public Sub btnEmptyCells(control As IRibbonControl)

    Call EmptyCells

End Sub

Public Sub btnRowsToColumns(control As IRibbonControl)

    Call RowsToColumns

End Sub

Public Sub btnHyperLinks(control As IRibbonControl)

    Call HyperLinks

End Sub

Public Sub btnPrintHyperLinksIndex(control As IRibbonControl)

    Call PrintHyperLinksIndex

End Sub

Public Sub btnMoveDataBlocks(control As IRibbonControl)

    Call MoveDataBlocks

End Sub

Public Sub btnMergeCells(control As IRibbonControl)

    Call MergeCells

End Sub

Public Sub btnCopyPasteVisibleCells(control As IRibbonControl)

    Call CopyPasteVisibleCells

End Sub

Public Sub btnReplaceFormulaResult(control As IRibbonControl)

    Call ReplaceFormulaResult

End Sub


Public Sub btnCustomViews(control As IRibbonControl)

    Call CustomViews

End Sub

Public Sub btnTableColors(control As IRibbonControl)

    Call TableColors

End Sub

Public Sub btnTrimSpaces(control As IRibbonControl)

    Call TrimSpaces

End Sub

Public Sub btnDeleteSheets(control As IRibbonControl)

    Call DeleteSheets

End Sub

Public Sub btnCombinations(control As IRibbonControl)

    Call Combinations

End Sub

Public Sub btnMoveSortColumns(control As IRibbonControl)

    Call MoveSortColumns

End Sub

Public Sub btnPrintSheetsIndex(control As IRibbonControl)

    Call PrintSheetsIndex

End Sub

Public Sub btnPrintNamesIndex(control As IRibbonControl)

    Call PrintNamesIndex

End Sub

Public Sub btnViewSettings(control As IRibbonControl)

    Call ViewSettings

End Sub

Public Sub btnUniqueList(control As IRibbonControl)

    Call UniqueList

End Sub

Public Sub btnExportToWord(control As IRibbonControl)

    Call ExportToWord

End Sub

Public Sub btnDisasterRecovery(control As IRibbonControl)

    Call DisasterRecovery

End Sub

Public Sub btnCrossTab(control As IRibbonControl)

    Call CrossTab

End Sub

Public Sub btnMultipleSort(control As IRibbonControl)

    Call MultipleSort

End Sub

Public Sub btnSelectUsedRange(control As IRibbonControl)

    Call SelectUsedRange

End Sub

Public Sub btnDeleteExtLinks(control As IRibbonControl)

    Call DeleteExtLinks

End Sub

Public Sub btnConvertFileFormat(control As IRibbonControl)

    Call ConvertFileFormat

End Sub

Public Sub btnEvaluateFormulaText(control As IRibbonControl)

    Call EvaluateFormulaText

End Sub

Public Sub btnGenerateSQL(control As IRibbonControl)

    Call GenerateSQL

End Sub

Public Sub btnPrintCommentsIndex(control As IRibbonControl)

    Call PrintCommentsIndex

End Sub

Public Sub btnPivotToRange(control As IRibbonControl)

    Call PivotToRange

End Sub

Public Sub btnSplitSheetToFiles(control As IRibbonControl)

    Call SplitSheetToFiles

End Sub

Public Sub btnTableToRange(control As IRibbonControl)

    Call TableToRange

End Sub
Attribute VB_Name = "Dialogs"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''


'In questo modulo sono contenute le routine per l'apertura di finestre di dialogo (es. scelta di file o cartelle)

Option Explicit
Option Private Module

Function FolderPicker(Optional fieldname As String, Optional dTitle As String) As String
    If dTitle = "" Then
        dTitle = IIf(lng = 0, "Selezionare una cartella:", "Please select a folder:")
    End If
    
    #If Mac Then
        Dim FolderPath As String
        Dim RootFolder As String
        Dim scriptstr As String
    
        On Error Resume Next
        RootFolder = MacScript("return (path to desktop folder) as String")
        'Or use RootFolder = "Macintosh HD:Users:YourUserName:Desktop:TestMap:"
        'Note : for a fixed path use : as seperator in 2011 and 2016
    
        If Val(Application.Version) < 15 Then
            scriptstr = "(choose folder with prompt ""Select the folder""" & _
                " default location alias """ & RootFolder & """) as string"
        Else
            scriptstr = "return posix path of (choose folder with prompt ""Select the folder""" & _
                " default location alias """ & RootFolder & """) as string"
        End If
    
        FolderPath = MacScript(scriptstr)
        On Error GoTo 0
    
        FolderPicker = FolderPath
            
    #Else
        
        Dim fd As FileDialog
        
        Set fd = Application.FileDialog(msoFileDialogFolderPicker)
        
        If fieldname <> "" Then
            fd.InitialFileName = fieldname
        ElseIf ActiveWorkbook.path = "" Then
            fd.InitialFileName = DesktopPath
        Else
            fd.InitialFileName = ActiveWorkbook.path
        End If
            
        fd.InitialView = msoFileDialogViewDetails
        fd.Title = dTitle
        
        If fd.Show = True Then
            FolderPicker = fd.SelectedItems(1)
        Else
            If fieldname <> "" Then
                FolderPicker = fieldname
            ElseIf ActiveWorkbook.path = "" Then
                FolderPicker = DesktopPath
            Else
                FolderPicker = ActiveWorkbook.path
            End If
        End If
    #End If
    
    FolderPicker = ValidateFolder(FolderPicker)
    
End Function

Function OpenDialog(Optional dPath As String, _
                    Optional dFilter As String = "Tutti i file di Excel, *.xl*;*.od*", _
                    Optional dTitle As String, _
                    Optional dMulti As Boolean = False) As Variant
                
    If dTitle = "" Then
        dTitle = IIf(lng = 0, "Selezionare uno o pi|fffd| file:", "Please select one or more files:")
    End If
    
    #If Mac Then
        Dim MyPath As String
        Dim MyScript As String
        Dim MyFiles As String
        Dim MultiFile As Boolean
        Dim FileFormat As String
    
        '#' In this example you can only select xlsx files
        '#' See my webpage how to use other and more formats.
        FileFormat = "{""xls"",""xlsx"",""xlsm"",""xlt"",""xla"",""xlam"",""xlsb"",""xml"",""xltx""," & _
                    """xltm"",""txt"",""csv"",""ods""}"
    
        '#'  Set to True if you only want to be able to select one file
        '#'  And to False to be able to select one or more files
        MultiFile = dMulti
    
        On Error Resume Next
        MyPath = MacScript("return (path to desktop folder) as String")
    
        'Building the applescript string, do not change this
        If Val(Application.Version) < 15 Then
            'This is Mac Excel 2011
            If MultiFile = False Then
                MyScript = _
                    "set theFile to (choose file of type" & _
                    " " & FileFormat & " " & _
                    "with prompt ""Please select a file"" default location alias """ & _
                    MyPath & """ without multiple selections allowed) as string" & vbNewLine & _
                    "return theFile"
            Else
                MyScript = _
                    "set applescript's text item delimiters to {ASCII character 10} " & vbNewLine & _
                    "set theFiles to (choose file of type" & _
                    " " & FileFormat & " " & _
                    "with prompt ""Please select a file or files"" default location alias """ & _
                    MyPath & """ with multiple selections allowed) as string" & vbNewLine & _
                    "set applescript's text item delimiters to """" " & vbNewLine & _
                    "return theFiles"
            End If
        Else
            'This is Mac Excel 2016
            If MultiFile = False Then
                MyScript = _
                    "set theFile to (choose file of type" & _
                    " " & FileFormat & " " & _
                    "with prompt ""Please select a file"" default location alias """ & _
                    MyPath & """ without multiple selections allowed) as string" & vbNewLine & _
                    "return posix path of theFile"
            Else
                MyScript = _
                    "set theFiles to (choose file of type" & _
                    " " & FileFormat & " " & _
                    "with prompt ""Please select a file or files"" default location alias """ & _
                    MyPath & """ with multiple selections allowed)" & vbNewLine & _
                    "set thePOSIXFiles to {}" & vbNewLine & _
                    "repeat with aFile in theFiles" & vbNewLine & _
                    "set end of thePOSIXFiles to POSIX path of aFile" & vbNewLine & _
                    "end repeat" & vbNewLine & _
                    "set {TID, text item delimiters} to {text item delimiters, ASCII character 10}" & vbNewLine & _
                    "set thePOSIXFiles to thePOSIXFiles as text" & vbNewLine & _
                    "set text item delimiters to TID" & vbNewLine & _
                    "return thePOSIXFiles"
            End If
        End If
    
        MyFiles = MacScript(MyScript)
        On Error GoTo 0
    
        '#' If you select one or more files MyFiles is not empty
        If MyFiles <> "" Then
            OpenDialog = Split(MyFiles, Chr(10))
        Else
            OpenDialog = False
        End If
    
    #Else
        On Error Resume Next
        ChDrive Left(dPath, 2)
        ChDir dPath
        On Error GoTo 0
        
        OpenDialog = Application.GetOpenFilename( _
                    FileFilter:=dFilter, _
                    Title:=dTitle, _
                    MultiSelect:=dMulti)
        
        
    #End If
    
End Function
Attribute VB_Name = "ErrorLogManager"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le istruzioni per creare, aggiornare e visualizzare il log di errori

Option Explicit

Sub UpdateErrorLog(ErrorString As String)
    Dim f As Long
    Dim dataline As String
    Dim strLog As String
    Dim RowLimit As Long
    
    RowLimit = CLng(GetSettings("ErrorLogLimit"))
    
    If FileExists(ErrorLog) = False Then Call CreateErrorLog
    
    On Error GoTo ErrorHandler
    f = FreeFile
    counter = 0
    
    Open ErrorLog For Input As #f
    Do While Not EOF(f)
        Line Input #f, dataline
        counter = counter + 1
        If InStr(1, dataline, EmptyLog) = 0 And _
            counter >= 5 Then
            
            If counter > RowLimit Then
                If InStr(1, dataline, "------------------") = 1 Then
                    Exit Do
                End If
            Else
                strLog = strLog & dataline & vbNewLine
            End If
        End If
    Loop
    Close #f
    
    Call CloseTxt(ErrorLog)
    
    strLog = ErrorLogHeader & _
                Now & ", in: " & Replace(CurrentProcedure, ProgramName, "") & vbNewLine & _
                ErrorString & vbNewLine & _
                "------------------" & vbNewLine & vbNewLine & _
                strLog
    
    Open ErrorLog For Output As #f
    Print #f, strLog
    Close #f
        
    Call CloseTxt(ErrorLog)
            
ErrorHandler:
End Sub

Sub CreateErrorLog()
    Dim f As Long
    
    On Error GoTo ErrorHandler
    
    f = FreeFile
    If Dir(ErrorLog) = "" Then 'Il file log non esiste, lo creo
        Open ErrorLog For Output As #f
        Print #f, ErrorLogHeader & EmptyLog
    End If
    
    Close f
    
    Call CloseTxt(ErrorLog)
    
ErrorHandler:
End Sub

Function ErrorLog() As String
    If IsPortable = True Then
        ErrorLog = ValidateFolder(ThisWorkbook.path) & "ESK_ErrorLog.txt"
    Else
        ErrorLog = CfgPath & "ESK_ErrorLog.txt"
    End If
End Function

Function EmptyLog() As String
    EmptyLog = IIf(lng = 0, _
                "Il registro errori di Excel Swiss Knife |fffd| al momento vuoto", _
                "Excel Swiss Knife Error Log is currently empty")

End Function

Function ErrorLogHeader() As String
    If lng = 0 Then
        ErrorLogHeader = "===============================================" & vbNewLine & _
                         "   Excel Swiss Knife - Registro degli errori   " & vbNewLine & _
                         "===============================================" & vbNewLine & vbNewLine
    Else
        ErrorLogHeader = "===============================================" & vbNewLine & _
                         "        Excel Swiss Knife - Error log          " & vbNewLine & _
                         "===============================================" & vbNewLine & vbNewLine
    End If
End Function
Attribute VB_Name = "Foglio1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio13"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "FormSize"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le funzioni per ridimensionare le UserForm

Option Explicit
Public tmpScale As Double

Sub Resizeform(frm As Object)
'Ridimensiona automaticamente i form nel caso superino la dimensione del foglio

    Dim c As control
    Dim reSize As Long
    
    If frm.Height > Application.Height Then
        reSize = Application.Height - frm.Height - 20
    Else
        reSize = (0.9 * Application.Height) - frm.Height
    End If
    
    frm.Height = frm.Height + reSize
    
    For Each c In frm.Controls
        If c.Tag = "retop" Then c.Top = c.Top + reSize
        If c.Tag = "resize" Then c.Height = Application.WorksheetFunction.Max(CDbl(c.Height + reSize), 20)
    Next c
    
End Sub

Sub ScaleForm(frm As Object, Optional dResizeFactor As Double = 1#)
    Dim ctl As control
    Dim sColWidths As String
    Dim vColWidths As Variant
    Dim iCol As Long
        
    If tmpScale = 0 Then tmpScale = 1
    If dResizeFactor = 1 Then dResizeFactor = (GetSettings("Scale") / 100) * tmpScale
    If dResizeFactor = 1 Then Exit Sub
    
    With frm
        .Height = .Height * dResizeFactor
        .Width = .Width * dResizeFactor
        
        For Each ctl In frm.Controls
            With ctl
                .Height = .Height * dResizeFactor
                .Width = .Width * dResizeFactor
                .Left = .Left * dResizeFactor
                .Top = .Top * dResizeFactor
                On Error Resume Next
                If TypeName(ctl) <> "ListBox" Then .Font.Size = .Font.Size * dResizeFactor
                On Error GoTo 0
                
                ' multi column listboxes, comboboxes
                Select Case TypeName(ctl)
                    Case "ListBox", "ComboBox"
                        If ctl.ColumnCount > 1 Then
                            sColWidths = ctl.ColumnWidths
                            vColWidths = Split(sColWidths, ";")
                            For iCol = LBound(vColWidths) To UBound(vColWidths)
                                vColWidths(iCol) = Val(vColWidths(iCol)) * dResizeFactor
                            Next
                            sColWidths = Join(vColWidths, ";")
                            ctl.ColumnWidths = sColWidths
                        End If
                End Select

            End With
        Next
    
    End With
End Sub

Sub IncreaseFormSize(frm As Object)
    If frm Is Nothing Then Exit Sub
    
    tmpScale = tmpScale * 1.05
    Call ScaleForm(frm, 1.05)
    
End Sub

Sub DecreaseFormSize(frm As Object)
    If frm Is Nothing Then Exit Sub
    
    tmpScale = tmpScale / 1.05
    Call ScaleForm(frm, 1 / 1.05)
End Sub
Attribute VB_Name = "Functions"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Option Private Module

Function IsWindows() As Boolean
    #If Mac Then
        IsWindows = False
    #Else
        IsWindows = True
    #End If
End Function

Function IsPortable() As Boolean
    If InStr(2, ThisWorkbook.Names("ESKVersionNum"), "Portable") > 0 Then IsPortable = True
End Function

Function IsInstalled() As Boolean
'Verifica se il file |fffd| installato come componente aggiuntivo oppure no
    Dim ai As AddIn
    
    For Each ai In Application.AddIns
        If ai.Name = ThisWorkbook.Name And ai.Installed = True Then
            IsInstalled = True
            Exit For
        End If
    Next ai
End Function

Function MenuSheet() As Worksheet
    Set MenuSheet = ThisWorkbook.Worksheets("menu_lng")
End Function

Function SortSheet() As Worksheet
    Set SortSheet = ThisWorkbook.Worksheets("ESK_Sort")
End Function

Public Function CommonButtons(uf As Object, Optional addnew As Boolean) As Collection
'Imposta azioni comuni per alcuni controlli presenti in molteplici form
'Crea nuovi controlli in runtime su tutti i form

    Dim Cl As New Collection
    Dim ctl As MSForms.control
    Dim cBtn As CCommonButtons
    
    'Setto le dimensioni iniziali del form
    BaseHeight = uf.Height
    TitleBarHeight = BaseHeight - uf.InsideHeight
    
    If addnew = False Then
        
        'Aggiungo i controlli per ingrandire/rimpicciolire il form
        Set ctl = uf.Controls.Add("Forms.CommandButton.1")
        With ctl
            .Name = "cmdIncSize"
            .Top = -1000
            .Height = 1
            .Width = 1
            .TabStop = False
            .TakeFocusOnClick = False
            .Accelerator = "+"
        End With
        
        Set ctl = uf.Controls.Add("Forms.CommandButton.1")
        With ctl
            .Name = "cmdDecSize"
            .Top = -1000
            .Height = 1
            .Width = 1
            .TabStop = False
            .TakeFocusOnClick = False
            .Accelerator = "-"
        End With
        
        'Aggiungo un controllo per l'apertura delle scorciatoie da tastiera
        Set ctl = uf.Controls.Add("Forms.CommandButton.1")
        With ctl
            .Name = "cmdKeys"
            .Top = -1000
            .Height = 1
            .Width = 1
            .TabStop = False
            .TakeFocusOnClick = False
            .Accelerator = "k"
        End With
        
    End If
    
    For Each ctl In uf.Controls
        
        Select Case True
            Case ctl.Name = "cmdKeys"
                Set cBtn = New CCommonButtons
                Set cBtn.cKeys = ctl
                Cl.Add cBtn
            Case ctl.Name = "cmdIncSize"
                Set cBtn = New CCommonButtons
                Set cBtn.cIncreaseSize = ctl
                Cl.Add cBtn
            Case ctl.Name = "cmdDecSize"
                Set cBtn = New CCommonButtons
                Set cBtn.cDecreaseSize = ctl
                Cl.Add cBtn
            Case ctl.Name = "cmdLatest"
                Set cBtn = New CCommonButtons
                Set cBtn.cLatest = ctl
                ctl.Accelerator = "l"
                Cl.Add cBtn
            Case ctl.Name = "cmdDefault"
                Set cBtn = New CCommonButtons
                Set cBtn.cDefault = ctl
                ctl.Accelerator = "d"
                Cl.Add cBtn
            Case ctl.Name = "cmdBatchAdd"
                Set cBtn = New CCommonButtons
                Set cBtn.cBatchAdd = ctl
                Cl.Add cBtn
            Case ctl.Name = "cmdBatchRemove"
                Set cBtn = New CCommonButtons
                Set cBtn.cBatchRemove = ctl
                Cl.Add cBtn
            Case ctl.Name = "cmdBatchEmptyList"
                Set cBtn = New CCommonButtons
                Set cBtn.cBatchEmptyList = ctl
                Cl.Add cBtn
            Case ctl.Name = "chkActiveFile"
                Set cBtn = New CCommonButtons
                Set cBtn.cBatchActiveFile = ctl
                Cl.Add cBtn
            Case ctl.Name = "chkBatchBackup"
                Set cBtn = New CCommonButtons
                Set cBtn.cBatchBackup = ctl
                Cl.Add cBtn
            Case ctl.Name = "tglBatch"
                Set cBtn = New CCommonButtons
                Set cBtn.cToggleBatch = ctl
                Cl.Add cBtn
            Case ctl.Name = "tglBackup"
                ctl.Value = Abs(CInt(GetSettings("CreateBackup")))
                Set cBtn = New CCommonButtons
                Set cBtn.cToggleBackup = ctl
                Cl.Add cBtn
            Case ctl.Name = "cmdHelp"
                Set cBtn = New CCommonButtons
                Set cBtn.cHelp = ctl
                Cl.Add cBtn
            Case ctl.Name = "tglAdvanced"
                Set cBtn = New CCommonButtons
                Set cBtn.cToggleAdvanced = ctl
                Cl.Add cBtn
            Case ctl.Name Like "cbxBaseSheetKey*"
                Set cBtn = New CCommonButtons
                Set cBtn.cColKey = ctl
                Cl.Add cBtn
            Case ctl.Name Like "cmdHelpFind_*"
                Set cBtn = New CCommonButtons
                Set cBtn.cHelpFind = ctl
                Cl.Add cBtn
            Case ctl.Name Like "cmdRunFind_*"
                Set cBtn = New CCommonButtons
                Set cBtn.cRunFind = ctl
                Cl.Add cBtn
            Case ctl.Name Like "lblBlank*"
                ctl.ControlTipText = "Svuota"
                ctl.visible = False
                Set cBtn = New CCommonButtons
                Set cBtn.cBlankTxt = ctl
                Cl.Add cBtn
            Case ctl.Name Like "txt*"
                Set cBtn = New CCommonButtons
                Set cBtn.cTextbox = ctl
                Cl.Add cBtn
            Case ctl.Name Like "SQLchkCol_*"
                Set cBtn = New CCommonButtons
                Set cBtn.cSQLCheck = ctl
                Cl.Add cBtn
            Case ctl.Name Like "SQLtxtSQLCol_*"
                Set cBtn = New CCommonButtons
                Set cBtn.cSQLText = ctl
                Cl.Add cBtn
            Case ctl.Name Like "SQLcbxSQLType_*"
                Set cBtn = New CCommonButtons
                Set cBtn.cSQLCombo = ctl
                Cl.Add cBtn
            Case ctl.Name Like "SQLtxtFLen_*"
                Set cBtn = New CCommonButtons
                Set cBtn.cSQLFLen = ctl
                Cl.Add cBtn
        End Select
            
        If addnew = False Then
            On Error Resume Next
            If lng <> 0 Or GetSettings("Scale") <> 100 Then
                If ctl.ControlTipText = "" And ctl.Name <> "lblDescription" Then
                    ctl.ControlTipText = ctl.Caption
                End If
            End If
            On Error GoTo 0
        End If
        
    Next ctl
    Set CommonButtons = Cl
    
End Function

Function CfgPath() As String
    Dim NewPath As String
    
    If IsPortable = True Then
        CfgPath = "Portable"
        Exit Function
    End If
        
    If Dir(ThisWorkbook.path & pSep & ".Portable", vbHidden) = "" And IsWindows = True Then
            On Error Resume Next
            MkDir Environ("Appdata") & pSep & "Excel Swiss Knife" & pSep
            On Error GoTo 0
            CfgPath = Environ("Appdata") & pSep & "Excel Swiss Knife" & pSep
    Else
        On Error Resume Next
        NewPath = ValidateFolder(ThisWorkbook.path & pSep & "Profile" & pSep)
        MkDir NewPath
        On Error GoTo 0
        CfgPath = NewPath
    End If
    
End Function
Function SettingsPath() As Variant
    SettingsPath = ValidateFolder(CfgPath & pSep & "Settings" & pSep)
    If SettingsPath = False Then SettingsPath = ValidateFolder(ThisWorkbook.path)
End Function

Function ConfirmExec(Optional ByVal MultiAllowed As Boolean, _
                    Optional ByVal NonDestructive As Boolean) As Long
    Dim SureCaption As String
    Dim SureTitle As String
    Dim lr As Long
    
    lr = GetSettings("LastRun")
    
    With MenuSheet
        On Error Resume Next
        SureCaption = .Cells(Application.Match(lr, .Columns(1), 0), Application.Match("desc_it", .Rows(1), 0) + lng)
        SureTitle = .Cells(Application.Match(lr, .Columns(1), 0), Application.Match("label_it", .Rows(1), 0) + lng)
        On Error GoTo 0
    End With
    
    If SureCaption = "" Then SureCaption = IIf(lng = 0, "Proseguire nell'esecuzione della macro?", "Confirm macro execution?")
    
    If SureTitle = "" Then
        SureTitle = Mid(ProgramName, 4)
    Else
        SureTitle = SureTitle & ProgramName
    End If
    
    If ActiveWindow.SelectedSheets.Count > 1 And NonDestructive = False Then
        If MultiAllowed = True Then
            If lng = 0 Then
                ConfirmExec = MsgBox("ATTENZIONE! Sono stati selezionati pi|fffd| fogli, e la macro agir|fffd| su ognuno di essi!" _
                & vbCrLf & vbCrLf & SureCaption, vbExclamation + vbYesNo, SureTitle & " (fogli multipli)")
            Else
                ConfirmExec = MsgBox("WARNING! Multiple sheets are selected, and this macro will operate on each of them!" _
                & vbCrLf & vbCrLf & SureCaption, vbExclamation + vbYesNo, SureTitle & " (multiple sheets)")
            End If
        Else    'Pi|fffd| fogli sono selezionati, ma l'esecuzione su pi|fffd| fogli non |fffd| consentita
            If lng = 0 Then
                MsgBox "L'esecuzione non |fffd| consentita su una selezione multipla di fogli", vbInformation, SureTitle
                ConfirmExec = vbNo
            Else
                MsgBox "Execution not allowed when multiple sheets are selected", vbInformation, SureTitle
                ConfirmExec = vbNo
            End If
        End If
    Else
        ConfirmExec = MsgBox(SureCaption, vbQuestion + vbYesNo, SureTitle)
    End If
    
End Function
Function MergeAreas(rng As Range) As Range
'Dato un range con selezioni multiple, cerca di unirle in un numero di aree pi|fffd| piccolo possibile
    
    Dim Subarea As Range
    
    For Each Subarea In rng.Areas
        If MergeAreas Is Nothing Then
            Set MergeAreas = Subarea
        Else
            Set MergeAreas = Union(MergeAreas, Subarea)
        End If
    Next Subarea

End Function
Function IsSelected(SheetName As String) As Boolean
'Ritorna VERO o FALSO a seconda se il foglio |fffd| selezionato oppure no
    
    Dim CurrWs As Worksheet
    
    IsSelected = False
    
    For Each CurrWs In ActiveWindow.SelectedSheets
        If UCase(CurrWs.Name) = UCase(SheetName) Then
            IsSelected = True
            Exit For
        End If
    Next CurrWs
    
End Function

Function RangeResize(rng As Range, Optional sh As Worksheet) As Variant
'Ridimensiona l'intervallo di input intersecandolo con l'intervallo utilizzato del foglio

    If sh Is Nothing Then Set sh = ActiveSheet
    
    On Error Resume Next
    Set RangeResize = Intersect(rng, sh.UsedRange)
    On Error GoTo 0
    
End Function

Function findfirstcell(Optional InRng As Range) As Range
    Dim SubFRow As Long, FRowProv As Long
    Dim SubFCol As Long, FColProv As Long
    Dim Subarea As Range
    
    If InRng Is Nothing Then Set InRng = ActiveSheet.Cells
        
    FRowProv = 10000000
    FColProv = 10000000
    
    For Each Subarea In InRng.Areas
        With Subarea
            SubFRow = Subarea.Row
            SubFCol = Subarea.Column
            If SubFRow < FRowProv Then FRowProv = SubFRow
            If SubFCol < FColProv Then FColProv = SubFCol
        End With
    Next Subarea
    
    Set findfirstcell = InRng.Parent.Cells(FRowProv, FColProv)

End Function

Function findlastcell(Optional InRng As Range) As Range
    Dim SubLRowFind As Long, LRowFind As Long
    Dim SubLColFind As Long, LColFind As Long
    Dim Subarea As Range
    
    If InRng Is Nothing Then Set InRng = ActiveSheet.Cells
    
    For Each Subarea In InRng.Areas
        With Subarea
            
            'Cerca ultima riga
            If .Application.WorksheetFunction.CountA(.Cells) <> 0 Then
                SubLRowFind = .Find(What:="*", _
                            After:=.Range("A1"), _
                            LookAt:=xlPart, _
                            LookIn:=xlFormulas, _
                            SearchOrder:=xlByRows, _
                            SearchDirection:=xlPrevious, _
                            MatchCase:=False).Row
            Else
                SubLRowFind = 1
            End If
            
            If SubLRowFind > LRowFind Then LRowFind = SubLRowFind
    
            '#' Cerca ultima colonna
            If .Application.WorksheetFunction.CountA(.Cells) <> 0 Then
                SubLColFind = .Find(What:="*", _
                            After:=.Range("A1"), _
                            LookAt:=xlPart, _
                            LookIn:=xlFormulas, _
                            SearchOrder:=xlByColumns, _
                            SearchDirection:=xlPrevious, _
                            MatchCase:=False).Column
            Else
                SubLColFind = 1
            End If
            
            If SubLColFind > LColFind Then LColFind = SubLColFind
            
        End With
    Next Subarea
    
    Set findlastcell = InRng.Parent.Cells(LRowFind, LColFind)
    
End Function

Function CleanString(str As String, Optional rep As String = "", Optional strType As String = "file")
'#' Sostituisce i caratteri non validi nelle stringhe di testo destinate a rinominare file, cartelle o fogli di lavoro
    
    Select Case strType
        Case "file"
            CleanString = Replace(Replace(Replace(Replace(Replace(Replace(Replace(Replace(str, "\", rep), "/", rep), "?", rep), "<", rep), ">", rep), "|", rep), "*", rep), ":", rep)
        Case "sheet"
            CleanString = Replace(Replace(Replace(Replace(Replace(Replace(Replace(str, "\", rep), "/", rep), "?", rep), "[", rep), "]", rep), "*", rep), ":", rep)
    End Select

End Function

Function FileExists(ByVal fPath As String) As Boolean
    If Dir(fPath) = "" Then
        FileExists = False
    Else
        FileExists = True
    End If
End Function

Function pSep() As String
    pSep = Application.PathSeparator
End Function

Function dSep() As String
    dSep = Application.DecimalSeparator
End Function

Function tSep() As String
    tSep = Application.ThousandsSeparator
End Function

Function ExtractColumnLetter(address As String) As String
'Dall'indirizzo di una cella ottiene la lettera della colonna

    Dim DeleteChars()
    Dim i As Long
    
    DeleteChars = Array(Chr(36), Chr(48), Chr(49), Chr(50), Chr(51), Chr(52), Chr(53), Chr(54), Chr(55), Chr(56), Chr(57))
    
    ExtractColumnLetter = address
    For i = 0 To UBound(DeleteChars)
        ExtractColumnLetter = Replace(ExtractColumnLetter, DeleteChars(i), "")
    Next i

End Function

Function ExtractRowNumber(address As String) As String
'Dall'indirizzo di una cella ottiene il numero di riga
    
    ExtractRowNumber = Mid(address, InStrRev(address, "$") + 1)
    
End Function

Function HasCaption(c As control) As Boolean
    Dim cap As String
    On Error Resume Next
    cap = c.Caption
    If Err.Number <> 0 Then
        Err.Clear
        HasCaption = False
    Else
        HasCaption = True
    End If
    On Error GoTo 0
End Function

Function CollKeyExists(coll As Collection, key As String) As Boolean
'Verifica l'esistenza di una chiave in una Collection

    On Error GoTo EH
    
    coll.Item key
    CollKeyExists = True
    
EH:
End Function

Function CollToArray(c As Collection) As Variant
'Converte una Collection in un Array

    Dim cArr As Variant
    Dim i As Long
    
    If c.Count > 0 Then
        ReDim cArr(1 To c.Count)
        For i = 1 To c.Count
            cArr(i) = c(i)
        Next i
        CollToArray = cArr
    Else
        CollToArray = False
    End If
        
End Function

Function ProgramName() As String
    ProgramName = " - Excel Swiss Knife"
End Function

Function CurrentProcedure() As String
    Dim lr As Long
    
    lr = GetSettings("LastRun")
    With MenuSheet
        On Error Resume Next
        CurrentProcedure = .Cells(Application.Match(lr, .Columns(1), 0), Application.Match("label_it", .Rows(1), 0) + lng) & ProgramName
        On Error GoTo 0
    End With
    If CurrentProcedure = "" Then CurrentProcedure = "Excel Swiss Knife"
    
End Function

Function lng() As Long
    lng = GetSettings("Language")
End Function

Function IsEmailValid(strEmail) As Boolean
'Verifica di validit|fffd| di un indirizzo email

    Dim strArray As Variant
    Dim strItem As Variant
    Dim i As Long
    Dim c As String
    Dim blnIsItValid As Boolean
    
    blnIsItValid = True
     
    On Error Resume Next
    i = Len(strEmail) - Len(Replace(strEmail, "@", ""))
    If Err.Number <> 0 Then i = 99
    On Error GoTo 0
    If i <> 1 Then IsEmailValid = False: Exit Function
    ReDim strArray(1 To 2)
    strArray(1) = Left(strEmail, InStr(1, strEmail, "@", 1) - 1)
    strArray(2) = Application.Substitute(Right(strEmail, Len(strEmail) - Len(strArray(1))), "@", "")
    For Each strItem In strArray
        If Len(strItem) <= 0 Then
            blnIsItValid = False
            IsEmailValid = blnIsItValid
            Exit Function
        End If
        For i = 1 To Len(strItem)
            c = LCase(Mid(strItem, i, 1))
            If InStr("abcdefghijklmnopqrstuvwxyz_-.", c) <= 0 And Not IsNumeric(c) Then
                blnIsItValid = False
                IsEmailValid = blnIsItValid
                Exit Function
            End If
        Next i
        If Left(strItem, 1) = "." Or Right(strItem, 1) = "." Then
            blnIsItValid = False
            IsEmailValid = blnIsItValid
            Exit Function
        End If
    Next strItem
    If InStr(strArray(2), ".") <= 0 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
    i = Len(strArray(2)) - InStrRev(strArray(2), ".")
    If i <> 2 And i <> 3 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
    If InStr(strEmail, "..") > 0 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
    IsEmailValid = blnIsItValid
End Function

Function FullPathToWBName(fPath As Variant, Optional ext As Boolean = True) As String
'Da un percorso completo ricava il nome del workbook, con o senza estensione

    On Error Resume Next
    If ext = True Then
        FullPathToWBName = Mid(fPath, InStrRev(fPath, pSep) + 1)
    Else
        FullPathToWBName = Mid(Split(fPath, pSep)(UBound(Split(fPath, pSep))), 1, InStrRev(Split(fPath, pSep)(UBound(Split(fPath, pSep))), ".") - 1)
    End If
    On Error GoTo 0
End Function

Function FileExt(ByVal fName As String) As String
'Da un nome file o un percorso completo, ricava l'estensione del file (senza punto)
    
    On Error Resume Next
    FileExt = Split(fName, ".")(UBound(Split(fName, ".")))
    On Error GoTo 0
End Function

Function ConvertFileLen(path As String, Optional scala As String) As Double
'Converte la dimensione di un file in KB, MB o GB

    Select Case scala
        Case "KB"
            ConvertFileLen = FileLen(path) / 1024
        Case "MB"
            ConvertFileLen = FileLen(path) / 1024 / 1024
        Case "GB"
            ConvertFileLen = FileLen(path) / 1024 / 1024 / 1024
        Case Else
            ConvertFileLen = FileLen(path)
    End Select
End Function

Function CleanSheetName(shname As String)
'Ripulisce i nomi dei fogli di lavoro dal suffisso "nascosto"
'presente nelle listbox di alcuni strumenti
    CleanSheetName = Replace(Replace(shname, " *Nascosto*", ""), " *Hidden*", "")
End Function

Function ValidateFolder(fPath As String, Optional exists As Boolean = False) As Variant
'Valida un percorso, verificandone opzionalmente l'esistenza e verificando la presenza di doppi separatori
        
    If Right(fPath, 1) <> pSep Then
        fPath = fPath & pSep
    End If
    
    Do
        fPath = Replace(fPath, pSep & pSep, pSep)
    Loop Until InStr(1, fPath, pSep & pSep) = 0
    
    If exists = True Then
        If Dir(fPath, vbDirectory) = "" Or fPath = pSep Then
            ValidateFolder = False
            Exit Function
        End If
    End If
    
    ValidateFolder = fPath
    
End Function

Function DesktopPath() As String
'Restituisce il percorso del desktop, su PC e Mac

    If IsWindows = True Then
        DesktopPath = ValidateFolder(Environ("USERPROFILE") & "\Desktop\", True)
    Else
        If Val(Application.Version) < 15 Then
            DesktopPath = MacScript("return (path to desktop folder) as String")
        Else
            DesktopPath = "/Users/" & Environ("USER") & "/Desktop"
        End If
    End If

End Function

Function StrEstrai(str As String, cBegin As String, cEnd As String, _
                    Optional Occurrence As Long = 1, _
                    Optional IncludeExtremes As Boolean = True, _
                    Optional EndReverse As Boolean = False) As String
'Estrae una sottostringa compresa tra due caratteri:
'Occurrence: trova la n-ma occorrenza del carattere iniziale
'IncludeExtremes: include i caratteri di inizio/fine nella stringa estratta
'EndReverse: estrae fino all'ultima occorrenza del carattere finale

    On Error Resume Next
    If InStr(1, str, cBegin, vbTextCompare) > 0 And InStr(1, str, cEnd, vbTextCompare) > 0 Then
        If IncludeExtremes = True Then
            If EndReverse = False Then
                StrEstrai = cBegin & Split(Split(str, cBegin)(0 + Occurrence), cEnd)(0) & cEnd
            Else
                StrEstrai = Mid(str, InStr(1, str, cBegin), InStrRev(str, cEnd) - InStr(1, str, cBegin) + Len(cEnd))
            End If
        Else
            If EndReverse = False Then
                StrEstrai = Split(Split(str, cBegin)(0 + Occurrence), cEnd)(0)
            Else
                StrEstrai = Mid(str, InStr(1, str, cBegin) + Len(cBegin), InStrRev(str, cEnd) - InStr(1, str, cBegin) - Len(cBegin))
            End If
        End If
    Else
        StrEstrai = str
    End If
    On Error GoTo 0
End Function

Function BaseColors() As Variant
'Elenco degli indici dei colori base (i pi|fffd| facilmente distinguibili)
    BaseColors = Array(3, 4, 6, 7, 8, 9, 10, 12, 13, 14, 16, 17, 23)
End Function

Function ArrayDimension(var As Variant) As Long
'Ritorna il numero di dimensioni di un array
    
    Dim i As Long
    Dim tmp As Long
    
    On Error GoTo Err
    i = 0
    Do While True
        i = i + 1
        tmp = UBound(var, i)
    Loop
Err:
    ArrayDimension = i - 1
End Function

Function DeleteBackupPrompt() As String
    DeleteBackupPrompt = IIf(lng = 0, _
                    "Vuoi cancellare il foglio di backup creato da Excel Swiss Knife ""ESK_Backup"" prima di salvare il file?" & _
                    vbNewLine & vbNewLine & _
                    "- S|fffd|: cancella il foglio di backup e salva il file" _
                    & vbNewLine & _
                    "- No: salva il file mantenendo il foglio di backup", _
                    "Would you like to delete Excel Swiss Knife backup sheet ""ESK_Backup"" before saving?" & _
                    vbNewLine & vbNewLine & _
                    "- Yes: delete backup sheet and save file" _
                    & vbNewLine & _
                    "- No: save file while keeping backup sheet")
End Function

Function SQLClean(str As String, SQLObject As String) As String
    Dim tmpstr As String
    Dim i As Long
        
    'Verifico il primo carattere della stringa (deve essere a-z A-Z, in caso contrario inserisco prefisso valido)
    If (Mid(str, 1, 1) Like "[A-Z]" Or _
        Mid(str, 1, 1) Like "[a-z]") = False Then
        
        Select Case LCase(SQLObject)
            Case "column"
                tmpstr = "c_"
            Case "table"
                tmpstr = "tbl_"
        End Select
    End If
    
    'Verifico i caratteri uno alla volta
    For i = 1 To Len(str)
        Select Case Asc(Mid(str, i, 1))
            Case 35, 36, 48 To 57, 64 To 90, 97 To 122
                tmpstr = tmpstr & Mid(str, i, 1)
            Case 192 To 198
                tmpstr = tmpstr & "A"
            Case 199
                tmpstr = tmpstr & "C"
            Case 200 To 203
                tmpstr = tmpstr & "E"
            Case 204 To 207
                tmpstr = tmpstr & "I"
            Case 209
                tmpstr = tmpstr & "N"
            Case 210 To 214, 216
                tmpstr = tmpstr & "O"
            Case 217 To 220
                tmpstr = tmpstr & "U"
            Case 224 To 230
                tmpstr = tmpstr & "a"
            Case 231
                tmpstr = tmpstr & "c"
            Case 2232 To 232
                tmpstr = tmpstr & "e"
            Case 236 To 239
                tmpstr = tmpstr & "i"
            Case 241
                tmpstr = tmpstr & "n"
            Case 242 To 246, 248
                tmpstr = tmpstr & "o"
            Case 249 To 252
                tmpstr = tmpstr & "u"
            Case Else
                tmpstr = tmpstr & "_"
        End Select
    Next i
    
    Do While CheckSQLReserved(tmpstr) = False
        tmpstr = IIf(SQLObject = "table", "tbl_", "c_") & tmpstr
    Loop
    
    SQLClean = tmpstr
End Function

Function CheckSQLReserved(str As String) As Boolean
    Dim ArrReserved() As Variant
    Dim i As Long
    
    ArrReserved = Array("A", "ABORT", "ABS", "ABSOLUTE", "ACCESS", "ACTION", "ADA", "ADD", "ADMIN", "AFTER", "AGGREGATE", "ALIAS", "ALL", "ALLOCATE", "ALSO", "ALTER", "ALWAYS", "ANALYSE", "ANALYZE", "AND", "ANY", "ARE", "ARRAY", "AS", "ASC", "ASENSITIVE", "ASSERTION", "ASSIGNMENT", "ASYMMETRIC", "AT", "ATOMIC", "ATTRIBUTE", "ATTRIBUTES", _
                    "AUDIT", "AUTHORIZATION", "AUTO_INCREMENT", "AVG", "AVG_ROW_LENGTH", "BACKUP", "BACKWARD", "BEFORE", "BEGIN", "BERNOULLI", "BETWEEN", "BIGINT", "BINARY", "BIT", "BIT_LENGTH", "BITVAR", "BLOB", "BOOL", "BOOLEAN", "BOTH", "BREADTH", "BREAK", "BROWSE", "BULK", "BY", "C", "CACHE", "CALL", "CALLED", "CARDINALITY", "CASCADE", "CASCADED", "CASE", "CAST", "CATALOG", "CATALOG_NAME", "CEIL", "CEILING", "CHAIN", "CHANGE", "CHAR", "CHAR_LENGTH", "CHARACTER", _
                    "CHARACTER_LENGTH", "CHARACTER_SET_CATALOG", "CHARACTER_SET_NAME", "CHARACTER_SET_SCHEMA", "CHARACTERISTICS", "CHARACTERS", "CHECK", "CHECKED", "CHECKPOINT", "CHECKSUM", "CLASS", "CLASS_ORIGIN", "CLOB", "CLOSE", "CLUSTER", "CLUSTERED", "COALESCE", "COBOL", _
                    "COLLATE", "COLLATION", "COLLATION_CATALOG", "COLLATION_NAME", "COLLATION_SCHEMA", "COLLECT", "COLUMN", "COLUMN_NAME", "COLUMNS", "COMMAND_FUNCTION", "COMMAND_FUNCTION_CODE", "COMMENT", "COMMIT", "COMMITTED", "COMPLETION", "COMPRESS", "COMPUTE", "CONDITION", "CONDITION_NUMBER", "CONNECT", "CONNECTION", "CONNECTION_NAME", "CONSTRAINT", "CONSTRAINT_CATALOG", "CONSTRAINT_NAME", "CONSTRAINT_SCHEMA", "CONSTRAINTS", "CONSTRUCTOR", "CONTAINS", "CONTAINSTABLE", "CONTINUE", "CONVERSION", "CONVERT", "COPY", "CORR", "CORRESPONDING", "COUNT", "COVAR_POP", "COVAR_SAMP", "CREATE", "CREATEDB", "CREATEROLE", _
                    "CREATEUSER", "CROSS", "CSV", "CUBE", "CUME_DIST", "CURRENT", "CURRENT_DATE", "CURRENT_DEFAULT_TRANSFORM_GROUP", "CURRENT_PATH", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TRANSFORM_GROUP_FOR_TYPE", "CURRENT_USER", "CURSOR", "CURSOR_NAME", "CYCLE", "DATA", "DATABASE", "DATABASES", "DATE", "DATETIME", "DATETIME_INTERVAL_CODE", "DATETIME_INTERVAL_PRECISION", "DAY", "DAY_HOUR", "DAY_MICROSECOND", _
                    "DAY_MINUTE", "DAY_SECOND", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DBCC", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFAULTS", "DEFERRABLE", "DEFERRED", "DEFINED", "DEFINER", "DEGREE", "DELAY_KEY_WRITE", "DELAYED", "DELETE", "DELIMITER", "DELIMITERS", "DENSE_RANK", "DENY", "DEPTH", "DEREF", "DERIVED", "DESC", "DESCRIBE", "DESCRIPTOR", "DESTROY", "DESTRUCTOR", "DETERMINISTIC", "DIAGNOSTICS", "DICTIONARY", "DISABLE", "DISCONNECT", "DISK", "DISPATCH", "DISTINCT", "DISTINCTROW", "DISTRIBUTED", "DIV", "DO", "DOMAIN", "DOUBLE", "DROP", "DUAL", "DUMMY", "DUMP", "DYNAMIC", "DYNAMIC_FUNCTION", _
                    "DYNAMIC_FUNCTION_CODE", "EACH", "ELEMENT", "ELSE", "ELSEIF", "ENABLE", "ENCLOSED", "ENCODING", "ENCRYPTED", "END", "END-EXEC", "ENUM", "EQUALS", "ERRLVL", "ESCAPE", "ESCAPED", "EVERY", "EXCEPT", "EXCEPTION", "EXCLUDE", "EXCLUDING", "EXCLUSIVE", "EXEC", "EXECUTE", "EXISTING", "EXISTS", "EXIT", "EXP", "EXPLAIN", "EXTERNAL", "EXTRACT", "FALSE", "FETCH", "FIELDS", "FILE", "FILLFACTOR", "FILTER", "FINAL", "FIRST", "FLOAT", _
                    "FLOAT4", "FLOAT8", "FLOOR", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FOREIGN", "FORTRAN", "FORWARD", "FOUND", "FREE", "FREETEXT", "FREETEXTTABLE", "FREEZE", "FROM", "FULL", "FULLTEXT", "FUNCTION", "FUSION", "G", "GENERAL", "GENERATED", "GET", "GLOBAL", "GO", "GOTO", "GRANT", "GRANTED", "GRANTS", "GREATEST", "GROUP", "GROUPING", "HANDLER", "HAVING", "HEADER", "HEAP", "HIERARCHY", "HIGH_PRIORITY", "HOLD", "HOLDLOCK", "HOST", "HOSTS", "HOUR", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IDENTIFIED", "IDENTITY", "IDENTITY_INSERT", "IDENTITYCOL", "IF", "IGNORE", "ILIKE", "IMMEDIATE", "IMMUTABLE", _
                    "IMPLEMENTATION", "IMPLICIT", "IN", "INCLUDE", "INCLUDING", "INCREMENT", "INDEX", "INDICATOR", "INFILE", "INFIX", "INHERIT", "INHERITS", "INITIAL", "INITIALIZE", "INITIALLY", "INNER", "INOUT", "INPUT", "INSENSITIVE", "INSERT", "INSERT_ID", "INSTANCE", "INSTANTIABLE", "INSTEAD", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "INTERSECT", "INTERSECTION", "INTERVAL", "INTO", "INVOKER", "IS", "ISAM", _
                    "ISNULL", "ISOLATION", "ITERATE", "JOIN", "K", "KEY", "KEY_MEMBER", "KEY_TYPE", "KEYS", "KILL", "LANCOMPILER", "LANGUAGE", "LARGE", "LAST", "LAST_INSERT_ID", "LATERAL", "LEADING", "LEAST", "LEAVE", "LEFT", "LENGTH", "LESS", "LEVEL", "LIKE", "LIMIT", "LINENO", "LINES", "LISTEN", "LN", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATION", "LOCATOR", "LOCK", "LOGIN", "LOGS", "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY", "LOWER", "M", "MAP", "MATCH", "MATCHED", "MAX", "MAX_ROWS", "MAXEXTENTS", "MAXVALUE", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MEMBER", "MERGE", "MESSAGE_LENGTH", _
                    "MESSAGE_OCTET_LENGTH", "MESSAGE_TEXT", "METHOD", "MIDDLEINT", "MIN", "MIN_ROWS", "MINUS", "MINUTE", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MINVALUE", "MLSLABEL", "MOD", "MODE", "MODIFIES", "MODIFY", "MODULE", "MONTH", "MONTHNAME", "MORE", "MOVE", "MULTISET", "MUMPS", "MYISAM", "NAME", "NAMES", "NATIONAL", "NATURAL", "NCHAR", "NCLOB", "NESTING", "NEW", "NEXT", "NO", "NO_WRITE_TO_BINLOG", "NOAUDIT", "NOCHECK", _
                    "NOCOMPRESS", "NOCREATEDB", "NOCREATEROLE", "NOCREATEUSER", "NOINHERIT", "NOLOGIN", "NONCLUSTERED", "NONE", "NORMALIZE", "NORMALIZED", "NOSUPERUSER", "NOT", "NOTHING", "NOTIFY", "NOTNULL", "NOWAIT", "NULL", "NULLABLE", "NULLIF", "NULLS", "NUMBER", "NUMERIC", "OBJECT", "OCTET_LENGTH", "OCTETS", "OF", "OFF", "OFFLINE", "OFFSET", "OFFSETS", "OIDS", "OLD", "ON", "ONLINE", "ONLY", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", "OPERATION", "OPERATOR", "OPTIMIZE", "OPTION", "OPTIONALLY", "OPTIONS", "OR", "ORDER", "ORDERING", "ORDINALITY", "OTHERS", "OUT", "OUTER", "OUTFILE", "OUTPUT", "OVER", _
                    "OVERLAPS", "OVERLAY", "OVERRIDING", "OWNER", "PACK_KEYS", "PAD", "PARAMETER", "PARAMETER_MODE", "PARAMETER_NAME", "PARAMETER_ORDINAL_POSITION", "PARAMETER_SPECIFIC_CATALOG", "PARAMETER_SPECIFIC_NAME", "PARAMETER_SPECIFIC_SCHEMA", "PARAMETERS", "PARTIAL", "PARTITION", "PASCAL", "PASSWORD", "PATH", "PCTFREE", "PERCENT", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "PLACING", "PLAN", "PLI", "POSITION", "POSTFIX", _
                    "POWER", "PRECEDING", "PRECISION", "PREFIX", "PREORDER", "PREPARE", "PREPARED", "PRESERVE", "PRIMARY", "PRINT", "PRIOR", "PRIVILEGES", "PROC", "PROCEDURAL", "PROCEDURE", "PROCESS", "PROCESSLIST", "PUBLIC", "PURGE", "QUOTE", "RAID0", "RAISERROR", "RANGE", "RANK", "RAW", "READ", "READS", "READTEXT", "REAL", "RECHECK", "RECONFIGURE", "RECURSIVE", "REF", "REFERENCES", "REFERENCING", "REGEXP", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "REINDEX", "RELATIVE", "RELEASE", "RELOAD", "RENAME", "REPEAT", "REPEATABLE", "REPLACE", "REPLICATION", _
                    "REQUIRE", "RESET", "RESIGNAL", "RESOURCE", "RESTART", "RESTORE", "RESTRICT", "RESULT", "RETURN", "RETURNED_CARDINALITY", "RETURNED_LENGTH", "RETURNED_OCTET_LENGTH", "RETURNED_SQLSTATE", "RETURNS", "REVOKE", "RIGHT", "RLIKE", "ROLE", "ROLLBACK", "ROLLUP", "ROUTINE", "ROUTINE_CATALOG", "ROUTINE_NAME", "ROUTINE_SCHEMA", "ROW", "ROW_COUNT", "ROW_NUMBER", "ROWCOUNT", "ROWGUIDCOL", "ROWID", "ROWNUM", "ROWS", _
                    "RULE", "SAVE", "SAVEPOINT", "SCALE", "SCHEMA", "SCHEMA_NAME", "SCHEMAS", "SCOPE", "SCOPE_CATALOG", "SCOPE_NAME", "SCOPE_SCHEMA", "SCROLL", "SEARCH", "SECOND", "SECOND_MICROSECOND", "SECTION", "SECURITY", "SELECT", "SELF", "SENSITIVE", "SEPARATOR", "SEQUENCE", "SERIALIZABLE", "SERVER_NAME", "SESSION", "SESSION_USER", "SET", "SETOF", "SETS", "SETUSER", "SHARE", "SHOW", "SHUTDOWN", "SIGNAL", "SIMILAR", "SIMPLE", "SIZE", "SMALLINT", "SOME", "SONAME", "SOURCE", "SPACE", "SPATIAL", "SPECIFIC", "SPECIFIC_NAME", "SPECIFICTYPE", "SQL", "SQL_BIG_RESULT", "SQL_BIG_SELECTS", "SQL_BIG_TABLES", _
                    "SQL_CALC_FOUND_ROWS", "SQL_LOG_OFF", "SQL_LOG_UPDATE", "SQL_LOW_PRIORITY_UPDATES", "SQL_SELECT_LIMIT", "SQL_SMALL_RESULT", "SQL_WARNINGS", "SQLCA", "SQLCODE", "SQLERROR", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQRT", "SSL", "STABLE", "START", "STARTING", "STATE", "STATEMENT", "STATIC", "STATISTICS", "STATUS", "STDDEV_POP", "STDDEV_SAMP", "STDIN", "STDOUT", "STORAGE", "STRAIGHT_JOIN", "STRICT", "STRING", "STRUCTURE", "STYLE", _
                    "SUBCLASS_ORIGIN", "SUBLIST", "SUBMULTISET", "SUBSTRING", "SUCCESSFUL", "SUM", "SUPERUSER", "SYMMETRIC", "SYNONYM", "SYSDATE", "SYSID", "SYSTEM", "SYSTEM_USER", "TABLE", "TABLE_NAME", "TABLES", "TABLESAMPLE", "TABLESPACE", "TEMP", "TEMPLATE", "TEMPORARY", "TERMINATE", "TERMINATED", "TEXT", "TEXTSIZE", "THAN", "THEN", "TIES", "TIME", "TIMESTAMP", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TINYBLOB", "TINYINT", "TINYTEXT", "TO", "TOAST", "TOP", "TOP_LEVEL_COUNT", "TRAILING", "TRAN", "TRANSACTION", "TRANSACTION_ACTIVE", "TRANSACTIONS_COMMITTED", "TRANSACTIONS_ROLLED_BACK", "TRANSFORM", _
                    "TRANSFORMS", "TRANSLATE", "TRANSLATION", "TREAT", "TRIGGER", "TRIGGER_CATALOG", "TRIGGER_NAME", "TRIGGER_SCHEMA", "TRIM", "TRUE", "TRUNCATE", "TRUSTED", "TSEQUAL", "TYPE", "UESCAPE", "UID", "UNBOUNDED", "UNCOMMITTED", "UNDER", "UNDO", "UNENCRYPTED", "UNION", "UNIQUE", "UNKNOWN", "UNLISTEN", "UNLOCK", "UNNAMED", "UNNEST", "UNSIGNED", "UNTIL", "UPDATE", "UPDATETEXT", "UPPER", "USAGE", "USE", "USER", "USER_DEFINED_TYPE_CATALOG", _
                    "USER_DEFINED_TYPE_CODE", "USER_DEFINED_TYPE_NAME", "USER_DEFINED_TYPE_SCHEMA", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "VACUUM", "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VALUES", "VAR_POP", "VAR_SAMP", "VARBINARY", "VARCHAR", "VARCHAR2", "VARCHARACTER", "VARIABLE", "VARIABLES", "VARYING", "VERBOSE", "VIEW", "VOLATILE", "WAITFOR", "WHEN", "WHENEVER", "WHERE", "WHILE", "WIDTH_BUCKET", "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRITE", "WRITETEXT", "X509", "XOR", "YEAR", "YEAR_MONTH", "ZEROFILL", "ZONE")
                    
    For i = LBound(ArrReserved) To UBound(ArrReserved)
        If UCase(str) = ArrReserved(i) Then
            Exit Function
        End If
    Next i
    
    CheckSQLReserved = True
    
End Function

Function PagesAddress(ws As Worksheet) As Variant
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim arrPages As Variant
    Dim cRow As Long
    Dim cCol As Long
    Dim precRow As Long
    Dim precCol As Long
    
    precCol = 1
    k = 1
    
    ReDim arrPages(1 To (1 + ws.HPageBreaks.Count) * (1 + ws.VPageBreaks.Count))
    
    For j = 1 To ws.VPageBreaks.Count + 1
        precRow = 1
        For i = 1 To ws.HPageBreaks.Count + 1
            If i > ws.HPageBreaks.Count Then
                cRow = ws.UsedRange.Rows.Count + ws.UsedRange.Row - 1
            Else
                cRow = ws.HPageBreaks(i).Location.Row - 1
            End If
    
            If j > ws.VPageBreaks.Count Then
                cCol = ws.UsedRange.Columns.Count + ws.UsedRange.Column - 1
            Else
                cCol = ws.VPageBreaks(j).Location.Column - 1
            End If
                
            arrPages(k) = Range(Cells(precRow, precCol), Cells(cRow, cCol)).address
            
            k = k + 1
            precRow = cRow + 1
            
        Next i
        precCol = cCol + 1
    Next j
            
    PagesAddress = arrPages

End Function

Function RngToArray(rng As Range) As Variant
'Copia le celle di un range di qualsiasi forma (anche unioni di range) in un array monodimensionale
    Dim i As Long
    Dim tmpArr As Variant
    
    ReDim tmpArr(1 To rng.Cells.Count)
    
    i = 1
    For Each cell In rng.Cells
        If IsError(cell) = False Then
            tmpArr(i) = cell.Value
            i = i + 1
        End If
    Next cell
        
    RngToArray = tmpArr
End Function
Attribute VB_Name = "General"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Public XLApp As New CExcelEvents
Public btnColl As Collection
Public bCodeSave As Boolean 'salvataggio da codice: salta il modulo di classe beforesave

Public Sub CModInitialize()
    If XLApp.App Is Nothing Then Set XLApp.App = Application
End Sub

Public Sub RestoreRibbon()
    On Error Resume Next
    If ESKRibbon Is Nothing And Val(Application.Version) >= 14 Then
        Set ESKRibbon = GetRibbon(Mid(ThisWorkbook.Names("RibbonXPointer"), 2))
    End If
    ESKRibbon.Invalidate
    On Error GoTo 0
End Sub

Sub RecordLastRun(index As Long)
    
    Call CModInitialize
    Call RestoreRibbon
    Call UpdateConfigFile("LastRun", index)

End Sub

Sub LastRun()
    Dim SubToRun As String
    Dim IdToRun As Long
    
    IdToRun = GetSettings("LastRun")
    
    With MenuSheet
        On Error Resume Next
        SubToRun = .Cells(Application.Match(IdToRun, .Columns(1), 0), Application.Match("desc_Sub", .Rows(1), 0))
        On Error GoTo 0
    End With
        
    If SubToRun = "" Then
        MsgBox IIf(lng = 0, "Ultima funzione utilizzata non disponibile", "Last used function not available"), _
        vbInformation
    Else
        Application.Run SubToRun
    End If
    
End Sub

Sub BatchBackup(ByVal FileName As String)
    'Crea una copia di backup dei file modificati in modalit|fffd| batch
    Dim BackupDir As String
    Dim PathParts
    Dim i As Long
    
    PathParts = Split(FileName, pSep)
    
    For i = 0 To UBound(PathParts) - 1
        BackupDir = BackupDir & PathParts(i) & pSep
    Next i
    BackupDir = BackupDir & "ESK_Backup_" & Replace(Date, "/", "-") & pSep
    
    On Error Resume Next
    MkDir BackupDir
    Kill BackupDir & PathParts(UBound(PathParts)) & ".bak"
    FileCopy FileName, BackupDir & PathParts(UBound(PathParts)) & ".bak"
    On Error GoTo 0
    
End Sub

Sub backup_create_new()
    Dim ErrNum As Long
    Dim SelSheets
    Dim wb As Workbook
    Dim n As Long
    Dim tmpName As String
    
    'Does nothing if main backup creation setting is false
    If GetSettings("CreateBackup") = False Then Exit Sub
    
    On Error Resume Next
    
    n = 0
    
    Set SelSheets = ActiveWindow.SelectedSheets
    Set wb = SelSheets(1).Parent
    
    'Se tra i fogli selezionati c'|fffd| il foglio di backup, annulla la procedura
    For Each ws In SelSheets
        If Left(ws.Name, 10) = "ESK_Backup" Then
            AutoCalc True
            MsgBox "Attenzione: procedura di backup annullata (il foglio di backup |fffd| tra quelli selezionati per l'elaborazione)", vbInformation, "Backup annullato"
            AutoCalc False
            Exit Sub
        End If
    Next ws
    
    'Elimino tutti i fogli di backup esistenti nella cartella attiva
    Application.DisplayAlerts = False
    For Each ws In ActiveWorkbook.Worksheets
        If Left(ws.Name, 10) = "ESK_Backup" Then ws.Delete
    Next ws
    Application.DisplayAlerts = True
    Set ws = Nothing
    Err.Clear
    
    'Attivo il workbook che contiene i fogli selezionati
    wb.Activate
    
    'Duplica tutti i fogli selezionati
    For Each ws In SelSheets
        
        ws.Select
        
        tmpName = ws.Name
        
        'Gestione caso particolare (bug Excel): nome di 30 caratteri i cui ultimi 3 sono " (2"
        If Len(ws.Name) = 30 And Right(ws.Name, 3) = " (2" Then
            ws.Name = ws.Name & "|fffd|"
        End If
        
        ws.Copy After:=wb.Worksheets(wb.Worksheets.Count)
        
        Set wsBACKUP = ActiveSheet
        
        With wsBACKUP
            .Name = "ESK_Backup"
            .Tab.ColorIndex = 6
            If Err.Number > 0 Then
                ErrNum = 1
                Do While Err.Number > 0
                    Err.Clear
                    .Name = "ESK_Backup_#" & Format(ErrNum, "000")
                    ErrNum = ErrNum + 1
                Loop
            End If
        End With
        n = n + 1
        
        'Ripristino il nome originale del foglio (gestione bug Excel)
        If tmpName <> ws.Name Then ws.Name = tmpName
        
    Next ws
    SelSheets.Select
    
    Set ws = Nothing
    
End Sub

Sub AutoCalc(onoff As Boolean)
    On Error Resume Next
    
    With Application
        If onoff = True Then
            .ScreenUpdating = True
            .Calculation = xlCalculationAutomatic
        Else
            .ScreenUpdating = False
            .Calculation = xlCalculationManual
        End If
    End With
End Sub

Sub AutoFilterOFF(Optional ws As Worksheet, Optional offmode As Long = 0)
    
    If ws Is Nothing Then Set ws = ActiveSheet
    
    Select Case offmode
        Case 0
            If ws.AutoFilterMode Then
                If ws.FilterMode Then
                    ws.ShowAllData
                End If
            ElseIf ws.FilterMode Then
                ws.ShowAllData
            End If
        Case 1
            ws.AutoFilterMode = False
    End Select
    
End Sub


Sub Cvalues(Optional ws As Worksheet, Optional Auto As Boolean)
    Dim Confirm As Long
    
    If ws Is Nothing Then
        Set ws = ActiveSheet
    End If
    
    If Auto Then
        Confirm = vbYes
    Else
        Confirm = MsgBox("Vuoi convertire l'intero foglio in valori (eliminando le formule)?", _
        vbYesNo + vbQuestion, "Incolla valori")
    End If
    
    If Confirm = vbYes Then
        Application.DisplayAlerts = False
        With ws
            If .AutoFilterMode Then
                Call AutoFilterOFF
            Else
                .Cells.Copy
                .Range("A1").PasteSpecial Paste:=xlValues
            End If
        End With
        Application.DisplayAlerts = True
    End If
    Application.CutCopyMode = False
    
End Sub

Sub CanceledProcedure(Optional CancelType As String)
    Dim ErrNum As Long
    Dim ErrDesc As String
    
    ErrNum = Err.Number
    ErrDesc = Err.Description
    Err.Clear
    
    Call AutoCalc(True)
    
    If lng = 0 Then
        If CancelType = "User" Or ProgressAborted = 1 Or ErrNum = 18 Then
            MsgBox "L'esecuzione di " & Replace(CurrentProcedure, ProgramName, "") & _
                    " |fffd| stata annullata dall'utente.", vbInformation, "Elaborazione annullata"
        ElseIf ErrDesc <> "" Then
            MsgBox "L'esecuzione di " & Replace(CurrentProcedure, ProgramName, "") & _
                    " |fffd| stata interrotta a causa di un errore." & vbNewLine & vbNewLine & _
                    "Consultare il registro errori dal menu Impostazioni.", _
                    vbExclamation, "Errore durante l'elaborazione"
        Else
            MsgBox "L'esecuzione di " & Replace(CurrentProcedure, ProgramName, "") & _
                    " |fffd| stata annullata dall'utente o interrotta a causa di un errore. Si prega di riprovare.", _
                    vbInformation, "Elaborazione interrotta"
        End If
    Else
        If CancelType = "User" Or ProgressAborted = 1 Or ErrNum = 18 Then
            MsgBox "The execution of " & Replace(CurrentProcedure, ProgramName, "") & " was aborted by the user.", _
            vbInformation, "Execution aborted"
        Else
            MsgBox "The execution of " & Replace(CurrentProcedure, ProgramName, "") & _
            " was aborted by the user or due to an error. Please try again.", _
            vbInformation, "Execution aborted"
        End If
    End If
    
    If ErrDesc <> "" And ErrNum <> 18 Then Call UpdateErrorLog(ErrDesc)
    
    '#' Pulizia finale
    Call Cleanup
    
    Unload UProgress
    Application.EnableCancelKey = xlInterrupt
    Application.DisplayAlerts = True
    Application.EnableEvents = True
End Sub

Sub ClearCollection(ByRef col As Collection)
    
    Do Until col.Count = 0
        col.Remove 1
    Loop
End Sub

Sub GoodToGo(frm As Object)
    Dim ctl As control
    
    Select Case frm.Name
    
        Case "frmAppendSheets", "frmCopySheets", "frmExportToWord", "frmSaveToSeparateFiles", "frmViewSettings"
            frm.cmdOK.Enabled = CountListBox(frm.lbxSheets) > 0
        
        Case "frmCompareRanges"
            frm.cmdOK.Enabled = CountListBox(frm.lbxCompareSheets) > 0
            
        Case "frmCompute"
            frm.cmdOK.Enabled = (Len(frm.txtfactor) > 0 And Trim(frm.txtfactor) <> "")

        Case "frmCrossTab"
            frm.cmdOK.Enabled = frm.lbxRowVars.ListCount * frm.lbxColVar.ListCount * frm.lbxCrossVars.ListCount

        Case "frmCustomViews"
            frm.cmdOK.Enabled = CountListBox(frm.lbxViews) > 0
            frm.chkAllNone.Enabled = CountListBox(frm.lbxViews) > 0
            For Each ctl In frm.fraOptions.Controls
                ctl.Enabled = CountListBox(frm.lbxViews) > 0
            Next ctl
        
        Case "frmDeleteSheets"
            frm.cmdOK.Enabled = (Abs(CInt(frm.tglBatch * (frm.lbxBatchFiles.ListCount + Abs(frm.chkActiveFile)))) + Abs(CInt((Not frm.tglBatch)))) * _
                       (Abs(CInt(frm.chkEmpty + frm.chkHidden + frm.chkGfx + frm.chkMacro + frm.chkDialog)))
        
        Case "frmDeleteEmtyHiddenRC"
            frm.cmdOK.Enabled = (Abs(CInt(frm.tglBatch * (frm.lbxBatchFiles.ListCount + Abs(frm.chkActiveFile)))) + Abs(CInt((Not frm.tglBatch)))) * _
                       (Abs(CInt(frm.chkEmptyC + frm.chkEmptyR + frm.chkHiddenC + frm.chkHiddenR + frm.chkFirstRows + frm.chkFirstCols)))
        
        Case "frmDisasterRecovery"
            frm.cmdOK.Enabled = (frm.chkData + frm.chkFormulas + frm.chkFormats) * (frm.txtDamagedFile <> "")
        
        Case "frmEmptyCells"
            frm.cmdOK.Enabled = Abs(CInt(((frm.chkGhost + frm.chkNonPrint + frm.chkNullFormulas + frm.chkTrim) <> 0))) * _
                (Abs(CInt(frm.tglBatch * (frm.lbxBatchFiles.ListCount + Abs(frm.chkActiveFile)))) + Abs(CInt((Not frm.tglBatch))))

        Case "frmImportMultipleTXT"
            frm.cmdCSV_OK.Enabled = (frm.lbxCSV_ImportFiles.ListCount > 0)
            frm.cmdXML_OK.Enabled = (frm.lbxXML_ImportFiles.ListCount > 0)
        
        Case "frmImportMultipleFiles"
            frm.cmdOK.Enabled = (frm.lbxImportFiles.ListCount > 0)
        
        Case "frmConvertFileFormat"
            frm.cmdOK.Enabled = (frm.lbxOriginalFiles.ListCount > 0)
        
        Case "frmImportPageSetup"
            frm.cmdOK.Enabled = CountListBox(frm.lbxDestSheet) > 0
            
        Case "frmJoinFiles"
            frm.cmdOK.Enabled = CountListBox(frm.lbxNewFileCols) > 0
            
        Case "frmMoveSortColumns"
            frm.cmdOK.Enabled = (frm.lbxNewColumns.ListCount > 0)
            
        Case "frmRecode"
            frm.cmdOK.Enabled = (frm.lbxSubList.ListCount > 0) * (Abs(CInt(frm.tglBatch * (frm.lbxBatchFiles.ListCount + Abs(frm.chkActiveFile)))) + _
                        Abs(CInt((Not frm.tglBatch))))
        
        Case "frmRenameFiles", "frmRenameSheets"
            frm.cmdOK.Enabled = (Abs(frm.chkAfter + frm.chkBefore + frm.chkCounter + frm.chkLeft + frm.chkPos + frm.chkReplace + frm.chkReplaceName + frm.chkRight + frm.chkTruncate) + frm.cbxCase.ListIndex) <> 0

        Case "frmSplitCol"
            frm.cmdOK.Enabled = (frm.lbxDelimList.ListCount > 0)
        
        Case "frmTrimSpaces"
            frm.cmdOK.Enabled = (Abs(CInt(frm.chkAll)) + Abs(CInt((frm.chkLTrim.Enabled * frm.chkLTrim.Value) + (frm.chkRTrim.Enabled * frm.chkRTrim.Value) + (frm.chkInsideTrim.Enabled * frm.chkInsideTrim.Value)))) * _
                                (Abs(CInt(frm.tglBatch * (frm.lbxBatchFiles.ListCount + Abs(frm.chkActiveFile)))) + Abs(CInt((Not frm.tglBatch))))
        
        Case Else 'Strumenti con batch e senza altri controlli "bloccanti"
            On Error Resume Next
            frm.cmdOK.Enabled = (Abs(CInt(frm.tglBatch * (frm.lbxBatchFiles.ListCount + Abs(frm.chkActiveFile)))) + _
                                    Abs(CInt((Not frm.tglBatch))))
            On Error GoTo 0
    End Select

End Sub

Sub Excel2007PDF()
    Dim ans As Long
    
    If Val(Application.Version) = 12 Then
        ans = MsgBox(IIf(lng = 0, _
                    "Attenzione: per salvare in PDF con Office 2007, |fffd| necessario installare un componente aggiuntivo. Vuoi aprire la pagina di download?" & _
                    vbNewLine & vbNewLine & _
                    "Clicca S|fffd| per aprire la pagina di download" & vbNewLine & _
                    "Clicca No per uscire", _
                    "Warning: in order to export to PDF in Office 2007, you need to install an add-in. Would you like to open the download page in your browser?" & _
                    vbNewLine & vbNewLine & _
                    "Click Yes to open download page" & vbNewLine & _
                    "Click no to exit"), _
                    vbInformation + vbYesNo)
        
        If ans = vbYes Then
            If lng = 0 Then
                Call OpenUrl("https://www.microsoft.com/it-it/download/details.aspx?id=7")
            Else
                Call OpenUrl("https://www.microsoft.com/en-US/download/details.aspx?id=7")
            End If
        End If
    End If
End Sub

Sub FixArrayStrings(ByRef var As Variant)
'Mette l'apostrofo davanti alle stringhe contenute in un array
'Evita che, trasferendo l'array sul foglio di lavoro, i numeri testuali vengano convertiti in numero
    
    Dim i As Long
    
    Select Case ArrayDimension(var) 'verifico il numero di dimensioni dell'array
        Case 1
            For i = LBound(var) To UBound(var)
                If VarType(var(i)) = 8 Then var(i) = "'" & var(i)
            Next i
        Case 2
            Dim j As Long
            For i = LBound(var, 1) To UBound(var, 1)
                For j = LBound(var, 2) To UBound(var, 2)
                    If VarType(var(i, j)) = 8 Then var(i, j) = "'" & var(i, j)
                Next j
            Next i
    End Select
End Sub

Sub SaveFile(ByVal wb As Workbook, Optional NewFileName As Variant, _
            Optional NewFileFormat As Long = 0, Optional NewFileLocal As Boolean, _
            Optional Silent As Boolean, Optional SaveCopy As Boolean)
    
    Dim sh As Worksheet
    Dim ConfirmDelete As VbMsgBoxResult
    
    'Imposto a True le variabili per evitare l'esecuzione delle routine nel modulo di classe CExcelEvents
    bCodeSave = True
    'Imposto il formato file in caso di SaveAs
    If NewFileFormat = 0 Then NewFileFormat = wb.FileFormat
    
    'Routine per la cancellazione del foglio di backup
    If GetSettings("DeleteBackup") = 1 Then
        For Each sh In wb.Worksheets
            If UCase(sh.Name) = "ESK_BACKUP" Then
                If Silent = False Then
                    ConfirmDelete = MsgBox(DeleteBackupPrompt, _
                        vbQuestion + vbYesNo, _
                        IIf(lng = 0, "Rilevato foglio di backup", "Backup sheet detected"))
                Else
                    ConfirmDelete = vbNo
                End If
                
                If ConfirmDelete = vbYes Then
                    Application.DisplayAlerts = False
                    sh.Delete
                    Application.DisplayAlerts = True
                End If
                
                Exit For
                
            End If
        Next sh
    End If
    
    'Comandi di salvataggio
    If IsMissing(NewFileName) = True Then      'Save
        wb.Save
    ElseIf SaveCopy = False Then               'SaveAs
        wb.SaveAs NewFileName, NewFileFormat, Local:=NewFileLocal
    Else                                       'SaveCopyAs
        wb.SaveCopyAs NewFileName
    End If
    
End Sub

Sub CloseTxt(ByVal fName As String)
'Accerta che un file di testo sia salvato e chiuso
    
    On Error Resume Next
    Do
        Err.Clear
        Name fName As fName
    '53 = file non esiste (|fffd| la prima creazione). 58 = Il file esiste gi|fffd| (lo sappiamo)
    Loop Until Err.Number = 0 Or Err.Number = 53 Or Err.Number = 58
    On Error GoTo 0

End Sub

Sub UpdateComments(wbname As String, wsName As String, lstObjname As String)
'Funzione di servizio per l'aggiornamento dei commenti delle celle
    Dim wb As Workbook
    Dim ws2 As Worksheet
    Dim lstObj As ListObject
    Dim arrBold As Variant
    Dim arrItalic As Variant
    Dim arrUnderline As Variant
    Dim arrStrikethrough As Variant
    Dim arrSuperscript As Variant
    Dim arrSubscript As Variant
    Dim i As Long
    Dim s As Long
    Dim cStart As Long
    Dim cEnd As Long
    
    Set wb = Workbooks(wbname)
    Set ws = wb.Worksheets(wsName)
    Set lstObj = ws.ListObjects(lstObjname)
    
    Call AutoCalc(False)
    
    On Error Resume Next
    For Each cell In lstObj.DataBodyRange.Columns(2).Cells
        
        Set ws2 = wb.Worksheets(cell.Offset(0, -1).Value)
        
        If cell.Offset(0, 3) = "" Then
            ws2.Range(cell.Value).Comment.Delete
        Else
        
            With ws2.Range(cell.Value).Comment.Shape.TextFrame
                .Characters.Text = cell.Offset(0, 3).Value
                .Characters.Font.Bold = False
                .Characters.Font.Italic = False
                .Characters.Font.Underline = False
                .Characters.Font.Strikethrough = False
                .Characters.Font.Superscript = False
                .Characters.Font.Subscript = False
                
                '#' Valuto il testo in grassetto
                    ReDim arrBold(1 To Len(cell), 1 To 2)
                    cStart = 0
                    cEnd = 0
                    i = 1
                    For s = 1 To Len(cell.Offset(0, 3))
                        If cell.Offset(0, 3).Characters(s, 1).Font.Bold = True Then
                            If cStart <= cEnd Then
                                cStart = s
                                arrBold(i, 1) = cStart
                            ElseIf s = Len(cell.Offset(0, 3)) Then
                                cEnd = s
                                arrBold(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        Else
                            If cStart > cEnd Then
                                cEnd = s - 1
                                arrBold(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        End If
                    Next s
                    
                    For i = 1 To UBound(arrBold, 1)
                        If Not IsEmpty(arrBold(i, 1)) Then
                            .Characters(arrBold(i, 1), arrBold(i, 2)).Font.Bold = True
                        End If
                    Next i
                
                '#' Valuto il testo in corsivo
                    ReDim arrItalic(1 To Len(cell), 1 To 2)
                    cStart = 0
                    cEnd = 0
                    i = 1
                    For s = 1 To Len(cell.Offset(0, 3))
                        If cell.Offset(0, 3).Characters(s, 1).Font.Italic = True Then
                            If cStart <= cEnd Then
                                cStart = s
                                arrItalic(i, 1) = cStart
                            ElseIf s = Len(cell.Offset(0, 3)) Then
                                cEnd = s
                                arrItalic(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        Else
                            If cStart > cEnd Then
                                cEnd = s - 1
                                arrItalic(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        End If
                    Next s
                    
                    For i = 1 To UBound(arrItalic, 1)
                        If Not IsEmpty(arrItalic(i, 1)) Then
                            .Characters(arrItalic(i, 1), arrItalic(i, 2)).Font.Italic = True
                        End If
                    Next i
                
                '#' Valuto il testo sottolineato
                    ReDim arrUnderline(1 To Len(cell), 1 To 2)
                    cStart = 0
                    cEnd = 0
                    i = 1
                    For s = 1 To Len(cell.Offset(0, 3))
                        If cell.Offset(0, 3).Characters(s, 1).Font.Underline = 2 Then
                            If cStart <= cEnd Then
                                cStart = s
                                arrUnderline(i, 1) = cStart
                            ElseIf s = Len(cell.Offset(0, 3)) Then
                                cEnd = s
                                arrUnderline(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        ElseIf cell.Offset(0, 3).Characters(s, 1).Font.Underline = -4142 Then
                            If cStart > cEnd Then
                                cEnd = s - 1
                                arrUnderline(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        End If
                    Next s
                    
                    For i = 1 To UBound(arrUnderline, 1)
                        If Not IsEmpty(arrUnderline(i, 1)) Then
                            .Characters(arrUnderline(i, 1), arrUnderline(i, 2)).Font.Underline = True
                        End If
                    Next i
                
                '#' Valuto il testo barrato
                    ReDim arrStrikethrough(1 To Len(cell), 1 To 2)
                    cStart = 0
                    cEnd = 0
                    i = 1
                    For s = 1 To Len(cell.Offset(0, 3))
                        If cell.Offset(0, 3).Characters(s, 1).Font.Strikethrough = True Then
                            If cStart <= cEnd Then
                                cStart = s
                                arrStrikethrough(i, 1) = cStart
                            ElseIf s = Len(cell.Offset(0, 3)) Then
                                cEnd = s
                                arrStrikethrough(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        Else
                            If cStart > cEnd Then
                                cEnd = s - 1
                                arrStrikethrough(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        End If
                    Next s
                    
                    For i = 1 To UBound(arrStrikethrough, 1)
                        If Not IsEmpty(arrStrikethrough(i, 1)) Then
                            .Characters(arrStrikethrough(i, 1), arrStrikethrough(i, 2)).Font.Strikethrough = True
                        End If
                    Next i
                
                '#' Valuto il testo apice
                    ReDim arrSuperscript(1 To Len(cell), 1 To 2)
                    cStart = 0
                    cEnd = 0
                    i = 1
                    For s = 1 To Len(cell.Offset(0, 3))
                        If cell.Offset(0, 3).Characters(s, 1).Font.Superscript = True Then
                            If cStart <= cEnd Then
                                cStart = s
                                arrSuperscript(i, 1) = cStart
                            ElseIf s = Len(cell.Offset(0, 3)) Then
                                cEnd = s
                                arrSuperscript(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        Else
                            If cStart > cEnd Then
                                cEnd = s - 1
                                arrSuperscript(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        End If
                    Next s
                    
                    For i = 1 To UBound(arrSuperscript, 1)
                        If Not IsEmpty(arrSuperscript(i, 1)) Then
                            .Characters(arrSuperscript(i, 1), arrSuperscript(i, 2)).Font.Superscript = True
                        End If
                    Next i
                
                 '#' Valuto il testo pedice
                    ReDim arrSubscript(1 To Len(cell), 1 To 2)
                    cStart = 0
                    cEnd = 0
                    i = 1
                    For s = 1 To Len(cell.Offset(0, 3))
                        If cell.Offset(0, 3).Characters(s, 1).Font.Subscript = True Then
                            If cStart <= cEnd Then
                                cStart = s
                                arrSubscript(i, 1) = cStart
                            ElseIf s = Len(cell.Offset(0, 3)) Then
                                cEnd = s
                                arrSubscript(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        Else
                            If cStart > cEnd Then
                                cEnd = s - 1
                                arrSubscript(i, 2) = cEnd - cStart + 1
                                i = i + 1
                            End If
                        End If
                    Next s
                    
                    For i = 1 To UBound(arrSubscript, 1)
                        If Not IsEmpty(arrSubscript(i, 1)) Then
                            .Characters(arrSubscript(i, 1), arrSubscript(i, 2)).Font.Subscript = True
                        End If
                    Next i
                
                .AutoSize = True
                   
            End With
            
            'Setto la visibilit|fffd|
            Select Case LCase(cell.Offset(0, 4))
                Case 1, "s|fffd|", "yes", True
                    ws2.Range(cell.Value).Comment.visible = True
                Case Else
                    ws2.Range(cell.Value).Comment.visible = False
            End Select
       
        End If
        
    Next cell
    On Error GoTo 0
    
    Call PrintCommentsIndex(True)

    Call AutoCalc(True)
End Sub

Sub Cleanup()
    Set ws = Nothing
    Set wsBACKUP = Nothing
    Set cell = Nothing
    Set InRng = Nothing
    Set btnColl = Nothing
    tmpScale = 1
    Call RestoreRibbon
    Close 'Chiude tutti i file di testo eventualmente aperti
End Sub

Attribute VB_Name = "ListComboBoxes"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le funzioni per popolare e modificare le list(combo)box

Option Explicit


Sub SetListBoxWidth(frm As Object, ctl As control)
'Forzatura per impostare la larghezza delle scrollbar a quella del contenuto delle Listbox

    Dim i As Long
    Dim scrollBarWidth As Double

    For i = 0 To ctl.ListCount - 1
        frm.txtScrollWidth.Value = ctl.List(i)
        If frm.txtScrollWidth.Width > scrollBarWidth Then scrollBarWidth = frm.txtScrollWidth.Width
    Next i
    
    ctl.ColumnWidths = scrollBarWidth

End Sub

Sub SortListCombobox(ctl As control, Optional SortType As Long = 0, Optional SortOrder As Long = 0, Optional col_ord As Long = 1)
'Ordinamento delle List(Combo)box
' SortType - 0: ordinamento alfabetico;
'            1: ordinamento lunghezza stringa;
'            2: ordinamento per lettera di colonna (AA > Z);
'            3: ordinamento per data
' SortOrder - 0: crescente; 1: decrescente
' col_ord: l'indice di colonna secondo cui effettuare l'ordinamento (da 1 a n)

    Dim ListArray As Variant
    Dim i As Long, j As Long, c As Long
    Dim vTemp As Variant
    
    ListArray = ctl.List
    ReDim Preserve ListArray(0 To ctl.ListCount - 1, 0 To ctl.ColumnCount - 1)
    ReDim vTemp(0 To ctl.ColumnCount - 1)
    
    'Riduco di 1 l'indice della colonna di ordinamento (che in questa routine |fffd| a base 0)
    col_ord = col_ord - 1
    
    
    Select Case SortType
        Case 0, 3 '#' Ordinamento alfabetico o per data
            
            If UBound(ListArray, 1) < 100 And SortType = 0 Then
                'Bubble sort
                If SortOrder = 0 Then
                    For i = LBound(ListArray, 1) To UBound(ListArray, 1) - 1
                        For j = i + 1 To UBound(ListArray, 1)
                            If StrComp(ListArray(i, col_ord), ListArray(j, col_ord), vbTextCompare) = 1 Then
                                For c = 0 To UBound(ListArray, 2)
                                    vTemp(c) = ListArray(i, c)
                                    ListArray(i, c) = ListArray(j, c)
                                    ListArray(j, c) = vTemp(c)
                                Next c
                            End If
                        Next j
                    Next i
                Else
                    For i = LBound(ListArray, 1) To UBound(ListArray, 1) - 1
                        For j = i + 1 To UBound(ListArray, 1)
                            If StrComp(ListArray(j, col_ord), ListArray(i, col_ord), vbTextCompare) = 1 Then
                                For c = 0 To UBound(ListArray, 2)
                                    vTemp(c) = ListArray(j, c)
                                    ListArray(j, c) = ListArray(i, c)
                                    ListArray(i, c) = vTemp(c)
                                Next c
                            End If
                        Next j
                    Next i
                End If
            Else
                'Ordinamento foglio excel
                With SortSheet
                    .Cells.Clear
                    .Cells(1, 1).reSize(UBound(ListArray, 1) + 1, UBound(ListArray, 2) + 1).NumberFormat = "@"
                    .Cells(1, 1).reSize(UBound(ListArray, 1) + 1, UBound(ListArray, 2) + 1) = ListArray
                    .Cells(1, 1).reSize(UBound(ListArray, 1) + 1, UBound(ListArray, 2) + 1).NumberFormat = "General"
                    With .Sort
                        .SortFields.Clear
                        .SortFields.Add key:=SortSheet.Cells(1, col_ord + 1), SortOn:=xlSortOnValues, Order:=IIf(SortOrder = 0, xlAscending, xlDescending), DataOption:=xlSortTextAsNumbers
                        .SetRange SortSheet.UsedRange
                        .header = xlNo
                        .MatchCase = False
                        .Orientation = xlTopToBottom
                        .SortMethod = xlPinYin
                        .Apply
                    End With
                    If .UsedRange.Cells.Count = 1 Then
                        ListArray = SortSheet.UsedRange.reSize(1, 2)
                        ReDim Preserve ListArray(1 To 1, 1 To 1)
                    Else
                        ListArray = .UsedRange
                    End If
                    
                    'Svuoto il foglio ordinamento
                    SortSheet.Cells.Clear
                End With
            End If
            
        Case 1 '#' Ordinamento lunghezza stringa
            
            If SortOrder = 0 Then
                For i = LBound(ListArray, 1) To UBound(ListArray, 1) - 1
                    For j = i + 1 To UBound(ListArray, 1)
                        If Len(ListArray(j, col_ord)) < Len(ListArray(i, col_ord)) Then
                            For c = 0 To UBound(ListArray, 2)
                                vTemp(c) = ListArray(i, c)
                                ListArray(i, c) = ListArray(j, c)
                                ListArray(j, c) = vTemp(c)
                            Next c
                        End If
                    Next j
                Next i
            Else
                For i = LBound(ListArray) To UBound(ListArray) - 1
                    For j = i + 1 To UBound(ListArray)
                        If Len(ListArray(i, 0)) < Len(ListArray(j, 0)) Then
                            For c = 0 To UBound(ListArray, 2)
                                vTemp(c) = ListArray(j, c)
                                ListArray(j, c) = ListArray(i, c)
                                ListArray(i, c) = vTemp(c)
                            Next c
                        End If
                    Next j
                Next i
            End If
            
        Case 2 '#' Ordinamento colonne
            
            If SortOrder = 0 Then
                For i = LBound(ListArray, 1) To UBound(ListArray, 1) - 1
                    For j = i + 1 To UBound(ListArray, 1)
                        If Cells(1, Split(ListArray(i, 0), " ")(0)).Column > Cells(1, Split(ListArray(j, 0), " ")(0)).Column Then
                            vTemp = ListArray(i, 0)
                            ListArray(i, 0) = ListArray(j, 0)
                            ListArray(j, 0) = vTemp
                        End If
                    Next j
                Next i
            Else
                For i = LBound(ListArray, 1) To UBound(ListArray, 1) - 1
                    For j = i + 1 To UBound(ListArray, 1)
                        If Cells(1, Split(ListArray(j, 0), " ")(0)).Column > Cells(1, Split(ListArray(i, 0), " ")(0)).Column Then
                            vTemp = ListArray(j, 0)
                            ListArray(j, 0) = ListArray(i, 0)
                            ListArray(i, 0) = vTemp
                        End If
                    Next j
                Next i
            End If
            
    End Select
    
    ctl.List = ListArray
    
End Sub

Sub ListRows(rng As Range, ctl As control, Optional header As Boolean = True)
'Elenca le righe del range "rng" nella list(combo)box "ctl"

    Dim i As Long
    
    On Error Resume Next
    
    ctl.Clear
    
    With rng
        For i = 1 To .Rows.Count
            ctl.AddItem ExtractRowNumber(.Cells(i, 1).address) & _
            IIf(.Cells(i, 1) <> "", " (" & .Cells(i, 1) & ")", " (" & .Cells(i, 1).End(xlToRight) & ")")
        Next i
    End With
    
    Call SwitchRowHeaders(rng, ctl, header)
    
    On Error GoTo 0
    
End Sub

Sub ListColumns(rng As Range, ctl As control, Optional header As Boolean = True, Optional nFilter As String = "")
'Elenca le colonne del range "rng" nella list/combobox "ctl"

    Dim i As Long
    
    On Error Resume Next
    
    ctl.Clear
    
    With rng
        For i = 1 To .Columns.Count
            If .Cells(1, i) <> "" Then
                If UCase(.Cells(1, i)) Like "*" & UCase(nFilter) & "*" Then
                    ctl.AddItem ExtractColumnLetter(.Cells(1, i).address) & " (" & .Cells(1, i) & ")"
                End If
            Else
                If UCase(.Cells(1, i).End(xlDown)) Like "*" & UCase(nFilter) & "*" Then
                    ctl.AddItem ExtractColumnLetter(.Cells(1, i).address) & " (" & .Cells(1, i).End(xlDown) & ")"
                End If
            End If
        Next i
    End With
    
    Call SwitchHeaders(rng, ctl, header)
    
    On Error GoTo 0
    
End Sub

Sub SwitchRowHeaders(rng As Range, ctl As control, header As Boolean)
'Cambia dati con/senza intestazioni (righe) in list/combobox
    
    Dim a As Long
    Dim RowIndex As Long
    Dim frstCell As Range
    
    With rng
        For a = 0 To ctl.ListCount - 1
            RowIndex = .Parent.Cells(Split(ctl.List(a), " ")(0), 1).Row
            Set frstCell = Intersect(rng, rng.Parent.Rows(RowIndex)).Cells(1, 1)
            ctl.RemoveItem (a)
            If header = True Then
                ctl.AddItem ExtractRowNumber(Cells(RowIndex, 1).address) & _
                IIf(frstCell <> "", " (" & frstCell.Value & ")", _
                " (" & frstCell.End(xlToRight).Value & ")"), a
            Else
                ctl.AddItem ExtractColumnLetter(Cells(RowIndex, 1).address) & _
                " (Riga " & ExtractRowNumber(Cells(RowIndex, 1).address) & ")", a
            End If
            If Left(ctl.Name, 3) = "lbx" Then ctl.Selected(a) = True
        Next a
    End With
    
    'Scroll to top of listbox/combobox
    If Left(ctl.Name, 3) = "lbx" Then ctl.TopIndex = 0
    If Left(ctl.Name, 3) = "cbx" Then ctl.ListIndex = 0
    
End Sub

Sub SwitchHeaders(rng As Range, ctl As control, header As Boolean)
'Cambia dati con/senza intestazioni (colonne) in list/combobox

    Dim a As Long
    Dim ColIndex As Long
    Dim frstCell As Range
    
    With rng
        For a = 0 To ctl.ListCount - 1
            ColIndex = .Parent.Cells(1, Split(ctl.List(a), " ")(0)).Column
            Set frstCell = Intersect(rng, rng.Parent.Columns(ColIndex)).Cells(1, 1)
            ctl.RemoveItem (a)
            If header = True Then
                ctl.AddItem ExtractColumnLetter(Cells(1, ColIndex).address) & _
                IIf(frstCell <> "", " (" & frstCell.Value & ")", _
                " (" & frstCell.End(xlDown).Value & ")"), a
            Else
                ctl.AddItem ExtractColumnLetter(Cells(1, ColIndex).address) & _
                " (Colonna " & ExtractColumnLetter(Cells(1, ColIndex).address) & ")", a
            End If
            If Left(ctl.Name, 3) = "lbx" Then ctl.Selected(a) = True
        Next a
    End With
    
    'Scroll to top of listbox/combobox
    If Left(ctl.Name, 3) = "lbx" Then ctl.TopIndex = 0
    If Left(ctl.Name, 3) = "cbx" Then ctl.ListIndex = 0
    
End Sub

Function ColItemToNumber(colitem As String) As Long
'Converte in numero una stringa in cui |fffd| definita una colonna (es. listbox o combobox)

    ColItemToNumber = Range(Replace(Mid(colitem, 1, InStr(1, colitem, "(") - 1) & "1", " ", "")).Column

End Function

Function RowItemToNumber(rowitem As String) As Long
'Converte in numero una stringa in cui |fffd| definita una riga (es. listbox o combobox)

    RowItemToNumber = Range("A" & Replace(Mid(rowitem, 1, InStr(1, rowitem, "(") - 1), " ", "")).Row

End Function

Function CountListBox(lbx As control) As Long
'Conta quanti elementi sono stati selezionati in una listbox
    
    Dim i As Long
    
    On Error Resume Next
    For i = 0 To lbx.ListCount - 1
        If lbx.Selected(i) = True Then
            CountListBox = CountListBox + 1
        End If
    Next i
    On Error GoTo 0
    
End Function

Function ListListBox(lbx As control, Optional separator As String = vbNewLine) As String
'Restituisce una lista degli elementi selezionati in una listbox (separati da a capo o carattere a scelta)
    
    Dim i As Long
    Dim s As Long
    Dim arr As Variant
    Dim strList As String
    Const esksep As String = "||fffd||ESKSEP||fffd||"
    
    s = 1
    ReDim arr(1 To 1)
    
    On Error Resume Next
    For i = 0 To lbx.ListCount - 1
        If lbx.Selected(i) = True Then
            ReDim Preserve arr(1 To s)
            arr(s) = lbx.List(i)
            s = s + 1
        End If
    Next i
    
    For s = LBound(arr) To UBound(arr)
        strList = strList & esksep & arr(s)
    Next s
    
    ListListBox = Replace(Mid(strList, Len(esksep) + 1), esksep, separator)
    On Error GoTo 0
    
End Function
Attribute VB_Name = "OpenStuff"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le funzioni per aprire file, cartelle e pagine web

Option Explicit


#If Not Mac Then
    #If VBA7 Then
        Private Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" _
        (ByVal hWnd As Long, ByVal Operation As String, ByVal FileName As String, Optional ByVal Parameters As String, Optional ByVal Directory As String, Optional ByVal WindowsStyle As Long = vbMinimizedFocus) As Long
    #Else
        Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" _
        (ByVal hWnd As Long, ByVal Operation As String, ByVal FileName As String, Optional ByVal Parameters As String, Optional ByVal Directory As String, Optional ByVal WindowsStyle As Long = vbMinimizedFocus) As Long
    #End If
#End If

Sub OpenFile(FilePath As Variant)
    'Esegue file
    Dim ret As Long
    
    On Error GoTo ErrorHandler
    
    #If Mac Then
        ActiveWorkbook.FollowHyperlink (FilePath)
        Exit Sub
    #Else
        ret = Shell("rundll32.exe url.dll,FileProtocolHandler " & FilePath, vbNormalFocus)
        Exit Sub
    #End If
    
ErrorHandler:
    If lng = 0 Then
        MsgBox "Si |fffd| verificato un errore nell'apertura del file: " & vbNewLine & FilePath & vbNewLine & "Si prega di verificare le impostazioni predefinite per questo tipo di file nel sistema in uso.", vbExclamation, "Errore nell'apertura del file"
    Else
        MsgBox "An error occurred in opening file: " & vbNewLine & FilePath & vbNewLine & "Please double check default settings for this file type in your system.", vbExclamation, "Error in opening file"
    End If
End Sub

Sub OpenFolder(FolderPath As Variant)
'Apre cartella in esplora risorse
    
    On Error GoTo ErrorHandler
    
    #If Mac Then
        ActiveWorkbook.FollowHyperlink (FolderPath)
        Exit Sub
    #Else
        Call Shell("explorer.exe" & " " & FolderPath, vbNormalFocus)
        Exit Sub
    #End If
    
ErrorHandler:
    If lng = 0 Then
        MsgBox "Si |fffd| verificato un errore nell'apertura in esplora risorse della cartella: " & vbNewLine & FolderPath, vbExclamation, "Errore nell'apertura della cartella"
    Else
        MsgBox "An error occurred in opening this folder in windows explorer: " & vbNewLine & FolderPath, vbExclamation, "Error in opening folder"
    End If
End Sub

Sub OpenUrl(url As String, Optional winstate As Long = 2)
    
    AutoCalc False
    
    On Error GoTo ErrorHandler
    
    #If Mac Then
        ActiveWorkbook.FollowHyperlink (url)
        GoTo ExSub
    #Else
        Dim lSuccess As Long
        
        lSuccess = ShellExecute(0, "Open", url, , , winstate)
        GoTo ExSub
    
    #End If

ErrorHandler:
    MsgBox IIf(lng = 0, "Impossibile aprire la pagina web " & vbNewLine & vbNewLine & url & vbNewLine & vbNewLine & "Verificare la connessione a internet e riprovare", _
                      "Failed opening web page " & vbNewLine & vbNewLine & url & vbNewLine & vbNewLine & "Please check your internet connection"), _
                      vbExclamation, _
                      IIf(lng = 0, "Errore nell'apertura del link", "Error opening URL")
ExSub:
    On Error GoTo 0
    AutoCalc True
End Sub

Sub OpenHelp(frmName As String, Optional findUI As Long = 0)
'Apre una finestra nel browser predefinito con la pagina di aiuto
    
    Dim url As String
    
    With MenuSheet
        On Error Resume Next
        url = .Cells(Application.Match(frmName, .Columns(3 - findUI), 0), Application.Match("Help", .Rows(1), 0))
        On Error GoTo 0
    End With
    
    If url <> "" Then
        Call OpenUrl(url)
    Else
        MsgBox IIf(lng = 0, "Impossibile aprire la pagina di help, si prega di visitare http://www.excelswissknife.com/help", _
                            "Failed opening help page, please visit http://www.excelswissknife.com/help")
    End If
End Sub

Attribute VB_Name = "Options"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le funzioni per salvare e richiamare le opzioni del programma e dei singoli strumenti

Option Explicit
Option Private Module

Function GetSettings(Setting As String) As Variant
    Dim f As Long
    Dim CfgFile As String
    Dim dataline As String
    
    '#' Valori di default se si usa versione portable
    If IsPortable = True Then
        Select Case Setting
            Case "Language"
                On Error Resume Next
                GetSettings = CLng(Replace(ThisWorkbook.Names("ESKLanguage"), "=", ""))
                If Err.Number <> 0 Then GetSettings = 0
                On Error GoTo 0
            Case "Scale"
                On Error Resume Next
                GetSettings = CLng(Replace(ThisWorkbook.Names("ESKScale"), "=", ""))
                If Err.Number <> 0 Then GetSettings = 100
                On Error GoTo 0
            Case "LastRun"
                On Error Resume Next
                GetSettings = Replace(ThisWorkbook.Names("ESKLastRun"), "=", "")
                If Err.Number <> 0 Then GetSettings = 999
                On Error GoTo 0
            Case "LoadSettings"
                GetSettings = 0
            Case "DisableProgBar"
                GetSettings = 0
            Case "ErrorLogLimit"
                GetSettings = 1000
            Case "MaxSnapFiles"
                GetSettings = 0
            Case "SnapFolderPath"
                GetSettings = ValidateFolder(ThisWorkbook.path & pSep & "Snapshots" & pSep)
            Case "PurgeSnapOnExit"
                GetSettings = 1
            Case "CreateBackup"
                GetSettings = 1
            Case "DeleteBackup"
                GetSettings = 1
            Case "AutoCheckInterval"
                GetSettings = 0
            Case "LastUpdateCheck"
                GetSettings = Date
            Case "CheckBetaUpdate"
                GetSettings = 1
        End Select
    Else
    
        
    On Error Resume Next
        f = FreeFile
        
        CfgFile = CfgPath & "Config.txt"
        
        Open CfgFile For Input As #f
        If Err.Number <> 0 Then
            Err.Clear
            GoTo ExitNow
        End If
        
            Do While Not EOF(f)
                
                Line Input #f, dataline
                If InStr(1, UCase(dataline), UCase(Setting)) = 1 Then
                    GetSettings = Trim(Mid(dataline, InStr(1, dataline, "=") + 1))
                    Exit Do
                End If
                
            Loop
        
        Close #f
        
    End If
    
ExitNow:
    On Error GoTo 0
    
End Function

Sub UpdateConfigFile(Optional SName As String, Optional SValue As Variant)
'Aggiorna il file di configurazione principale del programma

    Dim CfgFile As String
    Dim f As Long
    Dim sTemp As String
    Dim DefaultOptions()
    Dim Item
    Dim dataline As String
    Dim check As Long
    Dim repeat As Long
    Dim DefaultValue
        
    '#' Setta le opzioni disponibili nella versione portable
    If IsPortable = True Then
        Select Case SName
            Case "Language"
                ThisWorkbook.Names.Add "ESKLanguage", RefersTo:=SValue
            Case "Scale"
                ThisWorkbook.Names.Add "ESKScale", RefersTo:=SValue
            Case "LastRun"
                ThisWorkbook.Names.Add "ESKLastRun", RefersTo:=SValue
        End Select
        Exit Sub
    End If
    
    On Error Resume Next    'Evita errori di runtime su ogni possibile problema relativo al file di testo
    
    DefaultOptions = Array("Language", _
                                "Scale", _
                                "LastRun", _
                                "LoadSettings", _
                                "DisableProgBar", _
                                "CreateBackup", _
                                "DeleteBackup", _
                                "ErrorLogLimit", _
                                "MaxSnapFiles", _
                                "SnapFolderPath", _
                                "PurgeSnapOnExit", _
                                "SilentSnapShot", _
                                "AutoCheckInterval", _
                                "LastUpdateCheck", _
                                "CheckBetaUpdate")
    
    repeat = 0
    check = 0
    
    'Verifico che l'opzione da modificare sia tra quelle di default
    For Each Item In DefaultOptions
        If UCase(SName) = UCase(Item) Then
            check = 1
            Exit For
        End If
    Next Item
    
    'Non ho trovato l'opzione da cambiare tra quelle di default
    If check = 0 And SName <> "" Then
        DefaultOptions = Array("Language", _
                                "Scale", _
                                "LastRun", _
                                "LoadSettings", _
                                "DisableProgBar", _
                                "CreateBackup", _
                                "DeleteBackup", _
                                "ErrorLogLimit", _
                                "MaxSnapFiles", _
                                "SnapFolderPath", _
                                "PurgeSnapOnExit", _
                                "SilentSnapShot", _
                                "AutoCheckInterval", _
                                "LastUpdateCheck", _
                                "CheckBetaUpdate", _
                                SName) 'Aggiungo SName all'elenco delle opzioni di cui verificare la presenza nel file
    End If
    
    If Dir(CfgPath, vbDirectory) = "" Then MkDir CfgPath
    
    CfgFile = CfgPath & "Config.txt"
    
    SetAttr CfgFile, vbNormal
    Err.Clear
    
    f = FreeFile
    
    If Dir(CfgFile) = "" Then 'Il file config.txt non esiste: vado a crearlo con le impostazioni di default
    
        repeat = 1 'esegue di nuovo la procedura al termine, per aggiornare effettivamente l'opzione indicata
        
        sTemp = sTemp & "###################################" & vbNewLine
        sTemp = sTemp & "Opzioni di Excel Swiss Knife" & vbNewLine
        sTemp = sTemp & "Non modificare a mano questo file!" & vbNewLine
        sTemp = sTemp & "###################################" & vbNewLine
        sTemp = sTemp & vbNewLine
        sTemp = sTemp & "Language=0" & vbNewLine
        sTemp = sTemp & "Scale=100" & vbNewLine
        sTemp = sTemp & "LastRun=999" & vbNewLine
        sTemp = sTemp & "LoadSettings=1" & vbNewLine
        sTemp = sTemp & "DisableProgressBar=0" & vbNewLine
        sTemp = sTemp & "CreateBackup=1" & vbNewLine
        sTemp = sTemp & "DeleteBackup=1" & vbNewLine
        sTemp = sTemp & "AutoCheckInterval=0" & vbNewLine
        sTemp = sTemp & "LastUpdateCheck=" & Date & vbNewLine
        sTemp = sTemp & "CheckBetaUpdate=1" & vbNewLine
        sTemp = sTemp & "ErrorLogLimit=1000" & vbNewLine
        sTemp = sTemp & "MaxSnapFiles=0" & vbNewLine
        sTemp = sTemp & "SnapFolderPath=" & vbNewLine
        sTemp = sTemp & "PurgeSnapOnExit=1" & vbNewLine
        sTemp = sTemp & "SilentSnapShot=0" & vbNewLine

    Else ' Il file esiste gi|fffd|, verifico che ci siano tutte le impostazioni
        
        sTemp = sTemp & "###################################" & vbNewLine
        sTemp = sTemp & "Opzioni di Excel Swiss Knife" & vbNewLine
        sTemp = sTemp & "Non modificare a mano questo file!" & vbNewLine
        sTemp = sTemp & "###################################" & vbNewLine
        sTemp = sTemp & vbNewLine
        
        SetAttr CfgFile, vbNormal
        
        Open CfgFile For Input As #f
        
        For Each Item In DefaultOptions
            check = 0
            Do While Not EOF(f)
                Line Input #f, dataline
                
                If InStr(1, UCase(dataline), UCase(Item)) > 0 Then 'corrispondenza tra l'impostazione presa dall'array e la linea del file di testo
                    check = 1
                    If UCase(SName) = UCase(Item) Then '|fffd| l'impostazione che stiamo andando a cambiare
                        sTemp = sTemp & Item & "=" & SValue & vbNewLine
                    Else 'scrivo la linea cos|fffd| com'era nel file originale
                        sTemp = sTemp & dataline & vbNewLine
                    End If
                    Exit Do
                End If
            Loop
            
            If check = 0 Then 'L'impostazione non |fffd| stata trovata
        
                Select Case Item
                    Case "Language"
                        DefaultValue = 0
                    Case "Scale"
                        DefaultValue = IIf(IsWindows = True, 100, 133)
                    Case "LastRun"
                        DefaultValue = 999
                    Case "LoadSettings"
                        DefaultValue = 1
                    Case "DisableProgBar"
                        DefaultValue = 0
                    Case "CreateBackup"
                        DefaultValue = 1
                    Case "DeleteBackup"
                        DefaultValue = 1
                    Case "AutoCheckInterval"
                        DefaultValue = 0
                    Case "LastUpdateCheck"
                        DefaultValue = Date
                    Case "CheckBetaUpdate"
                        DefaultValue = 1
                    Case "ErrorLogLimit"
                        DefaultValue = 1000
                    Case "MaxSnapFiles"
                        DefaultValue = 0
                    Case "SnapFolderPath"
                        DefaultValue = ""
                    Case "PurgeSnapOnExit"
                        DefaultValue = 1
                    Case "SilentSnapShot"
                        DefaultValue = 0
                End Select
                If SName <> "" Then 'stiamo modificando un'impostazione che non esisteva nel file
                    sTemp = sTemp & SName & "=" & SValue & vbNewLine
                Else 'aggiungo l'impostazione con valore di default
                    sTemp = sTemp & Item & "=" & DefaultValue & vbNewLine
                End If
    
            End If
            Seek f, 1
        
        Next Item

        Close #f
            
        'Mi assicuro che il file non sia ancora aperto: provo a rinominarlo finch|fffd| non mi d|fffd| errore
        Call CloseTxt(CfgFile)
    
    End If
    
    f = FreeFile
    
    Open CfgFile For Output As #f
    Print #f, sTemp
    Close #f

    'Mi assicuro che il file non sia ancora aperto: provo a rinominarlo finch|fffd| non mi d|fffd| errore
    Call CloseTxt(CfgFile)
    
    'Imposto il file come nascosto e di sola lettura
    SetAttr CfgFile, vbHidden + vbReadOnly
    
    If repeat = 1 Then Call UpdateConfigFile(SName, SValue)

    On Error GoTo 0

End Sub

Sub SaveOptions(FormName As Object, Optional NewFile As Boolean = True)
'Salva le opzioni degli strumenti con interfaccia grafica

    Dim f As Long
    Dim ctl As control
    Dim CfgFile As String
    Dim n As Long
    Dim ListBoxArray1()
    Dim ListBoxArray2()
    Dim dcopy As Boolean
    
    '#' Disabilita il frame delle opzioni ed esci senza fare altro se in uso versione portable
    If IsPortable = True Then
        On Error Resume Next 'previene l'errore se manca il Frame
        FormName.fraLoad.ControlTipText = IIf(lng = 0, "Funzione non disponibile in modalit|fffd| portable", "Function not available in portable mode")
        FormName.cmdLatest.Enabled = False
        FormName.cmdDefault.Enabled = False
        'Rendo invisibile il toggle per creare o meno il backup
        FormName.tglBackup.Left = -2000
        On Error GoTo 0
        Exit Sub
    End If
    
    On Error Resume Next
    MkDir CfgPath           'Crea la cartella base dei setting se non esiste
    MkDir SettingsPath      'Crea la sottocartella dei setting se non esiste
    Err.Clear
    
    'Set default options file path
    If NewFile = True Then
        CfgFile = SettingsPath & FormName.Name & ".def.cfg"
        If Dir(CfgFile) = "" Then dcopy = True
    Else
        CfgFile = SettingsPath & FormName.Name & ".lst.cfg"
    End If
    
    f = FreeFile
    Open CfgFile For Output As #f
    
    For Each ctl In FormName.Controls
        Select Case ctl.Name
            Case "lblColor"
                Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                Print #f, ctl.Name & IIf(NewFile = True, ".BackColor=65535", ".BackColor=" & ctl.BackColor)
                Print #f, ctl.Name & ".BackStyle=" & ctl.BackStyle
                
            Case "lblHeaderColor"
                Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                Print #f, ctl.Name & IIf(NewFile = True, ".BackColor=8421504", ".BackColor=" & ctl.BackColor)
                Print #f, ctl.Name & ".BackStyle=" & ctl.BackStyle
                
            Case "lblEvenColor"
                Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                Print #f, ctl.Name & IIf(NewFile = True, ".BackColor=16777215", ".BackColor=" & ctl.BackColor)
                Print #f, ctl.Name & ".BackStyle=" & ctl.BackStyle
                
            Case "lblOddColor"
                Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                Print #f, ctl.Name & IIf(NewFile = True, ".BackColor=12648384", ".BackColor=" & ctl.BackColor)
                Print #f, ctl.Name & ".BackStyle=" & ctl.BackStyle
                
            Case "lbxDelimList" 'listbox 1 colonna
                Erase ListBoxArray1
                ReDim ListBoxArray1(0 To ctl.ListCount - 1)
                For n = 0 To ctl.ListCount - 1
                    ListBoxArray1(n) = ctl.List(n)
                Next n
                Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                Print #f, ctl.Name & ".Value(lbx)=" & IIf(NewFile = True, "", Join(ListBoxArray1, "|"))
                
            Case "lbxSubList" 'listbox 2 colonne
                Erase ListBoxArray1
                Erase ListBoxArray2
                ReDim ListBoxArray1(0 To ctl.ListCount - 1)
                ReDim ListBoxArray2(0 To ctl.ListCount - 1)
                For n = 0 To ctl.ListCount - 1
                    ListBoxArray1(n) = ctl.List(n)
                    ListBoxArray2(n) = ctl.List(n, 1)
                Next n
                Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                Print #f, ctl.Name & ".Value(lbx1)=" & IIf(NewFile = True, "", Join(ListBoxArray1, "|"))
                Print #f, ctl.Name & ".Value(lbx2)=" & IIf(NewFile = True, "", Join(ListBoxArray2, "|"))
                
                'Elenco dei controlli da ignorare
            Case "txtParams", "cbxBaseSheet", "cbxBaseFile", _
                "cbxDestFile", "cbxNewFile", "cbxNewFileSheet", _
                "cbxNewFileKey", "cbxKeyCol", "lbxFiles", "lbxPreview", _
                "lbxSheets", "chkWholeSheet", "tglBatch", "cbxFilterRow", _
                "cbxFilterColumn", "cbxFilterCol", "txtFilterList" ', "txtDestFolder"
                
            Case Else
                If Left(ctl.Name, 3) = "txt" Or _
                    Left(ctl.Name, 3) = "spb" Or _
                    Left(ctl.Name, 3) = "lbx" Or _
                    Left(ctl.Name, 3) = "cbx" Or _
                    Left(ctl.Name, 3) = "mpg" Then
                    
                    Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                    Print #f, ctl.Name & ".Value=" & ctl.Value
                    
                ElseIf Left(ctl.Name, 3) = "chk" Or _
                    Left(ctl.Name, 3) = "opt" Then
                
                    Print #f, ctl.Name & ".Enabled=" & Abs(CInt(ctl.Enabled))
                    Print #f, ctl.Name & ".Value=" & Abs(CInt(ctl.Value))
                    
                End If
        End Select
    
    Next ctl
    
    Close #f
    'Mi accerto che il file sia chiuso
    Call CloseTxt(CfgFile)
    
    If dcopy = True Then FileCopy SettingsPath & FormName.Name & ".def.cfg", SettingsPath & FormName.Name & ".lst.cfg"
    
    On Error GoTo 0
End Sub

Sub LoadOptions(FormName As Object, Default As Boolean)
'Ricarica le opzioni salvate degli strumentic on interfaccia grafica

    Dim ctl As control
    Dim CfgFile As String
    Dim n As Long, f As Long
    Dim ListBoxArray1() As String
    Dim ListBoxArray2() As String
    Dim strLine As String
    
    '#' Esci senza fare nulla se in uso versione portable
    If IsPortable = True Then Exit Sub
    
    On Error Resume Next
    
    If Default = True Then
        CfgFile = SettingsPath & FormName.Name & ".def.cfg"
    Else
        CfgFile = SettingsPath & FormName.Name & ".lst.cfg"
    End If
    
    f = FreeFile
    
    If Dir(CfgFile) <> "" Then
        Open CfgFile For Input As #f
        
        For Each ctl In FormName.Controls
            Do While Not EOF(f)
                
                Line Input #f, strLine
                
                If InStr(1, strLine, ctl.Name & ".Enabled=") > 0 Then
                    ctl.Enabled = CBool(Right(strLine, 1))
                    
                ElseIf InStr(1, strLine, ctl.Name & ".Value=") > 0 Then
                    ctl.Value = Mid(strLine, InStr(1, strLine, "=") + 1)
                    
                ElseIf InStr(1, strLine, ctl.Name & ".BackColor=") > 0 Then
                    ctl.BackColor = Mid(strLine, InStr(1, strLine, "=") + 1)
                    
                ElseIf InStr(1, strLine, ctl.Name & ".BackStyle=") > 0 Then
                    ctl.BackStyle = Mid(strLine, InStr(1, strLine, "=") + 1)
                    
                ElseIf InStr(1, strLine, ctl.Name & ".Value(lbx)=") > 0 Then 'ListBox una colonna
                    Erase ListBoxArray1
                    ListBoxArray1() = Split(Mid(strLine, InStr(1, strLine, "=") + 1), "|")
                    ctl.Clear
                    For n = 0 To UBound(ListBoxArray1)
                        ctl.AddItem (ListBoxArray1(n))
                    Next n
                
                ElseIf InStr(1, strLine, ctl.Name & ".Value(lbx1)=") > 0 Then 'ListBox multicolonne (prima colonna)
                    Erase ListBoxArray1
                    ListBoxArray1() = Split(Mid(strLine, InStr(1, strLine, "=") + 1), "|")
                    ctl.Clear
                    For n = 0 To UBound(ListBoxArray1)
                        ctl.AddItem (ListBoxArray1(n))
                    Next n
                
                ElseIf InStr(1, strLine, ctl.Name & ".Value(lbx2)=") > 0 Then 'ListBox multicolonne (seconda colonna)
                    Erase ListBoxArray2
                    ListBoxArray2() = Split(Mid(strLine, InStr(1, strLine, "=") + 1), "|")
                    For n = 0 To UBound(ListBoxArray2)
                        ctl.List(n, 1) = (ListBoxArray2(n))
                    Next n
            
                End If
    
            Loop
            
            Seek f, 1 'Torno in cima al file
            
        Next ctl

        Close #f
    End If

    On Error GoTo 0

End Sub



Attribute VB_Name = "ProgressBar"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le funzioni per aprire e aggiornare la barra di progresso

Option Explicit

Sub ShowProgressBar()
    pbShow = Not CBool(GetSettings("DisableProgBar"))
        
    If pbShow = True Then UProgress.Show vbModeless
End Sub

Sub UpdateProgressBar(ByVal counter As Long, ByVal countermax As Long)
    Dim CounterStep As Long
    
    If pbShow = False Then Exit Sub
    
    On Error Resume Next
    
    CounterStep = Application.WorksheetFunction.RoundDown(countermax / 100, 0)
    If CounterStep = 0 Then CounterStep = 1 'Per evitare divisioni per 0
    
    'Aggiorno la finestra di avanzamento
    If counter Mod CounterStep = 0 Then
        PctDone = counter / countermax
        Call UProgress.UpdateProgress(PctDone)
    End If
    If counter Mod 100 = 0 Then DoEvents
    
    On Error GoTo 0
    
End Sub

Sub UpdateSubProgressBar(ByVal counter2 As Long, ByVal countermax2 As Long)
    Dim CounterStep2 As Long
    
    If pbShow = False Then Exit Sub
    
    On Error Resume Next
    
    CounterStep2 = Application.WorksheetFunction.RoundDown(countermax2 / 100, 0)
    If CounterStep2 = 0 Then CounterStep2 = 1 'Per evitare divisioni per 0
    
    'Aggiorno la finestra di avanzamento
    If counter2 Mod CounterStep2 = 0 Then
        PctDone2 = counter2 / countermax2
        Call UProgress.UpdateProgress2(PctDone2)
    End If
    If counter2 Mod 100 = 0 Then DoEvents
    
    On Error GoTo 0
    
End Sub

Attribute VB_Name = "Questa_cartella_di_lavoro"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub Workbook_Open()
    Dim AppVersion As Long
    Dim ChangeLng As Long
    Dim ChangeScale As Long
    
    'Verifica la versione di Excel
    AppVersion = Val(Application.Version)
    If AppVersion < 12 Then
        MsgBox "Impossibile utilizzare Excel Swiss Knife: questo addin |fffd| compatibile solo con le versioni di Excel 2007 o successive.", vbCritical, "Versione di Excel non supportata"
        ThisWorkbook.Close
    End If
    
    'Nel caso ci sia stato un crash mentre l'aggiornamento schermo o gli eventi erano disabilitati, riabilitarli
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    
    'Inizializza il modulo di classe per gli eventi applicazione
    Call CModInitialize
    
    '#' Retrieve options from config file
    Call UpdateConfigFile
    
    'Se il paese |fffd| diverso da Italia, chiede se si vuole cambiare la lingua predefinita a inglese
    If Application.International(xlCountryCode) <> 39 And lng = 0 Then
        ChangeLng = MsgBox("Would you like to change language to English? (default: Italian)", vbYesNo + vbQuestion, "Set English language")
        
        If ChangeLng = vbYes Then
            Call UpdateConfigFile("Language", 1)
                
            If ESKRibbon Is Nothing Then
                MsgBox "Please restart Excel for the new language settings to be fully working", vbInformation
            Else
                ESKRibbon.Invalidate
            End If 'ESKRibbon is nothing
            
        End If 'Cambio lingua
    End If
    
    'Se il sistema |fffd| MacOS e la dimensione di default |fffd| <133, chiedere se si vuole cambiare
    If IsWindows = False Then
        If GetSettings("Scale") = "" Or GetSettings("Scale") < 120 Then
            ChangeScale = MsgBox(IIf(lng = 0, "Vuoi modificare la dimensione di default delle finestre per meglio adattarsi ai sistemi Mac?", "Would you like to change the default form size in order to better suit Mac environment?"), vbQuestion + vbYesNo)
            If ChangeScale = vbYes Then
                Call UpdateConfigFile("Scale", 138)
                MsgBox IIf(lng = 0, "Le dimensioni di default sono state modificate. Puoi ulteriormente personalizzarle dal menu Impostazioni", "Default form size has been changed. You can change it again via the settings menu"), vbInformation
            End If
        End If 'Cambio scala
    End If
    
    'Aggiorna la data ultimo aggiornamento se vuota (primo utilizzo)
    If GetSettings("LastUpdateCheck") = "" Then
        Call UpdateConfigFile("LastUpdateCheck", Date)
    End If
        
    '#' Mostra splash screen se in versione portable e non installata nel sistema
    If IsPortable = True Then
        If IsInstalled = False Then frmWelcomePortable.Show vbModeless
    End If
    
    '#' Inizializza le scorciatoie da tastiera:
    On Error Resume Next
    If IsWindows = True Then
        Application.OnKey "%^l", "LastRun" 'Ctrl+Alt+l ultimo strumento utilizzato
        Application.OnKey "%^s", "ShowSettings" 'Ctrl+Alt+s apre impostazioni
        Application.OnKey "%^b", "SaveSnapShot" 'Ctrl+Alt+b salva uno snapshot
        Application.OnKey "%^r", "SnapShots" 'Ctrl+Alt+r apre snapshot salvati
    Else
        'Mac
        Application.OnKey "*^l", "LastRun" 'Ctrl+Cmd+l ultimo strumento utilizzato
        Application.OnKey "*^s", "ShowSettings" 'Ctrl+Cmd+s apre impostazioni
        Application.OnKey "*^b", "SaveSnapShot" 'Ctrl+Alt+b salva uno snapshot
        Application.OnKey "*^r", "SnapShots" 'Ctrl+Alt+r apre snapshot salvati
    End If
    On Error GoTo 0
    
    
    '#' Check if enough time has past since last update check
    On Error Resume Next
    If CLng(Date) >= CLng(CDate(GetSettings("LastUpdateCheck"))) + GetSettings("AutoCheckInterval") + 1 Then
        Application.OnTime Now + TimeValue("00:00:01"), "CheckUpdateOnStartup"
    End If
    On Error GoTo 0
    
    '#' Inizializza a 1 la variabile tmpscale (ridimensionamento temporaneo form)
    tmpScale = 1
    
End Sub
  


Private Sub Workbook_BeforeClose(Cancel As Boolean)
    'VERSIONE PER IL PUBBLICO
    Dim strFolder As String

    Set XLApp = Nothing

    strFolder = SnapFolder

    '#' Resetto scorciatoie tastiera
    On Error Resume Next
    If IsWindows = True Then
       Application.OnKey "%^l"
       Application.OnKey "%^s"
       Application.OnKey "%^b"
       Application.OnKey "%^r"
    Else
        'Mac
        Application.OnKey "*^l"
        Application.OnKey "*^s"
        Application.OnKey "*^b"
        Application.OnKey "*^r"
    End If
    On Error GoTo 0

    '#' Svuoto la cartella SnapShot
    If GetSettings("PurgeSnapOnExit") = 1 Then
        On Error Resume Next
        Kill strFolder & "*.snap"
        On Error GoTo 0
    End If

End Sub
Attribute VB_Name = "SnapShot"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Option Private Module

Sub SaveSnapshot(Optional wb As Workbook, Optional Silent As Boolean)
    Dim asksave As Long
    Dim vFilePath As Variant
    Dim overwrite As Long
    Dim sNote As String
    Dim strFile As String
    Dim uR As Long
    Dim strFolder As String
    
    Call CModInitialize
    
    'Se serve creo ex novo il file di riepilogo degli Snapshot
    If SnapLogFileExists = False Then
        'Esco dalla routine senza fare altro (il msgbox me lo mostra gi|fffd| la funzione SnapLogFileExists)
    Else
        'Metto il file attivo in una variabile
        If wb Is Nothing Then Set wb = ActiveWorkbook
        
        'Se il foglio attivo non |fffd| mai stato salvato, non eseguire lo snapshot e visualizza un avviso
        If InStr(1, wb.FullName, pSep) = 0 Then
        
            asksave = MsgBox(IIf(lng = 0, "Non |fffd| possibile salvare lo snapshot perch|fffd| il file in uso non |fffd| mai stato salvato. Salvarlo ora?", _
                                          "It's not possible to save a snapshot because the active workbook has never been saved. Save it now?"), _
                                          vbYesNo + vbQuestion, _
                                          IIf(lng = 0, "File non salvato", "Unsaved file"))
            If asksave = vbYes Then
                Do
                    If IsWindows = True Then
                        vFilePath = Application.GetSaveAsFilename(FileFilter:="File Excel (*.xl*), *.xl*")
                    Else
                        vFilePath = Application.GetSaveAsFilename
                    End If
                        
                    '#' --exit if cancelled by user,
                    If vFilePath = False Then Exit Sub
                    
                    '#' --ask user if he wants to overwrite
                    If FileExists(vFilePath) Then
                        overwrite = MsgBox("Sovrascrivere il file " & vFilePath & "?", vbQuestion + vbYesNo, "Conferma sovrascrittura")
                                    
                        If overwrite = vbNo Then
                            vFilePath = ""
                            AutoCalc True
                            AutoCalc False
                        End If
                        
                    End If
                Loop Until vFilePath <> ""
                Call SaveFile(wb, vFilePath, Silent:=True)
            Else
                MsgBox IIf(lng = 0, "Snapshot non creato. Riprovare dopo aver salvato il file", "Snapshot not created. Try again on a saved file"), vbInformation, IIf(lng = 0, "Snapshot non creato", "Snapshot creation failed")
                Exit Sub
            End If
        ElseIf Silent = False And GetSettings("SilentSnapShot") = 0 Then
            asksave = MsgBox(IIf(lng = 0, "Vuoi creare un punto di ripristino per il file " & wb.Name & "?", _
                                          "Would you like to create a snapshot for the workbook " & wb.Name & "?"), _
                                          vbYesNo + vbQuestion, _
                                          IIf(lng = 0, "Creare uno snapshot?", "Create a snapshot?"))
            If asksave <> vbYes Then Exit Sub
        End If
        
        strFolder = SnapFolder
        
        sNote = InputBox(IIf(lng = 0, "Inserisci una nota (facoltativa) per identificare lo snapshot in seguito:", _
                                      "Type an optional note to identify your snapshot later"), "Note")
        
        Call AutoCalc(False)
    
        'Salvo lo snapshot
        With wb
            strFile = "ESK_Snapshot_" & Format(Now, "yymmdd_hhmmss") & ".snap"
            Call SaveFile(wb, strFolder & strFile, , , , True)
        End With
        
        If Not wbSnap Is Nothing Then
        
            'Aggiorno il file di log
            With wsSnap
                uR = .Cells(Rows.Count, 1).End(xlUp).Row
                .Cells(uR + 1, 1) = wb.FullName
                .Cells(uR + 1, 2) = strFile
                .Cells(uR + 1, 3) = Now
                .Cells(uR + 1, 4) = ConvertFileLen(wb.FullName, "MB")
                .Cells(uR + 1, 5) = sNote
                .UsedRange.EntireColumn.AutoFit
                'Ordinamento
                With .Sort
                    .SortFields.Clear
                    .SortFields.Add key:=Range("A2"), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
                    .SortFields.Add key:=Range("C2"), SortOn:=xlSortOnValues, Order:=xlDescending, DataOption:=xlSortNormal
                    .SetRange wsSnap.UsedRange
                    .header = xlYes
                    .MatchCase = False
                    .Orientation = xlTopToBottom
                    .SortMethod = xlPinYin
                    .Apply
                End With
            End With
        
            wbSnap.Close True
                
        End If
        
        'Lancio la pulizia della cartella e del log
        Call PurgeSnapshots
        
        Call AutoCalc(True)
        
        If Silent = False Then MsgBox IIf(lng = 0, "Snapshot creato nella cartella " & strFolder, "Snapshot created in folder " & strFolder), vbInformation
    End If
    
End Sub

Sub LoadSnapshot(wbOld As String, strSnap As String)
    Dim wb As Workbook
    Dim wbFN As String
    Dim uR As Long
    Dim i As Long
    Dim asksave As Long
    Dim askkill As Long
    Dim snapDesc As String
    
    Call AutoCalc(False)
    
    On Error Resume Next
    Set wb = Workbooks(wbOld)
    If Err.Number <> 0 Then
        MsgBox IIf(lng = 0, "La cartella di lavoro " & wbOld & " deve essere aperta", "Workbook " & wbOld & " must be open"), vbCritical
        Exit Sub
    End If
    On Error GoTo 0
    wbFN = wb.FullName
    
    'Esco se non esiste la cartella o il file degli snapshot
    If SnapLogFileExists = False Then Exit Sub
    
    'Chiedo se si vuole salvare una versione attuale
    If GetSettings("SilentSnapShot") = 0 Then
        asksave = MsgBox(IIf(lng = 0, "Si desidera salvare un nuovo punto di ripristino allo stato attuale, prima di tornare a uno precedente?", _
                                      ""), _
                                      vbYesNo + vbQuestion + vbDefaultButton2, _
                                      IIf(lng = 0, "Salvataggio attuale", "Save latest"))
    Else
        asksave = vbNo
    End If
    
    If asksave = vbYes Then
        Call SaveSnapshot(wb, True)
    End If
    
    With wsSnap
        uR = .Cells(Rows.Count, 1).End(xlUp).Row
        For i = 2 To uR
            If .Cells(i, 2) = strSnap Then
                If asksave <> vbYes And GetSettings("SilentSnapShot") = 0 Then
                    askkill = MsgBox(IIf(lng = 0, "Attenzione: il punto di ripristino sostituir|fffd| il file aperto, e le ultime modifiche non saranno pi|fffd| recuperabili. Proseguire?", _
                                              "Warning: your active workbook will be replaced by the snapshot, and latest changes won't be recoverable. Continue?"), _
                                              vbYesNo + vbInformation, _
                                              IIf(lng = 0, "Recupero punto di ripristino", "Snapshot recovery"))
                Else
                    askkill = vbYes
                End If
                
                If askkill = vbYes Then
                    Application.DisplayAlerts = False
                    wb.Close False
                    FileCopy SnapFolder & strSnap, wbFN
                    Workbooks.Open wbFN
                    Application.DisplayAlerts = True
                    snapDesc = .Cells(i, 5)
                End If
                Exit For
            End If
        Next i
    End With
    
    wbSnap.Close False
    
    Call AutoCalc(True)

    If askkill = vbYes Then
        MsgBox IIf(lng = 0, "Snapshot " & IIf(snapDesc = "", "", "'" & snapDesc & "' ") & "ripristinato", "Snapshot restored"), vbInformation
    Else
        MsgBox IIf(lng = 0, "Snapshot non ripristinato", "Snapshot was not restored"), vbExclamation
    End If
End Sub

Sub DeleteSnapshot(strSnap As String, Optional snapDesc As String, Optional Silent As Boolean = False)
    Dim askkill As Long
    
    Call AutoCalc(False)
    
    On Error Resume Next
    
    If Silent = False Then
        askkill = MsgBox(IIf(lng = 0, "Eliminare il punto di ripristino" & IIf(snapDesc = "", "", " '" & snapDesc & "'") & "?" & vbNewLine & _
                                            "N.B: Non sar|fffd| pi|fffd| possibile recuperarlo", _
                                  "Delete snapshot?"), _
                                  vbYesNo + vbExclamation, _
                                  IIf(lng = 0, "Conferma eliminazione", "Confirm delete"))
    Else
        askkill = vbYes
    End If
        
    If askkill = vbYes Then
        Application.DisplayAlerts = False
        Kill SnapFolder & strSnap
        Application.DisplayAlerts = True
    End If
    
    Call PurgeSnapshots
    
    Call AutoCalc(True)
End Sub

Sub PurgeSnapshots()
    Dim i As Long
    Dim uR As Long
    Dim nSnap As Long
    Dim maxSnap As Long
    Dim strFolder As String
    
    Call AutoCalc(False)
    
    'Esco se non esiste la cartella o il file degli snapshot
    If SnapLogFileExists(Silent:=True) = False Then Exit Sub
    
    strFolder = SnapFolder
    maxSnap = GetSettings("MaxSnapFiles")
    
    With wsSnap
        uR = .Cells(Rows.Count, 1).End(xlUp).Row
        For i = uR To 2 Step -1
                
            'Verifico che lo snapshot esista, e che non ci siano troppi snapshot su quel file
            If Dir(strFolder & .Cells(i, 2)) = "" Then
                On Error Resume Next
                Kill strFolder & .Cells(i, 2)
                .Rows(i).EntireRow.Delete
                On Error GoTo 0
            Else
                If maxSnap > 0 Then 'Se |fffd| 0 significa nessun limite
                    nSnap = Application.WorksheetFunction.CountIf(.UsedRange.Columns(1), .Cells(i, 1))
                    Do While nSnap > maxSnap
                        Err.Clear
                        On Error Resume Next
                        Kill strFolder & .Cells(i, 2)
                        .Rows(i).EntireRow.Delete
                        On Error GoTo 0
                        nSnap = nSnap - 1
                        i = i - 1
                    Loop
                End If
            End If
        Next i
    End With
    
    wbSnap.Close True
    
    Call AutoCalc(True)
    
End Sub

Private Sub CreateSnapLog()
    Dim wb As Workbook
    Dim wsSn As Worksheet
    
    On Error Resume Next
    If ValidateFolder(SnapFolder, True) = False Then Exit Sub
    
    Set wb = Workbooks.Add
    With wb
        .SaveAs SnapFolder & "ESK_Snapshots.xlsx"
        .Activate
        Set wsSn = ActiveSheet
        wsSn.Name = "Snapshots"
        
        With wsSn
            .Cells(1, 1) = "Filename"
            .Cells(1, 2) = "SnapName"
            .Cells(1, 3) = "Timestamp"
            .Cells(1, 4) = "FileSize"
            .Cells(1, 5) = "Notes"
        End With
        
        For Each ws In .Worksheets
            If Application.WorksheetFunction.CountA(ws.UsedRange) = 0 Then
                Application.DisplayAlerts = False
                ws.Delete
                Application.DisplayAlerts = True
            End If
        Next ws
        
        .Close (True)
    End With
    
    On Error GoTo 0
End Sub

Function SnapFolder() As String
    Dim newFolder As String
    
    newFolder = GetSettings("SnapFolderPath")
    
    If ValidateFolder(newFolder, True) <> False Then
        SnapFolder = newFolder
        Exit Function
    End If
    
    On Error Resume Next
    MkDir newFolder
    If Err.Number <> 0 Or newFolder = "" Then
        'Resetto SnapFolder a un'impostazione di default
        newFolder = ValidateFolder(CfgPath & pSep & "SnapShots")
        MkDir newFolder
    End If
    On Error GoTo 0
    
    Call UpdateConfigFile("SnapFolderPath", newFolder)
    SnapFolder = newFolder
    
End Function

Function SnapLogFileExists(Optional Silent As Boolean) As Boolean
    
    If Dir(SnapFolder & "ESK_Snapshots.xlsx") = "" Then
        Call CreateSnapLog
        
        'Controllo di nuovo: se non esiste ancora, vuol dire che |fffd| impossibile crearlo nel percorso definito nelle opzioni
        If Dir(SnapFolder & "ESK_Snapshots.xlsx") = "" Then
            If Silent = False Then
                MsgBox IIf(lng = 0, "Impossibile creare il file di log degli snapshot. Controlla di avere i diritti di scrittura sulla cartella definita nelle opzioni", _
                                    "Couldn't create snapshot log file. You need to have write permission to the path defined in the options"), vbInformation
            End If
        Else
            SnapLogFileExists = True
        End If
    Else
        SnapLogFileExists = True
    End If
    
End Function

Function wbSnap() As Workbook
    Dim sPath As String
    sPath = SnapFolder
    
    On Error Resume Next
    Set wbSnap = Workbooks("ESK_Snapshots.xlsx")
    If Err.Number <> 0 Then
        Set wbSnap = Workbooks.Open(sPath & "ESK_Snapshots.xlsx")
        wbSnap.Windows(1).visible = False
    End If
    On Error GoTo 0
End Function

Function wsSnap() As Worksheet
    On Error Resume Next
    'Definisco il foglio di riepilogo
    With wbSnap
        Set wsSnap = .Worksheets("SnapShots")
    End With
    On Error GoTo 0
End Function
Attribute VB_Name = "SwissKnife"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Public ws As Worksheet
Public wsBACKUP As Worksheet
Public FRow As Long
Public LRow As Long
Public fCol As Long
Public LCol As Long
Public cell As Range
Public InRng As Range
Public counter As Long
Public countermax As Long
Public counter2 As Long
Public countermax2 As Long
Public PctDone As Double
Public PctDone2 As Double
Public ProgressAborted As Long
Public BaseHeight As Double
Public TitleBarHeight As Double
Public pbShow As Boolean    'Mostra/Nascondi barra di progresso
Public strSQL As String
Dim myform As Object


Sub PivotTableClassic()
    Dim pt As PivotTable

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(60)
    
    Set ws = ActiveSheet
    
    If ws.PivotTables.Count = 0 Then
        MsgBox IIf(lng = 0, "Non sono state trovate tabelle pivot da convertire nel foglio attivo", _
                          "No pivot tables were detected in the active sheet"), _
                          vbInformation, _
                          IIf(lng = 0, "Tabelle pivot non rilevate", "No pivot tables detected")
    Else
        For Each pt In ActiveSheet.PivotTables
            pt.InGridDropZones = True
            pt.RowAxisLayout xlTabularRow
        Next pt
    End If
    
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub SplitSheet()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(47)
    
    Set myform = frmSplitSheet
    
    myform.Show

    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SaveToSeparateFiles()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(48)
    
    Set myform = frmSaveToSeparateFiles
    
    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub AppendSheets()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(46)
    
    Set myform = frmAppendSheets
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub ConvertTextToNumbers()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(22)
    
    Set myform = frmConvertTextToNumbers
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub Fill_Cells_Below()
    Dim i As Long
    Dim test As Long
    Dim j As Long
    Dim fRng As Range
    Dim fCount As Long
    Dim overwriteFormulas As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(38)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
        
    Set InRng = Selection
    If InRng.Rows.Count = ActiveSheet.Rows.Count Then 'Selezionate colonne o foglio intero: riduco allo Usedrange
        Set InRng = Intersect(InRng, ActiveSheet.UsedRange)
        If InRng Is Nothing Then
            Call AutoCalc(True)
            Exit Sub
        End If
    End If
        
    With InRng
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = .Cells.Count - .Rows(1).Cells.Count
        UProgress.SetDescription "Riempimento in basso in corso (" & countermax & " celle)..."
        Call ShowProgressBar
        
        'Verifico la presenza di formule con risultato nullo e nel caso chiedo l'eventuale sovrascrittura
        On Error Resume Next
        Set fRng = .Parent.Range(.Rows(2), .Rows(.Rows.Count)).SpecialCells(xlCellTypeFormulas)
        If Err.Number = 0 Then
            For Each cell In fRng.Cells
                If cell.Value = "" Then fCount = 1
                Exit For
            Next cell
            If fCount = 1 Then
                overwriteFormulas = MsgBox(IIf(lng = 0, _
                        "Sono state rilevate delle formule con risultato nullo nell'intervallo:" & _
                        vbNewLine & vbNewLine & _
                        "Si desidera SOVRASCRIVERE queste celle? Le formule verranno eliminate", _
                        "Formulas with NULL result have been detected within your range:" & _
                        vbNewLine & vbNewLine & _
                        "Do you want to OVERWRITE these cells? Formulas will be lost"), _
                        vbYesNo + vbExclamation, _
                        IIf(lng = 0, "Conferma sovrascrittura", "Confirm overwrite"))
            End If
        End If
        On Error GoTo 0
        
        
            
        For j = 1 To .Columns.Count
            For i = 2 To .Rows.Count
            
                '#' Aumento di 1 il contatore
                counter = counter + 1
                
                If .Rows(i).RowHeight > 0 And .Columns(j).ColumnWidth > 0 Then
                    
                    If overwriteFormulas = vbYes Then
                        If .Cells(i, j) = "" Then
                            test = i
                            Do While .Rows(test - 1).RowHeight = 0
                                test = test - 1
                            Loop
                            .Cells(i, j) = .Cells(test - 1, j)
                        End If
                    Else
                        If IsEmpty(.Cells(i, j)) Then
                            test = i
                            Do While .Rows(test - 1).RowHeight = 0
                                test = test - 1
                            Loop
                            .Cells(i, j) = .Cells(test - 1, j)
                        End If
                    End If
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next i
        Next j
    End With
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress

    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
        
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub UnFill_Below()
    Dim i As Long, test As Long
    Dim j As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(39)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    With Selection
    
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = .Cells.Count - .Rows(1).Cells.Count
        UProgress.SetDescription "Annullamento del riempimento in corso (" & countermax & " celle)..."
        Call ShowProgressBar
        
        For j = 1 To .Columns.Count
            For i = 2 To .Rows.Count
        
                '#' Aumento di 1 il contatore
                counter = counter + 1
            
                test = i - 1
                Do While IsEmpty(.Cells(test, j)) And test > 1
                    test = test - 1
                Loop
                
                If Not IsError(.Cells(i, j)) And Not IsError(.Cells(test, j)) Then
                    If .Cells(i, j).Value = .Cells(test, j).Value Then
                        .Cells(i, j).Value = ""
                    End If
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next i
        Next j
        
    End With
        
    '#' Chiudo la finestra di avanzamento
    Unload UProgress

    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub Fill_Cells_Right()
    Dim i As Long
    Dim test As Long
    Dim j As Long
    Dim fRng As Range
    Dim fCount As Long
    Dim overwriteFormulas As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(40)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
        
    On Error GoTo Aborted
    
    With Selection

        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = .Cells.Count - .Columns(1).Cells.Count
        UProgress.SetDescription "Riempimento a destra in corso (" & countermax & " celle)..."
        Call ShowProgressBar
    
        'Verifico la presenza di formule con risultato nullo e nel caso chiedo l'eventuale sovrascrittura
        On Error Resume Next
        Set fRng = .Parent.Range(.Rows(2), .Rows(.Rows.Count)).SpecialCells(xlCellTypeFormulas)
        If Err.Number = 0 Then
            For Each cell In fRng.Cells
                If cell.Value = "" Then fCount = 1
                Exit For
            Next cell
            If fCount = 1 Then
                overwriteFormulas = MsgBox(IIf(lng = 0, _
                        "Sono state rilevate delle formule con risultato nullo nell'intervallo:" & _
                        vbNewLine & vbNewLine & _
                        "Si desidera SOVRASCRIVERE queste celle? Le formule verranno eliminate", _
                        "Formulas with NULL result have been detected within your range:" & _
                        vbNewLine & vbNewLine & _
                        "Do you want to OVERWRITE these cells? Formulas will be lost"), _
                        vbYesNo + vbExclamation, _
                        IIf(lng = 0, "Conferma sovrascrittura", "Confirm overwrite"))
            End If
        End If
        On Error GoTo 0
    
        For i = 1 To .Rows.Count
            For j = 2 To .Columns.Count
                
                '#' Aumento di 1 il contatore
                counter = counter + 1
                
                If .Rows(i).RowHeight > 0 And .Columns(j).ColumnWidth > 0 Then
                    If overwriteFormulas = vbYes Then
                        If .Cells(i, j) = "" Then
                            test = j
                            Do While .Columns(test - 1).ColumnWidth = 0
                                test = test - 1
                            Loop
                            .Cells(i, j) = .Cells(i, test - 1)
                        End If
                    Else
                        If IsEmpty(.Cells(i, j)) Then
                            test = j
                            Do While .Columns(test - 1).ColumnWidth = 0
                                test = test - 1
                            Loop
                            .Cells(i, j) = .Cells(i, test - 1)
                        End If
                    End If
                End If
            
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next j
        Next i
        
    End With
        
    '#' Chiudo la finestra di avanzamento
    Unload UProgress

    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub UnFill_Right()
    Dim i As Long, test As Long
    Dim j As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(41)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
        
    With Selection
    
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = .Cells.Count - .Columns(1).Cells.Count
        UProgress.SetDescription "Annullamento del riempimento a destra in corso (" & countermax & " celle)..."
        Call ShowProgressBar
    
            For i = 1 To .Rows.Count
                For j = 2 To .Columns.Count
                    
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                    
                    test = j - 1
                    Do While IsEmpty(.Cells(i, test)) And test > fCol
                        test = test - 1
                    Loop
                    
                    If Not IsError(.Cells(i, j)) And Not IsError(.Cells(i, test)) Then
                        If .Cells(i, j).Value = .Cells(i, test).Value Then
                            .Cells(i, j).Value = ""
                        End If
                    End If
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                Next j
            Next i
            
        End With
        
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
        
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SelectShapes()
    Dim ShapesCount As Long
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(80)
    
    With ActiveSheet
        .Shapes.SelectAll
        ShapesCount = ShapesCount + .Shapes.Count
    End With

    
        If ShapesCount = 0 Then
            MsgBox "Non ci sono forme da selezionare nel foglio di lavoro corrente", vbInformation, "Risultato ricerca"
        Else
            MsgBox ShapesCount & " forme selezionate nel foglio di lavoro corrente", vbInformation, "Risultato ricerca"
        End If

    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub DeleteEmptyHiddenRC()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(33)
    
    Set myform = frmDeleteEmptyHiddenRC
    
    myform.Show
        
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
    
Sub AddBeforeAfter()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(13)
    
    Set myform = frmAddBeforeAfter
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub
    
Sub AddSheets()
    Dim wsNew As Worksheet
    Dim uniqueNames As New Collection
    Dim Item As Variant
    Dim ErrNum As Long
    Dim sCount As Long
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(45)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    
    On Error GoTo Aborted
    
    'Imposta range sulla selezione
    Set InRng = Selection
    
    On Error Resume Next
    For Each cell In InRng.Cells
        uniqueNames.Add cell.Value2, CStr(cell.Value2)
    Next cell
    On Error GoTo 0
    
    'Turn off AutoFilter
    AutoFilterOFF
    
    Call AutoCalc(False)
        
    'loop through the range in ws2
    For Each Item In uniqueNames
        
        sCount = sCount + 1
        
        'Add a new worksheet
        Set wsNew = Worksheets.Add(After:=Sheets(Sheets.Count))
        On Error Resume Next
        'Rinomina il foglio con il valore della cella (primi 31 caratteri). Se genera errore incrementa il contatore errori e cancella il foglio
        wsNew.Name = Left(CleanString(CStr(Item), "_", "sheet"), 31)
        If Err.Number > 0 Then
            Err.Clear
            ErrNum = ErrNum + 1
            Application.DisplayAlerts = False
            wsNew.Delete
            Application.DisplayAlerts = True
        End If
        On Error GoTo Aborted

    Next Item
    
    Call AutoCalc(True)
    
    If lng = 0 Then
        If ErrNum > 0 Then
            MsgBox "Si sono verificati " & ErrNum & " errori nella creazione di " & sCount & " nuovi fogli." & vbNewLine & "Si prega di verificare la presenza di nomi duplicati o caratteri non validi.", vbExclamation, "Errori nella creazione dei fogli"
        Else
            MsgBox "Creazione di " & sCount & " nuovi fogli completata", vbInformation, "Creazione fogli completata"
        End If
    Else
        If ErrNum > 0 Then
            MsgBox ErrNum & " errors occurred in trying to create " & sCount & " new sheets." & vbNewLine & "Please check for duplicate names or invalid characters.", vbExclamation, "Errors in adding new sheets"
        Else
            MsgBox "Ceation of " & sCount & " new sheets completed", vbInformation, "Sheets creation completed"
        End If
    End If
    
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub
    
Sub Unhide_Multiple_Sheets()
    Dim n As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(49)
    
       
    On Error GoTo Aborted
    
    n = 0
    For Each ws In ActiveWorkbook.Worksheets
        If ws.visible = xlSheetHidden Or ws.visible = xlSheetVeryHidden Then
            ws.visible = xlSheetVisible
            ws.Move After:=Worksheets(Worksheets.Count)
            n = n + 1
        End If
    Next ws
    
    If lng = 0 Then
        If n = 0 Then
            MsgBox "Non sono stati trovati fogli nascosti", vbInformation, "Esito operazione"
        Else
            MsgBox "Sono stati resi visibili " & n & " fogli nascosti", vbInformation, "Esito operazione"
        End If
    Else
        If n = 0 Then
            MsgBox "No hidden worksheets were found", vbInformation, "Result summary"
        Else
            MsgBox n & " hidden worksheets were made visible", vbInformation, "Result summary"
        End If
    End If
        
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub
    
Sub SortWorksheetsASC()
    Dim wb As Workbook
    Dim n As Long
    Dim m As Long
    Dim FirstWSToSort As Long
    Dim LastWSToSort As Long
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(43)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=True) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
         
    On Error GoTo Aborted
        
    Set wb = ActiveWorkbook
    
    If ActiveWindow.SelectedSheets.Count = 1 Then
        'Change the 1 to the worksheet you want sorted first
        FirstWSToSort = 1
        LastWSToSort = wb.Sheets.Count
    Else
        With ActiveWindow.SelectedSheets
            For n = 2 To .Count
                If .Item(n - 1).index <> .Item(n).index - 1 Then
                    MsgBox IIf(lng = 0, "Non |fffd| possibile ordinare fogli non adiacenti", _
                                        "Sorting of non-adjacent sheets is not allowed"), vbCritical
                    GoTo Aborted
                End If
            Next n
            FirstWSToSort = .Item(1).index
            LastWSToSort = .Item(.Count).index
        End With
    End If
     
    With wb
        For m = FirstWSToSort To LastWSToSort
            For n = m To LastWSToSort
                If Not .Sheets(m).visible = xlVeryHidden And Not .Sheets(n).visible = xlVeryHidden Then
                    If UCase(.Sheets(n).Name) < UCase(.Sheets(m).Name) Then
                        .Sheets(n).Move Before:=.Sheets(m)
                    End If
                End If
            Next n
        Next m
    End With
            
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub
    
Sub SortWorksheetsDESC()
    Dim wb As Workbook
    Dim n As Long
    Dim m As Long
    Dim FirstWSToSort As Long
    Dim LastWSToSort As Long
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(44)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=True) = vbNo Then Exit Sub
         
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
         
    On Error GoTo Aborted
         
    Set wb = ActiveWorkbook
     
    If ActiveWindow.SelectedSheets.Count = 1 Then
        'Change the 1 to the worksheet you want sorted first
        FirstWSToSort = 1
        LastWSToSort = wb.Sheets.Count
    Else
        With ActiveWindow.SelectedSheets
            For n = 2 To .Count
                If .Item(n - 1).index <> .Item(n).index - 1 Then
                    MsgBox IIf(lng = 0, "Non |fffd| possibile ordinare fogli non adiacenti", _
                                        "Sorting of non-adjacent sheets is not allowed"), vbCritical
                    GoTo Aborted
                End If
            Next n
            FirstWSToSort = .Item(1).index
            LastWSToSort = .Item(.Count).index
        End With
    End If
     
    With wb
        For m = FirstWSToSort To LastWSToSort
            For n = m To LastWSToSort
                If Not .Sheets(m).visible = xlVeryHidden And Not .Sheets(n).visible = xlVeryHidden Then
                    If UCase(.Sheets(n).Name) > UCase(.Sheets(m).Name) Then
                        .Sheets(n).Move Before:=.Sheets(m)
                    End If
                End If
            Next n
        Next m
    End With
            
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ConvertPct()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(24)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(MultiAllowed:=True, NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
        
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    For Each ws In ActiveWindow.SelectedSheets
    
        ws.Activate
        
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = Selection
             
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto convertendo le percentuali... (" & ws.Name & ")"
        Call ShowProgressBar
        
        'Clear formatting
        For Each cell In InRng.Cells
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            If cell.RowHeight > 0 _
                And cell.ColumnWidth > 0 _
                And Application.WorksheetFunction.IsNumber(cell) _
                And (cell.Style = "Percent" Or cell.NumberFormat = "Percent") Then
                    cell.Style = "Normal"
                    cell.NumberFormat = "General"
                    cell = cell * 100
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        Next cell
    
        '#' Chiudo la finestra di avanzamento
        Unload UProgress
    
    Next ws
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub InvertSelection()
    Dim rBig As Range
    Dim rSmall As Range
    Dim rNew As Range

    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(6)
    
    
    On Error GoTo Aborted
    
    Set rBig = ActiveSheet.UsedRange
    If TypeName(Selection) = "Range" Then
        Set rBig = Selection.Parent.UsedRange
        Set rSmall = Selection
    End If
    If Not rSmall Is Nothing Then
        For Each cell In rBig.Cells
            If Intersect(cell, rSmall) Is Nothing Then
                If rNew Is Nothing Then
                    Set rNew = cell
                Else
                    Set rNew = Union(rNew, cell)
                End If
            End If
        Next cell
    End If
    If Not rNew Is Nothing Then
        rNew.Select
    Else
        If lng = 0 Then
            MsgBox "Impossibile invertire la selezione", vbInformation
        Else
            MsgBox "Impossible to invert selection", vbInformation
        End If
    End If
    
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub SelectRows()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(4)
    
    Set myform = frmSelectRows
    
    myform.Show
        
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SelectCols()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(5)
    
    Set myform = frmSelectCols
    
    myform.Show
                
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub GroupRowsColumns()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(36)
    
    Set myform = frmGroupRowsColumns
    
    myform.Show
        
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub InsertRows()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(27)
    
   
    Set myform = frmInsertRows
    
    myform.Show
        
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub InsertColumns()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(28)
    
    Set myform = frmInsertColumns
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub Unselect()
    Dim OutRng As Range, DeleteRng As Range

    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(7)
    
    
    On Error GoTo Aborted
    
    Set InRng = Application.Selection
    If lng = 0 Then
        Set InRng = Application.InputBox("Selezionare l'intervallo iniziale", "Intervallo iniziale", _
                    Replace(InRng.address, ",", ";"), Type:=8)
    Else
        Set InRng = Application.InputBox("Please select initial range", "Initial range", _
                    Replace(InRng.address, ",", ";"), Type:=8)
    End If
    InRng.Select
    If lng = 0 Then
        Set DeleteRng = Application.InputBox("Evidenziare le celle da deselezionare", "Deselezione", Type:=8)
    Else
        Set DeleteRng = Application.InputBox("Highlight cells to deselect", "Deselection", Type:=8)
    End If
    
    Call RestoreRibbon
    
    For Each cell In InRng.Cells
        If Intersect(cell, DeleteRng) Is Nothing Then
            If OutRng Is Nothing Then
                Set OutRng = cell
            Else
                Set OutRng = Union(OutRng, cell)
            End If
        End If
    Next cell
    OutRng.Select
    
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt
    
    Exit Sub

Aborted:
    Call CanceledProcedure
    
    Application.EnableCancelKey = xlInterrupt


End Sub
Sub AdvancedPivot()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(37)
    
    Set myform = frmAdvancedPivot
    
    myform.Show

    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ImportMultipleFiles()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(66)
    
    Set myform = frmImportMultipleFiles
    
    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub AddIfError()
    Dim subChar As Variant
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(65)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(MultiAllowed:=True, NonDestructive:=False) = vbNo Then Exit Sub
    
    If lng = 0 Then
        subChar = InputBox("Inserisci il valore da visualizzare in caso di errore (default: """")", "Valore sostitutivo", "")
    Else
        subChar = InputBox("Type the value to show in case of error (default: """")", "Replacement value", "")
    End If
    
    If Not IsNumeric(subChar) Then subChar = """" & subChar & """"
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    For Each ws In ActiveWindow.SelectedSheets
    
        ws.Activate
        
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(Selection, ws).SpecialCells(xlCellTypeFormulas)
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
                
        Else
        
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto aggiungendo SE.ERRORE (" & countermax & " celle)..."
            Call ShowProgressBar
            
            For Each cell In InRng.Cells
                                
                '#' Aumento di 1 il contatore
                counter = counter + 1
                                
                If cell.RowHeight > 0 And cell.ColumnWidth > 0 Then
                    If Not cell.HasArray Then
                        cell.Formula = "=IFERROR(" & Mid(cell.Formula, 2) & "," & subChar & ")"
                    End If
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next cell
        
        End If
        
        '#' Chiudo la finestra di avanzamento
        Unload UProgress
    
    Next ws
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub Insert_international_formula()
    Dim strFormula As String
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(63)
    
           
    On Error GoTo Aborted
    
    strFormula = InputBox("Inserire la formula in lingua inglese", "Formula internazionale")
    ActiveCell.Formula = strFormula
    
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub Reset_Last_Cell()
    Dim wb As Workbook
    Dim LastCell As Range
    Dim RowClear As Long, ColClear As Long
    Dim wbPath As String
    Dim wbname As String
    Dim SaveConfirm As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(53)
    
       
    Call AutoCalc(False)
    
    Set ws = ActiveSheet
    Set wb = ws.Parent
    wbPath = wb.path
    wbname = wb.Name
        
    On Error GoTo Aborted
    
    For Each ws In ActiveWindow.SelectedSheets
        If ws.ProtectContents = False Then
        
            With ws
                .Activate
                Set LastCell = findlastcell(.Cells)
                RowClear = LastCell.Row + 1
                ColClear = LastCell.Column + 1
                
                .Range("A" & RowClear, "A" & .Rows.Count).EntireRow.Clear
                .Range(.Cells(1, ColClear), .Cells(1, .Columns.Count)).EntireColumn.Clear
            End With
        End If
    Next ws
    
    Call AutoCalc(True)
    
    SaveConfirm = MsgBox("L'ultima cella |fffd| stata impostata in tutti i fogli selezionati." & vbNewLine & vbNewLine & "Nessun dato |fffd| stato modificato, ma per memorizzare l'impostazione |fffd| necessario salvare il file. Procedere?", vbQuestion + vbYesNo, "Conferma salvataggio")
    
    If SaveConfirm = vbYes Then
        Call SaveFile(wb)
        MsgBox IIf(lng = 0, "Il file |fffd| stato salvato: ora premendo CTRL+Fine si andr|fffd| all'ultima cella effettivamente utilizzata", _
                          "File saved: pressing Ctrl+End will now take the cursor to the last actually used cell"), _
                          vbInformation, _
                          IIf(lng = 0, "File salvato", "File saved")
    Else
        MsgBox "Il file non |fffd| stato salvato: se si chiude il file senza salvarlo, l'ultima cella potrebbe non essere reimpostata correttamente.", vbInformation, "File non salvato"
    End If
    
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub PasteRowHeight()
    Dim SrcWs As Worksheet
    Dim i As Long, n As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(57)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=True) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    Set SrcWs = ActiveWindow.SelectedSheets.Item(1)
    
    n = InputBox("Indicare il numero di righe di cui si desidera riportare l'altezza sui fogli successivi:", _
        "Numero di righe", 100)
    
    On Error GoTo Aborted
    
    For Each ws In ActiveWindow.SelectedSheets
    
        ws.Activate
            
        For i = 1 To n
            ws.Rows(i).EntireRow.RowHeight = SrcWs.Rows(i).EntireRow.RowHeight
        Next i
    
    Next ws
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SplitCol()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(12)
    
    Set myform = frmSplitCol
    
    myform.Show
            
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub


Sub MeasurePrintArea()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(54)
    
       
    On Error GoTo Aborted
    
    If ActiveSheet.PageSetup.PrintArea = "" Then
        MsgBox ("Dimensioni dell'area di stampa:" & vbCrLf & vbCrLf & "Altezza: " & ActiveSheet.UsedRange.Height & " punti" & vbCrLf _
        & "Larghezza: " & ActiveSheet.UsedRange.Width & " punti")
    Else
        MsgBox ("Dimensioni dell'area di stampa:" & vbCrLf & vbCrLf & "Altezza: " & Range(ActiveSheet.PageSetup.PrintArea).Height & " punti" & vbCrLf _
        & "Larghezza: " & Range(ActiveSheet.PageSetup.PrintArea).Width & " punti")
    End If

    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ConditionalSelectCells()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(1)
    
    Set myform = frmConditionalSelectCells
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub JoinColumns()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(30)
    
    Set myform = frmJoinColumns
    
    myform.Show
        
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub JoinRows()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(29)
    
    Set myform = frmJoinRows
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub PrintExtLinksIndex()
    
    Dim sh As Object
    Dim alinks As Variant
    Dim reportWs As Worksheet
    Dim nextReportRow As Long
    Dim indexName As String
    Dim fRng As Range
    Dim LinksCount As Long
    Dim xChartCount As Long
    Dim xPTCount As Long
    Dim xSerColl As Variant
    Dim i As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(68)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=True) = vbNo Then Exit Sub
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    alinks = ActiveWorkbook.LinkSources(xlExcelLinks)
    If Not IsEmpty(alinks) Then        'there are links somewhere in the workbook
       
       indexName = "ESK_ExternalLinks"
    
       'Create the result sheet if one does not already exist
        On Error Resume Next
        Set reportWs = ActiveWorkbook.Worksheets(indexName)
        If Err.Number <> 0 Then
            Err.Clear
            Set reportWs = ActiveWorkbook.Worksheets.Add(Before:=ActiveWorkbook.Sheets(1))
            reportWs.Name = indexName
        End If
        On Error GoTo Aborted
    
       'Now start looking of linked data cells
       Set reportWs = ActiveWorkbook.Worksheets(indexName)
       reportWs.Cells.Clear
       reportWs.Range("A1") = "Foglio"
       reportWs.Range("B1") = "Cella"
       reportWs.Range("C1") = "Formula"
       reportWs.Range("D1") = "Link"
    
 
        For Each sh In ActiveWorkbook.Sheets
            If sh.Name <> reportWs.Name Then
                If TypeName(sh) = "Worksheet" Then
                    On Error Resume Next 'Per evitare l'errore "non |fffd| stata trovata alcuna cella"
                        Set fRng = sh.UsedRange.SpecialCells(xlCellTypeFormulas)
                        If Err.Number = 0 Then
                            For Each cell In fRng.Cells
                                If InStr(cell.Formula, "[") > 0 Then
                                    LinksCount = LinksCount + 1
                                    nextReportRow = reportWs.Range("A" & Rows.Count).End(xlUp).Row + 1
                                    reportWs.Range("A" & nextReportRow) = sh.Name
                                    reportWs.Range("B" & nextReportRow) = cell.address
                                    reportWs.Range("C" & nextReportRow) = "'" & cell.FormulaLocal
                                    reportWs.HyperLinks.Add anchor:=reportWs.Range("D" & nextReportRow), address:="", SubAddress:="'" & sh.Name & "'!" & cell.address, TextToDisplay:="[" & sh.Name & "]!" & cell.address
                                End If
                            Next cell
                        End If
                        Err.Clear
                    On Error GoTo Aborted
                                    
                    'Loop per verificare la presenza di tabelle pivot con collegamento esterno
                    xPTCount = sh.PivotTables.Count
                    For i = 1 To xPTCount
                        If InStr(sh.PivotTables(i).PivotCache.SourceData, "[") > 0 Then
                            LinksCount = LinksCount + 1
                            nextReportRow = reportWs.Range("A" & reportWs.Rows.Count).End(xlUp).Row + 1
                            reportWs.Range("A" & nextReportRow) = sh.Name
                            reportWs.Range("B" & nextReportRow) = sh.PivotTables(i).Name
                            reportWs.Range("C" & nextReportRow) = "'" & Mid(sh.PivotTables(i).PivotCache.SourceData, InStr(1, sh.PivotTables(i).PivotCache.SourceData, "["), InStr(1, sh.PivotTables(i).PivotCache.SourceData, "!") - 1 - InStr(1, sh.PivotTables(i).PivotCache.SourceData, "["))
                            reportWs.HyperLinks.Add anchor:=reportWs.Range("D" & nextReportRow), address:="", SubAddress:="'" & sh.Name & "'!$A$1", TextToDisplay:=sh.Name
                            Exit For
                        End If
                    Next i
                    
                    'Loop per verificare la presenza di grafici con collegamento esterno
                    xChartCount = sh.ChartObjects.Count
                    For i = 1 To xChartCount
                        sh.ChartObjects(i).Activate
                        For Each xSerColl In ActiveChart.SeriesCollection
                            If InStr(xSerColl.Formula, "[") > 0 Then
                                LinksCount = LinksCount + 1
                                nextReportRow = reportWs.Range("A" & Rows.Count).End(xlUp).Row + 1
                                reportWs.Range("A" & nextReportRow) = sh.Name
                                reportWs.Range("B" & nextReportRow) = sh.ChartObjects(i).Name
                                reportWs.Range("C" & nextReportRow) = Mid(xSerColl.FormulaLocal, 2)
                                reportWs.HyperLinks.Add anchor:=reportWs.Range("D" & nextReportRow), address:="", SubAddress:="'" & sh.Name & "'!$A$1", TextToDisplay:=sh.Name
                            End If
                        Next xSerColl
                    Next i
                
                ElseIf TypeName(sh) = "Chart" Then
                    sh.Activate
                    For Each xSerColl In ActiveChart.SeriesCollection
                        If InStr(xSerColl.Formula, "[") > 0 Then
                            LinksCount = LinksCount + 1
                            nextReportRow = reportWs.Range("A" & reportWs.Rows.Count).End(xlUp).Row + 1
                            reportWs.Range("A" & nextReportRow) = sh.Name
                            reportWs.Range("B" & nextReportRow) = ActiveChart.Name
                            reportWs.Range("C" & nextReportRow) = Mid(xSerColl.FormulaLocal, 2)
                            reportWs.Range("D" & nextReportRow) = "N.D."
                        End If
                    Next xSerColl
                End If
            
            End If
        Next sh   ' end sh loop
        
        With reportWs
            .Activate
            .UsedRange.Columns.AutoFit
    
            With .ListObjects.Add(xlSrcRange, .Range("$A$1").CurrentRegion, , xlYes)
                .Name = "IndiceEsterni"
                .TableStyle = "TableStyleMedium21"
                .Range.Rows(1).RowHeight = Application.WorksheetFunction.Max(1.75 * reportWs.StandardHeight, .Range.Rows(1).RowHeight)
                .Range.VerticalAlignment = xlVAlignCenter
                .DataBodyRange.EntireRow.RowHeight = 1.75 * reportWs.StandardHeight
                .DataBodyRange.Columns(2).HorizontalAlignment = xlCenter
                .DataBodyRange.Columns(5).HorizontalAlignment = xlCenter
            End With
        End With
        
        If lng = 0 Then
            MsgBox "Sono stati trovati " & LinksCount & " collegamenti esterni", vbInformation
        Else
            MsgBox LinksCount & " external links were found", vbInformation
        End If
    Else
        If lng = 0 Then
            MsgBox "Non sono stati trovati collegamenti esterni", vbInformation
        Else
            MsgBox "No external links were found", vbInformation
        End If
        
    End If
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub MirrorData()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(31)
    
    Set myform = frmMirrorData
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub RandomFill()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(42)
    
    Set myform = frmRandomFill
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub Compute()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(21)
    
    Set myform = frmCompute
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub FilterByTextFormat()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(3)
    
    Set myform = frmFilterByTextFormat
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ConvertCase()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(10)
    
    Set myform = frmConvertCase
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub
Sub RoundToNDecimals()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(26)
    
    Set myform = frmRoundToNDecimals
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub
Sub ImportPageSetup()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(61)
    
    Set myform = frmImportPageSetup
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub CompareRanges()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(9)
    
    Set myform = frmCompareRanges
        
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub AccentedVowels()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(11)
    
    Set myform = frmAccentedVowels
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub AddLeadingZeros()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(25)
    
    Set myform = frmAddLeadingZeros
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub
Sub MoveVisibleToRight()
    Dim i As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(73)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
        
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    Set ws = ActiveSheet
    
    ws.Activate
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = Selection.SpecialCells(xlCellTypeVisible)
    
         
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge
    UProgress.SetDescription "Sto effettuando lo spostamento a destra (" & countermax & " celle)..."
    Call ShowProgressBar

    'Turns Off Filter
    Call AutoFilterOFF(ws, 1)
         
    fCol = InRng.Column

    'Insert cells
    For Each cell In InRng.Cells

        '#' Aumento di 1 il contatore
        counter = counter + 1

        If cell.Column = fCol Then
            For i = 1 To InRng.Columns.Count
                cell.Insert (xlToRight)
            Next i
        End If

        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

    Next cell


    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ManageDuplicateRows()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(74)
    
    Set myform = frmManageDuplicateRows
    
    If Not RangeResize(Application.Selection, ActiveSheet) Is Nothing And TypeName(Application.Selection) = "Range" Then myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ManageDuplicateCells()
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(75)
    
    Set myform = frmManageDuplicateCells
    
    myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub CopyPasteMultipleSelection()
    Dim OutRng As Range
    Dim OutSheet As Worksheet, OutRow As Long, OutCol As Long
    Dim InSheet As Worksheet, InFRow As Long, InFCol As Long, InLRow As Long, InLCol As Long
    Dim i As Long, j As Long, m As Long, n As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(76)
    
       
    'If the user hits Cancel, exit sub
    On Error GoTo Aborted
    
    Set InRng = Application.InputBox("Selezionare gli intervalli da copiare:", "Aree da copiare", Replace(Application.Selection.address, ",", ";"), Type:=8)
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(InRng, ActiveSheet)
    If InRng Is Nothing Then
        MsgBox "Selezionare un intervallo di celle coerente con i dati del foglio"
        Exit Sub
    End If
        
    Set OutRng = Application.InputBox("Prima cella dell'area su cui incollare:" _
       & vbCrLf & vbCrLf & "ATTENZIONE: se l'area di incollamento si trova in un altro file, " _
       & "assicurarsi di avere il file aperto e selezionarlo dal menu 'Visualizza/Cambia finestra'", _
        "Area di incollamento", Type:=8)
        
    Set OutRng = OutRng.Cells(1, 1)
        
    Set InSheet = InRng.Parent
    InFRow = findfirstcell(InRng).Row
    InFCol = findfirstcell(InRng).Column
    InLRow = findlastcell(InRng).Row
    InLCol = findlastcell(InRng).Column
    
    With OutRng
        Set OutSheet = .Parent
        OutRow = .Row
        OutCol = .Column
    End With
    
    'Force the routine to begin from a visible cell
    With InSheet
        Do While .Rows(InFRow).RowHeight = 0
            InFRow = InFRow + 1
        Loop
        Do While .Columns(InFCol).ColumnWidth = 0
            InFCol = InFCol + 1
        Loop
    End With
    
    '#' Crea foglio di backup nascosto
    OutSheet.Activate
    Call backup_create_new
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge
    UProgress.SetDescription "Sto incollando le celle visibili..."
    Call ShowProgressBar

    
    
    For i = InFRow To InLRow
        For j = InFCol To InLCol
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            With InSheet
                If .Rows(i).RowHeight > 0 And .Columns(j).ColumnWidth > 0 Then
                    'Paste Routine
                        m = OutRow
                        n = OutCol
                        
                        'Find the closest visible cell to (m, n)
                        Do While OutSheet.Rows(m).RowHeight = 0
                            m = m + 1
                        Loop
                        Do While OutSheet.Columns(n).ColumnWidth = 0
                            n = n + 1
                        Loop
                        
                        'Paste clipboard content
                        If Not Intersect(.Cells(i, j), InRng) Is Nothing Then
                            'OutSheet.Cells(m, n).FormulaR1C1 = Formula2Copy '<== to paste formulas
                            'OutSheet.Cells(m, n) = .Cells(i, j)    '<== to paste values only
                            .Cells(i, j).Copy OutSheet.Cells(m, n)  '<== to paste formatting as well as values
                            Application.CutCopyMode = False
                        End If
                    'End of Paste routine
                End If
            End With
        'Before skipping to the next column of the input range, increase output column index by 1
        OutCol = n + 1
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

        Next j
    'Before skipping to the next row of the input range, increase output row index by 1 and reset column index to the first one used
    OutRow = m + 1
    OutCol = OutRng.Column
    Next i
           
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    OutSheet.Activate
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub RandomTxtFill()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(77)
    
    Set myform = frmRandomTxtFill
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub
Sub ReplaceRemoveChars()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(19)
    
    Set myform = frmReplaceRemoveChars
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub Recode()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(78)
    
    Set myform = frmRecode
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub JoinFiles()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(79)
    
    Set myform = frmJoinFiles
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ConvertFormulaRef()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(81)
    
    Set myform = frmConvertFormulaRef
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ShuffleRange()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(82)
    
    Set myform = frmShuffleRange
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub RandomSort()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(83)
    
    Set myform = frmRandomSort
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub RenameFiles()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(84)
    
    Set myform = frmRenameFiles
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub MakeDir()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(85)
    
    Set myform = frmMakeDir
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ExportRangeToImage()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(86)
    
    Set myform = frmExportRangeToImage
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt


End Sub


Sub CompactRange()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(87)
    
    Set myform = frmCompactRange
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt


End Sub

Sub PivotByGroups()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(88)
    
    Set myform = frmPivotByGroups
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt


End Sub


Sub ImportMultipleTXT()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(89)
    
    Set myform = frmImportMultipleTXT
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt


End Sub

Sub ExportRangeToASCII()
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(90)
    
    Set myform = frmExportRangeToASCII
    
    myform.Show
    
    Unload myform
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ImportExportCode()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(91)

    Set myform = frmImportExportCode

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub CopySheets()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(92)

    Set myform = frmCopySheets

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub RenameSheets()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(93)

    Set myform = frmRenameSheets

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub EmptyCells()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(94)

    Set myform = frmEmptyCells

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub RowsToColumns()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(95)

    Set myform = frmRowsToColumns

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub HyperLinks()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(96)

    Set myform = frmHyperLinks

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub PrintHyperLinksIndex()
    Dim reportWs         As Worksheet
    Dim nextReportRow    As Long
    Dim shtName          As String
    Dim bWsExists        As Boolean
    Dim LinksCount       As Long
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(97)
       
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=True) = vbNo Then Exit Sub
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    shtName = "ESK_HyperLinks"

    'Create the result sheet if one does not already exist
    For Each ws In ActiveWorkbook.Worksheets
        If ws.Name = shtName Then bWsExists = True
    Next ws
    
    If bWsExists = False Then
        Application.DisplayAlerts = False
        Set reportWs = ActiveWorkbook.Worksheets.Add(Type:=xlWorksheet)
        With reportWs
            .Name = shtName
            .Move Before:=ActiveWorkbook.Worksheets(1)
        End With
        Application.DisplayAlerts = True
    End If
    
    'Now start looking of linked data cells
    Set reportWs = ActiveWorkbook.Worksheets(shtName)
    reportWs.Cells.Clear
            
    If lng = 0 Then
        reportWs.Range("A1") = "Foglio"
        reportWs.Range("B1") = "Cella"
        reportWs.Range("C1") = "Nome del link"
        reportWs.Range("D1") = "Indirizzo del link"
    Else
        reportWs.Range("A1") = "Sheet"
        reportWs.Range("B1") = "Cell"
        reportWs.Range("C1") = "Hyperlink name"
        reportWs.Range("D1") = "Hyperlink address"
    End If
    
    For Each ws In ActiveWorkbook.Worksheets
        If ws.Name <> reportWs.Name Then
            For Each cell In ws.UsedRange.Cells
                If cell.HyperLinks.Count = 1 Then
                    LinksCount = LinksCount + 1
                    nextReportRow = reportWs.Range("A" & Rows.Count).End(xlUp).Row + 1
                    reportWs.Range("A" & nextReportRow) = ws.Name
                    reportWs.HyperLinks.Add anchor:=reportWs.Range("B" & nextReportRow), address:="", SubAddress:="'" & ws.Name & "'!" & cell.address, TextToDisplay:=cell.address
                    reportWs.Range("C" & nextReportRow) = cell.HyperLinks(1).Name
                    reportWs.Range("D" & nextReportRow) = cell.HyperLinks(1).address
                End If
            Next cell    ' end cell loop
        End If
    Next ws   ' end ws loop
            
    With reportWs
        .Activate
        .UsedRange.Columns.AutoFit

        With .ListObjects.Add(xlSrcRange, .Range("$A$1").CurrentRegion, , xlYes)
            .Name = "IndiceIpertestuali"
            .TableStyle = "TableStyleMedium21"
            .Range.Rows(1).RowHeight = Application.WorksheetFunction.Max(1.75 * reportWs.StandardHeight, .Range.Rows(1).RowHeight)
            .Range.VerticalAlignment = xlVAlignCenter
            .DataBodyRange.EntireRow.RowHeight = 1.75 * reportWs.StandardHeight
            .DataBodyRange.Columns(2).HorizontalAlignment = xlCenter
            .DataBodyRange.Columns(5).HorizontalAlignment = xlCenter
        End With
    End With
        
            
    If LinksCount > 0 Then
        
        reportWs.Activate
        reportWs.UsedRange.Columns.AutoFit
        
        If lng = 0 Then
            MsgBox "Sono stati trovati " & LinksCount & " collegamenti ipetrestuali", vbInformation
        Else
            MsgBox LinksCount & " hyperlinks were found", vbInformation
        End If
    Else
        If lng = 0 Then
            MsgBox "Non sono stati trovati collegamenti ipertestuali", vbInformation
        Else
            MsgBox "No hyperlinks were found", vbInformation
        End If
        
        '#' Cancello il foglio di report se non popolato
        Application.DisplayAlerts = False
        reportWs.Delete
        Application.DisplayAlerts = True
    End If
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub


Sub MoveDataBlocks()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(98)

    Set myform = frmMoveDataBlocks

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub MergeCells()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(99)

    Set myform = frmMergeCells

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub CopyPasteVisibleCells()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(100)
    
    If Val(Application.Version) >= 12 Then
        Set myform = frmCopyPasteVisibleCells

        myform.Show

        Unload myform
    
    Else
        Call CopyPasteVisibleCellsLegacy
    End If
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub CopyPasteVisibleCellsLegacy()
    Dim OutRng As Range
    Dim OutSheet As Worksheet
    Dim OutRow As Long
    Dim OutCol As Long
    Dim InSheet As Worksheet
    Dim InFRow As Long
    Dim InFCol As Long
    Dim InLRow As Long
    Dim InLCol As Long
    Dim i As Long
    Dim j As Long
    Dim m As Long
    Dim n As Long
    
    Application.EnableCancelKey = xlDisabled

    'If the user hits Cancel, exit sub
    On Error GoTo Aborted
    
    If lng = 0 Then
        Set InRng = Application.InputBox("Intervallo da copiare:", "Seleziona intervallo", Replace(Application.Selection.address, ",", ";"), Type:=8)
    Else
        Set InRng = Application.InputBox("Range to copy:", "Select range", Replace(Application.Selection.address, ",", ";"), Type:=8)
    End If
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(InRng, ActiveSheet)
    If InRng Is Nothing Then
        If lng = 0 Then
            MsgBox "Selezionare un intervallo di celle coerente con i dati del foglio", vbExclamation
        Else
            MsgBox "Please select a range consistent with worksheet data", vbExclamation
        End If
        Exit Sub
    End If
        
    If lng = 0 Then
        Set OutRng = Application.InputBox("Prima cella della colonna su cui incollare:" _
           & vbCrLf & vbCrLf & "ATTENZIONE: se l'area di incollamento si trova in un altro file, " _
           & "assicurarsi di avere il file aperto e selezionarlo dal menu 'Visualizza -> Cambia finestra'", _
            "Area di incollamento", Type:=8).Cells(1, 1)
    Else
        Set OutRng = Application.InputBox("First cell where to paste data:" _
           & vbCrLf & vbCrLf & "WARNING: if you want to paste on another file, " _
           & "please make sure that file is open and then select it via the 'View -> Switch Windows' menu", _
            "Area di incollamento", Type:=8).Cells(1, 1)
    End If
    
    Set InSheet = InRng.Parent
    InFRow = findfirstcell(InRng).Row
    InFCol = findfirstcell(InRng).Column
    InLRow = findlastcell(InRng).Row
    InLCol = findlastcell(InRng).Column
    
    With OutRng
        Set OutSheet = .Parent
        OutRow = .Row
        OutCol = .Column
    End With
    
    'Force the routine to begin from a visible cell
    With InSheet
        Do While .Rows(InFRow).RowHeight = 0
            InFRow = InFRow + 1
        Loop
        Do While .Columns(InFCol).ColumnWidth = 0
            InFCol = InFCol + 1
        Loop
    End With
    
    '#' Crea foglio di backup nascosto
    OutSheet.Activate
    Call backup_create_new
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge
    UProgress.SetDescription "Sto incollando le celle visibili..."
    UProgress.Show vbModeless
    
    For i = InFRow To InLRow
        For j = InFCol To InLCol
            
            '#' Aumento di 1 il contatore
            counter = counter + 1

            With InSheet
                If .Rows(i).RowHeight > 0 And .Columns(j).ColumnWidth > 0 Then
                    'Paste Routine
                        m = OutRow
                        n = OutCol
                        
                        'Find the closest visible cell to (m, n)
                        Do While OutSheet.Rows(m).RowHeight = 0
                            m = m + 1
                        Loop
                        Do While OutSheet.Columns(n).ColumnWidth = 0
                            n = n + 1
                        Loop
                        
                        'Paste clipboard content
                        If Not Intersect(.Cells(i, j), InRng) Is Nothing Then
                            OutSheet.Cells(m, n) = .Cells(i, j) '<== to paste values
                        End If
                    'End of Paste routine
                End If
            End With
        'Before skipping to the next column of the input range, increase output column index by 1
        OutCol = n + 1
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

        Next j
        'Before skipping to the next row of the input range, increase output row index by 1 and reset column index to the first one used
        OutRow = m + 1
        OutCol = OutRng.Column
    Next i
           
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    OutSheet.Activate
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub




Sub ReplaceFormulaResult()
    Dim result As Variant
    Dim subChar As Variant
        
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(101)
    
    '#' Richiesta di conferma all'utente
    If ConfirmExec(MultiAllowed:=True, NonDestructive:=False) = vbNo Then Exit Sub
    
    If lng = 0 Then
        result = InputBox("Inserisci il risultato della formula da sostituire (default: 0)", "Risultato da sostituire", 0)
        subChar = InputBox("Inserisci il valore sostitutivo da visualizzare (default: """")", "Valore sostitutivo", "")
    Else
        result = InputBox("Type the formula result to be replaced (default: 0)", "Result to be replaced", 0)
        subChar = InputBox("Type the replacement value to show (default: """")", "Replacement value", "")
    End If
    
    If Not IsNumeric(result) Then result = """" & result & """"
    If Not IsNumeric(subChar) Then subChar = """" & subChar & """"
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    For Each ws In ActiveWindow.SelectedSheets
    
        ws.Activate
        
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(Selection, ws)
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
                
        Else
        
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto sostituendo i risultati (" & countermax & " celle)..."
            Call ShowProgressBar
            
            For Each cell In InRng.SpecialCells(xlCellTypeFormulas).Cells
                                
                '#' Aumento di 1 il contatore
                counter = counter + 1
                                
                If cell.RowHeight > 0 And cell.ColumnWidth > 0 Then
                    If Not cell.HasArray Then
                        cell.Formula = "=IF(" & Mid(cell.Formula, 2) & " = " & result & ", " & subChar & ", " & Mid(cell.Formula, 2) & ")"
                    End If
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next cell
        
        End If
        
        '#' Chiudo la finestra di avanzamento
        Unload UProgress
    
    Next ws
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub CustomViews()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(102)

    Set myform = frmCustomViews

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub TableColors()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(103)

    Set myform = frmTableColors

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub TrimSpaces()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(104)

    Set myform = frmTrimSpaces

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub DeleteSheets()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(105)

    Set myform = frmDeleteSheets

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub Combinations()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(106)

    Set myform = frmCombinations

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub MoveSortColumns()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(107)

    Set myform = frmMoveSortColumns

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub


Sub PrintSheetsIndex()
    Dim reportWs As Worksheet
    Dim sh As Variant
    Dim cRow As Long
    Dim fName As String
    Const indexName As String = "ESK_Sheets"
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(108)
       
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=True) = vbNo Then Exit Sub
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    fName = Environ("Temp") & "\ESKTemp.xlsx"
            
    'Create the index sheet if one does not already exist
    On Error Resume Next
    Set reportWs = ActiveWorkbook.Worksheets(indexName)
    If Err.Number <> 0 Then
        Err.Clear
        Set reportWs = ActiveWorkbook.Worksheets.Add(Before:=ActiveWorkbook.Sheets(1))
        reportWs.Name = indexName
    End If
    On Error GoTo Aborted
            
    cRow = 2
    
    With reportWs
        
        .Activate
        .Cells.Clear
        
        If lng = 0 Then
            .Range("A1") = "Nome foglio"
            .Range("B1") = "Tipo foglio"
            .Range("C1") = "Visibile?"
            .Range("D1") = "Protetto?"
            .Range("E1") = "Contiene" & vbNewLine & "dati?"
            .Range("F1") = "Area utilizzata"
            .Range("G1") = "Contiene" & vbNewLine & "grafici?"
            .Range("H1") = "Contiene" & vbNewLine & "tabelle pivot?"
'            .Range("I1") = "Dimensione (in KB)"
        Else
            .Range("A1") = "Sheet name"
            .Range("B1") = "Sheet type"
            .Range("C1") = "Visible?"
            .Range("D1") = "Protected?"
            .Range("E1") = "Has data?"
            .Range("F1") = "Used range"
            .Range("G1") = "Has charts?"
            .Range("H1") = "Has pivot tables?"
'            .Range("I1") = "Size (in KB)"
        End If
    
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = ActiveWorkbook.Sheets.Count
        Call ShowProgressBar
        
        For Each sh In ActiveWorkbook.Sheets
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            If sh.Name <> indexName Then
                UProgress.SetDescription "Sto prelevando i dati dai fogli... (" & sh.Name & ")"
                
                'Scrivo il nome del foglio (con collegamento ipertestuale se visibile)
                If sh.visible = True And TypeName(sh) = "Worksheet" Then
                    .HyperLinks.Add anchor:=.Range("A" & cRow), address:="", SubAddress:="'" & sh.Name & "'!$A$1", TextToDisplay:=sh.Name
                Else
                    .Range("A" & cRow) = sh.Name
                End If
                
                'Scrivo il tipo di foglio
                Select Case TypeName(sh)
                    Case "Worksheet"
                        If sh.Type = 4 Or sh.Type = 3 Then
                            .Range("B" & cRow) = "Macro sheet"
                        Else
                            .Range("B" & cRow) = "Worksheet"
                        End If
                    Case Else
                        .Range("B" & cRow) = TypeName(sh)
                End Select
                
                'Scrivo la visibilit|fffd| del foglio
                If sh.visible = True Then
                    .Range("C" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                Else
                    .Range("C" & cRow) = "No"
                End If
                
                'Scrivo lo stato di protezione del foglio
                If sh.ProtectContents = True Then
                    .Range("D" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                Else
                    .Range("D" & cRow) = "No"
                End If
                
                'Scrivo se il foglio ha dati
                On Error Resume Next
                
                If TypeName(sh) = "Worksheet" Then
                    If Application.WorksheetFunction.CountA(sh.Cells) > 0 Then
                        .Range("E" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                    Else
                        .Range("E" & cRow) = "No"
                    End If
                Else
                    .Range("E" & cRow) = "No"
                End If
                
                'Scrivo l'area utilizzata
                If .Range("E" & cRow) = IIf(lng = 0, "S|fffd|", "Yes") Then .Range("F" & cRow) = sh.UsedRange.address
                
                'Scrivo se il foglio ha grafici
                If TypeName(sh) = "Worksheet" Then
                    If sh.ChartObjects.Count > 0 Then
                        .Range("G" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                    Else
                        .Range("G" & cRow) = "No"
                    End If
                ElseIf TypeName(sh) = "Chart" Then
                    .Range("G" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                Else
                    .Range("G" & cRow) = "No"
                End If
                
                'Scrivo se il foglio ha tabelle pivot
                If TypeName(sh) = "Worksheet" Then
                    If sh.PivotTables.Count > 0 Then
                        .Range("H" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                    Else
                        .Range("H" & cRow) = "No"
                    End If
                Else
                    .Range("H" & cRow) = "No"
                End If
                
'                'Scrivo la dimensione del foglio in KB
'                Application.DisplayAlerts = False
'                sh.Copy
'                ActiveWorkbook.SaveAs fName
'                ActiveWorkbook.Close (False)
'                .Range("I" & cRow) = ConvertFileLen(fName, "KB")
'                .Range("I" & cRow).NumberFormat = "#,##0.00"
'                Application.DisplayAlerts = True
                
                On Error GoTo 0
                On Error GoTo Aborted
                
                cRow = cRow + 1
            
            End If
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        Next sh
        
        .UsedRange.EntireColumn.AutoFit
    
        With .ListObjects.Add(xlSrcRange, .Range("$A$1").CurrentRegion, , xlYes)
            .Name = "IndiceFogli"
            .TableStyle = "TableStyleMedium21"
            .Range.Rows(1).RowHeight = Application.WorksheetFunction.Max(1.75 * reportWs.StandardHeight, .Range.Rows(1).RowHeight)
            .Range.VerticalAlignment = xlVAlignCenter
            .DataBodyRange.EntireRow.RowHeight = 1.75 * reportWs.StandardHeight
            .DataBodyRange.Columns(3).HorizontalAlignment = xlCenter
            .DataBodyRange.Columns(4).HorizontalAlignment = xlCenter
            .DataBodyRange.Columns(5).HorizontalAlignment = xlCenter
            .DataBodyRange.Columns(7).HorizontalAlignment = xlCenter
            .DataBodyRange.Columns(8).HorizontalAlignment = xlCenter
        End With
    
    End With
            
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
'    'Elimino il file temporaneo
'    Kill fName
'
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub



Sub PrintNamesIndex()
    Dim reportWs As Worksheet
    Dim nms As Variant
    Dim i As Long
    Dim cRow As Long
    Dim tmpRng As Range
    Dim tblAddress As String
    Const indexName As String = "ESK_nmIndex"
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(109)
       
    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=True) = vbNo Then Exit Sub
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    Set nms = ActiveWorkbook.Names
    
    
    'Create the index sheet if one does not already exist
    On Error Resume Next
    Set reportWs = ActiveWorkbook.Worksheets(indexName)
    If Err.Number <> 0 Then
        Err.Clear
        Set reportWs = ActiveWorkbook.Worksheets.Add(Before:=ActiveWorkbook.Sheets(1))
        reportWs.Name = indexName
    End If
    On Error GoTo 0
    On Error GoTo Aborted
            
    cRow = 2
    
    With reportWs
        
        .Activate
        .Cells.Clear
        
        If lng = 0 Then
            .Range("A1") = "Nome"
            .Range("B1") = "Indice"
            .Range("C1") = "Ambito"
            .Range("D1") = "Riferimento"
            .Range("E1") = "Nascosto?"
            .Range("F1") = "Commento"
        Else
            .Range("A1") = "Name"
            .Range("B1") = "Index"
            .Range("C1") = "Context"
            .Range("D1") = "Refers to"
            .Range("E1") = "Hidden?"
            .Range("F1") = "Comment"
        End If
        
        'Scrivo i dati relativi ai nomi definiti, se presenti
        If nms.Count <> 0 Then
            For i = 1 To nms.Count
                
                'Scrivo il nome del... nome definito
                .Range("A" & cRow) = nms(i).Name
                
                'Scrivo l'indice del nome definito
                .Range("B" & cRow) = nms(i).index
                
                'Scrivo l'ambito del nome definito
                Select Case TypeName(nms(i).Parent)
                    Case "Worksheet"
                        .Range("C" & cRow) = IIf(lng = 0, "Foglio di lavoro (", "Worksheet (") & nms(i).Parent.Name & ")"
                    Case "Workbook"
                        .Range("C" & cRow) = IIf(lng = 0, "Cartella di lavoro", "Workbook")
                    Case Else
                        .Range("C" & cRow) = nms(i).Parent.Name
                End Select
                
                'Scrivo il riferimento del nome definito
                .Range("D" & cRow) = Replace(nms(i).RefersToLocal, "=", "")
                On Error Resume Next
                Set tmpRng = Range(nms(i))
                If Err.Number = 0 Then .HyperLinks.Add anchor:=.Range("D" & cRow), address:="", SubAddress:=nms(i).RefersToLocal
                On Error GoTo 0
                
                'Scrivo la visibilit|fffd| del nome definito
                If nms(i).visible = True Then
                    .Range("E" & cRow) = "No"
                Else
                    .Range("E" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                End If
                
                'Scrivo il commento del nome definito
                .Range("F" & cRow) = nms(i).Comment
                
                cRow = cRow + 1
            
            Next i
            
        End If
        
        'Scrivo i dati dei range tabelle, se esistenti
        For Each ws In ActiveWorkbook.Worksheets
            
            If ws.ListObjects.Count > 0 Then
            
                For i = 1 To ws.ListObjects.Count
                    
                    With ws.ListObjects(i)
                        'Scrivo il nome della tabella
                        reportWs.Range("A" & cRow) = .Name
                        
                        'Scrivo il nome del foglio dove risiede la tabella
                        reportWs.Range("C" & cRow) = ws.Name
                        
                        'Scrivo l'indirizzo del range della tabella
                        tblAddress = Mid(.Range.address(External:=True), InStr(1, .Range.address(External:=True), "]") + 1)
                        reportWs.Range("D" & cRow) = tblAddress
                        On Error Resume Next
                        reportWs.HyperLinks.Add anchor:=reportWs.Range("D" & cRow), address:="", SubAddress:=tblAddress
                        On Error GoTo 0
                        
                        'Scrivo la visibilit|fffd| del nome definito
                        reportWs.Range("E" & cRow) = IIf(lng = 0, "S|fffd|", "Yes")
                        
                        'Scrivo il commento del nome definito
                        reportWs.Range("F" & cRow) = "Table range"
                        
                        cRow = cRow + 1
                    
                    End With
                
                Next i
            
            End If
        
        Next ws
        
        
        .UsedRange.EntireColumn.AutoFit
    
        If .UsedRange.Rows.Count = 1 Then
            MsgBox IIf(lng = 0, "Non sono presenti nomi definiti nel file attivo", "No defined names detected"), _
                    vbInformation, IIf(lng = 0, "Nessun nome definito", "No defined names")
            Application.DisplayAlerts = False
            .Delete
            Application.DisplayAlerts = True
        Else
            With .ListObjects.Add(xlSrcRange, .Range("$A$1").CurrentRegion, , xlYes)
                .Name = "IndiceNomi"
                .TableStyle = "TableStyleMedium21"
                .Range.Rows(1).RowHeight = Application.WorksheetFunction.Max(1.75 * reportWs.StandardHeight, .Range.Rows(1).RowHeight)
                .Range.VerticalAlignment = xlVAlignCenter
                .DataBodyRange.EntireRow.RowHeight = 1.75 * reportWs.StandardHeight
                .DataBodyRange.Columns(2).HorizontalAlignment = xlCenter
                .DataBodyRange.Columns(5).HorizontalAlignment = xlCenter
            End With
        End If
        
    End With
            
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ViewSettings()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(110)

    Set myform = frmViewSettings

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub UniqueList()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(111)

    Set myform = frmUniqueList

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ExportToWord()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(112)

    Set myform = frmExportToWord

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub DisasterRecovery()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(113)

    Set myform = frmDisasterRecovery

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub CrossTab()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(114)

    Set myform = frmCrossTab

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ShowSettings()
    frmSettings.Show
End Sub

Sub MultipleSort()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(115)

    Set myform = frmMultipleSort

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SelectUsedRange()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(116)

    On Error Resume Next
    ActiveSheet.UsedRange.Select
    On Error GoTo 0
    
    '#' Pulizia finale
    Call Cleanup
    
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SnapShots()

    Application.EnableCancelKey = xlDisabled

    Call CModInitialize

    Set myform = frmSnapShots

    If SnapLogFileExists(Silent:=True) = True Then myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SnapShotsManager()

    Application.EnableCancelKey = xlDisabled

    Call CModInitialize
    
    Set myform = frmSnapShotsManager

    If SnapLogFileExists(Silent:=True) = True Then myform.Show
    
    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub


Sub DeleteExtLinks()
    Dim sh As Object
    Dim fRng As Range
    Dim alinks As Variant
    Dim LinksCount As Long
    Dim fCount As Long
    Dim LinkSheetName As String
    Dim cF As String
    Dim ptCount As Long
    Dim chCount As Long
    Dim xChartCount As Long
    Dim xPTCount As Long
    Dim ptSd As String
    Dim xSerColl As Variant
    Dim strChFormula As String
    Dim i As Long
    Dim FinalReport As String
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(117)
       
    '#' Richiesta di conferma all'utente
    If ConfirmExec(MultiAllowed:=True, NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    alinks = ActiveWorkbook.LinkSources(xlExcelLinks)
    If Not IsEmpty(alinks) Then        'there are links somewhere in the workbook
      
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = ActiveWindow.SelectedSheets.Count
        UProgress.SetDescription "Sto eliminando i collegamenti..."
        Call ShowProgressBar
                
        For Each sh In ActiveWindow.SelectedSheets
            counter = counter + 1
            
            If TypeName(sh) = "Worksheet" Then
                On Error Resume Next 'Per evitare l'errore "non |fffd| stata trovata alcuna cella"
                    Set fRng = sh.UsedRange.SpecialCells(xlCellTypeFormulas)
                    If Err.Number = 0 Then
                        
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = fRng.Cells.Count
                    
                        For Each cell In fRng.Cells
                            
                            counter2 = counter2 + 1
                            
                            cF = cell.Formula
                            If InStr(cF, "[") > 0 Then
                                LinkSheetName = StrEstrai(cF, "[", "!", 1, 0) 'Mid(cF, InStr(1, cF, "]") + 1, InStr(1, cF, "!") - InStr(1, cF, "]") - 1)
                                fCount = fCount + 1
                                cF = Replace(cF, StrEstrai(cF, "[", IIf(UCase(LinkSheetName) = UCase(sh.Name), "!", "]"), 1, 1), "")
                                If InStr(1, cF, pSep) > 0 Then cF = Replace(cF, StrEstrai(cF, "'", pSep, , False, 1), "")
                                cF = Replace(cF, pSep, "")
                                cell.Formula = cF
                            End If
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                    End If
                    Err.Clear
                On Error GoTo Aborted
                
                'Loop per verificare la presenza di tabelle pivot con collegamento esterno
                xPTCount = sh.PivotTables.Count
                
                '#' Setto contatore secondario e suo massimo
                counter2 = 0
                countermax2 = xPTCount
                    
                For i = 1 To xPTCount
                    counter2 = counter2 + 1
                            
                    ptSd = sh.PivotTables(i).PivotCache.SourceData
                    If InStr(ptSd, "[") > 0 Then
                        ptCount = ptCount + 1
                        ptSd = Replace(ptSd, StrEstrai(ptSd, "[", "]", 1, 1), "")
                        If InStr(1, ptSd, pSep) > 0 Then ptSd = Replace(ptSd, StrEstrai(ptSd, "'", pSep, , False, 1), "")
                        ptSd = Replace(ptSd, pSep, "")
                        sh.PivotTables(i).ChangePivotCache sh.Parent.PivotCaches.Create(SourceType:=xlDatabase, SourceData:=ptSd)
                    End If
                            
                    '#' Aggiorna la barra di avanzamento secondaria
                    Call UpdateSubProgressBar(counter2, countermax2)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                Next i
                
                'Loop per verificare la presenza di grafici con collegamento esterno
                xChartCount = sh.ChartObjects.Count
                
                '#' Setto contatore secondario e suo massimo
                counter2 = 0
                countermax2 = xChartCount
                    
                For i = 1 To xChartCount
                    counter2 = counter2 + 1
                    sh.ChartObjects(i).Activate
                    For Each xSerColl In ActiveChart.SeriesCollection
                        If InStr(xSerColl.Formula, "[") > 0 Then
                            chCount = chCount + 1
                            strChFormula = xSerColl.Formula
                            strChFormula = Replace(strChFormula, StrEstrai(strChFormula, "[", "]", 1, 1), "")
                            If InStr(1, strChFormula, pSep) > 0 Then strChFormula = Replace(strChFormula, StrEstrai(strChFormula, "'", pSep, , False, 1), "")
                            strChFormula = Replace(strChFormula, pSep, "")
                            xSerColl.Formula = strChFormula
                        End If
                    Next xSerColl
                
                    '#' Aggiorna la barra di avanzamento secondaria
                    Call UpdateSubProgressBar(counter2, countermax2)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                Next i
            
            ElseIf TypeName(sh) = "Chart" Then
                sh.Activate
                For Each xSerColl In ActiveChart.SeriesCollection
                    If InStr(xSerColl.Formula, "[") > 0 Then
                        chCount = chCount + 1
                        strChFormula = xSerColl.Formula
                        strChFormula = Replace(strChFormula, StrEstrai(strChFormula, "[", "]", 1, 1), "")
                        If InStr(1, strChFormula, pSep) > 0 Then strChFormula = Replace(strChFormula, StrEstrai(strChFormula, "'", pSep, , False, 1), "")
                        strChFormula = Replace(strChFormula, pSep, "")
                        xSerColl.Formula = strChFormula
                    End If
                Next xSerColl
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            DoEvents
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        Next sh
        
        'Chiude la finestra di avanzamento
        Unload UProgress
        
        '#' Riattiva aggiornamenti automatici
        Call AutoCalc(True)
        
        LinksCount = fCount + ptCount + chCount
        
        If lng = 0 Then
            FinalReport = "RAPPORTO ELIMINAZIONE COLLEGAMENTI ESTERNI:" & vbNewLine & vbNewLine
            FinalReport = FinalReport & LinksCount & " eliminazioni complessive" & vbNewLine & vbNewLine
            FinalReport = FinalReport & "di cui: " & vbNewLine
            FinalReport = FinalReport & fCount & " da formule" & vbNewLine
            FinalReport = FinalReport & chCount & " da grafici" & vbNewLine
            FinalReport = FinalReport & ptCount & " da pivot"
            
            MsgBox FinalReport, vbInformation, "Rapporto finale"
        Else
            FinalReport = "EXTERNAL LINKS DELETION SUMMARY:" & vbNewLine & vbNewLine
            FinalReport = FinalReport & "Total: " & LinksCount & vbNewLine
            FinalReport = FinalReport & "of which: " & vbNewLine
            FinalReport = FinalReport & fCount & " from formulas" & vbNewLine
            FinalReport = FinalReport & chCount & " from charts" & vbNewLine
            FinalReport = FinalReport & ptCount & " from pivot tables"
            
            MsgBox FinalReport, vbInformation, "Summary"
        End If
        
    Else
        MsgBox IIf(lng = 0, "Non sono stati rilevati collegamenti esterni", "No external links were found"), vbInformation
    End If
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub ConvertFileFormat()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(118)

    Set myform = frmConvertFileFormat

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub EvaluateFormulaText()
    Dim oldvalue As Variant

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(119)

    '#' Richiesta di conferma all'utente
    If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
        
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    Set ws = ActiveSheet
    
    ws.Activate
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = Selection.SpecialCells(xlCellTypeVisible)
    
         
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge
    UProgress.SetDescription "Sto convertendo il testo in formule..."
    Call ShowProgressBar

    'Insert cells
    For Each cell In InRng.Cells

        '#' Aumento di 1 il contatore
        counter = counter + 1
        
        oldvalue = cell.Value
        
        cell.NumberFormat = "General"
        
        If Application.WorksheetFunction.IsNumber(cell) = False Then
            If InStr(1, Trim(cell.Value), "=") = 1 Then
                cell.FormulaLocal = Trim(cell.Value)
            Else
                On Error Resume Next
                cell.FormulaLocal = "=" & Trim(cell.Value)
                If IsError(Evaluate(cell.Formula)) = True Then
                    If Evaluate(cell.Formula) = CVErr(2029) Then    'Errore #NOME? -> Ho creato una formula inesistente
                        cell.Value = oldvalue
                    End If
                End If
                On Error GoTo 0
            End If
        End If
                
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

    Next cell


    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub GenerateSQL()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(120)

    Set myform = frmGenerateSQL

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub PrintCommentsIndex(Optional Silent As Boolean = False)
    Dim wb As Workbook
    Dim reportWs As Worksheet
    Dim i As Long
    Dim cRow As Long
    Dim NotesRng As Range
    Dim lObj As ListObject
    Dim blnFormat As Boolean
    Dim arrBold As Variant
    Dim arrItalic As Variant
    Dim arrUnderline As Variant
    Dim arrStrikethrough As Variant
    Dim arrSuperscript As Variant
    Dim arrSubscript As Variant
    Dim s As Long
    Dim cStart As Long
    Dim cEnd As Long
    Const indexName As String = "ESK_NotesIndex"
    
    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(121)
       
          
    '#' Richiesta di conferma all'utente
    If Silent = False Then
        If ConfirmExec(NonDestructive:=False) = vbNo Then Exit Sub
    End If
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    Set wb = ActiveWorkbook
    
    'Create the index sheet if one does not already exist
    On Error Resume Next
    Set reportWs = wb.Worksheets(indexName)
    If Err.Number = 0 Then
        Application.DisplayAlerts = False
        reportWs.Delete
        Application.DisplayAlerts = True
    End If
    
    Err.Clear
    Set reportWs = wb.Worksheets.Add(Before:=wb.Sheets(1))
    reportWs.Name = indexName
    On Error GoTo Aborted
            
    cRow = 2
    
    With reportWs
        
        .Activate
        .Cells.Delete Shift:=xlUp
        
        If lng = 0 Then
            .Range("A1") = "Foglio"
            .Range("B1") = "Indirizzo cella"
            .Range("C1") = "Contenuto cella"
            .Range("D1") = "Autore"
            .Range("E1") = "Testo del commento"
            .Range("F1") = "Sempre visibile?"
        Else
            .Range("A1") = "Sheet"
            .Range("B1") = "Cell address"
            .Range("C1") = "Cell content"
            .Range("D1") = "Author"
            .Range("E1") = "Comment text"
            .Range("F1") = "Always show?"
        End If
        .Range("E1").EntireColumn.ColumnWidth = 60
        
        If Silent = False Then
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = wb.Worksheets.Count - 1
            UProgress.SetDescription "Sto esportando i commenti..."
            Call ShowProgressBar
        End If
                
        'Scrivo i dati relativi ai nomi definiti, se presenti
        For Each ws In wb.Worksheets
            
            If ws.Name <> indexName And Silent = False Then
                UProgress.SetDescription "Sto esportando i commenti... (" & ws.Name & ")"
                counter = counter + 1
            End If
                                
            On Error Resume Next
            Set NotesRng = ws.UsedRange.SpecialCells(xlCellTypeComments)
            On Error GoTo Aborted
            
            If Not NotesRng Is Nothing Then
            
                If Silent = False Then
                    '#' Setto contatore secondario e suo massimo
                    counter2 = 0
                    countermax2 = NotesRng.Cells.Count
                End If
                
                For Each cell In NotesRng.Cells
                
                    counter2 = counter2 + 1
                                        
                    'Scrivo il nome del foglio
                    .Range("A" & cRow) = ws.Name
                    
                    'Scrivo l'indirizzo della cella con commento
                    .Range("B" & cRow) = cell.address
                    reportWs.HyperLinks.Add anchor:=reportWs.Range("B" & cRow), address:="", SubAddress:="'" & ws.Name & "'!" & cell.address, TextToDisplay:=cell.address
                    
                    'Scrivo il contenuto della cella con commento
                    .Range("C" & cRow) = cell.Value
                    
                    'Scrivo l'autore del commento
                    .Range("D" & cRow) = cell.Comment.Author
                    
                    'Scrivo il contenuto del commento
                    With cell.Comment.Shape.TextFrame
                        reportWs.Range("E" & cRow) = .Characters.Text
                            
                            '#' Valuto il testo in grassetto
                            If IsNull(.Characters.Font.Bold) Then
                                blnFormat = True
                            Else
                                blnFormat = CBool(.Characters.Font.Bold)
                            End If
                            
                            If blnFormat Then
                                ReDim arrBold(1 To Len(.Characters.Text), 1 To 2)
                                cStart = 0
                                cEnd = 0
                                i = 1
                                For s = 1 To Len(.Characters.Text)
                                    If .Characters(s, 1).Font.Bold = True Then
                                        If cStart <= cEnd Then
                                            cStart = s
                                            arrBold(i, 1) = cStart
                                        ElseIf s = Len(.Characters.Text) Then
                                            cEnd = s
                                            arrBold(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    Else
                                        If cStart > cEnd Then
                                            cEnd = s - 1
                                            arrBold(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    End If
                                Next s
                                
                                For i = 1 To UBound(arrBold, 1)
                                    If Not IsEmpty(arrBold(i, 1)) Then
                                        reportWs.Range("E" & cRow).Characters(arrBold(i, 1), arrBold(i, 2)).Font.Bold = True
                                    End If
                                Next i
                            End If
                            
                            '#' Valuto il testo in corsivo
                            If IsNull(.Characters.Font.Italic) Then
                                blnFormat = True
                            Else
                                blnFormat = CBool(.Characters.Font.Italic)
                            End If
                            
                            If blnFormat Then
                                ReDim arrItalic(1 To Len(.Characters.Text), 1 To 2)
                                cStart = 0
                                cEnd = 0
                                i = 1
                                For s = 1 To Len(.Characters.Text)
                                    If .Characters(s, 1).Font.Italic = True Then
                                        If cStart <= cEnd Then
                                            cStart = s
                                            arrItalic(i, 1) = cStart
                                        ElseIf s = Len(.Characters.Text) Then
                                            cEnd = s
                                            arrItalic(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    Else
                                        If cStart > cEnd Then
                                            cEnd = s - 1
                                            arrItalic(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    End If
                                Next s
                                
                                For i = 1 To UBound(arrItalic, 1)
                                    If Not IsEmpty(arrItalic(i, 1)) Then
                                        reportWs.Range("E" & cRow).Characters(arrItalic(i, 1), arrItalic(i, 2)).Font.Italic = True
                                    End If
                                Next i
                            End If
                            
                            '#' Valuto il testo sottolineato
                            If IsNull(.Characters.Font.Underline) Then
                                blnFormat = True
                            Else
                                blnFormat = CBool(.Characters.Font.Underline)
                            End If
                            
                            If blnFormat Then
                                ReDim arrUnderline(1 To Len(.Characters.Text), 1 To 2)
                                cStart = 0
                                cEnd = 0
                                i = 1
                                For s = 1 To Len(.Characters.Text)
                                    If .Characters(s, 1).Font.Underline <> False Then
                                        If cStart <= cEnd Then
                                            cStart = s
                                            arrUnderline(i, 1) = cStart
                                        ElseIf s = Len(.Characters.Text) Then
                                            cEnd = s
                                            arrUnderline(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    Else
                                        If cStart > cEnd Then
                                            cEnd = s - 1
                                            arrUnderline(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    End If
                                Next s
                                
                                For i = 1 To UBound(arrUnderline, 1)
                                    If Not IsEmpty(arrUnderline(i, 1)) Then
                                        reportWs.Range("E" & cRow).Characters(arrUnderline(i, 1), arrUnderline(i, 2)).Font.Underline = True
                                    End If
                                Next i
                            End If
                            
                            '#' Valuto il testo barrato
                            If IsNull(.Characters.Font.Strikethrough) Then
                                blnFormat = True
                            Else
                                blnFormat = CBool(.Characters.Font.Strikethrough)
                            End If
                            
                            If blnFormat Then
                                ReDim arrStrikethrough(1 To Len(.Characters.Text), 1 To 2)
                                cStart = 0
                                cEnd = 0
                                i = 1
                                For s = 1 To Len(.Characters.Text)
                                    If .Characters(s, 1).Font.Strikethrough = True Then
                                        If cStart <= cEnd Then
                                            cStart = s
                                            arrStrikethrough(i, 1) = cStart
                                        ElseIf s = Len(.Characters.Text) Then
                                            cEnd = s
                                            arrStrikethrough(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    Else
                                        If cStart > cEnd Then
                                            cEnd = s - 1
                                            arrStrikethrough(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    End If
                                Next s
                                
                                For i = 1 To UBound(arrStrikethrough, 1)
                                    If Not IsEmpty(arrStrikethrough(i, 1)) Then
                                        reportWs.Range("E" & cRow).Characters(arrStrikethrough(i, 1), arrStrikethrough(i, 2)).Font.Strikethrough = True
                                    End If
                                Next i
                            End If
                            
                            '#' Valuto il testo apice
                            If IsNull(.Characters.Font.Superscript) Then
                                blnFormat = True
                            Else
                                blnFormat = CBool(.Characters.Font.Superscript)
                            End If
                            
                            If blnFormat Then
                                ReDim arrSuperscript(1 To Len(.Characters.Text), 1 To 2)
                                cStart = 0
                                cEnd = 0
                                i = 1
                                For s = 1 To Len(.Characters.Text)
                                    If .Characters(s, 1).Font.Superscript = True Then
                                        If cStart <= cEnd Then
                                            cStart = s
                                            arrSuperscript(i, 1) = cStart
                                        ElseIf s = Len(.Characters.Text) Then
                                            cEnd = s
                                            arrSuperscript(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    Else
                                        If cStart > cEnd Then
                                            cEnd = s - 1
                                            arrSuperscript(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    End If
                                Next s
                                
                                For i = 1 To UBound(arrSuperscript, 1)
                                    If Not IsEmpty(arrSuperscript(i, 1)) Then
                                        reportWs.Range("E" & cRow).Characters(arrSuperscript(i, 1), arrSuperscript(i, 2)).Font.Superscript = True
                                    End If
                                Next i
                            End If
                            
                            '#' Valuto il testo pedice
                            If IsNull(.Characters.Font.Subscript) Then
                                blnFormat = True
                            Else
                                blnFormat = CBool(.Characters.Font.Subscript)
                            End If
                            
                            If blnFormat Then
                                ReDim arrSubscript(1 To Len(.Characters.Text), 1 To 2)
                                cStart = 0
                                cEnd = 0
                                i = 1
                                For s = 1 To Len(.Characters.Text)
                                    If .Characters(s, 1).Font.Subscript = True Then
                                        If cStart <= cEnd Then
                                            cStart = s
                                            arrSubscript(i, 1) = cStart
                                        ElseIf s = Len(.Characters.Text) Then
                                            cEnd = s
                                            arrSubscript(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    Else
                                        If cStart > cEnd Then
                                            cEnd = s - 1
                                            arrSubscript(i, 2) = cEnd - cStart + 1
                                            i = i + 1
                                        End If
                                    End If
                                Next s
                                
                                For i = 1 To UBound(arrSubscript, 1)
                                    If Not IsEmpty(arrSubscript(i, 1)) Then
                                        reportWs.Range("E" & cRow).Characters(arrSubscript(i, 1), arrSubscript(i, 2)).Font.Subscript = True
                                    End If
                                Next i
                            End If
                    End With
                                            
                    'Visibile o nascosto
                    .Range("F" & cRow) = IIf(cell.Comment.visible, IIf(lng = 0, "S|fffd|", "Yes"), "No")
                    
                    cRow = cRow + 1
                    
                    If Silent = False Then
                        '#' Aggiorna la barra di avanzamento secondaria
                        Call UpdateSubProgressBar(counter2, countermax2)
                        If ProgressAborted = 1 Then GoTo Aborted
                        On Error GoTo Aborted
                    End If
                
                Next cell
                        
                Set NotesRng = Nothing
            End If
        
            If Silent = False Then
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            End If
        
        Next ws
        
        '#' Chiudo la finestra di avanzamento
        If Silent = False Then Unload UProgress
                
        .UsedRange.EntireColumn.AutoFit
    
        If .UsedRange.Rows.Count = 1 Then
            MsgBox IIf(lng = 0, "Non sono presenti commenti nel file attivo", "No comments detected in the active workbook"), _
                    vbInformation, IIf(lng = 0, "Nessun commento esistente", "No existing comments")
            Application.DisplayAlerts = False
            .Delete
            Application.DisplayAlerts = True
        Else
            Set lObj = .ListObjects.Add(xlSrcRange, .Range("$A$1").CurrentRegion, , xlYes)
            With lObj
                .Name = "IndiceCommenti"
                .TableStyle = "TableStyleMedium21"
                .Range.Rows(1).RowHeight = Application.WorksheetFunction.Max(1.75 * reportWs.StandardHeight, .Range.Rows(1).RowHeight)
                .Range.VerticalAlignment = xlVAlignCenter
    '            .DataBodyRange.EntireRow.RowHeight = 1.75 * reportWs.StandardHeight
                .DataBodyRange.Columns(2).HorizontalAlignment = xlCenter
                .DataBodyRange.Columns(6).HorizontalAlignment = xlCenter
            End With
            
            On Error GoTo 0
            With .Shapes.AddFormControl(xlButtonControl, .Cells(1, 8).Left, .Cells(1, 8).Top + 4, 120, 60)
                .Name = "Update"
                .TextFrame.Characters.Text = IIf(lng = 0, "Aggiorna commenti", "Update comments")
                .OnAction = "'UpdateComments """ & wb.Name & """,""" & reportWs.Name & """,""" & lObj.Name & """ '"
                .Placement = xlFreeFloating
            End With
            
            ThisWorkbook.Worksheets("cnst_lng").Shapes("UpdateCommentsHelp").Copy
            .Paste
            Application.CutCopyMode = False
            .Shapes("UpdateCommentsHelp").Left = .Cells(1, 8).Left
            .Shapes("UpdateCommentsHelp").Top = .Cells(1, 8).Top + 100
        End If
        
    End With
            
    
    '#' Pulizia finale
    Call Cleanup
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub

Sub PivotToRange()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(122)

    Set myform = frmPivotToRange

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub SplitSheetToFiles()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(123)

    Set myform = frmSplitSheetToFiles

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub

Sub TableToRange()

    Application.EnableCancelKey = xlDisabled

    Call RecordLastRun(124)

    Set myform = frmTableToRange

    myform.Show

    Unload myform

    Application.EnableCancelKey = xlInterrupt

End Sub
Attribute VB_Name = "Translation"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''


'In questo modulo sono contenute le funzioni per tradurre i controlli dei form

Option Explicit
Option Private Module

Sub TranslateForm(form As Object, Optional newLng As Long = 999)
    Dim c As control
    Dim uR As Long
    Dim i As Long
    
    If newLng = 999 Then newLng = lng
    
    'TRADUZIONE TITOLO USERFORM
    With MenuSheet
        
        uR = .Cells(.Rows.Count, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)).End(xlUp).Row
        For i = 2 To uR
            If form.Name = .Cells(i, Application.WorksheetFunction.Match("ID_Userform", .Rows(1), 0)) Then
                form.Caption = .Cells(i, Application.WorksheetFunction.Match("label_it", .Rows(1), 0) + newLng)
                Exit For
            End If
        Next i
        
    End With
    
    'TRADUZIONE CONTROLLI USERFORM
    With ThisWorkbook.Worksheets("userforms_lng")
        
        For Each c In form.Controls
            If HasCaption(c) Then
                If c.Name = "lblDescription" Then
                    On Error Resume Next
                    c.Caption = MenuSheet.Cells(Application.Match(form.Name, MenuSheet.Columns(3), 0), Application.Match("desc_it", MenuSheet.Rows(1), 0) + newLng)
                    On Error GoTo 0
                Else
                    On Error Resume Next
                    c.Caption = .Cells(Application.Match(form.Name & "_" & c.Name, .Columns(1), 0), 2 + newLng)
                    On Error GoTo 0
                End If
            End If
        Next c
        
    End With
    
End Sub

Function TranslateCnst(cnst As String) As String
'TRADUZIONE COSTANTI (funzioni senza userform)
    
    With ThisWorkbook.Worksheets("cnst_lng")
    
        TranslateCnst = .Cells(Application.Match(cnst, .Columns(1), 0), 2 + lng)
    
    End With

End Function

Attribute VB_Name = "UProgress"
Attribute VB_Base = "0{0244927B-7B4B-48C3-938B-F53B3AC5DBC0}{BF961F43-2429-4353-BD8F-31A01118BC0D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim t1 As Double
Dim t2 As Double
Dim sommaT As Double


Private Sub UserForm_Initialize()
    ProgressAborted = 0
    With Me
        'Use a color from the workbook's theme
        On Error Resume Next
        .lblProgress.BackColor = ActiveWorkbook.Theme.ThemeColorScheme.Colors(msoThemeAccent1)
        On Error GoTo 0
        .lblProgress.Width = 0
        .lblprogress2.Width = 0
        If lng = 0 Then
            .Caption = "Avanzamento - " & CurrentProcedure
        Else
            .Caption = "Progress - " & CurrentProcedure
        End If
    End With
    
    Call ScaleForm(Me)
    
    t2 = Timer

End Sub

Public Sub UpdateProgress(PctDone As Double)
        
    If PctDone > 1 Then PctDone = 1
        
    t1 = t2
    t2 = Timer
    If t1 > 0 Then sommaT = sommaT + t2 - t1
        
    With Me
        .fraProgress.Caption = Format(PctDone, "0%") & "  -  " & _
            IIf(lng = 0, "Tempo stimato al termine: ", "Estimated time remaining: ") & _
            Format(TimeSerial(0, 0, sommaT + 0.3) / PctDone * (1 - PctDone), "hh:mm:ss")
        .lblProgress.Width = PctDone * (.fraProgress.Width - 10)
        .Repaint
    End With
End Sub

Public Sub UpdateProgress2(PctDone2 As Double)
        
    Me.Height = 152 * (GetSettings("Scale") / 100) * tmpScale
    
    Me.fraProgress2.visible = True
    Me.lblSubDescription.visible = True
    If PctDone2 > 1 Then PctDone2 = 1
    
    With Me
        .fraProgress2.Caption = Format(PctDone2, "0%")
        .lblprogress2.Width = PctDone2 * (.fraProgress2.Width - 10)
        .Repaint
    End With
End Sub

Public Sub SetDescription(Description As String)
    If lng = 0 Then
        Me.lblDescription.Caption = Description
    Else
        Me.lblDescription.Caption = "Executing..."
    End If
End Sub
Public Sub SetSubDescription(Description As String)
    If lng <> 0 Then Description = Replace(Description, "Foglio", "Sheet")
    Me.lblSubDescription.Caption = Description
End Sub

Private Sub cmdAbort_Click()
    Dim SureToAbort As Long
        
    If lng = 0 Then
        SureToAbort = MsgBox("Sei sicuro di voler interrompere l'esecuzione di " & Replace(CurrentProcedure, ProgramName, "") & "?" & _
                            vbNewLine & vbNewLine & "Una parte dell'elaborazione |fffd| gi|fffd| avvenuta e non pu|fffd| essere annullata, ma sar|fffd| possibile recuperare i dati originali dal foglio ""ESK_Backup"".", _
                            vbYesNo + vbExclamation, CurrentProcedure)
    Else
        SureToAbort = MsgBox("Are you sure you want to abort the execution of " & Replace(CurrentProcedure, ProgramName, "") & "?" & _
                            vbNewLine & vbNewLine & "Part of the processing has already happened and can't be rolled back, although the original data can be recovered from the worksheet ""ESK_Backup"".", _
                            vbYesNo + vbExclamation, CurrentProcedure)
    End If
        
    If SureToAbort = vbYes Then
        ProgressAborted = 1
        Unload Me
    Else
        Application.ScreenUpdating = True
        Application.ScreenUpdating = False
        DoEvents
    End If

End Sub

Attribute VB_Name = "UpdateCheck"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

'In questo modulo sono contenute le funzioni per il controllo aggiornamenti del programma

Option Explicit
Option Private Module

Public esk_online_version As String
Public esk_online_version_beta As String
Public esk_online_date As Date
Public esk_online_date_beta As Date
Public esk_installed_version As String
Public esk_installed_date As Date
Public esk_changelog As String
Public esk_installed_version_beta As String
Public esk_installed_date_beta As Date
Public esk_changelog_beta As String

Sub CheckUpdateOnStartup()
    'Controlla gli aggiornamenti all'avvio, solo dopo aver caricato il file
    
    On Error Resume Next
    If ActiveWorkbook Is Nothing Then
        Application.OnTime Now + TimeValue("00:00:05"), "CheckUpdateOnStartup"
        Exit Sub
    End If
    Call OnlineVersionCheck(True)
    On Error GoTo 0
End Sub

Sub OnlineVersionCheck(Optional Auto As Boolean)
    Dim xml_obj
    Dim my_url As String
    Dim my_url_beta As String
    Dim stime As Date
    Dim txt As String
    Dim txt_beta As String
    Dim v_start As Long
    Dim v_start_beta As Long
    Dim v_len As Long
    Dim v_len_beta As Long
    Dim d_start As Long
    Dim d_start_beta As Long
    Dim d_len As Long
    Dim d_len_beta As Long
    Dim log_start As Long
    Dim log_start_beta As Long
    Dim log_len As Long
    Dim log_len_beta As Long
    
    On Error Resume Next
    
    'Azzero le variabili pubbliche con i dati di versione
    esk_online_version = ""
    esk_online_date = 0
    esk_online_version_beta = ""
    esk_online_date_beta = 0
    esk_changelog = ""
    esk_changelog_beta = ""
    
    'Definisco le URL da cui estrarre i dati
    'my_url = "http://www.excelswissknife.com/changelog-test/" & "?dcli=" & Timer() * 100
    my_url = "http://www.excelswissknife.com/download/changelog/" & "?dcli=" & Timer() * 100
    my_url_beta = "http://www.excelswissknife.com/download/changelog-beta/" & "?dcli=" & Timer() * 100
    
   
    'Estraggo la sorgente del changelog stabile
    Set xml_obj = CreateObject("MSXML2.XMLHTTP")
    xml_obj.Open "GET", my_url, False
    xml_obj.Send
    stime = Now
    Do
        DoEvents
        If Now > stime + TimeValue("00:00:05") Then Exit Sub
    Loop Until xml_obj.readyState = 4
    txt = xml_obj.responseText
    Set xml_obj = Nothing
    
    'Estraggo la sorgente del changelog beta
    If GetSettings("CheckBetaUpdate") = 1 Then
        Set xml_obj = CreateObject("MSXML2.XMLHTTP")
        xml_obj.Open "GET", my_url_beta, False
        xml_obj.Send
        stime = Now
        Do
            DoEvents
            If Now > stime + TimeValue("00:00:05") Then Exit Sub
        Loop Until xml_obj.readyState = 4
        txt_beta = xml_obj.responseText
        Set xml_obj = Nothing
    End If
    
    'Estraggo versione, data e changelog
    'STABLE
    v_start = InStr(1, txt, "<strong>v.") + 11
    v_len = InStr(v_start, txt, "</strong>") - 13 - v_start
    esk_online_version = Mid(txt, v_start, v_len)
    
    d_start = v_start + v_len + 2
    d_len = 10
    esk_online_date = CDate(Mid(txt, d_start, d_len))
    
    log_start = InStr(1, txt, "latestlog") + 11
    log_len = InStr(log_start, txt, "&#8212;&#8212;&#8212;&#8212;&#8212;") - log_start
    esk_changelog = HtmlToText(Mid(txt, log_start, log_len))
    
    'BETA
    If GetSettings("CheckBetaUpdate") = 1 Then
        v_start_beta = InStr(1, txt_beta, "<strong>v.") + 11
        v_len_beta = InStr(v_start_beta, txt_beta, "</strong>") - 13 - v_start_beta
        esk_online_version_beta = Mid(txt_beta, v_start_beta, v_len_beta)
        
        d_start_beta = v_start_beta + v_len_beta + 2
        d_len_beta = 10
        esk_online_date_beta = CDate(Mid(txt_beta, d_start_beta, d_len_beta))
        
        log_start_beta = InStr(1, txt_beta, "latestlog") + 11
        log_len_beta = InStr(log_start_beta, txt_beta, "</span>") - log_start_beta
        esk_changelog_beta = HtmlToText(Mid(txt_beta, log_start_beta, log_len_beta))
    End If
    
    'Versione e data release installata sul PC
    esk_installed_version = Mid(Replace(ThisWorkbook.Names("ESKVersionNum").Value, """", ""), 2)
    esk_installed_date = CDate(Mid(Replace(ThisWorkbook.Names("ESKVersionDate").Value, """", ""), 2, 10))
    
    If Auto = True And _
       (esk_online_date > esk_installed_date Or _
            (esk_online_date_beta > esk_installed_date And _
            GetSettings("CheckBetaUpdate") = 1)) Then
            
        frmUpdateCheck.Show
    End If
    
    On Error GoTo 0
    
    Call UpdateConfigFile("LastUpdateCheck", Date)
    
End Sub

Function HtmlToText(sHTML) As String
    Dim html_doc

    Set html_doc = CreateObject("htmlfile")
    html_doc.body.innerHTML = sHTML
    HtmlToText = html_doc.body.innerText
End Function
Attribute VB_Name = "WSFunctions"
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''


'In questo modulo sono contenute le UDF

Option Explicit

Function ESK_SOMMA_SE_COLORE(intervallo As Range, cella_criterio As Range) As Double
Attribute ESK_SOMMA_SE_COLORE.VB_Description = "Questa funzione permette di sommare un intervallo di celle filtrate per il colore di riempimento (anche da formattazione condizionale). Accetta due argomenti: l'intervallo di celle da sommare e una cella ""esempio"" da cui prendere il colore di riempimento."
Attribute ESK_SOMMA_SE_COLORE.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim tCol As Long
    
    Application.Volatile
    
    tCol = ColorOfCF(cella_criterio)
    
    For Each cell In intervallo
        If ColorOfCF(cell) = tCol Then
            ESK_SOMMA_SE_COLORE = ESK_SOMMA_SE_COLORE + cell
        End If
    Next cell
    
End Function

Function ESK_SOMMA_SE_FONT(intervallo As Range, cella_criterio As Range) As Double
Attribute ESK_SOMMA_SE_FONT.VB_Description = "Questa funzione permette di sommare un intervallo di celle filtrate per il formato del carattere. Accetta due argomenti: l'intervallo di celle da sommare e una cella ""esempio"" da cui prendere il formato carattere (font, dimensioni, colore, grassetto etc.)"
Attribute ESK_SOMMA_SE_FONT.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim tFontName As String
    Dim tFontBold As Boolean
    Dim tFontItalic As Boolean
    Dim tFontUnderline As Variant
    Dim tFontStrike As Boolean
    Dim tFontColor As Long
    Dim tFontSize As Long
    Dim tFontSub As Boolean
    Dim tFontSup As Boolean
    
    Application.Volatile
    
    tFontName = cella_criterio.Font.Name
    tFontBold = cella_criterio.Font.Bold
    tFontItalic = cella_criterio.Font.Italic
    tFontUnderline = cella_criterio.Font.Underline
    tFontStrike = cella_criterio.Font.Strikethrough
    tFontColor = cella_criterio.Font.Color
    tFontSize = cella_criterio.Font.Size
    tFontSub = cella_criterio.Font.Subscript
    tFontSup = cella_criterio.Font.Superscript
    
    For Each cell In intervallo
        If cell.Font.Name = tFontName And _
        cell.Font.Bold = tFontBold And _
        cell.Font.Italic = tFontItalic And _
        cell.Font.Underline = tFontUnderline And _
        cell.Font.Strikethrough = tFontStrike And _
        cell.Font.Color = tFontColor And _
        cell.Font.Size = tFontSize And _
        cell.Font.Subscript = tFontSub And _
        cell.Font.Superscript = tFontSup Then
        ESK_SOMMA_SE_FONT = ESK_SOMMA_SE_FONT + cell
    End If
Next cell

End Function
Function ESK_CONTA_SE_COLORE(intervallo As Range, cella_criterio As Range) As Long
Attribute ESK_CONTA_SE_COLORE.VB_Description = "Questa funzione conta, in un intervallo, le celle con un determinato colore di riempimento (anche da formattazione condizionale). Accetta due argomenti: l'intervallo di celle da contare e una cella ""esempio"" da cui prendere il colore di riempimento"
Attribute ESK_CONTA_SE_COLORE.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim tCol As Long
    
    Application.Volatile
    
    tCol = ColorOfCF(cella_criterio)
    
    For Each cell In intervallo
        If ColorOfCF(cell) = tCol Then
            ESK_CONTA_SE_COLORE = ESK_CONTA_SE_COLORE + 1
        End If
    Next cell
    
End Function

Function ESK_CONTA_SE_FONT(intervallo As Range, cella_criterio As Range) As Long
Attribute ESK_CONTA_SE_FONT.VB_Description = "Questa funzione permette di contare un intervallo di celle filtrate per il formato del carattere. Accetta due argomenti: l'intervallo di celle da contare e una cella ""esempio"" da cui prendere il formato carattere (font, dimensioni, colore, grassetto etc.)"
Attribute ESK_CONTA_SE_FONT.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim tFontName As String
    Dim tFontBold As Boolean
    Dim tFontItalic As Boolean
    Dim tFontUnderline As Variant
    Dim tFontStrike As Boolean
    Dim tFontColor As Long
    Dim tFontSize As Long
    Dim tFontSub As Boolean
    Dim tFontSup As Boolean
    
    Application.Volatile
    
    tFontName = cella_criterio.Font.Name
    tFontBold = cella_criterio.Font.Bold
    tFontItalic = cella_criterio.Font.Italic
    tFontUnderline = cella_criterio.Font.Underline
    tFontStrike = cella_criterio.Font.Strikethrough
    tFontColor = cella_criterio.Font.Color
    tFontSize = cella_criterio.Font.Size
    tFontSub = cella_criterio.Font.Subscript
    tFontSup = cella_criterio.Font.Superscript
    
    For Each cell In intervallo
        If cell.Font.Name = tFontName And _
        cell.Font.Bold = tFontBold And _
        cell.Font.Italic = tFontItalic And _
        cell.Font.Underline = tFontUnderline And _
        cell.Font.Strikethrough = tFontStrike And _
        cell.Font.Color = tFontColor And _
        cell.Font.Size = tFontSize And _
        cell.Font.Subscript = tFontSub And _
        cell.Font.Superscript = tFontSup Then
        ESK_CONTA_SE_FONT = ESK_CONTA_SE_FONT + 1
    End If
Next cell

End Function

Function ESK_CONCATENA_INTERVALLI(separatore As String, incVuote As Boolean, ParamArray rng()) As String
Attribute ESK_CONCATENA_INTERVALLI.VB_Description = "Questa funzione semplifica il concatenamento di molti valori, in quanto accetta come terzo argomento uno o pi|fffd| intervalli di celle. I primi due argomenti sono un separatore tra i valori e un flag per l'inclusione o meno delle celle vuote."
Attribute ESK_CONCATENA_INTERVALLI.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim i As Long
    Dim str As String
    
    separatore = Replace(separatore, "^p", Chr(10))
    
    For i = LBound(rng) To UBound(rng)
        For Each cell In rng(i).Cells
            If cell.Value <> "" Or CBool(incVuote) = True Then
                str = str & separatore & cell.Value
            End If
        Next cell
    Next i
    
    ESK_CONCATENA_INTERVALLI = Mid(str, Len(separatore) + 1)
        
End Function


Function ESK_GINI(X As Range) As Double
Attribute ESK_GINI.VB_Description = "Questa funzione calcola l'indice di concentrazione di Gini sull'intervallo selezionato.\r\n\r\nSi ringrazia l'autore Michele De Meo (http://micheledemeo.blogspot.com)"
Attribute ESK_GINI.VB_ProcData.VB_Invoke_Func = " \n19"
    
    '#' AUTORE: MICHELE DE MEO
    '#' http://micheledemeo.blogspot.com/
    
    Dim tb As Variant
    Dim h As Long
    Dim k As Long
    Dim i As Long
    Dim j As Long
    Dim num As Double
    Dim den As Double
    
    tb = X.Value
    
    num = 0
    den = 0
    For h = 1 To UBound(tb, 1)
        For k = 1 To UBound(tb, 2)
            If IsNull(tb(h, k)) Then
                tb(h, k) = 0
            End If
            den = den + tb(h, k)
            For i = 1 To UBound(tb, 1)
                For j = 1 To UBound(tb, 2)
                    num = num + Abs(tb(h, k) - tb(i, j))
                Next j
            Next i
        Next k
    Next h
    
    num = num / (UBound(tb, 1) * UBound(tb, 2) * (UBound(tb, 1) * UBound(tb, 2) - 1)) '#' INDICE DI DISUGUAGLIANZA
    den = 2 * den / (UBound(tb, 1) * UBound(tb, 2)) '#' MASSIMO DELL'INDICE DI DISUGUAGLIANZA
    
    If den = 0 Then
        ESK_GINI = 1
    Else
        ESK_GINI = num / den
    End If
    
End Function

Function ESK_NORMALIZZA_MINMAX(Valore As Range, intervallo As Range, nMin As Double, nMax As Double)
Attribute ESK_NORMALIZZA_MINMAX.VB_Description = "Questa funzione permette di normalizzare un intervallo, cambiandone la scala tra un minimo e un massimo fissati dall'utente."
Attribute ESK_NORMALIZZA_MINMAX.VB_ProcData.VB_Invoke_Func = " \n19"
    
    ESK_NORMALIZZA_MINMAX = nMin + (((Valore - WorksheetFunction.Min(intervallo)) / _
    (WorksheetFunction.Max(intervallo) - WorksheetFunction.Min(intervallo))) * (nMax - nMin))
End Function

Function ESK_ORDINE_PAROLE(stringa As String, ordine As String, Optional separatore As String = " ") As String
Attribute ESK_ORDINE_PAROLE.VB_Description = "Questa funzione permette di cambiare l'ordine delle parole di una cella, seguendo un nuovo ordine indicato dall'utente. Pu|fffd| inoltre essere utilizzata per estrapolare solo alcune delle parole contenute nella stringa iniziale"
Attribute ESK_ORDINE_PAROLE.VB_ProcData.VB_Invoke_Func = " \n19"
'Esempi:
'=ESK_ORDINE_PAROLE(A1;"3|2|4|1")
'=ESK_ORDINE_PAROLE(A1;"a-z";",")
'=ESK_ORDINE_PAROLE(A1;"z-a";"-")

    Dim arrOrd
    Dim arrStr
    Dim tempValue As Variant
    Dim i As Long
    Dim j As Long
    
    arrOrd = Split(ordine, "|")
    arrStr = Split(stringa, separatore)
    
    If UCase(ordine) = "A-Z" Or UCase(ordine) = "Z-A" Then
        Select Case UCase(ordine)
            Case "A-Z"
                For i = LBound(arrStr) To UBound(arrStr) - 1
                    For j = i + 1 To UBound(arrStr)
                        If arrStr(j) < arrStr(i) Then
                            tempValue = arrStr(i)
                            arrStr(i) = arrStr(j)
                            arrStr(j) = tempValue
                        End If
                    Next j
                Next i
            Case "Z-A"
                For i = LBound(arrStr) To UBound(arrStr) - 1
                    For j = i + 1 To UBound(arrStr)
                        If arrStr(j) > arrStr(i) Then
                            tempValue = arrStr(j)
                            arrStr(j) = arrStr(i)
                            arrStr(i) = tempValue
                        End If
                    Next j
                Next i
        End Select
        
        ESK_ORDINE_PAROLE = Join(arrStr, separatore)
                
            
    Else
        On Error Resume Next
        For i = LBound(arrOrd) To UBound(arrOrd)
            ESK_ORDINE_PAROLE = ESK_ORDINE_PAROLE & separatore & arrStr(arrOrd(i) - 1)
        Next i
        On Error GoTo 0
        
        ESK_ORDINE_PAROLE = Mid(ESK_ORDINE_PAROLE, Len(separatore) + 1)
    End If
    
End Function

Function ESK_ESTRAI_NUMERI(stringa As String) As Double
Attribute ESK_ESTRAI_NUMERI.VB_Description = "Questa funzione ""estrae"" da una cella i soli numeri (0-9), cancellando tutti gli altri caratteri eventualmente presenti."
Attribute ESK_ESTRAI_NUMERI.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim i As Long
    Dim newstr As String
    
    For i = 1 To Len(stringa)
        If Asc(Mid(stringa, i, 1)) > 47 And Asc(Mid(stringa, i, 1)) < 58 Then
            newstr = newstr & Mid(stringa, i, 1)
        End If
    Next i
    
    ESK_ESTRAI_NUMERI = newstr
End Function

Function ESK_ESTRAI_HYPERLINK(c As Range, Optional link As Boolean = True) As String
Attribute ESK_ESTRAI_HYPERLINK.VB_Description = "Questa funzione estrae da una cella l'indirizzo a cui punta il collegamento ipertestuale che contiene, oppure il nome visualizzato privo del collegamento. Se non si specifica il secondo argomento, di default verr|fffd| estratto l'indirizzo."
Attribute ESK_ESTRAI_HYPERLINK.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim newstr As String
    
    If c.HyperLinks.Count > 0 Then
        If link = True Then
            newstr = Replace(c.HyperLinks(1).address, "mailto:", "")
        Else
            newstr = c.HyperLinks(1).Name
        End If
    End If
    
    ESK_ESTRAI_HYPERLINK = newstr
End Function

Function ESK_STRINGACOMUNE(ParamArray r()) As String
Attribute ESK_STRINGACOMUNE.VB_Description = "Questa funzione individua la stringa pi|fffd| lunga in comune a tutte le celle dell'intervallo selezionato, a prescindere dalla posizione in cui essa si trova all'interno della cella."
Attribute ESK_STRINGACOMUNE.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim minLen As Long
    Dim smCell As Range
    Dim n As Long
    Dim i As Long
    Dim X As Long
    Dim fCount As Long
    Dim strFind As String
    Dim commonStr As String
    Dim totalcount As Long
    
        
    minLen = 99999999
    For n = LBound(r) To UBound(r)
        For Each cell In r(n).Cells
            totalcount = totalcount + 1
            If Len(cell) > 0 Then
                minLen = Application.WorksheetFunction.Min(minLen, Len(cell))
                If Len(cell) = minLen Then
                    Set smCell = cell
                End If
            End If
        Next cell
    Next n
        
    For i = 1 To minLen
        For X = minLen - i + 1 To 1 Step -1
            fCount = 0
            strFind = Mid(smCell, i, X)
            
            For n = LBound(r) To UBound(r)
                For Each cell In r(n).Cells
                    If InStr(1, cell, strFind) > 0 Then fCount = fCount + 1 Else Exit For
                Next cell
            Next n
            
            If fCount = totalcount Then
                If Len(strFind) > Len(commonStr) Then commonStr = strFind
                Exit For
            End If
        Next X
    Next i
    
    ESK_STRINGACOMUNE = commonStr
    
End Function

Function ESK_MEDIA_MOBILE(t2 As Range, intervallo As Range, classe As Long) As Variant
Attribute ESK_MEDIA_MOBILE.VB_Description = "Questa funzione calcola la media mobile su una serie di valori posti su un'unica colonna, dove ""ultimo elemento"" |fffd| l'ultimo di un sottoinsieme di elementi di cardinalit|fffd| ""classe""."
Attribute ESK_MEDIA_MOBILE.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim Primariga As Long
    Dim Ultimariga As Long
    
    With intervallo
        Primariga = .Row
        Ultimariga = .Rows.Count + .Row - 1
        
        If Not (t2.Row - classe + 1) < Primariga Then
            ESK_MEDIA_MOBILE = Application.WorksheetFunction.Average(Range(t2.Offset(-classe + 1, 0), t2))
        Else
            ESK_MEDIA_MOBILE = CVErr(xlErrNA)
        End If
        
    End With
    
End Function

Function ESK_MEDIA_MOBILE_SIMMETRICA(centro As Range, intervallo As Range, classe As Long) As Variant
Attribute ESK_MEDIA_MOBILE_SIMMETRICA.VB_Description = "Questa funzione calcola la media mobile simmetrica su una serie di valori posti su un'unica colonna, dove ""centro"" |fffd| l'elemento intermedio di un sottoinsieme di elementi di cardinalit|fffd| ""classe""."
Attribute ESK_MEDIA_MOBILE_SIMMETRICA.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim Semiclasse As Long
    Dim Pari As Boolean
    Dim Primariga As Long
    Dim Ultimariga As Long
    
    Pari = (classe Mod 2 = 0)
    
    If Pari = True Then
        Semiclasse = (classe - 2) / 2
    Else
        Semiclasse = (classe - 1) / 2
    End If
    
    With intervallo
        Primariga = .Row
        Ultimariga = .Rows.Count + .Row - 1
        
        If Not (centro.Row - Semiclasse - (Abs(CInt(Pari)))) < Primariga _
        And Not (centro.Row + Semiclasse + (Abs(CInt(Pari)))) > Ultimariga Then
        
        If Pari = True Then
            ESK_MEDIA_MOBILE_SIMMETRICA = (Application.WorksheetFunction.Sum(Range(centro.Offset(-Semiclasse, 0), centro.Offset(Semiclasse, 0)), ((centro.Offset(-Semiclasse - 1, 0) + centro.Offset(Semiclasse + 1, 0)) / 2))) / classe
        Else
            ESK_MEDIA_MOBILE_SIMMETRICA = Application.WorksheetFunction.Average(Range(centro.Offset(-Semiclasse, 0), centro.Offset(Semiclasse, 0)))
        End If
        
    Else
        ESK_MEDIA_MOBILE_SIMMETRICA = CVErr(xlErrNA)
    End If
    
End With

End Function

Function ESK_CERCAVERT_SIMILE(cVal As Range, r As Range, colris As Long, Optional colric As Long = 1, Optional minparola As Long = 3) As Variant
Attribute ESK_CERCAVERT_SIMILE.VB_Description = "Questa funzione lavora in modo simile al CERCA.VERT, ma permette di trovare corrispondenze anche in caso di testo ""simile"", ma non uguale. I valori vengono divisi in ""parole"", di cui |fffd| possibile impostare la lunghezza minima affinch|fffd| vengano confrontate."
Attribute ESK_CERCAVERT_SIMILE.VB_ProcData.VB_Invoke_Func = " \n19"
    Dim result
    Dim matr As Variant
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim X As Long
    Dim soglia As Long
    Dim tmpcVal As Collection
    Dim parolecVal As Collection
    Dim paroleColric As Collection
    Dim check As Long
    Dim ok As Long
    Dim found As Boolean
    Dim maxCval As Long
    
    'Ridimensiono il range di ricerca
    Set r = Intersect(r, r.Parent.UsedRange)
    
    'Controlli di coerenza parametri
    On Error Resume Next
    If TypeName(r) <> "Range" Or _
    colris > r.Columns.Count Or _
    colric <= 0 Or _
    colric > r.Columns.Count Or _
    minparola <= 0 Then
    ESK_CERCAVERT_SIMILE = CVErr(xlErrValue)
    Exit Function
End If
On Error GoTo 0


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''' Per tutti i livelli di precisione: cerco prima una corrispondenza esatta con VLookup ''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

On Error Resume Next
result = Application.WorksheetFunction.index(r, Application.WorksheetFunction.Match(cVal, r.Columns(colric), 0), colris)
If Err.Number = 0 Then
    ESK_CERCAVERT_SIMILE = result
    found = True
    GoTo CloseFunction
End If
On Error GoTo 0


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''  Primo step: il valore cercato deve essere contenuto nel range di ricerca   ''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'il valore cercato |fffd| tutto contenuto nel range di ricerca
On Error Resume Next
result = Application.WorksheetFunction.index(r, Application.WorksheetFunction.Match("*" & Trim(cVal) & "*", r.Columns(colric), 0), colris)
If Err.Number = 0 Then
    ESK_CERCAVERT_SIMILE = result
    found = True
    GoTo CloseFunction
End If
On Error GoTo 0


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''' Secondo step: Almeno (n/n-1/.../(n/2)) parole del valore cercato sono contenute in parole nel range di ricerca, o viceversa ''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'Assegnazione del range alla matrice (correzione nel caso di matrice di una sola cella)
If r.Cells.Count = 1 Then
    matr = r.reSize(1, 2)
    ReDim Preserve matr(1 To 1, 1 To 1)
Else
    matr = r
End If

Set tmpcVal = StrToCollection(cVal, minparola)
maxCval = tmpcVal.Count

For soglia = maxCval To Application.WorksheetFunction.RoundUp(maxCval / 2, 0) Step -1
    
    For i = 1 To UBound(matr, 1)
        
        Set paroleColric = Nothing
        Set paroleColric = StrToCollection(matr(i, colric), minparola)
        
        If paroleColric.Count >= soglia Then
            
            Set parolecVal = Nothing
            Set parolecVal = New Collection
            For X = 1 To maxCval
                parolecVal.Add tmpcVal(X)
            Next X
            
            ok = 0
            
            For j = 1 To parolecVal.Count
                check = 0
                For k = 1 To paroleColric.Count
                    If (Len(parolecVal(j)) * 2 >= Len(paroleColric(k))) And (Len(paroleColric(k)) * 2 >= Len(parolecVal(j))) Then
                        If InStr(1, paroleColric(k), parolecVal(j)) > 0 Or InStr(1, parolecVal(j), paroleColric(k)) > 0 Then
                            ok = ok + 1
                            parolecVal.Remove (j)
                            paroleColric.Remove (k)
                            j = j - 1
                            Exit For
                        End If
                    End If
                Next k
                
                If ok = soglia Then
                    ESK_CERCAVERT_SIMILE = matr(i, colris)
                    found = True
                    GoTo CloseFunction
                End If
                
                If j = parolecVal.Count Then Exit For
            Next j
            
            
        End If
        
    Next i
        
Next soglia

CloseFunction:
If found = False Then ESK_CERCAVERT_SIMILE = CVErr(xlErrNA)

End Function

Private Function StrToCollection(str As Variant, Optional sign As Long = 3) As Collection
    'Separa le parole di una stringa, sostituendo una serie di caratteri delimitatori con uno spazio
    'Ordina le parole per lunghezza decrescente
    'Trasforma array in collection
    
    Dim mSep As Variant
    Dim newstr As String
    Dim i As Long
    Dim j As Long
    Dim SplitTemp As Variant
    Dim vTemp As Variant
    
    If sign < 0 Then sign = 1
    
    Set StrToCollection = New Collection
    mSep = Array("'", ",", ";", "_", "-", ":", ".", "?", "!", "@", "(", ")", "[", "]", "\", "/", vbCr, vbLf, vbNewLine)
    
    newstr = str
    For i = 0 To UBound(mSep)
        newstr = Replace(newstr, mSep(i), " ")
    Next i
    
    newstr = Replace(Replace(Replace(Replace(Replace(Replace(UCase(newstr), "|fffd|", "A"), "|fffd|", "E"), "|fffd|", "E"), "|fffd|", "I"), "|fffd|", "O"), "|fffd|", "U")
    newstr = Application.WorksheetFunction.Trim(newstr)
    
    SplitTemp = Split(newstr)
    
    'Ordinamento per lunghezza decrescente
    For i = LBound(SplitTemp) To UBound(SplitTemp) - 1
        For j = i + 1 To UBound(SplitTemp)
            If Len(SplitTemp(i)) < Len(SplitTemp(j)) Then
                vTemp = SplitTemp(i)
                SplitTemp(i) = SplitTemp(j)
                SplitTemp(j) = vTemp
            End If
        Next j
    Next i
    
    'Trasformo l'array in collection
    For i = LBound(SplitTemp) To UBound(SplitTemp)
        If Len(SplitTemp(i)) >= sign Then           'Considero significative solo le parole di almeno N lettere
        On Error Resume Next
        StrToCollection.Add SplitTemp(i), CStr(SplitTemp(i))
        On Error GoTo 0
    End If
Next i

End Function



'################### FUNZIONI OBSOLETE, MANTENUTE PER COMPATIBILITA' MA NON PIU' IN ELENCO #######################'

Private Function ESK_CONCATENA_INTERVALLO(intervallo As Range, Optional separatore As String) As String
    Dim cnt As Long
        
    cnt = 0
    For Each cell In intervallo.Cells
        If IsEmpty(cell) = False Then
            cnt = cnt + 1
            If cnt = 1 Then
                ESK_CONCATENA_INTERVALLO = cell.Value
            Else
                ESK_CONCATENA_INTERVALLO = ESK_CONCATENA_INTERVALLO & separatore & cell.Value
            End If
        End If
    Next cell
    
End Function

Private Function ESK_CONCATENA_A_CAPO(intervallo As Range) As String
    Dim cnt As Long
    
    cnt = 0
    For Each cell In intervallo
        If IsEmpty(cell) = False Then
            cnt = cnt + 1
            If cnt = 1 Then
                ESK_CONCATENA_A_CAPO = cell.Value
            Else
                ESK_CONCATENA_A_CAPO = ESK_CONCATENA_A_CAPO & Chr(10) & cell.Value
            End If
            
        End If
    Next cell
    
End Function




'################### FUNZIONI DI SERVIZIO PER LE UDF #######################'

Private Function ActiveCondition(rng As Range) As Integer
'#' Funzione di servizio per le UDF che verificano la formattazione condizionale
'#' Fonte: www.cpearson.com
    Dim Ndx As Long
    Dim FC As FormatCondition
    Dim Temp As Variant
    Dim Temp2 As Variant
    
    If rng.FormatConditions.Count = 0 Then
        ActiveCondition = 0
    Else
        For Ndx = 1 To rng.FormatConditions.Count
            Set FC = rng.FormatConditions(Ndx)
            Select Case FC.Type
                Case xlCellValue
                Select Case FC.Operator
                    Case xlBetween
                        Temp = GetStrippedValue(FC.Formula1)
                        Temp2 = GetStrippedValue(FC.Formula2)
                        If IsNumeric(Temp) Then
                           If CDbl(rng.Value) >= CDbl(Temp) And _
                               CDbl(rng.Value) <= CDbl(Temp2) Then
                               ActiveCondition = Ndx
                               Exit Function
                           End If
                       Else
                          If rng.Value >= Temp And _
                             rng.Value <= Temp2 Then
                             ActiveCondition = Ndx
                             Exit Function
                          End If
                       End If
    
                    Case xlGreater
                        Temp = GetStrippedValue(FC.Formula1)
                        If IsNumeric(Temp) Then
                           If CDbl(rng.Value) > CDbl(Temp) Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        Else
                           If rng.Value > Temp Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        End If
    
                    Case xlEqual
                        Temp = GetStrippedValue(FC.Formula1)
                        If IsNumeric(Temp) Then
                           If CDbl(rng.Value) = CDbl(Temp) Then
                               ActiveCondition = Ndx
                               Exit Function
                           End If
                        Else
                           If Temp = rng.Value Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        End If
    
    
                    Case xlGreaterEqual
                        Temp = GetStrippedValue(FC.Formula1)
                        If IsNumeric(Temp) Then
                           If CDbl(rng.Value) >= CDbl(Temp) Then
                               ActiveCondition = Ndx
                               Exit Function
                           End If
                        Else
                           If rng.Value >= Temp Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        End If
    
                  
                    Case xlLess
                        Temp = GetStrippedValue(FC.Formula1)
                        If IsNumeric(Temp) Then
                            If CDbl(rng.Value) < CDbl(Temp) Then
                               ActiveCondition = Ndx
                               Exit Function
                            End If
                        Else
                            If rng.Value < Temp Then
                               ActiveCondition = Ndx
                               Exit Function
                            End If
                        End If
    
                    Case xlLessEqual
                        Temp = GetStrippedValue(FC.Formula1)
                        If IsNumeric(Temp) Then
                           If CDbl(rng.Value) <= CDbl(Temp) Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        Else
                           If rng.Value <= Temp Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        End If
    
    
                    Case xlNotEqual
                        Temp = GetStrippedValue(FC.Formula1)
                        If IsNumeric(Temp) Then
                           If CDbl(rng.Value) <> CDbl(Temp) Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        Else
                           If Temp <> rng.Value Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        End If
    
                   Case xlNotBetween
                        Temp = GetStrippedValue(FC.Formula1)
                        Temp2 = GetStrippedValue(FC.Formula2)
                        If IsNumeric(Temp) Then
                           If Not (CDbl(rng.Value) <= CDbl(Temp)) And _
                              (CDbl(rng.Value) >= CDbl(Temp2)) Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        Else
                           If Not rng.Value <= Temp And _
                              rng.Value >= Temp2 Then
                              ActiveCondition = Ndx
                              Exit Function
                           End If
                        End If
                
                   Case Else
               End Select
    
    
            Case xlExpression
                If Application.Evaluate(FC.Formula1) Then
                   ActiveCondition = Ndx
                   Exit Function
                End If
    
            Case Else
           End Select
    
        Next Ndx
    
    End If
    
    ActiveCondition = 0

End Function

Private Function ColorOfCF(rng As Range, Optional OfText As Boolean = False) As Long
'#' Funzione di servizio per le UDF che verificano la formattazione condizionale
'#' Fonte: www.cpearson.com

Dim AC As Integer
AC = ActiveCondition(rng)
If AC = 0 Then
    If OfText = True Then
       ColorOfCF = rng.Font.Color
    Else
       ColorOfCF = rng.Interior.Color
    End If
Else
    If OfText = True Then
       ColorOfCF = rng.FormatConditions(AC).Font.Color
    Else
       ColorOfCF = rng.FormatConditions(AC).Interior.Color
    End If
End If

End Function

Private Function GetStrippedValue(cF As String) As String
'#' Funzione di servizio per le UDF che verificano la formattazione condizionale
'#' Fonte: www.cpearson.com
    Dim Temp As String
    If InStr(1, cF, "=", vbTextCompare) Then
       Temp = Mid(cF, 2)
       If Left(Temp, 1) = "=" Then
           Temp = Mid(Temp, 2)
       End If
    Else
       Temp = cF
    End If
    GetStrippedValue = Temp
End Function



Attribute VB_Name = "frmAbout"
Attribute VB_Base = "0{F62ABCDA-BA76-44BD-BB3E-D53C41AFD307}{55463F25-24CA-4B30-8DC8-EF38DF9E7788}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Const ForumURL As String = "http://rebrand.ly/esk_forumexcel"
Const WebSiteURL As String = "http://www.excelswissknife.com"
Const ContactsURL As String = "http://www.excelswissknife.com/contatti"

Private Sub UserForm_Initialize()
    If Mid(ThisWorkbook.Name, 18, 2) = "EG" Then
        Me.lblESKCaption = "Excel Swiss knife v. TEST"
    Else
        Me.lblESKCaption = "Excel Swiss knife v. " & Replace(Mid(ThisWorkbook.Names("ESKVersionNum"), 2), """", "")
    End If
    
    Me.lblESKDate = "(" & CDate(Replace(Mid(ThisWorkbook.Names("ESKVersionDate"), 2), """", "")) & ")"
    
    If lng > 0 Then Call TranslateForm(Me)

    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

End Sub

Private Sub lblEmail_Click()
    Call OpenUrl(ContactsURL, 1)
End Sub

Private Sub lblWebSite_Click()
    Call OpenUrl(WebSiteURL, 1)
End Sub

Private Sub lblForum_Click()
    Call OpenUrl(ForumURL, 1)
End Sub

Private Sub cmdOK_Click()
    Unload Me
End Sub
Attribute VB_Name = "frmAccentedVowels"
Attribute VB_Base = "0{95C38B82-6638-4864-A0EA-00F4AF08E84F}{AE2AD40A-4993-4C75-9A3F-2EE2D82B8079}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub optToPlain_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
Private Sub optToAccent_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
Private Sub optToApostrophe_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
        
        .Hide
        
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    If Me.tglBatch = False Then '#' NO BATCH
    
        Call backup_create_new
        
        Set ws = ActiveSheet
            
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If Me.chkIgnoreHidden = True Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
                
        Else
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto effettuando la conversione... (" & ws.Name & ")"
            Call ShowProgressBar
            
            For Each cell In InRng.Cells
                
                '#' Aumento di 1 il contatore
                counter = counter + 1
                                    
                Call elaboracella(cell)
                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
       
            Next cell
                
        End If
    
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto effettuando le sostituzioni... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto effettuando le sostituzioni... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True

NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub elaboracella(Cella As Range)
    Dim AccArray As Variant
    Dim ApoArray As Variant
    Dim PlainArray As Variant
    Dim k As Long
    Dim str As String

    AccArray = Array("|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", _
                        "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|", "|fffd|")
    ApoArray = Array("a'", "e'", "e'", "i'", "o'", "u'", _
                        "a'", "a'", "a'", "a'", "a'", "e'", "e'", "i'", "i'", "i'", "o'", "o'", "o'", "o'", "o'", "u'", "u'", "u'")
    PlainArray = Array("a", "e", "e", "i", "o", "u", _
                        "a", "a", "a", "a", "a", "e", "e", "i", "i", "i", "o", "o", "o", "o", "o", "u", "u", "u")
    
    If Not IsNumeric(Cella) And Not IsError(Cella) Then
        
        If Me.optToApostrophe Then
        
            str = CStr(Cella.Value)

            For k = LBound(AccArray) To UBound(AccArray)
                If InStr(1, str, AccArray(k)) > 0 Then
                    str = Replace(str, AccArray(k), ApoArray(k))
                ElseIf InStr(1, str, UCase(AccArray(k))) > 0 Then
                    str = Replace(str, UCase(AccArray(k)), UCase(ApoArray(k)))
                End If
            Next k
            
        ElseIf Me.optToPlain Then
        
            str = CStr(Cella.Value)

            For k = LBound(AccArray) To UBound(AccArray)
                If InStr(1, str, AccArray(k)) > 0 Then
                    str = Replace(str, AccArray(k), PlainArray(k))
                ElseIf InStr(1, str, UCase(AccArray(k))) > 0 Then
                    str = Replace(str, UCase(AccArray(k)), UCase(PlainArray(k)))
                End If
            Next k
            
        ElseIf Me.optToAccent Then
            
            str = CStr(Cella.Value)
            
            For k = LBound(ApoArray) To UBound(ApoArray)
                If InStr(1, str, ApoArray(k)) > 0 Then
                    str = Replace(str, ApoArray(k), AccArray(k))
                ElseIf InStr(1, str, UCase(ApoArray(k))) > 0 Then
                    str = Replace(str, UCase(ApoArray(k)), UCase(AccArray(k)))
                End If
            Next k
            
        End If
        
        Cella = str

    End If
    
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmAddBeforeAfter"
Attribute VB_Base = "0{CDD753D6-84E8-49AE-8891-0CC2181FCA6A}{E2B912B9-8780-4D6B-81AD-607DA5E96531}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call UpdatePreview
    
End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub spbNbegin_SpinDown()
    Me.txtNbegin = Me.spbNbegin
    Call UpdatePreview
End Sub

Private Sub spbNbegin_SpinUp()
    Me.txtNbegin = Me.spbNbegin
    Call UpdatePreview
End Sub
Private Sub txtNBegin_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNbegin_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtNbegin) > Me.spbNbegin.Max Then Me.txtNbegin = Me.spbNbegin.Max
    If Val(Me.txtNbegin) < Me.spbNbegin.Min Then Me.txtNbegin = Me.spbNbegin.Min
    Me.spbNbegin = Me.txtNbegin
    Call UpdatePreview
End Sub

Private Sub chktxtBefore_Change()
    Call UpdatePreview
    Me.txtBefore.Enabled = Me.chkTxtBefore
End Sub

Private Sub txtBefore_Change()
    Call UpdatePreview
    Me.txtBefore.ControlTipText = Me.txtBefore.Text
End Sub

Private Sub chkTxtAfter_Change()
    Call UpdatePreview
    Me.txtAfter.Enabled = Me.chkTxtAfter
End Sub

Private Sub txtAfter_Change()
    Call UpdatePreview
    Me.txtAfter.ControlTipText = Me.txtAfter.Text
End Sub

Private Sub chkBegin_Change()
    Application.EnableEvents = False
    If Me.chkBegin = True Then Me.chkInBetween = False
    Me.chkInBetween.Enabled = Not (Me.chkBegin)
    Me.txtBegin.Enabled = Me.chkBegin
    Me.spbNbegin.Enabled = Me.chkBegin
    Me.txtNbegin.Enabled = Me.chkBegin
    Application.EnableEvents = True
    
    Me.chkFormulas.Enabled = Not ((Me.txtBegin <> "") * (Me.chkBegin.Enabled = True) * (Me.chkBegin = True) _
                                + (Me.txtInBetween <> "") * (Me.chkInBetween.Enabled = True) * (Me.chkInBetween = True))
    Call UpdatePreview
End Sub

Private Sub txtBegin_Change()
    Call UpdatePreview
    Me.chkFormulas.Enabled = Not ((Me.txtBegin <> "") * (Me.chkBegin.Enabled = True) * (Me.chkBegin = True) _
                                + (Me.txtInBetween <> "") * (Me.chkInBetween.Enabled = True) * (Me.chkInBetween = True))
    Me.txtBegin.ControlTipText = Me.txtBegin.Text
End Sub

Private Sub chkInBetween_Change()
    Application.EnableEvents = False
    If Me.chkInBetween = True Then Me.chkBegin = False
    Me.chkBegin.Enabled = Not (Me.chkInBetween)
    Me.txtInBetween.Enabled = Me.chkInBetween
    Application.EnableEvents = True
    
    Me.chkFormulas.Enabled = Not ((Me.txtBegin <> "") * (Me.chkBegin.Enabled = True) * (Me.chkBegin = True) _
                                + (Me.txtInBetween <> "") * (Me.chkInBetween.Enabled = True) * (Me.chkInBetween = True))
    Call UpdatePreview
End Sub

Private Sub txtInBetween_Change()
    Call UpdatePreview
    Me.chkFormulas.Enabled = Not ((Me.txtBegin <> "") * (Me.chkBegin.Enabled = True) * (Me.chkBegin = True) _
                                + (Me.txtInBetween <> "") * (Me.chkInBetween.Enabled = True) * (Me.chkInBetween = True))
    Me.txtInBetween.ControlTipText = Me.txtInBetween.Text
End Sub

Private Sub UpdatePreview()

    Dim i As Long
    Dim c As Long
    Dim strPreview As String
    
    On Error Resume Next
    
    Me.lbxBefore.Clear
    Me.lbxAfter.Clear
    
    Set InRng = ActiveSheet.Range(Replace(Me.refRange, ";", ",")).SpecialCells(xlCellTypeVisible)
    
    i = 1
    For Each cell In InRng.Cells
        If IsEmpty(cell) = False And IsError(cell) = False Then
            
            Me.lbxBefore.AddItem cell.Value
            
            strPreview = ""
            
            If Me.chkInBetween = True And Me.chkInBetween.Enabled = True Then
                For c = 1 To Len(cell)
                    strPreview = strPreview & Me.txtInBetween & Mid(cell, c, 1)
                Next c
                strPreview = Mid(strPreview, Len(Me.txtInBetween) + 1)
            ElseIf Me.chkBegin = True And Me.chkBegin.Enabled = True Then
                strPreview = Left(cell, Me.txtNbegin) & Me.txtBegin & Mid(cell, Me.txtNbegin + 1)
            Else
                strPreview = cell.Value
            End If
            
            If Me.chkTxtBefore = True Then
                strPreview = Me.txtBefore & strPreview
            End If
                
            If Me.chkTxtAfter = True Then
                strPreview = strPreview & Me.txtAfter
            End If
            
            Me.lbxAfter.AddItem strPreview
            
            i = i + 1
            If i = 11 Or i > InRng.Cells.Count Then Exit For
        End If
    Next cell
    
    Me.cmdOK.Enabled = (Me.lbxBefore.ListCount > 0) * (Me.lbxBefore.List(1) <> Me.lbxAfter.List(1))
    
    On Error GoTo 0
    
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide
        
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
        
        '#' Crea foglio di backup nascosto
        Call backup_create_new
    
        On Error GoTo Aborted
        
        Set ws = ActiveSheet
        
        Set InRng = ws.Range(Replace(.refRange, ";", ","))
        If .chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
       
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto aggiungendo il testo... (" & ws.Name & ")"
        Call ShowProgressBar
        
        For Each cell In InRng.Cells
            'Aumenta di 1 il contatore
            counter = counter + 1
            
            If IsError(cell) = False Then
    
                Call elaboracella(cell)
                            
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        Next cell
        
        'Chiude la finestra di avanzamento
        Unload UProgress
    
    End With
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)

    If Me.chkClose = False Then Me.Show
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub elaboracella(Cella As Range)
    Dim strCella As String
    Dim strFormula As String
    Dim c As Long

    With Me
    
        If .chkFormulas.Enabled = True And _
            .chkFormulas = True And _
            Cella.HasFormula = True And _
            Cella.HasArray = False Then         'Sto elaborando la cella, essa contiene formule e le voglio conservare
            
            If Cella.Value <> "" Or .chkIgnoreEmpty = False Then
                
                strFormula = "=CONCATENATE("
                If .chkTxtBefore = True Then
                    strFormula = strFormula & """" & .txtBefore & """, "
                End If
                
                strFormula = strFormula & Mid(Cella.Formula, 2)
                
                If .chkTxtAfter = True Then
                    strFormula = strFormula & ", """ & .txtAfter & """"
                End If
                
                strFormula = strFormula & ")"
            
                Cella.Formula = strFormula
            End If
            
        Else 'La cella non ha formule: il risultato sar|fffd| una stringa
            
            If Cella <> "" Or .chkIgnoreEmpty = False Then
    
                'SEQUENZA:
                '1) inserisci tra ciascun carattere
                '2) inserisci a partire dal carattere N
                '3) inserisci testo prima
                '4) inserisci testo dopo
                
                strCella = ""
                
                If .chkInBetween = True Then
                    For c = 1 To Len(Cella)
                        strCella = strCella & .txtInBetween & Mid(Cella, c, 1)
                    Next c
                    strCella = Mid(strCella, Len(.txtInBetween) + 1)
                ElseIf .chkBegin = True Then
                    strCella = Left(Cella, .txtNbegin) & .txtBegin & Mid(Cella, .txtNbegin + 1)
                Else
                    strCella = Cella.Value
                End If
                
                If .chkTxtBefore = True Then
                    strCella = .txtBefore & strCella
                End If
                    
                If .chkTxtAfter = True Then
                    strCella = strCella & .txtAfter
                End If
                    
                Cella = strCella
                
            End If
        End If
    End With
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmAddLeadingZeros"
Attribute VB_Base = "0{A2E04B5B-518D-4F41-8D2D-009DCA1E87C4}{268A9E95-3197-4D69-8DB2-A86CC020595F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub


Private Sub spbDigits_SpinDown()
    Me.txtDigits = Me.spbDigits
End Sub
Private Sub spbDigits_SpinUp()
    Me.txtDigits = Me.spbDigits
End Sub
Private Sub txtDigits_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtDigits_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtDigits) > Me.spbDigits.Max Then Me.txtDigits = Me.spbDigits.Max
    If Val(Me.txtDigits) < Me.spbDigits.Min Then Me.txtDigits = Me.spbDigits.Min
    Me.spbDigits = Me.txtDigits
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long

    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        .Hide
        
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
        
    
    If Me.tglBatch = False Then '#' NO BATCH
    
        Call backup_create_new
        
        Set ws = ActiveSheet
            
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If Me.chkIgnoreHidden = True Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
                
        Else
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto aggiungendo gli zeri iniziali..."
            Call ShowProgressBar
            
            For Each cell In InRng.Cells
            
                'Aumenta di 1 il contatore
                counter = counter + 1
                                                            
                Call elaboracella(cell)
                                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next cell
            
        End If
        
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto aggiungendo gli zeri iniziali... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto aggiungendo gli zeri iniziali... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True

NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub elaboracella(Cella As Range)
    With Me
        If (.chkIgnoreEmpty And Cella <> "") Or .chkIgnoreEmpty = False Then
                                                
            If (.chkIgnoreText And Application.WorksheetFunction.IsNumber(Cella) = True) Or .chkIgnoreText = False Then
                                        
                If Len(Cella) < .txtDigits Then
                   Cella.NumberFormat = "@"
                   Cella.Value = "'" & Right(String(.txtDigits, "0") & Cella.Value, .txtDigits)
                Else
                   Cella.NumberFormat = "@"
                   Cella.Value = "'" & Cella.Value
                End If
                
            End If
        
        End If
    End With
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmAdvancedPivot"
Attribute VB_Base = "0{F00F3E77-DF24-4016-A242-F2726244BDD8}{727C5389-5DB6-468D-852B-66F5E9F93434}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim i As Long, j As Long
Dim TempRng As Range
Dim DisableEvents As Boolean


Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    DisableEvents = True
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    DisableEvents = False
    
    Call Recompute

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    Call Recompute(Val(Me.txtFixedCols), Val(Me.txtVarLayers))
    On Error GoTo 0
End Sub


Private Sub txtFixedCols_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtFixedCols_Change()
    If Val(Me.txtFixedCols) > Me.spbFixedCols.Max Then Me.txtFixedCols = Me.spbFixedCols.Max
    If Val(Me.txtFixedCols) < Me.spbFixedCols.Min Then Me.txtFixedCols = Me.spbFixedCols.Min
    If Me.txtFixedCols <> "" Then Me.spbFixedCols = Me.txtFixedCols
    Call Recompute(Val(Me.txtFixedCols), Val(Me.txtVarLayers))
End Sub
Private Sub txtVarLayers_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtVarLayers_Change()
    If Val(Me.txtVarLayers) > Me.spbVarLayers.Max Then Me.txtFixedCols = Me.spbVarLayers.Max
    If Val(Me.txtVarLayers) < Me.spbVarLayers.Min Then Me.txtVarLayers = Me.spbVarLayers.Min
    If Me.txtVarLayers <> "" Then Me.spbVarLayers = Me.txtVarLayers
    Call Recompute(Val(Me.txtFixedCols), Val(Me.txtVarLayers))
End Sub

Private Sub txtVar_Enter()
    Me.spbFixedCols.SetFocus
End Sub

Private Sub spbFixedCols_SpinDown()
    Me.txtFixedCols = Me.spbFixedCols
End Sub

Private Sub spbFixedCols_SpinUp()
    Me.txtFixedCols = Me.spbFixedCols
End Sub

Private Sub spbVarLayers_SpinDown()
    Me.txtVarLayers = Me.spbVarLayers
End Sub

Private Sub spbVarLayers_SpinUp()
    Me.txtVarLayers = Me.spbVarLayers
End Sub

Private Sub chkDelete_Change()
    Call Recompute(Val(Me.txtFixedCols), Val(Me.txtVarLayers))
End Sub

Private Sub Recompute(Optional Cfix As Long, Optional Vlay As Long)
    Dim TransposedRows As Long
    
    If DisableEvents = True Then Exit Sub
        
    'Evitiamo la chiamata ricorsiva alla routine
    DisableEvents = True
    
    On Error Resume Next
    Set TempRng = Range(Replace(Me.refRange, ";", ","))
    If Application.WorksheetFunction.CountA(TempRng) = 0 Then Exit Sub
    
    If Cfix = 0 Then
        i = 0
        For Each cell In TempRng.Rows(1).Cells
            If cell.Value = "" Then i = i + 1 Else Exit For
        Next cell
'        If i = 0 Then i = 1
        Me.txtFixedCols = i
    ElseIf Cfix > TempRng.Columns.Count - 2 Then
        Me.txtFixedCols = TempRng.Columns.Count - 2
    End If

    Me.txtVar = TempRng.Columns.Count - Me.txtFixedCols

    If Vlay = 0 Then
        j = 1
        For Each cell In TempRng.Columns(1).Cells
            If cell.Value = "" Then j = j + 1 Else Exit For
        Next cell
        Me.txtVarLayers = j
    ElseIf Vlay > TempRng.Rows.Count - 1 Then
        Me.txtVarLayers = TempRng.Rows.Count - 1
    End If
    
    If Me.chkDelete = True Then
        TransposedRows = Application.WorksheetFunction.CountA(Intersect(TempRng, TempRng.Offset(Me.txtVarLayers, Me.txtFixedCols))) + 1
    Else
        TransposedRows = ((TempRng.Rows.Count - Me.txtVarLayers) * Me.txtVar) + 1
    End If
    
    Me.lblNRows.Caption = Format(TransposedRows, "#,##0")
        
    If TransposedRows > TempRng.Parent.Rows.Count Then
        Me.lblAlert.Caption = TranslateCnst("TooManyRows")
        Me.lblAlert.ForeColor = vbRed
        Me.cmdOK.Enabled = False
    Else
        Me.lblAlert.Caption = TranslateCnst("OkRows")
        Me.lblAlert.ForeColor = vbBlack
        Me.cmdOK.Enabled = True
    End If
    
    DisableEvents = False
    On Error GoTo 0
    
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim restArray() As Variant
    Dim Cfix As Long
    Dim nLay As Long
    Dim nVar As Long
    Dim wsRestr As Worksheet
    Dim c As Long, i As Long, j As Long, k As Long, T As Long
    Dim SortCols As Boolean

    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted

        Cfix = .txtFixedCols
        nLay = .txtVarLayers
        SortCols = .chkSort
        Set InRng = Range(Replace(.refRange, ";", ","))

        .Hide

    End With

    Call AutoCalc(False)

    Set ws = ActiveSheet
    Set wsRestr = Worksheets.Add(After:=Sheets(ws.index))
    wsRestr.Name = Left(ws.Name, 8) & "_unpivot" & "_" & Format(Now, "yymmdd hhmmss")

    ws.Activate

    'Definiamo alcune variabili
    With InRng
        nVar = .Columns.Count - Cfix 'Numero di variabili da trasporre
    End With

    'Ridimensiono l'array di destinazione ((numero di casi * numero di variabili da trasporre)+1, colonne fisse + n "strati" di variabili +1)
    'e verifico se il numero di righe eccede quello del foglio di destinazione
    If Me.chkDelete Then
        ReDim restArray(1 To Application.WorksheetFunction.CountA(Intersect(InRng, InRng.Offset(nLay, Cfix))) + 1, 1 To nLay + Cfix + 1)
    Else
        ReDim restArray(1 To ((InRng.Rows.Count - nLay) * nVar) + 1, 1 To nLay + Cfix + 1)
    End If
    
    If UBound(restArray, 1) > wsRestr.Rows.Count - 1 Then
        MsgBox IIf(lng = 0, "Attenzione: con le opzioni selezionate il numero di righe eccede la lunghezza massima del foglio", _
                          "Warning: with the selected options, rows number exceeds destination worksheet's size"), vbCritical
        Exit Sub
    End If

    'Inizio a popolare l'array di destinazione

    'prima riga (intestazione), colonne fisse
    For i = 1 To Cfix
        restArray(1, i) = InRng(nLay, i).Value2
    Next i

    'prima riga (intestazione), colonne variabili e "dato"
    For i = 1 To nLay
        restArray(1, Cfix + i) = "Var" & i
    Next i
    restArray(1, nLay + Cfix + 1) = "Data"

    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Rows.Count * nVar
    UProgress.SetDescription "Ricostruisco la struttura..."
    Call ShowProgressBar

    'righe successive (valori)
    k = 1                                       'k |fffd| l'indice di riga del foglio ristrutturato
    For c = 1 To nVar                           'c indica le reiterazioni (numero di variabili da trasporre)
        For i = nLay + 1 To InRng.Rows.Count    'i |fffd| l'indice di riga del dataset originale

            If Me.chkDelete = False Or Application.WorksheetFunction.CountA(InRng(i, Cfix + c)) = 1 Then
            
                k = k + 1 'Mi porto alla riga successiva del foglio ristrutturato (iniziando da 2)
                
                'Riporto colonne fisse
                For j = 1 To Cfix                   'j |fffd| l'indice delle colonne fisse
                    restArray(k, j) = InRng(i, j).Value2
                Next j
    
                'Riporto intestazioni di variabile della colonna c
                For T = 1 To nLay                   't |fffd| l'indice di riga degli "strati" di variabili
                    restArray(k, Cfix + T) = InRng(T, Cfix + c).Value2
                Next T
    
                'Riporto il valore puntuale
                restArray(k, nLay + Cfix + 1) = InRng(i, Cfix + c).Value2

            End If
            
            counter = counter + 1

            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted

        Next i

    Next c

    'Chiude la finestra di avanzamento
    Unload UProgress
    
    With wsRestr
        
        .Activate
        
        'Riporto i valori nel foglio di destinazione
        .Range("A1").reSize(k, Cfix + nLay + 1).NumberFormat = "@"
        .Range("A1").reSize(k, Cfix + nLay + 1) = restArray
        .Range("A1").reSize(k, Cfix + nLay + 1).NumberFormat = "General"

        'Adatta larghezza colonne
        .UsedRange.Columns.AutoFit

        'Ordinamento colonne
        If SortCols Then
            For j = 1 To Cfix + nLay
                .Sort.SortFields.Add key:=Range(Cells(1, j), Cells(.UsedRange.Columns.Count, j)), _
                    SortOn:=xlSortOnValues, Order:=xlAscending, _
                    DataOption:=xlSortNormal
            Next j

            With .Sort
                .SetRange wsRestr.UsedRange
                .header = xlYes
                .MatchCase = False
                .Orientation = xlTopToBottom
                .Apply
            End With
        End If

    End With


    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)

    Exit Sub

Aborted:
    Call CanceledProcedure

End Sub



Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmAppendSheets"
Attribute VB_Base = "0{C3920A3B-AB14-496D-8B67-C6A3EC661979}{EF2FA950-0609-40F2-98C8-037ED2DD9E83}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean
Dim DisableAlerts As Boolean


Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    DisableAlerts = True
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    DisableAlerts = False
    
    Call PopulateSheetList

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Sub PopulateSheetList()
    Dim cSheets As New Collection
    Dim i As Long
    
    Me.lbxSheets.Clear
    
    For Each ws In ActiveWorkbook.Worksheets
        If Not Left(ws.Name, 8) = "Combined" And _
           Not ws.Name = "ESK_Backup" And _
           UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*" Then
                Me.lbxSheets.AddItem ws.Name
                If IsSelected(ws.Name) Or ActiveWindow.SelectedSheets.Count = 1 Then Me.lbxSheets.Selected(Me.lbxSheets.ListCount - 1) = True
        End If
    Next ws

    '#' Popolo la collection dei fogli selezionati
    For i = 0 To Me.lbxSheets.ListCount - 1
        If Me.lbxSheets.Selected(i) = True Then cSheets.Add Worksheets(Me.lbxSheets.List(i))
    Next i
    
    If cSheets.Count = Me.lbxSheets.ListCount Then Me.chkAllNone = True

End Sub

Private Sub txtFilterList_Change()
    Call PopulateSheetList
End Sub

Private Sub spbFirstRow_SpinDown()
    Me.txtFirstRow = Me.spbFirstRow
End Sub

Private Sub spbFirstRow_SpinUp()
    Me.txtFirstRow = Me.spbFirstRow
End Sub
Private Sub txtFirstRow_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtFirstRow_Change()
    If Val(Me.txtFirstRow) > Me.spbFirstRow.Max Then Me.txtFirstRow = Me.spbFirstRow.Max
    If Val(Me.txtFirstRow) < Me.spbFirstRow.Min Then Me.txtFirstRow = Me.spbFirstRow.Min
    Me.spbFirstRow = Me.txtFirstRow
    Me.chkNoFirstFile.Enabled = (CLng(Me.txtFirstRow) > 1)
End Sub


Private Sub spbOnlyFirst_SpinDown()
    Me.txtOnlyFirst = Me.spbOnlyFirst
End Sub
Private Sub spbOnlyFirst_SpinUp()
    Me.txtOnlyFirst = Me.spbOnlyFirst
End Sub

Private Sub txtOnlyFirst_Change()
    If Val(Me.txtOnlyFirst) > Me.spbOnlyFirst.Max Then Me.txtOnlyFirst = Me.spbOnlyFirst.Max
    If Val(Me.txtOnlyFirst) < Me.spbOnlyFirst.Min Then Me.txtOnlyFirst = Me.spbOnlyFirst.Min
    Me.spbOnlyFirst = Me.txtOnlyFirst
End Sub

Private Sub txtOnlyFirst_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub

Private Sub chkOnlyFirst_Change()
    Me.txtOnlyFirst.Enabled = Me.chkOnlyFirst
    Me.spbOnlyFirst.Enabled = Me.chkOnlyFirst
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxSheets.ListCount - 1
        Me.lbxSheets.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GoodToGo(Me)
End Sub

Private Sub lbxSheets_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub

Private Sub optCustomOrder_Click()
    If DisableAlerts = True Then Exit Sub
    
    If Me.optCustomOrder = True Then
        MsgBox IIf(lng = 0, "In questa modalit|fffd| verranno esaminate le intestazioni nella prima riga di ciascun foglio, per incolonnare correttamente i dati. " & vbNewLine & vbNewLine & _
                            "Cosa avviene in caso di difformit|fffd|:" & vbNewLine & _
                            "- Colonne non presenti nei file/fogli precedenti: saranno aggiunte in coda all'elenco delle colonne" & vbNewLine & _
                            "- Colonne senza intestazione nella prima riga: saranno ignorate", _
                            "In this mode, the headings in the first row of each sheet will be examined, to correctly append your data." & vbNewLine & _
                            "What happens in case of discrepancy:" & vbNewLine & _
                            "- Columns not present in previous files/sheets will be added at the end of the columns list" & vbNewLine & _
                            "- Columns with no header in first row will be ignored"), vbInformation
    End If
End Sub
Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wsComb As Worksheet
    Dim SelSheets As New Collection
    Dim i As Long, n As Long, j As Long, c As Long
    Dim SumRows As Long
    Dim CopyRng As Range
    Dim uR As Long
    Dim colArray As Variant
    Dim TrimmedValue As Variant
    
    '#' Popolo la collection dei fogli selezionati
    For i = 0 To Me.lbxSheets.ListCount - 1
        If Me.lbxSheets.Selected(i) = True Then SelSheets.Add ActiveWorkbook.Worksheets(Me.lbxSheets.List(i))
    Next i
    
    Me.Hide
    
    Call AutoCalc(False)

    '#' Trovo la somma delle righe da importare (SumRows)
    For Each ws In SelSheets
        SumRows = SumRows + ws.UsedRange.Rows.Count + ws.UsedRange.Row - 1
    Next ws
    
    '#' Verifico che la somma delle righe dei fogli da accodare non superi il numero di righe del foglio di lavoro
    If IIf(Me.chkOnlyFirst * (Me.txtOnlyFirst <> "") = 1, SelSheets.Count * Val(Me.txtOnlyFirst), SumRows) > ActiveSheet.Rows.Count Then
        MsgBox TranslateCnst("TooManyRows"), vbCritical
        Exit Sub
    End If
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = SelSheets.Count
    UProgress.SetDescription "Unisco i fogli selezionati..."
    Call ShowProgressBar
    
    '#' Crea un foglio "Combined" con un numero progressivo
    On Error Resume Next
    n = 1
    Set wsComb = ActiveWorkbook.Worksheets.Add(Before:=ActiveWorkbook.Worksheets(1), Count:=1)
    Do
        Err.Clear
        wsComb.Name = Trim("ESK_Combined " & n)
        n = n + 1
    Loop While Err.Number > 0
    On Error GoTo Aborted
    
    For Each ws In SelSheets
    
        'Aumenta di 1 il contatore, aggiorna descrizione avanzamento
        counter = counter + 1
        UProgress.SetDescription "Unisco i fogli selezionati... (" & ws.Name & ")"
        
        '#' Setto l'ultima riga del foglio di importazione
        uR = wsComb.UsedRange.Rows.Count + wsComb.UsedRange.Row - 1
        
        '''==========================='''
        '''   RIORDINAMENTO COLONNE   '''
        '''==========================='''
        
        If Me.optCustomOrder = True Then
            If counter = 1 Then 'E' il primo file, popolo l'array delle colonne con la prima riga
                colArray = ws.Range("A1:" & findlastcell(ws.Rows(1)).address)
                For j = LBound(colArray, 2) To UBound(colArray, 2)
                    colArray(1, j) = Application.WorksheetFunction.Trim(colArray(1, j))
                Next j
                ws.Range("A1:" & findlastcell(ws.Cells).address).Copy SortSheet.Cells(1, 1)
            Else 'Verifico se ci sono nuove colonne
                SortSheet.Cells.Clear
                c = UBound(colArray, 2)
                            
                For j = 1 To ws.Range("A1:" & findlastcell(ws.Rows(1)).address).Columns.Count
                    TrimmedValue = Application.WorksheetFunction.Trim(ws.Cells(1, j))
                    If TrimmedValue <> "" Then
                        If IsError(Application.Match(TrimmedValue, Application.index(colArray, 0), 0)) = True Then 'Colonna nuova, aggiungo in coda
                            c = c + 1
                            ReDim Preserve colArray(1 To 1, 1 To c)
                            colArray(1, c) = TrimmedValue
                            If Me.txtFirstRow = 1 Or Me.chkNoFirstFile = True Then
                                wsComb.Cells(1, c) = TrimmedValue
                            End If
                        End If
                    End If
                    
                    'Trasferisco i dati dal foglio di importazione al foglio di ordinamento,
                    ws.Columns(j).Copy
                    SortSheet.Cells(1, Application.Match(TrimmedValue, Application.index(colArray, 0), 0)).PasteSpecial
                    Application.CutCopyMode = False
                Next j
                
            End If
                
            'Copio dal foglio ordinato al foglio di importazione
            With SortSheet
                ws.Cells.Clear
                .UsedRange.Copy
                ws.Cells(1, 1).PasteSpecial
                .Cells.Clear
            End With
        End If
        
        '#' Imposto il range di copia
        Set CopyRng = ws.Range("A1:" & findlastcell(ws.Cells).address)
        
        If Me.txtFirstRow > 1 And (counter > 1 Or Me.chkNoFirstFile = False) Then
            Set CopyRng = Intersect(CopyRng, CopyRng.Offset(Me.txtFirstRow - 1, 0))
        End If
        
        If Me.chkOnlyFirst = True Then
            Set CopyRng = CopyRng.reSize(Me.txtOnlyFirst + Abs((Me.chkNoFirstFile) * (counter = 1) * (Me.txtFirstRow - 1)))
        End If
        
        '#' Effettuo la copia
        CopyRng.Copy
        With wsComb.Range("A" & uR).Offset(Abs(CInt(counter > 1)), Abs(CInt(Me.chkID)))
            If counter = 1 Then 'Copio larghezza colonne se |fffd| il primo foglio importato
                .PasteSpecial xlPasteColumnWidths
            End If
            
            .PasteSpecial xlPasteValues
            
            If Me.chkFormats Then .PasteSpecial xlPasteFormats
        End With
        
        '#' Aggiorno la colonna identificativa, se impostazione settata
        If Me.chkID Then
            wsComb.Range("A" & uR + Abs(CInt(counter > 1)) & ":A" & wsComb.UsedRange.Rows.Count) = ws.Name
        End If
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        DoEvents
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
    
    Next ws
    
    Unload UProgress
    
    wsComb.Activate
    ActiveWindow.ScrollRow = Abs(wsComb.UsedRange.Rows.Count - 10)
    wsComb.Range("A" & wsComb.UsedRange.Rows.Count).Select
    
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmChangelog"
Attribute VB_Base = "0{AD918BF6-CC7F-48E0-9B51-EB27F3335C4C}{1D61FDF9-22B7-4526-B442-9982281882FB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Dim FilePath As String
    Dim f As Long
    Dim dataline As String
    Dim CLog As String
    
    On Error Resume Next
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    If Mid(ThisWorkbook.Name, 18, 2) = "EG" Then
        FilePath = ThisWorkbook.path & pSep & "TxtFiles" & pSep & "Changelog.txt"
    Else
        FilePath = ThisWorkbook.path & pSep & "Changelog.txt"
    End If
    
    If FileExists(FilePath) = False Then
        Me.Hide
        MsgBox IIf(lng = 0, "File Changelog.txt non trovato, o non accessibile", _
                          "Changelog.txt not found or not accessible"), _
                          vbOKOnly + vbExclamation, _
                          IIf(lng = 0, "Changelog non trovato", "Changelog not found")
    Else
        f = FreeFile
        
        Open FilePath For Input As #f
            CLog = Input(LOF(f), f)
            
            Me.lblChangelog.Caption = CLog
            Me.lblChangelog.AutoSize = True
            Me.fraChangelog.ScrollBars = fmScrollBarsVertical
            Me.fraChangelog.ScrollHeight = Me.lblChangelog.Height + 10
            Me.fraChangelog.ScrollWidth = Me.fraChangelog.InsideWidth
    
        Close #f
    End If
    
End Sub

Private Sub UserForm_Activate()
    If Me.lblChangelog.Caption = "" Then
        Call cmdCancel_Click
    End If
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "frmCombinations"
Attribute VB_Base = "0{5587AFFA-8BAC-4682-8C69-E69C88E8E0D0}{257773B3-AE49-4929-9E8F-9CF824F74F39}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    With Me.cbxFilterSum
        If lng = 0 Then
            .AddItem "Uguale a:"
            .AddItem "Maggiore di:"
            .AddItem "Minore di:"
            .AddItem "Diversa da:"
        Else
            .AddItem "Exactly:"
            .AddItem "Greater than:"
            .AddItem "Smaller than:"
            .AddItem "Different from:"
        End If
        .ListIndex = 0
    End With
        
    Call SaveOptions(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

    Call CalcElem
    Call CalcComb
    
End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    Call CalcElem
    Call CalcComb
    Call CheckNumbers
    On Error GoTo 0
End Sub

Private Sub optRange_Change()
    Call CheckNumbers
    If Me.optRange = True Then
        Me.refRange.Enabled = True
    Else
        Me.refRange.Enabled = False
    End If
End Sub

Private Sub spbClass_SpinDown()
    Me.txtClass = Me.spbClass
End Sub

Private Sub spbClass_SpinUp()
    Me.txtClass = Me.spbClass
End Sub

Private Sub txtClass_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtClass_Change()
    If Val(Me.txtClass) > Me.spbClass.Max Then Me.txtClass = Me.spbClass.Max
    If Val(Me.txtClass) < Me.spbClass.Min Then Me.txtClass = Me.spbClass.Min
    Me.spbClass = Me.txtClass
    Call CalcComb
End Sub

Private Sub spbLimitResults_SpinDown()
    Me.txtLimitResults = Me.spbLimitResults
End Sub

Private Sub spbLimitResults_SpinUp()
    Me.txtLimitResults = Me.spbLimitResults
End Sub

Private Sub txtLimitResults_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub

Private Sub txtLimitResults_Change()
    On Error Resume Next
    If Val(Me.txtLimitResults) > Me.spbLimitResults.Max Then Me.txtLimitResults = Me.spbLimitResults.Max
    If Val(Me.txtLimitResults) > CLng(Me.lblCombinations) Then Me.txtLimitResults = CLng(Me.lblCombinations)
    If Val(Me.txtLimitResults) < Me.spbLimitResults.Min Then Me.txtLimitResults = Me.spbLimitResults.Min
    Me.spbLimitResults = Me.txtLimitResults
    On Error GoTo 0
End Sub

Private Sub spbFilterSum_SpinDown()
    Me.txtFilterSum = Me.spbFilterSum
End Sub

Private Sub spbFilterSum_SpinUp()
    Me.txtFilterSum = Me.spbFilterSum
End Sub

Private Sub txtFilterSum_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii <> 45 And (KeyAscii < 48 Or KeyAscii > 57) Then KeyAscii = 0
End Sub
Private Sub txtFilterSum_Change()
    If Val(Me.txtFilterSum) > Me.spbFilterSum.Max Then Me.txtFilterSum = Me.spbFilterSum.Max
    If Val(Me.txtFilterSum) < Me.spbFilterSum.Min Then Me.txtFilterSum = Me.spbFilterSum.Min
    Me.spbFilterSum = Me.txtFilterSum
End Sub

Private Sub txtChunk_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub

Private Sub txtChunk_Change()
    If Me.optNewSheet = True And Val(Me.txtChunk) > ActiveSheet.Rows.Count Then Me.txtChunk = ActiveSheet.Rows.Count
    If Val(Me.txtChunk) < 1 Then Me.txtChunk = 1
End Sub

Private Sub optNumbers_Change()
    Me.txtNbegin.Enabled = Me.optNumbers
    Me.txtNEnd.Enabled = Me.optNumbers
    Me.spbNbegin.Enabled = Me.optNumbers
    Me.spbNEnd.Enabled = Me.optNumbers
    Call CalcComb
End Sub

Private Sub spbNbegin_SpinDown()
    Me.txtNbegin = Me.spbNbegin
    Call CalcComb
End Sub

Private Sub spbNbegin_SpinUp()
    Me.txtNbegin = Me.spbNbegin
    Call CalcComb
End Sub
Private Sub txtNBegin_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii <> 45 And (KeyAscii < 48 Or KeyAscii > 57) Then KeyAscii = 0
End Sub
Private Sub txtNbegin_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtNbegin) > Me.spbNbegin.Max Then Me.txtNbegin = Me.spbNbegin.Max
    If Val(Me.txtNbegin) < Me.spbNbegin.Min Then Me.txtNbegin = Me.spbNbegin.Min
    Me.spbNbegin = Me.txtNbegin
    Call CalcComb
End Sub

Private Sub spbNEnd_SpinDown()
    Me.txtNEnd = Me.spbNEnd
    Call CalcComb
End Sub

Private Sub spbNEnd_SpinUp()
    Me.txtNEnd = Me.spbNEnd
    Call CalcComb
End Sub
Private Sub txtNEnd_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii <> 45 And (KeyAscii < 48 Or KeyAscii > 57) Then KeyAscii = 0
End Sub
Private Sub txtNEnd_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtNEnd) > Me.spbNEnd.Max Then Me.txtNEnd = Me.spbNEnd.Max
    If Val(Me.txtNEnd) < Me.spbNEnd.Min Then Me.txtNEnd = Me.spbNEnd.Min
    Me.spbNEnd = Me.txtNEnd
    Call CalcComb
End Sub

Private Sub optLimitResults_Change()
    Me.txtLimitResults.Enabled = Me.optLimitResults
    Me.spbLimitResults.Enabled = Me.optLimitResults
    Me.chkFilterSum.Enabled = Not Me.optLimitResults
    If Me.optLimitResults = True Then
        Me.chkFilterSum = False
    End If
End Sub

Private Sub optDispositions_Click()
    Call CalcComb
End Sub

Private Sub optDispRep_Click()
    Call CalcComb
End Sub

Private Sub optCombinations_Click()
    Call CalcComb
End Sub

Private Sub chkFilterSum_Change()
    Me.cbxFilterSum.Enabled = Me.chkFilterSum
    Me.txtFilterSum.Enabled = Me.chkFilterSum
    Me.spbFilterSum.Enabled = Me.chkFilterSum
    If Me.chkFilterSum = True Then Me.optAllResults = True
    Me.optLimitResults.Enabled = Not Me.chkFilterSum
End Sub

Private Sub CalcElem()
    On Error Resume Next
    If lng = 0 Then
        If Me.optRange Then
            Me.lblTotElem.Caption = "di " & Format(Range(Me.refRange).Cells.Count, "#,##0") & " elementi"
        Else
            Me.lblTotElem.Caption = "di " & Format(Me.txtNEnd - Me.txtNbegin + 1, "#,##0") & " elementi"
        End If
    Else
        If Me.optRange Then
            Me.lblTotElem.Caption = "of " & Format(Range(Me.refRange).Cells.Count, "#,##0") & " elements"
        Else
            Me.lblTotElem.Caption = "of " & Format(Me.txtNEnd - Me.txtNbegin + 1, "#,##0") & " elements"
        End If
    End If
    
    If Me.optDispRep = False Then
        If Me.optRange = True Then
            Me.spbClass.Max = Range(Me.refRange).Cells.Count
        Else
            Me.spbClass.Max = Me.txtNEnd - Me.txtNbegin + 1
        End If
    Else
        Me.spbClass.Max = 9999999
    End If
    Call spbClass_SpinUp
    Call spbClass_SpinDown
    On Error GoTo 0
End Sub

Private Sub CalcComb()
    Dim n As Long
    
    On Error Resume Next
    If Me.optRange = True Then
        n = Range(Me.refRange).Cells.Count
    Else
        n = Me.txtNEnd - Me.txtNbegin + 1
    End If
        
    If Me.optCombinations = True Then
        Me.lblCombinations = Format(Application.WorksheetFunction.Combin(n, Me.txtClass), "#,##0")
    ElseIf Me.optDispositions = True Then
        Me.lblCombinations = Format(Application.WorksheetFunction.Permut(n, Me.txtClass), "#,##0")
    ElseIf Me.optDispRep = True Then
        Me.lblCombinations = Format((n ^ Me.txtClass), "#,##0")
    End If
    Call CalcElem
    On Error GoTo 0
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim i As Long
    Dim p() As Variant
    Dim X As Long
    Dim classe As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
    
        .Hide
    End With
        
    Call AutoCalc(False)
    
    Set ws = ActiveSheet
    
    If Me.optRange = True Then
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            GoTo ErrHandler
        Else
            'Ridimensiono e popolo la matrice degli elementi da combinare
            ReDim p(1 To InRng.Cells.Count)
            For i = 1 To UBound(p)
                p(i) = InRng(i)
            Next i
        End If
    Else
        'Ridimensiono e popolo la matrice degli elementi da combinare
        X = 0
        ReDim p(1 To Me.txtNEnd - Me.txtNbegin + 1)
        For i = 1 To UBound(p)
            p(i) = Me.txtNbegin + X
            X = X + 1
        Next i
    End If
    
    'Definisco la classe di elementi da combinare
    classe = Me.txtClass
    
    'Eseguo le sub per generare combinazioni/disposizioni
    If Me.optCombinations = True Then
        Call printCombinations(p, classe)
    Else
        Call printDispositions(p, classe)
    End If
            
   
ErrHandler:
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub printCombinations(ByRef pool() As Variant, ByVal classe As Long)
    Dim RandomResults As New Collection
    Dim totcomb As Long     'Il totale di combinazioni possibili
    Dim limit As Long       'Il limite di combinazioni impostato
    Dim fPath As String     'Il percorso dove salvare i file di testo
    Dim cWs As Worksheet    'Il foglio di lavoro dove saranno scritte le combinazioni
    Dim i As Long
    Dim j As Long
    Dim n As Long
    Dim idx() As Variant
    Dim tabfinale As Variant
    Dim cOff As Long
    Dim cRow As Long
    Dim strComb As String
    Dim cntLoops As Long
    Dim sep As String
    Dim f As Long
    Dim fName As String
    Dim cFiles As Long
    Dim chunk As Long
    Dim num As Long
    
    'Definisco alcune costanti
    sep = Me.txtSeparator
    totcomb = CLng(Me.lblCombinations)
    If Me.optLimitResults = True Then limit = CLng(Me.txtLimitResults) Else limit = totcomb
    n = UBound(pool) - LBound(pool) + 1 'Il numero di elementi da combinare
    countermax = Application.WorksheetFunction.Min(totcomb, limit)
    chunk = Me.txtChunk 'Il numero di elementi per ogni colonna/file di testo
        
    'Creo e rinomino il foglio che ospiter|fffd| le combinazioni generate, o apro la finestra di dialogo per la scelta della cartella
    If Me.optNewSheet = True Then
        Set cWs = Worksheets.Add
        On Error Resume Next
        cWs.Name = "Combinations"
        If Err.Number <> 0 Then
            num = 1
            Do
                Err.Clear
                num = num + 1
                cWs.Name = "Combinations " & Format(num, "0000")
            Loop Until Err.Number = 0
        End If
    Else
        fPath = FolderPicker
        If fPath = "" Then GoTo Aborted
    End If
    
    
    On Error GoTo Aborted
        
    'Popolo la collection dei risultati da estrarre in caso di limite impostato
    If Me.optLimitResults = True Then
        
        If limit <= totcomb * 0.8 Then
            Randomize Timer
            Do
                On Error Resume Next
                RandomResults.Add Round(1 + Rnd() * (totcomb - 1), 0), CStr(Round(1 + Rnd() * (totcomb - 1), 0))
                On Error GoTo Aborted
            Loop Until RandomResults.Count = limit
        Else
            For i = 1 To totcomb
                On Error Resume Next
                RandomResults.Add i, CStr(i)
                On Error GoTo Aborted
            Next i

            Randomize Timer
            Do
                RandomResults.Remove Round(Rnd() * (RandomResults.Count - 1), 0)
            Loop Until RandomResults.Count = limit
        End If
    End If
    
    'Dimensiono e popolo la matrice degli indici
    ReDim idx(1 To classe)
    For i = 1 To classe
        idx(i) = i
    Next i
    
    'Dimensiono la matrice dei risultati
    ReDim tabfinale(1 To Application.WorksheetFunction.Min(chunk, countermax), 1 To 1)
    
    cRow = 1        'Il numero di riga nella matrice finale
    cntLoops = 1    'Il contatore di reiterazioni (con o senza limite impostato)
    counter = 0     'Il contatore di combinazioni effettivamente scritte nella tabella finale
    cFiles = 1      'Il conteggio dei file di testo generati
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    UProgress.SetDescription "Sto generando le combinazioni richieste..."
    Call ShowProgressBar
    
    Do
        
        'Genero le combinazioni
        If CollKeyExists(RandomResults, CStr(cntLoops)) = True Or Me.optAllResults = True Then
            counter = counter + 1
            strComb = ""
            
            If CheckFilter(pool, idx) = True Then
            
                For j = 1 To classe
                    strComb = strComb & sep & pool(idx(j))
                Next j
                tabfinale(cRow, 1) = Mid(strComb, Len(sep) + 1)
                
                cRow = cRow + 1
        
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
                
                    
            'Invio le combinazioni all'output finale
            If (cRow > 1 And (cRow - 1) Mod chunk = 0) Or counter = countermax Then
                
                If Me.optNewSheet Then
                    cWs.Cells(1, 1).Offset(0, cOff).reSize(UBound(tabfinale, 1), 1) = tabfinale
                    cOff = cOff + 1
                    cRow = 1
                    ReDim tabfinale(1 To chunk, 1 To 1)
                Else
                    Close
                    f = FreeFile
                    fName = fPath & "\ESK_Combinazioni_" & Format(cFiles, "00000") & ".txt"
                    
                    Open fName For Output As #f
                        Print #f, "Combinazioni da " & (cFiles - 1) * chunk + 1 & " a " & Application.WorksheetFunction.Min(cFiles * chunk, counter) & " - generato il " & Now
                        For j = LBound(tabfinale) To Application.WorksheetFunction.Min(chunk, counter - (cFiles - 1) * chunk)
                            Print #f, tabfinale(j, 1)
                        Next j
                    Close #f
                    'Mi accerto che il file sia chiuso
                    Call CloseTxt(fName)
                    
                    cFiles = cFiles + 1
                    cRow = 1
                    
                    If counter < countermax Then
                        ReDim tabfinale(1 To Application.WorksheetFunction.Min(countermax - ((cFiles - 1) * chunk), chunk), 1 To 1)
                    End If
                End If
            End If
        
        End If
        
        ' Locate last non-max index
        i = classe
        While (idx(i) = n - classe + i)
            i = i - 1
            If i = 0 Then
                'All indexes have reached their max, so we're done
                Exit Do
            End If
        Wend

        'Increase it and populate the following indexes accordingly
        idx(i) = idx(i) + 1
        For j = i + 1 To classe
            idx(j) = idx(i) + j - i
        Next j
        
        cntLoops = cntLoops + 1
    Loop
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    Call AutoCalc(True)
                                    
    If Me.optTextFile = True Then
    
        Call AskFolder(fPath, countermax)
    
    End If
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub



Private Sub printDispositions(ByRef pool() As Variant, ByVal classe As Long)
    Dim rep As Boolean
    Dim sep As String
    Dim totcomb As Long     'Il totale di combinazioni possibili
    Dim limit As Long       'Il limite di combinazioni impostato
    Dim fPath As String     'Il percorso dove salvare i file di testo
    Dim cWs As Worksheet    'Il foglio di lavoro dove saranno scritte le combinazioni
    Dim num As Long
    Dim RandomResults As New Collection
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim n As Long
    Dim idx() As Variant
    Dim tabfinale As Variant
    Dim cOff As Long
    Dim cRow As Long
    Dim strComb As String
    Dim cntLoops As Long
    Dim cntLoopsNOREP As Long
    Dim f As Long
    Dim fName As String
    Dim cFiles As Long
    Dim chunk As Long
    Dim absMax As Long
    
    
    'Definisco alcune costanti
    rep = Me.optDispRep 'Stabilisce se le disposizioni sono con o senza ripetizione
    sep = Me.txtSeparator
    totcomb = CLng(Me.lblCombinations)
    If Me.optLimitResults = True Then limit = CLng(Me.txtLimitResults) Else limit = totcomb
    n = UBound(pool) - LBound(pool) + 1 'Il numero di elementi da combinare
    countermax = Application.WorksheetFunction.Min(totcomb, limit)
    
    'Definisco il massimo assoluto
    If Me.optRange = True Then
        absMax = Range(Me.refRange).Cells.Count ^ Me.txtClass
    Else
        absMax = (Me.txtNEnd - Me.txtNbegin + 1) ^ Me.txtClass
    End If
    
    chunk = Me.txtChunk 'Il numero di elementi per ogni colonna/file di testo
        
    'Creo e rinomino il foglio che ospiter|fffd| le combinazioni generate, o apro la finestra di dialogo per la scelta della cartella
    If Me.optNewSheet = True Then
        Set cWs = Worksheets.Add
        On Error Resume Next
        cWs.Name = "Dispositions"
        If Err.Number <> 0 Then
            num = 0
            Do
                Err.Clear
                num = num + 1
                cWs.Name = "Dispositions " & Format(num, "0000")
            Loop Until Err.Number = 0
        End If
    Else
        fPath = FolderPicker
        If fPath = "" Then GoTo Aborted
    End If
    
    On Error GoTo Aborted
        
    'Popolo la collection dei risultati da estrarre in caso di limite impostato
    If Me.optLimitResults = True Then
        
        If limit <= totcomb * 0.8 Then
            Randomize Timer
            Do
                On Error Resume Next
                num = Round(1 + Rnd() * (totcomb - 1), 0)
                RandomResults.Add num, CStr(num)
                On Error GoTo Aborted
            Loop Until RandomResults.Count = limit
        Else
            For i = 1 To totcomb
                On Error Resume Next
                RandomResults.Add i, CStr(i)
                On Error GoTo Aborted
            Next i

            Randomize Timer
            Do
                RandomResults.Remove Round(Rnd() * (RandomResults.Count - 1), 0)
            Loop Until RandomResults.Count = limit
        End If
    End If
    
    'Dimensiono e popolo la matrice degli indici
    ReDim idx(1 To classe)
    For i = 1 To classe
        idx(i) = 1
    Next i
    
    'Dimensiono la matrice dei risultati
    ReDim tabfinale(1 To Application.WorksheetFunction.Min(chunk, countermax), 1 To 1)
    
    cRow = 1            'Il numero di riga nella matrice finale
    cntLoops = 1        'Il contatore di reiterazioni (con o senza limite impostato)
    cntLoopsNOREP = 1   'Il contatore di reiterazioni senza ripetizione (con o senza limite impostato)
    counter = 0         'Il contatore di combinazioni effettivamente scritte nella tabella finale
    cFiles = 1          'Il conteggio dei file di testo generati
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    UProgress.SetDescription "Sto generando le combinazioni richieste..."
    Call ShowProgressBar
    
    Do
        
        'Genero le combinazioni
        strComb = ""
        For j = 1 To classe
            strComb = strComb & sep & pool(idx(j))
        Next j
        
        If CheckDisposition(idx) = True Or Me.optDispRep = True Then
            
            If CollKeyExists(RandomResults, CStr(cntLoopsNOREP)) Or Me.optAllResults = True Then
        
                counter = counter + 1
                
                If CheckFilter(pool, idx) = True Then
                    tabfinale(cRow, 1) = Mid(strComb, Len(sep) + 1)
                    cRow = cRow + 1
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
                'Invio le combinazioni all'output finale
                If (cRow > 1 And (cRow - 1) Mod chunk = 0) Or counter = countermax Or cntLoops = absMax Then
                    
                    If Me.optNewSheet Then
                        cWs.Cells(1, 1).Offset(0, cOff).reSize(UBound(tabfinale, 1), 1) = tabfinale
                        cOff = cOff + 1
                        cRow = 1
                        ReDim tabfinale(1 To chunk, 1 To 1)
                    Else
                        Close
                        f = FreeFile
                        fName = fPath & "\ESK_Combinazioni_" & Format(cFiles, "00000") & ".txt"
                        
                        Open fName For Output As #f
                            If lng = 0 Then
                                Print #f, "Combinazioni da " & (cFiles - 1) * chunk + 1 & " a " & Application.WorksheetFunction.Min(cFiles * chunk, counter) & " - generato il " & Now
                            Else
                                Print #f, "Combinations from " & (cFiles - 1) * chunk + 1 & " to " & Application.WorksheetFunction.Min(cFiles * chunk, counter) & " - generated on " & Now
                            End If
                                                        
                            For j = LBound(tabfinale) To Application.WorksheetFunction.Min(chunk, counter - (cFiles - 1) * chunk)
                                Print #f, tabfinale(j, 1)
                            Next j
                        Close #f
                        'Mi accerto che il file sia chiuso
                        Call CloseTxt(fName)
                        
                        cFiles = cFiles + 1
                        cRow = 1
                        
                        If counter < countermax Then
                            ReDim tabfinale(1 To Application.WorksheetFunction.Min(countermax - ((cFiles - 1) * chunk), chunk), 1 To 1)
                        End If
                    End If
                End If
                On Error GoTo 0
            End If
            
            cntLoopsNOREP = cntLoopsNOREP + 1

        End If
        
        
        ' Locate first non-max index
        i = classe
        While (idx(i) = n)
            i = i - 1
            If i = 0 Then
                'All indexes have reached their max, so we're done
                Exit Do
            End If
        Wend

        'Increase it and populate the following indexes accordingly
        idx(i) = idx(i) + 1
        
        For j = i + 1 To classe
            
            k = 1 - Abs(CInt(idx(j) = n))
            idx(j) = k * idx(j) + 1
        
        Next j
        
        cntLoops = cntLoops + 1
    Loop
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    Call AutoCalc(True)
                                    
    If Me.optTextFile = True Then
    
        Call AskFolder(fPath, countermax)
    
    End If
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub CheckNumbers()
    On Error Resume Next
    If Me.optRange = True Then
        For Each cell In Range(Me.refRange)
            If Application.WorksheetFunction.IsNumber(cell) = False Then
                Me.chkFilterSum = False
                Me.chkFilterSum.Enabled = False
                Exit Sub
            End If
        Next cell
    End If
        
    Me.chkFilterSum.Enabled = True
    On Error GoTo 0
End Sub

Private Function CheckDisposition(arr() As Variant) As Boolean
    Dim i As Long
    Dim cD As New Collection
    
    CheckDisposition = True
    On Error GoTo EndFunc
    For i = LBound(arr) To UBound(arr)
        cD.Add arr(i), CStr(arr(i))
    Next i
    Set cD = Nothing
    Exit Function
    
EndFunc:
    CheckDisposition = False
End Function

Private Function CheckFilter(arrpool() As Variant, arridx() As Variant) As Boolean
    Dim somma As Double
    Dim i As Long
    
    If Me.chkFilterSum = False Then
        CheckFilter = True
        Exit Function
    End If
    
    On Error Resume Next
    For i = LBound(arridx) To UBound(arridx)
        somma = somma + arrpool(arridx(i))
    Next i
    
    Select Case Me.cbxFilterSum.ListIndex
        Case 0  'Uguale a
            If somma = CLng(Me.txtFilterSum) Then CheckFilter = True
        Case 1  'Maggiore di
            If somma > CLng(Me.txtFilterSum) Then
                CheckFilter = True
            End If
        Case 2  'Minore di
            If somma < CLng(Me.txtFilterSum) Then CheckFilter = True
        Case 3  'Diverso da
            If somma <> CLng(Me.txtFilterSum) Then CheckFilter = True
    End Select
    On Error GoTo 0
End Function

Private Sub AskFolder(fPath As String, countermax As Long)
    Dim oFolder As Long
    oFolder = MsgBox(IIf(lng = 0, "Generazione di " & Format(countermax, "#,##0") & " combinazioni completata. Troverai i file nella cartella: " & _
                    vbNewLine & vbNewLine & _
                    fPath & _
                    vbNewLine & vbNewLine & _
                    "Vuoi aprire la cartella di destinazione?", _
                    "Generation of " & Format(countermax, "#,##0") & " combinations complete. You can find your files in this folder: " & _
                    vbNewLine & vbNewLine & _
                    fPath & _
                    vbNewLine & vbNewLine & _
                    "Would you like to open destination folder?"), _
                    vbInformation + vbYesNo, _
                    IIf(lng = 0, "Esportazione completata", "Export complete"))
                    
    If oFolder = vbYes Then Call OpenFolder(fPath)
    
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmCompactRange"
Attribute VB_Base = "0{BEDC30B8-AC89-44B1-9CE2-2E96B7E878CB}{563D4DF2-5D52-4551-896B-41624647F5EC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub optToUp_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optToDown_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optToLeft_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optToRight_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim inMatrix()
    Dim i As Long   '#' numero di righe nel range/matrice
    Dim j As Long   '#' numero di colonne nel range/matrice
    Dim n As Long
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    
    
    Call backup_create_new
    
    Set ws = ActiveSheet
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
    
        '#' Assegno il range alla matrice
        inMatrix = InRng
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto consolidando l'intervallo nel foglio " & ws.Name & " ..."
        Call ShowProgressBar
        
        If Me.optToUp Then
            For j = 1 To UBound(inMatrix, 2)
                For i = 1 To UBound(inMatrix, 1)
                
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                                            
                    If inMatrix(i, j) = "" Then
                        For n = i + 1 To UBound(inMatrix, 1)
                            If inMatrix(n, j) <> "" Then
                                inMatrix(i, j) = inMatrix(n, j)
                                inMatrix(n, j) = ""
                                Exit For
                            End If
                        Next n
                    End If
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                
                Next i
            Next j
        End If
            
        If Me.optToDown Then
            For j = 1 To UBound(inMatrix, 2)
                For i = UBound(inMatrix, 1) To 1 Step -1
                
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                                            
                    If inMatrix(i, j) = "" Then
                        For n = i - 1 To LBound(inMatrix, 1) Step -1
                            If inMatrix(n, j) <> "" Then
                                inMatrix(i, j) = inMatrix(n, j)
                                inMatrix(n, j) = ""
                                Exit For
                            End If
                        Next n
                    End If
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                
                Next i
            Next j
        End If
            
        If Me.optToLeft Then
            For i = 1 To UBound(inMatrix, 1)
                For j = 1 To UBound(inMatrix, 2)
                
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                                            
                    If inMatrix(i, j) = "" Then
                        For n = j + 1 To UBound(inMatrix, 2)
                            If inMatrix(i, n) <> "" Then
                                inMatrix(i, j) = inMatrix(i, n)
                                inMatrix(i, n) = ""
                                Exit For
                            End If
                        Next n
                    End If
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                
                Next j
            Next i
        End If
            
        If Me.optToRight Then
            For i = 1 To UBound(inMatrix, 1)
                For j = UBound(inMatrix, 2) To 1 Step -1
                
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                                            
                    If inMatrix(i, j) = "" Then
                        For n = j - 1 To LBound(inMatrix, 2) Step -1
                            If inMatrix(i, n) <> "" Then
                                inMatrix(i, j) = inMatrix(i, n)
                                inMatrix(i, n) = ""
                                Exit For
                            End If
                        Next n
                    End If
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                
                Next j
            Next i
        End If
            
        InRng = inMatrix
        
    End If
    
    Erase inMatrix
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmCompareRanges"
Attribute VB_Base = "0{B588632B-A4F7-4CDF-8687-2071DB8402FB}{6C30A589-4957-44D5-8D33-06BF714EF831}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean


Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    Call RefreshOpenFiles
        
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub chkAllNone_Change()
    Dim i As Long
    
    DisableEvents = True
    For i = 0 To Me.lbxCompareSheets.ListCount - 1
        Me.lbxCompareSheets.Selected(i) = Me.chkAllNone
    Next i
    DisableEvents = False
    
    Call GoodToGo(Me)
    
End Sub

Private Sub RefreshOpenFiles()
    Dim wb As Workbook
    Dim i As Long
    Dim CurrWb As String
    
    CurrWb = Me.cbxCompareFile.Value
    
    Me.cbxCompareFile.Clear
       
    For Each wb In Workbooks
        If UCase(wb.Name) <> "PERSONAL.XLSB" Then
            Me.cbxCompareFile.AddItem wb.Name
        End If
    Next wb
       
    For i = 1 To Me.cbxCompareFile.ListCount - 1
        If Me.cbxCompareFile.List(i) = CurrWb Then
            Me.cbxCompareFile.Value = CurrWb
            Exit For
        End If
    Next i
    
    If Me.cbxCompareFile <> CurrWb Or CurrWb = "" Then Me.cbxCompareFile = ActiveWorkbook.Name
    
    Call RefreshCompareSheets(Me.cbxCompareFile.Text)
       
End Sub

Private Sub RefreshCompareSheets(wb As String)
    Dim i As Long
    
    DisableEvents = True
    
    Me.lbxCompareSheets.Clear
    
    If wb = "" Then wb = ActiveWorkbook.Name
    
    With Workbooks(wb)
        For Each ws In .Worksheets
            If wb <> ActiveWorkbook.Name Or ws.Name <> ActiveSheet.Name And _
                (UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*") Then
                    Me.lbxCompareSheets.AddItem ws.Name
            End If
        Next ws
        For i = 0 To Me.lbxCompareSheets.ListCount - 1
            Me.lbxCompareSheets.Selected(i) = True
        Next i
    End With
    
    DisableEvents = False
    
End Sub

Private Sub txtFilterList_Change()
    Call RefreshCompareSheets(Me.cbxCompareFile.Text)
End Sub

Private Sub cmdBrowse_Click()
    Dim CurrWb As Workbook
    Dim FileName As Variant
    Dim TemplateFile As Workbook
    
    Set CurrWb = ActiveWorkbook
            
    FileName = OpenDialog(, , IIf(lng = 0, "Seleziona il file modello", "Select template file"), False)
    
    If FileName = False Then Exit Sub
    
    On Error Resume Next

        Set TemplateFile = Workbooks(FullPathToWBName(FileName))
        If Err.Number > 0 Then
            Err.Clear
            Set TemplateFile = Workbooks.Open(FileName, 0)
        End If
    On Error Resume Next
    
    Call RefreshOpenFiles
            
    Me.cbxCompareFile = TemplateFile.Name
    
    CurrWb.Activate

End Sub

Private Sub cbxCompareFile_DropButtonClick()
    Call RefreshCompareSheets(Me.cbxCompareFile.Text)
End Sub

Private Sub optFormulas_Change()
    Me.chkCase.Enabled = Not Me.optFormulas
End Sub

Private Sub chkHighlight_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkComment_Change()
    Call GoodToGo(Me)
End Sub

Private Sub lbxCompareSheets_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim sCount As Long
    Dim i As Long
    Dim check As Long
    Dim CompareWb As Workbook
    Dim CompareSh As Worksheet
    Dim cCell1 As Variant, cCell2 As Variant
    Dim strComment As String
    Dim mCount As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted

        .Hide
    
    End With
    
    Call AutoCalc(False)
    
    'Totale dei fogli selezionati
    sCount = CountListBox(Me.lbxCompareSheets)
    
    Set CompareWb = Workbooks(Me.cbxCompareFile.Text)
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ActiveSheet.Range(Replace(Me.refRange, ";", ",")), ActiveSheet)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge * sCount
    UProgress.SetDescription "Sto effettuando la comparazione..."
    Call ShowProgressBar
    
    For i = 0 To Me.lbxCompareSheets.ListCount - 1
        If Me.lbxCompareSheets.Selected(i) Then
            Set CompareSh = CompareWb.Worksheets(Me.lbxCompareSheets.List(i))
            
            For Each cell In InRng.Cells
                            
                '#' Aumento di 1 il contatore
                counter = counter + 1
                            
                If lng = 0 Then
                    strComment = "Cella corrispondente nel foglio " & ActiveSheet.Name & ": " & vbNewLine & "Formula: " & cell.FormulaLocal & vbNewLine & "Valore: " & cell.Value2
                Else
                    strComment = "Corresponding cell in Sheet " & ActiveSheet.Name & ": " & vbNewLine & "Formula: " & cell.FormulaLocal & vbNewLine & "Value: " & cell.Value2
                End If
            
                If Me.chkCase.Enabled = True And Me.chkCase = False Then
                    cCell1 = UCase(cell.Value2)
                    cCell2 = UCase(CompareSh.Range(cell.address).Value2)
                Else
                    cCell1 = cell.Value2
                    cCell2 = CompareSh.Range(cell.address).Value2
                End If
                
                check = 0
                
                If Me.optEverything Then
                
                    If cell.HasFormula Or CompareSh.Range(cell.address).HasFormula Then
                        If cell.Formula <> CompareSh.Range(cell.address).Formula And _
                            cCell1 <> cCell2 Then
                            check = 1: If Me.chkHighlight = True Then CompareSh.Range(cell.address).Interior.Color = vbYellow
                        ElseIf cell.Formula <> CompareSh.Range(cell.address).Formula Then
                            check = 1: If Me.chkHighlight = True Then CompareSh.Range(cell.address).Interior.Color = vbGreen
                        ElseIf cCell1 <> cCell2 Then
                            check = 1: If Me.chkHighlight = True Then CompareSh.Range(cell.address).Interior.Color = vbCyan
                        End If
                    Else
                        If cCell1 <> cCell2 Then
                            check = 1: If Me.chkHighlight = True Then CompareSh.Range(cell.address).Interior.Color = vbCyan
                        End If
                    End If
                    
                ElseIf Me.optValue Then
                
                    If cCell1 <> cCell2 Then
                        check = 1: If Me.chkHighlight = True Then CompareSh.Range(cell.address).Interior.Color = vbCyan
                    End If
                    
                ElseIf Me.optFormulas Then
                    If cell.HasFormula Or CompareSh.Range(cell.address).HasFormula Then
                        If cell.Formula <> CompareSh.Range(cell.address).Formula Then
                            check = 1: If Me.chkHighlight = True Then CompareSh.Range(cell.address).Interior.Color = vbGreen
                        End If
                    End If
                End If
                       
                If Me.chkComment = True And check = 1 Then
                    CompareSh.Range(cell.address).ClearComments
                    CompareSh.Range(cell.address).AddComment (strComment)
                    CompareSh.Range(cell.address).Comment.Shape.TextFrame.AutoSize = True
                End If
                
                mCount = mCount + check
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next cell
            
        End If
    Next i
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
                                
    Call AutoCalc(True)
    
    If lng = 0 Then
        If mCount = 0 Then
            MsgBox "I " & sCount & " fogli analizzati risultano identici secondo i parametri impostati", vbInformation, "Risultato del confronto"
        Else
            MsgBox "Sono state trovate " & mCount & " celle diverse in " & sCount & " fogli analizzati, secondo i parametri impostati", vbInformation, "Risultato del confronto"
        End If
    Else
        If mCount = 0 Then
            MsgBox "The " & sCount & " analyzed sheets were found to be identical, according to your set criteria", vbInformation, "Results summary"
        Else
            MsgBox mCount & " different cells in " & sCount & " analyzed sheets were found, according to your set criteria", vbInformation, "Results summary"
        End If
    End If
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmCompute"
Attribute VB_Base = "0{94B1E1F0-53A0-4A63-9F62-E69F791F8437}{2F207DE6-45AC-482C-84AD-AFBCE309CF98}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then
        Call TranslateForm(Me)
        With Me.cbxOperator
            .AddItem "+ (add)"             '0
            .AddItem "- (subtract)"              '1
            .AddItem "* (multiply by)"       '2
            .AddItem "/ (divide by)"           '3
            .AddItem "^ (exponentiation)"  '4
            .AddItem "Add N %"           '5
            .AddItem "Subtract N %"        '6
            .AddItem "Custom"        '7
        End With
    Else
        With Me.cbxOperator
            .AddItem "+ (aggiungi)"             '0
            .AddItem "- (sottrai)"              '1
            .AddItem "* (moltiplica per)"       '2
            .AddItem "/ (dividi per)"           '3
            .AddItem "^ (eleva a Nma potenza)"  '4
            .AddItem "Aggiungi N %"           '5
            .AddItem "Sottrai N %"        '6
            .AddItem "Personalizzata"        '7
        End With
    End If
    Me.cbxOperator.ListIndex = 0
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub txtfactor_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If Me.cbxOperator.ListIndex <> 7 Then
        If KeyAscii = 46 Or KeyAscii = 44 Then
            KeyAscii = Asc(dSep)
        ElseIf KeyAscii = 45 Then
        ElseIf KeyAscii < 48 Or KeyAscii > 57 Then
            KeyAscii = 0
        End If
    End If
End Sub

Private Sub txtfactor_Change()
    Call GoodToGo(Me)
    Me.txtfactor.ControlTipText = Me.txtfactor.Text
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        If .cbxOperator.ListIndex <> 7 And (IsNumeric(.txtfactor) = False Or (.cbxOperator.ListIndex = 3 And Val(.txtfactor = 0))) Then
            MsgBox TranslateCnst("NoNumberDIV0"), vbExclamation
            .txtfactor.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        .Hide
    
    End With
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    If Me.tglBatch = False Then '#' NO BATCH

        '#' Crea foglio di backup nascosto
        Call backup_create_new
    
        Set ws = ActiveSheet
            
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
                
        Else
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto applicando le operazioni... (" & ws.Name & ")"
            Call ShowProgressBar
            
            For Each cell In InRng.Cells
            
                'Aumenta di 1 il contatore
                counter = counter + 1
        
                Call elaboracella(cell)
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next cell
                
        End If
        
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto applicando le operazioni... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto effettuando le sostituzioni... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True

NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
    'Chiude la finestra di avanzamento
    Unload UProgress
    
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub elaboracella(Cella As Range)
    Dim Factor As Variant

    If Application.WorksheetFunction.IsNumber(Cella) Then
        If Me.chkFormulas And Cella.HasFormula And Not Cella.HasArray Then
            Factor = Replace(Me.txtfactor, ",", ".")
            Select Case Me.cbxOperator.ListIndex
                Case 0 'Somma
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")+" & Factor
                Case 1 'Sottrazione
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")-" & Factor
                Case 2 'Moltiplicazione
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")*" & Factor
                Case 3 'Divisione
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")/" & Factor
                Case 4 'Eleva a potenza
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")^" & Factor
                Case 5 'Aumenta di N %
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")*(" & 1 + Factor / 100 & ")"
                Case 6 'Diminuisci di N %
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")*(" & 1 - Factor / 100 & ")"
                Case 7 'Personalizzata
                    Cella.Formula = "=(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")" & Factor
            End Select
        Else
            If Me.cbxOperator.ListIndex <> 7 Then Factor = CDbl(Replace(Me.txtfactor, ".", ","))
            Select Case Me.cbxOperator.ListIndex
                Case 0 'Somma
                    Cella = Cella + Factor
                Case 1 'Sottrazione
                    Cella = Cella - Factor
                Case 2 'Moltiplicazione
                    Cella = Cella * Factor
                Case 3 'Divisione
                    Cella = Cella / Factor
                Case 4 'Eleva a potenza
                    Cella = Cella ^ Factor
                Case 5 'Aumenta di N %
                    Cella = Cella * (1 + Factor / 100)
                Case 6 'Diminuisci di N %
                    Cella = Cella * (1 - Factor / 100)
                Case 7 'Personalizzata
                    Cella = "=(" & Cella & ")" & Me.txtfactor
            End Select
        End If
    End If

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmConditionalSelectCells"
Attribute VB_Base = "0{AFA4DA0C-7DE3-4FA1-9F90-C4294260D9CF}{826E3822-7A56-4A53-8CA0-CF0225A0505E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    Call SaveOptions(Me)
    
    If lng = 0 Then
        With Me.cobContent
            .AddItem "Uguale a:"                '0
            .AddItem "Uguale a (TESTO):"        '1
            .AddItem "Diverso da:"              '2
            .AddItem "Diverso da (TESTO):"      '3
            .AddItem "Maggiore di:"             '4
            .AddItem "Maggiore o uguale a:"     '5
            .AddItem "Minore di:"               '6
            .AddItem "Minore o uguale a:"       '7
            .AddItem "Compreso tra:"            '8
            .AddItem "Non compreso tra:"        '9
            .AddItem "Contiene:"                '10
            .AddItem "Non contiene:"            '11
            .AddItem "== Tipo di dato =="       '12
            .AddItem "Celle numeriche"           '13
            .AddItem "Celle testuali"            '14
            .AddItem "Celle con formule (tutte)"    '15
            .AddItem "Celle con formule (errori)"   '16
            .AddItem "Celle vuote"              '17
        End With
        With Me.cobFormat
            .AddItem "font = grassetto"         '0
            .AddItem "font <> grassetto"        '1
            .AddItem "font = corsivo"           '2
            .AddItem "font <> corsivo"          '3
            .AddItem "font = sottolineato"      '4
            .AddItem "font <> sottolineato"     '5
        End With
    Else
        With Me.cobContent
            .AddItem "Equal to:"                '0
            .AddItem "Equal to (TEXT):"        '1
            .AddItem "Not equal to:"              '2
            .AddItem "Not equal to (TEXT):"      '3
            .AddItem "Greater than:"             '4
            .AddItem "Greater or equal to:"     '5
            .AddItem "Lower than:"               '6
            .AddItem "Lower or equal to:"       '7
            .AddItem "Between:"            '8
            .AddItem "Not between:"        '9
            .AddItem "Contains:"                '10
            .AddItem "Doesn't contain:"            '11
            .AddItem "== Data type =="       '12
            .AddItem "Numeric"           '13
            .AddItem "Text"            '14
            .AddItem "Formulas (all)"    '15
            .AddItem "Formulas (errors)"   '16
            .AddItem "Empty cells"              '17
        End With
        With Me.cobFormat
            .AddItem "font = bold"         '0
            .AddItem "font <> bold"        '1
            .AddItem "font = italic"           '2
            .AddItem "font <> italic"          '3
            .AddItem "font = underlined"      '4
            .AddItem "font <> underlined"     '5
        End With
    End If
    
    Me.cobContent = Me.cobContent.List(0)
    Me.cobFormat = Me.cobFormat.List(0)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then
        Call TranslateForm(Me)
        Me.mpgCriteria.Pages(0).Caption = TranslateCnst("Me.mpgCriteria.Pages(0)")
        Me.mpgCriteria.Pages(1).Caption = TranslateCnst("Me.mpgCriteria.Pages(1)")
    End If
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub


Private Sub cobContent_Change()
    Select Case Me.cobContent.ListIndex
        Case 0, 4, 5, 6, 7
            Me.optAll.Enabled = False
            Me.optTxt.Enabled = False
            Me.optDigits.Enabled = False
            Me.optDigits = True
            Me.lblAnd.visible = False
            Me.txtVal1.visible = True
            Me.txtVal2.visible = False
            Me.txtVal1.Width = 48
            Me.txtVal1.TextAlign = fmTextAlignCenter
        Case 1
            Me.optAll.Enabled = False
            Me.optTxt.Enabled = False
            Me.optDigits.Enabled = False
            Me.optTxt = True
            Me.lblAnd.visible = False
            Me.txtVal1.visible = True
            Me.txtVal2.visible = False
            Me.txtVal1.Width = 100
            Me.txtVal1.TextAlign = fmTextAlignLeft
        Case 2
            Me.optAll.Enabled = True
            Me.optTxt.Enabled = False
            Me.optDigits.Enabled = True
            Me.optDigits = True
            Me.lblAnd.visible = False
            Me.txtVal1.visible = True
            Me.txtVal2.visible = False
            Me.txtVal1.Width = 48
            Me.txtVal1.TextAlign = fmTextAlignCenter
        Case 3
            Me.optAll.Enabled = True
            Me.optTxt.Enabled = True
            Me.optDigits.Enabled = False
            Me.lblAnd.visible = False
            Me.txtVal1.visible = True
            Me.txtVal2.visible = False
            Me.txtVal1.Width = 100
            Me.txtVal1.TextAlign = fmTextAlignLeft
        Case 8
            Me.optAll.Enabled = False
            Me.optTxt.Enabled = False
            Me.optDigits.Enabled = False
            Me.lblAnd.visible = True
            Me.txtVal1.visible = True
            Me.txtVal2.visible = True
            Me.optDigits = True
            Me.txtVal1.Width = 48
            Me.txtVal1.TextAlign = fmTextAlignCenter
        Case 9
            Me.optAll.Enabled = False
            Me.optTxt.Enabled = False
            Me.optDigits.Enabled = False
            Me.lblAnd.visible = True
            Me.txtVal1.visible = True
            Me.txtVal2.visible = True
            Me.optDigits = True
            Me.txtVal1.Width = 48
            Me.txtVal1.TextAlign = fmTextAlignCenter
        Case 10, 11
            Me.optAll.Enabled = True
            Me.optTxt.Enabled = True
            Me.optDigits.Enabled = True
            Me.lblAnd.visible = False
            Me.txtVal1.visible = True
            Me.txtVal2.visible = False
            Me.txtVal1.Width = 100
            Me.txtVal1.TextAlign = fmTextAlignLeft
        Case 13 To 17
            Me.lblAnd.visible = False
            Me.txtVal1.visible = False
            Me.txtVal2.visible = False
            
    End Select
    
    Me.fraType.visible = Me.cobContent.ListIndex < 12

    If Me.cobContent.ListIndex = 12 Then Me.cobContent.ListIndex = 13

End Sub

Private Sub txtVal1_Change()
    Me.txtVal1.ControlTipText = Me.txtVal1.Text
End Sub

Private Sub txtVal2_Change()
    Me.txtVal2.ControlTipText = Me.txtVal2.Text
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim SelRng As Range
    Dim MyRng As Range
    Dim i As Long
    Dim r As Long
    Dim areasArray() As String
    Dim cCount As Long
    Dim testRng As Range
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
    
        If .mpgCriteria.Value = 0 Then
            Select Case .cobContent.ListIndex
                Case 0, 2, 4 To 7
                    If Not IsNumeric(.txtVal1) Then
                        MsgBox TranslateCnst("NumbersOnly"), vbExclamation
                        .txtVal1.SetFocus
                        Exit Sub
                    End If
                Case 8, 9
                    If Val(Me.txtVal1) > Val(Me.txtVal2) Or Not IsNumeric(.txtVal1) Or Not IsNumeric(Me.txtVal2) Then
                        MsgBox TranslateCnst("Numbers2>1"), vbExclamation
                        .txtVal2.SetFocus
                        Exit Sub
                    End If
            End Select
        End If
    
        .Hide
    
    Call AutoCalc(False)
        
        
        On Error GoTo Aborted
        
        Set ws = ActiveSheet
        
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set SelRng = ws.Range(Replace(.refRange, ";", ","))
        On Error Resume Next
            
        If .mpgCriteria.Value = 0 And .cobContent.ListIndex > 12 Then
    
            Select Case .cobContent.ListIndex
            
                Case 13 'Numeri
                    Set InRng = SelRng.SpecialCells(xlCellTypeConstants, xlNumbers)
                Case 14 'Testo
                    Set InRng = SelRng.SpecialCells(xlCellTypeConstants, xlTextValues)
                Case 15 'Formule (tutte)
                    Set InRng = SelRng.SpecialCells(xlCellTypeFormulas)
                Case 16 'Formule (errori)
                    Set InRng = SelRng.SpecialCells(xlCellTypeFormulas, 16)
                Case 17 'Celle vuote
                    Set InRng = SelRng.SpecialCells(xlCellTypeBlanks)
            
            End Select
            
            If Err.Number <> 0 Then Set InRng = Nothing
        Else
            Set InRng = SelRng
        End If
            
        i = 0
        ReDim areasArray(0 To 0)
        
        For Each cell In InRng.Cells
            Select Case .mpgCriteria.Value
                Case 0  'Seleziona in base al contenuto
                    Select Case .cobContent.ListIndex
                        Case 0 'Uguale a:
                            If Application.WorksheetFunction.IsNumber(cell) Then
                                If cell.Value = Val(.txtVal1) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 1 'Uguale a (TESTO):
                            If cell.Value = .txtVal1 Then
                                If MyRng Is Nothing Then
                                    Set MyRng = cell
                                Else
                                    Set MyRng = Union(MyRng, cell)
                                End If
                            End If
                        Case 2 'Diverso da:
                            If .optDigits Then
                                If cell.Value <> Val(.txtVal1) And Application.WorksheetFunction.IsNumber(cell) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            Else
                                If cell.Value <> Val(.txtVal1) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 3 'Diverso da (TESTO):
                            If .optTxt Then
                                If cell.Value <> .txtVal1 And Not Application.WorksheetFunction.IsNumber(cell) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            Else
                                If cell.Value <> .txtVal1 Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 4 'Maggiore di:
                            If Application.WorksheetFunction.IsNumber(cell) Then
                                If cell.Value > Val(.txtVal1) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 5 'Maggiore o uguale a:
                            If Application.WorksheetFunction.IsNumber(cell) Then
                                If cell.Value >= Val(.txtVal1) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 6 'Minore di:
                            If Application.WorksheetFunction.IsNumber(cell) Then
                                If cell.Value < Val(.txtVal1) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 7 'Minore o uguale a:
                            If Application.WorksheetFunction.IsNumber(cell) Then
                                If cell.Value <= Val(.txtVal1) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 8 'Compreso tra:
                            If Application.WorksheetFunction.IsNumber(cell) Then
                                If cell.Value >= Val(.txtVal1) And cell.Value <= Val(.txtVal2) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 9 'Non compreso tra:
                            If Application.WorksheetFunction.IsNumber(cell) Then
                                If cell.Value < Val(.txtVal1) Or cell.Value > Val(.txtVal2) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 10 'Contiene:
                            If .optTxt Then
                                If InStr(1, cell, .txtVal1) And Not Application.WorksheetFunction.IsNumber(cell) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            ElseIf .optDigits Then
                                If InStr(1, cell, .txtVal1) And Application.WorksheetFunction.IsNumber(cell) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            Else
                                If InStr(1, cell, .txtVal1) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case 11 'Non contiene:
                            If .optTxt Then
                                If InStr(1, cell, .txtVal1) = False And Not Application.WorksheetFunction.IsNumber(cell) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            ElseIf .optDigits Then
                                If InStr(1, cell, .txtVal1) = False And Application.WorksheetFunction.IsNumber(cell) Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            Else
                                If InStr(1, cell, .txtVal1) = False Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                            End If
                        Case Is > 11
                            If MyRng Is Nothing Then
                                Set MyRng = cell
                            Else
                                Set MyRng = Union(MyRng, cell)
                            End If
                            
                    End Select
                Case 1  'Seleziona in base alla formattazione
                    Select Case .cobFormat.ListIndex
                        Case 0 'Grassetto
                            If cell.Font.Bold = True Then
                                If MyRng Is Nothing Then
                                    Set MyRng = cell
                                Else
                                    Set MyRng = Union(MyRng, cell)
                                End If
                            End If
                        Case 1 'Non grassetto
                                If cell.Font.Bold = False Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                        Case 2 'Corsivo
                            If cell.Font.Italic = True Then
                                If MyRng Is Nothing Then
                                    Set MyRng = cell
                                Else
                                    Set MyRng = Union(MyRng, cell)
                                End If
                            End If
                        Case 3 'Non corsivo
                                If cell.Font.Italic = False Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                        Case 4 'Sottolineato
                            If cell.Font.Underline <> xlUnderlineStyleNone Then
                                If MyRng Is Nothing Then
                                    Set MyRng = cell
                                Else
                                    Set MyRng = Union(MyRng, cell)
                                End If
                            End If
                        Case 5 'Non sottolineato
                                If cell.Font.Underline = xlUnderlineStyleNone Then
                                    If MyRng Is Nothing Then
                                        Set MyRng = cell
                                    Else
                                        Set MyRng = Union(MyRng, cell)
                                    End If
                                End If
                    End Select
            End Select
            
            areasArray(i) = MyRng.address
            
            If Len(areasArray(i)) > 230 Then
                i = i + 1
                ReDim Preserve areasArray(0 To i)
                Set MyRng = Nothing
            End If
            
        Next cell
        
        On Error GoTo Aborted
        
        'Selezione finale
        If Not MyRng Is Nothing Then
            
            Set testRng = Range(areasArray(0))
            If UBound(areasArray) > 0 Then
                For r = 1 To UBound(areasArray)
                    Set testRng = Union(testRng, Range(areasArray(r)))
                Next r
            End If
            
            cCount = testRng.Cells.Count
        
            If lng = 0 Then
                MsgBox "Sono state trovate " & cCount & " celle corrispondenti ai criteri", vbInformation, "Celle selezionate"
            Else
                MsgBox cCount & " cells matching your criteria have been found", vbInformation, "Selected cells"
            End If
            
            testRng.Select
        
        Else
            If lng = 0 Then
                MsgBox "Non sono state trovate celle corrispondenti", vbInformation
            Else
                MsgBox "No cells matching your criteria have been found", vbInformation
            End If
                
            SelRng(1, 1).Select
        
        End If
                
        '#' Riattiva aggiornamenti automatici
        Call AutoCalc(True)
            
        If Me.chkClose = False Then Me.Show
    
        Exit Sub
    End With
    
Aborted:
    Call CanceledProcedure
    
End Sub
Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmConvertCase"
Attribute VB_Base = "0{D2BD325A-CC02-49E2-B8BA-98EA3A0FB990}{86E0D346-0192-4E25-B46F-BA1C69C2CB07}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

    Call GoodToGo(Me)

End Sub


Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkFormulas_Change()
    Me.optInvert.Enabled = Not Me.chkFormulas
    Me.optFirstonly.Enabled = Not Me.chkFormulas
    Me.chkApostrophe.Enabled = Not Me.chkFormulas
    If Me.chkFormulas = True Then Me.chkApostrophe = False
End Sub
Private Sub optProper_Change()
    If Me.chkFormulas = False Then
        Me.chkApostrophe.Enabled = Me.optProper
    Else
        Me.chkApostrophe.Enabled = False
    End If
End Sub
Private Sub optUpper_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optLower_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optProper_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optFirstonly_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optInvert_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    If Me.tglBatch = False Then '#' NO BATCH
    
        Call backup_create_new
        
        Set ws = ActiveSheet
            
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto effettuando la conversione... (" & ws.Name & ")"
        Call ShowProgressBar
                    
        For Each cell In InRng.Cells
        
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            Call elaboracella(cell)
                    
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
    
        Next cell
    
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto effettuando la conversione... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto effettuando la conversione... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            wb.Close True
NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub



Private Sub elaboracella(Cella As Range)
    Dim i As Long
    Dim ch As String
    Dim NewString As String

    If Not IsNumeric(Cella) And Not IsError(Cella) Then
    
        If Me.chkFormulas And Cella.HasFormula And Not Cella.HasArray Then
            If Me.optUpper Then Cella.Formula = "=UPPER(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")"
            If Me.optLower Then Cella = "=LOWER(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")"
            If Me.optProper Then
                If Me.chkApostrophe Then
                    Cella.Formula = "=SUBSTITUTE(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ",""'"","" '"")"
                    Cella.Formula = "=PROPER(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ")"
                    Cella.Formula = "=SUBSTITUTE(" & Right(Cella.Formula, Len(Cella.Formula) - 1) & ","" '"",""'"")"
                Else
                    Cella = "=PROPER(" & Mid(Cella.Formula, 2) & ")"
                End If
            End If
        Else
            If Me.optUpper Then Cella = StrConv(Cella, vbUpperCase)
            If Me.optLower Then Cella = StrConv(Cella, vbLowerCase)
            If Me.optProper Then
                If Me.chkApostrophe Then
                    Cella = Application.WorksheetFunction.Proper(Cella)
                Else
                    Cella = StrConv(Cella, vbProperCase)
                End If
            End If
            If Me.optFirstonly Then Cella = UCase(Left(Cella, 1)) & LCase(Mid(Cella, 2))
            If Me.optInvert Then
                NewString = ""
                For i = 1 To Len(Cella)
                    ch = Mid(Cella, i, 1)
                    If UCase(ch) = ch Then
                        NewString = NewString & LCase(ch)
                    Else
                        NewString = NewString & UCase(ch)
                    End If
                Next i
                Cella = NewString
            End If
        
        End If
    
    End If

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmConvertFileFormat"
Attribute VB_Base = "0{57F94A19-25B4-442D-9471-561DBD53124E}{8633924A-FC9C-4457-BDCB-1259CFD65770}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
        
    Call SaveOptions(Me)
    
    Me.lbxOriginalFiles.RowSource = ""
    Me.lbxOriginalFiles.Clear
    
    With Me.cbxFormat
        .AddItem "Excel 2007+ (.xlsx)"
        .AddItem IIf(lng = 0, "Excel 2007+ con macro (.xlsm)", "Excel 2007+ macro-enabled (.xlsm)")
        .AddItem "Excel 97-2003 (.xls)"
        .AddItem "Excel 95/5.0 (.xls)"
        .AddItem "PDF multipage (.pdf)"
        .AddItem "Open Document Format (.ods)"
        .AddItem IIf(lng = 0, "Testo con delimitatore (.csv)", "Comma separated values (.csv)")
        .ListIndex = 0
    End With

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
        
    Call GoodToGo(Me)

    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
        
    If Me.txtOutputFolder = "" Then Me.txtOutputFolder = SettingsPath
    If Me.txtActionMove = "" Then Me.txtActionMove = SettingsPath
    
End Sub

Private Sub cmdAdd_Click()
    Dim i As Integer
    Dim FileList As Collection
    Dim FileName As Variant
    Dim Item As Variant
    Dim MaxColWidth As String
    
    Set FileList = New Collection
    On Error Resume Next
    For i = 0 To Me.lbxOriginalFiles.ListCount - 1
        FileList.Add Me.lbxOriginalFiles.List(i), CStr(Me.lbxOriginalFiles.List(i))
    Next i
    On Error GoTo 0
        
    
    FileName = OpenDialog(Me.txtPath.Text, "File gestibili da Excel, *.xl??;*.od?;*.csv;*.txt", "Seleziona i file da importare", True)
                       
    If IsArray(FileName) = False Then Exit Sub
    
    On Error Resume Next
    For i = LBound(FileName) To UBound(FileName)
        If i = LBound(FileName) Then 'Aggiorno il percorso nella textbox nascosta
            Me.txtPath = Replace(FileName(i), Dir(FileName(i)), "")
        End If
        
        FileList.Add FileName(i), CStr(FileName(i))
    Next i
    
    Me.lbxOriginalFiles.Clear
            
    For Each Item In FileList
        Me.lbxOriginalFiles.AddItem Item
        If Len(CStr(Item)) * 5 > MaxColWidth Then
            MaxColWidth = Len(CStr(Item)) * 5
            Me.lbxOriginalFiles.ColumnWidths = MaxColWidth
        End If
    Next Item
    On Error GoTo 0
    
    Call GoodToGo(Me)
    
End Sub
Private Sub cmdDelete_Click()
    Dim i As Long
    Dim counter As Long
    
    counter = 0
    For i = 0 To Me.lbxOriginalFiles.ListCount - 1
        If Me.lbxOriginalFiles.Selected(i - counter) = True Then
            Me.lbxOriginalFiles.RemoveItem (i - counter)
            counter = counter + 1
        End If
    Next i
    
    Call GoodToGo(Me)
    
End Sub
Private Sub cmdEmptyList_Click()
    Me.lbxOriginalFiles.Clear
    Call GoodToGo(Me)
End Sub

Private Sub cbxFormat_Change()
    If Me.cbxFormat.ListIndex = 4 Then
        Call Excel2007PDF
    End If
End Sub

Private Sub optCustomPath_Change()
    Me.txtOutputFolder.Enabled = Me.optCustomPath
    Me.cmdOutputFolder.Enabled = Me.optCustomPath
End Sub
Private Sub optActionMove_Change()
    Me.txtActionMove.Enabled = Me.optActionMove
    Me.cmdActionMove.Enabled = Me.optActionMove
End Sub

Private Sub cmdOutputFolder_Click()
    Dim strTemp As String
    
    strTemp = Me.txtOutputFolder.Text
    
    Me.txtOutputFolder.Text = FolderPicker(Me.txtOutputFolder.Text, IIf(lng = 0, "Seleziona la cartella dove salvare i file convertiti", "Please select a folder"))
    
    If Me.txtOutputFolder.Text = "" Then Me.txtOutputFolder.Text = strTemp
    
    Me.txtOutputFolder.ControlTipText = Me.txtOutputFolder.Text
End Sub

Private Sub cmdActionMove_Click()
    Dim strTemp As String
    
    strTemp = Me.txtActionMove
    
    Me.txtActionMove.Text = FolderPicker(Me.txtActionMove.Text, IIf(lng = 0, "Seleziona la cartella dove spostare i file originali", "Please select a folder"))

    If Me.txtActionMove.Text = "" Then Me.txtActionMove.Text = strTemp
    
    Me.txtActionMove.ControlTipText = Me.txtActionMove.Text
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim FileExtStr As String
    Dim FileFormatNum As Long
    Dim CurrWb As Workbook
    Dim ErrNum As Long
    Dim ErrorFiles As New Collection
    Dim ResultSummary As String
    Dim OutPath As String
    Dim MovePath As String
    Dim fName As String
    Dim i As Long
    Dim e As Long
    Dim FileProg As Long
    Dim ErrorString As String
    
    With Me
    
        .Hide
    
    End With
    
    
    Call AutoCalc(False)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.lbxOriginalFiles.ListCount
    UProgress.SetDescription "Conversione in corso..."
    Call ShowProgressBar
    
    'Definisco il formato di esportazione
    Select Case Me.cbxFormat.ListIndex
        Case 0 '#' Excel 2007+
            FileExtStr = ".xlsx"
            FileFormatNum = 51
        Case 1 '#' Excel 2007+ con macro
            FileExtStr = ".xlsm"
            FileFormatNum = 52
        Case 2 '#' Excel 97-2003
            FileExtStr = ".xls"
            FileFormatNum = 56
        Case 3 '#' Excel 95/5.0
            FileExtStr = ".xls"
            FileFormatNum = 39
        Case 4 '#' PDF
            '#' No variables set
        Case 5
            FileExtStr = ".ods"
            FileFormatNum = 60
        Case 6
            FileExtStr = ".csv"
            FileFormatNum = 6
    End Select
    
    'Definisco i percorsi custom se opzioni abilitate
    If Me.optCustomPath = True Then OutPath = ValidateFolder(Me.txtOutputFolder.Text)
    If Me.optActionMove = True Then MovePath = ValidateFolder(Me.txtActionMove.Text)
    
    For i = 0 To Me.lbxOriginalFiles.ListCount - 1
        
        On Error GoTo NextFile 'Da qui in poi se c'|fffd| un errore vado al prossimo file
        
        '#' Aumento di 1 il contatore
        counter = counter + 1
    
        Set CurrWb = Workbooks.Open(Me.lbxOriginalFiles.List(i), 0, True)
        
        With CurrWb
            UProgress.SetDescription "Conversione in corso... (" & .Name & ")"
            
            fName = FullPathToWBName(.FullName, False)
            If Me.optOriginalPath Then OutPath = ValidateFolder(.path)
            
            '#' Routine per rinominare in automatico i file se esistono gi|fffd| nell'output
            ErrNum = 0
            Do While Dir(OutPath & fName & FileExtStr) <> ""
                ErrNum = ErrNum + 1
                fName = FullPathToWBName(.FullName, False) & "(" & Format(ErrNum, "000") & ")"
            Loop
            
            '#' Save the new workbook and close it
            Application.DisplayAlerts = False
            
            Select Case Me.cbxFormat.ListIndex
                Case 4 '#' PDF
                    .Sheets.Select
                    ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, FileName:=OutPath & fName & ".pdf", Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:=False
                Case 6 '#' CSV
                    
                    '#' Routine per salvare ciascun foglio in un file csv numerato progressivamente
                    FileProg = 0
                    For Each ws In .Worksheets
                        If UCase(ws.Name) <> "ESK_BACKUP" Then
                            ws.Copy
                            FileProg = FileProg + 1
                            With ActiveWorkbook
                                .SaveAs OutPath & fName & "_" & Format(FileProg, "0000") & FileExtStr, FileFormat:=FileFormatNum, Local:=True
                                .Close False
                            End With
                        End If
                    Next ws
                Case Else
                    Call SaveFile(CurrWb, OutPath & fName & FileExtStr, FileFormatNum, NewFileLocal:=True, Silent:=True)
            End Select
            
            Application.DisplayAlerts = True
            
NextFile: 'punto di rimando se il file genera qualche errore

            'Chiudo il file da convertire
            If Not CurrWb Is Nothing Then .Close (False)
            
        End With 'CurrWb
        
        Set CurrWb = Nothing
        
        'Eseguo eventuale operazione su file originale
        Application.DisplayAlerts = False
        If Me.optActionDelete = True Then
            Kill Me.lbxOriginalFiles.List(i)
        ElseIf Me.optActionMove = True Then
            Name Me.lbxOriginalFiles.List(i) As MovePath & FullPathToWBName(Me.lbxOriginalFiles.List(i))
        End If
        Application.DisplayAlerts = True
        
        'Se si |fffd| generato un errore nell'importazione del file, aggiungi alla Collection
        If Err.Number <> 0 Then
            Err.Clear
            ErrorFiles.Add Me.lbxOriginalFiles.List(i), CStr(Me.lbxOriginalFiles.List(i))
            On Error GoTo -1
        End If
                        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        DoEvents
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
        
    Next i
        
    '#' Chiude la finestra di avanzamento
    Unload UProgress
        
    Call AutoCalc(True)
    
    '#' Mostra un avviso con l'esito dell'operazione
    ResultSummary = IIf(lng = 0, "Conversione completata: sono stati elaborati " & counter & " file", _
                        "Import complete: " & counter & " files were processed")
    
    If ErrorFiles.Count > 0 Then
        
        ErrorString = IIf(lng = 0, "I seguenti file non sono stati convertiti correttamente:", "The following files failed to convert correctly:") & vbNewLine
        
        ResultSummary = ResultSummary & vbNewLine & vbNewLine & IIf(lng = 0, "Sui seguenti file si |fffd| verificato un problema: ", _
        "The following files returned some kind of error: ") & vbNewLine & vbNewLine
                
        For e = 1 To ErrorFiles.Count
            ResultSummary = ResultSummary & ErrorFiles(e) & vbNewLine
            ErrorString = ErrorString & ErrorFiles(e) & vbNewLine
        Next e
        
        Call UpdateErrorLog(ErrorString)
        
    End If
    MsgBox ResultSummary, IIf(ErrorFiles.Count = 0, vbInformation, vbExclamation), IIf(lng = 0, "Esito importazione", "Result summary")
        
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmConvertFormulaRef"
Attribute VB_Base = "0{C58A46C3-CBC2-497B-AAF4-05C398C1272D}{27DCAC1E-FEDD-4784-A408-E95F2E5740BC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub UpdateExample()
    If lng = 0 Then
        If Me.optAbsolute Then
            Me.lblExample.Caption = "=SOMMA($A$1:$B$4)"
        ElseIf Me.optRelative Then
            Me.lblExample.Caption = "=SOMMA(A1:B4)"
        ElseIf Me.optAbsRows Then
            Me.lblExample.Caption = "=SOMMA(A$1:B$4)"
        ElseIf Me.optAbsCols Then
            Me.lblExample.Caption = "=SOMMA($A1:$B4)"
        End If
    Else
        If Me.optAbsolute Then
            Me.lblExample.Caption = "=SUM($A$1:$B$4)"
        ElseIf Me.optRelative Then
            Me.lblExample.Caption = "=SUM(A1:B4)"
        ElseIf Me.optAbsRows Then
            Me.lblExample.Caption = "=SUM(A$1:B$4)"
        ElseIf Me.optAbsCols Then
            Me.lblExample.Caption = "=SUM($A1:$B4)"
        End If
    End If
End Sub

Private Sub optAbsolute_Click()
    Call UpdateExample
End Sub

Private Sub optAbsRows_Click()
    Call UpdateExample
End Sub
Private Sub optAbsCols_Click()
    Call UpdateExample
End Sub

Private Sub optRelative_Click()
    Call UpdateExample
End Sub

Private Sub optAbsolute_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    cmdOK_Click
End Sub

Private Sub optRelative_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    cmdOK_Click
End Sub

Private Sub optAbsRows_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    cmdOK_Click
End Sub

Private Sub optAbsCols_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    cmdOK_Click
End Sub
Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    
    
    On Error GoTo Aborted
    
    Set ws = ActiveSheet
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto effettuando la conversione... (" & ws.Name & ")"
        Call ShowProgressBar
        
        For Each cell In InRng.SpecialCells(xlCellTypeFormulas).Cells
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            If Me.optAbsolute Then
                Me.lblExample.Caption = "$A$1:$B$4"
                cell.Formula = Application.ConvertFormula(cell.Formula, xlA1, xlA1, xlAbsolute)
            ElseIf Me.optRelative Then
                Me.lblExample.Caption = "A1:B4"
                cell.Formula = Application.ConvertFormula(cell.Formula, xlA1, xlA1, xlRelative)
            ElseIf Me.optAbsRows Then
                Me.lblExample.Caption = "A$1:B$4"
                cell.Formula = Application.ConvertFormula(cell.Formula, xlA1, xlA1, xlAbsRowRelColumn)
            ElseIf Me.optAbsCols Then
                Me.lblExample.Caption = "$A1:$B4"
                cell.Formula = Application.ConvertFormula(cell.Formula, xlA1, xlA1, xlRelRowAbsColumn)
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted

        Next cell
            
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmConvertTextToNumbers"
Attribute VB_Base = "0{F66409B3-A344-4162-AFAC-60802B71862B}{506FCA74-CA89-486C-8B85-252F06E54E89}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    On Error Resume Next
    Me.refRange = Selection.address
    
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then
        Call TranslateForm(Me)
        With Me.cbxDecimalSeparator
            .AddItem ","            '0
            .AddItem "."            '1
            .AddItem "Other"        '2
        End With
        With Me.cbxThousandSeparator
            .AddItem "."            '0
            .AddItem ","            '1
            .AddItem "Other"        '2
        End With
    Else
        With Me.cbxDecimalSeparator
            .AddItem ","            '0
            .AddItem "."            '1
            .AddItem "Altro"        '2
        End With
        With Me.cbxThousandSeparator
            .AddItem "."            '0
            .AddItem ","            '1
            .AddItem "Altro"        '2
        End With
    End If
    Me.cbxDecimalSeparator.Text = dSep
    Me.cbxThousandSeparator.Text = tSep
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub optText2Num_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraOptions.Controls
        If Not ctl.Name = "chkIgnoreHidden" Then
            ctl.Enabled = Me.optText2Num
        End If
    Next ctl
End Sub

Private Sub cbxDecimalSeparator_Change()
    Me.txtDecimalSeparator.visible = (Me.cbxDecimalSeparator.ListIndex = 2)
End Sub

Private Sub cbxThousandSeparator_Change()
    Me.txtThousandSeparator.visible = (Me.cbxThousandSeparator.ListIndex = 2)
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide
        
        Call AutoCalc(False)
        
        If .tglBatch = False Then '#' NO BATCH
        
            '#' Crea foglio di backup nascosto
            Call backup_create_new
        
            Set ws = ActiveSheet
                
            Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
            If .chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
            
            If Not InRng Is Nothing Then
            
                '#' Attivo la finestra di avanzamento e setto contatore e massimo
                counter = 0
                countermax = InRng.Cells.CountLarge
                UProgress.SetDescription "Sto effettuando la conversione... (" & ws.Name & ")"
                Call ShowProgressBar
                
                For Each cell In InRng.Cells
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                    
                    Call elaboracella(cell)
                                
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                Next cell
                        
            End If 'InRng is Nothing
            
        Else '#' BATCH
            
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
            Call ShowProgressBar
            
            '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
            If Me.chkActiveFile = True Then
                Set wb = ActiveWorkbook
                UProgress.SetDescription "Sto convertendo i numeri... (" & wb.Name & ")"
                counter = counter + 1
                
                If Me.chkBatchBackup Then
                    Call BatchBackup(wb.FullName)
                End If
            
                For Each ws In wb.Worksheets
                    
                    If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                        
                        ws.Activate
                    
                        '#' Imposta il range
                        If Me.chkWholeSheet Then
                            Set InRng = ws.UsedRange
                        Else
                            Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                        End If
                        If Not InRng Is Nothing Then
                            If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                    
                            '#' Setto contatore secondario e suo massimo
                            counter2 = 0
                            countermax2 = InRng.Cells.Count
                            UProgress.SetSubDescription "Foglio: " & ws.Name
                        
                            For Each cell In InRng.Cells
                                    
                                counter2 = counter2 + 1
                                Call elaboracella(cell)
                                    
                                '#' Aggiorna la barra di avanzamento secondaria
                                Call UpdateSubProgressBar(counter2, countermax2)
                                If ProgressAborted = 1 Then GoTo Aborted
                                On Error GoTo Aborted
                            
                            Next cell
                            
                        End If '#' Not InRng Is Nothing
                    
                    End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                    
                Next ws
                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            End If
            
            
            '#' Sezione dedicata agli altri file della lista
            For f = 0 To Me.lbxBatchFiles.ListCount - 1
                
                counter = counter + 1
                
                If Me.chkBatchBackup Then
                    Call BatchBackup(Me.lbxBatchFiles.List(f))
                End If
                            
                '#' Apro il file
                Application.DisplayAlerts = False
                Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
                Application.DisplayAlerts = True
                
                UProgress.SetDescription "Sto convertendo i numeri... (" & wb.Name & ")"
                
                On Error GoTo NextFile
                
                For Each ws In wb.Worksheets
                    
                    If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                        
                        ws.Activate
                    
                        '#' Imposta il range
                        If Me.chkWholeSheet Then
                            Set InRng = ws.UsedRange
                        Else
                            Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                        End If
                        If Not InRng Is Nothing Then
                            If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                    
                            '#' Setto contatore secondario e suo massimo
                            counter2 = 0
                            countermax2 = InRng.Cells.Count
                            UProgress.SetSubDescription "Foglio: " & ws.Name
                        
                            For Each cell In InRng.Cells
                                    
                                counter2 = counter2 + 1
                                Call elaboracella(cell)
                                    
                                '#' Aggiorna la barra di avanzamento secondaria
                                Call UpdateSubProgressBar(counter2, countermax2)
                                If ProgressAborted = 1 Then GoTo Aborted
                                On Error GoTo Aborted
                            
                            Next cell
                            
                        End If '#' Not InRng Is Nothing
                    
                    End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                    
                Next ws
                    
                Application.EnableEvents = False
                wb.Close True
                Application.EnableEvents = True
NextFile:
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next f
        
        End If '#' batch/no batch
        
        '#' Chiudo la finestra di avanzamento
        Unload UProgress
        
    End With
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
    
    If Me.chkClose = False Then Me.Show
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub elaboracella(Cella As Range)
    Dim DecimalSeparator As String
    Dim ThousandSeparator As String
    Dim newcell As String
        
    If Me.optText2Num = True Then
        If Me.cbxDecimalSeparator.ListIndex < 2 Then
            DecimalSeparator = Me.cbxDecimalSeparator
        Else
            DecimalSeparator = Me.txtDecimalSeparator
        End If
        
        If Me.cbxThousandSeparator.ListIndex < 2 Then
            ThousandSeparator = Me.cbxThousandSeparator
        Else
            ThousandSeparator = Me.txtThousandSeparator
        End If
            
        If Not IsEmpty(Cella) And Not IsError(Cella) And Not Cella.HasArray Then
            On Error Resume Next
            newcell = Replace(Replace(Replace(Cella.Value2, DecimalSeparator, "|fffd|"), ThousandSeparator, ""), "|fffd|", dSep)
            If IsNumeric(newcell) Then Cella = "'" & newcell
            Cella.TextToColumns destination:=Cella, DataType:=xlDelimited, _
            TextQualifier:=xlDoubleQuote, ConsecutiveDelimiter:=False, Tab:=False, _
            Semicolon:=False, Comma:=False, Space:=False, Other:=False, FieldInfo _
            :=Array(1, 1)
            On Error GoTo 0
        End If
        
        Cella.NumberFormat = "General"
        
    Else
        If Application.WorksheetFunction.IsNumber(Cella) Then
            Cella.Value = "'" & Cella.Value
        End If
    End If

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmCopyPasteVisibleCells"
Attribute VB_Base = "0{87423636-20F1-4179-B71A-5EAAECC87E70}{4A328262-641A-45EB-B13C-AAE9577E9E03}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim OutBook As Workbook
    Dim OutRng As Range
    Dim OutSheet As Worksheet, OutRow As Long, OutCol As Long
    Dim InSheet As Worksheet, InFRow As Long, InFCol As Long, InLRow As Long, InLCol As Long
    Dim i As Long, j As Long, m As Long, n As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        If TypeName(Range(Replace(.refDest, ";", ",")).Cells(1, 1)) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refDest.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        On Error GoTo Aborted
        
        .Hide
        
    End With
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)

    Set InRng = RangeResize(Range(Replace(Me.refRange, ";", ",")), Range(Replace(Me.refRange, ";", ",")).Parent)
    
    Set OutBook = Range(Me.refDest).Parent.Parent
    Set OutSheet = Range(Me.refDest).Parent
    
    Set OutRng = OutSheet.Range(Mid(Replace(Me.refDest, ";", ","), InStr(1, Me.refDest, "!") + 1)).Cells(1, 1)
        
    Set InSheet = InRng.Parent
    InFRow = findfirstcell(InRng).Row
    InFCol = findfirstcell(InRng).Column
    InLRow = findlastcell(InRng).Row
    InLCol = findlastcell(InRng).Column
    
    With OutRng
        OutRow = .Row
        OutCol = .Column
    End With
    
    'Force the routine to begin from a visible cell
    With InSheet
        Do While .Rows(InFRow).RowHeight = 0
            InFRow = InFRow + 1
        Loop
        Do While .Columns(InFCol).ColumnWidth = 0
            InFCol = InFCol + 1
        Loop
    End With
    
    '#' Crea foglio di backup nascosto
    OutSheet.Activate
    Call backup_create_new
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge
    UProgress.SetDescription "Copiando e incollando le celle visibili..."
    Call ShowProgressBar
    
    For i = InFRow To InLRow
        For j = InFCol To InLCol
            
            '#' Aumento di 1 il contatore
            counter = counter + 1

            With InSheet
                If .Rows(i).RowHeight > 0 And .Columns(j).ColumnWidth > 0 Then
                    If Me.chkKeepFormats = True Then .Cells(i, j).Copy
                    
                    '#' Paste Routine
                    m = OutRow
                    n = OutCol
                    
                    'Find the closest visible cell to (m, n)
                    Do While OutSheet.Rows(m).RowHeight = 0
                        m = m + 1
                    Loop
                    Do While OutSheet.Columns(n).ColumnWidth = 0
                        n = n + 1
                    Loop
                    
                    'Paste clipboard content
                    If Me.chkKeepFormats = True Then
                        OutSheet.Cells(m, n).PasteSpecial
                        OutSheet.Cells(m, n).PasteSpecial xlPasteValues
                    Else
                        OutSheet.Cells(m, n) = .Cells(i, j) '<== to paste values
                    End If
                    '#' End of Paste routine
                    
                End If
            End With
        
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
                
            'Before skipping to the next column of the input range, increase output column index by 1
            OutCol = n + 1

        Next j
        
        'Before skipping to the next row of the input range, increase output row index by 1 and reset column index to the first one used
        OutRow = m + 1
        OutCol = OutRng.Column
    Next i
           
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Application.EnableCancelKey = xlInterrupt

    Exit Sub
    
Aborted:
    Call CanceledProcedure
    Application.EnableCancelKey = xlInterrupt

End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmCopySheets"
Attribute VB_Base = "0{D1302F10-53CF-41A8-B3FF-40C19B050AEF}{718A74D3-09E3-4583-8071-A898D6016339}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean


Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Dim cSheets As New Collection
    Dim i As Long
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    DisableEvents = True
    
    Call ListSheets
    
    '#' Popolo la collection dei fogli selezionati
    For i = 0 To Me.lbxSheets.ListCount - 1
        If Me.lbxSheets.Selected(i) = True Then cSheets.Add Worksheets(CleanSheetName(Me.lbxSheets.List(i)))
    Next i
    
    If cSheets.Count = Me.lbxSheets.ListCount Then Me.chkAllNone = True

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    DisableEvents = False
    
    Call GoodToGo(Me)

End Sub

Private Sub ListSheets()
    Dim wb As Workbook
    
    If ActiveWorkbook Is Nothing Or ActiveWorkbook.Name = ThisWorkbook.Name Then Exit Sub
    
    Set wb = ActiveWorkbook
    Me.lbxSheets.Clear
    
    For Each ws In ActiveWorkbook.Worksheets
        
        If ws.Name = "ESK_Backup" Then GoTo Nextws
        If Me.chkEmpty = False And Application.WorksheetFunction.CountA(ws.Cells) = 0 Then GoTo Nextws
        If Me.chkHidden = False And ws.visible <> xlSheetVisible Then GoTo Nextws
            
        If UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*" Then
            If ws.visible <> xlSheetVisible Then
                Me.lbxSheets.AddItem ws.Name & IIf(lng = 0, " *Nascosto*", " *Hidden*")
            Else
                Me.lbxSheets.AddItem ws.Name
            End If
            If IsSelected(ws.Name) Or ActiveWindow.SelectedSheets.Count = 1 Then Me.lbxSheets.Selected(Me.lbxSheets.ListCount - 1) = True
        End If
Nextws:
    Next ws
End Sub

Private Sub txtFilterList_Change()
    Call ListSheets
End Sub

Private Sub spbNCopies_SpinDown()
    Me.txtNCopies = Me.spbNCopies
End Sub

Private Sub spbNCopies_SpinUp()
    Me.txtNCopies = Me.spbNCopies
End Sub
Private Sub txtNCopies_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNCopies_Change()
    If Val(Me.txtNCopies) > Me.spbNCopies.Max Then Me.txtNCopies = Me.spbNCopies.Max
    If Val(Me.txtNCopies) < Me.spbNCopies.Min Then Me.txtNCopies = Me.spbNCopies.Min
    Me.spbNCopies = Me.txtNCopies
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxSheets.ListCount - 1
        Me.lbxSheets.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GoodToGo(Me)
End Sub

Private Sub lbxSheets_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub

Private Sub optBeforeActive_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optAfterActive_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optBeforeAll_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optAfterAll_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim SelSheets As New Collection
    Dim aWs As Worksheet
    Dim i As Long
    Dim ErrNum As Long
    Dim wsVisible As Long
    
    '#' Popolo la collection dei fogli selezionati
    For i = 0 To Me.lbxSheets.ListCount - 1
        If Me.lbxSheets.Selected(i) = True Then SelSheets.Add Worksheets(CleanSheetName(Me.lbxSheets.List(i)))
    Next i
    
    Me.Hide
    
    Call AutoCalc(False)

    
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.txtNCopies * SelSheets.Count
    UProgress.SetDescription "Sto creando le copie..."
    Call ShowProgressBar
    
    Set aWs = ActiveSheet
    
    For i = 1 To Me.txtNCopies
        For Each ws In SelSheets
            
            '#' Aumenta di 1 il contatore
            counter = counter + 1
            
            '#' Rendo visibile il foglio
            wsVisible = ws.visible
            ws.visible = xlSheetVisible
            
            If Me.optBeforeActive Then
                ws.Copy Before:=aWs
            ElseIf Me.optAfterActive Then
                ws.Copy After:=ActiveWorkbook.Worksheets(aWs.index + counter - 1)
            ElseIf Me.optBeforeAll Then
                ws.Copy Before:=ActiveWorkbook.Worksheets(0 + counter)
            ElseIf Me.optAfterAll Then
                ws.Copy After:=ActiveWorkbook.Worksheets(ActiveWorkbook.Worksheets.Count)
            End If
            
            With ActiveSheet
                '#' Rinomina il foglio, numerandolo e tenendo conto dei possibili errori
                On Error Resume Next
                ErrNum = 0
                .Name = Left(ws.Name, 26) & "_(" & Format(i, "00") & ")"
                Do While Err.Number <> 0
                    Err.Clear
                    ErrNum = ErrNum + 1
                    .Name = Left(ws.Name, 22) & "_(" & Format(i, "00") & ")" & "_" & Format(ErrNum, "000")
                Loop
                On Error GoTo Aborted
                
                '#' Incolla i valori, se opzione selezionata
                If Me.chkValues = True Then
                    .Cells.Copy
                    .Range("A1").PasteSpecial xlPasteValues
                End If
                
                '#' Elimina le formattazioni, se opzione selezionata
                If Me.chkFormats = False Then
                    .Cells.ClearFormats
                End If
                
                .visible = wsVisible
                
            End With
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            DoEvents
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
            '#' Ripristino lo stato di visibilit|fffd|
            ws.visible = wsVisible
        
        Next ws
    Next i
        
    Unload UProgress
    
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmCrossTab"
Attribute VB_Base = "0{209C6F1F-7A53-4BB0-BC90-C5E27F75CA61}{AE6AD1F9-1D05-4771-8022-2127E3B31093}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit



Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    Me.lbxBaseColumns.RowSource = ""
    Me.lbxBaseColumns.Clear
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    Call ListColumns(Range(Me.refRange), Me.lbxBaseColumns)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub


Private Sub cmdToRows_Click()
    Dim i As Long
    Dim Shift As Long
    Dim newindex As Long
    
    For i = Me.lbxBaseColumns.ListCount - 1 To 0 Step -1
        If Me.lbxBaseColumns.Selected(i) = True Then
            newindex = Me.lbxRowVars.ListCount - Shift
            Me.lbxRowVars.AddItem Me.lbxBaseColumns.List(i), newindex
            Me.lbxBaseColumns.RemoveItem i
            Shift = Shift + 1
        End If
    Next i
    Call GoodToGo(Me)
End Sub

Private Sub cmdFromRows_Click()
    Dim i As Long
    
    For i = Me.lbxRowVars.ListCount - 1 To 0 Step -1
        If Me.lbxRowVars.Selected(i) = True Or CountListBox(Me.lbxRowVars) = 0 Then
            Me.lbxBaseColumns.AddItem Me.lbxRowVars.List(i)
            Me.lbxRowVars.RemoveItem i
            counter = counter + 1
        End If
    Next i
    Call GoodToGo(Me)
    Call SortListCombobox(Me.lbxBaseColumns)
End Sub

Private Sub cmdToCol_Click()
    Dim i As Long
        
    If Me.lbxColVar.ListCount > 0 Then Exit Sub
    
    For i = 0 To Me.lbxBaseColumns.ListCount - 1
        If Me.lbxBaseColumns.Selected(i) = True Then
            Me.lbxColVar.AddItem Me.lbxBaseColumns.List(i)
            Me.lbxBaseColumns.RemoveItem i
            Exit For
        End If
    Next i
    Call GoodToGo(Me)
End Sub

Private Sub cmdFromCol_Click()
    Dim i As Long
    
    For i = 0 To Me.lbxColVar.ListCount - 1
        If Me.lbxColVar.Selected(i) = True Or CountListBox(Me.lbxColVar) = 0 Then
            Me.lbxBaseColumns.AddItem Me.lbxColVar.List(i)
            Me.lbxColVar.RemoveItem i
        End If
    Next i
    Call GoodToGo(Me)
    Call SortListCombobox(Me.lbxBaseColumns)
End Sub

Private Sub cmdToCross_Click()
    Dim i As Long
    Dim Shift As Long
    Dim newindex As Long
    
    For i = Me.lbxBaseColumns.ListCount - 1 To 0 Step -1
        If Me.lbxBaseColumns.Selected(i) = True Then
            newindex = Me.lbxCrossVars.ListCount - Shift
            Me.lbxCrossVars.AddItem Me.lbxBaseColumns.List(i), newindex
            Me.lbxBaseColumns.RemoveItem i
            Shift = Shift + 1
        End If
    Next i
    Call GoodToGo(Me)
    Call UpdateCrossVars
End Sub

Private Sub cmdFromCross_Click()
    Dim i As Long
    
    For i = Me.lbxCrossVars.ListCount - 1 To 0 Step -1
        If Me.lbxCrossVars.Selected(i) = True Or CountListBox(Me.lbxCrossVars) = 0 Then
            Me.lbxBaseColumns.AddItem Me.lbxCrossVars.List(i)
            Me.lbxCrossVars.RemoveItem i
            counter = counter + 1
        End If
    Next i
    Call GoodToGo(Me)
    Call UpdateCrossVars
    Call SortListCombobox(Me.lbxBaseColumns)
End Sub


Private Sub lbxBaseColumns_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdToRows_Click
End Sub

Private Sub lbxRowVars_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdFromRows_Click
End Sub

Private Sub lbxColVar_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdFromCol_Click
End Sub

Private Sub lbxCrossVars_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdFromCross_Click
End Sub

Private Sub UpdateCrossVars()
    Me.chkSeparator.Enabled = (Me.lbxCrossVars.ListCount > 1)
    Me.txtSeparator.Enabled = (Me.lbxCrossVars.ListCount > 1)
    If Me.lbxCrossVars.ListCount > 1 Then Me.chkSeparator = True
End Sub

Private Sub chkSeparator_Change()
    Me.txtSeparator.Enabled = Me.chkSeparator
End Sub

Private Sub chkAllNone_Change()
    Dim i As Long
    
    For i = 0 To Me.lbxBaseColumns.ListCount - 1
        Me.lbxBaseColumns.Selected(i) = Me.chkAllNone
    Next i
End Sub

Private Sub optOutRng_Change()
    Me.refOutRng.Enabled = Me.optOutRng
    If Me.optOutRng = True Then Me.refOutRng.SetFocus
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim nRows As Long
    Dim nCross As Long
    Dim strSep As String
    Dim OutRng As Range
    Dim tmpWs As Worksheet
    Dim tmpWs2 As Worksheet
    Dim tmpArr As Variant
    Dim RowsArr As Variant
    Dim ColColl As New Collection
    Dim i As Long
    Dim j As Long
    Dim n As Long
    Dim w As Long
    Dim tmpRng As Range
    Dim tmpstr As String
    Const sep As String = "||fffd|ESK|fffd||"
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        
        If .optOutRng.Enabled = True And .optOutRng.Value = True Then
           Set OutRng = Range(Replace(.refOutRng, ";", ","))
           If Err.Number <> 0 Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refOutRng.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
    
    Call AutoCalc(False)
    
    nRows = Me.lbxRowVars.ListCount
    nCross = Me.lbxCrossVars.ListCount
    strSep = Me.txtSeparator
    If Me.chkSeparator = False Then strSep = ""
    
    Set ws = ActiveSheet
    Set tmpWs = Worksheets.Add
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        With tmpWs
            j = 1
            'Copio le variabili riga
            For i = 0 To nRows - 1
                Set tmpRng = Intersect(InRng, ws.Columns(ColItemToNumber(Me.lbxRowVars.List(i))))
                tmpRng.Copy .Cells(1, j)
                j = j + 1
            Next i
            
            'Copio la variabile colonna
            Set tmpRng = Intersect(InRng, ws.Columns(ColItemToNumber(Me.lbxColVar.List(0))))
            tmpRng.Copy .Cells(1, j)
            j = j + 1
            
            'Copio le variabili valore
            For i = 0 To nCross - 1
                Set tmpRng = Intersect(InRng, ws.Columns(ColItemToNumber(Me.lbxCrossVars.List(i))))
                tmpRng.Copy .Cells(1, j)
                j = j + 1
            Next i
            
            'Creo l'array con la colonna concatenata e i valori
            ReDim tmpArr(1 To .UsedRange.Rows.Count, 1 To nCross + 1)
            For i = 1 To .UsedRange.Rows.Count
                For j = 1 To nRows + 1
                    tmpArr(i, 1) = tmpArr(i, 1) & sep & .Cells(i, j)
                Next j
                tmpArr(i, 1) = Mid(tmpArr(i, 1), Len(sep) + 1)
                For j = 2 To nCross + 1
                    tmpArr(i, j) = .Cells(i, nRows + j)
                Next j
            Next i
            
            'Creo un secondo foglio temporaneo e ci copio le variabili riga
            Set tmpWs2 = Worksheets.Add
            .UsedRange.reSize(.UsedRange.Rows.Count, nRows).Copy tmpWs2.Cells(1, 1)
            
            'Creo un array con gli indici di colonna delle variabili riga
            ReDim RowsArr(0 To 0)
            For i = 1 To tmpWs2.UsedRange.Columns.Count
                ReDim Preserve RowsArr(0 To i - 1)
                RowsArr(i - 1) = i
            Next i
            
            'Rimuovo i duplicati dalle colonne delle variabili riga
            tmpWs2.Range("A1").CurrentRegion.RemoveDuplicates Columns:=(RowsArr), header:=xlYes
            
            'Copio la variabile colonna, trasposta
            j = nRows + 1
            On Error Resume Next
            For Each cell In .UsedRange.Columns(nRows + 1).Offset(1, 0).Cells
                ColColl.Add cell.Value, CStr(cell.Value)
                If Err.Number = 0 Then
                    tmpWs2.Cells(1, j) = cell.Value
                    j = j + 1
                End If
                Err.Clear
            Next cell
            On Error GoTo Aborted
            
        End With
            
        'Riempio la tabella dei valori
        For i = 2 To findlastcell(tmpWs2.Cells).Row
            For j = nRows + 1 To findlastcell(tmpWs2.Cells).Column
                tmpstr = ""
                
                For n = 1 To nRows
                    tmpstr = tmpstr & sep & tmpWs2.Cells(i, n)
                Next n
                
                tmpstr = Mid(tmpstr & sep & tmpWs2.Cells(1, j), Len(sep) + 1)
                
                For w = 1 To UBound(tmpArr)
                    For n = 2 To nCross + 1
                        If tmpArr(w, 1) = tmpstr Then
                            tmpWs2.Cells(i, j) = tmpWs2.Cells(i, j) & strSep & tmpArr(w, n)
                        End If
                    Next n
                Next w
                
                tmpWs2.Cells(i, j) = Mid(tmpWs2.Cells(i, j), Len(strSep) + 1)
            Next j
        Next i
            
        'Output finale
        Application.DisplayAlerts = False
        If Me.optNewSheet Then
            tmpWs2.Name = Left(tmpWs2.Name, 11) & "_cross" & "_" & Format(Now, "yymmdd hhmmss")
            tmpWs2.UsedRange.Columns.EntireColumn.AutoFit
        Else
            tmpWs2.Range("A1:" & findlastcell(tmpWs2.Cells).address).Copy OutRng.Cells(1, 1)
            tmpWs2.Delete
            OutRng.CurrentRegion.Columns.EntireColumn.AutoFit
        End If
        tmpWs.Delete
        Application.DisplayAlerts = True
    
    End If
    
    Call AutoCalc(True)
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmCustomViews"
Attribute VB_Base = "0{6C030E39-9E66-4834-A3C4-58501A6DDD90}{CA3AB30F-1E9C-4BA0-9C10-195C3D177C13}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    Dim cView As CustomView
    Dim i As Long
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    DisableEvents = True
    
    If ActiveWorkbook.CustomViews.Count = 0 Then
        Me.lbxViews.visible = False
        Me.lblNoViews.visible = True
    Else
        For Each cView In ActiveWorkbook.CustomViews
            Me.lbxViews.AddItem cView.Name
            Me.lbxViews.Selected(Me.lbxViews.ListCount - 1) = True
        Next cView
    End If
    
    With Me.cbxFormat
        .AddItem "Excel 2007+ (.xlsx)"          '0
        .AddItem "Excel 97-2003 (.xls)"             '1
        .AddItem "PDF (.pdf)"                       '2
        .AddItem "Open Document Format (.ods)"      '3
        .AddItem "Excel 95/5.0 (.xls)"              '4
        .AddItem "Testo con delimitatore (.csv)"    '5
        .AddItem "Testo Unicode (.txt)"             '6
        .ListIndex = 0
    End With

    With CreateObject("WScript.Network")
        For i = 1 To .EnumPrinterConnections.Count Step 2
            Me.cbxPrinters.AddItem .EnumPrinterConnections(i)
        Next
        Me.cbxPrinters.ListIndex = 0
    End With

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)
        
    DisableEvents = False

End Sub


Private Sub lbxViews_Change()
    Call GoodToGo(Me)
End Sub

Private Sub SelectFolder()
    Me.txtDestFolder.Text = FolderPicker(Me.txtDestFolder.Text)
            
    If Me.txtDestFolder = "" Then
        Me.optNewSheet = True
    End If
End Sub

Private Sub optNewFile_Click()
    Call SelectFolder
End Sub

Private Sub optPrint_Change()
    Me.chkValues.Enabled = Not Me.optPrint
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxViews.ListCount - 1
        Me.lbxViews.Selected(i) = Me.chkAllNone
    Next i
    
    Call GoodToGo(Me)
    
    DisableEvents = False
End Sub

Private Sub cbxPrinters_Change()
    Me.cbxPrinters.ControlTipText = Me.cbxPrinters.Text
End Sub

Private Sub cbxFormat_Change()
    Me.cbxFormat.ControlTipText = Me.cbxFormat.Text
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim FileExtStr As String
    Dim FileFormatNum As Long
    Dim FolderName As String
    Dim Sourcewb As Workbook
    Dim DestWb As Workbook
    Dim Destws As Worksheet
    Dim i As Long
    Dim oFolder As Long
    
    Me.Hide
    
    On Error GoTo Aborted
    
    Set Sourcewb = ActiveWorkbook
    
    FolderName = ValidateFolder(Me.txtDestFolder)
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)

    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = CountListBox(Me.lbxViews)
    UProgress.SetDescription "Elaborazione di " & countermax & " visualizzazioni personalizzate in corso..."
    Call ShowProgressBar
        
    '#' Copy every selected sheet to a new workbook
    For i = 0 To Me.lbxViews.ListCount - 1
        
        If Me.lbxViews.Selected(i) = True Then
                        
            '#' Aumento di 1 il contatore e aggiorno descrizione barra avanzamento
            counter = counter + 1
                        
            '#' Attivo la visualizzazione personalizzata
            Sourcewb.CustomViews(Me.lbxViews.List(i)).Show
                        
            '#' Copio la parte visibile del foglio attivo
            Set ws = ActiveSheet
            
            '#' A questo punto distinguo tra le varie operazioni da compiere
            If Me.optNewFile = True Then
            
                '#' Set Destwb to the new workbook
                Set DestWb = Workbooks.Add
    
                With DestWb
                    Set Destws = .Sheets(1)
                    Destws.Name = Left(ws.Name, 20) & "_(View " & counter & ")"
                    ws.UsedRange.SpecialCells(xlCellTypeVisible).Copy
                    With Destws.Range("A1")
                        .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                        
                        If Me.chkValues Then
                            .PasteSpecial xlPasteValues
                        Else
                            .PasteSpecial xlPasteFormulas
                        End If
                        
                        .PasteSpecial xlPasteFormats
                    End With
                    Application.CutCopyMode = False
                    
                    Select Case Me.cbxFormat.ListIndex
                        Case 0 '#' Excel 2007+
                            FileExtStr = ".xlsx"
                            FileFormatNum = 51
                        Case 1 '#' Excel 97-2003
                            FileExtStr = ".xls"
                            FileFormatNum = 56
                        Case 2 '#' PDF
                            '#' No variables set
                        Case 3
                            FileExtStr = ".ods"
                            FileFormatNum = 60
                        Case 4
                            FileExtStr = ".xls"
                            FileFormatNum = 39
                        Case 5
                            FileExtStr = ".csv"
                            FileFormatNum = 6
                        Case 6
                            FileExtStr = ".txt"
                            FileFormatNum = 42
                    End Select
                    
                    '#' Remove all empty sheets
                    For Each ws In .Worksheets
                        If Application.CountA(ws.Cells) = 0 Then
                            ws.Delete
                        End If
                    Next ws
                    
                    '#' Save the new workbook and close it
                    Application.DisplayAlerts = False
                    Select Case Me.cbxFormat.ListIndex
                        Case 2 '#' PDF
                            Destws.ExportAsFixedFormat Type:=xlTypePDF, FileName:=FolderName & Destws.Name & ".pdf", Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:=False
                        Case Else
                            Call SaveFile(DestWb, FolderName & Destws.Name & FileExtStr, NewFileFormat:=FileFormatNum, NewFileLocal:=True, Silent:=True)
                    End Select
                    
                    .Close False
                    Application.DisplayAlerts = True
                
                End With
            
            ElseIf Me.optNewSheet = True Then
                
                Sourcewb.Worksheets.Add
                Set Destws = ActiveSheet
                
                With Destws
                    .Name = Left(ws.Name, 20) & "_(View " & counter & ")"
                    ws.UsedRange.SpecialCells(xlCellTypeVisible).Copy
                    With .Range("A1")
                        .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                        
                        If Me.chkValues Then
                            .PasteSpecial xlPasteValues
                        Else
                            .PasteSpecial xlPasteFormulas
                        End If
                        
                        .PasteSpecial xlPasteFormats
                    End With
                    Application.CutCopyMode = False
                End With
                
            ElseIf Me.optPrint = True Then
                ws.PrintOut ActivePrinter:=Me.cbxPrinters.Text
            End If

            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If counter Mod 10 = 0 Then DoEvents
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
                
    Next i

    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    If Me.optNewFile = True Then
        oFolder = MsgBox(IIf(lng = 0, "Esportazione di " & countermax & " file completata. Troverai i file nella cartella: " & _
                        vbNewLine & vbNewLine & _
                        FolderName & _
                        vbNewLine & vbNewLine & _
                        "Vuoi aprire la cartella di destinazione?", _
                        "Export of " & countermax & " files complete. You will find your files in this folder: " & _
                        vbNewLine & vbNewLine & _
                        FolderName & _
                        vbNewLine & vbNewLine & _
                        "Would you like to open destination folder?"), _
                        vbInformation + vbYesNo, _
                        IIf(lng = 0, "Esportazione completata", "Export complete"))
        If oFolder = vbYes Then Call OpenFolder(FolderName)
    End If
    
    Exit Sub
        
Aborted:
    If Me.cbxFormat.ListIndex = 2 Then
        Call Excel2007PDF
    End If
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmDeleteEmptyHiddenRC"
Attribute VB_Base = "0{EDCFB4CB-1561-4E30-ACDA-A635451B8AE6}{CD16EB22-71CA-4EAC-AE0C-82114F034E17}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub chkHiddenR_Change()
    Me.chkValues.Enabled = Abs(CInt(Me.chkHiddenC + Me.chkHiddenR))
    Call GoodToGo(Me)
End Sub
Private Sub chkHiddenC_Change()
    Me.chkValues.Enabled = Abs(CInt(Me.chkHiddenC + Me.chkHiddenR))
    Call GoodToGo(Me)
End Sub

Private Sub chkEmptyR_Change()
    Me.chkEmptyFormulas.Enabled = Abs(CInt(Me.chkEmptyC + Me.chkEmptyR))
    Call GoodToGo(Me)
End Sub

Private Sub chkEmptyC_Change()
    Me.chkEmptyFormulas.Enabled = Abs(CInt(Me.chkEmptyC + Me.chkEmptyR))
    Call GoodToGo(Me)
End Sub

Private Sub spbFirstRows_SpinDown()
    Me.txtFirstRows = Me.spbFirstRows
End Sub
Private Sub spbFirstRows_SpinUp()
    Me.txtFirstRows = Me.spbFirstRows
End Sub
Private Sub txtFirstRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtFirstRows_Change()
    If Val(Me.txtFirstRows) > Me.spbFirstRows.Max Then Me.txtFirstRows = Me.spbFirstRows.Max
    If Val(Me.txtFirstRows) < Me.spbFirstRows.Min Then Me.txtFirstRows = Me.spbFirstRows.Min
    If Me.txtFirstRows <> "" Then Me.spbFirstRows = Me.txtFirstRows
End Sub
Private Sub chkFirstRows_Change()
    Me.txtFirstRows.Enabled = Me.chkFirstRows
    Me.spbFirstRows.Enabled = Me.chkFirstRows
    Call GoodToGo(Me)
End Sub

Private Sub spbFirstCols_SpinDown()
    Me.txtFirstCols = Me.spbFirstCols
End Sub
Private Sub spbFirstCols_SpinUp()
    Me.txtFirstCols = Me.spbFirstCols
End Sub
Private Sub txtFirstCols_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtFirstCols_Change()
    If Val(Me.txtFirstCols) > Me.spbFirstCols.Max Then Me.txtFirstCols = Me.spbFirstCols.Max
    If Val(Me.txtFirstCols) < Me.spbFirstCols.Min Then Me.txtFirstCols = Me.spbFirstCols.Min
    If Me.txtFirstCols <> "" Then Me.spbFirstCols = Me.txtFirstCols
End Sub
Private Sub chkFirstCols_Change()
    Me.txtFirstCols.Enabled = Me.chkFirstCols
    Me.spbFirstCols.Enabled = Me.chkFirstCols
    Call GoodToGo(Me)
End Sub




Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(Me.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        
        .Hide
        
        Call AutoCalc(False)
    End With
        
    On Error GoTo Aborted
        
    If Me.tglBatch = False Then '#' NO BATCH
    
        Call backup_create_new
        
        Set ws = ActiveSheet
        
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        
        If Not InRng Is Nothing Then
            
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = 1
            UProgress.SetDescription "Eliminazione righe/colonne in corso..."
            Call ShowProgressBar
        
            Call ElaboraFoglio(ws, InRng)
                        
            counter = 1
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        End If
       
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        UProgress.SetDescription "Sto eliminando le righe/colonne..."
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False Then
                    
                    ws.Activate
                    
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    
                    If Not InRng Is Nothing Then
                        Call ElaboraFoglio(ws, InRng)
                    End If
                    
                End If '#' ws.ProtectContents = False
                
            Next ws
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False Then
                    
                    ws.Activate
                    
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    
                    If Not InRng Is Nothing Then
                        Call ElaboraFoglio(ws, InRng)
                    End If
                    
                End If '#' ws.ProtectContents = False
                
            Next ws
                
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True
NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
                
                
    'Chiude la finestra di avanzamento
    Unload UProgress
        
    Call AutoCalc(True)
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub



Private Sub ElaboraFoglio(foglio As Worksheet, rng As Range)
    Dim i As Long
    Dim j As Long
    Dim check As Long
    
    LRow = findlastcell(rng).Row
    LCol = findlastcell(rng).Column
        
    On Error Resume Next
        
    With foglio
    
        '======== RIGHE VUOTE ===========
        If Me.chkEmptyR = True Then
            For i = LRow To rng.Row Step -1
                
                If WorksheetFunction.CountA(Rows(i)) = 0 Then
                    .Rows(i).EntireRow.Delete
                
                ElseIf Me.chkEmptyFormulas = True Then 'Righe con formule che restituiscono un valore vuoto
                    check = 0
                    For j = rng.Column To LCol
                        If .Cells(i, j).Value <> "" Then
                            check = 1
                            Exit For
                        End If
                    Next j
                    If check = 0 Then .Rows(i).EntireRow.Delete
                End If
                
            Next i
        End If
        
        '======== COLONNE VUOTE ===========
        If Me.chkEmptyC = True Then
            For j = LCol To 1 Step -1
                
                If WorksheetFunction.CountA(Columns(j)) = 0 Then
                    .Columns(j).EntireColumn.Delete
                
                ElseIf Me.chkEmptyFormulas = True Then 'Colonne con formule che restituiscono un valore vuoto
                    check = 0
                    For i = rng.Row To LRow
                        If .Cells(i, j).Value <> "" Then
                            check = 1
                            Exit For
                        End If
                    Next i
                    If check = 0 Then .Columns(j).EntireColumn.Delete
                End If
                
            Next j
        End If
        
        '======== RIGHE NASCOSTE ===========
        If Me.chkHiddenR = True Then
            For i = LRow To 1 Step -1
                
                If .Rows(i).RowHeight = 0 Then
                    .Rows(i).EntireRow.Delete
                End If
    
            Next i
        End If
        
        '======== COLONNE NASCOSTE ===========
        If Me.chkHiddenC = True Then
            Call AutoFilterOFF(foglio)
            For j = LCol To 1 Step -1
                
                If .Columns(j).ColumnWidth = 0 Then
                    .Columns(j).EntireColumn.Delete
                End If
            
            Next j
        End If
        
        '======== PRIME N RIGHE ===========
        If Me.chkFirstRows = True Then
            For i = Me.txtFirstRows To 1 Step -1
                
                .Rows(i).EntireRow.Delete
    
            Next i
        End If
        
        '======== PRIME N COLONNE ===========
        If Me.chkFirstCols = True Then
            For j = Me.txtFirstCols To 1 Step -1
                
                .Columns(j).EntireColumn.Delete
    
            Next j
        End If
    
    End With
    
    On Error GoTo Aborted
    
Aborted:
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmDeleteSheets"
Attribute VB_Base = "0{F88D8979-16D4-4905-A9DE-3F066699D79C}{D7BC36FF-8478-4D4D-9571-4E2470DC9FE1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub chkEmpty_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkHidden_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkGfx_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkMacro_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkDialog_Change()
    Call GoodToGo(Me)
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim sh As Variant
    Dim wb As Workbook
    Dim f As Long
    Dim nEmpty As Long, nHidden As Long, nGfx As Long, nMacro As Long, nDialog As Long
    
    Me.Hide
    
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    If Me.tglBatch = False Then '#' NO BATCH
    
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = ActiveWorkbook.Worksheets.Count
        UProgress.SetDescription "Sto effettuando le eliminazioni..."
        Call ShowProgressBar
        
        For Each sh In ActiveWorkbook.Sheets
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
                                
            If sh.ProtectContents = False Then
            
                Call ElaboraFoglio(ActiveWorkbook, sh, nEmpty, nHidden, nGfx, nMacro, nDialog)
                
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
    
        Next sh
                
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        UProgress.SetDescription "Sto effettuando le eliminazioni..."
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each sh In wb.Sheets
                
                If sh.ProtectContents = False Then
                    
                    Call ElaboraFoglio(wb, sh)
                    
                End If '#' ws.ProtectContents = False
                
            Next sh
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            On Error GoTo NextFile
            
            For Each sh In wb.Sheets
                
                If sh.ProtectContents = False Then
                    
                    Call ElaboraFoglio(wb, sh)
                        
                End If '#' sh.ProtectContents = False
                
            Next sh
                
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True
NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    If Me.tglBatch = True Then
        MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
    Else
        MsgBox IIf(lng = 0, "Sono stati eliminati: ", "These sheets were deleted: ") & vbNewLine & vbNewLine & _
               IIf(Me.chkEmpty = True, nEmpty & IIf(lng = 0, " fogli vuoti", " empty sheets") & vbNewLine, "") & _
               IIf(Me.chkHidden = True, nHidden & IIf(lng = 0, " fogli nascosti", " hidden sheets") & vbNewLine, "") & _
               IIf(Me.chkGfx = True, nGfx & IIf(lng = 0, " fogli grafico", " chart sheets") & vbNewLine, "") & _
               IIf(Me.chkMacro = True, nMacro & IIf(lng = 0, " fogli macro", " macro sheets") & vbNewLine, "") & _
               IIf(Me.chkDialog = True, nDialog & IIf(lng = 0, " fogli dialogo", " dialog sheets"), ""), vbInformation, IIf(lng = 0, "Esito eliminazione fogli", "Summary result")
    End If
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub ElaboraFoglio(wbk As Workbook, foglio As Variant, Optional ByRef nEmpty As Long, Optional ByRef nHidden As Long, Optional ByRef nGfx As Long, Optional ByRef nMacro As Long, Optional ByRef nDialog As Long)
    Application.DisplayAlerts = False
    
    Err.Clear
    
    '======== FOGLI DIALOGO ===========
    If Me.chkDialog = True Then
        If TypeName(foglio) = "DialogSheet" Then
            On Error Resume Next
            foglio.Delete
            If Err.Number = 0 Then nDialog = nDialog + 1
            On Error GoTo 0
            GoTo esci
        End If
    End If
    
    '======== FOGLI GRAFICO ===========
    If Me.chkGfx = True Then
        If TypeName(foglio) = "Chart" Then
            On Error Resume Next
            foglio.Delete
            If Err.Number = 0 Then nGfx = nGfx + 1
            On Error GoTo 0
            GoTo esci
        End If
    End If
    
    '======== FOGLI MACRO ===========
    If Me.chkMacro = True Then
        If TypeName(foglio) = "Worksheet" Then
            If (foglio.Type = xlExcel4MacroSheet Or foglio.Type = xlExcel4IntlMacroSheet) = True Then
                On Error Resume Next
                foglio.Delete
                If Err.Number = 0 Then nMacro = nMacro + 1
                On Error GoTo 0
                GoTo esci
            End If
        End If
    End If
    
    '======== FOGLI NASCOSTI ===========
    If Me.chkHidden = True Then
        If TypeName(foglio) = "Worksheet" Then
            If (foglio.visible = xlSheetHidden Or foglio.visible = xlSheetVeryHidden) Then
                On Error Resume Next
                foglio.Delete
                If Err.Number = 0 Then nHidden = nHidden + 1
                On Error GoTo 0
                GoTo esci
            End If
        End If
    End If
    
    '======== FOGLI VUOTI ===========
    If Me.chkEmpty = True Then
        If TypeName(foglio) = "Worksheet" Then
            If Application.CountA(foglio.Cells) = 0 Then
                On Error Resume Next
                foglio.Delete
                If Err.Number = 0 Then nEmpty = nEmpty + 1
                On Error GoTo 0
                GoTo esci
            End If
        End If
    End If
    
esci:
    Application.DisplayAlerts = True
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmDisasterRecovery"
Attribute VB_Base = "0{FC805467-2FAB-4A76-B1BE-2EE279E1954F}{CB232858-D175-4892-AA5F-04E65C83AB59}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub chkAll_change()
    Dim ctl As control
    
    For Each ctl In Me.fraOptions.Controls
        If ctl.Name <> "chkAll" And TypeName(ctl) = "CheckBox" Then
            If Me.chkAll = True Then
                ctl.Enabled = False
                ctl.Value = True
            Else
                ctl.Enabled = True
            End If
        End If
    Next ctl
    
    Call GoodToGo(Me)
End Sub

Private Sub chkData_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkFormulas_Change()
    If Me.chkFormulas = True Then Me.chkData = True
    Call GoodToGo(Me)
End Sub

Private Sub chkFormats_Change()
    If Me.chkFormats = True Then Me.chkData = True
    Call GoodToGo(Me)
End Sub

Private Sub cmdBrowse_Click()
    Dim FileName As Variant
    Dim DamagedFile As Workbook
    Dim Continua As Long
        
    FileName = OpenDialog(, , IIf(lng = 0, "Seleziona il file danneggiato", "Select damaged file"), False)
    
    If FileName = False Then Exit Sub
    
    On Error Resume Next
        Set DamagedFile = Workbooks(FullPathToWBName(FileName))
        If Err.Number = 0 Then
            Err.Clear
            Continua = MsgBox(IIf(lng = 0, "Il file danneggiato o un file con lo stesso nome risulta aperto. Per procedere |fffd| necessario chiuderlo: continuo?", _
                            "The damaged file or a file with the same name is open. To continue, it is necessary to close it: proceed?"), _
                            vbExclamation + vbYesNo, _
                            IIf(lng = 0, "File aperto", "Open file"))
            If Continua = vbYes Then
                Workbooks(FullPathToWBName(FileName)).Close
            Else
                Exit Sub
            End If
        End If
    On Error GoTo 0
    
    Me.txtDamagedFile = FileName
            
    Call GoodToGo(Me)

End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim newApp As Excel.Application
    Dim fName As String
    Dim wb As Workbook
    Dim Continua As Long
    Dim wbNew As Workbook
    Dim wsNew As Worksheet
    Dim wbDamaged As Workbook
    Dim wsDamaged As Worksheet
    Dim fRng As Range
    Dim i As Long
    Dim ff As Long
    Dim oFile As Long
    
    'Apre un avviso se ci sono file aperti non salvati
    For Each wb In Workbooks
        If wb.Saved = False Then
            Continua = MsgBox(IIf(lng = 0, "ATTENZIONE: ci sono dei file aperti non salvati. La procedura di ripristino potrebbe potrare a un crash dell'applicazione e alla conseguente perdita di dati. Proseguire comunque?", _
                                            "WARNING: unsaved files detected. This procedure could possibly lead to application crashes and data loss. Continue anyway?"), _
                                            vbYesNo, IIf(lng = 0, "File non salvati", "Unsaved data"))
            If Continua = vbNo Then Exit Sub
            Exit For
        End If
    Next wb
    
    Me.Hide
    
    Call AutoCalc(False)
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    
    fName = Me.txtDamagedFile.Value
    
    '#' Creo una nuova istanza di Excel e apro il foglio danneggiato al suo interno
    Set newApp = New Excel.Application
    With newApp
        .EnableEvents = False
        .DisplayAlerts = False
        .AutomationSecurity = msoAutomationSecurityForceDisable 'disabilita le macro
        .ScreenUpdating = False
        Set wbNew = .Workbooks.Add
        Set wbDamaged = .Workbooks.Open(fName, 0, True, , , , , , , , , , False, , 1)
        .Calculation = xlCalculationManual
    End With
    
    ff = wbDamaged.FileFormat
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = wbDamaged.Worksheets.Count
    Call ShowProgressBar
    
    For i = 1 To wbDamaged.Worksheets.Count
        
        counter = counter + 1
        
        'Aggiungo il foglio al nuovo file
        With wbNew
            If i > .Worksheets.Count Then .Worksheets.Add After:=.Worksheets(.Worksheets.Count)
        End With
        
        Set wsDamaged = wbDamaged.Worksheets(i)
        Set wsNew = wbNew.Worksheets(i)
        
        With wsDamaged
            wsNew.Name = .Name
            
            'Copio i dati (valori ed eventualmente formati)
            UProgress.SetDescription "Sto recuperando i dati... (" & wsDamaged.Name & ")"
            If Me.chkData = True Then
                .Cells.Copy
                wsNew.Cells(1, 1).PasteSpecial xlPasteValues
                If Me.chkFormats Then wsNew.Cells(1, 1).PasteSpecial xlPasteFormats
                newApp.CutCopyMode = False
            End If
            
            'Copio le formule

            If Me.chkFormulas = True Then
                UProgress.SetDescription "Sto recuperando le formule... (" & wsDamaged.Name & ")"
                
                On Error Resume Next
                Set fRng = .UsedRange.SpecialCells(xlCellTypeFormulas)
                If Err.Number = 0 Then
                    
                    '#' Attivo la finestra di avanzamento e setto contatore e massimo
                    counter2 = 0
                    countermax2 = fRng.Cells.Count
                    
                    For Each cell In fRng.Cells
                        counter2 = counter2 + 1
                        wsNew.Range(cell.address).FormulaLocal = cell.FormulaLocal
                        
                        '#' Aggiorna la barra di avanzamento secondaria
                        Call UpdateSubProgressBar(counter2, countermax2)
                        If ProgressAborted = 1 Then GoTo Aborted
                        On Error GoTo Aborted
                        
                    Next cell
                    UProgress.fraProgress2.visible = False
                    
                End If
                On Error GoTo Aborted
            End If
            
        End With
        
        'Reimposto l'ultima cella
        With wsNew
            .Range("A" & findlastcell(.Cells).Row + 1, "A" & .Rows.Count).EntireRow.Clear
            .Range(.Cells(1, findlastcell(.Cells).Column + 1), .Cells(1, .Columns.Count)).EntireColumn.Clear
        End With
            
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
    
    Next i
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    wbDamaged.Close (False)
    
    Name Me.txtDamagedFile As Me.txtDamagedFile & ".damaged"
    
    wbNew.SaveAs Me.txtDamagedFile, ff
    wbNew.Close (False)
    
    '#' Riattiva aggiornamenti automatici
    Application.EnableEvents = True
    Application.DisplayAlerts = True
    Call AutoCalc(True)
    
                                    
    oFile = MsgBox(IIf(lng = 0, _
                    "Il recupero dati |fffd| terminato." & vbNewLine & _
                    vbNewLine & _
                    "Dimensioni:" & vbNewLine & _
                    "File danneggiato: " & vbTab & Format(ConvertFileLen(Me.txtDamagedFile & ".damaged", "KB"), "#,##0") & " KB" & vbNewLine & _
                    "File riparato: " & vbTab & Format(ConvertFileLen(Me.txtDamagedFile, "KB"), "#,##0") & " KB" & vbNewLine & _
                    vbNewLine & _
                    "Vuoi aprire il file riparato per verificare il contenuto?", _
                    "Data recovery complete." & vbNewLine & _
                    vbNewLine & _
                    "Dimensions:" & vbNewLine & _
                    "Damaged file: " & vbTab & Format(ConvertFileLen(Me.txtDamagedFile & ".damaged", "KB"), "#,##0") & " KB" & vbNewLine & _
                    "Repaired file: " & vbTab & Format(ConvertFileLen(Me.txtDamagedFile, "KB"), "#,##0") & " KB" & vbNewLine & _
                    vbNewLine & _
                    "Would you like to open the repaired file to check its contents?"), _
                    vbInformation + vbYesNo, IIf(lng = 0, "Recupero dati completato", "Data recovery complete"))
                    
    If oFile = vbYes Then Call OpenFile(Me.txtDamagedFile)
    
    Exit Sub

Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub
Attribute VB_Name = "frmEmptyCells"
Attribute VB_Base = "0{F7A77863-C107-4DFF-9D16-38FFD6E3069D}{28397DF1-AF9D-4B2D-AF8B-9314AADA221F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim FormulaAlert As Boolean
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    DisableEvents = True
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    DisableEvents = False
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub chkNullFormulas_Click()
    If Me.chkNullFormulas = True And DisableEvents = False Then
        If FormulaAlert = False Then
            FormulaAlert = True
            If lng = 0 Then
                MsgBox "== ATTENZIONE: == " & vbNewLine & vbNewLine & "Questa opzione canceller|fffd| definitivamente le formule che in questo momento danno un risultato nullo!", vbExclamation, "Eliminazione formule"
            Else
                MsgBox "== WARNING: == " & vbNewLine & vbNewLine & "This option will permanently delete all formulas which currently give a null result!", vbExclamation, "Formulas deletion"
            End If
        End If
    End If
    
    Call GoodToGo(Me)

End Sub

Private Sub chkGhost_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkNonPrint_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkTrim_Change()
    Call GoodToGo(Me)
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        'On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        'On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    If Me.tglBatch = False Then '#' no batch
    
        Call backup_create_new
        
        Set ws = ActiveSheet
            
        If ws.ProtectContents = False Then
        
            '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
            Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
            
            If InRng Is Nothing Then
                MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
                    
            Else
                '#' Attivo la finestra di avanzamento e setto contatore e massimo
                counter = 0
                countermax = InRng.Cells.CountLarge
                UProgress.SetDescription "Sto svuotando le celle... (" & ws.Name & ")"
                Call ShowProgressBar
                
                For Each cell In InRng.Cells
                    
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                                                    
                    Call elaboracella(cell)
                                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    'On Error GoTo Aborted
    
                Next cell
                    
            End If
            
        End If
                            
    Else '#' BATCH
    
        On Error GoTo Aborted
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto svuotando le celle... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
                    
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    
                    'If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                    If Not InRng Is Nothing Then
                        
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If
                
                End If
            
            Next ws
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
            
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto svuotando le celle... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                                    
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                        
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If
                
                End If
            
            Next ws
            
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True
NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
                    
        Next f
            
    End If
    
    'Chiude la finestra di avanzamento
    Unload UProgress
        
    Call AutoCalc(True)
    
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub



Private Sub elaboracella(Cella As Range)
    Dim i As Long
    Dim strTemp As String
                
    If Not IsError(Cella) Then
                                        
        If Me.chkGhost = True Then
            If IsEmpty(Cella) = False And _
               Len(Cella.Value) = 0 And _
               Cella.HasFormula = False Then
                    Cella.ClearContents
            End If
        End If
        
        If Me.chkTrim = True Then
            If Trim(Cella) = "" Then Cella.ClearContents
        End If
        
        If Me.chkNonPrint = True Then
            strTemp = Cella.Value
            For i = 0 To 160
                If i < 32 Or i = 160 Then
                    strTemp = Replace(strTemp, Chr(i), "")
                End If
            Next i
            If strTemp = "" Then Cella.ClearContents
        End If
        
        If Me.chkNullFormulas = True Then
            If Cella.HasFormula = True Then
                If Cella.Value = "" Then
                    Cella.ClearContents
                End If
            End If
        End If
    
    End If

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmErrorLog"
Attribute VB_Base = "0{241224A4-4C6B-4539-BDDC-6090691AB8C1}{04DF1A2B-2775-418F-B2C8-626498921699}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim LimitChanged As Boolean

Private Sub UserForm_Initialize()
    Dim FilePath As String
    Dim f As Long
    Dim dataline As String
    Dim ErrLog As String
    
    On Error Resume Next

    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    FilePath = ErrorLog
    
    If FileExists(FilePath) = False Then
        Call CreateErrorLog
        If FileExists(FilePath) = False Then
            Me.Hide
            MsgBox "Il Registro degli errori non |fffd| stato trovato o risulta vuoto. Verr|fffd| generato automaticamente in occasione di un errore del programma", vbOKOnly + vbInformation, "Registro errori non trovato"
            Exit Sub
        End If
    End If
        
    f = FreeFile
    
    Open FilePath For Input As #f
    
        Do While Not EOF(f)
            Line Input #f, dataline
            If ErrLog = "" Then ErrLog = ErrLog & dataline Else ErrLog = ErrLog & vbNewLine & dataline
        Loop
        Me.lblErrorlog.Caption = ErrLog
        Me.lblErrorlog.AutoSize = True
        Me.fraErrorlog.ScrollBars = fmScrollBarsVertical
        Me.fraErrorlog.ScrollHeight = Me.lblErrorlog.Height + 10
        Me.fraErrorlog.ScrollWidth = Me.fraErrorlog.InsideWidth
        
        If IsPortable = True Then
            Me.lblLimitRows.visible = False
            Me.txtNRows.visible = False
            Me.spbNRows.visible = False
        Else
            Me.txtNRows = GetSettings("ErrorLogLimit")
        End If
    
    Close #f
    
End Sub

Private Sub UserForm_Activate()
    If Me.lblErrorlog.Caption = "" Then
        Call cmdOK_Click
    End If
End Sub

Private Sub cmdCleanup_Click()
    Dim ans As Long
    
    ans = MsgBox(IIf(lng = 0, _
                "Vuoi davvero cancellare il contenuto del registro errori?", _
                "Do you really want to erase the error log contents?"), _
                vbQuestion + vbYesNo)
    
    If ans = vbYes Then
        
        On Error Resume Next
        Kill ErrorLog
        On Error GoTo 0
        Call CreateErrorLog
        MsgBox IIf(lng = 0, "Registro errori cancellato", "Error log erased"), vbInformation
        Unload Me
    End If
    
End Sub

Private Sub spbNRows_SpinDown()
    Me.txtNRows = Me.spbNRows
End Sub

Private Sub spbNRows_SpinUp()
    Me.txtNRows = Me.spbNRows
End Sub
Private Sub txtNRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNRows_Change()
    If Val(Me.txtNRows) > Me.spbNRows.Max Then Me.txtNRows = Me.spbNRows.Max
    If Val(Me.txtNRows) < Me.spbNRows.Min Then Me.txtNRows = Me.spbNRows.Min
    Me.spbNRows = Me.txtNRows
    LimitChanged = True
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Unload Me
End Sub

Private Sub UserForm_Terminate()
    If LimitChanged = True Then Call UpdateConfigFile("ErrorLogLimit", Me.txtNRows)
End Sub
Attribute VB_Name = "frmExportRangeToASCII"
Attribute VB_Base = "0{37ECC994-2883-4246-931C-BCDB2DDD450A}{812A3F11-6858-4982-A29C-0B61D57C4DAC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub


Private Sub txtRowSep_Change()
    Me.chkRowSep = Not (Me.txtRowSep = "")
End Sub

Private Sub txtColSep_Change()
    Me.chkColSep = Not (Me.txtColSep = "")
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Sub cmdOK_Click()
    Dim i As Long, j As Long, n As Long, k As Long, f As Long
    Dim maxWidth As Long
    Dim pLength As Long
    Dim pRows As Long
    Dim arrRHeight() As Long
    Dim arrCWidth() As Long
    Dim totWidth As Long
    Dim sDefaultName As String
    Dim fp As String
    Dim T As String
    Dim vFilePath As Variant
    Dim strStart As Long
    Dim strLen As Long
    Dim strRow As String
    Dim pRowStr As String
    Dim overwrite As Long
    Dim oFolder As Long
    Dim p As Long
    Dim arrPages As Variant
    Dim myPage As Range
    Dim FolderName As String
    Dim fName As String
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If (TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Or _
                Range(Replace(.refRange, ";", ",")).Areas.Count > 1) Then
                MsgBox TranslateCnst("NoOrMultipleRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Set ws = ActiveSheet
    Set InRng = ws.Range(Replace(Me.refRange, ";", ","))
    
    If ActiveWorkbook.path = "" Then
        fp = DesktopPath
    Else
        fp = ValidateFolder(ActiveWorkbook.path)
    End If
    
        
    sDefaultName = "Exp_Range_" & ActiveWorkbook.Name & "_" & ws.Name & "_" & _
                    Replace(InRng.address(0, 0, xlA1), ":", "-") & ".txt"
    
    T = "Esporta l'intervallo in formato Ascii"
            
    Do
        If IsWindows = True Then
            vFilePath = Application.GetSaveAsFilename( _
                        InitialFileName:=fp & sDefaultName, _
                        FileFilter:="File di testo (*.txt), *.txt", _
                        Title:=T)
        Else
            vFilePath = Application.GetSaveAsFilename(InitialFileName:=fp & sDefaultName)
        End If
        
        '#' --exit if cancelled by user,
        If vFilePath = False Then GoTo Aborted
        
        '#' --ask user if he wants to overwrite
        If FileExists(vFilePath) Then
            overwrite = MsgBox(IIf(lng = 0, _
                               "Sovrascrivere il file " & vFilePath & "?", _
                               "Overwrite file " & vFilePath & "?"), _
                               vbExclamation + vbYesNo, _
                               IIf(lng = 0, "Conferma sovrascrittura", "Confirm overwrite"))
                        
            If overwrite = vbNo Then
                vFilePath = ""
                AutoCalc True
                AutoCalc False
            End If
            
        End If
        
    Loop Until vFilePath <> ""
                
    
    FolderName = Replace(vFilePath, Split(vFilePath, pSep)(UBound(Split(vFilePath, pSep))), "")
    
    'Creo l'array degli indirizzi dei range delle singole pagine:
    'Se l'opzione non |fffd| flaggata, popolo l'array con l'indirizzo dell'intero foglio
    If Me.chkMultipleImages = True Then
        arrPages = PagesAddress(ws)
    Else
        ReDim arrPages(1 To 1)
        arrPages(1) = CStr(ws.Cells.address)
    End If
    
    For p = 1 To UBound(arrPages)
        
        Set myPage = Intersect(InRng, ws.Range(arrPages(p)))
        
        If Not myPage Is Nothing Then
        
            With myPage
            
                '#' Ridimensiono gli array CWidth e RHeight, che conterranno la larghezza (massima di colonna) e il numero di righe (massimo di riga)
                ReDim arrRHeight(1 To .Rows.Count)
                ReDim arrCWidth(1 To .Columns.Count)
                
                '#' Creo gli array con l'altezza massima di ciascuna riga e la larghezza massima di ciascuna colonna
                For j = 1 To .Columns.Count
                    maxWidth = 0
                    For i = 1 To .Rows.Count
                        pRows = 0
                        If InStr(1, .Cells(i, j), Chr(10)) > 0 Then '#' abbiamo una linea che va a capo
                            strStart = 1
                            Do While Mid(.Cells(i, j), strStart) <> ""
                                pRows = pRows + 1
                                '#' pLength = lunghezza della riga "parziale"
                                pLength = InStr(strStart, .Cells(i, j), Chr(10)) - strStart
                                If pLength <= 0 Then pLength = Len(Mid(.Cells(i, j), strStart)) '#' Non |fffd| stata trovata un'interruzione successiva: pLength |fffd| = a tutto il resto della stringa dall'ultima interruzione
                                If pLength + (2 * Abs(CInt(Me.chkSpace))) > maxWidth Then maxWidth = pLength + (2 * Abs(CInt(Me.chkSpace)))
                                strStart = InStr(strStart, .Cells(i, j), Chr(10)) + 1
                                If strStart = 1 Then Exit Do '#' Non |fffd| stata trovata una nuova interruzione di linea: esci dal loop
                            Loop
                        ElseIf Len(.Cells(i, j)) + (2 * Abs(CInt(Me.chkSpace))) > maxWidth Then '#' La linea non va a capo
                            maxWidth = Len(.Cells(i, j)) + (2 * Abs(CInt(Me.chkSpace)))
                        End If
                        If pRows = 0 Then pRows = 1
                        If pRows > arrRHeight(i) Then arrRHeight(i) = pRows
                    Next i
                    arrCWidth(j) = maxWidth
                Next j
                
                '#' Stabilisco la larghezza complessiva della tabella
                For j = 1 To UBound(arrCWidth)
                    totWidth = totWidth + arrCWidth(j)
                Next j
                totWidth = totWidth + Abs(CInt(Me.chkColSep)) * (UBound(arrCWidth) + 1)                 '#' aggiungo la larghezza dei separatori colonne
                
                f = FreeFile
                
                If UBound(arrPages) = 1 Then
                    fName = vFilePath
                Else
                    fName = Replace(vFilePath, "." & FileExt(vFilePath), "") & "(" & p & ")." & FileExt(vFilePath)
                End If
                
                Open fName For Output As #f
                
                    For i = 1 To .Rows.Count
                    
                        If arrRHeight(i) = 1 Then   '#' Niente interruzioni di riga
                            
                            If i = 1 And Me.chkRowSep = True Then Print #f, String(totWidth, Me.txtRowSep)  '#' bordo superiore riga, solo se prima riga
                            
                            '#' Routine per la scrittura dei dati e dei separatori di colonna
                            strRow = ""
                            For j = 1 To .Columns.Count
                                If j = 1 And Me.chkColSep = True Then strRow = strRow & Me.txtColSep        '#' bordo sinistro, solo prima colonna
                                If Me.chkSpace Then strRow = strRow & " "                                   '#' spazio iniziale
                                strRow = strRow & .Cells(i, j) & _
                                    String(arrCWidth(j) - Len(.Cells(i, j)) - (2 * Abs(CInt(Me.chkSpace))), " ")
                                If Me.chkSpace Then strRow = strRow & " "                                   '#' spazio finale
                                If Me.chkColSep = True Then strRow = strRow & Me.txtColSep                  '#' bordo destro
                            Next j
                            Print #f, strRow
                            
                            If Me.chkRowSep = True Then Print #f, String(totWidth, Me.txtRowSep)            '#' bordo inferiore riga
                        
                        Else    '#' Abbiamo interruzioni di riga
                            If i = 1 And Me.chkRowSep = True Then Print #f, String(totWidth, Me.txtRowSep)  '#' bordo superiore riga, solo se prima riga
                                                
                            For n = 1 To arrRHeight(i) '#' Ciclo per ogni linea fino al massimo della riga corrente
                                          
                                strRow = ""     '#' il contenuto parziale della riga
                                strStart = 1    '#' il punto da cui si inizia a estratte strRow
                                strLen = 1      '#' la lunghezza di strRow
                                
                                For j = 1 To .Columns.Count
                                    If j = 1 And Me.chkColSep = True Then strRow = strRow & Me.txtColSep        '#' bordo sinistro, solo prima colonna
                                    If Me.chkSpace Then strRow = strRow & " "                                   '#' spazio iniziale
                                    
                                    '#' Cerco il punto di inizio di estrazione del multiriga
                                        If n = 1 Then
                                            strStart = 1    '#' E' la prima riga, inizio da 1
                                        Else
                                            For k = 2 To n  '#' Trovo l'n-1esima ricorrenza di interruzione di riga
                                                strStart = InStr(strStart, .Cells(i, j), Chr(10)) + 1
                                            Next k
                                        End If
                                        
                                    '#' Cerco la lunghezza parziale della riga
                                        strLen = InStr(strStart, .Cells(i, j), Chr(10)) - strStart
                                        '#' Se la stringa non raggiunge il massimo di linee della riga, strLen diventa < 0 per le linee vuote. Se non ha interruzioni di linea, diventa 0 per la prima riga. Quindi:
                                        If (strLen < 0) Or (strLen = 0 And n = 1) Then strLen = Len(.Cells(i, j)) - strStart + 1
                                    
                                    '#' Estraggo la riga parziale
                                    If n > 1 And strStart = 1 Then '#' linea vuota nella cella
                                        pRowStr = ""
                                    Else
                                        pRowStr = Mid(.Cells(i, j), strStart, strLen)
                                    End If
                                    
                                    strRow = strRow & pRowStr & String(arrCWidth(j) - Len(pRowStr) - (2 * Abs(CInt(Me.chkSpace))), " ")
                                    
                                    If Me.chkSpace Then strRow = strRow & " "                                   '#' spazio finale
                                    If Me.chkColSep = True Then strRow = strRow & Me.txtColSep                  '#' bordo destro
                                Next j
                                Print #f, strRow
                      
                            Next n
                            
                            If Me.chkRowSep = True Then Print #f, String(totWidth, Me.txtRowSep)            '#' bordo inferiore riga
                        End If
                    Next i
                Close #f
                
                Call CloseTxt(fName)
            
            End With
                                    
        End If 'Not myPage Is Nothing
                                    
    Next p
    
    oFolder = MsgBox(IIf(lng = 0, "L'esportazione di " & UBound(arrPages) & " file di testo |fffd| avvenuta con successo nella cartella: " & _
                    vbNewLine & vbNewLine & _
                    FolderName & _
                    vbNewLine & vbNewLine & _
                    "Vuoi aprire la cartella di destinazione?", _
                    "Export successfully completed to folder: " & _
                    vbNewLine & vbNewLine & _
                    FolderName & _
                    vbNewLine & vbNewLine & _
                    "Would you like to open destination folder?"), _
                    vbInformation + vbYesNo, _
                    IIf(lng = 0, "Esportazione completata", "Export complete"))
                    
    If oFolder = vbYes Then Call OpenFolder(FolderName)
                                
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmExportRangeToImage"
Attribute VB_Base = "0{B8822571-3F80-40BA-9C15-6057F6453655}{12F6CF5B-F2F3-4954-92B3-4EE3A161381A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    With Me.cbxFormat
        .AddItem "Portable Network Graphics Format (*.png)"
        .AddItem "JPEG File Interchange Format (*.jpg)"
        .AddItem "Graphics Interchange Format (*.gif)"
        .ListIndex = 0
    End With
    
    With Me.cbxColor
        If lng = 0 Then
            .AddItem "Automatico (default)"
            .AddItem "Scala di grigi"
            .AddItem "Bianco e nero (1 bit)"
        Else
            .AddItem "Automatic (default)"
            .AddItem "Grayscale"
            .AddItem "Black & white (1 bit)"
        End If
        .ListIndex = 0
    End With
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    Call CalculateSize

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    Call CalculateSize
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub scbQuality_Change()
    Call CalculateSize
    Me.lblQuality.Caption = "Qualit|fffd|: " & Me.scbQuality.Value
    Me.cmdOK.SetFocus
End Sub

Private Sub chkMultipleImages_Change()
    Call CalculateSize
End Sub

Private Sub CalculateSize()
    Dim wPix As Long
    Dim hPix As Long
    Dim cRng As Range
    
    If Me.chkMultipleImages = True Then
        Me.lblImgSize = IIf(lng = 0, "Immagini multiple", "Multiple pictures")
        Exit Sub
    End If
        
    On Error Resume Next
    Set cRng = Range(Me.refRange)
    
    wPix = PtsToPx(cRng.Width * Me.scbQuality)
    hPix = PtsToPx(cRng.Height * Me.scbQuality)
    
    Me.lblImgSize = wPix & " x " & hPix & " pixel"
    On Error GoTo 0
    
End Sub

Private Function PtsToPx(p As Long) As Long
    PtsToPx = p * 96 / 72
End Function

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Sub cmdOK_Click()
    Dim sDefaultName As String
    Dim fp As String
    Dim fFilter As String
    Dim T As String
    Dim vFilePath As Variant
    Dim overwrite As Long
    Dim oFolder As Long
    Dim i As Long
    Dim arrPages As Variant
    Dim myPage As Range
    Dim FolderName As String

    'If IsWindows = False Then Exit Sub
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If (TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Or _
                Range(Replace(.refRange, ";", ",")).Areas.Count > 1) Then
                MsgBox TranslateCnst("NoOrMultipleRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Set ws = ActiveSheet
    Set InRng = ws.Range(Replace(Me.refRange, ";", ","))
        
    On Error GoTo Aborted
    
    If ActiveWorkbook.path = "" Then
        fp = DesktopPath
    Else
        fp = ValidateFolder(ActiveWorkbook.path)
    End If
    
    Select Case Me.cbxFormat.ListIndex
        Case 0
            fFilter = "Portable Network Graphics Format (*.png), *.png"
        Case 1
            fFilter = "JPEG File Interchange Format (*.jpg), *.jpg"
        Case 2
            fFilter = "Graphics Interchange Format (*.gif), *.gif"
    End Select
    sDefaultName = "Exp_Range_" & ActiveWorkbook.Name & "_" & ws.Name & "_" & _
                    Replace(InRng.address(0, 0, xlA1), ":", "-") & Right(fFilter, 4)
    
    T = "Salva l'intervallo come immagine"
            
    Do
        If IsWindows = True Then
            vFilePath = Application.GetSaveAsFilename( _
                        InitialFileName:=fp & sDefaultName, _
                        FileFilter:=fFilter, _
                        Title:=T)
        Else
            vFilePath = Application.GetSaveAsFilename(InitialFileName:=fp & sDefaultName)
        End If
        
        '#' --exit if cancelled by user,
        If vFilePath = False Then GoTo Aborted
        
        '#' --ask user if he wants to overwrite
        If FileExists(vFilePath) Then
            overwrite = MsgBox("Sovrascrivere il file " & vFilePath & "?", vbExclamation + vbYesNo, "Conferma sovrascrittura")
                        
            If overwrite = vbNo Then
                vFilePath = ""
                AutoCalc True
                AutoCalc False
            End If
            
        End If
        
    Loop Until vFilePath <> ""
    
    FolderName = Replace(vFilePath, Split(vFilePath, pSep)(UBound(Split(vFilePath, pSep))), "")
    
    'Creo l'array degli indirizzi dei range delle singole pagine:
    'Se l'opzione non |fffd| flaggata, popolo l'array con l'indirizzo dell'intero foglio
    If Me.chkMultipleImages = True Then
        arrPages = PagesAddress(ws)
    Else
        ReDim arrPages(1 To 1)
        arrPages(1) = CStr(ws.Cells.address)
    End If
    
    For i = 1 To UBound(arrPages)
        
        Set myPage = Intersect(InRng, ws.Range(arrPages(i)))
        
        If Not myPage Is Nothing Then
        
            With myPage
                        
                '#' --Make picture of selection and copy to clipboard
                .CopyPicture Appearance:=xlScreen, Format:=xlPicture
                
                '#' --Create an empty chart with exact size of range copied
                With ws.ChartObjects.Add( _
                    Left:=.Left, Top:=.Top, Width:=.Width, Height:=.Height)
                    .Name = "ESK_TempChart"
                    .Activate
                End With
            End With
            
            '#' --Paste into chart area
            ActiveChart.Paste
            
            '#' --Improve quality (1 to 10)
            With ws.Shapes("ESK_TempChart")
                .ScaleWidth Me.scbQuality, msoFalse, msoScaleFromTopLeft
                .ScaleHeight Me.scbQuality, msoFalse, msoScaleFromTopLeft
            End With
            
            '#' --export to file, delete chart.
            With ws.ChartObjects("ESK_TempChart")
                .Activate
                ActiveChart.Shapes.Range(Array("chart")).Select
                Selection.ShapeRange.PictureFormat.ColorType = Me.cbxColor.ListIndex + 1 'Set color depth
                If UBound(arrPages) = 1 Then
                    .Chart.Export CStr(vFilePath)
                Else
                    .Chart.Export CStr(Left(vFilePath, Len(vFilePath) - 4) & "(" & i & ")" & Right(vFilePath, 4))
                End If
                .Delete
            End With
                
        End If 'Not myPage Is Nothing
        
    Next i
    
    oFolder = MsgBox(IIf(lng = 0, "L'esportazione di " & UBound(arrPages) & " immagini |fffd| avvenuta con successo nella cartella: " & _
                    vbNewLine & vbNewLine & _
                    FolderName & _
                    vbNewLine & vbNewLine & _
                    "Vuoi aprire la cartella di destinazione?", _
                    "Export successfully completed to folder: " & _
                    vbNewLine & vbNewLine & _
                    FolderName & _
                    vbNewLine & vbNewLine & _
                    "Would you like to open destination folder?"), _
                    vbInformation + vbYesNo, _
                    IIf(lng = 0, "Esportazione completata", "Export complete"))
                    
    If oFolder = vbYes Then Call OpenFolder(FolderName)
                                
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmExportToWord"
Attribute VB_Base = "0{26232B9A-87EE-4103-B739-E36177EF164A}{D49E7E37-6D64-4B69-BE4B-D77A83294722}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim FolderName As String
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    DisableEvents = True
    
    With Me.cbxFormat
        .AddItem "Tabelle Excel"
        .AddItem "Testo non formattato"
        .AddItem "Immagine Bitmap"
        .ListIndex = 0
    End With
    
    Call SaveOptions(Me)
    
    If ActiveWorkbook.path = "" Then
        Me.txtDestFolder = DesktopPath
    Else
        Me.txtDestFolder = ActiveWorkbook.path
    End If
    
    Call ListSheets
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    On Error Resume Next
    Me.refFixedRange = Selection.address
    If Range(Me.refFixedRange).Cells.Count = 1 Then
        Me.refFixedRange = ActiveCell.CurrentRegion.address
        Range(Me.refFixedRange).Select
    End If
    On Error GoTo 0
    
    Call GoodToGo(Me)
        
    DisableEvents = False

End Sub

Private Sub ListSheets()
        
    If ActiveWorkbook Is Nothing Or ActiveWorkbook.Name = ThisWorkbook.Name Then Exit Sub
    
    Me.lbxSheets.Clear
    
    For Each ws In ActiveWorkbook.Worksheets
        If Not ws.Name = "ESK_Backup" And _
           ws.visible = xlSheetVisible And _
           UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*" Then
                Me.lbxSheets.AddItem ws.Name
                If IsSelected(ws.Name) Or ActiveWindow.SelectedSheets.Count = 1 Then Me.lbxSheets.Selected(Me.lbxSheets.ListCount - 1) = True
        End If
    Next ws

End Sub

Private Sub txtFilterList_Change()
    Call ListSheets
End Sub

Private Sub cmdSelectFolder_Click()
    Me.txtDestFolder.Text = FolderPicker(Me.txtDestFolder.Text)
End Sub

Private Sub txtDestFolder_Change()
    Me.txtDestFolder.ControlTipText = Me.txtDestFolder.Text
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxSheets.ListCount - 1
        Me.lbxSheets.Selected(i) = Me.chkAllNone
    Next i
    
    Call GoodToGo(Me)
    
    DisableEvents = False
End Sub

Private Sub lbxSheets_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub

Private Sub refFixedRange_Change()
    On Error Resume Next
    Me.refFixedRange = Mid(Replace(Me.refFixedRange, ";", ","), InStr(1, Me.refFixedRange, "!") + 1)
    On Error GoTo 0
End Sub

Private Sub optFixedRange_Change()
    Me.refFixedRange.Enabled = Me.optFixedRange
    If Me.optFixedRange = True Then Me.refFixedRange.SetFocus
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim Sourcewb As Workbook
    Dim sh As Worksheet
    Dim DateString As String
    Dim i As Long
    Dim oFolder As Long
    Dim WdObj As Object
    Dim CopyRng As Range
    Dim arrPages As Variant
    Dim myPage As Range
    Dim p As Long
    
    With Me
        On Error Resume Next
        If .optFixedRange = True Then
            If TypeName(Range(Replace(.refFixedRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refFixedRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With

    Set Sourcewb = ActiveWorkbook
    
    DateString = Format(Now, "yyyy-mm-dd hh-mm-ss")

    FolderName = ValidateFolder(Me.txtDestFolder)
    If Me.chkSubFolder Then FolderName = FolderName & DateString
    
    'Creo l'oggetto Applicazione Word
    Set WdObj = CreateObject("Word.Application")
    WdObj.visible = False
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)

    '#' Create new folder to save the new files in
    On Error Resume Next
    MkDir FolderName
    On Error GoTo Aborted
    
    '#' Creo nuovo documento Word
    WdObj.Documents.Add
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = CountListBox(Me.lbxSheets)
    UProgress.SetDescription "Salvataggio di " & countermax & " file in corso..."
    Call ShowProgressBar
        
    '#' Copy every selected sheet to a new workbook
    For i = 0 To Me.lbxSheets.ListCount - 1
        
        If Me.lbxSheets.Selected(i) = True Then
            
            Set sh = Sourcewb.Worksheets(Me.lbxSheets.List(i))
    
            '#' Aumento di 1 il contatore e aggiorno descrizione barra avanzamento
            counter = counter + 1
            UProgress.SetDescription "Esportazione in corso - " & counter & " di " & countermax & " - (" & sh.Name & ")"
                            
            '#' Determino qual |fffd| l'area da copiare, e la copio
            If Me.optPrintArea = True Then
                If sh.PageSetup.PrintArea <> "" Then
                    Set CopyRng = sh.Range(sh.PageSetup.PrintArea)
                Else
                    Set CopyRng = sh.UsedRange
                End If
            ElseIf Me.optUsedRange = True Then
                Set CopyRng = sh.UsedRange
            ElseIf Me.optFixedRange = True Then
                Set CopyRng = sh.Range(Me.refFixedRange)
            End If

            'Creo l'array degli indirizzi dei range delle singole pagine:
            'Se l'opzione non |fffd| flaggata, popolo l'array con l'indirizzo dell'intero foglio
            If Me.chkMultipleImages = True Then
                arrPages = PagesAddress(sh)
            Else
                ReDim arrPages(1 To 1)
                arrPages(1) = CStr(sh.Cells.address)
            End If
            
            For p = 1 To UBound(arrPages)
                
                Set myPage = Intersect(CopyRng, sh.Range(arrPages(p)))
                
                If Not myPage Is Nothing Then
                                
                    myPage.Copy
            
                    With WdObj
        
                        Select Case Me.cbxFormat.ListIndex
                            Case 0 '#' Tabelle Excel
                                .Selection.PasteExcelTable False, False, False
        
                            Case 1 '#' Testo non formattato
                                .Selection.PasteSpecial link:=False, _
                                                        DataType:=2, _
                                                        Placement:=0, _
                                                        DisplayAsIcon:=False
        
                            Case 2 '#' Immagine Bitmap
                                .Selection.PasteSpecial link:=False, _
                                                        DataType:=3, _
                                                        Placement:=0, _
                                                        DisplayAsIcon:=False
                        End Select
                        
                        '#' Se si |fffd| selezionato file unico, allora inserisci interruzione di pagina, altrimenti salva il file
                        If Me.optOneFile = True Then
                            DoEvents
                            .Selection.InsertBreak Type:=7
        
                        ElseIf Me.optSepFiles = True Then
                            DoEvents
                            Application.DisplayAlerts = False
                            .ChangeFileOpenDirectory FolderName
                            If UBound(arrPages) = 1 Then
                                .Activedocument.SaveAs FileName:=Replace(Sourcewb.Name, "." & Split(Sourcewb.Name, ".")(UBound(Split(Sourcewb.Name, "."))), "") & "_" & sh.Name & ".docx", FileFormat:=12
                            Else
                                .Activedocument.SaveAs FileName:=Replace(Sourcewb.Name, "." & Split(Sourcewb.Name, ".")(UBound(Split(Sourcewb.Name, "."))), "") & "_" & sh.Name & "(" & p & ").docx", FileFormat:=12
                            End If
                            Application.DisplayAlerts = True
                            .Activedocument.Close
                            .Documents.Add
                        End If
        
                    End With
                                
                End If 'Not myPage is Nothing
                
            Next p

GoToNextSheet:
            Set CopyRng = Nothing
            Set myPage = Nothing
            Application.CutCopyMode = False

            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If counter Mod 10 = 0 Then DoEvents
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        End If
    Next i

    If Me.optOneFile = True Then
        Application.DisplayAlerts = False
        With WdObj
            .ChangeFileOpenDirectory FolderName
            .Activedocument.SaveAs FileName:=Replace(Sourcewb.Name, "." & Split(Sourcewb.Name, ".")(UBound(Split(Sourcewb.Name, "."))), "") & ".docx", FileFormat:=12
            .Activedocument.Close
            .Quit
        End With
        Application.DisplayAlerts = True
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress

    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    oFolder = MsgBox(IIf(lng = 0, "Esportazione di " & countermax & " fogli completata. Troverai i file nella cartella: " & _
                    vbNewLine & vbNewLine & _
                    FolderName & _
                    vbNewLine & vbNewLine & _
                    "Vuoi aprire la cartella di destinazione?", _
                    "Export of " & countermax & " sheets complete. You can find your files in this folder: " & _
                    vbNewLine & vbNewLine & _
                    FolderName & _
                    vbNewLine & vbNewLine & _
                    "Would you like to open destination folder?"), _
                    vbInformation + vbYesNo, _
                    IIf(lng = 0, "Esportazione completata", "Export complete"))
                    
    If oFolder = vbYes Then Call OpenFolder(FolderName)
        
    Set WdObj = Nothing
    
    Exit Sub
        
Aborted:
    Set WdObj = Nothing
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmFilterByTextFormat"
Attribute VB_Base = "0{53D51625-8B02-4B47-AF2C-A5FB7A36BF54}{DE9B2E3B-E741-4E90-AA9B-EA23431446C1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim HideRng As Range
    Dim check As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    
    
    On Error GoTo Aborted
    
    Set ws = ActiveSheet
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")))
    Set InRng = Intersect(InRng, InRng.Offset(1, 0))
    
    For Each cell In InRng.Cells
        check = 0
        With Me
            If .chkBold Then
                If cell.Font.Bold = False Then
                    check = 1
                    GoTo BuildRange
                Else
                    check = 0
                End If
            End If
        
            If .chkItalic Then
                If cell.Font.Italic = False Then
                    check = 1
                    GoTo BuildRange
                Else
                    check = 0
                End If
            End If
        
            If .chkUnderline Then
                If cell.Font.Underline = xlUnderlineStyleNone Then
                    check = 1
                    GoTo BuildRange
                Else
                    check = 0
                End If
            End If
        
            If .chkStrikethrough Then
                If cell.Font.Strikethrough = False Then
                    check = 1
                    GoTo BuildRange
                Else
                    check = 0
                End If
            End If
                    
BuildRange:
            If check = 1 Then
                If HideRng Is Nothing Then
                    Set HideRng = cell
                Else
                    Set HideRng = Union(HideRng, cell)
                End If
            End If
        End With
    Next cell
                            
    'Filtro finale
    If Not HideRng Is Nothing Then
        HideRng.EntireRow.Hidden = True
    End If
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmFindUtility"
Attribute VB_Base = "0{9BD06A83-C76D-4953-A027-CE702D744AFB}{AFA7A52F-6A57-4F16-A8EA-25BD1EBB24B7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim CurrentScale As Single
    
Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    CurrentScale = GetSettings("Scale") / 100 * tmpScale
    
    Me.txtFind = ""
    Me.lblSearchResults.Height = 1
    Me.lblSearchResults.Width = Me.fraSearchResults.Width - 20 * CurrentScale
    Me.lblSearchResults.Caption = TranslateCnst("InitialMsg")
    Me.lblSearchResults.AutoSize = True
    Me.lblSearchResults.AutoSize = False
    
    With Me.fraSearchResults
        .ScrollBars = fmScrollBarsVertical
        .ScrollHeight = .InsideHeight * 2
        .ScrollWidth = .InsideWidth
    End With

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub
Private Sub txtFind_Change()
    Dim ctl As control
    
    CurrentScale = GetSettings("Scale") / 100 * tmpScale

    If Len(Me.txtFind) > 2 Then
        Call DoSearch
    Else
        Me.lblSearchResults.AutoSize = False
        Me.lblSearchResults.Caption = TranslateCnst("InitialMsg")
        Me.lblSearchResults.Width = Me.fraSearchResults.Width - 20 * CurrentScale
        Me.lblSearchResults.AutoSize = True
        Me.lblSearchResults.AutoSize = False
        For Each ctl In Me.fraSearchResults.Controls
            If Left(ctl.Name, 3) = "cmd" Then Me.Controls.Remove (ctl.Name)
        Next ctl
        Me.fraSearchResults.ScrollHeight = Me.lblSearchResults.Height
    End If
End Sub
Private Sub lblBlank0_Click()
    Me.fraSearchResults.ScrollHeight = Me.lblSearchResults.Height
End Sub

Private Sub chkShowDesc_Change()
    If Len(Me.txtFind) > 2 Then Call DoSearch
End Sub

Private Sub DoSearch()
    Dim ctl As control
    
    CurrentScale = GetSettings("Scale") / 100 * tmpScale
    
    For Each ctl In Me.fraSearchResults.Controls
        If Left(ctl.Name, 3) = "cmd" Then Me.Controls.Remove (ctl.Name)
    Next ctl
    Me.lblSearchResults.AutoSize = False
    Me.lblSearchResults.Caption = ""
    Me.lblSearchResults.Height = 1
    Me.lblSearchResults.Width = 280 * CurrentScale
    
    Call ListResults
    Me.fraSearchResults.ScrollHeight = Me.lblSearchResults.Height
    Me.fraSearchResults.Scroll fmScrollActionNoChange, fmScrollActionBegin

End Sub

Private Sub ListResults()
    Dim TextToFind As String
    Dim SearchResults As String
    Dim ListWs As Worksheet
    Dim i As Long
    Dim FoundItems As New Collection
    Dim ctladd1 As control
    Dim ctladd2 As control
    Dim PrevHeight As Long
    Dim fCount As Long
    
    CurrentScale = GetSettings("Scale") / 100 * tmpScale
    
    Set ListWs = MenuSheet
    TextToFind = Me.txtFind
    SearchResults = ""
    
    PrevHeight = 0
    fCount = 0
    With ListWs
        For i = 2 To .UsedRange.Rows.Count
            PrevHeight = Me.lblSearchResults.Height
            Err.Clear
            If .Cells(i, Application.WorksheetFunction.Match("desc_Sub", .Rows(1), 0)) <> "" And InStr(1, UCase(.Cells(i, Application.WorksheetFunction.Match("label_it", .Rows(1), 0) + lng)), UCase(TextToFind)) > 0 Then '#' Trovato riscontro in elenco nomi
                fCount = fCount + 1
                On Error Resume Next
                FoundItems.Add .Cells(i, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)), CStr(.Cells(i, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)))
                If Err.Number = 0 Then '#' non |fffd| ancora inclusa nell'elenco dei risultati
                    PrevHeight = Me.lblSearchResults.Height
                    'TITOLO DELLO STRUMENTO
                    SearchResults = SearchResults & "== " & .Cells(i, Application.Match("label_it", .Rows(1), 0) + lng) & " ==" & vbNewLine & vbNewLine
                    'CATEGORIA DELLO STRUMENTO
                    SearchResults = SearchResults & IIf(lng = 0, "Categoria: ", "Category: ") & .Cells(Application.Match(.Cells(i, Application.Match("id_cat", .Rows(1), 0)), .Columns(2), 0), Application.Match("label_it", .Rows(1), 0) + lng) & vbNewLine & vbNewLine
                    'DESCRIZIONE DELLO STRUMENTO
                    If Me.chkShowDesc = True Then
                        If .Cells(i, 3) = "" Then
                            SearchResults = SearchResults & .Cells(i, Application.Match("supertip_it", .Rows(1), 0) + lng) & vbNewLine & vbNewLine
                        Else
                            SearchResults = SearchResults & .Cells(i, Application.Match("desc_it", .Rows(1), 0) + lng) & vbNewLine & vbNewLine
                        End If
                    End If
                    SearchResults = SearchResults & "___________________________________________________________" & vbNewLine & vbNewLine
                    Me.lblSearchResults.Caption = SearchResults
                    Me.lblSearchResults.AutoSize = True
                    Set ctladd1 = Me.fraSearchResults.Controls.Add("Forms.CommandButton.1", "cmdRunFind_" & .Cells(i, Application.WorksheetFunction.Match("desc_Sub", .Rows(1), 0)))
                    With ctladd1
                        .Left = Me.lblSearchResults.Width + 25
                        .Top = (5 * CurrentScale) + PrevHeight
                        .Height = 20 * CurrentScale
                        .Width = 80 * CurrentScale
                        .BackColor = 12648447
                        .Caption = IIf(lng = 0, "Esegui", "Run")
                        .ControlTipText = IIf(lng = 0, "Esegui: ", "Run: ") & ListWs.Cells(i, Application.WorksheetFunction.Match("label_it", ListWs.Rows(1), 0) + lng)
                        .Tag = ListWs.Cells(i, 4)
                    End With
                    Set ctladd2 = Me.fraSearchResults.Controls.Add("Forms.CommandButton.1", "cmdHelpFind_" & .Cells(i, Application.WorksheetFunction.Match("desc_Sub", .Rows(1), 0)))
                    With ctladd2
                        .Width = 20 * CurrentScale
                        .Height = 20 * CurrentScale
                        .Left = Me.lblSearchResults.Width + 25 + ctladd1.Width - .Width
                        .Top = (5 * CurrentScale) + PrevHeight + ctladd1.Height + 4
                        .visible = True
                        .ControlTipText = "Help: " & ListWs.Cells(i, Application.Match("label_it", ListWs.Rows(1), 0) + lng)
                        .Tag = ListWs.Cells(i, 2)
                        .Caption = "?"
                    End With
                    Set btnColl = CommonButtons(Me, True)

                    Set ctladd1 = Nothing
                    Set ctladd2 = Nothing
                Else
                    Err.Clear
                End If
                On Error GoTo Aborted
            End If
        Next i
    
        For i = 2 To .UsedRange.Rows.Count
            PrevHeight = Me.lblSearchResults.Height
            Err.Clear
            If .Cells(i, Application.WorksheetFunction.Match("desc_Sub", .Rows(1), 0)) <> "" And InStr(1, UCase(.Cells(i, Application.WorksheetFunction.Match("desc_it", .Rows(1), 0) + lng)), UCase(TextToFind)) > 0 Then  '#' Trovato riscontro in elenco descrizioni
                fCount = fCount + 1
                On Error Resume Next
                FoundItems.Add .Cells(i, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)), CStr(.Cells(i, Application.WorksheetFunction.Match("ID_menu", .Rows(1), 0)))
                If Err.Number = 0 Then '#' non |fffd| ancora inclusa nell'elenco dei risultati
                    PrevHeight = Me.lblSearchResults.Height
                    'TITOLO DELLO STRUMENTO
                    SearchResults = SearchResults & "== " & .Cells(i, Application.Match("label_it", .Rows(1), 0) + lng) & " ==" & vbNewLine & vbNewLine
                    'CATEGORIA DELLO STRUMENTO
                    SearchResults = SearchResults & IIf(lng = 0, "Categoria: ", "Category: ") & .Cells(Application.Match(.Cells(i, Application.Match("id_cat", .Rows(1), 0)), .Columns(2), 0), Application.Match("label_it", .Rows(1), 0) + lng) & vbNewLine & vbNewLine
                    'DESCRIZIONE DELLO STRUMENTO
                    If Me.chkShowDesc = True Then
                        If .Cells(i, 3) = "" Then
                            SearchResults = SearchResults & .Cells(i, Application.Match("supertip_it", .Rows(1), 0) + lng) & vbNewLine & vbNewLine
                        Else
                            SearchResults = SearchResults & .Cells(i, Application.Match("desc_it", .Rows(1), 0) + lng) & vbNewLine & vbNewLine
                        End If
                    End If
                    SearchResults = SearchResults & "___________________________________________________________" & vbNewLine & vbNewLine
                    Me.lblSearchResults.Caption = SearchResults
                    Me.lblSearchResults.AutoSize = True
                    Set ctladd1 = Me.fraSearchResults.Controls.Add("Forms.CommandButton.1", "cmdRunFind_" & .Cells(i, Application.WorksheetFunction.Match("desc_Sub", .Rows(1), 0)))
                    With ctladd1
                        .Left = Me.lblSearchResults.Width + 25
                        .Top = (5 * CurrentScale) + PrevHeight
                        .Height = 20 * CurrentScale
                        .Width = 80 * CurrentScale
                        .BackColor = 12648447
                        .Caption = IIf(lng = 0, "Esegui", "Run")
                        .ControlTipText = IIf(lng = 0, "Esegui: ", "Run: ") & ListWs.Cells(i, Application.WorksheetFunction.Match("label_it", ListWs.Rows(1), 0) + lng)
                        .Tag = ListWs.Cells(i, 4)
                    End With
                    Set ctladd2 = Me.fraSearchResults.Controls.Add("Forms.CommandButton.1", "cmdHelpFind_" & .Cells(i, Application.WorksheetFunction.Match("desc_Sub", .Rows(1), 0)))
                    With ctladd2
                        .Width = 20 * CurrentScale
                        .Height = 20 * CurrentScale
                        .Left = Me.lblSearchResults.Width + 25 + ctladd1.Width - .Width
                        .Top = (5 * CurrentScale) + PrevHeight + ctladd1.Height + 4
                        .visible = True
                        .ControlTipText = "Help: " & ListWs.Cells(i, Application.WorksheetFunction.Match("label_it", ListWs.Rows(1), 0) + lng)
                        .Tag = ListWs.Cells(i, 2)
                        .Caption = "?"
                    End With
                    Set btnColl = CommonButtons(Me, True)

                    Set ctladd1 = Nothing
                    Set ctladd2 = Nothing
                Else
                    Err.Clear
                End If
                On Error GoTo Aborted
            End If
        Next i
        
        If fCount = 0 Then
            Me.lblSearchResults.Caption = IIf(lng = 0, "== Spiacente, nessun risultato trovato per ", "== Sorry, no results found for ") & """" & Me.txtFind & """ =="
            Me.lblSearchResults.AutoSize = True
        End If
    End With
        
    Exit Sub

Aborted:
    Call CanceledProcedure

End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub


Attribute VB_Name = "frmGenerateSQL"
Attribute VB_Base = "0{87830115-5355-4709-B730-C10F76DE7B7C}{A8C16CCD-DF46-44FD-90A5-7C1CA75012D6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim CurrentScale As Single
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    Dim strDBMS As String
    
    DisableEvents = True
    
    Call ScaleForm(Me)
    
    Call SaveOptions(Me)
    With Me.cbxDBMS
        .AddItem "Oracle"
        .AddItem "MS Sql Server"
        .AddItem "MS Access"
        .AddItem IIf(lng = 0, "Altro (MySQL, PostgreSQL, SQLite, etc.)", "Other (MySQL, PostgreSQL, SQLite, etc.)")
        .ListIndex = 0
    End With
        
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    Set btnColl = CommonButtons(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    CurrentScale = GetSettings("Scale") / 100 * tmpScale
    
    Me.lblColumnsList.Height = 1
    Me.lblColumnsList.Width = 1
    
    With Me.fraColumnsList
        .ScrollBars = fmScrollBarsVertical
        .ScrollHeight = .InsideHeight * 2
        .ScrollWidth = .InsideWidth
    End With

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    DisableEvents = False
    
    Call ReadColumns
    Me.txtTableName = SQLClean(ActiveSheet.Name, "table")
    
    strDBMS = Me.cbxDBMS.Value
    DisableEvents = True
    Me.cbxDBMS.Value = ""
    DisableEvents = False
    Me.cbxDBMS.Value = strDBMS
    
End Sub
    
Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
    Call ReadColumns
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub cbxDBMS_Change()
    Dim ctl As control
    Dim lIndex As Long
    
    If DisableEvents = True Then Exit Sub
    
    Me.chkTruncateTable = (Me.cbxDBMS <> "MS Access")
    Me.chkTruncateTable.Enabled = (Me.cbxDBMS <> "MS Access")
    
    For Each ctl In Me.fraColumnsList.Controls
        If ctl.Name Like "SQLcbxSQLType_*" Then
            With ctl
                lIndex = .ListIndex
                .Clear
                .List = DBMSTypes(Me.cbxDBMS.Text)
                .ListIndex = lIndex
            End With
        End If
    Next ctl
    
End Sub

Private Sub chkCreateTable_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraColumnsList.Controls
        If ctl.Name Like "SQLtxtFLen_*" Then
            ctl.visible = Me.chkCreateTable
        End If
    Next ctl
    
    If Me.chkCreateTable = False Then Me.chkDropTable = False
    If Me.chkCreateTable = True Then Me.chkTruncateTable = False
End Sub

Private Sub txtTableName_Change()
    If Me.txtTableName <> SQLClean(Me.txtTableName, "table") Then
        Me.txtTableName.BackColor = &HC0E0FF
    Else
        Me.txtTableName.BackColor = &H80000005
    End If
End Sub

Private Sub chkDropTable_Change()
    If Me.chkDropTable = True Then Me.chkCreateTable = True
End Sub

Private Sub chkTruncateTable_Change()
    If Me.chkTruncateTable = True Then Me.chkCreateTable = False
End Sub

Private Sub ReadColumns()
    Dim ctl As control
    
    If DisableEvents = True Then Exit Sub
    
    For Each ctl In Me.fraColumnsList.Controls
        If Not ctl.Name = "lblColumnsList" Then Me.Controls.Remove (ctl.Name)
    Next ctl
    Me.lblColumnsList.Height = 1
    Me.lblColumnsList.Width = 1
    
    Call ListResults
    Me.fraColumnsList.ScrollHeight = Me.lblColumnsList.Height
    Me.fraColumnsList.Scroll fmScrollActionNoChange, fmScrollActionBegin

End Sub

Private Sub ListResults()
    Dim cIndex As Long
    Dim ctl As control
    Dim ctladd1 As control
    Dim ctladd2 As control
    Dim ctladd3 As control
    Dim ctladd4 As control
    Dim ctladd5 As control
    Dim PrevHeight As Long
    Dim firstValue As Range
    
    CurrentScale = GetSettings("Scale") / 100 * tmpScale
    
    PrevHeight = 0
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    End With
    
    Set ws = ActiveSheet
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
        Exit Sub
    Else
        
        For Each cell In InRng.Rows(1).Cells
             
            PrevHeight = Me.lblColumnsList.Height
            cIndex = cell.Column - InRng.Column + 1
            
            If IsError(cell) = False Then
            
                Set ctladd1 = Me.fraColumnsList.Controls.Add("Forms.CheckBox.1", "SQLchkCol_" & cIndex)
                With ctladd1
                    .Left = 4
                    .Top = (4 * CurrentScale) + PrevHeight
                    .Height = 18 * CurrentScale
                    .Width = 18 * CurrentScale
                    .Value = True
                    .Caption = ""
                    .ControlTipText = IIf(lng = 0, "Esporta", "Export")
                End With
                
                Set ctladd2 = Me.fraColumnsList.Controls.Add("Forms.TextBox.1", "SQLtxtXLCol_" & cIndex)
                With ctladd2
                    .Width = 100 * CurrentScale
                    .Height = 18 * CurrentScale
                    .Left = 8 + ctladd1.Width
                    .Top = ctladd1.Top
                    .visible = True
                    .Locked = True
                    .TabStop = False
                    .Enabled = True
                    .Value = IIf(cell.Value = "", "Column_" & cIndex, cell.Value)
                    .ControlTipText = .Value
                    .BackColor = &HE0E0E0
                    .ForeColor = &H404040
                End With
                     
                Set ctladd3 = Me.fraColumnsList.Controls.Add("Forms.TextBox.1", "SQLtxtSQLCol_" & cIndex)
                With ctladd3
                    .Width = 100 * CurrentScale
                    .Height = 18 * CurrentScale
                    .Left = 8 + ctladd1.Width + ctladd2.Width + 8
                    .Top = ctladd1.Top
                    .visible = True
                    .Locked = False
                End With
                     
                Set ctladd4 = Me.fraColumnsList.Controls.Add("Forms.ComboBox.1", "SQLcbxSQLType_" & cIndex)
                With ctladd4
                    .Width = 80 * CurrentScale
                    .Height = 18 * CurrentScale
                    .Left = 8 + ctladd1.Width + ctladd2.Width + 8 + ctladd3.Width + 8
                    .Top = ctladd1.Top
                    .List = DBMSTypes(Me.cbxDBMS.Text)
                    .Style = 2
                    If cell.Offset(1, 0) = "" Then
                        Set firstValue = Intersect(cell.End(xlDown), InRng)
                    Else
                        Set firstValue = cell.Offset(1, 0)
                    End If
                    Select Case VarType(firstValue)
                        Case 5 'NUMBER
                            .ListIndex = 0
                        Case 8 'STRING
                            .ListIndex = 1
                        Case 7 'DATE
                            .ListIndex = 2
                        Case Else
                            .ListIndex = 1
                    End Select
                End With
                                 
                Set ctladd5 = Me.fraColumnsList.Controls.Add("Forms.TextBox.1", "SQLtxtFLen_" & cIndex)
                With ctladd5
                    .Width = 70 * CurrentScale
                    .Height = 18 * CurrentScale
                    .Left = 8 + ctladd1.Width + ctladd2.Width + 8 + ctladd3.Width + 8 + ctladd4.Width + 8
                    .Top = ctladd1.Top
                    .TextAlign = 2
                    .Enabled = (ctladd4.ListIndex <> 2)
                    .visible = Me.chkCreateTable.Value
                    .MaxLength = 8
                    Select Case ctladd4.ListIndex
                        Case 1 'STRING
                            .Value = "50"
                        Case Else
                            .Value = ""
                    End Select
                End With
                            
            End If 'IsError(cell)
                
            PrevHeight = PrevHeight + ctladd1.Height + 8
            Me.lblColumnsList.Height = PrevHeight
            
        Next cell
            
    End If
    
    Set btnColl = CommonButtons(Me, True)
            
    For Each ctl In Me.fraColumnsList.Controls
        If ctl.Name Like "SQLtxtSQLCol_*" Then
            ctl.Value = Me.Controls("SQLtxtXLCol_" & Replace(ctl.Name, "SQLtxtSQLCol_", "")).Value
        End If
    Next ctl
        
    Exit Sub

Aborted:
    Call CanceledProcedure

End Sub

Private Sub cmdCleanSQL_Click()
    Dim ctl As control
    Dim ans As VbMsgBoxResult
    
    ans = MsgBox(IIf(lng = 0, "I nomi delle colonne evidenziati in rosso verranno corretti per aderire allo standard SQL. Proseguire?", _
                     "Column names highlighted in red will be corrected to comply with SQL standards. Continue?"), vbQuestion + vbYesNo)
    
    If ans = vbNo Then Exit Sub
    
    Me.txtTableName = SQLClean(Me.txtTableName, "table")
    
    For Each ctl In Me.fraColumnsList.Controls
        If ctl.Name Like "SQLtxtSQLCol_*" Then
            ctl.Value = SQLClean(ctl.Value, "column")
        End If
    Next ctl
    
End Sub

Private Sub chkAllNone_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraColumnsList.Controls
        If ctl.Name Like "SQLchk*" Then
            ctl.Value = Me.chkAllNone
        End If
    Next ctl
End Sub

Private Function DBMSTypes(DBMS As String) As Variant
    Dim arrTypes As Variant
    
    ReDim arrTypes(0 To 2)
    Select Case UCase(DBMS)
        Case "ORACLE"
            arrTypes(0) = "NUMBER"
            arrTypes(1) = "VARCHAR2"
            arrTypes(2) = "DATE"
        Case "MS SQL SERVER"
            arrTypes(0) = "float"
            arrTypes(1) = "varchar"
            arrTypes(2) = "smalldatetime"
        Case "MS ACCESS"
            arrTypes(0) = "float"
            arrTypes(1) = "varchar"
            arrTypes(2) = "datetime"
        Case Else
            arrTypes(0) = "FLOAT"
            arrTypes(1) = "VARCHAR"
            arrTypes(2) = "DATE"
    End Select

    DBMSTypes = arrTypes

End Function

Private Sub cmdReset_Click()
    Dim ans As Long
    
    ans = MsgBox(IIf(lng = 0, "Resettare i nomi delle colonne e della tabella alle impostazioni di default?", "Reset column and table names to default values?"), vbQuestion + vbYesNo)
    
    If ans = vbYes Then
        Call ReadColumns
        Me.txtTableName = SQLClean(ActiveSheet.Name, "table")
    End If
End Sub

Private Sub cmdSavePreset_Click()
    Dim vFilePath As Variant
    Dim overwrite As Long
    Dim f As Long
    Dim i As Long
    Dim maxIndex As Long
    Dim strPreset As String
    Const sep As String = "|"
    
    'Trovo l'indice massimo di colonna
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    
    If InRng Is Nothing Then
        MsgBox "Non ci sono colonne da esportare"
        Exit Sub
    Else
        maxIndex = InRng.Columns.Count
    End If
    
    Do
        If IsWindows = True And IsPortable = False Then
            vFilePath = Application.GetSaveAsFilename( _
                        InitialFileName:=SettingsPath & Me.txtTableName & ".cpr", _
                        FileFilter:="Columns preset (*.cpr), *.cpr", _
                        Title:="Esporta la definizione delle colonne")
        Else
            vFilePath = Application.GetSaveAsFilename(InitialFileName:=Me.txtTableName & ".cpr")
        End If
        
        '#' --exit if cancelled by user,
        If vFilePath = False Then Exit Sub
        
        '#' --ask user if he wants to overwrite
        If FileExists(vFilePath) Then
            overwrite = MsgBox("Sovrascrivere il file " & vFilePath & "?", vbExclamation + vbYesNo, "Conferma sovrascrittura")
                        
            If overwrite = vbNo Then
                vFilePath = ""
                AutoCalc True
                AutoCalc False
            End If
            
        End If
        
    Loop Until vFilePath <> ""
    
    f = FreeFile
    
    Open vFilePath For Output As #f
    
    strPreset = IIf(lng = 0, "Definizione delle colonne per la tabella: ", "Column definitions for table: ") & Me.txtTableName & vbNewLine
    
    For i = 1 To maxIndex
        On Error Resume Next
        strPreset = strPreset & i & sep
        strPreset = strPreset & Abs(CInt(Me.Controls("SQLchkCol_" & i))) & sep
        strPreset = strPreset & Me.Controls("SQLtxtSQLCol_" & i) & sep
        strPreset = strPreset & Me.Controls("SQLcbxSQLType_" & i).ListIndex & sep
        strPreset = strPreset & Me.Controls("SQLtxtFLen_" & i) & vbNewLine
        On Error GoTo 0
    Next i
    
    Print #f, strPreset
    
    Close f
    
    MsgBox IIf(lng = 0, "Esportazione di " & maxIndex & " definizioni di colonne per la tabella " & Me.txtTableName & " completata con successo", _
                        maxIndex & " column definitions for table " & Me.txtTableName & " were successfully exported"), vbInformation, _
                        IIf(lng = 0, "Esportazione completata", "Export complete")
    
End Sub
Private Sub cmdLoadPreset_Click()
    Dim vFilePath As Variant
    Dim f As Long
    Dim dataline As String
    Dim cArr As Variant
    Dim cIndex As Long
    Dim i As Long
    Const sep As String = "|"
    
    
    vFilePath = OpenDialog(SettingsPath, "Preset colonne, *.cpr", "Seleziona un preset")
        
    If vFilePath = False Then Exit Sub
    
    f = FreeFile
    
    Open vFilePath For Input As #f
    
    i = 1
    Do While Not EOF(f)
        Line Input #f, dataline
        
        'Nome della tabella
        If i = 1 Then
            Me.txtTableName = Trim(Replace(Replace(Replace(dataline, "Definizione delle colonne per la tabella: ", ""), "Column definitions for table: ", ""), vbNewLine, ""))
        End If
        
        On Error Resume Next
        cArr = Split(dataline, sep)
        cIndex = cArr(0)
        
        With Me.fraColumnsList
            .Controls("SQLchkCol_" & cIndex) = cArr(1)
            .Controls("SQLtxtSQLCol_" & cIndex) = cArr(2)
            .Controls("SQLcbxSQLType_" & cIndex).ListIndex = cArr(3)
            .Controls("SQLtxtFLen_" & cIndex) = cArr(4)
        End With
        On Error GoTo 0
                
        Erase cArr
        i = i + 1
    Loop
        
    Close f
    
    MsgBox IIf(lng = 0, "Importazione di " & cIndex & " definizioni di colonne nella tabella " & Me.txtTableName & " completata con successo", _
                        cIndex & " column definitions in table " & Me.txtTableName & " were successfully imported"), vbInformation, _
                        IIf(lng = 0, "Importazione completata", "Import complete")
    
End Sub



Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim i As Long
    Dim j As Long
    Dim tblName As String
    Dim DBMS As String
        
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
        
        .Hide
        
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    tblName = IIf(Me.txtTableName = "", "tbl_" & Int(Timer), Me.txtTableName)
    Set ws = ActiveSheet
    strSQL = ""
    DBMS = UCase(Me.cbxDBMS.Text)
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto effettuando la conversione... (" & ws.Name & ")"
        Call ShowProgressBar
        
        'Routine che genera il DROP TABLE
        If Me.chkDropTable = True And Me.chkDropTable.Enabled = True Then
            strSQL = strSQL & "DROP TABLE " & SQLClean(tblName, "table") & vbNewLine & ";" & vbNewLine
        End If
        
        'Routine che genera il TRUNCATE TABLE
        If Me.chkTruncateTable = True And Me.chkTruncateTable.Enabled = True Then
            strSQL = strSQL & "TRUNCATE TABLE " & SQLClean(tblName, "table") & vbNewLine & ";" & vbNewLine
        End If
        
        'Routine che genera il CREATE TABLE
        If Me.chkCreateTable = True And Me.chkCreateTable.Enabled = True Then
            strSQL = strSQL & IIf(lng = 0, "/* Verificare il tipo di dato corretto a seconda del DBMS utilizzato */", _
                                           "/* Please check the correct data type according to your DBMS */") & vbNewLine
            strSQL = strSQL & "CREATE TABLE " & SQLClean(tblName, "table") & " (" & vbNewLine
            For j = 1 To InRng.Rows(1).Cells.Count
                counter = counter + 1
                If Me.Controls("SQLchkCol_" & j).Value = True Then
                    strSQL = strSQL & "    " & SQLClean(Me.Controls("SQLtxtSQLCol_" & j).Value, "column") & " "
                    
                    Select Case Me.Controls("SQLcbxSQLType_" & j).ListIndex
                        Case 0, 1 'NUMBERS & STRINGS
                            strSQL = strSQL & Me.Controls("SQLcbxSQLType_" & j) & IIf(Me.Controls("SQLtxtFLen_" & j).Value = "", "", "(" & Me.Controls("SQLtxtFLen_" & j).Value & ")") & ", " & vbNewLine
                        Case 2 'DATES
                            strSQL = strSQL & Me.Controls("SQLcbxSQLType_" & j) & ", " & vbNewLine
                    End Select
                End If
            Next j
            
            strSQL = Mid(strSQL, 1, Len(strSQL) - 4) & vbNewLine & ")" & vbNewLine & ";" & vbNewLine
        Else
            counter = InRng.Rows(1).Cells.Count
        End If
        
        'Routine che genera gli INSERT TABLE
        For i = 2 To InRng.Rows.Count
            
            strSQL = strSQL & "INSERT INTO " & SQLClean(tblName, "table")
            strSQL = strSQL & " ("
            For j = 1 To InRng.Rows(1).Cells.Count
                If Me.Controls("SQLchkCol_" & j).Value = True Then
                    strSQL = strSQL & SQLClean(Me.Controls("SQLtxtSQLCol_" & j).Value, "column") & ", "
                End If
            Next j
            strSQL = Mid(strSQL, 1, Len(strSQL) - 2) & ")" & vbNewLine
            strSQL = strSQL & "    VALUES ("
                        
            For j = 1 To InRng.Columns.Count
            
                '#' Aumento di 1 il contatore
                counter = counter + 1
                                    
                If Me.Controls("SQLchkCol_" & j).Value = True Then
                    Select Case Me.Controls("SQLcbxSQLType_" & j).ListIndex
                        Case 0 'NUMBERS
                            strSQL = strSQL & Replace(InRng(i, j).Value, ",", ".") & ", "
                        Case 1 'STRINGS
                            strSQL = strSQL & "'" & Replace(InRng(i, j).Value, "'", "''") & "', "
                        Case 2 'DATES
                            Select Case DBMS
                                Case "MS SQL SERVER"
                                    strSQL = strSQL & "'" & Format(InRng(i, j).Value, "mm/dd/yyyy") & "', "
                                Case "MS ACCESS"
                                    strSQL = strSQL & "#" & Format(InRng(i, j).Value, "mm/dd/yyyy") & "#, "
                                Case Else
                                    strSQL = strSQL & "DATE '" & Format(InRng(i, j).Value, "yyyy-mm-dd") & "', "
                            End Select
                    End Select
                End If
                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next j
            
            strSQL = Mid(strSQL, 1, Len(strSQL) - 2) & ");" & vbNewLine
        Next i
        
        Select Case DBMS
            Case "MS SQL SERVER", "MS ACCESS"
                'Non aggiungo nulla
            Case Else
                strSQL = strSQL & vbNewLine & "COMMIT;"
        End Select
    End If
    
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    frmGenerateSQLOutput.Show vbModeless
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmGenerateSQLOutput"
Attribute VB_Base = "0{8BA479EE-E851-4E7D-9822-32795CE8CD9B}{FD8C66E2-6368-4F3D-816E-DD4291254AFF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Me.txtSQL.Value = strSQL
End Sub

Private Sub cmdCopy_Click()
    With New MSForms.DataObject
        .SetText Me.txtSQL.Text
        .PutInClipboard
    End With
    
    MsgBox IIf(lng = 0, "Codice SQL copiato negli appunti", _
                      "SQL code has been copied to the clipboard"), vbInformation, _
                      IIf(lng = 0, "Codice copiato", "Code copied")
    
    Call cmdExit_Click
End Sub

Private Sub cmdExit_Click()
    Unload Me
End Sub

Attribute VB_Name = "frmGroupRowsColumns"
Attribute VB_Base = "0{3AEFD881-8034-430A-B686-318B3464B23C}{D57A7497-AA31-4DCB-84B3-040ADFFA55DD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    On Error Resume Next
    Me.refRange = MergeAreas(Selection).address
    On Error GoTo 0
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub


Private Sub optCols_Change()
    If Me.optCols = True Then
        Me.chkHide.Caption = Replace(Me.chkHide.Caption, "righe", "colonne")
    Else
        Me.chkHide.Caption = Replace(Me.chkHide.Caption, "colonne", "righe")
    End If
End Sub
Private Sub optGroup_Click()
    Me.optRemove = False
    Me.optRemove.visible = False
    Me.optExpand = False
    Me.optExpand.visible = False
    Me.chkHide.visible = True
End Sub

Private Sub optUngroup_Click()
    Me.optRemove = False
    Me.optRemove.visible = True
    Me.optExpand = True
    Me.optExpand.visible = True
    Me.chkHide.visible = False
End Sub

Private Sub optRows_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optCols_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optGroup_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optUngroup_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optExpand_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optRemove_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim Subarea As Range
    Dim j As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(Me.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
    
        .Hide
        
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
                    
        
    
        On Error GoTo Aborted
        
        For Each ws In ActiveWindow.SelectedSheets
        
            ws.Activate
            
            If .optRows Then
            
                Set InRng = MergeAreas(ws.Range(Replace(.refRange, ";", ",")).EntireRow)
                
                If .optGroup Then
                    For Each Subarea In InRng.Areas
                        Subarea.Rows.Group
                        If .chkHide Then
                            Subarea.Rows(1).ShowDetail = False
                        End If
                    Next Subarea
                    
                ElseIf .optUngroup Then
                    On Error Resume Next
                    For Each Subarea In InRng.Areas
                        For j = 1 To Subarea.Rows.Count
                            If Subarea.Rows(j).ShowDetail = False Then
                                Subarea.Rows(j).ShowDetail = True
                            End If
                        Next j
                        If .optRemove Then
                            Subarea.Rows.Ungroup
                        End If
                    Next Subarea
                End If
    
            ElseIf .optCols Then
                
                Set InRng = MergeAreas(ws.Range(Replace(.refRange, ";", ",")).EntireColumn)
                            
                If .optGroup Then
                    For Each Subarea In InRng.Areas
                        Subarea.Columns.Group
                        If .chkHide Then
                            Subarea.Columns(1).ShowDetail = False
                        End If
                    Next Subarea
                    
                ElseIf .optUngroup Then
                    On Error Resume Next
                    For Each Subarea In InRng.Areas
                        For j = 1 To Subarea.Columns.Count
                            If Subarea.Columns(j).ShowDetail = False Then
                                Subarea.Columns(j).ShowDetail = True
                            End If
                        Next j
                        If .optRemove Then
                            Subarea.Columns.Ungroup
                        End If
                    Next Subarea
                End If
            
            End If
        
        Next ws
        
    End With

    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
End Sub




Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmHyperLinks"
Attribute VB_Base = "0{8545F266-801D-407C-94E2-77CDAE497C8A}{4299D3C9-258C-435D-A529-1014F8C53F0C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim wCount As Long, eCount As Long, fCount As Long, ndCount As Long, skCount As Long, nCount As Long, othCount As Long


Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub optRemoveHL_Change()
    Me.optDetected.Enabled = Not Me.optRemoveHL
    Me.optAll.Enabled = Not Me.optRemoveHL
End Sub

Private Sub optGenerateHL_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
Private Sub optRemoveHL_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optDetected_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optAll_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Function DetectHL(r As Range) As String
    Dim nome As Name
    
    If r.HyperLinks.Count = 0 Then
        If InStr(1, r.Value, "http://") = 1 Or _
           InStr(1, r.Value, "https://") = 1 Or _
           InStr(1, r.Value, "ftp://") = 1 Or _
           InStr(1, r.Value, "ftp.") = 1 Or _
           InStr(1, r.Value, "www") = 1 Then
            DetectHL = "web"
        ElseIf IsEmailValid(r.Value) = True Then
            DetectHL = "email"
        ElseIf InStr(1, r.Value, ":\") = 2 Or _
           InStr(1, r.Value, "\\") = 1 Then
            DetectHL = "file"
        Else
            For Each nome In ActiveWorkbook.Names
                If r.Value = nome.Name Then
                    DetectHL = "Name"
                    Exit For
                End If
            Next nome
            
            If DetectHL = "" Then DetectHL = "ND"
        End If
    Else
        DetectHL = "Skip"
    End If

End Function


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim FinalReport As String
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    If Me.tglBatch = False Then '#' NO BATCH
    
        Call backup_create_new
        
        Set ws = ActiveSheet
            
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If Me.chkIgnoreHidden = True Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
        Else
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto creando/modificando i collegamenti... (" & ws.Name & ")"
            Call ShowProgressBar
            
            For Each cell In InRng.Cells
                
                '#' Aumento di 1 il contatore
                counter = counter + 1
            
                Call elaboracella(cell)
                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next cell
            
        End If
    
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto creando/modificando i collegamenti... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto creando/modificando i collegamenti... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    
                    If Not InRng Is Nothing Then
                        
                        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True

NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    '#' Report finale
    If Me.optGenerateHL Then
        If lng = 0 Then
            If wCount + fCount + eCount + skCount + nCount + othCount = 0 Then
                FinalReport = "Non sono stati rilevati collegamenti ipertestuali nell'intervallo selezionato"
            Else
                FinalReport = "CREAZIONE COLLEGAMENTI IPERTESTUALI:" & vbNewLine & vbNewLine
                FinalReport = FinalReport & "Collegamenti a siti web: " & vbTab & wCount & vbNewLine
                FinalReport = FinalReport & "Indirizzi email: " & vbTab & vbTab & eCount & vbNewLine
                FinalReport = FinalReport & "Collegamenti a file/cartelle: " & vbTab & fCount & vbNewLine
                FinalReport = FinalReport & "Collegamenti a range: " & vbTab & nCount & vbNewLine
                FinalReport = FinalReport & "Altri collegamenti: " & vbTab & vbTab & othCount & vbNewLine
                FinalReport = FinalReport & "Collegamenti non rilevati: " & vbTab & ndCount & vbNewLine
                FinalReport = FinalReport & "Collegamenti gi|fffd| esistenti: " & vbTab & skCount
            End If
            MsgBox FinalReport, vbInformation, "Rapporto finale"
        Else
            If wCount + fCount + eCount + skCount + nCount + othCount = 0 Then
                FinalReport = "No hyperlinks were detected in the selected range"
            Else
                FinalReport = "HYPERLINKS CREATION:" & vbNewLine & vbNewLine
                FinalReport = FinalReport & "Website links: " & vbTab & wCount & vbNewLine
                FinalReport = FinalReport & "Email addresses: " & vbTab & eCount & vbNewLine
                FinalReport = FinalReport & "File/folder links: " & vbTab & fCount & vbNewLine
                FinalReport = FinalReport & "Range links: " & vbTab & vbTab & nCount & vbNewLine
                FinalReport = FinalReport & "Other links: " & vbTab & vbTab & othCount & vbNewLine
                FinalReport = FinalReport & "Undetected links: " & ndCount & vbNewLine
                FinalReport = FinalReport & "Pre-existent links: " & vbTab & skCount
            End If
            MsgBox FinalReport, vbInformation, "Summary report"
        End If
    End If
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub elaboracella(cell As Range)
    Dim strAddress As String
    Dim tmpRng As Range
    
    If Me.optGenerateHL Then
        
        If Not IsEmpty(cell) And Not IsError(cell) Then
            Select Case DetectHL(cell)
                Case "web"
                    If InStr(1, cell, "www") = 1 Then strAddress = "http://" & cell.Value Else strAddress = cell.Value
                    ActiveSheet.HyperLinks.Add anchor:=cell, address:=strAddress, TextToDisplay:=cell.Value
                    wCount = wCount + 1
                Case "file"
                    ActiveSheet.HyperLinks.Add anchor:=cell, address:=cell.Value, TextToDisplay:=cell.Value
                    fCount = fCount + 1
                Case "email"
                    ActiveSheet.HyperLinks.Add anchor:=cell, address:="mailto:" & cell.Value, TextToDisplay:=cell.Value
                    eCount = eCount + 1
                Case "Name"
                    On Error Resume Next
                    Set tmpRng = Range(cell.Value)
                    If Err.Number = 0 Then ActiveSheet.HyperLinks.Add anchor:=cell, address:="", SubAddress:=cell.Value
                    On Error GoTo 0
                    nCount = nCount + 1
                Case "ND"
                    If Me.optAll = True Then
                        ActiveSheet.HyperLinks.Add anchor:=cell, address:=cell.Value
                        othCount = othCount + 1
                    Else
                        ndCount = ndCount + 1
                    End If
                Case "Skip"
                    skCount = skCount + 1
            End Select
        End If
        
    ElseIf Me.optRemoveHL = True Then
        
        cell.HyperLinks.Delete
        
    End If

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmImportExportCode"
Attribute VB_Base = "0{E47A4DFB-A0B5-4BD6-8BD0-4363ADCD9349}{D6413201-2AF1-479A-AB41-EA5DE94D3D5D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim NoAccess As Boolean

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    If lng > 0 Then
        Call TranslateForm(Me)
        With Me.cbxOverwrite
            .AddItem "Ask"
            .AddItem "Always"
            .AddItem "Never"
            .ListIndex = 0
        End With
    Else
        With Me.cbxOverwrite
            .AddItem "Chiedi"
            .AddItem "Sempre"
            .AddItem "Mai"
            .ListIndex = 0
        End With
    End If
    
    Call SaveOptions(Me)
    
    If ActiveWorkbook.path = "" Then
        Me.txtFolder = DesktopPath
    Else
        Me.txtFolder = ValidateFolder(ActiveWorkbook.path)
    End If
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    'Popolo le combobox
    Call ListProjects
        
    If NoAccess = True Then
        Me.cmdOK.Enabled = False
    Else
        Me.cmdOK.Enabled = True
    End If
    
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    If Me.txtFolder = "" Then Me.txtFolder = ValidateFolder(SettingsPath & pSep & "VBA")
    
End Sub

Private Sub UserForm_Activate()
    If NoAccess = True Then
        Call cmdCancel_Click
    End If
End Sub

Private Sub chkAll_change()
    Me.chkModules.Enabled = Not Me.chkAll
    Me.chkForms.Enabled = Not Me.chkAll
    Me.chkClasses.Enabled = Not Me.chkAll
    If Me.chkAll = True Then
        Me.chkModules = True
        Me.chkForms = True
        Me.chkClasses = True
    End If
End Sub

Private Sub ListProjects()
'Popolo le combo dei progetti aperti
    
    Dim wb As Workbook
    Dim cProject As Object
    Dim pColl As New Collection
    Dim personalname As String
    Dim ans As VbMsgBoxResult
    
    With Me.cbxImport
        'Inizio scorrendo i workbook aperti
        On Error Resume Next
        For Each wb In Workbooks
            If wb.VBProject.Protection = 0 Then
                If UCase(wb.Name) Like "PERSONAL.XLS*" Then
                    personalname = wb.Name
                Else
                    pColl.Add wb.Name, CStr(wb.Name)
                End If
            End If
        Next wb
        If Err.Number <> 0 Then
            ans = MsgBox("E' necessario consentire l'accesso al modello oggetti dei progetti VBA." & vbNewLine & vbNewLine & _
                    "Puoi attivarlo dal menu Opzioni -> Centro protezione -> Impostazioni macro" & vbNewLine & vbNewLine & _
                    "Vuoi aprire adesso la maschera delle opzioni? Sar|fffd| poi necessario rieseguire lo strumento", vbInformation + vbYesNo)
            If ans = vbYes Then
                Application.CommandBars.ExecuteMso ("MacroSecurity")
            End If
            NoAccess = True
            Exit Sub
        End If
        On Error GoTo 0
        
        'Proseguo con i progetti (non necessariamente appartenenti a una cartella della collection Workbooks)
        For Each cProject In Application.VBE.VBProjects
            On Error Resume Next
            If cProject.Protection = 0 And FullPathToWBName(cProject.FileName) <> personalname Then
                pColl.Add FullPathToWBName(cProject.FileName), CStr(FullPathToWBName(cProject.FileName))
            End If
            On Error GoTo 0
        Next cProject
        
        'Aggiungo alla fine cartella macro personale
        pColl.Add personalname, CStr(personalname)
                                
        'Rimuovo personal e funcres
        On Error Resume Next
        pColl.Remove "FUNCRES.XLAM"
        On Error GoTo 0
        
        .List = CollToArray(pColl)
        Me.cbxExport.List = .List
        Me.cbxIndex.List = .List
        Me.cbxDeleteEmpty.List = .List
        
        .ListIndex = 0
        Me.cbxExport.ListIndex = 0
        Me.cbxIndex.ListIndex = 0
        Me.cbxDeleteEmpty.ListIndex = 0
    End With

End Sub
Private Sub optImport_Change()
    Me.cbxImport.Enabled = Me.optImport
    Me.cbxExport.Enabled = Me.optExport
    Me.cbxIndex.Enabled = Me.optIndex
    Me.cbxDeleteEmpty.Enabled = Me.optDeleteEmpty
    Me.txtFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.cmdSelectFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.chkSubFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.chkNotEmpty.Enabled = CBool(Me.optExport + Me.optIndex)
End Sub

Private Sub optIndex_Change()
    Me.cbxImport.Enabled = Me.optImport
    Me.cbxExport.Enabled = Me.optExport
    Me.cbxIndex.Enabled = Me.optIndex
    Me.cbxDeleteEmpty.Enabled = Me.optDeleteEmpty
    Me.txtFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.cmdSelectFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.chkSubFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.chkNotEmpty.Enabled = CBool(Me.optExport + Me.optIndex)
End Sub

Private Sub optExport_Change()
    Me.cbxImport.Enabled = Me.optImport
    Me.cbxExport.Enabled = Me.optExport
    Me.cbxIndex.Enabled = Me.optIndex
    Me.cbxDeleteEmpty.Enabled = Me.optDeleteEmpty
    Me.txtFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.cmdSelectFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.chkDelete.Enabled = Me.optExport
    Me.lblOverwrite.Enabled = Me.optExport
    Me.cbxOverwrite.Enabled = Me.optExport
    Me.chkSubFolder.Enabled = CBool(Me.optExport + Me.optImport)
    Me.chkNotEmpty.Enabled = CBool(Me.optExport + Me.optIndex)
End Sub

Private Sub txtFolder_Change()
    Me.txtFolder.ControlTipText = Me.txtFolder.Text
End Sub

Private Sub cmdSelectFolder_Click()
    Me.txtFolder.Text = FolderPicker(Me.txtFolder.Text, "Seleziona la cartella " & IIf(Me.optImport, "con i file .bas da importare", "nella quale esportare i moduli del file attivo"))
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim BasePath As String
    Dim FileName As String
    Dim FileCount As Long
    Dim FileArray As Variant
    Dim wbname As String
    Dim wb As Workbook
    Dim aWb As Workbook
    Dim cmp As Object
    Dim bExport As Boolean
    Dim bImport As Boolean
    Dim bIndex As Boolean
    Dim bDelete As Boolean
    Dim ow As Long
    Dim mCount As Long
    Dim fMod As New Collection
    Dim oFolder As Long
    Dim strMB As String
    Dim i As Long
    Dim f As Long
    Dim strMname As String
    Dim dataline As String
    Dim IndexWS As Worksheet
    Dim cRow As Long
    Dim cType As String
    Dim emptyLines As Long
    Dim commentLines As Long
    Dim ConfirmDelete As VbMsgBoxResult
    
    Me.Hide
    
    
    On Error GoTo Aborted
    
    Call AutoCalc(False)
    
    Set wb = ActiveWorkbook
    
    If Me.optImport = True Then
        wbname = Me.cbxImport.Text
    ElseIf Me.optExport = True Then
        wbname = Me.cbxExport.Text
    ElseIf Me.optIndex = True Then
        wbname = Me.cbxIndex.Text
    ElseIf Me.optDeleteEmpty = True Then
        wbname = Me.cbxDeleteEmpty.Text
    End If
    
    
    '#' Stabiliamo qual |fffd| la cartella di lavoro su cui operare
    Set aWb = Workbooks(wbname)
    
    If Me.optExport Then '#' ESPORTAZIONE
        
        If aWb.VBProject.Protection = 1 Then
            MsgBox TranslateCnst("ProtectedVBA"), vbExclamation
            Exit Sub
        End If
        
        If Me.chkSubFolder Then
            On Error Resume Next
            MkDir ValidateFolder(ValidateFolder(Me.txtFolder) & "[Moduli_VBA] " & aWb.Name)
            BasePath = ValidateFolder(ValidateFolder(Me.txtFolder) & "[Moduli_VBA] " & aWb.Name)
            On Error GoTo Aborted
        Else
            BasePath = ValidateFolder(Me.txtFolder)
        End If
    
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = aWb.VBProject.VBComponents.Count
        UProgress.SetDescription "Sto esportando i moduli di " & aWb.Name
        Call ShowProgressBar
        
        mCount = 0
        For Each cmp In aWb.VBProject.VBComponents
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            'Inizializzo a True la variabile booleana
            bExport = True
            
            'Calcolo il numero di righe
            emptyLines = 0
            commentLines = 0
            With cmp.CodeModule
                
                For i = 1 To .CountOfLines
                    If Trim(.Lines(i, 1)) = "" Then
                        emptyLines = emptyLines + 1
                    ElseIf InStr(1, Trim(.Lines(i, 1)), "'") = 1 Then
                        commentLines = commentLines + 1
                    End If
                Next i
                                                            
                If .CountOfLines - emptyLines = 0 And Me.chkNotEmpty = True Then bExport = False
                                                            
            End With
            
            FileName = cmp.Name
    
            '#' Concatenate the correct filename for export.
            Select Case cmp.Type
                Case 1                                                  '#' Modulo standard
                    FileName = FileName & ".bas"
                    If Me.chkModules = False Then bExport = False
                Case 2                                                  '#' Modulo di classe
                    FileName = FileName & ".cls"
                    If Me.chkClasses = False Then bExport = False
                Case 3                                                  '#' Userform
                    FileName = FileName & ".frm"
                    If Me.chkForms = False Then bExport = False
                Case 100                                                '#' Foglio di lavoro
                    bExport = False
            End Select
            
            If bExport = True Then
                '#'  Check if file exists
                If Dir(BasePath & FileName) <> "" Then
                    If Me.cbxOverwrite.ListIndex = 2 Then bExport = False   '#' Si |fffd| scelto di non sovrascrivere mai
                    If Me.cbxOverwrite.ListIndex = 0 Then                   '#' Si |fffd| scelto di chiedere sempre se sovrascrivere
                        ow = MsgBox("Vuoi sovrascrivere il file " & FileName & "?", vbQuestion + vbYesNo, "File gi|fffd| esistente")
                        If ow = vbNo Then bExport = False
                    End If
                End If
                                
                If bExport = True Then
                    '#'  Export the component to a text file.
                    On Error Resume Next
                    cmp.Export BasePath & FileName
                    If Err.Number = 0 Then mCount = mCount + 1
                    Err.Clear
                    On Error GoTo Aborted
                    
                    '#'  remove it from the project if you want
                    If Me.chkDelete Then aWb.VBProject.VBComponents.Remove cmp
                End If
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
       
        Next cmp
        
        oFolder = MsgBox(IIf(lng = 0, "L'esportazione di " & mCount & " moduli |fffd| avvenuta con successo nella cartella: " & _
                            vbNewLine & vbNewLine & _
                            BasePath & _
                            vbNewLine & vbNewLine & _
                            "Vuoi aprire la cartella in esplora risorse?", _
                            "Export of " & mCount & " modules completed successfully to folder: " & _
                            vbNewLine & vbNewLine & _
                            BasePath & _
                            vbNewLine & vbNewLine & _
                            "Would you like to open this folder in Explorer?"), _
                            vbInformation + vbYesNo, _
                            IIf(lng = 0, "Esportazione completata", "Export complete"))
        If oFolder = vbYes Then Call OpenFolder(BasePath)
        
    ElseIf Me.optIndex = True Then '#' Crea un foglio indice
        
        On Error Resume Next
        Set IndexWS = wb.Worksheets("ESK_ModuleIndex")
        If Err.Number <> 0 Then
            wb.Worksheets.Add Before:=wb.Worksheets(1)
            Set IndexWS = wb.Worksheets(1)
            IndexWS.Name = "ESK_ModuleIndex"
        Else
            IndexWS.Cells.Clear
        End If
                
        cRow = 2
        
        With IndexWS
            
            .Activate
            .Cells.Clear
            
            If lng = 0 Then
                .Range("A1") = "Nome"
                .Range("B1") = "Tipo"
                .Range("C1") = "Numero righe di codice"
                .Range("D1") = "Numero righe vuote"
                .Range("E1") = "Numero righe di commento"
                .Range("F1") = "Numero righe totali"
            Else
                .Range("A1") = "Name"
                .Range("B1") = "Type"
                .Range("C1") = "N. of code lines"
                .Range("D1") = "N. of blank lines"
                .Range("E1") = "N. of comment lines"
                .Range("F1") = "Total N. of lines"
            End If
        
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = aWb.VBProject.VBComponents.Count
            UProgress.SetDescription "Sto creando un indice dei moduli di " & aWb.Name
            Call ShowProgressBar
            
            For Each cmp In aWb.VBProject.VBComponents
                
                '#' Aumento di 1 il contatore
                counter = counter + 1
                
                bIndex = True
                
                '#' Verifico se il modulo |fffd| vuoto
                If cmp.CodeModule.CountOfLines = 0 And Me.chkNotEmpty = True Then bIndex = False
                
                'Calcolo il numero di righe
                emptyLines = 0
                commentLines = 0
                With cmp.CodeModule
                    
                    For i = 1 To .CountOfLines
                        If Trim(.Lines(i, 1)) = "" Then
                            emptyLines = emptyLines + 1
                        ElseIf InStr(1, Trim(.Lines(i, 1)), "'") = 1 Then
                            commentLines = commentLines + 1
                        End If
                    Next i
                                                                
                    If .CountOfLines - emptyLines = 0 And Me.chkNotEmpty = True Then bIndex = False
                                                                
                End With
                
                If cmp.Type = 1 And Me.chkModules = False Then bIndex = False
                If (cmp.Type = 2 Or cmp.Type = 100) And Me.chkClasses = False Then bIndex = False
                If cmp.Type = 3 And Me.chkForms = False Then bIndex = False
                
                If bIndex = True Then
                    'Scrivo il nome del modulo
                    .Range("A" & cRow) = cmp.Name
                    
                    'Scrivo il tipo di modulo
                    Select Case cmp.Type
                        Case 1                                                  '#' Modulo standard
                            cType = "Modulo standard"
                        Case 2                                                  '#' Modulo di classe
                            cType = "Modulo di classe"
                        Case 3                                                  '#' Userform
                            cType = "Userform"
                        Case 100                                                '#' Foglio di lavoro
                            cType = "Modulo foglio o cartella di lavoro"
                    End Select
                    .Range("B" & cRow) = cType
                    
                    'Scrivo il numero di righe
                    .Range("C" & cRow) = cmp.CodeModule.CountOfLines - emptyLines - commentLines
                    .Range("D" & cRow) = emptyLines
                    .Range("E" & cRow) = commentLines
                    .Range("F" & cRow) = cmp.CodeModule.CountOfLines
                                        
                    cRow = cRow + 1
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
       
            Next cmp
            
            If cRow > 2 Then 'Almeno una riga |fffd| stata scritta
            
                .UsedRange.EntireColumn.AutoFit
            
                With .ListObjects.Add(xlSrcRange, Range("$A$3").CurrentRegion, , xlYes)
                    .Name = "IndiceModuli"
                    .TableStyle = "TableStyleMedium21"
                    .DataBodyRange.EntireRow.RowHeight = 1.75 * IndexWS.StandardHeight
                    .DataBodyRange.VerticalAlignment = xlVAlignCenter
                    .DataBodyRange.Columns(2).HorizontalAlignment = xlCenter
                    .Range.Sort _
                        key1:=.ListColumns(2), order1:=xlAscending, _
                        header:=xlYes, OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, _
                        key2:=.ListColumns(1), order2:=xlAscending ', _
                        header:=xlYes, OrderCustom:=2, MatchCase:=False, Orientation:=xlTopToBottom
    
                End With
            Else
                Application.DisplayAlerts = False
                .Delete
                Application.DisplayAlerts = True
                MsgBox IIf(lng = 0, "Non sono stati trovati moduli non vuoti nel file selezionato", _
                                "No modules were found in your selected file"), vbInformation
            End If
        End With
        
    ElseIf Me.optDeleteEmpty = True Then '#' Elimina i moduli vuoti
    
        If aWb.VBProject.Protection = 1 Then
            MsgBox TranslateCnst("ProtectedVBA"), vbExclamation
            Exit Sub
        End If
        
        '#'  Ask for confirmation
        ConfirmDelete = MsgBox(IIf(lng = 0, "Procedere con l'eliminazione dei moduli vuoti dal workbook " & aWb.Name & "?", _
                                          "Delete empty modules from workbook " & aWb.Name & "?"), _
                                          vbQuestion + vbYesNo, _
                                          IIf(lng = 0, "Conferma eliminazione moduli vuoti", "Delete empty modules"))
        If ConfirmDelete = vbNo Then GoTo Aborted
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = aWb.VBProject.VBComponents.Count
        UProgress.SetDescription "Sto eliminando i moduli vuoti di " & aWb.Name
        Call ShowProgressBar
        
        mCount = 0
        For Each cmp In aWb.VBProject.VBComponents
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            'Inizializzo a True la variabile booleana
            bDelete = True
            
            'Calcolo il numero di righe
            emptyLines = 0
            commentLines = 0
            With cmp.CodeModule
                
                For i = 1 To .CountOfLines
                    If Trim(.Lines(i, 1)) = "" Then
                        emptyLines = emptyLines + 1
                    ElseIf InStr(1, Trim(.Lines(i, 1)), "'") = 1 Then
                        commentLines = commentLines + 1
                    End If
                Next i
                                                            
                If .CountOfLines - emptyLines > 0 Then bDelete = False
                                                            
            End With
            
            FileName = cmp.Name
    
            '#' Filtro per tipologia
            Select Case cmp.Type
                Case 1                                                  '#' Modulo standard
                    If Me.chkModules = False Then bDelete = False
                Case 2                                                  '#' Modulo di classe
                    If Me.chkClasses = False Then bDelete = False
                Case 3                                                  '#' Userform
                    If Me.chkForms = False Then bDelete = False
                Case 100                                                '#' Foglio di lavoro
                    bDelete = False
            End Select
            
            '#' Elimino i moduli vuoti
            If bDelete = True Then
                aWb.VBProject.VBComponents.Remove cmp
                mCount = mCount + 1
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
       
        Next cmp
        
        MsgBox IIf(lng = 0, "Eliminazione di " & mCount & " moduli vuoti completata", _
                          mCount & " empty modules were deleted"), vbInformation
    
    Else '#' IMPORTAZIONE
            
        BasePath = ValidateFolder(Me.txtFolder)
                        
        ReDim FileArray(1 To 1)
        
        'Conto i file presenti
        FileName = Dir(BasePath)
        Do While FileName <> ""
           FileCount = FileCount + 1
           ReDim Preserve FileArray(1 To FileCount)
           FileArray(FileCount) = FileName
           FileName = Dir
        Loop
        
        mCount = 0
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = FileCount
        UProgress.SetDescription "Sto importando i moduli in " & aWb.Name
        Call ShowProgressBar
        
        For i = 1 To UBound(FileArray)
            
            FileName = FileArray(i)
            
            '#' Aumento di 1 il contatore
            counter = counter + 1
            
            bImport = True
            Select Case Right(FileName, 4)
                Case ".bas"                                             '#' Modulo standard
                    If Me.chkModules = False Then
                        bImport = False
                    End If
                Case ".cls"                                             '#' Modulo di classe
                    If Me.chkClasses = False Then
                        bImport = False
                    End If
                Case ".frm"                                             '#' Userform
                    If Me.chkForms = False Then
                        bImport = False
                    End If
                Case Else                                               '#' Altro file
                    bImport = False
            End Select
            
            If bImport = True Then
                '#' Verify (for standard and class modules) if a module with the same name exists
                Select Case Right(FileName, 4)
                    Case ".bas", ".cls"                                             '#' Modulo standard
                        f = FreeFile
                        Open BasePath & FileName For Input As #f
                            Do While Not EOF(f)
                                Line Input #f, dataline
                                If InStr(1, dataline, "Attribute VB_Name") = 1 Then
                                    strMname = Trim(Replace(Replace(Replace(dataline, "Attribute VB_Name", ""), "=", ""), """", ""))
                                    For Each cmp In aWb.VBProject.VBComponents
                                        If cmp.Name = strMname Then
                                            bImport = False
                                            fMod.Add FileName, CStr(FileName)
                                        End If
                                    Next cmp
                                    Exit Do
                                End If
                            Loop
                        Close #f
                End Select
            
                If bImport = True Then
                    On Error Resume Next
                    aWb.VBProject.VBComponents.Import BasePath & FileName
                    If Err.Number = 0 Then mCount = mCount + 1 Else fMod.Add FileName, CStr(FileName)
                    Err.Clear
                    On Error GoTo Aborted
                End If
            End If

            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
       
        Next i
        
        strMB = "Sono stati importati con successo n. " & mCount & " moduli nel file " & aWb.Name
        If fMod.Count > 0 Then
            strMB = strMB & vbNewLine & vbNewLine & "E' fallita l'importazione dei seguenti moduli:" & vbNewLine
            For i = 1 To fMod.Count
                strMB = strMB & vbNewLine & fMod(i)
            Next i
            strMB = strMB & vbNewLine & vbNewLine & "Verificare che non esistano gi|fffd| moduli con lo stesso nome nel file"
        End If
        
        MsgBox strMB, vbInformation, "Esito importazione moduli"
        
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmImportMultipleFiles"
Attribute VB_Base = "0{840BBD27-4349-4977-9511-6D45B0EB731B}{38D20F31-A0A1-4587-A2B7-E6235BA1C847}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
        
    With Me.cbxNameFilter
        If lng = 0 Then
            .AddItem "-- Scegli un'opzione --"
            .AddItem "Il nome del foglio contiene:"
            .AddItem "Il nome del foglio |fffd| esattamente:"
            .AddItem "L'indice del foglio |fffd|: (separare i numeri con ,)"
        Else
            .AddItem "-- Choose an option --"
            .AddItem "Sheet name contains:"
            .AddItem "Sheet name is exactly:"
            .AddItem "Sheet index is: (separate numbers with ,)"
        End If
        .ListIndex = 0
    End With
    
    With Me.cbxProtected
        If lng = 0 Then
            .AddItem "Salta"
            .AddItem "Chiedi password"
            .AddItem "Usa sempre questa password:"
        Else
            .AddItem "Skip"
            .AddItem "Ask for password"
            .AddItem "Always use this password:"
        End If
        .ListIndex = 0
    End With
    
    Call SaveOptions(Me)
    
    Me.lbxImportFiles.RowSource = ""
    Me.lbxImportFiles.Clear
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
        
    Call GoodToGo(Me)

    Me.tglAdvanced = False
    
    DisableEvents = True
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    DisableEvents = False
    
End Sub


Private Sub optAppend_Change()
    Dim ctl As control
    
    Me.fraAppend.Enabled = Me.optAppend
    For Each ctl In Me.fraAppend.Controls
        ctl.Enabled = Me.optAppend
    Next ctl
    
    'Correzione per la casellina delle righe di separazione
    If Me.optAppend = True Then
        Me.txtSepRows.Enabled = Me.chkSepRows
        Me.spbSepRows.Enabled = Me.chkSepRows
    End If
End Sub

Private Sub optCustomOrder_Click()
    If DisableEvents = True Then Exit Sub
    
    If Me.optCustomOrder = True Then
        MsgBox IIf(lng = 0, "In questa modalit|fffd| verranno esaminate le intestazioni nella prima riga di ciascun foglio, per incolonnare correttamente i dati. " & vbNewLine & vbNewLine & _
                            "Cosa avviene in caso di difformit|fffd|:" & vbNewLine & _
                            "- Colonne non presenti nei file/fogli precedenti: saranno aggiunte in coda all'elenco delle colonne" & vbNewLine & _
                            "- Colonne senza intestazione nella prima riga: saranno ignorate", _
                            "In this mode, the headings in the first row of each sheet will be examined, to correctly append your data." & vbNewLine & _
                            "What happens in case of discrepancy:" & vbNewLine & _
                            "- Columns not present in previous files/sheets will be added at the end of the columns list" & vbNewLine & _
                            "- Columns with no header in first row will be ignored"), vbInformation
    End If
End Sub

Private Sub chkSepRows_Change()
    Me.txtSepRows.Enabled = Me.chkSepRows
    Me.spbSepRows.Enabled = Me.chkSepRows
End Sub

Private Sub spbFirstRow_SpinDown()
    Me.txtFirstRow = Me.spbFirstRow
End Sub

Private Sub spbFirstRow_SpinUp()
    Me.txtFirstRow = Me.spbFirstRow
End Sub
Private Sub txtFirstRow_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtFirstRow_Change()
    If Val(Me.txtFirstRow) > Me.spbFirstRow.Max Then Me.txtFirstRow = Me.spbFirstRow.Max
    If Val(Me.txtFirstRow) < Me.spbFirstRow.Min Then Me.txtFirstRow = Me.spbFirstRow.Min
    If Me.txtFirstRow <> "" Then Me.spbFirstRow = Me.txtFirstRow
    Me.chkNoFirstFile.Enabled = (Me.txtFirstRow > 1)
End Sub

Private Sub spbOnlyFirst_SpinDown()
    Me.txtOnlyFirst = Me.spbOnlyFirst
End Sub
Private Sub spbOnlyFirst_SpinUp()
    Me.txtOnlyFirst = Me.spbOnlyFirst
End Sub
Private Sub txtOnlyFirst_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtOnlyFirst_Change()
    If Val(Me.txtOnlyFirst) > Me.spbOnlyFirst.Max Then Me.txtOnlyFirst = Me.spbOnlyFirst.Max
    If Val(Me.txtOnlyFirst) < Me.spbOnlyFirst.Min Then Me.txtOnlyFirst = Me.spbOnlyFirst.Min
    If Me.txtOnlyFirst <> "" Then Me.spbOnlyFirst = Me.txtOnlyFirst
End Sub

Private Sub spbNoLast_SpinDown()
    Me.txtNoLast = Me.spbNoLast
End Sub
Private Sub spbNoLast_SpinUp()
    Me.txtNoLast = Me.spbNoLast
End Sub
Private Sub txtNoLast_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNoLast_Change()
    If Val(Me.txtNoLast) > Me.spbNoLast.Max Then Me.txtNoLast = Me.spbNoLast.Max
    If Val(Me.txtNoLast) < Me.spbNoLast.Min Then Me.txtNoLast = Me.spbNoLast.Min
    If Me.txtNoLast <> "" Then Me.spbNoLast = Me.txtNoLast
End Sub

Private Sub chkNoLast_Change()
    Me.txtNoLast.Enabled = Me.chkNoLast
    Me.spbNoLast.Enabled = Me.chkNoLast
End Sub

Private Sub spbSepRows_SpinDown()
    Me.txtSepRows = Me.spbSepRows
End Sub

Private Sub spbSepRows_SpinUp()
    Me.txtSepRows = Me.spbSepRows
End Sub
Private Sub txtSepRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtSepRows_Change()
    If Val(Me.txtSepRows) > Me.spbSepRows.Max Then Me.txtSepRows = Me.spbSepRows.Max
    If Val(Me.txtSepRows) < Me.spbSepRows.Min Then Me.txtSepRows = Me.spbSepRows.Min
    If Me.txtSepRows <> "" Then Me.spbSepRows = Me.txtSepRows
End Sub

Private Sub chkOnlyFirst_Change()
    Me.txtOnlyFirst.Enabled = Me.chkOnlyFirst
    Me.spbOnlyFirst.Enabled = Me.chkOnlyFirst
End Sub

Private Sub cbxProtected_Change()
    Select Case Me.cbxProtected.ListIndex
        Case 2
            On Error Resume Next
            Me.txtPassword.BackColor = &H80000005
            Me.txtPassword.Enabled = True
            Me.txtPassword.SetFocus
            On Error GoTo 0
        Case Else
            Me.txtPassword.BackColor = &HC0C0C0
            Me.txtPassword.Enabled = False
    End Select
    Me.cbxProtected.ControlTipText = Me.cbxProtected.Text
End Sub

Private Sub cmdAdd_Click()
    Dim i As Integer
    Dim FileList As Collection
    Dim FileName As Variant
    Dim Item As Variant
    Dim MaxColWidth As String
    
    Set FileList = New Collection
    On Error Resume Next
    For i = 0 To Me.lbxImportFiles.ListCount - 1
        FileList.Add Me.lbxImportFiles.List(i), CStr(Me.lbxImportFiles.List(i))
    Next i
    On Error GoTo 0
        
    
    FileName = OpenDialog(Me.txtPath.Text, , "Seleziona i file da importare", True)
                       
    If IsArray(FileName) = False Then
        
        Exit Sub
    
    Else
    
        On Error Resume Next
        For i = LBound(FileName) To UBound(FileName)
            If i = LBound(FileName) Then 'Aggiorno il percorso nella textbox nascosta
                Me.txtPath = Replace(FileName(i), Dir(FileName(i)), "")
            End If
            
            FileList.Add FileName(i), CStr(FileName(i))
        Next i
        
        Me.lbxImportFiles.Clear
                
        For Each Item In FileList
            Me.lbxImportFiles.AddItem Item
            If Len(CStr(Item)) * 5 > MaxColWidth Then
                MaxColWidth = Len(CStr(Item)) * 5
                Me.lbxImportFiles.ColumnWidths = MaxColWidth
            End If
        Next Item
        On Error GoTo 0
        
    End If
    
    Call GoodToGo(Me)
    
End Sub
Private Sub cmdDelete_Click()
    Dim i As Long
    Dim counter As Long
    
    counter = 0
    For i = 0 To Me.lbxImportFiles.ListCount - 1
        If Me.lbxImportFiles.Selected(i - counter) = True Then
            Me.lbxImportFiles.RemoveItem (i - counter)
            counter = counter + 1
        End If
    Next i
    
    Call GoodToGo(Me)
    
End Sub
Private Sub cmdEmptyList_Click()
    Me.lbxImportFiles.Clear
    Call GoodToGo(Me)
End Sub
    
Private Sub optSeparateSheets_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub refOutRange_Enter()
    Me.optOutRange = True
End Sub

Private Sub txtNameFilter_Change()
    Me.txtNameFilter.ControlTipText = Me.txtNameFilter.Text
End Sub

Private Sub cbxNameFilter_Change()
    Dim i As Long
    
    If Me.cbxNameFilter.ListIndex = 3 Then
        For i = 1 To Len(Me.txtNameFilter)
            If (Asc(Mid(Me.txtNameFilter, i, 1)) < 48 And Asc(Mid(Me.txtNameFilter, i, 1)) <> 44) Or _
                Asc(Mid(Me.txtNameFilter, i, 1)) > 57 Then
                Me.txtNameFilter = ""
                Exit For
            End If
        Next i
    End If
End Sub
Private Sub txtNameFilter_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If Me.cbxNameFilter.ListIndex = 3 Then
        If KeyAscii = 46 Or KeyAscii = 44 Then
            KeyAscii = 44
        ElseIf KeyAscii < 48 Or KeyAscii > 57 Then
            KeyAscii = 0
        End If
    End If
End Sub

Private Sub optIncludeNamefilter_Change()
    Me.cbxNameFilter.Enabled = (Me.optIncludeNamefilter.Value = True Or Me.optExcludeNameFilter.Value = True)
    Me.txtNameFilter.Enabled = (Me.optIncludeNamefilter.Value = True Or Me.optExcludeNameFilter.Value = True)
End Sub

Private Sub optExcludeNamefilter_Change()
    Me.cbxNameFilter.Enabled = (Me.optIncludeNamefilter.Value = True Or Me.optExcludeNameFilter.Value = True)
    Me.txtNameFilter.Enabled = (Me.optIncludeNamefilter.Value = True Or Me.optExcludeNameFilter.Value = True)
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim Importbook As Workbook
    Dim ImportSheet As Worksheet
    Dim CurrWb As Workbook
    Dim newWs As Worksheet
    Dim ErrNum As Long
    Dim k As Long
    Dim i As Long
    Dim j As Long
    Dim c As Long
    Dim OutRng As Range, ImportRng As Range
    Dim off As Long
    Dim nRowsToPaste As Long
    Dim ErrorFiles As New Collection
    Dim ResultSummary As String
    Dim e As Long
    Dim cProtect As Long
    Dim cPivot As Long
    Dim Skip As Long
    Dim ErrorString As String
    Dim colArray As Variant
    Dim wsFilter As Variant
    Dim w As Long
    Dim CheckFilter As Long
    Dim wImport As Boolean
    Dim TrimmedValue As Variant
        
    With Me
        On Error Resume Next
        If .optOutRange.Enabled = True And .optOutRange.Value = True Then
           Set OutRng = Range(Replace(.refOutRange, ";", ","))
           If Err.Number <> 0 Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refOutRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
    
    '#' Imposta il file corrente come file "contenitore"
    If ActiveWorkbook Is Nothing Then Workbooks.Add
    Set Importbook = ActiveWorkbook
    
    Call AutoCalc(False)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.lbxImportFiles.ListCount
    UProgress.SetDescription "Importazione in corso..."
    Call ShowProgressBar
    
    
    For i = 0 To Me.lbxImportFiles.ListCount - 1
        
        On Error GoTo NextFile 'Da qui in poi se c'|fffd| un errore vado al prossimo file
        
        '#' Aumento di 1 il contatore
        counter = counter + 1
    
        Set CurrWb = Workbooks.Open(Me.lbxImportFiles.List(i), 0)
        
        With CurrWb
            UProgress.SetDescription "Importazione in corso... (" & .Name & ")"
            
            '#' Setto contatore secondario e suo massimo
            counter2 = 0
            countermax2 = .Worksheets.Count
                    
            For k = 1 To .Worksheets.Count
                
                counter2 = counter2 + 1
                
                ''' ==================================== '''
                ''' INIZIO FILTRI SUI FOGLI DA IMPORTARE '''
                ''' ==================================== '''
                
                With .Worksheets(k)
                    
                    wImport = True
                    
                    '#' Escludo le elaborazioni se opzioni avanzate |fffd| disabilitato
                    If Me.tglAdvanced = True Then
                    
                        '#' Verifico filtro includi/escludi nome
                        If Me.optIncludeNamefilter = True Then
                            
                            Select Case Me.cbxNameFilter.ListIndex
                                Case 1 'Includi se nome contiene
                                    If Me.txtNameFilter <> "" And InStr(1, .Name, Me.txtNameFilter, vbTextCompare) = 0 Then wImport = False
                                Case 2 'Includi se nome |fffd| uguale a
                                    If Me.txtNameFilter <> "" And UCase(.Name) <> UCase(Me.txtNameFilter) Then wImport = False
                                Case 3 'Includi se indice |fffd| tra
                                    wsFilter = Split(Me.txtNameFilter, ",")
                                    CheckFilter = 0
                                    For w = 0 To UBound(wsFilter)
                                        If .index = CLng(wsFilter(w)) Then
                                            CheckFilter = 1
                                            Exit For
                                        End If
                                    Next w
                                    If CheckFilter = 0 Then wImport = False
                            End Select
                        
                        ElseIf Me.optExcludeNameFilter = True Then
                        
                            Select Case Me.cbxNameFilter.ListIndex
                                Case 1 'Escludi se nome contiene
                                    If Me.txtNameFilter <> "" And InStr(1, .Name, Me.txtNameFilter, vbTextCompare) > 0 Then wImport = False
                                Case 2 'Escludi se nome |fffd| uguale a
                                    If Me.txtNameFilter <> "" And UCase(.Name) = UCase(Me.txtNameFilter) Then wImport = False
                                Case 3 'Escludi se indice |fffd| tra
                                    wsFilter = Split(Me.txtNameFilter, ",")
                                    For w = 0 To UBound(wsFilter)
                                        If .index = CLng(wsFilter(w)) Then wImport = False
                                    Next w
                            End Select
                
                        End If
                        
                        '#' Verifico filtro fogli vuoti
                        If Me.chkIncludeEmpty = False And wImport = True And Application.WorksheetFunction.CountA(.Cells) = 0 Then wImport = False
                        
                        '#' Verifico filtro fogli nascosti
                        If Me.chkIncludeHidden = False And wImport = True And .visible = False Then wImport = False
                        
                        '#' Routine per i fogli protetti
                        If .ProtectContents = True And wImport = True Then
                            Select Case Me.cbxProtected.ListIndex
                                Case 0
                                    'Salta il foglio
                                    cProtect = cProtect + 1
                                    wImport = False
                                Case 1
                                    'Chiedi la password
                                    On Error Resume Next
                                    Call AutoCalc(True)
                                    Do
                                        UProgress.Hide
                                        .Unprotect Password:=InputBox(IIf(lng = 0, "Foglio: ", "Worksheet: ") & .Name & vbNewLine & vbNewLine & _
                                            "File: " & CurrWb.Name & vbNewLine & vbNewLine & _
                                            IIf(lng = 0, "Inserisci la password:", "Type password:"), _
                                            IIf(lng = 0, "Richiesta password", "Password request"))
    
                                        If .ProtectContents = True Then
                                            Skip = MsgBox(IIf(lng = 0, "La password inserita non |fffd| corretta. Riprovare?", "Incorrect password. Try again?"), _
                                                            vbExclamation + vbRetryCancel, IIf(lng = 0, "Password errata", "Incorrect password"))
                                            If Skip = vbCancel Then
                                                Call ShowProgressBar
                                                cProtect = cProtect + 1
                                                Err.Clear
                                                wImport = False
                                            End If
                                        End If
                                    Loop Until .ProtectContents = False
                                    Call ShowProgressBar
                                    Err.Clear
                                    Call AutoCalc(False)
                                    On Error GoTo Aborted
                                Case 2
                                    'Usa sempre la stessa password
                                    On Error Resume Next
                                    .Unprotect Password:=Me.txtPassword
    
                                    If .ProtectContents = True Then 'La password predefinita non ha funzionato
                                        Call AutoCalc(True)
                                        Do
                                            UProgress.Hide
                                            .Unprotect Password:=InputBox(IIf(lng = 0, "Foglio: ", "Worksheet: ") & .Name & vbNewLine & vbNewLine & _
                                                "File: " & CurrWb.Name & vbNewLine & vbNewLine & _
                                                IIf(lng = 0, "Inserisci la password:", "Type password:"), _
                                                IIf(lng = 0, "Richiesta password", "Password request"))
    
                                            If .ProtectContents = True Then
                                                Skip = MsgBox(IIf(lng = 0, "La password inserita non |fffd| corretta. Riprovare?", "Incorrect password. Try again?"), _
                                                                vbExclamation + vbRetryCancel, IIf(lng = 0, "Password errata", "Incorrect password"))
                                                If Skip = vbCancel Then
                                                    Call ShowProgressBar
                                                    cProtect = cProtect + 1
                                                    Err.Clear
                                                    wImport = False
                                                End If
                                            End If
                                        Loop Until .ProtectContents = False
                                        Call ShowProgressBar
                                        Err.Clear
                                        Call AutoCalc(False)
                                    End If
                                    On Error GoTo Aborted
                            End Select
                        End If
                    
                    Else
                        
                        '#' Se opzioni semplificate, escludo i fogli vuoti e protetti
                        If Application.WorksheetFunction.CountA(.Cells) = 0 Then
                            wImport = False
                        ElseIf .ProtectContents = True Then
                            cProtect = cProtect + 1
                            wImport = False
                        End If
                    
                    End If 'Opzioni avanzate = True
                                        
                    '#' Escludo il foglio se contiene tabelle pivot
                    If .PivotTables.Count > 0 And wImport = True Then
                        cPivot = cPivot + 1
                        wImport = False
                    End If
                    
                ''' ==================================== '''
                '''  FINE FILTRI SUI FOGLI DA IMPORTARE  '''
                ''' ==================================== '''
                    
                    
                End With '.Worksheets(k)
                
                If wImport = True Then
                '#' Superati tutti i filtri dei fogli, passo all'importazione
                
                    UProgress.SetSubDescription "Foglio: " & .Worksheets(k).Name
                    .Worksheets(k).visible = True 'Rendo il foglio visibile
                    
                    '#' Copia il k-mo foglio di lavoro dal file in elenco a quello di importazione, imposta newWS al foglio appena copiato
                    .Worksheets(k).Copy After:=Importbook.Sheets(Importbook.Sheets.Count)
                    Set newWs = Importbook.Worksheets(Importbook.Worksheets.Count)
                    
                    
                    On Error Resume Next '#' Per superare eventuali errori nella rinomina del foglio
                    newWs.Name = Left(.Name, 15) & "_" & Left(.Sheets(k).Name, 30 - Len(Left(.Name, 15)))
                    If Err.Number > 0 Then
                        ErrNum = 1
                        Do While Err.Number > 0
                            Err.Clear
                            newWs.Name = Left(.Name, 13) & "_" & Left(.Sheets(k).Name, 26 - Len(Left(.Name, 13))) & "_" & Format(ErrNum, "000")
                            ErrNum = ErrNum + 1
                        Loop
                    End If
                    On Error GoTo NextFile
                        
                        
                    ''' ====================================================================== '''
                    '''  Inizio delle operazioni su newWS (foglio copiato dal file in elenco)  '''
                    ''' ====================================================================== '''
                        
                    With newWs
                    
                        '#' Incolla valori (e disabilita filtro automatico)
                        Call Cvalues(newWs, True)
                        
                        '''==========================='''
                        '''   RIORDINAMENTO COLONNE   '''
                        '''==========================='''
                        
                        If Me.optCustomOrder = True And Me.optAppend = True Then
                            If i = 0 Then 'E' il primo file, popolo l'array delle colonne con la prima riga
                                colArray = .Range("A1:" & findlastcell(.Rows(1)).address)
                                For j = LBound(colArray, 2) To UBound(colArray, 2)
                                    colArray(1, j) = Application.WorksheetFunction.Trim(colArray(1, j))
                                Next j
                                .Range("A1:" & findlastcell(.Cells).address).Copy SortSheet.Cells(1, 1)
                            
                            Else 'Verifico se ci sono nuove colonne
                                SortSheet.Cells.Clear
                                c = UBound(colArray, 2)
                                
                                For j = 1 To findlastcell(.Rows(1)).Column
                                    TrimmedValue = Application.WorksheetFunction.Trim(.Cells(1, j))
                                    If TrimmedValue <> "" Then
                                        If IsError(Application.Match(TrimmedValue, Application.index(colArray, 0), 0)) = True Then 'Colonna nuova, aggiungo in coda
                                            c = c + 1
                                            ReDim Preserve colArray(1 To 1, 1 To c)
                                            colArray(1, c) = TrimmedValue
                                            If Me.txtFirstRow = 1 Or Me.chkNoFirstFile = True Then
                                                ImportSheet.Cells(1, c) = TrimmedValue
                                            End If
                                        End If
                                    End If
                                    
                                    'Trasferisco i dati dal foglio di importazione al foglio di ordinamento,
                                    .Columns(j).Copy
                                    SortSheet.Cells(1, Application.Match(TrimmedValue, Application.index(colArray, 0), 0)).PasteSpecial
                                    Application.CutCopyMode = False

                                Next j
                            End If
                                
                            'Copio dal foglio ordinato al foglio di importazione
                            .Cells.Clear
                            SortSheet.UsedRange.Copy
                            .Cells(1, 1).PasteSpecial
                            SortSheet.Cells.Clear
                        End If
                        
                        '#' Solo se opzioni avanzate visibili
                        If Me.tglAdvanced = True Then
                        
                            '#' Rimuove formattazioni se relativa opzione impostata
                            If Me.chkFormats = False Then .UsedRange.ClearFormats
                            
                            '#' Rimuove le prime N righe se relativa opzione impostata
                            If Me.txtFirstRow > 1 And (Me.chkNoFirstFile * (i = 0)) = 0 Then
                                .Rows("1:" & Me.txtFirstRow - 1).Delete
                            End If
                            
                            '#' Rimuove le ultime N righe se relativa opzione impostata
                            If Me.chkNoLast = True Then
                                .Rows((.UsedRange.Rows.Count + .UsedRange.Row - 1) - Me.txtNoLast + 1 & ":" & .UsedRange.Rows.Count + .UsedRange.Row - 1).Delete
                            End If
                            
                            '#' Rimuove righe successive a N (ovvero importa solo prime N righe) se relativa opzione impostata
                            'Aggiungo le prime X-1 righe se |fffd| il primo file e sono impostate le opzioni "inizia dalla riga X solo per i file successivi al primo"
                            If Me.chkOnlyFirst = True Then
                                .Rows(Me.txtOnlyFirst + 1 + Abs((i = 0) * (Me.chkNoFirstFile.Enabled) * (Me.chkNoFirstFile) * (Me.txtFirstRow - 1)) & ":" & .Rows.Count).Delete
                            End If
                        
                        End If
                                            
                        '#' determino il numero di righe del range da incollare
                        nRowsToPaste = findlastcell(.Cells).Row
                        
                    End With 'newWs
                                            
                    ''' ====================================================================== '''
                    '''   Fine delle operazioni su newWS (foglio copiato dal file in elenco)   '''
                    ''' ====================================================================== '''
                        
                                            
                                            
                    ''' ================================================================================================== '''
                    '''                              Inizio opzioni accodamento di pi|fffd| file                                '''
                    '''  A questo punto, il foglio temporaneo newWS |fffd| stato gi|fffd| privato di tutti i dati da NON incollare   '''
                    ''' ================================================================================================== '''
                    
                    If Me.optAppend Then
                        
                        '#' Se importo in un nuovo foglio, lo creo e lo rinomino (se non esiste gi|fffd|)
                            If Me.optNewSheet Then
                            
                                On Error Resume Next
                                Set ImportSheet = Importbook.Worksheets("XLS Importati")
                                If Err.Number <> 0 Then
                                    Err.Clear
                                    Set ImportSheet = Importbook.Worksheets.Add
                                    ImportSheet.Name = "XLS Importati"
                                ElseIf i = 0 Then
                                    ImportSheet.Cells.Clear
                                End If
                                On Error GoTo NextFile
                            Else
                                'Se importo in un intervallo definito dall'utente, setto il foglio come Parent del range indicato
                                Set ImportSheet = OutRng.Parent
                            End If
                        
                        '#' Copio tutti i dati del foglio temporaneo
                        newWs.Range("A1:" & findlastcell(newWs.Cells).address).Copy
                                            
                        With ImportSheet
                        
                            '#' Imposto il range di uscita (incollamento)
                            
                            If Me.optNewSheet Then 'Nuovo foglio di lavoro
                                
                                'Colonna A, prima riga, spostata di "off" righe
                                Set ImportRng = .Range("A1").Offset(off, 0)
                            
                            Else 'Range custom
                                
                                'Cella indicata dall'utente, spostata di "off" righe
                                Set ImportRng = OutRng.Offset(off, 0)
                                    
                            End If
                            
                            'Scalo di una colonna se selezionato campo identificativo
                            If Me.chkID = True Then Set ImportRng = ImportRng.Offset(0, 1)
                                
                        End With
                            
                        With ImportRng
                        
                            If i = 0 And Me.optOutRange = False Then 'Incollo larghezza colonne se |fffd| il primo foglio importato del primo file
                                .PasteSpecial xlPasteColumnWidths
                            End If
                            
                            .PasteSpecial xlPasteValues 'Incollo i valori
                            
                            If Me.chkFormats = True And Me.tglAdvanced = True Then 'Se impostato, incollo i formati
                                .PasteSpecial xlPasteFormats
                            End If
                            
                        End With
                        
                        Application.CutCopyMode = False
                                                
                        '#' Scrivo la colonna dell'ID
                        If Me.chkID Then
                            Range(ImportRng(1, 1), ImportRng(nRowsToPaste, 1)).Offset(0, -1) = CurrWb.FullName & " [" & CurrWb.Sheets(k).Name & "]"
                        End If
                        
                        '#' Aggiorno il valore di off aggiungendo le righe appena incollate
                        off = off + nRowsToPaste
                        'Se le relative opzioni sono settate, aumento di N righe vuote di separazione
                        If Me.chkSepRows.Enabled = True And Me.chkSepRows = True Then
                            off = off + Me.txtSepRows
                        End If
                        
                        Application.DisplayAlerts = False
                        newWs.Delete
                        Application.DisplayAlerts = True
                        
                    End If 'Me.optAppend
                        
                    ''' ================================================================================================== '''
                    '''                              Fine opzioni accodamento di pi|fffd| file                                  '''
                    ''' ================================================================================================== '''
                        
NextSheet:     'punto di rimando se il foglio non incontra i criteri settati nel filtro
                                
                    '#' Aggiorna la barra di avanzamento secondaria
                    Call UpdateSubProgressBar(counter2, countermax2)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                End If
                    
            Next k
            
NextFile: 'punto di rimando se il file genera qualche errore

            'Chiudo il file da importare
            If Not CurrWb Is Nothing Then .Close (False)
            
        End With 'CurrWb
        
        Set CurrWb = Nothing
        
        'Se si |fffd| generato un errore nell'importazione del file, aggiungi alla Collection
        If Err.Number <> 0 Then
            Err.Clear
            ErrorFiles.Add Me.lbxImportFiles.List(i), CStr(Me.lbxImportFiles.List(i))
            On Error GoTo -1
        End If
                        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        DoEvents
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
        
    Next i
        
    'Adatto la larghezza della colonna identificativa
    If Me.chkID = True Then ImportSheet.Columns(1).AutoFit
            
    '#' Chiude la finestra di avanzamento
    Unload UProgress
        
    Call AutoCalc(True)
    
    '#' Mostra un avviso con l'esito dell'operazione
    ResultSummary = IIf(lng = 0, "Importazione completata: sono stati elaborati " & counter & " file", "Import complete: " & counter & " files were processed")
    
    If cProtect > 0 Then
        ResultSummary = ResultSummary & vbNewLine & vbNewLine & cProtect & IIf(lng = 0, " fogli non sono stati importati in quanto protetti", " sheets were not imported due to protection") & vbNewLine
    End If
    
    If cPivot > 0 Then
        ResultSummary = ResultSummary & vbNewLine & vbNewLine & cPivot & IIf(lng = 0, " fogli non sono stati importati in quanto contengono tabelle pivot", " sheets were not imported for they include pivot tables") & vbNewLine
    End If
    
    If ErrorFiles.Count > 0 Then
        
        ErrorString = IIf(lng = 0, "I seguenti file non sono stati importati correttamente:", "The following files failed to import correctly:") & vbNewLine
        
        ResultSummary = ResultSummary & vbNewLine & vbNewLine & IIf(lng = 0, "Sui seguenti file si |fffd| verificato un problema: ", "The following files returned some kind of error: ") & vbNewLine & vbNewLine
                
        For e = 1 To ErrorFiles.Count
            ResultSummary = ResultSummary & ErrorFiles(e) & vbNewLine
            ErrorString = ErrorString & ErrorFiles(e) & vbNewLine
        Next e
        ErrorString = Left(ErrorString, Len(ErrorString) - 2)
        
        Call UpdateErrorLog(ErrorString)
        
        ResultSummary = ResultSummary & vbNewLine
        ResultSummary = ResultSummary & IIf(lng = 0, "E' stato aggiornato il log degli errori al percorso:", "The error log was updated:") & vbNewLine
        
    End If
    MsgBox ResultSummary, IIf(ErrorFiles.Count = 0, vbInformation, vbExclamation), IIf(lng = 0, "Esito importazione", "Result summary")
        
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmImportMultipleTXT"
Attribute VB_Base = "0{B1A48D05-7F6F-4AF3-B61A-9042828FC947}{72F701CA-7653-4F83-B2E9-57ED619BBD84}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableMsg As Boolean

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    DisableMsg = True
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    Me.lbxCSV_ImportFiles.Clear
    Me.lbxXML_ImportFiles.Clear
    
    With Me.cbxCSV_TxtQual
        .AddItem """"
        .AddItem "'"
        .AddItem "nessuno"
        .ListIndex = 0
    End With
    
    With Me.cbxCSV_TxtDec
        .AddItem ","
        .AddItem "."
        .Text = dSep
    End With
    
    With Me.cbxCSV_TxtThou
        .AddItem "."
        .AddItem ","
        .AddItem "{spazio}"
        .AddItem "'"
        .Text = tSep
    End With
    
    Me.mpgType.Value = 0
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    Me.lblXML_Description.Caption = Me.lblDescription.Caption
    
    DisableMsg = False
    
    Call GoodToGo(Me)

End Sub



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''   INIZIO SEZIONE CSV  '''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''


Private Sub chkCompatibility_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraCSV_Delim.Controls
        If ctl.Name <> "chkCompatibility" Then ctl.Enabled = Not Me.chkCompatibility
    Next ctl

    If Me.chkCompatibility = True And DisableMsg = False Then
        Select Case lng
            Case 0
                MsgBox "Questa modalit|fffd| |fffd| pi|fffd| lenta e supporta solo i delimitatori di default, ma funziona anche nel caso di interruzioni di riga manuali interne alle celle.", vbInformation, "Modalit|fffd| alternativa"
            Case Else
                MsgBox "This mode is slower and only supports local default delimiters, but also works in case of manual line breaks within cells.", vbInformation, "Alternative mode"
        End Select
    End If
End Sub

Private Sub optDelim_Change()
    Dim ctl As control
    For Each ctl In Me.fraCSV_Delim.Controls
        If ctl.Tag = "Delim" Then ctl.visible = Me.optDelim
        If ctl.Tag = "Fixed" Then ctl.visible = Me.optFixed
    Next ctl
End Sub

Private Sub optFixed_Change()
    Dim ctl As control
    For Each ctl In Me.fraCSV_Delim.Controls
        If ctl.Tag = "Delim" Then ctl.visible = Me.optDelim
        If ctl.Tag = "Fixed" Then ctl.visible = Me.optFixed
    Next ctl
End Sub

Private Sub txtCWidth_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If (KeyAscii < 48 And KeyAscii <> 44) Or KeyAscii > 57 Then KeyAscii = 0
End Sub

Private Sub spbCSV_OnlyFirst_SpinDown()
    Me.txtCSV_OnlyFirst = Me.spbCSV_OnlyFirst
End Sub

Private Sub spbCSV_OnlyFirst_SpinUp()
    Me.txtCSV_OnlyFirst = Me.spbCSV_OnlyFirst
End Sub
Private Sub txtCSV_OnlyFirst_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtCSV_OnlyFirst_Change()
    If Val(Me.txtCSV_OnlyFirst) > Me.spbCSV_OnlyFirst.Max Then Me.txtCSV_OnlyFirst = Me.spbCSV_OnlyFirst.Max
    If Val(Me.txtCSV_OnlyFirst) < Me.spbCSV_OnlyFirst.Min Then Me.txtCSV_OnlyFirst = Me.spbCSV_OnlyFirst.Min
    If Me.txtCSV_OnlyFirst <> "" Then Me.spbCSV_OnlyFirst = Me.txtCSV_OnlyFirst
End Sub

Private Sub spbCSV_FirstRow_SpinDown()
    Me.txtCSV_FirstRow = Me.spbCSV_FirstRow
End Sub

Private Sub spbCSV_FirstRow_SpinUp()
    Me.txtCSV_FirstRow = Me.spbCSV_FirstRow
End Sub
Private Sub txtCSV_FirstRow_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtCSV_FirstRow_Change()
    If Val(Me.txtCSV_FirstRow) > Me.spbCSV_FirstRow.Max Then Me.txtCSV_FirstRow = Me.spbCSV_FirstRow.Max
    If Val(Me.txtCSV_FirstRow) < Me.spbCSV_FirstRow.Min Then Me.txtCSV_FirstRow = Me.spbCSV_FirstRow.Min
    If Me.txtCSV_FirstRow <> "" Then Me.spbCSV_FirstRow = Me.txtCSV_FirstRow
    Me.chkCSV_NoFirstFile.Enabled = (Me.txtCSV_FirstRow > 1)
End Sub

Private Sub spbCSV_SepRows_SpinDown()
    Me.txtCSV_SepRows = Me.spbCSV_SepRows
End Sub

Private Sub spbCSV_SepRows_SpinUp()
    Me.txtCSV_SepRows = Me.spbCSV_SepRows
End Sub
Private Sub txtCSV_SepRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtCSV_SepRows_Change()
    If Val(Me.txtCSV_SepRows) > Me.spbCSV_SepRows.Max Then Me.txtCSV_SepRows = Me.spbCSV_SepRows.Max
    If Val(Me.txtCSV_SepRows) < Me.spbCSV_SepRows.Min Then Me.txtCSV_SepRows = Me.spbCSV_SepRows.Min
    If Me.txtCSV_SepRows <> "" Then Me.spbCSV_SepRows = Me.txtCSV_SepRows
End Sub

Private Sub optCSV_Append_Change()
    Dim ctl As control
    
    Me.fraCSV_Append.Enabled = Me.optCSV_Append
    For Each ctl In Me.fraCSV_Append.Controls
        ctl.Enabled = Me.optCSV_Append
    Next ctl
    Me.txtCSV_SepRows.Enabled = Me.optCSV_Append * Me.chkCSV_SepRows
    Me.spbCSV_SepRows.Enabled = Me.optCSV_Append * Me.chkCSV_SepRows
End Sub

Private Sub chkCSV_SepRows_Change()
    Me.txtCSV_SepRows.Enabled = Me.optCSV_Append * Me.chkCSV_SepRows
    Me.spbCSV_SepRows.Enabled = Me.optCSV_Append * Me.chkCSV_SepRows
End Sub

Private Sub chkCSV_OnlyFirst_Change()
    Me.txtCSV_OnlyFirst.Enabled = Me.chkCSV_OnlyFirst
    Me.spbCSV_OnlyFirst.Enabled = Me.chkCSV_OnlyFirst
End Sub

Private Sub cmdCSV_Add_Click()
    Dim i As Integer
    Dim FileList As Collection
    Dim FileName As Variant
    Dim Item As Variant
    Dim MaxColWidth As String
    
    Set FileList = New Collection
    On Error Resume Next
    For i = 0 To Me.lbxCSV_ImportFiles.ListCount - 1
        FileList.Add Me.lbxCSV_ImportFiles.List(i), CStr(Me.lbxCSV_ImportFiles.List(i))
    Next i
    On Error GoTo 0
        
    FileName = OpenDialog(Me.txtCSVPath.Text, "File di testo,*.csv;*.txt;*.prn, Tutti i file,*.*", IIf(lng = 0, "Seleziona i file di testo da importare", "Select text files to import"), True)
                       
    If IsArray(FileName) = False Then
        
        Exit Sub
    
    Else
    
        On Error Resume Next
        For i = LBound(FileName) To UBound(FileName)
            If i = LBound(FileName) Then 'Aggiorno il percorso nella textbox nascosta
                Me.txtCSVPath = Replace(FileName(i), Dir(FileName(i)), "")
            End If
            
            FileList.Add FileName(i), CStr(FileName(i))
        Next i
        
        Me.lbxCSV_ImportFiles.Clear
                
        For Each Item In FileList
            Me.lbxCSV_ImportFiles.AddItem Item
            If Len(CStr(Item)) * 5 > MaxColWidth Then
                MaxColWidth = Len(CStr(Item)) * 5
                Me.lbxCSV_ImportFiles.ColumnWidths = MaxColWidth
            End If
        Next Item
        On Error GoTo 0
        
    End If
    
    Call GoodToGo(Me)

End Sub
Private Sub cmdCSV_Delete_Click()
    Dim i As Long
    Dim counter As Long
    
    counter = 0
    For i = 0 To Me.lbxCSV_ImportFiles.ListCount - 1
        If Me.lbxCSV_ImportFiles.Selected(i - counter) = True Then
            Me.lbxCSV_ImportFiles.RemoveItem (i - counter)
            counter = counter + 1
        End If
    Next i
    
    Call GoodToGo(Me)

End Sub

Private Sub lbxCSV_ImportFiles_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdCSV_Delete_Click
End Sub

Private Sub cmdCSV_EmptyList_Click()
    Me.lbxCSV_ImportFiles.Clear
    Me.cmdCSV_OK.Enabled = False
End Sub

Private Sub cmdCSV_Cancel_Click()
    Unload Me
End Sub

Private Sub cmdCSV_OK_click()
    Dim Importbook As Workbook
    Dim i As Long
    Dim newWb As Workbook
    Dim newWs As Worksheet
    Dim ImportSheet As Worksheet
    Dim OutRng As Range
    Dim wArray1() As String
    Dim wArray2() As Integer
    Dim w As Long
    Dim ImportRng As Range
    Dim nRowsToPaste As Long
    Dim off As Long
    Dim ErrorFiles As New Collection
    Dim ResultSummary As String
    Dim e As Long
    Dim ErrNum As Long
    Dim ErrorString As String
        
    With Me
        On Error Resume Next
        If .optCSV_OutRange.Enabled = True And .optCSV_OutRange.Value = True Then
           Set OutRng = Range(Replace(.refCSV_OutRange, ";", ","))
           If Err.Number <> 0 Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refCSV_OutRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    '#' Imposta il file corrente come file "contenitore"
    If ActiveWorkbook Is Nothing Then Workbooks.Add
    Set Importbook = ActiveWorkbook
    
    Call AutoCalc(False)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.lbxCSV_ImportFiles.ListCount
    UProgress.SetDescription "Importazione in corso..."
    Call ShowProgressBar
    
    For i = 0 To Me.lbxCSV_ImportFiles.ListCount - 1
        
        On Error GoTo NextFile
    
        counter = counter + 1
        
        
        If Me.chkCompatibility = True Then
            Set newWb = Workbooks.Open(FileName:=Me.lbxCSV_ImportFiles.List(i), Local:=True)
            newWb.Worksheets(1).Copy After:=Importbook.Worksheets(Importbook.Worksheets.Count)
            Set newWs = Importbook.Worksheets(Importbook.Worksheets.Count)
            newWb.Close (False)
            Set newWb = Nothing
        Else
            '#' Aggiungo un foglio di lavoro
            Set newWs = Importbook.Worksheets.Add
                
            '#' Se larghezza fissa, creo l'array delle larghezze colonne e lo converto in Integer
            If Me.optFixed = True And Me.txtCWidth <> "" Then
                wArray1() = Split(Me.txtCWidth.Value, ",")
                ReDim wArray2(LBound(wArray1) To UBound(wArray1))
                For w = LBound(wArray1) To UBound(wArray1)
                    wArray2(w) = CInt(wArray1(w))
                Next w
            End If
            
            With newWs.QueryTables.Add(Connection:="TEXT;" & Me.lbxCSV_ImportFiles.List(i), destination:=newWs.Range("$A$1"))
                .Name = Left(Replace(Replace(Replace(Mid(Me.lbxCSV_ImportFiles.List(i), InStrRev(Me.lbxCSV_ImportFiles.List(i), pSep) + 1), ".csv", ""), ".txt", ""), ".prn", ""), 31)
                .FieldNames = True
                .RowNumbers = False
                .FillAdjacentFormulas = False
                .PreserveFormatting = True
                .RefreshOnFileOpen = False
                .RefreshStyle = xlInsertDeleteCells
                .SavePassword = False
                .SaveData = True
                .AdjustColumnWidth = True
                .RefreshPeriod = 0
                .TextFilePromptOnRefresh = False
                .TextFileDecimalSeparator = Me.cbxCSV_TxtDec
                .TextFileThousandsSeparator = Replace(Me.cbxCSV_TxtThou, "{spazio}", " ")
                If Me.chkCSV_NoFirstFile = False Or i > 0 Then
                    .TextFileStartRow = Me.txtCSV_FirstRow
                Else
                    .TextFileStartRow = 1
                End If
                If Me.optFixed = True Then .TextFileParseType = xlFixedWidth Else .TextFileParseType = xlDelimited
                If Me.cbxCSV_TxtQual.ListIndex = 0 Then
                    .TextFileTextQualifier = xlTextQualifierDoubleQuote
                ElseIf Me.cbxCSV_TxtQual.ListIndex = 0 Then
                    .TextFileTextQualifier = xlTextQualifierSingleQuote
                Else
                    .TextFileTextQualifier = xlTextQualifierNone
                End If
                .TextFileConsecutiveDelimiter = Me.chkCSV_ConsecutiveDelim
                .TextFileTabDelimiter = Me.chkCSV_Tab
                .TextFileSemicolonDelimiter = Me.chkCSV_Semicolon
                .TextFileCommaDelimiter = Me.chkCSV_Comma
                .TextFileSpaceDelimiter = Me.chkCSV_Space
                If Me.chkCSV_CustomDelim = True And Me.txtCSV_CustomDelim <> "" Then .TextFileOtherDelimiter = Me.txtCSV_CustomDelim
                If Me.optFixed = True Then
                    .TextFileFixedColumnWidths = wArray2()
                End If
                .TextFileTrailingMinusNumbers = True
                On Error Resume Next
                .Refresh BackgroundQuery:=False
                On Error GoTo NextFile
            End With
            
            newWs.QueryTables(1).Delete
                
        End If
        
        With newWs
            If Me.optCSV_SeparateSheets = True Then
                On Error Resume Next
                .Name = Left(Replace(Dir(Me.lbxCSV_ImportFiles.List(i)), "." & Split(Dir(Me.lbxCSV_ImportFiles.List(i)), ".")(UBound(Split(Dir(Me.lbxCSV_ImportFiles.List(i)), "."))), ""), 30)
                ErrNum = 1
                Do While Err.Number <> 0
                    Err.Clear
                    ErrNum = ErrNum + 1
                    .Name = Left(Replace(Dir(Me.lbxCSV_ImportFiles.List(i)), "." & Split(Dir(Me.lbxCSV_ImportFiles.List(i)), ".")(UBound(Split(Dir(Me.lbxCSV_ImportFiles.List(i)), "."))), ""), 25) & "_" & Format(ErrNum, "0000")
                Loop
                On Error GoTo Aborted
            End If
            
            If Me.chkCompatibility = True And Me.txtCSV_FirstRow > 1 Then
                '#' Delete first n rows if set to be skipped
                If i > 0 Or Me.chkCSV_NoFirstFile = False Then
                    .Range("1:" & Me.txtCSV_FirstRow - 1).EntireRow.Delete
                End If
            End If
        
            If Me.chkCSV_OnlyFirst = True Then
                '#' Delete lines if limit was set
                .Rows(Me.txtCSV_OnlyFirst + 1 + Abs((i = 0) * (Me.chkCSV_NoFirstFile.Enabled) * (Me.chkCSV_NoFirstFile) * (Me.txtCSV_FirstRow - 1)) & ":" & .Rows.Count).Delete
            End If
            
            '#' determino il numero di righe del range da incollare
            nRowsToPaste = findlastcell(.Cells).Row

        End With
        
            
        If Me.optCSV_Append Then
            If Me.optCSV_NewSheet Then
                Err.Clear
                On Error Resume Next
                Set ImportSheet = Importbook.Worksheets("TXT Importati")
                If Err.Number <> 0 Then
                    Err.Clear
                    Set ImportSheet = Importbook.Worksheets.Add
                    ImportSheet.Name = "TXT Importati"
                End If
                On Error GoTo NextFile
            Else
                'Se importo in un intervallo definito dall'utente, setto il foglio come Parent del range indicato
                Set ImportSheet = OutRng.Parent
            End If
            
            '#' Copio tutti i dati del foglio temporaneo
            newWs.Range("A1:" & findlastcell(newWs.Cells).address).Copy
                        
            With ImportSheet
            
                '#' Imposto il range di uscita (incollamento)
                
                If Me.optCSV_NewSheet Then 'Nuovo foglio di lavoro
                    
                    'Colonna A, prima riga, spostata di "off" righe
                    Set ImportRng = .Range("A1").Offset(off, 0)
                
                Else 'Range custom
                    
                    'Cella indicata dall'utente, spostata di "off" righe
                    Set ImportRng = OutRng.Offset(off, 0)
                        
                End If
                
                'Scalo di una colonna se selezionato campo identificativo
                If Me.chkCSV_ID = True Then Set ImportRng = ImportRng.Offset(0, 1)
                    
            End With
            
            With ImportRng
            
                .PasteSpecial 'Incollo i valori
                
            End With
            
            Application.CutCopyMode = False
                                    
            '#' Scrivo la colonna dell'ID
            If Me.chkCSV_ID Then
                Range(ImportRng(1, 1), ImportRng(nRowsToPaste, 1)).Offset(0, -1) = Me.lbxCSV_ImportFiles.List(i)
            End If
            
            '#' Aggiorno il valore di off aggiungendo le righe appena incollate
            off = off + nRowsToPaste
            'Se le relative opzioni sono settate, aumento di N righe vuote di separazione
            If Me.chkCSV_SepRows.Enabled = True And Me.chkCSV_SepRows = True Then
                off = off + Me.txtCSV_SepRows
            End If
                                    
            '#' Adatto larghezza colonne nel foglio di destinazione
            ImportSheet.Columns.AutoFit
            
            Application.DisplayAlerts = False
            newWs.Delete
            Application.DisplayAlerts = True
        End If
        
NextFile: 'punto di rimando se il file genera qualche errore
        
        'Se si |fffd| generato un errore nell'importazione del file, aggiungi alla Collection
        If Err.Number <> 0 Then
            Err.Clear
            ErrorFiles.Add Me.lbxCSV_ImportFiles.List(i), CStr(Me.lbxCSV_ImportFiles.List(i))
            On Error GoTo -1
        End If
                        

        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        DoEvents
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

    Next i
    
    '#' Chiude la finestra di avanzamento
    Unload UProgress
        
    Call AutoCalc(True)
    
    '#' Mostra un avviso con l'esito dell'operazione
    ResultSummary = IIf(lng = 0, "Importazione completata: sono stati elaborati " & counter & " file", "Import complete: " & counter & " files were processed")
    If ErrorFiles.Count > 0 Then
        
        ErrorString = IIf(lng = 0, "I seguenti file non sono stati importati correttamente:", "The following files failed to import correctly:") & vbNewLine
        
        ResultSummary = ResultSummary & vbNewLine & vbNewLine & IIf(lng = 0, "Sui seguenti file si |fffd| verificato un problema: ", "The following files returned some kind of error: ") & vbNewLine & vbNewLine
                
        For e = 1 To ErrorFiles.Count
            ResultSummary = ResultSummary & ErrorFiles(e) & vbNewLine
            ErrorString = ErrorString & ErrorFiles(e) & vbNewLine
        Next e
        
        Call UpdateErrorLog(ErrorString)
        
        ResultSummary = ResultSummary & vbNewLine
        ResultSummary = ResultSummary & IIf(lng = 0, "E' stato aggiornato il log degli errori: puoi consultarlo dal menu Impostazioni", "The error log was updated: You can find it on the Settings menu")
        
    End If
    MsgBox ResultSummary, IIf(ErrorFiles.Count = 0, vbInformation, vbExclamation), IIf(lng = 0, "Esito importazione", "Result summary")
        
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub




















'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''   INIZIO SEZIONE XML  '''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''



Private Sub optXML_Table_Change()
    Me.txtXML_FirstRow.Enabled = Not Me.optXML_Table
    Me.spbXML_FirstRow.Enabled = Not Me.optXML_Table
    Me.chkXML_NoFirstFile.Enabled = Not Me.optXML_Table
    Me.lblXML_FirstRow.Enabled = Not Me.optXML_Table
    Me.chkXML_SepRows.Enabled = (Not Me.optXML_Table) * Me.optXML_Append
    Me.txtXML_SepRows.Enabled = (Not Me.optXML_Table) * Me.optXML_Append
    Me.spbXML_SepRows.Enabled = (Not Me.optXML_Table) * Me.optXML_Append
    
    If Me.optXML_Table = True Then Me.txtXML_FirstRow = 1
End Sub

Private Sub spbXML_OnlyFirst_SpinDown()
    Me.txtXML_OnlyFirst = Me.spbXML_OnlyFirst
End Sub

Private Sub spbXML_OnlyFirst_SpinUp()
    Me.txtXML_OnlyFirst = Me.spbXML_OnlyFirst
End Sub
Private Sub txtXML_OnlyFirst_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtXML_OnlyFirst_Change()
    If Val(Me.txtXML_OnlyFirst) > Me.spbXML_OnlyFirst.Max Then Me.txtXML_OnlyFirst = Me.spbXML_OnlyFirst.Max
    If Val(Me.txtXML_OnlyFirst) < Me.spbXML_OnlyFirst.Min Then Me.txtXML_OnlyFirst = Me.spbXML_OnlyFirst.Min
    Me.spbXML_OnlyFirst = Me.txtXML_OnlyFirst
End Sub

Private Sub spbXML_FirstRow_SpinDown()
    Me.txtXML_FirstRow = Me.spbXML_FirstRow
End Sub

Private Sub spbXML_FirstRow_SpinUp()
    Me.txtXML_FirstRow = Me.spbXML_FirstRow
End Sub
Private Sub txtXML_FirstRow_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtXML_FirstRow_Change()
    If Val(Me.txtXML_FirstRow) > Me.spbXML_FirstRow.Max Then Me.txtXML_FirstRow = Me.spbXML_FirstRow.Max
    If Val(Me.txtXML_FirstRow) < Me.spbXML_FirstRow.Min Then Me.txtXML_FirstRow = Me.spbXML_FirstRow.Min
    Me.spbXML_FirstRow = Me.txtXML_FirstRow
End Sub

Private Sub spbXML_SepRows_SpinDown()
    Me.txtXML_SepRows = Me.spbXML_SepRows
End Sub

Private Sub spbXML_SepRows_SpinUp()
    Me.txtXML_SepRows = Me.spbXML_SepRows
End Sub
Private Sub txtXML_SepRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtXML_SepRows_Change()
    If Val(Me.txtXML_SepRows) > Me.spbXML_SepRows.Max Then Me.txtXML_SepRows = Me.spbXML_SepRows.Max
    If Val(Me.txtXML_SepRows) < Me.spbXML_SepRows.Min Then Me.txtXML_SepRows = Me.spbXML_SepRows.Min
    If Me.txtXML_SepRows <> "" Then Me.spbXML_SepRows = Me.txtXML_SepRows
End Sub

Private Sub optXML_Append_Change()
    Dim ctl As control
    
    Me.fraXML_Append.Enabled = Me.optXML_Append
    For Each ctl In Me.fraXML_Append.Controls
        ctl.Enabled = Me.optXML_Append
    Next ctl
    Me.txtXML_SepRows.Enabled = Me.optXML_Append * Me.chkXML_SepRows
    Me.spbXML_SepRows.Enabled = Me.optXML_Append * Me.chkXML_SepRows
End Sub

Private Sub chkXML_SepRows_Change()
    Me.txtXML_SepRows.Enabled = Me.optXML_Append * Me.chkXML_SepRows
    Me.spbXML_SepRows.Enabled = Me.optXML_Append * Me.chkXML_SepRows
End Sub

Private Sub chkXML_OnlyFirst_Change()
    Me.txtXML_OnlyFirst.Enabled = Me.chkXML_OnlyFirst
    Me.spbXML_OnlyFirst.Enabled = Me.chkXML_OnlyFirst
End Sub

Private Sub cmdXML_Add_Click()
    Dim i As Integer
    Dim FileList As Collection
    Dim FileName As Variant
    Dim Item As Variant
    Dim MaxColWidth As String
    
    Set FileList = New Collection
    On Error Resume Next
    For i = 0 To Me.lbxXML_ImportFiles.ListCount - 1
        FileList.Add Me.lbxXML_ImportFiles.List(i), CStr(Me.lbxXML_ImportFiles.List(i))
    Next i
    On Error GoTo 0
        
                       
    FileName = OpenDialog(Me.txtXMLPath.Text, "File XML,*.xml", IIf(lng = 0, "Seleziona i file .xml da importare", "Select .xml files to import"), True)
                       
    If IsArray(FileName) = False Then
        
        Exit Sub
    
    Else
    
        On Error Resume Next
        For i = LBound(FileName) To UBound(FileName)
            If i = LBound(FileName) Then 'Aggiorno il percorso nella textbox nascosta
                Me.txtXMLPath = Replace(FileName(i), Dir(FileName(i)), "")
            End If
            
            FileList.Add FileName(i), CStr(FileName(i))
        Next i
        
        Me.lbxXML_ImportFiles.Clear
                
        For Each Item In FileList
            Me.lbxXML_ImportFiles.AddItem Item
            If Len(CStr(Item)) * 5 > MaxColWidth Then
                MaxColWidth = Len(CStr(Item)) * 5
                Me.lbxXML_ImportFiles.ColumnWidths = MaxColWidth
            End If
        Next Item
        On Error GoTo 0
        
    End If
    
    Call GoodToGo(Me)

End Sub
Private Sub cmdXML_Delete_Click()
    Dim i As Long
    Dim counter As Long
    
    counter = 0
    For i = 0 To Me.lbxXML_ImportFiles.ListCount - 1
        If Me.lbxXML_ImportFiles.Selected(i - counter) = True Then
            Me.lbxXML_ImportFiles.RemoveItem (i - counter)
            counter = counter + 1
        End If
    Next i
    
    Call GoodToGo(Me)

End Sub

Private Sub lbxXML_ImportFiles_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdXML_Delete_Click
End Sub

Private Sub cmdXML_EmptyList_Click()
    Me.lbxXML_ImportFiles.Clear
    Me.cmdXML_OK.Enabled = False
End Sub

Private Sub cmdXML_Cancel_Click()
    Unload Me
End Sub

Private Sub cmdXML_OK_click()
    Dim Importbook As Workbook
    Dim ImportSheet As Worksheet
    Dim OutRng As Range
    Dim i As Long
    Dim newWb As Workbook
    Dim startRow As Long
    Dim ImportRng As Range
    Dim nRowsToPaste As Long
    Dim off As Long
    Dim ErrorFiles As New Collection
    Dim ResultSummary As String
    Dim e As Long
    Dim ErrorString As String
        
    With Me
        On Error Resume Next
        If .optXML_OutRange.Enabled = True And .optXML_OutRange.Value = True Then
           Set OutRng = Range(Replace(.refXML_OutRange, ";", ","))
           If Err.Number <> 0 Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refXML_OutRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    '#' Imposta il file corrente come file "contenitore"
    If ActiveWorkbook Is Nothing Then Workbooks.Add
    Set Importbook = ActiveWorkbook
    
    Call AutoCalc(False)
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.lbxXML_ImportFiles.ListCount
    UProgress.SetDescription "Importazione in corso..."
    Call ShowProgressBar
    
    For i = 0 To Me.lbxXML_ImportFiles.ListCount - 1
        
        On Error GoTo NextFile
    
        counter = counter + 1
        
        '#' Apro il file XML in una nuova cartella di lavoro
        If Me.optXML_Text Then
            Set newWb = Workbooks.Open(FileName:=Me.lbxXML_ImportFiles.List(i))
        ElseIf Me.optXML_Table Then
            Set newWb = Workbooks.OpenXML(FileName:=Me.lbxXML_ImportFiles.List(i), LoadOption:=xlXmlLoadImportToList)
        End If
        
        '#' Start from nth row
        startRow = Me.txtXML_FirstRow
        If startRow > 1 And (Me.chkXML_NoFirstFile = False Or i > 0) Then
            newWb.Worksheets(1).Rows("1:" & startRow - 1).Delete
        End If
        
        If Me.chkXML_OnlyFirst = True Then
            With newWb.Worksheets(1)
                '#' Delete rows if limit was set
                .Rows(Me.txtXML_OnlyFirst + 1 + Abs((Me.chkXML_NoFirstFile.Enabled) * (Me.chkXML_NoFirstFile) * (i = 0) * (Me.txtXML_FirstRow - 1)) & ":" & .Rows.Count).Delete
            End With
        End If
        
        '#' determino il numero di righe del range da incollare
        nRowsToPaste = findlastcell(newWb.Worksheets(1).Cells).Row
        
        If Me.optXML_Append Then
            If Me.optXML_NewSheet Then
                Err.Clear
                On Error Resume Next
                Set ImportSheet = Importbook.Worksheets("XML Importati")
                If Err.Number <> 0 Then
                    Err.Clear
                    Set ImportSheet = Importbook.Worksheets.Add
                    ImportSheet.Name = "XML Importati"
                End If
                On Error GoTo NextFile
            Else
                Set ImportSheet = OutRng.Parent
            End If
            
            '#' Copio tutti i dati del foglio temporaneo
            newWb.Worksheets(1).Range("A1:" & findlastcell(newWb.Worksheets(1).Cells).address).Copy
                        
            
            With ImportSheet
            
                '#' Imposto il range di uscita (incollamento)
                
                If Me.optXML_NewSheet Then 'Nuovo foglio di lavoro
                    
                    'Colonna A, prima riga, spostata di "off" righe
                    Set ImportRng = .Range("A1").Offset(off, 0)
                
                Else 'Range custom
                    
                    'Cella indicata dall'utente, spostata di "off" righe
                    Set ImportRng = OutRng.Offset(off, 0)
                        
                End If
                
                'Scalo di una colonna se selezionato campo identificativo
                If Me.chkXML_ID = True Then Set ImportRng = ImportRng.Offset(0, 1)
                    
            End With
            
            With ImportRng
            
                .PasteSpecial 'Incollo i valori
                
            End With
            
            Application.CutCopyMode = False
                                    
            '#' Scrivo la colonna dell'ID
            If Me.chkXML_ID Then
                Range(ImportRng(1, 1), ImportRng(nRowsToPaste, 1)).Offset(0, -1) = Me.lbxXML_ImportFiles.List(i)
            End If
            
            '#' Aggiorno il valore di off aggiungendo le righe appena incollate
            off = off + nRowsToPaste
            'Se le relative opzioni sono settate, aumento di N righe vuote di separazione
            If Me.chkXML_SepRows.Enabled = True And Me.chkXML_SepRows = True Then
                off = off + Me.txtXML_SepRows
            End If
                                    
            '#' Adatto larghezza colonne nel foglio di destinazione
            ImportSheet.Columns.AutoFit
            
        Else '#' Just copy the first worksheet of newWB to Importbook
            newWb.Worksheets(1).Copy After:=Importbook.Worksheets(Importbook.Worksheets.Count)
            If Me.optXML_Table Then
                On Error Resume Next
                Importbook.Worksheets(Importbook.Worksheets.Count).Name = Replace(Mid(Me.lbxXML_ImportFiles.List(i), InStrRev(Me.lbxXML_ImportFiles.List(i), pSep) + 1), ".xml", "")
                On Error GoTo NextFile
            End If
        End If
                        
        newWb.Close (False)
                        
NextFile: 'punto di rimando se il file genera qualche errore
        
        'Se si |fffd| generato un errore nell'importazione del file, aggiungi alla Collection
        If Err.Number <> 0 Then
            Err.Clear
            ErrorFiles.Add Me.lbxXML_ImportFiles.List(i), CStr(Me.lbxXML_ImportFiles.List(i))
            On Error GoTo -1
        End If
                        

        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        DoEvents
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

    Next i
    
    '#' Chiude la finestra di avanzamento
    Unload UProgress
        
    Call AutoCalc(True)
    
    '#' Mostra un avviso con l'esito dell'operazione
    ResultSummary = IIf(lng = 0, "Importazione completata: sono stati elaborati " & counter & " file", "Import complete: " & counter & " files were processed")
    If ErrorFiles.Count > 0 Then
        
        ErrorString = IIf(lng = 0, "I seguenti file non sono stati importati correttamente:", "The following files failed to import correctly:") & vbNewLine
        
        ResultSummary = ResultSummary & vbNewLine & vbNewLine & IIf(lng = 0, "Sui seguenti file si |fffd| verificato un problema: ", "The following files returned some kind of error: ") & vbNewLine & vbNewLine
                
        For e = 1 To ErrorFiles.Count
            ResultSummary = ResultSummary & ErrorFiles(e) & vbNewLine
            ErrorString = ErrorString & ErrorFiles(e) & vbNewLine
        Next e
        
        Call UpdateErrorLog(ErrorString)
        
        ResultSummary = ResultSummary & vbNewLine
        ResultSummary = ResultSummary & IIf(lng = 0, "E' stato aggiornato il log degli errori: puoi consultarlo dal menu Impostazioni", "The error log was updated: You can find it on the Settings menu")
        
    End If
    MsgBox ResultSummary, IIf(ErrorFiles.Count = 0, vbInformation, vbExclamation), IIf(lng = 0, "Esito importazione", "Result summary")
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmImportPageSetup"
Attribute VB_Base = "0{E41BDD02-6A6C-400E-8DDB-EA8AB58D0027}{0ADFAD79-B0AD-4127-AE50-3C531EC94DFB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
              
    DisableEvents = True
        
    Call SaveOptions(Me)
    Me.cbxBaseFile = ActiveWorkbook.Name
    Me.cbxDestFile = ActiveWorkbook.Name
    Me.cbxBaseSheet = ActiveSheet.Name
    Call UpdateParams
    
    Call RefreshOpenFiles
    Call RefreshDestSheets
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
              
    Call GoodToGo(Me)
    
    DisableEvents = False

End Sub


Private Sub imgPrintPreview_Click()
    Dim TemplateSheet As Worksheet
    
    On Error Resume Next
    Set TemplateSheet = Workbooks(CStr(Me.cbxBaseFile)).Worksheets(CStr(Me.cbxBaseSheet))
    On Error GoTo 0
    
    If Not TemplateSheet Is Nothing Then
        Me.Hide
        Workbooks(CStr(Me.cbxBaseFile)).Activate
        TemplateSheet.Activate
        TemplateSheet.PrintPreview
        Me.Show
    End If
End Sub
Private Sub imgPrintPreview_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Me.imgPrintPreview.SpecialEffect = fmSpecialEffectSunken
End Sub

Private Sub imgPrintPreview_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Me.imgPrintPreview.SpecialEffect = fmSpecialEffectRaised
End Sub

Private Sub RefreshOpenFiles()
    Dim wb As Workbook
    Dim i As Long
    Dim CurrDestWb As String, CurrBaseWb As String
    
    DisableEvents = True
    
    CurrBaseWb = Me.cbxBaseFile.Value
    CurrDestWb = Me.cbxDestFile.Value
    
    Me.cbxBaseFile.Clear
    Me.cbxDestFile.Clear
       
    For Each wb In Workbooks
        If UCase(wb.Name) <> "PERSONAL.XLSB" Then
            Me.cbxBaseFile.AddItem wb.Name
            Me.cbxDestFile.AddItem wb.Name
        End If
    Next wb
       
    For i = 1 To Me.cbxBaseFile.ListCount - 1
        If Me.cbxBaseFile.List(i) = CurrBaseWb Then
            Me.cbxBaseFile.Value = CurrBaseWb
            Exit For
        End If
    Next i
    
    For i = 1 To Me.cbxDestFile.ListCount - 1
        If Me.cbxDestFile.List(i) = CurrDestWb Then
            Me.cbxDestFile.Value = CurrDestWb
            Exit For
        End If
    Next i
    
    If Me.cbxBaseFile <> CurrBaseWb Then Me.cbxBaseFile = ActiveWorkbook.Name
    If Me.cbxDestFile <> CurrDestWb Then Me.cbxDestFile = ActiveWorkbook.Name
       
    DisableEvents = False
       
End Sub
Private Sub cbxBaseFile_Change()
    Call RefreshBaseSheets
    Me.cbxBaseFile.ControlTipText = Me.cbxBaseFile.Text
End Sub
Private Sub RefreshBaseSheets()
    Me.cbxBaseSheet.Clear
    On Error Resume Next
        For Each ws In Workbooks(CStr(Me.cbxBaseFile)).Worksheets
            Me.cbxBaseSheet.AddItem ws.Name
        Next ws
        Me.cbxBaseSheet = Me.cbxBaseSheet.List(0)
    On Error GoTo 0
End Sub
Private Sub cbxDestFile_Change()
    Call RefreshDestSheets
    Me.cbxDestFile.ControlTipText = Me.cbxDestFile.Text
End Sub
Private Sub RefreshDestSheets()
    Dim i As Long
    
    DisableEvents = True
    
    Me.lbxDestSheet.Clear
    On Error Resume Next
        For Each ws In Workbooks(CStr(Me.cbxDestFile)).Worksheets
             Me.lbxDestSheet.AddItem ws.Name
        Next ws
                
        For i = 0 To Me.lbxDestSheet.ListCount - 1
            Me.lbxDestSheet.Selected(i) = True
        Next i
        
        If Me.cbxBaseFile = Me.cbxDestFile Then
            For i = 0 To Me.lbxDestSheet.ListCount - 1
                If Me.lbxDestSheet.List(i) = Me.cbxBaseSheet Then Me.lbxDestSheet.RemoveItem (i)
            Next i
        End If
    On Error GoTo 0
    
    DisableEvents = False
    
End Sub
Private Sub chkAllNoneDestSheets_Click()
    Dim i As Long
    
    DisableEvents = True
    
    For i = 0 To Me.lbxDestSheet.ListCount - 1
        Me.lbxDestSheet.Selected(i) = Me.chkAllNoneDestSheets
    Next i

    DisableEvents = False
    
    Call GoodToGo(Me)
    
End Sub
Private Sub cbxBaseSheet_Change()
    Dim i As Long

    Call RefreshDestSheets 'Rinnova l'elenco dei fogli di destinazione
    
    'Rimuove dall'elenco dei fogli di destinazione il foglio base selezionato, se sono sullo stesso file
    If Me.cbxBaseFile = Me.cbxDestFile Then
        For i = 0 To Me.lbxDestSheet.ListCount - 1
            If Me.lbxDestSheet.List(i) = Me.cbxBaseSheet Then
                Me.lbxDestSheet.RemoveItem (i)
                Exit For
            End If
        Next i
    End If
    
    Call UpdateParams
    Me.cbxBaseSheet.ControlTipText = Me.cbxBaseSheet.Text
End Sub
Private Sub UpdateParams()
    Const PtsToCm As Double = 0.0352778
    Dim TemplateSheet As Worksheet
    Dim psSize As String, psOr As String
    Dim psLM As Double, psRM As Double, psTM As Double, psBM As Double, psHM As Double, psFM As Double
    Dim psZoom As Variant
'    Dim psFitTall As Long, psFitWide As Long
'    Dim psLH As String, psCH As String, psRH As String, psLF As String, psCF As String, psRF As String
    Dim psPrintTitles As String
'    Dim psPrintArea As String
'    Dim psPrintHeadings As Boolean
'    Dim psPrintGridlines As Boolean
'    Dim psPrintComments As Long
'    Dim psPrintQuality As Variant
'    Dim psCenterHorizontally As Boolean
'    Dim psCenterVertically As Boolean
'    Dim psDraft As Boolean
'    Dim psFirstPageNumber As Long
'    Dim psOrder As Double
'    Dim psBlackAndWhite As Boolean
'    Dim psPrintErrors As Long
'    Dim psOddAndEvenPagesHeaderFooter As Boolean
'    Dim psDifferentFirstPageHeaderFooter As Boolean
'    Dim psScaleWithDocHeaderFooter As Boolean
'    Dim psAlignMarginsHeaderFooter As Boolean
'    Dim psEvenPageLeftHeaderText As String
'    Dim psEvenPageCenterHeaderText As String
'    Dim psEvenPageRightHeaderText As String
'    Dim psEvenPageLeftFooterText As String
'    Dim psEvenPageCenterFooterText As String
'    Dim psEvenPageRightFooterText As String
'    Dim psFirstPageLeftHeaderText As String
'    Dim psFirstPageCenterHeaderText As String
'    Dim psFirstPageRightHeaderText As String
'    Dim psFirstPageLeftFooterText As String
'    Dim psFirstPageCenterFooterText As String
'    Dim psFirstPageRightFooterText As String
    Dim BaseParams As String
    
    Call AutoCalc(False)
    
    On Error Resume Next
    
    Set TemplateSheet = Workbooks(CStr(Me.cbxBaseFile)).Worksheets(CStr(Me.cbxBaseSheet))
    With TemplateSheet.PageSetup
    
        'Margini
        psLM = .LeftMargin * PtsToCm
        psRM = .RightMargin * PtsToCm
        psTM = .TopMargin * PtsToCm
        psBM = .BottomMargin * PtsToCm
        psHM = .HeaderMargin * PtsToCm
        psFM = .FooterMargin * PtsToCm
'        psCenterHorizontally = .CenterHorizontally
'        psCenterVertically = .CenterVertically
        
        'Intestazione e piede pagina
'        psLH = .LeftHeader
'        psCH = .CenterHeader
'        psRH = .RightHeader
'        psLF = .LeftFooter
'        psCF = .CenterFooter
'        psRF = .RightFooter
'        psOddAndEvenPagesHeaderFooter = .OddAndEvenPagesHeaderFooter
'        psDifferentFirstPageHeaderFooter = .DifferentFirstPageHeaderFooter
'        psScaleWithDocHeaderFooter = .ScaleWithDocHeaderFooter
'        psAlignMarginsHeaderFooter = .AlignMarginsHeaderFooter
'        psEvenPageLeftHeaderText = .EvenPage.LeftHeader.Text
'        psEvenPageCenterHeaderText = .EvenPage.CenterHeader.Text
'        psEvenPageRightHeaderText = .EvenPage.RightHeader.Text
'        psEvenPageLeftFooterText = .EvenPage.LeftFooter.Text
'        psEvenPageCenterFooterText = .EvenPage.CenterFooter.Text
'        psEvenPageRightFooterText = .EvenPage.RightFooter.Text
'        psFirstPageLeftHeaderText = .FirstPage.LeftHeader.Text
'        psFirstPageCenterHeaderText = .FirstPage.CenterHeader.Text
'        psFirstPageRightHeaderText = .FirstPage.RightHeader.Text
'        psFirstPageLeftFooterText = .FirstPage.LeftFooter.Text
'        psFirstPageCenterFooterText = .FirstPage.CenterFooter.Text
'        psFirstPageRightFooterText = .FirstPage.RightFooter.Text
'        psOddAndEvenPagesHeaderFooter = .OddAndEvenPagesHeaderFooter
'        psDifferentFirstPageHeaderFooter = .DifferentFirstPageHeaderFooter
'        psScaleWithDocHeaderFooter = .ScaleWithDocHeaderFooter
'        psAlignMarginsHeaderFooter = .AlignMarginsHeaderFooter

        
        'Dimensioni pagina
        Select Case .PaperSize
            Case 8
                psSize = "A3"
            Case 9
                psSize = "A4"
            Case 11
                psSize = "A5"
            Case 70
                psSize = "A6"
            Case 13
                psSize = "B5 (JIS)"
            Case 1
                psSize = "Letter"
            Case 5
                psSize = "Legale"
            Case 14
                psSize = "Folio"
            Case 130
                psSize = "Cartolina 4x6"
            Case 12
                psSize = "B4"
            Case 34
                psSize = "B5 (ISO)"
            Case 3
                psSize = "Tabloid"
            Case 7
                psSize = "Executive"
            Case 190
                psSize = "Oficio"
            
            Case Else
                psSize = "Personalizzato"
        End Select
        
        'Orientamento pagina
        Select Case .Orientation
            Case 1
                psOr = "Verticale"
            Case 2
                psOr = "Orizzontale"
        End Select
        
        'Scala
        Select Case .Zoom
            Case False
                psZoom = "adatta a " & .FitToPagesTall & "(H) x " & .FitToPagesWide & "(L) pagine"
            Case Else
                psZoom = .Zoom & "%"
        End Select
        
        'Area di stampa
'        psPrintArea = .PrintArea
'
        'Righe e colonne da ripetere
        psPrintTitles = IIf(.PrintTitleRows = "", "-", .PrintTitleRows) & " / " & IIf(.PrintTitleColumns = "", "-", .PrintTitleColumns)
'        If psPrintTitles = "- / -" Then psPrintTitles = "Nessuna"
'
'
'        'Elementi visuali
'        psPrintHeadings = .PrintHeadings
'        psPrintGridlines = .PrintGridlines
'        psPrintComments = .PrintComments
'        psPrintQuality = .PrintQuality
'        psDraft = .Draft
'        psFirstPageNumber = .FirstPageNumber
'        psOrder = .Order
'        psBlackAndWhite = .BlackAndWhite
'        psPrintErrors = .PrintErrors
        
    End With

    BaseParams = "Parametri di stampa del foglio """ & TemplateSheet.Name & """:" & vbCrLf & vbCrLf
    BaseParams = BaseParams & "Formato pagina: " & vbTab & psSize & " | " & psOr & vbCrLf
    BaseParams = BaseParams & "Margini (A,D,B,S): " & vbTab & Format(psTM, "0.0") & " | " & Format(psRM, "0.0") & " | " & Format(psBM, "0.0") & " | " & Format(psLM, "0.0") & vbCrLf
    BaseParams = BaseParams & "Zoom: " & vbTab & vbTab & psZoom & vbCrLf
    BaseParams = BaseParams & "R/C da ripetere: " & vbTab & psPrintTitles
    
    Me.txtParams = BaseParams
    
    On Error GoTo 0
    
    Call AutoCalc(True)
    
End Sub

Private Sub chkAll_change()
    Dim ctl As control
    
    For Each ctl In Me.Controls
        If ctl.Tag = "subgroup" Then
            If Me.chkAll Then
                ctl.Enabled = False
                ctl.Value = True
            Else
                ctl.Enabled = True
            End If
        End If
    Next ctl
End Sub
Private Sub chkHeader_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkHeader = True Then
        Me.chkLeftHeader = False
        Me.chkCenterHeader = False
        Me.chkRightHeader = False
    Else
        Me.chkLeftHeader = True
        Me.chkCenterHeader = True
        Me.chkRightHeader = True
    End If
End Sub
Private Sub chkFooter_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkFooter = True Then
        Me.chkLeftFooter = False
        Me.chkCenterFooter = False
        Me.chkRightFooter = False
    Else
        Me.chkLeftFooter = True
        Me.chkCenterFooter = True
        Me.chkRightFooter = True
    End If
End Sub
Private Sub chkLeftHeader_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkLeftHeader = True Then
        If Me.chkCenterHeader = False And Me.chkRightHeader = False Then
            Me.chkHeader = False
        End If
    ElseIf Me.chkHeader = False Then
         Me.chkHeader = True
    End If
End Sub
Private Sub chkCenterHeader_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkCenterHeader = True Then
        If Me.chkLeftHeader = False And Me.chkRightHeader = False Then
            Me.chkHeader = False
        End If
    ElseIf Me.chkHeader = False Then
        Me.chkHeader = True
    End If
End Sub
Private Sub chkRightHeader_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkRightHeader = True Then
        If Me.chkCenterHeader = False And Me.chkLeftHeader = False Then
            Me.chkHeader = False
        End If
    ElseIf Me.chkHeader = False Then
        Me.chkHeader = True
    End If
End Sub
Private Sub chkLeftFooter_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkLeftFooter = True Then
        If Me.chkCenterFooter = False And Me.chkRightFooter = False Then
            Me.chkFooter = False
        End If
    ElseIf Me.chkFooter = False Then
        Me.chkFooter = True
    End If
End Sub
Private Sub chkCenterFooter_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkCenterFooter = True Then
        If Me.chkLeftFooter = False And Me.chkRightFooter = False Then
            Me.chkFooter = False
        End If
    ElseIf Me.chkFooter = False Then
        Me.chkFooter = True
    End If
End Sub
Private Sub chkRightFooter_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.chkRightFooter = True Then
        If Me.chkCenterFooter = False And Me.chkLeftFooter = False Then
            Me.chkFooter = False
        End If
    ElseIf Me.chkFooter = False Then
        Me.chkFooter = True
    End If
End Sub

Private Sub cmdTemplate_Click()
    Dim CurrWb As Workbook
    Dim FileName As Variant
    Dim TemplateFile As Workbook
    
    Set CurrWb = ActiveWorkbook
        
    FileName = OpenDialog(Me.txtPath, , IIf(lng = 0, "Seleziona il file modello", "Select template file"), False)
    
    If FileName = False Then Exit Sub
    
    On Error Resume Next
        Me.txtPath = Replace(FileName, Dir(FileName), "")

        Set TemplateFile = Workbooks(FullPathToWBName(FileName, True))
        If Err.Number > 0 Then
            Err.Clear
            Set TemplateFile = Workbooks.Open(FileName, 0)
        End If
    On Error Resume Next
    
    Call RefreshOpenFiles
            
    Me.cbxBaseFile = TemplateFile.Name
    
    CurrWb.Activate

End Sub

Private Sub lbxDestSheet_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim i As Long
    Dim TemplateFile As Workbook
    Dim TemplateName As String
    Dim TemplateSheet As Worksheet
    Dim TargetFile As Workbook
    Dim TargetName As String
    Dim psLM As Double, psRM As Double, psTM As Double, psBM As Double, psHM As Double, psFM As Double, psSize As Double, psOr As Double
    Dim psZoom As Variant
    Dim psFitTall As Long, psFitWide As Long
    Dim psLH As String, psCH As String, psRH As String, psLF As String, psCF As String, psRF As String
    Dim psPrintTitleRows As String
    Dim psPrintTitleColumns As String
    Dim psPrintArea As String
    Dim psPrintHeadings As Boolean
    Dim psPrintGridlines As Boolean
    Dim psPrintComments As Long
'    Dim psPrintQuality As Variant
    Dim psCenterHorizontally As Boolean
    Dim psCenterVertically As Boolean
'    Dim psDraft As Boolean
'    Dim psFirstPageNumber As Long
'    Dim psOrder As Double
'    Dim psBlackAndWhite As Boolean
'    Dim psPrintErrors As Long
    Dim psOddAndEvenPagesHeaderFooter As Boolean
    Dim psDifferentFirstPageHeaderFooter As Boolean
    Dim psScaleWithDocHeaderFooter As Boolean
    Dim psAlignMarginsHeaderFooter As Boolean
    Dim psEvenPageLeftHeaderText As String
    Dim psEvenPageCenterHeaderText As String
    Dim psEvenPageRightHeaderText As String
    Dim psEvenPageLeftFooterText As String
    Dim psEvenPageCenterFooterText As String
    Dim psEvenPageRightFooterText As String
    Dim psFirstPageLeftHeaderText As String
    Dim psFirstPageCenterHeaderText As String
    Dim psFirstPageRightHeaderText As String
    Dim psFirstPageLeftFooterText As String
    Dim psFirstPageCenterFooterText As String
    Dim psFirstPageRightFooterText As String

    Me.Hide
    
    Call AutoCalc(False)
    
    
    
    'Sets Template file and sheet
    TemplateName = Me.cbxBaseFile
    On Error Resume Next
    Err.Clear
    Set TemplateFile = Workbooks(TemplateName)
    If Err.Number > 0 Then
        Err.Clear
        MsgBox IIf(lng = 0, "Il file modello deve essere aperto", "Template file must be opened"), vbExclamation
        Exit Sub
    End If
    Set TemplateSheet = TemplateFile.Worksheets(CStr(Me.cbxBaseSheet.Value))
    If Err.Number > 0 Then
        Err.Clear
        MsgBox IIf(lng = 0, "Foglio modello non valido", "Invalid template sheet"), vbCritical
        Exit Sub
    End If
    On Error GoTo Aborted
    
    'Sets target file
    TargetName = Me.cbxDestFile
    On Error Resume Next
    Err.Clear
    Set TargetFile = Workbooks(TargetName)
    If Err.Number > 0 Then
        MsgBox IIf(lng = 0, "Il file di destinazione deve essere aperto", "Destination file must be opened"), vbExclamation
        Exit Sub
    End If
    On Error GoTo Aborted
    
    Application.PrintCommunication = False

    With TemplateSheet.PageSetup
    
        'Margini
        psLM = .LeftMargin
        psRM = .RightMargin
        psTM = .TopMargin
        psBM = .BottomMargin
        psHM = .HeaderMargin
        psFM = .FooterMargin
        psCenterHorizontally = .CenterHorizontally
        psCenterVertically = .CenterVertically
        
        'Intestazione e piede pagina
        psLH = .LeftHeader
        psCH = .CenterHeader
        psRH = .RightHeader
        psLF = .LeftFooter
        psCF = .CenterFooter
        psRF = .RightFooter
        psOddAndEvenPagesHeaderFooter = .OddAndEvenPagesHeaderFooter
        psDifferentFirstPageHeaderFooter = .DifferentFirstPageHeaderFooter
        psScaleWithDocHeaderFooter = .ScaleWithDocHeaderFooter
        psAlignMarginsHeaderFooter = .AlignMarginsHeaderFooter
        psEvenPageLeftHeaderText = .EvenPage.LeftHeader.Text
        psEvenPageCenterHeaderText = .EvenPage.CenterHeader.Text
        psEvenPageRightHeaderText = .EvenPage.RightHeader.Text
        psEvenPageLeftFooterText = .EvenPage.LeftFooter.Text
        psEvenPageCenterFooterText = .EvenPage.CenterFooter.Text
        psEvenPageRightFooterText = .EvenPage.RightFooter.Text
        psFirstPageLeftHeaderText = .FirstPage.LeftHeader.Text
        psFirstPageCenterHeaderText = .FirstPage.CenterHeader.Text
        psFirstPageRightHeaderText = .FirstPage.RightHeader.Text
        psFirstPageLeftFooterText = .FirstPage.LeftFooter.Text
        psFirstPageCenterFooterText = .FirstPage.CenterFooter.Text
        psFirstPageRightFooterText = .FirstPage.RightFooter.Text
        psOddAndEvenPagesHeaderFooter = .OddAndEvenPagesHeaderFooter
        psDifferentFirstPageHeaderFooter = .DifferentFirstPageHeaderFooter
        psScaleWithDocHeaderFooter = .ScaleWithDocHeaderFooter
        psAlignMarginsHeaderFooter = .AlignMarginsHeaderFooter

        
        'Dimensioni pagina
        psSize = .PaperSize
        
        'Orientamento pagina
        psOr = .Orientation
        
        'Scala
        psZoom = .Zoom
        psFitTall = .FitToPagesTall
        psFitWide = .FitToPagesWide
        
        'Area di stampa
        psPrintArea = .PrintArea
        
        'Righe e colonne da ripetere
        psPrintTitleRows = .PrintTitleRows
        psPrintTitleColumns = .PrintTitleColumns

        'Elementi visuali
        psPrintHeadings = .PrintHeadings
        psPrintGridlines = .PrintGridlines
        psPrintComments = .PrintComments
        
        'Altro

    End With
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.lbxDestSheet.ListCount
    UProgress.SetDescription "Sto importando le impostazioni..."
    Call ShowProgressBar
    
    For i = 0 To Me.lbxDestSheet.ListCount - 1
        
        'Aumenta di 1 il contatore
        counter = counter + 1
        UProgress.SetDescription "Sto importando le impostazioni... (" & TargetFile.Worksheets(Me.lbxDestSheet.List(i)).Name & ")"
        
        If Me.lbxDestSheet.Selected(i) = True Then
        
            With TargetFile.Worksheets(Me.lbxDestSheet.List(i)).PageSetup
            
                If Me.chkMargins Then
                    .LeftMargin = psLM
                    .RightMargin = psRM
                    .TopMargin = psTM
                    .BottomMargin = psBM
                    .HeaderMargin = psHM
                    .FooterMargin = psFM
    '                .CenterHorizontally = psCenterHorizontally
    '                .CenterVertically = psCenterVertically
                End If
                
                If Me.chkHeader Then
                    If Me.chkLeftHeader Then
                        .LeftHeader = psLH
                        .EvenPage.LeftHeader.Text = psEvenPageLeftHeaderText
                        .FirstPage.LeftHeader.Text = psFirstPageLeftHeaderText
                    End If
                    If Me.chkCenterHeader Then
                        .CenterHeader = psCH
                        .EvenPage.CenterHeader.Text = psEvenPageCenterHeaderText
                        .FirstPage.CenterHeader.Text = psFirstPageCenterHeaderText
                    End If
                    If Me.chkRightHeader Then
                        .RightHeader = psRH
                        .EvenPage.RightHeader.Text = psEvenPageRightHeaderText
                        .FirstPage.RightHeader.Text = psFirstPageRightHeaderText
                    End If
                    .OddAndEvenPagesHeaderFooter = psOddAndEvenPagesHeaderFooter
                    .DifferentFirstPageHeaderFooter = psDifferentFirstPageHeaderFooter
                    .ScaleWithDocHeaderFooter = psScaleWithDocHeaderFooter
                    .AlignMarginsHeaderFooter = psAlignMarginsHeaderFooter
    
                End If
                
                If Me.chkFooter Then
                    If Me.chkLeftFooter Then
                        .LeftFooter = psLF
                        .EvenPage.LeftFooter.Text = psEvenPageLeftFooterText
                        .FirstPage.LeftFooter.Text = psFirstPageLeftFooterText
                    End If
                    If Me.chkCenterFooter Then
                        .CenterFooter = psCF
                        .EvenPage.CenterFooter.Text = psEvenPageCenterFooterText
                        .FirstPage.CenterFooter.Text = psFirstPageCenterFooterText
                    End If
                    If Me.chkRightFooter Then
                        .RightFooter = psRF
                        .EvenPage.RightFooter.Text = psEvenPageRightFooterText
                        .FirstPage.RightFooter.Text = psFirstPageRightFooterText
                    End If
                    .DifferentFirstPageHeaderFooter = psDifferentFirstPageHeaderFooter
                    .ScaleWithDocHeaderFooter = psScaleWithDocHeaderFooter
                    .AlignMarginsHeaderFooter = psAlignMarginsHeaderFooter
                End If
                
                If Me.chkSize Then
                    .PaperSize = psSize
                End If
                
                If Me.chkOrientation Then
                    .Orientation = psOr
                End If
                
                On Error Resume Next
                If Me.chkScale Then
                    If psZoom <> False Then
                        .Zoom = psZoom
                    Else
                        .FitToPagesTall = psFitTall
                        .FitToPagesWide = psFitWide
                    End If
                End If
                On Error GoTo Aborted
                
                If Me.chkVisual Then
                    .PrintHeadings = psPrintHeadings
                    .PrintGridlines = psPrintGridlines
                    .PrintComments = psPrintComments
                End If
                
                If Me.chkPrintArea Then
                    .PrintArea = psPrintArea
                End If
                
                If Me.chkRepeat Then
                    .PrintTitleRows = psPrintTitleRows
                    .PrintTitleColumns = psPrintTitleColumns
                End If
                
            End With
                
        End If
                
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        DoEvents
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
        
    Next i
    
    'Chiude la finestra di avanzamento
    Unload UProgress
    
    Application.PrintCommunication = True
    
    Call AutoCalc(True)
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmInsertColumns"
Attribute VB_Base = "0{18D3B16A-0780-4CA9-8737-FDB730FEB7F4}{745EA10C-8A98-4412-990B-DBFF454701D4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange.Text = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    Call PopulateRowList

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
    Call PopulateRowList
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
    Call PopulateRowList
End Sub


Private Sub spbNColumns_SpinDown()
    Me.txtNColumns = Me.spbNColumns
End Sub

Private Sub spbNColumns_SpinUp()
    Me.txtNColumns = Me.spbNColumns
End Sub

Private Sub txtNColumns_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNColumns_Change()
    If Val(Me.txtNColumns) > Me.spbNColumns.Max Then Me.txtNColumns = Me.spbNColumns.Max
    If Val(Me.txtNColumns) < Me.spbNColumns.Min Then Me.txtNColumns = Me.spbNColumns.Min
    Me.spbNColumns = Me.txtNColumns
End Sub

Private Sub spbEveryNCols_SpinDown()
    Me.txtEveryNCols = Me.spbEveryNCols
End Sub

Private Sub spbEveryNCols_SpinUp()
    Me.txtEveryNCols = Me.spbEveryNCols
End Sub
Private Sub txtEveryNCols_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtEveryNCols_Change()
    If Val(Me.txtEveryNCols) > Me.spbEveryNCols.Max Then Me.txtEveryNCols = Me.spbEveryNCols.Max
    If Val(Me.txtEveryNCols) < Me.spbEveryNCols.Min Then Me.txtEveryNCols = Me.spbEveryNCols.Min
    Me.spbEveryNCols = Me.txtEveryNCols
End Sub

Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
End Sub

Private Sub optEveryNCols_Change()
    Me.txtEveryNCols.Enabled = Me.optEveryNCols
    Me.spbEveryNCols.Enabled = Me.optEveryNCols
    Me.cbxFilterRow.Enabled = Not Me.optEveryNCols
End Sub

Private Sub PopulateRowList()
    Dim cRng As Range
    Dim i As Long
    
    Me.cbxFilterRow.Clear
    
    On Error Resume Next
    Set cRng = RangeResize(ActiveSheet.Range(Me.refRange), ActiveSheet)
    
    With cRng
        If Application.WorksheetFunction.CountA(.Columns(1)) > 0 Then
            For i = 1 To .Rows.Count
                Me.cbxFilterRow.AddItem ExtractRowNumber(.Cells(i, 1).address) & IIf(.Cells(i, 1) <> "", " (" & .Cells(i, 1) & ")", " (" & .Cells(i, 1).End(xlToRight) & ")")
            Next i
        Else
            For i = 1 To .Rows.Count
                Me.cbxFilterRow.AddItem ExtractRowNumber(.Cells(i, 1).address) & " (Riga " & ExtractRowNumber(.Cells(i, 1).address) & ")"
            Next i
        End If
    End With
    
    If Me.cbxFilterRow = "" Then Me.cbxFilterRow.ListIndex = 0
    On Error GoTo 0
    
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim n As Long
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim FilterRow As Long
    Dim ucGroup As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide

    
    End With
    
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted

    Set InRng = RangeResize(ActiveSheet.Range(Replace(Me.refRange, ";", ",")), ActiveSheet)
    
    n = Me.txtNColumns
    FRow = InRng.Row
    LRow = InRng.Rows.Count
    fCol = InRng.Column
    LCol = InRng.Columns.Count
    FilterRow = RowItemToNumber(Me.cbxFilterRow.Text) - FRow + 1
        
    
    With InRng
        
        If Me.optEveryNCols = True Then
            
            'Imposto la posizione iniziale di inserimento colonne
            j = 1 + Me.txtHeader + Me.txtEveryNCols
                               
            Do
                               
                For k = 1 To n
                    .Cells(1, j).EntireColumn.Insert
                Next k
                
                If Me.chkSubT = True Then
                    .Cells(1, j) = "Subtotale"
                    For i = 2 To LRow
                        On Error Resume Next
                        .Cells(i, j) = Application.WorksheetFunction.Sum(Range(.Cells(i, j - Me.txtEveryNCols), .Cells(i, j - 1)))
                        On Error GoTo Aborted
                    Next i
                End If
                    
                j = j + Me.txtEveryNCols + n
                LCol = LCol + n
            
            Loop Until j > LCol
        
            'Scrivo l'ultimo subtotale
            If Me.chkSubT = True Then
                .Cells(1, LCol + 1) = "Subtotale"
                For i = 2 To LCol
                    On Error Resume Next
                    .Cells(i, LCol + 1) = Application.WorksheetFunction.Sum(Range(.Cells(i, j - Me.txtEveryNCols), .Cells(i, LCol)))
                    On Error GoTo Aborted
                Next i
            End If
        
        ElseIf Me.optFilterRow = True Then
        
            For j = LCol + 1 To Me.txtHeader + 2 Step -1
               
               If .Cells(FilterRow, j) <> .Cells(FilterRow, j - 1) Then
                   
                   For k = 1 To n
                       .Cells(1, j).EntireColumn.Insert
                   Next k
                   
                   If Me.chkSubT = True Then
                       .Cells(1, j) = "Totale " & .Cells(FilterRow, j - 1)
                       LCol = LCol + n
                   End If
               End If
            Next j
        
            'Genero i subtotali ripercorrendo le righe inserite dall'inizio alla fine
            If Me.chkSubT = True Then
                ucGroup = 1
                For j = Me.txtHeader + 2 To LCol + 1
                    If .Cells(FilterRow, j) <> .Cells(FilterRow, j - 1) And .Cells(FilterRow, j) = "Totale " & .Cells(FilterRow, j - 1) Then
                        For i = 2 To LRow
                            If i <> FilterRow Then
                                .Cells(i, j) = Application.WorksheetFunction.SumIf(Range(.Cells(FilterRow, ucGroup), _
                                    .Cells(FilterRow, j - 1)), .Cells(FilterRow, j - 1).Value, Range(.Cells(i, ucGroup), .Cells(i, j - 1)))
                            End If
                        Next i
                        ucGroup = j + n
                    End If
                Next j
            End If
        
        End If
        
    End With
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmInsertRows"
Attribute VB_Base = "0{0735AF45-F4BF-4AD9-BFDE-C431400E4B34}{F7B8C9AC-FE04-4D98-802B-E3F2A467EE36}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange.Text = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
        Call ListColumns(Range(Me.refRange), Me.cbxColNRows, Me.txtHeader > 0)
        Call ListColumns(Range(Me.refRange), Me.cbxFilterCol, Me.txtHeader > 0)
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    Call ListColumns(Range(Me.refRange), Me.cbxColNRows, Me.txtHeader > 0)
    Call ListColumns(Range(Me.refRange), Me.cbxFilterCol, Me.txtHeader > 0)
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
    Call ListColumns(Range(Me.refRange), Me.cbxColNRows, Me.txtHeader > 0)
    Call ListColumns(Range(Me.refRange), Me.cbxFilterCol, Me.txtHeader > 0)
End Sub

Private Sub optColNRows_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraWhereToInsert.Controls
        ctl.Enabled = Not (Me.optColNRows)
    Next ctl
    
    Me.chkSubT.Enabled = Not (Me.optColNRows)
    Me.cbxColNRows.Enabled = Me.optColNRows
    Me.txtNRows.Enabled = Not (Me.optColNRows)
    Me.spbNRows.Enabled = Not (Me.optColNRows)
    
End Sub

Private Sub spbNRows_SpinDown()
    Me.txtNRows = Me.spbNRows
End Sub

Private Sub spbNRows_SpinUp()
    Me.txtNRows = Me.spbNRows
End Sub
Private Sub txtNRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNRows_Change()
    If Val(Me.txtNRows) > Me.spbNRows.Max Then Me.txtNRows = Me.spbNRows.Max
    If Val(Me.txtNRows) < Me.spbNRows.Min Then Me.txtNRows = Me.spbNRows.Min
    Me.spbNRows = Me.txtNRows
End Sub

Private Sub spbEveryNRows_SpinDown()
    Me.txtEveryNRows = Me.spbEveryNRows
End Sub

Private Sub spbEveryNRows_SpinUp()
    Me.txtEveryNRows = Me.spbEveryNRows
End Sub
Private Sub txtEveryNRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtEveryNRows_Change()
    If Val(Me.txtEveryNRows) > Me.spbEveryNRows.Max Then Me.txtEveryNRows = Me.spbEveryNRows.Max
    If Val(Me.txtEveryNRows) < Me.spbEveryNRows.Min Then Me.txtEveryNRows = Me.spbEveryNRows.Min
    Me.spbEveryNRows = Me.txtEveryNRows
End Sub

Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
    On Error Resume Next
    Call ListColumns(Range(Me.refRange), Me.cbxColNRows, Me.txtHeader > 0)
    Call ListColumns(Range(Me.refRange), Me.cbxFilterCol, Me.txtHeader > 0)
    On Error GoTo 0
End Sub

Private Sub optEveryNRows_Change()
    Me.txtEveryNRows.Enabled = Me.optEveryNRows
    Me.spbEveryNRows.Enabled = Me.optEveryNRows
    Me.cbxFilterCol.Enabled = Not Me.optEveryNRows
End Sub

Private Sub chkFill_Change()
    If Me.chkFill = True Then Me.chkSubT = False
End Sub

Private Sub chkSubT_Change()
    If Me.chkSubT = True Then Me.chkFill = False
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim n As Long
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim FilterCol As Long
    Dim urGroup As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide

    End With
    
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted

    Set InRng = RangeResize(ActiveSheet.Range(Replace(Me.refRange, ";", ",")), ActiveSheet)
    
    FRow = InRng.Row
    LRow = InRng.Rows.Count
    fCol = InRng.Column
    LCol = InRng.Columns.Count
    FilterCol = ColItemToNumber(Me.cbxFilterCol.Text) - fCol + 1
    
    With InRng
             
        If Me.optFixed = True Then
        
            n = Me.txtNRows
            
            If Me.optEveryNRows = True Then
                
                'Imposto la posizione iniziale di inserimento righe
                i = 1 + Me.txtHeader + Me.txtEveryNRows
                                   
                Do
                                   
                    For k = 1 To n
                        .Cells(i, 1).EntireRow.Insert
                    Next k
                    
                    If Me.chkSubT = True Then
                        .Cells(i, 1) = "Subtotale"
                        For j = 2 To LCol
                            On Error Resume Next
                            .Cells(i, j) = Application.WorksheetFunction.Sum(Range(.Cells(i - Me.txtEveryNRows, j), .Cells(i - 1, j)))
                            On Error GoTo Aborted
                        Next j
                    ElseIf Me.chkFill = True Then
                        Range(.Cells(i - 1, 1), .Cells(i + n - 1, LCol)).FillDown
                    End If
                        
                    i = i + Me.txtEveryNRows + n
                    LRow = LRow + n
                
                Loop Until i > LRow
                
                'Scrivo l'ultimo subtotale o riempimento
                If Me.chkSubT = True Then
                    .Cells(LRow + 1, 1) = "Subtotale"
                    For j = 2 To LCol
                        On Error Resume Next
                        .Cells(LRow + 1, j) = Application.WorksheetFunction.Sum(Range(.Cells(i - Me.txtEveryNRows, j), .Cells(LRow, j)))
                        On Error GoTo Aborted
                    Next j
                ElseIf Me.chkFill = True Then
                    If i = LRow + 1 Then 'solo se l'ultima riga sarebbe stata quella da replicare
                        Range(.Cells(LRow, 1), .Cells(LRow + n, LCol)).FillDown
                    End If
                End If
            
            ElseIf Me.optFilterCol = True Then
            
                For i = LRow + 1 To Me.txtHeader + 2 Step -1
                   
                   If .Cells(i, FilterCol) <> .Cells(i - 1, FilterCol) Then
                       
                       For k = 1 To n
                           .Cells(i, 1).EntireRow.Insert
                       Next k
                       
                       If Me.chkSubT = True Then
                           .Cells(i, 1) = "Totale " & .Cells(i - 1, FilterCol)
                           LRow = LRow + n
                       End If
                   End If
                Next i
            
                'Genero i subtotali ripercorrendo le righe inserite dall'inizio alla fine
                If Me.chkSubT = True Then
                    urGroup = 1
                    For i = Me.txtHeader + 2 To LRow + 1
                        If .Cells(i, FilterCol) <> .Cells(i - 1, FilterCol) And .Cells(i, 1) = "Totale " & .Cells(i - 1, FilterCol) Then
                            For j = 2 To LCol
                                If j <> FilterCol Then
                                    .Cells(i, j) = Application.WorksheetFunction.SumIf(Range(.Cells(urGroup, FilterCol), _
                                        .Cells(i - 1, FilterCol)), .Cells(i - 1, FilterCol).Value, Range(.Cells(urGroup, j), .Cells(i - 1, j)))
                                End If
                            Next j
                            urGroup = i + n
                        End If
                    Next i
                End If
                
            End If
                
        Else    'Inserire un numero di righe definito in una colonna
            
            For i = LRow To Me.txtHeader + 1 Step -1
                
                n = .Cells(i, ColItemToNumber(Me.cbxColNRows) - fCol + 1).Value - Abs(CInt(Me.chkMinusOne))
                
                If n > 0 Then
                    For k = 1 To n
                        .Cells(i + 1, 1).EntireRow.Insert
                    Next k
                    
                    'Riempio le righe vuote
                    If Me.chkFill = True Then
                        Range(.Cells(i, 1), .Cells(i + n, LCol)).FillDown
                    End If
                End If
                
                LRow = LRow + n
            Next i
        
        End If
        
    End With
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmJoinColumns"
Attribute VB_Base = "0{60022357-CE7B-4991-87F5-BD0984D01293}{DD36D599-53B7-440E-AEFE-71B1E83C11A1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange.Text = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub cmdNewLine_Click()
    Me.txtDelim = Me.txtDelim & "{CR}"
End Sub
    
Private Sub optEmpty_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optDelete_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optNothing_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim i As Long, j As Long
    Dim result As Variant
    Dim delim As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide
        
        delim = Replace(.txtDelim, "{CR}", vbNewLine)
    
    End With
    
    Call AutoCalc(False)
    
    
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    Set ws = ActiveSheet
        
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Rows.Count
        UProgress.SetDescription "Unione colonne in corso... (" & ws.Name & ")"
        Call ShowProgressBar
        
        With InRng
            LRow = .Rows.Count
            LCol = .Columns.Count
    
            For i = 1 To LRow
                
                '#' Aumento di 1 il contatore
                counter = counter + 1
    
                For j = 1 To LCol
                    If .Rows(i).RowHeight > -1 - Me.chkIgnoreHidden And .Columns(j).ColumnWidth > -1 - Me.chkIgnoreHidden Then
                        If .Cells(i, j) = "" And Me.chkEmptyCells Then
                            result = result
                        Else
                            result = result & .Cells(i, j) & delim
                        End If
                    End If
                Next j
                
                If Len(result) > 0 Then .Cells(i, 1) = Left(result, Len(result) - Len(delim))
                result = ""
                If .Rows(i).RowHeight > -1 - Me.chkIgnoreHidden And Me.optEmpty Then
                    For j = 2 To LCol
                        If .Columns(j).ColumnWidth > -1 - Me.chkIgnoreHidden Then .Cells(i, j) = ""
                    Next j
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted

            Next i
            If Me.optDelete Then
                .Range(Cells(1, 2), Cells(1, LCol)).EntireColumn.Delete
            End If
            
            '#' Chiudo la finestra di avanzamento
            Unload UProgress
            
        End With

    End If
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmJoinFiles"
Attribute VB_Base = "0{DB6DB673-C24E-4268-A575-DF67D37B5CEF}{00259802-3ADD-40CC-BB2B-8D63DFAAC496}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim CurrWb As Workbook
Dim CurrWs As Worksheet
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
        
    Set CurrWb = ActiveWorkbook
    Set CurrWs = ActiveSheet
            
    DisableEvents = True
    Call RefreshOpenFiles
    Call ListColumns(ActiveSheet.Range("A1:" & findlastcell(ActiveSheet.Cells).address), Me.cbxBaseSheetKey1, Me.chkHeader)
    Call UpdateNewKey
    DisableEvents = False
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
        
    Call GoodToGo(Me)

End Sub

Private Sub RefreshOpenFiles()
'Aggiorno la combo dei file aperti
    
    Dim wb As Workbook
    Dim i As Long
    Dim CurrDestWb As String
        
    DisableEvents = True
    
    CurrDestWb = Me.cbxNewFile.Text
    
    Me.cbxNewFile.Clear
       
    For Each wb In Workbooks
        If UCase(wb.Name) <> "PERSONAL.XLSB" Then
            Me.cbxNewFile.AddItem wb.Name
        End If
    Next wb
    
    DisableEvents = False
    
    For i = 0 To Me.cbxNewFile.ListCount - 1
        If Me.cbxNewFile.List(i) = CurrDestWb Then
            Me.cbxNewFile.Value = CurrDestWb
            Exit For
        End If
    Next i
    
    DisableEvents = True
    
    Call SortListCombobox(Me.cbxNewFile)
    
    DisableEvents = False
    
    On Error Resume Next 'Previene un errore generato su sistemi Mac
    If Me.cbxNewFile = "" Or Me.cbxNewFile <> CurrDestWb Then
        Me.cbxNewFile = ActiveWorkbook.Name
    End If
    On Error GoTo 0
    
End Sub
Private Sub cbxNewFile_Change()
'Modifico la combo del nuovo file da unire
'Azioni conseguenti:
  '1) Popolo la combobox dei fogli del nuovo file
    
    If DisableEvents = True Then Exit Sub
        
    DisableEvents = True
    Call RefreshNewFileSheets
    Me.cbxNewFile.ControlTipText = Me.cbxNewFile.Text
    DisableEvents = False
    
    Call GoodToGo(Me)
    
End Sub
Private Sub RefreshNewFileSheets()
    Me.cbxNewFileSheet.Clear
    
    DisableEvents = True
    On Error Resume Next
    
    'Popolo la combobox dei fogli di lavoro
    For Each ws In Workbooks(CStr(Me.cbxNewFile)).Worksheets
        If Not (Workbooks(CStr(Me.cbxNewFile)).Name = CurrWb.Name And ws.Name = CurrWs.Name) Then
            Me.cbxNewFileSheet.AddItem ws.Name
        End If
    Next ws
    DisableEvents = False
                
    Me.cbxNewFileSheet = Me.cbxNewFileSheet.List(0) 'Innesco cbxNewFileSheet_Change()
    On Error GoTo 0
        
End Sub

Private Sub cbxNewFileSheet_Change()
'Cambio la combobox del foglio da unire
'Azioni conseguenti:
  '1) Popolo la listbox delle colonne da importare
  '2) Popolo la combobox delle colonne chiave del file da unire
  '3) Sincronizzo le combobox delle pagine successive

    If DisableEvents = True Then Exit Sub
    
    On Error Resume Next
        'Popolo la listbox delle colonne da importare e la combobox delle colonne chiave
        With Workbooks(Me.cbxNewFile.Text).Worksheets(Me.cbxNewFileSheet.Text)
            Call ListColumns(.Range("A1:" & findlastcell(.Cells).address), Me.cbxNewSheetKey1, Me.chkHeader)
            Call ListColumns(.Range("A1:" & findlastcell(.Cells).address), Me.lbxNewFileCols, Me.chkHeader, Me.txtFilterList.Text)
        End With
    On Error GoTo 0
    
    Me.cbxNewFileSheet.ControlTipText = Me.cbxNewFileSheet.Text
    
    Call SyncNewKey
    
    Call GoodToGo(Me)
End Sub

Private Sub cbxNewSheetKey1_Change()
    Me.cbxNewSheetKey1.ControlTipText = Me.cbxNewSheetKey1.Text
End Sub

Private Sub txtFilterList_Change()
    With Workbooks(Me.cbxNewFile.Text).Worksheets(Me.cbxNewFileSheet.Text)
        Call ListColumns(.Range("A1:" & findlastcell(.Cells).address), Me.lbxNewFileCols, Me.chkHeader, Me.txtFilterList.Text)
    End With
End Sub

Private Sub chkHeader_Click()
    Dim CurrBaseSelection As Long
    Dim CurrNewSelection As Long
    Dim i As Long
    
    
    For i = 0 To Me.mpgCriteria.Pages.Count - 1
        'Salvo la voce selezionata in una variabile
        CurrBaseSelection = Me.mpgCriteria.Pages(i).Controls("cbxBaseSheetKey" & i + 1).ListIndex
        CurrNewSelection = Me.mpgCriteria.Pages(i).Controls("cbxNewSheetKey" & i + 1).ListIndex
        
        'Switcho le intestazioni
        Call SwitchHeaders(ActiveSheet.Range("A1:" & findlastcell(ActiveSheet.Cells).address), Me.mpgCriteria.Pages(i).Controls("cbxBaseSheetKey" & i + 1), Me.chkHeader)
        Call SwitchHeaders(Workbooks(Me.cbxNewFile.Text).Worksheets(Me.cbxNewFileSheet.Text).Range("A1:" & findlastcell(Workbooks(Me.cbxNewFile.Text).Worksheets(Me.cbxNewFileSheet.Text).Cells).address), Me.mpgCriteria.Pages(i).Controls("cbxNewSheetKey" & i + 1), Me.chkHeader)
        
        'Riseleziono la voce precedente
        Me.mpgCriteria.Pages(i).Controls("cbxBaseSheetKey" & i + 1).ListIndex = CurrBaseSelection
        Me.mpgCriteria.Pages(i).Controls("cbxNewSheetKey" & i + 1).ListIndex = CurrNewSelection
        
    Next i
        
End Sub

Private Sub SyncNewKey()
    Dim i As Long
    Dim c As Long
    Dim ctlNew As control

    For i = 1 To Me.mpgCriteria.Pages.Count - 1
        For c = 0 To Me.mpgCriteria.Pages(i).Controls.Count - 1
            If Me.mpgCriteria.Pages(i).Controls(c).Name Like "cbxNewSheetKey*" Then Set ctlNew = Me.mpgCriteria.Pages(i).Controls(c)
        Next c
        
        ctlNew.Clear
        ctlNew.List = Me.cbxNewSheetKey1.List
        On Error Resume Next
        If ctlNew.ListIndex = -1 Then ctlNew.ListIndex = 0
        On Error GoTo 0
    Next i
    
    Call UpdateNewKey
End Sub

Sub UpdateNewKey(Optional pagindex As Long = -1)
    Dim i As Long
    Dim c As Long
    Dim ctlBase As control
    Dim ctlNew As control
    
    On Error Resume Next
    
    If pagindex = -1 Then
        For i = 0 To Me.mpgCriteria.Pages.Count - 1
            For c = 0 To Me.mpgCriteria.Pages(i).Controls.Count - 1
                If Me.mpgCriteria.Pages(i).Controls(c).Name Like "cbxBaseSheetKey*" Then Set ctlBase = Me.mpgCriteria.Pages(i).Controls(c)
                If Me.mpgCriteria.Pages(i).Controls(c).Name Like "cbxNewSheetKey*" Then Set ctlNew = Me.mpgCriteria.Pages(i).Controls(c)
            Next c
            
            For c = 0 To ctlNew.ListCount - 1
                If Mid(ctlBase.Text, InStr(1, ctlBase.Text, " ")) = Mid(ctlNew.List(c), InStr(1, ctlNew.List(c), " ")) Then
                    ctlNew.ListIndex = c
                    Exit For
                End If
            Next c
        Next i
    
    Else
    
        For c = 0 To Me.mpgCriteria.Pages(pagindex).Controls.Count - 1
            If Me.mpgCriteria.Pages(pagindex).Controls(c).Name Like "cbxBaseSheetKey*" Then Set ctlBase = Me.mpgCriteria.Pages(pagindex).Controls(c)
            If Me.mpgCriteria.Pages(pagindex).Controls(c).Name Like "cbxNewSheetKey*" Then Set ctlNew = Me.mpgCriteria.Pages(pagindex).Controls(c)
        Next c
        
        For c = 0 To ctlNew.ListCount - 1
            If Mid(ctlBase.Text, InStr(1, ctlBase.Text, " ")) = Mid(ctlNew.List(c), InStr(1, ctlNew.List(c), " ")) Then
                ctlNew.ListIndex = c
                Exit For
            End If
        Next c

    End If
    
    On Error GoTo 0
    
End Sub

Private Sub chkAllNone_Change()
    Dim i As Long
    
    DisableEvents = True
    
    For i = 0 To Me.lbxNewFileCols.ListCount - 1
        Me.lbxNewFileCols.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GoodToGo(Me)
    
End Sub

Private Sub cmdNewFileBrowse_Click()
    Dim JoinFile As Workbook
    Dim FileName As Variant
    
    FileName = OpenDialog(, , "Seleziona il file da unire", False)
        
    If FileName = False Then Exit Sub
    
    On Error Resume Next
        Set JoinFile = Workbooks(Mid(FileName, InStrRev(FileName, pSep) + 1))
        If Err.Number > 0 Then
            Err.Clear
            Set JoinFile = Workbooks.Open(FileName, 0)
        End If
    On Error Resume Next
            
    Call RefreshOpenFiles
    
    Me.cbxNewFile = JoinFile.Name
            
    CurrWb.Activate

End Sub

Private Sub lbxNewFileCols_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub

Private Sub mpgCriteria_Change()
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
End Sub

Private Sub cmdAddCriteria_Click()
    Call AddCriteria
End Sub

Private Sub cmdAddCriteria_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdAddCriteria_Click
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
End Sub

Private Sub AddCriteria()
    Dim newindex As Long
    
    newindex = Me.mpgCriteria.Pages.Count + 1
    
    On Error Resume Next
    
    With Me.mpgCriteria.Pages.Add
        .Name = "pagC" & newindex
        .Caption = "C" & newindex
        With .Controls.Add("Forms.Label.1", "lblBaseSheetKey" & newindex)
            .Top = Me.lblBaseSheetKey1.Top
            .Left = Me.lblBaseSheetKey1.Left
            .Width = Me.lblBaseSheetKey1.Width
            .Height = Me.lblBaseSheetKey1.Height
            .Font.Size = Me.lblBaseSheetKey1.Font.Size
            .Caption = Me.lblBaseSheetKey1.Caption
        End With
    
        With .Controls.Add("Forms.ComboBox.1", "cbxBaseSheetKey" & newindex)
            .Top = Me.cbxBaseSheetKey1.Top
            .Left = Me.cbxBaseSheetKey1.Left
            .Width = Me.cbxBaseSheetKey1.Width
            .Height = Me.cbxBaseSheetKey1.Height
            .Font.Size = Me.cbxBaseSheetKey1.Font.Size
            .List = Me.cbxBaseSheetKey1.List
            .ListIndex = 0
        End With
    
        With .Controls.Add("Forms.Label.1", "lblNewSheetKey" & newindex)
            .Top = Me.lblNewSheetKey1.Top
            .Left = Me.lblNewSheetKey1.Left
            .Width = Me.lblNewSheetKey1.Width
            .Height = Me.lblNewSheetKey1.Height
            .Font.Size = Me.lblNewSheetKey1.Font.Size
            .Caption = Me.lblNewSheetKey1.Caption
        End With
    
        With .Controls.Add("Forms.ComboBox.1", "cbxNewSheetKey" & newindex)
            .Top = Me.cbxNewSheetKey1.Top
            .Left = Me.cbxNewSheetKey1.Left
            .Width = Me.cbxNewSheetKey1.Width
            .Height = Me.cbxNewSheetKey1.Height
            .Font.Size = Me.cbxNewSheetKey1.Font.Size
            .List = Me.cbxNewSheetKey1.List
            .ListIndex = 0
        End With
        
        Set btnColl = CommonButtons(Me, True)

    End With
    
    On Error GoTo 0
    
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
    
    Call UpdateNewKey(Me.mpgCriteria.Pages.Count - 1)
    
    Me.mpgCriteria.Value = Me.mpgCriteria.Pages.Count - 1

End Sub

Private Sub cmdDeleteCriteria_Click()
    Call DeleteCriteria(Me.mpgCriteria.Value)
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
End Sub

Private Sub cmdDeleteCriteria_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdDeleteCriteria_Click
End Sub

Private Sub DeleteCriteria(pag As Long)
    Dim ctl As control
    Dim i As Long
    
    Me.mpgCriteria.Pages.Remove (pag)
    
    For i = 0 To Me.mpgCriteria.Pages.Count - 1
        If i >= pag Then
            Me.mpgCriteria.Pages(i).Name = Replace(Me.mpgCriteria.Pages(i).Name, i + 2, i + 1)
            Me.mpgCriteria.Pages(i).Caption = Replace(Me.mpgCriteria.Pages(i).Caption, i + 2, i + 1)
            For Each ctl In Me.mpgCriteria.Pages(i).Controls
                ctl.Name = Replace(ctl.Name, i + 2, i + 1)
            Next ctl
        End If
    Next i
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Const crSep As String = "|fffd||ESK||fffd|"
    Dim NewFile As Workbook
    Dim BaseSheet As Worksheet
    Dim NewSheet As Worksheet
    Dim KeysSheet As Worksheet
    Dim NewRng As Range
    Dim i As Long
    Dim k As Long
    Dim nRow As Variant
    Dim fNewCol As Long
    Dim off As Long
    'Array:
    '1. Range(A1-ultimacella) foglio base
        Dim BaseRngArray As Variant
    '2. Range(A1-ultimacella) foglio nuovo
        Dim NewRngArray As Variant
    '3. colonne chiavi foglio base
        Dim BaseKeyArray As Variant
    '4. colonne chiavi foglio nuovo
        Dim NewKeyArray As Variant
    '5. Elenco colonne da importare
        Dim ColumnsArray As Variant
    '6. Range da aggiungere al foglio base
        Dim AddArray As Variant
        
    
    Me.Hide
    
    Call AutoCalc(False)
    
    On Error Resume Next
    Err.Clear
    Set NewFile = Workbooks(Me.cbxNewFile.Text)
    If Err.Number > 0 Then
        Err.Clear
        MsgBox IIf(lng = 0, "Il file da unire deve essere aperto", "The file to be merged must be opened"), vbCritical
        Exit Sub
    End If
    
    Set NewSheet = NewFile.Worksheets(Me.cbxNewFileSheet.Text)
    If Err.Number > 0 Then
        Err.Clear
        MsgBox IIf(lng = 0, "Foglio da unire non valido", "Worksheet to be merged is not valid"), vbCritical
        Exit Sub
    End If
    On Error GoTo Aborted
    
    'Tolgo il filtro automatico dal foglio destinazione
    Call AutoFilterOFF(NewSheet)
    
    Call backup_create_new
    
    Set BaseSheet = CurrWs
    
    'Tolgo il filtro automatico dal foglio base
    Call AutoFilterOFF(CurrWs)
    
    Set KeysSheet = ThisWorkbook.Worksheets("ESK_Keys")
    KeysSheet.Cells.Clear
    
    '#' Ridimensiono e popolo gli array degli intervalli:
    
    '1. Range(A1-ultimacella) foglio base
        Set InRng = BaseSheet.Range("A1:" & findlastcell(BaseSheet.Cells).address)
        BaseRngArray = InRng.Value2
    
    '2. Colonna chiavi foglio base
        ReDim BaseKeyArray(1 To UBound(BaseRngArray, 1), 1 To 1)
        For i = 0 To Me.mpgCriteria.Pages.Count - 1
            For k = 1 To UBound(BaseKeyArray)
                If IsError(BaseRngArray(k, ColItemToNumber(Me.mpgCriteria.Pages(i).Controls("cbxBaseSheetKey" & i + 1).Text))) Then
                    BaseKeyArray(k, 1) = "Errore"
                Else
                    BaseKeyArray(k, 1) = BaseKeyArray(k, 1) & crSep & BaseRngArray(k, ColItemToNumber(Me.mpgCriteria.Pages(i).Controls("cbxBaseSheetKey" & i + 1).Text))
                End If
            Next k
        Next i
        KeysSheet.Cells(1, 1).reSize(UBound(BaseKeyArray)) = BaseKeyArray
        
    '3. Range(A1-ultimacella) foglio nuovo
        Set NewRng = NewSheet.Range("A1:" & findlastcell(NewSheet.Cells).address)
        NewRngArray = NewRng.Value2
    
    '4. Colonna chiavi foglio nuovo
        ReDim NewKeyArray(1 To UBound(NewRngArray, 1), 1 To 1)
        For i = 0 To Me.mpgCriteria.Pages.Count - 1
            For k = 1 To UBound(NewRngArray)
                NewKeyArray(k, 1) = NewKeyArray(k, 1) & crSep & NewRngArray(k, ColItemToNumber(Me.mpgCriteria.Pages(i).Controls("cbxNewSheetKey" & i + 1).Text))
            Next k
        Next i
        KeysSheet.Cells(1, 2).reSize(UBound(NewKeyArray)) = NewKeyArray
    
    '5. Elenco colonne da importare
        k = 1
        ReDim ColumnsArray(1 To 1)
        For i = 0 To Me.lbxNewFileCols.ListCount - 1
            If Me.lbxNewFileCols.Selected(i) = True Then
                ReDim Preserve ColumnsArray(1 To k)
                ColumnsArray(k) = ColItemToNumber(Me.lbxNewFileCols.List(i))
                k = k + 1
            End If
        Next i
         
    '6. Range da aggiungere al foglio base
        ReDim AddArray(1 To UBound(BaseRngArray, 1), 1 To UBound(ColumnsArray))
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = UBound(BaseKeyArray)
    UProgress.SetDescription "Sto unendo i file..."
    Call ShowProgressBar
    
    'Costruisco l'array delle celle da aggiungere
    'Scrivo l'intestazione
    If Me.chkHeader = True Then
        off = 1
        For k = 1 To UBound(ColumnsArray)
            AddArray(1, k) = NewRng(1, ColumnsArray(k))
        Next k
    End If
    
    For i = 1 + off To UBound(BaseKeyArray, 1)
    
        counter = counter + 1
        
        nRow = Application.Match(KeysSheet.Cells(i, 1), KeysSheet.Columns(2), 0)

        If IsError(nRow) = False Then
            For k = 1 To UBound(ColumnsArray)
                AddArray(i, k) = NewRng(nRow, ColumnsArray(k))
            Next k
        Else
            For k = 1 To UBound(ColumnsArray)
                AddArray(i, k) = nRow
            Next k
        End If
        
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
        
    Next i

    'Scrive l'array sul range di destinazione
    fNewCol = findlastcell(BaseSheet.Cells).Column + 1
    BaseSheet.Cells(1, fNewCol).reSize(UBound(AddArray, 1), UBound(AddArray, 2)) = AddArray
    
    'Svuota il foglio chiavi
    KeysSheet.Cells.Clear
    
    'Chiude la finestra di avanzamento
    Unload UProgress

    Call AutoCalc(True)
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmJoinRows"
Attribute VB_Base = "0{B3D334A1-D690-4E32-B6AA-18D8E4B65D8E}{EB747C5F-BDA9-48FB-8127-2F815BB13DEF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange.Text = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub


Private Sub cmdNewLine_Click()
    Me.txtDelim = Me.txtDelim & "{CR}"
End Sub
    
Private Sub optEmpty_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optDelete_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optNothing_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim i As Long, j As Long
    Dim result As Variant
    Dim delim As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide
        
        delim = Replace(.txtDelim, "{CR}", vbNewLine)
    
    End With
    
    Call AutoCalc(False)
    
    
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    Set ws = ActiveSheet

    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
    
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Columns.Count
        UProgress.SetDescription "Unione righe in corso... (" & ws.Name & ")"
        Call ShowProgressBar
        
        With InRng
            LRow = .Rows.Count
            LCol = .Columns.Count
    
            For j = 1 To LCol
                
                'Aumenta di 1 il contatore
                counter = counter + 1
    
                For i = 1 To LRow
                    If .Rows(i).RowHeight > -1 - Me.chkIgnoreHidden And .Columns(j).ColumnWidth > -1 - Me.chkIgnoreHidden Then
                        If .Cells(i, j) = "" And Me.chkEmptyCells Then
                            result = result
                        Else
                            result = result & .Cells(i, j) & delim
                        End If
                    End If
                Next i
                
                If Len(result) > 0 Then .Cells(1, j) = Left(result, Len(result) - Len(delim))
                result = ""
                If .Columns(j).ColumnWidth > -1 - Me.chkIgnoreHidden And Me.optEmpty Then
                    For i = 2 To LRow
                        If .Rows(i).RowHeight > -1 - Me.chkIgnoreHidden Then .Cells(i, j) = ""
                    Next i
                End If
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next j
            If Me.optDelete Then
                .Range(Cells(2, 1), Cells(LRow, 1)).EntireRow.Delete
            End If
        End With
            
        'Chiude la finestra di avanzamento
        Unload UProgress
            
    End If
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)
    
    Call Cleanup
End Sub

Attribute VB_Name = "frmKeyShortcuts"
Attribute VB_Base = "0{C7652DB3-2E1C-43EE-8407-DCD19F57F9F8}{863E999E-9C5F-47EC-AB21-2AB6D7FD2A6F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Dim ctl As control
    
    Call ScaleForm(Me)
    
    Set btnColl = CommonButtons(Me)
    
    If IsWindows = False Then
        For Each ctl In Me.Controls
            If HasCaption(ctl) Then
                ctl.Caption = Replace(ctl.Caption, "Alt", "Cmd")
            End If
        Next ctl
    End If
End Sub

Private Sub UserForm_Click()
    Unload Me
End Sub

Private Sub lblFormKeys_Click()
    Unload Me
End Sub

Private Sub lblFormKeysTitle_Click()
    Unload Me
End Sub

Private Sub lblGlobalKeys_Click()
    Unload Me
End Sub

Private Sub lblGlobalKeysTitle_Click()
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub



Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmMakeDir"
Attribute VB_Base = "0{C2D3EC1D-F170-407A-88ED-0DE6B69ADB2F}{6FA3C7B7-659F-4149-A4B8-78F43C5D963E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Me.refRange = Selection.address
    On Error Resume Next
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If ActiveWorkbook.path = "" Then
        Me.txtbaseFolder = DesktopPath
    Else
        Me.txtbaseFolder = ActiveWorkbook.path
    End If

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    If TypeName(RangeResize(Range(Replace(Me.refRange, ";", ",")))) = "Range" Then
        Me.cmdOK.Enabled = True
        Call fCount(RangeResize(Range(Me.refRange)))
        RangeResize(Range(Replace(Me.refRange, ";", ","))).Select
        Me.refRange = RangeResize(Range(Replace(Me.refRange, ";", ","))).address
    Else
        Me.lblLvls.Caption = ""
        Me.cmdOK.Enabled = False
    End If
    On Error GoTo 0
End Sub


Private Sub opt1lvl_Change()
    If TypeName(RangeResize(Range(Replace(Me.refRange, ";", ",")))) = "Range" Then
        Call fCount(RangeResize(Range(Me.refRange)))
    End If
End Sub
Private Sub fCount(r As Range)
    Dim i As Long, j As Long
    Dim fc1 As New Collection
    Dim fcN As New Collection
    Dim nf As String
    Dim lvlCaption As String
    
    i = r.Columns.Count
    Me.optNlvls.Enabled = i > 1
    If Me.optNlvls.Enabled = False Then Me.opt1lvl = True
    
    '#' Empties collection
    Call ClearCollection(fc1)
    Call ClearCollection(fcN)
    
    If Me.optNlvls = True Then
        For i = 1 To r.Rows.Count
            nf = ""
            For j = 1 To r.Columns.Count
                If r(i, j) <> "" Then
                    nf = nf & r(i, j)
                    On Error Resume Next
                    fcN.Add nf, CStr(nf)
                    On Error GoTo 0
                End If
            Next j
        Next i
        If lng = 0 Then
            lvlCaption = "Saranno create " & fcN.Count & " cartelle su " & r.Columns.Count & " livelli"
        Else
            lvlCaption = fcN.Count & " folders over " & r.Columns.Count & " levels will be created"
        End If
    Else
        For Each cell In r.Cells
            nf = ""
            If cell <> "" Then
                nf = nf & cell
                On Error Resume Next
                fc1.Add nf, CStr(nf)
                On Error GoTo 0
            End If
        Next cell
        If lng = 0 Then
            lvlCaption = "Saranno create " & fc1.Count & " cartelle"
        Else
            lvlCaption = fc1.Count & " folders will be created"
        End If
    End If
    
    Me.lblLvls.Caption = lvlCaption
    
End Sub
Private Sub cmdSelectFolder_Click()
    Me.txtbaseFolder.Text = FolderPicker(Me.txtbaseFolder.Text)
End Sub
    
Private Sub opt1lvl_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optNlvls_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim BaseDir As String
    Dim nCell As String
    Dim i As Long, j As Long, n As Long
    Dim oFolder As Long
    Dim finalcount As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        If IsWindows = True And ValidateFolder(Me.txtbaseFolder, True) = False Then
            MsgBox IIf(lng = 0, "Attenzione: cartella base non valida. Riprovare", "Warning: invalid folder. Retry"), _
                    vbExclamation, _
                    IIf(lng = 0, "Errore: cartella base non valida", "Error: invalid base folder")
            .refRange = Selection.address
            .txtbaseFolder.SetFocus
            Exit Sub
        End If
        
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    
    
    On Error GoTo Aborted
    
    BaseDir = ValidateFolder(Me.txtbaseFolder)
    
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet)
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
        Call AutoCalc(True)
        Exit Sub
    Else
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.CountLarge
        UProgress.SetDescription "Sto creando le cartelle..."
        Call ShowProgressBar
        
        If Me.opt1lvl Then
            For Each cell In InRng.Cells
                counter = counter + 1
                nCell = ""
                If cell <> "" Then
                    If Right(cell, 1) <> pSep Then
                        nCell = Trim(CleanString(cell.Value, "_")) & pSep
                    Else
                        nCell = Trim(CleanString(Left(cell.Value, Len(cell) - 1), "_")) & pSep
                    End If
                    
                    On Error Resume Next
                    Err.Clear
                    MkDir BaseDir & nCell
                    If Err.Number = 0 Then finalcount = finalcount + 1
                    On Error GoTo Aborted
                        
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                End If
            Next cell
                        
        Else
            For i = 1 To InRng.Rows.Count
                For j = 1 To InRng.Columns.Count
                    
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                    
                    If InRng(i, j) <> "" Then
                        
                        nCell = ""
                        If j = 1 Then '#' 1st level
                            
                            If Right(InRng(i, j), 1) <> pSep Then
                                nCell = Trim(CleanString(InRng(i, j), "_")) & pSep
                            Else
                                nCell = Trim(CleanString(Left(InRng(i, j), Len(InRng(i, j)) - 1), "_")) & pSep
                            End If
                            
                        Else '#' Further levels
                            
                            For n = 1 To j
                                If Right(InRng(i, n), 1) <> pSep Then
                                    nCell = Replace(nCell & pSep & Trim(CleanString(InRng(i, n), "_")) & pSep, pSep & pSep, pSep)
                                Else
                                    nCell = Replace(nCell & pSep & Trim(CleanString(Left(InRng(i, n), Len(InRng(i, n)) - 1), "_")) & pSep, pSep & pSep, pSep)
                                End If
                            Next n
                        End If
                        
                        On Error Resume Next
                        Err.Clear
                        MkDir BaseDir & nCell
                        If Err.Number = 0 Then finalcount = finalcount + 1
                        On Error GoTo Aborted
                        
                        '#' Aggiorna la barra di avanzamento
                        Call UpdateProgressBar(counter, countermax)
                        If ProgressAborted = 1 Then GoTo Aborted
                        On Error GoTo Aborted
                    End If
                Next j
            Next i
        End If
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
                                
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    oFolder = MsgBox("Sono state create con successo " & finalcount & " cartelle. Vuoi aprire la cartella base in esplora risorse?", vbInformation + vbYesNo, "Creazione cartelle completata")
    If oFolder = vbYes Then Call OpenFolder(BaseDir)
    
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmManageDuplicateCells"
Attribute VB_Base = "0{ED1CF757-04E5-4AFB-9915-C1A7EC01EF15}{DE8EF7DF-B587-400E-8976-FB5E687C8880}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkMinDupes_Change()
    Me.spbMinDupes.Enabled = Me.chkMinDupes
    Me.txtMinDupes.Enabled = Me.chkMinDupes
End Sub

Private Sub spbMinDupes_SpinDown()
    Me.txtMinDupes = Me.spbMinDupes
End Sub

Private Sub spbMinDupes_SpinUp()
    Me.txtMinDupes = Me.spbMinDupes
End Sub

Private Sub txtMinDupes_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtMinDupes_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMinDupes) > Me.spbMinDupes.Max Then Me.txtMinDupes = Me.spbMinDupes.Max
    If Val(Me.txtMinDupes) < Me.spbMinDupes.Min Then Me.txtMinDupes = Me.spbMinDupes.Min
    Me.spbMinDupes = Me.txtMinDupes
    Me.txtMinDupes.ControlTipText = Me.txtMinDupes.Text
End Sub

Private Sub chkDiffCols_Change()
    Me.lblColor.Enabled = Not Me.chkDiffCols
    If Me.chkDiffCols = True Then
        Me.lblColor.BackStyle = fmBackStyleTransparent
    Else
        Me.lblColor.BackStyle = fmBackStyleOpaque
    End If
End Sub
Private Function PickNewColor(Optional i_OldColor As Double = xlNone) As Double
    Const BGColor As Long = 13160660  'background color of dialogue
    Const ColorIndexLast As Long = 32 'index of last custom color in palette
    
    Dim myOrgColor As Double          'original color of color index 32
    Dim myRGB_R As Integer            'RGB values of the color that will be
    Dim myRGB_G As Integer            'displayed in the dialogue as
    Dim myRGB_B As Integer            '"Current" color
      
    'save original palette color, because we don't really want to change it
    myOrgColor = ActiveWorkbook.Colors(ColorIndexLast)
    
    If i_OldColor = xlNone Then
        'get RGB values of background color, so the "Current" color looks empty
        Color2RGB BGColor, myRGB_R, myRGB_G, myRGB_B
    Else
        'get RGB values of i_OldColor
        Color2RGB i_OldColor, myRGB_R, myRGB_G, myRGB_B
    End If
    
    'call the color picker dialogue
    If Application.Dialogs(xlDialogEditColor).Show(ColorIndexLast, _
         myRGB_R, myRGB_G, myRGB_B) = True Then
        '"OK" was pressed, so Excel automatically changed the palette
        'read the new color from the palette
        PickNewColor = ActiveWorkbook.Colors(ColorIndexLast)
        'reset palette color to its original value
        ActiveWorkbook.Colors(ColorIndexLast) = myOrgColor
    Else
        '"Cancel" was pressed, palette wasn't changed
        'return old color (or xlNone if no color was passed to the function)
        PickNewColor = i_OldColor
    End If
End Function
Private Sub Color2RGB(ByVal i_Color As Long, _
    o_R As Integer, o_G As Integer, o_B As Integer)
    o_R = i_Color Mod 256
    i_Color = i_Color \ 256
    o_G = i_Color Mod 256
    i_Color = i_Color \ 256
    o_B = i_Color Mod 256
    
    If o_R < 0 Then o_R = 0
    If o_G < 0 Then o_G = 0
    If o_B < 0 Then o_B = 0

End Sub

Private Sub lblColor_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.lblColor.BackColor = PickNewColor(Me.lblColor.BackColor)
End Sub
Private Sub optHighlight_Change()
    If Me.optHighlight Then
        Me.chkKeepFirst.Caption = "Compresa la prima cella"
        Me.chkDiffCols.Enabled = True
        If Me.chkDiffCols = False Then Me.lblColor.Enabled = True
        If Me.chkDiffCols = False Then Me.lblColor.BackStyle = fmBackStyleOpaque
    Else
        Me.chkKeepFirst.Caption = "Mantieni la prima cella"
        Me.chkDiffCols.Enabled = False
        Me.lblColor.Enabled = False
        Me.lblColor.BackStyle = fmBackStyleTransparent
    End If
End Sub
Private Sub optNothing_Change()
    If Me.optNothing Then
        Me.chkKeepFirst = True
        Me.chkKeepFirst.Enabled = False
    Else
        Me.chkKeepFirst.Enabled = True
    End If
End Sub
    
Private Sub optHighlight_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optErase_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optNothing_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim i As Long, j As Long, i2 As Long, j2 As Long
    Dim dupescountprov As Long
    Dim MaxDupes As Long
    Dim dupesfound As Long
    Dim FinalReport As String
    Dim DupesColl As New Collection
    Dim DupesCount As New Collection
    Dim CurrDupes As New Collection
    Dim TotalDupesCount As Long
    Dim col_R As Long, col_G As Long, col_B As Long
    Dim RngArray()
    Dim Item As Variant
    Dim CurrDupe As Variant
    Dim reportWs As Worksheet
    Dim UsedColors As Long

    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        If Range(Replace(.refRange, ";", ",")).Areas.Count > 1 Then
            MsgBox TranslateCnst("MultipleRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.Areas(1).address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted

        .Hide
    End With
    
    Call AutoCalc(False)
    
    Call backup_create_new

    Set InRng = RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet)

    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge
    UProgress.SetDescription "Ricerca duplicati su " & countermax & " celle..."
    Call ShowProgressBar

    ReDim RngArray(1 To InRng.Rows.Count, 1 To InRng.Columns.Count)
    RngArray = InRng.Value2
    
    If Me.optHighlight = True Then InRng.Interior.ColorIndex = 0
    
    Randomize
    
    'Ciclo tra le celle dell'intervallo
    For i = 1 To UBound(RngArray, 1)
        For j = 1 To UBound(RngArray, 2)
        
            'Aumenta di 1 il contatore
            counter = counter + 1
            
            If RngArray(i, j) <> vbNullString Or Me.chkIgnoreEmpty = False Then
                'Azzera la collection dei duplicati per questa cella
                Call ClearCollection(CurrDupes)
                
                'Azzera le variabili di controllo e conteggio duplicati per questa cella
                dupesfound = 0
                dupescountprov = 0
        
                On Error Resume Next
                DupesColl.Add i & ";" & j, CStr(i & ";" & j)
                If Err.Number <> 0 Then 'La cella |fffd| stata gi|fffd| marcata in precedenza come duplicato: salta tutta la procedura
                    Err.Clear
                Else
                    On Error GoTo Aborted
                
                    'Seleziono un colore random con valori R, G, B compresi tra 75 e 220 (per non renderli troppo scuri, o quasi bianchi)
                    col_R = 75 + (Round(Rnd() * (220 - 75), 0))
                    col_G = 75 + (Round(Rnd() * (220 - 75), 0))
                    col_B = 75 + (Round(Rnd() * (220 - 75), 0))
        
                    'Ciclo tra le celle del range
                    For i2 = i To UBound(RngArray, 1)
                        For j2 = 1 To UBound(RngArray, 2)
        
                            If (i2 <> i Or j2 <> j) And RngArray(i2, j2) = RngArray(i, j) Then 'Trovato un duplicato
        
                                'Aggiorna il conteggio parziale dei duplicati
                                dupescountprov = dupescountprov + 1
                                'Aggiorna il conteggio dei duplicati
                                TotalDupesCount = TotalDupesCount + 1
                                
                                If Me.chkMinDupes = False Or _
                                   (Me.chkMinDupes = True And dupescountprov >= Me.txtMinDupes) Then 'Superato il numero minimo di duplicazioni impostato
                                    dupesfound = 1
                                End If
            
                                'Aggiorna la collezione globale dei duplicati
                                On Error Resume Next
                                DupesColl.Add i2 & ";" & j2, CStr(i2 & ";" & j2)
                                On Error GoTo Aborted
                                
                                'Aggiorna la collezione dei duplicati relativi alla cella corrente
                                On Error Resume Next
                                CurrDupes.Add i2 & ";" & j2, CStr(i2 & ";" & j2)
                                On Error GoTo Aborted
                                
                            End If
                        Next j2
                    Next i2
                
                End If
                    
                If dupesfound = 1 Then
                    On Error Resume Next
                    If InRng(i, j).Value2 = "" Then
                        DupesCount.Add "{{NULL}}" & "|" & CurrDupes.Count, "{{NULL}}"
                    Else
                        DupesCount.Add InRng(i, j).Value2 & "|" & CurrDupes.Count, CStr(InRng(i, j).Value2)
                    End If
                    On Error GoTo Aborted
                    
                    'Esegue l'operazione impostata
                    For Each Item In CurrDupes
                        CurrDupe = Split(Item, ";")
                        If Me.optErase Then
                            RngArray(Val(CurrDupe(0)), Val(CurrDupe(1))) = ""
                            If Me.chkKeepFirst = False Then RngArray(i, j) = ""
                        ElseIf Me.optHighlight Then
                            If Me.chkDiffCols Then
                                If UsedColors > UBound(BaseColors) Then
                                    InRng(Val(CurrDupe(0)), Val(CurrDupe(1))).Interior.Color = RGB(col_R, col_G, col_B)
                                    If Me.chkKeepFirst Then
                                        InRng(i, j).Interior.Color = RGB(col_R, col_G, col_B)
                                    End If
                                Else
                                    InRng(Val(CurrDupe(0)), Val(CurrDupe(1))).Interior.ColorIndex = BaseColors(UsedColors)
                                    If Me.chkKeepFirst Then
                                        InRng(i, j).Interior.ColorIndex = BaseColors(UsedColors)
                                    End If
                                End If
                            Else
                                InRng(Val(CurrDupe(0)), Val(CurrDupe(1))).Interior.Color = Me.lblColor.BackColor
                                If Me.chkKeepFirst Then
                                    InRng(i, j).Interior.Color = Me.lblColor.BackColor
                                End If
                            End If
                        End If
                    Next Item
                    UsedColors = UsedColors + 1
                End If
                If dupescountprov > MaxDupes Then MaxDupes = dupescountprov
                
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted

        Next j
    Next i
    
    'Converto in testo i numeri memorizzati come testo
    Call FixArrayStrings(RngArray)
    
    'Trasferisco l'array nel range
    InRng = RngArray


    'Chiude la finestra di avanzamento
    Unload UProgress

    Call AutoCalc(True)

    If Me.chkReport Then
        If lng = 0 Then
            If DupesCount.Count = 0 Then
                FinalReport = "Non sono state trovate celle duplicate secondo i criteri selezionati"
            Else
                FinalReport = "RAPPORTO FINALE RICERCA DUPLICATI:" & vbNewLine & vbNewLine
                FinalReport = FinalReport & "Totale celle nell'intervallo: " & vbTab & InRng.Cells.Count & vbNewLine
                FinalReport = FinalReport & IIf(Me.chkMinDupes = True, "N.", "Numero") & " celle con" & IIf(Me.chkMinDupes = True, " >= " & Me.txtMinDupes, "") & " duplicati: " & vbTab & DupesCount.Count & vbNewLine
                If Me.chkMinDupes = False Then FinalReport = FinalReport & "Numero tot. celle duplicate: " & vbTab & TotalDupesCount & vbNewLine
                If Me.chkMinDupes = False Then FinalReport = FinalReport & "N. celle univoche/vuote: " & vbTab & InRng.Cells.Count - TotalDupesCount & vbNewLine
                FinalReport = FinalReport & "Numero max duplicazioni: " & vbTab & MaxDupes
            End If
            MsgBox FinalReport, vbInformation, "Rapporto finale"
        Else
            If DupesCount.Count = 0 Then
                FinalReport = "No duplicate cells were found with your set criteria"
            Else
                FinalReport = "DUPLICATE SEARCH SUMMARY:" & vbNewLine & vbNewLine
                FinalReport = FinalReport & "Number of cells in range: " & vbTab & InRng.Cells.Count & vbNewLine
                FinalReport = FinalReport & IIf(Me.chkMinDupes = True, "Nr.", "Nr.") & " of cells with" & IIf(Me.chkMinDupes = True, " >= " & Me.txtMinDupes, "") & " duplicates: " & vbTab & DupesCount.Count & vbNewLine
                If Me.chkMinDupes = False Then FinalReport = FinalReport & "Total nr. of duplicate cells: " & vbTab & TotalDupesCount & vbNewLine
                If Me.chkMinDupes = False Then FinalReport = FinalReport & "Total nr. unique/empty cells: " & vbTab & InRng.Cells.Count - TotalDupesCount & vbNewLine
                FinalReport = FinalReport & "Max number of copies: " & vbTab & MaxDupes
            End If
            MsgBox FinalReport, vbInformation, "Summary"
        End If
    End If

    If Me.chkReportSheet Then
        If DupesCount.Count = 0 Then
            'Non fare nulla
        Else
            On Error Resume Next
            Application.DisplayAlerts = False
            Worksheets("ESK_Report").Delete
            Application.DisplayAlerts = True
            On Error GoTo Aborted
            Set reportWs = Worksheets.Add(After:=ActiveSheet)
            With reportWs
                .Activate
                .Name = "ESK_Report"
                If lng = 0 Then .Range("A1") = "Valore" Else .Range("A1") = "Value"
                If lng = 0 Then .Range("B1") = "N. duplicati" Else .Range("B1") = "Nr. of duplicates"
                For Each Item In DupesCount
                    .Range("A" & Rows.Count).End(xlUp).Offset(1, 0) = Split(Item, "|")(0)
                    .Range("B" & Rows.Count).End(xlUp).Offset(1, 0) = CLng(Split(Item, "|")(1))
                Next Item
                With .Sort
                    .SortFields.Clear
                    .SortFields.Add key:=Range("B2:B" & reportWs.UsedRange.Rows.Count + reportWs.UsedRange.Row - 1), _
                        SortOn:=xlSortOnValues, Order:=xlDescending, DataOption:=xlSortTextAsNumbers
                    .SetRange Range("A1:B" & reportWs.UsedRange.Rows.Count + reportWs.UsedRange.Row - 1)
                    .header = xlYes
                    .MatchCase = False
                    .Orientation = xlTopToBottom
                    .SortMethod = xlPinYin
                    .Apply
                End With
                .Range("A:B").EntireColumn.AutoFit
            End With
        End If
    End If

    Exit Sub

Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmManageDuplicateRows"
Attribute VB_Base = "0{51ABEA00-5BB5-4482-943B-8EE57B53DAD2}{ADE78D0D-A9C8-4111-A64A-BEA707B5E91A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)

    Me.lblColor.BackColor = vbYellow
    Me.lblColor.BackStyle = fmBackStyleTransparent
    
    Me.lbxColumns.RowSource = ""
    Me.lbxColumns.Clear
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    
    Set InRng = RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet)
    Err.Clear
    On Error GoTo 0
    
    Call ListColumns(InRng, Me.lbxColumns, Me.chkHeader)
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    If TypeName(RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet)) = "Range" Then
        Call ListColumns(RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet), Me.lbxColumns, Me.chkHeader)
        RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet).Select
        Me.refRange = RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet).address
    End If
    On Error GoTo 0
End Sub


Private Sub chkMinDupes_Change()
    Me.spbMinDupes.Enabled = Me.chkMinDupes
    Me.txtMinDupes.Enabled = Me.chkMinDupes
End Sub

Private Sub spbMinDupes_SpinDown()
    Me.txtMinDupes = Me.spbMinDupes
End Sub

Private Sub spbMinDupes_SpinUp()
    Me.txtMinDupes = Me.spbMinDupes
End Sub

Private Sub txtMinDupes_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtMinDupes_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMinDupes) > Me.spbMinDupes.Max Then Me.txtMinDupes = Me.spbMinDupes.Max
    If Val(Me.txtMinDupes) < Me.spbMinDupes.Min Then Me.txtMinDupes = Me.spbMinDupes.Min
    Me.spbMinDupes = Me.txtMinDupes
    Me.txtMinDupes.ControlTipText = Me.txtMinDupes.Text
End Sub

Private Sub chkDiffCols_Change()
    Me.lblColor.Enabled = Not Me.chkDiffCols
    If Me.chkDiffCols Then
        Me.lblColor.BackStyle = fmBackStyleTransparent
    Else
        Me.lblColor.BackStyle = fmBackStyleOpaque
    End If
End Sub
Private Function PickNewColor(Optional i_OldColor As Double = xlNone) As Double
    Const BGColor As Long = 13160660  'background color of dialogue
    Const ColorIndexLast As Long = 32 'index of last custom color in palette
    
    Dim myOrgColor As Double          'original color of color index 32
    Dim myRGB_R As Integer            'RGB values of the color that will be
    Dim myRGB_G As Integer            'displayed in the dialogue as
    Dim myRGB_B As Integer            '"Current" color
      
    'save original palette color, because we don't really want to change it
    myOrgColor = ActiveWorkbook.Colors(ColorIndexLast)
    
    If i_OldColor = xlNone Then
        'get RGB values of background color, so the "Current" color looks empty
        Color2RGB BGColor, myRGB_R, myRGB_G, myRGB_B
    Else
        'get RGB values of i_OldColor
        Color2RGB i_OldColor, myRGB_R, myRGB_G, myRGB_B
    End If
    
    'call the color picker dialogue
    If Application.Dialogs(xlDialogEditColor).Show(ColorIndexLast, _
         myRGB_R, myRGB_G, myRGB_B) = True Then
        '"OK" was pressed, so Excel automatically changed the palette
        'read the new color from the palette
        PickNewColor = ActiveWorkbook.Colors(ColorIndexLast)
        'reset palette color to its original value
        ActiveWorkbook.Colors(ColorIndexLast) = myOrgColor
    Else
        '"Cancel" was pressed, palette wasn't changed
        'return old color (or xlNone if no color was passed to the function)
        PickNewColor = i_OldColor
    End If
End Function

Private Sub Color2RGB(ByVal i_Color As Long, _
    o_R As Integer, o_G As Integer, o_B As Integer)
    o_R = i_Color Mod 256
    i_Color = i_Color \ 256
    o_G = i_Color Mod 256
    i_Color = i_Color \ 256
    o_B = i_Color Mod 256
    
    If o_R < 0 Then o_R = 0
    If o_G < 0 Then o_G = 0
    If o_B < 0 Then o_B = 0

End Sub

Private Sub lblColor_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.lblColor.BackColor = PickNewColor(Me.lblColor.BackColor)
End Sub
Private Sub optHighlight_Change()
    If Me.optHighlight Then
        Me.chkDiffCols.Enabled = True
        Me.chkKeepFirst.Caption = IIf(lng = 0, "Compresa la prima riga", "Including first row")
        If Me.chkDiffCols = False Then Me.lblColor.Enabled = True
        If Me.chkDiffCols = False Then Me.lblColor.BackStyle = fmBackStyleOpaque
    Else
        Me.chkDiffCols.Enabled = False
        Me.chkKeepFirst.Caption = IIf(lng = 0, "Mantieni la prima riga", "Keep first row")
        Me.lblColor.Enabled = False
        Me.lblColor.BackStyle = fmBackStyleTransparent
    End If
End Sub
Private Sub optNothing_Change()
    If Me.optNothing Then
        Me.chkKeepFirst = True
        Me.chkKeepFirst.Enabled = False
        Me.chkReport = True
        Me.chkReport.Enabled = False
    Else
        Me.chkKeepFirst.Enabled = True
        Me.chkReport.Enabled = True
    End If
End Sub
Private Sub chkAllNone_Change()
    Dim i As Long
    
    For i = 0 To Me.lbxColumns.ListCount - 1
        Me.lbxColumns.Selected(i) = Me.chkAllNone
    Next i
End Sub
Private Sub txtFilterList_Change()
    Call ListColumns(InRng, Me.lbxColumns, Me.chkHeader, Me.txtFilterList.Text)
End Sub
Private Sub chkHeader_Change()
    Set ws = ActiveSheet
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    Call SwitchHeaders(InRng, Me.lbxColumns, Me.chkHeader)
End Sub
Private Sub optHighlight_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optClear_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optNothing_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optDelete_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click() 'NEW
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim c As Long
    Dim z As Long
    Dim check As Long
    Dim AddRows As Long
    Dim dupescountprov As Long
    Dim dupesfound As Long
    Dim MaxDupes As Long
    Dim colArray() As Variant
    Dim InRngArray() As Variant
    Dim KeyArray() As Variant
    Dim FinalReport As String
    Dim DupesCount As New Collection
    Dim TotalDupesCount As New Collection
    Dim CurrDupes As New Collection
    Dim ActualDupes As New Collection
    Dim Item As Variant
    Dim col_R As Long, col_G As Long, col_B As Long
    Dim UsedColors As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        check = 0
        For i = 0 To .lbxColumns.ListCount - 1
            If .lbxColumns.Selected(i) Then
                check = 1
                Exit For
            End If
        Next i
        If check = 0 Then
            MsgBox IIf(lng = 0, "Attenzione: |fffd| necessario selezionare almeno una colonna", "Warning: at least 1 column must be selected"), vbExclamation
            .lbxColumns.SetFocus
            Err.Clear
            Exit Sub
        End If

        .Hide
    
    End With
    
    Call AutoCalc(False)
    
    Call backup_create_new
    
    Set ws = ActiveSheet
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    InRngArray = InRng.Value2
    ReDim KeyArray(1 To UBound(InRngArray, 1))
    
    If Me.optHighlight = True Then InRng.Interior.ColorIndex = 0
    
    'Imposta l'array delle colonne da confrontare, che sar|fffd| composto dai numeri delle colonne dell'intervallo, a partire da 1
    c = 1
    ReDim colArray(1 To 1)
    For i = 0 To Me.lbxColumns.ListCount - 1
        If Me.lbxColumns.Selected(i) Then
            ReDim Preserve colArray(1 To c)
            colArray(c) = ColItemToNumber(Me.lbxColumns.List(i)) - InRng.Column + 1
            c = c + 1
        End If
    Next i
    
    For i = 1 To UBound(InRngArray, 1)
        For j = LBound(colArray) To UBound(colArray)
            KeyArray(i) = KeyArray(i) & "|fffd||fffd||fffd|" & InRngArray(i, colArray(j))
        Next j
    Next i
    
    AddRows = 0
    If Me.chkHeader Then AddRows = 1
    
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = UBound(InRngArray, 1)
    UProgress.SetDescription "Ricerca righe duplicate..."
    Call ShowProgressBar
    
    Randomize
    
    'Ciclo tra le righe dell'intervallo
    For i = 1 + AddRows To UBound(KeyArray)
    
        'Aumenta di 1 il contatore
        counter = counter + 1
        
        'Azzera la collection dei duplicati per questa cella
        Call ClearCollection(CurrDupes)
            
        'Seleziono un colore random con valori R, G, B compresi tra 75 e 220 (per non renderli troppo scuri, o quasi bianchi)
        col_R = 75 + (Round(Rnd() * (220 - 75), 0))
        col_G = 75 + (Round(Rnd() * (220 - 75), 0))
        col_B = 75 + (Round(Rnd() * (220 - 75), 0))
        
        If CollKeyExists(TotalDupesCount, CStr(i)) = False Then
            dupescountprov = 0
            dupesfound = 0
            
            'Ciclo tra le righe successive alla prima
            For k = i + 1 To UBound(KeyArray)
                
                If KeyArray(k) = KeyArray(i) Then 'Trovato un duplicato
                
                    'Aggiorna il conteggio parziale dei duplicati
                    dupescountprov = dupescountprov + 1
                    
                    'Aggiorna la collezione filtri
                    On Error Resume Next
                    TotalDupesCount.Add k, (CStr(k))
                    On Error GoTo Aborted
                    
                    'Aggiorna la collezione dei duplicati relativi alla riga corrente
                    On Error Resume Next
                    CurrDupes.Add k, CStr(k)
                    On Error GoTo Aborted
                    
                    If Me.chkMinDupes = False Or _
                       (Me.chkMinDupes = True And dupescountprov >= Me.txtMinDupes) Then 'Superato il numero minimo di duplicazioni impostato
                        
                        'Aggiorna la collezione dei duplicati effettivamente da considerare
                        If dupesfound = 0 Then
                            On Error Resume Next
                            For z = 1 To CurrDupes.Count
                                ActualDupes.Add CurrDupes(z), CStr(CurrDupes(z))
                            Next z
                            On Error GoTo Aborted
                        Else
                            On Error Resume Next
                            ActualDupes.Add k, CStr(k)
                            On Error GoTo Aborted
                        End If
                        dupesfound = 1
                    End If
                            
                End If
            Next k
            
            If dupesfound = 1 Then
                On Error Resume Next
                DupesCount.Add i, CStr(i)
                On Error GoTo Aborted
            
                'Esegue l'operazione impostata
                For Each Item In CurrDupes
                    If Me.optClear Or Me.optDelete Then
                        InRng.Rows(Item).ClearContents
                        If Me.chkKeepFirst = False Then InRng.Rows(i).ClearContents
                    ElseIf Me.optHighlight Then
                        If Me.chkDiffCols Then
                            If UsedColors > UBound(BaseColors) Then
                                InRng.Rows(Item).Interior.Color = RGB(col_R, col_G, col_B)
                                If Me.chkKeepFirst Then
                                    InRng.Rows(i).Interior.Color = RGB(col_R, col_G, col_B)
                                End If
                            Else
                                InRng.Rows(Item).Interior.ColorIndex = BaseColors(UsedColors)
                                If Me.chkKeepFirst Then
                                    InRng.Rows(i).Interior.ColorIndex = BaseColors(UsedColors)
                                End If
                            End If
                        Else
                            InRng.Rows(Item).Interior.Color = Me.lblColor.BackColor
                            If Me.chkKeepFirst Then
                                InRng.Rows(i).Interior.Color = Me.lblColor.BackColor
                            End If
                        End If
                    End If
                Next Item
                UsedColors = UsedColors + 1
                If dupescountprov > MaxDupes Then MaxDupes = dupescountprov
            End If
        End If
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
        
    Next i
    
    '#' Alla fine, elimino le righe duplicate se cos|fffd| impostato
    If Me.optDelete Then
        For i = InRng.Rows.Count To 1 Step -1
            If Me.chkKeepFirst = True Then
                If CollKeyExists(ActualDupes, CStr(i)) Then
                    InRng.Rows(i).Delete Shift:=xlUp
                    InRng.Rows(InRng.Rows.Count + 1).Insert Shift:=xlDown 'Inserisco celle per compensare lo slittamento in alto
                    InRng.Rows(InRng.Rows.Count + 1).Clear  'Cancello eventuale formattazione dalle celle inserite
                End If
            Else
                If CollKeyExists(ActualDupes, CStr(i)) Or CollKeyExists(DupesCount, CStr(i)) Then
                    InRng.Rows(i).Delete Shift:=xlUp
                    InRng.Rows(InRng.Rows.Count + 1).Insert Shift:=xlDown 'Inserisco celle per compensare lo slittamento in alto
                    InRng.Rows(InRng.Rows.Count + 1).Clear  'Cancello eventuale formattazione dalle celle inserite
                End If
            End If
        Next i
    End If
    
    'Chiude la finestra di avanzamento
    Unload UProgress
    
   
    Call AutoCalc(True)
    
    
    If Me.chkReport Then
        If lng = 0 Then
            If DupesCount.Count = 0 Then
                FinalReport = "Non sono state trovate righe duplicate secondo i criteri selezionati"
            Else
                FinalReport = "RAPPORTO FINALE RICERCA DUPLICATI:" & vbNewLine & vbNewLine
                FinalReport = FinalReport & "Totale righe nell'intervallo: " & vbTab & countermax - AddRows & vbNewLine
                FinalReport = FinalReport & IIf(Me.chkMinDupes = True, "N.", "Numero") & " righe con" & IIf(Me.chkMinDupes = True, " >= " & Me.txtMinDupes, "") & " duplicati: " & vbTab & DupesCount.Count & vbNewLine
                FinalReport = FinalReport & "Numero tot. righe duplicate: " & vbTab & TotalDupesCount.Count & vbNewLine
                FinalReport = FinalReport & "Numero tot. righe univoche: " & vbTab & countermax - TotalDupesCount.Count - AddRows & vbNewLine
                FinalReport = FinalReport & "Numero max duplicazioni: " & vbTab & MaxDupes
            End If
            MsgBox FinalReport, vbInformation, "Rapporto finale"
        Else
            If DupesCount.Count = 0 Then
                FinalReport = "Non sono state trovate righe duplicate secondo i criteri selezionati"
            Else
                FinalReport = "DUPLICATES SEARCH SUMMARY:" & vbNewLine & vbNewLine
                FinalReport = FinalReport & "Number of rows in range: " & vbTab & countermax - AddRows & vbNewLine
                FinalReport = FinalReport & IIf(Me.chkMinDupes = True, "Nr.", "Nr.") & " rows with" & IIf(Me.chkMinDupes = True, " >= " & Me.txtMinDupes, "") & " dupes: " & vbTab & DupesCount.Count & vbNewLine
                FinalReport = FinalReport & "Total nr. duplicate rows: " & vbTab & TotalDupesCount.Count & vbNewLine
                FinalReport = FinalReport & "Total nr. unique rows: " & vbTab & countermax - TotalDupesCount.Count - AddRows & vbNewLine
                FinalReport = FinalReport & "Max number of duplicates: " & vbTab & MaxDupes
            End If
            MsgBox FinalReport, vbInformation, "Summary"
        End If
    End If
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmMergeCells"
Attribute VB_Base = "0{DC28C3FB-11B0-46DA-B298-AD315B9E1F2C}{47552029-B640-4771-BFF4-D44AD6B398F7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    
    '#' Cambia in automatico a verticale se una sola colonna selezionata
    If Range(Me.refRange).Columns.Count = 1 Then Me.optVer = True Else Me.optHor = True
    
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    
    MergeAreas(Range(Me.refRange)).Select
    
    '#' Cambia in automatico a verticale se una sola colonna selezionata
    If Range(Me.refRange).Columns.Count = 1 Then Me.optVer = True Else Me.optHor = True
    
    On Error GoTo 0
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub optMerge_Change()
    Me.fraMerge.visible = Me.optMerge
    Me.fraUnmerge.visible = Not Me.optMerge
    Me.imgMH.visible = Me.optMerge * Me.optHor
    Me.imgMV.visible = Me.optMerge * Me.optVer
    Me.imgUH.visible = Me.optUnMerge * Me.optHor
    Me.imgUV.visible = Me.optUnMerge * Me.optVer
    Me.chkCenterAcross.Enabled = Me.optUnMerge * Me.optHor * Me.optFirst
End Sub

Private Sub optHor_Change()
    Me.imgMH.visible = Me.optMerge * Me.optHor
    Me.imgMV.visible = Me.optMerge * Not Me.optHor
    Me.imgUH.visible = Me.optUnMerge * Me.optHor
    Me.imgUV.visible = Me.optUnMerge * Not Me.optHor
    Me.chkCenterAcross.Enabled = Me.optUnMerge * Me.optHor * Me.optFirst
End Sub

Private Sub optFirst_Change()
    Me.chkCenterAcross.Enabled = Me.optUnMerge * Me.optHor * Me.optFirst
End Sub

Private Sub optHor_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optVer_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optMerge_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optUnmerge_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optEqual_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optEqualEmpty_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim i As Long
    Dim j As Long
    Dim off As Long
    Dim MArea As Range
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    
    On Error GoTo Aborted
    
    Call backup_create_new
    
    Set ws = ActiveSheet
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto convertendo da/in celle unite... (" & ws.Name & ")"
        Call ShowProgressBar
        
        If Me.optHor Then
                                
            For i = 1 To InRng.Rows.Count
                
                For j = 1 To InRng.Columns.Count - 1
                
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                    
                    off = 1
                    If Me.optMerge Then
                        If Me.optEqual Then
                            Do While InRng(i, j + off) = InRng(i, j)
                                off = off + 1
                                If Intersect(InRng, InRng(i, j + off)) Is Nothing Then Exit Do
                            Loop
                        ElseIf Me.optEqualEmpty Then
                            Do While InRng(i, j + off) = InRng(i, j) Or InRng(i, j + off) = ""
                                off = off + 1
                                If Intersect(InRng, InRng(i, j + off)) Is Nothing Then Exit Do
                            Loop
                        End If
                        If off > 1 Then
                            Application.DisplayAlerts = False
                            With Range(InRng(i, j), InRng(i, j + off - 1))
                                .Merge
                                .HorizontalAlignment = xlCenter
                            End With
                            Application.DisplayAlerts = True
                            j = j + off - 1
                            counter = j * i
                        End If
                        
                    ElseIf Me.optUnMerge Then
                    
                        If InRng(i, j).MergeCells = True Then
                            If Me.optFirst Then
                                Set MArea = InRng(i, j).MergeArea
                                InRng(i, j).UnMerge
                                If Me.chkCenterAcross Then MArea.HorizontalAlignment = xlCenterAcrossSelection
                            ElseIf Me.optFill Then
                                Set MArea = InRng(i, j).MergeArea
                                InRng(i, j).UnMerge
                                InRng(i, j).Copy MArea
                            End If
                        End If
                    End If
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                Next j
                
            Next i
        ElseIf Me.optVer Then
            For j = 1 To InRng.Columns.Count
                
                For i = 1 To InRng.Rows.Count - 1
                
                    '#' Aumento di 1 il contatore
                    counter = counter + 1
                    
                    off = 1
                    If Me.optMerge Then
                        If Me.optEqual Then
                            Do While InRng(i + off, j) = InRng(i, j)
                                off = off + 1
                                If Intersect(InRng, InRng(i + off, j)) Is Nothing Then Exit Do
                            Loop
                        ElseIf Me.optEqualEmpty Then
                            Do While InRng(i + off, j) = InRng(i, j) Or InRng(i + off, j) = ""
                                off = off + 1
                                If Intersect(InRng, InRng(i + off, j)) Is Nothing Then Exit Do
                            Loop
                        End If
                        If off > 1 Then
                            Application.DisplayAlerts = False
                            With Range(InRng(i, j), InRng(i + off - 1, j))
                                .Merge
                                .VerticalAlignment = xlCenter
                            End With
                            Application.DisplayAlerts = True
                            i = i + off - 1
                            counter = i * j
                        End If
                    ElseIf Me.optUnMerge Then
                        If InRng(i, j).MergeCells = True Then
                            If Me.optFirst Then
                                InRng(i, j).UnMerge
                            ElseIf Me.optFill Then
                                Set MArea = InRng(i, j).MergeArea
                                InRng(i, j).UnMerge
                                InRng(i, j).Copy MArea
                            End If
                        End If
                    End If
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                Next i
                
            Next j
        End If
            
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmMirrorData"
Attribute VB_Base = "0{64DACD4C-CCBE-4A13-BD69-B01FE7108E85}{C1E1F59E-B7A7-47E2-BC88-7270BDB577F4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkGroup_Change()
    Me.txtNGroup.Enabled = Me.chkGroup
    Me.spbNGroup.Enabled = Me.chkGroup
End Sub
Private Sub optCols_Click()
    If Me.optCols Then Me.lblType.Caption = "colonne"
End Sub
Private Sub optRows_Click()
    If Me.optRows Then Me.lblType.Caption = "righe"
End Sub

Private Sub spbNGroup_SpinDown()
    Me.txtNGroup = Me.spbNGroup
End Sub

Private Sub spbNGroup_SpinUp()
    Me.txtNGroup = Me.spbNGroup
End Sub

Private Sub txtNGroup_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNGroup_Change()
    If Val(Me.txtNGroup) > Me.spbNGroup.Max Then Me.txtNGroup = Me.spbNGroup.Max
    If Val(Me.txtNGroup) < Me.spbNGroup.Min Then Me.txtNGroup = Me.spbNGroup.Min
    Me.spbNGroup = Me.txtNGroup
    Me.txtNGroup.ControlTipText = Me.txtNGroup.Text
End Sub

    
Private Sub optRows_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optCols_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim TempRng As Range
    Dim i As Long, j As Long, k As Long, n As Long
    Dim NGroup As Long
    Dim CurrRow As Long, currCol As Long
    Dim RngArray()
        
    With Me
        On Error Resume Next
        Set TempRng = Range(Replace(.refRange, ";", ","))
        If TypeName(TempRng) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        If Me.optCols Then
            If TempRng.Columns.Count Mod (Val(Me.txtNGroup)) <> 0 Then
                MsgBox "Attenzione: il numero di colonne dell'intervallo deve essere un multiplo del numero di colonne in ciascun gruppo. Riprovare", vbExclamation
                .txtNGroup.SetFocus
                Err.Clear
                Exit Sub
            End If
        ElseIf Me.optRows Then
            If TempRng.Rows.Count Mod (Val(Me.txtNGroup)) <> 0 Then
                MsgBox "Attenzione: il numero di righe dell'intervallo deve essere un multiplo del numero di colonne in ciascun gruppo. Riprovare", vbExclamation
                .txtNGroup.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        
        .Hide
    
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
        
        
        
        '#' Crea foglio di backup nascosto
        Call backup_create_new
    
        On Error GoTo Aborted
        
        Set ws = ActiveSheet

        Set InRng = RangeResize(ws.Range(Replace(.refRange, ";", ",")), ws)
        With InRng
            LRow = .Rows.Count
            LCol = .Columns.Count
        End With
        ReDim RngArray(1 To LRow, 1 To LCol)
                               
        If Me.chkGroup Then NGroup = Me.txtNGroup Else NGroup = 1
        
        For k = 1 To NGroup
            n = 1
            If Me.optCols Then
                For j = k To LCol Step NGroup
                    currCol = LCol - (n * NGroup) + k
                    For i = 1 To LRow
                        If Me.chkFormulas _
                          And InRng(i, currCol).HasFormula And Not InRng(i, currCol).HasArray Then
                            RngArray(i, j) = InRng(i, currCol).Formula
                        Else
                            RngArray(i, j) = InRng(i, currCol).Value2
                        End If
                    Next i
                    n = n + 1
                Next j
            
            ElseIf Me.optRows Then
                
                For i = k To LRow Step NGroup
                    CurrRow = LRow - (n * NGroup) + k
                    For j = 1 To LCol
                        If Me.chkFormulas And Not InRng(CurrRow, j).HasArray Then
                            RngArray(i, j) = InRng(CurrRow, j).Formula
                        Else
                            RngArray(i, j) = InRng(CurrRow, j).Value2
                        End If
                    Next j
                    n = n + 1
                Next i
            End If
        Next k
        
        InRng.NumberFormat = "@"
        InRng = RngArray
        InRng.NumberFormat = "General"
    
    End With
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmMoveDataBlocks"
Attribute VB_Base = "0{DB292D0D-2BE2-4176-86A6-5023939CC018}{72E151B2-5B15-4D89-AD1C-6E247D5E973F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Me.spbNRC.Max = ActiveSheet.Rows.Count
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    If lng > 0 Then
        Call TranslateForm(Me)
    End If
        
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub optR2C_Change()
    If lng = 0 Then
        If Me.optR2C Then Me.lblRC = "righe" Else Me.lblRC = "colonne"
    Else
        If Me.optR2C Then Me.lblRC = "rows" Else Me.lblRC = "columns"
    End If
    
    If Me.optR2C Then
        Me.spbNRC.Max = ActiveSheet.Rows.Count
    Else
        Me.spbNRC.Max = ActiveSheet.Columns.Count
    End If
    
    Me.imgR2C.visible = Me.optR2C
    Me.imgC2R.visible = Not Me.optR2C
End Sub

Private Sub spbNRC_SpinDown()
    Me.txtNRC = Me.spbNRC
End Sub

Private Sub spbNRC_SpinUp()
    Me.txtNRC = Me.spbNRC
End Sub

Private Sub txtNRC_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNRC_Change()
    If Val(Me.txtNRC) > Me.spbNRC.Max Then Me.txtNRC = Me.spbNRC.Max
    If Val(Me.txtNRC) < Me.spbNRC.Min Then Me.txtNRC = Me.spbNRC.Min
    Me.spbNRC = Me.txtNRC
End Sub


Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
End Sub

Private Sub optC2R_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optR2C_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim DataWs As Worksheet
    Dim wsNew As Worksheet
    Dim oMatrix()
    Dim nMatrix()
    Dim i As Long, j As Long, block As Long, cRow As Long, cCol As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        On Error GoTo Aborted
        
        .Hide
    
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
        
        Set DataWs = ActiveSheet
        Set InRng = RangeResize(Range(Replace(Me.refRange, ";", ",")), DataWs)
        
        oMatrix = InRng.Value2
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Ricostruisco l'intervallo..."
        Call ShowProgressBar
        
        If .optR2C Then
            ReDim nMatrix(1 To .txtNRC + .txtHeader, 1 To (InRng.Columns.Count * (Application.WorksheetFunction.RoundUp((InRng.Rows.Count - .txtHeader) / .txtNRC, 0))))
            
            '#' Intestazione
            If .txtHeader > 0 Then
                For i = 1 To .txtHeader
                    For j = 1 To UBound(nMatrix, 2)
                        nMatrix(i, j) = oMatrix(i, IIf(j Mod UBound(oMatrix, 2) = 0, UBound(oMatrix, 2), j Mod UBound(oMatrix, 2)))
                    Next j
                Next i
            End If
            
            block = 1
            
            For i = LBound(oMatrix, 1) + .txtHeader To UBound(oMatrix, 1)
                For j = LBound(oMatrix, 2) To UBound(oMatrix, 2)
                    
                    '#' Aumenta di 1 il contatore
                    counter = counter + 1
                    
                    cRow = (i - .txtHeader) Mod .txtNRC
                    If cRow = 0 Then cRow = .txtNRC
                    
                    nMatrix(cRow + .txtHeader, j + (UBound(oMatrix, 2) * (block - 1))) = oMatrix(i, j)
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                
                Next j
                If (i - .txtHeader) Mod .txtNRC = 0 Then block = block + 1
            Next i
    
        ElseIf .optC2R Then
        
            ReDim nMatrix(1 To (InRng.Rows.Count * (Application.WorksheetFunction.RoundUp(InRng.Columns.Count / .txtNRC, 0))), 1 To .txtNRC)
            
            '#' Intestazione
            If .txtHeader > 0 Then
                For i = 1 To .txtHeader
                    For j = 1 To .txtNRC
                        nMatrix(i, j) = oMatrix(i, j)
                    Next j
                Next i
            End If
            
            block = 1
            
            For j = LBound(oMatrix, 2) To UBound(oMatrix, 2)
                For i = LBound(oMatrix, 1) + .txtHeader To UBound(oMatrix, 1)
                    
                    '#' Aumenta di 1 il contatore
                    counter = counter + 1
                    
                    cCol = j Mod .txtNRC
                    If cCol = 0 Then cCol = .txtNRC
                    
                    nMatrix(i + ((UBound(oMatrix, 1) - .txtHeader) * (block - 1)), cCol) = oMatrix(i, j)
                    
                Next i
                If j Mod .txtNRC = 0 Then block = block + 1
    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next j
                
        End If
                        
        Set wsNew = Worksheets.Add(After:=ActiveSheet)
        wsNew.Name = Left(DataWs.Name, 9) & "_rebuild" & "_" & Format(Now, "yymmdd hhmmss")
        wsNew.Range("A1").reSize(UBound(nMatrix, 1), UBound(nMatrix, 2)) = nMatrix
        
        '#' Chiude la finestra di avanzamento
        Unload UProgress
    
    End With
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmMoveSortColumns"
Attribute VB_Base = "0{E22A8277-EC8F-454B-820A-125C4719392B}{5EA3673D-884E-493B-A3C4-4984B7AFB12E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit


Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Me.lbxBaseColumns.RowSource = ""
    Me.lbxBaseColumns.Clear
    
    Set InRng = ActiveSheet.Range("A1:" & findlastcell(ActiveSheet.Cells).address)
    Call ListColumns(InRng, Me.lbxBaseColumns, Me.chkHeader)
    
    With Me.cbxFormat
        .AddItem "Excel 2007+ (.xlsx)"
        .AddItem "Excel 97-2003 (.xls)"
        .AddItem "PDF (.pdf)"
        .AddItem "Open Document Format (.ods)"
        .AddItem "Excel 95/5.0 (.xls)"
        .AddItem "Testo con delimitatore (.csv)"
        .AddItem "Testo Unicode (.txt)"
        .ListIndex = 0
    End With

    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub


Private Sub cmdToRight_Click()
    Dim i As Long
    Dim Shift As Long
    Dim newindex As Long
    
    For i = Me.lbxBaseColumns.ListCount - 1 To 0 Step -1
        If Me.lbxBaseColumns.Selected(i) = True Then
            newindex = Me.lbxNewColumns.ListCount - Shift
            Me.lbxNewColumns.AddItem Me.lbxBaseColumns.List(i), newindex
            Me.lbxBaseColumns.RemoveItem i
            Shift = Shift + 1
        End If
    Next i
    Call GoodToGo(Me)
End Sub

Private Sub cmdToLeft_Click()
    Dim i As Long
    
    For i = Me.lbxNewColumns.ListCount - 1 To 0 Step -1
        If Me.lbxNewColumns.Selected(i) = True Then
            Me.lbxBaseColumns.AddItem Me.lbxNewColumns.List(i)
            Me.lbxNewColumns.RemoveItem i
'            counter = counter + 1
        End If
    Next i
    Call GoodToGo(Me)
    Call SortListCombobox(Me.lbxBaseColumns, SortType:=2)
'    If counter > 1 Then Call SortListCombobox(Me.lbxBaseColumns, SortType:=2)
End Sub

Private Sub lbxBaseColumns_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdToRight_Click
End Sub

Private Sub lbxNewColumns_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdToLeft_Click
End Sub


Private Sub cmdMoveUp_Click()
    Dim tmpVal As Variant
    Dim i As Long
    Dim topI As Boolean
    
    For i = 1 To Me.lbxNewColumns.ListCount - 1
        If Me.lbxNewColumns.Selected(i) = True Then
            tmpVal = Me.lbxNewColumns.List(i - 1)
            Me.lbxNewColumns.RemoveItem i - 1
            Me.lbxNewColumns.AddItem tmpVal, i
            If topI = False And Me.lbxNewColumns.TopIndex > i - 1 Then
                Me.lbxNewColumns.TopIndex = i - 1
                topI = True
            End If
        End If
    Next i
    Me.lbxNewColumns.SetFocus
End Sub

Private Sub cmdMoveDown_Click()
    Dim tmpVal As Variant
    Dim i As Long
    
    For i = Me.lbxNewColumns.ListCount - 2 To 0 Step -1
        If Me.lbxNewColumns.Selected(i) = True Then
            tmpVal = Me.lbxNewColumns.List(i + 1)
            Me.lbxNewColumns.RemoveItem i + 1
            Me.lbxNewColumns.AddItem tmpVal, i
            Me.lbxNewColumns.TopIndex = i - 1
        End If
    Next i
    Me.lbxNewColumns.SetFocus
End Sub

Private Sub cmdMoveDown_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdMoveDown_Click
End Sub

Private Sub cmdMoveUp_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdMoveUp_Click
End Sub

Private Sub chkAllNone_Change()
    Dim i As Long
    
    For i = 0 To Me.lbxBaseColumns.ListCount - 1
        Me.lbxBaseColumns.Selected(i) = Me.chkAllNone
    Next i
End Sub

Private Sub chkHeader_Change()
    Set InRng = ActiveSheet.Range("A1:" & findlastcell(ActiveSheet.Cells).address)
    Call SwitchHeaders(InRng, Me.lbxBaseColumns, Me.chkHeader)
    Call SwitchHeaders(InRng, Me.lbxNewColumns, Me.chkHeader)
End Sub

Private Sub cbxFormat_Change()
    Me.cbxFormat.ControlTipText = Me.cbxFormat.Text
End Sub

Private Sub optSaveAs_Change()
    Me.cbxFormat.Enabled = Me.optSaveAs
End Sub

Private Sub optInPlace_Change()
    Dim i As Long
    
    On Error Resume Next
    
    If Me.optInPlace = True Then
        For i = 0 To Me.lbxNewColumns.ListCount - 1
            Me.lbxNewColumns.Selected(i) = True
        Next i
        Call cmdToLeft_Click
        Me.chkAllNone = False
        Me.chkAllNone = True
        Call cmdToRight_Click
    End If
    
    Me.lbxBaseColumns.Enabled = Not Me.optInPlace
    Me.cmdToLeft.Enabled = Not Me.optInPlace
    Me.cmdToRight.Enabled = Not Me.optInPlace
        
    On Error GoTo 0
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim aWs As Worksheet
    Dim newWb As Workbook
    Dim newWs As Worksheet
    Dim tmpWs As Worksheet
    Dim i As Long
    Dim ColCount As Long
    Dim ColIndex As Long
    Dim vFilePath As Variant
    Dim fName As String
    Dim fExt As String
    Dim fFilter As String
    Dim FileFormatNum As Long
    Dim overwrite As Long
    
    Me.Hide
    
    Call AutoCalc(False)
    
    If Me.optSaveAs = True Then
        fExt = Replace(Split(Me.cbxFormat.Text, "(")(1), ")", "")
        fName = Replace(ActiveWorkbook.Name, "." & Split(ActiveWorkbook.Name, ".")(UBound(Split(ActiveWorkbook.Name, "."))), "")
        fFilter = Replace(Me.cbxFormat.Text, "(", "(*") & ", " & fExt
    
        Do
            If IsWindows = True Then
                vFilePath = Application.GetSaveAsFilename( _
                            InitialFileName:=ActiveWorkbook.path & pSep & fName & fExt, _
                            FileFilter:=fFilter, _
                            Title:="Esporta le colonne selezionate")
            Else
                vFilePath = Application.GetSaveAsFilename(InitialFileName:=ActiveWorkbook.path & pSep & fName & fExt)
            End If
            '#' --exit if cancelled by user,
            If vFilePath = False Then Exit Sub
            
            '#' --ask user if he wants to overwrite
            If FileExists(vFilePath) Then
                overwrite = MsgBox("Sovrascrivere il file " & vFilePath & "?", vbExclamation + vbYesNo, "Conferma sovrascrittura")
                            
                If overwrite = vbNo Then
                    vFilePath = ""
                    AutoCalc True
                    AutoCalc False
                End If
                
            End If
        Loop Until vFilePath <> ""
    End If
    
    
    Set aWs = ActiveSheet
    aWs.Copy After:=Worksheets(aWs.index)
    Set tmpWs = ActiveSheet
    Set newWb = Workbooks.Add
    Set newWs = newWb.Worksheets(1)
    newWs.Name = Left(aWs.Name, 25) & "_edit"
    
    ColCount = 1
    For i = 0 To Me.lbxNewColumns.ListCount - 1
        ColIndex = ColItemToNumber(Me.lbxNewColumns.List(i))
        aWs.Columns(ColIndex).Cut newWs.Cells(1, ColCount)
        ColCount = ColCount + 1
    Next i
    tmpWs.Cells.Copy aWs.Cells(1, 1)
    Application.DisplayAlerts = False
    tmpWs.Delete
    Application.DisplayAlerts = True
    
    With newWs
        If Me.chkFormats = False Then
            .Cells.ClearFormats
        End If
        
        If Me.chkValues = True Then
            Call Cvalues(newWs, True)
        End If
    End With
    
    If Me.optInPlace = True Then
        aWs.Activate
        Call backup_create_new
        Application.DisplayAlerts = False
        newWs.UsedRange.Cut
        aWs.Range("A1").Select
        aWs.Paste
        newWb.Close False
        Application.DisplayAlerts = False
    End If
    
    If Me.optSaveAs = True Then
        Select Case Me.cbxFormat.ListIndex
            Case 0 '#' Excel 2007+
                FileFormatNum = 51
            Case 1 '#' Excel 97-2003
                FileFormatNum = 56
            Case 2 '#' PDF
                '#' No variables set
            Case 3 '#' Open Document
                FileFormatNum = 60
            Case 4 '#' Excel 95
                FileFormatNum = 39
            Case 5 '#' CSV
                FileFormatNum = 6
            Case 6 '#' TXT
                FileFormatNum = 42
        End Select
            
        '#' Save the new workbook and close it
        Application.DisplayAlerts = False
        With newWb
            
            Select Case Me.cbxFormat.ListIndex
                Case 2 '#' PDF
                    .Sheets(1).ExportAsFixedFormat Type:=xlTypePDF, FileName:=vFilePath, Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:=False
                Case Else
                    Call SaveFile(newWb, vFilePath, NewFileFormat:=FileFormatNum, NewFileLocal:=True, Silent:=True)
            End Select
            
            .Close False
        
        End With
        MsgBox IIf(lng = 0, _
            "File salvato al percorso: " & vbNewLine & vFilePath, _
            "File saved: " & vbNewLine & vFilePath), vbInformation
        Application.DisplayAlerts = True
        
    End If
    
    Call AutoCalc(True)
    
    Exit Sub
        
Aborted:
    If Me.cbxFormat.ListIndex = 2 Then
        Call Excel2007PDF
    End If
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmMultipleSort"
Attribute VB_Base = "0{62BACA03-6BE3-4464-8161-7CED7DF489BD}{EC6388D5-9B7D-4308-800E-384A783D3088}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
        
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    
    Call ListColumns(Range(Me.refRange), Me.cbxSortCol1, Me.chkHeader)
    Me.cbxFilterCol.List = Me.cbxSortCol1.List
    Me.cbxFilterCol.ListIndex = 0
    
    On Error GoTo 0
    
    With Me.cbxSortOrder1
        .AddItem "Dal pi|fffd| piccolo al pi|fffd| grande"
        .AddItem "Dal pi|fffd| grande al pi|fffd| piccolo"
        .ListIndex = 0
    End With
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
        
End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    Call ListColumns(Range(Me.refRange), Me.cbxSortCol1, Me.chkHeader)
    Me.cbxFilterCol.List = Me.cbxSortCol1.List
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then
        Me.refRange = ActiveSheet.UsedRange.address
        Call ListColumns(Range(Me.refRange), Me.cbxSortCol1, Me.chkHeader)
        Me.cbxFilterCol.List = Me.cbxSortCol1.List
    Else
        Me.refRange.SetFocus
    End If
End Sub

Private Sub mpgCriteria_Change()
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
End Sub

Private Sub cmdAddCriteria_Click()
    Call AddCriteria
End Sub

Private Sub cmdAddCriteria_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdAddCriteria_Click
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
End Sub

Private Sub AddCriteria()
    Dim newindex As Long
    
    newindex = Me.mpgCriteria.Pages.Count + 1
    
    On Error Resume Next
    
    With Me.mpgCriteria.Pages.Add
        .Name = "pagC" & newindex
        .Caption = "C" & newindex
        With .Controls.Add("Forms.Label.1", "lblSortCol" & newindex)
            .Top = Me.lblSortCol1.Top
            .Left = Me.lblSortCol1.Left
            .Width = Me.lblSortCol1.Width
            .Height = Me.lblSortCol1.Height
            .Font.Size = Me.lblSortCol1.Font.Size
            .Caption = Me.lblSortCol1.Caption
        End With
    
        With .Controls.Add("Forms.ComboBox.1", "cbxSortCol" & newindex)
            .Top = Me.cbxSortCol1.Top
            .Left = Me.cbxSortCol1.Left
            .Width = Me.cbxSortCol1.Width
            .Height = Me.cbxSortCol1.Height
            .Font.Size = Me.cbxSortCol1.Font.Size
            .List = Me.cbxSortCol1.List
            .ListIndex = 0
        End With
    
        With .Controls.Add("Forms.Label.1", "lblSortOrder" & newindex)
            .Top = Me.lblSortOrder1.Top
            .Left = Me.lblSortOrder1.Left
            .Width = Me.lblSortOrder1.Width
            .Height = Me.lblSortOrder1.Height
            .Font.Size = Me.lblSortOrder1.Font.Size
            .Caption = Me.lblSortOrder1.Caption
        End With
    
        With .Controls.Add("Forms.ComboBox.1", "cbxSortOrder" & newindex)
            .Top = Me.cbxSortOrder1.Top
            .Left = Me.cbxSortOrder1.Left
            .Width = Me.cbxSortOrder1.Width
            .Height = Me.cbxSortOrder1.Height
            .Font.Size = Me.cbxSortOrder1.Font.Size
            .List = Me.cbxSortOrder1.List
            .ListIndex = 0
        End With
    
    End With
    
    On Error GoTo 0
    
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
    Me.mpgCriteria.Value = Me.mpgCriteria.Pages.Count - 1

End Sub

Private Sub cmdDeleteCriteria_Click()
    Call DeleteCriteria(Me.mpgCriteria.Value)
    Me.cmdDeleteCriteria.Enabled = (Me.mpgCriteria.Pages.Count > 1)
End Sub

Private Sub cmdDeleteCriteria_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdDeleteCriteria_Click
End Sub

Private Sub DeleteCriteria(pag As Long)
    Dim ctl As control
    Dim i As Long
    
    Me.mpgCriteria.Pages.Remove (pag)
    
    For i = 0 To Me.mpgCriteria.Pages.Count - 1
        If i >= pag Then
            Me.mpgCriteria.Pages(i).Name = Replace(Me.mpgCriteria.Pages(i).Name, i + 2, i + 1)
            Me.mpgCriteria.Pages(i).Caption = Replace(Me.mpgCriteria.Pages(i).Caption, i + 2, i + 1)
            For Each ctl In Me.mpgCriteria.Pages(i).Controls
                ctl.Name = Replace(ctl.Name, i + 2, i + 1)
            Next ctl
        End If
    Next i
End Sub

Private Sub chkHeader_Click()
    Dim CurrColSelection As Long
    Dim i As Long
    
    
    For i = 0 To Me.mpgCriteria.Pages.Count - 1
        'Salvo la voce selezionata in una variabile
        CurrColSelection = Me.mpgCriteria.Pages(i).Controls("cbxSortCol" & i + 1).ListIndex
        
        'Switcho le intestazioni
        Call SwitchHeaders(ActiveSheet.Range(Me.refRange), Me.mpgCriteria.Pages(i).Controls("cbxSortCol" & i + 1), Me.chkHeader)
        
        'Riseleziono la voce precedente
        Me.mpgCriteria.Pages(i).Controls("cbxSortCol" & i + 1).ListIndex = CurrColSelection
        
    Next i
        
    CurrColSelection = Me.cbxFilterCol.ListIndex
    Me.cbxFilterCol.List = Me.cbxSortCol1.List
    Me.cbxFilterCol.ListIndex = CurrColSelection
        
End Sub

Private Sub spbNRows_SpinDown()
    Me.txtNRows = Me.spbNRows
End Sub

Private Sub spbNRows_SpinUp()
    Me.txtNRows = Me.spbNRows
End Sub
Private Sub txtNRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNRows_Change()
    If Val(Me.txtNRows) > Me.spbNRows.Max Then Me.txtNRows = Me.spbNRows.Max
    If Val(Me.txtNRows) < Me.spbNRows.Min Then Me.txtNRows = Me.spbNRows.Min
    Me.spbNRows = Me.txtNRows
End Sub

Private Sub optFilterCol_Change()
    Me.cbxFilterCol.Enabled = Me.optFilterCol
    Me.txtNRows.Enabled = Not Me.optFilterCol
    Me.spbNRows.Enabled = Not Me.optFilterCol
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim SortRng As Range
    Dim i As Long
    Dim n As Long
    Dim k As Long
    Dim fCol As Long
    Dim head As Long
    Dim SortArray As Variant
        
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    Call backup_create_new
     
    Set ws = ActiveSheet
    head = Abs(CInt(Me.chkHeader))
        
    'Array delle colonne da ordinare
    ReDim SortArray(0 To Me.mpgCriteria.Pages.Count - 1, 0 To 1)
    For i = 0 To Me.mpgCriteria.Pages.Count - 1
        SortArray(i, 0) = ColItemToNumber(Me.mpgCriteria.Pages(i).Controls("cbxSortCol" & i + 1).Text)
        SortArray(i, 1) = Me.mpgCriteria.Pages(i).Controls("cbxSortOrder" & i + 1).ListIndex
    Next i
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Rows.Count
        UProgress.SetDescription "Sto riordinando i dati... (" & ws.Name & ")"
        Call ShowProgressBar
        
        If Me.optNRows = True Then
            
            n = Me.txtNRows        'intervallo di righe da ordinare
            
            For i = 1 + head To InRng.Rows.Count
                
                '#' Aumento di 1 il contatore
                counter = i
                                    
                Set SortRng = Intersect(InRng, InRng.Rows(i).reSize(n))
                
                Application.DisplayAlerts = False
                With ws.Sort
                    .SortFields.Clear
                    For k = 0 To UBound(SortArray, 1)
                        .SortFields.Add key:=SortRng.Columns(SortArray(k, 0) - SortRng.Column + 1), SortOn:=xlSortOnValues, Order:=IIf(SortArray(k, 1) = 0, xlAscending, xlDescending), DataOption:=xlSortNormal
                    Next k
                    .SetRange SortRng
                    .header = xlNo
                    .MatchCase = False
                    .Orientation = xlTopToBottom
                    .SortMethod = xlPinYin
                    .Apply
                End With
                Application.DisplayAlerts = True
                           
                i = i + n - 1
                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
        
            Next i
            
        ElseIf Me.optFilterCol = True Then
        
            For i = 1 + head To InRng.Rows.Count
                
                '#' Aumento di 1 il contatore
                counter = i
                n = 0
                fCol = ColItemToNumber(Me.cbxFilterCol.Text) - InRng.Column + 1
                
                Do
                    n = n + 1
                Loop Until InRng(i + n, fCol) <> InRng(i, fCol)
                                    
                Set SortRng = Intersect(InRng, InRng.Rows(i).reSize(n))
                Application.DisplayAlerts = False
                With ws.Sort
                    .SortFields.Clear
                    For k = 0 To UBound(SortArray, 1)
                        .SortFields.Add key:=SortRng.Columns(SortArray(k, 0) - SortRng.Column + 1), SortOn:=xlSortOnValues, Order:=IIf(SortArray(k, 1) = 0, xlAscending, xlDescending), DataOption:=xlSortNormal
                    Next k
                    .SetRange SortRng
                    .header = xlNo
                    .MatchCase = False
                    .Orientation = xlTopToBottom
                    .SortMethod = xlPinYin
                    .Apply
                End With
                Application.DisplayAlerts = True
                
                i = i + n - 1
                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
        
            Next i
                  
        End If
        
    End If
    
    'Chiude la finestra di avanzamento
    Unload UProgress

    Call AutoCalc(True)
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)
    
    Call Cleanup
End Sub


Attribute VB_Name = "frmPivotByGroups"
Attribute VB_Base = "0{CB95CDE0-E88D-46C9-AB56-C8A66F2C1048}{1E4AD056-2C98-4FE7-8530-62A2438374AC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.Columns(1).address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.Columns(1).address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    If lng > 0 Then
        Call TranslateForm(Me)
        With Me.cbxStartEnd
            .AddItem "Start a new block"
            .AddItem "Ends block"
            .ListIndex = 0
        End With
    Else
        With Me.cbxStartEnd
            .AddItem "Inizio un nuovo blocco"
            .AddItem "Termino il blocco"
            .ListIndex = 0
        End With
    End If
        
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub


Private Sub refRange_Change()
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    If DisableEvents = False Then
        On Error Resume Next
        DisableEvents = True
        Me.refRange = MergeAreas(Range(Me.refRange)).Columns(1).address
        Range(Me.refRange).Select
        On Error GoTo 0
    End If
    DisableEvents = False
End Sub

Private Sub optNRows_Change()
    Me.cbxStartEnd.Enabled = Not Me.optNRows
    Me.txtNRows.Enabled = Me.optNRows
    Me.spbNRows.Enabled = Me.optNRows
    If Me.optNRows Then Me.spbNRows.SetFocus Else Me.txtFindText.SetFocus
End Sub

Private Sub spbNRows_SpinDown()
    Me.txtNRows = Me.spbNRows
End Sub

Private Sub spbNRows_SpinUp()
    Me.txtNRows = Me.spbNRows
End Sub

Private Sub txtNRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNRows_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtNRows) > Me.spbNRows.Max Then Me.txtNRows = Me.spbNRows.Max
    If Val(Me.txtNRows) < Me.spbNRows.Min Then Me.txtNRows = Me.spbNRows.Min
    Me.spbNRows = Me.txtNRows
End Sub

Private Sub txtFindText_Enter()
    Me.optFindText = True
End Sub

Private Sub txtFindText_Change()
    Me.txtFindText.ControlTipText = Me.txtFindText.Text
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim nMatrix()
    Dim wsNew As Worksheet
    Dim i As Long, j As Long
    Dim cMax As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        If .optFindText = True And .txtFindText = "" Then
            MsgBox "Attenzione: |fffd| necessario inserire un testo di ricerca. Riprovare", vbExclamation, "Errore: testo di ricerca non inserito"
            .txtFindText.SetFocus
            Exit Sub
        End If
        
        On Error GoTo Aborted
        
        .Hide
    
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
        
        
    
        On Error GoTo Aborted
        
        Set InRng = RangeResize(Range(Replace(Me.refRange, ";", ",")), ActiveSheet)
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Riporto i dati in colonna..."
        Call ShowProgressBar
        
        i = 0
        j = 1
        
        If .optNRows Then
            ReDim nMatrix(1 To Round((InRng.Rows.Count / .txtNRows) + 0.5, 0), 1 To Val(.txtNRows))
            
            For Each cell In InRng.Cells
            
                '#' Aumenta di 1 il contatore
                counter = counter + 1
                        
                If j Mod .txtNRows = 1 Then
                    i = i + 1
                    j = 1
                End If
                nMatrix(i, j) = cell
                j = j + 1
        
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next cell
                
        ElseIf .optFindText Then
        
            cMax = 1
            
            ReDim nMatrix(1 To InRng.Rows.Count, 1 To 1)
            
            For Each cell In InRng.Cells
            
                '#' Aumenta di 1 il contatore
                counter = counter + 1
                        
                Select Case Me.cbxStartEnd.ListIndex
                    Case 0
                        If i = 0 Or InStr(1, cell, .txtFindText) > 0 Then
                            i = i + 1
                            j = 1
                        End If
                        nMatrix(i, j) = cell
                        j = j + 1
                        If j > cMax Then
                            ReDim Preserve nMatrix(1 To InRng.Rows.Count, 1 To j)
                            cMax = j
                        End If
                    Case 1
                        If i = 0 Then
                            i = i + 1
                            j = 1
                        End If
                        nMatrix(i, j) = cell
                        If InStr(1, cell, Me.txtFindText) > 0 Then
                            i = i + 1
                            j = 1
                        Else
                            j = j + 1
                            If j > cMax Then
                                ReDim Preserve nMatrix(1 To InRng.Rows.Count, 1 To j)
                                cMax = j
                            End If
                        End If
                End Select
                        
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next cell
                
        End If
                        
        Set wsNew = Worksheets.Add(After:=ActiveSheet)
        wsNew.Name = Left(ActiveSheet.Name, 10) & "_pivot" & "_" & Format(Now, "yymmdd hhmmss")
        wsNew.Range("A1").reSize(UBound(nMatrix, 1), UBound(nMatrix, 2)) = nMatrix
        
        '#' Chiude la finestra di avanzamento
        Unload UProgress
    
    
    End With
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmPivotToRange"
Attribute VB_Base = "0{614FEEA8-934D-4CF5-9F44-972911D2B923}{EDE9CDAA-C2F1-463B-AD25-2673FAB38E50}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean
Dim DisableAlerts As Boolean


Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    DisableAlerts = True
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    DisableAlerts = False
    
    Call PopulateTableList

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Sub PopulateTableList()
    Dim cTables As New Collection
    Dim pt As PivotTable
    Dim i As Long
    
    Me.lbxTables.Clear
    
    For Each ws In ActiveWorkbook.Worksheets
        If UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*" Then
            For Each pt In ws.PivotTables
                Me.lbxTables.AddItem ws.Name & ": " & pt.Name
                If IsSelected(ws.Name) Or ActiveWindow.SelectedSheets.Count = 1 Then Me.lbxTables.Selected(Me.lbxTables.ListCount - 1) = True
            Next pt
        End If
    Next ws

    '#' Popolo la collection delle tabelle selezionate
    For i = 0 To Me.lbxTables.ListCount - 1
        If Me.lbxTables.Selected(i) = True Then cTables.Add Me.lbxTables.List(i)
    Next i
    
    If cTables.Count = Me.lbxTables.ListCount Then Me.chkAllNone = True

End Sub

Private Sub txtFilterList_Change()
    Call PopulateTableList
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxTables.ListCount - 1
        Me.lbxTables.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GoodToGo(Me)
End Sub

Private Sub lbxTables_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim pt As PivotTable
    Dim wsPaste As Worksheet
    Dim wsName As String
    Dim SelSheets As New Collection
    Dim FirstCell As Range
    Dim i As Long, n As Long, j As Long, c As Long
    Dim CopyRng As Range
    Dim uR As Long
    
    '#' Popolo la collection dei fogli selezionati
    For i = 0 To Me.lbxTables.ListCount - 1
        wsName = Split(Me.lbxTables.List(i), ":")(0)
        If Me.lbxTables.Selected(i) = True Then SelSheets.Add ActiveWorkbook.Worksheets(wsName)
    Next i
    
    Me.Hide
    
    Call AutoCalc(False)

    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = SelSheets.Count
    UProgress.SetDescription "Converto le Tabelle Pivot selezionate..."
    Call ShowProgressBar
    
    For Each ws In SelSheets
        
        For Each pt In ws.PivotTables
        
            'Aumenta di 1 il contatore, aggiorna descrizione avanzamento
            counter = counter + 1
            UProgress.SetDescription "Converto la tabella pivot... (" & pt.Name & ")"
            
            If Me.chkUpdatePivot = True Then
                pt.Update
            End If
            
            'Detect pivot table data range first cell and copy the whole data range
            Set FirstCell = pt.TableRange1.Cells(1, 1)
            pt.TableRange1.Copy
            
            'Create temporary sheet to paste contents along with formatting
            Set wsPaste = Worksheets.Add
            wsPaste.Cells(1, 1).PasteSpecial
            
            'Get back to pivot table sheet, clear it and paste data from temporary sheet (and optionally formats)
            ws.Activate
            pt.PivotSelect "", xlDataAndLabel, True
            Selection.Clear
            wsPaste.UsedRange.Copy
            FirstCell.PasteSpecial xlPasteValues
            If Me.chkFormats = True Then
                FirstCell.PasteSpecial xlPasteFormats
            End If
            
            'Delete temporary sheet
            Application.DisplayAlerts = False
            wsPaste.Delete
            Application.DisplayAlerts = True
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            DoEvents
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        Next pt
    
    Next ws
    
    Unload UProgress
    
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmRandomFill"
Attribute VB_Base = "0{73A3BD29-437F-4737-A3DB-C2786B069CC2}{2E856094-0284-416A-878C-A40B7F00AE29}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    Me.txtMin = 0
    Me.txtMax = 100
    Me.txtDecimal = 0
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    Call CalcNumbers

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
    Call CalcNumbers
End Sub

Private Sub txtMin_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = 46 Or KeyAscii = 44 Then
        KeyAscii = Asc(dSep)
    ElseIf KeyAscii = 45 Then
    ElseIf KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub txtMin_Change()
    If Me.txtMin = "" Then Me.txtMin = 0
    Call CalcNumbers
    Me.txtMin.ControlTipText = Me.txtMin.Text
End Sub

Private Sub txtMax_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = 46 Or KeyAscii = 44 Then
        KeyAscii = Asc(dSep)
    ElseIf KeyAscii = 45 Then
    ElseIf KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub txtMax_Change()
    If Me.txtMax = "" Then Me.txtMax = 0
    Call CalcNumbers
    Me.txtMax.ControlTipText = Me.txtMax.Text
End Sub

Private Sub spbDecimal_SpinDown()
    Me.txtDecimal = Me.spbDecimal
    Call CalcNumbers
End Sub

Private Sub spbDecimal_SpinUp()
    Me.txtDecimal = Me.spbDecimal
    Call CalcNumbers
End Sub

Private Sub txtDecimal_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub txtDecimal_Change()
    If Val(Me.txtDecimal) > Me.spbDecimal.Max Then Me.txtDecimal = Me.spbDecimal.Max
    If Val(Me.txtDecimal) < Me.spbDecimal.Min Then Me.txtDecimal = Me.spbDecimal.Min
    Me.spbDecimal = Me.txtDecimal
    Call CalcNumbers
    Me.txtDecimal.ControlTipText = Me.txtDecimal.Text
End Sub
Private Sub CalcNumbers()
    Dim totNumeri As Long
    Dim cellCount As Long
    
    If Me.txtMin = "" Or Me.txtMax = "" Then
        Me.cmdOK.Enabled = False
        Exit Sub
    End If
    
    On Error Resume Next
        totNumeri = CLng(CDbl(Me.txtMax) * 10 ^ Me.txtDecimal) - CLng(CDbl(Me.txtMin) * 10 ^ Me.txtDecimal) + 1
        cellCount = Range(Replace(Me.refRange, ";", ",")).CountLarge
    
        Me.chkNodupes.Enabled = (totNumeri >= cellCount) + (Err.Number > 0)
    On Error GoTo 0

End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim RngArray()
    Dim i As Long, j As Long, n As Long
    Dim totNumeri As Long
    Dim iPos As Long
    Dim Estratti() As Double
    Dim Numeri As New Collection
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        If Range(Replace(.refRange, ";", ",")).Areas.Count > 1 Then
            MsgBox TranslateCnst("MultipleRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.Areas(1).address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        If Application.WorksheetFunction.IsNumber(Val(.txtMin)) = False _
        Or Application.WorksheetFunction.IsNumber(Val(.txtMax)) = False _
        Or Val(.txtMin) > Val(.txtMax) Then
            MsgBox TranslateCnst("InvalidNumRange"), vbExclamation
            .txtMin.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        .Hide
        
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
        
        
    
        '#' Crea foglio di backup nascosto
        Call backup_create_new
    
        '#' Popolo la collection con tutti i numeri possibili
        totNumeri = CLng(.txtMax * 10 ^ .txtDecimal) - CLng(.txtMin * 10 ^ .txtDecimal)
        For i = 0 To totNumeri
            Numeri.Add i, CStr(i)
        Next i
        ReDim Estratti(1 To totNumeri)
            
        Set ws = ActiveSheet
        
        Set InRng = ws.Range(Replace(.refRange, ";", ","))
        
        ReDim RngArray(1 To InRng.Rows.Count, 1 To InRng.Columns.Count)
                   
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Riempio con numeri casuali... (" & ws.Name & ")"
        Call ShowProgressBar
        
        n = totNumeri
        
        Randomize
                
        For i = 1 To UBound(RngArray, 1)
            For j = 1 To UBound(RngArray, 2)
                'Aumento di 1 il Counter
                counter = counter + 1
                
                If .chkNodupes.Enabled = True And .chkNodupes = True Then
                    iPos = Int((n * Rnd) + 1)
                    RngArray(i, j) = Round(.txtMin + (Numeri(iPos) / 10 ^ .txtDecimal), .txtDecimal)
                    Numeri.Remove (iPos)
                    n = n - 1
                Else
                    RngArray(i, j) = Round(.txtMin + (Rnd() * (.txtMax - .txtMin)), .txtDecimal)
                End If
                                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next j
        Next i
        InRng = RngArray()
    
        'Chiudo la finestra avanzamento
        Unload UProgress
    
    End With
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
        
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmRandomSort"
Attribute VB_Base = "0{48529524-A25B-4221-A3E5-0941CA7DEF2C}{D86A3C89-7F80-42A2-B246-B63664ED8EB2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub optCols_Change()
    If Me.optCols Then
        Me.lblHeader = Replace(Me.lblHeader, "Righe", "Colonne")
    Else
        Me.lblHeader = Replace(Me.lblHeader, "Colonne", "Righe")
    End If
End Sub

Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
End Sub
    
Private Sub optRows_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optCols_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim i As Long
    Dim j As Long
    Dim RndRow As Long
    Dim RndCol As Long
    Dim RngArray()
    Dim TempArray()
    Dim TempWs As Worksheet
    
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    
    
    On Error GoTo Aborted
    
    Call backup_create_new
    
    Set ws = ActiveSheet
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    If Me.optRows Then
        Set InRng = Intersect(InRng, InRng.Offset(Me.txtHeader, 0))
    Else
        Set InRng = Intersect(InRng, InRng.Offset(0, Me.txtHeader))
    End If
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        If Me.optRows Then
            countermax = InRng.Rows.Count
        Else
            countermax = InRng.Columns.Count
        End If
        
        UProgress.SetDescription "Sto ordinando le " & IIf(Me.optRows, "righe", "colonne") & " in modo casuale... (" & ws.Name & ")"
        Call ShowProgressBar
        
        ReDim RngArray(1 To InRng.Rows.Count, 1 To InRng.Columns.Count)
        RngArray = InRng
                    
        Randomize
        
        If Me.chkFormat Then '#' Mantiene i formati (pi|fffd| lento)
            Worksheets.Add
            Set TempWs = ActiveSheet
            If Me.optRows Then '#' Procedo per righe
                For i = 1 To InRng.Rows.Count
                    '#' Aumenta il contatore
                    counter = counter + 1
                    
                    RndRow = Rnd() * (InRng.Rows.Count - 1) + 1
                    InRng.Rows(i).Copy TempWs.Range("A1")
                    Application.CutCopyMode = False
                    InRng.Rows(RndRow).Copy InRng(i, 1)
                    Application.CutCopyMode = False
                    TempWs.UsedRange.Copy InRng(RndRow, 1)
                    Application.CutCopyMode = False
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                Next i
                Application.DisplayAlerts = False
                TempWs.Delete
                Application.DisplayAlerts = True
                Set TempWs = Nothing
            Else '#' Procedo per colonne
                For j = 1 To InRng.Columns.Count
                    '#' Aumenta il contatore
                    counter = counter + 1
                    
                    RndCol = Rnd() * (InRng.Columns.Count - 1) + 1
                    InRng.Columns(j).Copy TempWs.Range("A1")
                    Application.CutCopyMode = False
                    InRng.Columns(RndCol).Copy InRng(1, j)
                    Application.CutCopyMode = False
                    TempWs.UsedRange.Copy InRng(1, RndCol)
                    Application.CutCopyMode = False
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                Next j
                Application.DisplayAlerts = False
                TempWs.Delete
                Application.DisplayAlerts = True
                Set TempWs = Nothing
            End If
        Else '#' Lose formats
            InRng.ClearFormats
            If Me.optRows Then '#' Procedo per righe
                ReDim TempArray(1 To InRng.Columns.Count)
                For i = LBound(RngArray, 1) To UBound(RngArray, 1)
                    '#' Aumenta il contatore
                    counter = counter + 1
                    
                    RndRow = Rnd() * (UBound(RngArray, 1) - 1) + 1
                    For j = 1 To UBound(RngArray, 2)
                        TempArray(j) = RngArray(i, j)
                        RngArray(i, j) = RngArray(RndRow, j)
                        RngArray(RndRow, j) = TempArray(j)
                    Next j
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                    
                Next i
            Else '#' Procedo per colonne
                ReDim TempArray(1 To InRng.Rows.Count)
                For j = LBound(RngArray, 2) To UBound(RngArray, 2)
                    '#' Aumenta il contatore
                    counter = counter + 1
                    
                    RndCol = Rnd() * (UBound(RngArray, 2) - 1) + 1
                    For i = 1 To UBound(RngArray, 1)
                        TempArray(i) = RngArray(i, j)
                        RngArray(i, j) = RngArray(i, RndCol)
                        RngArray(i, RndCol) = TempArray(i)
                    Next i
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                Next j
            End If
        
        End If
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
                                    
    'Converto in testo i numeri memorizzati come testo
    Call FixArrayStrings(RngArray)
    
    If Not Me.chkFormat Then InRng = RngArray
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmRandomTxtFill"
Attribute VB_Base = "0{B3807F0B-2C50-4C15-B475-C9D5220128C4}{25CCBFA5-8B8A-4CF8-9A35-429FD341FA07}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    Me.txtMinWords = 1
    Me.txtMaxWords = 3
    Me.txtMinChars = 3
    Me.txtMaxChars = 10
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    If lng > 0 Then
        Call TranslateForm(Me)
        Me.mpgTxtFill.Pages(0).Caption = TranslateCnst("Me.mpgTxtFill.Pages(0)")
        Me.mpgTxtFill.Pages(1).Caption = TranslateCnst("Me.mpgTxtFill.Pages(1)")
    End If
    
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub optSurnames_Change()
    Me.optFemale.Enabled = Not Me.optSurnames
    Me.optMale.Enabled = Not Me.optSurnames
    Me.optFemale_Male.Enabled = Not Me.optSurnames
End Sub
    
Private Sub spbMinWords_SpinUp()
    Me.txtMinWords = Me.spbMinWords
    If Val(Me.txtMaxWords) < Val(Me.txtMinWords) Then Me.txtMaxWords = Me.txtMinWords
End Sub
    
Private Sub spbMinWords_SpinDown()
    Me.txtMinWords = Me.spbMinWords
    If Val(Me.txtMaxWords) < Val(Me.txtMinWords) Then Me.txtMaxWords = Me.txtMinWords
End Sub

Private Sub txtMinWords_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub

Private Sub txtMinWords_Change()
    On Error Resume Next
    Me.spbMinWords = Me.txtMinWords
    On Error GoTo 0
End Sub

Private Sub txtMinWords_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMinWords) > Me.spbMinWords.Max Then Me.txtMinWords = Me.spbMinWords.Max
    If Val(Me.txtMinWords) < Me.spbMinWords.Min Then Me.txtMinWords = Me.spbMinWords.Min
    If Val(Me.txtMaxWords) < Val(Me.txtMinWords) Then Me.txtMaxWords = Me.txtMinWords
End Sub
    
Private Sub spbMaxWords_SpinDown()
    Me.txtMaxWords = Me.spbMaxWords
    If Val(Me.txtMaxWords) < Val(Me.txtMinWords) Then Me.txtMinWords = Me.txtMaxWords
End Sub
    
Private Sub spbMaxWords_SpinUp()
    Me.txtMaxWords = Me.spbMaxWords
    If Val(Me.txtMaxWords) < Val(Me.txtMinWords) Then Me.txtMinWords = Me.txtMaxWords
End Sub
Private Sub txtMaxWords_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub

Private Sub txtMaxWords_Change()
    On Error Resume Next
    Me.spbMaxWords = Me.txtMaxWords
    On Error GoTo 0
End Sub

Private Sub txtMaxWords_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMaxWords) > Me.spbMaxWords.Max Then Me.txtMaxWords = Me.spbMaxWords.Max
    If Val(Me.txtMaxWords) < Me.spbMaxWords.Min Then Me.txtMaxWords = Me.spbMaxWords.Min
    If Val(Me.txtMaxWords) < Val(Me.txtMinWords) Then Me.txtMinWords = Me.txtMaxWords
End Sub
    
Private Sub spbMinChars_SpinDown()
    Me.txtMinChars = Me.spbMinChars
    If Val(Me.txtMaxChars) < Val(Me.txtMinChars) Then Me.txtMaxChars = Me.txtMinChars
End Sub
    
Private Sub spbMinChars_SpinUp()
    Me.txtMinChars = Me.spbMinChars
    If Val(Me.txtMaxChars) < Val(Me.txtMinChars) Then Me.txtMaxChars = Me.txtMinChars
End Sub
Private Sub txtMinChars_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtMinChars_Change()
    On Error Resume Next
    Me.spbMinChars = Me.txtMinChars
    On Error GoTo 0
End Sub
Private Sub txtMinChars_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMinChars) > Me.spbMinChars.Max Then Me.txtMinChars = Me.spbMinChars.Max
    If Val(Me.txtMinChars) < Me.spbMinChars.Min Then Me.txtMinChars = Me.spbMinChars.Min
    If Val(Me.txtMaxChars) < Val(Me.txtMinChars) Then Me.txtMaxChars = Me.txtMinChars
End Sub
        
Private Sub spbMaxChars_SpinDown()
    Me.txtMaxChars = Me.spbMaxChars
    If Val(Me.txtMaxChars) < Val(Me.txtMinChars) Then Me.txtMinChars = Me.txtMaxChars
End Sub
        
Private Sub spbMaxChars_SpinUp()
    Me.txtMaxChars = Me.spbMaxChars
    If Val(Me.txtMaxChars) < Val(Me.txtMinChars) Then Me.txtMinChars = Me.txtMaxChars
End Sub

Private Sub txtMaxChars_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtMaxChars_Change()
    On Error Resume Next
    Me.spbMaxChars = Me.txtMaxChars
    On Error GoTo 0
End Sub
Private Sub txtMaxChars_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMaxChars) > Me.spbMaxChars.Max Then Me.txtMaxChars = Me.spbMaxChars.Max
    If Val(Me.txtMaxChars) < Me.spbMaxChars.Min Then Me.txtMaxChars = Me.spbMaxChars.Min
    If Val(Me.txtMaxChars) < Val(Me.txtMinChars) Then Me.txtMinChars = Me.txtMaxChars
End Sub
    
Private Sub spbMinLorem_SpinDown()
    Me.txtMinLorem = Me.spbMinLorem
    If Val(Me.txtMaxLorem) < Val(Me.txtMinLorem) Then Me.txtMaxLorem = Me.txtMinLorem
End Sub
    
Private Sub spbMinLorem_SpinUp()
    Me.txtMinLorem = Me.spbMinLorem
    If Val(Me.txtMaxLorem) < Val(Me.txtMinLorem) Then Me.txtMaxLorem = Me.txtMinLorem
End Sub

Private Sub txtMinLorem_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtMinLorem_Change()
    On Error Resume Next
    Me.spbMinLorem = Me.txtMinLorem
    On Error GoTo 0
End Sub
Private Sub txtMinLorem_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMinLorem) > Me.spbMinLorem.Max Then Me.txtMinLorem = Me.spbMinLorem.Max
    If Val(Me.txtMinLorem) < Me.spbMinLorem.Min Then Me.txtMinLorem = Me.spbMinLorem.Min
    If Val(Me.txtMaxLorem) < Val(Me.txtMinLorem) Then Me.txtMaxLorem = Me.txtMinLorem
End Sub
    
Private Sub spbMaxLorem_SpinDown()
    Me.txtMaxLorem = Me.spbMaxLorem
    If Val(Me.txtMaxLorem) < Val(Me.txtMinLorem) Then Me.txtMinLorem = Me.txtMaxLorem
End Sub
    
Private Sub spbMaxLorem_SpinUp()
    Me.txtMaxLorem = Me.spbMaxLorem
    If Val(Me.txtMaxLorem) < Val(Me.txtMinLorem) Then Me.txtMinLorem = Me.txtMaxLorem
End Sub
Private Sub txtMaxLorem_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtMaxLorem_Change()
    On Error Resume Next
    Me.spbMaxLorem = Me.txtMaxLorem
    On Error GoTo 0
End Sub
Private Sub txtMaxLorem_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMaxLorem) > Me.spbMaxLorem.Max Then Me.txtMaxLorem = Me.spbMaxLorem.Max
    If Val(Me.txtMaxLorem) < Me.spbMaxLorem.Min Then Me.txtMaxLorem = Me.spbMaxLorem.Min
    If Val(Me.txtMaxLorem) < Val(Me.txtMinLorem) Then Me.txtMinLorem = Me.txtMaxLorem
End Sub
    
Private Sub optNames_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optSurnames_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optFirstSecond_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optSecondFirst_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optMale_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optFemale_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optFemale_Male_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim RngArray()
    Dim LettersArray()
    Dim DigitsArray()
    Dim PunctuationArray()
    Dim SpecialArray()
    Dim SelectedArray()
    Dim i As Long
    Dim j As Long
    Dim w As Long
    Dim l As Long
    Dim s As Long
    Dim CurrWords As Long
    Dim CurrChars As Long
    Dim CurrSet As Long
    Dim arrFirstNames As Variant
    Dim arrSecondNames As Variant
    Dim Rnd1stName As Long
    Dim Rnd2ndName As Long
    Dim StrLorem As String
    Dim StartChar As Long
    Dim Chapter As String
    Dim ChapterEnd As Long
    Dim ChapterEnd2 As Long
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        If .mpgTxtFill.Value = 1 And (Val(.txtMinWords) > Val(.txtMaxWords) Or Val(.txtMinChars) > Val(.txtMaxChars)) Then
            MsgBox TranslateCnst("InvalidNumRange"), vbExclamation
            .txtMinChars.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        .Hide
        
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
        
        
    
        LettersArray = Array("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z")
        DigitsArray = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)
        PunctuationArray = Array(",", ".", ";", ":", "!", "?")
        SpecialArray = Array(Chr(64), Chr(91), Chr(92), Chr(93), Chr(94), Chr(95), Chr(96), Chr(123), Chr(124), Chr(125), Chr(126))
        
        '#' Crea foglio di backup nascosto
        Call backup_create_new
    
        On Error GoTo Aborted
        
        Set ws = ActiveSheet

         Set InRng = ws.Range(Replace(.refRange, ";", ","))
                                
         'Ridimensiona l'array del range da riempire
         ReDim RngArray(1 To InRng.Rows.Count, 1 To InRng.Columns.Count)
                                
         Select Case Me.mpgTxtFill.Value
             Case 0 'Testo casuale
         
                 'Ridimensiona e popola il range dei set di caratteri selezionati
                 s = 1
                 If .chkUpperCase Then
                     ReDim Preserve SelectedArray(1 To s)
                     SelectedArray(s) = 1
                     s = s + 1
                 End If
                 If .chkLowercase Then
                     ReDim Preserve SelectedArray(1 To s)
                     SelectedArray(s) = 2
                     s = s + 1
                 End If
                 If .chkDigits Then
                     ReDim Preserve SelectedArray(1 To s)
                     SelectedArray(s) = 3
                     s = s + 1
                 End If
                 If .chkPunctuation Then
                     ReDim Preserve SelectedArray(1 To s)
                     SelectedArray(s) = 4
                     s = s + 1
                 End If
                 If .chkSpecial Then
                     ReDim Preserve SelectedArray(1 To s)
                     SelectedArray(s) = 5
                     s = s + 1
                 End If
                 
                 '#' Attivo la finestra di avanzamento e setto contatore e massimo
                 counter = 0
                 countermax = InRng.Cells.CountLarge
                 UProgress.SetDescription "Riempio con testo casuale... (" & ws.Name & ")"
                 Call ShowProgressBar
     
                                        
                 Randomize

                 For i = 1 To UBound(RngArray, 1)
                     For j = 1 To UBound(RngArray, 2)
                     
                         '#' Aumento di 1 il contatore
                         counter = counter + 1
                         
                         'stabilisco il numero di parole per la cella
                         CurrWords = .txtMinWords + (Round(Rnd() * (.txtMaxWords - .txtMinWords), 0))
                         For w = 1 To CurrWords
                             If Not RngArray(i, j) = "" Then RngArray(i, j) = RngArray(i, j) & " "
                             'stabilisco il numero di lettere per la parola corrente
                             CurrChars = .txtMinChars + (Round(Rnd() * (.txtMaxChars - .txtMinChars), 0))
                             For l = 1 To CurrChars
                                 
                                 'seleziono casualmente il set di caratteri per la lettera corrente
                                 CurrSet = 1 + (Round(Rnd() * (UBound(SelectedArray) - 1), 0))
                                 
                                 'scrivo la lettera corrente utilizzando le opzioni selezionate
                                 Select Case SelectedArray(CurrSet)
                                     Case 1
                                         RngArray(i, j) = RngArray(i, j) & UCase(LettersArray(LBound(LettersArray) + (Round(Rnd() * (UBound(LettersArray) - LBound(LettersArray)), 0))))
                                     Case 2
                                         RngArray(i, j) = RngArray(i, j) & LCase(LettersArray(LBound(LettersArray) + (Round(Rnd() * (UBound(LettersArray) - LBound(LettersArray)), 0))))
                                     Case 3
                                         RngArray(i, j) = RngArray(i, j) & DigitsArray(LBound(DigitsArray) + (Round(Rnd() * (UBound(DigitsArray) - LBound(DigitsArray)), 0)))
                                     Case 4
                                         RngArray(i, j) = RngArray(i, j) & PunctuationArray(LBound(PunctuationArray) + (Round(Rnd() * (UBound(PunctuationArray) - LBound(PunctuationArray)), 0)))
                                     Case 5
                                         RngArray(i, j) = RngArray(i, j) & SpecialArray(LBound(SpecialArray) + (Round(Rnd() * (UBound(SpecialArray) - LBound(SpecialArray)), 0)))
                                 End Select
                             Next l
                         Next w
                         
                         '#' Aggiorna la barra di avanzamento
                         Call UpdateProgressBar(counter, countermax)
                         If ProgressAborted = 1 Then GoTo Aborted
                         On Error GoTo Aborted
                         
                     Next j
                 Next i
                 InRng = RngArray()
                 
             Case 1 'Nomi e cognomi
                 
                 '#' Attivo la finestra di avanzamento e setto contatore e massimo
                 counter = 0
                 countermax = InRng.Cells.CountLarge
                 UProgress.SetDescription "Riempio con nomi propri casuali... (" & ws.Name & ")"
                 Call ShowProgressBar
                 
                 With ThisWorkbook.Worksheets("FirstSecondNames")
                     If Me.optFemale Then
                         arrFirstNames = RngToArray(.Range("B2:B" & .Cells(.Rows.Count, 2).End(xlUp).Row))
                     ElseIf Me.optMale Then
                         arrFirstNames = RngToArray(.Range("A2:A" & .Cells(.Rows.Count, 1).End(xlUp).Row))
                     Else
                         arrFirstNames = RngToArray(Union(.Range("B2:B" & .Cells(.Rows.Count, 2).End(xlUp).Row), .Range("A2:A" & .Cells(.Rows.Count, 1).End(xlUp).Row)))
                     End If
                     arrSecondNames = RngToArray(.Range("C2:C" & .Cells(.Rows.Count, 3).End(xlUp).Row))
                 End With
                 
                 For i = 1 To UBound(RngArray, 1)
                     For j = 1 To UBound(RngArray, 2)
                     
                         '#' Aumento di 1 il contatore
                         counter = counter + 1
                         
                         Rnd1stName = 1 + (Round(Rnd() * (UBound(arrFirstNames) - 1), 0))
                         Rnd2ndName = 1 + (Round(Rnd() * (UBound(arrSecondNames) - 1), 0))
                         If Me.optNames Then
                             RngArray(i, j) = arrFirstNames(Rnd1stName)
                         ElseIf .optSurnames Then
                             RngArray(i, j) = arrSecondNames(Rnd2ndName)
                         ElseIf .optFirstSecond Then
                             RngArray(i, j) = arrFirstNames(Rnd1stName) & " " & arrSecondNames(Rnd2ndName)
                         ElseIf .optSecondFirst Then
                             RngArray(i, j) = arrSecondNames(Rnd2ndName) & " " & arrFirstNames(Rnd1stName)
                         End If
                         
                         '#' Aggiorna la barra di avanzamento
                         Call UpdateProgressBar(counter, countermax)
                         If ProgressAborted = 1 Then GoTo Aborted
                         On Error GoTo Aborted
                         
                     Next j
                 Next i
                 InRng = RngArray()
                 
             Case 2 'Lorem Ipsum
                 StrLorem = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. In quis congue tortor. Suspendisse fringilla augue in aliquet euismod. In hac habitasse platea dictumst. Integer vestibulum hendrerit ex, sed tincidunt risus suscipit eget. Aliquam laoreet dictum porttitor. Curabitur gravida erat metus, non placerat erat laoreet ut. Suspendisse dapibus facilisis mauris, non mollis quam tincidunt at. Praesent condimentum quis sem aliquet consectetur. Donec ut iaculis lacus. Morbi sit amet pharetra dui."
                 StrLorem = StrLorem & " Donec in elit ut ante semper hendrerit vitae eget magna. Maecenas urna odio, pretium ut diam a, vestibulum auctor eros. Cras ligula diam, aliquet at efficitur ut, lacinia quis eros. Vivamus gravida consectetur justo id sollicitudin. Mauris ipsum velit, hendrerit ut nibh vel, tempus efficitur nisl. Ut consectetur ornare rutrum. Curabitur rutrum convallis sagittis."
                 StrLorem = StrLorem & " Suspendisse dolor nunc, sodales eu semper ac, volutpat quis nulla. Ut posuere dignissim eros, in aliquet turpis blandit aliquam. Mauris neque odio, lobortis quis quam a, tincidunt fringilla leo. Mauris dignissim dui ut venenatis finibus. Nullam lectus elit, pulvinar sed libero sodales, laoreet gravida erat. Aenean eu condimentum mauris. Mauris tempus, augue eu efficitur accumsan, tortor metus feugiat magna, nec viverra lacus est at neque. Etiam accumsan quam nunc, a semper arcu malesuada vitae."
                 StrLorem = StrLorem & " Donec pharetra tincidunt varius. Morbi sed eros efficitur, consequat nulla rhoncus, rhoncus risus. Proin sit amet mauris vel elit viverra sollicitudin. Nullam ac lorem fermentum, posuere tortor sit amet, ultricies leo. Proin non luctus libero. Maecenas eget interdum nibh. Donec non aliquam lorem, ac sodales quam. Vivamus vestibulum malesuada erat aliquam mattis. Cras vel vulputate quam, ac dictum tortor. In tempus fermentum mauris, non condimentum purus sollicitudin nec."
                 StrLorem = StrLorem & " Phasellus feugiat ultricies massa cursus faucibus. Nam pretium dolor tellus, sit amet sagittis nisl vehicula quis. In leo risus, tempor vel metus a, commodo consequat nisi. Fusce dictum, sem sit amet volutpat cursus, diam diam maximus orci, eu maximus nisl leo et felis. Cras cursus dictum enim, eu malesuada tortor. Morbi ac tellus aliquet, pulvinar purus eu, sodales elit. Maecenas rutrum turpis accumsan justo vulputate gravida. Donec nulla ex, facilisis at ex ac, tincidunt vehicula lorem. Morbi eget gravida ante, ut pretium lacus. Etiam eget enim non massa placerat tempor ut ac quam. Nam a metus eget turpis dictum euismod. Morbi pellentesque a tortor et tincidunt. Nam sodales euismod sem eu pellentesque."
                 StrLorem = StrLorem & " Sed suscipit diam ante, quis egestas arcu suscipit vel. Sed molestie enim eget dictum bibendum. Cras ultrices lacus sit amet lorem vestibulum, a tristique quam ornare. Sed a massa vitae dolor viverra malesuada. Duis id metus vel arcu lacinia pellentesque vitae a lorem. Nullam tempor ornare arcu non facilisis. Suspendisse rutrum mollis scelerisque. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Aliquam nec nunc mauris. Donec eu dui quis mi pretium suscipit. Vivamus eleifend pulvinar sapien at accumsan. Donec ante purus, viverra ut odio quis, commodo pharetra nisi. Sed et ligula eget lacus pharetra scelerisque eu eget sem. Pellentesque accumsan ex ut eleifend iaculis. Nunc tellus orci, porta eget suscipit non, facilisis nec massa."
                 StrLorem = StrLorem & " Maecenas eleifend magna non ultrices congue. Curabitur vehicula dignissim risus, quis sollicitudin urna egestas ut. Etiam laoreet varius molestie. Nullam convallis in quam at efficitur. Sed commodo purus lobortis justo posuere, vel sagittis mi tincidunt. Vivamus euismod mi quis augue sollicitudin tincidunt. Donec a urna gravida, faucibus orci et, dapibus dui. Phasellus a lectus semper, dictum eros et, elementum justo. Phasellus lacinia nulla mi, a ullamcorper libero accumsan eget. Curabitur et sapien ullamcorper urna convallis maximus at vel felis. Curabitur sollicitudin euismod quam eu gravida. Nullam ut laoreet ipsum, eget rutrum neque."
                 StrLorem = StrLorem & " Phasellus sodales ex enim, non tempus arcu volutpat sit amet. Integer semper eros quis mauris hendrerit, sed blandit arcu scelerisque. Aliquam rhoncus congue est, cursus vulputate lectus placerat sed. Etiam eu sem vitae arcu bibendum dapibus id non nibh. Donec congue elit ex, eu porta augue consequat vitae. Nullam varius sagittis ipsum, a venenatis justo porttitor sit amet. Quisque non euismod diam. Fusce blandit in lacus a faucibus. Vivamus aliquam eleifend est et suscipit. Vestibulum sed nunc rhoncus, congue neque vel, rutrum lacus. Nulla commodo et tortor non fringilla. Vestibulum sodales mauris sit amet convallis luctus. Integer porta id dolor a blandit. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae;"
                 StrLorem = StrLorem & " Nulla tempor erat sed elit ultrices, euismod blandit felis vestibulum. Aliquam lobortis sollicitudin nisl, a blandit justo consequat ut. Nullam ornare nunc at bibendum fringilla. Mauris condimentum diam vitae congue tempor. Vestibulum vitae purus quis velit varius rhoncus ut nec diam. Vivamus fringilla consequat malesuada. Maecenas mollis elit nec massa volutpat sollicitudin. Nunc sapien nibh, pharetra vitae mattis auctor, commodo sed nisi."
                 StrLorem = StrLorem & " Etiam eget tincidunt tortor. Sed euismod eleifend diam et sollicitudin. Vivamus ultricies at nibh vel ullamcorper. Nulla sed odio non erat laoreet pretium. Pellentesque suscipit, dui id suscipit ullamcorper, lacus eros gravida sem, nec cursus nunc augue vitae felis. Pellentesque quis efficitur purus. Integer sit amet nulla velit."
                 StrLorem = StrLorem & " Donec dignissim, libero ac iaculis tristique, nunc lacus posuere felis, ut interdum massa metus at neque. Curabitur eu nisi sagittis ipsum consequat luctus in ut sem. Maecenas faucibus, risus non finibus aliquet, eros odio convallis magna, sit amet cursus est purus sollicitudin velit. Duis ornare viverra risus, non malesuada purus pellentesque in. Ut non fermentum augue. Sed arcu libero, condimentum ut tortor id, maximus gravida ante. Ut varius viverra ligula, ac porttitor nunc maximus vitae. Phasellus in urna non lorem dapibus vestibulum vel eu lorem. Nullam blandit nibh id feugiat euismod. Cras malesuada, mi vel congue semper, diam ligula auctor sapien, sit amet pharetra urna mauris ac turpis. Aenean maximus augue magna. Morbi nibh justo, interdum a neque vitae, tempor scelerisque velit. Curabitur vel risus suscipit, vestibulum dui ut, lobortis diam."
                 StrLorem = StrLorem & " Pellentesque laoreet, urna et facilisis convallis, eros orci convallis turpis, eu faucibus ex sapien in odio. Ut convallis dui id felis commodo tempor. Aliquam faucibus accumsan felis ac tempus. Etiam ac porta leo. Vestibulum consectetur id diam ut tincidunt. Phasellus ut pellentesque mi. Nam ut massa in justo bibendum tempor eget et augue. Vestibulum venenatis pulvinar ligula nec faucibus. Maecenas interdum pharetra dapibus. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nullam urna nibh, mollis vel aliquam eget, auctor at nibh. Sed viverra enim a erat elementum pharetra. Pellentesque dictum lacus sed leo varius tincidunt."
                 
                 
                 For i = 1 To UBound(RngArray, 1)
                     For j = 1 To UBound(RngArray, 2)
                         
                         '#' Aumento di 1 il contatore
                         counter = counter + 1
                         
                         If Me.chkStartLorem Then
                             StartChar = 1
                         Else
                             StartChar = Round(Rnd() * Len(StrLorem) * 0.8, 0)
                             StartChar = InStr(StartChar, StrLorem, ".") + 2
                             If StartChar + Me.txtMaxLorem > Len(StrLorem) Then StartChar = 1
                         End If
                         Chapter = Mid(StrLorem, StartChar, Me.txtMinLorem + Round(Rnd() * (Me.txtMaxLorem - Me.txtMinLorem), 0))
                         
                         On Error Resume Next
                         ChapterEnd = InStr(StartChar + Len(Chapter), StrLorem, ".")
                         ChapterEnd2 = InStrRev(StrLorem, ".", StartChar + Len(Chapter))
                         If ChapterEnd - StartChar + 1 <= Me.txtMaxLorem Then
                             Chapter = Mid(StrLorem, StartChar, ChapterEnd - StartChar + 1)
                         ElseIf ChapterEnd2 - StartChar + 1 >= Me.txtMinLorem Then
                             Chapter = Mid(StrLorem, StartChar, ChapterEnd2 - StartChar + 1)
                         End If
                         On Error GoTo Aborted
                         
                         RngArray(i, j) = Chapter
                         
                         '#' Aggiorna la barra di avanzamento
                         Call UpdateProgressBar(counter, countermax)
                         If ProgressAborted = 1 Then GoTo Aborted
                         On Error GoTo Aborted
                     
                     Next j
                 Next i
                 InRng = RngArray
                 
         End Select
          
         'Chiude la finestra avanzamento
         Unload UProgress
    
        
    End With
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
        
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmReadMe"
Attribute VB_Base = "0{2F67CEC2-F0E7-4D22-BCE7-231A214D4DCA}{7BA9E2DA-B7D7-4605-AAA6-9904A09EA442}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Dim FilePath As String
    Dim f As Long
    Dim dataline As String
    Dim RMe As String
    
    On Error Resume Next
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    If Mid(ThisWorkbook.Name, 18, 2) = "EG" Then
        FilePath = ThisWorkbook.path & pSep & "TxtFiles" & pSep & "Readme.txt"
    Else
        FilePath = ThisWorkbook.path & pSep & "Readme.txt"
    End If
    
    If FileExists(FilePath) = False Then
        Me.Hide
        MsgBox IIf(lng = 0, "File Readme.txt non trovato, o non accessibile", _
                          "Readme.txt not found or not accessible"), _
                          vbOKOnly + vbExclamation, _
                          IIf(lng = 0, "Readme non trovato", "readme not found")
    Else
        f = FreeFile
        
        Open FilePath For Input As #f
        
            RMe = Input(LOF(f), f)
            Me.lblReadme.Caption = RMe
            Me.lblReadme.AutoSize = True
            Me.fraReadme.ScrollBars = fmScrollBarsVertical
            Me.fraReadme.ScrollHeight = Me.lblReadme.Height + 10
            Me.fraReadme.ScrollWidth = Me.fraReadme.InsideWidth
        
        Close #f
    End If
End Sub

Private Sub UserForm_Activate()
    If Me.lblReadme.Caption = "" Then
        Call cmdCancel_Click
    End If
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "frmRecode"
Attribute VB_Base = "0{593205B5-F8D3-47B2-8E2A-ACBBF9915476}{AEEC4944-9503-423A-8A43-544E7FB982B8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub


Private Sub cmdAddSub_Click()
    Dim i As Long
    Dim check As Long
    Dim rep As Long
    
    With Me
    
        check = 0
        
        For i = 0 To .lbxSubList.ListCount - 1
            If .lbxSubList.List(i) = .txtFrom Or _
                (.lbxSubList.List(i) = "{null}" And .txtFrom = "") Then
                If lng = 0 Then
                    rep = MsgBox("Sostituzione gi|fffd| impostata:" & vbNewLine & vbNewLine & _
                                .lbxSubList.List(i) & " => " & .lbxSubList.List(i, 1) & vbNewLine & vbNewLine & _
                                "Sovrascrivere?", vbQuestion + vbYesNo, "Sovrascrittura sostituzione")
                Else
                    rep = MsgBox("Replacement already set:" & vbNewLine & vbNewLine & _
                                .lbxSubList.List(i) & " => " & .lbxSubList.List(i, 1) & vbNewLine & vbNewLine & _
                                "Overwrite?", vbQuestion + vbYesNo, "Overwrite replacement")
                End If
                If rep = vbYes Then
                    .lbxSubList.RemoveItem (i)
                Else
                    check = 1
                End If
                Exit For
            End If
        Next i
        
        If check = 0 Then
            If .txtFrom = "" Then .txtFrom = "{null}"
            If .txtTo = "" Then .txtTo = "{null}"
            .lbxSubList.AddItem Replace(.txtFrom, " ", "{SP}")
            .lbxSubList.List(.lbxSubList.ListCount - 1, 1) = Replace(.txtTo, " ", "{SP}")
            .lbxSubList.Selected(i) = True
        End If
        
        .txtFrom = ""
        .txtTo = ""
        .txtFrom.SetFocus
    End With

    Call GoodToGo(Me)

End Sub

Private Sub cmdDelSub_Click()
    Dim i As Long

    With Me.lbxSubList
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                .RemoveItem (i)
            End If
        Next i
    End With
    
    Call GoodToGo(Me)
    
End Sub

Private Sub cmdEmptyList_Click()

    With Me.lbxSubList
        .Clear
    End With
    Me.cmdOK.Enabled = False
    
End Sub

Private Sub cmdImportList_Click()
    Dim n As Long
    Dim FileName As Variant
    Dim f As Long
    Dim dataline As String
    Dim strFrom As String
    Dim strTo As String
    Dim check As Long
        
    FileName = OpenDialog(, "Lista sostituzioni (*.sub), *.sub, Tutti i file,*.*", IIf(lng = 0, "Seleziona i file con le sostituzioni da importare", "Select replacements file to import"), False)
        
    If FileName = False Then Exit Sub
    
    On Error Resume Next
    
    'procedura di importazione
    f = FreeFile
    
    Open FileName For Input As #f
    
    Do While Not EOF(f)
        Line Input #f, dataline
        
        If InStr(1, dataline, "<-esk_replace->") > 0 Then
        
            strFrom = Split(dataline, "<-esk_replace->")(0)
            strTo = Split(dataline, "<-esk_replace->")(1)
            
            With Me
                check = 0
                
                For n = 0 To .lbxSubList.ListCount - 1
                    If .lbxSubList.List(n) = strFrom Then
                        check = 1
                        Exit For
                    End If
                Next n
                                    
                If check = 0 Then
                    .lbxSubList.AddItem strFrom
                    .lbxSubList.List(.lbxSubList.ListCount - 1, 1) = strTo
                    .lbxSubList.Selected(.lbxSubList.ListCount - 1) = True
                End If
            
            End With
        
        End If
    Loop
        
    Close f
        
        
    Call GoodToGo(Me)

End Sub

Private Sub cmdSaveList_Click()
    Dim vFilePath As Variant
    Dim overwrite As Long
    Dim f As Long
    Dim i As Long
    
    Do
        If IsWindows = True Then
            vFilePath = Application.GetSaveAsFilename( _
                        InitialFileName:=SettingsPath & "Replace_list.sub", _
                        FileFilter:="Lista sostituzioni (*.sub), *.sub", _
                        Title:="Esporta la lista di sostituzioni")
        Else
            vFilePath = Application.GetSaveAsFilename(InitialFileName:=ActiveWorkbook.path & pSep & "Replace list.txt")
        End If
        
        '#' --exit if cancelled by user,
        If vFilePath = False Then Exit Sub
        
        '#' --ask user if he wants to overwrite
        If FileExists(vFilePath) Then
            overwrite = MsgBox("Sovrascrivere il file " & vFilePath & "?", vbExclamation + vbYesNo, "Conferma sovrascrittura")
                        
            If overwrite = vbNo Then
                vFilePath = ""
                AutoCalc True
                AutoCalc False
            End If
            
        End If
        
    Loop Until vFilePath <> ""
    
    f = FreeFile
    
    Open vFilePath For Output As #f
    
    For i = 0 To Me.lbxSubList.ListCount - 1
         Print #f, Me.lbxSubList.List(i) & "<-esk_replace->" & Me.lbxSubList.List(i, 1)
    Next i
    
    Close f
    
    MsgBox IIf(lng = 0, "Esportazione di " & Me.lbxSubList.ListCount & " sostituzioni completata con successo", _
                        Me.lbxSubList.ListCount & " substitutions were successfully exported"), vbInformation, _
                        IIf(lng = 0, "Esportazione completata", "Export completed")

End Sub



Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
        
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
    
    Call AutoCalc(False)
    
    If Me.tglBatch = False Then '#' no batch
    
        On Error GoTo Aborted
        
        Call backup_create_new
        
        Set ws = ActiveSheet
            
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        If Not InRng Is Nothing Then
            
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto efefttuando le sostituzioni... "
            Call ShowProgressBar
            
            For Each cell In InRng.Cells
                
                counter = counter + 1
                            
                Call elaboracella(cell)
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next cell
            
        End If
        
    Else '#' BATCH
    
        On Error GoTo Aborted
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto effettuando le sostituzioni... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
                    
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    
                    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                    If Not InRng Is Nothing Then
                        
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If
                
                End If
            
            Next ws
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
            
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto effettuando le sostituzioni... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                                    
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                        
                        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                        
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If
                
                End If
            
            Next ws
            
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True
NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
                    
        Next f
            
    End If
    
    'Chiude la finestra di avanzamento
    Unload UProgress
        
    Call AutoCalc(True)
    
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
        
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub
Private Sub elaboracella(Cella As Range)
    Dim i As Long
    Dim Val1 As Variant, Val2 As Variant
    
    For i = 0 To Me.lbxSubList.ListCount - 1
        
        Val1 = Replace(Replace(Replace(Replace(Me.lbxSubList.List(i), "{SP}", " "), "{null}", ""), "{CR}", vbNewLine), "{TAB}", vbTab)
        Val2 = Replace(Replace(Replace(Replace(Me.lbxSubList.List(i, 1), "{SP}", " "), "{null}", ""), "{CR}", vbNewLine), "{TAB}", vbTab)
            
        If Me.chkWholeCell = True Then
                                    
            If Me.chkCaseSensitive Then
                If CStr(Cella.Value) = Val1 Then
                    Cella.Value = Val2
                    Exit For
                End If
            Else
                If UCase(CStr(Cella.Value)) = UCase(Val1) Then
                    Cella.Value = Val2
                    Exit For
                End If
            End If
        
        Else
            
            If Me.chkCaseSensitive Then
                Cella.Value = Replace(Cella.Value, Val1, Val2)
            Else
                Cella.Value = Replace(Cella.Value, Val1, Val2, , , vbTextCompare)
            End If
            
        End If
        
    Next i

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmRenameFiles"
Attribute VB_Base = "0{912EBA9F-089C-4EE1-BADD-A03E7879AB1A}{D30B7533-6D44-462E-87CE-D58E70D4F478}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim strFolder As String
Private DisableEvents As Boolean

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)
    
    Set btnColl = CommonButtons(Me)
        
    DisableEvents = True
    
    If ActiveWorkbook.path = "" Then
        Me.txtFolder = DesktopPath
    Else
        Me.txtFolder = ValidateFolder(ActiveWorkbook.path)
    End If
    
    With Me.cbxCase
        If lng > 0 Then
            .AddItem "Leave unchanged"
            .AddItem "UPPERCASE"
            .AddItem "lowercase"
            .AddItem "Proper Case"
            .AddItem "First letter uppercase"
        Else
            .AddItem "Lascia invariato"
            .AddItem "MAIUSCOLO"
            .AddItem "minuscolo"
            .AddItem "Tutte Le Iniziali Maiuscole"
            .AddItem "Prima iniziale maiuscola"
        End If
        Me.cbxCase.ListIndex = 0
    End With
        
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    Call ListFiles

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)
    DisableEvents = False
    
    Call GeneratePreview

    Call Resizeform(Me)

End Sub


Private Sub ListFiles()
    Dim nFile As String
    
    DisableEvents = True
    
    strFolder = ValidateFolder(Me.txtFolder)
    
    nFile = Dir(strFolder & "*.*")
    
    Me.lbxFiles.Clear
    Do While Not nFile = ""
        If Me.txtFilter = "" Or InStr(1, UCase(nFile), UCase(Me.txtFilter)) > 0 Then
            Me.lbxFiles.AddItem nFile
        End If
            
        nFile = Dir()
    Loop

    DisableEvents = False
    
    Call GeneratePreview
    
End Sub
Private Sub UnselectListBox(lbx As String)
    
    With Me.Controls(lbx)
        .MultiSelect = fmMultiSelectMulti
        .ListIndex = -1
        .MultiSelect = fmMultiSelectSingle
    End With
    
End Sub

Private Sub lbxFiles_Change()
    If DisableEvents = True Then Exit Sub
    
    If Me.chkSelected = True Then
        Call GeneratePreview
    Else
        DisableEvents = True
        Call UnselectListBox(Me.lbxFiles.Name)
        Call UnselectListBox(Me.lbxPreview.Name)
        DisableEvents = False
    End If
End Sub
Private Sub lbxPreview_Change()
    If DisableEvents = True Then Exit Sub
    
    If Me.chkSelected = False Then
        DisableEvents = True
        Call UnselectListBox(Me.lbxFiles.Name)
        Call UnselectListBox(Me.lbxPreview.Name)
        DisableEvents = False
    Else
        DisableEvents = True
        Call UnselectListBox(Me.lbxPreview.Name)
        DisableEvents = False
    End If
End Sub

Private Sub txtFilter_Change()
    Me.txtFilter = CleanString(Me.txtFilter)
    Call ListFiles
End Sub

Private Sub cmdSelectFolder_Click()
    Me.txtFolder.Text = FolderPicker(Me.txtFolder.Text, IIf(lng = 0, "Seleziona la cartella con i file da rinominare", "Please select a folder with the files to rename"))
    
    Call ListFiles
End Sub

Private Sub txtFolder_Change()
    Me.txtFolder.ControlTipText = Me.txtFolder.Text
End Sub

Private Sub chkAllNone_Change()
    Dim i As Long
    
    DisableEvents = True
    
    For i = 0 To Me.lbxFiles.ListCount - 1
        Me.lbxFiles.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GeneratePreview
    
End Sub
Private Sub chkSelected_Click()
    DisableEvents = True
    
    If Me.chkSelected Then
        Me.lbxFiles.MultiSelect = fmMultiSelectExtended
    Else
        Me.lbxFiles.MultiSelect = fmMultiSelectSingle
    End If
    Me.chkAllNone.Enabled = Me.chkSelected
    
    DisableEvents = False
    
    Call GeneratePreview
End Sub

Private Sub chkReplaceName_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraOptions.Controls
        ctl.Enabled = Not Me.chkReplaceName
    Next ctl
    Me.fraSubst.Enabled = True
    Me.chkReplaceName.Enabled = True
    Me.txtReplaceName.Enabled = Me.chkReplaceName
    Me.fraCounter.Enabled = True
    Me.chkCounter = Me.chkReplaceName
    Me.lblWarning.visible = Me.chkReplaceName
    Me.lblWarning.Enabled = Me.chkReplaceName
    
    Set ctl = Nothing
End Sub

Private Sub txtReplaceName_Change()
    Me.txtReplaceName = CleanString(Me.txtReplaceName)
    Call GeneratePreview
    Me.txtReplaceName.ControlTipText = Me.txtReplaceName.Text
End Sub
Private Sub spbRight_SpinDown()
    Me.txtRight = Me.spbRight
End Sub
Private Sub spbRight_SpinUp()
    Me.txtRight = Me.spbRight
End Sub
Private Sub txtRight_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtRight_Change()
    If Val(Me.txtRight) > Me.spbRight.Max Then Me.txtRight = Me.spbRight.Max
    If Val(Me.txtRight) < Me.spbRight.Min Then Me.txtRight = Me.spbRight.Min
    Me.spbRight = Me.txtRight
    Call GeneratePreview
    Me.txtRight.ControlTipText = Me.txtRight.Text
End Sub
Private Sub spbLeft_SpinDown()
    Me.txtLeft = Me.spbLeft
End Sub
Private Sub spbLeft_SpinUp()
    Me.txtLeft = Me.spbLeft
End Sub
Private Sub txtLeft_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtLeft_Change()
    If Val(Me.txtLeft) > Me.spbLeft.Max Then Me.txtLeft = Me.spbLeft.Max
    If Val(Me.txtLeft) < Me.spbLeft.Min Then Me.txtLeft = Me.spbLeft.Min
    Me.spbLeft = Me.txtLeft
    Call GeneratePreview
    Me.txtLeft.ControlTipText = Me.txtLeft.Text
End Sub
Private Sub spbTruncate_SpinDown()
    Me.txtTruncate = Me.spbTruncate
End Sub
Private Sub spbTruncate_SpinUp()
    Me.txtTruncate = Me.spbTruncate
End Sub
Private Sub txtTruncate_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtTruncate_Change()
    If Val(Me.txtTruncate) > Me.spbTruncate.Max Then Me.txtTruncate = Me.spbTruncate.Max
    If Val(Me.txtTruncate) < Me.spbTruncate.Min Then Me.txtTruncate = Me.spbTruncate.Min
    Me.spbTruncate = Me.txtTruncate
    Call GeneratePreview
    Me.txtTruncate.ControlTipText = Me.txtTruncate.Text
End Sub
Private Sub spbNPos_SpinDown()
    Me.txtNpos = Me.spbNPos
End Sub
Private Sub spbNPos_SpinUp()
    Me.txtNpos = Me.spbNPos
End Sub
Private Sub txtNPos_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNPos_Change()
    If Val(Me.txtNpos) > Me.spbNPos.Max Then Me.txtNpos = Me.spbNPos.Max
    If Val(Me.txtNpos) < Me.spbNPos.Min Then Me.txtNpos = Me.spbNPos.Min
    Me.spbNPos = Me.txtNpos
    Call GeneratePreview
End Sub

Private Sub chkRight_Change()
    Me.txtRight.Enabled = Me.chkRight
    Me.spbRight.Enabled = Me.chkRight
    Call GeneratePreview
End Sub
Private Sub chkLeft_Change()
    Me.txtLeft.Enabled = Me.chkLeft
    Me.spbLeft.Enabled = Me.chkLeft
    Call GeneratePreview
End Sub

Private Sub chkTruncate_Change()
    Me.txtTruncate.Enabled = Me.chkTruncate
    Me.spbTruncate.Enabled = Me.chkTruncate
    Call GeneratePreview
End Sub

Private Sub chkBefore_Change()
    Me.txtBefore.Enabled = Me.chkBefore
    Call GeneratePreview
End Sub

Private Sub chkAfter_Change()
    Me.txtAfter.Enabled = Me.chkAfter
    Call GeneratePreview
End Sub

Private Sub chkPos_Change()
    Me.spbNPos.Enabled = Me.chkPos
    Me.txtNpos.Enabled = Me.chkPos
    Me.txtPos.Enabled = Me.chkPos
    Call GeneratePreview
End Sub

Private Sub txtBefore_Change()
    Me.txtBefore = CleanString(Me.txtBefore)
    Call GeneratePreview
    Me.txtBefore.ControlTipText = Me.txtBefore.Text
End Sub

Private Sub txtAfter_Change()
    Me.txtAfter = CleanString(Me.txtAfter)
    Call GeneratePreview
    Me.txtAfter.ControlTipText = Me.txtAfter.Text
End Sub

Private Sub txtPos_Change()
    Me.txtPos = CleanString(Me.txtPos)
    Call GeneratePreview
    Me.txtPos.ControlTipText = Me.txtPos.Text
End Sub

Private Sub chkReplace_Change()
    Me.txtFrom.Enabled = Me.chkReplace
    Me.txtTo.Enabled = Me.chkReplace
    Call GeneratePreview
End Sub
Private Sub txtFrom_Change()
    Me.txtFrom = CleanString(Me.txtFrom)
    Call GeneratePreview
End Sub
Private Sub txtTo_Change()
    Me.txtTo = CleanString(Me.txtTo)
    Call GeneratePreview
End Sub
Private Sub cbxCase_Change()
    Call GeneratePreview
End Sub

Private Sub chkBeforeText_Change()
    Me.txtBeforeText.Enabled = Me.chkBeforeText
    Call GeneratePreview
End Sub

Private Sub txtBeforeText_Change()
    Me.txtBeforeText = CleanString(Me.txtBeforeText)
    Call GeneratePreview
    Me.txtBeforeText.ControlTipText = Me.txtBeforeText.Text
End Sub

Private Sub chkAfterText_Change()
    Me.txtAfterText.Enabled = Me.chkAfterText
    Call GeneratePreview
End Sub

Private Sub txtAfterText_Change()
    Me.txtAfterText = CleanString(Me.txtAfterText)
    Call GeneratePreview
    Me.txtAfterText.ControlTipText = Me.txtAfterText.Text
End Sub

Private Sub spbStart_Change()
    Me.txtStart = Me.spbStart
    Call GeneratePreview
End Sub

Private Sub spbIncrement_Change()
    Me.txtIncrement = Me.spbIncrement
    Call GeneratePreview
End Sub

Private Sub spbZeroFill_Change()
    Me.chkZeroFill = True
    Me.txtZeroFill = Me.spbZerofill
    Call GeneratePreview
End Sub

Private Sub chkCounter_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraCounter.Controls
        ctl.Enabled = Me.chkCounter
    Next ctl
    Me.chkCounter.Enabled = True
    Call GeneratePreview
End Sub

Private Sub optCountBefore_Click()
    Call GeneratePreview
End Sub

Private Sub optCountAfter_Click()
    Call GeneratePreview
End Sub

Private Sub chkZeroFill_Change()
    Call GeneratePreview
End Sub
Private Sub chkCaseSensitive_Change()
    Call GeneratePreview
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub GeneratePreview()
    Dim i As Long
    Dim pFile As String
    Dim pExt As String
    Dim fCount As Long
    Dim n As Variant
    
    If DisableEvents = True Then Exit Sub
    
    DisableEvents = True
    
    Call AutoCalc(False)
        
    Me.lbxPreview.Clear
    
    For i = 0 To Me.lbxFiles.ListCount - 1
    
        If InStrRev(Me.lbxFiles.List(i), ".") > 0 Then
            pFile = Mid(Me.lbxFiles.List(i), 1, InStrRev(Me.lbxFiles.List(i), ".") - 1)
            pExt = Mid(Me.lbxFiles.List(i), InStrRev(Me.lbxFiles.List(i), ".") + 1)
        Else
            pFile = Me.lbxFiles.List(i)
            pExt = ""
        End If
            
        If Me.chkSelected = False Or Me.lbxFiles.Selected(i) = True Then
        
            fCount = fCount + 1
            
            If Me.chkReplaceName = True And Me.chkReplaceName.Enabled = True Then
                If Len(Me.txtReplaceName) > 0 Then pFile = Me.txtReplaceName
            End If
            
            If Me.chkRight = True And Me.chkRight.Enabled = True Then
                If CLng(Me.txtRight) < Len(pFile) Then
                    pFile = Right(pFile, Len(pFile) - CLng(Me.txtRight))
                End If
            End If
            
            If Me.chkLeft = True And Me.chkLeft.Enabled = True Then
                If CLng(Me.txtLeft) < Len(pFile) Then
                    pFile = Left(pFile, Len(pFile) - CLng(Me.txtLeft))
                End If
            End If
            
            If Me.chkTruncate = True And Me.chkTruncate.Enabled = True Then
                pFile = Left(pFile, CLng(Me.txtTruncate))
            End If
            
            If Me.chkReplace Then
                If Me.chkCaseSensitive Then
                    pFile = Replace(pFile, Me.txtFrom, Me.txtTo)
                Else
                    pFile = Replace(pFile, Me.txtFrom, Me.txtTo, , , vbTextCompare)
                End If
            End If
            
            If Me.chkBefore = True And Me.chkBefore.Enabled = True Then
                pFile = Me.txtBefore & pFile
            End If
            
            If Me.chkAfter = True And Me.chkAfter.Enabled = True Then
                pFile = pFile & Me.txtAfter
            End If
            
            If Me.chkBeforeText = True And Me.chkBeforeText.Enabled = True And Me.txtBeforeText <> "" Then
                If InStr(1, pFile, Me.txtBeforeText) > 0 Then
                    pFile = Right(pFile, Len(pFile) - InStr(1, pFile, Me.txtBeforeText) - Len(Me.txtBeforeText) + 1)
                End If
            End If
            
            If Me.chkAfterText = True And Me.chkAfterText.Enabled = True And Me.txtAfterText <> "" Then
                If InStr(1, pFile, Me.txtAfterText) > 0 Then
                    pFile = Left(pFile, InStr(1, pFile, Me.txtAfterText) - 1)
                End If
            End If
            
            If Me.chkPos = True And Me.chkPos.Enabled = True Then
                pFile = Left(pFile, Me.txtNpos) & Me.txtPos & Right(pFile, Len(pFile) - CLng(Me.txtNpos))
            End If
            
            If Me.chkCounter Then
            
                n = Me.txtStart + ((fCount - 1) * Me.txtIncrement)
                If Me.chkZeroFill Then
                    n = Right(String(CLng(Me.txtZeroFill), "0") & n, CLng(Me.txtZeroFill))
                End If
                
                If Me.optCountBefore Then
                    pFile = n & pFile
                Else
                    pFile = pFile & n
                End If
                
            End If
            
            Select Case Me.cbxCase.ListIndex
                Case 1
                    pFile = StrConv(pFile, vbUpperCase)
                Case 2
                    pFile = StrConv(pFile, vbLowerCase)
                Case 3
                   pFile = StrConv(pFile, vbProperCase)
                Case 4
                    pFile = UCase(Left(pFile, 1)) & LCase(Right(pFile, Len(pFile) - 1))
                Case Else
                    pFile = pFile
            End Select
                            
        End If
        
        Me.lbxPreview.AddItem pFile & "." & pExt
    Next i
    
    Call GoodToGo(Me)
    Call AutoCalc(True)
    DisableEvents = False
    
End Sub

Private Sub cmdOK_Click()
    Dim cPath As String
    Dim cFile As String
    Dim rFile As String
    Dim i As Long
    Dim oFolder As Long
    Dim fCount As Long
    Dim rCount As Long
    
    If Me.chkClose Then Me.Hide
    
    On Error GoTo Aborted
    
    cPath = ValidateFolder(Me.txtFolder)
    
    fCount = 0
    rCount = 0
            
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.lbxFiles.ListCount
    UProgress.SetDescription "Sto rinominando i file..."
    Call ShowProgressBar
    
    For i = 0 To Me.lbxFiles.ListCount - 1
        
        '#' Aumento di 1 il contatore
        counter = counter + 1
            
        If Me.lbxFiles.Selected(i) = True Or Me.chkSelected = False Then
            
            fCount = fCount + 1
            
            cFile = Me.lbxFiles.List(i)
            rFile = Me.lbxPreview.List(i)
            
            If Dir(cPath & rFile) = "" Then
                rCount = rCount + 1
                Name cPath & cFile As cPath & rFile
            End If
        End If
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

    Next i
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
                                
    oFolder = MsgBox("Sono stati rinominati con successo " & rCount & " file su un totale di " & fCount & ". Troverai i file nella cartella: " & vbNewLine & vbNewLine & cPath & vbNewLine & vbNewLine & "Vuoi aprire la cartella in esplora risorse?", vbInformation + vbYesNo, "Rinomina completata")
    If oFolder = vbYes Then Call OpenFolder(cPath)
        
    If Not Me.chkClose Then Call ListFiles
        
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmRenameSheets"
Attribute VB_Base = "0{B646C582-D791-4ED8-93A1-42C5E6655E44}{7FE37B74-AA55-42CB-A66E-B145340AE387}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Public DisableEvents As Boolean

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    DisableEvents = True
    
    With Me.cbxCase
        If lng > 0 Then
            .AddItem "Leave unchanged"
            .AddItem "UPPERCASE"
            .AddItem "lowercase"
            .AddItem "Proper Case"
            .AddItem "First letter uppercase"
        Else
            .AddItem "Lascia invariato"
            .AddItem "MAIUSCOLO"
            .AddItem "minuscolo"
            .AddItem "Tutte Le Iniziali Maiuscole"
            .AddItem "Prima iniziale maiuscola"
        End If
        .ListIndex = 0
    End With
        
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)
    
    DisableEvents = False
    
    Call ListSheets
    
    Call Resizeform(Me)
    
End Sub

Private Sub ListSheets()
    Dim sh As Object
    
    DisableEvents = True
    
    Me.lbxSheets.Clear
    For Each sh In ActiveWorkbook.Sheets
        If Me.txtFilterSheets = "" Or InStr(1, UCase(sh.Name), UCase(Me.txtFilterSheets)) > 0 Then
            Me.lbxSheets.AddItem sh.Name
        End If
    Next sh
    
    DisableEvents = False
    
    Call GeneratePreview

End Sub
Private Sub UnselectListBox(lbx As String)
    
    With Me.Controls(lbx)
        .MultiSelect = fmMultiSelectMulti
        .ListIndex = -1
        .MultiSelect = fmMultiSelectSingle
    End With
    
End Sub

Private Sub lbxSheets_Change()
    If DisableEvents = True Then Exit Sub
    
    If Me.chkSelected = True Then
        Call GeneratePreview
    Else
        DisableEvents = True
        Call UnselectListBox(Me.lbxSheets.Name)
        Call UnselectListBox(Me.lbxPreview.Name)
        DisableEvents = False
    End If
End Sub
Private Sub lbxPreview_Change()
    If DisableEvents = True Then Exit Sub
    
    If Me.chkSelected = False Then
        DisableEvents = True
        Call UnselectListBox(Me.lbxSheets.Name)
        Call UnselectListBox(Me.lbxPreview.Name)
        DisableEvents = False
    Else
        DisableEvents = True
        Call UnselectListBox(Me.lbxPreview.Name)
        DisableEvents = False
    End If
End Sub

Private Sub txtFilterSheets_Change()
    Me.txtFilterSheets = CleanString(Me.txtFilterSheets, , "sheet")
    
    If DisableEvents = True Then Exit Sub
    
    Call ListSheets
End Sub
Private Sub chkAllNone_Change()
    Dim i As Long
    
    DisableEvents = True
    
    For i = 0 To Me.lbxSheets.ListCount - 1
        Me.lbxSheets.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GeneratePreview
    
End Sub
Private Sub chkSelected_Change()
    
    DisableEvents = True
    
    If Me.chkSelected Then
        Me.lbxSheets.MultiSelect = fmMultiSelectExtended
    Else
        Me.lbxSheets.MultiSelect = fmMultiSelectSingle
    End If
    Me.chkAllNone.Enabled = Me.chkSelected
    
    DisableEvents = False
    
    Call GeneratePreview
    
End Sub

Private Sub chkReplaceName_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraOptions.Controls
        ctl.Enabled = Not Me.chkReplaceName
    Next ctl
    Me.fraSubst.Enabled = True
    Me.chkReplaceName.Enabled = True
    Me.txtReplaceName.Enabled = Me.chkReplaceName
    Me.fraCounter.Enabled = True
    Me.chkCounter = Me.chkReplaceName
    Me.lblWarning.visible = Me.chkReplaceName
    Me.lblWarning.Enabled = Me.chkReplaceName
    
    Set ctl = Nothing
End Sub

Private Sub txtReplaceName_Change()
    Me.txtReplaceName = CleanString(Me.txtReplaceName, , "sheet")
    Call GeneratePreview
    Me.txtReplaceName.ControlTipText = Me.txtReplaceName.Text
End Sub
Private Sub spbRight_SpinDown()
    Me.txtRight = Me.spbRight
    Call GeneratePreview
End Sub
Private Sub spbRight_SpinUp()
    Me.txtRight = Me.spbRight
    Call GeneratePreview
End Sub
Private Sub txtRight_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtRight_Change()
    If Val(Me.txtRight) > Me.spbRight.Max Then Me.txtRight = Me.spbRight.Max
    If Val(Me.txtRight) < Me.spbRight.Min Then Me.txtRight = Me.spbRight.Min
    Me.spbRight = Me.txtRight
    Call GeneratePreview
    Me.txtRight.ControlTipText = Me.txtRight.Text
End Sub
Private Sub spbLeft_SpinDown()
    Me.txtLeft = Me.spbLeft
    Call GeneratePreview
End Sub
Private Sub spbLeft_SpinUp()
    Me.txtLeft = Me.spbLeft
    Call GeneratePreview
End Sub
Private Sub txtLeft_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtLeft_Change()
    If Val(Me.txtLeft) > Me.spbLeft.Max Then Me.txtLeft = Me.spbLeft.Max
    If Val(Me.txtLeft) < Me.spbLeft.Min Then Me.txtLeft = Me.spbLeft.Min
    Me.spbLeft = Me.txtLeft
    Call GeneratePreview
    Me.txtLeft.ControlTipText = Me.txtLeft.Text
End Sub
Private Sub spbTruncate_SpinDown()
    Me.txtTruncate = Me.spbTruncate
    Call GeneratePreview
End Sub
Private Sub spbTruncate_SpinUp()
    Me.txtTruncate = Me.spbTruncate
    Call GeneratePreview
End Sub
Private Sub txtTruncate_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtTruncate_Change()
    If Val(Me.txtTruncate) > Me.spbTruncate.Max Then Me.txtTruncate = Me.spbTruncate.Max
    If Val(Me.txtTruncate) < Me.spbTruncate.Min Then Me.txtTruncate = Me.spbTruncate.Min
    Me.spbTruncate = Me.txtTruncate
    Call GeneratePreview
    Me.txtTruncate.ControlTipText = Me.txtTruncate.Text
End Sub
Private Sub spbNPos_SpinDown()
    Me.txtNpos = Me.spbNPos
    Call GeneratePreview
End Sub
Private Sub spbNPos_SpinUp()
    Me.txtNpos = Me.spbNPos
    Call GeneratePreview
End Sub
Private Sub txtNPos_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNPos_Change()
    If Val(Me.txtNpos) > Me.spbNPos.Max Then Me.txtNpos = Me.spbNPos.Max
    If Val(Me.txtNpos) < Me.spbNPos.Min Then Me.txtNpos = Me.spbNPos.Min
    Me.spbNPos = Me.txtNpos
    Call GeneratePreview
End Sub

Private Sub chkRight_Change()
    Me.txtRight.Enabled = Me.chkRight
    Me.spbRight.Enabled = Me.chkRight
    Call GeneratePreview
End Sub
Private Sub chkLeft_Change()
    Me.txtLeft.Enabled = Me.chkLeft
    Me.spbLeft.Enabled = Me.chkLeft
    Call GeneratePreview
End Sub

Private Sub chkTruncate_Change()
    Me.txtTruncate.Enabled = Me.chkTruncate
    Me.spbTruncate.Enabled = Me.chkTruncate
    Call GeneratePreview
End Sub

Private Sub chkBefore_Change()
    Me.txtBefore.Enabled = Me.chkBefore
    Call GeneratePreview
End Sub

Private Sub chkAfter_Change()
    Me.txtAfter.Enabled = Me.chkAfter
    Call GeneratePreview
End Sub

Private Sub chkPos_Change()
    Me.spbNPos.Enabled = Me.chkPos
    Me.txtNpos.Enabled = Me.chkPos
    Me.txtPos.Enabled = Me.chkPos
    Call GeneratePreview
End Sub

Private Sub txtBefore_Change()
    Me.txtBefore = CleanString(Me.txtBefore, , "sheet")
    Call GeneratePreview
End Sub

Private Sub txtAfter_Change()
    Me.txtAfter = CleanString(Me.txtAfter, , "sheet")
    Call GeneratePreview
End Sub

Private Sub txtPos_Change()
    Me.txtPos = CleanString(Me.txtPos, , "sheet")
    Call GeneratePreview
    Me.txtPos.ControlTipText = Me.txtPos.Text
End Sub

Private Sub chkBeforeText_Change()
    Me.txtBeforeText.Enabled = Me.chkBeforeText
    Call GeneratePreview
End Sub

Private Sub txtBeforeText_Change()
    Me.txtBeforeText = CleanString(Me.txtBeforeText, , "sheet")
    Call GeneratePreview
    Me.txtBeforeText.ControlTipText = Me.txtBeforeText.Text
End Sub

Private Sub chkAfterText_Change()
    Me.txtAfterText.Enabled = Me.chkAfterText
    Call GeneratePreview
End Sub

Private Sub txtAfterText_Change()
    Me.txtAfterText = CleanString(Me.txtAfterText, , "sheet")
    Call GeneratePreview
    Me.txtAfterText.ControlTipText = Me.txtAfterText.Text
End Sub

Private Sub chkReplace_Change()
    Me.txtFrom.Enabled = Me.chkReplace
    Me.txtTo.Enabled = Me.chkReplace
    Call GeneratePreview
End Sub
Private Sub txtFrom_Change()
    Me.txtFrom = CleanString(Me.txtFrom, , "sheet")
    Call GeneratePreview
    Me.txtFrom.ControlTipText = Me.txtFrom.Text
End Sub
Private Sub txtTo_Change()
    Me.txtTo = CleanString(Me.txtTo, , "sheet")
    Call GeneratePreview
    Me.txtTo.ControlTipText = Me.txtTo.Text
End Sub
Private Sub cbxCase_Change()
    Call GeneratePreview
End Sub

Private Sub spbStart_Change()
    Me.txtStart = Me.spbStart
    Call GeneratePreview
End Sub

Private Sub spbIncrement_Change()
    Me.txtIncrement = Me.spbIncrement
    Call GeneratePreview
End Sub

Private Sub spbZeroFill_Change()
    Me.chkZeroFill = True
    Me.txtZeroFill = Me.spbZerofill
    Call GeneratePreview
End Sub

Private Sub chkCounter_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraCounter.Controls
        ctl.Enabled = Me.chkCounter
    Next ctl
    Me.chkCounter.Enabled = True
    Call GeneratePreview
End Sub

Private Sub optCountBefore_Click()
    Call GeneratePreview
End Sub

Private Sub optCountAfter_Click()
    Call GeneratePreview
End Sub

Private Sub chkZeroFill_Change()
    Call GeneratePreview
End Sub
Private Sub chkCaseSensitive_Change()
    Call GeneratePreview
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub GeneratePreview()
    Dim i As Long
    Dim sCount As Long
    Dim n As Variant
    Dim pSheet As String
    
    If DisableEvents = True Then Exit Sub
    
    DisableEvents = True
    
    Call AutoCalc(False)
    
    Me.lbxPreview.Clear
    
    For i = 0 To Me.lbxSheets.ListCount - 1
    
        pSheet = Me.lbxSheets.List(i)
        
        If Me.chkSelected = False Or Me.lbxSheets.Selected(i) = True Then
            
            sCount = sCount + 1
            
            If Me.chkReplaceName = True And Me.chkReplaceName.Enabled = True Then
                If Len(Me.txtReplaceName) > 0 Then pSheet = Me.txtReplaceName
            End If
            
            If Me.chkRight = True And Me.chkRight.Enabled = True Then
                If CLng(Me.txtRight) < Len(pSheet) Then
                    pSheet = Right(pSheet, Len(pSheet) - CLng(Me.txtRight))
                End If
            End If
            
            If Me.chkLeft = True And Me.chkLeft.Enabled = True Then
                If CLng(Me.txtLeft) < Len(pSheet) Then
                    pSheet = Left(pSheet, Len(pSheet) - CLng(Me.txtLeft))
                End If
            End If
            
            If Me.chkTruncate = True And Me.chkTruncate.Enabled = True Then
                pSheet = Left(pSheet, CLng(Me.txtTruncate))
            End If
            
            If Me.chkReplace = True And Me.chkReplace.Enabled = True Then
                If Me.chkCaseSensitive Then
                    pSheet = Replace(pSheet, Me.txtFrom, Me.txtTo)
                Else
                    pSheet = Replace(pSheet, Me.txtFrom, Me.txtTo, , , vbTextCompare)
                End If
            End If
            
            If Me.chkBefore = True And Me.chkBefore.Enabled = True Then
                pSheet = Me.txtBefore & pSheet
            End If
            
            If Me.chkAfter = True And Me.chkAfter.Enabled = True Then
                pSheet = pSheet & Me.txtAfter
            End If
            
            If Me.chkBeforeText = True And Me.chkBeforeText.Enabled = True And Me.txtBeforeText <> "" Then
                If InStr(1, pSheet, Me.txtBeforeText) > 0 Then
                    pSheet = Right(pSheet, Len(pSheet) - InStr(1, pSheet, Me.txtBeforeText) - Len(Me.txtBeforeText) + 1)
                End If
            End If
            
            If Me.chkAfterText = True And Me.chkAfterText.Enabled = True And Me.txtAfterText <> "" Then
                If InStr(1, pSheet, Me.txtAfterText) > 0 Then
                    pSheet = Left(pSheet, InStr(1, pSheet, Me.txtAfterText) - 1)
                End If
            End If
            
            If Me.chkPos = True And Me.chkPos.Enabled = True Then
                pSheet = Left(pSheet, Me.txtNpos) & Me.txtPos & Right(pSheet, Len(pSheet) - CLng(Me.txtNpos))
            End If
            
            If Me.chkCounter Then
            
                n = Me.txtStart + ((sCount - 1) * Me.txtIncrement)
                If Me.chkZeroFill Then
                    n = Right(String(CLng(Me.txtZeroFill), "0") & n, CLng(Me.txtZeroFill))
                End If
                
                If Me.optCountBefore Then
                    pSheet = n & pSheet
                Else
                    pSheet = pSheet & n
                End If
                
            End If
            
            Select Case Me.cbxCase.ListIndex
                Case 1
                    pSheet = StrConv(pSheet, vbUpperCase)
                Case 2
                    pSheet = StrConv(pSheet, vbLowerCase)
                Case 3
                   pSheet = StrConv(pSheet, vbProperCase)
                Case 4
                    pSheet = UCase(Left(pSheet, 1)) & LCase(Right(pSheet, Len(pSheet) - 1))
                Case Else
                    pSheet = pSheet
            End Select
        
        End If
        
        Me.lbxPreview.AddItem pSheet
    Next i
    
    Call GoodToGo(Me)
    Call AutoCalc(True)
    DisableEvents = False
    
End Sub


Private Sub cmdOK_Click()
    Dim i As Long
    Dim sCount As Long
    Dim rCount As Long
    Dim cSheet As String
    Dim rSheet As String
    
    If Me.chkClose Then Me.Hide
    
    On Error GoTo Aborted
    
    sCount = 0
    rCount = 0
            
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = Me.lbxSheets.ListCount
    UProgress.SetDescription "Sto rinominando i fogli..."
    Call ShowProgressBar
    
    For i = 0 To Me.lbxSheets.ListCount - 1
        
        '#' Aumento di 1 il contatore
        counter = counter + 1
            
        If Me.lbxSheets.Selected(i) = True Or Me.chkSelected = False Then
            
            sCount = sCount + 1
            
            cSheet = Me.lbxSheets.List(i)
            rSheet = Me.lbxPreview.List(i)
            
            On Error Resume Next
            ActiveWorkbook.Sheets(cSheet).Name = rSheet
            If Err.Number = 0 Then rCount = rCount + 1
            On Error GoTo Aborted
            
        End If
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted

    Next i
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
                                
    MsgBox IIf(lng = 0, "Sono stati rinominati con successo " & rCount & " fogli su un totale di " & sCount, _
                        rCount & " out of " & sCount & " were successfully renamed"), vbInformation, _
                        IIf(lng = 0, "Rinomina completata", "Rename completed")
        
    If Not Me.chkClose Then Call ListSheets
        
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmReplaceRemoveChars"
Attribute VB_Base = "0{63DA491B-0BFB-4874-B25A-47A996B15885}{372304F5-079F-4BB1-9C4F-3EDF6B91F636}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim UnicodeAlert As Boolean
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    Dim ctl(256) As MSForms.control
    Dim ctllbl(256) As MSForms.control
    Dim i As Long
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)

    With Me.fraDelete
        For i = 0 To 255
            Set ctl(i) = .Controls.Add("Forms.CheckBox.1", "chk" & i)
            With ctl(i)
                .Name = i
                .Top = 10 + ((i Mod 20) * 15)
                .Left = 12 + (Application.WorksheetFunction.RoundDown(i / 20, 0) * 34)
                .Height = 18
                .Width = 32
                .Caption = CStr(Chr(i))
                If i = 32 Then .Caption = "sp"
                
                Select Case i
                    Case 65 To 90, 97 To 122
                        .Tag = "Letters"
                    Case 48 To 57
                        .Tag = "Digits"
                    Case 0 To 31, 127
                        .Tag = "NonPrint"
                    Case Else
                        .Tag = "Symbols"
                End Select
            
            End With
            Set ctllbl(i) = .Controls.Add("Forms.Label.1", "lbl" & i)
            With ctllbl(i)
                .Name = "l" & i
                .Top = 16 + ((i Mod 20) * 15)
                .Left = 2 + (Application.WorksheetFunction.RoundDown(i / 20, 0) * 34)
                .Height = 10
                .Width = 10
                .Caption = i
                .TextAlign = fmTextAlignRight
                .WordWrap = False
                .Font.Size = 5
                .ForeColor = RGB(150, 150, 150)
                .AutoSize = False
                .Tag = "ASCII"
            End With
        Next i
    End With
    
    Call SaveOptions(Me)
    DisableEvents = True
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    DisableEvents = False
    
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub cmdAll_Click()
    Dim ctl As MSForms.control
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag <> "ASCII" Then
            ctl.Value = True
        End If
    Next ctl
End Sub
Private Sub cmdNone_Click()
    Dim ctl As MSForms.control
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag <> "ASCII" Then
            ctl.Value = False
        End If
    Next ctl
End Sub
Private Sub cmdInvert_Click()
    Dim ctl As MSForms.control
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag <> "ASCII" Then
            ctl.Value = Not ctl.Value
        End If
    Next ctl
End Sub

Private Sub cmdLetters_Click()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag = "Letters" Then ctl.Value = True
    Next ctl
    
End Sub
Private Sub cmdDigits_Click()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag = "Digits" Then ctl.Value = True
    Next ctl
    
End Sub
Private Sub cmdNonPrint_Click()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag = "NonPrint" Then ctl.Value = True
    Next ctl
    
End Sub
Private Sub cmdSymbols_Click()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag = "Symbols" Then ctl.Value = True
    Next ctl
    
End Sub

Private Sub tglUnicode_Click()
    If Me.tglUnicode = True And DisableEvents = False Then
        If UnicodeAlert = False Then
            UnicodeAlert = True
            MsgBox IIf(lng = 0, "Abilitando questa opzione, tutti i caratteri non inclusi nella lista sopra riportata saranno eliminati (es. emoji, caratteri di altre lingue etc.)", "Enabling this option, all characters not included in the above list will be deleted (ex. emoji, foreign languages characters, etc.)"), vbInformation
        End If
    End If
End Sub

Private Sub chkRight_Change()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraShortcuts.Controls
        If ctl.Tag = "Quick" Or _
           ctl.Tag = "Left" Or _
           ctl.Tag = "Truncate" Or _
           ctl.Tag = "BeforeText" Or _
           ctl.Tag = "AfterText" Then
                ctl.Enabled = Not Me.chkRight.Value
        End If
    Next ctl
    
    For Each ctl In Me.fraDelete.Controls
        ctl.Enabled = Not Me.chkRight.Value
    Next ctl
    
    If Me.chkRight = True Then
        Me.optDelete = True
        Me.optReplace.Enabled = False
    Else
        Me.optReplace.Enabled = True
    End If
    
End Sub

Private Sub chkLeft_Change()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraShortcuts.Controls
        If ctl.Tag = "Quick" Or _
           ctl.Tag = "Right" Or _
           ctl.Tag = "Truncate" Or _
           ctl.Tag = "BeforeText" Or _
           ctl.Tag = "AfterText" Then
                ctl.Enabled = Not Me.chkLeft.Value
        End If
    Next ctl

    For Each ctl In Me.fraDelete.Controls
        ctl.Enabled = Not Me.chkLeft.Value
    Next ctl
    
    If Me.chkLeft = True Then
        Me.optDelete = True
        Me.optReplace.Enabled = False
    Else
        Me.optReplace.Enabled = True
    End If

End Sub

Private Sub chkTruncate_Change()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraShortcuts.Controls
        If ctl.Tag = "Quick" Or _
           ctl.Tag = "Left" Or _
           ctl.Tag = "Right" Or _
           ctl.Tag = "BeforeText" Or _
           ctl.Tag = "AfterText" Then
                ctl.Enabled = Not Me.chkTruncate.Value
        End If
    Next ctl

    For Each ctl In Me.fraDelete.Controls
        ctl.Enabled = Not Me.chkTruncate.Value
    Next ctl

    If Me.chkTruncate = True Then
        Me.optDelete = True
        Me.optReplace.Enabled = False
    Else
        Me.optReplace.Enabled = True
    End If

End Sub

Private Sub chkBeforeText_Change()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraShortcuts.Controls
        If ctl.Tag = "Quick" Or _
           ctl.Tag = "Left" Or _
           ctl.Tag = "Right" Or _
           ctl.Tag = "Truncate" Or _
           ctl.Tag = "AfterText" Then
                ctl.Enabled = Not Me.chkBeforeText.Value
        End If
    Next ctl

    For Each ctl In Me.fraDelete.Controls
        ctl.Enabled = Not Me.chkBeforeText.Value
    Next ctl
    
    If Me.chkBeforeText = True Then
        Me.optDelete = True
        Me.optReplace.Enabled = False
    Else
        Me.optReplace.Enabled = True
    End If

    Me.txtBeforeText.Enabled = Me.chkBeforeText
End Sub

Private Sub chkAfterText_Change()
    Dim ctl As MSForms.control
    
    For Each ctl In Me.fraShortcuts.Controls
        If ctl.Tag = "Quick" Or _
           ctl.Tag = "Left" Or _
           ctl.Tag = "Right" Or _
           ctl.Tag = "Truncate" Or _
           ctl.Tag = "BeforeText" Then
                ctl.Enabled = Not Me.chkAfterText.Value
        End If
    Next ctl

    For Each ctl In Me.fraDelete.Controls
        ctl.Enabled = Not Me.chkAfterText.Value
    Next ctl
    
    If Me.chkAfterText = True Then
        Me.optDelete = True
        Me.optReplace.Enabled = False
    Else
        Me.optReplace.Enabled = True
    End If

    Me.txtAfterText.Enabled = Me.chkAfterText
End Sub

Private Sub spbRight_SpinDown()
    Me.txtRight = Me.spbRight
End Sub
Private Sub spbRight_SpinUp()
    Me.txtRight = Me.spbRight
End Sub
Private Sub txtRight_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtRight_Change()
    If Val(Me.txtRight) > Me.spbRight.Max Then Me.txtRight = Me.spbRight.Max
    If Val(Me.txtRight) < Me.spbRight.Min Then Me.txtRight = Me.spbRight.Min
    Me.spbRight = Me.txtRight
End Sub
Private Sub spbLeft_SpinDown()
    Me.txtLeft = Me.spbLeft
End Sub
Private Sub spbLeft_SpinUp()
    Me.txtLeft = Me.spbLeft
End Sub
Private Sub txtLeft_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtLeft_Change()
    If Val(Me.txtLeft) > Me.spbLeft.Max Then Me.txtLeft = Me.spbLeft.Max
    If Val(Me.txtLeft) < Me.spbLeft.Min Then Me.txtLeft = Me.spbLeft.Min
    Me.spbLeft = Me.txtLeft
End Sub
Private Sub spbTruncate_SpinDown()
    Me.txtTruncate = Me.spbTruncate
End Sub
Private Sub spbTruncate_SpinUp()
    Me.txtTruncate = Me.spbTruncate
End Sub
Private Sub txtTruncate_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtTruncate_Change()
    If Val(Me.txtTruncate) > Me.spbTruncate.Max Then Me.txtTruncate = Me.spbTruncate.Max
    If Val(Me.txtTruncate) < Me.spbTruncate.Min Then Me.txtTruncate = Me.spbTruncate.Min
    Me.spbTruncate = Me.txtTruncate
End Sub

Private Sub optReplace_Change()
    Me.txtReplace.Enabled = Me.optReplace.Value
    If Me.optReplace = False Then Me.txtReplace = ""
End Sub
    
Private Sub optDelete_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optReplace_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub txtAfterText_Change()
    Me.txtAfterText.ControlTipText = Me.txtAfterText.Text
End Sub

Private Sub txtBeforeText_Change()
    Me.txtBeforeText.ControlTipText = Me.txtBeforeText.Text
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim ctl As MSForms.control
    Dim SelectedChars() As Long
    Dim c As Long

    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
    
    Call AutoCalc(False)
    
    
    
    Call backup_create_new
    
    'Costruisco l'array di caratteri da eliminare
    c = 1
    ReDim SelectedChars(1 To 1)
    For Each ctl In Me.fraDelete.Controls
        If ctl.Tag <> "ASCII" Then
            If ctl.Value = True Then
                ReDim Preserve SelectedChars(1 To c)
                SelectedChars(c) = CLng(ctl.Name)
                c = c + 1
            End If
        End If
    Next ctl

    
    Set ws = ActiveSheet
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
    
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
    
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto cancellando i caratteri... (" & ws.Name & ")"
        Call ShowProgressBar
        
            For Each cell In InRng.Cells
            
                '#' Aumento di 1 il contatore
                counter = counter + 1
                                    
                If Not IsError(cell) Then
                
                    If Me.chkRight Then
                        
                        If Len(cell) <= CLng(Me.txtRight) Then
                            cell = ""
                        Else
                            cell = Right(cell, Len(cell) - CLng(Me.txtRight))
                        End If
                    
                    ElseIf Me.chkLeft Then
                        
                        If Len(cell) <= CLng(Me.txtLeft) Then
                            cell = ""
                        Else
                            cell = Left(cell, Len(cell) - CLng(Me.txtLeft))
                        End If
                    
                    ElseIf Me.chkTruncate Then
                    
                        If Len(cell) > CLng(Me.txtTruncate) Then
                            cell = Left(cell, CLng(Me.txtTruncate))
                        End If
                    
                    ElseIf Me.chkBeforeText = True And Me.chkBeforeText.Enabled = True And Me.txtBeforeText <> "" Then
                        If InStr(1, cell, Me.txtBeforeText) > 0 Then
                            cell = Right(cell, Len(cell) - InStr(1, cell, Me.txtBeforeText) - Len(Me.txtBeforeText) + 1)
                        End If
                    
                    ElseIf Me.chkAfterText = True And Me.chkAfterText.Enabled = True And Me.txtAfterText <> "" Then
                        If InStr(1, cell, Me.txtAfterText) > 0 Then
                            cell = Left(cell, InStr(1, cell, Me.txtAfterText) - 1)
                        End If
                    
                    Else
                        For c = 1 To UBound(SelectedChars, 1)
                            cell = Replace(cell, Chr(CLng(SelectedChars(c))), Me.txtReplace)
                        Next c
                        
                        If Me.tglUnicode = True Then
                            For c = Len(cell.Value) To 1 Step -1
                                If AscW(Mid(cell, c, 1)) <> Asc(Mid(cell, c, 1)) Then
                                    cell = Replace(cell, Mid(cell, c, 1), "")
                                End If
                            Next c
                        End If
                    End If
                
                End If
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        Next cell
            
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    Call AutoCalc(True)
    
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
        
Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmRoundToNDecimals"
Attribute VB_Base = "0{FC1BF550-E9EA-45F4-B9B6-BB4D4BB3992E}{FEBE8FA6-2628-4F49-A528-354705BDE576}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub


Private Sub spbNDecimals_SpinDown()
    Me.txtNDecimals = Me.spbNDecimals
End Sub

Private Sub spbNDecimals_SpinUp()
    Me.txtNDecimals = Me.spbNDecimals
End Sub

Private Sub txtNDecimals_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNDecimals_Change()
    If Val(Me.txtNDecimals) > Me.spbNDecimals.Max Then Me.txtNDecimals = Me.spbNDecimals.Max
    If Val(Me.txtNDecimals) < Me.spbNDecimals.Min Then Me.txtNDecimals = Me.spbNDecimals.Min
    Me.spbNDecimals = Me.txtNDecimals
    Me.chkEndingZeros.Caption = Replace(Me.chkEndingZeros.Caption, Mid(Me.chkEndingZeros.Caption, _
                                InStrRev(Me.chkEndingZeros.Caption, " ") + 1), Format(Round(1.5, Me.txtNDecimals), _
                                "#,##0" & IIf(Me.txtNDecimals > 0, "." & String(Me.txtNDecimals, "0"), "") & ")"))
End Sub

Private Sub optStandard_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optRoundUp_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optRoundDown_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
        
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide
    
        '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
        Call AutoCalc(False)
        
        
    
        '#' Crea foglio di backup nascosto
        Call backup_create_new
    
        On Error GoTo Aborted
        
        Set ws = ActiveSheet

        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If .chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Eseguo arrotondamento... (" & ws.Name & ")"
        Call ShowProgressBar
        
        For Each cell In InRng.Cells
            
            'Aumenta di 1 il contatore
            counter = counter + 1
            
            If Application.WorksheetFunction.IsNumber(cell) And Not IsEmpty(cell) Then
                    
                If .optStandard Then
                    
                    If cell.HasFormula And Not cell.HasArray And Me.chkFormulas Then
                        cell.Formula = "=ROUND(" & Mid(cell.Formula, 2) & ", " & Me.txtNDecimals & ")"
                    Else
                        cell = Application.WorksheetFunction.Round(cell, Me.txtNDecimals)
                    End If
                
                ElseIf .optRoundUp Then
                    
                    If cell.HasFormula And Not cell.HasArray And Me.chkFormulas Then
                        cell.Formula = "=ROUNDUP(" & Mid(cell.Formula, 2) & ", " & Me.txtNDecimals & ")"
                    Else
                        cell = Application.WorksheetFunction.RoundUp(cell, Me.txtNDecimals)
                    End If
                
                ElseIf .optRoundDown Then
                    
                    If cell.HasFormula And Not cell.HasArray And Me.chkFormulas Then
                        cell.Formula = "=ROUNDDOWN(" & Mid(cell.Formula, 2) & ", " & Me.txtNDecimals & ")"
                    Else
                        cell = Application.WorksheetFunction.RoundDown(cell, Me.txtNDecimals)
                    End If
                
                End If
                
                'Formatto la cella col numero di decimali visibili, zero inclusi
                If Me.chkEndingZeros = True Then
                    cell.NumberFormat = "#,##0" & IIf(Me.txtNDecimals > 0, "." & String(Me.txtNDecimals, "0"), "")
                End If
            End If
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next cell
    
        'Chiude la finestra di avanzamento
        Unload UProgress
        
    End With
        
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmRowsToColumns"
Attribute VB_Base = "0{359B261F-AD9A-4203-BF91-D34E51D5906C}{82B4B9D9-5769-44DB-B6D9-C915EF1B4A68}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim i As Long, j As Long
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)

    DisableEvents = True
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    DisableEvents = False
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

    Call Recompute

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub


Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
End Sub

Private Sub txtFixedCols_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtFixedCols_Change()
    If Val(Me.txtFixedCols) > Me.spbFixedCols.Max Then Me.txtFixedCols = Me.spbFixedCols.Max
    If Val(Me.txtFixedCols) < Me.spbFixedCols.Min Then Me.txtFixedCols = Me.spbFixedCols.Min
    If Me.txtFixedCols <> "" Then Me.spbFixedCols = Me.txtFixedCols
    Call Recompute(Val(Me.txtFixedCols))
End Sub
Private Sub spbFixedCols_SpinDown()
    Me.txtFixedCols = Me.spbFixedCols
End Sub
Private Sub spbFixedCols_SpinUp()
    Me.txtFixedCols = Me.spbFixedCols
End Sub

Private Sub txtVar_Enter()
    Me.spbFixedCols.SetFocus
End Sub

Private Sub Recompute(Optional Cfix As Long)
    Dim TempRng As Range
    
    If DisableEvents = True Then Exit Sub
        
    'Evitiamo la chiamata ricorsiva alla routine
    DisableEvents = True
    
    On Error Resume Next
    Set TempRng = Range(Replace(Me.refRange, ";", ","))
    If Application.WorksheetFunction.CountA(TempRng) = 0 Then Exit Sub
    
    If Cfix = 0 Then
        i = 0
        For Each cell In TempRng.Rows(1).Cells
            If cell.Value = "" Then i = i + 1 Else Exit For
        Next cell
        If i = 0 Then i = 1
        Me.txtFixedCols = i
    ElseIf Cfix > TempRng.Columns.Count - 1 Then
        Me.txtFixedCols = TempRng.Columns.Count - 1
    End If

    Me.txtVar = TempRng.Columns.Count - Me.txtFixedCols

    DisableEvents = False
    On Error GoTo 0
    
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wsRestr As Worksheet
    Dim restArray() As Variant
    Dim rowArray() As String
    Dim InRngArray() As Variant
    Dim fixRngArray() As String
    Dim i As Long, j As Long, k As Long, n As Long, r As Long
    Dim nVar As Long
    Dim tRows As New Collection
    Dim cDiscard As New Collection
    Dim strRow As String
    Dim cMax As Long
    Dim currCol As Long
        
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted

        .Hide

    End With

    Call AutoCalc(False)
    
    nVar = Me.txtVar
    Set ws = ActiveSheet
    Set wsRestr = Worksheets.Add(After:=Sheets(ws.index))
    wsRestr.Name = Left(ws.Name, 10) & "_pivot" & "_" & Format(Now, "yymmdd hhmmss")
    
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    InRngArray = InRng
    ReDim fixRngArray(1 To UBound(InRngArray, 1))
    
    For i = 1 + Me.txtHeader To UBound(InRngArray, 1)
        strRow = ""
        For j = 1 To Me.txtFixedCols
            strRow = strRow & "|" & InRngArray(i, j)
        Next j
        strRow = Mid(strRow, 2)
        fixRngArray(i) = strRow
        
        On Error Resume Next
        tRows.Add strRow, CStr(strRow)
        On Error GoTo Aborted
    Next i
    
    ReDim restArray(1 To tRows.Count + Me.txtHeader, 1 To UBound(InRngArray, 2))
        
            
    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = tRows.Count
    UProgress.SetDescription "Ricostruisco la struttura..."
    Call ShowProgressBar

    For r = 1 To tRows.Count
        
        counter = counter + 1
        
        currCol = UBound(InRngArray, 2)
        
        Erase rowArray
        rowArray = Split(tRows(r), "|")
        For n = LBound(rowArray) To UBound(rowArray)
            restArray(r + Me.txtHeader, n + 1) = rowArray(n)
        Next n
        
        For i = 1 + Me.txtHeader To UBound(fixRngArray)
            If CollKeyExists(cDiscard, CStr(i)) = False Then
                If fixRngArray(i) = tRows(r) Then
                    cDiscard.Add i, CStr(i)
                    If UBound(restArray, 2) < currCol Then ReDim Preserve restArray(1 To UBound(restArray, 1), 1 To currCol)
                        For k = 1 To nVar
                            restArray(r + Me.txtHeader, currCol - nVar + k) = InRngArray(i, UBound(InRngArray, 2) - nVar + k)
                        Next k
                    If currCol > cMax Then cMax = currCol
                    currCol = currCol + nVar
                End If
            End If
        Next i

        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
    Next r

    '#' Scrivo le intestazioni
    If Me.txtHeader > 0 Then
        For r = 1 To Me.txtHeader
            For j = 1 To UBound(InRngArray, 2)
                restArray(r, j) = InRngArray(r, j)
            Next j
                            
            j = UBound(InRngArray, 2) + 1
            Do
                For k = UBound(InRngArray, 2) - nVar + 1 To UBound(InRngArray, 2)
                    restArray(r, j) = InRngArray(r, k)
                    j = j + 1
                Next k
            Loop Until j > UBound(restArray, 2)
            
        Next r
    End If

    'Chiude la finestra di avanzamento
    Unload UProgress

    'Riporto i valori nel foglio di destinazione
    With wsRestr
        
        .Activate
        
        'Riporto i valori nel foglio di destinazione
        .Range("A1").reSize(UBound(restArray, 1), cMax).NumberFormat = "@"
        .Range("A1").reSize(UBound(restArray, 1), cMax) = restArray
        .Range("A1").reSize(UBound(restArray, 1), cMax).NumberFormat = "General"
        
        'Adatta larghezza colonne
        .UsedRange.Columns.AutoFit
        
    End With

    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub

Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmSaveToSeparateFiles"
Attribute VB_Base = "0{491F6E76-773D-4CA3-ACA0-8A204DD0C78E}{9E89F550-C3A5-464C-B06B-DD95F2452FB0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim FolderName As String
Dim DisableEvents As Boolean


Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
        
    DisableEvents = True
    
    Call ListSheets
        
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    With Me.cbxFormat
        .AddItem "Excel 2007+ (.xlsx)"
        .AddItem "Excel 97-2003 (.xls)"
        .AddItem "PDF (.pdf)"
        .AddItem "PDF multipage (.pdf)"
        .AddItem "Open Document Format (.ods)"
        .AddItem "Excel 95/5.0 (.xls)"
        .AddItem IIf(lng = 0, "Testo con delimitatore (.csv)", "Comma separated values (.csv)")
        .AddItem IIf(lng = 0, "Testo con del. custom (.csv)", "Custom separated values (.csv)")
        .AddItem IIf(lng = 0, "Testo Unicode (.txt)", "Unicode text (.txt)")
        .AddItem "File XML (.xml)"
        If .ListIndex = -1 Then .ListIndex = 0
    End With

    If ActiveWorkbook.path = "" Then
        Me.txtDestFolder = DesktopPath
    Else
        Me.txtDestFolder = ValidateFolder(ActiveWorkbook.path)
    End If
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)
        
    DisableEvents = False

End Sub

Private Sub ListSheets()
        
    If ActiveWorkbook Is Nothing Or ActiveWorkbook.Name = ThisWorkbook.Name Then Exit Sub
    
    Me.lbxSheets.Clear
    
    For Each ws In ActiveWorkbook.Worksheets
        
        If ws.Name = "ESK_Backup" Then GoTo Nextws
        If Me.chkEmpty = False And Application.WorksheetFunction.CountA(ws.Cells) = 0 Then GoTo Nextws
        If Me.chkHidden = False And ws.visible <> xlSheetVisible Then GoTo Nextws
            
        If UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*" Then
            If ws.visible <> xlSheetVisible Then
                Me.lbxSheets.AddItem ws.Name & IIf(lng = 0, " *Nascosto*", " *Hidden*")
            Else
                Me.lbxSheets.AddItem ws.Name
            End If
            If IsSelected(ws.Name) Or ActiveWindow.SelectedSheets.Count = 1 Then Me.lbxSheets.Selected(Me.lbxSheets.ListCount - 1) = True
        End If
Nextws:
    Next ws

End Sub

Private Sub optArea_Change()
    Me.refRange.Enabled = Me.optArea
End Sub

Private Sub txtFilterList_Change()
    Call ListSheets
End Sub

Private Sub chkEmpty_Change()
    Call ListSheets
End Sub

Private Sub chkHidden_Change()
    Call ListSheets
End Sub

Private Sub cbxFormat_Change()
    
    Select Case Me.cbxFormat.ListIndex
        Case 0, 1, 4
            Me.chkValues.Enabled = True
        Case Else
            Me.chkValues.Enabled = False
    End Select

    Select Case Me.cbxFormat.ListIndex
        Case 7
            Me.lblSeparator.Enabled = True
            Me.txtSeparator.Enabled = True
        Case Else
            Me.lblSeparator.Enabled = False
            Me.txtSeparator.Enabled = False
    End Select


End Sub

Private Sub cmdSelectFolder_Click()
    Me.txtDestFolder.Text = FolderPicker(Me.txtDestFolder.Text)
End Sub

Private Sub txtDestFolder_Change()
    Me.txtDestFolder.ControlTipText = Me.txtDestFolder.Text
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxSheets.ListCount - 1
        Me.lbxSheets.Selected(i) = Me.chkAllNone
    Next i
    
    Call GoodToGo(Me)
    
    DisableEvents = False
End Sub

Private Sub ExportToXML(sh As Worksheet)
    Dim headArr()
    Dim dataArr()
    Const strPrefix As String = "<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>"
    Dim oTag As String
    Const rTag As String = "    <record>"
    Dim f As Long
    Dim i As Long, j As Long
    
    f = FreeFile
    
    oTag = "<XmlExport"
    
    Open FolderName & sh.Name & ".xml" For Output As #f
    
    Print #f, strPrefix
    Print #f, oTag & " xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">"
    
    dataArr = sh.UsedRange
    
    With sh.UsedRange
        headArr = .Range(.Cells(1, 1), .Cells(1, .Columns.Count))
        For i = 2 To .Rows.Count
            Print #f, rTag
            For j = LBound(headArr, 2) To UBound(headArr, 2)
                Print #f, "        <" & Replace(headArr(1, j), " ", "") & ">" & dataArr(i, j) & "</" & Replace(headArr(1, j), " ", "") & ">"
            Next j
            Print #f, Replace(rTag, "<", "</")
        Next i
    End With
    Print #f, Replace(oTag, "<", "</") & ">"
    
    Close #f
    'Mi accerto che il file sia chiuso
    Call CloseTxt(FolderName & sh.Name & ".xml")

End Sub

Private Sub ExportWithCustomDelimiter(sh As Worksheet)
    Dim dataArr()
    Dim f As Long
    Dim i As Long, j As Long
    Dim strLine As String
    Dim sep As String
        
    sep = Me.txtSeparator
    
    f = FreeFile
    
    Open FolderName & sh.Name & ".csv" For Output As #f
    
    dataArr = sh.UsedRange
    
    With sh.UsedRange
        For i = LBound(dataArr, 1) To UBound(dataArr, 1)
            strLine = ""
            For j = LBound(dataArr, 2) To UBound(dataArr, 2)
                strLine = strLine & dataArr(i, j) & sep
            Next j
            Print #f, Left(strLine, Len(strLine) - Len(sep))
        Next i
    End With
    
    Close #f
    'Mi accerto che il file sia chiuso
    Call CloseTxt(FolderName & sh.Name & ".csv")

End Sub


Private Sub lbxSheets_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub


Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim FileExtStr As String
    Dim FileFormatNum As Long
    Dim Sourcewb As Workbook
    Dim DestWb As Workbook
    Dim DateString As String
    Dim i As Long
    Dim oFolder As Long
    Dim SelSheets As String
    Dim sCount As Long
    Dim wsName As String
    Dim wsVisible As Long
    Dim wsVisibleArr() As Long

    Me.Hide
    
    Set Sourcewb = ActiveWorkbook
    
    DateString = Format(Now, "yyyy-mm-dd hh-mm-ss")

    FolderName = ValidateFolder(Me.txtDestFolder)
    If Me.chkSubFolder Then FolderName = ValidateFolder(FolderName & DateString)
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)

    '#' Create new folder to save the new files in
    On Error Resume Next
    MkDir FolderName
    On Error GoTo Aborted
    
    
    
    '#' For anything except PDF multipage
    If Me.cbxFormat.ListIndex <> 3 Then
            
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = CountListBox(Me.lbxSheets)
        UProgress.SetDescription "Salvataggio di " & countermax & " file in corso..."
        Call ShowProgressBar
            
        '#' Copy every selected sheet to a new workbook
        For i = 0 To Me.lbxSheets.ListCount - 1
            If Me.lbxSheets.Selected(i) = True Then
                
                wsName = CleanSheetName(Me.lbxSheets.List(i))
                
                Set ws = ActiveWorkbook.Worksheets(wsName)
                
                '#' Aumento di 1 il contatore e aggiorno descrizione barra avanzamento
                counter = counter + 1
                UProgress.SetDescription "Salvataggio file in corso - " & counter & " di " & countermax & " - (" & ws.Name & ")"
                                
                '#' Rendo visibile il foglio
                wsVisible = ws.visible
                ws.visible = xlSheetVisible
                                
                '#' If the sheet is visible then copy it to a new workbook
                If Me.optWholeSheet Then
                    ws.Copy
                    '#' Set Destwb to the new workbook
                    Set DestWb = ActiveWorkbook
                Else
                    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
                    Workbooks.Add
                    '#' Set Destwb to the new workbook
                    Set DestWb = ActiveWorkbook
                    InRng.Copy DestWb.Sheets(1).Cells(1, 1)
                End If
                
                '#' Ripristino lo stato di visibilit|fffd|
                ws.visible = wsVisible
    
                '#' Determine the Excel version and file extension/format
                With DestWb
                
                    Select Case Me.cbxFormat.ListIndex
                        Case 0 '#' Excel 2007+
                            FileExtStr = ".xlsx"
                            FileFormatNum = 51
                        Case 1 '#' Excel 97-2003
                            FileExtStr = ".xls"
                            FileFormatNum = 56
                        Case 2, 3 '#' PDF
                            '#' No variables set
                        Case 4
                            FileExtStr = ".ods"
                            FileFormatNum = 60
                        Case 5
                            FileExtStr = ".xls"
                            FileFormatNum = 39
                        Case 6
                            FileExtStr = ".csv"
                            FileFormatNum = 6
                        Case 8
                            FileExtStr = ".txt"
                            FileFormatNum = 42
                        Case 7, 9 '#' Separatore custom o XML
                            '#' No variables set
                    
                    End Select
                
                End With
    
                '#' Change all cells in the worksheet to values if you want
                If Me.chkValues Then
                    If DestWb.Sheets(1).ProtectContents = False Then
                        With DestWb.Sheets(1).UsedRange
                            .Cells.Copy
                            .Cells.PasteSpecial xlPasteValues
                            .Cells(1).Select
                        End With
                        Application.CutCopyMode = False
                    End If
                End If
    
                '#' Save the new workbook and close it
                Application.DisplayAlerts = False
                With DestWb
                    
                    Select Case Me.cbxFormat.ListIndex
                        Case 2 '#' PDF
                            .Sheets(1).ExportAsFixedFormat Type:=xlTypePDF, FileName:=FolderName & DestWb.Sheets(1).Name & ".pdf", Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:=False
                        Case 7 '#' Separatore custom
                            Call ExportWithCustomDelimiter(DestWb.Sheets(1))
                        Case 9 '#' XML
                            Call ExportToXML(DestWb.Sheets(1))
                        Case Else
                            Call SaveFile(DestWb, FolderName & DestWb.Sheets(1).Name & FileExtStr, NewFileFormat:=FileFormatNum, NewFileLocal:=True, Silent:=True)
                    End Select
                    
                    .Close False
                
                End With
                Application.DisplayAlerts = True
                
GoToNextSheet:
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            End If
        Next i
    
        '#' Chiudo la finestra di avanzamento
        Unload UProgress
    
    Else '#' PDF multipage
        sCount = 0
        ReDim wsVisibleArr(0 To CountListBox(Me.lbxSheets))
        
        For i = 0 To Me.lbxSheets.ListCount - 1
            If Me.lbxSheets.Selected(i) = True Then
                wsName = Replace(Replace(Me.lbxSheets.List(i), " *Nascosto*", ""), " *Hidden*", "")
                
                Set ws = ActiveWorkbook.Worksheets(wsName)
                
                '#' Rendo visibile il foglio
                wsVisibleArr(i) = ws.visible
                ws.visible = xlSheetVisible
                
                SelSheets = SelSheets & "," & wsName
            End If
        Next i
        SelSheets = Mid(SelSheets, 2)
        Sourcewb.Sheets(Split(SelSheets, ",")).Select
        ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, FileName:=FolderName & Replace(Sourcewb.Name, "." & FileExt(Sourcewb.Name), "") & ".pdf", Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:=False
        
        'Ripristino la visibilit|fffd| dei fogli
        For i = 0 To Me.lbxSheets.ListCount - 1
            If Me.lbxSheets.Selected(i) = True Then
                wsName = Replace(Replace(Me.lbxSheets.List(i), " *Nascosto*", ""), " *Hidden*", "")
                
                Set ws = ActiveWorkbook.Worksheets(wsName)
                
                ws.visible = wsVisibleArr(i)
                
            End If
        Next i
        
        On Error Resume Next
        Sourcewb.Worksheets(1).Select
        On Error GoTo Aborted
    End If

    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    oFolder = MsgBox("Esportazione di " & countermax & " file completata. Troverai i file nella cartella: " & vbNewLine & vbNewLine & FolderName & vbNewLine & vbNewLine & "Vuoi aprire la cartella di destinazione?", vbInformation + vbYesNo, "Esportazione completata")
    If oFolder = vbYes Then Call OpenFolder(FolderName)
        
    Exit Sub
        
Aborted:
    If Me.cbxFormat.ListIndex = 2 Or Me.cbxFormat.ListIndex = 3 Then
        Call Excel2007PDF
    End If
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmSelectCols"
Attribute VB_Base = "0{9C62293E-8750-40DE-873E-3F430CB9B66E}{6B91607E-E507-4928-90CD-044DC4CF5D75}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()

    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng = 0 Then
        With Me.cobCriteria
            .AddItem "Ogni N colonne"
            .AddItem "Le celle selezionate sono vuote"
            .AddItem "Le celle selezionate contengono:"
            .AddItem "Le celle selezionate NON contengono:"
            .AddItem "Le celle coincidono con una cella dell'intervallo:"
            .AddItem "Le celle NON coincidono con una cella dell'intervallo:"
        End With
    Else
        With Me.cobCriteria
            .AddItem "Every N columns"
            .AddItem "Selected cells are empty"
            .AddItem "Selected cells contain:"
            .AddItem "Selected cells DON'T contain:"
            .AddItem "Cells match one cell in the range:"
            .AddItem "Cells DON'T match any cell in the range:"
        End With
    End If
    Me.cobCriteria.ListIndex = 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub cobCriteria_Change()
    Dim ctl As control
    
    Select Case Me.cobCriteria.ListIndex
        Case 0 'Ogni n colonne
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then ' If omitted, all controls in form must have a TAG value
                    If InStr(1, ctl.Tag, "NCol") > 0 Then
                        ctl.visible = True
                    Else
                        ctl.visible = False
                    End If
                End If
            Next
        Case 1 'Le celle selezionate sono vuote
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then
                    ctl.visible = False
                End If
            Next
        Case 2, 3 'Le celle selezionate contengono/non contengono
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then ' If omitted, all controls in form must have a TAG value
                    If InStr(1, ctl.Tag, "InStr") > 0 Then
                        ctl.visible = True
                    Else
                        ctl.visible = False
                    End If
                End If
            Next
        Case 4, 5 'Le celle selezionate coincidono/non coincidono con intervallo
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then ' If omitted, all controls in form must have a TAG value
                    If InStr(1, ctl.Tag, "Compare") > 0 Then
                        ctl.visible = True
                    Else
                        ctl.visible = False
                    End If
                End If
            Next
    End Select
End Sub

Private Sub spbNCol_SpinDown()
    Me.txtNCol = Me.spbNCol
End Sub

Private Sub spbNCol_SpinUp()
    Me.txtNCol = Me.spbNCol
End Sub

Private Sub txtNCol_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNCol_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtNCol) > Me.spbNCol.Max Then Me.txtNCol = Me.spbNCol.Max
    If Val(Me.txtNCol) < Me.spbNCol.Min Then Me.txtNCol = Me.spbNCol.Min
    Me.spbNCol = Me.txtNCol
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim cell2 As Range
    Dim rNew As Range
    Dim n As Long, k As Long
    Dim FirstCol As Long
    Dim SearchString As String
    Dim rngCompare As Range
    
    With Me
        On Error Resume Next
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
            
            Select Case .cobCriteria.ListIndex
                Case 4, 5 'Range di confronto
                    If TypeName(Range(.refCompare)) <> "Range" Or WorksheetFunction.CountA(Range(.refCompare)) = 0 Then
                        MsgBox "Inserire un intervallo valido come range di confronto. Riprovare", vbExclamation
                        .refCompare.SetFocus
                        Err.Clear
                        Exit Sub
                    End If
                End Select

        .Hide
        
        Set ws = ActiveSheet
        Set InRng = RangeResize(ws.Range(Replace(.refRange, ";", ",")), ws)
        
        FirstCol = InRng.Column
        
        Select Case .cobCriteria.ListIndex
            Case 0 'OGNI N COLONNE
                n = .txtNCol
                If .optEntireCols Then
                    If .chk1st = True Then
                        Set rNew = InRng.Cells(1, 1).EntireColumn
                        For Each cell In InRng.Rows(1).Cells
                            If (cell.Column - FirstCol) Mod n = 0 Then
                                Set rNew = Union(rNew, cell.EntireColumn)
                            End If
                        Next cell
                    Else
                        For Each cell In InRng.Rows(1).Cells
                            If (cell.Column - FirstCol + 1) Mod n = 0 Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireColumn
                                Else
                                    Set rNew = Union(rNew, cell.EntireColumn)
                                End If
                            End If
                        Next
                    End If
                Else
                    If .chk1st = True Then
                        Set rNew = InRng.Columns(1)
                        For Each cell In InRng.Rows(1).Cells
                            If (cell.Column - FirstCol) Mod n = 0 Then
                                Set rNew = Union(rNew, InRng.Columns(cell.Column - FirstCol + 1))
                            End If
                        Next
                    Else
                        For Each cell In InRng.Rows(1).Cells
                            If (cell.Column - FirstCol + 1) Mod n = 0 Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Columns(cell.Column - FirstCol + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Columns(cell.Column - FirstCol + 1))
                                End If
                            End If
                        Next
                    End If
                End If
                
            Case 1 'LE CELLE SELEZIONATE SONO VUOTE
                If .optEntireCols Then
                    For Each cell In InRng.Cells
                        If IsEmpty(cell) Then
                            If rNew Is Nothing Then
                                Set rNew = cell.EntireColumn
                            Else
                                Set rNew = Union(rNew, cell.EntireColumn)
                            End If
                        End If
                    Next
                Else
                    For Each cell In InRng.Cells
                        If IsEmpty(cell) Then
                            If rNew Is Nothing Then
                                Set rNew = InRng.Columns(cell.Column - FirstCol + 1)
                            Else
                                Set rNew = Union(rNew, InRng.Columns(cell.Column - FirstCol + 1))
                            End If
                        End If
                    Next
                End If
            
            Case 2 'LE CELLE SELEZIONATE CONTENGONO:
                SearchString = .txtInStr
                If .optEntireCols Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireColumn
                                Else
                                    Set rNew = Union(rNew, cell.EntireColumn)
                                End If
                            End If
                        End If
                    Next
                Else
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Columns(cell.Column - FirstCol + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Columns(cell.Column - FirstCol + 1))
                                End If
                            End If
                        End If
                    Next
                End If
            Case 3 'LE CELLE SELEZIONATE NON CONTENGONO:
                SearchString = .txtInStr
                If .optEntireCols Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) = False Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireColumn
                                Else
                                    Set rNew = Union(rNew, cell.EntireColumn)
                                End If
                            End If
                        End If
                    Next
                Else
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) = False Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Columns(cell.Column - FirstCol + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Columns(cell.Column - FirstCol + 1))
                                End If
                            End If
                        End If
                    Next
                End If
            Case 4 'LE CELLE SELEZIONATE CORRISPONDONO A UNA CELLA DELL'INTERVALLO:
                Set rngCompare = Range(.refCompare.Text)
                If .optEntireCols Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            For Each cell2 In rngCompare.Cells
                                If cell = cell2 Then
                                    If rNew Is Nothing Then
                                        Set rNew = cell.EntireColumn
                                    Else
                                        Set rNew = Union(rNew, cell.EntireColumn)
                                    End If
                                End If
                            Next cell2
                        End If
                    Next cell
                Else
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            For Each cell2 In rngCompare.Cells
                                If cell = cell2 Then
                                    If rNew Is Nothing Then
                                        Set rNew = InRng.Columns(cell.Column - FirstCol + 1)
                                    Else
                                        Set rNew = Union(rNew, InRng.Columns(cell.Column - FirstCol + 1))
                                    End If
                                End If
                            Next cell2
                        End If
                    Next cell
                End If
            Case 5 'LE CELLE SELEZIONATE NON CORRISPONDONO A UNA CELLA DELL'INTERVALLO:
                Set rngCompare = Range(.refCompare.Text)
                If .optEntireCols Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            k = 0
                            For Each cell2 In rngCompare.Cells
                                If cell <> cell2 Then k = k + 1
                            Next cell2
                            If k = rngCompare.Cells.Count Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireColumn
                                Else
                                    Set rNew = Union(rNew, cell.EntireColumn)
                                End If
                            End If
                        End If
                    Next cell
                Else
                    For Each cell In InRng.Cells
                        k = 0
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            For Each cell2 In rngCompare.Cells
                                If cell <> cell2 Then k = k + 1
                            Next cell2
                            If k = rngCompare.Cells.Count Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Columns(cell.Column - FirstCol + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Columns(cell.Column - FirstCol + 1))
                                End If
                            End If
                        End If
                    Next cell
                End If
        End Select
        
    End With
    
    'Selezione finale
    If Not rNew Is Nothing Then
        rNew.Select
    Else
        MsgBox IIf(lng = 0, "Non sono state individuate colonne da selezionare", _
                            "No columns to be selected were found"), vbInformation
        InRng.Cells(1, 1).Select
    End If
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmSelectRows"
Attribute VB_Base = "0{60D4C621-B7B3-4F96-8FA2-13404E5F5D5C}{69B6F3D3-3FAF-4E7C-AD4B-E1FFE84BFEFD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()

    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0
    
    If lng = 0 Then
        With Me.cobCriteria
            .AddItem "Ogni N colonne"
            .AddItem "Le celle selezionate sono vuote"
            .AddItem "Le celle selezionate contengono:"
            .AddItem "Le celle selezionate NON contengono:"
            .AddItem "Le celle coincidono con una cella dell'intervallo:"
            .AddItem "Le celle NON coincidono con una cella dell'intervallo:"
        End With
    Else
        With Me.cobCriteria
            .AddItem "Every N columns"
            .AddItem "Selected cells are empty"
            .AddItem "Selected cells contain:"
            .AddItem "Selected cells DON'T contain:"
            .AddItem "Cells match one cell in the range:"
            .AddItem "Cells DON'T match any cell in the range:"
        End With
    End If
    Me.cobCriteria.ListIndex = 0
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub

Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub spbNRow_SpinDown()
    Me.txtNRow = Me.spbNRow
End Sub

Private Sub spbNRow_SpinUp()
    Me.txtNRow = Me.spbNRow
End Sub

Private Sub txtNRow_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNRow_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtNRow) > Me.spbNRow.Max Then Me.txtNRow = Me.spbNRow.Max
    If Val(Me.txtNRow) < Me.spbNRow.Min Then Me.txtNRow = Me.spbNRow.Min
    Me.spbNRow = Me.txtNRow
End Sub

Private Sub cobCriteria_Change()
    Dim ctl As control
    
    Select Case Me.cobCriteria.ListIndex
        Case 0 'Ogni n Righe
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then ' If omitted, all controls in form must have a TAG value
                    If InStr(1, ctl.Tag, "NRow") > 0 Then
                        ctl.visible = True
                    Else
                        ctl.visible = False
                    End If
                End If
            Next
        Case 1 'Le celle selezionate sono vuote
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then
                    ctl.visible = False
                End If
            Next
        Case 2, 3 'Le celle selezionate contengono/non contengono
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then ' If omitted, all controls in form must have a TAG value
                    If InStr(1, ctl.Tag, "InStr") > 0 Then
                        ctl.visible = True
                    Else
                        ctl.visible = False
                    End If
                End If
            Next
        Case 4, 5 'Le celle selezionate coincidono/non coincidono con intervallo
            For Each ctl In Me.Controls
                If Not ctl.Tag = "" Then ' If omitted, all controls in form must have a TAG value
                    If InStr(1, ctl.Tag, "Compare") > 0 Then
                        ctl.visible = True
                    Else
                        ctl.visible = False
                    End If
                End If
            Next
    End Select
End Sub
Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim cell2 As Range
    Dim rNew As Range
    Dim n As Long, k As Long
    Dim FirstRow As Long
    Dim SearchString As String
    Dim rngCompare As Range
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        Select Case .cobCriteria.ListIndex
            Case 4, 5 'Range di confronto
                If TypeName(Range(.refCompare)) <> "Range" Or WorksheetFunction.CountA(Range(.refCompare)) = 0 Then
                    MsgBox "Inserire un intervallo valido come range di confronto. Riprovare", vbExclamation
                    .refCompare.SetFocus
                    Err.Clear
                    Exit Sub
                End If
        End Select
        

        .Hide
    
    
        Set ws = ActiveSheet
        Set InRng = RangeResize(ws.Range(Replace(.refRange, ";", ",")), ws)
        
        FirstRow = InRng.Row
        
        Select Case .cobCriteria.ListIndex
            
            'OGNI N RIGHE
            Case 0
                n = .txtNRow
                If .optEntireRows Then
                    If .chk1st = True Then
                        Set rNew = InRng.Cells(1, 1).EntireRow
                        For Each cell In InRng.Columns(1).Cells
                            If (cell.Row - FirstRow) Mod n = 0 Then
                                Set rNew = Union(rNew, cell.EntireRow)
                            End If
                        Next cell
                    Else
                        For Each cell In InRng.Columns(1).Cells
                            If (cell.Row - FirstRow + 1) Mod n = 0 Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireRow
                                Else
                                    Set rNew = Union(rNew, cell.EntireRow)
                                End If
                            End If
                        Next
                    End If
                Else
                    If .chk1st = True Then
                        Set rNew = InRng.Rows(1)
                        For Each cell In InRng.Columns(1).Cells
                            If (cell.Row - FirstRow) Mod n = 0 Then
                                Set rNew = Union(rNew, InRng.Rows(cell.Row - FirstRow + 1))
                            End If
                        Next
                    Else
                        For Each cell In InRng.Columns(1).Cells
                            If (cell.Row - FirstRow + 1) Mod n = 0 Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Rows(cell.Row - FirstRow + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Rows(cell.Row - FirstRow + 1))
                                End If
                            End If
                        Next
                    End If
                End If
                
            Case 1 'LE CELLE SELEZIONATE SONO VUOTE
                If .optEntireRows Then
                    For Each cell In InRng.Cells
                        If IsEmpty(cell) Then
                            If rNew Is Nothing Then
                                Set rNew = cell.EntireRow
                            Else
                                Set rNew = Union(rNew, cell.EntireRow)
                            End If
                        End If
                    Next
                Else
                    For Each cell In InRng.Cells
                        If IsEmpty(cell) Then
                            If rNew Is Nothing Then
                                Set rNew = InRng.Rows(cell.Row - FirstRow + 1)
                            Else
                                Set rNew = Union(rNew, InRng.Rows(cell.Row - FirstRow + 1))
                            End If
                        End If
                    Next
                End If
            'LE CELLE SELEZIONATE CONTENGONO:
            Case 2
                SearchString = .txtInStr
                If .optEntireRows Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireRow
                                Else
                                    Set rNew = Union(rNew, cell.EntireRow)
                                End If
                            End If
                        End If
                    Next
                Else
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Rows(cell.Row - FirstRow + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Rows(cell.Row - FirstRow + 1))
                                End If
                            End If
                        End If
                    Next
                End If
                
            'LE CELLE SELEZIONATE NON CONTENGONO:
            Case 3
                SearchString = .txtInStr
                If .optEntireRows Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) = False Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireRow
                                Else
                                    Set rNew = Union(rNew, cell.EntireRow)
                                End If
                            End If
                        End If
                    Next
                Else
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            If InStr(1, UCase(cell), UCase(SearchString)) = False Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Rows(cell.Row - FirstRow + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Rows(cell.Row - FirstRow + 1))
                                End If
                            End If
                        End If
                    Next
                End If
            'LE CELLE SELEZIONATE CORRISPONDONO A UNA CELLA DELL'INTERVALLO:
            Case 4
                Set rngCompare = Range(.refCompare.Text)
                If .optEntireRows Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            For Each cell2 In rngCompare.Cells
                                If cell = cell2 Then
                                    If rNew Is Nothing Then
                                        Set rNew = cell.EntireRow
                                    Else
                                        Set rNew = Union(rNew, cell.EntireRow)
                                    End If
                                End If
                            Next cell2
                        End If
                    Next cell
                Else
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            For Each cell2 In rngCompare.Cells
                                If cell = cell2 Then
                                    If rNew Is Nothing Then
                                        Set rNew = InRng.Rows(cell.Row - FirstRow + 1)
                                    Else
                                        Set rNew = Union(rNew, InRng.Rows(cell.Row - FirstRow + 1))
                                    End If
                                End If
                            Next cell2
                        End If
                    Next cell
                End If
                
            'LE CELLE SELEZIONATE NON CORRISPONDONO A UNA CELLA DELL'INTERVALLO:
            Case 5
                Set rngCompare = Range(.refCompare.Text)
                If .optEntireRows Then
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            k = 0
                            For Each cell2 In rngCompare.Cells
                                If cell <> cell2 Then k = k + 1
                            Next cell2
                            If k = rngCompare.Cells.Count Then
                                If rNew Is Nothing Then
                                    Set rNew = cell.EntireRow
                                Else
                                    Set rNew = Union(rNew, cell.EntireRow)
                                End If
                            End If
                        End If
                    Next cell
                Else
                    For Each cell In InRng.Cells
                        If Not Application.WorksheetFunction.IsError(cell) Then
                            k = 0
                            For Each cell2 In rngCompare.Cells
                                If cell <> cell2 Then k = k + 1
                            Next cell2
                            If k = rngCompare.Cells.Count Then
                                If rNew Is Nothing Then
                                    Set rNew = InRng.Rows(cell.Row - FirstRow + 1)
                                Else
                                    Set rNew = Union(rNew, InRng.Rows(cell.Row - FirstRow + 1))
                                End If
                            End If
                        End If
                    Next cell
                End If
        End Select
        
    End With
    
    'Selezione finale
    If Not rNew Is Nothing Then
        rNew.Select
    Else
        MsgBox IIf(lng = 0, "Non sono state individuate righe da selezionare", _
                            "No rows to be selected were found"), vbInformation
        InRng.Cells(1, 1).Select
    End If
    
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub



Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmSettings"
Attribute VB_Base = "0{FADE7973-2D6E-4559-A597-9407558C0AA0}{C80C258A-567C-4D95-BA43-E15720198E87}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim PBAlert As Boolean
Dim oSaved As Boolean

Private Sub UserForm_Initialize()
            
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    PBAlert = True
    Me.mpgSettings.Value = 0
        
    Call RestoreRibbon
    
    Select Case lng
        
        Case 0 'Italiano
            
            '#' Dove salvare le impostazioni
            With Me.cbxSettingsLocation
                .AddItem "Nella cartella utente di Windows"
                .AddItem "Nella cartella del programma"
            End With
            
            '#' Controlla aggiornamenti all'avvio
            With Me.cbxAutocheck
                .AddItem "Ogni giorno"
                .AddItem "Una volta alla settimana"
                .AddItem "Una volta al mese"
                .AddItem "Mai"
            End With
            
            '#' Scegli quali impostazioni caricare all'avvio degli strumenti
            With Me.cbxLoadSettings
                .AddItem "Le impostazioni di default"
                .AddItem "Le ultime impostazioni utilizzate"
            End With
    
        Case Else
            
            '#' Dove salvare le impostazioni
            With Me.cbxSettingsLocation
                .AddItem "User profile Windows folder"
                .AddItem "Program folder"
            End With
            
            '#' Controlla aggiornamenti all'avvio
            With Me.cbxAutocheck
                .AddItem "Every day"
                .AddItem "Once a week"
                .AddItem "Once a month"
                .AddItem "Never"
            End With
            
            '#' Scegli quali impostazioni caricare all'avvio degli strumenti
            With Me.cbxLoadSettings
                .AddItem "Default settings"
                .AddItem "Last used settings"
            End With
    
    End Select
    
    
    
    '#' Impostazioni indipendenti dalla lingua
    
    '#' Selezione lingua
    With Me.cbxLanguage
        .AddItem "Italiano"
        .AddItem "English"
    End With
    
    Me.cbxLanguage.ListIndex = lng
            
    '#' Preimposto l'intervallo di ricerca aggiornamenti
    Select Case GetSettings("AutoCheckInterval")
        Case 0
            Me.cbxAutocheck.ListIndex = 0
        Case 7
            Me.cbxAutocheck.ListIndex = 1
        Case 30
            Me.cbxAutocheck.ListIndex = 2
        Case 99999
            Me.cbxAutocheck.ListIndex = 3
        Case Else
            Me.cbxAutocheck.ListIndex = 0
    End Select
    
    Me.chkBetaUpdate = CBool(GetSettings("CheckBetaUpdate"))
    
    Me.lblMac.visible = Not IsWindows
    
    If IsWindows = False Then
        Me.cbxSettingsLocation.Enabled = False
        Me.cbxSettingsLocation.ListIndex = 1
    Else
        If Dir(ThisWorkbook.path & pSep & ".Portable", vbHidden) = "" Then
            Me.cbxSettingsLocation.ListIndex = 0
        Else
            Me.cbxSettingsLocation.ListIndex = 1
        End If
    End If
            
    Select Case GetSettings("LoadSettings")
        Case 0
            Me.cbxLoadSettings.ListIndex = 0
        Case 1
            Me.cbxLoadSettings.ListIndex = 1
        Case Else
            Me.cbxLoadSettings.ListIndex = 1
    End Select
    
    '#' Richiesta di creazione e cancellazione del foglio di backup
    Me.chkDeleteBackup = CBool(GetSettings("DeleteBackup"))
    Me.chkCreateBackup = CBool(GetSettings("CreateBackup"))
    
    '#' Dimensioni del form
    With Me.cbxScale
        .AddItem "200%  "
        .AddItem "150%  "
        .AddItem "100%  "
        .AddItem "75%  "
        .AddItem "Custom  "
    
        Select Case GetSettings("Scale")
            Case 200
                .ListIndex = 0
            Case 150
                .ListIndex = 1
            Case 100
                .ListIndex = 2
            Case 75
                .ListIndex = 3
            Case Else
                .ListIndex = 4
                Me.txtScale = GetSettings("Scale")
        End Select
    End With
            
    '#' Visualizzazione della barra di progresso
    Me.chkDisableProgressBar = CBool(GetSettings("DisableProgBar"))
    
    '#' Impostazioni SnapShot
    Me.chkPurgeSnapOnExit = CBool(GetSettings("PurgeSnapOnExit"))
    Me.txtMaxSnap = GetSettings("MaxSnapFiles")
    Me.spbMaxSnap = GetSettings("MaxSnapFiles")
    Me.chkSilentSnapshot = CBool(GetSettings("SilentSnapshot"))
    
    Me.txtSnapFolder = SnapFolder
    If (ValidateFolder(Me.txtSnapFolder, True) = False Or Me.txtSnapFolder = "") And _
        IsWindows = True Then
            Me.txtSnapFolder = Environ("Appdata") & "\Snapshots\"
    End If
    Me.txtSnapFolder.ControlTipText = Me.txtSnapFolder.Text
    
    ''' Fine Impostazioni SnapShot '''''''''''''''''''''''''''
        
    If IsPortable = True Then Call SwitchToPortable
    If lng > 0 Then
        Call TranslateForm(Me)
        Me.mpgSettings.Pages(0).Caption = TranslateCnst("Me.mpgSettings.Pages(0)")
        Me.mpgSettings.Pages(2).Caption = TranslateCnst("Me.mpgSettings.Pages(2)")
    End If
    
    PBAlert = False
    
End Sub
Private Sub cbxLanguage_Change()
    Call TranslateForm(Me, cbxLanguage.ListIndex)
    Call TranslateCombos
    oSaved = False
End Sub

Private Sub SwitchToPortable()
    Dim ctl As control
    
    Me.cbxSettingsLocation.ListIndex = 1
    Me.cbxAutocheck.ListIndex = 3
    Me.cbxLoadSettings.ListIndex = 0
    
    For Each ctl In Me.Controls
        If Left(ctl.Name, 3) <> "lbl" And _
            Left(ctl.Name, 3) <> "fra" And _
            Left(ctl.Name, 3) <> "mpg" And _
            Left(ctl.Name, 3) <> "cmd" And _
            Left(ctl.Name, 3) <> "pag" And _
            ctl.Name <> "cbxLanguage" And _
            InStr(1, ctl.Name, "Scale") = 0 _
                Then ctl.Enabled = False
    Next ctl

End Sub

Private Sub cbxAutocheck_Change()
    If IsPortable = False Then
        Me.chkBetaUpdate.Enabled = (Me.cbxAutocheck.ListIndex <> 3)
    End If
    oSaved = False
End Sub

Private Sub TranslateCombos()
    Dim AutoCheckIntervalLI As Long
    Dim SettingsLocationLI As Long
    Dim LoadSettingsLI As Long
    
    AutoCheckIntervalLI = Me.cbxAutocheck.ListIndex
    SettingsLocationLI = Me.cbxSettingsLocation.ListIndex
    LoadSettingsLI = Me.cbxLoadSettings.ListIndex
    
    Application.EnableEvents = False
    
    Select Case Me.cbxLanguage.ListIndex
        
        Case 0 'Italiano
            
            '#' Dove salvare le impostazioni
            With Me.cbxSettingsLocation
                .Clear
                .AddItem "Nella cartella utente di Windows"
                .AddItem "Nella cartella del programma"
            End With
            
            '#' Controlla aggiornamenti all'avvio
            With Me.cbxAutocheck
                .Clear
                .AddItem "Ogni giorno"
                .AddItem "Una volta alla settimana"
                .AddItem "Una volta al mese"
                .AddItem "Mai"
            End With
            
            '#' Scegli quali impostazioni caricare all'avvio degli strumenti
            With Me.cbxLoadSettings
                .Clear
                .AddItem "Le impostazioni di default"
                .AddItem "Le ultime impostazioni utilizzate"
            End With
    
        Case Else
            
            '#' Dove salvare le impostazioni
            With Me.cbxSettingsLocation
                .Clear
                .AddItem "User profile Windows folder"
                .AddItem "Program folder"
            End With
            
            '#' Controlla aggiornamenti all'avvio
            With Me.cbxAutocheck
                .Clear
                .AddItem "Every day"
                .AddItem "Once a week"
                .AddItem "Once a month"
                .AddItem "Never"
            End With
            
            '#' Scegli quali impostazioni caricare all'avvio degli strumenti
            With Me.cbxLoadSettings
                .Clear
                .AddItem "Default settings"
                .AddItem "Last used settings"
            End With
    
    End Select
    
    Application.EnableEvents = True
    
    If IsPortable = True Then
        Call SwitchToPortable
    Else
    
        Me.cbxAutocheck.ListIndex = AutoCheckIntervalLI
        Me.cbxSettingsLocation.ListIndex = SettingsLocationLI
        Me.cbxLoadSettings.ListIndex = LoadSettingsLI
        
    End If
End Sub

Private Sub spbMaxSnap_SpinDown()
    Me.txtMaxSnap = Me.spbMaxSnap
    oSaved = False
End Sub

Private Sub spbMaxSnap_SpinUp()
    Me.txtMaxSnap = Me.spbMaxSnap
    oSaved = False
End Sub
Private Sub txtMaxSnap_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtMaxSnap_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtMaxSnap) > Me.spbMaxSnap.Max Then Me.txtMaxSnap = Me.spbMaxSnap.Max
    If Val(Me.txtMaxSnap) < Me.spbMaxSnap.Min Then Me.txtMaxSnap = Me.spbMaxSnap.Min
    Me.spbMaxSnap = Me.txtMaxSnap
    oSaved = False
End Sub

Private Sub cmdSelectFolder_Click()
    Me.txtSnapFolder.Text = FolderPicker(Me.txtSnapFolder.Text)
    Me.txtSnapFolder.ControlTipText = Me.txtSnapFolder.Text
    oSaved = False
End Sub

Private Sub cbxScale_Change()
    Me.txtScale.visible = (Me.cbxScale.ListIndex = 4)
    Me.lblCustom.visible = (Me.cbxScale.ListIndex = 4)
    On Error Resume Next
    If Me.cbxScale.ListIndex = 4 Then Me.txtScale.SetFocus
    On Error GoTo 0
    oSaved = False
End Sub

Private Sub txtScale_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
    oSaved = False
End Sub

Private Sub chkDisableProgressBar_Click()
    If Me.chkDisableProgressBar = True Then
        If PBAlert = False Then
            MsgBox IIf(lng = 0, "Attenzione: disabilitando la barra di progresso, non sar|fffd| possibile annullare le operazioni " & _
                              "prima del loro completamento, e non si vedr|fffd| a che punto |fffd| arrivata l'elaborazione", _
                              "Warning: by disabling the progress bar, you won't be able to cancel an operation before it's " & _
                              "completed, and you won't see how far the processing has gone"), vbExclamation, IIf(lng = 0, "Avviso", "Warning")
                              
        End If
        PBAlert = True
    End If
    oSaved = False
    
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdSaveSettings_Click()
    Dim f As Long
    Dim strRestart As String
    
    On Error GoTo ErrHandler
    
    'TUTTE LE VERSIONI
    
    '#' Assicuriamo la valorizzazione della variabile ESKRibbon
    Call RestoreRibbon
    
    '#' Aggiorna lingua
    If Me.cbxLanguage.ListIndex <> lng Then
        Call UpdateConfigFile("Language", CInt(Me.cbxLanguage.ListIndex))
        
        If ESKRibbon Is Nothing Then
            If lng = 0 Then
                strRestart = vbNewLine & vbNewLine & "Riavviare Excel per completare la modifica della lingua"
            Else
                strRestart = vbNewLine & vbNewLine & "Please restart Excel for the new language settings to be fully working"
            End If
        Else
            strRestart = ""
            ESKRibbon.Invalidate
        End If
    End If
    
    '#' Aggiorna il ridimensionamento del form
    Call UpdateConfigFile("Scale", IIf(Me.cbxScale.ListIndex < 4, Val(Me.cbxScale.Text), CInt(Me.txtScale)))
    
    
    
    'SOLO VERSIONI NON PORTABLE
    
    If IsPortable = False Then
    
        '#' Aggiorna frequenza controllo aggiornamenti
        Select Case Me.cbxAutocheck.ListIndex
            Case 0
                Call UpdateConfigFile("AutoCheckInterval", 0)
            Case 1
                Call UpdateConfigFile("AutoCheckInterval", 7)
            Case 2
                Call UpdateConfigFile("AutoCheckInterval", 30)
            Case 3
                Call UpdateConfigFile("AutoCheckInterval", 99999)
        End Select
        
        Call UpdateConfigFile("CheckBetaUpdate", Abs(CInt(Me.chkBetaUpdate)))
        
        '#' Aggiorna caricamento impostazioni
        Select Case Me.cbxLoadSettings.ListIndex
            Case 0
                Call UpdateConfigFile("LoadSettings", 0)
            Case 1
                Call UpdateConfigFile("LoadSettings", 1)
        End Select
    
        '#' Aggiorna impostazioni foglio di backup
        Call UpdateConfigFile("DeleteBackup", Abs(CInt(Me.chkDeleteBackup)))
        Call UpdateConfigFile("CreateBackup", Abs(CInt(Me.chkCreateBackup)))
        
        '#' Aggiorna visualizzazione barra di progresso
        Call UpdateConfigFile("DisableProgBar", Abs(CInt(Me.chkDisableProgressBar)))
        
        '#' Aggiorna impostazioni Snapshot
        Call UpdateConfigFile("SnapFolderPath", Me.txtSnapFolder)
        Call UpdateConfigFile("MaxSnapFiles", Me.txtMaxSnap)
        Call UpdateConfigFile("PurgeSnapOnExit", Abs(CInt(Me.chkPurgeSnapOnExit)))
        Call UpdateConfigFile("SilentSnapshot", Abs(CInt(Me.chkSilentSnapshot)))
        
        '#' Aggiorna posizione file impostazioni
        If ThisWorkbook.IsAddin = True Then
            Select Case Me.cbxSettingsLocation.ListIndex
                Case 0 '#' Settings go to APPDATA
                    If CfgPath = Environ("Appdata") & pSep & "Excel Swiss Knife" & pSep Then
                        '#' Already configured for APPDATA, do nothing
                    Else
                        On Error Resume Next
                        SetAttr ThisWorkbook.path & pSep & ".Portable", vbNormal
                        Kill (ThisWorkbook.path & pSep & ".Portable")
                        Call Shell("xcopy """ & ThisWorkbook.path & pSep & "Profile""" & " """ & Left(CfgPath, Len(CfgPath) - 1) & """ /S /C /H /K /R /Y") '#' Copy settings from program dir to appdata
                        On Error GoTo 0 'ErrHandler
                    End If
                Case 1 '#' Settings go to program dir
                    If CfgPath = ThisWorkbook.path & pSep & "Profile" & pSep Then
                        '#' Already configured for Program dir, do nothing
                    Else
                        On Error Resume Next
                        f = FreeFile
                        Open ThisWorkbook.path & pSep & ".Portable" For Output As #f
                        Close #f
                        If Dir(ThisWorkbook.path & pSep & ".Portable") = "" Then '#' The file was not created: no privileges?
                            If lng = 0 Then
                                MsgBox "Attenzione: " & vbNewLine & vbNewLine & "Non hai i privilegi necessari per scrivere sulla cartella del programma (" & ThisWorkbook.path & ").", vbExclamation, "Errore nella modifica dell'impostazione"
                            Else
                                MsgBox "Warning: " & vbNewLine & vbNewLine & "You haven't got the required privileges in order to set " & ThisWorkbook.path & " as the config folder.", vbExclamation, "Error in modifying a setting"
                            End If
                        Else
                            SetAttr ThisWorkbook.path & pSep & ".Portable", vbHidden + vbReadOnly
                            Call Shell("xcopy """ & Environ("Appdata") & pSep & "Excel Swiss Knife""" & " """ & Left(CfgPath, Len(CfgPath) - 1) & """ /S /C /H /K /R /Y") '#' Copy settings from program dir to appdata
                        End If
                        On Error GoTo ErrHandler
                    End If
            End Select
        End If
    End If
    
    Unload Me
    
    If lng = 0 Then
        MsgBox "Impostazioni modificate con successo" & strRestart, vbInformation, "Impostazioni salvate"
    Else
        MsgBox "Settings were modified successfully" & strRestart, vbInformation, "Settings saved"
    End If
    
    oSaved = True
    
    Exit Sub
    
ErrHandler:
    Unload Me
    
    If lng = 0 Then
        MsgBox "C'|fffd| stato un errore nella modifica delle impostazioni. Si prega di riavviare Excel e ritentare", vbExclamation, "Errore nella modifica delle impostazioni"
    Else
        MsgBox "Something went wrong when saving your new settings. Please restart Excel and try again", vbInformation, "Error in saving settings"
    End If
    
End Sub


Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Dim nosave As Long
    
    If CloseMode = VbQueryClose.vbFormControlMenu And oSaved = False Then
        nosave = MsgBox(IIf(lng = 0, "Uscire senza salvare le impostazioni?", "Exit without saving?"), vbYesNo + vbQuestion)
        If nosave <> vbYes Then Cancel = True
    End If
End Sub
Attribute VB_Name = "frmShuffleRange"
Attribute VB_Base = "0{806B5ED0-617D-48D8-A04F-D380E9FA348A}{EB0A4E00-C718-420E-BD21-2C2A9A82AE00}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub optElseWhere_Change()
    Me.refDest.Enabled = Me.optElseWhere
    If Me.optElseWhere = True Then Me.refDest.SetFocus
End Sub
    
Private Sub optInPlace_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
    
Private Sub optElseWhere_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Private Sub cmdOK_Click()
    Dim i As Long
    Dim j As Long
    Dim RndRow As Long
    Dim RndCol As Long
    Dim tempValue As Variant
    Dim TempWs As Worksheet
    Dim DestRng As Range
    Dim RngArray()
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        If .optElseWhere = True Then
        
            If TypeName(Range(Replace(.refDest, ";", ","))) <> "Range" Then
                MsgBox IIf(lng = 0, "Attenzione: intervallo di destinazione non valido. Riprovare", _
                                    "Warning: destination range is not valid. Please try again"), vbExclamation, _
                                    IIf(lng = 0, "Errore: Intervallo di destinazione non valido", "Error: invalid destination range")
                .refDest.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    Call backup_create_new
    
    Set ws = ActiveSheet
        
    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
    Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
    If InRng Is Nothing Then
        MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
            
    Else
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto mescolando i valori... (" & ws.Name & ")"
        Call ShowProgressBar
        
        ReDim RngArray(1 To InRng.Rows.Count, 1 To InRng.Columns.Count)
        RngArray = InRng.Value2
        
        Randomize
        
        If Me.chkFormat Then '#' Mantiene i formati
            Worksheets.Add
            Set TempWs = ActiveSheet
            If Me.optInPlace Then '#' Rimescolamento sul posto
                For i = 1 To InRng.Rows.Count
                    For j = 1 To InRng.Columns.Count
                        '#' Aumenta il contatore
                        counter = counter + 1
                        
                        RndRow = Rnd() * (InRng.Rows.Count - 1) + 1
                        RndCol = Rnd() * (InRng.Columns.Count - 1) + 1
                        InRng(i, j).Copy TempWs.Range("A1")
                        Application.CutCopyMode = False
                        InRng(RndRow, RndCol).Copy InRng(i, j)
                        Application.CutCopyMode = False
                        TempWs.Range("A1").Copy InRng(RndRow, RndCol)
                        Application.CutCopyMode = False
                        
                        '#' Aggiorna la barra di avanzamento
                        Call UpdateProgressBar(counter, countermax)
                        If ProgressAborted = 1 Then GoTo Aborted
                        On Error GoTo Aborted
                    Next j
                Next i
            Else '#' Copia range rimescolato da un'altra parte
                Set DestRng = Range(Me.refDest).reSize(InRng.Rows.Count, InRng.Columns.Count)
                InRng.Copy DestRng
                For i = 1 To InRng.Rows.Count
                    For j = 1 To InRng.Columns.Count
                        '#' Aumenta il contatore
                        counter = counter + 1
                        
                        RndRow = Rnd() * (InRng.Rows.Count - 1) + 1
                        RndCol = Rnd() * (InRng.Columns.Count - 1) + 1
                        DestRng(i, j).Copy TempWs.Range("A1")
                        Application.CutCopyMode = False
                        DestRng(RndRow, RndCol).Copy DestRng(i, j)
                        Application.CutCopyMode = False
                        TempWs.Range("A1").Copy DestRng(RndRow, RndCol)
                        Application.CutCopyMode = False
                        
                        '#' Aggiorna la barra di avanzamento
                        Call UpdateProgressBar(counter, countermax)
                        If ProgressAborted = 1 Then GoTo Aborted
                        On Error GoTo Aborted
                    Next j
                Next i
            End If
            Application.DisplayAlerts = False
            TempWs.Delete
            Application.DisplayAlerts = True
            Set TempWs = Nothing
        Else '#' Non mantiene i formati - usa matrici (pi|fffd| veloce)
            For i = LBound(RngArray, 1) To UBound(RngArray, 1)
                For j = LBound(RngArray, 2) To UBound(RngArray, 2)
                    '#' Aumenta il contatore
                    counter = counter + 1
                    
                    RndRow = Rnd() * (UBound(RngArray, 1) - 1) + 1
                    RndCol = Rnd() * (UBound(RngArray, 2) - 1) + 1
                    tempValue = RngArray(i, j)
                    RngArray(i, j) = RngArray(RndRow, RndCol)
                    RngArray(RndRow, RndCol) = tempValue
                    
                    '#' Aggiorna la barra di avanzamento
                    Call UpdateProgressBar(counter, countermax)
                    If ProgressAborted = 1 Then GoTo Aborted
                    On Error GoTo Aborted
                
                Next j
            Next i
        End If
    End If
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    Call FixArrayStrings(RngArray)
    
    If Not Me.chkFormat Then '#' Copia la matrice sul range di origine o destinazione (solo se non mantiene formati)
        If Me.optInPlace Then
            InRng = RngArray
        Else
            Range(Me.refDest).Cells(1, 1).reSize(InRng.Rows.Count, InRng.Columns.Count) = RngArray
        End If
    End If
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "frmSnapShots"
Attribute VB_Base = "0{09D433E1-3FE7-4F6A-9740-E6C4625212BB}{559561AA-9B37-4DB8-8F1A-DA0F2F097201}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean
Dim HaltExecution As Boolean
Dim snapApp As Excel.Application


Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
    Set btnColl = CommonButtons(Me)
    
    Call RestoreRibbon
    
    Call ListSnapShots
    
    If HaltExecution = False Then
        Call RefreshOpenFiles
    End If
    
    If lng > 0 Then Call TranslateForm(Me)
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub ListSnapShots(Optional wbname As String)
    Dim wb As Workbook
    Dim uR As Long
    Dim i As Long
    Dim noteslen As Double
    Dim cNotesWidth As Double

    'Metto il file attivo in una variabile
    If wbname = "" Then
        Set wb = ActiveWorkbook
    Else
        Set wb = Workbooks(wbname)
    End If
    
    Call AutoCalc(False)
    
    Me.lbxSnapshots.visible = True
    Me.lblNotFound.visible = False
    
    'Esco se non esiste la cartella o il file degli snapshot
    If SnapLogFileExists = False Then
        HaltExecution = True
        Exit Sub
    End If
    
    Me.lbxSnapshots.Clear
    
    With wsSnap
        uR = .Cells(Rows.Count, 1).End(xlUp).Row
        For i = 2 To uR
            If .Cells(i, 1) = wb.FullName Then
                Me.txtListBox.Text = .Cells(i, 5)
                noteslen = Me.txtListBox.Width
                cNotesWidth = CDbl(Val(Split(Me.lbxSnapshots.ColumnWidths, ";")(3)))
                With Me.lbxSnapshots
                    .AddItem wsSnap.Cells(i, 3)
                    .List(.ListCount - 1, 1) = wsSnap.Cells(i, 2)
                    .List(.ListCount - 1, 2) = Round(wsSnap.Cells(i, 4), 2) & " MB"
                    .List(.ListCount - 1, 3) = wsSnap.Cells(i, 5)
                    If noteslen > cNotesWidth Then
                        Me.lbxSnapshots.ColumnWidths = Join(Array(Split(Me.lbxSnapshots.ColumnWidths, ";")(0), _
                                                                  Split(Me.lbxSnapshots.ColumnWidths, ";")(1), _
                                                                  Split(Me.lbxSnapshots.ColumnWidths, ";")(2), _
                                                                  noteslen & " pt"), ";")
                    End If
                End With
            End If
        Next i
    End With
    
    wbSnap.Close False
    
    If Me.lbxSnapshots.ListCount = 0 Then
        With Me.lblNotFound
            .Left = Me.lbxSnapshots.Left
            .Top = Me.lbxSnapshots.Top
            .Height = Me.lbxSnapshots.Height
            .Width = Me.lbxSnapshots.Width
            .visible = True
        End With
        Me.lbxSnapshots.visible = False
    End If
    
    Call AutoCalc(True)
    
End Sub

Private Sub RefreshOpenFiles()
    Dim wb As Workbook
    Dim i As Long
    Dim CurrDestWb As String
    
    DisableEvents = True
    
    CurrDestWb = Me.cbxWorkbook.Value
    
    Me.cbxWorkbook.Clear
       
    For Each wb In Workbooks
        If UCase(wb.Name) <> "PERSONAL.XLSB" Then
            Me.cbxWorkbook.AddItem wb.Name
        End If
    Next wb
    
    For i = 0 To Me.cbxWorkbook.ListCount - 1
        If Me.cbxWorkbook.List(i) = CurrDestWb Then
            Me.cbxWorkbook.Value = CurrDestWb
            Exit For
        End If
    Next i
    
    On Error Resume Next 'Previene un errore generato su sistemi Mac
    If Me.cbxWorkbook <> CurrDestWb Or Me.cbxWorkbook = "" Then Me.cbxWorkbook = ActiveWorkbook.Name
    On Error GoTo 0
    
    DisableEvents = False
    
End Sub

Private Sub lbxSnapshots_Click()
    Dim i As Long
    For i = 0 To Me.lbxSnapshots.ListCount - 1
        If Me.lbxSnapshots.Selected(i) = True Then
            Me.cmdPreview.Enabled = True
            Me.cmdLoadSnap.Enabled = True
            Me.cmdDeleteSnap.Enabled = True
            Exit Sub
        End If
    Next i
    Me.cmdPreview.Enabled = False
    Me.cmdLoadSnap.Enabled = False
    Me.cmdDeleteSnap.Enabled = False
End Sub

Private Sub cbxWorkbook_Change()
    If DisableEvents = False Then
        Call ListSnapShots(Me.cbxWorkbook.Text)
        Call lbxSnapshots_Click
    End If
    
    'Se il foglio selezionato non |fffd| mai stato salvato, non eseguire lo snapshot e visualizza un avviso
    If InStr(1, Workbooks(Me.cbxWorkbook.Text).FullName, pSep) = 0 Then
        MsgBox IIf(lng = 0, "Non |fffd| possibile utilizzare lo strumento snapshot su file che non sono mai stati salvati: riprova dopo aver salvato il file", _
                            "It's not possible to use the snapshots tool on unsaved files: try again after saving the file"), _
                            vbInformation, _
                            IIf(lng = 0, "File non salvato", "Unsaved file")
        Exit Sub
    End If
    
End Sub

Private Sub lbxSnapshots_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdLoadSnap_Click
End Sub

Private Sub cmdDate_Click()
    If Me.lbxSnapshots.ListCount > 0 Then
        If Me.cmdDate.Caption Like "*" & ChrW(8593) Then
            Call SortListCombobox(Me.lbxSnapshots, , 1, 1)
            Me.cmdDate.Caption = Replace(Me.cmdDate.Caption, ChrW(8593), ChrW(8595))
        Else
            Call SortListCombobox(Me.lbxSnapshots, , 0, 1)
            Me.cmdDate.Caption = Replace(Me.cmdDate.Caption, " " & ChrW(8595), "") & " " & ChrW(8593)
        End If
        Me.cmdSize.Caption = IIf(lng = 0, "Dim.", "Size")
        Me.cmdNote.Caption = "Note"
    End If
End Sub
Private Sub cmdDate_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdDate_Click
End Sub

Private Sub cmdSize_Click()
    If Me.lbxSnapshots.ListCount > 0 Then
        If Me.cmdSize.Caption Like "*" & ChrW(8593) Then
            Call SortListCombobox(Me.lbxSnapshots, , 1, 3)
            Me.cmdSize.Caption = Replace(Me.cmdSize.Caption, ChrW(8593), ChrW(8595))
        Else
            Call SortListCombobox(Me.lbxSnapshots, , 0, 3)
            Me.cmdSize.Caption = Replace(Me.cmdSize.Caption, " " & ChrW(8595), "") & " " & ChrW(8593)
        End If
        Me.cmdDate.Caption = IIf(lng = 0, "Data", "Date")
        Me.cmdNote.Caption = "Note"
    End If
End Sub
Private Sub cmdSize_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdSize_Click
End Sub

Private Sub cmdNote_Click()
    If Me.lbxSnapshots.ListCount > 0 Then
        If Me.cmdNote.Caption Like "*" & ChrW(8593) Then
            Call SortListCombobox(Me.lbxSnapshots, , 1, 4)
            Me.cmdNote.Caption = Replace(Me.cmdNote.Caption, ChrW(8593), ChrW(8595))
        Else
            Call SortListCombobox(Me.lbxSnapshots, , 0, 4)
            Me.cmdNote.Caption = Replace(Me.cmdNote.Caption, " " & ChrW(8595), "") & " " & ChrW(8593)
        End If
        Me.cmdSize.Caption = IIf(lng = 0, "Dim.", "Size")
        Me.cmdDate.Caption = IIf(lng = 0, "Data", "Date")
    End If
End Sub
Private Sub cmdNote_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdNote_Click
End Sub

Private Sub cmdPreview_Click()
    Dim i As Long
    Dim wbNew As Workbook
    
    Call AutoCalc(False)
    
    For i = 0 To Me.lbxSnapshots.ListCount - 1
        If Me.lbxSnapshots.Selected(i) = True Then
            If Dir(SnapFolder & Me.lbxSnapshots.List(i, 1)) <> "" Then
                MsgBox IIf(lng = 0, "Il punto di ripristino si aprir|fffd| in modalit|fffd| anteprima: per riportare il file a questa versione, chiudere l'anteprima e premere il pulsante ""Ripristina""", _
                                    "The snapshot will open in preview mode: to restore your workbook back at this state, close the preview window and press ""Restore"" button"), _
                                    vbInformation, _
                                    IIf(lng = 0, "Anteprima snapshot", "Snapshot preview")
                                    
                                    
                If IsWindows = True Then
                    '#' Creo una nuova istanza di Excel e apro il punto di ripristino al suo interno
                    Set snapApp = New Excel.Application
                    With snapApp
                        .AutomationSecurity = msoAutomationSecurityForceDisable 'disabilita le macro
                        Set wbNew = .Workbooks.Open(FileName:=SnapFolder & Me.lbxSnapshots.List(i, 1), UpdateLinks:=False, ReadOnly:=True, Editable:=False)
                        wbNew.Windows(1).visible = True
                        .visible = True
                    End With
                Else
                    Set wbNew = Workbooks.Open(FileName:=SnapFolder & Me.lbxSnapshots.List(i, 1), UpdateLinks:=False, ReadOnly:=True, Editable:=False)
                End If
            Else
                MsgBox IIf(lng = 0, "File del punto di ripristino non trovato", _
                                    "Snapshot file not found"), _
                                    vbCritical
                                    
            End If
            Exit For
        End If
    Next i
    Call AutoCalc(True)
    
End Sub
Private Sub cmdDeleteSnap_Click()
    Dim i As Long
    
    Call AutoCalc(False)
    
    For i = 0 To Me.lbxSnapshots.ListCount - 1
        If Me.lbxSnapshots.Selected(i) = True Then
            Call DeleteSnapshot(Me.lbxSnapshots.List(i, 1), Me.lbxSnapshots.List(i, 3))
            Exit For
        End If
    Next i
        
    Call ListSnapShots(Me.cbxWorkbook.Text)
    
    Call AutoCalc(True)
    
End Sub

Private Sub cmdLoadSnap_Click()
    Dim i As Long
    
    Call AutoCalc(False)
    
    For i = 0 To Me.lbxSnapshots.ListCount - 1
        If Me.lbxSnapshots.Selected(i) = True Then
            Me.Hide
            Call LoadSnapshot(Me.cbxWorkbook.Text, Me.lbxSnapshots.List(i, 1))
            Exit For
        End If
    Next i
    
    Call AutoCalc(True)
    
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
    On Error Resume Next
    snapApp.Quit
    On Error GoTo 0
    Set snapApp = Nothing
End Sub


Attribute VB_Name = "frmSnapShotsManager"
Attribute VB_Base = "0{B45C0BC9-ECF1-447A-A95D-DD0FBC0EBFD1}{87F70DED-3796-4D17-AA76-CCB0C4FBFFED}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim HaltExecution As Boolean
Dim snapApp As Excel.Application

Private Sub UserForm_Initialize()
    
    Call RestoreRibbon
    
    Call ListSnapShots
    
    If HaltExecution = False Then
        If lng > 0 Then Call TranslateForm(Me)
        Call ScaleForm(Me)
        Set btnColl = CommonButtons(Me)
    End If
    
End Sub

Private Sub ListSnapShots()
    Dim strFile As String
    Dim leftStr As Long
    Dim uR As Long
    Dim i As Long
    Dim noteslen As Double
    Dim cNotesWidth As Double
    Dim WarningNotFound As String
    Dim strNote As String

    Call AutoCalc(False)
    
    WarningNotFound = IIf(lng = 0, "(ATTENZIONE: Percorso inesistente!) ", "(WARNING: Path not found!) ")
    
    Me.lbxSnapshots.visible = True
    Me.lblNotFound.visible = False
    
    'Esco se non esiste la cartella o il file degli snapshot
    If SnapLogFileExists = False Then
        HaltExecution = True
        Exit Sub
    End If
    
    Me.lbxSnapshots.Clear
    
    With wsSnap
        uR = .Cells(Rows.Count, 1).End(xlUp).Row
        For i = 2 To uR
            strFile = .Cells(i, 1)
            strNote = .Cells(i, 5)
            cNotesWidth = CDbl(Val(Split(Me.lbxSnapshots.ColumnWidths, ";")(4)))
            With Me.lbxSnapshots
                
                'Verifico che il file esista, e in caso contrario aggiuno un warning alle note
                If Dir(strFile) = "" Then
                    On Error Resume Next
                    If InStr(1, strNote, WarningNotFound) = 0 Then
                        strNote = WarningNotFound & strNote
                    End If
                    On Error GoTo 0
                End If
                Me.txtListBox.Text = strNote
                noteslen = Me.txtListBox.Width
                
                If Len(wsSnap.Cells(i, 1)) > 50 Then
                    leftStr = Application.WorksheetFunction.Max(3, 47 - Len(Right(strFile, Len(strFile) - InStrRev(strFile, pSep) + 1)))
                    strFile = Left(strFile, leftStr) & "..." & Right(strFile, Len(strFile) - InStrRev(strFile, pSep) + 1)
                End If
                .AddItem strFile
                .List(.ListCount - 1, 1) = wsSnap.Cells(i, 3)
                .List(.ListCount - 1, 2) = wsSnap.Cells(i, 2)
                .List(.ListCount - 1, 3) = Round(wsSnap.Cells(i, 4), 2) & " MB"
                .List(.ListCount - 1, 4) = strNote
                .List(.ListCount - 1, 5) = wsSnap.Cells(i, 1)
                If noteslen > cNotesWidth Then
                    Me.lbxSnapshots.ColumnWidths = Join(Array(Split(Me.lbxSnapshots.ColumnWidths, ";")(0), _
                                                              Split(Me.lbxSnapshots.ColumnWidths, ";")(1), _
                                                              Split(Me.lbxSnapshots.ColumnWidths, ";")(2), _
                                                              Split(Me.lbxSnapshots.ColumnWidths, ";")(3), _
                                                              noteslen & " pt", _
                                                              Split(Me.lbxSnapshots.ColumnWidths, ";")(5)), _
                                                              ";")
                End If
            End With
        Next i
    End With
    
    wbSnap.Close False
    
    If Me.lbxSnapshots.ListCount = 0 Then
        With Me.lblNotFound
            .Left = Me.lbxSnapshots.Left
            .Top = Me.lbxSnapshots.Top
            .Height = Me.lbxSnapshots.Height
            .Width = Me.lbxSnapshots.Width
            .visible = True
        End With
        Me.lbxSnapshots.visible = False
    Else
        Call cmdPath_Click
    End If
    
    Call AutoCalc(True)
    
End Sub

Private Sub lbxSnapshots_Change()
    
    Select Case CountListBox(Me.lbxSnapshots)
        Case 0
            Me.cmdPreview.Enabled = False
            Me.cmdDeleteSnap.Enabled = False
        Case 1
            Me.cmdPreview.Enabled = True
            Me.cmdDeleteSnap.Enabled = True
        Case Else
            Me.cmdPreview.Enabled = False
            Me.cmdDeleteSnap.Enabled = True
    End Select
End Sub

Private Sub cmdPath_Click()
    If Me.lbxSnapshots.ListCount > 0 Then
        If Me.cmdPath.Caption Like "*" & ChrW(8593) Then
            Call SortListCombobox(Me.lbxSnapshots, , 1, 1)
            Me.cmdPath.Caption = Replace(Me.cmdPath.Caption, ChrW(8593), ChrW(8595))
        Else
            Call SortListCombobox(Me.lbxSnapshots, , 0, 1)
            Me.cmdPath.Caption = Replace(Me.cmdPath.Caption, " " & ChrW(8595), "") & " " & ChrW(8593)
        End If
        Me.cmdDate.Caption = IIf(lng = 0, "Data", "Date")
        Me.cmdSize.Caption = IIf(lng = 0, "Dim.", "Size")
        Me.cmdNote.Caption = "Note"
    End If
'    Me.lbxSnapshots.Height = 244 * (GetSettings("Scale") / 100) * tmpScale
End Sub
Private Sub cmdPath_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdPath_Click
End Sub

Private Sub cmdDate_Click()
    If Me.lbxSnapshots.ListCount > 0 Then
        If Me.cmdDate.Caption Like "*" & ChrW(8593) Then
            Call SortListCombobox(Me.lbxSnapshots, 3, 1, 2)
            Me.cmdDate.Caption = Replace(Me.cmdDate.Caption, ChrW(8593), ChrW(8595))
        Else
            Call SortListCombobox(Me.lbxSnapshots, 3, 0, 2)
            Me.cmdDate.Caption = Replace(Me.cmdDate.Caption, " " & ChrW(8595), "") & " " & ChrW(8593)
        End If
        Me.cmdSize.Caption = IIf(lng = 0, "Dim.", "Size")
        Me.cmdNote.Caption = "Note"
        Me.cmdPath.Caption = IIf(lng = 0, "Percorso file", "File Path")
    End If
'    Me.lbxSnapshots.Height = 244 * (GetSettings("Scale") / 100) * tmpScale
End Sub
Private Sub cmdDate_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdDate_Click
End Sub

Private Sub cmdSize_Click()
    If Me.lbxSnapshots.ListCount > 0 Then
        If Me.cmdSize.Caption Like "*" & ChrW(8593) Then
            Call SortListCombobox(Me.lbxSnapshots, , 1, 4)
            Me.cmdSize.Caption = Replace(Me.cmdSize.Caption, ChrW(8593), ChrW(8595))
        Else
            Call SortListCombobox(Me.lbxSnapshots, , 0, 4)
            Me.cmdSize.Caption = Replace(Me.cmdSize.Caption, " " & ChrW(8595), "") & " " & ChrW(8593)
        End If
        Me.cmdDate.Caption = IIf(lng = 0, "Data", "Date")
        Me.cmdNote.Caption = "Note"
        Me.cmdPath.Caption = IIf(lng = 0, "Percorso file", "File Path")
    End If
'    Me.lbxSnapshots.Height = 244 * (GetSettings("Scale") / 100) * tmpScale
End Sub
Private Sub cmdSize_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdSize_Click
End Sub

Private Sub cmdNote_Click()
    If Me.lbxSnapshots.ListCount > 0 Then
        If Me.cmdNote.Caption Like "*" & ChrW(8593) Then
            Call SortListCombobox(Me.lbxSnapshots, , 1, 5)
            Me.cmdNote.Caption = Replace(Me.cmdNote.Caption, ChrW(8593), ChrW(8595))
        Else
            Call SortListCombobox(Me.lbxSnapshots, , 0, 5)
            Me.cmdNote.Caption = Replace(Me.cmdNote.Caption, " " & ChrW(8595), "") & " " & ChrW(8593)
        End If
        Me.cmdSize.Caption = IIf(lng = 0, "Dim.", "Size")
        Me.cmdDate.Caption = IIf(lng = 0, "Data", "Date")
        Me.cmdPath.Caption = IIf(lng = 0, "Percorso file", "File Path")
    End If
'    Me.lbxSnapshots.Height = 244 * (GetSettings("Scale") / 100) * tmpScale
End Sub
Private Sub cmdNote_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdNote_Click
End Sub

Private Sub cmdPreview_Click()
    Dim i As Long
    Dim wbNew As Workbook
    
    Call AutoCalc(False)
    
    For i = 0 To Me.lbxSnapshots.ListCount - 1
        If Me.lbxSnapshots.Selected(i) = True Then
            If Dir(SnapFolder & Me.lbxSnapshots.List(i, 2)) <> "" Then
                MsgBox IIf(lng = 0, "Il punto di ripristino si aprir|fffd| in modalit|fffd| anteprima: per riportare il file a questa versione, chiudere l'anteprima e premere il pulsante ""Ripristina""", _
                                    "The snapshot will open in preview mode: to restore your workbook back at this state, close the preview window and press ""Restore"" button"), _
                                    vbInformation, _
                                    IIf(lng = 0, "Anteprima snapshot", "Snapshot preview")
                                    
                                    
                If IsWindows = True Then
                    '#' Creo una nuova istanza di Excel e apro il punto di ripristino al suo interno
                    Set snapApp = New Excel.Application
                    With snapApp
                        .AutomationSecurity = msoAutomationSecurityForceDisable 'disabilita le macro
                        Set wbNew = .Workbooks.Open(FileName:=SnapFolder & Me.lbxSnapshots.List(i, 2), UpdateLinks:=False, ReadOnly:=True, Editable:=False)
                        wbNew.Windows(1).visible = True
                        .visible = True
                    End With
                Else
                    Set wbNew = Workbooks.Open(FileName:=SnapFolder & Me.lbxSnapshots.List(i, 2), UpdateLinks:=False, ReadOnly:=True, Editable:=False)
                End If
            Else
                MsgBox IIf(lng = 0, "File del punto di ripristino non trovato", _
                                    "Snapshot file not found"), _
                                    vbCritical
                                    
            End If
            Exit For
        End If
    Next i
    Call AutoCalc(True)
    
End Sub
Private Sub cmdDeleteSnap_Click()
    Dim i As Long
    Dim ans As Long
    
    ans = MsgBox(IIf(lng = 0, "Eliminare " & CountListBox(Me.lbxSnapshots) & " snapshot selezionati?" & vbNewLine & _
                              "N.B: Non sar|fffd| pi|fffd| possibile recuperarli", _
                              "Delete selected snapshots?"), _
                              vbYesNo + vbExclamation, _
                              IIf(lng = 0, "Conferma eliminazione", "Confirm deletion"))
    If ans = vbYes Then
        Call AutoCalc(False)
        
        For i = 0 To Me.lbxSnapshots.ListCount - 1
            If Me.lbxSnapshots.Selected(i) = True Then
                Call DeleteSnapshot(Me.lbxSnapshots.List(i, 2), Me.lbxSnapshots.List(i, 4), True)
            End If
        Next i
            
'        Call PurgeSnapshots
'
        Call ListSnapShots
        
        Call AutoCalc(True)
    
        MsgBox IIf(lng = 0, "Eliminazione completata", "Deletion complete"), vbInformation
    End If
    
End Sub

Private Sub chkAllNone_Change()
    Dim i As Long
    
    For i = 0 To Me.lbxSnapshots.ListCount - 1
        Me.lbxSnapshots.Selected(i) = Me.chkAllNone
    Next i
    
    If Me.chkAllNone = True Then
        Me.chkNonexistent = True
    End If
    
End Sub

Private Sub chkNonExistent_Change()
    Dim i As Long
    
    For i = 0 To Me.lbxSnapshots.ListCount - 1
        If InStr(1, Me.lbxSnapshots.List(i, 4), IIf(lng = 0, "(ATTENZIONE: Percorso inesistente!) ", "(WARNING: Path not found!) ")) > 0 Then
            Me.lbxSnapshots.Selected(i) = Me.chkNonexistent
        End If
    Next i
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
    On Error Resume Next
    snapApp.Quit
    On Error GoTo 0
    Set snapApp = Nothing
End Sub


Attribute VB_Name = "frmSplitCol"
Attribute VB_Base = "0{15209596-B3B0-40F9-8DE1-FD0F2FB4FD98}{C0F1D5FB-867A-45BA-B5A5-33EC7CD5BA6C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    
    On Error Resume Next
    Me.refRange = Selection.address
    On Error GoTo 0
    
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkInsertCols_Change()
    If Me.chkInsertCols Then
        Me.chkOverwrite.Enabled = False
        Me.chkOverwrite = False
    Else
        Me.chkOverwrite.Enabled = True
    End If
End Sub
Private Sub cmdAddDelim_Click()
    Dim i As Long
    Dim check As Long
    
    With Me
    
        check = 0
        
        If .txtDelim = "" Then
            MsgBox IIf(lng = 0, "La stringa di separazione del testo non pu|fffd| essere vuota", "Delimiter can't be an empty string"), vbExclamation
            check = 1
        Else
            For i = 0 To .lbxDelimList.ListCount - 1
                If .lbxDelimList.List(i) = .txtDelim Then
                    MsgBox IIf(lng = 0, "Sostituzione gi|fffd| impostata", "Replacement already exists"), vbExclamation
                    check = 1
                    Exit For
                End If
            Next i
        End If
        
        If check = 0 Then
            .lbxDelimList.AddItem Replace(.txtDelim, " ", "{sp}")
            Call SortListCombobox(Me.lbxDelimList, 1, 1)
        End If
        
        .txtDelim = ""
        .txtDelim.SetFocus
        
    End With
    
    Call GoodToGo(Me)
    
End Sub

Private Sub cmdDelDelim_Click()
    Dim i As Long

    With Me.lbxDelimList
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                .RemoveItem (i)
            End If
        Next i
    End With
    
    Call GoodToGo(Me)
    
End Sub
Private Sub cmdEmptyList_Click()

    With Me.lbxDelimList
        .Clear
    End With
    Me.cmdOK.Enabled = False
    
End Sub

Private Sub cmdNewLine_Click()
    Me.txtDelim = Me.txtDelim & "{CR}"
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim InRng As Range
    Dim UserDelims() As String
    Dim newcell As Variant
    Dim origcell As Variant
    Dim DefaultDelims() As String
    Dim WrongDelim As Boolean
    Dim okDelim As String
    Dim SplitArr() As String
    Dim off As Long
    Dim AddCols As Long
    Dim d As Long
    Dim i As Long
    Dim n As Long
    Dim s As Long
    Dim MatchPrefix As Variant
    Dim StartPos As Long
    Dim oValue As Long
    
    With Me
        On Error Resume Next
        
        Set InRng = RangeResize(Range(Replace(.refRange, ";", ",")), ActiveSheet)
        If InRng Is Nothing Or _
           TypeName(InRng) <> "Range" Or _
           InRng.Columns.Count > 1 Then
                MsgBox "Attenzione: intervallo non valido. Selezionare una sola colonna di valori. Riprovare", vbExclamation, "Intervallo non valido"
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
        End If
        
        On Error GoTo Aborted
        
        .Hide
        
        'Popolo l'array dei delimitatori di default
        DefaultDelims() = Split(Chr(1) & ";" & Chr(2) & ";" & Chr(3) & ";" & Chr(4), ";")
        
        'Popolo l'array dei delimitatori definiti dall'utente
        ReDim UserDelims(0 To .lbxDelimList.ListCount - 1)
        For i = 0 To .lbxDelimList.ListCount - 1
            UserDelims(i) = Replace(Replace(.lbxDelimList.List(i), "{CR}", Chr(10)), "{sp}", " ")
        Next i
        
        'fisso a 1 il valore di oValue se |fffd| da mantenere la cella originale
        If Me.chkOriginal = True Then oValue = 1
        
    End With
    
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new
    
    On Error GoTo Aborted
    
    Set ws = ActiveSheet

    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = InRng.Cells.CountLarge
    UProgress.SetDescription "Divisione in colonne in corso... (" & ws.Name & ")"
    Call ShowProgressBar
    
    'Loop per trovare delimitatore di default non presente nelle celle
    For d = 0 To UBound(DefaultDelims)
        WrongDelim = False
        For Each cell In InRng.Cells
            If InStr(1, cell, DefaultDelims(d)) Then
                WrongDelim = True
                Exit For
            End If
        Next cell
        If WrongDelim = False Then
            okDelim = DefaultDelims(d) '<== Questo |fffd| il delimitatore sostitutivo
            Exit For
        End If
    Next d
        
    'Se non |fffd| stato possibile trovare nessun delimitatore...
    If okDelim = "" Then
        MsgBox "Non |fffd| stato possibile individuare un delimitatore unico adatto, la procedura sar|fffd| terminata", vbExclamation, "Delimitatore unico non trovato"
        GoTo Aborted
    End If
    
    'Loop per individuare il numero di colonne da inserire (AddCols)
    If Me.chkInsertCols = True Then
        AddCols = 0
        For Each cell In InRng.Cells
            If Not IsError(cell) Then
                newcell = cell.Value
                'Sostituisci delimitatore/i con carattere singolo (okDelim)
                For i = 0 To UBound(UserDelims)
                    newcell = Replace(newcell, UserDelims(i), okDelim)
                Next i
            
                If UBound(Split(newcell, okDelim)) + 1 > AddCols Then AddCols = UBound(Split(newcell, okDelim)) + 1
            End If
        Next cell
    End If
            
    'Inserisci il numero di colonne individuato
    If AddCols > 0 And Me.chkInsertCols = True Then
        InRng.Cells(1, 2).reSize(1, AddCols).EntireColumn.Insert
    End If
            
    'Loop di splittaggio delle celle
        For Each cell In InRng.Cells
    
        '#' Aumento di 1 il contatore
        counter = counter + 1
        
        If Not IsError(cell) Then
            
            'Prima parte: come se i delimitatori fossero sempre da cancellare
                newcell = cell.Value
                origcell = cell.Value
                
                'Sostituisci delimitatore/i con carattere singolo (okDelim)
                For i = 0 To UBound(UserDelims)
                    newcell = Replace(newcell, UserDelims(i), okDelim)
                Next i
            
                SplitArr() = Split(newcell, okDelim)
                If Me.chkOriginal = True Then off = 1 Else off = 0 'Imposta offset a 1 se |fffd| selezionata "mantieni colonna originale"
                
                If Me.chkOverwrite Then
                    For i = 0 To UBound(SplitArr)
                        cell.Offset(0, off) = SplitArr(i)
                        off = off + 1
                    Next i
                Else
                    For i = 0 To UBound(SplitArr)
                        If cell.Offset(0, off) = "" Or off = 0 Then
                            cell.Offset(0, off) = SplitArr(i)
                        End If
                        off = off + 1
                    Next i
                End If
            'Fine prima parte
                
            'Inizio routine per conservazione delimitatori
            If Me.chkDelete = False Then
                StartPos = 1
                For n = 0 To off
                    For s = 0 To UBound(UserDelims)
                        MatchPrefix = ""
                        On Error Resume Next
                        MatchPrefix = Mid(origcell, StartPos, Len(UserDelims(s)))
                        If MatchPrefix = UserDelims(s) Then
                            If n = 0 Then
                                cell.Offset(0, oValue) = ""
                            Else
                                cell.Offset(0, n + oValue) = UserDelims(s) & cell.Offset(0, n + oValue)
                            End If
                        End If
                        On Error GoTo Aborted
                    Next s
                    StartPos = StartPos + Len(cell.Offset(0, n + oValue))
                Next n
            End If
        
        End If
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
        
    Next cell
    'Fine loop splittaggio celle
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub
Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)


    Call Cleanup
End Sub

Attribute VB_Name = "frmSplitSheet"
Attribute VB_Base = "0{499FA4F8-F648-4178-A3E5-ED2DCCDB7B8F}{761ECBCF-445E-4CEF-A6A5-945418BB6F2F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Me.Width = Me.Width - 194 'La larghezza dell'elenco colonne
        
    On Error Resume Next
    If Selection.Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
    Else
        Me.refRange = Selection.address
    End If
    Range(Me.refRange).Select
    On Error GoTo 0
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    Me.txtFilterList = ""
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
    Call ListColumns(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
    Call ListColumns(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
End Sub

Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
    Call ListFilterValues(False)
End Sub

Private Sub optNStep_Change()
    Me.txtNStep.Enabled = Me.optNStep
    Me.spbNStep.Enabled = Me.optNStep
    Me.cbxFilterCol.Enabled = Not Me.optNStep
    Me.chkDelete.Enabled = Not Me.optNStep
    If Me.optNStep = True Then Me.chkFilterValues = False
    Me.chkFilterValues.Enabled = Not Me.optNStep
    Me.optRename.Enabled = Not Me.optNStep
    Me.optOverwrite.Enabled = Not Me.optNStep
End Sub

Private Sub spbNStep_SpinDown()
    Me.txtNStep = Me.spbNStep
End Sub

Private Sub spbNStep_SpinUp()
    Me.txtNStep = Me.spbNStep
End Sub

Private Sub txtNStep_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNStep_Change()
    If Val(Me.txtNStep) > Me.spbNStep.Max Then Me.txtNStep = Me.spbNStep.Max
    If Val(Me.txtNStep) < Me.spbNStep.Min Then Me.txtNStep = Me.spbNStep.Min
    Me.spbNStep = Me.txtNStep
End Sub

Private Sub chkFilterValues_Change()
    Me.Width = Me.Width + (IIf(Me.chkFilterValues = True, 1, -1) * 194)
    Me.lblFilterValues.visible = Me.chkFilterValues
    Me.lbxFilterValues.visible = Me.chkFilterValues
    Me.chkAllNone.visible = Me.chkFilterValues
End Sub

Private Sub cbxFilterCol_Change()
    Me.cbxFilterCol.ControlTipText = Me.cbxFilterCol.Text
    Call ListFilterValues
End Sub

Private Sub optByColumns_Change()
    Dim ctl As control
    
    If Me.optByColumns = True Then
        Call ListRows(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
        
        For Each ctl In Me.Controls
            Select Case ctl.Name
                Case "optNStep", "lblHeader"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Riga", "Colonna"), "Righe", "Colonne"), "riga", "colonna"), "righe", "colonne"), "Row", "Column"), "row", "column")
                Case "optFilterCol", "chkDelete"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Colonna", "Riga"), "Colonne", "Righe"), "colonna", "riga"), "colonne", "righe"), "Column", "Row"), "column", "row")
            End Select
        Next ctl
    Else
        Call ListColumns(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
        
        For Each ctl In Me.fraSplit.Controls
            Select Case ctl.Name
                Case "optNStep", "lblHeader"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Colonna", "Riga"), "Colonne", "Righe"), "colonna", "riga"), "colonne", "righe"), "Column", "Row"), "column", "row")
                Case "optFilterCol", "chkDelete"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Riga", "Colonna"), "Righe", "Colonne"), "riga", "colonna"), "righe", "colonne"), "Row", "Column"), "row", "column")
            End Select
        Next ctl
    End If

End Sub

Private Sub ListFilterValues(Optional clearvalues As Boolean = True)
    Dim i As Long
    Dim FilterCol As Long
    Dim FilterRow As Long
    Dim SplitColl As New Collection
    Dim selValues
    Dim arr As Variant
    Dim m As Long
    
    
    If clearvalues = False And Me.lbxFilterValues.ListCount > 0 Then
        'Costruisco l'array dei valori precedentemente selezionati
        ReDim selValues(0 To Me.lbxFilterValues.ListCount - 1, 0 To 1)
        For i = 0 To UBound(selValues, 1)
            selValues(i, 0) = Me.lbxFilterValues.List(i)
            selValues(i, 1) = Me.lbxFilterValues.Selected(i)
        Next i
    End If
    Me.lbxFilterValues.Clear
    
    On Error Resume Next
    
    Set InRng = Range(Me.refRange)
    If InRng Is Nothing Then Exit Sub
    If InRng.Cells.Count = 1 Then
        arr = InRng.reSize(1, 2)
        ReDim Preserve arr(1 To 1, 1 To 1)
    Else
        arr = InRng
    End If
    
    If Me.optByRows = True Then
    
        FilterCol = ColItemToNumber(Me.cbxFilterCol.Text)
        
        For i = 1 + Me.txtHeader To UBound(arr, 1)
            On Error Resume Next
            If InRng.Rows(i).RowHeight > 0 And UCase(arr(i, FilterCol - InRng.Column + 1)) Like "*" & UCase(Me.txtFilterList) & "*" Then
                SplitColl.Add arr(i, FilterCol - InRng.Column + 1), CStr(arr(i, FilterCol - InRng.Column + 1))
            End If
            On Error GoTo 0
        Next i
        
        On Error Resume Next
        Me.lbxFilterValues.List = CollToArray(SplitColl)
        On Error GoTo 0
        Set SplitColl = Nothing
        
        'Ordina lista A-Z
        Call SortListCombobox(Me.lbxFilterValues)
        
        'Se ho cambiato colonna seleziona tutti, se ho solo variato le righe di intestazione, mantieni selezione precedente
        If clearvalues = True Then
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                Me.lbxFilterValues.Selected(i) = True
            Next i
        ElseIf IsArray(selValues) Then
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                For m = 0 To UBound(selValues, 1)
                    If Me.lbxFilterValues.List(i) = selValues(m, 0) Then
                        Me.lbxFilterValues.Selected(i) = selValues(m, 1)
                        Exit For
                    End If
                Next m
            Next i
        End If
        
    Else
    
        FilterRow = RowItemToNumber(Me.cbxFilterCol.Text)
        
        For i = 1 + Me.txtHeader To InRng.Rows(FilterRow).Cells.Count
            On Error Resume Next
            If InRng.Rows(FilterRow - InRng.Row + 1).Cells(i).ColumnWidth > 0 Then SplitColl.Add InRng.Rows(FilterRow - InRng.Row + 1).Cells(i).Value, CStr(InRng.Rows(FilterRow - InRng.Row + 1).Cells(i).Value)
            On Error GoTo 0
        Next i
        
        For i = 1 To SplitColl.Count
            Me.lbxFilterValues.AddItem CStr(SplitColl(i))
        Next i
        Set SplitColl = Nothing
        
        'Ordina lista A-Z
        Call SortListCombobox(Me.lbxFilterValues)
        
        'Se ho cambiato colonna seleziona tutti, se ho solo variato le righe di intestazione, mantieni selezione precedente
        If clearvalues = True Then
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                Me.lbxFilterValues.Selected(i) = True
            Next i
        Else
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                For m = 0 To UBound(selValues, 1)
                    If Me.lbxFilterValues.List(i) = selValues(m, 0) Then
                        Me.lbxFilterValues.Selected(i) = selValues(m, 1)
                        Exit For
                    End If
                Next m
            Next i
        End If
    
    End If
    
    On Error GoTo 0
    
End Sub

Private Sub txtFilterList_Change()
    Call ListFilterValues
End Sub

Private Sub chkAllNone_Click()
    Dim i As Long
    
    For i = 0 To Me.lbxFilterValues.ListCount - 1
        Me.lbxFilterValues.Selected(i) = Me.chkAllNone
    Next i
End Sub

Private Sub optA1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optSamePosition_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim SrcWs As Worksheet
    Dim FilterCol As Long
    Dim FilterRow As Long
    Dim FilterRowRng As Range
    Dim CopyRng As Range
    Dim head As Long
    Dim SplitColl As New Collection
    Dim Item As Variant
    Dim cCount As Long
    Dim wsNew As Worksheet
    Dim wsNewFCell As Range
    Dim ErrNum As Long
    Dim i As Long
    Dim j As Long
    Dim corr As Long
    Dim cDelete As Long
    Dim cSucc As Long
    Dim strSucc As String, strErr As String
    
    On Error Resume Next
    With Me
        If TypeName(Range(.refRange)) <> "Range" And Not Me.chkWholeSheet Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        .Hide
        
        Set InRng = Range(.refRange)
    
    End With
    
    On Error GoTo Aborted
    
    Set SrcWs = InRng.Parent
    
    If ActiveWorkbook.ProtectStructure = True Or InRng.Parent.ProtectContents = True Then
        If lng = 0 Then
            MsgBox "Spiacente, la procedura non pu|fffd| funzionare se il foglio o la cartella di lavoro sono protetti", vbOKOnly + vbExclamation, "Foglio o cartella di lavoro protetti"
        Else
            MsgBox "Sorry, not working when the workbook or worksheet is protected", vbOKOnly + vbExclamation, "Worksheet or Workbook protected"
        End If
        Exit Sub
    End If
    
    If Me.optByRows = True Then
        FilterCol = Range(Replace(Mid(Me.cbxFilterCol, 1, InStr(1, Me.cbxFilterCol, "(") - 1) & "1", " ", "")).Column - InRng.Column + 1
        For i = 1 To FilterCol - 1
            If InRng.Columns(i).Width = 0 Then corr = corr + 1
        Next i
        cDelete = FilterCol - corr 'indice della colonna da eliminare nei fogli splittati
    Else
        FilterRow = Range("A" & Replace(Mid(Me.cbxFilterCol, 1, InStr(1, Me.cbxFilterCol, "(") - 1), " ", "")).Row - InRng.Row + 1
        For i = 1 To FilterRow - 1
            If InRng.Rows(i).Height = 0 Then corr = corr + 1
        Next i
        cDelete = FilterRow - corr 'indice della riga da eliminare nei fogli splittati
    End If
    
    On Error Resume Next
    If Me.optByRows = True Then InRng.Cells(1, FilterCol).UnMerge
    On Error GoTo Aborted
    
    
    'Turn off AutoFilter
    InRng.Parent.AutoFilterMode = False

    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    head = Application.WorksheetFunction.Max(1, Me.txtHeader)
                        
    
    If Me.optByRows = True Then
    
        '############################
        '####### OGNI N RIGHE #######
        '############################
        
        If Me.optNStep Then
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = Application.WorksheetFunction.RoundUp((InRng.Rows.Count - Me.txtHeader) / Me.txtNStep, 0)
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
            
            For i = 1 To countermax
                
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                'Add a new worksheet
                Set wsNew = Worksheets.Add(After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count))
                On Error Resume Next
                wsNew.Name = Left(SrcWs.Name, 26) & "_" & Format(i, "000")
                If Err.Number <> 0 Then
                    ErrNum = ErrNum + 1
                    wsNew.Name = "Error_" & Format(ErrNum, "0000")
                    Err.Clear
                End If
                On Error GoTo Aborted
                
                Set wsNewFCell = wsNew.Range("A1")
                If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                    
                'Copy headers to new worksheet
                If Me.txtHeader > 0 Then
                    InRng.Rows("1:" & Me.txtHeader).SpecialCells(xlCellTypeVisible).Copy
                    
                    With wsNewFCell
                        .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                        
                        If Me.chkValues Then
                            .PasteSpecial xlPasteValues
                        Else
                            .PasteSpecial xlPasteFormulas
                        End If
                        
                        If Me.chkFormats Then
                            .PasteSpecial xlPasteFormats
                        End If
                        
                        Application.CutCopyMode = False
                    End With
                End If
                            
                'Copy data to new worksheet
                InRng.Rows(Me.txtHeader + ((i - 1) * Me.txtNStep) + 1 & ":" & Application.WorksheetFunction.Min(Me.txtHeader + (i * Me.txtNStep), InRng.Rows.Count)).SpecialCells(xlCellTypeVisible).Copy
                With wsNewFCell.Offset(Me.txtHeader, 0)
                    .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                    
                    If Me.chkValues Then
                        .PasteSpecial xlPasteValues
                    Else
                        .PasteSpecial xlPasteFormulas
                    End If
                    
                    If Me.chkFormats Then
                        .PasteSpecial xlPasteFormats
                    End If
                    
                    wsNew.Activate
                    wsNewFCell.Select
                    
                    Application.CutCopyMode = False
                End With
                
                cSucc = cSucc + 1
                            
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next i
        Else
    
        '################################################
        '####### SECONDO IL VALORE DI UNA COLONNA #######
        '################################################
        
            '#' Nuova versione con collection
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                If Me.lbxFilterValues.Selected(i) = True Or Me.chkFilterValues = False Then
                    SplitColl.Add Me.lbxFilterValues.List(i), CStr(Me.lbxFilterValues.List(i))
                End If
            Next i
            
            
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = SplitColl.Count
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
                
            For Each Item In SplitColl
            
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                'Filter the range
                InRng.Offset(head - 1).reSize(InRng.Rows.Count - head + 1).AutoFilter Field:=FilterCol, Criteria1:="=" & _
                 Replace(Replace(Replace(Item, "~", "~~"), "*", "~*"), "?", "~?")
                
                'Caso particolare: header = 0 (nascondo la prima riga se non |fffd| uguale al filtro)
                If Me.txtHeader = 0 Then
                    If Not InRng(1, FilterCol - InRng.Column + 1) = Replace(Replace(Replace(Item, "~", "~~"), "*", "~*"), "?", "~?") Then
                        InRng.Rows(1).EntireRow.Hidden = True
                    End If
                End If
                
                'Check if there are no more then 8192 areas(limit of areas)
                cCount = 0
                On Error Resume Next
                cCount = InRng.Columns(1).SpecialCells(xlCellTypeVisible) _
                         .Areas(1).Cells.Count
                On Error GoTo Aborted
                If cCount = 0 Then
                    MsgBox "There are more than 8192 areas for the value : " & cell.Value _
                         & vbNewLine & "It is not possible to copy the visible data." _
                         & vbNewLine & "Tip: Sort your data before you use this macro.", _
                           vbOKOnly, "Numero eccessivo di aree"
                Else
                    'Add a new worksheet
                    
                    'Elimino l'eventuale foglio preesistente con lo stesso nome
                    If Me.optOverwrite = True Then
                        On Error Resume Next
                        Application.DisplayAlerts = False
                        If Item = "" Then
                            Worksheets("{Empty}").Delete
                        Else
                            Worksheets(Left(CleanString(CStr(Item), "_", "sheet"), 31)).Delete
                        End If
                        Application.DisplayAlerts = True
                        On Error GoTo Aborted
                    End If
                    
                    Set wsNew = Worksheets.Add(After:=Sheets(Sheets.Count))
                    On Error Resume Next
                    'Rinomina il foglio con il valore della cella (primi 31 caratteri), togliendo i caratteri non validi.
                    'Se comunque genera errore rinomina come 'Error' con numero progressivo
                    If Item = "" Then
                        wsNew.Name = "{Empty}"
                    Else
                        wsNew.Name = Left(CleanString(CStr(Item), "_", "sheet"), 31)
                        If Err.Number > 0 Then
                            ErrNum = ErrNum + 1
                            wsNew.Name = "Error_" & Format(ErrNum, "0000")
                            Err.Clear
                        End If
                    End If
                    On Error GoTo Aborted
    
    
                    'Copy the visible data to the new worksheet
                    InRng.SpecialCells(xlCellTypeVisible).Copy
                    
                    'Se avevo nascosto la prima riga, la rendo di nuovo visibile
                    If InRng.Rows(1).EntireRow.Hidden = True Then InRng.Rows(1).EntireRow.Hidden = False
                    
                    Set wsNewFCell = wsNew.Range("A1")
                    If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                    
                    With wsNewFCell
                        .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                        
                        If Me.chkValues Then
                            .PasteSpecial xlPasteValues
                        Else
                            .PasteSpecial xlPasteFormulas
                        End If
                        
                        If Me.chkFormats Then
                            .PasteSpecial xlPasteFormats
                        End If
                        
                        wsNew.Activate
                        wsNewFCell.Select
                            
                        Application.CutCopyMode = False
                    End With
                    
                    With wsNew
                    
                        If Me.chkDelete Then
                            .Columns(cDelete + wsNewFCell.Column - 1).EntireColumn.Delete
                        End If
                    
                    End With
                    
                    cSucc = cSucc + 1
                    
                End If
    
                'Show all data in the range
                InRng.AutoFilter Field:=FilterCol
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next Item
                
        End If
    
    Else 'SEZIONE PER COLONNE
    
        '##############################
        '####### OGNI N COLONNE #######
        '##############################
        
        If Me.optNStep Then
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = Application.WorksheetFunction.RoundUp((InRng.Columns.Count - Me.txtHeader) / Me.txtNStep, 0)
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
            
            For i = 1 To countermax
                
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                'Add a new worksheet
                Set wsNew = Worksheets.Add(After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count))
                On Error Resume Next
                wsNew.Name = Left(SrcWs.Name, 26) & "_" & Format(i, "000")
                If Err.Number <> 0 Then
                    ErrNum = ErrNum + 1
                    wsNew.Name = "Error_" & Format(ErrNum, "0000")
                    Err.Clear
                End If
                On Error GoTo Aborted
                
                Set wsNewFCell = wsNew.Range("A1")
                If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                    
                'Copy headers to new worksheet
                If Me.txtHeader > 0 Then
                    For j = 1 To Me.txtHeader
                    
                        InRng.Columns(j).SpecialCells(xlCellTypeVisible).Copy
                    
                        With wsNewFCell.Offset(0, j - 1)
                            .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                            
                            If Me.chkValues Then
                                .PasteSpecial xlPasteValues
                            Else
                                .PasteSpecial xlPasteFormulas
                            End If
                            
                            If Me.chkFormats Then
                                .PasteSpecial xlPasteFormats
                            End If
                    
                            wsNew.Activate
                            wsNewFCell.Select
                            
                            Application.CutCopyMode = False
                        End With
                    Next j
                End If
                            
                'Copy data to new worksheet
                InRng.Range(InRng.Cells(1, Me.txtHeader + ((i - 1) * Me.txtNStep) + 1), _
                            InRng.Cells(InRng.Row + InRng.Rows.Count - 1, Application.WorksheetFunction.Min(Me.txtHeader + (i * Me.txtNStep), InRng.Columns.Count))).SpecialCells(xlCellTypeVisible).Copy
                With wsNewFCell.Offset(0, Me.txtHeader)
                    .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                    
                    If Me.chkValues Then
                        .PasteSpecial xlPasteValues
                    Else
                        .PasteSpecial xlPasteFormulas
                    End If
                    
                    If Me.chkFormats Then
                        .PasteSpecial xlPasteFormats
                    End If
                    
                    .Select
                    
                    Application.CutCopyMode = False
                End With
                
                cSucc = cSucc + 1
                            
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next i
        Else
    
        '#############################################
        '####### SECONDO IL VALORE DI UNA RIGA #######
        '#############################################
        
            '#' Nuova versione con collection
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                If Me.lbxFilterValues.Selected(i) = True Or Me.chkFilterValues = False Then
                    SplitColl.Add Me.lbxFilterValues.List(i), CStr(Me.lbxFilterValues.List(i))
                End If
            Next i
            
            
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = SplitColl.Count
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
                
            For Each Item In SplitColl
            
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                '#' Definisco il range della riga filtro
                Set FilterRowRng = InRng.Rows(FilterRow)
                
                '#' Costruisco il range da copiare
                    Set CopyRng = Nothing
                    
                    'Aggiungo le colonne di intestazione
                    If Me.txtHeader > 0 Then
                        For i = 1 To Me.txtHeader
                            If CopyRng Is Nothing Then
                                Set CopyRng = InRng.Columns(i)
                            Else
                                Set CopyRng = Union(CopyRng, InRng.Columns(i))
                            End If
                        Next i
                    End If
                                
                    'faccio un ciclo per verificare se il valore nella riga filtro corrisponde al valore della collection
                    For j = Me.txtHeader + 1 To FilterRowRng.Cells.Count
                        If CStr(FilterRowRng.Cells(1, j)) = Item Then
                            If CopyRng Is Nothing Then
                                Set CopyRng = InRng.Columns(j)
                            Else
                                Set CopyRng = Union(CopyRng, InRng.Columns(j))
                            End If
                        End If
                    Next j
                
                'Add a new worksheet
                
                'Elimino l'eventuale foglio preesistente con lo stesso nome
                If Me.optOverwrite = True Then
                    On Error Resume Next
                    Application.DisplayAlerts = False
                    If Item = "" Then
                        Worksheets("{Empty}").Delete
                    Else
                        Worksheets(Left(CleanString(CStr(Item), "_", "sheet"), 31)).Delete
                    End If
                    Application.DisplayAlerts = True
                    On Error GoTo Aborted
                End If
                    
                Set wsNew = Worksheets.Add(After:=Sheets(Sheets.Count))
                On Error Resume Next
                'Rinomina il foglio con il valore della cella (primi 31 caratteri), togliendo i caratteri non validi.
                'Se comunque genera errore rinomina come 'Error' con numero progressivo
                If Item = "" Then
                    wsNew.Name = "{Empty}"
                Else
                    wsNew.Name = Left(CleanString(CStr(Item), "_", "sheet"), 31)
                    If Err.Number > 0 Then
                        ErrNum = ErrNum + 1
                        wsNew.Name = "Error_" & Format(ErrNum, "0000")
                        Err.Clear
                    End If
                End If
                On Error GoTo Aborted


                'Copy the visible data to the new worksheet
                CopyRng.SpecialCells(xlCellTypeVisible).Copy
                
                Set wsNewFCell = wsNew.Range("A1")
                If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                
                With wsNewFCell
                    .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                    
                    If Me.chkValues Then
                        .PasteSpecial xlPasteValues
                    Else
                        .PasteSpecial xlPasteFormulas
                    End If
                    
                    If Me.chkFormats Then
                        .PasteSpecial xlPasteFormats
                    End If
                    
                    wsNew.Activate
                    wsNewFCell.Select
                            
                    Application.CutCopyMode = False
                End With
                
                With wsNew
                
                    If Me.chkDelete Then
                        .Rows(cDelete + wsNewFCell.Row - 1).EntireRow.Delete
                    End If
                
                End With
                
                cSucc = cSucc + 1
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next Item
                
        End If
    
    
    End If
    
    
    'Chiude la finestra di avanzamento
    Unload UProgress

    'Turn off AutoFilter
    SrcWs.AutoFilterMode = False
    
    InRng.Parent.Activate

    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    If lng = 0 Then
        strSucc = "Sono stati creati con successo " & cSucc & " fogli"
        strErr = "Rinominare manualmente i fogli col nome che inizia per ""Error_"": " _
             & "Ci sono caratteri non permessi nei nomi dei fogli " _
             & "oppure esistono pi|fffd| fogli con lo stesso nome."
    Else
        strSucc = cSucc & " sheets have been successfully created"
        strErr = "Please rename manually sheets whose name begins with ""Error_"": " _
             & "Characters not allowed in sheet names were found, " _
             & "or multiple sheets with the same name exist."
    End If
    
    If ErrNum > 0 Then
        MsgBox strSucc & vbNewLine & vbNewLine & strErr, vbInformation, IIf(lng = 0, "Esecuzione completata", "Execution completed")
    Else
        MsgBox strSucc, vbInformation, IIf(lng = 0, "Esecuzione completata", "Execution completed")
    End If

    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub



Attribute VB_Name = "frmSplitSheetToFiles"
Attribute VB_Base = "0{34119ACC-48EF-4664-8756-1F8997F45596}{B9A2ACAD-185E-473B-A170-F72E99D76FF5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim FolderName As String

Private Sub UserForm_Initialize()
        
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Me.Width = Me.Width - 194 'La larghezza dell'elenco colonne
        
    On Error Resume Next
    If Selection.Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
    Else
        Me.refRange = Selection.address
    End If
    Range(Me.refRange).Select
    On Error GoTo 0
    
    With Me.cbxFormat
        .AddItem "Excel 2007+ (.xlsx)"
        .AddItem "Excel 97-2003 (.xls)"
        .AddItem "PDF (.pdf)"
        .AddItem "Open Document Format (.ods)"
        .AddItem "Excel 95/5.0 (.xls)"
        .AddItem IIf(lng = 0, "Testo con delimitatore (.csv)", "Comma separated values (.csv)")
        .AddItem IIf(lng = 0, "Testo con del. custom (.csv)", "Custom separated values (.csv)")
        .AddItem IIf(lng = 0, "Testo Unicode (.txt)", "Unicode text (.txt)")
        .AddItem "File XML (.xml)"
        If .ListIndex = -1 Then .ListIndex = 0
    End With

    If ActiveWorkbook.path = "" Then
        Me.txtDestFolder = DesktopPath
    Else
        Me.txtDestFolder = ValidateFolder(ActiveWorkbook.path)
    End If
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    Me.txtFilterList = ""
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
    Call ListColumns(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
    Call ListColumns(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
End Sub

Private Sub cbxFormat_Change()
    
    '#' Enable/Disable values only
    Select Case Me.cbxFormat.ListIndex
        Case 0, 1, 3, 4
            Me.chkValues.Enabled = True
            Me.optA1.Enabled = True
            Me.optSamePosition.Enabled = True
            Me.chkFormats.Enabled = True
        Case Else
            Me.chkValues.Enabled = False
            Me.optA1.Enabled = False
            Me.optSamePosition.Enabled = False
            Me.chkFormats.Enabled = False
    End Select

    '#' Enable/Disable custom delimiter
    Select Case Me.cbxFormat.ListIndex
        Case 6
            Me.lblSeparator.Enabled = True
            Me.txtSeparator.Enabled = True
        Case Else
            Me.lblSeparator.Enabled = False
            Me.txtSeparator.Enabled = False
    End Select

End Sub

Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
    Call ListFilterValues(False)
End Sub

Private Sub optNStep_Change()
    Me.txtNStep.Enabled = Me.optNStep
    Me.spbNStep.Enabled = Me.optNStep
    Me.cbxFilterCol.Enabled = Not Me.optNStep
    Me.chkDelete.Enabled = Not Me.optNStep
    If Me.optNStep = True Then Me.chkFilterValues = False
    Me.chkFilterValues.Enabled = Not Me.optNStep
End Sub

Private Sub spbNStep_SpinDown()
    Me.txtNStep = Me.spbNStep
End Sub

Private Sub spbNStep_SpinUp()
    Me.txtNStep = Me.spbNStep
End Sub

Private Sub txtNStep_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtNStep_Change()
    If Val(Me.txtNStep) > Me.spbNStep.Max Then Me.txtNStep = Me.spbNStep.Max
    If Val(Me.txtNStep) < Me.spbNStep.Min Then Me.txtNStep = Me.spbNStep.Min
    Me.spbNStep = Me.txtNStep
End Sub

Private Sub chkFilterValues_Change()
    Me.Width = Me.Width + (IIf(Me.chkFilterValues = True, 1, -1) * 194)
    Me.lblFilterValues.visible = Me.chkFilterValues
    Me.lbxFilterValues.visible = Me.chkFilterValues
    Me.chkAllNone.visible = Me.chkFilterValues
End Sub

Private Sub cbxFilterCol_Change()
    Me.cbxFilterCol.ControlTipText = Me.cbxFilterCol.Text
    Call ListFilterValues
End Sub

Private Sub optByColumns_Change()
    Dim ctl As control
    
    If Me.optByColumns = True Then
        Call ListRows(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
        
        For Each ctl In Me.Controls
            Select Case ctl.Name
                Case "optNStep", "lblHeader"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Riga", "Colonna"), "Righe", "Colonne"), "riga", "colonna"), "righe", "colonne"), "Row", "Column"), "row", "column")
                Case "optFilterCol", "chkDelete"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Colonna", "Riga"), "Colonne", "Righe"), "colonna", "riga"), "colonne", "righe"), "Column", "Row"), "column", "row")
            End Select
        Next ctl
    Else
        Call ListColumns(ActiveSheet.Range(Me.refRange), Me.cbxFilterCol)
        
        For Each ctl In Me.fraSplit.Controls
            Select Case ctl.Name
                Case "optNStep", "lblHeader"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Colonna", "Riga"), "Colonne", "Righe"), "colonna", "riga"), "colonne", "righe"), "Column", "Row"), "column", "row")
                Case "optFilterCol", "chkDelete"
                    ctl.Caption = Replace(Replace(Replace(Replace(Replace(Replace(ctl.Caption, "Riga", "Colonna"), "Righe", "Colonne"), "riga", "colonna"), "righe", "colonne"), "Row", "Column"), "row", "column")
            End Select
        Next ctl
    End If

End Sub

Private Sub ListFilterValues(Optional clearvalues As Boolean = True)
    Dim i As Long
    Dim FilterCol As Long
    Dim FilterRow As Long
    Dim SplitColl As New Collection
    Dim selValues
    Dim arr As Variant
    Dim m As Long
    
    
    If clearvalues = False And Me.lbxFilterValues.ListCount > 0 Then
        'Costruisco l'array dei valori precedentemente selezionati
        ReDim selValues(0 To Me.lbxFilterValues.ListCount - 1, 0 To 1)
        For i = 0 To UBound(selValues, 1)
            selValues(i, 0) = Me.lbxFilterValues.List(i)
            selValues(i, 1) = Me.lbxFilterValues.Selected(i)
        Next i
    End If
    Me.lbxFilterValues.Clear
    
    On Error Resume Next
    
    Set InRng = Range(Me.refRange)
    If InRng Is Nothing Then Exit Sub
    If InRng.Cells.Count = 1 Then
        arr = InRng.reSize(1, 2)
        ReDim Preserve arr(1 To 1, 1 To 1)
    Else
        arr = InRng
    End If
    
    If Me.optByRows = True Then
    
        FilterCol = ColItemToNumber(Me.cbxFilterCol.Text)
        
        For i = 1 + Me.txtHeader To UBound(arr, 1)
            On Error Resume Next
            If InRng.Rows(i).RowHeight > 0 And UCase(arr(i, FilterCol - InRng.Column + 1)) Like "*" & UCase(Me.txtFilterList) & "*" Then
                SplitColl.Add arr(i, FilterCol - InRng.Column + 1), CStr(arr(i, FilterCol - InRng.Column + 1))
            End If
            On Error GoTo 0
        Next i
        
        On Error Resume Next
        Me.lbxFilterValues.List = CollToArray(SplitColl)
        On Error GoTo 0
        Set SplitColl = Nothing
        
        'Ordina lista A-Z
        Call SortListCombobox(Me.lbxFilterValues)
        
        'Se ho cambiato colonna seleziona tutti, se ho solo variato le righe di intestazione, mantieni selezione precedente
        If clearvalues = True Then
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                Me.lbxFilterValues.Selected(i) = True
            Next i
        ElseIf IsArray(selValues) Then
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                For m = 0 To UBound(selValues, 1)
                    If Me.lbxFilterValues.List(i) = selValues(m, 0) Then
                        Me.lbxFilterValues.Selected(i) = selValues(m, 1)
                        Exit For
                    End If
                Next m
            Next i
        End If
        
    Else
    
        FilterRow = RowItemToNumber(Me.cbxFilterCol.Text)
        
        For i = 1 + Me.txtHeader To InRng.Rows(FilterRow).Cells.Count
            On Error Resume Next
            If InRng.Rows(FilterRow - InRng.Row + 1).Cells(i).ColumnWidth > 0 Then SplitColl.Add InRng.Rows(FilterRow - InRng.Row + 1).Cells(i).Value, CStr(InRng.Rows(FilterRow - InRng.Row + 1).Cells(i).Value)
            On Error GoTo 0
        Next i
        
        For i = 1 To SplitColl.Count
            Me.lbxFilterValues.AddItem CStr(SplitColl(i))
        Next i
        Set SplitColl = Nothing
        
        'Ordina lista A-Z
        Call SortListCombobox(Me.lbxFilterValues)
        
        'Se ho cambiato colonna seleziona tutti, se ho solo variato le righe di intestazione, mantieni selezione precedente
        If clearvalues = True Then
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                Me.lbxFilterValues.Selected(i) = True
            Next i
        Else
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                For m = 0 To UBound(selValues, 1)
                    If Me.lbxFilterValues.List(i) = selValues(m, 0) Then
                        Me.lbxFilterValues.Selected(i) = selValues(m, 1)
                        Exit For
                    End If
                Next m
            Next i
        End If
    
    End If
    
    On Error GoTo 0
    
End Sub

Private Sub txtFilterList_Change()
    Call ListFilterValues
End Sub

Private Sub chkAllNone_Click()
    Dim i As Long
    
    For i = 0 To Me.lbxFilterValues.ListCount - 1
        Me.lbxFilterValues.Selected(i) = Me.chkAllNone
    Next i
End Sub

Private Sub optA1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub

Private Sub optSamePosition_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If Me.cmdOK.Enabled = True Then Call cmdOK_Click
End Sub
Private Sub ExportToXML(sh As Worksheet)
    Dim headArr()
    Dim dataArr()
    Const strPrefix As String = "<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>"
    Dim oTag As String
    Const rTag As String = "    <record>"
    Dim f As Long
    Dim i As Long, j As Long
    
    f = FreeFile
    
    oTag = "<XmlExport"
    
    Open FolderName & sh.Name & ".xml" For Output As #f
    
    Print #f, strPrefix
    Print #f, oTag & " xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">"
    
    dataArr = sh.UsedRange
    
    With sh.UsedRange
        headArr = .Range(.Cells(1, 1), .Cells(1, .Columns.Count))
        For i = 2 To .Rows.Count
            Print #f, rTag
            For j = LBound(headArr, 2) To UBound(headArr, 2)
                Print #f, "        <" & Replace(headArr(1, j), " ", "") & ">" & dataArr(i, j) & "</" & Replace(headArr(1, j), " ", "") & ">"
            Next j
            Print #f, Replace(rTag, "<", "</")
        Next i
    End With
    Print #f, Replace(oTag, "<", "</") & ">"
    
    Close #f
    'Mi accerto che il file sia chiuso
    Call CloseTxt(FolderName & sh.Name & ".xml")

End Sub

Private Sub ExportWithCustomDelimiter(sh As Worksheet)
    Dim dataArr()
    Dim f As Long
    Dim i As Long, j As Long
    Dim strLine As String
    Dim sep As String
        
    sep = Me.txtSeparator
    
    f = FreeFile
    
    Open FolderName & sh.Name & ".csv" For Output As #f
    
    dataArr = sh.UsedRange
    
    With sh.UsedRange
        For i = LBound(dataArr, 1) To UBound(dataArr, 1)
            strLine = ""
            For j = LBound(dataArr, 2) To UBound(dataArr, 2)
                strLine = strLine & dataArr(i, j) & sep
            Next j
            Print #f, Left(strLine, Len(strLine) - Len(sep))
        Next i
    End With
    
    Close #f
    'Mi accerto che il file sia chiuso
    Call CloseTxt(FolderName & sh.Name & ".csv")

End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim DateString As String
    Dim SrcWs As Worksheet
    Dim FilterCol As Long
    Dim FilterRow As Long
    Dim FilterRowRng As Range
    Dim CopyRng As Range
    Dim head As Long
    Dim SplitColl As New Collection
    Dim Item As Variant
    Dim cCount As Long
    Dim wsNew As Worksheet
    Dim wsNewFCell As Range
    Dim ErrNum As Long
    Dim i As Long
    Dim j As Long
    Dim corr As Long
    Dim cDelete As Long
    Dim cSucc As Long
    Dim strSucc As String
    Dim oFolder As VbMsgBoxResult
    
    On Error Resume Next
    With Me
        If TypeName(Range(.refRange)) <> "Range" And Not Me.chkWholeSheet Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        .Hide
        
        Set InRng = Range(.refRange)
    
    End With
    
    On Error GoTo Aborted
    
    DateString = Format(Now, "yyyy-mm-dd hh-mm-ss")

    FolderName = ValidateFolder(Me.txtDestFolder)
    If Me.chkSubFolder Then FolderName = ValidateFolder(FolderName & DateString)
    
    Set SrcWs = InRng.Parent
    
    If ActiveWorkbook.ProtectStructure = True Or InRng.Parent.ProtectContents = True Then
        If lng = 0 Then
            MsgBox "Spiacente, la procedura non pu|fffd| funzionare se il foglio o la cartella di lavoro sono protetti", vbOKOnly + vbExclamation, "Foglio o cartella di lavoro protetti"
        Else
            MsgBox "Sorry, not working when the workbook or worksheet is protected", vbOKOnly + vbExclamation, "Worksheet or Workbook protected"
        End If
        Exit Sub
    End If
    
    If Me.optByRows = True Then
        FilterCol = Range(Replace(Mid(Me.cbxFilterCol, 1, InStr(1, Me.cbxFilterCol, "(") - 1) & "1", " ", "")).Column - InRng.Column + 1
        For i = 1 To FilterCol - 1
            If InRng.Columns(i).Width = 0 Then corr = corr + 1
        Next i
        cDelete = FilterCol - corr 'indice della colonna da eliminare nei fogli splittati
    Else
        FilterRow = Range("A" & Replace(Mid(Me.cbxFilterCol, 1, InStr(1, Me.cbxFilterCol, "(") - 1), " ", "")).Row - InRng.Row + 1
        For i = 1 To FilterRow - 1
            If InRng.Rows(i).Height = 0 Then corr = corr + 1
        Next i
        cDelete = FilterRow - corr 'indice della riga da eliminare nei fogli splittati
    End If
    
    On Error Resume Next
    If Me.optByRows = True Then InRng.Cells(1, FilterCol).UnMerge
    On Error GoTo Aborted
    
    
    'Turn off AutoFilter
    InRng.Parent.AutoFilterMode = False

    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Create new folder to save the new files in
    On Error Resume Next
    MkDir FolderName
    On Error GoTo Aborted
    
    head = Application.WorksheetFunction.Max(1, Me.txtHeader)
                        
    
    If Me.optByRows = True Then
    
        '############################
        '####### OGNI N RIGHE #######
        '############################
        
        If Me.optNStep Then
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = Application.WorksheetFunction.RoundUp((InRng.Rows.Count - Me.txtHeader) / Me.txtNStep, 0)
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
            
            For i = 1 To countermax
                
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                'Add a new worksheet
                Set wsNew = Worksheets.Add(After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count))
                On Error Resume Next
                wsNew.Name = Left(SrcWs.Name, 26) & "_" & Format(i, "000")
                If Err.Number <> 0 Then
                    ErrNum = ErrNum + 1
                    wsNew.Name = "Error_" & Format(ErrNum, "0000")
                    Err.Clear
                End If
                On Error GoTo Aborted
                
                Set wsNewFCell = wsNew.Range("A1")
                If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                    
                'Copy headers to new worksheet
                If Me.txtHeader > 0 Then
                    InRng.Rows("1:" & Me.txtHeader).SpecialCells(xlCellTypeVisible).Copy
                    
                    With wsNewFCell
                        .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                        
                        If Me.chkValues Then
                            .PasteSpecial xlPasteValues
                        Else
                            .PasteSpecial xlPasteFormulas
                        End If
                        
                        If Me.chkFormats Then
                            .PasteSpecial xlPasteFormats
                        End If
                        
                        Application.CutCopyMode = False
                    End With
                End If
                            
                'Copy data to new worksheet
                InRng.Rows(Me.txtHeader + ((i - 1) * Me.txtNStep) + 1 & ":" & Application.WorksheetFunction.Min(Me.txtHeader + (i * Me.txtNStep), InRng.Rows.Count)).SpecialCells(xlCellTypeVisible).Copy
                With wsNewFCell.Offset(Me.txtHeader, 0)
                    .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                    
                    If Me.chkValues Then
                        .PasteSpecial xlPasteValues
                    Else
                        .PasteSpecial xlPasteFormulas
                    End If
                    
                    If Me.chkFormats Then
                        .PasteSpecial xlPasteFormats
                    End If
                    
                    wsNew.Activate
                    wsNewFCell.Select
                    
                    Application.CutCopyMode = False
                End With
                
                'Save to new file and delete temporary worksheet
                Call GenerateFiles(wsNew)
                
                
                cSucc = cSucc + 1
                            
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next i
        Else
    
        '################################################
        '####### SECONDO IL VALORE DI UNA COLONNA #######
        '################################################
        
            '#' Nuova versione con collection
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                If Me.lbxFilterValues.Selected(i) = True Or Me.chkFilterValues = False Then
                    SplitColl.Add Me.lbxFilterValues.List(i), CStr(Me.lbxFilterValues.List(i))
                End If
            Next i
            
            
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = SplitColl.Count
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
                
            For Each Item In SplitColl
            
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                'Filter the range
                InRng.Offset(head - 1).reSize(InRng.Rows.Count - head + 1).AutoFilter Field:=FilterCol, Criteria1:="=" & _
                 Replace(Replace(Replace(Item, "~", "~~"), "*", "~*"), "?", "~?")
                
                'Caso particolare: header = 0 (nascondo la prima riga se non |fffd| uguale al filtro)
                If Me.txtHeader = 0 Then
                    If Not InRng(1, FilterCol - InRng.Column + 1) = Replace(Replace(Replace(Item, "~", "~~"), "*", "~*"), "?", "~?") Then
                        InRng.Rows(1).EntireRow.Hidden = True
                    End If
                End If
                
                'Check if there are no more then 8192 areas(limit of areas)
                cCount = 0
                On Error Resume Next
                cCount = InRng.Columns(1).SpecialCells(xlCellTypeVisible) _
                         .Areas(1).Cells.Count
                On Error GoTo Aborted
                If cCount = 0 Then
                    MsgBox "There are more than 8192 areas for the value : " & cell.Value _
                         & vbNewLine & "It is not possible to copy the visible data." _
                         & vbNewLine & "Tip: Sort your data before you use this macro.", _
                           vbOKOnly, "Numero eccessivo di aree"
                Else
                    'Add a new worksheet
                    
                    Set wsNew = Worksheets.Add(After:=Sheets(Sheets.Count))
                    On Error Resume Next
                    'Rinomina il foglio con il valore della cella (primi 31 caratteri), togliendo i caratteri non validi.
                    'Se comunque genera errore rinomina come 'Error' con numero progressivo
                    If Item = "" Then
                        wsNew.Name = "{Empty}"
                    Else
                        wsNew.Name = Left(CleanString(CStr(Item), "_", "sheet"), 31)
                        If Err.Number > 0 Then
                            ErrNum = ErrNum + 1
                            wsNew.Name = "Error_" & Format(ErrNum, "0000")
                            Err.Clear
                        End If
                    End If
                    On Error GoTo Aborted
    
    
                    'Copy the visible data to the new worksheet
                    InRng.SpecialCells(xlCellTypeVisible).Copy
                    
                    'Se avevo nascosto la prima riga, la rendo di nuovo visibile
                    If InRng.Rows(1).EntireRow.Hidden = True Then InRng.Rows(1).EntireRow.Hidden = False
                    
                    Set wsNewFCell = wsNew.Range("A1")
                    If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                    
                    With wsNewFCell
                        .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                        
                        If Me.chkValues Then
                            .PasteSpecial xlPasteValues
                        Else
                            .PasteSpecial xlPasteFormulas
                        End If
                        
                        If Me.chkFormats Then
                            .PasteSpecial xlPasteFormats
                        End If
                        
                        wsNew.Activate
                        wsNewFCell.Select
                            
                        Application.CutCopyMode = False
                    End With
                    
                    With wsNew
                    
                        If Me.chkDelete Then
                            .Columns(cDelete + wsNewFCell.Column - 1).EntireColumn.Delete
                        End If
                    
                    End With
                    
                    'Save to new file and delete temporary worksheet
                    Call GenerateFiles(wsNew)
                    
                    cSucc = cSucc + 1
                    
                End If
    
                'Show all data in the range
                InRng.AutoFilter Field:=FilterCol
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next Item
                
        End If
    
    Else 'SEZIONE PER COLONNE
    
        '##############################
        '####### OGNI N COLONNE #######
        '##############################
        
        If Me.optNStep Then
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = Application.WorksheetFunction.RoundUp((InRng.Columns.Count - Me.txtHeader) / Me.txtNStep, 0)
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
            
            For i = 1 To countermax
                
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                'Add a new worksheet
                Set wsNew = Worksheets.Add(After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count))
                On Error Resume Next
                wsNew.Name = Left(SrcWs.Name, 26) & "_" & Format(i, "000")
                If Err.Number <> 0 Then
                    ErrNum = ErrNum + 1
                    wsNew.Name = "Error_" & Format(ErrNum, "0000")
                    Err.Clear
                End If
                On Error GoTo Aborted
                
                Set wsNewFCell = wsNew.Range("A1")
                If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                    
                'Copy headers to new worksheet
                If Me.txtHeader > 0 Then
                    For j = 1 To Me.txtHeader
                    
                        InRng.Columns(j).SpecialCells(xlCellTypeVisible).Copy
                    
                        With wsNewFCell.Offset(0, j - 1)
                            .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                            
                            If Me.chkValues Then
                                .PasteSpecial xlPasteValues
                            Else
                                .PasteSpecial xlPasteFormulas
                            End If
                            
                            If Me.chkFormats Then
                                .PasteSpecial xlPasteFormats
                            End If
                    
                            wsNew.Activate
                            wsNewFCell.Select
                            
                            Application.CutCopyMode = False
                        End With
                    Next j
                End If
                            
                'Copy data to new worksheet
                InRng.Range(InRng.Cells(1, Me.txtHeader + ((i - 1) * Me.txtNStep) + 1), _
                            InRng.Cells(InRng.Row + InRng.Rows.Count - 1, Application.WorksheetFunction.Min(Me.txtHeader + (i * Me.txtNStep), InRng.Columns.Count))).SpecialCells(xlCellTypeVisible).Copy
                With wsNewFCell.Offset(0, Me.txtHeader)
                    .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                    
                    If Me.chkValues Then
                        .PasteSpecial xlPasteValues
                    Else
                        .PasteSpecial xlPasteFormulas
                    End If
                    
                    If Me.chkFormats Then
                        .PasteSpecial xlPasteFormats
                    End If
                    
                    .Select
                    
                    Application.CutCopyMode = False
                End With
                
                'Save to new file and delete temporary worksheet
                Call GenerateFiles(wsNew)
                
                cSucc = cSucc + 1
                            
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
            
            Next i
        Else
    
        '#############################################
        '####### SECONDO IL VALORE DI UNA RIGA #######
        '#############################################
        
            '#' Nuova versione con collection
            For i = 0 To Me.lbxFilterValues.ListCount - 1
                If Me.lbxFilterValues.Selected(i) = True Or Me.chkFilterValues = False Then
                    SplitColl.Add Me.lbxFilterValues.List(i), CStr(Me.lbxFilterValues.List(i))
                End If
            Next i
            
            
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = SplitColl.Count
            UProgress.SetDescription "Splittaggio in corso..."
            Call ShowProgressBar
                
            For Each Item In SplitColl
            
                'Aumenta di 1 il contatore
                counter = counter + 1
                
                '#' Definisco il range della riga filtro
                Set FilterRowRng = InRng.Rows(FilterRow)
                
                '#' Costruisco il range da copiare
                    Set CopyRng = Nothing
                    
                    'Aggiungo le colonne di intestazione
                    If Me.txtHeader > 0 Then
                        For i = 1 To Me.txtHeader
                            If CopyRng Is Nothing Then
                                Set CopyRng = InRng.Columns(i)
                            Else
                                Set CopyRng = Union(CopyRng, InRng.Columns(i))
                            End If
                        Next i
                    End If
                                
                    'faccio un ciclo per verificare se il valore nella riga filtro corrisponde al valore della collection
                    For j = Me.txtHeader + 1 To FilterRowRng.Cells.Count
                        If CStr(FilterRowRng.Cells(1, j)) = Item Then
                            If CopyRng Is Nothing Then
                                Set CopyRng = InRng.Columns(j)
                            Else
                                Set CopyRng = Union(CopyRng, InRng.Columns(j))
                            End If
                        End If
                    Next j
                
                'Add a new worksheet
                Set wsNew = Worksheets.Add(After:=Sheets(Sheets.Count))
                On Error Resume Next
                'Rinomina il foglio con il valore della cella (primi 31 caratteri), togliendo i caratteri non validi.
                'Se comunque genera errore rinomina come 'Error' con numero progressivo
                If Item = "" Then
                    wsNew.Name = "{Empty}"
                Else
                    wsNew.Name = Left(CleanString(CStr(Item), "_", "sheet"), 31)
                    If Err.Number > 0 Then
                        ErrNum = ErrNum + 1
                        wsNew.Name = "Error_" & Format(ErrNum, "0000")
                        Err.Clear
                    End If
                End If
                On Error GoTo Aborted


                'Copy the visible data to the new worksheet
                CopyRng.SpecialCells(xlCellTypeVisible).Copy
                
                Set wsNewFCell = wsNew.Range("A1")
                If Me.optSamePosition = True Then Set wsNewFCell = wsNewFCell.Offset(InRng.Row - 1, InRng.Column - 1)
                
                With wsNewFCell
                    .PasteSpecial Paste:=8 '<== Copia larghezza colonne
                    
                    If Me.chkValues Then
                        .PasteSpecial xlPasteValues
                    Else
                        .PasteSpecial xlPasteFormulas
                    End If
                    
                    If Me.chkFormats Then
                        .PasteSpecial xlPasteFormats
                    End If
                    
                    wsNew.Activate
                    wsNewFCell.Select
                            
                    Application.CutCopyMode = False
                End With
                
                With wsNew
                
                    If Me.chkDelete Then
                        .Rows(cDelete + wsNewFCell.Row - 1).EntireRow.Delete
                    End If
                
                End With
                
                'Save to new file and delete temporary worksheet
                Call GenerateFiles(wsNew)
                
                cSucc = cSucc + 1
                
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If counter Mod 10 = 0 Then DoEvents
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
                
            Next Item
                
        End If
    
    
    End If
    
    
    'Chiude la finestra di avanzamento
    Unload UProgress

    'Turn off AutoFilter
    SrcWs.AutoFilterMode = False
    
    InRng.Parent.Activate

    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    oFolder = MsgBox("Sono stati creati con successo " & cSucc & " file. Troverai i file nella cartella: " & _
                vbNewLine & vbNewLine & _
                FolderName & _
                vbNewLine & vbNewLine & _
                "Vuoi aprire la cartella di destinazione?", vbInformation + vbYesNo, "Esportazione completata")
    If oFolder = vbYes Then Call OpenFolder(FolderName)
        
    Exit Sub
    
Aborted:
    Call CanceledProcedure

End Sub

Private Sub GenerateFiles(sh As Worksheet)
    Dim DestWb As Workbook
    Dim FileExtStr As String
    Dim FileFormatNum As Long
    
    sh.Copy
    Set DestWb = ActiveWorkbook
    
    With DestWb
    
        '#' Determine the Excel version and file extension/format
        Select Case Me.cbxFormat.ListIndex
            Case 0 '#' Excel 2007+
                FileExtStr = ".xlsx"
                FileFormatNum = 51
            Case 1 '#' Excel 97-2003
                FileExtStr = ".xls"
                FileFormatNum = 56
            Case 2 '#' PDF
                '#' No variables set
            Case 3
                FileExtStr = ".ods"
                FileFormatNum = 60
            Case 4
                FileExtStr = ".xls"
                FileFormatNum = 39
            Case 5
                FileExtStr = ".csv"
                FileFormatNum = 6
            Case 7
                FileExtStr = ".txt"
                FileFormatNum = 42
            Case 6, 8 '#' Separatore custom o XML
                '#' No variables set
        
        End Select
    
        '#' Save file
        Select Case Me.cbxFormat.ListIndex
            Case 2 '#' PDF
                .Sheets(1).ExportAsFixedFormat Type:=xlTypePDF, FileName:=FolderName & DestWb.Sheets(1).Name & ".pdf", Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:=False
            Case 6 '#' Separatore custom
                Call ExportWithCustomDelimiter(DestWb.Sheets(1))
            Case 8 '#' XML
                Call ExportToXML(DestWb.Sheets(1))
            Case Else
                Call SaveFile(DestWb, FolderName & DestWb.Sheets(1).Name & FileExtStr, NewFileFormat:=FileFormatNum, NewFileLocal:=True, Silent:=True)
        End Select
    
    End With

    Application.DisplayAlerts = False
    sh.Delete
    DestWb.Close False
    Application.DisplayAlerts = True
    
End Sub

Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub



Attribute VB_Name = "frmTableColors"
Attribute VB_Base = "0{197958E0-ACAE-4D59-A4DB-774845769D08}{0426F8C8-B67F-4D23-80C3-620EC57A1677}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub optCols_Change()
    Dim ctl As control
    
    For Each ctl In Me.fraOptions.Controls
        If HasCaption(ctl) Then
            If Me.optCols = True Then
                ctl.Caption = Replace(ctl.Caption, "righe", "colonne")
            Else
                ctl.Caption = Replace(ctl.Caption, "colonne", "righe")
            End If
        End If
    Next ctl
End Sub

Private Sub txtHeader_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtHeader_Change()
    If Val(Me.txtHeader) > Me.spbHeader.Max Then Me.txtHeader = Me.spbHeader.Max
    If Val(Me.txtHeader) < Me.spbHeader.Min Then Me.txtHeader = Me.spbHeader.Min
    Me.spbHeader = Me.txtHeader
    
    If Me.txtHeader = 0 Then
        Me.lblHeaderColor.BackStyle = fmBackStyleTransparent
        Me.lblHeaderColor.Enabled = False
        Me.chkHeaderNoColor.Enabled = False
    Else
        Me.lblHeaderColor.BackStyle = fmBackStyleOpaque
        Me.lblHeaderColor.Enabled = True
        Me.chkHeaderNoColor.Enabled = True
    End If
End Sub
Private Sub spbHeader_SpinDown()
    Me.txtHeader = Me.spbHeader
End Sub
Private Sub spbHeader_SpinUp()
    Me.txtHeader = Me.spbHeader
End Sub

Private Sub lblOddColor_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.lblOddColor.BackColor = PickNewColor(Me.lblOddColor.BackColor)
End Sub

Private Sub lblEvenColor_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.lblEvenColor.BackColor = PickNewColor(Me.lblEvenColor.BackColor)
End Sub

Private Sub lblHeaderColor_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.lblHeaderColor.BackColor = PickNewColor(Me.lblHeaderColor.BackColor)
End Sub


Private Function PickNewColor(Optional i_OldColor As Double = xlNone) As Double
    Const BGColor As Long = 13160660  'background color of dialogue
    Const ColorIndexLast As Long = 32 'index of last custom color in palette
    
    Dim myOrgColor As Double          'original color of color index 32
    Dim myRGB_R As Integer            'RGB values of the color that will be
    Dim myRGB_G As Integer            'displayed in the dialogue as
    Dim myRGB_B As Integer            '"Current" color
      
    'save original palette color, because we don't really want to change it
    myOrgColor = ActiveWorkbook.Colors(ColorIndexLast)
    
    If i_OldColor = xlNone Then
        'get RGB values of background color, so the "Current" color looks empty
        Color2RGB BGColor, myRGB_R, myRGB_G, myRGB_B
    Else
        'get RGB values of i_OldColor
        Color2RGB i_OldColor, myRGB_R, myRGB_G, myRGB_B
    End If
    
    'call the color picker dialogue
    If Application.Dialogs(xlDialogEditColor).Show(ColorIndexLast, _
         myRGB_R, myRGB_G, myRGB_B) = True Then
        '"OK" was pressed, so Excel automatically changed the palette
        'read the new color from the palette
        PickNewColor = ActiveWorkbook.Colors(ColorIndexLast)
        'reset palette color to its original value
        ActiveWorkbook.Colors(ColorIndexLast) = myOrgColor
    Else
        '"Cancel" was pressed, palette wasn't changed
        'return old color (or xlNone if no color was passed to the function)
        PickNewColor = i_OldColor
    End If
End Function
Private Sub Color2RGB(ByVal i_Color As Long, _
    o_R As Integer, o_G As Integer, o_B As Integer)
    o_R = i_Color Mod 256
    i_Color = i_Color \ 256
    o_G = i_Color Mod 256
    i_Color = i_Color \ 256
    o_B = i_Color Mod 256
    
    If o_R < 0 Then o_R = 0
    If o_G < 0 Then o_G = 0
    If o_B < 0 Then o_B = 0

End Sub

Private Sub chkHeaderNoColor_Change()
    If Me.chkHeaderNoColor = True Then Me.lblHeaderColor.BackStyle = fmBackStyleTransparent Else Me.lblHeaderColor.BackStyle = fmBackStyleOpaque
End Sub

Private Sub chkOddNoColor_Change()
    If Me.chkOddNoColor = True Then Me.lblOddColor.BackStyle = fmBackStyleTransparent Else Me.lblOddColor.BackStyle = fmBackStyleOpaque
End Sub

Private Sub chkEvenNoColor_Change()
    If Me.chkEvenNoColor = True Then Me.lblEvenColor.BackStyle = fmBackStyleTransparent Else Me.lblEvenColor.BackStyle = fmBackStyleOpaque
End Sub

Private Sub optRows_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdOK_Click
End Sub

Private Sub optCols_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cmdOK_Click
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim i As Long

    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        On Error GoTo Aborted
        
        .Hide
        
    End With
        
    '#' Disattiva aggiornamenti automatici per velocizzare l'esecuzione
    Call AutoCalc(False)
    
    '#' Crea foglio di backup nascosto
    Call backup_create_new

    Set ws = ActiveSheet
    Set InRng = ws.Range(Replace(Me.refRange, ";", ","))
               
    
    With InRng
        
        'INTESTAZIONE
        If Me.txtHeader > 0 Then
            If Me.chkHeaderNoColor = True Then
                .Rows("1:" & Me.txtHeader).Interior.Pattern = xlNone
            Else
                .Rows("1:" & Me.txtHeader).Interior.Color = Me.lblHeaderColor.BackColor
            End If
        End If
        
        'RIGHE ALTERNATE
        If Me.optRows = True Then
            For i = 1 + Me.txtHeader To .Rows.Count
                If (i - Me.txtHeader) Mod 2 = 1 Then
                    If Me.chkOddNoColor = True Then
                        .Rows(i).Interior.Pattern = xlNone
                    Else
                        .Rows(i).Interior.Color = Me.lblOddColor.BackColor
                    End If
                Else
                    If Me.chkEvenNoColor = True Then
                        .Rows(i).Interior.Pattern = xlNone
                    Else
                        .Rows(i).Interior.Color = Me.lblEvenColor.BackColor
                    End If
                End If
            Next i
        
        'COLONNE ALTERNATE
        Else
            For i = 1 To .Columns.Count
                If i Mod 2 = 1 Then
                    If Me.chkOddNoColor = True Then
                        Intersect(.Columns(i), .Columns(i).Offset(Me.txtHeader, 0)).Interior.Pattern = xlNone
                    Else
                        Intersect(.Columns(i), .Columns(i).Offset(Me.txtHeader, 0)).Interior.Color = Me.lblOddColor.BackColor
                    End If
                Else
                    If Me.chkEvenNoColor = True Then
                        Intersect(.Columns(i), .Columns(i).Offset(Me.txtHeader, 0)).Interior.Pattern = xlNone
                    Else
                        Intersect(.Columns(i), .Columns(i).Offset(Me.txtHeader, 0)).Interior.Color = Me.lblEvenColor.BackColor
                    End If
                End If
            Next i
        End If
    
    End With
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmTableToRange"
Attribute VB_Base = "0{AD48DAC7-C0BA-4851-8411-531CF9F78054}{819F6FB1-AF43-4EC7-BCF1-BBDD7419295E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean
Dim DisableAlerts As Boolean


Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    DisableAlerts = True
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    DisableAlerts = False
    
    Call PopulateTableList

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Sub PopulateTableList()
    Dim cTables As New Collection
    Dim tbl As ListObject
    Dim i As Long
    
    Me.lbxTables.Clear
    
    For Each ws In ActiveWorkbook.Worksheets
        If UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*" Then
            For Each tbl In ws.ListObjects
                Me.lbxTables.AddItem ws.Name & ": " & tbl.Name
                If IsSelected(ws.Name) Or ActiveWindow.SelectedSheets.Count = 1 Then Me.lbxTables.Selected(Me.lbxTables.ListCount - 1) = True
            Next tbl
        End If
    Next ws

    '#' Popolo la collection delle tabelle selezionate
    For i = 0 To Me.lbxTables.ListCount - 1
        If Me.lbxTables.Selected(i) = True Then cTables.Add Me.lbxTables.List(i)
    Next i
    
    If cTables.Count = Me.lbxTables.ListCount Then Me.chkAllNone = True

End Sub

Private Sub txtFilterList_Change()
    Call PopulateTableList
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxTables.ListCount - 1
        Me.lbxTables.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GoodToGo(Me)
End Sub

Private Sub lbxTables_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim tbl As ListObject
    Dim wsName As String
    Dim SelSheets As New Collection
    Dim i As Long
    
    '#' Popolo la collection dei fogli selezionati
    For i = 0 To Me.lbxTables.ListCount - 1
        wsName = Split(Me.lbxTables.List(i), ":")(0)
        If Me.lbxTables.Selected(i) = True Then SelSheets.Add ActiveWorkbook.Worksheets(wsName)
    Next i
    
    Me.Hide
    
    Call AutoCalc(False)

    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = SelSheets.Count
    UProgress.SetDescription "Converto le tabelle selezionate..."
    Call ShowProgressBar
    
    For Each ws In SelSheets
        
        For Each tbl In ws.ListObjects
        
            'Aumenta di 1 il contatore, aggiorna descrizione avanzamento
            counter = counter + 1
            UProgress.SetDescription "Converto la tabella... (" & tbl.Name & ")"
            
            '# Convert table to normal range
            tbl.Unlist
            
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            DoEvents
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        Next tbl
    
    Next ws
    
    Unload UProgress
    
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmTrimSpaces"
Attribute VB_Base = "0{9FBAD36C-7CBB-4431-B967-844F755781F4}{87DFED3B-4F1B-48CC-9765-A75FC8F1F38A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub chkAll_change()
    Me.chkLTrim.Enabled = Not (Me.chkAll.Value)
    Me.chkRTrim.Enabled = Not (Me.chkAll.Value)
    Me.chkInsideTrim.Enabled = Not (Me.chkAll.Value)
    Me.chkKeepFormulas.Enabled = Me.chkAll.Value
    Call GoodToGo(Me)
End Sub

Private Sub chkLTrim_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkRTrim_Change()
    Call GoodToGo(Me)
End Sub

Private Sub chkInsideTrim_Change()
    Call GoodToGo(Me)
End Sub



Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim wb As Workbook
    Dim f As Long
    
    With Me
        On Error Resume Next
        If Not .chkWholeSheet Then
            If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                .refRange = Selection.address
                .refRange.SetFocus
                Err.Clear
                Exit Sub
            End If
        End If
    
        .Hide
    
    End With
        
    Call AutoCalc(False)
    
    On Error GoTo Aborted
    
    If Me.tglBatch = False Then '#' NO BATCH
    
        Call backup_create_new
        
        Set ws = ActiveSheet
            
        '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If Me.chkIgnoreHidden = True Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        If InRng Is Nothing Then
            MsgBox TranslateCnst("InvalidRange1") & ws.Name & TranslateCnst("InvalidRange2"), vbInformation
                
        Else
            '#' Attivo la finestra di avanzamento e setto contatore e massimo
            counter = 0
            countermax = InRng.Cells.CountLarge
            UProgress.SetDescription "Sto eliminando gli spazi... (" & ws.Name & ")"
            Call ShowProgressBar
            
            For Each cell In InRng.Cells
                
                '#' Aumento di 1 il contatore
                counter = counter + 1
                                    
                Call elaboracella(cell)
                    
                '#' Aggiorna la barra di avanzamento
                Call UpdateProgressBar(counter, countermax)
                If ProgressAborted = 1 Then GoTo Aborted
                On Error GoTo Aborted
       
            Next cell
                
        End If
    
    Else '#' BATCH
        
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile))
        Call ShowProgressBar
        
        '#' Sezione dedicata al file attivo, se il relativo flag |fffd| selezionato
        If Me.chkActiveFile = True Then
            Set wb = ActiveWorkbook
            UProgress.SetDescription "Sto eliminando gli spazi... (" & wb.Name & ")"
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(wb.FullName)
            End If
        
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                    If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                    
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
                            
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        End If
        
        
        '#' Sezione dedicata agli altri file della lista
        For f = 0 To Me.lbxBatchFiles.ListCount - 1
            
            counter = counter + 1
            
            If Me.chkBatchBackup Then
                Call BatchBackup(Me.lbxBatchFiles.List(f))
            End If
                        
            '#' Apro il file
            Application.DisplayAlerts = False
            Set wb = Workbooks.Open(Me.lbxBatchFiles.List(f), 0)
            Application.DisplayAlerts = True
            
            UProgress.SetDescription "Sto eliminando gli spazi... (" & wb.Name & ")"
            
            On Error GoTo NextFile
            
            For Each ws In wb.Worksheets
                
                If ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden Then
                    
                    ws.Activate
                
                    '#' Ridimensiona il range selezionato per farlo restare all'interno del range dei dati
                    '#' Imposta il range
                    If Me.chkWholeSheet Then
                        Set InRng = ws.UsedRange
                    Else
                        Set InRng = RangeResize(ws.Range(Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)), ws)
                    End If
                    If Not InRng Is Nothing Then
                        If Me.chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
                
                        '#' Setto contatore secondario e suo massimo
                        counter2 = 0
                        countermax2 = InRng.Cells.Count
                        UProgress.SetSubDescription "Foglio: " & ws.Name
                            
                        For Each cell In InRng.Cells
                                
                            counter2 = counter2 + 1
                            Call elaboracella(cell)
    
                            '#' Aggiorna la barra di avanzamento secondaria
                            Call UpdateSubProgressBar(counter2, countermax2)
                            If ProgressAborted = 1 Then GoTo Aborted
                            On Error GoTo Aborted
                        
                        Next cell
                        
                    End If '#' Not InRng Is Nothing
                
                End If '#' ws.ProtectContents = False And Not ws.visible = xlSheetVeryHidden
                
            Next ws
                
            Application.EnableEvents = False
            wb.Close True
            Application.EnableEvents = True
NextFile:
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
        
        Next f
    
    End If '#' batch/no batch
    
    '#' Chiudo la finestra di avanzamento
    Unload UProgress
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    If Me.tglBatch = True Then MsgBox Me.lbxBatchFiles.ListCount + Abs(CInt(Me.chkActiveFile)) & TranslateCnst("BatchResult"), vbInformation, TranslateCnst("BatchResultTitle")
        
    If Me.chkClose = False Then Me.Show
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub

Private Sub elaboracella(Cella As Range)
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    Dim Matches
    Dim Match
 
    With regex
      .Pattern = "(\S)\s{2,}(\S)"
      .Global = True
    End With
    
    If Me.chkAll = True And Not IsNumeric(Cella) Then
    
        If Me.chkKeepFormulas = True And Cella.HasFormula And Not Cella.HasArray Then
            Cella.Formula = "=TRIM(" & Mid(Cella.Formula, 2) & ")"
        Else
            Cella.Value2 = Application.WorksheetFunction.Trim(Cella.Value2)
        End If
    
    ElseIf Not IsNumeric(Cella) Then
        
        If Me.chkLTrim = True Then
            Cella.Value2 = LTrim(Cella.Value2)
        End If
        
        If Me.chkRTrim = True Then
            Cella.Value2 = RTrim(Cella.Value2)
        End If
        
        If Me.chkInsideTrim = True Then
            Set Matches = regex.Execute(Cella.Value2)

            For Each Match In Matches
                Cella.Value2 = Replace(Cella.Value2, Match, Match.submatches(0) & " " & Match.submatches(1))
            Next Match
        End If
    
    End If
        
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub

Attribute VB_Name = "frmUniqueList"
Attribute VB_Base = "0{CD9AA530-1E7D-4782-99E0-2E405DFCDE12}{29618764-A7DC-4578-9E4F-C84C728AFAB6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    On Error Resume Next
    Me.refRange = Selection.address
    If Range(Me.refRange).Cells.Count = 1 Then
        Me.refRange = ActiveCell.CurrentRegion.address
        Range(Me.refRange).Select
    End If
    Me.refOutRng = ActiveSheet.Cells(1, findlastcell(ActiveSheet.Cells).Column + 1).address
    On Error GoTo 0

    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName

End Sub

Private Sub refRange_Change()
    On Error Resume Next
    Me.refRange = Mid(Replace(Me.refRange, ";", ","), InStr(1, Me.refRange, "!") + 1)
    MergeAreas(Range(Me.refRange)).Select
    On Error GoTo 0
End Sub


Private Sub chkWholeSheet_Change()
    Me.refRange.Enabled = Not Me.chkWholeSheet
    If Me.chkWholeSheet = True Then Me.refRange = ActiveSheet.UsedRange.address
    If Me.chkWholeSheet = False Then Me.refRange.SetFocus
End Sub

Private Sub chkSortList_Change()
    Me.optAZ.Enabled = Me.chkSortList
    Me.optZA.Enabled = Me.chkSortList
End Sub

Private Sub optOutRng_Change()
    Me.refOutRng.Enabled = Me.optOutRng
    If Me.optOutRng = True Then
        On Error Resume Next
        Me.refOutRng.SetFocus
        On Error GoTo 0
    End If
End Sub

Private Sub optNumbers_Change()
    Me.chkIgnoreCase.Enabled = Not Me.optNumbers
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim newWs As Worksheet
    Dim UniqueDict As Object
    Dim key As Variant
    Dim i As Long
    Dim j As Long
    Dim testRng As Range
    Dim OutRng As Range
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(.refRange, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .refRange = Selection.address
            .refRange.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        If .optOutRng = True And TypeName(Range(Replace(.refOutRng, ";", ","))) <> "Range" Then
            MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
            .optOutRng.SetFocus
            Err.Clear
            Exit Sub
        End If
        
        On Error GoTo Aborted
        
        .Hide
        
        Call AutoCalc(False)
        
        '#' Crea foglio di backup nascosto
        If .optOutRng = True Then Call backup_create_new
    
        On Error GoTo Aborted
        
        Set UniqueDict = CreateObject("Scripting.Dictionary")
        
        'Imposto la sensibilit|fffd| a maiuscole-minuscole
        If Me.chkIgnoreCase = True Then UniqueDict.CompareMode = vbTextCompare
        
        Set ws = ActiveSheet
            
        'Definisco il range di celle da considerare
        Set InRng = RangeResize(ws.Range(Replace(Me.refRange, ";", ",")), ws)
        If .chkIgnoreHidden Then Set InRng = InRng.SpecialCells(xlCellTypeVisible)
        
        If .optNumbers = True Then
            On Error Resume Next
            
            Set testRng = InRng.SpecialCells(xlCellTypeConstants, xlNumbers)
            If Err.Number = 0 Then                                                      'ci sono costanti numeriche
                Set testRng = InRng.SpecialCells(xlCellTypeFormulas, xlNumbers)
                If Err.Number = 0 Then                                                  'ci sono ANCHE formule numeriche
                    Set InRng = Union(InRng, InRng.SpecialCells(xlCellTypeFormulas, xlNumbers))
                Else                                                                    'non ci sono ANCHE formule numeriche
                    Set InRng = InRng.SpecialCells(xlCellTypeConstants, xlNumbers)
                End If
                
            Else 'non ci sono costanti: cerco formule
                
                Err.Clear
                Set testRng = InRng.SpecialCells(xlCellTypeFormulas, xlNumbers)
                If Err.Number = 0 Then                                                  'ci sono SOLO formule numeriche
                    Set InRng = InRng.SpecialCells(xlCellTypeFormulas, xlNumbers)
                Else
                    Set InRng = Nothing                                                 'Non c'|fffd| nulla
                End If
            End If
            
            On Error GoTo Aborted
        End If
                
        If .optText = True Then
            On Error Resume Next
            
            Set testRng = InRng.SpecialCells(xlCellTypeConstants, xlTextValues)
            If Err.Number = 0 Then                                                      'ci sono costanti testuali
                Set testRng = InRng.SpecialCells(xlCellTypeFormulas, xlTextValues)
                If Err.Number = 0 Then                                                  'ci sono ANCHE formule testuali
                    Set InRng = Union(InRng, InRng.SpecialCells(xlCellTypeFormulas, xlTextValues))
                Else                                                                    'non ci sono ANCHE formule testuali
                    Set InRng = InRng.SpecialCells(xlCellTypeConstants, xlTextValues)
                End If
                
            Else 'non ci sono costanti: cerco formule
                
                Err.Clear
                Set testRng = InRng.SpecialCells(xlCellTypeFormulas, xlTextValues)
                If Err.Number = 0 Then                                                  'ci sono SOLO formule testuali
                    Set InRng = InRng.SpecialCells(xlCellTypeFormulas, xlTextValues)
                Else
                    Set InRng = Nothing                                                 'Non c'|fffd| nulla
                End If
            End If
            
            On Error GoTo Aborted
        End If
                
        If InRng Is Nothing Then
            Call AutoCalc(True)
            If lng = 0 Then
                MsgBox "Nessuna cella corrisponde ai criteri selezionati", vbExclamation, "Nessuna cella valida"
            Else
                MsgBox "No cell meets the selected criteria", vbExclamation, "No valid cell"
            End If
            Exit Sub
        End If
            
        '#' Attivo la finestra di avanzamento e setto contatore e massimo
        counter = 0
        countermax = InRng.Cells.CountLarge
        UProgress.SetDescription "Sto generando l'elenco..."
        Call ShowProgressBar
        
        For Each cell In InRng.Cells
        
            'Aumenta di 1 il contatore
            counter = counter + 1
                        
            If (IsEmpty(cell) = False And _
                IsError(cell) = False And _
                UniqueDict.exists(CStr(cell.Value)) = False) Then UniqueDict.Add CStr(cell.Value), cell.Value
                        
            '#' Aggiorna la barra di avanzamento
            Call UpdateProgressBar(counter, countermax)
            If ProgressAborted = 1 Then GoTo Aborted
            On Error GoTo Aborted
            
        Next cell
        
        'Chiude la finestra di avanzamento
        Unload UProgress
        
    End With
    
    On Error Resume Next
    If Me.optNewSheet = True Then
        Worksheets.Add After:=Worksheets(ActiveSheet.index)
        Set newWs = ActiveSheet
        newWs.Name = "ESK_UniqueList" & "_" & Format(Now, "yymmdd hhmmss")
        Set OutRng = newWs.Range("A1")
    Else
        Set OutRng = Range(Me.refOutRng)
    End If
    On Error GoTo Aborted
    
    'Scrivo l'elenco nel range di destinazione
    i = 0
    j = 0
    For Each key In UniqueDict.keys
        If Application.WorksheetFunction.IsNumber(UniqueDict(key)) = True Then
            OutRng.Offset(i, j) = key
        Else
            OutRng.Offset(i, j) = "'" & key
        End If
        
        If OutRng.Offset(i, j).address Like "*" & OutRng.Parent.Rows.Count Then
            i = 0
            j = j + 1
        Else
            i = i + 1
        End If
    Next key
    
    'Ordinamento
    If Me.chkSortList Then
        With OutRng.Parent.Sort
            .SortFields.Clear
            .SortFields.Add key:=OutRng, SortOn:=xlSortOnValues, Order:=IIf(Me.optAZ, xlAscending, xlDescending), DataOption:=xlSortTextAsNumbers
            .SetRange OutRng.reSize(i + 1, 1)
            .header = xlNo
            .MatchCase = False
            .Orientation = xlTopToBottom
            .SortMethod = xlPinYin
            .Apply
        End With
    End If
    
    '#' Riattiva aggiornamenti automatici
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub
Attribute VB_Name = "frmUpdateCheck"
Attribute VB_Base = "0{B3A4D4F5-6D43-44E2-BD76-2CC9D40248B9}{62B2BA6C-4BE7-4F22-84B2-20F08C55CFCE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Const DefaultHeight As Long = 200
Private Sub UserForm_Initialize()
    Dim checkInterval As Long
    
    Me.Height = DefaultHeight
    With Me.fraChangelog
        .ScrollBars = fmScrollBarsNone
        .ScrollHeight = .InsideHeight * 2
        .ScrollWidth = .InsideWidth
    End With
    
    If lng = 0 Then
        With Me.cbxAutocheck
            .AddItem "Ogni giorno"
            .AddItem "Una volta alla settimana"
            .AddItem "Una volta al mese"
            .AddItem "Mai"
        End With
    Else
        With Me.cbxAutocheck
            .AddItem "Every day"
            .AddItem "Once a week"
            .AddItem "Once a month"
            .AddItem "Never"
        End With
    End If
    
    checkInterval = GetSettings("AutoCheckInterval")
    Select Case checkInterval
        Case 0
            Me.cbxAutocheck.ListIndex = 0
        Case 7
            Me.cbxAutocheck.ListIndex = 1
        Case 30
            Me.cbxAutocheck.ListIndex = 2
        Case 99999
            Me.cbxAutocheck.ListIndex = 3
    End Select

    On Error Resume Next
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
        
    Call ShowUpdateResults

    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
End Sub

Private Sub ShowUpdateResults()
    Dim NewVersion As String
    Dim NewVersionBeta As String
    Dim Updated As String
    Dim Newer As String
    Dim UpdateError As String
    Dim CheckResult As String
    
    If lng = 0 Then
        NewVersion = "E' disponibile una nuova versione di ESK! Elenco delle ultime modifiche:"
        NewVersionBeta = "E' disponibile una nuova versione beta di ESK! Elenco delle ultime modifiche:"
        Updated = "Hai gi|fffd| la versione pi|fffd| aggiornata di ESK"
        Newer = "La versione installata |fffd| pi|fffd| recente dell'ultima release stabile disponibile. A breve sar|fffd| rilasciata una nuova versione ufficiale"
        UpdateError = "Si |fffd| verificato un errore nella ricerca dell'aggiornamento. Riprovare pi|fffd| tardi. In caso di mancata risoluzione, si prega di contattare l'autore (menu Impostazioni - Risorse online - Scrivi email)"
    Else
        NewVersion = "A new release of ESK is available!"
        NewVersionBeta = "A new beta release of ESK is available!"
        Updated = "You already have the latest ESK version installed"
        Newer = "The installed version is newer than the latest official release. Please check back soon for a new release"
        UpdateError = "An error occurred during the update check. Please try again later or contact the author (Settings - Online resources - Write email)"
    End If
    
    Call OnlineVersionCheck
    
    Me.lblAvailableND.Caption = esk_online_version & " (" & esk_online_date & ")"
    Me.lblAvailableBetaND.Caption = esk_online_version_beta & " (" & esk_online_date_beta & ")"
    Me.lblInstalledND.Caption = esk_installed_version & " (" & esk_installed_date & ")"
    
    If GetSettings("CheckBetaUpdate") = 0 Then
                
        If esk_installed_date = esk_online_date Then
            CheckResult = "Updated"
        ElseIf IsDate(esk_online_date) = False Then
            CheckResult = "Error"
        ElseIf esk_online_date > esk_installed_date Then
            CheckResult = "Older"
        Else
            CheckResult = "Newer"
        End If
           
    Else
        
        Me.lblAvailableBeta.visible = True
        Me.lblAvailableBetaND.visible = True
        Me.cmdDownloadBeta.visible = True
        
        If esk_online_date = esk_installed_date Then
            '#' Release ufficiale ha stessa data di versione installata: verifico se c'|fffd| una beta pi|fffd| aggiornata
            If IsDate(esk_online_date_beta) And esk_online_date_beta > esk_installed_date Then
                CheckResult = "Beta"
            Else
                CheckResult = "Updated"
            End If
        ElseIf IsDate(esk_online_date) And esk_online_date > esk_installed_date Then
            '#' Release ufficiale pi|fffd| recente di versione installata: verifico se c'|fffd| ANCHE una beta pi|fffd| aggiornata
            If IsDate(esk_online_date_beta) And esk_online_date_beta > esk_online_date Then
                CheckResult = "OlderBeta"
            Else
                CheckResult = "Older"
            End If
        ElseIf IsDate(esk_online_date_beta) And esk_online_date_beta > esk_installed_date Then
            '#' Release ufficiale pi|fffd| vecchia di versione installata; release beta pi|fffd| aggiornata
            CheckResult = "Beta"
        ElseIf IsDate(esk_online_date_beta) And esk_online_date_beta = esk_installed_date Then
            '#' Release ufficiale pi|fffd| vecchia di versione installata; release beta stessa data
            CheckResult = "Updated"
        Else
            CheckResult = "Error"
        End If
           
    End If
    
    Select Case CheckResult
        Case "Older" '#' Versione ufficiale pi|fffd| aggiornate di quella installata
            
            '#' Spostamento controlli
            Me.lblAvailable.Top = Me.lblAvailable.Top + 10
            Me.lblAvailableND.Top = Me.lblAvailableND.Top + 10
            Me.cmdClose.Top = Me.cmdClose.Top + 10
            Me.lblInstalled.Top = Me.lblInstalled.Top + 10
            Me.lblInstalledND.Top = Me.lblInstalledND.Top + 10
            Me.cmdDownload.Top = Me.cmdDownload.Top + 10
            
            '#' Visibilit|fffd| e formato controlli
            'ufficiale
            Me.lblAvailableND.Font.Bold = True
            Me.cmdDownload.visible = True
            'beta
            Me.lblAvailableBeta.visible = False
            Me.lblAvailableBetaND.visible = False
            Me.cmdDownloadBeta.visible = False
            
            
            Me.lblResponse.Caption = NewVersion
            Me.lblResponse.ForeColor = RGB(0, 128, 0)
            Me.lblChangelog = esk_changelog
            Me.lblChangelog.AutoSize = True
            Me.fraChangelog.ScrollHeight = Me.lblChangelog.Height + 10
            If Me.fraChangelog.Height > Me.lblChangelog.Height + 10 Then Me.fraChangelog.Height = Me.lblChangelog.Height + 20
            If Me.fraChangelog.Top + Me.lblChangelog.Height < 320 Then
                Me.Height = Me.fraChangelog.Top + Me.lblChangelog.Height + 80
                Me.fraChangelog.ScrollBars = fmScrollBarsNone
            Else
                Me.Height = 400
                Me.fraChangelog.ScrollBars = fmScrollBarsVertical
            End If
        
            If lng > 0 Then
                Me.Height = DefaultHeight
                Me.fraChangelog.visible = False
            End If
        
        Case "OlderBeta" '#' Versione ufficiale E BETA pi|fffd| aggiornate di quella installata

            '#' Visibilit|fffd| e formato controlli
            'ufficiale
            Me.lblAvailableND.Font.Bold = True
            Me.cmdDownload.visible = True
            'beta
            Me.lblAvailableBeta.visible = True
            Me.lblAvailableBetaND.visible = True
            Me.lblAvailableBetaND.Font.Bold = True
            Me.cmdDownloadBeta.visible = True
            
            Me.lblResponse.Caption = NewVersion
            Me.lblResponse.ForeColor = RGB(0, 128, 0)
            Me.lblChangelog = esk_changelog
            Me.lblChangelog.AutoSize = True
            Me.fraChangelog.ScrollHeight = Me.lblChangelog.Height + 10
            If Me.fraChangelog.Height > Me.lblChangelog.Height + 10 Then Me.fraChangelog.Height = Me.lblChangelog.Height + 20
            If Me.fraChangelog.Top + Me.lblChangelog.Height < 320 Then
                Me.Height = Me.fraChangelog.Top + Me.lblChangelog.Height + 80
                Me.fraChangelog.ScrollBars = fmScrollBarsNone
            Else
                Me.Height = 400
                Me.fraChangelog.ScrollBars = fmScrollBarsVertical
            End If
        
            If lng > 0 Then
                Me.Height = DefaultHeight
                Me.fraChangelog.visible = False
            End If
        
        Case "Beta"
            '#' Visibilit|fffd| e formato controlli
            'ufficiale
            Me.cmdDownload.visible = False
            'beta
            Me.lblAvailableBeta.visible = True
            Me.lblAvailableBetaND.visible = True
            Me.lblAvailableBetaND.Font.Bold = True
            Me.cmdDownloadBeta.visible = True
            
            Me.lblResponse.Caption = NewVersionBeta
            Me.lblResponse.ForeColor = RGB(255, 128, 0)
            Me.lblChangelog = esk_changelog_beta
            Me.lblChangelog.AutoSize = True
            Me.fraChangelog.ScrollHeight = Me.lblChangelog.Height + 10
            If Me.fraChangelog.Height > Me.lblChangelog.Height + 10 Then Me.fraChangelog.Height = Me.lblChangelog.Height + 20
            If Me.fraChangelog.Top + Me.lblChangelog.Height < 320 Then
                Me.Height = Me.fraChangelog.Top + Me.lblChangelog.Height + 80
                Me.fraChangelog.ScrollBars = fmScrollBarsNone
            Else
                Me.Height = 400
                Me.fraChangelog.ScrollBars = fmScrollBarsVertical
            End If
            
            If lng > 0 Then
                Me.Height = DefaultHeight
                Me.fraChangelog.visible = False
            End If
        
        Case "Updated"
            '#' Posizione controlli
            Me.lblAvailable.Top = Me.lblAvailable.Top + 10
            Me.lblAvailableND.Top = Me.lblAvailableND.Top + 10
            Me.cmdClose.Top = Me.cmdClose.Top + 10
            Me.lblInstalled.Top = Me.lblInstalled.Top + 10
            Me.lblInstalledND.Top = Me.lblInstalledND.Top + 10
            Me.cmdDownload.Top = Me.cmdDownload.Top + 10
        
            '#' Visibilit|fffd| e formato controlli
            'ufficiale
            Me.cmdDownload.visible = False
            'beta
            Me.lblAvailableBeta.visible = False
            Me.lblAvailableBetaND.visible = False
            Me.cmdDownloadBeta.visible = False
            
            Me.lblResponse.Caption = Updated
            Me.Height = DefaultHeight
            Me.fraChangelog.visible = False
        
        Case "Newer"
            '#' Posizione controlli
            Me.lblAvailable.Top = Me.lblAvailable.Top + 10
            Me.lblAvailableND.Top = Me.lblAvailableND.Top + 10
            Me.cmdClose.Top = Me.cmdClose.Top + 10
            Me.lblInstalled.Top = Me.lblInstalled.Top + 10
            Me.lblInstalledND.Top = Me.lblInstalledND.Top + 10
            Me.cmdDownload.Top = Me.cmdDownload.Top + 10
        
            '#' Visibilit|fffd| e formato controlli
            'ufficiale
            Me.cmdDownload.visible = False
            'beta
            Me.lblAvailableBeta.visible = False
            Me.lblAvailableBetaND.visible = False
            Me.cmdDownloadBeta.visible = False
            
            Me.lblResponse.Caption = Newer
            Me.Height = DefaultHeight
            Me.fraChangelog.visible = False
        
        Case "Error"
            '#' Posizione controlli
            Me.lblAvailable.Top = Me.lblAvailable.Top + 10
            Me.lblAvailableND.Top = Me.lblAvailableND.Top + 10
            Me.cmdClose.Top = Me.cmdClose.Top + 10
            Me.lblInstalled.Top = Me.lblInstalled.Top + 10
            Me.lblInstalledND.Top = Me.lblInstalledND.Top + 10
            Me.cmdDownload.Top = Me.cmdDownload.Top + 10
        
            '#' Visibilit|fffd| e formato controlli
            'ufficiale
            Me.lblAvailableND.visible = False
            Me.cmdDownload.visible = False
            'beta
            Me.lblAvailableBeta.visible = False
            Me.lblAvailableBetaND.visible = False
            Me.cmdDownloadBeta.visible = False
            
            Me.lblResponse.Caption = UpdateError
            Me.lblResponse.AutoSize = True
            Me.Height = DefaultHeight
            Me.fraChangelog.visible = False
    End Select
        
    Me.lblAutocheck.Top = Me.InsideHeight - 18
    Me.cbxAutocheck.Top = Me.InsideHeight - 23
    On Error GoTo 0
        
End Sub

Private Sub cbxAutocheck_DropButtonClick()
    Select Case Me.cbxAutocheck.ListIndex
        Case 0
            Call UpdateConfigFile("AutoCheckInterval", 0)
        Case 1
            Call UpdateConfigFile("AutoCheckInterval", 7)
        Case 2
            Call UpdateConfigFile("AutoCheckInterval", 30)
        Case 3
            Call UpdateConfigFile("AutoCheckInterval", 99999)
    End Select

End Sub

Private Sub cmdDownload_Click()
    Call OpenUrl("http://www.excelswissknife.com/download", 1)
End Sub

Private Sub cmdDownloadBeta_Click()
    Call OpenUrl("http://www.excelswissknife.com/download", 1)
End Sub

Private Sub cmdClose_Click()
    Unload Me
End Sub

Private Sub UserForm_Terminate()
    esk_online_version = ""
    esk_online_version_beta = ""
    esk_online_date = 0
    esk_online_date_beta = 0
    esk_installed_version = ""
    esk_installed_date = 0
    esk_installed_version_beta = ""
    esk_installed_date_beta = 0
    esk_changelog = ""
    esk_changelog_beta = ""
End Sub
Attribute VB_Name = "frmViewSettings"
Attribute VB_Base = "0{8B0B0717-D608-40C7-B00B-83156B6B9357}{0B1D6D12-36CD-4F5F-82F0-EF31B126F7C1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit
Dim DisableEvents As Boolean

Private Sub UserForm_Initialize()
    
    Call ScaleForm(Me)

    Set btnColl = CommonButtons(Me)
    
    Call SaveOptions(Me)
    If GetSettings("LoadSettings") = 1 Then Call LoadOptions(Me, False)
    
    DisableEvents = True
    
    Call ListSheets
        
    DisableEvents = False
    
    'Popolo la combobox zoom
    With Me.cbxZoom
        .AddItem "200%  "
        .AddItem "100%  "
        .AddItem "75%  "
        .AddItem "50%  "
        .AddItem "25%  "
        .AddItem "Custom  "
    
        Select Case ActiveWindow.Zoom
            Case 200
                .ListIndex = 0
            Case 100
                .ListIndex = 1
            Case 75
                .ListIndex = 2
            Case 50
                .ListIndex = 3
            Case 25
                .ListIndex = 4
            Case Else
                .ListIndex = 5
                Me.txtZoom = ActiveWindow.Zoom
        End Select
    End With
    
    
    'Popolo la combobox viewmode
    With Me.cbxViewMode
        If lng = 0 Then
            .AddItem "Normale"
            .AddItem "Layout di stampa"
            .AddItem "Interruzioni di pagina"
        Else
            .AddItem "Normal"
            .AddItem "Print layout"
            .AddItem "Page breaks"
        End If
        
        Select Case ActiveWindow.View
            Case xlNormalView
                .ListIndex = 0
            Case xlPageLayoutView
                .ListIndex = 1
            Case xlPageBreakPreview
                .ListIndex = 2
        End Select
    End With
    
    On Error Resume Next
    Me.refPosition = Cells(ActiveWindow.ScrollRow, ActiveWindow.ScrollColumn).address
    On Error GoTo 0
    
    If lng > 0 Then Call TranslateForm(Me)
    If InStr(1, Me.Caption, ProgramName) = 0 Then Me.Caption = Me.Caption & ProgramName
    
    Call GoodToGo(Me)

End Sub

Private Sub ListSheets()
        
    If ActiveWorkbook Is Nothing Or ActiveWorkbook.Name = ThisWorkbook.Name Then Exit Sub
    
    Me.lbxSheets.Clear
    
    For Each ws In ActiveWorkbook.Worksheets
        If Not ws.Name = "ESK_Backup" And _
           ws.visible = xlSheetVisible And _
           UCase(ws.Name) Like "*" & UCase(Me.txtFilterList) & "*" Then
                Me.lbxSheets.AddItem ws.Name
                If IsSelected(ws.Name) Or ActiveWindow.SelectedSheets.Count = 1 Then Me.lbxSheets.Selected(Me.lbxSheets.ListCount - 1) = True
        End If
    Next ws

End Sub

Private Sub txtFilterList_Change()
    Call ListSheets
End Sub

Private Sub refPosition_Change()
    On Error Resume Next
    Me.refPosition = Range(Mid(Replace(Me.refPosition, ";", ","), InStr(1, Me.refPosition, "!") + 1)).Cells(1, 1).address
    On Error GoTo 0
End Sub

Private Sub chkAllNone_Change()
    DisableEvents = True
    
    Dim i As Long
    
    For i = 0 To Me.lbxSheets.ListCount - 1
        Me.lbxSheets.Selected(i) = Me.chkAllNone
    Next i
    
    DisableEvents = False
    
    Call GoodToGo(Me)
End Sub

Private Sub lbxSheets_Change()
    If DisableEvents = False Then Call GoodToGo(Me)
End Sub

Private Sub chkPosition_Change()
    Me.refPosition.Enabled = Me.chkPosition
    If Me.chkPosition = True Then Me.refPosition.SetFocus
    Call GoodToGo(Me)
End Sub

Private Sub chkZoom_Change()
    Me.cbxZoom.Enabled = Me.chkZoom
    Me.txtZoom.Enabled = Me.chkZoom
    Me.spbZoom.Enabled = Me.chkZoom
    If Me.chkZoom = True Then Me.cbxZoom.SetFocus
    Call GoodToGo(Me)
End Sub

Private Sub chkViewMode_Change()
    Me.cbxViewMode.Enabled = Me.chkViewMode
    If Me.chkViewMode = True Then Me.cbxViewMode.SetFocus
    Call GoodToGo(Me)
End Sub

Private Sub cbxZoom_Change()
    Select Case Me.cbxZoom.ListIndex
        Case 5
            Me.txtZoom.visible = True
            Me.spbZoom.visible = True
        Case Else
            Me.txtZoom.visible = False
            Me.spbZoom.visible = False
    End Select
End Sub

Private Sub spbZoom_SpinDown()
    Me.txtZoom = Me.spbZoom
End Sub

Private Sub spbZoom_SpinUp()
    Me.txtZoom = Me.spbZoom
End Sub
Private Sub txtZoom_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then KeyAscii = 0
End Sub
Private Sub txtZoom_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Val(Me.txtZoom) > Me.spbZoom.Max Then Me.txtZoom = Me.spbZoom.Max
    If Val(Me.txtZoom) < Me.spbZoom.Min Then Me.txtZoom = Me.spbZoom.Min
    Me.spbZoom = Me.txtZoom
    Me.txtZoom.ControlTipText = Me.txtZoom.Text & "%"
End Sub

Private Sub txtZoom_Change()
    Me.txtZoom.ControlTipText = Me.txtZoom.Text & "%"
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim SelSheets As New Collection
    Dim aWs As Worksheet
    Dim i As Long
    
    With Me
        On Error Resume Next
        If Me.chkPosition = True Then
            If TypeName(Range(Replace(.refPosition, ";", ","))) <> "Range" Then
                MsgBox TranslateCnst("NoRange"), vbExclamation, TranslateCnst("NoRangeTitle")
                Err.Clear
                Exit Sub
            End If
        End If
        On Error GoTo Aborted
    
        .Hide
        
    End With
    
    '#' Popolo la collection dei fogli selezionati
    For i = 0 To Me.lbxSheets.ListCount - 1
        If Me.lbxSheets.Selected(i) = True Then SelSheets.Add Worksheets(Me.lbxSheets.List(i))
    Next i
    
    
    Call AutoCalc(False)

    '#' Attivo la finestra di avanzamento e setto contatore e massimo
    counter = 0
    countermax = SelSheets.Count
    UProgress.SetDescription "Sto personalizzando la visualizzazione di " & countermax & IIf(countermax = 1, " foglio...", " fogli...")
    Call ShowProgressBar
    
    Set aWs = ActiveSheet
    
    For Each ws In SelSheets
        
        '#' Aumenta di 1 il contatore
        counter = counter + 1
            
        If ws.ProtectContents = False Then
            
            ws.Activate
            
            If Me.chkPosition = True Then
                ActiveWindow.ScrollRow = Range(Me.refPosition).Cells(1, 1).Row
                ActiveWindow.ScrollColumn = Range(Me.refPosition).Cells(1, 1).Column
            End If
            
            If Me.chkZoom = True Then
                Select Case Me.cbxZoom.ListIndex
                    Case 5
                        ActiveWindow.Zoom = CLng(Me.txtZoom.Text)
                    Case Else
                        ActiveWindow.Zoom = CLng(Trim(Replace(Me.cbxZoom, "%", "")))
                End Select
            End If
            
            If Me.chkViewMode = True Then
                Select Case Me.cbxViewMode.ListIndex
                    Case 0
                        ActiveWindow.View = xlNormalView
                    Case 1
                        ActiveWindow.View = xlPageLayoutView
                    Case 2
                        ActiveWindow.View = xlPageBreakPreview
                End Select
            End If
            
            If Me.optGridY = True Then
                ActiveWindow.DisplayGridlines = True
            End If
            If Me.optGridN = True Then
                ActiveWindow.DisplayGridlines = False
            End If
            
            If Me.optHeadersY = True Then
                ActiveWindow.DisplayHeadings = True
            End If
            If Me.optHeadersN = True Then
                ActiveWindow.DisplayHeadings = False
            End If
            
        End If 'Foglio protetto
        
        '#' Aggiorna la barra di avanzamento
        Call UpdateProgressBar(counter, countermax)
        DoEvents
        If ProgressAborted = 1 Then GoTo Aborted
        On Error GoTo Aborted
        
    Next ws
        
    aWs.Activate
    
    Unload UProgress
    
    Call AutoCalc(True)
    
    Exit Sub
    
Aborted:
    Call CanceledProcedure
    
End Sub


Private Sub UserForm_Terminate()
    Call SaveOptions(Me, False)

    Call Cleanup
End Sub


Attribute VB_Name = "frmWelcomePortable"
Attribute VB_Base = "0{8564D308-E6F2-456D-90C7-D5D2F77FEBFF}{5F63B2F7-04AF-478D-B145-2C66B95A73C7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Option Explicit

Dim bCntDown As Boolean

Private Sub UserForm_Initialize()
    If ActiveWorkbook Is Nothing Then Workbooks.Add
    bCntDown = True
End Sub

Private Sub UserForm_Activate()
    If lng <> 0 Then
        Me.lblWelcome.Caption = "Thank you for downloading the portable version of Excel Swiss Knife!" & _
                                vbNewLine & vbNewLine & _
                                "You can find the tools offered by the program in the Excel menu bar, in a new tab created at the end of the pre-existing ones:" & _
                                 vbNewLine & vbNewLine & _
                                 vbNewLine & vbNewLine & _
                                 vbNewLine & vbNewLine & _
                                 vbNewLine & vbNewLine & _
                                "This version contains all the features of the installed version, but does not write any other settings file on the hard disk, and does not change any system settings: the menu of ESK functions will disappear from the Excel menu bar at the end of the working session." & _
                                 vbNewLine & vbNewLine & _
                                "In the hope that my program can help you, I encourage you to contact me at info@excelswissknife.com for information, support requests, suggestions and more!" & vbNewLine & "Thank you :-)"
                                
        Me.lblAuthor.Caption = "Enrico Galli, author of the program"
        Me.lblHint.Caption = "Click on form to stop"
    End If
    Call CountDown
End Sub

Private Sub cmdClose_Click()
    Unload Me
End Sub

Private Sub UserForm_Click()
    bCntDown = False
    Me.lblHint.visible = False
End Sub

Private Sub lblWelcome_Click()
    bCntDown = False
    Me.lblHint.visible = False
End Sub

Private Sub imgLogo_Click()
    bCntDown = False
    Me.lblHint.visible = False
End Sub

Private Sub CountDown()
    Dim i As Long
        
    i = 10
    Do While i > 0
        If bCntDown = True Then
            Me.cmdClose.Caption = IIf(lng = 0, "Chiudi (" & i & ")", "Close (" & i & ")")
            DoEvents
            i = i - 1
            Aspetta (1)
        Else
            Exit Do
        End If
    Loop
        
    If bCntDown = True Then
        Unload Me
    Else
        Me.cmdClose.Caption = IIf(lng = 0, "Chiudi", "Close")
    End If
End Sub

Sub Aspetta(secondi As Long)
Dim time As Date
Const ms As Double = 0.000000011574

time = Now + (secondi * 900 * ms)
    Do Until Now >= time
        DoEvents
    Loop
End Sub
Attribute VB_Name = "udfCERCAVERT_SIMILE"
Attribute VB_Base = "0{92876071-D5EB-46E7-98A9-E4D228BE6A4D}{91722148-9F9C-4FDD-A5AC-1E7A7C8ADF28}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refValue_Enter()
    Me.lblArgumentName.Caption = Me.lblValue.Caption
    Me.lblArgumentDesc.Caption = "Il valore da ricercare"
    Me.lblArgumentName.Font.Bold = True
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "La matrice su cui effettuare la ricerca"
    Me.lblArgumentName.Font.Bold = True
End Sub

Private Sub txtColRis_Enter()
    Me.lblArgumentName.Caption = Me.lblColRis.Caption
    Me.lblArgumentDesc.Caption = "L'indice di colonna del valore da restituire"
    Me.lblArgumentName.Font.Bold = True
End Sub

Private Sub txtSign_Enter()
    Me.lblArgumentName.Caption = Me.lblSign.Caption
    Me.lblArgumentDesc.Caption = "La lunghezza minima di una parola per essere considerata significativa"
    Me.lblArgumentName.Font.Bold = False
End Sub

Private Sub txtCVal_Enter()
    Me.lblArgumentName.Caption = Me.lblCVal.Caption
    Me.lblArgumentDesc.Caption = "L'indice della colonna di ricerca"
    Me.lblArgumentName.Font.Bold = False
End Sub

Private Sub txtSign_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub txtColRis_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub txtCVal_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refValue)) <> "Range" Or _
            CLng(.txtColRis) = 0 Or _
            .txtColRis = "" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refValue.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_CERCAVERT_SIMILE(" & strAddressCell & "," & strAddressRange & _
                                        "," & Me.txtColRis & _
                                        "," & Me.txtCVal & _
                                        "," & Me.txtSign & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Attribute VB_Name = "udfCONCATENA_INTERVALLI"
Attribute VB_Base = "0{14323459-1C1E-4A31-82AC-5A083DEC8015}{3916AD75-0503-439B-BAA8-BEC60AD26252}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    With Me.cbxEmpty
        If lng = 0 Then
            .AddItem "FALSO"
            .AddItem "VERO"
        Else
            .AddItem "FALSE"
            .AddItem "TRUE"
        End If
        .ListIndex = 0
    End With
    
    Call ScaleForm(Me)
End Sub

Private Sub txtSeparator_Enter()
    Me.lblArgumentName.Caption = Me.lblSeparator.Caption
    Me.lblArgumentName.Font.Bold = False
    Me.lblArgumentDesc.Caption = "Il testo di separazione da inserire tra i valori dell'intervallo (default: """")"
End Sub

Private Sub cbxEmpty_Enter()
    Me.lblArgumentName.Caption = Me.lblEmpty.Caption
    Me.lblArgumentName.Font.Bold = True
    Me.lblArgumentDesc.Caption = "Include o meno le celle vuote nel concatenamento (default: no)"
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentName.Font.Bold = True
    Me.lblArgumentDesc.Caption = "L'intervallo o gli intervalli di celle da concatenare"
End Sub

Private Sub cmdOK_Click()
    Dim sep As String
    Dim strAddress As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(Me.refRange.Text, ";", ","))) <> "Range" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    sep = Me.txtSeparator
    strAddress = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_CONCATENA_INTERVALLI(""" & sep & """, " & Me.cbxEmpty.ListIndex & ", " & strAddress & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Attribute VB_Name = "udfCONTA_SE_COLORE"
Attribute VB_Base = "0{B23C4DB3-9D19-49C5-A262-ADF86D0FDBA3}{6E1BA30C-E8B2-4ABE-9E28-CA14CA1776EC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "L'intervallo di celle da contare"
End Sub

Private Sub refCell_Enter()
    Me.lblArgumentName.Caption = Me.lblCell.Caption
    Me.lblArgumentDesc.Caption = "La cella esempio, dello stesso colore delle celle che si vogliono contare"
End Sub

Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refCell)) <> "Range" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refCell.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_CONTA_SE_COLORE(" & strAddressRange & "," & strAddressCell & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub


Attribute VB_Name = "udfCONTA_SE_FONT"
Attribute VB_Base = "0{E4831915-F60A-43A9-AA41-EA5F161A6B7C}{8423CEEA-F6D4-4278-9EDC-3FE0C01E53F9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "L'intervallo di celle da contare"
End Sub

Private Sub refCell_Enter()
    Me.lblArgumentName.Caption = Me.lblCell.Caption
    Me.lblArgumentDesc.Caption = "La cella esempio, dello stesso formato carattere delle celle che si vogliono contare"
End Sub

Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refCell)) <> "Range" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refCell.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_CONTA_SE_FONT(" & strAddressRange & "," & strAddressCell & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfESTRAI_HYPERLINK"
Attribute VB_Base = "0{A9E2F6BB-A852-4A61-AB1A-084742253B70}{4D2A911F-084A-4D75-B0C0-291945F6B085}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentName.Font.Bold = True
    Me.lblArgumentDesc.Caption = "La cella da cui estrarre il nome o l'indirizzo del collegamento"
End Sub

Private Sub txtLink_Enter()
    Me.lblArgumentName.Caption = Me.lblLink.Caption
    Me.lblArgumentName.Font.Bold = False
    Me.lblArgumentDesc.Caption = "0 o omesso se si vuole estrarre l'indirizzo, 1 per il nome (opzionale)"
End Sub

Private Sub txtLink_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 49 Then KeyAscii = 0
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Then
            MsgBox "Attenzione: riferimento di cella non validi. Riprovare", vbExclamation, "Errore: intervallo non valido"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_ESTRAI_HYPERLINK(" & strAddressRange & IIf(Me.txtLink <> "", "," & Me.txtLink, "") & ")"
    
    Unload Me
End Sub

Attribute VB_Name = "udfESTRAI_NUMERI"
Attribute VB_Base = "0{569F5FB0-E44E-4186-BC2C-856DBF8538B4}{3DB6E7D2-16F8-42C7-B655-B41DA70952AC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentName.Font.Bold = True
    Me.lblArgumentDesc.Caption = "Il valore da cui estrarre i soli numeri (0-9)"
End Sub

Private Sub cmdOK_Click()
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Then
            MsgBox "Attenzione: riferimento di cella non validi. Riprovare", vbExclamation, "Errore: intervallo non valido"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_ESTRAI_NUMERI(" & strAddressRange & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfGINI"
Attribute VB_Base = "0{1292B770-4F1A-4E87-B4A8-A0E543D670A2}{BA818F84-1AFD-47E4-8F37-B261AF9DBF3F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''


Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentName.Font.Bold = True
    Me.lblArgumentDesc.Caption = "L'intervallo di celle su cui calcolare l'indice"
End Sub

Private Sub cmdOK_Click()
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_GINI(" & strAddressRange & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfMEDIA_MOBILE"
Attribute VB_Base = "0{6FE8AEA2-A0D9-42F6-B18B-9209D0E5CCC6}{885D8CB6-EA6A-4D64-B0A4-E12C06BA365D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refValue_Enter()
    Me.lblArgumentName.Caption = Me.lblValue.Caption
    Me.lblArgumentDesc.Caption = "Il valore finale del sottoinsieme di elementi su cui calcolare la media"
End Sub
Private Sub txtClass_Enter()
    Me.lblArgumentName.Caption = Me.lblClass.Caption
    Me.lblArgumentDesc.Caption = "La classe (numero di elementi) su cui calcolare la media mobile"
End Sub
Private Sub txtClass_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub
Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "L'intervallo dei valori (disposti su un'unica colonna)"
End Sub
Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refValue)) <> "Range" Or _
            Range(.refRange).Columns.Count > 1 Or _
            IsNumeric(.txtClass) = False Or _
            .txtClass = "" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refValue.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_MEDIA_MOBILE(" & strAddressCell & "," & strAddressRange & "," & Me.txtClass & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfMEDIA_MOBILE_SIMMETRICA"
Attribute VB_Base = "0{5F29091A-8B32-4917-B83B-A60AA5D87802}{EEB29861-9A30-4E27-BD25-E52F471C1520}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refValue_Enter()
    Me.lblArgumentName.Caption = Me.lblValue.Caption
    Me.lblArgumentDesc.Caption = "Il valore centrale del sottoinsieme di elementi su cui calcolare la media"
End Sub
Private Sub txtClass_Enter()
    Me.lblArgumentName.Caption = Me.lblClass.Caption
    Me.lblArgumentDesc.Caption = "La classe (numero di elementi) su cui calcolare la media mobile"
End Sub
Private Sub txtClass_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub
Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "L'intervallo dei valori (disposti su un'unica colonna)"
End Sub
Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refValue)) <> "Range" Or _
            Range(.refRange).Columns.Count > 1 Or _
            IsNumeric(.txtClass) = False Or _
            .txtClass = "" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refValue.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_MEDIA_MOBILE_SIMMETRICA(" & strAddressCell & "," & strAddressRange & "," & Me.txtClass & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfNORMALIZZA_MINMAX"
Attribute VB_Base = "0{12D86C5A-D39A-4918-8710-9BEF0B5F9FE9}{4AE496A6-5B16-4332-AE74-CA1B7E258D54}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refValue_Enter()
    Me.lblArgumentName.Caption = Me.lblValue.Caption
    Me.lblArgumentDesc.Caption = "Il valore da normalizzare"
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "L'intervallo da normalizzare (di cui fa parte il valore)"
End Sub

Private Sub txtMin_Enter()
    Me.lblArgumentName.Caption = Me.lblMin.Caption
    Me.lblArgumentDesc.Caption = "Il valore minimo della nuova scala"
End Sub

Private Sub txtMax_Enter()
    Me.lblArgumentName.Caption = Me.lblMax.Caption
    Me.lblArgumentDesc.Caption = "Il valore massimo della nuova scala"
End Sub

Private Sub txtMin_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = 44 Or KeyAscii = 46 Then
        KeyAscii = Asc(dSep)
    ElseIf KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub txtMax_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = 44 Or KeyAscii = 46 Then
        KeyAscii = Asc(dSep)
    ElseIf KeyAscii < 48 Or KeyAscii > 57 Then
        KeyAscii = 0
    End If
End Sub

Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refValue)) <> "Range" Or _
            IsNumeric(.txtMin) = False Or _
            IsNumeric(.txtMax) = False Or _
            .txtMin = "" Or _
            .txtMax = "" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refValue.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_NORMALIZZA_MINMAX(" & strAddressCell & "," & strAddressRange & _
                                                "," & Replace(Me.txtMin, ",", ".") & _
                                                "," & Replace(Me.txtMax, ",", ".") & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfORDINE_PAROLE"
Attribute VB_Base = "0{827F6ED1-1FAA-4187-B7BF-1B5F9B14C362}{AD0FB930-85A0-4A1F-8F5B-17FA369E9161}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refValue_Enter()
    Me.lblArgumentName.Caption = Me.lblValue.Caption
    Me.lblArgumentDesc.Caption = "La stringa da riordinare"
End Sub

Private Sub txtOrd_Enter()
    Me.lblArgumentName.Caption = Me.lblOrd.Caption
    Me.lblArgumentDesc.Caption = "Il nuovo ordine da dare alle parole, usando il carattere ""|"" come separatore dei numeri oppure a-z o z-a per ordine alfabetico crescente/decrescente"
End Sub

Private Sub txtOrd_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If (KeyAscii < 48 Or KeyAscii > 57) And _
        KeyAscii <> 45 And _
        KeyAscii <> 65 And _
        KeyAscii <> 90 And _
        KeyAscii <> 97 And _
        KeyAscii <> 122 And _
        KeyAscii <> 124 Then KeyAscii = 0
End Sub

Private Sub txtSep_Enter()
    Me.lblArgumentName.Caption = Me.lblSep.Caption
    Me.lblArgumentDesc.Caption = "Il separatore delle parole nella stringa originale"
End Sub

Private Sub cmdOK_Click()
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refValue)) <> "Range" Or _
            .txtOrd = "" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    If Me.txtSep = "" Then Me.txtSep = " "
    If Left(Me.txtOrd, 1) <> """" Then Me.txtOrd = """" & Me.txtOrd & """"
    Me.txtSep = """" & Me.txtSep & """"
    strAddressRange = Replace(Replace(Me.refValue.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_ORDINE_PAROLE(" & strAddressRange & "," & Me.txtOrd & "," & Me.txtSep & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfSOMMA_SE_COLORE"
Attribute VB_Base = "0{4AAA87ED-FF78-483D-A48B-5641C89CC284}{C14D8888-CBAA-44DA-8B40-5FD17F315CA7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "L'intervallo di celle da sommare"
End Sub

Private Sub refCell_Enter()
    Me.lblArgumentName.Caption = Me.lblCell.Caption
    Me.lblArgumentDesc.Caption = "La cella esempio, dello stesso colore delle celle che si vogliono sommare"
End Sub

Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refCell)) <> "Range" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refCell.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_SOMMA_SE_COLORE(" & strAddressRange & "," & strAddressCell & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfSOMMA_SE_FONT"
Attribute VB_Base = "0{90EEC160-084C-445C-8232-D9598B3047F6}{FF105208-A0F0-4189-A08B-B8A84EFD339A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentDesc.Caption = "L'intervallo di celle da sommare"
End Sub

Private Sub refCell_Enter()
    Me.lblArgumentName.Caption = Me.lblCell.Caption
    Me.lblArgumentDesc.Caption = "La cella esempio, con lo stesso formato carattere delle celle che si vogliono sommare"
End Sub

Private Sub cmdOK_Click()
    Dim strAddressCell As String
    Dim strAddressRange As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(.refRange)) <> "Range" Or _
            TypeName(Range(.refCell)) <> "Range" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
    
    strAddressCell = Replace(Replace(Me.refCell.Text, ";", ","), ActiveSheet.Name & "!", "")
    strAddressRange = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
    
    ActiveCell.Formula = "=ESK_SOMMA_SE_FONT(" & strAddressRange & "," & strAddressCell & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Attribute VB_Name = "udfSTRINGACOMUNE"
Attribute VB_Base = "0{A18A9806-DF82-45F2-870E-3C69CBC72D26}{FA7C1D06-9233-4F40-992A-4809D594BBFE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'''    #############################################################################    '''
'''                                                                                     '''
'''    Excel Swiss Knife - Free add-in for Microsoft Excel 2007-2019 / 365              '''
'''    Copyright (C) 2017-19  Enrico Galli                                              '''
'''                                                                                     '''
'''    This program is free software: you can redistribute it and/or modify             '''
'''    it under the terms of the GNU General Public License as published by             '''
'''    the Free Software Foundation, either version 3 of the License, or                '''
'''    (at your option) any later version.                                              '''
'''                                                                                     '''
'''    This program is distributed in the hope that it will be useful,                  '''
'''    but WITHOUT ANY WARRANTY; without even the implied warranty of                   '''
'''    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                    '''
'''    GNU General Public License for more details.                                     '''
'''                                                                                     '''
'''    You should have received a copy of the GNU General Public License                '''
'''    along with this program.  If not, see <http://www.gnu.org/licenses/>.            '''
'''                                                                                     '''
'''    You are welcome to contact the author via email: info@excelswissknife.com        '''
'''                                                                                     '''
'''    #############################################################################    '''

Private Sub UserForm_Initialize()
    Call ScaleForm(Me)
End Sub

Private Sub refRange_Enter()
    Me.lblArgumentName.Caption = Me.lblRange.Caption
    Me.lblArgumentName.Font.Bold = True
    Me.lblArgumentDesc.Caption = "Uno o pi|fffd| intervalli di celle da verificare"
End Sub

Private Sub cmdOK_Click()
    Dim strAddress As String
    
    With Me
        On Error Resume Next
        If TypeName(Range(Replace(Me.refRange.Text, ";", ","))) <> "Range" Then
            MsgBox "Attenzione: dati non validi o numero di argomenti insufficiente. Riprovare", vbExclamation, "Errore: dati non validi"
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    End With
        
    strAddress = Replace(Replace(Me.refRange.Text, ";", ","), ActiveSheet.Name & "!", "")
        
    ActiveCell.Formula = "=ESK_STRINGACOMUNE(" & strAddress & ")"
    
    Unload Me
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub


' InQuest injected base64 decoded content
' *exX
' *ey'
' ^V+"nW
' x+jwb
' *exX
' ^V+"nW
' x"{e1
' ~`ZrD

INQUEST-PP=macro
