Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
Dim Antwort As Integer
On Error Resume Next
Schutz False

If Dir(Range("Path_W") & "Automatic_Deutschland", vbDirectory) <> "" Then
    Range("Path_Root").FormulaR1C1 = "=Path_W"
Else
    Range("Path_Root").FormulaR1C1 = "=Path_T"
End If

If Dir(Range("Dir_W"), vbDirectory) <> "" Then
    Range("Dir_DB").FormulaR1C1 = "=Dir_W"
Else
    Range("Dir_DB").FormulaR1C1 = "=Dir_T"
End If


Zeilen_einstellen False

If Sheets(1).Range("AU_Nr") = "" Then
    Sheets(1).Range("PN_Datum") = Date
    ActiveWindow.Caption = App_Name
End If

If Ist_Extern() Then
'Laufzeitpr|fffd|fung
        If Sheets("Param").Range("Rest_Tage") < 0 Then
            Antwort = MsgBox(Range("Rest_Tage_Text") _
            & vbCrLf _
            & "Das Programm wird beendet." _
            , vbExclamation + IIf(Ist_Admin(), vbOKCancel, vbOKOnly), App_Name)
            If Antwort = vbOK Then WB_Close
        End If
End If

Application.CalculateFull
If Not DB_available(True) Then
    'Sheets("Param").Range("DB_Sync_JN") = False
End If

DB_Controls_setzen

Schutz True

If Not System_ok() Then
    frmSettings.Show
End If
End Sub
Attribute VB_Name = "Tabelle01"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "Adr_import, 21, 0, MSForms, CommandButton"
Attribute VB_Control = "Sign1, 23, 1, MSForms, CommandButton"
Attribute VB_Control = "ResetC, 24, 2, MSForms, CommandButton"
Attribute VB_Control = "Sign2, 30, 3, MSForms, CommandButton"
Attribute VB_Control = "CompressC, 45, 4, MSForms, CommandButton"
Attribute VB_Control = "Page_addC, 33, 5, MSForms, CommandButton"
Attribute VB_Control = "BerechnungC, 52, 6, MSForms, CommandButton"
Attribute VB_Control = "CopyC, 71, 7, MSForms, CommandButton"
Attribute VB_Control = "Adr_export, 153, 8, MSForms, CommandButton"
Attribute VB_Control = "ZA_copy, 147, 9, MSForms, CommandButton"
Attribute VB_Control = "InsertC, 100, 10, MSForms, CommandButton"
Attribute VB_Control = "DeleteC, 101, 11, MSForms, CommandButton"
Attribute VB_Control = "ClearC, 104, 12, MSForms, CommandButton"
Attribute VB_Control = "csv_ExportC, 115, 13, MSForms, CommandButton"
Attribute VB_Control = "csv_ImportC, 120, 14, MSForms, CommandButton"
Attribute VB_Control = "FinishC, 134, 15, MSForms, CommandButton"
Attribute VB_Control = "CloseC, 135, 16, MSForms, CommandButton"
Attribute VB_Control = "Kopfdaten, 166, 17, MSForms, ToggleButton"
Attribute VB_Control = "P_AktivC, 187, 18, MSForms, ToggleButton"
Attribute VB_Control = "PB_JN, 197, 19, MSForms, ToggleButton"
Attribute VB_Control = "DB_Del_JNc, 329, 20, MSForms, CheckBox"
Attribute VB_Control = "DB_Query, 296, 21, MSForms, CommandButton"
Attribute VB_Control = "DB_Add_JNc, 232, 22, MSForms, CheckBox"
Attribute VB_Control = "DB_Upd_JNc, 233, 23, MSForms, CheckBox"
Attribute VB_Control = "DB_Sync, 234, 24, MSForms, CommandButton"
Attribute VB_Control = "DB_New_JNc, 235, 25, MSForms, CheckBox"
Attribute VB_Control = "DB_ImportC, 495, 26, MSForms, CommandButton"
Attribute VB_Control = "Komp_NrC, 504, 27, MSForms, CommandButton"
Option Explicit
Option Compare Text

Private Sub Adr_import_Click()
Dim msg As String, Antwort As Integer
Gruppierung_setzen False
ResetC_Click
AdrDatei_read
Range("PN_Datum") = Date
If Range("WE_Firma1") <> "" Then
    Antwort = MsgBox("Datei speichern?" _
    & vbCrLf & vbCrLf _
    & Copy_PathFile() _
    , vbQuestion + vbOKCancel, "Datei speichern")
End If
If Antwort = vbOK Then
    CopyFile True
End If
End Sub
Private Sub Adr_export_Click()
Gruppierung_setzen False
AdrDatei_write
csv_Export True
End Sub

Private Sub ClearC_Click()
Dim Antwort As Integer
Del_P_Ergebnisse True

Antwort = MsgBox("Auftragsdaten aus der aktuelle Exportdatei |fffd|bernehmen?" _
, vbQuestion + vbYesNo, App_Name)
If Antwort = vbYes Then
    SANA_Status = 0
    AdrDatei_read
    Range("PN_Datum") = Date
    If Range("WE_Firma1") <> "" Then
        Antwort = MsgBox("Datei speichern?" _
        & vbCrLf & vbCrLf _
        & Copy_PathFile() _
        , vbQuestion + vbOKCancel, "Datei speichern")
    End If
    If Antwort = vbOK Then
        CopyFile True
    End If
End If
End Sub

Private Sub CloseC_Click()
WB_Close
End Sub

Private Sub CompressC_Click()
If Check_Ok(1) Then Liste_verdichten
End Sub

Private Sub CopyC_Click()
CopyFile True
End Sub

Private Sub csv_ExportC_Click()
If Item_Anz() > 0 Then
    If FAnz_OK() Then csv_Export True
End If
End Sub

Private Sub csv_ImportC_Click()
SANA_Status = 0
'csv_Import
Import_PN
End Sub

Private Sub DB_Add_JNc_Click()
Me.DB_New_JNc = Not Me.DB_Add_JNc
If Me.DB_Add_JNc Then
    If Me.DB_Upd_JNc Then Me.DB_Upd_JNc = False
    Me.DB_Del_JNc = False
End If
End Sub

Private Sub DB_ImportC_Click()
DB_Import
End Sub

Private Sub DB_Upd_JNc_Click()
If Me.DB_Upd_JNc Then
    Sheets("Param").Range("DB_New_JN") = False
    Me.DB_Del_JNc = False
    Me.DB_New_JNc = False
    Me.DB_Add_JNc = False
End If
End Sub

Private Sub DB_Sync_Click()
DB_Synchronisieren
End Sub

Private Sub DB_del_JNc_Click()
If Me.DB_Del_JNc Then
    Me.DB_Add_JNc = False
    Me.DB_Upd_JNc = False
    Me.DB_New_JNc = False
End If
End Sub

Private Sub DB_New_JNc_Click()
If Me.DB_New_JNc Then
    If Me.DB_Add_JNc Then
        Me.DB_Add_JNc = False
    End If
    Me.DB_Del_JNc = False
End If
End Sub

Private Sub DB_Query_Click()
Open_Template Sheets("Param").Range("DB_QueryName")
End Sub


Private Sub DeleteC_Click()
Row_delete
End Sub

Private Sub FinishC_Click()
If Check_Ok(0) Then
    If FAnz_OK() Then Finish
End If
End Sub

Private Sub InsertC_Click()
Row_insert
End Sub

Private Sub Komp_NrC_Click()
Komp_Nr_setzen
End Sub

Private Sub Kopfdaten_Click()
Schutz False
Gruppierung_setzen Not Me.Kopfdaten
Schutz True
End Sub

Private Sub P_AktivC_Click()
PAktiv_Filtern
End Sub

Private Sub Page_addC_Click()
Page_add
Range("A" & P_FirstRow()).Select
Zeilenh|fffd|he_setzen False 'Standard

End Sub

Private Sub PDFc_Click()
'Finish
If Ist_PDF() Then PDF_Create
End Sub

Private Sub PB_JN_Click()
On Error Resume Next
SANA_Status = 0
'If Me.PB_JN Then
'    frmPB.Show
'Else
'    Unload frmPB
'End If
End Sub

Private Sub ResetC_Click()
SANA_Status = 0
Del_Signature SignNr
Reset_Adr
If Item_Anz() > 0 Then
    
    Del_Produkte True
End If
End Sub

Private Sub Sign1_Click()
SignNr = 0
frmDraw.Show
End Sub

Private Sub Sign2_Click()
SignNr = 1
frmDraw.Show
End Sub

Private Sub BerechnungC_Click()
Dim Antwort As Integer
If Check_Ok(0) Then
    If FAnz_OK() Then
        CompressC_Click
        P_Bereich_setzen
        Sheets("Berechnung").Activate
        Pivot_einstellen
    End If
End If
End Sub

Private Sub MailC_Click()
Mail_xlFile
End Sub


Private Sub ZA_copy_Click()
Dim sText As String
Dim sh As Worksheet
Dim SID, T|fffd|rnummer, Standort, Pr|fffd|fbefund, Pr|fffd|fbericht, Ma|fffd|nahme
Dim rFirst As Integer, rLast As Integer, i As Integer, Antwort As Integer
Const cSID = 1, cT|fffd|rnummer = 2, cStandort = 4, cPr|fffd|fbefund = 11, cPr|fffd|fbericht = 12, cMa|fffd|nahme = 13, cStatus = 14

If Item_Anz() = 0 Then
    MsgBox "Keine Produkte vorhanden!", vbExclamation, "Produkte in Zwischenablage kopieren"
    Exit Sub
End If
Set sh = Sheets(1)
rFirst = P_FirstRow()
rLast = P_LastRow() - 1

With sh
    For i = rFirst To rLast
        If sh.Cells(i, cStatus) = "" Then
            SID = sh.Cells(i, cSID)
            T|fffd|rnummer = sh.Cells(i, cT|fffd|rnummer)
            Standort = sh.Cells(i, cStandort)
            Pr|fffd|fbefund = sh.Cells(i, cPr|fffd|fbefund)
            'Nr durch Text ersetzen
            Pr|fffd|fbefund = Param("Befund" & Pr|fffd|fbefund, 3)
            
            Pr|fffd|fbericht = sh.Cells(i, cPr|fffd|fbericht)
            Pr|fffd|fbericht = ReplaceStr(Pr|fffd|fbericht, Chr(10), " ")
            
            Ma|fffd|nahme = sh.Cells(i, cMa|fffd|nahme)
            Ma|fffd|nahme = ReplaceStr(Ma|fffd|nahme, Chr(10), " ")
            sText = sText & SID & vbTab & T|fffd|rnummer & vbTab & Standort & vbTab & Pr|fffd|fbefund & vbTab & Pr|fffd|fbericht & vbTab & Ma|fffd|nahme & vbCrLf
        End If
    Next i
End With

    'sh.Cells(i, 1).Interior.ColorIndex = 4
    'Sleep 200
    'sh.Cells(i, 1).Interior.ColorIndex = 0
Antwort = MsgBox(sh.Range("PN_Anzahl") & " Produkte in Zwischenablage kopiert." _
& vbCrLf & vbCrLf _
& "T|fffd|rnummer, Standort, Pr|fffd|fbefund, Pr|fffd|fbericht, Ma|fffd|nahme" _
& vbCrLf & vbCrLf _
& "F|fffd|gen Sie die Daten in der Zielanwendung mit Strg+V ein" _
, vbInformation + vbOKOnly, "Produkte in Zwischenablage kopieren")

Text_to_Clipboard sText
End Sub
Attribute VB_Name = "Tabelle02"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "HomeC, 1, 0, MSForms, CommandButton"
Option Explicit

Private Sub HomeC_Click()
Sheets(1).Activate
End Sub
Attribute VB_Name = "Tabelle03"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Tabelle99"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "frmDraw"
Attribute VB_Base = "0{24ACA3C5-61DC-4FB4-9B91-3BF4D4B36458}{35D1D29E-3173-4AE3-90DA-9A34795CA20D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim sh As Worksheet
Dim Sign_Anzahl As Integer
Dim c1a, c2a, c3a, c4a, c1b, c2b, c3b, c4b  'Spalten f|fffd|r US1 (A) und US2 (B)

Private Sub UserForm_Activate()
If SignNr = 1 Then
    Me.Caption = "Unterschrift ST"
Else
    Me.Caption = "Unterschrift Kunde"
End If
NewC_Click
End Sub

Private Sub UserForm_Initialize()
Set sh = Sheets("Param")
'sets things up for drawing - see sub
Setup
Sign_Anzahl = ActiveSheet.ChartObjects.Count
c1a = "K": c2a = "L": c3a = "M": c4a = "N"
c1b = "O": c2b = "P": c3b = "Q": c4b = "R"


sh.Range(c1a & "1:" & c4a & Sign_Rows).ClearContents
sh.Range(c1b & "1:" & c4b & Sign_Rows).ClearContents
ActiveSheet.ChartObjects(1).Chart.SetSourceData Source:=Sheets("Param").Range(c1a & "1:" & c2a & Sign_Rows), PlotBy:=xlColumns
If Sign_Anzahl = 2 Then
    ActiveSheet.ChartObjects(2).Chart.SetSourceData Source:=Sheets("Param").Range(c1b & "1:" & c2b & Sign_Rows), PlotBy:=xlColumns
End If

End Sub

Private Sub NewC_Click()
'clears userform
Me.Repaint
Del_Signature SignNr
End Sub

Private Sub FertigC_Click()
Dim zell As Range
If SignNr = 1 Then
    sh.Range(c3b & "1:" & c4b & Sign_Rows).Replace "x", "", , , , , , True
    sh.Range(c3b & "1:" & c4b & Sign_Rows).Copy Destination:=sh.Range(c1b & "1")
    sh.Range(c4b & "1:" & c4b & Sign_Rows).Copy Destination:=sh.Range(c2b & "1")
Else
    sh.Range(c3a & "1:" & c4a & Sign_Rows).Replace "x", "", , , , , , True
    sh.Range(c3a & "1:" & c4a & Sign_Rows).Copy Destination:=sh.Range(c1a & "1")
    sh.Range(c4a & "1:" & c4a & Sign_Rows).Copy Destination:=sh.Range(c2a & "1")
End If

frmDraw.Hide
frmDraw2.Show

End Sub

Private Sub UserForm_Deactivate()
CleanUpLine 'cleans up, realse objects etc
''' resets the repiant for thing ellipse
Range("repaint_mode") = 0
Set sh = Nothing
End Sub

Private Sub UserForm_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
If Button = 1 Then
    SetDrawStart X, Y
End If
End Sub
Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
'Pass the mouse position to subs
If Button = 1 Then
    Draw X, Y
    Dim A
    Dim B
    
    'SignNr:    0=extern 1=intern
    If SignNr = 1 Then
        Set A = sh.Range(c3b & Sign_Rows).End(xlUp).Offset(1, 0)
        Set B = sh.Range(c4b & Sign_Rows).End(xlUp).Offset(1, 0)
    Else
        Set A = sh.Range(c3a & Sign_Rows).End(xlUp).Offset(1, 0)
        Set B = sh.Range(c4a & Sign_Rows).End(xlUp).Offset(1, 0)
    End If
    A.Value = -10 + X / 12.5
    B.Value = 10 - Y / 12.5
End If

If Button = 0 Then
    If SignNr = 1 Then
        sh.Range(c3b & Sign_Rows).End(xlUp).Offset(0, 0) = "x"
        sh.Range(c3b & Sign_Rows).End(xlUp).Offset(0, 0) = "x"
    Else
        sh.Range(c3a & Sign_Rows).End(xlUp).Offset(0, 0) = "x"
        sh.Range(c3a & Sign_Rows).End(xlUp).Offset(0, 0) = "x"
    End If

End If


End Sub
Attribute VB_Name = "frmDraw2"
Attribute VB_Base = "0{D68DD889-D6C0-420D-9408-36BCEC76A241}{58318143-3C30-4800-A4CC-A46CE5090F46}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub CloseC_Click()
If SignNr = 1 Then
    Del_Signature 1
Else
    Del_Signature 0
End If
frmDraw2.Hide

End Sub

Private Sub UserForm_Activate()
'Me.Sign_Anrede = ""
Me.Sign_Name = ""
Me.Sign_Name.SetFocus
End Sub

Private Sub FertigC_Click()
On Error Resume Next
If Len(Me.Sign_Name) = 0 Then Exit Sub

With ActiveSheet
    '.Unprotect Password:=PW
    If SignNr = 1 Then
        .Range("Sign_Name2") = Me.Sign_Anrede & " " & Me.Sign_Name
        .Range("Sign_Datum2") = Date
    Else
        .Range("Sign_Name1") = Me.Sign_Anrede & " " & Me.Sign_Name
        .Range("Sign_Datum1") = Date
    End If
    'If Not Ist_Test() Then .Protect Password:=PW
End With
frmDraw2.Hide

End Sub

Attribute VB_Name = "frmSettings"
Attribute VB_Base = "0{FB692CFF-E295-437C-BDE8-4B5316B45730}{9E74AC1F-F356-4727-BC49-9B8CD4626416}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_Initialize()
Me.Extern_JN.Enabled = Ist_Admin()
End Sub

Private Sub DB_Sync_JN_Click()
Dim Antwort As Integer
If Me.DB_Sync_JN Then
    If DB_available(True) Then
        Antwort = MsgBoxT(DB_Name() & " ist verf|fffd|gbar." _
        & vbCrLf & vbCrLf _
        & "Pr|fffd|fnachweise k|fffd|nnen synchronisiert werden." _
        , 2, "Verbindungspr|fffd|fung", vbInformation + vbOKOnly)
    End If
End If
End Sub

Private Sub DB_Sync_JN_AfterUpdate()
DB_Controls_setzen

End Sub

Private Sub Extern_JN_Click()
Dim Antwort As Integer
Antwort = MsgBox("Standardwerte f|fffd|r " & IIf(Me.Extern_JN, "externe", "interne") & " Anwender setzen?" _
& vbCrLf & vbCrLf _
& IIf(Me.Extern_JN, "Extern: e-Mail AUS, PDFCreator AUS", _
"Intern: e-Mail AN, PDFCreator AN") _
, vbQuestion + vbOKCancel, "Parameter setzen")
If Antwort = vbOK Then
    Range("Mail_JN") = Not Ist_Extern()
    Range("PDF_JN") = Not Ist_Extern()
    'Range("Print_JN") = Not Range("PDF_JN")
End If
If Ist_Extern Then Me.DB_Sync_JN = False
End Sub

Private Sub PDF_Sleep_BeforeUpdate(ByVal Cancel As MSForms.ReturnBoolean)
Dim Antwort As Integer
If Me.PDF_Sleep < 1000 Then
    Antwort = MsgBox("Wert < 1000 ist nicht zul|fffd|ssig", vbExclamation, "Pause bei PDF-Erstellung")
    Cancel = True
ElseIf Me.PDF_Sleep > 3000 Then
    Antwort = MsgBox("Wert > 3000 ist nicht zul|fffd|ssig", vbExclamation, "Pause bei PDF-Erstellung")
    Cancel = True
End If
End Sub

Private Sub CloseC_Click()
'Me.Hide
Unload Me
End Sub

Private Sub Mail_JN_Click()
Dim mailok As Boolean
If Me.Mail_JN Then
    mailok = OutlookInstalliert(True)
    If Not mailok Then
        mailok = LotusInstalliert(True)
    End If
    If Not mailok Then Me.Mail_JN = False
End If

End Sub

Private Sub PDF_JN_Click()
If Me.PDF_JN Then
    If Not PDFCreator_installed(True) Then Me.PDF_JN = False
End If
End Sub
Attribute VB_Name = "mod_App"
Option Explicit
Option Compare Text
Global Const Sign_Rows As Integer = 5000
Global Const C_Plicht1 As Integer = 3, C_Plicht2 As Integer = 5, C_Check As Integer = 4, C_Status = 14, C_SID = 1, C_TN = 2
Public SignNr As Integer, SANA_Status As Integer, AU_exist As Boolean
Function App_Name() As String
App_Name = Sheets("Param").Range("App_Kurzname")
End Function

Function Ist_Admin()
Dim vFunktion, vUsername
vUsername = Login_akt()
Ist_Admin = vUsername = "Bonczekl" _
 Or vUsername = "Reinauge" _
 Or vUsername = "ZopKa"

End Function
Function Ist_Test() As Boolean
Ist_Test = Ist_Admin() And ActiveWindow.DisplayWorkbookTabs = True
End Function
Function Login_akt() As String
Login_akt = Environ("Username")
If Login_akt = "Klaus" Or Login_akt = "KlaBo" Then Login_akt = "Bonczekl"

End Function

Sub Reset_Adr()
With ActiveSheet
    .Unprotect
    .Range("WE_Firma1") = ""
    .Range("WE_Nr") = ""
    .Range("WE_Firma2") = ""
    .Range("WE_Strasse") = ""
    .Range("WE_PLZ_Ort") = ""
    .Range("WE_Mail") = ""
    .Range("AG_Nr") = ""
    .Range("AG_Firma1") = ""
    .Range("AG_Firma2") = ""
    .Range("AG_Strasse") = ""
    .Range("AG_PLZ_Ort") = ""
    .Range("AG_Mail") = ""
    .Range("AU_Nr") = ""
    .Range("Sign_Name1") = ""
    .Range("Sign_Name2") = ""
    .Range("Sign_Datum1") = ""
    .Range("Sign_Datum2") = ""
    .Range("B_KompNr") = ""
    .Range("G_Standort") = ""
    
    Del_Signature 0
    Del_Signature 1
    If Not Ist_Test() Then Schutz True
End With
End Sub

Sub Del_Signature(nSignNr As Integer)
'Unterschrift l|fffd|schen
Dim ws As Worksheet
On Error Resume Next
Set ws = Sheets("Param")
If nSignNr = 1 Then
    ws.Range("o2:r" & Sign_Rows).ClearContents
    Sheets(1).Range("Sign_Datum2").ClearContents
    Sheets(1).Range("Sign_Name2").ClearContents
Else
    ws.Range("k2:n" & Sign_Rows).ClearContents
    Sheets(1).Range("Sign_Datum1").ClearContents
    Sheets(1).Range("Sign_Name1").ClearContents
End If
Set ws = Nothing
End Sub
Function Sign_exist(nSignNr As Integer) As Boolean
'Unterschrift pr|fffd|fen
Dim ws As Worksheet
On Error Resume Next
Set ws = Sheets("Param")
If nSignNr = 1 Then
    Sign_exist = ws.Range("o2") <> ""
Else
    Sign_exist = ws.Range("k2") <> ""
End If
Set ws = Nothing
End Function

Function P_FirstRow() As Integer
Dim sh As Worksheet, rStart
Set sh = Sheets(1)
P_FirstRow = sh.Range("Head_End").Row + 1
Set sh = Nothing
End Function
Function P_LastRow() As Integer
Dim sh As Worksheet, rStart
Set sh = Sheets(1)
P_LastRow = sh.Range("Foot_Start").Row - 1
Set sh = Nothing
End Function
Sub Row_insert()
Dim sh As Worksheet, rSel
Schutz False
Set sh = Sheets(1)
rSel = ActiveCell.Row
If rSel < P_FirstRow() + 1 Or rSel > P_LastRow() Then
    MsgBox "Bitte w|fffd|hlen Sie eine Zeile im Listenbereich!", vbExclamation, "Zeile einf|fffd|gen"
Else
    sh.Rows(rSel).Insert Shift:=xlUp
    sh.Cells(rSel, C_Status) = "Neu"
    'Selection.Insert Shift:=xlUp
End If

Application.CutCopyMode = False
Schutz True
Set sh = Nothing
End Sub
Sub Row_delete()
Dim sh As Worksheet, rSel
Set sh = Sheets(1)
sh.Unprotect
rSel = ActiveCell.Row
If rSel < P_FirstRow() Or rSel > P_LastRow() Then
    MsgBox "Bitte w|fffd|hlen Sie eine Zeile im Listenbereich!", vbExclamation, "Zeile l|fffd|schen"
Else
    sh.Rows(rSel).Delete
End If

Application.CutCopyMode = False
If Not Ist_Test() Then Schutz True
Set sh = Nothing
End Sub
Sub Lines_add(nRows As Integer)
Dim sh As Worksheet, rStart
Set sh = Sheets(1)
rStart = P_LastRow()
Schutz False
sh.Rows(rStart & ":" & rStart - nRows + IIf(nRows = 1, 1, 2)).Select
Selection.Insert Shift:=xlUp
If nRows = 1 Then
    Exit Sub
End If
sh.Rows(rStart & ":" & rStart).Select
Selection.Insert Shift:=xlUp
Application.CutCopyMode = False
Schutz True
Set sh = Nothing
End Sub
Sub Lines_delete()
Dim objWks As Worksheet
Dim i%, Eingabe As String
Dim rFirst As Integer, rLast As Integer, cPr|fffd|fung As Integer
Set objWks = Worksheets(1)
'Eingabe = InputBox("Spalte mit leeren Zellen eingeben:" _
& vbCrLf & vbCrLf & vbCrLf & "Zeile wird gel|fffd|scht, wenn gew|fffd|hlte Spalte leer ist" _
& vbCrLf & vbCrLf & vbCrLf & "aktuell: Spalte " & ActiveCell.Column _
, "Zeilen l|fffd|schen", ActiveCell.Column)
'If Eingabe = "" Then Exit Sub

Application.ScreenUpdating = False
Schutz False
With objWks
    rFirst = P_FirstRow()
    rLast = P_LastRow() - 1
    cPr|fffd|fung = C_Plicht1
    For i = rLast To rFirst Step -1
        If IsEmpty(.Cells(i, cPr|fffd|fung)) Or .Cells(i, cPr|fffd|fung) = "" Then
            Rows(i).Delete
        End If
    Next i
    .Rows(P_LastRow()).Hidden = True
End With
'Objektverweis freigeben
Set objWks = Nothing
Application.ScreenUpdating = True
Formeln_einf|fffd|gen
Schutz True
End Sub
Function Item_Anz() As Integer
Dim objWks As Worksheet
Dim i%
Dim rFirst As Integer, rLast As Integer, cPr|fffd|fung As Integer
Set objWks = Worksheets(1)

Application.ScreenUpdating = False
With objWks
    rFirst = P_FirstRow()
    rLast = P_LastRow()
    cPr|fffd|fung = C_Plicht1
    For i = rLast To rFirst Step -1
        If Not (IsEmpty(.Cells(i, cPr|fffd|fung)) Or .Cells(i, cPr|fffd|fung) = "") Then
            Item_Anz = Item_Anz + 1
        End If
    Next i
End With
'Objektverweis freigeben
Set objWks = Nothing
Application.ScreenUpdating = True

End Function
Sub Liste_verdichten()
    Lines_delete
    If ActiveSheet.Range("Foot_Start").Row - 1 < Sheets("Param").Range("R_Anzahl1") Then
        'mindestens 1 ganzeSeite
        Page_add
    End If
    Range("A" & Range("Head_End").Row + 1).Select
Zeilenh|fffd|he_setzen True
End Sub
Sub Page_add()
Dim rAnzahl1 As Integer, rAnzahl2 As Integer, Foot_Start As Integer, i As Integer
Dim sh As Worksheet
Schutz False
Set sh = Worksheets(1)
rAnzahl1 = Sheets("Param").Range("R_Anzahl1")
rAnzahl2 = Sheets("Param").Range("R_Anzahl2")
Application.ScreenUpdating = False

With sh
    If P_LastRow() + 1 < P_FirstRow() + rAnzahl1 Then
        'auf ganze Seite auff|fffd|llen
        rAnzahl1 = rAnzahl1 - (P_LastRow() - P_FirstRow()) - 1
        For i = 1 To rAnzahl1
            Lines_add 1
        Next i
        GoTo Exit_
    End If
    If rAnzahl1 <> 0 Then
        For i = 1 To rAnzahl1
            Lines_add 1
        Next i
    End If
    If rAnzahl2 <> 0 Then 'Lines_add rAnzahl2 - rAnzahl1
        For i = 1 To rAnzahl2 - rAnzahl1
            Lines_add 1
        Next i
    End If
End With


Exit_:
Schutz True
Set sh = Nothing
Formeln_einf|fffd|gen
Application.ScreenUpdating = True
Application.CalculateFull
Exit Sub
End Sub

Function LastPage() As Double
Dim Foot_Start As Integer
If P_LastRow() < 30 Then
    LastPage = 1
Else
    LastPage = Round(1 + (P_LastRow() - 29) / 27, 2)
End If
End Function
Sub P_Bereich_setzen()
Dim cStart, cEnde, rStart, rEnde
Dim sh As Worksheet
Set sh = Worksheets(1)
With sh
    rStart = .Range("Head_End").Row
    cStart = .Range("Head_End").Column
    rEnde = .Range("Head_End").Row + Item_Anz()
    cEnde = .Range("P_Ma|fffd|nahme").Column + 2
    ActiveWorkbook.names.Add name:="P_Bereich", RefersToR1C1:= _
        "=" & .name & "!R" & rStart & "C" & cStart & ":R" & rEnde & "C" & cEnde
End With
End Sub
Sub P_Daten_setzen()
Dim cStart, cEnde, rStart, rEnde
Dim sh As Worksheet
Set sh = Worksheets(1)
With sh
    rStart = P_FirstRow()
    cStart = .Range("Head_End").Column
    rEnde = P_LastRow()
    cEnde = Range("P_Ma|fffd|nahme").Column + 2
    'Alle Daten
        ActiveWorkbook.names.Add name:="P_Daten", RefersToR1C1:= _
       "=" & .name & "!R" & rStart & "C" & cStart & ":R" & rEnde & "C" & cEnde
    'Pr|fffd|fergebnisse
        cStart = .Range("P_Datum").Column
        ActiveWorkbook.names.Add name:="P_Ergebnisse", RefersToR1C1:= _
       "=" & .name & "!R" & rStart & "C" & cStart & ":R" & rEnde & "C" & cEnde
    
End With
End Sub
Sub Pivot_einstellen()
On Error Resume Next
With Sheets(2)
    '.PivotTableWizard SourceType:=xlDatabase, SourceData:= _
        "Produktliste!" & Range("P_Bereich").Address(ReferenceStyle:=xlR1C1)
    If Item_Anz() > 0 Then
        .PivotTables("PivotTable1").SourceData = "Produktliste!" & Range("P_Bereich").Address(ReferenceStyle:=xlR1C1)
    End If
    .PivotTables("PivotTable1").PivotCache.Refresh
    .PivotTables("PivotTable1").PivotFields("Status").CurrentPage = "(Leer)"
End With
End Sub
Function Copy_Path() As String
Dim Path As String
Path = Path_MyDocs() & "100 Service Exceltools\"
MakeDir Path
Path = Path & "400 Pr|fffd|fnachweise\"
MakeDir Path
Copy_Path = Path
End Function
Function Copy_FileName() As String
Dim sh As Worksheet
Set sh = Worksheets(1)
'Copy_FileName = Format(sh.Range("AU_Nr"), "0000000000") & "_" & "PN_" & sh.Range("WE_Firma1") & "_" & Format(Date, "YYYYMMDD") & ".xls"
Copy_FileName = Format(sh.Range("AU_Nr"), "0000000000") & "_" & "W00" & Right(Year(Date), 1) & ".xls"
Set sh = Nothing
End Function
Function Copy_PathFile() As String
Copy_PathFile = Copy_Path() & Copy_FileName()
End Function
Sub Del_Produkte(MsgJN As Boolean)
On Error Resume Next
Dim Antwort As Integer
P_Daten_setzen
If MsgJN Then
    Antwort = MsgBox("Alle Produktdaten l|fffd|schen?" _
    & vbCrLf & vbCrLf _
    & Item_Anz() & " Produkte" _
    , vbQuestion + vbOKCancel, "Daten l|fffd|schen")
ElseIf Item_Anz() = 0 Then
    Antwort = vbOK
Else
    Antwort = vbOK
End If
If Antwort = vbOK Then
    Sheets(1).Range("P_Daten").ClearContents
    Sheets(2).PivotTables("PivotTable1").PivotCache.Refresh
    Sheets(1).csv_ImportC.Enabled = True
End If
Application.CalculateFull
End Sub
Sub Del_P_Ergebnisse(MsgJN As Boolean)
Dim Antwort As Integer
On Error Resume Next
P_Daten_setzen
If Item_Anz() = 0 Then
    Antwort = vbOK
ElseIf MsgJN Then
    Antwort = MsgBox("Alle Pr|fffd|fergebnisse l|fffd|schen?" _
    & vbCrLf & vbCrLf _
    & Item_Anz() & " Produkte" _
    , vbQuestion + vbOKCancel, "Pr|fffd|fergebnisse l|fffd|schen")
Else
    Antwort = vbOK
End If
If Antwort = vbOK Then
    Sheets(1).Range("P_Ergebnisse").ClearContents
    'Sheets(1).Range("AU_Nr").MergeArea.ClearContents
    Sheets(1).Range("PN_Kommentar").MergeArea.ClearContents
    Del_Signature 0
    Del_Signature 1

End If
'Application.CalculateFull
End Sub
Function CopyFile(DelSign As Boolean, Optional NoMsg As Boolean) As Boolean
Dim sFile As String, Antwort As Integer, fName
On Error GoTo Err_
Schutz False
If Val(Application.Version) > 11 Then
    ActiveWorkbook.CheckCompatibility = False
End If

If Sheets(1).Range("WE_Firma1") <> "" And Sheets(1).Range("AU_Nr") <> "" Then
    'If File_new() Then
        Sheets(1).Range("Login_akt") = Login_akt()
    'End If
    
    sFile = Copy_PathFile()
    
    If DelSign Then
        Del_Signature 0
        Del_Signature 1
    Else
        Zeilen_einstellen True
    End If
    
    If Sheets(1).Range("PN_Anzahl") > 0 Then Sheets(1).csv_ImportC.Enabled = False
    
    If Dir(sFile) = "" Then
    
        ActiveWorkbook.SaveAs sFile, FileFormat:=xlFormat()
        'Antwort = MsgBox("Arbeitskopie wurde erstellt." _
        & vbCrLf & vbCrLf _
        & Copy_PathFile() _
        , vbOKOnly + vbInformation, "Datei speichern")
        CopyFile = True
    ElseIf Copy_FileName = ActiveWorkbook.name Then
        'fName = Application.GetSaveAsFilename(sFile)
        'If fName <> False Then
            ActiveWorkbook.Save
            CopyFile = True
        'End If
    Else
        Kill sFile
        ActiveWorkbook.SaveAs sFile, FileFormat:=xlFormat()
        CopyFile = True
    End If
Else
    Antwort = MsgBox("Kein Objekt oder Auftrag vorhanden!" _
    & vbCrLf & vbCrLf _
    & "Arbeitskopie kann nicht erstellt werden." _
    & vbCrLf & vbCrLf _
    & "Bitte geben Sie Adressdaten und Auftragsnummer ein und wiederholen Sie den Vorgang." _
    , vbOKOnly + vbExclamation, "Datei speichern")
End If

Exit_:
ActiveWindow.Caption = ActiveWorkbook.name
Schutz True
Exit Function

Err_:
CopyFile = False
MsgBox Err.Number & " " & Err.Description
Resume Exit_
'If Err.Number = 1004 Then
'End If

End Function
Function Mail_xlFile() As Boolean
Dim sh As Worksheet, FileName As String
Dim strEmpfaenger As Variant, strBetreff As Variant, strText As Variant, strCC As Variant, strbcc As Variant, strFilename As String, SaveIt As Boolean
Dim wb_Quelle As Workbook, wb_Ziel As Workbook, nMailAction As Integer, MailActionT As String, msg As String, doc_Dir As String, Doc_SubDir As String, Doc_Name As String, Antwort As Integer
Set wb_Quelle = ThisWorkbook
'FileName = PDF_Path() & PDF_Name()
FileName = Copy_PathFile()
If Not ThisWorkbook.Saved Or Dir(FileName) = "" Then
    If CopyFile(True) = False Then
        Antwort = MsgBox("E-Mail kann nicht automatisch erstellt werden." _
        & vbCrLf & vbCrLf _
        & "Versenden Sie die Datei manuell." _
        , vbExclamation, App_Name())
        Exit Function
    End If
End If
'ActiveWorkbook.SaveCopyAs FileName
'If Len(PDF_Name()) = 0 Then
'    Antwort = MsgBox("PDF kann nicht erstellt werden.", vbExclamation, App_Name)
'    Exit Sub
'End If

'PDF_Drucken PDF_Path(), PDF_Name()



strEmpfaenger = wb_Quelle.Sheets("Param").Range("xl_MailTo")
strCC = wb_Quelle.Sheets("Param").Range("xl_CC")
strBetreff = wb_Quelle.Sheets("Param").Range("xl_Betreff")
strFilename = FileName
strText = wb_Quelle.Sheets("Param").Range("xl_Text")

nMailAction = wb_Quelle.Sheets("Param").Range("mail_Action_sel") '1=Entwurf, 2=bearbeiten, 3=versenden
Select Case nMailAction
    Case 1
    MailActionT = "als Entwurf gespeichert"
    Case 2
    MailActionT = "E-Mail erstellt"
    Case 3
    MailActionT = "versendet"
End Select

SaveIt = True   'wb_Quelle.Sheets("Param").Range("doc_Save")

If InStr(1, Sheets("Param").Range("xl_MailTo"), "@") = 0 Then
    WSH_Run GetShortPath(FileName)
    'Log_Action PDF_Name(), "erstellt"
Else
    'PDF geht separat an CRM
    FileName = ""   'ReplaceStr(strFilename, ".xls", ".pdf")
    
    Mail_xlFile = NotesMailSend(strEmpfaenger, strBetreff, strText, strCC, strbcc, strFilename, FileName, "", "", nMailAction)
    
    'Log_Action PDF_Name(), MailActionT
        If Not SaveIt Then Kill strFilename
    'End If
End If

End Function
Function PDF_Create() As Boolean
Dim PDF_Path As String, PDF_FileName As String
Dim strEmpfaenger As Variant, strBetreff As Variant, strText As Variant, strCC As Variant, strbcc As Variant, strFilename As String, strFilename2 As String, SaveIt As Boolean
Dim wb_Quelle As Workbook, wb_Ziel As Workbook, nMailAction As Integer, MailActionT As String, msg As String, doc_Dir As String, Doc_SubDir As String, Doc_Name As String, Antwort As Integer


PDF_Path = Copy_Path()
PDF_FileName = ReplaceStr(Copy_FileName(), ".xls", ".pdf")

If PDF_Drucken(PDF_Path, PDF_FileName) Then
    WSH_Run (GetShortPath(PDF_Path & PDF_FileName))
    Antwort = MsgBox("Pr|fffd|fnachweis als E-Mail versenden?" _
    , vbQuestion + vbOKCancel, App_Name())
    If Antwort = vbOK Then
        'interne Mail
        strEmpfaenger = Sheets("Param").Range("doc_MailTo")
        strCC = Sheets("Param").Range("doc_CC")
        strBetreff = Sheets("Param").Range("doc_Betreff")
        strFilename = PDF_Path & PDF_FileName
        strText = Sheets("Param").Range("doc_Text")

        nMailAction = Sheets("Param").Range("mail_Action_sel") '1=Entwurf, 2=bearbeiten, 3=versenden
        Select Case nMailAction
            Case 1
            MailActionT = "als Entwurf gespeichert"
            Case 2
            MailActionT = "E-Mail erstellt"
            Case 3
            MailActionT = "versendet"
        End Select
        
        SaveIt = True   'wb_Quelle.Sheets("Param").Range("doc_Save")
        
        PDF_Create = NotesMailSend(strEmpfaenger, strBetreff, strText, strCC, strbcc, strFilename, "", "", "", nMailAction)
        
        'ZIP an CRM
        If Ist_SANA() Then
            strFilename2 = Copy_Path() & Sheets("Param").Range("SANA_Prot_PDF")
            If Dir(strFilename2) <> "" Then
                If Right(strFilename2, 3) = "ZIP" Then
                    strText = ReplaceStr(strText, "PDF", "ZIP")
                    strBetreff = ReplaceStr(strBetreff, "PDF", "ZIP")
                End If
                PDF_Create = NotesMailSend(strEmpfaenger, strBetreff, strText, strCC, strbcc, strFilename2, "", "", "", nMailAction)
            End If
        End If
        
        
        
        'externe Mail
        If Sheets("Param").Range("KD_MailTo") <> 0 Then
            strEmpfaenger = Sheets("Param").Range("KD_MailTo")
        Else
            strEmpfaenger = ""
        End If
        If Sheets("Param").Range("KD_CC") <> 0 Then
            strCC = Sheets("Param").Range("KD_CC")
        Else
            strCC = ""
        End If
        strBetreff = Sheets("Param").Range("KD_Betreff")
        strFilename = PDF_Path & PDF_FileName
        If Ist_SANA() Then
            strFilename2 = Copy_Path() & Sheets("Param").Range("SANA_Prot_PDF")
            If Dir(strFilename2) = "" Then strFilename2 = ""
        End If

        strText = Sheets("Param").Range("KD_Text")
        
        PDF_Create = NotesMailSend(strEmpfaenger, strBetreff, strText, strCC, strbcc, strFilename, strFilename2, "", "", nMailAction)
    End If
    Del_Signature 0
    Del_Signature 1
    Zeilen_einstellen False
    ActiveWorkbook.Save

End If

End Function
Sub Modus_einstellen()
Dim Antwort As Integer
If Ist_Admin() Then
    Antwort = MsgBox(App_Name() & " entsperren (Administrator)?" _
        & vbCrLf & vbCrLf _
        & "Nein: Sheets sperren (User)" _
        , vbQuestion + vbYesNoCancel, App_Name & "-Modus einstellen")
    If Antwort = vbYes Then
        Sheets_einstellen True
    ElseIf Antwort = vbNo Then
        Sheets_einstellen False
    End If
Else
    Sheets_einstellen False
    
End If
Antwort = MsgBox("Settings |fffd|ffnen?", vbOKCancel, App_Name())
If Antwort = vbOK Then frmSettings.Show
End Sub

Sub Sheets_einstellen(AnAus As Boolean)
Dim sh As Worksheet
Const Sheet_Start As Integer = 1
On Error Resume Next
Schutz False
For Each sh In Sheets
    If sh.name = "param" Then sh.Visible = AnAus
    With sh
    End With
Next sh

Sheets(1).Activate
    With ActiveWindow
        '.DisplayGridlines = AnAus
        '.DisplayHeadings = AnAus
        '.DisplayHorizontalScrollBar = AnAus
        .Caption = IIf(AnAus, ThisWorkbook.name, App_Name)
        
    End With
    With ActiveSheet
        '.Columns("J:Z").Font.ColorIndex = IIf(AnAus, 0, 2)
        .Range("A9:G9").Font.ColorIndex = IIf(AnAus, 0, 2)
        .Range("PN_neu").Font.ColorIndex = IIf(AnAus, 0, 2)
        .Range("PN_SID").Font.ColorIndex = IIf(AnAus, 0, 2)
        .Range("AG_Nr").Font.ColorIndex = IIf(AnAus, 0, 2)
        .Range("WE_Nr").Font.ColorIndex = IIf(AnAus, 0, 2)
        .Range("Login_akt") = ""
        .Range("C11").Comment.Shape.Height = 60
        .Range("H11").Comment.Shape.Height = 178

    End With
    With ActiveSheet.PageSetup
        '.LeftHeader = ""
        '.CenterHeader = ""
        '.RightHeader = ""
        .LeftFooter = "&8Druckzeit: &D &T"    '"&8" & Range("Rev_Info")
        .CenterFooter = ""
        .RightFooter = "&8Seite &P von &N"
    End With

Worksheets(Sheet_Start).Visible = True
Worksheets(Sheet_Start).Activate
    With ActiveWindow
        '.DisplayGridlines = AnAus
        '.DisplayHeadings = AnAus
        '.DisplayHorizontalScrollBar = AnAus
        .DisplayWorkbookTabs = AnAus
    End With
Schutz Not AnAus
End Sub

Sub Formeln_einf|fffd|gen()
Dim sh As Worksheet
Dim cAnzahl As Integer, rStart As Integer, rEnde As Integer
Schutz False
Set sh = Sheets(1)

cAnzahl = C_Plicht1 'Referenzspalte f|fffd|r Anzahl (Art)
rStart = P_FirstRow()
rEnde = P_LastRow() - 1
With sh
    .Range("PN_Check1").FormulaR1C1 = "=COUNTIF(R" & rStart & "C" & C_Check & ":R" & rEnde & "C" & C_Check & ",""<>"")"
    .Range("PN_Pflicht1").FormulaR1C1 = "=COUNTIF(R" & rStart & "C" & C_Plicht1 & ":R" & rEnde & "C" & C_Plicht1 & ",""<>"")"
    .Range("PN_Pflicht2").FormulaR1C1 = "=COUNTIF(R" & rStart & "C" & C_Plicht2 & ":R" & rEnde & "C" & C_Plicht2 & ",""<>"")"
    '.Range("PN_Anzahl").FormulaR1C1 = "=PN_Pflicht1"
    .Range("PN_Anzahl").FormulaR1C1 = "=IF(P_AktivJN,PN_Auswahl,PN_Pflicht1)"
    
    .Range("PN_Seiten").FormulaR1C1 = "=ROUNDUP(LastPage(),0)"
    .Range("PN_Auswahl").FormulaR1C1 = "=SUBTOTAL(" & cAnzahl & ",R" & rStart & "C" & cAnzahl & ":R" & rEnde & "C" & cAnzahl & ")"
    .Range("PN_neu").FormulaR1C1 = "=COUNTIF(R" & rStart & "C" & C_Status & ":R" & rEnde & "C" & C_Status & ",""neu"")"
    .Range("PN_SID").FormulaR1C1 = "=COUNTIF(R" & rStart & "C" & C_SID & ":R" & rEnde & "C" & C_SID & ",""<>"")"
    .Range("PN_TN").FormulaR1C1 = "=COUNTIF(R" & rStart & "C" & C_TN & ":R" & rEnde & "C" & C_TN & ",""<>"")"
End With
Schutz True
Set sh = Nothing

End Sub

Function csv_Name()
Dim Dateiname As String, Pfad As String
Const Extension As String = ".csv"

Pfad = Copy_Path()
Dateiname = Copy_FileName()
Dateiname = ReplaceStr(Dateiname, ".xls", Extension)
csv_Name = Pfad & Dateiname
End Function
Function csv_Export(MsgJN As Boolean) As Boolean
Dim Bereich As Object, Zeile As Object, Zelle As Object
Dim RowStart As Long, RowEnde As Long, Anz_Items As Long, i As Integer
Dim strTemp As String, Antwort As Integer
Const Trennzeichen As String = ";"
Const Extension As String = ".csv"
On Error GoTo Err_

P_Bereich_setzen

Anz_Items = Item_Anz()
If Anz_Items = 0 Then
    Antwort = MsgBox("Keine Produkte zum Exportieren vorhanden!", vbExclamation + vbOKOnly, App_Name & " exportieren")
    Antwort = vbCancel
ElseIf MsgJN Then
    Antwort = MsgBox(Anz_Items & " Produkte exportieren?" _
    & vbCrLf & vbCrLf _
    & csv_Name() _
    , vbQuestion + vbOKCancel, App_Name & " exportieren")
Else
    Antwort = vbOK
End If
If Antwort = vbCancel Then Exit Function

With Sheets(1)
    'CSV-Datei erstellen
    Set Bereich = .Range("P_Bereich")
    
    'M|fffd|gliche Datumswerte in T|fffd|rnummer verhindern
    TN_pr|fffd|fen True
    
    Open csv_Name() For Output As #1
    For Each Zeile In Bereich.Rows
        For Each Zelle In Zeile.Cells
            If InStr(1, Zelle.Text, ";") > 0 Then
                'Zellen, die ein Semikolon beinhalten in Anf|fffd|hrungsstriche setzen
                strTemp = strTemp & """" & Trim(CStr(Zelle.Text)) & """" & Trennzeichen
            Else
                strTemp = strTemp & Trim(CStr(Zelle.Text)) & Trennzeichen
            End If
        Next
        
        'Erg|fffd|nzung Kopfdaten
        If Zeile.Row = P_FirstRow() - 1 Then
            strTemp = strTemp _
            & "AU_Nr" & Trennzeichen _
            & "WE_Nr" & Trennzeichen _
            & "WE_Name1" & Trennzeichen _
            & "WE_Name2" & Trennzeichen _
            & "WE_PLZ" & Trennzeichen _
            & "WE_Ort" & Trennzeichen _
            & "WE_Str" & Trennzeichen _
            & "WE_Mail" & Trennzeichen _
            & "G_Standort" & Trennzeichen _
            & "AG_Nr" & Trennzeichen _
            & "AG_Name1" & Trennzeichen _
            & "AG_Name2" & Trennzeichen _
            & "AG_PLZ" & Trennzeichen _
            & "AG_Ort" & Trennzeichen _
            & "AG_Str" & Trennzeichen _
            & "AG_Mail" & Trennzeichen _
            & "PN_Datum" & Trennzeichen _
            & "PN_User" & Trennzeichen

        Else
            strTemp = strTemp _
            & Range("AU_Nr") & Trennzeichen _
            & Range("WE_Nr") & Trennzeichen _
            & Range("WE_Firma1") & Trennzeichen _
            & Range("WE_Firma2") & Trennzeichen _
            & NurZahl(Range("WE_PLZ_Ort")) & Trennzeichen _
            & Trim(OhneZahl(Range("WE_PLZ_Ort"))) & Trennzeichen _
            & Range("WE_Strasse") & Trennzeichen _
            & Range("WE_Mail") & Trennzeichen _
            & Range("G_Standort") & Trennzeichen _
            & Range("AG_Nr") & Trennzeichen _
            & Range("AG_Firma1") & Trennzeichen _
            & Range("AG_Firma2") & Trennzeichen _
            & NurZahl(Range("AG_PLZ_Ort")) & Trennzeichen _
            & Trim(OhneZahl(Range("AG_PLZ_Ort"))) & Trennzeichen _
            & Range("AG_Strasse") & Trennzeichen _
            & Range("AG_Mail") & Trennzeichen _
            & Range("PN_Datum") & Trennzeichen _
            & Range("Login_akt") & Trennzeichen
            
        End If
        
        strTemp = Left(strTemp, Len(strTemp) - 1)
        strTemp = ReplaceStr(strTemp, Chr(10), "")
        Print #1, strTemp
        strTemp = ""
    Next
    Close #1
    Set Bereich = Nothing
End With

'"_" wieder entfernen
TN_pr|fffd|fen False

csv_Export = True
If MsgJN Then Antwort = MsgBox("Exportdatei wurde erstellt.", vbInformation + vbOKOnly, App_Name & " exportieren")

Exit_:
Exit Function

Err_:
MsgBox Err.Description
Resume Exit_
End Function
Function CSV_mail() As Boolean
Dim strEmpfaenger As Variant, strBetreff As Variant, strText As Variant, strCC As Variant, strbcc As Variant, strFilename As String, strFilename2 As String, SaveIt As Boolean
On Error GoTo Err_
strEmpfaenger = Sheets("Param").Range("csv_mailto")
strCC = Sheets("Param").Range("csv_CC")
strBetreff = Sheets("Param").Range("csv_Betreff")
strText = Sheets("Param").Range("csv_Text")
strFilename = csv_Name()
If Dir(strFilename) = "" Then GoTo Exit_

CSV_mail = NotesMailSend(strEmpfaenger, strBetreff, strText, strCC, strbcc, strFilename, "", "", "", 1)

Exit_:
Exit Function

Err_:
Resume Exit_
End Function

Sub Zeilen_einstellen(HideJN As Boolean)
Dim rMail As Integer
rMail = Sheets(1).Range("WE_Mail").Row
With Sheets(1)
    .Rows(rMail).Hidden = HideJN
End With
End Sub
Sub Finish()
On Error GoTo Err_
Dim Antwort As Integer, pdf_ok As Boolean, xl_ok As Boolean, SANA_Print As Boolean, SANA_PDF As Boolean, msg As String, Counter As Integer, csv_ok As Boolean


Gruppierung_setzen False
Sheets(1).Range("PN_Datum") = Date
Sheets(1).Range("Login_akt") = Login_akt()
Liste_verdichten
P_Bereich_setzen
Sheets("Berechnung").Activate
Pivot_einstellen
Sheets(1).Activate

'inaktive ausblenden
Sheets(1).P_AktivC = True
'Sheets(1).Range("P_AktivJN") = True

If CopyFile(False) = False Then GoTo Exit_
If Not Data_ok() Then GoTo Exit_

SANA_Print = True: SANA_PDF = True

SANA:
If Ist_SANA() Then

    Select Case SANA_Status
    Case 0
        SANA_PDF = False
        SANA_Print = Protokolle_ok() = 1
        Counter = Counter + 1
        If Counter = 1 Then
            GoTo SANA
        Else
            GoTo Message_
        End If
    Case 1
        'Antwort = MsgBox("Nach dem Ausdruck mu|fffd| noch die Protokolldatei erstellt werden" _
        & vbCrLf & vbCrLf _
        & "Jetzt erstellen (Schritt 2)?" _
        , vbQuestion + vbYesNoCancel, "SANA Wartungsprotokolle")
        Antwort = vbYes
        If Antwort = vbYes Then
            SANA_PDF = Protokolle_ok() = 2
            If SANA_PDF Then
                GoTo SANA
            Else
                GoTo Message_
            End If
        End If
    Case 2
        SANA_Print = True: SANA_PDF = True
        Antwort = MsgBox("Pr|fffd|fbl|fffd|tter wurden erstellt." _
        & vbCrLf & vbCrLf _
        & "Mit der Verarbeitung f|fffd|r CRM fortfahren?" _
        , vbQuestion + vbOKCancel, "Pr|fffd|fbl|fffd|tter")
        If Antwort = vbCancel Then
            SANA_Status = 0
            GoTo Message_
        End If
        
    End Select
    
End If

PDF:
If Ist_PDF() Then
    pdf_ok = PDF_Create()
ElseIf Ist_Mail() Then
    Antwort = MsgBox("Automatische PDF-Erstellung ist deaktiviert." _
    & vbCrLf & vbCrLf _
    & "Wollen Sie die Daten als CSV exportieren und per E-Mail versenden?" _
    & vbCrLf & vbCrLf _
    & "NEIN: Diese Exceldatei per E-Mail versenden?" _
    , vbYesNoCancel + vbQuestion, App_Name())
    If Antwort = vbYes Then
        csv_ok = csv_Export(False)
        If csv_ok Then csv_ok = CSV_mail()
        If csv_ok Then
            Antwort = MsgBox("Pr|fffd|fbericht wurde als CSV exportiert und als E-Mail-Anhang erstellt." _
            & vbCrLf & vbCrLf _
            & "Wollen Sie die Anwendung beenden?" _
            , vbOKCancel + vbQuestion, App_Name())
            If Antwort = vbOK Then
                WB_Close
            Else
                GoTo Exit_
            End If
        End If
            GoTo Message_
    ElseIf Antwort = vbNo Then
        xl_ok = Mail_xlFile()
        GoTo Message_
    End If
Else
    Antwort = MsgBox("Automatische PDF- und E-Mail-Erstellung sind deaktiviert." _
    & vbCrLf & vbCrLf _
    & "Sie k|fffd|nnen exportierte Daten oder diese Exceldatei manuell per E-Mail versenden." _
    , vbOKOnly + vbInformation, App_Name())
     GoTo Message_
End If
If pdf_ok And Ist_Mail() Then
    'Excel
    If Range("XL_JN") Then
        xl_ok = Mail_xlFile()
    End If
    'CSV
    If Range("CSV_JN") Then
        csv_ok = csv_Export(False)
        If csv_ok Then csv_ok = CSV_mail()
  
    End If
End If

Message_:

If pdf_ok And (csv_ok Or xl_ok) And SANA_Print And SANA_PDF Then
    Antwort = MsgBox("Alle erforderlichen Dateien wurden erstellt." _
    & vbCrLf & vbCrLf _
    & "Bearbeitung beenden?" _
    , vbInformation + vbOKCancel + vbDefaultButton2, App_Name())
    
    If Antwort = vbOK Then WB_Close
Else
    Antwort = MsgBox("Vorgang wurde nicht vollst|fffd|ndig abgeschlossen!" _
    & vbCrLf & vbCrLf _
    & IIf(Range("XL_JN") And Not xl_ok, "Exceldatei nicht erstellt / versendet", "") _
    & vbCrLf _
    & IIf(Range("CSV_JN") And Not csv_ok, "CSV-Datei nicht erstellt / versendet", "") _
    & vbCrLf _
    & IIf(Not pdf_ok, "PDF-Datei nicht erstellt / versendet", "") _
    & vbCrLf _
    & IIf(Not SANA_Print, "Pr|fffd|fbl|fffd|tter nicht gedruckt", "") _
    & vbCrLf _
    & IIf(Not SANA_PDF, "Pr|fffd|fbl|fffd|tter nicht als PDF erstellt", "") _
    & vbCrLf & vbCrLf _
    & "Verzeichnis der Pr|fffd|fnachweise anzeigen?" _
    , vbExclamation + vbOKCancel + vbDefaultButton2, App_Name())
    If Antwort = vbOK Then Explore Copy_Path()
End If

Exit_:
Exit Sub

Err_:
MsgBox Err.Description
Resume Exit_
End Sub
Sub Text_to_Clipboard(sText As String)
    Dim oData As New DataObject
    With oData
        .SetText sText
        .PutInClipboard
    End With
End Sub
Function Text_from_Clipboard() As String
    Dim oData As New DataObject
    On Error Resume Next ' Brutal um falsche Formate abzuw|fffd|rgen, gibt dann einen Leerstring
    oData.GetFromClipboard
    Text_from_Clipboard = oData.GetText
End Function
Function Param(ParaName As String, Optional ParaNr As Integer) As Variant
On Error Resume Next
Dim nRow
nRow = Sheets("Param").Columns(1).Find(What:=ParaName, LookAt:=1).Row
Param = Sheets("Param").Cells(nRow, ParaNr).Value
End Function

Sub Gruppierung_setzen(AnAus As Boolean)
Dim gLevel As Integer
On Error Resume Next
'ActiveSheet.Rows("3:9").Group
If AnAus Then
    gLevel = 1
Else
    gLevel = 2
End If
Sheets(1).Outline.ShowLevels RowLevels:=gLevel, ColumnLevels:=gLevel
End Sub

Sub Schutz(AnAus As Boolean)
Dim sh As Worksheet
Set sh = Sheets(1)
'Schutz deaktiviert
AnAus = False
If AnAus Then
    sh.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True _
        , AllowInsertingRows:=True, AllowDeletingRows:=True, AllowSorting:=True, _
        AllowFiltering:=True
    sh.EnableSelection = xlUnlockedCells
Else
    sh.Unprotect
End If
Set sh = Nothing
End Sub

Function Info_Pflichtfeld(PflichtNr As Integer) As String
If PflichtNr = 1 Then
    Info_Pflichtfeld = Cells(P_FirstRow() - 1, C_Plicht1)
Else
    Info_Pflichtfeld = Cells(P_FirstRow() - 1, C_Plicht2)
End If

Info_Pflichtfeld = "Spalte '" & Info_Pflichtfeld & "' ist ein Pflichtfeld."

End Function
Function Anz_Check() As Integer
Dim sh As Worksheet
Set sh = Sheets(1)
Anz_Check = sh.Range("PN_Check1")
Set sh = Nothing
End Function
Function Anz_Pflicht1() As Integer
Dim sh As Worksheet
Set sh = Sheets(1)
Anz_Pflicht1 = sh.Range("PN_Pflicht1")
Set sh = Nothing
End Function
Function Anz_Pflicht2() As Integer
Dim sh As Worksheet
Set sh = Sheets(1)
Anz_Pflicht2 = sh.Range("PN_Pflicht2")
Set sh = Nothing
End Function
Function Check_Dif(PflichtNr As Integer) As Integer
Select Case PflichtNr
    Case 1
        Check_Dif = Anz_Check() - Anz_Pflicht1()
    Case 2
        Check_Dif = Anz_Check() - Anz_Pflicht2()
End Select
End Function
Function Check_Ok(PflichtNr As Integer) As Boolean
Dim Antwort As Integer, msg1 As String, msg2 As String, titel As String
msg1 = " Produkte unvollst|fffd|ndig!"
msg2 = "Bitte bearbeiten Sie die Liste."
titel = "Pr|fffd|fung Produkte im " & App_Name()

If Item_Anz() = 0 And Anz_Check() = 0 Then
    Antwort = MsgBox("Keine Produkte vorhanden!" _
    & vbCrLf & vbCrLf _
    & "Bitte geben Sie Produkte ein." _
    , vbExclamation + vbOKOnly, titel)
    GoTo Exit_
End If
If PflichtNr = 0 Or PflichtNr = 1 Then
    If Anz_Check() > 0 And Check_Dif(1) > 0 Then
        Antwort = MsgBox(Check_Dif(1) & msg1 _
        & vbCrLf & vbCrLf _
        & Info_Pflichtfeld(1) _
        & vbCrLf & vbCrLf _
        & msg2 _
        , vbExclamation + vbOKOnly, titel)
        Check_Ok = False
        If PflichtNr = 1 Then
            Antwort = MsgBox("Unvollst|fffd|ndige Produkte entfernen?" _
            , vbQuestion + vbYesNo + vbDefaultButton2, titel)
            Check_Ok = Antwort = vbYes
            GoTo Exit_
        End If
    Else
        Check_Ok = True
    End If
End If
If PflichtNr = 0 Or PflichtNr = 2 Then
    If Anz_Check() > 0 And Check_Dif(2) > 0 Then
        Antwort = MsgBox(Check_Dif(2) & msg1 _
        & vbCrLf & vbCrLf _
        & Info_Pflichtfeld(2) _
        & vbCrLf & vbCrLf _
        & msg2 _
        , vbExclamation + vbOKOnly, titel)
        Check_Ok = False
        If PflichtNr = 2 Then GoTo Exit_
    Else
        Check_Ok = True
    End If
Else
    Check_Ok = True
End If

Exit_:
Exit Function
End Function

Sub Zeilenh|fffd|he_setzen(AutoJN As Boolean)
Dim H|fffd|he As Double
With Sheets(1)
    If AutoJN Then
        .Rows(P_FirstRow() & ":" & P_LastRow()).AutoFit
    Else
        H|fffd|he = 18 'Standard (lesbar)
        .Rows(P_FirstRow() & ":" & P_LastRow()).RowHeight = H|fffd|he
    End If
        .Rows(P_LastRow()).Hidden = True
        .Range("C11").Comment.Shape.Height = 60
        .Range("H11").Comment.Shape.Height = 178
End With
End Sub
Sub PAktiv_Filtern()
With Sheets(1)
    If .Range("P_AktivJN") Then
        .Range("A" & Range("Head_End").Row).AutoFilter Field:=FieldCol("Status"), Criteria1:="<>inaktiv"
    Else
        .Range("A" & Range("Head_End").Row).AutoFilter Field:=FieldCol("Status")
    End If
End With
End Sub
Function Ist_SANA() As Boolean
Ist_SANA = Sheets("Param").Range("SANA") = True
End Function

Function Protokoll_erstellen(Anzahl_JN As Boolean, Optional PDF_JN As Boolean)
Dim Bereich As Object, Zeile As Object, Zelle As Object, Antwort As Integer, OldPrinter As String
Dim SID, T|fffd|rNr, Art, Standort, Typ, Hersteller, Antriebstyp, Feststellung, Fl|fffd|gel, Pr|fffd|fdatum, Pr|fffd|fbefund, Pr|fffd|fer, Pr|fffd|fbericht, Ma|fffd|nahme, Status, P_ID As String, R_Korr
Dim Prot_Nr As Integer, Prot_Kennung As String, Prot_Name As String, Prot_Anzahl As Integer, i As Integer
Dim B_AU_Nr, B_WE_Firma1, B_WE_Firma2, B_WE_Strasse, B_WE_PLZ_Ort, B_AG_Firma1, B_AG_Firma2, B_AG_Strasse, B_AG_PLZ_Ort
Dim B_Standort, B_T|fffd|rNr, B_SID, B_Typ, B_Hersteller, B_AS_Typ, B_Feststellung, B_Fl|fffd|gel, B_Pr|fffd|fdatum, B_Pr|fffd|fbefund, B_Pr|fffd|fbericht, B_Ma|fffd|nahmen, B_Pr|fffd|fer

Dim pdfjob As Object, SheetAnz As Integer, PDF_Sleep As Integer
Dim sPDFPath As String, sPDFName As String, Combine As Boolean, sPDFKomponente As String
On Error GoTo Err_
Application.CalculateFull
PDF_Sleep = Sleep_ms()
R_Korr = P_FirstRow() - 1

P_Bereich_setzen

If Not Anzahl_JN And PDF_JN And Ist_PDF() Then

    'Einzelne Dateien erstellen
    Combine = Sheets("Param").Range("PDF_Combine")
    
    sPDFName = Sheets("Param").Range("SANA_Prot_PDF")
    If Dir(Copy_Path() & sPDFName) <> "" Then
        Kill Copy_Path() & sPDFName
    End If
    If Combine Then
        sPDFPath = Copy_Path()
    Else
        sPDFPath = Sheets("Param").Range("SANA_Protokolle")
        MakeDir sPDFPath
    End If


    'PDFCreator beenden
    Terminate_Process "PDFCreator.exe"
    OldPrinter = Application.ActivePrinter

    SheetAnz = Prot_Anz()
    Set pdfjob = CreateObject("PDFCreator.clsPDFCreator")

    With pdfjob
        If .cStart("/NoProcessingAtStartup") = False Then
            MsgBox "Kann PDFCreator nicht initialisieren.", vbCritical + vbOKOnly, "PrtPDFCreator"
            GoTo Err_
        End If
        
        .cOption("UseAutosave") = 1
        .cOption("UseAutosaveDirectory") = 1
        .cOption("AutosaveDirectory") = sPDFPath
        .cOption("AutosaveFilename") = sPDFName
        .cOption("AutosaveFormat") = 0  ' 0 = PDF
        .cClearCache
    End With
End If
Application.ScreenUpdating = False
With Sheets(1)
    Pr|fffd|fer = .Range("Sign_Name2")
    B_AU_Nr = .Range("AU_Nr")
    B_WE_Firma1 = .Range("WE_Firma1")
    B_WE_Firma2 = .Range("WE_Firma2")
    B_WE_Strasse = .Range("WE_Strasse")
    B_WE_PLZ_Ort = .Range("WE_PLZ_Ort")
    B_AG_Firma1 = .Range("AG_Firma1")
    B_AG_Firma2 = .Range("AG_Firma2")
    B_AG_Strasse = .Range("AG_Strasse")
    B_AG_PLZ_Ort = .Range("AG_PLZ_Ort")
    
    Set Bereich = .Range("P_Bereich")
    For Each Zeile In Bereich.Rows
        If Zeile.Row >= P_FirstRow() Then
            SID = .Cells(Zeile.Row, 1)
            T|fffd|rNr = "'" & .Cells(Zeile.Row, 2)
            Art = .Cells(Zeile.Row, 3)
            Standort = .Cells(Zeile.Row, 4)
            Typ = .Cells(Zeile.Row, 5)
            Hersteller = .Cells(Zeile.Row, 6)
            Antriebstyp = .Cells(Zeile.Row, 7)
            Feststellung = .Cells(Zeile.Row, 8)
            Fl|fffd|gel = .Cells(Zeile.Row, 9)
            Pr|fffd|fdatum = .Cells(Zeile.Row, 10)
            Pr|fffd|fbefund = .Cells(Zeile.Row, 11)
            Pr|fffd|fbefund = Pr|fffd|fbefund & IIf(IsEmpty(Pr|fffd|fbefund), "", " = " & Param("Befund" & Pr|fffd|fbefund, 3))
            Pr|fffd|fbericht = .Cells(Zeile.Row, 12)
            Ma|fffd|nahme = .Cells(Zeile.Row, 13)
            Status = .Cells(Zeile.Row, 14)
            P_ID = Format(Zeile.Row - R_Korr, "0000")
            'Select Case Typ
            '    Case "TS"
            '        Prot_Nr = 1
            '    Case "FSA"
            '        Prot_Nr = 1
            '    Case "Aut ED"
            '        If Feststellung = "RM-ED" Then
            '            Prot_Nr = 1
            '        Else
            '            Prot_Nr = 1
            '        End If
            '    Case "Tor"
            '        Prot_Nr = 1
            '    Case "Aut F/ST"
            '        Prot_Nr = 1
            'End Select
            Prot_Nr = 1
            If Prot_Nr > 0 And Status <> "inaktiv" Then
                If Anzahl_JN Then
                    'Anzahl Protokolle f|fffd|r PDF-Erstellung
                    Prot_Anzahl = Prot_Anzahl + 1
                Else
                    'Prot_Kennung = Format(Prot_Nr, "A00")
                    Prot_Name = "Pr|fffd|fblatt"
                    B_Standort = Standort
                    B_Hersteller = Hersteller
                    B_Typ = Typ
                    B_T|fffd|rNr = T|fffd|rNr
                    B_SID = SID
                    B_AS_Typ = Antriebstyp
                    B_Feststellung = Feststellung
                    B_Fl|fffd|gel = Fl|fffd|gel
                    B_Pr|fffd|fdatum = Pr|fffd|fdatum
                    B_Pr|fffd|fer = Pr|fffd|fer
                    B_Pr|fffd|fbefund = Pr|fffd|fbefund
                    B_Pr|fffd|fbericht = Pr|fffd|fbericht
                    B_Ma|fffd|nahmen = Ma|fffd|nahme
                    
                    Sheets(Prot_Name).Activate
                    With ActiveSheet
                        .Range("B_AU_Nr") = B_AU_Nr
                        .Range("B_Standort") = B_Standort
                        .Range("B_WE_Firma1") = B_WE_Firma1
                        .Range("B_WE_Firma2") = B_WE_Firma2
                        .Range("B_WE_Strasse") = B_WE_Strasse
                        .Range("B_WE_PLZ_Ort") = B_WE_PLZ_Ort
                        .Range("B_AG_Firma1") = B_AG_Firma1
                        .Range("B_AG_Firma2") = B_AG_Firma2
                        .Range("B_AG_Strasse") = B_AG_Strasse
                        .Range("B_AG_PLZ_Ort") = B_AG_PLZ_Ort
                        .Range("B_T|fffd|rNr") = B_T|fffd|rNr
                        .Range("B_SID") = B_SID
                        .Range("B_Hersteller") = B_Hersteller
                        .Range("B_Typ") = B_Typ
                        .Range("B_AS_Typ") = B_AS_Typ
                        .Range("B_Feststellung") = B_Feststellung
                        .Range("B_Fl|fffd|gel") = B_Fl|fffd|gel
                        .Range("B_Pr|fffd|fdatum") = B_Pr|fffd|fdatum
                        .Range("B_Pr|fffd|fbefund") = B_Pr|fffd|fbefund
                        .Range("B_Pr|fffd|fbericht") = B_Pr|fffd|fbericht
                        .Range("B_Ma|fffd|nahmen") = B_Ma|fffd|nahmen
                        .Range("B_Pr|fffd|fer") = B_Pr|fffd|fer
                        If PDF_JN And Ist_PDF() Then
                            If Not Combine Then
                                ' PDF je Komponente erstellen...
                                'sPDFKomponente = "PB_" & P_ID & "_" & Format(Date, "YYYY") & ".pdf"
                                sPDFKomponente = "PB_" & P_ID & "_" & Format(IIf(SID = "", 0, SID), "000000") & "_" & Mid(T|fffd|rNr, 2) & ".pdf"
                                'sPDFKomponente = "PB_" & Mid(T|fffd|rNr, 2) & "_" & P_ID & ".pdf"
                                
                                pdfjob.cOption("AutosaveFilename") = Filename_Proper(sPDFKomponente)
                            End If
                            
                            .PrintOut Copies:=1, ActivePrinter:="PDFCreator", Collate:=True
                            Sleep PDF_Sleep
                            
                            If Not Combine Then
                                    'Do Until pdfjob.cCountOfPrintjobs = 1
                                    '    DoEvents
                                    '    Sleep 1000
                                    'Loop

                                pdfjob.cPrinterStop = False
                                Sleep PDF_Sleep
                                i = i + 1
                                'Antwort = MsgBoxT("Produkt " & i & vbCrLf & sPDFKomponente & " wird hinzugef|fffd|gt...", 1, sPDFName, vbOKOnly)
                                'Statusinfo "Produkt " & i & ": " & sPDFKomponente & " wird hinzugef|fffd|gt..."
                                WindowsZip sPDFPath & sPDFKomponente, Copy_Path() & sPDFName
                            End If
                        Else
                            If Ist_Test() Then
                                .PrintPreview
                             Else
                               .PrintOut Copies:=1
                            End If
                        End If
                        
                        .Range("B_AU_Nr").MergeArea.ClearContents
                        .Range("B_WE_Firma1").MergeArea.ClearContents
                        .Range("B_WE_Firma2").MergeArea.ClearContents
                        .Range("B_WE_Strasse").MergeArea.ClearContents
                        .Range("B_WE_PLZ_Ort").MergeArea.ClearContents
                        .Range("B_AG_Firma1").MergeArea.ClearContents
                        .Range("B_AG_Firma2").MergeArea.ClearContents
                        .Range("B_AG_Strasse").MergeArea.ClearContents
                        .Range("B_AG_PLZ_Ort").MergeArea.ClearContents
                        .Range("B_T|fffd|rNr").MergeArea.ClearContents
                        .Range("B_SID").MergeArea.ClearContents
                        .Range("B_Hersteller").MergeArea.ClearContents
                        .Range("B_Typ").MergeArea.ClearContents
                        .Range("B_AS_Typ").MergeArea.ClearContents
                        .Range("B_Feststellung").MergeArea.ClearContents
                        .Range("B_Fl|fffd|gel").MergeArea.ClearContents
                        .Range("B_Pr|fffd|fdatum").MergeArea.ClearContents
                        .Range("B_Pr|fffd|fbefund").MergeArea.ClearContents
                        .Range("B_Pr|fffd|fbericht").MergeArea.ClearContents
                        .Range("B_Ma|fffd|nahmen").MergeArea.ClearContents
                        
                    End With
                End If
                Protokoll_erstellen = Prot_Anzahl
            End If
            
        End If
    Next
    If Not Anzahl_JN And PDF_JN And Ist_PDF() Then
            sPDFName = Sheets("Param").Range("SANA_Prot_PDF")

        If pdfjob.cCountOfPrintjobs = Prot_Anz() And Combine Then
            If Combine Then pdfjob.cCombineAll
            Sleep 1000
            pdfjob.cPrinterStop = False
        End If
        Sleep 2000
        pdfjob.cClose
        Set pdfjob = Nothing
        
        Application.ActivePrinter = OldPrinter

        Antwort = MsgBox(sPDFName & " anzeigen?", vbQuestion + vbOKCancel, App_Name)
        If Antwort = vbOK Then
            Open_Proper Copy_Path() & sPDFName
        End If
    End If
    Set Bereich = Nothing
End With
Sheets(1).Activate
Application.ScreenUpdating = True

Exit_:
Exit Function

Err_:
MsgBox Err.Description
Resume Exit_
End Function
Function Prot_Anz() As Integer
    Prot_Anz = Sheets("Param").Range("A00_Anzahl")
End Function

Function Protokolle_ok() As Integer
Dim msg As String, Antwort As Integer, nDefault
If Ist_SANA() Then
    'inaktive ausblenden
    Sheets(1).P_AktivC = True
    'Sheets(1).Range("P_AktivJN") = True
    Formeln_einf|fffd|gen
    
    Sheets("Param").Range("A00_Anzahl") = Protokoll_erstellen(True)
    
    Select Case SANA_Status
    Case 0
        msg = "Schritt 1 ausf|fffd|hren -> JA"
        nDefault = vbDefaultButton1
    Case 1
        If Ist_PDF() Then
            msg = "Schritt 2 ausf|fffd|hren -> NEIN"
            nDefault = vbDefaultButton2
        Else
            msg = "PDF-Erstellung deaktiviert -> Abbrechen"
            nDefault = vbDefaultButton3
        End If
    End Select
    
        Antwort = MsgBox("Schritt 1: " & vbCrLf & Prot_Anz() & " Pr|fffd|fbl|fffd|tter ausdrucken." _
        & vbCrLf _
        & "Aktiver Drucker:" & Application.ActivePrinter _
        & vbCrLf & IIf(Ist_Test(), "Im Testmodus: Druckvorschau" & vbCrLf, "") & vbCrLf _
        & IIf(Ist_PDF(), _
        "Schritt 2: " & vbCrLf & "Protokolle als PDF erstellen." _
        & vbCrLf _
        & Copy_Path() _
        & vbCrLf _
        & Sheets("Param").Range("SANA_Prot_PDF") _
        , "") _
        & vbCrLf & vbCrLf _
        & "Aktion: " & vbTab & msg _
        , vbQuestion + vbYesNoCancel + nDefault, App_Name)
    If Antwort = vbYes Then
        Protokoll_erstellen False
        SANA_Status = 1
        Protokolle_ok = 1
    ElseIf Antwort = vbNo And Ist_PDF Then
        Protokoll_erstellen False, True
        SANA_Status = 2
        Protokolle_ok = 2
    Else
        Sheets("Param").Range("A00_Anzahl") = 0
        SANA_Status = 0
    End If
End If

End Function
Function Data_ok() As Boolean
Dim Antwort As Integer
Data_ok = True
If Sheets(1).Range("AU_Nr") = "" Then
    Antwort = MsgBox("Keine Auftragsnummer vorhanden!" _
    & vbCrLf & vbCrLf _
    & "Unterlagen k|fffd|nnen nicht erstellt werden." _
    , vbOKOnly + vbExclamation, App_Name())
    Data_ok = False
    GoTo Exit_
ElseIf Sheets(1).Range("WE_Firma1") = "" Then
    Antwort = MsgBox("Kein Objekt vorhanden!" _
    & vbCrLf & vbCrLf _
    & "Unterlagen k|fffd|nnen nicht erstellt werden." _
    , vbOKOnly + vbExclamation, App_Name())
    Data_ok = False
    GoTo Exit_
ElseIf Item_Anz() = 0 Then
    Antwort = MsgBox("Kein Produkte vorhanden!" _
    & vbCrLf & vbCrLf _
    & "Unterlagen k|fffd|nnen nicht erstellt werden." _
    , vbOKOnly + vbExclamation, App_Name())
    Data_ok = False
    GoTo Exit_
ElseIf Not Sign_exist(0) Or Not Sign_exist(1) Then
    Antwort = MsgBox("Fehlende Unterschrift!" _
    & vbCrLf & vbCrLf _
    & IIf(Not Sign_exist(0), "Kunde", "") _
    & vbCrLf _
    & IIf(Not Sign_exist(1), "Techniker", "") _
    & vbCrLf & vbCrLf _
    & "Fortfahren, da keine unterschriftsberechigte Person vor Ort?" _
    , vbQuestion + vbYesNo + vbDefaultButton2, App_Name())
    If Antwort = vbNo Then
        Data_ok = False
        GoTo Exit_
    End If
End If

'If Not TN_ok() Then    '31.01.2017 Pr|fffd|fung nicht erforderlich, da fortlaufende Nr. verwendet wird
'        Data_ok = False
'        GoTo Exit_
'End If

If Dir(Copy_PathFile()) = "" Then
    If CopyFile(False) = False Then
        Antwort = MsgBox("Unterlagen k|fffd|nnen nicht automatisch erstellt werden." _
        & vbCrLf & vbCrLf _
        & "Erstellen Sie die Datei manuell." _
        , vbExclamation, App_Name())
        Data_ok = False
        GoTo Exit_
    End If
Else
    If Antwort = vbYes Then 'keine US vorhanden
        Antwort = vbOK
    Else
        Antwort = MsgBox("Unterschriften werden nach PDF-Erstellung gel|fffd|scht!" _
        & vbCrLf & vbCrLf _
        & "Fortfahren?" _
        , vbQuestion, App_Name())
    End If
    If Antwort = vbOK Then
        If Not ActiveWorkbook.Saved Then ActiveWorkbook.Save
    Else
        Data_ok = False
        GoTo Exit_
    End If
End If

Exit_:
Exit Function
End Function
Function Ist_Mail() As Boolean
Ist_Mail = Sheets("Param").Range("Mail_JN")
End Function
Function Ist_PDF() As Boolean
Ist_PDF = Sheets("Param").Range("PDF_JN")
End Function
Function Ist_Extern() As Boolean
Ist_Extern = Sheets("Param").Range("Extern_JN")
End Function

Function Sleep_ms() As Integer
Sleep_ms = Sheets("Param").Range("PDF_Sleep")
If Val(Sleep_ms) < 1000 Then
    Sleep_ms = 1000
ElseIf Val(Sleep_ms) > 3000 Then
    Sleep_ms = 3000
End If
End Function
Function System_ok() As Boolean
Dim Antwort As Integer
System_ok = True
If Ist_PDF() Then
    If Not PDFCreator_installed(False) Then
        Sheets("Param").Range("PDF_JN") = False
        Antwort = MsgBoxT("PDFCreator nicht installiert!" _
        & vbCrLf & vbCrLf _
        & "PDF-Erstellung wurde deaktiviert!" _
        , 1, "Systempr|fffd|fung", vbExclamation + vbOKOnly)
        GoTo Err_
    End If
End If
If Ist_Mail() Then
    If Not OutlookInstalliert(False) Then
        If Not LotusInstalliert(False) Then
            Sheets("Param").Range("Mail_JN") = False
            Antwort = MsgBoxT("Kein Outlook oder Lotus Notes installiert!" _
            & vbCrLf & vbCrLf _
            & "E-Mail-Erstellung wurde deaktiviert!" _
            , 1, "Systempr|fffd|fung", vbExclamation + vbOKOnly)
            GoTo Err_
        End If
    End If
End If

Exit_:
Exit Function

Err_:
System_ok = False
GoTo Exit_
End Function

Function xl_to_mdb() As Integer
Dim Bereich As Object, Zeile As Object, Zelle As Object, Antwort As Integer
Dim SIDx, T_Nrx, AU_Nrx, WE_Nrx, Artx, Standortx, Typx, Herstellerx, A_Typx, Feststellungx, F_Anzx, P_Datumx, P_Befundx, P_Berichtx, P_Ma|fffd|nahmex, P_Pr|fffd|ferx, P_Empf|fffd|ngerx, P_Statusx, AG_KdNrx, AG_Name1x, AG_Name2x, AG_Landx, AG_PLZx, AG_Ortx, AG_Strx, WE_Name1x, WE_Name2x, WE_Landx, WE_PLZx, WE_Ortx, WE_Strx, Statusx, erstellt_amx, erstellt_vonx, B_KompNrx, G_Standortx, WE_Mailx, AG_Mailx
Dim B_AU_Nr, B_WE_Nr, B_AG_Nr, B_WE_Firma1, B_WE_Firma2, B_WE_Strasse, B_WE_PLZ_Ort As String, B_AG_Firma1, B_AG_Firma2, B_AG_Strasse, B_AG_PLZ_Ort As String, PN_Datum
Dim SID, T|fffd|rNr, Art, Standort, Typ, Hersteller, Antriebstyp, Feststellung, Fl|fffd|gel, Pr|fffd|fdatum, Pr|fffd|fbefund, Pr|fffd|fer, Pr|fffd|fbericht, Ma|fffd|nahme, Status, B_Empf|fffd|nger, B_KompNr, G_Standort, WE_Mail, AG_Mail
Dim strSQL_Add As String, strSQL_Add2 As String, strSQL_Del As String
Dim strSQL_Upd As String, strSQL_Upd2 As String, Krit_Upd As String, Krit_Del As String, Upd_JN As Boolean, Add_JN As Boolean, New_JN As Boolean, sTable As String, Del_JN As Boolean
On Error GoTo Err_
Application.CalculateFull
strSQL_Add = Sheets("Param").Range("DB_Qry1")
strSQL_Upd = Sheets("Param").Range("DB_Qry2")
strSQL_Del = Sheets("Param").Range("DB_Qry3")

Upd_JN = Sheets("Param").Range("DB_Upd_JN")
Add_JN = Sheets("Param").Range("DB_Add_JN")
New_JN = Sheets("Param").Range("DB_New_JN")
Del_JN = Sheets("Param").Range("DB_Del_JN")

sTable = Sheets("Param").Range("DB_Table")

If Upd_JN Or Add_JN Or New_JN Then
    xl_to_mdb = mdb_SQL_Batch()
    GoTo Exit_
End If
P_Bereich_setzen


With Sheets(1)
    PN_Datum = .Range("PN_Datum")
    
    Set Bereich = .Range("P_Bereich")
    For Each Zeile In Bereich.Rows
        If Zeile.Row >= P_FirstRow() Then
            Pr|fffd|fer = .Range("Sign_Name2")
            B_Empf|fffd|nger = .Range("Sign_Name1")
            B_AU_Nr = .Range("AU_Nr")
            B_WE_Nr = .Range("WE_Nr")
            B_WE_Firma1 = .Range("WE_Firma1")
            B_WE_Firma2 = .Range("WE_Firma2")
            B_WE_Strasse = .Range("WE_Strasse")
            B_WE_PLZ_Ort = .Range("WE_PLZ_Ort")
            B_AG_Firma1 = .Range("AG_Firma1")
            B_AG_Nr = .Range("AG_Nr")
            B_AG_Firma2 = .Range("AG_Firma2")
            B_AG_Strasse = .Range("AG_Strasse")
            B_AG_PLZ_Ort = .Range("AG_PLZ_Ort")
            
            G_Standort = .Range("G_Standort")
            WE_Mail = .Range("WE_Mail")
            AG_Mail = .Range("AG_Mail")
            
            
            SID = .Cells(Zeile.Row, 1)
            T|fffd|rNr = .Cells(Zeile.Row, 2)
            Art = .Cells(Zeile.Row, 3)
            Standort = .Cells(Zeile.Row, 4)
            Typ = .Cells(Zeile.Row, 5)
            Hersteller = .Cells(Zeile.Row, 6)
            Antriebstyp = .Cells(Zeile.Row, 7)
            Feststellung = .Cells(Zeile.Row, 8)
            Fl|fffd|gel = .Cells(Zeile.Row, 9)
            Pr|fffd|fdatum = .Cells(Zeile.Row, 10)
            Pr|fffd|fbefund = .Cells(Zeile.Row, 11)
            'Pr|fffd|fbefund = Pr|fffd|fbefund & IIf(IsEmpty(Pr|fffd|fbefund), "", " = " & Param("Befund" & Pr|fffd|fbefund, 3))
            Pr|fffd|fbericht = .Cells(Zeile.Row, 12)
            Ma|fffd|nahme = .Cells(Zeile.Row, 13)
            Status = .Cells(Zeile.Row, 14)
            B_KompNr = .Cells(Zeile.Row, 15)
            
            'Felder aufbereiten f|fffd|r Insert
            SIDx = fProper(SID) & " As SID, "
            T_Nrx = fProper(T|fffd|rNr) & " As T_Nr, "
            AU_Nrx = fProper(B_AU_Nr) & " As AU_Nr, "
            Artx = fProper(Art) & " As Art, "
            Standortx = fProper(Standort) & " As Standort, "
            Typx = fProper(Typ) & " As Typ, "
            Herstellerx = fProper(Hersteller) & " As Hersteller, "
            A_Typx = fProper(Antriebstyp) & " As A_Typ, "
            Feststellungx = fProper(Feststellung) & " As Feststellung, "
            F_Anzx = fProper(Fl|fffd|gel) & " As F_Anz, "
            P_Datumx = fProper(Pr|fffd|fdatum, "Date") & " As P_Datum, "
            P_Befundx = fProper(Pr|fffd|fbefund, "Zahl") & " As P_Befund, "
            P_Berichtx = fProper(Pr|fffd|fbericht) & " As P_Bericht, "
            P_Ma|fffd|nahmex = fProper(Ma|fffd|nahme) & " As P_Ma|fffd|nahme, "
            P_Pr|fffd|ferx = fProper(Pr|fffd|fer) & " As P_Pr|fffd|fer, "
            P_Empf|fffd|ngerx = fProper(B_Empf|fffd|nger) & " As P_Empf|fffd|nger, "
            P_Statusx = fProper(Status) & " As P_Status, "
            AG_KdNrx = fProper(B_AG_Nr) & " as AG_KdNr, "
            AG_Name1x = fProper(B_AG_Firma1) & " As AG_Name1, "
            AG_Name2x = fProper(B_AG_Firma2) & " As AG_Name2, "
            AG_Landx = "NULL as AG_Land, "
            AG_PLZx = fProper(NurZahl(B_AG_PLZ_Ort), "String") & " As AG_PLZ, "
            AG_Ortx = fProper(Trim(OhneZahl(B_AG_PLZ_Ort))) & " As AG_Ort, "
            AG_Strx = fProper(B_AG_Strasse) & " As AG_Str, "
            WE_Nrx = fProper(B_WE_Nr) & " as WE_Nr, "
            WE_Name1x = fProper(B_WE_Firma1) & " As WE_Name1, "
            WE_Name2x = fProper(B_WE_Firma2) & " As WE_Name2, "
            WE_Landx = "NULL as WE_Land, "
            WE_PLZx = fProper(NurZahl(B_WE_PLZ_Ort), "String") & " As WE_PLZ, "
            WE_Ortx = fProper(Trim(OhneZahl(B_WE_PLZ_Ort))) & " As WE_Ort, "
            WE_Strx = fProper(B_WE_Strasse) & " As WE_Str, "
            Statusx = " 1 as Status, "
            erstellt_amx = fProper(Date, "Date") & " As erstellt_am, "
            erstellt_vonx = fProper(Login_akt()) & " As erstellt_von, "
            B_KompNrx = fProper(B_KompNr) & " as Komp_Nr, "
            G_Standortx = fProper(G_Standort) & " as G_Standort, "
            WE_Mailx = fProper(WE_Mail) & " as WE_Mail, "
            AG_Mailx = fProper(AG_Mail) & " as AG_Mail "
            
            strSQL_Add2 = "Select " _
            & SIDx & T_Nrx & AU_Nrx & Artx & Standortx & Typx & Herstellerx & A_Typx & Feststellungx & F_Anzx & P_Datumx & P_Befundx & P_Berichtx & P_Ma|fffd|nahmex & P_Pr|fffd|ferx & P_Empf|fffd|ngerx & P_Statusx & AG_KdNrx & AG_Name1x & AG_Name2x & AG_Landx & AG_PLZx & AG_Ortx & AG_Strx & WE_Nrx & WE_Name1x & WE_Name2x & WE_Landx & WE_PLZx & WE_Ortx & WE_Strx & Statusx & erstellt_amx & erstellt_vonx & B_KompNrx & G_Standortx & WE_Mailx & AG_Mailx
            
            strSQL_Upd2 = "SET " _
            & AS_convert(SIDx) & AS_convert(T_Nrx) & AS_convert(AU_Nrx) & AS_convert(Artx) & AS_convert(Standortx) _
            & AS_convert(Typx) & AS_convert(Herstellerx) & AS_convert(A_Typx) & AS_convert(Feststellungx) & AS_convert(F_Anzx) _
            & AS_convert(P_Datumx) & AS_convert(P_Befundx) & AS_convert(P_Berichtx) & AS_convert(P_Ma|fffd|nahmex) _
            & AS_convert(P_Pr|fffd|ferx) & AS_convert(P_Empf|fffd|ngerx) & AS_convert(P_Statusx) & AS_convert(AG_KdNrx) _
            & AS_convert(AG_Name1x) & AS_convert(AG_Name2x) & AS_convert(AG_Landx) & AS_convert(AG_PLZx) & AS_convert(AG_Ortx) _
            & AS_convert(AG_Strx) & AS_convert(WE_Nrx) & AS_convert(WE_Name1x) & AS_convert(WE_Name2x) & AS_convert(WE_Landx) & AS_convert(WE_PLZx) _
            & AS_convert(WE_Ortx) & AS_convert(WE_Strx) & AS_convert(Statusx) & AS_convert(erstellt_amx) & AS_convert(erstellt_vonx) _
            & " D_Modified=" & SQLDatum(Date) & ", " & AS_convert(B_KompNrx) & AS_convert(G_Standortx) & AS_convert(WE_Mailx) & AS_convert(AG_Mailx)
            
            Krit_Upd = " WHERE AU_Nr= " & fProper(B_AU_Nr) _
                    & " AND " & sTable & ".SID is not null AND " & sTable & ".SID = " & fProper(SID) _
                    & " AND " & sTable & ".P_Datum = " & fProper(Pr|fffd|fdatum, "Date")
                    
            'Pr|fffd|fdatum ignorieren
            Krit_Upd = " WHERE AU_Nr= " & fProper(B_AU_Nr) _
                    & " AND " & sTable & ".SID is not null AND " & sTable & ".SID = " & fProper(SID)
            
            Krit_Del = " WHERE AU_Nr= " & fProper(B_AU_Nr)
            
            'Upd_JN = True
            'Add_JN = PN_Datum = Date
            
            If Upd_JN And Len(SID) > 0 Then
                If RUNSQL(strSQL_Upd & strSQL_Upd2 & Krit_Upd) Then
                    Statusinfo "SID " & SID & " wird aktualisiert ..."
                    xl_to_mdb = xl_to_mdb + IIf(Add_JN, 0, 1)
                End If
            End If
            
            If Add_JN Then
                If (.Range("P_AktivJN") And Status <> "inaktiv") Or Not .Range("P_AktivJN") Then
                    If RUNSQL(strSQL_Add & strSQL_Add2) Then
                        Statusinfo "SID " & SID & " wird hinzugef|fffd|gt ..."
                        xl_to_mdb = xl_to_mdb + 1
                    End If
                End If
            End If
            
            If Del_JN Then
                If RUNSQL(strSQL_Del & Krit_Del) Then
                    Statusinfo "SID " & SID & " wird gel|fffd|scht ..."
                    xl_to_mdb = xl_to_mdb + 1
                End If
            End If
            
            If New_JN Then
                If Status = "Neu" And Len(SID) > 0 Then
                    If Not Data_exist("SID", SID) Then
                        If RUNSQL(strSQL_Add & strSQL_Add2) Then
                            Statusinfo "SID " & SID & " wird neu hinzugef|fffd|gt ..."
                            xl_to_mdb = xl_to_mdb + 1
                        End If
                    End If
                End If
            End If
        End If
    Next
End With

Statusinfo
Exit_:
Exit Function

Err_:
MsgBox Err.Description
Resume Exit_
End Function

Function AS_convert(sFieldstring As Variant) As String
Dim nPos1 As Integer, nPos2 As Integer, sValue, sFieldName
nPos1 = InStr(1, sFieldstring, " As ")
If nPos1 > 0 Then
    sValue = Left(sFieldstring, nPos1)
    sFieldName = Mid(sFieldstring, nPos1 + 4)
    nPos2 = InStr(1, sFieldName, ",")
    If nPos2 > 0 Then
        sFieldName = Left(sFieldName, nPos2 - 1)
        sValue = Trim(sValue) & ", "
    End If
    AS_convert = sFieldName & " = " & sValue
End If
End Function
Function Ist_DB() As Boolean
Ist_DB = Sheets("Param").Range("DB_Sync_JN") And DB_available(True)
End Function

Sub DB_Synchronisieren()
Dim Antwort As Integer, msg1 As String, msg2 As String, DS_Anz As Integer, DS_Anz_neu As Integer, DS_Anz_SID As Integer
Dim sAdd As Boolean, sUpd As Boolean, sNew As Boolean, sDel As Boolean

If CopyFile(False) = False Then GoTo Exit_
If Not Data_ok() Then GoTo Exit_
'Formeln_einf|fffd|gen
sAdd = Sheets("Param").Range("DB_Add_JN")
sUpd = Sheets("Param").Range("DB_Upd_JN")
sNew = Sheets("Param").Range("DB_New_JN")
sDel = Sheets("Param").Range("DB_Del_JN")

AU_exist = Data_exist("AU_Nr", Range("AU_Nr"))

If AU_exist Then
    If sAdd Then
        Antwort = MsgBoxT("Auftrag " & Range("AU_Nr") & " ist vorhanden." _
        & vbCrLf & vbCrLf _
        & "Um alle Produkte hinzuzuf|fffd|gen, m|fffd|ssen Sie erst den Auftrag in der " & DB_Name() & " l|fffd|schen." _
        & vbCrLf & vbCrLf _
        & "F|fffd|hren Sie anschlie|fffd|end den Export erneut durch." _
        , 5, "Datenpr|fffd|fung", vbOKOnly + vbExclamation)
        GoTo Exit_
    End If
Else
    If sUpd Or sNew Then
        Antwort = MsgBoxT("Auftrag " & Range("AU_Nr") & " ist nicht vorhanden." _
        & vbCrLf & vbCrLf _
        & "Bitte w|fffd|hlen Sie Option 'Alle hinzuf|fffd|gen'" _
        , 2, "Datenpr|fffd|fung", vbOKOnly + vbExclamation)
        GoTo Exit_
    ElseIf sDel Then
        Antwort = MsgBoxT("Auftrag " & Range("AU_Nr") & " ist nicht vorhanden." _
        & vbCrLf & vbCrLf _
        & "L|fffd|schen nicht m|fffd|glich!" _
        , 2, "Datenpr|fffd|fung", vbOKOnly + vbExclamation)
        GoTo Exit_
    End If

End If

DS_Anz_neu = Sheets(1).Range("PN_neu")
DS_Anz_SID = Sheets(1).Range("PN_SID")

If sUpd Then
    msg1 = DS_Anz_SID & " Produkte mit gleichem Pr|fffd|fdatum aktualisieren" _
    & vbCrLf
    
    'SID statt Pr|fffd|fdatum
    msg1 = DS_Anz_SID & " Produkte mit gleicher SID aktualisieren" _
    & vbCrLf
End If
If sAdd Then
    msg2 = IIf(Range("P_AktivJN"), Range("PN_Anzahl") & " aktive", Item_Anz()) & " Produkte hinzuf|fffd|gen"
ElseIf sNew Then
    msg2 = DS_Anz_neu & " neue Produkte hinzuf|fffd|gen"
ElseIf sDel Then
    msg1 = Item_Anz() & " Produkte dieses Auftrags l|fffd|schen"
End If

If DS_Anz_neu = 0 And sNew Then
    Antwort = MsgBoxT("Keine neuen Produkte vorhanden!" _
    , 2, App_Name() & " synchronisieren", vbExclamation + vbOKOnly)
    GoTo Exit_
End If

Antwort = MsgBox(msg1 & msg2 _
& vbCrLf & vbCrLf _
& "Synchronisierung starten?" _
, vbQuestion + vbOKCancel + vbDefaultButton2, App_Name() & " synchronisieren")

If Antwort = vbOK Then
    DS_Anz = xl_to_mdb()
    Antwort = MsgBoxT(DS_Anz & " Datens|fffd|tze wurden synchronisiert.", 2, App_Name() & " synchronisieren", vbInformation + vbOKOnly)
End If

Exit_:
Exit Sub
End Sub
Sub DB_Controls_setzen()
Dim ShowJN As Boolean
ShowJN = Ist_DB()
With Sheets(1)
    .DB_Sync.Visible = ShowJN
    .DB_Add_JNc.Visible = ShowJN
    .DB_New_JNc.Visible = ShowJN
    .DB_Upd_JNc.Visible = ShowJN
    .DB_Del_JNc.Visible = ShowJN
    .DB_Query.Visible = ShowJN
    .DB_ImportC.Visible = ShowJN
End With
End Sub
Function Data_exist(sFieldName As String, ByVal sValue As String) As Boolean
Dim exist
Statusinfo sFieldName & " " & sValue & " wird gepr|fffd|ft..."
exist = DLookup(sFieldName, Sheets("Param").Range("DB_Table"), , sFieldName & "='" & sValue & "'")
Data_exist = Len(exist)
Statusinfo
End Function

Sub SID_setzen()
Dim i As Long
With Sheets(1)
    For i = P_FirstRow() To P_LastRow() - 1
        If .Cells(i, C_SID) = "" Then
            .Cells(i, C_SID) = "'" & .Range("WE_Nr") & "_" & i
        End If
    Next i
End With
End Sub
Sub Komp_Nr_setzen()
Dim Antwort As Integer, sTitle As String, KompNr As String, msg As String, c_KompNr As Integer, i As Integer
sTitle = "Komponenten-Nr. |fffd|bernehmen"
msg = "Zuordnung Komponenten-Nr. zu sichtbaren Produkten." _
& vbCrLf _
& "(Ausgeblendete Zeilen werden nicht ber|fffd|cksichtigt.)"
c_KompNr = 15
If Item_Anz() = 0 Then
    MsgBoxT "Keine Produkte f|fffd|r Zuordnung vorhanden!", 2, sTitle, vbExclamation
    Exit Sub
End If

KompNr = InputBox(msg & vbCrLf & vbCrLf & "Komp.-Nr. eingeben", sTitle, Range("B_KompNr"))
If KompNr = "" Then Exit Sub

With Sheets(1)
    For i = P_FirstRow() To P_LastRow() - 1
        If .Cells(i, c_KompNr) = "" And Not Rows(i).Hidden Then
            .Cells(i, c_KompNr) = "'" & KompNr
        End If
    Next i
End With
End Sub
Sub DB_Import()
Dim Antwort As Integer, i As Integer, Pos_Last As Integer, P_Dat_Anz  As Long, P_DB_Pages As Integer
If Item_Anz() < 0 Then
    Antwort = MsgBox("Import kann nicht ausgef|fffd|hrt werden!" _
    & vbCrLf & vbCrLf _
    & Item_Anz() & " Produkte sind vorhanden!" _
    & vbCrLf & vbCrLf _
    & "Bitte erstellen Sie einen neuen Pr|fffd|fnachweis." _
    , vbExclamation, "Daten importieren")
    Exit Sub
End If
If Range("AU_Nr") = "" Then
    Antwort = MsgBox("Import kann nicht ausgef|fffd|hrt werden!" _
    & vbCrLf & vbCrLf _
    & "Bitte geben Sie eine Auftragsnummer ein!" _
    & vbCrLf & vbCrLf _
    & "" _
    , vbExclamation, "Daten importieren")
    Exit Sub
End If
P_Dat_Anz = DS_Anzahl()
If P_Dat_Anz = 0 Then
    MsgBox "Keine Produkte zu Auftrag " & Range("AU_Nr") & " gefunden.", vbInformation, "Daten importieren"
    Exit Sub
Else
    Antwort = MsgBox("Auftrag " & Range("AU_Nr") & " importieren?" _
    & vbCrLf & vbCrLf _
    & P_Dat_Anz & " Produkte" _
    & vbCrLf & vbCrLf _
    & "" _
    , vbQuestion + vbOKCancel, "Daten importieren")
End If

If Antwort = vbOK Then
    Del_Signature 0
    Del_Signature 1
    'Lines_delete
    Pos_Last = P_LastRow() - 1
    P_DB_Pages = P_Dat_Anz / Sheets("Param").Range("R_Anzahl2")
    For i = 1 To CInt(P_DB_Pages) + 2
        Page_add
    Next i
    
    'RUNSQL Range("DB_Select2"), Sheets(1).Range("A" & P_FirstRow())
    RUNSQL Range("DB_Select2"), Sheets(1).Range("A" & Pos_Last)
    
    Rows(Pos_Last).Delete
    Liste_verdichten
End If
End Sub
Function DS_Anzahl() As Long
Statusinfo "Bitte warten..."
Application.Cursor = xlWait
DS_Anzahl = Domain(dtCount, "AU_Nr", "PN_Data_all", , Range("DB_Where2"))
Statusinfo
Application.Cursor = xlDefault
End Function
Function File_new() As Boolean
File_new = Left(Copy_FileName, 10) <> Left(ActiveWorkbook.name, 10)
End Function
Sub TN_pr|fffd|fen(SetzenJN As Boolean)
Dim i As Integer, C_TN
C_TN = 2
With Sheets(1)
    For i = P_FirstRow() To P_LastRow() - 1
        If SetzenJN Then
            If IsDate(.Cells(i, C_TN)) Then
                .Cells(i, C_TN) = "_" & .Cells(i, C_TN)
            End If
        Else
            If Left(.Cells(i, C_TN), 1) = "_" Then
                .Cells(i, C_TN) = Mid(.Cells(i, C_TN), 2)
            End If
        End If
    Next i
End With
End Sub
Function TN_ok() As Boolean
Dim Antwort As Integer, sTitle As String, TN_neu As String, msg As String, i As Integer, TN_fehlt_Anz As Integer, SID_ok As Boolean

TN_fehlt_Anz = Item_Anz() - Range("PN_TN")
SID_ok = Range("PN_SID") = Item_Anz()

If TN_fehlt_Anz = 0 Or Item_Anz() = 0 Or Not Ist_SANA() Then
    TN_ok = True
    GoTo Exit_
Else
    sTitle = "Pr|fffd|fblatter"
    msg = "Pr|fffd|fbl|fffd|tter k|fffd|nnen nur f|fffd|r Produkte mit vorhandener T|fffd|rnummer erstellt werden." & vbCrLf & vbCrLf
    msg = msg & TN_fehlt_Anz & " fehlende T|fffd|rnummern durch fortlaufende Nummer ersetzen?" _
    & IIf(SID_ok, vbCrLf & vbCrLf _
    & "NEIN: SID als T|fffd|rnummer verwenden.", "") _
    & vbCrLf & vbCrLf _
    & "(Ausgeblendete Zeilen werden nicht ber|fffd|cksichtigt.)"
    
    Antwort = MsgBox(msg, IIf(SID_ok, vbYesNoCancel, vbOKCancel) + vbQuestion, sTitle)
    
    If Antwort = vbCancel Then
        TN_ok = False
        GoTo Exit_
    End If
    With Sheets(1)
        For i = P_FirstRow() To P_LastRow() - 1
            If .Cells(i, C_TN) = "" And .Cells(i, C_Plicht1) <> "" And Not Rows(i).Hidden Then
                If Antwort = vbNo Then
                    .Cells(i, C_TN) = .Cells(i, C_SID)
                Else
                    .Cells(i, C_TN) = i - P_FirstRow + 1
                End If
            End If
        Next i
    End With
    TN_ok = True
End If

Exit_:
Exit Function
End Function
Sub Import_PN()
On Error GoTo Err_
Dim Dateiname As String, Pfad As String, Antwort As Integer, i As Integer, Pos_Last As Integer, Kopf_JN As Boolean, Restore As Boolean
Dim vrtSelectedItem As Variant
Dim wb_PN As Workbook, sh_PN As Worksheet, imp_Kopfdaten As String, xl_Filename As String, msgTitle As String
Dim wb_imp As Workbook, sh_imp As Worksheet, P_imp As String, P_imp_Anz As Integer, P_imp_Pages As Double, pn_c_last As Integer, imp_c_last As Integer, C_Max As Integer
Dim AU_Nr As String, WE_Nr As String, WE_Firma1 As String, WE_Firma2 As String, WE_Strasse As String, WE_PLZ_Ort As String, WE_Mail As String, G_Standort As String, AG_Nr As String, AG_Firma1 As String, AG_Firma2 As String, AG_Strasse As String, AG_PLZ_Ort As String, AG_Mail As String, PN_Datum As String, PN_User As String, r_Titles As Integer, CSV_JN As Boolean
Set wb_PN = ThisWorkbook
Set sh_PN = wb_PN.Sheets(1)

Application.Cursor = xlWait
Statusinfo "Userdaten werden gepr|fffd|ft..."
pn_c_last = sh_PN.Range("P_Bereich").Columns.Count
C_Max = Range("PN_LastCol")
Pfad = Copy_Path()
Restore = Restore_ok()
msgTitle = "Pr|fffd|fnachweis importieren"

Application.Cursor = xlDefault
Statusinfo

With Application.FileDialog(msoFileDialogOpen)
    .AllowMultiSelect = False
    .InitialFileName = Pfad & "8*"
    .Filters.Clear
    .Filters.Add "Alle Pr|fffd|fnachweise", "*.csv; *.xls"
    .Filters.Add "Pr|fffd|fnachweise CSV-Dateien", "*.csv"
    .Filters.Add "Pr|fffd|fnachweise Excel", "*.xls"
    .Title = msgTitle
    
    If .Show = -1 Then
        For Each vrtSelectedItem In .SelectedItems
            Dateiname = vrtSelectedItem
            If Dateiname = ThisWorkbook.Path & "\" & ThisWorkbook.name Then
                MsgBox "Die Datei " & Copy_FileName() & " wird gerade bearbeitet!" _
                & vbCrLf & vbCrLf _
                & "Datei kann nicht nochmals ge|fffd|ffnet werden." _
                , vbExclamation, msgTitle
                GoTo Exit_
            ElseIf WB_loaded(Dateiname, False) Then
                WB_loaded Dateiname, True
            ElseIf ParsePath(Dateiname, "Ext") <> ".xls" And ParsePath(Dateiname, "Ext") <> ".csv" Then
                MsgBox "Ung|fffd|ltiger Dateityp!" _
                & vbCrLf & vbCrLf _
                & "Es k|fffd|nnen nur Dateien mit der Endung xls oder csv ge|fffd|ffnet werden." _
                , vbExclamation, msgTitle
                GoTo Exit_
            End If
            .Execute
            Set wb_imp = ActiveWorkbook
            Set sh_imp = wb_imp.Sheets(1)
        Next vrtSelectedItem
    'The user pressed Cancel.
    Else
        GoTo Exit_
    End If

End With

If Len(Dateiname) = 0 Then GoTo Exit_

CSV_JN = ParsePath(Dateiname, "EXT") = ".csv"
r_Titles = IIf(CSV_JN, 1, 11)


imp_c_last = nLastCol(sh_imp.name)

If sh_imp.Cells(r_Titles, 6) = "Elementetyp" Then  'SANA-Daten
    Antwort = MsgBox("ACHTUNG!" _
    & " " _
    & "Diese Datei hat eine abweichende Datenstruktur." _
    & vbCrLf & vbCrLf _
    & "Daten k|fffd|nnen nicht automatisch importiert werden." _
    & vbCrLf & vbCrLf _
    & "Datei schlie|fffd|en?" _
    & vbCrLf & vbCrLf _
    & "NEIN: Datei f|fffd|r manuelles Kopieren ge|fffd|ffnet lassen." _
    , vbExclamation + vbYesNo, msgTitle)
    
    If Antwort <> vbNo Then
        wb_imp.Close SaveChanges:=False
    End If
    GoTo Exit_
End If

imp_c_last = nLastCol(sh_imp.name)

'Kopfdaten einlesen
PN_Datum = Format(FileDateTime(Dateiname), "DD.MM.YYYY")

If CSV_JN Then
    xl_Filename = ParsePath(ReplaceStr(Dateiname, ".csv", ".xls"), "FILE_EXT")
    'Exportdatei aus DB
    xl_Filename = ReplaceStr(xl_Filename, "_Exp", "_W00" & Right(Date, 1))
Else
    xl_Filename = ParsePath(Dateiname, "FILE_EXT")
End If

With sh_imp
    If CSV_JN Then
        AU_Nr = .Cells(2, FieldCol("AU_Nr"))
        WE_Nr = .Cells(2, FieldCol("WE_Nr"))
        WE_Firma1 = .Cells(2, FieldCol("WE_Name1"))
        If WE_Firma1 = "" Then WE_Firma1 = .Cells(2, FieldCol("WE_Firma1"))
        WE_Firma2 = .Cells(2, FieldCol("WE_Name2"))
        If WE_Firma2 = "" Then WE_Firma2 = .Cells(2, FieldCol("WE_Firma2"))
        WE_PLZ_Ort = .Cells(2, FieldCol("WE_PLZ")) & " " & .Cells(2, FieldCol("WE_Ort"))
        WE_Strasse = .Cells(2, FieldCol("WE_Str"))
        WE_Mail = .Cells(2, FieldCol("WE_Mail"))
        G_Standort = .Cells(2, FieldCol("G_Standort"))
        AG_Nr = .Cells(2, FieldCol("AG_Nr"))
        AG_Firma1 = .Cells(2, FieldCol("AG_Name1"))
        If AG_Firma1 = "" Then AG_Firma1 = .Cells(2, FieldCol("AG_Firma1"))
        AG_Firma2 = .Cells(2, FieldCol("AG_Name2"))
        If AG_Firma2 = "" Then AG_Firma2 = .Cells(2, FieldCol("AG_Firma2"))
        AG_Strasse = .Cells(2, FieldCol("AG_Str"))
        AG_PLZ_Ort = .Cells(2, FieldCol("AG_PLZ")) & " " & .Cells(2, FieldCol("AG_Ort"))
        AG_Mail = .Cells(2, FieldCol("AG_Mail"))
        PN_User = .Cells(2, FieldCol("PN_User"))
        If PN_User = "" Then
            PN_User = .Cells(2, FieldCol("erstellt_von"))
        End If
        PN_Datum = .Cells(2, FieldCol("PN_Datum"))
        If PN_Datum = "" Then
            PN_Datum = .Cells(2, FieldCol("erstellt_am"))
        End If
        P_imp_Anz = nLastRow(sh_imp.name) - 1
    Else
        AU_Nr = .Range("AU_Nr")
        WE_Nr = .Range("WE_Nr")
        WE_Firma1 = .Range("WE_Firma1")
        WE_Firma2 = .Range("WE_Firma2")
        WE_PLZ_Ort = .Range("WE_PLZ_Ort")
        WE_Strasse = .Range("WE_Strasse")
        WE_Mail = .Range("WE_Mail")
        G_Standort = .Range("G_Standort")
        AG_Nr = .Range("AG_Nr")
        AG_Firma1 = .Range("AG_Firma1")
        AG_Firma2 = .Range("AG_Firma2")
        AG_Strasse = .Range("AG_Strasse")
        AG_PLZ_Ort = .Range("AG_PLZ_Ort")
        AG_Mail = .Range("AG_Mail")
        PN_User = .Range("Login_akt")
        PN_Datum = .Range("PN_Datum")
        P_imp_Anz = .Range("PN_Anzahl")
    End If
    
    If Len(AU_Nr) Then
        imp_Kopfdaten = IIf(Restore, "Auftrag " & vbTab & AU_Nr _
        , "Auftrag" & vbTab & "[aus Export]" _
        & vbCrLf & "-------------------------------") _
        & vbCrLf & "Objekt" & vbTab & WE_Nr _
        & vbCrLf & vbTab & WE_Firma1 _
        & IIf(Len(WE_Firma2), vbCrLf & vbTab & WE_Firma2, "") _
        & vbCrLf & vbTab & WE_Strasse _
        & vbCrLf & vbTab & WE_PLZ_Ort _
        & vbCrLf & vbTab & G_Standort _
        & vbCrLf _
        & vbCrLf & "AG" & vbTab & AG_Nr _
        & vbCrLf & vbTab & AG_Firma1 _
        & IIf(Len(AG_Firma2), vbCrLf & vbTab & AG_Firma2, "") _
        & vbCrLf & vbTab & AG_Strasse _
        & vbCrLf & vbTab & AG_PLZ_Ort
    End If
End With

If P_imp_Anz = 0 Then
    Antwort = MsgBox(ParsePath(Dateiname, "File_Ext") & " vom " & PN_Datum & " enth|fffd|lt keine Produkte!" _
    & vbCrLf & vbCrLf _
    & "Import wird nicht durchgef|fffd|hrt." _
    , vbExclamation, msgTitle)
    Antwort = vbCancel
ElseIf Len(imp_Kopfdaten) Then
    If Restore Then
        Antwort = MsgBox("Pr|fffd|fnachweis rekonstruieren?" _
        & vbCrLf & vbCrLf _
        & imp_Kopfdaten _
        & vbCrLf & vbCrLf _
        & P_imp_Anz & " Produkte" _
        & vbCrLf & vbCrLf _
        & "erstellt von " & PN_User & " am " & PN_Datum _
        & vbCrLf & vbCrLf _
        & "NEIN: Datei weiter anzeigen." _
        , vbQuestion + vbYesNoCancel, msgTitle)
        Kopf_JN = Antwort = vbYes
        
    Else
        Antwort = MsgBox("Wurde der aktuelle Auftrag aus SAP-mobile bereits exportiert?" _
        & vbCrLf & vbCrLf _
        & "Kopfdaten werden aus letztem SAP-Export |fffd|bernommen." _
        & vbCrLf & vbCrLf _
        & imp_Kopfdaten _
        & vbCrLf & vbCrLf _
        & P_imp_Anz & " Produkte" _
        & vbCrLf & vbCrLf _
        & "erstellt von " & PN_User & " am " & PN_Datum _
        , vbQuestion + vbOKCancel, msgTitle)
    End If
ElseIf Restore Then
    Antwort = MsgBox(ParsePath(Dateiname, "File_Ext") & " vom " & PN_Datum & " importieren?" _
    & vbCrLf & vbCrLf _
    & "Kopfdaten sind nicht vorhanden." _
    & vbCrLf & vbCrLf _
    & P_imp_Anz & " Produkte" _
    & IIf(Restore, vbCrLf & vbCrLf _
    & "NEIN: Datei weiter anzeigen.", "") _
    , vbQuestion + IIf(Restore, vbYesNoCancel, vbOKCancel), msgTitle)

Else
    Antwort = MsgBox(ParsePath(Dateiname, "File_Ext") & " vom " & PN_Datum & " importieren?" _
    & vbCrLf & vbCrLf _
    & "Kopfdaten werden aus letztem SAP-Export |fffd|bernommen." _
    & vbCrLf & vbCrLf _
    & P_imp_Anz & " Produkte" _
    & IIf(Restore, vbCrLf & vbCrLf _
    & "NEIN: Datei weiter anzeigen.", "") _
    , vbQuestion + IIf(Restore, vbYesNoCancel, vbOKCancel), msgTitle)
End If

If Antwort = vbCancel Then
    wb_imp.Close SaveChanges:=False
    Exit Sub
ElseIf Antwort = vbNo Then
    GoTo Exit_
End If

wb_PN.Activate
Del_Signature 0
Del_Signature 1
'Lines_delete
Pos_Last = P_LastRow() - 1
P_imp_Pages = P_imp_Anz / Sheets("Param").Range("R_Anzahl2")
For i = 1 To CInt(P_imp_Pages) + 2
    Page_add
Next i

wb_imp.Activate
P_imp = sh_imp.Cells(r_Titles + 1, 1).Address & ":" & sh_imp.Cells(P_imp_Anz + r_Titles, C_Max).Address

Range(P_imp).Copy


wb_PN.Activate
Range("A" & Pos_Last).Select
Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _
    :=False, Transpose:=False
    
Application.DisplayAlerts = False

wb_imp.Close SaveChanges:=False
Range("A" & Pos_Last).Select

Application.DisplayAlerts = True
Liste_verdichten


'T|fffd|rnummern wiederherstellen: "_" entfernen
TN_pr|fffd|fen False


    
If Kopf_JN Then
    Range("AU_Nr") = AU_Nr
    Range("WE_Nr") = WE_Nr
    Range("WE_Firma1") = WE_Firma1
    Range("WE_Firma2") = WE_Firma2
    Range("WE_Strasse") = WE_Strasse
    Range("WE_PLZ_Ort") = WE_PLZ_Ort
    Range("WE_Mail") = WE_Mail
    Range("G_Standort") = G_Standort
    Range("AG_Nr") = AG_Nr
    Range("AG_Firma1") = AG_Firma1
    Range("AG_Firma2") = AG_Firma2
    Range("AG_Strasse") = AG_Strasse
    Range("AG_PLZ_Ort") = AG_PLZ_Ort
    Range("AG_Mail") = AG_Mail
    Range("PN_Datum") = PN_Datum
    Range("Login_akt") = PN_User
    If Sheets(1).Range("PN_Anzahl") > 0 Then Sheets(1).csv_ImportC.Enabled = False
ElseIf Not Restore Then
    'Kopfdaten aus export.csv ohne Nachfrage
    AdrDatei_read True
    Range("PN_Datum") = Date    'PN_Datum
    Range("Login_akt") = Login_akt()
    Del_P_Ergebnisse False
    CopyFile True
    GoTo Exit_
Else
    If Range("AU_Nr") = "" Then
        GoTo Exit_
    End If
End If
 



If Val(Application.Version) > 11 Then
    ActiveWorkbook.CheckCompatibility = False
End If
                    
If Dir(xl_Filename) <> "" Then Kill xl_Filename
                    
ActiveWorkbook.SaveAs xl_Filename, FileFormat:=xlFormat()
ActiveWindow.Caption = ActiveWorkbook.name
    

Exit_:
Set wb_PN = Nothing
Set sh_PN = Nothing
Set wb_imp = Nothing
Set sh_imp = Nothing
Exit Sub

Err_:
If Err.Number = 1004 Then
    Resume Next 'Exit_
Else
    MsgBox Err.Number & ": " & Err.Description
    Resume Exit_
End If
End Sub

Function Restore_ok() As Boolean
Dim sFunktion As String
If DB_available(True) Then
    sFunktion = Userdata("Funktion")
    Restore_ok = sFunktion <> "ST"
End If
If Ist_Test() Then Restore_ok = False
End Function
Function FAnz_OK() As Boolean
Dim i As Integer, C_Typ, C_FAnz, Typ, FAnz, F_OK As Boolean, msg As String, Dub_Anz As Integer
C_Typ = 5
C_FAnz = 9
FAnz_OK = True
With Sheets(1)
    For i = P_FirstRow() To P_LastRow() - 1
        Typ = .Cells(i, C_Typ)
        FAnz = .Cells(i, C_FAnz)
        If InStr(1, Typ, "HSW") = 0 And Len(Typ) Then
            If InStr(1, Typ, "Schranke") = 0 Then
                Select Case Typ
                Case "Kerberos"
                    F_OK = FAnz = 3
                Case "Charon"
                    F_OK = FAnz > 0 And FAnz <= 4
                Case "Kentaur"
                    F_OK = FAnz = 1 Or FAnz = 3 Or FAnz = 4
                Case "Geryon"
                    F_OK = FAnz > 1 And FAnz <= 4
                Case "Talos"
                    F_OK = FAnz >= 3 And FAnz <= 4
                Case "Orthos"
                    F_OK = FAnz >= 2 And FAnz <= 3
                Case "Talos"
                    F_OK = FAnz = 2
                Case Else
                    F_OK = FAnz > 0 And FAnz <= 2
                End Select
            Else
                F_OK = FAnz = 1
            End If
            If Not F_OK Then msg = msg & vbCrLf & "Zeile " & i & ":" & vbTab & IIf(FAnz = "", 0, FAnz) & " Fl|fffd|gel f|fffd|r " & Typ & " nicht zul|fffd|ssig!"
        ElseIf Len(Typ) Then
            F_OK = FAnz > 0
            If Not F_OK Then msg = msg & vbCrLf & "Zeile " & i & ":" & vbTab & IIf(FAnz = "", 0, FAnz) & " Fl|fffd|gel f|fffd|r " & Typ & " nicht zul|fffd|ssig!"
        Else
            F_OK = True
        End If
        If Not F_OK Then
            FAnz_OK = False
        End If
    Next i
    If Not FAnz_OK Then MsgBox msg, vbOKOnly + vbExclamation, "Pr|fffd|fung Fl|fffd|gelanzahl"

    'Dublettenpr|fffd|fung
    If FAnz_OK Then
        Dub_Pr|fffd|fen "SID", True
        Dub_Anz = Dub_Pr|fffd|fen("SID", False)
        FAnz_OK = Dub_Anz = 0
        If Not FAnz_OK Then
            MsgBox Dub_Anz & " Dubletten im Feld SID vorhanden!" & vbCrLf & vbCrLf & "Verarbeitung wird abgebrochen.", vbOKOnly + vbExclamation, "Dublettenpr|fffd|fung SID"
        End If
    End If
End With
End Function
Function Dub_Pr|fffd|fen(FeldName As String, ResetJN As Boolean) As Integer
Dim Dub_Anz As Integer
Select Case FeldName
    Case "T|fffd|rnummer"
    Dub_Anz = Doppelte_markieren(2, ResetJN)
    Case "SID"
    Dub_Anz = Doppelte_markieren(1, ResetJN)
End Select
If ResetJN Then Dub_Anz = -1
Dub_Pr|fffd|fen = Dub_Anz
End Function

Function Doppelte_markieren(nSpalte As Long, Optional Reset_JN As Boolean) As Long
'Duplikate in sortierter Liste rot markieren
Dim nBisZeile As Long, nAbZeile As Long, i As Long, sDup As String, sDup1 As String
Const Farbe1 As Integer = 3, Farbe2 As Integer = 4
Sheets(1).Activate

nAbZeile = P_FirstRow()
nBisZeile = P_LastRow() - 1
 
For i = nAbZeile To nBisZeile Step 1
    sDup = Cells(i, nSpalte).Value
    sDup1 = Cells(i + 1, nSpalte).Value
    If sDup <> "" And Application.WorksheetFunction.CountIf(Range(Cells(1, nSpalte), Cells(nBisZeile, nSpalte)), sDup) <> 1 Then
       If sDup = sDup1 Then
            Cells(i, nSpalte).Interior.ColorIndex = IIf(Reset_JN, xlColorIndexNone, Farbe1)
        Else
            Cells(i, nSpalte).Interior.ColorIndex = IIf(Reset_JN, xlColorIndexNone, Farbe1)
        End If
        Doppelte_markieren = Doppelte_markieren + 1
    ElseIf Reset_JN Then
        Cells(i, nSpalte).Interior.ColorIndex = xlColorIndexNone
    End If
Next i

End Function

Attribute VB_Name = "mod_Draw"
Option Explicit

Declare Function CreatePen Lib "gdi32" (ByVal nPenStyle As Long, ByVal nWidth As Long, ByVal crColor As Long) As Long
Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
Declare Function LineTo Lib "gdi32" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long) As Long
Declare Function MoveToEx Lib "gdi32" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long, lpPoint As POINTAPI) As Long
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

' Constants used in the GetDeviceCaps call
Private Const LOGPIXELSX = 88   '  Pixels/inch in X
'A point is defined as 1/72 inches
Private Const POINTS_PER_INCH As Long = 72

'  mode selections for the device mode function
Public Const DM_UPDATE = 1
Public Const DM_COPY = 2
Public Const DM_PROMPT = 4
Public Const DM_MODIFY = 8

Public Const DM_IN_BUFFER = DM_MODIFY
Public Const DM_IN_PROMPT = DM_PROMPT
Public Const DM_OUT_BUFFER = DM_COPY
Public Const DM_OUT_DEFAULT = DM_UPDATE

'  device capabilities indices
Public Const DC_FIELDS = 1
Public Const DC_PAPERS = 2
Public Const DC_PAPERSIZE = 3
Public Const DC_MINEXTENT = 4
Public Const DC_MAXEXTENT = 5
Public Const DC_BINS = 6
Public Const DC_DUPLEX = 7
Public Const DC_SIZE = 8
Public Const DC_EXTRA = 9
Public Const DC_VERSION = 10
Public Const DC_DRIVER = 11
Public Const DC_BINNAMES = 12
Public Const DC_ENUMRESOLUTIONS = 13
Public Const DC_FILEDEPENDENCIES = 14
Public Const DC_TRUETYPE = 15
Public Const DC_PAPERNAMES = 16
Public Const DC_ORIENTATION = 17
Public Const DC_COPIES = 18

'  Pen Styles
Public Const PS_SOLID = 0
Public Const PS_DASH = 1                    '  -------
Public Const PS_DOT = 2                     '  .......
Public Const PS_DASHDOT = 3                 '  _._._._
Public Const PS_DASHDOTDOT = 4              '  _.._.._
Public Const PS_NULL = 5
Public Const PS_INSIDEFRAME = 6
Public Const PS_USERSTYLE = 7
Public Const PS_ALTERNATE = 8
Public Const PS_STYLE_MASK = &HF

' Structures
Public Const CCHDEVICENAME = 32
Public Const CCHFORMNAME = 32#

Type DEVMODE
        dmDeviceName As String * CCHDEVICENAME
        dmSpecVersion As Integer
        dmDriverVersion As Integer
        dmSize As Integer
        dmDriverExtra As Integer
        dmFields As Long
        dmOrientation As Integer
        dmPaperSize As Integer
        dmPaperLength As Integer
        dmPaperWidth As Integer
        dmScale As Integer
        dmCopies As Integer
        dmDefaultSource As Integer
        dmPrintQuality As Integer
        dmColor As Integer
        dmDuplex As Integer
        dmYResolution As Integer
        dmTTOption As Integer
        dmCollate As Integer
        dmFormName As String * CCHFORMNAME
        dmUnusedPadding As Integer
        dmBitsPerPel As Integer
        dmPelsWidth As Long
        dmPelsHeight As Long
        dmDisplayFlags As Long
        dmDisplayFrequency As Long
End Type

Type POINTAPI
    X As Long
    Y As Long
End Type
Global mouseposition As POINTAPI

'''Some Public vars for passing to other functions/subs
Public hdc As Long
Public hNewPen As Long
Public hwnd As Long 'DC of userform
Public PCF As Double ' a convertion factor to for API pixles to excel points

'''Globals for drawing ovals
Global lYs As Long
Global lXs As Long

'*********************************************************************8
''''Controling subs for starting enviroment and clearing up at exit
Sub Setup()
'''set things up
NewPen ' make new pen
GetFormsDC ' get DC for form
SelectDrawingObj_into_DC (hNewPen) ' sets pen into for,
PCF = PointsPerPixel ' returns convertion fatcor
End Sub

Sub CleanUpLine()
ReleaseSessionDC
DeleteObject (hNewPen)
End Sub
'*****************************************************************
'**********************************************************************
'''Code that creates objects, and get handelers and things like that


'''The pen must be made then slected in to Deivce context
''' the pen is used for the line drawing,
Sub NewPen()
hNewPen = CreatePen(PS_SOLID, 0, RGB(225, 0, 0))
End Sub

''' gets the dc handel of the form
Function GetFormsDC()
'working code
'hwnd = Application.hwndDraw all over excel - update "Sub ReleaseSessionDC()"
hwnd = FindWindow("thunderDFrame", frmDraw.Caption)
hdc = GetDC(hwnd)
'''appttemp to get frame hnd
''' dont work, might have to drill down from the perent form
''' will look later
'hwnd = FindWindow("F3 Server 02d50000", frmDraw.Frame1.Caption)
'hDC = GetDC(hwnd)
'frmDraw.CommandButton1.Caption = hDC
End Function
''' this pust the pen/brush in to the form DC
Function SelectDrawingObj_into_DC(ByVal lObject As Long)
Dim hSelect As Long
hSelect = SelectObject(lObject, hdc)
End Function
Sub ReleaseSessionDC()
Dim Rc As Long
'hwnd = Application.hwndDraw all over excel
hwnd = FindWindow("thunderDFrame", frmDraw.Caption)
Rc = ReleaseDC(hwnd, hdc)
End Sub

'''*************************************************************
'''*************************************************************
'''the api calls used for the drawing events!
Function SetDrawStart(ByVal X As Integer, ByVal Y As Integer)
MoveToEx hdc, (X / PCF), (Y / PCF), mouseposition
End Function
Function Draw(ByVal X As Integer, ByVal Y As Integer)
LineTo hdc, (X / PCF), (Y / PCF)
End Function

'''Delsets objects from mem, good practice, pervents mem leeks
Sub DeleteObject_Pen(ByVal Object As Long)
DeleteObject (Object)
End Sub

'''need to convert forms point measuements in to api pixles
'''this code is taken from Professional Excel Deveopment
'''http://www.oaltd.co.uk/ProExcelDev/Default.htm
'''cheers fellas

Public Function PointsPerPixel() As Double
    Dim hdc As Long
    Dim lDotsPerInch As Long

    'Get the Device Context of the desktop window (i.e. the screen)
    hdc = GetDC(0)

    'Get the user's DPI setting
    lDotsPerInch = GetDeviceCaps(hdc, LOGPIXELSX)

    'Divide the 72 points-per-inch by the dpi to give the width of a pixel
    PointsPerPixel = POINTS_PER_INCH / lDotsPerInch

'Release the Device Context, to tidy up
    ReleaseDC 0, hdc
End Function
Attribute VB_Name = "mod_IO1"
Option Explicit
Function IOPath() As String
Dim IOPath_neu As String
IOPath_neu = Path_MyDocs() & "900 Datensicherung Mobile\"
If Dir(IOPath_neu, vbDirectory) = "" Then
    IOPath = IOPath_neu '"Z:\MI_Backup\"
Else
    IOPath = IOPath_neu
End If
If Not MakeDir(IOPath) Then
    IOPath = Path_MyDocs()
End If
End Function

Function IOFilename() As String
IOFilename = "export.csv"
End Function

Function IOPathFile() As String
IOPathFile = IOPath() & IOFilename()
End Function

Function App_akt() As String
    App_akt = "PN"
End Function


Sub AdrDatei_read(Optional NoMsg As Boolean)
Dim sPathName As String, sFilename As String, sPathFile As String, WorkText As String, sSeparator As String
Dim sFeldname, sFeldInhalt, Z|fffd|hler As Integer, sData, sHeader
Dim Antwort As Integer, DataInfo As String
Dim FeldAnz As Integer

sPathFile = IOPathFile()
If Dir(sPathFile) = "" Then GoTo No_Data
sSeparator = Chr(9)
sHeader = txt_ReadLine(sPathFile, 1)
WorkText = txt_ReadLine(sPathFile, 2)

sData = WorkText
FeldAnz = IIf(Len(sHeader) > 376, 44, 37)

DataInfo = selektiere(sData, 3, sSeparator)

If NoMsg Then
    Antwort = vbOK
Else
    Antwort = MsgBox(DataInfo _
    & vbCrLf & vbCrLf & "Adresse |fffd|bernehmen?" _
    , vbQuestion + vbOKCancel, "Adresse importieren")
    
    If Antwort = vbCancel Then GoTo Exit_
End If

For Z|fffd|hler = 1 To FeldAnz
    sFeldname = Trim(Replace(selektiere(sHeader, Z|fffd|hler, sSeparator), Chr(10), ""))
    sFeldInhalt = Trim(Replace(selektiere(sData, Z|fffd|hler, sSeparator), Chr(10), ""))
    Feld_schreiben sFeldname, sFeldInhalt
Next Z|fffd|hler

Exit_:
Exit Sub

No_Data:
Antwort = MsgBox("Keine Daten zum Import gefunden!" _
    & vbCrLf & vbCrLf & "Bitte exportieren Sie eine Adresse." _
    , vbExclamation, "Adresse importieren")
End Sub

Sub Feld_schreiben(sFeldname, sFeldInhalt)
Dim sh As Worksheet
On Error Resume Next
If App_akt() = "PN" Then
    Set sh = Worksheets(1)
    With sh
        Select Case sFeldname
            Case "B_BelegNr"
                .Range("AU_Nr") = sFeldInhalt
            Case "WE_Firma1"
                .Range("WE_Firma1") = sFeldInhalt
            Case "WE_Firma2"
                .Range("WE_Firma2") = sFeldInhalt
            Case "WE_Land"
                '.Range("WL_Land") = sFeldInhalt
            Case "WE_PLZ"
                .Range("WE_PLZ_Ort") = "'" & sFeldInhalt
            Case "WE_Ort"
                .Range("WE_PLZ_Ort") = .Range("WE_PLZ_Ort") & " " & sFeldInhalt
            Case "WE_Strasse"
                .Range("WE_Strasse") = sFeldInhalt
            Case "WE_Hausnummer"
                .Range("WE_Strasse") = .Range("WE_Strasse") & " " & sFeldInhalt
            Case "WE_AP_Anrede"
                '.Range("WE_AP") = sFeldInhalt
            Case "WE_AP_Nachname"
                '.Range("WE_AP") = Trim(.Range("WE_AP") & " " & sFeldInhalt)
           Case "WE_AP_Vorname"
                If InStr(1, .Range("WE_AP"), " ") > 0 Then
                    If Len(sFeldInhalt) > 0 Then
                        '.Range("WE_AP") = ReplaceStr(.Range("WE_AP"), " ", " " & sFeldInhalt & " ")
                    End If
                End If
            Case "WE_AP_Mail"
                .Range("WE_Mail") = sFeldInhalt
                
            Case "AG_Firma1"
                .Range("AG_Firma1") = sFeldInhalt
            Case "AG_Firma2"
                .Range("AG_Firma2") = sFeldInhalt
            Case "AG_Land"
                '.Range("AN_Land") = sFeldInhalt
            Case "AG_PLZ"
                .Range("AG_PLZ_Ort") = "'" & sFeldInhalt
            Case "AG_Ort"
                .Range("AG_PLZ_Ort") = Trim(.Range("AG_PLZ_Ort")) & " " & sFeldInhalt
            Case "AG_Strasse"
                .Range("AG_Strasse") = sFeldInhalt
            Case "AG_Hausnummer"
                .Range("AG_Strasse") = .Range("AG_Strasse") & " " & sFeldInhalt
            Case "AG_Mail"
                .Range("AG_Mail") = sFeldInhalt
            Case "AG_Nr"
                .Range("AG_Nr") = sFeldInhalt
            Case "WE_Nr"
                .Range("WE_Nr") = sFeldInhalt
            Case "B_Komponente"
                 .Range("B_KompNr") = sFeldInhalt
            Case "B_Standort"
                 .Range("G_Standort") = sFeldInhalt

        End Select
    End With
End If
'Debug.Print sFeldname & ":" & sFeldInhalt
End Sub
Sub AdrDatei_write()
Dim B_BelegNr, B_SID, AG_Firma1, AG_Firma2, AG_Land, AG_PLZ, AG_Ort, AG_Strasse, AG_Hausnummer, AG_Tel, AG_Fax, AG_Mail
Dim WE_Firma1, WE_Firma2, WE_Land, WE_PLZ, WE_Ort, WE_Strasse, WE_Hausnummer, WE_Tel, WE_Fax, WE_Mail
Dim WE_AP_Anrede, WE_AP_Vorname, WE_AP_Nachname, RE_Firma1, RE_Firma2, RE_Land, RE_PLZ, RE_Ort, RE_Strasse, RE_Hausnummer, RE_Tel, RE_Fax, RE_Mail
Dim WE_AP_Tel, WE_AP_Mail, WE_AP_Fax
Dim RE_Anrede, RE_Vorname, RE_Nachname  'nicht vorhanden
Dim AG_Nr, WE_Nr, RE_Nr, WE_AP_Nr
Dim B_Komponente, B_Standort

Dim sh As Worksheet
Dim sPathFile As String
Dim sData, sHeader, sSeparator As String
Dim Blank1 As Integer, Blank2 As Integer
sPathFile = IOPathFile()
sSeparator = Chr(9)
'sHeader = txt_ReadLine(sPathFile, 1)
sHeader = "B_BelegNr" & sSeparator & "B_SID" & sSeparator & "AG_Firma1" & sSeparator & "AG_Firma2" & sSeparator _
& "AG_Land" & sSeparator & "AG_PLZ" & sSeparator & "AG_Ort" & sSeparator & "AG_Strasse" & sSeparator & "AG_Hausnummer" & sSeparator _
& "AG_Tel" & sSeparator & "AG_Fax" & sSeparator & "AG_Mail" & sSeparator _
& "WE_Firma1" & sSeparator & "WE_Firma2" & sSeparator & "WE_Land" & sSeparator & "WE_PLZ" & sSeparator & "WE_Ort" & sSeparator _
& "WE_Strasse" & sSeparator & "WE_Hausnummer" & sSeparator _
& "WE_Tel" & sSeparator & "WE_Fax" & sSeparator & "WE_Mail" & sSeparator _
& "RE_Firma1" & sSeparator & "RE_Firma2" & sSeparator & "RE_Land" _
& "RE_PLZ" & sSeparator & "RE_Ort" & sSeparator & "RE_Strasse" & sSeparator & "RE_Hausnummer" & sSeparator _
& "RE_Tel" & sSeparator & "RE_Fax" & sSeparator & "RE_Mail" & sSeparator _
& "WE_AP_Anrede" & sSeparator & "WE_AP_Nachname" & sSeparator & "WE_AP_Vorname" & sSeparator _
& "WE_AP_Tel" & sSeparator & "WE_AP_Fax" & sSeparator & "WE_AP_Mail" & sSeparator _
& "AG_Nr" & sSeparator & "WE_Nr" & sSeparator & "RE_Nr" & sSeparator & "WE_AP_Nr" & sSeparator _
& "B_Komponente" & sSeparator & "B_Standort"

If App_akt() = "PN" Then
    Set sh = Worksheets("Produktliste")
    With sh
        B_BelegNr = .Range("AU_Nr")
        AG_Firma1 = .Range("AG_Firma1")
        AG_Firma2 = .Range("AG_Firma2")
        AG_PLZ = Trim(NurZahl(.Range("AG_PLZ_Ort")))
        AG_Ort = Trim(OhneZahl(.Range("AG_PLZ_Ort")))
        AG_Strasse = OhneZahl(.Range("AG_Strasse"))
        AG_Hausnummer = NurZahl(.Range("AG_Strasse"))
        AG_Mail = .Range("AG_Mail")

        WE_Firma1 = .Range("WE_Firma1")
        WE_Firma2 = .Range("WE_Firma2")
        WE_PLZ = Trim(NurZahl(.Range("WE_PLZ_Ort")))
        WE_Ort = Trim(OhneZahl(.Range("WE_PLZ_Ort")))
        WE_Strasse = OhneZahl(.Range("WE_Strasse"))
        WE_Hausnummer = NurZahl(.Range("WE_Strasse"))
        WE_Mail = .Range("WE_Mail")
        WE_AP_Mail = .Range("WE_Mail")
            AG_Nr = .Range("AG_Nr")
            WE_Nr = .Range("WE_Nr")
            RE_Nr = "0"
            WE_AP_Nr = "0"
        B_Komponente = .Range("B_KompNr")
        B_Standort = .Range("G_Standort")

     End With
End If

sData = B_BelegNr & sSeparator & B_SID & sSeparator & AG_Firma1 & sSeparator & AG_Firma2 & sSeparator _
& AG_Land & sSeparator & AG_PLZ & sSeparator & AG_Ort & sSeparator & AG_Strasse & sSeparator & AG_Hausnummer & sSeparator _
& AG_Tel & sSeparator & AG_Fax & sSeparator & AG_Mail & sSeparator _
& WE_Firma1 & sSeparator & WE_Firma2 & sSeparator & WE_Land & sSeparator _
& WE_PLZ & sSeparator & WE_Ort & sSeparator & WE_Strasse & sSeparator & WE_Hausnummer & sSeparator _
& WE_Tel & sSeparator & WE_Fax & sSeparator & WE_Mail & sSeparator _
& RE_Firma1 & sSeparator & RE_Firma2 & sSeparator & RE_Land _
& RE_PLZ & sSeparator & RE_Ort & sSeparator & RE_Strasse & sSeparator & RE_Hausnummer & sSeparator _
& RE_Tel & sSeparator & RE_Fax & sSeparator & RE_Mail & sSeparator _
& WE_AP_Anrede & sSeparator & WE_AP_Nachname & sSeparator & WE_AP_Vorname & sSeparator _
& WE_AP_Tel & sSeparator & WE_AP_Fax & sSeparator & WE_AP_Mail & sSeparator _
& AG_Nr & sSeparator & WE_Nr & sSeparator & RE_Nr & sSeparator & WE_AP_Nr _
& B_Komponente & sSeparator & B_Standort




'Debug.Print sHeader & vbCrLf & sData

If Len(B_BelegNr) = 0 Then
    MsgBox "Keine Daten zum Exportieren vorhanden!" & vbCrLf & vbCrLf & "Bitte geben Sie eine Adresse ein.", vbExclamation, "Adresse exportieren"
Else
    txt_WriteAll sPathFile, sHeader & Chr(10) & Chr(13) & sData
End If
End Sub




Attribute VB_Name = "mod_Mail"
Option Explicit
Option Compare Text

Function NotesMailSend(strEmpfaenger As Variant, strBetreff As Variant, _
strText As Variant, strCC As Variant, strbcc As Variant, strFilename As _
String, strFilename2 As String, strFilename3 As String, strFilename4 As String, nMailAction As Integer) As Boolean
Dim Antwort As Integer

If Not Ist_Mail() Then
'Abbruch, falls eMail deaktiviert
    Exit Function
End If

If OutlookInstalliert() Then
    NotesMailSend = OutlookMailSend(strEmpfaenger, strBetreff, strText, strCC, strbcc, strFilename, strFilename2, strFilename3, strFilename4, nMailAction)
    Exit Function
End If

' E-mail mit Lotus Notes
' Maximal 4 Dateien im Anhang!
Dim Session As Object 'Die Notes Session
Dim UserName As String 'Der Benutzername
Dim Maildb As Object 'Die Datenbank
Dim MailDbName As String 'Der Datenbankname

Dim objNotes As Object, objNotesDB As Object, objNotesMailDoc As Object
Dim SendItem, NCopyItem, BlindCopyToItem, i As Integer, rtitem, Signature, Workspace
Dim msg As String
'Dim strFilename2 As String
On Error GoTo Err_Lotus

'If Ist_Test_Bo() Then Exit Function

'
' Zuweisung der Objektvariablen
'Die Session starten
Set Session = CreateObject("Notes.NotesSession")

'Den Benutzernamen auslesen und den Dateinamen
'der MailDB errechnen
'Dies wird nicht |fffd|berall ben|fffd|tigt. Auf manchen
'Systemen kann auch ein leerer String |fffd|bergeben werden
UserName = Session.UserName
MailDbName = Left$(UserName, 1) _
& Right$(UserName, (Len(UserName) - InStr(1, UserName, " "))) & ".nsf"

'Datenbank |fffd|ffnen
Set objNotes = GetObject("", "Notes.Notessession")
Set objNotesDB = objNotes.GETDATABASE("", MailDbName)


If objNotesDB.IsOpen = True Then
         'Fertig zum mailen!
    Else
        objNotesDB.OPENMAIL
End If

' Erstellen neues Maildokument
Set objNotesMailDoc = objNotesDB.CREATEDOCUMENT
objNotesMailDoc.Form = "Memo"

Set SendItem = objNotesMailDoc.APPENDITEMVALUE("SendTo", "")
Set NCopyItem = objNotesMailDoc.APPENDITEMVALUE("CopyTo", "")
Set BlindCopyToItem = objNotesMailDoc.APPENDITEMVALUE("BlindCopyTo", "")
objNotesMailDoc.sendto = strEmpfaenger
objNotesMailDoc.CopyTo = strCC
objNotesMailDoc.Subject = strBetreff

Set rtitem = objNotesMailDoc.CREATERICHTEXTITEM("Body")

'objNotesMailDoc.Body = strText 'Fehler bei Mail an externe Adressen!!!

rtitem.ADDNEWLINE (1)
Call rtitem.AppendText(strText)
rtitem.ADDNEWLINE (1)

'objNotesMailDoc.SAVEMESSAGEONSEND = True
'Anh|fffd|nge hinzuf|fffd|gen

If Len(strFilename) > 0 Then
    Call rtitem.EMBEDOBJECT(1454, "", strFilename)
End If
If Len(strFilename2) > 0 Then
    Call rtitem.EMBEDOBJECT(1454, "", strFilename2)
End If
If Len(strFilename3) > 0 Then
    Call rtitem.EMBEDOBJECT(1454, "", strFilename3)
End If
If Len(strFilename4) > 0 Then
    Call rtitem.EMBEDOBJECT(1454, "", strFilename4)
End If

'Signatur einf|fffd|gen
Signature = objNotesDB.GETPROFILEDOCUMENT("CalendarProfile").GETITEMVALUE("Signature")(0)

If nMailAction = 1 Or nMailAction = 3 Then  'Entwurf / Versand
    'rtitem.ADDNEWLINE (2)
    If Left(strBetreff, 1) <> "8" Then
        'Sonderfall: Keine Signatur f|fffd|r CRM-Team
        rtitem.AppendText Signature
    End If
End If

'Mail als Entwurf
'Call objNotesMailDoc.Save(True, True)

'Mail nach Lotus Notes transferieren
    
Select Case nMailAction

    Case 1  'Entwurf
        ' Nachricht an Benutzer
        msg = "Die Datei wurde als Entwurf in Lotus Notes gespeichert." _
        & vbCrLf & vbCrLf _
        & strBetreff
        '& vbCrLf & vbCrLf _
        '& "W|fffd|hlen Sie 'Weiterleiten' um Ihre Signatur und Text hinzuzuf|fffd|gen."
        
        Call objNotesMailDoc.Save(True, True) 'Entwurf
        
        Antwort = vbYes
    Case 2   'Bearbeiten
        ' Nachricht an Benutzer
        'msg = "Die E-Mail wurde in Lotus Notes erstellt." _
            & vbCrLf & vbCrLf _
            & strBetreff _
            & vbCrLf & vbCrLf _
            & "JA: Sofort versenden" _
            & vbCrLf & vbCrLf _
            & "Nein: Zur Bearbeitung anzeigen"
        Set Workspace = CreateObject("Notes.NotesUIWorkspace")
        Call Workspace.EDITDOCUMENT(True, objNotesMailDoc).GOTOFIELD("Body")
        'Call Workspace.EDITDOCUMENT(True, objNotesMailDoc).GOTOFIELD("Subject")
        AppActivate "> "
    Case 3  'sofort senden
        msg = "Die E-Mail wurde erfolgreich versendet." _
            & vbCrLf & vbCrLf _
            & strBetreff
        objNotesMailDoc.PostedDate = Now() 'Gets the mail to appear in the sent items folder
        Call objNotesMailDoc.Send(False)
End Select
    'Call objNotesMailDoc.send(False)
    'objNotesMailDoc.RemoveItem ("DeliveredDate")
    'Call objNotesMailDoc.Save(True, False)

'If Len(msg) > 0 Then Antwort = MsgBox(msg, vbInformation, "Datei an Lotus Notes senden")

' Objektvariablen zur|fffd|cksetzen
Call objNotes.Close
' Leider funktioniert der Quit-Befehl aus irgend einem Grund nicht.
'objNotes.Quit

Set rtitem = Nothing
Set Workspace = Nothing
Set objNotes = Nothing

NotesMailSend = True


ExitF:
Exit Function

Err_Lotus:
MsgBox "Fehler " & Err.Number & ": " & Err.Description _
& vbCrLf & vbCrLf _
& "E-Mail kann in Lotus Notes nicht erstellt werden." _
, vbExclamation + vbOKOnly

Resume ExitF
End Function

Sub Outlook_Mail(strEmpfaenger As Variant, strBetreff As Variant, _
strText As Variant, strCC As Variant, strbcc As Variant, strFilename As _
String)
Dim objOutl As Object
Dim objMail As Object
On Error GoTo ErrorHandler

Set objOutl = CreateObject("Outlook.application")
Set objMail = objOutl.CreateItem(0)

objMail.Subject = strBetreff

objMail.To = strEmpfaenger
objMail.CC = strCC
If Len(strFilename) > 0 Then objMail.Attachments.Add strFilename
objMail.Display

Set objOutl = Nothing
Set objMail = Nothing

ErrorHandler:
Exit Sub
End Sub
Function OutlookMailSend(strEmpfaenger As Variant, strBetreff As Variant, _
strText As Variant, strCC As Variant, strbcc As Variant, Optional strFilename As _
Variant, Optional strFilename2 As Variant, Optional strFilename3 As Variant, Optional strFilename4 As Variant, Optional nMailAction) As Boolean

' E-mail mit Outlook
Dim Send As Boolean, msg As String

    Dim OutApp As Object
    Dim OutMail As Object

On Error GoTo Err_
    Set OutApp = CreateObject("Outlook.Application")
    Set OutMail = OutApp.CreateItem(0)

    On Error Resume Next
    With OutMail
        .To = strEmpfaenger
        .CC = strCC
        .BCC = strbcc
        .Subject = strBetreff
        .Body = strText
        If strFilename <> "" Then .Attachments.Add strFilename
        If strFilename2 <> "" Then .Attachments.Add strFilename2
        If strFilename3 <> "" Then .Attachments.Add strFilename3
        If strFilename4 <> "" Then .Attachments.Add strFilename4
        
        If Send = True Then
            .Send
        Else
            .Display
        End If
    End With
    On Error GoTo Err_

OutlookMailSend = True


Exit_:
Set OutMail = Nothing
Set OutApp = Nothing
Exit Function

Err_:
MsgBox "Fehler " & Err.Number & ": " & Err.Description _
& vbCrLf & vbCrLf _
& "E-Mail kann in Outlook nicht erstellt werden." _
, vbExclamation + vbOKOnly

Resume Exit_
End Function


Function OutlookInstalliert(Optional Msg_JN As Boolean) As Boolean
Dim olapp As Object
On Error Resume Next
Set olapp = CreateObject("Outlook.Application")
If Not olapp Is Nothing Then
    OutlookInstalliert = True
    If Msg_JN Then MsgBox "Outlook ist installiert", vbOKOnly + vbInformation, "Hinweis"
Else
    If Msg_JN Then MsgBox "Outlook ist nicht installiert", vbOKOnly + vbExclamation, "Achtung"
End If

Set olapp = Nothing
End Function
Function LotusInstalliert(Optional Msg_JN As Boolean) As Boolean
Dim olapp As Object
On Error Resume Next
Set olapp = CreateObject("Notes.NotesSession")
If Not olapp Is Nothing Then
    LotusInstalliert = True
    If Msg_JN Then MsgBox "Lotus Notes ist installiert", vbOKOnly + vbInformation, "Hinweis"
Else
    If Msg_JN Then MsgBox "Lotus Notes ist nicht installiert", vbOKOnly + vbExclamation, "Achtung"
End If

Set olapp = Nothing
End Function


Function MailClientName() As String
Dim nClient As Integer
nClient = mail_Client() 'Sheets("param").Range("mail_Client")
Select Case nClient
    Case 2
        MailClientName = "Outlook"
    Case 1
        MailClientName = "Lotus Notes"
    Case Else
        MailClientName = "unbekannt"
End Select
End Function

Function mail_Client() As Integer
'1=Lotus, 2=Outlook, 0=unbekannt
If OutlookInstalliert() Then
    mail_Client = 2
ElseIf LotusInstalliert() Then
    mail_Client = 1
End If
    
End Function


Attribute VB_Name = "mod_PDF"
Option Explicit
Option Compare Text
#Const EARLYBINDING = False

Function PDF_Drucken(sPDFPath As String, sPDFName As String) As Boolean
On Error GoTo Err_PDF_drucken
#If EARLYBINDING Then
    Dim pdfjob As PDFCreator.clsPDFCreator
#Else
    Dim pdfjob As Object
#End If
Dim Antwort As Integer
Dim SheetAnz As Integer, PDF_Sleep As Integer
'PDFCreator beenden
Terminate_Process "PDFCreator.exe"

SheetAnz = 1
PDF_Sleep = Sleep_ms()

#If EARLYBINDING Then
    Set pdfjob = New PDFCreator.clsPDFCreator
#Else
    Set pdfjob = CreateObject("PDFCreator.clsPDFCreator")
#End If

With pdfjob
    If .cStart("/NoProcessingAtStartup") = False Then
        MsgBox "Kann PDFCreator nicht initialisieren.", vbCritical + _
                vbOKOnly, "PrtPDFCreator"
        GoTo Err_PDF_drucken
    End If
    
    .cOption("UseAutosave") = 1
    .cOption("UseAutosaveDirectory") = 1
    .cOption("AutosaveDirectory") = sPDFPath
    .cOption("AutosaveFilename") = sPDFName
    .cOption("AutosaveFormat") = 0  ' 0 = PDF
    .cClearCache
End With

'Print the document to PDF
Sheets(1).PrintOut Copies:=1, ActivePrinter:="PDFCreator", Collate:=True
If SheetAnz > 1 Then
    'Berechnung
    'Sheets(2).PrintOut Copies:=1, ActivePrinter:="PDFCreator", Collate:=True
End If

'Wait until the print job has entered the print queue
Do Until pdfjob.cCountOfPrintjobs = SheetAnz
    DoEvents
    Sleep PDF_Sleep
Loop

If SheetAnz > 1 Then
    'Mehrere Sheets drucken
    Sleep PDF_Sleep
    pdfjob.cCombineAll
    Sleep PDF_Sleep
Else
    'Wait until PDF creator is finished then release the objects
    Do Until pdfjob.cCountOfPrintjobs = 1
        DoEvents
        Sleep PDF_Sleep
    Loop

End If

pdfjob.cPrinterStop = False
Sleep PDF_Sleep * 2 '1000

If Dir(sPDFPath & sPDFName) <> "" Then
    PDF_Drucken = True
Else
    'Fehlermeldung deaktiviert!!!   13.12.2012
    PDF_Drucken = True
    
    'Antwort = MsgBox(sPDFPath & sPDFName & " konnte nicht erstellt werden!" _
    & vbCrLf & vbCrLf _
    & "Bitte wiederholen Sie den Vorgang." _
    , vbExclamation, App_Name)
End If
pdfjob.cClose
Set pdfjob = Nothing

Exit_PDF_drucken:
'PDFCreator beenden
Terminate_Process "PDFCreator.exe"
Exit Function

Err_PDF_drucken:
Resume Exit_PDF_drucken
End Function

Function PDFCreator_installed(Optional Msg_JN As Boolean) As Boolean
Dim Antwort As Integer, pdfjob As Object
On Error Resume Next
Set pdfjob = CreateObject("PDFCreator.clsPDFCreator")
If Not pdfjob Is Nothing Then
    PDFCreator_installed = True
    If Msg_JN Then Antwort = MsgBox("PDFCreator ist installiert", vbOKOnly + vbInformation, "Installationspr|fffd|fung")
    Terminate_Process "PDFCreator.exe"
    Set pdfjob = Nothing
Else
    If Msg_JN Then Antwort = MsgBox("PDFCreator ist nicht installiert", vbOKOnly + vbExclamation, "Installationspr|fffd|fung")
End If
End Function

Attribute VB_Name = "mod_SQL"
Option Explicit
Option Compare Text
'Kommunikation mit DB
'Verweis: Microsoft ActiveX Data Objects 2.8 Library

Public Enum eDomainType
  dtAvg = 0
  dtCount = 1
  dtFirst = 2
  dtLast = 3
  dtMax = 4
  dtMin = 5
  dtLookup = 6
  dtSdtev = 7
  dtSum = 8
  dtVar = 9
End Enum
Function DB_Source() As String
'Pfad + Dateiname DB
DB_Source = DB_Path() & "\" & DB_File()
End Function
Function DB_Path() As String
'Pfad DB
DB_Path = Range("DB_Path")
End Function
Function DB_File() As String
'Dateiname DB
DB_File = Range("DB_File")
End Function
Function DB_Name() As String
'Name DB Klartext
DB_Name = Range("DB_Name")
End Function
Function DB_available(Optional NoMsg As Boolean) As Boolean
Dim Antwort As Integer, vDB_Dir
On Error Resume Next
vDB_Dir = DB_Path()
If Dir(DB_Source()) = "" Then
    If Not NoMsg Then
        Antwort = MsgBox("Online-Verbindung zu " & DB_Name() & " nicht verf|fffd|gbar!" _
        & vbCrLf & vbCrLf _
        & "Zugriff auf " & vDB_Dir & " ist erforderlich" _
        & vbCrLf & vbCrLf _
        & "Synchronisation ist nicht m|fffd|glich." _
        , vbExclamation + vbOKOnly, App_Name & " Verbindungspr|fffd|fung")
    End If
Else
    DB_available = True
End If
End Function
Function RUNSQL(strSQL As String, Optional Targetrange As Range) As Boolean
On Error GoTo Err_RUNSQL
Dim rst As ADODB.Recordset
Dim Cnxn As ADODB.Connection
Dim strCnxn As String

Dim Datasource As String, intColIndex As Integer
Datasource = DB_Source()
If Len(strSQL) = 0 Then Exit Function

' Open connection
Set Cnxn = New ADODB.Connection
strCnxn = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & Datasource & ";User Id=admin;Password=; "
Cnxn.Open strCnxn

Set rst = New ADODB.Recordset

With rst
    .Open strSQL, Cnxn, adOpenDynamic, adLockOptimistic, adCmdText

    If Not IsMissing(Targetrange) And Left(strSQL, 6) = "Select" Then
        'RS2WS rst, Targetrange ' write data from the recordset to the worksheet
        
'        ' optional approach for Excel 2000 or later (RS2WS is not necessary)
        For intColIndex = 0 To rst.Fields.Count - 1 ' the field names
            Targetrange.Offset(0, intColIndex).Value = rst.Fields(intColIndex).name
        Next
        Targetrange.Offset(1, 0).CopyFromRecordset rst ' the recordset data
    End If

End With
RUNSQL = True

Exit_RUNSQL:
  On Error Resume Next
  If Not rst Is Nothing Then rst.Close: Set rst = Nothing
  If Not Cnxn Is Nothing Then Cnxn.Close: Set Cnxn = Nothing
  Exit Function

Err_RUNSQL:
MsgBox Err.Description _
& vbCrLf & vbCrLf _
& "SQL-String:" & vbCrLf & strSQL _
& vbCrLf & vbCrLf _
& "L|fffd|nge: " & Len(strSQL)
Resume Exit_RUNSQL
End Function
Function DLookup( _
                              psField As String, _
                              psDomain As String, _
                              Optional psDbs _
                              As String = vbNullString, _
                              Optional psCriteria _
                              As String = vbNullString) _
                              As Variant
  '// =====================================================
  '// Methode   | Simuliert die DLookup-Methode
  '//           | (DomWert) unter ADO (performanter)
  '// -----------------------------------------------------
  '// Parameter | psField - Angabe des Feldes
  '//           | psDomain - Angabe der Tabelle/Abfrage
  '//           | psDbs - Optional Name und Pfad der DB
  '//           | psCriteria - Optional DS-Einschr|fffd|nkung
  '// -----------------------------------------------------
  '// R|fffd|ckgabe  | Variant - Wert bzw. NULL, falls
  '//           | keine DS vorhanden
  '// -----------------------------------------------------
  '// Erstellt  | Manuela Kulpa - Sep, 2002
  '//           | EDV Innovation & Consulting - Dormagen
  '// -----------------------------------------------------
  '// Beispiel  | ?DLookup("Nachname","Personal")
  '//           | ?DLookup("Nachname","Personal",, _
  '//           |              "Geburtsdatum=#2/19/1952#")
  '// =====================================================
  On Error GoTo HandleErr
 
  ' Verweis auf ActiveX Data Object 2.X muss gesetzt sein!
  Dim cnn As ADODB.Connection
  Dim rst As ADODB.Recordset
 
  Dim sSql As String
  Dim vRet As Variant
 
 'Aktuelle MDB
 psDbs = DB_Source()
 
  ' R|fffd|ckgabewert initialisieren
  vRet = Null
 
  ' SQL-String zusammen schnipseln
  sSql = "SELECT [" & psField & "] AS RecCount " & _
         "FROM [" & psDomain & "] "
 
  ' Falls Kriterium angegeben, WHERE-Klausel erstellen
  If Len(psCriteria) > 0 Then
    sSql = sSql & "WHERE " & psCriteria
  End If
  sSql = sSql & ";"
 
  ' Datenbank |fffd|ffnen
  If Len(psDbs) > 0 Then
    Set cnn = New ADODB.Connection
    cnn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _
             "Data Source=" & psDbs
  Else
    'Set cnn = CurrentProject.Connection
  End If
 
  ' Recordset |fffd|ffnen
  Set rst = New ADODB.Recordset
  rst.Open sSql, cnn, adOpenStatic
 
  ' Falls DS vorhanden, Wert |fffd|bergeben
  If rst.RecordCount > 0 Then
    vRet = rst![RecCount]
  End If
 
  If Not IsNull(vRet) Then DLookup = vRet
 
HandleExit:
  On Error Resume Next
  If Not rst Is Nothing Then rst.Close: Set rst = Nothing
  If Not cnn Is Nothing Then cnn.Close: Set cnn = Nothing
  Exit Function
 
HandleErr:
  Select Case Err.Number
    Case Else
      MsgBox "Fehler " & Err.Number & ": " & _
             Err.Description, vbCritical, _
             "basAdo.DLookup"
  End Select
  Resume HandleExit
End Function
Public Function Domain( _
                             peType As eDomainType, _
                             psField As String, _
                             psDomain As String, _
                             Optional psDbs _
                             As String = vbNullString, _
                             Optional psCriteria _
                             As String = vbNullString) _
       As Variant
  '// =====================================================
  '// Methode   | Simuliert die Dom|fffd|nenaggregatfunktionen
  '//           | unter ADO (performanter)
  '// -----------------------------------------------------
  '// Parameter | peType     - Funktionstyp
  '//           | psField    - Tabellen-/Abfragefeld
  '//           | psDomain   - Tabelle/Abfrage
  '//           | psDbs      - Optional Pfad & Name der DB
  '//           | psCriteria - Optional Kriterium
  '//           | Hinweis    - Das Enum eDomainType sollte
  '//           |              vorab auf Modulebene
  '//           |              deklariert sein!
  '// -----------------------------------------------------
  '// R|fffd|ckgabe  | Variant - Wert bzw. NULL falls kein DS
  '//           |           vorhanden
  '// -----------------------------------------------------
  '// Erstellt  | Manuela Kulpa - Sep, 2002
  '//           | EDV Innovation & Consulting - Dormagen
  '// -----------------------------------------------------
  '// Beispiel  | ?Domain(dtSum,"Einzelpreis", _
  '//           |               "Artikel")
  '//           | ?Domain(dtSum,"Einzelpreis", _
  '//           |               "Artikel",, _
  '//           |               "Auslaufartikel=True")
  '// =====================================================
  On Error GoTo HandleErr
  ' Verweis auf ActiveX Data Object 2.X muss gesetzt sein!
  Dim cnn As ADODB.Connection
  Dim rst As ADODB.Recordset
 
  Dim sSql As String
  Dim vRet As Variant
  Dim sDomType As String
 
  'Dom|fffd|nenaggregatfunktionen ermitteln
  Select Case peType
    Case dtAvg
      sDomType = "Avg"
    Case dtCount
      sDomType = "Count"
    Case dtFirst
      sDomType = "First"
    Case dtLast
      sDomType = "Last"
    Case dtMax
      sDomType = "Max"
    Case dtMin
      sDomType = "Min"
    Case dtLookup
      sDomType = vbNullString
    Case dtSdtev
      sDomType = "Sdtev"
    Case dtSum
      sDomType = "Sum"
    Case dtVar
      sDomType = "Var"
  End Select
 
 'Aktuelle MDB
 psDbs = DB_Source()
 
  ' R|fffd|ckgabewert initialisieren
  vRet = Null
 
  ' SQL-String zusammen schnipseln
  sSql = "SELECT "
  If Len(sDomType) > 0 Then
    sSql = sSql & sDomType
  End If
  sSql = sSql & "([" & psField & "]) AS SummaryValue "
  sSql = sSql & "FROM [" & psDomain & "]"
 
  ' Falls Kriterium angegeben, WHERE-Klausel erstellen
  If Len(psCriteria) > 0 Then
    sSql = sSql & "WHERE " & psCriteria
  End If
  sSql = sSql & ";"
 
  ' Datenbank |fffd|ffnen
  If Len(psDbs) > 0 Then
    Set cnn = New ADODB.Connection
    cnn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _
             "Data Source=" & psDbs
  Else
    GoTo HandleExit
    'Set cnn = CurrentProject.Connection
  End If
 
  ' Recordset |fffd|ffnen
  Set rst = New ADODB.Recordset
  rst.Open sSql, cnn, adOpenStatic
 
  ' Falls DS vorhanden, Wert |fffd|bergeben
  If rst.RecordCount > 0 Then
    vRet = rst![SummaryValue]
  End If
 
  If Not IsNull(vRet) Then
    Domain = vRet
  End If
 
HandleExit:
  On Error Resume Next
  If Not rst Is Nothing Then rst.Close: Set rst = Nothing
  If Not cnn Is Nothing Then cnn.Close: Set cnn = Nothing
  Exit Function
 
HandleErr:
  Select Case Err.Number
    Case Else
      MsgBox "Fehler " & Err.Number & ": " & _
             Err.Description, vbCritical, _
             "basAdo.Domain"
  End Select
  Resume HandleExit
End Function

Function SQLDatum(ByVal vDatum As Date) As String
SQLDatum = "#" & Format(vDatum, "mm") & "/" & Format(vDatum, "dd") & "/" & Format(vDatum, "yy") & "#"
End Function
Function fProper(Feldinhalt, Optional ConvertToDataType As String) As Variant

If Len(ConvertToDataType) = 0 Then
    ConvertToDataType = "String"
End If

'leeres Feld als "NULL" zur|fffd|ckgeben
If IsEmpty(Feldinhalt) Or IsNull(Feldinhalt) Or Len(Feldinhalt) = 0 Then
    fProper = "NULL"
Else
    Select Case ConvertToDataType
        Case "String"
        fProper = "'" & Feldinhalt & "'"
        Case "Date", "Datum"
            fProper = SQLDatum(Feldinhalt)
        Case "Zahl"
            fProper = Val(Feldinhalt)
        Case Else
        fProper = Feldinhalt
    End Select
End If
End Function
'************************************************************

Function mdb_SQL_Batch() As Integer
    Dim con As ADODB.Connection, rs As ADODB.Recordset
    Dim i As Long
    
Dim Bereich As Object, Zeile As Object, Zelle As Object, Antwort As Integer, Counter As Integer
Dim AG_PLZ, AG_Ort, WE_PLZ, WE_Ort, B_AU_Nr, B_WE_Nr, B_AG_Nr, B_WE_Firma1, B_WE_Firma2, B_WE_Strasse, B_WE_PLZ_Ort As String, B_AG_Firma1, B_AG_Firma2, B_AG_Strasse, B_AG_PLZ_Ort As String, PN_Datum
Dim SID, T|fffd|rNr, Art, Standort, Typ, Hersteller, Antriebstyp, Feststellung, Fl|fffd|gel, Pr|fffd|fdatum, Pr|fffd|fbefund, Pr|fffd|fer, Pr|fffd|fbericht, Ma|fffd|nahme, Status, B_Empf|fffd|nger, B_KompNr, G_Standort, WE_Mail, AG_Mail
Dim Upd_JN As Boolean, Add_JN As Boolean, New_JN As Boolean, Del_JN As Boolean

On Error GoTo Err_
Application.CalculateFull

Upd_JN = Sheets("Param").Range("DB_Upd_JN")
Add_JN = Sheets("Param").Range("DB_Add_JN")
New_JN = Sheets("Param").Range("DB_New_JN")
Del_JN = Sheets("Param").Range("DB_Del_JN")

    Set con = getConn()

    Set rs = New ADODB.Recordset
    rs.CursorLocation = adUseClient '<<<< important!

    If Add_JN Or New_JN Then
    'get an empty recordset to add new records to
        rs.Open "select * from " & Range("DB_Table") & " where false", con, _
             adOpenDynamic, adLockBatchOptimistic

    ElseIf Upd_JN Then
        rs.Open "select * from " & Range("DB_Table") & " where AU_Nr='" & Range("AU_Nr") & "'", con, _
             adOpenDynamic, adLockBatchOptimistic
    End If
    
    'disconnect the recordset and close the connection
    Set rs.ActiveConnection = Nothing
    
    If Upd_JN Then
        Dim v
        v = rs.Fields(0).Value
    End If
    
    con.Close
    Set con = Nothing
P_Bereich_setzen



With Sheets(1)
    PN_Datum = .Range("PN_Datum")
    Pr|fffd|fer = .Range("Sign_Name2")
    B_Empf|fffd|nger = .Range("Sign_Name1")
    B_AU_Nr = .Range("AU_Nr")
    B_WE_Nr = .Range("WE_Nr")
    B_WE_Firma1 = .Range("WE_Firma1")
    B_WE_Firma2 = .Range("WE_Firma2")
    B_WE_Strasse = .Range("WE_Strasse")
    B_WE_PLZ_Ort = .Range("WE_PLZ_Ort")
    B_AG_Firma1 = .Range("AG_Firma1")
    B_AG_Nr = .Range("AG_Nr")
    B_AG_Firma2 = .Range("AG_Firma2")
    B_AG_Strasse = .Range("AG_Strasse")
    AG_PLZ = NurZahl(.Range("AG_PLZ_Ort"))
    AG_Ort = Trim(OhneZahl(.Range("AG_PLZ_Ort")))
    WE_PLZ = NurZahl(.Range("WE_PLZ_Ort"))
    WE_Ort = Trim(OhneZahl(.Range("WE_PLZ_Ort")))
    G_Standort = .Range("G_Standort")
    WE_Mail = .Range("WE_Mail")
    AG_Mail = .Range("AG_Mail")
    
    Set Bereich = .Range("P_Bereich")
    For Each Zeile In Bereich.Rows
        If Zeile.Row >= P_FirstRow() Then
            
            SID = .Cells(Zeile.Row, 1)
            T|fffd|rNr = .Cells(Zeile.Row, 2)
            Art = .Cells(Zeile.Row, 3)
            Standort = .Cells(Zeile.Row, 4)
            Typ = .Cells(Zeile.Row, 5)
            Hersteller = .Cells(Zeile.Row, 6)
            Antriebstyp = .Cells(Zeile.Row, 7)
            Feststellung = .Cells(Zeile.Row, 8)
            Fl|fffd|gel = .Cells(Zeile.Row, 9)
            Pr|fffd|fdatum = .Cells(Zeile.Row, 10)
            Pr|fffd|fbefund = .Cells(Zeile.Row, 11)
            'Pr|fffd|fbefund = Pr|fffd|fbefund & IIf(IsEmpty(Pr|fffd|fbefund), "", " = " & Param("Befund" & Pr|fffd|fbefund, 3))
            Pr|fffd|fbericht = .Cells(Zeile.Row, 12)
            Ma|fffd|nahme = .Cells(Zeile.Row, 13)
            Status = .Cells(Zeile.Row, 14)
            B_KompNr = .Cells(Zeile.Row, 15)
            
            If Add_JN And ((.Range("P_AktivJN") And Status <> "inaktiv") Or Not .Range("P_AktivJN")) _
            Or New_JN And Status = "Neu" Then

                'add new records to recordset
                rs.AddNew
                Counter = Counter + 1
                rs("SID") = SID
                rs("T_Nr") = T|fffd|rNr
                rs("AU_Nr") = B_AU_Nr
                rs("Art") = Art
                rs("Standort") = Standort
                rs("Typ") = Typ
                rs("Hersteller") = Hersteller
                rs("A_Typ") = Antriebstyp
                rs("Feststellung") = Feststellung
                rs("F_Anz") = Fl|fffd|gel
                rs("P_Datum") = Pr|fffd|fdatum
                rs("P_Befund") = Pr|fffd|fbefund
                rs("P_Bericht") = Pr|fffd|fbericht
                rs("P_Ma|fffd|nahme") = Ma|fffd|nahme
                rs("P_Pr|fffd|fer") = Pr|fffd|fer
                rs("P_Empf|fffd|nger") = B_Empf|fffd|nger
                rs("P_Status") = Status
                rs("AG_KdNr") = B_AG_Nr
                rs("AG_Name1") = B_AG_Firma1
                rs("AG_Name2") = B_AG_Firma2
                rs("AG_Land") = "DE"
                rs("AG_PLZ") = AG_PLZ
                rs("AG_Ort") = AG_Ort
                rs("AG_Str") = B_AG_Strasse
                rs("WE_Nr") = B_WE_Nr
                rs("WE_Name1") = B_WE_Firma1
                rs("WE_Name2") = B_WE_Firma2
                rs("WE_Land") = "DE"
                rs("WE_PLZ") = WE_PLZ
                rs("WE_Ort") = WE_Ort
                rs("WE_Str") = B_WE_Strasse
                rs("Status") = 1
                rs("erstellt_am") = Date
                rs("erstellt_von") = Login_akt()
                rs("Komp_Nr") = B_KompNr
                rs("G_Standort") = G_Standort
                rs("WE_Mail") = WE_Mail
                rs("AG_Mail") = AG_Mail
                
            ElseIf Upd_JN Then
                Counter = Counter + 1
                
                rs.Fields("SID").Value = SID
                rs.Fields("T_Nr").Value = T|fffd|rNr
                rs.Fields("AU_Nr").Value = B_AU_Nr
                rs.Fields("Art").Value = Art
                rs.Fields("Standort").Value = Standort
                rs.Fields("Typ").Value = Typ
                rs.Fields("Hersteller").Value = Hersteller
                rs.Fields("A_Typ").Value = Antriebstyp
                rs.Fields("Feststellung").Value = Feststellung
                rs.Fields("F_Anz").Value = Fl|fffd|gel
                rs.Fields("P_Datum").Value = Pr|fffd|fdatum
                rs.Fields("P_Befund").Value = Pr|fffd|fbefund
                rs.Fields("P_Bericht").Value = Pr|fffd|fbericht
                rs.Fields("P_Ma|fffd|nahme").Value = Ma|fffd|nahme
                rs.Fields("P_Pr|fffd|fer").Value = Pr|fffd|fer
                rs.Fields("P_Empf|fffd|nger").Value = B_Empf|fffd|nger
                rs.Fields("P_Status").Value = Status
                rs.Fields("AG_KdNr").Value = B_AG_Nr
                rs.Fields("AG_Name1").Value = B_AG_Firma1
                rs.Fields("AG_Name2").Value = B_AG_Firma2
                rs.Fields("AG_Land").Value = "DE"
                rs.Fields("AG_PLZ").Value = AG_PLZ
                rs.Fields("AG_Ort").Value = AG_Ort
                rs.Fields("AG_Str").Value = B_AG_Strasse
                rs.Fields("WE_Nr").Value = B_WE_Nr
                rs.Fields("WE_Name1").Value = B_WE_Firma1
                rs.Fields("WE_Name2").Value = B_WE_Firma2
                rs.Fields("WE_Land").Value = "DE"
                rs.Fields("WE_PLZ").Value = WE_PLZ
                rs.Fields("WE_Ort").Value = WE_Ort
                rs.Fields("WE_Str").Value = B_WE_Strasse
                rs.Fields("Status").Value = 1
                rs.Fields("erstellt_am").Value = Date
                rs.Fields("erstellt_von").Value = Login_akt()
                rs.Fields("Komp_Nr").Value = B_KompNr
                rs.Fields("G_Standort").Value = G_Standort
                rs.Fields("WE_Mail").Value = WE_Mail
                rs.Fields("AG_Mail").Value = AG_Mail
                
                rs.MoveNext
            End If
            
        End If
    Next
End With

    'reconnect to update
    Set con = getConn()
    Set rs.ActiveConnection = con
    Statusinfo Counter & " Datens|fffd|tze werden aktualisiert..."
    Application.Cursor = xlWait
    rs.UpdateBatch '<<< transfer to DB happens here: no loop!
    Application.Cursor = xlDefault
    rs.Close

    'requery to demonstrate insert was successful
    'rs.Open "select * from " & Range("DB_Table"), con, _
            adOpenDynamic, adLockBatchOptimistic

    'Do While Not rs.EOF
    '    Debug.Print rs("SID").Value, rs("T_Nr").Value
    '    rs.MoveNext
    'Loop

    'rs.Close
    con.Close
    
Statusinfo
mdb_SQL_Batch = Counter

Exit_:
Exit Function

Err_:
MsgBox Err.Description
Resume Exit_

End Function

Function getConn() As ADODB.Connection
    Dim rv As New ADODB.Connection
    Dim strConn As String

    'strConn = "Provider=Microsoft.ACE.OLEDB.12.0;" _
     & "Data Source = " & ThisWorkbook.Path & "\Test.accdb"
    strConn = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & DB_Source() & ";User Id=admin;Password=; "

    rv.Open strConn
    Set getConn = rv
End Function


Function Userdata(sFeldname As String) As String
Dim sDormaname As String
sDormaname = Login_akt()

Userdata = DLookup(sFeldname, "User", DB_Source(), "(Dormaname like '" & sDormaname & "')")
End Function
Attribute VB_Name = "mod_Signatur"
Option Explicit

Public Function IsUnicode(ByVal uFilename As String) As Boolean

On Error GoTo Fehler
Dim sText$
Close #1
Open uFilename For Binary As #1
sText = Input(LOF(1), #1)
'Debug.Print Time & ": " & sText
Close #1
If Left(sText, 2) = "|fffd||fffd|" Or Left(sText, 2) = "|fffd||fffd|" Or Left(sText, 3) = "|feff|" Then
IsUnicode = True
Else
IsUnicode = False
End If

Exit Function
Fehler:
'Debug.Print "Error in function IsUnicode: " & Err.Description & vbNewLine & "Error number: " & Err.Number

End Function


Public Function Push(ByRef mArray, ByVal mValue)
Dim mValEl
    If IsArray(mArray) Then
        If IsArray(mValue) Then
            For Each mValEl In mValue
                ReDim Preserve mArray(UBound(mArray) + 1)
                mArray(UBound(mArray)) = mValEl
            Next
        Else
            ReDim Preserve mArray(UBound(mArray) + 1)
            mArray(UBound(mArray)) = mValue
        End If
    Else
        If IsArray(mValue) Then
            mArray = mValue
        Else
            mArray = Array(mValue)
        End If
    End If
    Push = UBound(mArray)
End Function


Function FileOrDirExists(PathName As String) As Boolean
     'Macro Purpose: Function returns TRUE if the specified file
     '               or folder exists, false if not.
     'PathName     : Supports Windows mapped drives or UNC
     '             : Supports Macintosh paths
     'File usage   : Provide full file path and extension
     'Folder usage : Provide full folder path
     '               Accepts with/without trailing "\" (Windows)
     '               Accepts with/without trailing ":" (Macintosh)
     
    Dim iTemp As Integer
     
     'Ignore errors to allow for error evaluation
    On Error Resume Next
    iTemp = GetAttr(PathName)
     
     'Check if error exists and set response appropriately
    Select Case Err.Number
    Case Is = 0
        FileOrDirExists = True
    Case Else
        FileOrDirExists = False
    End Select
     
     'Resume error checking
    On Error GoTo 0
End Function


Function get_signature_dir() As String
Rem C:\Users\<UserName>\AppData\Roaming\Microsoft\Signatures
    get_signature_dir = "C:\Users\" + Environ("UserName") + "\AppData\Roaming\Microsoft\Signatures\"
End Function





Function get_signature_names() As Variant
On Error Resume Next
    Dim Pfad, Dateiname As String
    get_signature_names = Array()
    If Not FileOrDirExists(get_signature_dir()) Then Exit Function

    Pfad = get_signature_dir() + "*.*"
    Dateiname = Dir(Pfad)
    Do While Dateiname <> ""
        If Right(Dateiname, 4) = ".txt" Then
            Call Push(get_signature_names, Left(Dateiname, Len(Dateiname) - 4))
        End If
    Dateiname = Dir
    Loop
    
End Function

Function get_signature(ByVal name As String) As String

Dim dateidirname As String
Dim FSO, MyFile, FileName, TextLine
Const ForReading = 1, ForWriting = 2, ForAppending = 8
Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0

get_signature = ""
If Not FileOrDirExists(get_signature_dir()) Then Exit Function

dateidirname = get_signature_dir() + name + ".txt"
Set FSO = CreateObject("Scripting.FileSystemObject")
If IsUnicode(dateidirname) Then
    Set MyFile = FSO.OpentextFile(dateidirname, ForReading, True, TristateTrue)
Else
    Set MyFile = FSO.OpentextFile(dateidirname, ForReading, True, TristateFalse)
End If
Do While MyFile.AtEndOfStream <> True
TextLine = MyFile.ReadLine
get_signature = get_signature + TextLine + vbNewLine
Loop
MyFile.Close

Rem MsgBox (get_signature)

End Function


Sub test_signature()
Dim names As Variant
Dim i As Integer
names = get_signature_names()

For i = 0 To UBound(names)
    MsgBox (names(i))
    MsgBox (get_signature(names(i)))
Next i

End Sub


Function Signatur1() As String
Dim names As Variant
Dim i As Integer
names = get_signature_names()

For i = 0 To UBound(names)
    'MsgBox (names(i))
    If i = 0 Then Signatur1 = get_signature(names(i))
Next i

End Function
Attribute VB_Name = "mod_Utility"
Option Explicit
Option Compare Text
Declare Function GetShortPathName Lib "kernel32" Alias "GetShortPathNameA" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long
Private Declare Function GetSystemDirectory Lib "kernel32" Alias "GetSystemDirectoryA" (ByVal lpBuffer As String, ByVal nSize As Long) As Long
Private Declare Function GetWindowsDirectory Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal lpBuffer As String, ByVal nSize As Long) As Long
Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" _
       (ByVal hwnd As Long, ByVal lpOperation As String, _
        ByVal lpFile As String, ByVal lpParameters As String, _
        ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Declare Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long)


Public Function ReplaceStr(Textin, SearchStr, Replacement, Optional CompMode As Integer = 1)
'
' Replaces the SearchStr string with Replacement string in the TextIn string.
' Uses CompMode to determine comparison mode
' Aus der Neatcd97.mdb Microsoft
'   vbTextCompare=1
Dim WorkText As String, Pointer As Integer
  If IsNull(Textin) Then
    ReplaceStr = Null
  Else
    WorkText = Textin
    Pointer = InStr(1, WorkText, SearchStr, CompMode)
    Do While Pointer > 0
      WorkText = Left(WorkText, Pointer - 1) & Replacement & Mid(WorkText, Pointer + Len(SearchStr))
      Pointer = InStr(Pointer + Len(Replacement), WorkText, SearchStr, CompMode)
    Loop
    ReplaceStr = WorkText
  End If
End Function

Function GetDataRange(sheetname As String) As Range
'R|fffd|ckgabe der Function, wenn Daten im Tabellenblatt vorhanden sind:
Dim objWks As Worksheet
'Fehlerbehandlung aktivieren
  On Error Resume Next

If Len(sheetname) > 0 Then
    Set objWks = ActiveWorkbook.Worksheets(sheetname)
Else
    Set objWks = ActiveWorkbook.ActiveSheet
End If


'  Verwendeter Bereich (Range) mit Daten
    
    Dim objUsedRange As Range     'Gesamter verwendeter Bereich in Tabellenblatt
    Dim objAreaRange As Range     'Einzelner Bereich in nicht zusammenh|fffd|ngendem Bereich
    
    Dim nFirstColA   As Integer   'Erste verwendete Spalte in einzelnem Bereich
    Dim nFirstRowA   As Long      'Erste verwendete Zeile  in einzelnem Bereich
    
    Dim nLastColA    As Integer   'Letzte Spalten-Nr. in einzelnem Bereich
    Dim nLastRowA    As Long      'Letzte Zeile-Nr.   in einzelnem Bereich
    
    Dim nFirstCol    As Integer   'Erste verwendete Spalte
    Dim nFirstRow    As Long      'Erste verwendete Zeile
    
    Dim nLastCol     As Integer   'Letzte verwendete Spalte
    Dim nLastRow     As Long      'Letzte verwendete Zeile
    
  'Fehlerbehandlung aktivieren
    On Error Resume Next
    
  'Pr|fffd|fen, ob Zellen mit Daten (Konstanten und/oder Formeln) im angegebenen
  'Tabellenblatt vorhanden sind...
    If Application.WorksheetFunction.CountA(objWks.Cells) > 0 Then
      
      'Objektverweis auf die Vereinigung der Bereiche setzen, in dem Zellen
      'enthalten sind, die sowohl  Konstanten als auch Formeln enthalten
        Set objUsedRange = Union(objWks.UsedRange.SpecialCells(xlCellTypeConstants), _
            objWks.UsedRange.SpecialCells(xlCellTypeFormulas))
         
      '******************************************************************************
      'Wenn nicht sowohl Konstanten als auch Formeln im Tabellenblatt vorhanden sind,
      'ist objUsedRange hier = Nothing.
      '******************************************************************************
        
        If objUsedRange Is Nothing Then
          'N|fffd|chster Versuch...
          'Objektverweis auf den Bereich setzen, in dem Zellen enthalten sind,
          'die nur Konstanten enthalten
            Set objUsedRange = objWks.UsedRange.SpecialCells(xlCellTypeConstants)
        End If
      
      '******************************************************************************
      'Wenn im Tabellenblatt keine Konstanten enthalten sind (unwahrscheinlich!), ist
      'objUsedRange hier = Nothing.
      'Es m|fffd|ssten dann aber Formeln enthalten sein!!!
      '******************************************************************************
        
        If objUsedRange Is Nothing Then
          'N|fffd|chster Versuch...
          'Objektverweis auf den Bereich setzen, in dem Zellen enthalten sind,
          'die Formeln enthalten
            Set objUsedRange = objWks.UsedRange.SpecialCells(xlCellTypeFormulas)
        End If
        
      '******************************************************************************
      'Wenn hier objUsedRange immer noch = Nothing ist, dann ist 'was schief
      'gelaufen *heul*. (Bitte Problembeschreibung in unserem Forum posten.)
      '******************************************************************************
        
        If Not objUsedRange Is Nothing Then
          'Startwert f|fffd|r erste Spalte/Zeile
          '(hier letzte m|fffd|gliche Spalte/Zeile im Tabellenblatt)
            nFirstCol = objWks.Columns.Count
            nFirstRow = objWks.Rows.Count
            
          'Alle Bereiche (Areas) im Bereich (objUsedRange) "abklappern" und die
          'erste und letzte Spalte/Zeile ermitteln, und ggf. die Werte anpassen
            For Each objAreaRange In objUsedRange.Areas
                
              'Erste Spalte/Zeile des Bereichs (Area) ermitteln
                nFirstColA = objAreaRange.Column
                nFirstRowA = objAreaRange.Row
              
              'Letzte Spalte/Zeile des Bereichs (Area) ermitteln
                nLastColA = nFirstColA + objAreaRange.Columns.Count - 1
                nLastRowA = nFirstRowA + objAreaRange.Rows.Count - 1
                
              'Erste Spalte/Zeile des gesamten verwendeten Bereichs
              'ggf. korrigieren
                If nFirstColA < nFirstCol Then nFirstCol = nFirstColA
                If nFirstRowA < nFirstRow Then nFirstRow = nFirstRowA
                
              'Letzte Spalte/Zeile des gesamten verwendeten Bereichs
              'ggf. korrigieren
                If nLastRowA > nLastRow Then nLastRow = nLastRowA
                If nLastColA > nLastCol Then nLastCol = nLastColA
            Next  '// objAreaRange
           
          'R|fffd|ckgabe der Function
          'Objektverweis auf verwendeten Bereich
            Set GetDataRange = objWks.Range(objWks.Cells(nFirstRow, nFirstCol), _
                  objWks.Cells(nLastRow, nLastCol))
        End If
      'Fehlerbehandlung zur|fffd|cksetzen
        On Error GoTo 0
    End If
End Function
Function FieldCol(FieldName As String, Optional sheetname As String, Optional F_Row As Long) As Long
Dim xlsheet As Worksheet
'Fehlerbehandlung aktivieren
  On Error Resume Next
If Len(sheetname) > 0 Then
    Set xlsheet = ActiveWorkbook.Worksheets(sheetname)
Else
    Set xlsheet = ActiveWorkbook.ActiveSheet
End If
If F_Row = 0 Then F_Row = 1

With xlsheet
'Spalte mit Fieldname ermitteln (xlFormulas=-4123, xlWhole=1, xlByColumns=2, xlPrevious=2)
FieldCol = .Cells.Find(What:=FieldName, After:=.Cells(F_Row, 1), _
                    LookIn:=xlFormulas, LookAt:=1, _
                    SearchOrder:=xlByColumns, _
                    SearchDirection:=2).Column
End With
End Function

Function nLastCol(Optional sheetname As String) As Long
Dim xlsheet As Worksheet
'Fehlerbehandlung aktivieren
  On Error Resume Next
If Len(sheetname) > 0 Then
    Set xlsheet = ActiveWorkbook.Worksheets(sheetname)
Else
    Set xlsheet = ActiveWorkbook.ActiveSheet
End If
With xlsheet
'Letzte Spalte mit Daten ermitteln (xlFormulas=-4123, xlWhole=1, xlByColumns=2, xlPrevious=2)
nLastCol = .Cells.Find(What:="*", After:=.Cells(1), _
                    LookIn:=xlFormulas, LookAt:=1, _
                    SearchOrder:=2, _
                    SearchDirection:=2).Column
End With
End Function
Function nLastRow(Optional sheetname As String) As Long
Dim xlsheet As Worksheet, data_Adr
'Fehlerbehandlung aktivieren
  On Error Resume Next
If Len(sheetname) > 0 Then
    Set xlsheet = ActiveWorkbook.Worksheets(sheetname)
Else
    Set xlsheet = ActiveWorkbook.ActiveSheet
    sheetname = xlsheet.name
End If
data_Adr = GetDataRange(sheetname).Address
'nLastRow = Range(sheetname & "!" & Mid(data_Adr, InStr(1, data_Adr, ":") + 1)).Row
nLastRow = NurZahl(Mid(data_Adr, InStr(1, data_Adr, ":") + 1))

'With xlsheet
'Letzte Spalte mit Daten ermitteln (xlFormulas=-4123, xlWhole=1, xlByColumns=2, xlPrevious=2)
'nLastRow = .Cells.Find(What:="*", After:=.Cells(1), _
                    LookIn:=xlFormulas, LookAt:=1, _
                    SearchOrder:=2, _
                    SearchDirection:=2).Row
'End With
End Function
Public Sub ResetLastCell()
'-------------------------------------------------------------------------
' Diese Prozedur setzt die letzte Zelle des aktiven Tabellenblattes zur|fffd|ck
' Original-Code: Microsoft Corporation
' Anpassungen:   Philipp von Wartburg
'-------------------------------------------------------------------------
  Dim rngLastCell As Range
  Dim rowstep As Integer
  Dim colstep As Integer
  'Aktuelle letzte Zelle des aktiven Blattes merken
  Set rngLastCell = Cells.SpecialCells(xlLastCell)
  'Adresse der aktuellen letzten Zelle in der Statusleiste anzeigen
  Application.StatusBar = "Letzte Zelle: " & rngLastCell.Address
  'Variablen rowstep und colstep initialisieren
  rowstep = -1
  colstep = -1
  'Schleife durchlaufen bis letzte Zelle gefunden oder Zelle A1 erreicht ist
  While (rowstep + colstep <> 0) And (rngLastCell.Address <> "$A$1")
    'Pr|fffd|fen ob die momentane Spalte eine Zelle mit Daten enth|fffd|lt
    If Application.CountA(Range(Cells(1, rngLastCell.Column), rngLastCell)) > 0 Then _
      colstep = 0
    'Pr|fffd|fen ob die momentane Zeile eine Zelle mit Daten enth|fffd|lt
    If Application.CountA(Range(Cells(rngLastCell.Row, 1), rngLastCell)) > 0 Then _
      rowstep = 0
    'Objektpointer rngLastCell auf die neue Position setzen
    Set rngLastCell = rngLastCell.Offset(rowstep, colstep)
    'Adresse der "neuen" letzten Zelle in der Statusleiste anzeigen
    Application.StatusBar = "Letzte Zelle: " & rngLastCell.Address
  Wend
  'Unbenutzte Spalten leeren und dann l|fffd|schen
  With Range(Cells(1, rngLastCell.Column + 1), "IV65536")
    Application.StatusBar = "L|fffd|sche Spalten: " & .Address
    .Clear
    .Delete
  End With
  'Unbenutzte Zeilen leeren und dann l|fffd|schen
  With Rows(rngLastCell.Row + 1 & ":65536")
    Application.StatusBar = "L|fffd|sche Zeilen: " & .Address
    .Clear
    .Delete
  End With
  Set rngLastCell = Nothing
  'Neue letzte Zelle selektieren
  Cells.SpecialCells(xlLastCell).Select
  'Statusleiste zur|fffd|cksetzen und neue letzte Zelle ausgeben
  Application.StatusBar = False
  MsgBox "Die neue letzte Zelle besitzt die Adresse " & _
    Cells.SpecialCells(xlLastCell).Address(False, False) & ".", vbInformation
End Sub


Function WSH_Run(strCommand As String, Optional intWindowStyle As Integer = 1, Optional bWaitOnReturn As Boolean)
Dim WshShell As Object
On Error Resume Next
'intWindowStyle Description
'0   Hides the window and activates another window.
'1   Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time.
'2   Activates the window and displays it as a minimized window.
'3   Activates the window and displays it as a maximized window.
'4   Displays a window in its most recent size and position. The active window remains active.
'5   Activates the window and displays it in its current size and position.
'6   Minimizes the specified window and activates the next top-level window in the Z order.
'7   Displays the window as a minimized window. The active window remains active.
'8   Displays the window in its current state. The active window remains active.
'9   Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window.
'10  Sets the show-state based on the state of the program that started the application.
If Len(strCommand) = 0 Then Exit Function
Set WshShell = CreateObject("WScript.Shell")
WSH_Run = WshShell.Run(strCommand, intWindowStyle, bWaitOnReturn)
Set WshShell = Nothing
End Function
Function Explore(Path As String) As Double
On Error Resume Next
If Dir(Path, vbDirectory) = "" Then Exit Function
'Explore = Shell("c:\Windows\explorer.exe " & Path, vbNormalFocus)
Explore = WSH_Run("explorer.exe " & Path)

End Function
Function F_Copy(strQuelle As String, strZiel As String)
Dim FSO
On Error Resume Next
Statusinfo strQuelle & " wird nach " & strZiel & " kopiert..."
'Screen.MousePointer = 11
Set FSO = CreateObject("Scripting.FileSystemObject")
FSO.CopyFile strQuelle, strZiel
'Screen.MousePointer = 0
Statusinfo
Set FSO = Nothing
End Function
Function MakeDir(Foldername) As Boolean
Dim FSO
On Error GoTo Err_MakeDir
Set FSO = CreateObject("Scripting.FileSystemObject")
If Not FSO.FolderExists(Foldername) Then
   FSO.CreateFolder (Foldername)
End If
MakeDir = True

Exit_MakeDir:
Exit Function

Err_MakeDir:
If Err.Number = 76 Or Err.Number = 52 Then 'Pfad nicht gefunden / Dateiname oder Nummer falsch
    'MsgBox "Verzeichnis " & Foldername & " konnte nicht erstellt werden!" _
    , vbExclamation + vbOKOnly, App_Name
Else
    MsgBox Err.Number & " " & Err.Description
End If
Resume Exit_MakeDir

End Function
Sub Statusinfo(Optional Statustext As String)
Dim oldStatusBar
On Error GoTo Err_Statusinfo
oldStatusBar = Application.DisplayStatusBar
Application.DisplayStatusBar = True
If Statustext <> "" Then
    Application.StatusBar = Statustext
Else
    Application.StatusBar = False
    Application.DisplayStatusBar = oldStatusBar
End If
Exit_Statusinfo:
Exit Sub

Err_Statusinfo:
MsgBox Err.Description
Resume Exit_Statusinfo
End Sub

Function Path_Desktop() As String
Dim WshShell
'AllUsersDesktop, AllUsersStartMenu, AllUsersPrograms, AllUsersStartup
'Desktop, Favorites, Fonts, MyDocuments, NetHood, PrintHood, Programs
'Recent, SendTo, StartMenu, Startup, Templates
Set WshShell = CreateObject("WScript.Shell")
Path_Desktop = WshShell.SpecialFolders.Item("Desktop") & "\"
Set WshShell = Nothing
End Function
Function Path_MyDocs() As String
Dim WshShell
Set WshShell = CreateObject("WScript.Shell")
Path_MyDocs = WshShell.SpecialFolders.Item("MyDocuments") & "\"
Set WshShell = Nothing
End Function

Sub PDFCreator_Stop()
Dim oFD, ws, strProcess As String, strComputer As String, objWMIService, colProcesses, colProcessList, objProcess
strProcess = "PDFCreator.exe"
strComputer = "."
Set ws = CreateObject("WScript.Shell")
Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
Set colProcesses = objWMIService.ExecQuery _
("SELECT * FROM Win32_Process Where Name ='" & strProcess & "'")
Set colProcessList = objWMIService.ExecQuery _
("SELECT * FROM Win32_Process Where Name ='" & strProcess & "'")
For Each objProcess In colProcessList
    objProcess.Terminate
Next
End Sub
Function BrowseForAnything(ShowText, BrowseInformation, SetRoot)
 On Error Resume Next
 Dim AppShell As Object, ReturnFolder, WshShell, errorcode, ColonPosition

'Const SerSetRoot_desktop = 0
'Const SerSetRoot_programs = 2
'Const SerSetRoot_controlpanel = 3
'Const SerSetRoot_printers = 4
'Const SerSetRoot_documents = 5
'Const SerSetRoot_favorites = 6
'Const SerSetRoot_startup = 7
'Const SerSetRoot_recent = 8
'Const SerSetRoot_sendto = 9
'Const SerSetRoot_startmenu = 11
'Const SerSetRoot_drives = 17
'Const SerSetRoot_network = 18
'Const SerSetRoot_nethood = 19
'Const SerSetRoot_fonts = 20
'Const SerSetRoot_templates = 21


'&H0001  Only file system folders can be selected. If this bit is set, the OK button is disabled if the user selects a folder that doesn't belong to the file system (such as the Control Panel folder).
'&H0002  The user is prohibited from browsing below the domain within a network (during a computer search).
'&H0004  Room for status text is provided under the text box. (I haven't found a way to show the status, however.)
'&H0008  Returns file system ancestors only.
'&H0010  Shows an edit box in the dialog box for the user to type the name of an item.
'&H0020  Validate the name typed in the edit box.
'&H1000  Enables the user to browse the network branch of the shell's namespace for computer names.
'&H2000  Enables the user to browse the network branch of the shell's namespace for printer names.
'&H4000  Allows browsing for everything.

'Aufruf: xy = BrowseForAnything("Browse For Anything", &H10 + &H20 + &H4000, SerSetRoot_desktop)

 Set WshShell = CreateObject("WScript.Shell")
 Set AppShell = CreateObject("Shell.Application")

 Set ReturnFolder = AppShell.BrowseForFolder(&H0, ShowText, BrowseInformation, SetRoot)
 BrowseForAnything = ReturnFolder.ParentFolder.ParseName(ReturnFolder.Title).Path
 

errorcode = Err.Number

If errorcode <> 0 Then
    If errorcode = 424 Then
        BrowseForAnything = Null
    Else
        ColonPosition = InStr(ReturnFolder.Title, ":")
        If ColonPosition > 0 Then
            BrowseForAnything = Mid(ReturnFolder.Title, ColonPosition - 1, 2) & "\"
        End If
    End If
 End If
End Function
Function Ordnerauswahl() As String
Dim Startordner, titel As String
Const SerSetRoot_documents = 5
Const SerSetRoot_drives = 17
Const SerSetRoot_desktop = 0

Startordner = SerSetRoot_drives
titel = "Speicherort ausw|fffd|hlen"
'Ordnerauswahl = BrowseForAnything(Titel, &H10 + &H20 + &H4000, Startordner)
Ordnerauswahl = BrowseForAnything(titel, &H1000, Startordner)
End Function
Function Path_Programs() As String
Dim WshShell
Set WshShell = CreateObject("WScript.Shell")
Path_Programs = WshShell.RegRead("HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\ProgramFilesDir") & "\"
Set WshShell = Nothing
End Function
Function Path_DORMA_Apps() As String
Path_DORMA_Apps = "C:\" & "DORMA" & "\"
End Function
Function Path_DORMA_DB() As String
Path_DORMA_DB = Path_DORMA_Apps() & "Shared" & "\"
End Function
Function Path_This_App() As String
Path_This_App = ThisWorkbook.Path & "\"
End Function
Sub pcwBreaker()
'Blattschutz entfernen
  Dim i As Integer, j As Integer, k As Integer
  Dim l As Integer, m As Integer, N As Integer
  Dim i1 As Integer, i2 As Integer, i3 As Integer
  Dim i4 As Integer, i5 As Integer, i6 As Integer, Kennwort
  On Error Resume Next
  For i = 65 To 66: For j = 65 To 66: For k = 65 To 66
  For l = 65 To 66: For m = 65 To 66: For i1 = 65 To 66
  For i2 = 65 To 66: For i3 = 65 To 66: For i4 = 65 To 66
  For i5 = 65 To 66: For i6 = 65 To 66: For N = 32 To 126
     
 Kennwort = Chr(i) & Chr(j) & Chr(k) & Chr(l) & Chr(m) & Chr(i1) & Chr(i2) & Chr(i3) & Chr(i4) & Chr(i5) & Chr(i6) & Chr(N)
 ActiveSheet.Unprotect Kennwort
 If ActiveSheet.ProtectContents = False Then
        MsgBox "Fertig" & vbCr & "Das alternative Kennwort lautet:" & vbCr & Kennwort
        Exit Sub
  End If
  Next: Next: Next: Next: Next: Next
  Next: Next: Next: Next: Next: Next

End Sub

Function selektiere(ByVal S As String, ByVal i As Integer, ByVal A As String) As String
'
'               Funktion von Sascha Wostmann, s.w@gmx.de
'
' Selektiert im String S den i-ten Teil. Trennzeichen ist in A.
' Bei Fehlern (z.B. nicht genug Trennzeichen im String) wird ""
' geliefert
'
' z.B.
' String mit Trennzeichen
' ("suche den zweiten Teil, wenn '-' die Teile trennt")
'      selektiere("abc-def-ghi-jkl",2,"-") = "def"
'      selektiere("abc-def,ghi-jkl",2,"-") = "def,ghi"
'
' Suche vom Ende nach vorne
' ("suche den zweitletzten Teil")
'      selektiere("abc-def-ghi-jkl",-2,"-") = "ghi"
'
' mehrere Trennzeichen
' ("suche den zweiten Teil, wenn der String ', ' die Teile trennt")
'      selektiere("Bonn, K|fffd|ln, Bremen, D|fffd|sseldorf",2,", ") = "K|fffd|ln"
'
Dim Ret As String

Dim S1 As Integer
Dim S2 As Integer   ' Stellen, an denen der String getrennt wird

    selektiere = ""
    ' Sonderfall i<0 bedeutet, ich will den i.letzten Teilstring
    If i < 0 Then
        i = SAnzahl(S, A) + i + 2
    End If
    
    ' i mu|fffd| (nach obiger Anpassung) gr|fffd||fffd|er als Null sein
    If i <= 0 Then Exit Function
    S2 = -Len(A) + 1
    Do
        S1 = S2 + Len(A)
        S2 = InStr(S1, S, A)
        
        ' InStr gibt Null zur|fffd|ck, wenn Suchstring nicht gefunden wird
        If S2 = 0 Then S2 = Len(S) + 1
        i = i - 1
    Loop Until i = 0

    ' s1 ist dann gr|fffd||fffd|er als s2, wenn ein Teil selektiert
    ' werden soll, der gar nicht mehr in der Zeile existiert
    ' (z.B. das 5. von 4 Feldern)
    If S1 > S2 Then Exit Function
    
    ' R|fffd|ckgabewert ist der Teilstring zwischen s1 und s2
    Ret = Mid$(S, S1, S2 - S1)
    If Left$(Ret, 1) = Chr$(34) Then Ret = Mid$(Ret, 2)
    If Right$(Ret, 1) = Chr$(34) Then Ret = Left$(Ret, Len(Ret) - 1)
    
    selektiere = Ret
End Function
Function SAnzahl(S As String, A As String) As Integer
'
'               Funktion von Sascha Wostmann, s.w@gmx.de
'
' z|fffd|hlt die Vorkommen von A in S und liefert die Anzahl zur|fffd|ck
' Diese Funktion wird von "selektiere" (s.u.) aufgerufen, also
' nicht l|fffd|schen, wenn selektiere benutzt wird!
'
' z.B.
'      SAnzahl("abc-def-ghi-jkl","-") = 3
'      SAnzahl("Saschas Spass","as") = 3
'
Dim Ret As Integer
Dim T As String

    Ret = 0
    T = S
    Do While InStr(T, A)
        Ret = Ret + 1
        T = Mid$(T, InStr(T, A) + 1)
    Loop
    
    SAnzahl = Ret
End Function
Function ParsePath(ByVal FullPath As String, Drive_Dir_File_Ext As String) As String
'
' Parses drive, directory, filename, and extension into separate variables.
' Returns blank drive letter/path if none specified.
' Frm Neatcd97.mdb (MS)
'
Dim i As Integer, F As String, found As Integer
  Dim Drive As String, Dirname As String, fName As String, Ext As String
  FullPath = Trim$(FullPath)
'
' Get drive letter
'
  If Mid$(FullPath, 2, 1) = ":" Then
    Drive = Left$(FullPath, 2)
    FullPath = Mid$(FullPath, 3)
  End If
'
' Get directory name
'
  F = ""
  found = False
  For i = Len(FullPath) To 1 Step -1
    If Mid$(FullPath, i, 1) = "\" Then
      F = Mid$(FullPath, i + 1)
      Dirname = Left$(FullPath, i)
      found = True
      Exit For
    End If
  Next i
  If Not found Then
    F = FullPath
  End If
'
' Get File name and extension
'
  If F = "." Or F = ".." Then
    fName = F
  Else
    i = InStrRev(F, ".")
    If i > 0 Then
      fName = Left$(F, i - 1)
      Ext = Mid$(F, i)
    Else
      fName = F
    End If
  End If
  Select Case Drive_Dir_File_Ext
  Case "Drive_Dir_File_Ext"
    ParsePath = Drive & Dirname & fName & Ext
  Case "Drive_Dir_File"
    ParsePath = Drive & Dirname & fName
  Case "Drive"
    ParsePath = Drive
  Case "Dir"
    ParsePath = Dirname
  Case "Drive_Dir"
    ParsePath = Drive & Dirname
  Case "File_Ext"
    ParsePath = fName & Ext
  Case "File"
    ParsePath = fName
  Case "Ext"
    ParsePath = Ext
  Case Else
    ParsePath = FullPath
  End Select
End Function
Function GetShortPath(LongPath As String) As String
'**********************************************************************************
' Diese Funktion gibt den Kurzen Pfadnamen zur|fffd|ck
'**********************************************************************************
' Aus www.basicworld.com
'Declare Function GetShortPathName Lib "kernel32" Alias "GetShortPathNameA" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long

Dim sBuffer As String, lLen As Long
sBuffer = Space$(512)
lLen = GetShortPathName(LongPath, sBuffer, Len(sBuffer))
GetShortPath = Left$(sBuffer, lLen)

End Function
Function OhneUmlaut(vString As String) As String
vString = ReplaceStr(vString, "|fffd|", "ae")
vString = ReplaceStr(vString, "|fffd|", "oe")
vString = ReplaceStr(vString, "|fffd|", "ue")
vString = ReplaceStr(vString, "|fffd|", "ss")
OhneUmlaut = vString
End Function
Function OhneZahl(vString As String) As String
vString = ReplaceStr(vString, "0", "")
vString = ReplaceStr(vString, "1", "")
vString = ReplaceStr(vString, "2", "")
vString = ReplaceStr(vString, "3", "")
vString = ReplaceStr(vString, "4", "")
vString = ReplaceStr(vString, "5", "")
vString = ReplaceStr(vString, "6", "")
vString = ReplaceStr(vString, "7", "")
vString = ReplaceStr(vString, "8", "")
vString = ReplaceStr(vString, "9", "")
'Bindestrich entfernen
If Right(vString, 1) = "-" Then vString = ReplaceStr(vString, "-", "")
OhneZahl = vString
End Function
Function NurZahl(Eingabe As String)
' ***********************************************************
' Entfernt alle nicht numerischen Werte und gibt die puren Ziffern zur|fffd|ck
' Ausschlie|fffd|lich gedacht, um z.B. aus Telefonnummern "/" oder "-" oder "(" ")"
' zu entfernen.
' Achtung: Es entfernt auch Komma oder Tausenderpunkt etc ohne R|fffd|cksicht.
' Die Funktion ist also f|fffd|r Zahlen mit Nachkommastellen ungeeignet !!!
' ***********************************************************

Dim i As Integer, Max As Integer, Tmp As String

NurZahl = ""

Max = Len(Trim(Eingabe))

If Max = 0 Then
    Exit Function
End If

For i = 1 To Max
    Tmp = Mid(Eingabe, i, 1)
    If Not (Tmp < Chr(48) Or Tmp > Chr(57)) Then
        NurZahl = NurZahl & Tmp
    End If
Next i

End Function
Function Dorma62(vNachname, vVorname) As Variant
Dim NN6 As String, VN2 As String
On Error Resume Next
Dorma62 = Null
If Len(vNachname) = 0 Or Len(vVorname) = 0 Then
    Exit Function
Else
    NN6 = vNachname
    NN6 = OhneUmlaut(NN6)
    NN6 = Left(NN6, 6)
    
    VN2 = vVorname
    VN2 = OhneUmlaut(VN2)
    VN2 = Left(VN2, 2)
    
    Dorma62 = NN6 & VN2

End If
End Function
Function Filename_Proper(sFilename As String) As String
'Entfernung unzul|fffd|ssige Zeichen im Dateinamen
' ",", "\", "/", "&", ";", ":", "+", "|", ">", "<"

sFilename = Replace(sFilename, ":", " ")
sFilename = Replace(sFilename, ",", " ")
sFilename = Replace(sFilename, ";", " ")
sFilename = Replace(sFilename, "+", " ")
sFilename = Replace(sFilename, "<", " ")
sFilename = Replace(sFilename, ">", " ")
sFilename = Replace(sFilename, "|", " ")
sFilename = Replace(sFilename, "/", " ")
sFilename = Replace(sFilename, "?", " ")
sFilename = Replace(sFilename, "*", " ")
sFilename = Replace(sFilename, Chr(34), "")

Filename_Proper = sFilename
End Function
Function NV2VN(NV As String) As String
'Name, Vorname zu Vorname Name
Dim SepPos As Integer
SepPos = InStr(1, NV, ",")
If SepPos > 0 Then
    NV2VN = Trim(Mid(NV, SepPos + 1)) & " " & Trim(Left(NV, SepPos - 1))
Else
    NV2VN = NV
End If
End Function
Sub WB_Close()
On Error Resume Next
Application.DisplayAlerts = False
ThisWorkbook.Saved = True
If Application.Workbooks.Count = 1 Then
    Application.Quit
Else
    ThisWorkbook.Close
End If
End Sub

Function WindowsUnZip(sUnzipFileName, sUnzipDestination)
Dim oUnzipFSO
  'This script is provided under the Creative Commons license located
  'at http://creativecommons.org/licenses/by-nc/2.5/ . It may not
  'be used for commercial purposes with out the expressed written consent
  'of NateRice.com
  Set oUnzipFSO = CreateObject("Scripting.FileSystemObject")
 
  If Not oUnzipFSO.FolderExists(sUnzipDestination) Then
    oUnzipFSO.CreateFolder (sUnzipDestination)
  End If

  With CreateObject("Shell.Application")
       .Namespace("" & sUnzipDestination).Copyhere .Namespace("" & sUnzipFileName).Items()
  End With

  Set oUnzipFSO = Nothing
End Function

Function WindowsZip(sFile, sZipFile)
Dim oZipShell, oZipFSO, oZipApp, sZipFileCount, aFileName, sFilename, sDupe, sFileNameInZip, sLoop
  'This script is provided under the Creative Commons license located
  'at http://creativecommons.org/licenses/by-nc/2.5/ . It may not
  'be used for commercial purposes with out the expressed written consent
  'of NateRice.com

  Set oZipShell = CreateObject("WScript.Shell")
  Set oZipFSO = CreateObject("Scripting.FileSystemObject")
  
  If Not oZipFSO.FileExists(sZipFile) Then
    NewZip (sZipFile)
  End If

  Set oZipApp = CreateObject("Shell.Application")
  
  sZipFileCount = oZipApp.Namespace("" & sZipFile).Items.Count

  aFileName = Split(sFile, "\")
  sFilename = (aFileName(UBound(aFileName)))
  
  'listfiles
  sDupe = False
  For Each sFileNameInZip In oZipApp.Namespace("" & sZipFile).Items()
    If LCase(sFilename) = LCase(sFileNameInZip) Then
      sDupe = True
      Exit For
    End If
  Next
  
  If Not sDupe Then
    oZipApp.Namespace("" & sZipFile).Copyhere "" & sFile

    'Keep script waiting until Compressing is done
    On Error Resume Next
    sLoop = 0
    Do Until sZipFileCount < oZipApp.Namespace("" & sZipFile).Items.Count
      Sleep (100)
      sLoop = sLoop + 1
    Loop
    On Error GoTo 0
  End If
End Function

Sub NewZip(sNewZip)
Dim oNewZipFSO, oNewZipFile
  'This script is provided under the Creative Commons license located
  'at http://creativecommons.org/licenses/by-nc/2.5/ . It may not
  'be used for commercial purposes with out the expressed written consent
  'of NateRice.com

  Set oNewZipFSO = CreateObject("Scripting.FileSystemObject")
  Set oNewZipFile = oNewZipFSO.CreateTextFile(sNewZip)
    
  oNewZipFile.Write Chr(80) & Chr(75) & Chr(5) & Chr(6) & String(18, 0)
  
  oNewZipFile.Close
  Set oNewZipFSO = Nothing

  Sleep (500)
End Sub
Function Open_Template(Vorlage As String)
Dim oApp As Object, aDoc, Ext As String, Maximized, Antwort As Integer, sTool As String, sKennung As String

On Error Resume Next
'Screen.MousePointer = 11
Statusinfo Vorlage & " wird ge|fffd|ffnet..."
Ext = Right(Vorlage, 3)
Select Case Ext
    Case "dot"
        Maximized = 1   'wdWindowStateMaximize
        Set oApp = CreateObject("Word.Application")
        oApp.Documents.Add Template:=Vorlage, NewTemplate:=False
        Set aDoc = oApp.ActiveDocument
    Case "xlt"
        Maximized = -4137    'xlMaximized
        If App_Name() = "Pr|fffd|fnachweis" Then
            sKennung = Sheets(1).Range("AU_Nr")
            Antwort = MsgBox("Aktuelle Kopfdaten von Auftrag " & sKennung & " als Filter verwenden?" _
            & vbCrLf & vbCrLf _
            & "Info: Filter k|fffd|nnen mit Doppelklick in das Eingabefeld entfernt werden." _
            , vbQuestion + vbYesNoCancel, "Datenselektion PN Abfrage")
            If Antwort = vbCancel Then Exit Function
        End If
        Set oApp = CreateObject("Excel.Application")
        oApp.Workbooks.Add Template:=Vorlage
        Set aDoc = oApp.ActiveSheet
End Select

oApp.Visible = True
oApp.Activate
oApp.WindowState = Maximized
oApp.ActiveWindow.WindowState = Maximized

If Ext = "dot" Then
    If InStr(1, Vorlage, "Risk") Then   'Risikobewertung
        'RB_f|fffd|llen oApp, aDoc, Vorlage
    End If
ElseIf Ext = "xlt" Then
    
    sTool = Left(oApp.ActiveWorkbook.name, 3)
    
    If sTool = "PN_" Then
        If Antwort = vbYes Then
            Bereiche_f|fffd|llen oApp, sTool
        End If
    End If
End If


Set aDoc = Nothing
Set oApp = Nothing
Statusinfo
'Screen.MousePointer = 0
End Function
Sub Bereiche_f|fffd|llen(oApp, sTool)
On Error Resume Next
With oApp
    If sTool = "PN_" Then
        With oApp.Sheets(2)
            .Range("Filt3_sel") = ThisWorkbook.Sheets(1).Range("Login_akt")
            .Range("Filt4_sel") = ThisWorkbook.Sheets(1).Range("AG_Nr")
            .Range("Filt6_sel") = ThisWorkbook.Sheets(1).Range("WE_Firma1")
            .Range("Filt7_sel") = ThisWorkbook.Sheets(1).Range("WE_Nr")
            .Range("Filt8_sel") = ThisWorkbook.Sheets(1).Range("AU_Nr")
            '.Range("Filt9_sel") = ThisWorkbook.Sheets(1).Range("B_KompNr")
            '.Range("Filt10_sel") = ThisWorkbook.Sheets(1).Range("G_Standort")
        End With
    End If
End With

End Sub
Function Open_Proper(Dateiname As String)
If Len(Dateiname) > 0 Then
    If Right(Dateiname, 3) = "xlt" Or Right(Dateiname, 3) = "dot" Then
        Open_Template Dateiname
    Else
        WSH_Run Chr(34) & Dateiname & Chr(34)    'GetShortPath(Dateiname)
    End If
End If

End Function

Function New_Excel()
Dim oApp As Object, aDoc, Ext As String, Maximized
On Error Resume Next
'Screen.MousePointer = 11
'Statusinfo Vorlage & " wird ge|fffd|ffnet..."

Maximized = -4137    'xlMaximized
Set oApp = CreateObject("Excel.Application")
oApp.Workbooks.Add
Set aDoc = oApp.ActiveSheet

oApp.Visible = True
oApp.Activate
oApp.WindowState = Maximized
oApp.ActiveWindow.WindowState = Maximized

If Ext = "dot" Then
    'Textmarken_f|fffd|llen adoc, Vorlage
ElseIf Ext = "xlt" Then
    'Bereiche_f|fffd|llen adoc, Vorlage
End If

Set aDoc = Nothing
Set oApp = Nothing
Statusinfo
'Screen.MousePointer = 0

End Function
Function Formfield_f|fffd|llen(aDoc, FeldName As String, ByVal Inhalt As String)
On Error Resume Next
If aDoc.formfields.Exists(FeldName) Then
    aDoc.formfields(FeldName).Result = Inhalt
    If Inhalt = "0" Or Inhalt = "-1" Then
        aDoc.formfields(FeldName).CheckBox.Value = CBool(Inhalt)
    End If
End If

End Function
Function Bookmarks_f|fffd|llen(aDoc, FeldName As String, ByVal Inhalt As String)
On Error Resume Next
If aDoc.Bookmarks.Exists(FeldName) Then
    aDoc.Bookmarks(FeldName).Range.Text = Inhalt
End If
End Function
Sub Terminate_Process(ProcessName As String)
'Prozess ohne Nachfrage beenden
Dim strComputer As String, objProcess As Object, objWMIService, colProcessList
strComputer = "."
Set objWMIService = GetObject("winmgmts:" _
    & "{impersonationLevel=impersonate}!\\" _
    & strComputer & "\root\cimv2")
    
Set colProcessList = objWMIService.ExecQuery _
    ("Select * from Win32_Process Where Name = '" & ProcessName & "'")
For Each objProcess In colProcessList
    objProcess.Terminate
Next
End Sub

Function WB_loaded(FileName As String, CloseJN As Boolean) As Boolean
Dim wb As Workbook, wb_xlName As String
wb_xlName = ParsePath(FileName, "File_Ext")
For Each wb In Application.Workbooks
    If wb.name = wb_xlName Then
        WB_loaded = True
        If CloseJN Then wb.Close SaveChanges:=False
    End If
Next wb
End Function
Function xlFormat()
    'Excel-Format definieren
    If Val(Application.Version) > 11 Then
        xlFormat = 56 'xlExcel8
    Else
        xlFormat = xlNormal
    End If
End Function
Function MsgBoxT(strText As String, Optional nSecondsToWait As Long, Optional strTitle As String, Optional nType As Long) As Integer
    Dim AckTime As Integer, InfoBox As Object
    Set InfoBox = CreateObject("WScript.Shell")
    MsgBoxT = InfoBox.Popup(strText, nSecondsToWait, strTitle, nType)
End Function

Attribute VB_Name = "mod_txt"
Option Explicit
Option Compare Text
' Wird ben|fffd|tigt, zum Ermitteln des tempor|fffd|ren
' Verzeichnisses und zum Erstellen tempor|fffd|rer Dateien
Private Declare Function GetTempFileName Lib "kernel32" _
  Alias "GetTempFileNameA" ( _
  ByVal lpszPath As String, _
  ByVal lpPrefixString As String, _
  ByVal wUnique As Long, _
  ByVal lpTempFileName As String) As Long
 
Private Declare Function GetTempPath Lib "kernel32.dll" _
  Alias "GetTempPathA" ( _
  ByVal nBufferLength As Long, _
  ByVal lpBuffer As String) As Long
 
Private winTempPath As String
 
' Ermittelt einen tempor|fffd|ren Dateinamen
' im tempor|fffd|ren Verzeichnis
Private Function txt_TempFilename() As String
  Dim myTempFileName As String
  Dim RetVal As Long
 
  If winTempPath = "" Then
    ' Tempor|fffd|res Verzeichnis ermitteln
    winTempPath = Space$(256)
    RetVal = GetTempPath(Len(winTempPath), winTempPath)
    winTempPath = Left$(winTempPath, RetVal)
  End If
 
  ' Tempor|fffd|ren Dateinamen ermitteln
  myTempFileName = Space$(256)
  Call GetTempFileName(winTempPath, "txt", 0&, myTempFileName)
  myTempFileName = Left$(myTempFileName, _
    InStr(myTempFileName, Chr$(0)) - 1)
 
  txt_TempFilename = myTempFileName
End Function
' Beliebigen Text in eine Textdatei speichern, wobei
' der bisherige Inhalt der Textdatei vollst|fffd|ndig
' |fffd|berschrieben wird
'
' sFilename:  vollst|fffd|ndiger Dateiname
' sLines   :  Inhalt, der gespeichert werden soll
' ===============================================
Public Sub txt_WriteAll(ByVal sFilename As String, _
  ByVal sLines As String)
 
  Dim F As Integer
 
  ' Datei zum Schreiben |fffd|ffnen
  ' Achtung: bisheriger Inhalt wird gel|fffd|scht!
  F = FreeFile
  Open sFilename For Output As #F
  Print #F, sLines
  Close #F
End Sub
' Einzelne Zeile in eine Textdatei speichern
' sFilename:  vollst|fffd|ndiger Name der Datei
' LinePos  :  Zeilenummer in der Textdatei
' sLine    :  Inhalt, der gespeichert werden soll
' ===============================================
Public Sub txt_WriteLine(ByVal sFilename As String, _
  ByVal LinePos As Long, ByVal sLine As String)
 
  Dim F As Integer
  Dim N As Integer
  Dim i As Long
  Dim lRow As Long
  Dim Zeile As String
  Dim myTempFile As String
 
  If Dir$(sFilename, vbNormal) = "" Then
    ' Wenn Datei nicht existiert, automatisch erstellen
    ' und Inhalt sofort speichern
    F = FreeFile
    Open sFilename For Output As #F
 
    ' Datei mit Leerzeilen f|fffd|llen, bis gew|fffd|nschte
    ' Schreibposition erreicht ist
    For i = 1 To LinePos - 1
      Print #F, ""
    Next i
 
    ' Inhalt speichern
    Print #F, sLine
    Close #F
 
  Else
    ' Tempor|fffd|re Datei erstellen
    myTempFile = txt_TempFilename()
 
    ' Original-Datei zum Lesen und tempor|fffd|re
    ' Datei zum Schreiben |fffd|ffnen
    F = FreeFile: Open sFilename For Input As #F
    N = FreeFile: Open myTempFile For Output As #N
 
    ' Original-Datei einlesen und x. Zeile durch
    ' neuen Inhalt ersetzen
    lRow = 0
    While Not EOF(F)
      lRow = lRow + 1
      Line Input #F, Zeile
 
      If lRow = LinePos Then
        ' x. Zeile durch neuen Inhalt ersetzen
        Zeile = sLine
      End If
 
      Print #N, Zeile
    Wend
 
    ' sollte LinePos gr|fffd||fffd|er sein, als die bisherige
    ' Anzahl gespeicherter Zeilen in der Orginaldatei
    ' wurde der neue Inhalt noch nicht gespeichert
    ' und die Datei muss ggf. noch mit zus|fffd|tzlichen
    ' Leerzeilen gef|fffd|llt werden!
    If lRow < LinePos Then
      ' Ggf. mit Leerzeilen f|fffd|llen
      For i = lRow + 1 To LinePos - 1
        Print #N, ""
      Next i
 
      ' Neuen Zeilen-Inhalt speichern
      Print #N, sLine
    End If
 
    ' Dateien schliessen
    Close #F: Close #N
 
    ' Alte Datei l|fffd|schen
    Kill sFilename
 
    ' tempor|fffd|re Datei in "alte" Datei umbenennen
    FileCopy myTempFile, sFilename
    Kill myTempFile
  End If
End Sub
' Lesen einer bestimmten Zeile einer Textdatei
' sFilename:  vollst|fffd|ndiger Dateiname
' LineToRead: Zeile, deren Inhalt zur|fffd|ckgegeben werden soll
' =========================================================
Public Function txt_ReadLine(ByVal sFilename As String, _
  ByVal LineToRead As Long) As String
 
  Dim F As Integer
  Dim sLine As String
  Dim lRow As Long
 
  lRow = 0
  ' Existiert die Datei ?
  If Dir$(sFilename) <> "" Then
 
    ' Datei zum Lesen |fffd|ffnen
    F = FreeFile
    Open sFilename For Input As #F
 
    ' Solange einlesen, bis entweder Dateiende
    ' oder gew|fffd|nschte Zeilennummer erreicht
    While Not EOF(F) And lRow < LineToRead
      lRow = lRow + 1
      Line Input #F, sLine
    Wend
    Close #F
  End If
 
  ' Dateiende wurde fr|fffd|hzeitig erreicht,
  ' oder Datei war nicht vorhanden
  If lRow < LineToRead Then _
    sLine = ""
 
  txt_ReadLine = sLine
End Function

' Einzelne Zeile an eine Textdatei anh|fffd|ngen
' sFilename:  vollst|fffd|ndiger Name der Datei
' sLine    :  Inhalt, der gespeichert werden soll
' ===============================================
Public Sub txt_AppendLine(ByVal sFilename As String, _
  ByVal sLine As String)
 
  Dim F As Integer
 
  ' Datei zum "Anh|fffd|ngen" von Daten |fffd|ffnen
  ' und Textzeile ans Ende anf|fffd|gen
  F = FreeFile
  Open sFilename For Append As #F
  Print #F, sLine
  Close #F
End Sub
' Lesen des gesamten Inhaltes einer Textdatei
' sFilename:  vollst|fffd|ndiger Dateiname
' =========================================================
Public Function txt_ReadAll(ByVal sFilename As String) _
  As String
 
  Dim F As Integer
  Dim sInhalt As String
 
  ' Existiert die Datei ?
  If Dir$(sFilename, vbNormal) <> "" Then
    ' Textdatei im Bin|fffd|rmodus |fffd|ffnen und gesamten
    ' Inhalt in einem Rutsch auslesen
    F = FreeFile
    Open sFilename For Binary As #F
    sInhalt = Space$(LOF(F))
    Get #F, , sInhalt
    Close #F
  End If
 
  txt_ReadAll = sInhalt
End Function


INQUEST-PP=macro
