Attribute VB_Name = "Mod1Zip"
Option Explicit
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

'Here's the enum for Sheel.Application Filter. Encontrei no CD1 do VS60 em F:\VC98\INCLUDE s|fffd| 6,
'mas para o XP e Vista tem mais constantes. As 3 |fffd|ltimas |fffd| s|fffd| no Vista.
Public Const SHCONTF_FOLDERS = 32    '&H20    'Include items that are folders in the enumeration
Public Const SHCONTF_NONFOLDERS = 64    '&H40    'Include items that are not folders in the enumeration
Const SHCONTF_INCLUDEHIDDEN = 128    '&H80    'Include hidden items in the enumeration

Const SHCONTF_INIT_ON_FIRST_NEXT = 256    '&H100    'http://msdn2.microsoft.com/en-us/library/ms649332.aspx
Const SHCONTF_NETPRINTERSRCH = 512    '&H200
Const SHCONTF_SHAREABLE = 1024    '&H400
Const SHCONTF_STORAGE = 2048    '&H800

Const SHCONTF_FASTITEMS = 8192    '&H2000
Const SHCONTF_FLATLIST = 16384    '&H4000
Const SHCONTF_ENABLE_ASYNC = -32768    '&H8000

Sub TestCopyToZipFolder()
    Dim sDestZipPath
    Dim sOrigPath
    Dim sFileFilter As String
    Dim lAttrib As Long

    sDestZipPath = "c:\backtest.zip"
    sOrigPath = "s:\cpap"
    '    sFileFilter = "*.mac"
    '    sFileFilter = "areceber"
    '    sFileFilter = ""
    sFileFilter = "Areceber\testeLOtot.xls"
    lAttrib = 32
    'lAttrib = 64
    lAttrib = 0
    If Dir(sDestZipPath) <> "" Then Kill sDestZipPath

    CopyToZipFolder sDestZipPath, sOrigPath, sFileFilter, lAttrib
End Sub

Function CopyToZipFolder(sDestZipPath As Variant, sOrigPath As Variant, _
        Optional sFileFilter As String, Optional lAttrib As Long) As Boolean
'Um problema desta rotina |fffd| que se houver falha, como uma subpasta em branco ou um caractere n|fffd|o
'aceit|fffd|vel para zip (|fffd||fffd|), o restante dos arquivos n|fffd|o s|fffd|o copiados. A solu|fffd||fffd|o |fffd| criticar tudo antes
'de copiar ou abrir e copiar e criticar um a um.
    Dim ShlApp
    Dim OrigItems
    Dim lDest As Long
    Dim lOrig As Long
    Dim lWaitMax As Long
    Dim lAdding As Long
    Dim lAddingAnt As Long

    On Error GoTo ErrorHandler
    Application.StatusBar = "Backup de " & sFileFilter & "..."
    With CreateObject("Scripting.FileSystemObject")
        If Not .FileExists(sDestZipPath) Then .CreateTextFile(sDestZipPath, True).Write "PK" & Chr(5) & Chr(6) & String(18, Chr(0))
    End With

    Set ShlApp = CreateObject("Shell.Application")
    lDest = ShlApp.NameSpace(sDestZipPath).items.Count

    Set OrigItems = ShlApp.NameSpace(sOrigPath).items    'Se sDestZipPath e sOrigPath n|fffd|o forem Variant d|fffd| erro

    'Filtrar por atributo ou m|fffd|scara de nome de arquivo ou folder
    Select Case lAttrib
    Case SHCONTF_FOLDERS    '32 para copiar s|fffd| SubFolders
        OrigItems.Filter SHCONTF_FOLDERS, sFileFilter
    Case SHCONTF_NONFOLDERS    '64 para copiar s|fffd| arquivos, ignora SubFolders
        OrigItems.Filter SHCONTF_NONFOLDERS, sFileFilter
    Case Else    'Sem atributo definido
        'Se existir m|fffd|scara, copia s|fffd| os arquivos que a satisfa|fffd|am. Do contr|fffd|rio, n|fffd|o
        'filtra nada e vai copiar todos os arquivos e subfolders
        If sFileFilter <> "" Then OrigItems.Filter SHCONTF_NONFOLDERS, sFileFilter
    End Select

    lOrig = OrigItems.Count
    ShlApp.NameSpace(sDestZipPath).CopyHere OrigItems    ', 4 nao atende as op|fffd||fffd|es, parece bug

    'Esperar
    Application.Interactive = False
    Do
        MyWait 1
        lAdding = GetlAdding(sDestZipPath) 'ShlApp.NameSpace(sDestZipPath).items.Count Troquei pela fun|fffd||fffd|o ver obs. na mesma
        Application.StatusBar = "Aguardando backup de " & sFileFilter & ": " & lWaitMax & "s"
        If lAdding = lAddingAnt Then lWaitMax = lWaitMax + 1 Else lWaitMax = 0
        lAddingAnt = lAdding
    Loop While lAdding < lDest + lOrig And lWaitMax < 60
    Application.Interactive = True

ErrorHandler:
    If Err.Number <> 0 Then MsgBox "Erro " & Err.Number & " (" & Err.Description & ")", vbCritical, "Falha no Procedimento CopyToZipFolder!"
    CopyToZipFolder = Err.Number = 0 And lWaitMax < 60
    Set OrigItems = Nothing
    Set ShlApp = Nothing
    Application.StatusBar = " ": Application.StatusBar = False    'No 2007 false n|fffd|o atualiza de imediato
End Function

Private Function GetlAdding(sDestZipPath As Variant) As Long
'A contagem dava erro inexplic|fffd|vel no 2007 em Virtual principalmente se verif. nomes de arquivos e
'projeto VBA estivesse protegido. Com esta fun|fffd||fffd|o o controle de erro fica separado e retornando
'contagem 0 o que |fffd| mais adequado. Assim h|fffd| mais tentativas e deixa pra sair na espera max.
    Dim ShlApp
    On Error Resume Next
    Set ShlApp = CreateObject("Shell.Application")
    GetlAdding = ShlApp.NameSpace(sDestZipPath).items.Count
    If Err.Number <> 0 Then GetlAdding = 0
    Set ShlApp = Nothing
End Function

Sub TestCopyToZipFolder2()
    Dim sDestZipPath
    Dim sOrigPath
    Dim sListFile As String

    sDestZipPath = "c:\backtest.zip"
    sOrigPath = "s:\cpap"
    sListFile = "S:\cpap\lstarq.bak"
    If Dir(sDestZipPath) <> "" Then Kill sDestZipPath

    CopyToZipFolder2 sDestZipPath, sOrigPath, sListFile
End Sub

Function CopyToZipFolder2(sDestZipPath As Variant, sOrigPath As Variant, _
        sListFile As String) As Boolean
'Copia todos os arquivos de uma lista pre salva para um folder temp e depois copia usando CopyToZipFolder
    Dim fso As Scripting.FileSystemObject      'Microsoft Scripting Runtime library ref
    Dim LogTbak As Scripting.TextStream
    Dim DirTemp As Scripting.Folder
    Dim CpapTempFold As Scripting.Folder

    Set fso = CreateObject("Scripting.FileSystemObject")
    Set DirTemp = fso.GetSpecialFolder(TemporaryFolder)
    If fso.FolderExists(DirTemp.Path & "\CpapTempBak") Then DirTemp.SubFolders("CpapTempBak").Delete
    Set CpapTempFold = DirTemp.SubFolders.Add("CpapTempBak")

    Set LogTbak = fso.OpenTextFile(sListFile, ForReading, False)

    Do While Not LogTbak.AtEndOfStream
        Dim sReadLine As String
        Dim fCopy As Scripting.File
        sReadLine = LogTbak.ReadLine
        If fso.FileExists(sOrigPath & "\" & sReadLine) Then
            Set fCopy = fso.GetFile(sOrigPath & "\" & sReadLine)

            'Montar arvore de subfolders para copiar o arquivo
            Dim sReadLine1 As String
            Dim sReadLine2 As String
            Dim tFolder As Scripting.Folder
            sReadLine1 = sReadLine
            Set tFolder = fso.GetFolder(DirTemp.Path & "\CpapTempBak")
            Do While InStr(1, sReadLine1, "\") > 0
                sReadLine2 = Left(sReadLine1, InStr(1, sReadLine1, "\") - 1)
                If fso.FolderExists(tFolder.Path & "\" & sReadLine2) Then
                    Set tFolder = fso.GetFolder(tFolder.Path & "\" & sReadLine2)
                Else
                    Set tFolder = tFolder.SubFolders.Add(sReadLine2)
                End If
                sReadLine1 = Mid(sReadLine1, InStr(1, sReadLine1, "\") + 1)
            Loop

            fCopy.Copy (CpapTempFold.Path & "\" & sReadLine)
        Else
            MsgBox "Arquivo n|fffd|o encontrado: " & sOrigPath & "\" & sReadLine
        End If
    Loop
    LogTbak.Close

    CopyToZipFolder sDestZipPath, CpapTempFold.Path
    MyWait 0.1
    CopyToZipFolder2 = Err.Number = 0

    CpapTempFold.Delete

    Set fso = Nothing
    Set LogTbak = Nothing
    Set DirTemp = Nothing
    Set CpapTempFold = Nothing
    Set fCopy = Nothing
    Set tFolder = Nothing
End Function

Sub MyWait(PauseSeg As Double)
    Dim Start
    Start = Timer
    Do While Timer < Start + PauseSeg
        DoEvents
        Sleep 1    'Com isso o CPU Usage cai de 100% para seus 0 ou 2% normal
    Loop
End Sub

Attribute VB_Name = "Mod2ListFolder"
Option Explicit
Dim fso
Dim LogTbak

Sub ttt()
    Dim DirP As String
    Dim SubDir As String
    DirP = "s:\cpap"
    SubDir = "tabelas"
    ListCPAPfiles DirP, SubDir, "s:\cpap\logt.bak"
End Sub

Function ListCPAPfiles(DirP As String, SubDir As String, sListFile As String) As Boolean
    Static lCntFld As Long    'pois chamado de xlm
    On Error Resume Next
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set LogTbak = fso.OpenTextFile(sListFile, 8, True)
    If Not ListFolder(IIf(SubDir = "", DirP, DirP & "\" & SubDir), Len(DirP), lCntFld) Then Exit Function
    LogTbak.Close
    Set fso = Nothing
    Set LogTbak = Nothing
    ListCPAPfiles = Err.Number = 0
    Application.StatusBar = " ": Application.StatusBar = False    'No 2007 false n|fffd|o atualiza de imediato
End Function

Function ListFolder(ByVal sFolder As String, ByVal lLenRootPath As Long, lCntFld As Long) As Boolean
    Dim f As Scripting.File
    Dim fd As Scripting.Folder
    Dim fd1 As Scripting.Folder
    Dim fc    'File or folder collection
    Dim i As Long
    Dim j As Long
    On Error Resume Next
    Set fd = fso.GetFolder(sFolder)

    Set fc = fd.SubFolders
    For Each fd1 In fc
        ListFolder fd1.Path, lLenRootPath, lCntFld
    Next
    lCntFld = lCntFld + 1

    Set fc = fd.Files
    j = fc.Count
    For Each f In fc
        LogTbak.WriteLine (Mid(f.Path, lLenRootPath + 2))
        i = i + 1
        Application.StatusBar = "Listando pasta(" & lCntFld & "): " & Int(i / j * 100) & "%"
    Next

    Set fc = Nothing
    ListFolder = Err.Number = 0
End Function

Function CriticarNomesDeArquivos(CpapDir As String, bSilence As Boolean) As Boolean
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| - Todos os caracteres acentuados da l|fffd|ngua portuguesa mas esses
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| n|fffd|o s|fffd|o aceitos pelo zip (Shell e Brazip). Trocar por: '|fffd|A|fffd||fffd||fffd||fffd||fffd||fffd|O|fffd|ao
'Esse cr|fffd|tica |fffd| melhor ser silenciosa, pois s|fffd| o |fffd||fffd| causam problema. S|fffd| em edi|fffd||fffd|o que vai alertar.
    Dim fso As Scripting.FileSystemObject      'Microsoft Scripting Runtime library ref
    Dim f As Scripting.File
    Dim fd As Scripting.Folder
    Dim sFile As String
    Set fso = CreateObject("Scripting.FileSystemObject")
    Dim lCntFld As Long

    If fso.FolderExists(CpapDir & "\Areceber") Then RenBySubFolder fso.GetFolder(CpapDir & "\Areceber"), lCntFld, bSilence
    If fso.FolderExists(CpapDir & "\Avulso") Then RenBySubFolder fso.GetFolder(CpapDir & "\Avulso"), lCntFld, bSilence
    If fso.FolderExists(CpapDir & "\Banco") Then RenBySubFolder fso.GetFolder(CpapDir & "\Banco"), lCntFld, bSilence
    If fso.FolderExists(CpapDir & "\Exp_plan") Then RenBySubFolder fso.GetFolder(CpapDir & "\Exp_plan"), lCntFld, bSilence
    If fso.FolderExists(CpapDir & "\Tabelas") Then RenBySubFolder fso.GetFolder(CpapDir & "\Tabelas"), lCntFld, bSilence
    CriticarNomesDeArquivos = Err.Number = 0
    Application.StatusBar = " ": Application.StatusBar = False    'No 2007 false n|fffd|o atualiza de imediato
End Function

Function RenBySubFolder(ByVal fd As Scripting.Folder, lCntFld As Long, ByVal bSilence As Boolean) As Boolean
'Recorrente para subir nos subfolders
    Dim sName As String
    Dim f As Scripting.File
    Dim fd1 As Scripting.Folder
    Dim fc    'File or folder collection
    Dim i As Long
    Dim j As Long

    Set fc = fd.SubFolders
    For Each fd1 In fc
        RenBySubFolder fd1, lCntFld, bSilence
        sName = NameGoodForZip(fd1.Name)
        If sName <> fd1.Name Then
            If Not bSilence Then If MsgBox("A subpasta: " & fd1.Name & " ser|fffd| renomeada para: " & sName, vbOKCancel, "Necess|fffd|rio para Zipar") = vbCancel Then Stop
            fd1.Name = sName
        End If
    Next
    lCntFld = lCntFld + 1

    Set fc = fd.Files
    j = fc.Count
    For Each f In fc
        sName = NameGoodForZip(f.Name)
        If sName <> f.Name Then
            If Not bSilence Then If MsgBox("O arquivo: " & f.Name & " ser|fffd| renomeado para: " & sName, vbOKCancel, "Necess|fffd|rio para Zipar") = vbCancel Then Stop
            f.Name = sName
        End If
        i = i + 1
        Application.StatusBar = "Verif. nomes pasta(" & lCntFld & "): " & Int(i / j * 100) & "%"
    Next
    Set fc = Nothing
End Function

Function NameGoodForZip(sName As String) As String
    NameGoodForZip = MyReplace(sName, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "A")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "O")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "|fffd|")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "a")
    NameGoodForZip = MyReplace(NameGoodForZip, "|fffd|", "o")
End Function

Private Function MyReplace(vText As String, vTxtFind As String, vTxtRep As String)
'Word 6.0 VBA doesn't have Replace function
    Dim lPos As Long
    lPos = 1 - Len(vTxtRep)
vStart:
    lPos = InStr(lPos + Len(vTxtRep), vText, vTxtFind)
    If lPos = 0 Or vTxtFind = "" Then
        MyReplace = vText
        Exit Function
    End If
    vText = Left(vText, lPos - 1) & vTxtRep & Right(vText, Len(vText) - lPos - Len(vTxtFind) + 1)
    GoTo vStart
End Function

Function GetShortPath(sLongName As String) As String    'Returns the short path used by programs that require the earlier 8.3 file naming convention like Arj.exe.
    Dim fso, f
    Set fso = CreateObject("Scripting.FileSystemObject")
    On Error Resume Next
    Set f = fso.GetFile(sLongName)
    If Err.Number <> 0 Then Err.Clear: Set f = fso.GetFolder(sLongName)
    If Err.Number = 0 Then GetShortPath = f.ShortPath Else GetShortPath = sLongName
End Function

Attribute VB_Name = "Mod3UnZip"
Option Explicit
Dim fso As Scripting.FileSystemObject      'Microsoft Scripting Runtime library ref

Sub TestCopyFromZipFolder()
    Dim sOrigZipPath
    Dim sDestTempPath
    Dim sDestPath
    Dim sItemFilter As String
    Dim lAttrib As Long

    'Como a c|fffd|pia direto do zip usando Shell.Application n|fffd|o d|fffd| op|fffd||fffd|o para criticar data dos
    'arquivos a copiar e substituir e nenhum filtro em arquivos dentro de sub pastas. Vamos
    'primeiro copiar do zip para uma pasta temp podendo j|fffd| fazer um filtro grosso para o
    'filtro fino e ganhar tempo.

    sOrigZipPath = "C:\CPAP-BAK2007-06-18 11-05.zip"
    sDestTempPath = MakeTempExtractZipFolder: If sDestTempPath = False Then Stop
    sItemFilter = "banco": lAttrib = 32    'Todos os arquivos de um subfolder
    'sItemFilter = "A108.mda": lAttrib = 64    'Arquivo A108.mda exato no raiz do zip
    'sItemFilter = "": lAttrib = 0   'Todos os arquivos no raiz e em qualquer subfolder

    If Not CopyFromZipFolder(sOrigZipPath, sDestTempPath, sItemFilter, lAttrib) Then Stop


    'Agora sim copia from tempfolder com filtro total de attributos e m|fffd|scara usando FileSystemObject
    'para criticar cada arquivo copiado
    Dim OrigFolder As Scripting.Folder
    Dim DestFolder As Scripting.Folder
    Dim sFolderFilter As String
    Dim sFileFilter As String
    Dim lLenRootPath As Long
    Dim RestApenasAtualiz As Boolean
    Dim AlertAoSubescrev As Boolean
    Dim lCntFld As Long

    RestApenasAtualiz = True
    AlertAoSubescrev = True
    sDestPath = "D:\Documents and Settings\Orlando Filho\Local Settings\Temp\cpap"

    sFolderFilter = ""    'Arquivo em quaquer subfolder j|fffd| extra|fffd|dos do zip
    sFolderFilter = "banco"    'Arquivo s|fffd| no raiz do subfolder banco j|fffd| extra|fffd|dos do zip
    '    sFolderFilter = "banco*"    'Arquivo no subfolder banco e seus subfolders acima j|fffd| extra|fffd|dos do zip
    '    sFolderFilter = "banco\DBFZEROS"    'Arquivo s|fffd| no raiz do subfolder DBFZEROS do subfolder banco j|fffd| extra|fffd|dos do zip
    '    sFolderFilter = "banco\DBF*"    'Arquivo em subfolder iniciado por DBF no subfolder banco j|fffd| extra|fffd|dos do zip

    sFileFilter = ""    'Todos os arquivos j|fffd| extra|fffd|dos do zip
    '    sFileFilter = "A108.mda"   'Arquivos A108.mda exato j|fffd| extra|fffd|dos do zip
    'sFileFilter = "*A108.mda"   'Arquivos terminados em A108.mda j|fffd| extra|fffd|dos do zip
    'sFileFilter = "*.mda"    'Arquivos terminados em .mda j|fffd| extra|fffd|dos do zip
    'sFileFilter = "*banco\A108.mda"    'Arquivos A108.mda em qualquer sub folder banco j|fffd| extra|fffd|dos do zip

    If Dir(sDestPath, vbDirectory) = "" Then Stop
    If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")
    Set OrigFolder = fso.GetFolder(sDestTempPath)
    Set DestFolder = fso.GetFolder(sDestPath)
    lLenRootPath = Len(sDestTempPath)
    CopyTreeFileByFile OrigFolder, DestFolder, sFolderFilter, lLenRootPath, sFileFilter, lCntFld, RestApenasAtualiz, AlertAoSubescrev

    'Aproveitando o mesmo TempExtractZipFolder pode-se fazer outras chamadas com diferentes filtros

    Set fso = Nothing
    Set OrigFolder = Nothing
    Set DestFolder = Nothing
End Sub

Function CopyFromZipFolder(sOrigZipPath As Variant, sDestPath As Variant, _
        Optional sItemFilter As String, Optional lAttrib As Long) As Boolean
'O objeto Shell.Application s|fffd| copia arquivos no raiz ou subfolder inteiros (itens) ent|fffd|o o sItemFilter
'pode ser o nome exato do subfolder, se copiando s|fffd| subfolder, ou do arquivo no raiz incluindo
'a extens|fffd|o, ou ainda, se iniciado por *, o final do arquivo no raiz incluindo a extens|fffd|o, se
'copiando s|fffd| arquivos.
    Dim ShlApp
    Dim DestFolder As Scripting.Folder
    Dim OrigItems
    Dim lDest As Long
    Dim lOrig As Long
    Dim lWaitMax As Long
    Dim lAdding As Long
    Dim lAddingAnt As Long

    On Error GoTo ErrorHandler
    If Dir(sOrigZipPath) = "" Then Stop
    If Dir(sDestPath, vbDirectory) = "" Then Stop

    Application.StatusBar = "Copiando a partir do zip " & sItemFilter & "..."

    Set ShlApp = CreateObject("Shell.Application")
    lDest = ShlApp.NameSpace(sDestPath).items.Count

    'Primeiro copia from zipfolder para uma pasta temp com filtro poss|fffd|vel de atributos e m|fffd|scara para item
    Set OrigItems = ShlApp.NameSpace(sOrigZipPath).items    'Se sOrigZipPath e sDestPath n|fffd|o forem Variant d|fffd| erro

    'Filtrar por atributo ou m|fffd|scara de nome de arquivo ou folder
    Dim i
    Select Case lAttrib
    Case SHCONTF_FOLDERS    '32 para copiar s|fffd| SubFolders
        'OrigItems.Filter SHCONTF_FOLDERS, sItemFilter N|fffd|o funciona from zipfolder
        For Each i In OrigItems
            If i.isfolder And LCase(i.Name) = LCase(sItemFilter) Then
                lOrig = 1
                ShlApp.NameSpace(sDestPath).CopyHere i    ', 4 nao atende as op|fffd||fffd|es, parece bug
                sItemFilter = "": Exit For    'Sempre copia apenas 1 subfolder e a mascara n|fffd|o serve como mascara de arquivo
            End If
        Next

    Case SHCONTF_NONFOLDERS    '64 para copiar s|fffd| arquivos, ignora SubFolders
        'OrigItems.Filter SHCONTF_NONFOLDERS, sItemFilter N|fffd|o funciona from zipfolder
        For Each i In OrigItems
            If Not i.isfolder Then
                If sItemFilter = "" _
                        Or (Left(sItemFilter, 1) = "*" And LCase(Right(sItemFilter, Len(sItemFilter) - 1)) = LCase(Right(i.Name, Len(sItemFilter) - 1))) _
                        Or (Left(sItemFilter, 1) <> "*" And LCase(sItemFilter) = LCase(Right(i.Name, Len(sItemFilter)))) Then
                    lOrig = lOrig + 1
                    ShlApp.NameSpace(sDestPath).CopyHere i    ', 4 nao atende as op|fffd||fffd|es, parece bug
                End If
            End If
        Next

    Case Else    'Sem atributo definido
        'Copiar todos os arquivos e subfolders
        lOrig = OrigItems.Count
        ShlApp.NameSpace(sDestPath).CopyHere OrigItems    ', 4 nao atende as op|fffd||fffd|es, parece bug
    End Select

    'Esperar e conferir extra|fffd||fffd|o dos itens
    Application.Interactive = False
    Do
        MyWait 1
        'lAdding = ShlApp.NameSpace(sDestPath.Path).items.Count    'Esse falha porque n|fffd|o est|fffd| contando os ocultos. |fffd| melhor usar fso
        If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")
        Set DestFolder = fso.GetFolder(sDestPath)
        lAdding = DestFolder.SubFolders.Count + DestFolder.Files.Count
        If lAdding = lAddingAnt Then lWaitMax = lWaitMax + 1 Else lWaitMax = 0
        lAddingAnt = lAdding
    Loop While lAdding < lDest + lOrig And lWaitMax < 60
    Application.Interactive = True

ErrorHandler:
    If Err.Number <> 0 Then MsgBox "Erro " & Err.Number & " (" & Err.Description & ")", vbCritical, "Falha no Procedimento CopyFromZipFolder!"
    CopyFromZipFolder = Err.Number = 0 And lWaitMax < 60
    Set OrigItems = Nothing
    Set ShlApp = Nothing
    Set DestFolder = Nothing
    Application.StatusBar = " ": Application.StatusBar = False    'No 2007 false n|fffd|o atualiza de imediato
End Function

Function CopyTreeFileByFile(ByVal OrigFolder As Scripting.Folder, ByVal DestFolder As Scripting.Folder, _
        sFolderFilter As String, lLenRootPath As Long, sFileFilter As String, lCntFld As Long, Optional RestApenasAtualiz As Boolean = True, _
        Optional AlertAoSubescrev As Boolean = True) As Boolean
'Recorrente para subir nos subfolders por isso os argumentos de folder devem ser objetos e ByVal
'pois variam ao subir. J|fffd| os outros argumentos permanecem fixos e podem ser ByRef. Sobre os filtros
'sFolderFilter e sFileFilter veja os exemplos em TestCopyFromZipFolder
    Dim sName As String
    Dim f As Scripting.File
    Dim fd As Scripting.Folder
    Dim fd1 As Scripting.Folder
    Dim fc    'File or folder collection
    Dim sFolderRelPath As String
    Dim bFolderFilter As Boolean
    Dim bFileFilter As Boolean
    Dim i As Long
    Dim j As Long

    On Error GoTo ErrorHandler
    If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")

    Set fc = OrigFolder.SubFolders
    For Each fd In fc
        sFolderRelPath = Mid(fd.Path, lLenRootPath + 2)
        If sFolderFilter = "" Then
            bFolderFilter = True
        Else
            bFolderFilter = (Right(sFolderFilter, 1) = "*" And LCase(Left(sFolderFilter, Len(sFolderFilter) - 1)) = LCase(Left(sFolderRelPath, Len(sFolderFilter) - 1))) _
                    Or (Right(sFolderFilter, 1) <> "*" And LCase(sFolderFilter) = LCase(sFolderRelPath))
        End If

        If bFolderFilter Then    'Se n|fffd|o satisfizer sFolderFilter n|fffd|o adianta subir na arvore
            If fso.FolderExists(DestFolder.Path & "\" & fd.Name) Then
                Set fd1 = DestFolder.SubFolders(fd.Name)
                If Not CopyTreeFileByFile(fd, fd1, sFolderFilter, lLenRootPath, sFileFilter, lCntFld, RestApenasAtualiz, AlertAoSubescrev) Then Exit Function
            Else
                Set fd1 = DestFolder.SubFolders.Add(fd.Name)
                If Not CopyTreeFileByFile(fd, fd1, sFolderFilter, lLenRootPath, sFileFilter, lCntFld, RestApenasAtualiz, AlertAoSubescrev) Then Exit Function
                If fd1.SubFolders.Count + fd1.Files.Count = 0 Then fd1.Delete    'Se foi criado, mas ficou vazio ent|fffd|o deleta
            End If
        End If
    Next
    lCntFld = lCntFld + 1

    Set fc = OrigFolder.Files
    j = fc.Count
    For Each f In fc
        sFolderRelPath = Mid(f.Path, lLenRootPath + 2)
        If Len(sFolderRelPath) = Len(f.Name) Then sFolderRelPath = "" Else sFolderRelPath = Left(sFolderRelPath, Len(sFolderRelPath) - Len(f.Name) - 1)
        If sFolderFilter = "" Then
            bFolderFilter = True
        Else
            bFolderFilter = (Right(sFolderFilter, 1) = "*" And LCase(Left(sFolderFilter, Len(sFolderFilter) - 1)) = LCase(Left(sFolderRelPath, Len(sFolderFilter) - 1))) _
                    Or (Right(sFolderFilter, 1) <> "*" And LCase(sFolderFilter) = LCase(sFolderRelPath))
        End If

        If sFileFilter = "" Then
            bFileFilter = True
        Else
            bFileFilter = (Left(sFileFilter, 1) = "*" And LCase(Right(sFileFilter, Len(sFileFilter) - 1)) = LCase(Right(f.Path, Len(sFileFilter) - 1))) _
                    Or (Left(sFileFilter, 1) <> "*" And LCase(sFileFilter) = LCase(Right(f.Name, Len(sFileFilter))))
        End If

        If bFolderFilter And bFileFilter Then    'Tem que satisfazer sFolderFilter e sFileFilter
            If Not RestApenasAtualiz Or Not fso.FileExists(DestFolder.Path & "\" & f.Name) Then
                f.Copy DestFolder.Path & "\", True
            Else
                Dim f1 As Scripting.File
                Set f1 = fso.GetFile(DestFolder.Path & "\" & f.Name)
                If f.DateLastModified > f1.DateLastModified Then
                    If Not AlertAoSubescrev Then
                        f.Copy DestFolder.Path & "\", True
                    Else
                        If MsgBox("A pasta '" & DestFolder.Name & "' j|fffd| cont|fffd|m o arquivo de nome '" & f.Name & "'." & Chr(10) & Chr(10) & _
                                "Voc|fffd| gostaria de substituir o arquivo existente" & Chr(10) & _
                                "      Tamanho: " & Round(f1.Size / 1000, 2) & " KB" & Chr(10) & _
                                "      Modificado: " & f1.DateLastModified & Chr(10) & _
                                "por este arquivo do backup?" & Chr(10) & _
                                "      Tamanho: " & Round(f.Size / 1000, 2) & " KB" & Chr(10) & _
                                "      Modificado: " & f.DateLastModified, vbYesNo + vbCritical, "Confirmar Substitui|fffd||fffd|o de Arquivo") = vbYes Then _
                                f.Copy DestFolder.Path & "\", True
                    End If
                End If
            End If
        End If
        i = i + 1
        Application.StatusBar = "Copiando pasta(" & lCntFld & "): " & Int(i / j * 100) & "%"
    Next

ErrorHandler:
    If Err.Number <> 0 Then MsgBox "Erro " & Err.Number & " (" & Err.Description & ")", vbCritical, "Falha no Procedimento CopyTreeFileByFile!"
    CopyTreeFileByFile = Err.Number = 0
    Set fd1 = Nothing
    Set f1 = Nothing
    Set fc = Nothing
End Function

Sub TestGetFileName()
    MsgBox GetFileName
End Sub

Function GetFileName()
    Dim FileToOpen
ReGet:
    If 2 = 2 Then
        GetFileName = GetFileNameAPI
    Else
        'GetFileName = Application.GetOpenFilename("Zip (*.zip), *.zip,Arj (*.arj), *.arj", 1, "Arquivo de Backup do CPAP", , False)
        GetFileName = Application.GetOpenFilename("Formato Atual (*.zip),*.zip,Formato Antigo (*.arj),*.arj,Todos Arquivos (*.*),*.*", 1, "Arquivo de Backup do CPAP", , False)
    End If
    
    If GetFileName <> False Then
        If LCase(Left(Dir(GetFileName), Len("CPAP-BAK"))) <> LCase("CPAP-BAK") Then
            MsgBox Dir(GetFileName) & " n|fffd|o parece ser um arquivo de bakcup do CPAP que por padr|fffd|o sempre inicia por 'Cpap-bak'!" & Chr(10) & Chr(10) & "Tente outro.", vbCritical + vbOKOnly, "CPAP - Nome de Arquivo Desconhecido"
            GoTo ReGet
        End If
    End If
End Function

Function GetFileNameAPI()
    Dim sFile As String
    Dim sFileFilter As String
    bUseHook = True
    hWndForm = Application.hWnd    'hWnd
    sFileFilter = "Formato Atual (*.zip)" & vbNullChar & "*.zip" & vbNullChar & "Formato Antigo (*.arj)" & vbNullChar & "*.arj" & vbNullChar & "Todos Arquivos (*.*)" & vbNullChar & "*.*" & vbNullChar & vbNullChar

    On Error GoTo ErrHandler
    sFile = GetOpenFilenameAPI(sFileFilter, 1, "Arquivo de Backup do CPAP")
    If LenB(sFile) > 0 Then GetFileNameAPI = sFile Else GetFileNameAPI = False
    Exit Function
ErrHandler:
    GetFileNameAPI = False
End Function


Function MakeTempExtractZipFolder()
'Monta um folder novo, excluindo se j|fffd| existir, para abrir o zip nele
    Dim DirTemp As Scripting.Folder
    Dim TempExtractZipFolder As Scripting.Folder
    On Error GoTo ErrorHandler
    If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")
    Set DirTemp = fso.GetSpecialFolder(TemporaryFolder)

    On Error Resume Next    'Se listar para restaura|fffd||fffd|o, cancelar e restaurar normal n|fffd|o conseque deletar TempExtractZipFolder mas deixa limpa. Ent|fffd|o ok ignorar erro e continuar
    If fso.FolderExists(DirTemp.Path & "\TempExtractZipFolder") Then DirTemp.SubFolders("TempExtractZipFolder").Delete
    MyWait 0.2

    On Error GoTo ErrorHandler
    If fso.FolderExists(DirTemp.Path & "\TempExtractZipFolder") Then
        Set TempExtractZipFolder = DirTemp.SubFolders("TempExtractZipFolder")
    Else
        Set TempExtractZipFolder = DirTemp.SubFolders.Add("TempExtractZipFolder")
    End If

    MakeTempExtractZipFolder = TempExtractZipFolder.Path
ErrorHandler:
    If Err.Number <> 0 Then MakeTempExtractZipFolder = False
    Set DirTemp = Nothing
    Set TempExtractZipFolder = Nothing
End Function

Function ExcluiArquivDesnec(sDestTempPath As String, bRestaurando As Boolean) As Boolean
    Dim s    'Deve ser variant para o each in Array
    Dim tf As String
    Dim f As Scripting.File
    Dim fd As Scripting.Folder
    Dim fc    'File or folder collection

    On Error Resume Next
    If bRestaurando Then
        'N|fffd|o tem sentido restaurar o mem.mac aqui, pois se o cpap est|fffd| funcionando |fffd| porque
        'o orig t|fffd| ok. E os de |fffd|ndice de qualquer maneira ser|fffd|o recriados
        tf = sDestTempPath & "\banco\cpap-mem.mac": If Dir(tf) <> "" Then Kill tf
        tf = sDestTempPath & "\banco\INDICE.*": If Dir(tf) <> "" Then Kill tf
    End If

    For Each s In Array("\areceber", "\avulso", "\banco", "\exp_plan", "\tabelas")
        tf = sDestTempPath & s & "\*.bak": If Dir(tf) <> "" Then Kill tf
        tf = sDestTempPath & s & "\*.xlk": If Dir(tf) <> "" Then Kill tf
        tf = sDestTempPath & s & "\*.wbk": If Dir(tf) <> "" Then Kill tf
        tf = sDestTempPath & s & "\*.exe": If Dir(tf) <> "" Then Kill tf
        tf = sDestTempPath & s & "\*.com": If Dir(tf) <> "" Then Kill tf
        tf = sDestTempPath & s & "\*.bat": If Dir(tf) <> "" Then Kill tf
        tf = sDestTempPath & s & "\*.vbs": If Dir(tf) <> "" Then Kill tf

        'Excluir arquivos vazios e os sem extens|fffd|o definida
        If Dir(sDestTempPath & s, vbDirectory) <> "" Then
            If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")
            Set fd = fso.GetFolder(sDestTempPath & s)
            Set fc = fd.Files
            For Each f In fc
                If f.Size = 0 Then f.Delete True
                If InStr(1, f.Name, ".") = 0 Then f.Delete True
            Next
        End If
    Next
    Set fso = Nothing
    Set f = Nothing
    Set fd = Nothing
    Set fc = Nothing
    ExcluiArquivDesnec = True
End Function

Function TransfArquivFromTemp(sTempPath As String, sDestPath As String, ByVal sFolderFilter As String, _
        ByVal sFileFilter As String, Optional ByVal RestApenasAtualiz As Boolean = True, _
        Optional ByVal AlertAoSubescrev As Boolean = True) As Boolean

    Dim OrigFolder As Scripting.Folder
    Dim DestFolder As Scripting.Folder
    Dim lLenRootPath As Long
    Dim lCntFld As Long

    If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")

    If Dir(sDestPath, vbDirectory) = "" Then Stop
    Set OrigFolder = fso.GetFolder(sTempPath)
    Set DestFolder = fso.GetFolder(sDestPath)
    lLenRootPath = Len(sTempPath)
    TransfArquivFromTemp = CopyTreeFileByFile(OrigFolder, DestFolder, sFolderFilter, lLenRootPath, sFileFilter, lCntFld, RestApenasAtualiz, AlertAoSubescrev)
    Set fso = Nothing
    Set OrigFolder = Nothing
    Set DestFolder = Nothing
    Application.StatusBar = " ": Application.StatusBar = False    'No 2007 false n|fffd|o atualiza de imediato
End Function

Function LimparTempDir() As Boolean
'Durante a listagem para backup ou restaura|fffd||fffd|o s|fffd|o criadas subpastas em temp que n|fffd|o s|fffd|o
'apagadas automaticamente pelo sistema. Esse limpa tudo supondo que tudo que tiver CPAP-BAK
'foi criado por um zip do cpap.
    Dim DirTemp As Scripting.Folder
    Dim sbf As Scripting.Folder
    Dim fc    'File or folder collection

    On Error Resume Next
    If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")
    Set DirTemp = fso.GetSpecialFolder(TemporaryFolder)
    If fso.FolderExists(DirTemp.Path & "\TempExtractZipFolder") Then DirTemp.SubFolders("TempExtractZipFolder").Delete True
    Set fc = DirTemp.SubFolders
    For Each sbf In fc
        If InStr(1, UCase(sbf.Name), "CPAP-BAK") > 0 Then sbf.Delete True
    Next
    Set fc = Nothing
End Function
Attribute VB_Name = "Mod9GetFileNameAPI"
Option Explicit
' demo project showing how to call the GetSaveFileName and GetOpenFileName API functions
' by Bryan Stafford of New Vision Software|fffd| - newvision@mvps.org (Save_And_Open_File_Dialog_Demo.zip)
' this demo is released into the public domain "as is" without
' warranty or guaranty of any kind.  In other words, use at
' your own risk.


' this demo also shows how the view type for the file list can be set before the
' dialog is shown by sending the undocumented windows messages discovered by Brad Martinez
' (http://www.mvps.org/btmtz/index.html).  THANKS Brad!  you can find more information
' in Brad's listview demo on his site.

'***********************************************************************
' MESSAGES PROVIDED BY Brad Martinez
' view menu command IDs fall within the FCIDM_SHVIEWFIRST/LAST
' range defined in ShlObj.h:
Private Const FCIDM_SHVIEW_LARGEICON As Long = &H7029&     ' 28713
Private Const FCIDM_SHVIEW_SMALLICON As Long = &H702A&     ' 28714
Private Const FCIDM_SHVIEW_LIST As Long = &H702B&          ' 28715
Private Const FCIDM_SHVIEW_REPORT As Long = &H702C&        ' 28716
Private Const FCIDM_SHVIEW_THUMBNAIL As Long = &H702D&     ' 28717
Private Const FCIDM_SHVIEW_TILE As Long = &H702E&          ' 28718
'***********************************************************************

Private Const WM_COMMAND As Long = &H111&

Private Enum OPENFILENAME_FLAGS
    OFN_ALLOWMULTISELECT = &H200
    OFN_CREATEPROMPT = &H2000
    OFN_ENABLEHOOK = &H20
    OFN_ENABLETEMPLATE = &H40
    OFN_ENABLETEMPLATEHANDLE = &H80
    OFN_EXTENSIONDIFFERENT = &H400&
    OFN_FILEMUSTEXIST = &H1000
    OFN_HIDEREADONLY = &H4&
    OFN_NOCHANGEDIR = &H8&
    OFN_NOLONGNAMES = &H40000
    OFN_NONETWORKBUTTON = &H20000
    OFN_NOREADONLYRETURN = &H8000
    OFN_NOTESTFILECREATE = &H10000
    OFN_NOVALIDATE = &H100
    OFN_OVERWRITEPROMPT = &H2&
    OFN_PATHMUSTEXIST = &H800
    OFN_READONLY = &H1
    OFN_SHAREAWARE = &H4000
    OFN_SHAREFALLTHROUGH = 2
    OFN_SHAREWARN = 0
    OFN_SHARENOWARN = 1
    OFN_SHOWHELP = &H10
    OFS_MAXPATHNAME = 128

    ' #if /* WINVER >= 0x0400 */
    OFN_EXPLORER = &H80000                                 '// new look commdlg
    OFN_NODEREFERENCELINKS = &H100000
    OFN_LONGNAMES = &H200000                               '// force long names for 3.x modules
    OFN_ENABLEINCLUDENOTIFY = &H400000                     '// send include message to callback
    OFN_ENABLESIZING = &H800000                            '// enables the sizing for the dialog
    ' #endif /* WINVER >= 0x0400 */

    '#if (_WIN32_WINNT >= 0x0500)
    'OFN_USESHELLITEM = &H1000000               '// disabling support for IShellItem for now (see comdlg32\commdlg.h)
    OFN_DONTADDTORECENT = &H2000000
    OFN_FORCESHOWHIDDEN = &H10000000                       '// Show All files including System and hidden files
    '#endif // (_WIN32_WINNT >= 0x0500)

    '//FlagsEx Values
    '#if (_WIN32_WINNT >= 0x0500)
    OFN_EX_NOPLACESBAR = &H1
    '#endif // (_WIN32_WINNT >= 0x0500)

End Enum

  Private Type OPENFILENAME
'Para detalhes sobre essa estrutua ver: http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/commondialogboxlibrary/commondialogboxreference/commondialogboxstructures/openfilename.asp?frame=true
    lStructSize As Long
    hWndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    Flags As OPENFILENAME_FLAGS
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String

    ' new members of this struct added in version 5 of the shell
    ' we can still use this struct with older versions of the shell
    ' because we pass the size of the struct expected by the function
    pvReserved As Long
    dwReserved As Long
    FlagsEx As Long
End Type

Private Declare Function GetSaveFileName Lib "comdlg32" Alias "GetSaveFileNameA" (lpOpenfilename As OPENFILENAME) As Long
Private Declare Function GetOpenFilename Lib "comdlg32" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long

Private Declare Function CommDlgExtendedError Lib "comdlg32" () As Long

Private Type NMHDR
    hwndFrom As Long
    idfrom As Long
    code As Long
End Type


' messages used in the hook proc
Private Const WM_NOTIFY As Long = &H4E&

Private Const CDN_FIRST As Long = (0& - 601&)
Private Const CDN_LAST As Long = (0& - 699&)

' Notifications when Open or Save dialog status changes
Private Const CDN_INITDONE As Long = (CDN_FIRST - &H0&)
Private Const CDN_SELCHANGE As Long = (CDN_FIRST - &H1&)
Private Const CDN_FOLDERCHANGE As Long = (CDN_FIRST - &H2&)
Private Const CDN_SHAREVIOLATION As Long = (CDN_FIRST - &H3&)
Private Const CDN_HELP As Long = (CDN_FIRST - &H4&)
Private Const CDN_FILEOK As Long = (CDN_FIRST - &H5&)
Private Const CDN_TYPECHANGE As Long = (CDN_FIRST - &H6&)
Private Const CDN_INCLUDEITEM As Long = (CDN_FIRST - &H7&)

Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWndParent&, ByVal hWndChildAfter&, ByVal lpClassName$, ByVal lpWindowName$) As Long

Private Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc&, ByVal hWnd&, ByVal Msg&, ByVal wParam&, ByVal lParam&) As Long


Private Declare Function GetFileVersionInfoSize Lib "Version.dll" Alias "GetFileVersionInfoSizeA" (ByVal lptstrFilename$, lpdwHandle&) As Long
Private Declare Function GetFileVersionInfo Lib "Version.dll" Alias "GetFileVersionInfoA" (ByVal lptstrFilename$, ByVal dwHandle&, ByVal dwLen&, lpData As Any) As Long
Private Declare Function VerQueryValue Lib "Version.dll" Alias "VerQueryValueA" (pBlock As Any, ByVal lpSubBlock As String, lplpBuffer As Any, puLen As Long) As Long


Private Const WM_SETREDRAW As Long = &HB&
Private Const WM_GETMINMAXINFO As Long = &H24&
Private Const WM_WINDOWPOSCHANGING As Long = &H46&


Private Const WM_RBUTTONUP As Long = &H205&

Private Const MK_RBUTTON As Long = &H2&

Private Const GWL_WNDPROC As Long = (-4&)

Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (lpDest As Any, lpSource As Any, ByVal cBytes As Long)

Private Declare Function GetDesktopWindow Lib "user32" () As Long

Private Declare Function GetParent Lib "user32" (ByVal hWnd&) As Long

Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd&, ByVal wMsg&, wParam As Any, lParam As Any) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hWnd&, ByVal wMsg&, wParam As Any, lParam As Any) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd&, ByVal nIndex&, ByVal dwNewLong&) As Long

Private Declare Function SetCurrentDirectory Lib "kernel32" Alias "SetCurrentDirectoryA" (ByVal lpPathName As String) As Long
Public bUseHook As Boolean
Public hWndForm As Long

Public Function DialogHookProc(ByVal hDlg&, ByVal nMsg&, ByVal wParam&, ByVal lParam&) As Long
' this is the dialog hook proc.  it is called by the dialog to inform us when certian
' actions occur.

' the hDlg param in a hook proc is the handle of a sub dialog created to contain any
' controls that we might want to add to the parent dialog.  to get the actual handle
' to the dialog itself, we need to use the GetParent function.

    Dim hLV&, lpNMHDR As NMHDR

    Select Case nMsg
        ' the WM_NOTIFY message with a code of CDN_FOLDERCHANGE is sent when the
        ' folder view is changing before the dialog is displayed.
    Case WM_NOTIFY
        CopyMemory lpNMHDR, ByVal lParam, Len(lpNMHDR)

        Select Case lpNMHDR.code
            '*******************************************************************************
            ' code that calles the undocumemted messages for changing the listview's view
            ' Thanks go to Brad Martinez for discovering these messages
        Case CDN_FOLDERCHANGE
            hLV = FindWindowEx(GetParent(hDlg), 0, "SHELLDLL_DefView", vbNullString)

            If hLV Then
                Call SendMessage(hLV, WM_COMMAND, ByVal FCIDM_SHVIEW_REPORT, ByVal 0&)
            End If
            '*******************************************************************************

        End Select

    End Select

End Function

Private Function ReturnProcAddress(ByVal lpProc&) As Long
' helper function to return the address of the hook proc
    ReturnProcAddress = lpProc
End Function

Private Function Is2KShell() As Boolean
' this function returns the version of the Comdlg32.dll on the system
' this info is used to determine which version of the OPENFILENAME struct
' should be passed to the dialog functions

    Dim nBuffSize&, nDiscard&, lpBuffer&, nVerMajor&, abytBuffer() As Byte

    Const FILE_NAME As String = "Comdlg32.dll"

    nBuffSize = GetFileVersionInfoSize(FILE_NAME, nDiscard)

    If nBuffSize > 0 Then
        ReDim abytBuffer(nBuffSize - 1) As Byte

        Call GetFileVersionInfo(FILE_NAME, 0&, nBuffSize, abytBuffer(0))

        If VerQueryValue(abytBuffer(0), "\", lpBuffer, nDiscard) Then
            CopyMemory nVerMajor, ByVal lpBuffer + 10, 2&

            If nVerMajor >= 5 Then Is2KShell = True
        End If
    End If

End Function

'======================
' demo project showing how to call the GetSaveFileName and GetOpenFileName API functions
' by Bryan Stafford of New Vision Software|fffd| - newvision@mvps.org
' this demo is released into the public domain "as is" without
' warranty or guaranty of any kind.  In other words, use at
' your own risk.

' this demo also shows how the view type for the file list can be set before the
' dialog is shown by sending the undocumented windows messages discovered by Brad Martinez
' (http://www.mvps.org/btmtz/index.html).  THANKS Brad!  you can find more information
' in Brad's listview demo on his site.

 Public Function GetSaveAsFilenameAPI(sInitialFilename As String, sFileFilter As String, lFilterIndex As Long) As String

    Dim lpOFN As OPENFILENAME, sTemp$, nStrEnd&, sInitialDir$

    sInitialDir = CurDir

    ' initialize the struct params
    With lpOFN
        .lStructSize = Len(lpOFN)

        ' if the 2K version of the common dialog dll is not present, subtract the byte count for the
        ' last three members of the struct
        If Is2KShell() = False Then .lStructSize = .lStructSize - 12

        .hWndOwner = hWndForm

        ' tell it we want a "doc" extension.  filter strings are explained in
        ' the OPENFILENAME documentation in the MSDN
        .lpstrFilter = sFileFilter
        .nFilterIndex = lFilterIndex
        .lpstrFile = sInitialFilename & String$(700, 0)
        .nMaxFile = 700
        .lpstrFileTitle = String$(260, 0)
        .nMaxFileTitle = 260
        .lpstrInitialDir = sInitialDir
        '.lpstrTitle = sTitle
        .Flags = OFN_EXTENSIONDIFFERENT Or OFN_NOCHANGEDIR Or OFN_OVERWRITEPROMPT Or _
                OFN_HIDEREADONLY Or OFN_EXPLORER Or OFN_ENABLESIZING Or OFN_FORCESHOWHIDDEN
        .lpstrDefExt = "doc"

        ' if the "Change File View" checkbox is checked, enable the hook proc and change
        ' the view before the dialog is displayed
        If bUseHook Then
            .Flags = .Flags Or OFN_ENABLEHOOK
            .lpfnHook = ReturnProcAddress(AddressOf Mod9GetFileNameAPI.DialogHookProc)
        End If
    End With

    If GetSaveFileName(lpOFN) Then
        sTemp = lpOFN.lpstrFile
        nStrEnd = InStr(sTemp, vbNullChar)
        If nStrEnd > 1 Then
            GetSaveAsFilenameAPI = Left$(sTemp, nStrEnd - 1)
            SetCurrentDirectory Left(GetSaveAsFilenameAPI, Len(GetSaveAsFilenameAPI) - Len(Dir(GetSaveAsFilenameAPI)))
        Else
            GetSaveAsFilenameAPI = vbNullString
        End If
    Else
        GetSaveAsFilenameAPI = vbNullString
    End If

End Function

 Public Function GetOpenFilenameAPI(sFileFilter As String, lFilterIndex As Long, sTitle As String) As String

    Dim lpOFN As OPENFILENAME, sTemp$, nStrEnd&, sInitialDir$

    sInitialDir = CurDir

    ' initialize the struct params
    With lpOFN
        .lStructSize = Len(lpOFN)

        ' if the 2K version of the common dialog dll is not present, subtract the byte count for the
        ' last three members of the struct
        If Is2KShell() = False Then .lStructSize = .lStructSize - 12

        .hWndOwner = hWndForm

        ' tell it we want to display all files.  filter strings are explained in
        ' the OPENFILENAME documentation in the MSDN
        .lpstrFilter = sFileFilter
        .nFilterIndex = lFilterIndex
        .lpstrFile = String$(700, 0)
        .nMaxFile = 700
        .lpstrFileTitle = String$(260, 0)
        .nMaxFileTitle = 260
        .lpstrInitialDir = sInitialDir
        .lpstrTitle = sTitle
        .Flags = OFN_EXTENSIONDIFFERENT Or OFN_NOCHANGEDIR Or OFN_OVERWRITEPROMPT Or _
                OFN_HIDEREADONLY Or OFN_EXPLORER Or OFN_ENABLESIZING Or OFN_FORCESHOWHIDDEN

        ' if the "Change File View" checkbox is checked, enable the hook proc and change
        ' the view before the dialog is displayed
        If bUseHook Then
            .Flags = .Flags Or OFN_ENABLEHOOK
            .lpfnHook = ReturnProcAddress(AddressOf Mod9GetFileNameAPI.DialogHookProc)
        End If
    End With

    If GetOpenFilename(lpOFN) Then
        sTemp = lpOFN.lpstrFile
        nStrEnd = InStr(sTemp, vbNullChar)
        If nStrEnd > 1 Then
            GetOpenFilenameAPI = Left$(sTemp, nStrEnd - 1)
            '            If Mid(GetOpenFilenameAPI, 2, 1) = ":" Then ChDrive GetOpenFilenameAPI
            '            ChDir Left(GetOpenFilenameAPI, Len(GetOpenFilenameAPI) - Len(Dir(GetOpenFilenameAPI)))
            SetCurrentDirectory Left(GetOpenFilenameAPI, Len(GetOpenFilenameAPI) - Len(Dir(GetOpenFilenameAPI)))
        Else
            GetOpenFilenameAPI = vbNullString
        End If
    Else
        GetOpenFilenameAPI = vbNullString
    End If

End Function
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True



Attribute VB_Name = "basAddrOf"
Option Explicit

'NOTE: The brilliant AddrOf function herein contained is the work of Ken Getz and
'Michael Kaplan.  Published in the May 1998 issue of
'Microsoft Office & Visual Basic for Applications Developer (page 46).

'Office 97 does not support the "AddressOf" operator which is needed to tell Windows
'where our "call back" function is.  Getz and Kaplan figured out a workaround.

'The rest of this module is entirely their work.

'-------------------------------------------------------------------------------------------------------------------
'   Declarations
'
'   These function names were puzzled out by using DUMPBIN /exports
'   with VBA332.DLL and then puzzling out parameter names and types
'   through a lot of trial and error and over 100 IPFs in MSACCESS.EXE
'   and VBA332.DLL.
'
'   These parameters may not be named properly but seem to be correct in
'   light of the function names and what each parameter does.
'
'   EbGetExecutingProj: Gives you a handle to the current VBA project
'   TipGetFunctionId: Gives you a function ID given a function name
'   TipGetLpfnOfFunctionId: Gives you a pointer a function given its function ID
'
'-------------------------------------------------------------------------------------------------------------------
Private Declare Function GetCurrentVbaProject _
        Lib "vba332.dll" Alias "EbGetExecutingProj" _
        (hProject As Long) As Long
Private Declare Function GetFuncID _
        Lib "vba332.dll" Alias "TipGetFunctionId" _
        (ByVal hProject As Long, ByVal strFunctionName As String, _
        ByRef strFunctionId As String) As Long
Private Declare Function GetAddr _
        Lib "vba332.dll" Alias "TipGetLpfnOfFunctionId" _
        (ByVal hProject As Long, ByVal strFunctionId As String, _
        ByRef lpfn As Long) As Long

'-------------------------------------------------------------------------------------------------------------------
'   AddrOf
'
'   Returns a function pointer of a VBA public function given its name. This function
'   gives similar functionality to VBA as VB5 has with the AddressOf param type.
'
'   NOTE: This function only seems to work if the proc you are trying to get a pointer
'       to is in the current project. This makes sense, since we are using a function
'       named EbGetExecutingProj.
'-------------------------------------------------------------------------------------------------------------------
Public Function AddrOf(strFuncName As String) As Long
    Dim hProject As Long
    Dim lngResult As Long
    Dim strID As String
    Dim lpfn As Long
    Dim strFuncNameUnicode As String

    Const NO_ERROR = 0

    ' The function name must be in Unicode, so convert it.
    strFuncNameUnicode = StrConv(strFuncName, vbUnicode)

    ' Get the current VBA project
    ' The results of GetCurrentVBAProject seemed inconsistent, in our tests,
    ' so now we just check the project handle when the function returns.
    Call GetCurrentVbaProject(hProject)

    ' Make sure we got a project handle... we always should, but you never know!
    If hProject <> 0 Then
        ' Get the VBA function ID (whatever that is!)
        lngResult = GetFuncID( _
                hProject, strFuncNameUnicode, strID)

        ' We have to check this because we GPF if we try to get a function pointer
        ' of a non-existent function.
        If lngResult = NO_ERROR Then
            ' Get the function pointer.
            lngResult = GetAddr(hProject, strID, lpfn)

            If lngResult = NO_ERROR Then
                AddrOf = lpfn
            End If
        End If
    End If
End Function
Attribute VB_Name = "mBrowseDeclares"
Option Explicit

Public Type BROWSEINFO
    hOwner As Long                 'Handle to the owner window for the dialog box.

    pidlRoot As Long                'Address of an ITEMIDLIST structure specifying the location
    'of the root folder from which to browse. Only the specified
    'folder and its subfolders appear in the dialog box.
    'This member can be NULL; in that case, the namespace
    'root (the desktop folder) is used.

    pszDisplayName As String    'Address of a buffer to receive the display name of the folder
    'selected by the user. The size of this buffer is assumed to
    'be MAX_PATH bytes.

    lpszTitle As String                 'Address of a null-terminated string that is displayed above
    'the tree view control in the dialog box.  This string can be
    'used to specify instructions to the user.

    ulFlags As Long                    'Flags specifying the options for the dialog box.
    'See constants below

    lpfn As Long                        'Address of an application-defined function that the dialog box calls
    'when an event occurs. For more information, see the
    'BrowseCallbackProc function. This member can be NULL.

    lParam As Long                  'Application-defined value that the dialog box passes to the
    'callback function (in pData), if one is specified

    iImage As Long                  'Variable to receive the image associated with the selected folder.
    'The image is specified as an index to the system image list.
End Type

Public Const WM_USER = &H400
Public Const MAX_PATH = 260

'ulFlag constants
Public Const BIF_RETURNONLYFSDIRS = &H1      'Only return file system directories.
'If the user selects folders that are not
'part of the file system, the OK button is grayed.

Public Const BIF_DONTGOBELOWDOMAIN = &H2  'Do not include network folders below the
'domain level in the tree view control

Public Const BIF_STATUSTEXT = &H4                    'Include a status area in the dialog box.
'The callback function can set the status text
'by sending messages to the dialog box.

Public Const BIF_RETURNFSANCESTORS = &H8      'Only return file system ancestors. If the user selects
'anything other than a file system ancestor, the OK button is grayed

Public Const BIF_EDITBOX = &H10                        'Version 4.71. The browse dialog includes an edit control
'in which the user can type the name of an item.

Public Const BIF_VALIDATE = &H20                       'Version 4.71. If the user types an invalid name into the
'edit box, the browse dialog will call the application's
'BrowseCallbackProc with the BFFM_VALIDATEFAILED
' message. This flag is ignored if BIF_EDITBOX is not specified

Public Const BIF_NEWDIALOGSTYLE = &H40      'Version 5.0. New dialog style with context menu and resizability

Public Const BIF_BROWSEINCLUDEURLS = &H80   'Version 5.0. Allow URLs to be displayed or entered. Requires BIF_USENEWUI.

Public Const BIF_BROWSEFORCOMPUTER = &H1000   'Only return computers. If the user selects anything
'other than a computer, the OK button is grayed

Public Const BIF_BROWSEFORPRINTER = &H2000    'Only return printers. If the user selects anything
'other than a printer, the OK button is grayed.

Public Const BIF_BROWSEINCLUDEFILES = &H4000   'The browse dialog will display files as well as folders

Public Const BIF_SHAREABLE = &H8000   'Version 5.0.  Allow display of remote shareable resources.  Requires BIF_USENEWUI.

'Message from browser to callback function constants

Public Const BFFM_INITIALIZED = 1   'Indicates the browse dialog box has finished initializing.
'The lParam parameter is NULL.

Public Const BFFM_SELCHANGED = 2    'Indicates the selection has changed. The lParam parameter
'contains the address of the item identifier list for the newly selected folder.

Public Const BFFM_VALIDATEFAILED = 3  'Version 4.71. Indicates the user typed an invalid name into the edit
'box of the browse dialog. The lParam parameter is the address of
'a character buffer that contains the invalid name.
'An application can use this message to inform the user that the
'name entered was not valid. Return zero to allow the dialog to be
'dismissed or nonzero to keep the dialog displayed.

' messages to browser from callback function
Public Const BFFM_SETSTATUSTEXTA = WM_USER + 100
Public Const BFFM_ENABLEOK = WM_USER + 101
Public Const BFFM_SETSELECTIONA = WM_USER + 102
Public Const BFFM_SETSELECTIONW = WM_USER + 103
Public Const BFFM_SETSTATUSTEXTW = WM_USER + 104

Public Const LMEM_FIXED = &H0
Public Const LMEM_ZEROINIT = &H40
Public Const LPTR = (LMEM_FIXED Or LMEM_ZEROINIT)

'Main Browse for directory function
Declare Function SHBrowseForFolder Lib "shell32.dll" _
        Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
'Gets path from pidl
Declare Function SHGetPathFromIDList Lib "shell32.dll" _
        Alias "SHGetPathFromIDListA" (ByVal pidl As Long, ByVal pszPath As String) As Long
'Used by callback function to communicate with the browser
Declare Function SendMessage Lib "user32" _
        Alias "SendMessageA" (ByVal hWnd As Long, _
        ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Any) As Long

Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, _
        hpvSource As Any, ByVal cbCopy As Long)

Public Declare Sub CoTaskMemFree Lib "ole32.dll" (ByVal pv As Long)

Public Declare Function LocalAlloc Lib "kernel32" _
        (ByVal uFlags As Long, _
        ByVal uBytes As Long) As Long

Public Declare Function LocalFree Lib "kernel32" _
        (ByVal hMem As Long) As Long


''The following declarations for the option to center the dialog in the user's screen
Public Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long

Public Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long

Public Const SM_CXFULLSCREEN = 16
Public Const SM_CYFULLSCREEN = 17

Public Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type

Public Declare Function MoveWindow Lib "user32" (ByVal hWnd As Long, _
        ByVal x As Long, _
        ByVal y As Long, _
        ByVal nWidth As Long, _
        ByVal nHeight As Long, ByVal bRepaint As Long) As Long
''End of dialog centering declarations


Attribute VB_Name = "mBrowseMain"
'Demonstration of the Windows Shell Browse for Folder function
'for Excel 97 and Excel 2000.  (Revision 1)
'By Jim Rech (jarech@kpmg.com)

Option Explicit
Dim CntrDialog As Boolean

Function GetDirectory(InitDir As String, Flags As Long, CntrDlg As Boolean, Msg) As String
Attribute GetDirectory.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim bInfo As BROWSEINFO
    Dim pidl As Long, lpInitDir As Long

    CntrDialog = CntrDlg   ''Copy dialog centering setting to module level variable so callback function can see it
    With bInfo
        .pidlRoot = 0   'Root folder = Desktop
        .lpszTitle = Msg
        .ulFlags = Flags

        lpInitDir = LocalAlloc(LPTR, Len(InitDir) + 1)
        CopyMemory ByVal lpInitDir, ByVal InitDir, Len(InitDir) + 1
        .lParam = lpInitDir

        If Val(Application.Version) > 8 Then   'Establish the callback function
            .lpfn = BrowseCallBackFuncAddress
        Else
            .lpfn = AddrOf("BrowseCallBackFunc")
        End If
    End With
    'Display the dialog
    pidl = SHBrowseForFolder(bInfo)
    'Get path string from pidl
    GetDirectory = GetPathFromID(pidl)
    CoTaskMemFree pidl
    LocalFree lpInitDir
End Function

'Windows calls this function when the dialog events occur
Function BrowseCallBackFunc(ByVal hWnd As Long, ByVal Msg As Long, ByVal lParam As Long, ByVal pData As Long) As Long
    Select Case Msg
    Case BFFM_INITIALIZED
        'Dialog is being initialized. I use this to set the initial directory and to center the dialog if the requested
        SendMessage hWnd, BFFM_SETSELECTIONA, 1, pData   'Send message to dialog
        If CntrDialog Then CenterDialog hWnd
    Case BFFM_SELCHANGED
        'User selected a folder - change status text ("show status text" option must be set to see this)
        SendMessage hWnd, BFFM_SETSTATUSTEXTA, 0, GetPathFromID(lParam)
    Case BFFM_VALIDATEFAILED
        'This message is sent  to the callback function only if "Allow direct entry" and
        '"Validate direct entry" have been be set on the Demo worksheet
        'and the user's direct entry is not valid.
        '"Show status text" must be set on to see error message we send back to the dialog
        Beep
        SendMessage hWnd, BFFM_SETSTATUSTEXTA, 0, "Bad Directory"
        BrowseCallBackFunc = 1   'Block dialog closing
        Exit Function
    End Select
    BrowseCallBackFunc = 0   'Allow dialog to close
End Function

'Converts a PIDL to a string
Function GetPathFromID(ID As Long) As String
    Dim Result As Boolean, Path As String * MAX_PATH
    Result = SHGetPathFromIDList(ID, Path)
    If Result Then
        GetPathFromID = Left(Path, InStr(Path, Chr$(0)) - 1)
    Else
        GetPathFromID = ""
    End If
End Function

'XL8 is very unhappy about using Excel 9's AddressOf operator, but as long as it is in a
' function that is not called when run on XL8, it seems to allow it to exist.
Function BrowseCallBackFuncAddress() As Long
    #If VBA6 Then
        BrowseCallBackFuncAddress = Long2Long(AddressOf BrowseCallBackFunc)
    #End If
End Function

'It is not possible to assign the result of AddressOf (which is a Long) directly to a member
'of a user defined data type.  This explicitly "converts" it to a Long and
'allows the assignment
Function Long2Long(x As Long) As Long
    Long2Long = x
End Function

'Centers dialog on desktop
Sub CenterDialog(hWnd As Long)
    Dim WinRect As RECT, ScrWidth As Integer, ScrHeight As Integer
    Dim DlgWidth As Integer, DlgHeight As Integer
    GetWindowRect hWnd, WinRect
    DlgWidth = WinRect.Right - WinRect.Left
    DlgHeight = WinRect.Bottom - WinRect.Top
    ScrWidth = GetSystemMetrics(SM_CXFULLSCREEN)
    ScrHeight = GetSystemMetrics(SM_CYFULLSCREEN)
    MoveWindow hWnd, (ScrWidth - DlgWidth) / 2, (ScrHeight - DlgHeight) / 2, DlgWidth, DlgHeight, 1
End Sub


Function GetFolderVBA(vFolder As String, vMsg As String) As String
    Dim RetStr As String, Flags As Long, DoCenter As Boolean
    Flags = BIF_RETURNONLYFSDIRS   'Set only basic browse

    '      Flags = Flags + BIF_EDITBOX   'Allow direct entry *
    '      Flags = Flags + BIF_VALIDATE   'Validate direct entry *
    Flags = Flags + BIF_STATUSTEXT   'Show status text
    '   Flags = Flags + BIF_BROWSEINCLUDEFILES   'Show files
    Flags = Flags + BIF_NEWDIALOGSTYLE   'Use "New Style" dialog **
    '      DoCenter = True   'Centralizar na tela
    '* Requires Shell32.dll version 4.71 and above
    '** Requires Shell32.dll version 5.0 and above (Windows 2000 amd ME)
    Application.Interactive = False
    GetFolderVBA = GetDirectory(vFolder, Flags, DoCenter, vMsg)
    Application.Interactive = True
End Function




Public Function CopiarArq(Orig As String, Dest As String)
    On Error GoTo ErrorHandler
    FileCopy Orig, Dest
    CopiarArq = True
    GoTo Fim
ErrorHandler:
    CopiarArq = False
Fim:
End Function

Public Function RenArq(Orig As String, Dest As String)
    On Error GoTo ErrorHandler
    Name Orig As Dest
    RenArq = True
    GoTo Fim
ErrorHandler:
    RenArq = False
Fim:
End Function


' InQuest injected base64 decoded content
' j'v&
' j'v&
' N*Fz

INQUEST-PP=macro
