Attribute VB_Name = "QuickStringCollection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' QuickStringCollection:                                                    '
' ~~~~~~~~~~~~~~~~~~~~~~                                                    '
'   Class which implements a simple "collection" of strings using one large '
'   delimited string.  This class can be very useful for storing a list of  '
'   bookmarks, shapes, etc.                                                 '
'==========================================================================='
Option Explicit

Private m_sCollection As String
Private m_sDelimiter As String
Private m_bAllowDupes As Boolean
Private m_lItemCount As Long

'== Class_Initialize ===============================================================
'
Private Sub Class_Initialize()
    m_sDelimiter = "|"
    m_bAllowDupes = False
End Sub

'== Init ===========================================================================
'
Public Sub Init(Optional sDelimiter As String = "", _
                Optional bAllowDuplicates As Boolean = False)
    m_sCollection = ""
    m_lItemCount = 0
    If sDelimiter <> "" Then
        m_sDelimiter = sDelimiter
    End If
    m_bAllowDupes = bAllowDuplicates
End Sub



'== Add ============================================================================
'
Public Function Add(sValue As String) As Boolean
    
    If sValue = "" Then
        Add = False
    ElseIf InStr(sValue, m_sDelimiter) > 0 Then
        Add = False
    Else
        Add = True
        If m_sCollection = "" Then
            m_sCollection = m_sDelimiter & sValue & m_sDelimiter
            m_lItemCount = m_lItemCount + 1
        ElseIf m_bAllowDupes Then
            m_sCollection = m_sCollection & sValue & m_sDelimiter
            m_lItemCount = m_lItemCount + 1
        ElseIf Not Exists(sValue) Then
            m_sCollection = m_sCollection & sValue & m_sDelimiter
            m_lItemCount = m_lItemCount + 1
        Else
            Add = False
        End If
    End If
End Function

'== Exists =========================================================================
'
Public Function Exists(ByVal sValue As String) As Boolean
    Exists = (InStr(m_sCollection, m_sDelimiter & sValue & m_sDelimiter) > 0)
End Function

'== Delete =========================================================================
'
Public Function Delete(ByVal sValue As String) As Boolean
    Dim lPos As Long, lItemLength As Long
    
    lPos = InStr(m_sCollection, m_sDelimiter & sValue & m_sDelimiter)
    lItemLength = Len(m_sDelimiter) * 2 + Len(sValue)
    If lPos = 0 Then
        Delete = False
    ElseIf lPos = 1 And Len(m_sCollection) = lItemLength Then
        m_sCollection = ""
        m_lItemCount = 0
        Delete = True
    ElseIf lPos = 1 Then
        m_sCollection = Mid(m_sCollection, lPos + lItemLength - 1)
        m_lItemCount = m_lItemCount - 1
        Delete = True
    Else
        m_sCollection = Left(m_sCollection, lPos) _
                        & Mid(m_sCollection, lPos + lItemLength)
        m_lItemCount = m_lItemCount - 1
        Delete = True
    End If
End Function



'== RemoveNext =====================================================================
'
Public Function RemoveNext() As String
    Dim lStart As Long, lPos As Long
    
    If m_sCollection = "" Then
        RemoveNext = ""
    Else
        ' find the second instance of the delimiter
        lStart = Len(m_sDelimiter) + 1
        lPos = InStr(lStart, m_sCollection, m_sDelimiter)
        
        If lPos = 0 Then
            ' no trailing delimiter
            m_sCollection = ""
            m_lItemCount = 0
            RemoveNext = Mid(m_sCollection, lStart)
        Else
            RemoveNext = Mid(m_sCollection, lStart, lPos - lStart)
            m_sCollection = Mid(m_sCollection, lPos)
            If m_sCollection = m_sDelimiter Then
                ' nothing left but the last delimiter -- collection is empty
                m_sCollection = ""
                m_lItemCount = 0
            Else
                m_lItemCount = m_lItemCount - 1
            End If
        End If
    End If
End Function

'== ItemCount ======================================================================
'
Public Function ItemCount() As Long
    ItemCount = m_lItemCount
End Function
Attribute VB_Name = "RibbonClassic2007"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' RibbonClassic2007:                                                        '
' ~~~~~~~~~~~~~~~~~~                                                        '
'   Ribbon callbacks for "classic" ribbon features (text and picture tools  '
'   for single-section documents, other than divider tabs.)                 '
'==========================================================================='
Option Explicit

Global Const FEATURE_FILL = "fill"
Global Const FEATURE_PICTURES = "pictures"
Global Const FEATURE_ADDSHEET = "addSheet"

Global Const RIBBON_TEXTEDIT = "buttonAveryTemplateEditText" ' & 1 or 2
Global Const RIBBON_TEXTFORMAT = "toggleAveryTemplateFormatText" ' & 1 or 2

'== AveryRibbonGetVisibleClassic ======================================== CALLBACK =
'
' Purpose:  Determines if a classic ribbon feature is currently visible
' Used By:  getVisible callbacks on all types of ribbon controls
'-----------------------------------------------------------------------------------
Sub AveryRibbonGetVisibleClassic(rcTarget As IRibbonControl, ByRef returnedVal)
    
    On Error Resume Next    ' handle errors silently in this background function
    If g_trRibbonConfig Is Nothing Then
        RibbonInit
    End If
    
    Select Case rcTarget.id
        '--- regular text ---
        Case "groupAveryTemplateText1":
            returnedVal = g_trRibbonConfig.FeatureVisible(FEATURE_FILL, 1)
        Case "groupAveryTemplateText2":
            returnedVal = g_trRibbonConfig.FeatureVisible(FEATURE_FILL, 2)
        
        '--- pictures ---
        Case "groupAveryTemplatePictures":
            returnedVal = g_trRibbonConfig.FeatureVisible(FEATURE_PICTURES)
        
        '--- add sheet ---
        Case "groupAveryTemplateSheets":
            If g_trRibbonConfig.FeatureVisible(FEATURE_ADDSHEET) Then
                ' bootstrap our refresh hook here, if add sheet has already been used
                ' (this will run when a saved doc is reloaded)
                Dim cxnSheets As CustomXMLNode
                Set cxnSheets = g_trRibbonConfig.CurrentSection().FeatureNode(FEATURE_ADDSHEET)
            
                If Not cxnSheets Is Nothing Then
                    If cxnSheets.ChildNodes.Count > 0 Then
                        Word_SetRefreshOnScroll ActiveDocument
                    End If
                End If
                returnedVal = True
            Else
                returnedVal = False
            End If
        
        Case Else
            returnedVal = False
    End Select
End Sub

'== AveryRibbonOnActionClassic ========================================== CALLBACK =
'
' Purpose:  Executes the code for a feature associated with a ribbon button
' Used By:  onAction callbacks on classic ribbon buttons, e.g. web links
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonOnActionClassic(rcTarget As IRibbonControl)
    Dim doc As Document, sControlPrefix As String, lFillGroup As Long
    
    On Error GoTo Err_OnActionClassic
    
    If g_trRibbonConfig Is Nothing Then
        RibbonInit
    End If
        
    If g_trRibbonConfig.EULACheck() Then
        Set doc = g_trRibbonConfig.Document()
        Select Case rcTarget.id
            Case "buttonAveryPicChangeAll":
                Pictures_ChangeAll doc
            
            Case "buttonAveryPicResizeAll":
                Pictures_ResizeAll doc
                    
            Case "buttonAveryPicChangeSel":
                Pictures_ChangeSelected doc
                    
            Case "buttonAveryPicRemoveAll":
                Pictures_RemoveAll doc
            
            Case "buttonAveryAddSheet":
                Text_AddSheet doc
            
            Case Else
                lFillGroup = Val(Right(rcTarget.id, 1))
                If lFillGroup > 0 Then
                    sControlPrefix = Left(rcTarget.id, Len(rcTarget.id) - 1)
                End If
            
                Select Case sControlPrefix
                    Case RIBBON_TEXTEDIT:
                        Text_EditFieldText doc, lFillGroup
                End Select
        End Select
    End If
    Exit Sub

Err_OnActionClassic:
    UI_ScreenUpdating True
    UI_HideProgress
    UI2007_MsgBox "FatalError", vbCritical, Err.Number
End Sub

'== AveryRibbonToggleOnActionClassic =========================================== CAL
'
' Purpose:  Executes the code for a feature associated with a toggle button
' Used By:  onAction callbacks on classic ribbon toggle buttons, e.g. text fill
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonToggleOnActionClassic(rcTarget As IRibbonControl, _
                                            pressed As Boolean)
    Dim doc As Document, sControlId As String, lFillGroup As Long
    
    On Error GoTo Err_ToggleOnActionClassic
    
    If g_trRibbonConfig Is Nothing Then
        RibbonInit
    End If
        
    If g_trRibbonConfig.EULACheck() Then
        Set doc = g_trRibbonConfig.Document()
        
        lFillGroup = Val(Right(rcTarget.id, 1))
        If lFillGroup > 0 Then
            sControlId = Left(rcTarget.id, Len(rcTarget.id) - 1)
        Else
            sControlId = rcTarget.id
        End If
        
        Select Case sControlId
            Case RIBBON_TEXTFORMAT:
                Text_FormatPanels doc, lFillGroup
        End Select
    End If
    Exit Sub

Err_ToggleOnActionClassic:
    UI_ScreenUpdating True
    UI_HideProgress
    UI2007_MsgBox "FatalError", vbCritical, Err.Number
End Sub
Attribute VB_Name = "RibbonCore2007"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' RibbonClassic2007:                                                        '
' ~~~~~~~~~~~~~~~~~~                                                        '
'   Ribbon callbacks for shared ribbon features.                            '
'                                                                           '
'   Note some ribbon callbacks (eg. Ready Index, Index Maker, Direct Print) '
'   are found in the QuickEditor*2007 modules, rather than Ribbon* modules. '
'==========================================================================='
Option Explicit
Global g_trRibbonConfig As TemplateRibbon2007
Private m_sWebSearchText As String
Private m_dWebSearchTimer As Double

'== AveryRibbonVerify ==============================================================
'
' Purpose:  Checks if this ribbon is already in use -- to avoid other bugs, we only
'           allow one document open at a time per ribbon.
' Used By:  Document events (New and Open)
'-----------------------------------------------------------------------------------
Public Function AveryRibbonVerify(docNew As Document)
    On Error Resume Next
    AveryRibbonVerify = True
    If g_trRibbonConfig Is Nothing Then
        AveryRibbonVerify = True
    Else
        AveryRibbonVerify = g_trRibbonConfig.VerifyStep1(docNew)
    End If
End Function

Public Sub AveryRibbonVerifyDocuments()
    If Not g_trRibbonConfig Is Nothing Then
        g_trRibbonConfig.VerifyStep2
    End If
End Sub

'== AveryRibbonOnLoad =================================================== CALLBACK =
'
' Purpose:  Stores local pointer to ribbon interface
' Used By:  onLoad callback
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonOnLoad(ribbon As IRibbonUI)
    
    On Error GoTo Err_RibbonOnLoad
    
    ' in some templates with actions on new/open (e.g. dividers), this code runs
    ' _after_ those events; the ribbon object may already be initialized
    If g_trRibbonConfig Is Nothing Then
        Set g_trRibbonConfig = New TemplateRibbon2007
        g_trRibbonConfig.Init ActiveDocument, ribbon
    Else
        g_trRibbonConfig.LateInit ribbon
    End If
    
    If Not g_trRibbonConfig.EULACheck(True) Then
        ' user declined EULA; close our template
        
        If Application.Documents.Count = 1 Then
            ' in the fishbowl, ribbon can stay around, half-initialized
            ' open another, blank doc to avoid this...
            Dim doc As Document
            Set doc = ActiveDocument
            Application.Documents.Add
            doc.Close
        Else
            ActiveDocument.Close
        End If
    End If
    Exit Sub

Err_RibbonOnLoad:
    UI_ScreenUpdating True
    UI_HideProgress
    UI2007_MsgBox "FatalError", vbCritical, Err.Number
End Sub

'== RibbonInit =====================================================================
'
' Purpose:  Ensures ribbon has been properly initialized (especially in case of VBA
'           failure/reset)
' Used By:  Should be called by all ribbon callbacks before relying on ribbon state
'-----------------------------------------------------------------------------------
Public Function RibbonInit() As Boolean
    If g_trRibbonConfig Is Nothing Then
        Set g_trRibbonConfig = New TemplateRibbon2007
        g_trRibbonConfig.Init ActiveDocument, Nothing
    End If
End Function

'== AveryRibbonGetLabel ================================================= CALLBACK =
'
' Purpose:  Supplies UI text for classic ribbon features
' Used By:  getLabel callbacks on all types of ribbon controls
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonGetLabel(rcTarget As IRibbonControl, ByRef returnedVal)
    On Error Resume Next    ' handle errors silently in this background function
    
    returnedVal = UI2007_GetLocalString(CTRLS_RIBBON, "", rcTarget.id, STRING_LABEL, _
                                        APPLY_SYMBOLS_ALWAYS)
End Sub

'== AveryRibbonGetScreentip ============================================= CALLBACK =
'
' Purpose:  Provides Word with the screentip for an Avery ribbon feature (by looking
'           it up in the UI XML)
' Used By:  getScreentip callbacks on all types of ribbon controls
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonGetScreentip(rcTarget As IRibbonControl, ByRef returnedVal)
    On Error Resume Next    ' handle errors silently in this background function
    
    returnedVal = UI2007_GetLocalString(CTRLS_RIBBON, "", rcTarget.id, _
                                        STRING_SCREENTIP, APPLY_SYMBOLS_ALWAYS)
End Sub

'== AveryRibbonGetSupertip ============================================== CALLBACK =
'
' Purpose:  Provides Word with the supertip for an Avery ribbon feature (by looking
'           it up in the UI XML)
' Used By:  getSupertip callbacks on all types of ribbon controls
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonGetSupertip(rcTarget As IRibbonControl, ByRef returnedVal)
    On Error Resume Next    ' handle errors silently in this background function
    
    returnedVal = UI2007_GetLocalString(CTRLS_RIBBON, "", rcTarget.id, _
                                        STRING_SUPERTIP, APPLY_SYMBOLS_ALWAYS)
End Sub

'== AveryRibbonGetVisible =============================================== CALLBACK =
'
' Purpose:  Determines if a ribbon feature is currently visible
' Used By:  getVisible callbacks on all types of ribbon controls
'
' Remarks:  Template-specific features will have their own GetVisible callback,
'           e.g. AveryRibbonGetVisibleClassic for the Classic Ribbon
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonGetVisible(rcTarget As IRibbonControl, ByRef returnedVal)
    On Error Resume Next    ' handle errors silently in this background function
    
    If g_trRibbonConfig Is Nothing Then
        RibbonInit
    End If
    
    Select Case rcTarget.id
        '--- web links ---
        Case "groupAveryWeb", "buttonAveryAbout", "buttonAveryHelp", _
             "buttonAveryMore", "boxAveryWebSearch":
            ' always show web links and web search
            returnedVal = True
        
        Case "buttonAveryPrintHelp":
            ' command only appears if a URL is supplied in ui-en.xml as a "data" tag
            returnedVal = (UI2007_GetLocalString(CTRLS_RIBBON, "", rcTarget.id, _
                           STRING_DATA) <> "")
            
        Case Else
            returnedVal = False
    End Select
End Sub

'== AveryRibbonGetPressed =============================================== CALLBACK =
'
' Purpose:  Determines whether a toggle button should be shown highlighted; note
'           this relies on state information maintained by the Section object
' Used By:  getPressed callbacks on all ribbon toggle buttons, e.g. text fill
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonGetPressed(rcTarget As IRibbonControl, ByRef returnedVal)
    On Error Resume Next    ' handle errors silently in this background function

    
    If g_trRibbonConfig Is Nothing Then
        RibbonInit
    End If

    If Not g_trRibbonConfig.CurrentSection().GetPressed(rcTarget.id, returnedVal) Then
        ' pressed state hasn't been set yet... default to not pressed
        returnedVal = False
    End If
End Sub

'== AveryRibbonOnAction ================================================= CALLBACK =
'
' Purpose:  Executes the code for a feature associated with a ribbon button
' Used By:  onAction callbacks on core ribbon buttons, e.g. web links
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonOnAction(rcTarget As IRibbonControl)
    Dim doc As Document
    
    On Error GoTo Err_OnActionCore
    
    If g_trRibbonConfig Is Nothing Then
        RibbonInit
    End If
    Set doc = g_trRibbonConfig.Document()
    
    Select Case rcTarget.id
        Case "buttonAveryCom", "buttonAveryMore", "buttonAveryAbout", _
             "buttonAveryHelp", "buttonAveryPrintHelp":
            UI2007_BrowseLink doc, rcTarget.id, ""
        
        Case "buttonAveryWebSearch":
            ' if the user just changed the text, they'll fire an OnChange event when
            ' they click the button.  The timer lets us see if the two are happening
            ' simultaneously (and not launch a second browser window)
            If Timer - m_dWebSearchTimer > 2 Then
                If m_sWebSearchText <> "" Then
                    UI2007_BrowseLink doc, "editAveryWebSearch", m_sWebSearchText
                End If
            End If
    End Select
    Exit Sub

Err_OnActionCore:
    UI_ScreenUpdating True
    UI_HideProgress
    UI2007_MsgBox "FatalError", vbCritical, Err.Number
End Sub

'== AveryRibbonOnChange ================================================= CALLBACK =
'
' Purpose:  Takes action based on changes the user has made to a ribbon text box
' Used By:  onChange callback for editAveryWebSearch (the web search text box)
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonOnChange(rcTarget As IRibbonControl, Text As String)
    Dim doc As Document
    
    On Error GoTo Err_OnChangeCore
    
    If g_trRibbonConfig Is Nothing Then
        RibbonInit
    End If
    
    If rcTarget.id = "editAveryWebSearch" Then
        ' the ribbon programmability model doesn't quite give us enough to mimic the
        ' behaviour of other text controls on the ribbon; closest we can get is to
        ' perform a search when the OnChange event fires
        m_sWebSearchText = Text
        If m_sWebSearchText <> "" Then
            UI2007_BrowseLink doc, "editAveryWebSearch", m_sWebSearchText
            ' this timer prevents us from performing the same search twice
            ' (see buttonAveryWebSearch)
            m_dWebSearchTimer = Timer
        End If
    End If
    Exit Sub

Err_OnChangeCore:
    UI_ScreenUpdating True
    UI_HideProgress
    UI2007_MsgBox "FatalError", vbCritical, Err.Number
End Sub

'== AveryRibbonRestoreSelection ====================================================
'
' Purpose:  Restores the user's previous selection that was temporarily deselected
'           by the "ribbon protection" feature
' Used By:  Called by Application.OnTime in the TemplateRibbon2007 class (must be
'           Public and have no arguments)
'-----------------------------------------------------------------------------------
Public Sub AveryRibbonRestoreSelection()
    ' this macro is called a split second after our window is reactivated, via
    ' Application.OnTime (so it must be a Public Sub of this name!)
    ' If ribbon protection isn't properly set up, this does nothing...
    On Error Resume Next
    If Not g_trRibbonConfig Is Nothing Then
        g_trRibbonConfig.RestoreProtectedSelection
    End If
End Sub
Attribute VB_Name = "RibbonSection2007"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' RibbonSection2007:                                                        '
' ~~~~~~~~~~~~~~~~~~                                                        '
'   Class which handles the list of features displayed on the ribbon for    '
'   a given section.  (In a suite, each section could have a different      '
'   feature set.)                                                           '
'==========================================================================='
Option Explicit
Private m_trParent As TemplateRibbon2007
Private m_cxnConfig As CustomXMLNode
Private m_lSectionIndex As Long
Private m_sProductType As String, m_sProductGroup As String
Private m_qscCtrlPressed As QuickStringCollection
Private m_qscCtrlNotPressed As QuickStringCollection
'Private m_frmModeless As UserForm
'Private m_sModelessUIToggle As String

'== Init ===========================================================================
'
Public Sub Init(trParent As TemplateRibbon2007, _
                cxnSection As CustomXMLNode, _
                lSectionIndex As Long)

    Dim cxnProductInfo As CustomXMLNode

    Set m_trParent = trParent
    Set m_cxnConfig = cxnSection
    
    ' get ProductType from XML
    Set cxnProductInfo = XML_SelectSingleNode(cxnSection, "productType")
    If Not (cxnProductInfo Is Nothing) Then
        m_sProductType = cxnProductInfo.Text
    End If
    
    ' get ProductGroup from XML
    Set cxnProductInfo = XML_SelectSingleNode(cxnSection, "productGroup")
    If Not (cxnProductInfo Is Nothing) Then
        m_sProductGroup = cxnProductInfo.Text
    End If
    
    Set m_qscCtrlPressed = New QuickStringCollection
    Set m_qscCtrlNotPressed = New QuickStringCollection
End Sub


'== SectionAttribute ===============================================================
'
Public Function SectionAttribute(sAttributeName As String, _
                                 Optional sDefaultValue As String = "") As String
                            
    SectionAttribute = XML_GetAttribute(m_cxnConfig, sAttributeName, sDefaultValue)
End Function


'== SectionBoolAttribute ===========================================================
'
Public Function SectionBoolAttribute(sAttributeName As String, _
                            Optional bDefaultValue As Boolean = False) As Boolean
                            
    SectionBoolAttribute = XML_GetBoolAttribute(m_cxnConfig, sAttributeName, _
                                                bDefaultValue)
End Function

'== HasFeature =====================================================================
'
Public Function HasFeature(sFeatureName As String, _
                           Optional lFeatureIndex As Long = 1) As Boolean
    
    HasFeature = Not (FeatureNode(sFeatureName, lFeatureIndex) Is Nothing)
End Function



'== FeatureNode ====================================================================
'
Public Function FeatureNode(sFeatureName As String, _
                            Optional lFeatureIndex As Long = 1) As CustomXMLNode
                            
    Dim sXPath As String
    
    sXPath = sFeatureName & "[" & Format(lFeatureIndex, "0") & "]"
    Set FeatureNode = XML_SelectSingleNode(m_cxnConfig, sXPath)
End Function



'== WordSection ====================================================================
'
Public Function WordSection() As Word.Section
    Set WordSection = m_trParent.Document().Sections(1)
End Function

'== WordTable ======================================================================
'
Public Function WordTable() As Word.Table
    Dim rngSection As Range
    
    Set rngSection = WordSection().Range
    If rngSection.Tables.Count = 0 Then
        Set WordTable = Nothing
    Else
        Set WordTable = rngSection.Tables(1)
    End If
End Function

'== SectionIndex ===================================================================
'
Public Function SectionIndex() As Long
    SectionIndex = m_lSectionIndex
End Function

'== Document =======================================================================
'
Public Function Document() As Word.Document
    Set Document = m_trParent.Document()
End Function

'== ProductType ====================================================================
'
Public Function ProductType() As String
    ProductType = m_sProductType
End Function

'== ProductType ====================================================================
'
Public Function ProductGroup() As String
    ProductGroup = m_sProductGroup
End Function

'== GetPressed =====================================================================
'
Public Function GetPressed(sControlId As String, ByRef returnedVal)
    If m_qscCtrlPressed.Exists(sControlId) Then
        returnedVal = True
        GetPressed = True
    ElseIf m_qscCtrlNotPressed.Exists(sControlId) Then
        returnedVal = False
        GetPressed = True
    Else
        GetPressed = False
    End If
End Function

'== SetPressed =====================================================================
'
Public Sub SetPressed(sControlId As String, bIsPressed As Boolean, _
                      Optional bInvalidate As Boolean = True)
    If bIsPressed Then
        m_qscCtrlNotPressed.Delete sControlId
        m_qscCtrlPressed.Add sControlId
    Else
        m_qscCtrlPressed.Delete sControlId
        m_qscCtrlNotPressed.Add sControlId
    End If
    
    If bInvalidate Then
        m_trParent.InvalidateControl sControlId
    End If
End Sub

'Public Sub RegisterModelessUI(frmModeless As UserForm, sToggleCtrl As String)
'    Set m_frmModeless = frmModeless
'    m_sModelessUIToggle = sToggleCtrl
'    If sToggleCtrl <> "" Then
'        SetPressed sToggleCtrl, False
'    End If
'End Sub

'Public Sub HideModelessUI(Optional bUnloadForm As Boolean = True)
'    If m_sModelessUIToggle <> "" Then
'        SetPressed m_sModelessUIToggle, False
'    End If
'
'    If Not (m_frmModeless Is Nothing) Then
'        If bUnloadForm Then
'            Unload m_frmModeless
'        End If
'        Set m_frmModeless = Nothing
'    End If
'End Sub
Attribute VB_Name = "RibbonToolsPictures2007"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' RibbonToolsPictures2007:                                                  '
' ~~~~~~~~~~~~~~~~~~~~~~~~                                                  '
'   Implementation of Word 2007 picture features on the "classic" ribbon.   '
'==========================================================================='
Option Explicit

Private Type PictureInfo
    ' this type is used to store info about pictures during
    ' the Change All Pictures process
    Name As String
    Left As Single
    Top As Single
    Shape As Shape
    Anchor As Range
    Done As Boolean
End Type

'== Pictures_ChangeAll =============================================================
'
' Purpose:  Change all pictures.
'
' Params:   (in) doc: The document in which to change pictures
'
' Remarks:  Works by invoking Word's "Change Picture" feature, and then applying
'           those changes to all other copies of that picture in the document.
'-----------------------------------------------------------------------------------
Public Sub Pictures_ChangeAll(doc As Document)
    Dim collPics As Collection, rngSavedSel As Range, srSavedSel As ShapeRange
    Dim sContentIDBase As String, lShapeCount As Long, lShape As Long
    Dim lShapeFirst As Long, lContentID As Long, lContentIDLowest As Long
    Dim shp As Shape, cxnPictures As CustomXMLNode, a_piPics() As PictureInfo
    Dim cxnSheets As CustomXMLNode, a_lSheetRanges() As Long, lSheetCount As Long
    Dim bDocWasSaved As Boolean, bContinue As Boolean
    
    If Not Pictures_FeatureInfo(cxnPictures, sContentIDBase, cxnSheets) Then
        ' picture feature node not found
        UI2007_MsgBox "FatalError", vbCritical
        Exit Sub
    End If
    
    Set collPics = Pictures_PicsCollection(doc, sContentIDBase)
    If (collPics Is Nothing) Then
        UI2007_MsgBox "MissingPictures", vbExclamation
    Else
        'g_trRibbonConfig.CurrentSection().HideModelessUI True
        Word_SaveSelection doc, rngSavedSel, srSavedSel
        lShapeCount = collPics.Count
        ReDim a_piPics(1 To lShapeCount)
        
        ' get multi-sheet information, if any
        If cxnSheets Is Nothing Then
            lSheetCount = 0
        Else
            lSheetCount = cxnSheets.ChildNodes.Count
            
            If lSheetCount > 0 Then
                ReDim a_lSheetRanges(1 To lSheetCount, 1 To 3)
                Pictures_GetSheetRanges cxnSheets, a_lSheetRanges, lSheetCount
            End If
        End If
        
        ' find lowest shape index
        lShapeFirst = 0
        For lShape = 1 To lShapeCount
            If WordPort_DecodeName(collPics(lShape).Name, "", 0, "", lContentID, 0, 0) Then
                If lContentID < lContentIDLowest Or lShapeFirst = 0 Then
                    lShapeFirst = lShape
                    lContentIDLowest = lContentID
                End If
            End If
        Next
        
        ' save current properties of first picture
        Pictures_SaveInfo collPics(lShapeFirst), a_piPics(lShapeFirst), cxnPictures, _
                          a_lSheetRanges, lSheetCount, sContentIDBase
        
        ' temporarily mark the document as "Saved"
        bDocWasSaved = doc.Saved
        doc.Saved = True
        
        UI_ScreenUpdating False
        a_piPics(lShapeFirst).Shape.Select
        
        ' call Word's built-in "Change Picture" feature to change the first picture
        doc.CommandBars.ExecuteMso "PictureChange"
        
        If doc.Saved Then
            ' doc is still marked as "Saved", so no change made (i.e. user cancelled)
            doc.Saved = bDocWasSaved    ' restore original "dirty" bit
        
        ElseIf lShapeCount > 1 Then
            ' yes, user made a change, and we need to apply it to other pictures
            UI2007_ShowProgress "UpdatingPictures", True
            UI_PushProgressSubRange 0, 0.05
            
            XML_SetAttribute cxnPictures, "cw", Format(a_piPics(lShapeFirst).Shape.Width, "0.00"), True
            XML_SetAttribute cxnPictures, "ch", Format(a_piPics(lShapeFirst).Shape.Height, "0.00"), True
            a_piPics(lShapeFirst).Done = True
            bContinue = True
            
            ' gather info about all the replaceable pictures in the document
            For lShape = 1 To lShapeCount
                Set shp = collPics(lShape)
                If lShape <> lShapeFirst Then
                    Pictures_SaveInfo shp, a_piPics(lShape), cxnPictures, _
                                    a_lSheetRanges, lSheetCount, sContentIDBase
                End If
                If lShape Mod 5 = 0 Then
                    If Not UI_UpdateProgress(lShape / lShapeCount) Then
                        ' user cancelled
                        bContinue = False
                        Exit For
                    End If
                End If
            Next lShape
        
            If (Not bContinue) Or (Not UI_UpdateProgress(1)) Then
                ' user cancelled here or in loop above
                UI_HideProgress
                UI_ScreenUpdating True
                Word_RestoreSelection rngSavedSel, srSavedSel
                Exit Sub
            End If
            UI_PopProgressSubRange
            UI_PushProgressSubRange 0.05, 1
            
            ' finally, replace all pictures using info we've gathered
            Pictures_CloneAll doc, a_piPics, lShapeCount, lShapeFirst
            UI_HideProgress
        End If
        UI_ScreenUpdating True
        Word_SetDelayedRefresh
        Word_RestoreSelection rngSavedSel, srSavedSel
    End If
End Sub

'== Pictures_SaveInfo ==============================================================
'
' Purpose:  Fills a PictureInfo structure with the details of the specified picture.
' Remarks:  Helper function for Pictures_ChangeAll.
'-----------------------------------------------------------------------------------
Private Sub Pictures_SaveInfo(shpPic As Shape, ByRef piInfo As PictureInfo, cxnPictures As CustomXMLNode, _
                              ByRef a_lSheetRanges() As Long, lSheetCount As Long, sContentIDBase As String)
    
    
    With piInfo
        Set .Shape = shpPic
        Set .Anchor = shpPic.Anchor
        .Name = shpPic.Name
        If Not Pictures_GetXY(cxnPictures, a_lSheetRanges, lSheetCount, sContentIDBase, .Name, _
                              .Left, .Top) Then
            .Left = .Shape.Left
            .Top = .Shape.Top
        End If
    End With
End Sub

'== Pictures_CloneAll ==============================================================
'
' Purpose:  Takes the change made to picture #1 and applies it to all other related
'           pictures in the document.
' Remarks:  Helper function for Pictures_ChangeAll.
'-----------------------------------------------------------------------------------
Private Function Pictures_CloneAll(doc As Document, a_piPics() As PictureInfo, _
                                   lShapeCount As Long, lShapeFirst As Long) As Boolean
    Dim lShape As Long, lSourceShape As Long, lDoneCount As Long
    
    Pictures_CloneAll = True
    lDoneCount = 0

    ' Directly setting (or even querying) .Left and .Top is very slow, so instead we
    ' use .IncrementLeft or .IncrementTop to "nudge" pictures into place.  To further
    ' optimize, we use the first pic to clone the first row, and then use the first
    ' row to clone the rest of the document (so we only have to nudge in one direction
    ' for each picture.)

    ' First row:
    Do
        lShape = Pictures_GetByLocation(a_piPics, lShapeCount, False, Y:=a_piPics(lShapeFirst).Top)
        
        If lShape > 0 Then
            Pictures_CloneOne doc, a_piPics, lShapeFirst, lShape
            
            ' increment progress bar
            lDoneCount = lDoneCount + 1
            If Not (UI_UpdateProgress(lDoneCount / lShapeCount)) Then
                Pictures_CloneAll = False
                Exit Function
            End If
        End If
    Loop Until lShape = 0
    
    ' Subsequent rows:
    ' (We loop through all pics again, just in case the order of the shapes collection
    ' isn't left to right, top to bottom, but ignore those already marked "Done")
    For lShape = 2 To lShapeCount
        If Not a_piPics(lShape).Done Then
            lSourceShape = Pictures_GetByLocation(a_piPics, lShapeCount, True, X:=a_piPics(lShape).Left)
        
            If lSourceShape = 0 Then
                lSourceShape = Pictures_GetByLocation(a_piPics, lShapeCount, True, Y:=a_piPics(lShape).Top)
                
                If lSourceShape = 0 Then
                    ' can't find a location match -- clone from first
                    Pictures_CloneOne doc, a_piPics, 1, lShape
                Else
                    Pictures_CloneOne doc, a_piPics, lSourceShape, lShape
                End If
            Else
                Pictures_CloneOne doc, a_piPics, lSourceShape, lShape
            End If
        End If
        ' increment progress bar
        lDoneCount = lDoneCount + 1
        If Not (UI_UpdateProgress(lDoneCount / lShapeCount)) Then
            Pictures_CloneAll = False
            Exit Function
        End If
    Next lShape
End Function

'== Pictures_GetByLocation =========================================================
'
' Purpose:  Finds a picture that has the specified X or Y coordinate.  Used to find
'           pictures in the same row or column, which optimizes picture cloning by
'           cutting down on the number of moves.
' Remarks:  Helper function for Pictures_CloneAll.
'-----------------------------------------------------------------------------------
Private Function Pictures_GetByLocation(ByRef a_piPics() As PictureInfo, _
                                        lShapeCount As Long, bDone As Boolean, _
                                        Optional X As Single = -999, _
                                        Optional Y As Single = -999) As Long

    Dim lShape As Long, bMatch As Boolean
    
    For lShape = 1 To lShapeCount
        If a_piPics(lShape).Done = bDone Then
            bMatch = True
            If X <> -999 Then
                bMatch = (a_piPics(lShape).Left = X)
            End If
            If Y <> -999 Then
                bMatch = (a_piPics(lShape).Top = Y)
            End If
            If bMatch Then
                Pictures_GetByLocation = lShape
                Exit Function
            End If
        End If
    Next lShape
    Pictures_GetByLocation = 0
End Function

'== Pictures_CloneOne ==============================================================
'
' Purpose:  Replaces a single target picture using the source picture specified, and
'           fixes location and shape name accordingly.
' Remarks:  Helper function for Pictures_CloneAll.
'-----------------------------------------------------------------------------------
Private Sub Pictures_CloneOne(doc As Document, ByRef a_piPics() As PictureInfo, _
                               lSourceShape As Long, lTargetShape As Long)
    ' rename the base shape to the target shape's name
    a_piPics(lSourceShape).Shape.Name = a_piPics(lTargetShape).Name
    ' copy the shape
    a_piPics(lTargetShape).Shape.Anchor.FormattedText = a_piPics(lSourceShape).Shape.Anchor.FormattedText
    ' unrename the base shape
    a_piPics(lSourceShape).Shape.Name = a_piPics(lSourceShape).Name
    ' reattach to the changed shape
    Set a_piPics(lTargetShape).Shape = doc.Shapes(a_piPics(lTargetShape).Name)
    
    ' nudge the changed shape into the correct position
    If a_piPics(lTargetShape).Left <> a_piPics(lSourceShape).Left Then
        a_piPics(lTargetShape).Shape.IncrementLeft a_piPics(lTargetShape).Left - a_piPics(lSourceShape).Left
    End If
    If a_piPics(lTargetShape).Top <> a_piPics(lSourceShape).Top Then
        a_piPics(lTargetShape).Shape.IncrementTop a_piPics(lTargetShape).Top - a_piPics(lSourceShape).Top
    End If
    
    ' mark the shape as done
    a_piPics(lTargetShape).Done = True
End Sub

'== Pictures_ResizeAll =============================================================
'
' Purpose:  Shows the Resize Pictures dialog, and then resizes all selected pictures
'           as requested by the end user
'
' Params:   (in) doc: the document in which to change pictures
'-----------------------------------------------------------------------------------
Public Sub Pictures_ResizeAll(doc As Document)
    Dim collPics As Collection, rngSavedSel As Range, srSavedSel As ShapeRange
    Dim shp As Shape, fCurrentWidth As Single, fCurrentHeight As Single
    Dim bLockAspect As Boolean, bAllSizesMatch As Boolean
    Dim fUserWidth As Single, fUserHeight As Single
    Dim fOriginalWidth As Single, fOriginalHeight As Single
    Dim fNewWidth As Single, fNewHeight As Single
    Dim bUserLockAspect As Boolean, sFirstPicName As String
    Dim cxnPictures As CustomXMLNode, sContentIDBase As String
    Dim fShapeIncrement As Single
    
    If Not Pictures_FeatureInfo(cxnPictures, sContentIDBase, Nothing) Then
        ' picture feature node not found
        UI2007_MsgBox "FatalError", vbCritical
    End If
    
    Set collPics = Pictures_PicsCollection(doc, sContentIDBase)
    If (collPics Is Nothing) Then
        UI2007_MsgBox "MissingPictures", vbExclamation
        Exit Sub
    End If
    'g_trRibbonConfig.CurrentSection().HideModelessUI True
    
    ' get update size info from XML, if available
    fOriginalWidth = Val(XML_GetAttribute(cxnPictures, "cw", "0"))
    fOriginalHeight = Val(XML_GetAttribute(cxnPictures, "ch", "0"))
    
    ' scan pictures to determine size info for the dialog box
    For Each shp In collPics
        If shp.Type = msoPicture Then
            If sFirstPicName = "" Then
                sFirstPicName = shp.Name
                fCurrentWidth = shp.Width
                fCurrentHeight = shp.Height
                bLockAspect = shp.LockAspectRatio
                bAllSizesMatch = True
                
                If fOriginalWidth = 0 Or fOriginalHeight = 0 Then
                    ' if not in the XML, read it from the WordPort name
                    WordPort_DecodeName shp.Name, "", 0, 0, 0, _
                                       fOriginalWidth, fOriginalHeight
                End If
                                   
                If Abs(fCurrentWidth - fOriginalWidth) _
                 + Abs(fCurrentHeight - fOriginalHeight) < 2 Then
                    ' still original (WordPort) size -- set Lock Aspect Ratio
                    Selection.ShapeRange.LockAspectRatio = msoTrue
                    bLockAspect = True
                End If
            Else
                If (fCurrentWidth <> shp.Width) Or (fCurrentHeight <> shp.Height) Then
                    bAllSizesMatch = False
                    Exit For
                End If
            End If
        End If
    Next
    
    Load frmResizePics
    frmResizePics.InitializeValues fCurrentWidth, fCurrentHeight, _
                                   fOriginalWidth, fOriginalHeight, _
                                   bLockAspect, bAllSizesMatch
    frmResizePics.Tag = ""
    frmResizePics.Show
    If frmResizePics.GetValues(fUserWidth, fUserHeight, bUserLockAspect) Then
        Unload frmResizePics
            
        If collPics.Count > 0 Then
            Application.ScreenRefresh
            UI_ScreenUpdating False
            UI2007_ShowProgress "UpdatingPictures", True
            
            fShapeIncrement = 1 / collPics.Count
            For Each shp In collPics
                If Not (bUserLockAspect = shp.LockAspectRatio) Then
                    shp.LockAspectRatio = bUserLockAspect
                End If
                shp.ScaleWidth fUserWidth, msoFalse, msoScaleFromMiddle
            
                If Not bUserLockAspect Then
                    shp.ScaleHeight fUserHeight, msoFalse, msoScaleFromMiddle
                End If
                If Not UI_IncrementProgress(fShapeIncrement) Then
                    ' user cancelled
                    Exit For
                End If
            Next
                
            ' done updating pictures
            UI_HideProgress
            UI_ScreenUpdating True
        End If
    Else
        Unload frmResizePics
    End If
End Sub

'== Pictures_ChangeSelected ========================================================
'
' Purpose:  Runs Word's built-in Change Selected Picture(s) feature, and then
'           massages the results for our purposes.
'
' Params:   (in) doc: the document in which to change pictures
'
' Remarks:  Using the built-in Word feature is _much_ faster than reinserting each
'           picture ourselves, even if we use copy/paste.  It also creates a cleaner
'           Undo stack.
'-----------------------------------------------------------------------------------
Public Sub Pictures_ChangeSelected(doc As Document)
    
    If doc.Shapes.Count = 0 Then
        UI2007_MsgBox "MissingPictures", vbExclamation
    ElseIf Not doc.CommandBars.GetEnabledMso("PictureChange") Then
        UI2007_MsgBox "NoPictureSelected", vbExclamation
    Else
        'g_trRibbonConfig.CurrentSection().HideModelessUI
        doc.CommandBars.ExecuteMso "PictureChange"
    End If
End Sub

'== Pictures_RemoveAll =============================================================
'
' Purpose:  Deletes all pictures in the template.
'
' Params:   (in) doc: the document from which to remove pictures
'-----------------------------------------------------------------------------------
Public Sub Pictures_RemoveAll(doc As Document)
    Dim collPics As Collection, shp As Shape, fShapeIncr As Single
    Dim sPicsBaseID As String, cxnPictures As CustomXMLNode
    Dim lPicID As Long, fPicWidth As Single, fPicHeight As Single
    Dim lPicIDFirst As Long, fPicWidthFirst As Single, fPicHeightFirst As Single
    Dim fPicXFirst As Single, fPicYFirst As Single
    Dim lEmpty(1) As Long
    
    ' gather picture info
    If Not Pictures_FeatureInfo(cxnPictures, sPicsBaseID, Nothing) Then
        ' picture feature node not found
        UI2007_MsgBox "FatalError", vbCritical
    End If
    Set collPics = Pictures_PicsCollection(doc, sPicsBaseID)
    
    ' verify we have pics and that the user wants to remove them
    If (collPics Is Nothing) Then
        UI2007_MsgBox "MissingPictures", vbExclamation
    ElseIf UI2007_MsgBox("ConfirmRemovePictures", vbYesNo + vbQuestion) = vbYes Then
        
        Application.ScreenRefresh
        UI_ScreenUpdating False
        UI2007_ShowProgress "UpdatingPictures", True
        
        Set cxnPictures = g_trRibbonConfig.CurrentSection().FeatureNode(FEATURE_PICTURES)
        lPicIDFirst = 0
        fShapeIncr = 1 / Math_Max(collPics.Count, 1)
        UI_PushProgressSubRange 0, 0.65
        
        For Each shp In collPics
            ' for the first panel, obtain width/height information from the picture's shape
            ' name, and its current XY position
            If WordPort_DecodeName(shp.Name, "", 0, "", lPicID, fPicWidth, fPicHeight) Then
                If (lPicID < lPicIDFirst) Or (lPicIDFirst = 0) Then
                    fPicWidthFirst = fPicWidth
                    fPicHeightFirst = fPicHeight
                    If Pictures_GetXY(cxnPictures, lEmpty(), 0, sPicsBaseID, shp.Name, _
                                      fPicXFirst, fPicYFirst) Then
                        lPicIDFirst = lPicID
                    End If
                End If
            End If
        
            ' delete the picture
            Word_DeleteShapeNotBookmarks shp
            If Not UI_IncrementProgress(fShapeIncr) Then
                UI_HideProgress
                UI_ScreenUpdating True
                Exit Sub
            End If
        Next
        UI_PopProgressSubRange
        UI_PushProgressSubRange 0.65, 1
        
        ' using height/width/X/Y info obtained above, collapse the margins or expand textboxes to
        ' make use of the space freed up by the picture
        Text_CollapseMinimumIndents doc, fPicXFirst, fPicYFirst, fPicWidthFirst, fPicHeightFirst
        
        UI_PopProgressSubRange
        UI_HideProgress
        UI_ScreenUpdating True
    End If
End Sub

'==================================================================================='
' General Pictures helper functions
'
'
'== Pictures_BaseContentID =========================================================
'
' Purpose:  Returns the BaseContentID (e.g. "PF1") that identifies the replaceable
'           pictures in the template.
'-----------------------------------------------------------------------------------
Private Function Pictures_BaseContentID() As String
    Dim sContentIDBase As String
    If Pictures_FeatureInfo(Nothing, sContentIDBase, Nothing) Then
        Pictures_BaseContentID = sContentIDBase
    Else
        Pictures_BaseContentID = ""
    End If
End Function

'== Pictures_FeatureInfo ===========================================================
'
' Purpose:  Returns:
'           - the Pictures CustomXMLNode that holds picture feature configuration
'           - the BaseContentID (e.g. "PF1") that identifies the replaceable
'             pictures in the template.
'           - the Sheets CustomXMLNode that holds "add sheet" feature configuration
'-----------------------------------------------------------------------------------
Private Function Pictures_FeatureInfo(ByRef cxnPictures As CustomXMLNode, _
                                      ByRef sContentIDBase As String, _
                                      ByRef cxnSheets As CustomXMLNode) As Boolean
    Dim rsCurrent As RibbonSection2007
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    Set cxnPictures = rsCurrent.FeatureNode(FEATURE_PICTURES)
    If Not (cxnPictures Is Nothing) Then
        sContentIDBase = XML_GetAttribute(cxnPictures, "baseContentId")
        Set cxnSheets = rsCurrent.FeatureNode(FEATURE_ADDSHEET)
        Pictures_FeatureInfo = True
    Else
        sContentIDBase = ""
        Pictures_FeatureInfo = False
    End If
End Function

'== Pictures_PicsCollection ========================================================
'
' Purpose:  Returns a collection with a Shape object for each replaceable picture in
'           in the template with a base content ID matching the one specified.
'           If no pictures match, returns Nothing.
'-----------------------------------------------------------------------------------
Private Function Pictures_PicsCollection(doc As Document, _
                                         sContentIDBase As String) As Collection
    Dim collResult As Collection, shp As Shape

    Set collResult = New Collection
    For Each shp In doc.Shapes
        If WordPort_MatchBaseContentID(shp.Name, sContentIDBase) Then
            collResult.Add shp, shp.Name
        End If
    Next shp
    If collResult.Count = 0 Then
        Set Pictures_PicsCollection = Nothing
    Else
        Set Pictures_PicsCollection = collResult
    End If
End Function

'== Pictures_GetSheetRanges ========================================================
'
' Purpose:  Populates a Sheet Ranges array with info from the Sheets XML node.
'           The Sheet Ranges array stores the minimum and maximum content IDs on
'           each sheet, as well as the offset from the first sheet.  (E.g. if PF1
'           on page 1 has been copied to PF101 on page 2, the offset is 100.)
'-----------------------------------------------------------------------------------
Private Sub Pictures_GetSheetRanges(cxnSheets As CustomXMLNode, _
                                    ByRef a_lSheetRanges() As Long, lSheetCount As Long)
                            
    Dim cxnSheet As CustomXMLNode, lSheetIndex As Long
    
    lSheetIndex = 0
    For Each cxnSheet In cxnSheets.ChildNodes
        lSheetIndex = lSheetIndex + 1
        a_lSheetRanges(lSheetIndex, 1) = Val(XML_GetAttribute(cxnSheet, "minId"))
        a_lSheetRanges(lSheetIndex, 2) = Val(XML_GetAttribute(cxnSheet, "maxId"))
        a_lSheetRanges(lSheetIndex, 3) = Val(XML_GetAttribute(cxnSheet, "offsetId"))
        
        If lSheetIndex >= lSheetCount Then Exit For
    Next
End Sub

'== Pictures_GetXY =================================================================
'
' Purpose:  Gets the XY coordinates for a given picture.
' Remarks:  If lSheetCount > 0, uses sheet range information to refer back to the
'           equivalent picture on page 1, which should have its XY stored in XML.
'           If picture cannot be found in XML, returns False.
'-----------------------------------------------------------------------------------
Private Function Pictures_GetXY(cxnPictures As CustomXMLNode, _
                                ByRef a_lSheetRanges() As Long, lSheetCount As Long, _
                                sContentIDBase As String, sName As String, _
                                ByRef fX As Single, ByRef fY As Single) As Boolean
    
    Dim sThisContentIDBase As String, lContentID As Long, lSheetIndexCheck As Long
    Dim cxnPic As CustomXMLNode
    
    Pictures_GetXY = False
    If WordPort_DecodeName(sName, "", 0, sThisContentIDBase, lContentID, 0, 0) Then
        If sThisContentIDBase = sContentIDBase Then
            For lSheetIndexCheck = 1 To lSheetCount
                If a_lSheetRanges(lSheetIndexCheck, 1) <= lContentID _
                 And lContentID <= a_lSheetRanges(lSheetIndexCheck, 2) Then
                    ' found its sheet -- offset this content ID back to the first sheet equivalent
                    lContentID = lContentID - a_lSheetRanges(lSheetIndexCheck, 3)
                    Exit For
                End If
            Next
        
            Set cxnPic = XML_SelectSingleNode(cxnPictures, "pp[@id=""" & Format(lContentID) & """]")
            If Not (cxnPic Is Nothing) Then
                fX = Val(XML_GetAttribute(cxnPic, "x"))
                fY = Val(XML_GetAttribute(cxnPic, "y"))
                Pictures_GetXY = True
                Exit Function
            End If
        End If
    End If
End Function
Attribute VB_Name = "RibbonToolsText2007"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' RibbonToolsText2007:                                                      '
' ~~~~~~~~~~~~~~~~~~~~                                                      '
'   Code for Word 2007 text fill features found on the "classic" ribbon.    '
'==========================================================================='
Option Explicit

Private Type Text_FieldProperties
    Name As String
    PointSize As Single
    Colour As Long
    Bold As Long
    Italic As Long
    Underline As Long
    Align As Long
End Type

Global Const AT_AUTOFILL_TAG_INVALID = vbTab & vbCr
Global Const AT_FORMAT_MIXEDFONTCOLOUR = "MixedFontColour"
Global Const AT_FORMAT_FONT = "FONT"
Global Const AT_FORMAT_ALIGN = "ALIGN"

'== Text_EditFieldText =============================================================
'
' Implements the "Edit Text" feature on the ribbon.
'
Public Sub Text_EditFieldText(doc As Document, lFillGroup As Long)
    
    Dim rsCurrent As RibbonSection2007, lPanelCount As Long
    Dim bSame As Boolean
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    
    If Text_FillDialogInit(rsCurrent, lFillGroup) Then
        'rsCurrent.HideModelessUI True
        frmTextFill2007.Show
    
        If frmTextFill2007.Tag = DLG_OK Then
            Application.ScreenRefresh
            Text_ExecuteFill rsCurrent, lFillGroup
        End If
    Else
        UI2007_MsgBox "MissingPlaceholders"
    End If
End Sub

'== Text_FormatPanels ==============================================================
'
' Implements the "Format Text" feature on the ribbon.
'
Public Sub Text_FormatPanels(doc As Document, lFillGroup As Long)
    
    Dim rsCurrent As RibbonSection2007, cxnFillGroup As CustomXMLNode
    Dim lXmlField As Long, lXmlFieldCount As Long, sTag As String
    Dim sUITitle As String, shpSelected As Shape, rngSelection As Range
    Dim bMadeFormattingChanges As Boolean
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    Set cxnFillGroup = rsCurrent.FeatureNode(FEATURE_FILL, lFillGroup)
    
    lXmlFieldCount = Text_FieldCount(cxnFillGroup)
    If lXmlFieldCount = 1 Then
        frmFormatPalette2007.HideFieldList
    Else
        With frmFormatPalette2007.lstSelectField
            .Clear
            .AddItem "<all text>"
    
            For lXmlField = 1 To lXmlFieldCount
                .AddItem Text_FieldName(cxnFillGroup, lXmlField)
            Next lXmlField
        End With
    End If

    sUITitle = UI2007_GetLocalString(CTRLS_DIALOG, "frmFormatPalette2007", _
                             "CaptionFormatText" & lFillGroup, _
                             STRING_LABEL, APPLY_SYMBOLS_NONE)

    frmFormatPalette2007.FinishInit sUITitle, doc, lFillGroup
    
    ' deselect shape/text ranges to prevent confusion (otherwise people might
    ' expect the formatting palette to update the selected shape/text!)
    
    Set shpSelected = Word_FirstSelectedShape(Selection)
    If Not (shpSelected Is Nothing) Then
       ' collapse shape selection
        Set rngSelection = shpSelected.Anchor
        rngSelection.Collapse wdCollapseStart
        rngSelection.Select
    ElseIf Selection.Range.End > Selection.Range.Start + 1 Then
        Set rngSelection = Selection.Range
        rngSelection.Collapse
        rngSelection.Select
    End If
    
    Do
        Application.ScreenRefresh
        frmFormatPalette2007.Show
        sTag = frmFormatPalette2007.Tag
        frmFormatPalette2007.Tag = ""
        
        If Not (sTag = DLG_OK) Then
            Dim lSelectedField As Long, bMixedFontColour As Boolean, lAlign As Long
            
            lSelectedField = frmFormatPalette2007.SelectedField()
                
            If sTag = AT_FORMAT_FONT Then
                bMixedFontColour = (frmFormatPalette2007.cmdFormatFont.Tag = AT_FORMAT_MIXEDFONTCOLOUR)
                Text_FormatFieldFont doc, lFillGroup, lSelectedField, bMixedFontColour
                frmFormatPalette2007.RefreshPalette
                bMadeFormattingChanges = True
            
            ElseIf InStr(sTag, AT_FORMAT_ALIGN) = 1 Then
                lAlign = Val(Mid(sTag, Len(AT_FORMAT_ALIGN) + 1))
                Text_FormatFieldAlignment doc, lFillGroup, lSelectedField, lAlign
                frmFormatPalette2007.UpdateAlignment lAlign
            End If
        End If
    Loop Until sTag = DLG_OK
    
    rsCurrent.SetPressed RIBBON_TEXTFORMAT & lFillGroup, False
    If bMadeFormattingChanges Then
        Word_ClearUndoStack doc
    End If
End Sub

'== Text_FormatFieldFont ===========================================================
'
' Handles the Format Font button within the Format Palette.
'
Private Sub Text_FormatFieldFont(doc As Document, lFillGroup As Long, _
                                 ByVal lFormatField As Long, _
                                 bMixedFontColour As Boolean)

    Dim rsCurrent As RibbonSection2007, cxnFillGroup As CustomXMLNode
    Dim rng As Range, rngSavedSel As Range, dlgFormatFont As Dialog
    Dim lFieldCount As Long, lFieldIndex As Long, bMadeSelection As Boolean
    Dim shpTextboxParent As Shape, structFieldProps As Text_FieldProperties
    Dim bContinue As Boolean
    Const WORD_DLG_OK = -1
    
    On Error GoTo Err_FormatFieldFont
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    Set cxnFillGroup = rsCurrent.FeatureNode(FEATURE_FILL, lFillGroup)

    UI_ScreenUpdating False
    Set rngSavedSel = doc.ActiveWindow.Selection.Range
    Set dlgFormatFont = Nothing

    If lFormatField = 0 Then
        ' Format All Fields
        ''''''''''''''''''''
        lFieldCount = Text_FieldCount(cxnFillGroup)
        If bMixedFontColour Then
            ' if we're dealing with mixed font colours, Format Font on its own would
            ' show the wrong font colour ("Automatic" for any mixed selection, even
            ' if it's Automatic isn't used anywhere)
            
            ' so we select the first field to get its font colour, then deal with the
            ' other properties...
            
            Set rng = Text_GetFieldRange(doc, cxnFillGroup, 1, 0, 0)
            If Not rng Is Nothing Then
                If Text_FieldFontProperties(doc, cxnFillGroup, 0, structFieldProps) Then
                    rng.Select
                    bMadeSelection = True
                    
                    Set dlgFormatFont = Application.Dialogs(wdDialogFormatFont)
                                        
                    ' now clear out any font properties from Format Font that are mixed
                    ' across the entire selection
                    If structFieldProps.Name = "" Then
                        dlgFormatFont.Font = ""
                    End If
                    
                    If structFieldProps.PointSize = WORD_MIXED Then
                        dlgFormatFont.Points = ""
                    End If
                    
                    If structFieldProps.Bold = WORD_MIXED Then
                        dlgFormatFont.Bold = -1
                    End If
                    
                    If structFieldProps.Italic = WORD_MIXED Then
                        dlgFormatFont.Italic = -1
                    End If
                    
                    If structFieldProps.Underline = WORD_MIXED Then
                        dlgFormatFont.Underline = -1
                    End If
                End If
            End If
        Else
            ' if we're not dealing with mixed font colours, select all the different
            ' fields (in text boxes) at once; this automatically sets up Format Font
            ' to match the current selection
        
            For lFieldIndex = 1 To lFieldCount
                Set rng = Text_GetFieldRange(doc, cxnFillGroup, lFieldIndex, 0, 0)
                If Not (rng Is Nothing) Then
                    If rng.Bookmarks.Count > 0 Then
                    
                        Set shpTextboxParent = Word_ParentTextBox(rng, rng.Bookmarks(1).Name)
                        If shpTextboxParent Is Nothing Then
                            Set shpTextboxParent = Word_ParentTextBox(rng, "")
                        End If
                        
                        If Not shpTextboxParent Is Nothing Then
                            ' on the first field, replace existing selection; on subsequent
                            ' fields, add to selection
                            shpTextboxParent.Select (Not bMadeSelection)
                            bMadeSelection = True
                        End If
                    End If
                End If
            Next lFieldIndex
        End If
        
        If Not bMadeSelection Then
            ' haven't found a valid range yet; use field 1 as a last-ditch effort
            Set rng = Text_GetFieldRange(doc, cxnFillGroup, 1, 0, 0)
            If rng Is Nothing Then
                UI_ScreenUpdating True
                Exit Sub
            Else
                rng.Select
            End If
        End If
    Else
        ' Format a Single Field
        ''''''''''''''''''''''''
        Set rng = Text_GetFieldRange(doc, cxnFillGroup, lFormatField, 0, 0)
        If rng Is Nothing Then
            UI_ScreenUpdating True
            Exit Sub
        Else
            rng.Select
            bMadeSelection = True
        End If
    End If
        
    If dlgFormatFont Is Nothing Then
        ' if we haven't initialized the dialog yet, do so now
        Set dlgFormatFont = Application.Dialogs(wdDialogFormatFont)
    End If
    
    UI_ScreenUpdating True  ' scr 5252 -- prevent refresh problems if user moves dialog box
    If dlgFormatFont.Display() = WORD_DLG_OK Then
        Application.ScreenRefresh
        UI_ScreenUpdating False
        
        UI2007_ShowProgress "UpdatingDoc", True
        
        If lFormatField = 0 Then
            For lFieldIndex = 1 To lFieldCount
                UI_PushProgressSubRange (lFieldIndex - 1) / lFieldCount, lFieldIndex / lFieldCount
                bContinue = Text_SetFieldProperty(doc, cxnFillGroup, lFieldIndex, FormatFont:=dlgFormatFont)
                
                If (Not bContinue) Or (Not UI_UpdateProgress(1)) Then
                    ' user cancelled
                    Exit For
                End If
                UI_PopProgressSubRange
            Next lFieldIndex
        Else
            Text_SetFieldProperty doc, cxnFillGroup, lFormatField, FormatFont:=dlgFormatFont
        End If
        
        UI_HideProgress
    End If
    rngSavedSel.Select
    UI_ScreenUpdating True
    Exit Sub

Err_FormatFieldFont:
    UI_ScreenUpdating True
    UI_HideProgress
    UI2007_MsgBox "FatalError", vbCritical, Err.Number
End Sub

'== Text_AddSheet ==================================================================
'
' Implements the "Add Sheet" feature on the ribbon.
'
Public Sub Text_AddSheet(doc As Document)

    Dim rngSheet As Range, lTblCount As Long, tblStart As Table, tblEnd As Table
    Dim rsCurrent As RibbonSection2007, cxnAddSheet As CustomXMLNode
    Dim lStartPos As Long, rngBreak As Range
    Dim lMinContentID As Long, lMaxContentID As Long, lContentIDShift As Long
    Dim bkmk As Bookmark, shp As Shape, collAdjust As Collection
    Dim sFirstBkmk As String, lFirstBkmkStart As Long, lFirstBkmkEnd As Long
    Dim fProgressIncrement As Single, bCancelled As Boolean
    
    If doc.Tables.Count = 0 Then
        UI2007_MsgBox "MissingTable"
    End If
        
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    Set cxnAddSheet = rsCurrent.FeatureNode(FEATURE_ADDSHEET)
    
    Set tblEnd = doc.Tables(doc.Tables.Count)
    lTblCount = XML_GetAttribute(cxnAddSheet, "tables", "1")
    If lTblCount > 1 Then
        lTblCount = Math_Min(doc.Tables.Count, lTblCount)
        Set tblStart = doc.Tables(doc.Tables.Count - lTblCount + 1)
    Else
        Set tblStart = tblEnd
    End If
    Set rngSheet = doc.Range(tblStart.Range.Start, tblEnd.Range.End)
    
    UI_ScreenUpdating False
    UI2007_ShowProgress "UpdatingDoc", True
    bCancelled = False
    
    lStartPos = rngSheet.Start
    lMaxContentID = WordPort_MaxContentID(doc)
    
    ' copy last table to the clipboard
    rngSheet.Copy
    
    ' rename shapes and bookmarks (if any) to make last table
    If lMaxContentID > 0 Then
        lMinContentID = WordPort_MinContentID(rngSheet)
        lContentIDShift = lMaxContentID - lMinContentID + 1
        
        Text_SaveAddedSheetRange lMinContentID, lMaxContentID, lContentIDShift
        
        Set collAdjust = New Collection
        UI_PushProgressSubRange 0, 0.02
        fProgressIncrement = 1 / Math_Max(rngSheet.Bookmarks.Count, 1)
        For Each bkmk In rngSheet.Bookmarks
            collAdjust.Add bkmk
            If Not UI_IncrementProgress(fProgressIncrement) Then
                bCancelled = True
                Exit For
            End If
        Next
        UI_PopProgressSubRange
        
        If Not bCancelled Then
            UI_PushProgressSubRange 0.02, 0.08
            For Each bkmk In collAdjust
                WordPort_ShiftBookmarkContentID bkmk, lContentIDShift
                If Not UI_IncrementProgress(fProgressIncrement) Then
                    bCancelled = True
                    Exit For
                End If
            Next
            UI_PopProgressSubRange
        End If
        
        If (Not bCancelled) And Word_HasShapeRange(rngSheet) Then
            UI_PushProgressSubRange 0.08, 0.16
            fProgressIncrement = 1 / Math_Max(rngSheet.ShapeRange.Count, 1)
            Set collAdjust = New Collection
            For Each shp In rngSheet.ShapeRange
                collAdjust.Add shp
                If Not UI_IncrementProgress(fProgressIncrement) Then
                    bCancelled = True
                    Exit For
                End If
            Next
            UI_PopProgressSubRange
            
            If Not bCancelled Then
                UI_PushProgressSubRange 0.16, 0.9
                For Each shp In collAdjust
                    WordPort_ShiftShapeContentID shp, lContentIDShift
                    If Not UI_IncrementProgress(fProgressIncrement) Then
                        bCancelled = True
                        Exit For
                    End If
                Next
                UI_PopProgressSubRange
            End If
        End If
    End If
    
    If Not bCancelled Then
        bCancelled = Not UI_UpdateProgress(0.9)
    End If
    
    If Not bCancelled Then
        ' track any bookmarks that might get expanded when we insert
        ' our page break...
        If doc.Range(lStartPos, lStartPos).Bookmarks.Count > 0 Then
            Set bkmk = doc.Range(lStartPos, lStartPos).Bookmarks(1)
            sFirstBkmk = bkmk.Name
            lFirstBkmkStart = bkmk.Range.Start - rngSheet.Start
            lFirstBkmkEnd = bkmk.Range.End - rngSheet.Start
            bkmk.Delete
        Else
            sFirstBkmk = ""
        End If
        
        ' add page break
        doc.Range(lStartPos, lStartPos).InsertBreak wdPageBreak
        bCancelled = Not UI_UpdateProgress(0.92)
    End If
    
    If Not bCancelled Then
        ' format page break so it doesn't trigger an extra page itself
        Set rngSheet = doc.Range(tblStart.Range.Start, tblEnd.Range.End)
        Set rngBreak = doc.Range(lStartPos, rngSheet.Start)
        rngBreak.Font.Size = 1
        rngBreak.ParagraphFormat.LineSpacingRule = wdLineSpaceSingle
        rngBreak.ParagraphFormat.SpaceAfter = 0
        rngBreak.ParagraphFormat.SpaceBefore = 0
        
        ' fix expanded bookmarks
        If sFirstBkmk <> "" Then
            doc.Bookmarks.Add sFirstBkmk, doc.Range(rngSheet.Start + lFirstBkmkStart, _
                                                     rngSheet.Start + lFirstBkmkEnd)
        End If
    
        bCancelled = Not UI_UpdateProgress(0.95)
    End If
    
    If Not bCancelled Then
        doc.Range(lStartPos, lStartPos).Paste
        UI_UpdateProgress 1 ' can't cancel now!
        Word_ClearUndoStack doc
    End If
    
    doc.Range(doc.Range.End - 1, doc.Range.End).Copy    ' prevent large clipboard warning
    UI_HideProgress
    UI_ScreenUpdating True
    
    ' refresh after large scroll events to prevent redraw bugs!
    Word_SetRefreshOnScroll doc
End Sub

'== Text_CollapseMinimumIndents ====================================================
'
' Used by Pictures_RemoveAll to update paragraph margins or text box sizes so that
' text can occupy the space vacated by removed pictures.
'
Public Sub Text_CollapseMinimumIndents(doc As Document, fPicXFirst As Single, fPicYFirst As Single, _
                                       fPicWidthFirst As Single, fPicHeightFirst As Single)
    
    Dim rsCurrent As RibbonSection2007
    Dim cxnFillGroup1 As CustomXMLNode, cxnFillGroup2 As CustomXMLNode
    Dim fMinLeft1 As Single, fMinLeft2 As Single, fMinLeftAll As Single
    Dim fMinRight1 As Single, fMinRight2 As Single, fMinRightAll As Single
    Dim bIsTextbox As Boolean, bContinue As Boolean
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    
    Set cxnFillGroup1 = rsCurrent.FeatureNode(FEATURE_FILL, 1)
    If cxnFillGroup1 Is Nothing Then
        Exit Sub
    Else
        Text_GetMinimumIndents doc, cxnFillGroup1, fMinLeft1, fMinRight1, bIsTextbox
    End If
    
    Set cxnFillGroup2 = rsCurrent.FeatureNode(FEATURE_FILL, 2)
    If bIsTextbox Then
        ' textbox text: the logic for the two groups is exactly the same:
        ' compare textbox position to picture position and shift text boxes
        ' into the space held by the picture
    
        Do
            If Not (cxnFillGroup2 Is Nothing) Then
                ' two groups, doing the first one now
                UI_PushProgressSubRange 0, 0.5
            End If

            If fPicXFirst > fMinRight1 Then
                ' right-side picture
                bContinue = Text_ExpandFieldTextboxes(doc, cxnFillGroup1, 0, _
                                                      fPicXFirst + fPicWidthFirst - fMinRight1)
            ElseIf fPicXFirst + fPicWidthFirst < fMinLeft1 Then
                ' left-side picture
                bContinue = Text_ExpandFieldTextboxes(doc, cxnFillGroup1, _
                                                      fMinLeft1 - fPicXFirst, 0)
            End If
            If cxnFillGroup2 Is Nothing Then
                ' done with both groups
                bContinue = False
            ElseIf bContinue Then
                UI_PopProgressSubRange
                UI_PushProgressSubRange 0.5, 1
                Text_GetMinimumIndents doc, cxnFillGroup2, fMinLeft1, fMinRight1, bIsTextbox
                ' we use MinLeft/Right1, not 2, because we're handling each separately
                ' (note also that bIsTextbox should always be True here)
                
                ' loop through again, and break out of loop next time
                Set cxnFillGroup1 = cxnFillGroup2
                Set cxnFillGroup2 = Nothing
            End If
        Loop While bContinue
    ElseIf cxnFillGroup2 Is Nothing Then
        ' plain text: only the one group
        ' collapse the larger indent
        
        If fMinLeft1 >= fMinRight1 And fMinLeft1 > 0 Then
            Text_CollapseFieldIndents doc, cxnFillGroup1, fMinLeft1, 0
        ElseIf fMinRight1 > 0 Then
            Text_CollapseFieldIndents doc, cxnFillGroup1, 0, fMinRight1
        End If
    Else
        ' plain text: two text groups
        ' we need to find the minimum indent on each side across both groups
        ' and then collapse the side with the larger minimum indent
        
        ' first get the second group's indents too
        Text_GetMinimumIndents doc, cxnFillGroup2, fMinLeft2, fMinRight2, bIsTextbox
    
        ' now take the smallest non-zero indent on each side
        fMinLeftAll = Math_MinPositive(fMinLeft1, fMinLeft2)
        fMinRightAll = Math_MinPositive(fMinRight1, fMinRight2)
    
        ' now take the largest of the smallest indents!
        If fMinLeftAll >= fMinRightAll And fMinLeftAll > 0 Then
        
            UI_PushProgressSubRange 0, 0.5
            If Text_CollapseFieldIndents(doc, cxnFillGroup1, Math_Min(fMinLeftAll, fMinLeft1), 0) Then
                UI_PopProgressSubRange
                UI_PushProgressSubRange 0.5, 1
                Text_CollapseFieldIndents doc, cxnFillGroup2, Math_Min(fMinLeftAll, fMinLeft2), 0
            End If
            UI_PopProgressSubRange
        
        ElseIf fMinRightAll > 0 Then
            
            UI_PushProgressSubRange 0, 0.5
            If Text_CollapseFieldIndents(doc, cxnFillGroup1, 0, Math_Min(fMinRightAll, fMinRight1)) Then
                UI_PopProgressSubRange
                UI_PushProgressSubRange 0.5, 1
                Text_CollapseFieldIndents doc, cxnFillGroup2, 0, Math_Min(fMinRightAll, fMinRight2)
            End If
            UI_PopProgressSubRange
        End If
    End If
End Sub

'===================================================================================
' Text helper functions (general and Edit Text)
'===================================================================================

'== Text_FillDialogInit ============================================================
'
' Creates the Fill dialog for Edit Text.
'
Private Function Text_FillDialogInit(rsCurrent As RibbonSection2007, _
                                lFillGroup As Long) As Boolean
                                
    Dim docTemplate As Word.Document, cxnFillGroup As CustomXMLNode
    Dim bSetLabels As Boolean, lXmlField As Long, lXmlFieldCount As Long
    Dim lDlgFieldIndex As Long, fWidthFactor As Single, lLineCount As Long
    Dim sFieldText As String, sUITitle As String
    
    Set docTemplate = rsCurrent.Document()
    Set cxnFillGroup = rsCurrent.FeatureNode(FEATURE_FILL, lFillGroup)
                                
    frmTextFill2007.StartInit rsCurrent.SectionIndex(), lFillGroup
    bSetLabels = Not frmTextFill2007.IsInitialized()
    lXmlFieldCount = Text_FieldCount(cxnFillGroup)
    docTemplate.ActiveWindow.View.ShowBookmarks = False
                                
    Do While lXmlField < lXmlFieldCount And lDlgFieldIndex < frmTextFill2007.FieldLimit()
        lXmlField = lXmlField + 1
        If Text_GetFieldValue(docTemplate, cxnFillGroup, lXmlField, sFieldText, _
                         fWidthFactor, lLineCount) Then
            lDlgFieldIndex = lDlgFieldIndex + 1
            
            If bSetLabels Then
                ' when initializing, we also need to set the label caption
                ' (this must be called before SetTextValue)
                frmTextFill2007.SetTextLabel lDlgFieldIndex, _
                                             Text_FieldName(cxnFillGroup, lXmlField)
            End If
            frmTextFill2007.SetTextValue lDlgFieldIndex, lXmlField, sFieldText, _
                                         lLineCount, fWidthFactor
        End If
    Loop
    
    If lDlgFieldIndex > 0 Then
        ' we succeed if we find a bookmark for at least one field
        
        sUITitle = rsCurrent.SectionAttribute("brand")
        If sUITitle = "" Then
            sUITitle = UI2007_GetLocalString(CTRLS_DIALOG, "frmTextFill2007", _
                                             "lblTitle", STRING_LABEL, _
                                             APPLY_SYMBOLS_NONE)
        End If
        
        frmTextFill2007.FinishInit sUITitle, rsCurrent.SectionIndex(), lFillGroup
        UI_SelectAndFocusFormTextBox frmTextFill2007.txtField1
        Text_FillDialogInit = True
    Else
        frmTextFill2007.UnInit
        Text_FillDialogInit = False
    End If
End Function

'== Text_ExecuteFill ===============================================================
'
' Performs the "fill" operation once a user has OK'd Edit Text.
'
Private Function Text_ExecuteFill(rsCurrent As RibbonSection2007, _
                                  lFillGroup As Long) As Boolean
    
    Dim docTemplate As Word.Document, cxnFillGroup As CustomXMLNode
    Dim lField As Long, lFieldCount As Long, sFieldText As String
    Dim fProgressIncrement As Single, lChildIndex As Long
    Dim bContinue As Boolean
    
    Set docTemplate = rsCurrent.Document()
    Set cxnFillGroup = rsCurrent.FeatureNode(FEATURE_FILL, lFillGroup)
    lFieldCount = frmTextFill2007.FieldCount()
    
    If lFieldCount > 0 Then
        UI_ScreenUpdating False
        UI2007_ShowProgress "UpdatingDoc", True
        
        Text_ExecuteFill = True  ' assume success
        fProgressIncrement = 1 / lFieldCount
        
        For lField = 1 To lFieldCount
        
            UI_PushProgressSubRange fProgressIncrement * (lField - 1), _
                                fProgressIncrement * lField
            
            ' GetTextValue _sets_ lChildIndex
            sFieldText = frmTextFill2007.GetTextValue(lField, lChildIndex)
            ' update the document for this field
            bContinue = Text_SetFieldValue(docTemplate, cxnFillGroup, lChildIndex, sFieldText)
            
            If (Not bContinue) Or (Not UI_UpdateProgress(1)) Then
                Exit For
            End If
            UI_PopProgressSubRange
        Next lField
        
        UI_HideProgress
        UI_ScreenUpdating True
        ' refresh after 2 seconds to prevent disappearing parts of pictures!
        Word_SetDelayedRefresh
    End If
End Function

'== Text_GetFieldRange =============================================================
'
' Returns a range for the location of a field in the first panel.
'
Private Function Text_GetFieldRange(docTemplate As Document, _
                                    cxnFillGroup As CustomXMLNode, _
                                    lFieldIndex As Long, _
                                    ByRef fWidth As Single, _
                                    ByRef fHeight As Single) As Range
    
    Dim bkmk As Bookmark
    Dim sContentIDBaseTarget As String, sMergeFieldIDTarget As String
    Dim lMinimumContentID As Long, bkmkMinimum As Bookmark
    Dim fBkmkMinimumWidth As Single, fBkmkMinimumHeight As Single
    Dim sObjectType As String, sContentIDBase As String, sMergeFieldID As String
    Dim lContentID As Long, fTextBoxWidth As Single, fTextBoxHeight As Single
    Dim sPanel1Bkmk As String
    
    fWidth = 0
    fHeight = 0
    Set bkmkMinimum = Nothing
    
    If Text_GetContentIDs(cxnFillGroup, lFieldIndex, sContentIDBaseTarget, _
                          sMergeFieldIDTarget) Then
        ' use panel 1 shortcut to go directly to our bookmark
        sPanel1Bkmk = Text_Panel1Bkmk(cxnFillGroup, lFieldIndex)
        If sPanel1Bkmk <> "" Then
            If docTemplate.Bookmarks.Exists(sPanel1Bkmk) Then
                Set bkmkMinimum = docTemplate.Bookmarks(sPanel1Bkmk)
            
                If WordPort_DecodeName(bkmkMinimum.Name, sObjectType, 0, sContentIDBase, _
                                      lContentID, fTextBoxWidth, fTextBoxHeight, sMergeFieldID) Then
            
                    fBkmkMinimumWidth = fTextBoxWidth
                    fBkmkMinimumHeight = fTextBoxHeight
                End If
            End If
        End If
    
        If bkmkMinimum Is Nothing Then
            ' didn't find via panel 1 shortcut; search all bookmarks
            
            For Each bkmk In docTemplate.Bookmarks
                If WordPort_DecodeName(bkmk.Name, sObjectType, 0, sContentIDBase, _
                                      lContentID, fTextBoxWidth, fTextBoxHeight, sMergeFieldID) Then
                                      
                    If sContentIDBase = sContentIDBaseTarget _
                     And sMergeFieldID = sMergeFieldIDTarget Then
                        ' if the bookmark is for the correct field...
                        
                        If (lMinimumContentID = 0 Or lContentID < lMinimumContentID) Then
                            ' we're looking for the first instance of the field, which
                            ' is the bookmark with the lowest content ID; we'll use this
                            ' to extract the value to show in the dialog box
                            lMinimumContentID = lContentID
                            Set bkmkMinimum = bkmk
                            fBkmkMinimumWidth = fTextBoxWidth
                            fBkmkMinimumHeight = fTextBoxHeight
                        End If
                    End If
                End If
            Next
        End If
        
        If bkmkMinimum Is Nothing Then
            ' bookmarks have been deleted!
            Set Text_GetFieldRange = Nothing
        Else
            fWidth = fBkmkMinimumWidth
            fHeight = fBkmkMinimumHeight
            Set Text_GetFieldRange = Word_AdjustedRange(bkmkMinimum)
        End If
    Else
        Set Text_GetFieldRange = Nothing
    End If
End Function

'== Text_GetFieldValue =============================================================
'
' Returns the current value (based on the text in the doc) for a specified field.
'
Private Function Text_GetFieldValue(docTemplate As Document, _
                                    cxnFillGroup As CustomXMLNode, _
                                    lFieldIndex As Long, _
                                    ByRef sFieldValue As String, _
                                    ByRef fWidthFactor As Single, _
                                    ByRef lLineCount As Long) As Boolean
    
    Dim rng As Range, fWidth As Single, fHeight As Single
    
    sFieldValue = ""
    fWidthFactor = 0
    lLineCount = 1
    
    Set rng = Text_GetFieldRange(docTemplate, cxnFillGroup, lFieldIndex, fWidth, fHeight)
    If rng Is Nothing Then
        Text_GetFieldValue = False
    Else
        sFieldValue = rng.Text
        rng.Collapse wdCollapseStart
        
        If InStr(sFieldValue, vbCr) > 0 Then
            lLineCount = String_Count(sFieldValue, vbCr) + 1
        Else
            ' determine if more than one line fits at the current text size
            If rng.Font.Size * 2.4 < fHeight Then
                lLineCount = 2
            End If
        End If
        
        If fWidth > 0 Then
            fWidthFactor = (fWidth / rng.Font.Size)
        End If
        
        Text_GetFieldValue = True
    End If
End Function

'== Text_SetFieldValue =============================================================
'
' Updates all panels in the document with new text for a specified field.
'
Private Function Text_SetFieldValue(docTemplate As Document, cxnFillGroup As CustomXMLNode, _
                                    lFieldIndex As Long, sFieldText As String) As Boolean
    
    Dim bkmk As Bookmark
    Dim sContentIDBaseTarget As String, sMergeFieldIDTarget As String
    Dim sObjectType As String, sContentIDBase As String, sMergeFieldID As String
    Dim lContentID As Long, sBkmkName As String
    Dim qscBookmarks As QuickStringCollection, fProgressIncrement As Single
    
    Text_SetFieldValue = True
    
    If Text_GetContentIDs(cxnFillGroup, lFieldIndex, sContentIDBaseTarget, _
                          sMergeFieldIDTarget) Then
        Set qscBookmarks = New QuickStringCollection
        
        For Each bkmk In docTemplate.Bookmarks
            If WordPort_DecodeName(bkmk.Name, sObjectType, 0, sContentIDBase, _
                                  lContentID, 0, 0, sMergeFieldID) Then
                                  
                If sContentIDBase = sContentIDBaseTarget _
                 And sMergeFieldID = sMergeFieldIDTarget Then
                    ' yes, it's the right field
                    qscBookmarks.Add bkmk.Name
                End If
            End If
        Next
        
        If qscBookmarks.ItemCount() > 0 Then
            fProgressIncrement = 1 / qscBookmarks.ItemCount()
            Do
                If Not UI_IncrementProgress(fProgressIncrement) Then
                    Text_SetFieldValue = False
                    Exit Do
                End If
                
                sBkmkName = qscBookmarks.RemoveNext()
                Word_SetBookmarkText docTemplate, sBkmkName, sFieldText
            Loop Until qscBookmarks.ItemCount() = 0
        End If
    End If
End Function

'== Text_SetFieldProperty ==========================================================
'
' Updates all panels in the document with new formatting for a specified field.
'
Private Function Text_SetFieldProperty(docTemplate As Document, _
                                       cxnFillGroup As CustomXMLNode, _
                                       lFieldIndex As Long, _
                                       Optional Align As Long = WORD_MIXED, _
                                       Optional LeftIndentAdjust As Single = 0, _
                                       Optional RightIndentAdjust As Single = 0, _
                                       Optional FormatFont As Dialog = Nothing _
                                       ) As Boolean
    
    Dim bkmk As Bookmark, lBkmkCount As Long, lBkmkIndex As Long, rng As Range
    Dim sContentIDBaseTarget As String, sMergeFieldIDTarget As String
    Dim sObjectType As String, sContentIDBase As String, sMergeFieldID As String
    
    Text_SetFieldProperty = True
    
    If Text_GetContentIDs(cxnFillGroup, lFieldIndex, sContentIDBaseTarget, _
                          sMergeFieldIDTarget) Then
    
        lBkmkCount = docTemplate.Bookmarks.Count
        lBkmkIndex = 0
        For Each bkmk In docTemplate.Bookmarks
            If WordPort_DecodeName(bkmk.Name, sObjectType, 0, sContentIDBase, _
                                  0, 0, 0, sMergeFieldID) Then
                                  
                If sContentIDBase = sContentIDBaseTarget _
                 And sMergeFieldID = sMergeFieldIDTarget Then
                    ' yes, it's the right field
                    Set rng = Word_AdjustedRange(bkmk)
                    If Not FormatFont Is Nothing Then
                        rng.Select
                        FormatFont.Execute
                    End If
                    With rng.ParagraphFormat
                        If Align <> WORD_MIXED Then
                            .Alignment = Align
                        End If
                        If LeftIndentAdjust <> 0 Then
                            .LeftIndent = .LeftIndent + LeftIndentAdjust
                        End If
                        If RightIndentAdjust <> 0 Then
                            .RightIndent = .RightIndent + RightIndentAdjust
                        End If
                    End With
                End If
            End If
            
            lBkmkIndex = lBkmkIndex + 1
            If Not UI_UpdateProgress(lBkmkIndex / lBkmkCount) Then
                Text_SetFieldProperty = False
                Exit For
            End If
        Next
    End If
End Function

'== Text_GetContentIDs =============================================================
'
' Used to untangle field and merge fields IDs from companion XML info.
'
Private Function Text_GetContentIDs(cxnFillGroup As CustomXMLNode, lFieldIndex As Long, _
                                    ByRef sContentIDBaseTarget As String, _
                                    ByRef sMergeFieldIDTarget As String) As Boolean
                                    
    Dim cxnFillField As CustomXMLNode, sMergeParent As String
    
    sContentIDBaseTarget = ""
    sMergeFieldIDTarget = ""
    
    Set cxnFillField = Text_FieldNode(cxnFillGroup, lFieldIndex)
    If cxnFillField Is Nothing Then
        Text_GetContentIDs = False
    Else
        sContentIDBaseTarget = XML_GetAttribute(cxnFillField, "id")
        sMergeParent = XML_GetAttribute(cxnFillField, "parent")
        
        If sMergeParent <> "" Then
            Set cxnFillField = Text_FieldNodeByContentID(cxnFillGroup, sMergeParent)
            
            If Not (cxnFillField Is Nothing) Then
                sMergeFieldIDTarget = sContentIDBaseTarget
                sContentIDBaseTarget = XML_GetAttribute(cxnFillField, "id")
            End If
        End If
        Text_GetContentIDs = True
    End If
End Function

'== Text_FieldNode =================================================================
'
' Retrieves companion XML info for a given text field.
'
Private Function Text_FieldNode(cxnFillGroup As CustomXMLNode, _
                                ByVal lFieldIndex As Long) As CustomXMLNode
    Dim cxnsFields As CustomXMLNodes
    Set cxnsFields = XML_SelectNodes(cxnFillGroup, "content[not(@childCount)]")
    
    If cxnsFields Is Nothing Then
        ' this is a fallback case; shouldn't happen
        If cxnFillGroup.ChildNodes.Count < lFieldIndex Then
            Set Text_FieldNode = Nothing
        Else
            Set Text_FieldNode = cxnFillGroup.ChildNodes(lFieldIndex)
        End If
    Else
        If lFieldIndex > cxnsFields.Count Then
            Set Text_FieldNode = Nothing
        Else
            Set Text_FieldNode = cxnsFields(lFieldIndex)
        End If
    End If
End Function

'== Text_FieldNodeByContentID ======================================================
'
' Retrieves companion XML info for a text field identified by its content ID.
'
Private Function Text_FieldNodeByContentID(cxnFillGroup As CustomXMLNode, _
                                           ByVal sContentID As String) As CustomXMLNode
    
    Set Text_FieldNodeByContentID = XML_SelectSingleNode(cxnFillGroup, "content[@id=""" + sContentID + """]")
End Function

'== Text_FieldCount ================================================================
'
' Returns a total number of fields in this fill group (counting merge fields but not
' their parents, if any).
'
Private Function Text_FieldCount(cxnFillGroup As CustomXMLNode) As Long
    Dim cxnsFields As CustomXMLNodes
    Set cxnsFields = XML_SelectNodes(cxnFillGroup, "content[not(@childCount)]")
    
    If cxnsFields Is Nothing Then
        If cxnFillGroup Is Nothing Then
            Text_FieldCount = 0
        Else
            Text_FieldCount = cxnFillGroup.ChildNodes.Count
        End If
    Else
        Text_FieldCount = cxnsFields.Count
    End If
End Function

'== Text_FieldName =================================================================
'
' Returns the printable description of a field.
'
Private Function Text_FieldName(cxnFillGroup As CustomXMLNode, _
                                ByVal lFieldIndex As Long) As String

    Text_FieldName = XML_GetAttribute(Text_FieldNode(cxnFillGroup, lFieldIndex), _
                                      "description")
End Function

'== Text_Panel1ID ==================================================================
'
' Returns the name of this field's bookmark in the first panel.  Callers should
' beware that the bookmark may have been deleted.
'
Private Function Text_Panel1Bkmk(cxnFillGroup As CustomXMLNode, _
                                 ByVal lFieldIndex As Long) As String
    
    Text_Panel1Bkmk = XML_GetAttribute(Text_FieldNode(cxnFillGroup, lFieldIndex), _
                                       "panel1")
End Function

'===================================================================================
' Text helper functions (Format Text)
'===================================================================================

'== Text_FormatFieldAlignment ======================================================
'
' Handles the Alignment buttons within the Format Palette.
'
Private Sub Text_FormatFieldAlignment(doc As Document, lFillGroup As Long, _
                                      ByVal lFieldIndex As Long, lAlign As Long)

    Dim rsCurrent As RibbonSection2007, cxnFillGroup As CustomXMLNode
    Dim lThisFieldIndex As Long, lFieldCount As Long, bContinue As Boolean
    
    On Error GoTo Err_FormatFieldAlignment
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    Set cxnFillGroup = rsCurrent.FeatureNode(FEATURE_FILL, lFillGroup)

    If lAlign <> WORD_MIXED Then
        Application.ScreenRefresh   ' prevent remnants of Format Palette from appearing on screen
        UI_ScreenUpdating False
        UI2007_ShowProgress "UpdatingDoc", True
        
        If lFieldIndex = 0 Then
            lFieldCount = Text_FieldCount(cxnFillGroup)
            
            For lThisFieldIndex = 1 To lFieldCount
                UI_PushProgressSubRange (lThisFieldIndex - 1) / lFieldCount, lThisFieldIndex / lFieldCount
                bContinue = Text_SetFieldProperty(doc, cxnFillGroup, lThisFieldIndex, Align:=lAlign)
            
                If (Not bContinue) Or (Not UI_UpdateProgress(1)) Then
                    ' user cancelled
                    Exit For
                End If
                UI_PopProgressSubRange
            
            Next lThisFieldIndex
        Else
            Text_SetFieldProperty doc, cxnFillGroup, lFieldIndex, Align:=lAlign
        End If
        UI_HideProgress
        UI_ScreenUpdating True
    End If
    Exit Sub

Err_FormatFieldAlignment:
    UI_ScreenUpdating True
    UI_HideProgress
    UI2007_MsgBox "FatalError", vbCritical, Err.Number
End Sub

'== Text_FieldFontProperties =======================================================
'
' Gathers the current formatting properties for a specified field.
'
Private Function Text_FieldFontProperties(doc As Document, cxnFillGroup As CustomXMLNode, _
                                         ByVal lFieldIndex As Long, _
                                         ByRef structFieldProps As Text_FieldProperties _
                                         ) As Boolean
    
    Dim rng As Range, lFieldCount As Long
    Dim structFieldProps2 As Text_FieldProperties
    
    If lFieldIndex = 0 Then
        lFieldCount = Text_FieldCount(cxnFillGroup)
        
        Set rng = Text_GetFieldRange(doc, cxnFillGroup, 1, 0, 0)
        If rng Is Nothing Then
            Text_FieldFontProperties = False
            Exit Function
        End If
        
        Text_GetFieldPropertiesFromRange rng, structFieldProps
        
        For lFieldIndex = 2 To lFieldCount
            Set rng = Text_GetFieldRange(doc, cxnFillGroup, lFieldIndex, 0, 0)
            
            If Not rng Is Nothing Then
                Text_GetFieldPropertiesFromRange rng, structFieldProps2
                Text_MixFontProperties structFieldProps, structFieldProps2
                If Text_AllFieldPropertiesMixed(structFieldProps) Then
                    Exit For
                End If
            End If
        Next lFieldIndex
        
        Text_FieldFontProperties = True
        
    Else
        Set rng = Text_GetFieldRange(doc, cxnFillGroup, lFieldIndex, 0, 0)
        
        If Not rng Is Nothing Then
            Text_GetFieldPropertiesFromRange rng, structFieldProps
            Text_FieldFontProperties = True
        Else
            Text_FieldFontProperties = False
        End If
    End If
End Function

'== Text_FieldFontBanter ===========================================================
'
' Generates "banter" text (human readable description of formatting) for a given
' field.
'
Public Function Text_FieldFontBanter(doc As Document, lFillGroup As Long, _
                                     ByVal lFieldIndex As Long, _
                                     ByRef lFieldAlign As Long, _
                                     ByRef bMixedFontColour As Boolean) As String
    
    Dim structFieldProps As Text_FieldProperties
    Dim rsCurrent As RibbonSection2007, cxnFillGroup As CustomXMLNode
    
    ' default output
    Text_FieldFontBanter = ""
    lFieldAlign = WORD_MIXED
    bMixedFontColour = True
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    Set cxnFillGroup = rsCurrent.FeatureNode(FEATURE_FILL, lFillGroup)
    
    If Not cxnFillGroup Is Nothing Then
        If Text_FieldFontProperties(doc, cxnFillGroup, lFieldIndex, structFieldProps) Then
            Text_FieldFontBanter = Text_FontBanterFromProperties(structFieldProps)
            lFieldAlign = structFieldProps.Align
            bMixedFontColour = (structFieldProps.Colour = WORD_MIXED)
        End If
    End If
End Function

'== Text_GetFieldPropertiesFromRnage ===============================================
'
' Loads a Text_FieldProperties structure with the formatting details of a specified
' range.
'
Private Sub Text_GetFieldPropertiesFromRange(rng As Range, ByRef structFieldProperties As Text_FieldProperties)
    With structFieldProperties
        If rng Is Nothing Then
            .Name = ""
            .PointSize = WORD_MIXED
            .Colour = WORD_MIXED
            .Bold = WORD_MIXED
            .Italic = WORD_MIXED
            .Underline = WORD_MIXED
            .Align = WORD_MIXED
        Else
            If Left(rng.Font.NameAscii, 1) = "+" And Left(rng.Font.Name, 1) <> "+" Then
                .Name = rng.Font.Name & " (" & rng.Font.NameAscii & ")"
            Else
                .Name = rng.Font.Name
            End If
            .PointSize = rng.Font.Size
            .Colour = rng.Font.Color
            .Bold = rng.Font.Bold
            .Italic = rng.Font.Italic
            .Underline = (rng.Font.Underline <> wdUnderlineNone)
            .Align = rng.ParagraphFormat.Alignment
        End If
    End With
End Sub

'== Text_MixFontProperties =========================================================
'
' Updates the first Text_FieldProperties structure to incorporate the formatting
' noted in the second Text_FieldProperties structure.
'
Private Sub Text_MixFontProperties(ByRef structFieldProperties As Text_FieldProperties, _
                                   structFieldPropertiesMixIn As Text_FieldProperties)
                                    
    With structFieldProperties
        If .Name <> structFieldPropertiesMixIn.Name Then
            .Name = ""
        End If
        If .PointSize <> structFieldPropertiesMixIn.PointSize Then
            .PointSize = WORD_MIXED
        End If
        If .Colour <> structFieldPropertiesMixIn.Colour Then
            .Colour = WORD_MIXED
        End If
        If .Bold <> structFieldPropertiesMixIn.Bold Then
            .Bold = WORD_MIXED
        End If
        If .Italic <> structFieldPropertiesMixIn.Italic Then
            .Italic = WORD_MIXED
        End If
        If .Underline <> structFieldPropertiesMixIn.Underline Then
            .Underline = WORD_MIXED
        End If
        If .Align <> structFieldPropertiesMixIn.Align Then
            .Align = WORD_MIXED
        End If
    End With
End Sub

'== Text_AllFieldPropertiesMixed ===================================================
'
' Returns True if all field properties are in a mixed state.  This is handy for
' knowing when there's no point looking at additional text ranges.
'
Private Function Text_AllFieldPropertiesMixed(ByRef structFieldProperties As Text_FieldProperties) As Boolean
    With structFieldProperties
        Text_AllFieldPropertiesMixed = (.Name = "") And (.PointSize = WORD_MIXED) And (.Colour = WORD_MIXED) _
                                       And (.Bold = WORD_MIXED) And (.Italic = WORD_MIXED) _
                                       And (.Underline = WORD_MIXED) And (.Align = WORD_MIXED)
    End With
End Function

'== Text_FontBanterFromProperties ==================================================
'
' Banter-generation engine
'
Private Function Text_FontBanterFromProperties(ByRef structFieldProperties As Text_FieldProperties) As String
    Dim sBanterText As String
    
    With structFieldProperties
        If .Name = "" And .PointSize = WORD_MIXED And .Colour = WORD_MIXED Then
            sBanterText = "(Mixed formatting)"
        Else
            If .Name = "" Then
                sBanterText = "(Multiple fonts)"
            Else
                sBanterText = .Name
            End If
            
            If .PointSize = WORD_MIXED Then
                sBanterText = sBanterText & ", (Multiple sizes)"
            Else
                sBanterText = sBanterText & ", " & Format(.PointSize, "0") & "pt"
            End If
            
            If .Colour = WORD_MIXED Then
                sBanterText = sBanterText & ", (Multiple colors)"
            Else
                sBanterText = sBanterText & ", Font color: "
                
                Select Case .Colour
                    Case 0: sBanterText = sBanterText & "Black"
                    Case 16777215: sBanterText = sBanterText & "White"
                    Case -16777216: sBanterText = sBanterText & "Automatic"
                    Case -603914241: sBanterText = sBanterText & "Background 1"
                    Case -805240833: sBanterText = sBanterText & "Text 1"
                    Case -587137025: sBanterText = sBanterText & "Text 1"
                    Case -570359809: sBanterText = sBanterText & "Background 2"
                    Case -553582593: sBanterText = sBanterText & "Text 2"
                    Case -738131969: sBanterText = sBanterText & "Accent 1"
                    Case -721354753: sBanterText = sBanterText & "Accent 2"
                    Case -704577537: sBanterText = sBanterText & "Accent 3"
                    Case -687800321: sBanterText = sBanterText & "Accent 4"
                    Case -671023105: sBanterText = sBanterText & "Accent 5"
                    Case -654245889: sBanterText = sBanterText & "Accent 6"
                    Case Else
                        sBanterText = sBanterText & "Custom color"
                End Select
            End If
            
            If .Bold = True Then
                sBanterText = sBanterText & ", Bold"
            End If
            If .Italic = True Then
                sBanterText = sBanterText & ", Italic"
            End If
            If .Underline = True Then
                sBanterText = sBanterText & ", Underline"
            End If
        End If
    End With
    Text_FontBanterFromProperties = sBanterText
End Function

'===================================================================================
' Text helper functions (Add Sheet)
'===================================================================================

'== Text_SaveAddedSheetRange =======================================================
'
' Saves sheet information for future Add Sheet and Pictures operations.
'
Private Sub Text_SaveAddedSheetRange(lLastPageStartID As Long, lLastPageEndID As Long, _
                                     lContentIDShift As Long)
    
    Dim rsCurrent As RibbonSection2007, cxnAddSheet As CustomXMLNode
    Dim cxnSheetRange As CustomXMLNode
    Dim lTotalContentIDShift As Long, lSheetIndex As Long
    
    Set rsCurrent = g_trRibbonConfig.CurrentSection()
    Set cxnAddSheet = rsCurrent.FeatureNode(FEATURE_ADDSHEET)
    
    If cxnAddSheet.ChildNodes.Count = 0 Then
        ' first run -- add the first page too
        Set cxnSheetRange = XML_AddChildNode(cxnAddSheet, "sheet")
        XML_SetAttribute cxnSheetRange, "index", "1", False
        XML_SetAttribute cxnSheetRange, "minId", Format(lLastPageStartID), False
        XML_SetAttribute cxnSheetRange, "maxId", Format(lLastPageEndID), False
        XML_SetAttribute cxnSheetRange, "offsetId", "0", False
    End If
    
    ' search for the last sheet (the one we're copying)
    
    For Each cxnSheetRange In cxnAddSheet.ChildNodes
        If lLastPageStartID >= XML_GetAttribute(cxnSheetRange, "minId") _
           And lLastPageEndID <= XML_GetAttribute(cxnSheetRange, "maxId") Then
            ' calculate our sheet index and total shift relative to page 1
            lSheetIndex = 1 + XML_GetAttribute(cxnSheetRange, "index")
            lTotalContentIDShift = lContentIDShift + XML_GetAttribute(cxnSheetRange, "offsetId")
            Exit For
        End If
    Next
    
    If lTotalContentIDShift = 0 Then
        lSheetIndex = 1
        lTotalContentIDShift = lContentIDShift
    End If

    Set cxnSheetRange = XML_AddChildNode(cxnAddSheet, "sheet")
    XML_SetAttribute cxnSheetRange, "index", Format(lSheetIndex), False
    XML_SetAttribute cxnSheetRange, "minId", Format(lLastPageStartID + lContentIDShift), False
    XML_SetAttribute cxnSheetRange, "maxId", Format(lLastPageEndID + lContentIDShift), False
    XML_SetAttribute cxnSheetRange, "offsetId", Format(lTotalContentIDShift), False
End Sub

'===================================================================================
' Text helper functions (Collapse Minimum Indents)
'===================================================================================

'== Text_GetMinimumIndents =========================================================
'
' Used by Pictures_CollapseMinimumIndents to determine which side we should be
' removing indents from.  (This relies on templates to be laid out in a certain
' way and would not work with all possible documents.)
'
Private Sub Text_GetMinimumIndents(doc As Document, cxnFillGroup As CustomXMLNode, _
                                   ByRef fMinLeftIndent As Single, _
                                   ByRef fMinRightIndent As Single, _
                                   ByRef bIsTextbox As Boolean)
                                        
    Dim lFieldCount As Long, lFieldIndex As Long, bFirstField As Boolean
    Dim rng As Range, fLeftIndent As Single, fRightIndent As Single
    Dim shpTextbox As Shape, sBkmkName As String, fTextboxLeft As Single
    
    fMinLeftIndent = 0
    fMinRightIndent = 0
    bFirstField = True
    bIsTextbox = False
    
    lFieldCount = Text_FieldCount(cxnFillGroup)
    For lFieldIndex = 1 To lFieldCount
        Set rng = Text_GetFieldRange(doc, cxnFillGroup, lFieldIndex, 0, 0)
        If Not rng Is Nothing Then
            If rng.StoryType = wdTextFrameStory Then
                ' textbox-based field
                If rng.Bookmarks.Count > 0 Then
                    sBkmkName = rng.Bookmarks(1).Name
                Else
                    sBkmkName = ""
                End If
                Set shpTextbox = Word_ParentTextBox(rng, sBkmkName)
                
                If Not shpTextbox Is Nothing Then
                    ' get text box minimum left/right coordinates and
                    ' return in MinLeftIndent and MinRightIndent
                    fTextboxLeft = shpTextbox.Left
                    
                    If bFirstField Then
                        fMinLeftIndent = fTextboxLeft
                        fMinRightIndent = fTextboxLeft + shpTextbox.Width
                        bIsTextbox = True
                        bFirstField = False
                    Else
                        fMinLeftIndent = Math_Min(fMinLeftIndent, fTextboxLeft)
                        fMinRightIndent = Math_Min(fMinRightIndent, fTextboxLeft + shpTextbox.Width)
                    End If
                End If
            ElseIf bFirstField Then
                ' non-textbox-based field (first one)
                fMinLeftIndent = rng.ParagraphFormat.LeftIndent
                fMinRightIndent = rng.ParagraphFormat.RightIndent
                bFirstField = False
            Else
                ' non-textbox-based field
                fMinLeftIndent = Math_Min(fMinLeftIndent, rng.ParagraphFormat.LeftIndent)
                fMinRightIndent = Math_Min(fMinRightIndent, rng.ParagraphFormat.RightIndent)
            End If
        End If
    Next lFieldIndex
End Sub

'== Text_ExpandFieldTextboxes ======================================================
'
' Used by CollapseMinimumIndents to update text boxes (where used) to occupy the
' space vacated by removed pictures.
'
Private Function Text_ExpandFieldTextboxes(doc As Document, cxnFillGroup As CustomXMLNode, _
                                           fExpandLeft As Single, fExpandRight As Single) As Boolean
    Dim lTextboxCount As Long, lTextboxIndex As Long
    Dim cxnsFields As CustomXMLNodes, cxnField As CustomXMLNode, qscBaseContentIDs As QuickStringCollection
    Dim shp As Shape, sObjectType As String, sContentIDBase As String, fWidth As Single, fHeight As Single
    Dim lShapeCount As Long
    
    Text_ExpandFieldTextboxes = True
    If fExpandLeft > 0 Or fExpandRight > 0 Then
        
        Set qscBaseContentIDs = New QuickStringCollection
        Set cxnsFields = XML_SelectNodes(cxnFillGroup, "content[@type=""Textbox""]")
        If Not cxnsFields Is Nothing Then
            For Each cxnField In cxnsFields
                qscBaseContentIDs.Add XML_GetAttribute(cxnField, "id")
            Next
        End If
        
        If qscBaseContentIDs.ItemCount > 0 Then
            lShapeCount = doc.Shapes.Count

            For Each shp In doc.Shapes
                If WordPort_DecodeName(shp.Name, sObjectType, 0, sContentIDBase, 0, fWidth, fHeight) Then
                    If sObjectType = OBJECT_TEXTBOX Then
                        If qscBaseContentIDs.Exists(sContentIDBase) Then
                            If fExpandLeft > 0 Then
                                shp.Left = shp.Left - fExpandLeft
                                shp.Width = shp.Width + fExpandLeft
                            Else
                                shp.Width = shp.Width + fExpandRight
                            End If
                        End If
                    End If
                End If
                If Not UI_IncrementProgress(1 / lShapeCount) Then
                    Text_ExpandFieldTextboxes = False
                    Exit For
                End If
            Next
        End If
        Set qscBaseContentIDs = Nothing
    End If
End Function

'== Text_CollapseFieldIndents ======================================================
'
' A version of ExpandFieldTextboxes for text found in tables.
'
Private Function Text_CollapseFieldIndents(doc As Document, cxnFillGroup As CustomXMLNode, _
                                           fMinLeftIndent As Single, fMinRightIndent As Single) As Boolean

    Dim lFieldCount As Long, lFieldIndex As Long
    
    Text_CollapseFieldIndents = True
    If fMinLeftIndent > 0 Or fMinRightIndent > 0 Then
        lFieldCount = Text_FieldCount(cxnFillGroup)
        For lFieldIndex = 1 To lFieldCount
            
            Text_SetFieldProperty doc, cxnFillGroup, lFieldIndex, _
                                  LeftIndentAdjust:=-fMinLeftIndent, _
                                  RightIndentAdjust:=-fMinRightIndent
            If Not UI_UpdateProgress(lFieldIndex / lFieldCount) Then
                Text_CollapseFieldIndents = False
                Exit For
            End If
        Next lFieldIndex
    End If
End Function
Attribute VB_Name = "TemplateRibbon2007"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' TemplateRibbon2007:                                                       '
' ~~~~~~~~~~~~~~~~~~~                                                       '
'   Class which handles the list of sections in the Word 2007 template.     '
'   A non-suite template will only have one section.                        '
'==========================================================================='
Option Explicit

Private m_arsSection() As RibbonSection2007
Private m_uiRibbon As IRibbonUI
Private m_lSectionsCount As Long
Private m_lCurrentSection As Long   ' if anything is wrong, m_lCurrentSection = 0
Private m_docTemplate As Document

' Ribbon protection state (see comments in Init, below):
Private WithEvents m_appWordApp As Word.Application ' set this to enable protection
Attribute m_appWordApp.VB_VarHelpID = -1
Private m_rngProtectedSelection As Range
Attribute m_rngProtectedSelection.VB_VarHelpID = -1
Private m_nProtectedVScrollPos As Long
Private m_nProtectedHScrollPos As Long
Private m_bAcceptedEULA As Boolean
Private m_bDeclinedEULA As Boolean
Private m_sAveryName As String
Private m_docToBeClosed As Document
Private m_dCloseTime As Double
Private m_sCloseDocMsg As String

'== Init ===========================================================================
'
Public Sub Init(doc As Document, uiRibbon As IRibbonUI)
    
    Dim cxpTemplate As CustomXMLPart, cxnsSections As CustomXMLNodes
    Dim lSection As Long, bAveryCodeInAttachedTemplate As Boolean
    
    Set m_docTemplate = doc
    
    ' set up Ribbon Protection for non-DOTM templates
    ' (DOTM templates don't have the bug... and we can tell when we're using one
    '  because the attached template has the Avery "productGroup" doc property.)
    
    If (Word_TemplateDocProp(doc, "productGroup") = "") Then
        ' "Ribbon protection" is needed, so set it up...
        ' For a full explanation of this feature, see comments above WindowDeactivate
        Set m_appWordApp = m_docTemplate.Application
        Set m_rngProtectedSelection = Nothing
    End If
    
    Set m_uiRibbon = uiRibbon
    Set cxpTemplate = XML_GetCustomPartBySchemaAndRootElement(doc, _
                                         AVERY_SCHEMA, "averyTemplate")
    
    m_bAcceptedEULA = False
    m_bDeclinedEULA = False
    If Not (cxpTemplate Is Nothing) Then
        m_sAveryName = XML_GetAttribute(cxpTemplate.DocumentElement, "averyName")
    
        Set cxnsSections = XML_SelectNodes(cxpTemplate, "section")
        ' select nodes returns Nothing if no nodes found
    End If

    If cxnsSections Is Nothing Then
        m_lCurrentSection = 0
        ReDim m_arsSection(1 To 1)
        Set m_arsSection(1) = New RibbonSection2007
        m_arsSection(1).Init Me, Nothing, 1
    
    Else
        m_lSectionsCount = cxnsSections.Count
        m_lCurrentSection = 1
        
        ReDim m_arsSection(1 To m_lSectionsCount)
        For lSection = 1 To m_lSectionsCount
            Set m_arsSection(lSection) = New RibbonSection2007
            m_arsSection(lSection).Init Me, cxnsSections(lSection), lSection
        Next lSection
    End If
End Sub

'== LateInit =======================================================================
'
Public Sub LateInit(uiRibbon As IRibbonUI)
    Set m_uiRibbon = uiRibbon
End Sub

'== Count ==========================================================================
'
Public Function Count() As Long
    If m_lCurrentSection = 0 Then
        Count = 0
    Else
        Count = m_lSectionsCount
    End If
End Function

'== CurrentWordSection =============================================================
'
Public Function CurrentWordSection() As Word.Section
    If m_lCurrentSection > 0 And m_lCurrentSection <= m_lSectionsCount Then
        Set CurrentWordSection = m_arsSection(m_lCurrentSection).WordSection()
    Else
        Set CurrentWordSection = Nothing
    End If

End Function

'== CurrentSection =================================================================
'
Public Function CurrentSection() As RibbonSection2007
    Set CurrentSection = Section(m_lCurrentSection)
End Function

'== Section ========================================================================
'
Private Function Section(lSectionIndex As Long) As RibbonSection2007
    If lSectionIndex > 0 And lSectionIndex <= m_lSectionsCount Then
        Set Section = m_arsSection(lSectionIndex)
    Else
        Set Section = m_arsSection(1)
    End If
End Function

'== FeatureVisible =================================================================
'
Public Function FeatureVisible(sFeatureName As String, _
                               Optional lFeatureIndex As Long = 1) As Boolean
    
    If m_lCurrentSection = 0 Then
        FeatureVisible = False
    Else
        FeatureVisible = m_arsSection(m_lCurrentSection).HasFeature( _
                                                    sFeatureName, lFeatureIndex)
    End If
End Function

'== Document =======================================================================
'
Public Function Document() As Document
    Set Document = m_docTemplate
End Function

'== InvalidateControl ==============================================================
'
Public Sub InvalidateControl(sControlId As String)
    If Not m_uiRibbon Is Nothing Then
        If sControlId = "" Then
            m_uiRibbon.Invalidate
        Else
            m_uiRibbon.InvalidateControl sControlId
        End If
    End If
End Sub

'===================================================================================
' Ribbon Protection feature
'-----------------------------------------------------------------------------------
' Word 2007 has a bug (which Microsoft seems unlikely to fix) where a custom ribbon
' will disappear if the user has the cursor in a text box when they switch away
' from the document with the custom ribbon.  This is of concern because complex
' label layouts involve text boxes.
'
' The bug does not occur with ribbons in attached templates (e.g. if the ribbon is
' in U-0087-01_P.dotm, any new docs created from that template will have the U87
' ribbon but won't suffer from the bug).  But it does occur in .docm templates, in
' which the ribbon is embedded in the document which the user edits directly.
'
' "Ribbon protection" is a workaround for this bug which works as follows:
'
' 1. We use the WindowDeactivate event to (a) determine whether a text box is
'    selected and (b) deselect the text box so that the bug does not occur.  For
'    (a), if the selection is not in a text box we do nothing else in the remainder
'    of the code, thereby avoiding any side-effects.  For (b), Selection.GoTo looked
'    promising but only worked every other time.  Luckily, Selection.HomeKey seems
'    to work every time.
'
'    Side-effect: This does cause our template window to scroll to the top of the
'    document, if it's not there already.  This will be visible to the user if the
'    doc they're switching to isn't maximized.
'
' 2. We use the WindowActivate event to detect when the user reactivates the
'    template.  At that point, we restore their scroll position.  However, also
'    re-selecting the text box during WindowActivate still triggers the ribbon bug.
'    Unfortunately, there don't appear to be any later events (Document_Change and
'    Commandbars_OnUpdate both fire before WindowActivate).  Instead, we have to
'    defer execution of the re-selection code by using Application.OnTime.
'
'    Side-effect: if the user didn't see the scroll before because of a maximized
'    window, they'll see a flash of it now because Word will redraw the window
'    before we can get it back to the original scroll position.
'
' 3. Application.OnTime causes a macro to run during Word's "idle loop" -- i.e.
'    after all events have completed.  In this case, that's at a point where the
'    ribbon is safe again.  This deferred code restores the user's original
'    selection to be within the textbox, before they notice it's moved anywhere
'    else!
'-----------------------------------------------------------------------------------

'== Application.WindowDeactivate ===================================================
'
' This event is used solely for the "ribbon protection" feature, as outlined above.
'
Private Sub m_appWordApp_WindowDeactivate(ByVal docDeactivated As Document, _
                                          ByVal winDeactivated As Window)
    
    If docDeactivated.FullName = m_docTemplate.FullName _
     And winDeactivated.Selection.Range.StoryType = wdTextFrameStory Then
        ' selection is in a text box -- save it and move selection elsewhere
        m_nProtectedHScrollPos = winDeactivated.HorizontalPercentScrolled
        m_nProtectedVScrollPos = winDeactivated.VerticalPercentScrolled
        ' this sometimes moves the scrollbar, which is why we save the scroll pos first
        Set m_rngProtectedSelection = winDeactivated.Selection.Range.Duplicate
        
        ' this deselects the text box without reactivating our window
        ' unlike Range().Select
        m_docTemplate.ActiveWindow.Selection.HomeKey wdStory, wdMove
    End If
End Sub

'== Application.WindowActivate =====================================================
'
' This event is used solely for the "ribbon protection" feature.  We use it to
' detect when ActiveWindow is changing back to our template, so we can restore the
' proper selection and scroll position.
'
Private Sub m_appWordApp_WindowActivate(ByVal docActivated As Document, _
                                        ByVal winActivated As Window)

    If docActivated.FullName = m_docTemplate.FullName _
     And Not m_rngProtectedSelection Is Nothing Then
        
        ' restore user's scroll position now that the window is active again
        winActivated.HorizontalPercentScrolled = m_nProtectedHScrollPos
        winActivated.VerticalPercentScrolled = m_nProtectedVScrollPos
        
        ' we have a previously-saved textbox selection -- set up a deferred macro
        ' (a public Sub in RibbonCore2007) to restore it
        Application.OnTime Now(), "AveryRibbonRestoreSelection", 0
    End If
End Sub

'== RestoreProtectedSelection ======================================================
'
' This code completes the "ribbon protection" feature by restoring the user's
' original selection.  It's called by AveryRibbonRestoreSelection in RibbonCore2007,
' a split-second after WindowActivate.
'
Public Function RestoreProtectedSelection() As Boolean
    Dim winActive As Window

    ' called by AveryRibbonRestoreSelection -- after the window has been reactivated,
    ' restore the text box selection
    If m_rngProtectedSelection Is Nothing Then
        RestoreProtectedSelection = False
    Else
        m_rngProtectedSelection.Select
        Set m_rngProtectedSelection = Nothing
        Set winActive = m_docTemplate.ActiveWindow
        
        ' reselecting sometimes scrolls the document; fix if necessary
        If winActive.HorizontalPercentScrolled <> m_nProtectedHScrollPos _
         Or winActive.VerticalPercentScrolled <> m_nProtectedVScrollPos Then
         
            winActive.HorizontalPercentScrolled = m_nProtectedHScrollPos
            winActive.VerticalPercentScrolled = m_nProtectedVScrollPos
        End If
        RestoreProtectedSelection = True
    End If
End Function


'== EULACheck ======================================================================
'
' Purpose:  Built-in End User License Agreement for templates that don't include
'           full "self-install" features.
'
' Params:   (in) [bOnlyAskOnce]: True if the user should not be prompted again with
'                                the EULA if they already declined it this session
' Returns:  True if the user has accepted the EULA, False otherwise.
'-----------------------------------------------------------------------------------
Public Function EULACheck(Optional bOnlyAskOnce As Boolean = False) As Boolean

    If m_bAcceptedEULA Then
        EULACheck = True
    ElseIf bOnlyAskOnce And m_bDeclinedEULA Then
        ' user already saw EULA prompt once and hit I Disagree; don't ask again
        EULACheck = False
    Else
        Const EULA_AGREE = ".acceptEULA"
        
        Dim sAveryName As String
        sAveryName = m_sAveryName
        
        ' fallbacks if "averyName" attribute is missing
        If sAveryName = "" And Count() > 0 Then
            sAveryName = Section(1).ProductGroup()
        End If
        If sAveryName = "" Then
            sAveryName = ActiveDocument.Name
        End If
        
        sAveryName = Replace(Replace(sAveryName, "\", ""), "/", "")
        m_bAcceptedEULA = Word_ProfileString(PROFILE_SECTION_AVERY, sAveryName) = EULA_AGREE
        
        If m_bAcceptedEULA Then
            EULACheck = True
        Else
            frmAveryEULA.Show
            m_bAcceptedEULA = (LCase(frmAveryEULA.Tag) = "agree")
            m_bDeclinedEULA = Not m_bAcceptedEULA
            Unload frmAveryEULA
            
            If m_bAcceptedEULA Then
                On Error Resume Next    ' don't let a registry error block template use
                System.ProfileString(PROFILE_SECTION_AVERY, sAveryName) = EULA_AGREE
                EULACheck = True
            Else
                EULACheck = False
            End If
        End If
    End If
End Function

'== VerifyStep1 ====================================================================
'
' Part one of the "Verification" feature, which ensures only one doc with the same
' ribbon is running at a time.  (If we allow two, their state gets mixed together,
' with strange results.)
'
' This function automatically sets up "Step2" to occur on Idle.
'
Public Function VerifyStep1(docNew As Document) As Boolean
    Dim docOld As Document
    Dim sOldDocName As String, sNewDocName As String, sMsg As String
    On Error Resume Next

    Set docOld = g_trRibbonConfig.Document()
    sOldDocName = docOld.FullName
    sNewDocName = docNew.FullName
    
    If sOldDocName = "" Then
        ' old document has been closed; re-init for new document
        Init docNew, Nothing
        VerifyStep1 = True
    
    ElseIf sOldDocName = sNewDocName Then
        VerifyStep1 = True
    
    Else
        sOldDocName = docOld.Name   ' don't include path
        sNewDocName = docNew.Name   ' this line is here in case the next one fails
        sNewDocName = docNew.AttachedTemplate.Name
        sMsg = UI2007_GetLocalString(CTRLS_MSGBOX, "", "NoMultiRibbon", STRING_LABEL, _
                                     APPLY_SYMBOLS_ALWAYS)
        sMsg = Replace(sMsg, "%1", sNewDocName)
        m_sCloseDocMsg = Replace(sMsg, "%2", sOldDocName)
        
        ' we have to use a timed event to close the doc, because Word doesn't let us
        ' close a doc in the midst of its Document_New or Document_Open event.
        Set m_docToBeClosed = docNew
        m_dCloseTime = Timer
        Application.OnTime Now(), "AveryRibbonVerifyDocuments", 0
        VerifyStep1 = False
    End If
End Function

'== VerifyStep2 ====================================================================
'
' Part two of the "Verification" feature, which closes the newly-opened document,
' after showing an error message
'
Public Function VerifyStep2() As Boolean
    On Error Resume Next

    If (Not (m_docToBeClosed Is Nothing)) And Abs(Timer - m_dCloseTime) < 10 Then
        ' only close if very little time has passed (otherwise user might have made changes!)
        
        ' close it first (so it disappears right away and leaves the other doc visible)
        m_docToBeClosed.Close False
        VerifyStep2 = False
        If m_sCloseDocMsg <> "" Then
            UI_MsgBox2003 m_sCloseDocMsg, vbExclamation, , UI2007_GetLocalString(CTRLS_MSGBOX, "", _
                                                        "title", STRING_LABEL, APPLY_SYMBOLS_LOCALE)
        End If
    Else
        VerifyStep2 = True
    End If
    
    Set m_docToBeClosed = Nothing
    m_sCloseDocMsg = ""
    m_dCloseTime = 0
End Function
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'==========================================================================='
Option Explicit

Private Sub Document_New()
    AveryRibbonVerify ActiveDocument
End Sub

Private Sub Document_Open()
    AveryRibbonVerify ActiveDocument
End Sub
Attribute VB_Name = "UtilMathAndStrings"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' UtilMathAndStrings:                                                       '
' ~~~~~~~~~~~~~~~~~~~                                                       '
'   Utility functions that accomplish common tasks with numbers and text.   '
'==========================================================================='
Option Explicit

'== Math_Min =======================================================================
'
' Purpose:  Given two numbers, returns the smaller number.
'
' Params:   (in) vVal1, vVal2: the values to compare
' Returns:  (Variant) the smaller value
'
' Notes:    See also MinNonNegative.
'-----------------------------------------------------------------------------------
Public Function Math_Min(vVal1 As Variant, vVal2 As Variant) As Variant
    If vVal1 < vVal2 Then
        Math_Min = vVal1
    Else
        Math_Min = vVal2
    End If
End Function

'== Math_Max =======================================================================
'
' Purpose:  Given two numbers, returns the larger number.
'
' Params:   (in) vVal1, vVal2: the values to compare
' Returns:  (Variant) the larger value
'-----------------------------------------------------------------------------------
Public Function Math_Max(vVal1 As Variant, vVal2 As Variant) As Variant
    If vVal1 > vVal2 Then
        Math_Max = vVal1
    Else
        Math_Max = vVal2
    End If
End Function

'== Math_MinPositive ===============================================================
'
' Purpose:  Given two numbers, returns the smaller number that's more than zero.
'
' Params:   (in) vVal1, vVal2: the values to compare
' Returns:  (Variant) the smaller positive value
'
' Remarks:  Only returns zero (or less) if both values are zero or less.
'-----------------------------------------------------------------------------------
Public Function Math_MinPositive(vVal1 As Variant, vVal2 As Variant) As Variant

    If vVal1 > 0 And vVal2 <= 0 Then
        Math_MinPositive = vVal1
    ElseIf vVal2 > 0 And vVal1 <= 0 Then
        Math_MinPositive = vVal2
    ElseIf vVal1 < vVal2 Then
        Math_MinPositive = vVal1
    Else
        Math_MinPositive = vVal2
    End If
End Function

'== Math_MinNonNegative ============================================================
'
' Purpose:  Given two numbers, returns the smaller number that's not less than zero.
'
' Params:   (in) fVal1, fVal2: the values to compare
' Returns:  (Single) the smaller non-negative value
'
' Remarks:  Used to return the smallest allowable scale.  The extra non-negative
'           logic is required because PICTURE_SCALE_NO_LIMIT is a negative number
'           (but should really be interpreted as infinity).
'-----------------------------------------------------------------------------------
Public Function Math_MinNonNegative(fVal1 As Single, fVal2 As Single) As Single

    If fVal1 < fVal2 Then
        If fVal1 >= 0 Then
            Math_MinNonNegative = fVal1
        Else
            Math_MinNonNegative = fVal2
        End If
    Else
        If fVal2 >= 0 Then
            Math_MinNonNegative = fVal2
        Else
            Math_MinNonNegative = fVal1
        End If
    End If
End Function

'== Math_SwapObjects ===============================================================
'
' Purpose:  Swaps two objects by using a third, temporary variable.
'
' Params:   (in/out) obj1, obj2: the two objects to swap.
'-----------------------------------------------------------------------------------
Public Sub Math_SwapObjects(ByRef obj1 As Object, ByRef obj2 As Object)
    Dim objSwapTemp As Object
    Set objSwapTemp = obj1
    Set obj1 = obj2
    Set obj2 = objSwapTemp
End Sub

'== Math_ScaleToMax ================================================================
'
' Purpose:  Calculates a new size for a picture, fitting within a maximum width and
'           height and preserving the aspect ratio
'
' Params:   (in) dSrcWidth, dSrcHeight: the original size (which may be too large)
'           (in) dMaxWidth, dMaxHeight: the maximum size to return
'           (out) dScaledWidth, dScaledHeight: the recommended size
'
' Remarks:  Math_ScaleToMax will never return a value greater than the original
'           size or the maximum size.  If the original is larger than the maximum,
'           it returns the largest possible size that does not exceed the maximum.
'           (This won't be exactly the same as the maximum if the aspect ratios
'           differ.)
'-----------------------------------------------------------------------------------
Public Sub Math_ScaleToMax(ByVal dSrcWidth As Double, ByVal dSrcHeight As Double, _
                           ByVal dMaxWidth As Double, ByVal dMaxHeight As Double, _
                           ByRef dScaledWidth As Double, ByRef dScaledHeight As Double)
    
    ' if only one max is supplied, calculate the other max using the pic's
    ' current aspect ratio (so that it ultimately cancels out)
    If dMaxWidth > 0 And dMaxHeight = 0 And dSrcWidth > 0 Then
        dMaxHeight = dMaxWidth * dSrcHeight / dSrcWidth
    ElseIf dMaxHeight > 0 And dMaxWidth = 0 And dSrcHeight > 0 Then
        dMaxWidth = dMaxHeight * dSrcWidth / dSrcHeight
    ElseIf dMaxHeight = 0 And dMaxWidth = 0 Then
        dMaxHeight = dSrcHeight
        dMaxWidth = dSrcWidth
    End If
    
    If dSrcWidth > dMaxWidth Then
        If dSrcHeight > dMaxHeight Then
            ' bigger in both dimensions -
            ' check aspect ratios for controlling dimension
            If (dSrcWidth / dSrcHeight) > (dMaxWidth / dMaxHeight) Then
                dScaledHeight = dSrcHeight * dMaxWidth / dSrcWidth
                dScaledWidth = dMaxWidth
            Else ' already know dSrcHeight > dMaxHeight
                dScaledWidth = dSrcWidth * dMaxHeight / dSrcHeight
                dScaledHeight = dMaxHeight
            End If
        Else    ' width too large, but height already OK
            dScaledHeight = dSrcHeight * dMaxWidth / dSrcWidth
            dScaledWidth = dMaxWidth
        End If
    ElseIf dSrcHeight > dMaxHeight Then  ' height too large
        dScaledWidth = dSrcWidth * dMaxHeight / dSrcHeight
        dScaledHeight = dMaxHeight
    Else
        ' no shrinking necessary
        dScaledWidth = dSrcWidth
        dScaledHeight = dSrcHeight
    End If
End Sub



'== Math_ScaleToMaxPixels ==========================================================
'
' Purpose:  A version of Math_ScaleToMax that works in pixels instead of points
'
' Params:   See Math_ScaleToMax
'
' Remarks:  As a convenience, Math_ScaleToMaxPixels handles the type casts to
'           Double-precision values required by Math_ScaleToMax.
'-----------------------------------------------------------------------------------
Public Sub Math_ScaleToMaxPixels(lSrcWidth As Long, lSrcHeight As Long, _
                                    lMaxWidth As Long, lMaxHeight As Long, _
                                    ByRef lScaledWidth As Long, _
                                    ByRef lScaledHeight As Long)
    Dim dScaledWidth As Double, dScaledHeight As Double
    
    Math_ScaleToMax CDbl(lSrcWidth), CDbl(lSrcHeight), CDbl(lMaxWidth), _
                        CDbl(lMaxHeight), dScaledWidth, dScaledHeight
                             
    lScaledWidth = CLng(dScaledWidth)
    lScaledHeight = CLng(dScaledHeight)
End Sub



'== Math_EncodeBooleanFlags ========================================================
'
' Purpose:  Takes up to four Boolean values and packs them into a single Long value.
'
' Params:   (in) bBool1...bBool4: input flags (default = False).
' Returns:  (Long) The packed Long integer.
'
' Remarks:  This is used when saving options for Word 2003 templates -- we create a
'           single value, e.g. 13, that is the sum of a number of options yet is
'           easier to store than individual values.  Use DecodeBooleanFlags to
'           reverse.
'-----------------------------------------------------------------------------------
Public Function Math_EncodeBooleanFlags(bBool1 As Boolean, _
                                        Optional bBool2 As Boolean = False, _
                                        Optional bBool3 As Boolean = False, _
                                        Optional bBool4 As Boolean = False, _
                                        Optional bBool5 As Boolean = False, _
                                        Optional bBool6 As Boolean = False, _
                                        Optional bBool7 As Boolean = False, _
                                        Optional bBool8 As Boolean = False) As Long

    Math_EncodeBooleanFlags = (1 And bBool1) Or (2 And bBool2) Or (4 And bBool3) Or _
                              (8 And bBool4) Or (16 And bBool5) Or (32 And bBool6) Or _
                              (64 And bBool7) Or (128 And bBool8)
End Function



'== Math_DecodeBooleanFlags ========================================================
'
' Purpose:  Unpacks flags packed by EncodeBooleanFlags
'
' Params:   (in) lFlags: the packed value created by DecodeBooleanFlags
'           (out) bBool1...bBool4: the value of each flag
'-----------------------------------------------------------------------------------
Public Sub Math_DecodeBooleanFlags(lFlags As Long, Optional ByRef bBool1 As Boolean, _
                                   Optional ByRef bBool2 As Boolean, _
                                   Optional ByRef bBool3 As Boolean, _
                                   Optional ByRef bBool4 As Boolean, _
                                   Optional ByRef bBool5 As Boolean, _
                                   Optional ByRef bBool6 As Boolean, _
                                   Optional ByRef bBool7 As Boolean, _
                                   Optional ByRef bBool8 As Boolean)
    bBool1 = (lFlags And 1)
    bBool2 = (lFlags And 2)
    bBool3 = (lFlags And 4)
    bBool4 = (lFlags And 8)
    bBool5 = (lFlags And 16)
    bBool6 = (lFlags And 32)
    bBool7 = (lFlags And 64)
    bBool8 = (lFlags And 128)
End Sub



'== String_ApplySymbols ============================================================
'
' Purpose:    Replaces special sequences -- (R), (c), and (TM) -- with
'             special characters within a string, if appropriate
' Used By:    Various, for dialog box text and filenames
' Parameters: (in)  sSrcString: the string containing (R), (c), and/or (TM)
'             (in)  bLocaleMode: If True, symbols will only be used on systems
'                                with an ASCII code page.  Use locale mode for
'                                filenames and Windows title bars.
' Returns:    (String)  The modified string (or the original string, if no
'                       replaceable symbols are found)
'-----------------------------------------------------------------------------------
Public Function String_ApplySymbols(sSrcString As String, _
                                    bLocaleMode As Boolean) As String
    
    Const CHR_CIRCLE_R = 174, CHR_CIRCLE_C = 169, CHRW_LITTLE_TM = 8482
    Dim sResultString As String, lPos As Long
    
    If bLocaleMode And Not (Chr(CHR_CIRCLE_R) = ChrW(CHR_CIRCLE_R)) Then
        ' in Locale mode (used for window title bars), we don't use circle-R
        ' or circle-C in non-ASCII code pages because certain fonts can't
        ' handle them (the UI font within dialog boxes is OK, and so those
        ' labels don't need to use Locale mode)
        String_ApplySymbols = sSrcString
    Else
        ' replace (R) with Registered Trademark symbol
        sResultString = sSrcString
        lPos = InStr(sResultString, "(R)")
        Do Until lPos = 0
            sResultString = Left(sResultString, lPos - 1) & ChrW(CHR_CIRCLE_R) _
                            & Mid(sResultString, lPos + 3)
            lPos = InStr(sResultString, "(R)")
        Loop
        
        ' replace (c) [lowercase] with Copyright symbol
        lPos = InStr(sResultString, "(c)")
        Do Until lPos = 0
            sResultString = Left(sResultString, lPos - 1) & ChrW(CHR_CIRCLE_C) _
                            & Mid(sResultString, lPos + 3)
            lPos = InStr(sResultString, "(c)")
        Loop
        
        ' replace (TM) with Trademark symbol
        lPos = InStr(sResultString, "(TM)")
        Do Until lPos = 0
            sResultString = Left(sResultString, lPos - 1) & ChrW(CHRW_LITTLE_TM) _
                            & Mid(sResultString, lPos + 4)
            lPos = InStr(sResultString, "(c)")
        Loop
        
        String_ApplySymbols = sResultString
    End If
End Function




'== String_InstrRev ================================================================
'
' Purpose:  Equivalent to VBA's InstrRev, but supported on all versions.
'
' Params:   (in) sCheck: the string to search
'           (in) sMatch: the string to search for
' Returns:  (Long) the last location of sMatch in sCheck, or 0 if none
'-----------------------------------------------------------------------------------
Public Function String_InstrRev(sCheck As String, sMatch As String) As Long
    ' note: InstrRev exists as a VBA function in some version of Word, but
    ' not all... this function provides a version-independent substitute
    Dim lPosition As Long, lNextPosition As Long
    
    lPosition = 0
    lNextPosition = InStr(sCheck, sMatch)
    Do Until lNextPosition = 0
        lPosition = lNextPosition
        lNextPosition = InStr(lPosition + 1, sCheck, sMatch)
    Loop
    String_InstrRev = lPosition
End Function


'== String_Count ===================================================================
'
' Purpose:  Count the number of occurrences of a substring
'
' Params:   (in) sCheck: the string to search
'           (in) sMatch: the string to search for
' Returns:  (Long) the number of occurrences (0 for none)
'-----------------------------------------------------------------------------------
Public Function String_Count(sCheck As String, sMatch As String) As Long
    ' note: InstrRev exists as a VBA function in some version of Word, but
    ' not all... this function provides a version-independent substitute
    Dim lPosition As Long, lCount As Long
    
    lPosition = 1
    lCount = 0
    Do Until lPosition = 0
        lPosition = InStr(lPosition, sCheck, sMatch)
        If lPosition > 0 Then
            lCount = lCount + 1
            lPosition = lPosition + 1
        End If
    Loop
    String_Count = lCount
End Function


'== String_Replace =================================================================
'
' Purpose:  Roughly equivalent to VBA's Replace, but supported on all versions.
'
' Params:   (in)     sExpr: the string to search and replace within
'           (in)     sFind: the string to replace
'           (in)     sReplace: the string to replace sFind with
'           (in)     bReplaceAll: false to replace only the first instance of sFind
' Returns:  (String) updated string
'-----------------------------------------------------------------------------------
Public Function String_Replace(ByVal sExpr As String, sFind As String, _
                               sReplace As String, bReplaceAll As Boolean) As String
    Dim nPos As Long
    
    nPos = InStr(sExpr, sFind)
    Do While nPos > 0
        If nPos > 1 Then
            sExpr = Left(sExpr, nPos - 1) & sReplace & Mid(sExpr, nPos + Len(sFind))
        Else
            sExpr = sReplace & Mid(sExpr, nPos + Len(sFind))
        End If
        
        If bReplaceAll Then
            nPos = InStr(nPos + Len(sReplace), sExpr, sFind)
        Else
            nPos = 0
        End If
    Loop
    String_Replace = sExpr
End Function

'== String_FileType ================================================================
'
' Purpose:  Extracts the file extension from a string filename.
'
' Params:   (in) sFilename: the filename.
' Returns:  (String) the extension (the part following the last ., not including .)
'-----------------------------------------------------------------------------------
Public Function String_FileType(sFilename As String) As String
    String_FileType = Trim(LCase(Mid(sFilename, String_InstrRev(sFilename, ".") + 1)))
End Function

'== String_SplitFromList ===========================================================
'
' Purpose:    Extracts the first item from a delimited string
' Used By:    Various
'
' Parameters: (in/out) sFullString: pass in the whole string and get back
'                                   the remaining part of the string
'             (in)     sDelimiter: typically "_", ";", ":", etc.
' Returns:    The first item in the string, blank if FullString is empty
'
' Remarks:    Use repeatedly to extract each item of the list.  E.g. a string like
'             "first_2nd__fourth" would return "first", "2nd", "", and "fourth" with
'             repeated calls to SplitFromList.
'-----------------------------------------------------------------------------------
Public Function String_SplitFromList(ByRef sFullString As String, _
                                     sDelimiter As String) As String
    Dim lPos As Integer
    
    If sDelimiter = "" Then
        String_SplitFromList = sFullString
        sFullString = ""
    Else
        lPos = InStr(sFullString, sDelimiter)
        If lPos = 0 Then
            lPos = Len(sFullString) + 1
        End If
        String_SplitFromList = Left(sFullString, lPos - 1)
        sFullString = Mid(sFullString, lPos + Len(sDelimiter))
    End If
End Function



'== String_ConvertFloat ============================================================
'
' Purpose:  Converts a string to a floating (Single-precision) value.
'
' Params:   (in) sNumeric: the string, typically from user input
'           (out) fValue: the number from the conversion
' Returns:  (Boolean): True if sNumeric is a number, False if it's not valid
'
' Remarks:  This does the same thing as Val(), except it fails if the user
'           entered "1sdf3", instead of just returning 1.
'-----------------------------------------------------------------------------------
Private Function String_ConvertFloat(ByVal sNumeric As String, _
                                     ByRef fValue As Single) As Boolean
    Dim lDecimalPos As Long, fTempValue As Single
    
    sNumeric = Trim(sNumeric)
    If sNumeric = "" Then
        ' blank is invalid
        String_ConvertFloat = False
    Else
        lDecimalPos = InStr(sNumeric, String_LocalDecimalPoint())
        If InStr(lDecimalPos + 1, sNumeric, String_LocalDecimalPoint()) > 0 Then
            ' two decimal points!
            String_ConvertFloat = False
        Else
            ' zero or one decimal points, i.e. may be valid
            ' Val returns zero for invalid strings
            fTempValue = Val(sNumeric)
            If fTempValue = 0 Then
                ' maybe it's actually zero, maybe it's invalid
                If lDecimalPos > 0 Then
                    ' had a decimal point; strip it out
                    sNumeric = Left(sNumeric, lDecimalPos - 1) & _
                                Mid(sNumeric, lDecimalPos + 1)
                End If
                If sNumeric = String(Len(sNumeric), "0") Then
                    ' all zeros -- it's actually zero
                    fValue = 0
                    String_ConvertFloat = True
                Else
                    ' it wasn't all zeros; must be invalid
                    String_ConvertFloat = False
                End If
            Else
                ' was successfully converted above
                fValue = fTempValue
                String_ConvertFloat = True
            End If
        End If
    End If
End Function



'== String_LocalDecimalPoint =======================================================
'
' Purpose:  Returns the locale-specific decimal point (typically . or ,).
'-----------------------------------------------------------------------------------
Private Function String_LocalDecimalPoint() As String
    String_LocalDecimalPoint = Format(0, ".")
End Function
Attribute VB_Name = "UtilUI"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' UtilUI:                                                                   '
' ~~~~~~~                                                                   '
'   Common utility functions for error messages, progress bars, etc.        '
'==========================================================================='
Option Explicit

' Our UI constants:
Global Const DLG_OK = "OK"
Global Const DLG_CANCEL = "Cancel"
Global Const DLG_RESHOW = "RESHOW"
Global Const AT_MSG_TITLE = "Avery(R) Template" ' unlocalized fallback, all versions
Global Const AVERY_COMMANDBAR = "Avery Template Tools"
Global Const AT_DIALOG_MARGIN As Single = 6
Global Const APPLY_SYMBOLS_NONE = 0
Global Const APPLY_SYMBOLS_LOCALE = 1
Global Const APPLY_SYMBOLS_ALWAYS = 2

'==========================================================================='
' Windows API Declarations
'
Private Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long

'== UI_ShowErrorMessage ============================================================
'
' Purpose:  Shows a boilerplate error message for a given error code
'
' Params:   (in) lErrorCode: the error code to include in the message
'           [in] sMsgTitle: a template-specific title for the error, if possible
'
' Remarks:  This is the general-purpose error handler for the entire project.  It
'           will attempt to restore Word to a usable state, and display a message
'           indicating failure.
'-----------------------------------------------------------------------------------
Public Sub UI_ShowErrorMessage(lErrorCode As Long, _
                               Optional ByVal sMsgTitle As String = "")
    On Error Resume Next    ' make any errors here non-fatal
    
    ' clean-up, in order from least likely to fail to most likely to fail...
    Application.ScreenUpdating = True
    Application.System.Cursor = wdCursorNormal
    UI_HideProgress

    UI_MsgBox2003 "The command cannot be completed successfully.  If this " _
                    & "problem persists, you may want to download a new copy " _
                    & "of this template from Avery.com.", vbOKOnly + vbCritical, _
                    lErrorCode
    Exit Sub
End Sub


'== UI2003_MsgBox ==================================================================
'
' Purpose:  Show a message box in a Word 2003 template.
'
' Params:   (in) sPrompt: the prompt text to show to the end user.
'           [in] lButtons: the VB buttons and icon constants for the message box
'           [in] lErrorCode: an error code to append to the message
'           [in] sTitle: the template-specific title for the message, if possible
' Returns:  the result of the message box (same as the built-in MsgBox function)
'-----------------------------------------------------------------------------------
Public Function UI_MsgBox2003(ByVal sPrompt As String, _
                              Optional lButtons As Long = vbExclamation, _
                              Optional lErrorCode As Long = 0, _
                              Optional ByVal sTitle As String = "") As Long
    If sTitle = "" Then
        sTitle = AT_MSG_TITLE
    End If
    sTitle = String_ApplySymbols(sTitle, True)
    
    If lErrorCode <> 0 Then
        sPrompt = sPrompt & vbCr & vbCr & "(Error: " & lErrorCode & ")"
    End If
    UI_MsgBox2003 = MsgBox(sPrompt, lButtons, sTitle)
End Function

'== UI_SilentError =================================================================
'
' Purpose:  Clean up from an error without showing an error message.
'
' Remarks:  Typically used for events -- we do not want a bug in the event code to
'           trigger an error message out of nowhere.
'-----------------------------------------------------------------------------------
Public Sub UI_SilentError(lErrorCode As Integer)
    On Error Resume Next    ' make any errors here non-fatal
        
    ' clean-up, in order from least likely to fail to most likely to fail...
    Application.ScreenUpdating = True
    Application.System.Cursor = wdCursorNormal
    UI_HideProgress
End Sub

'== UI_Commandbar ==================================================================
'
' Purpose:  Returns our toolbar, if found.
'
' Remarks:  Note that in Word 2007, you will be able to get a commandbar object but
'           it may have very limited functionality.
'-----------------------------------------------------------------------------------
Public Function UI_Commandbar(Optional ByVal sName As String = "") As CommandBar
    Set UI_Commandbar = Nothing
    If sName = "" Then
        sName = AVERY_COMMANDBAR
    End If
    
    ' errors here (e.g. if toolbar doesn't exist) should be non-fatal
    On Error Resume Next
    Set UI_Commandbar = ActiveDocument.CommandBars(sName)
End Function

'== UI_ForceToolbarVisible =========================================================
'
' Purpose:  Forces our toolbar on or off.
'
' Params:   (in) sName: the name of our toolbar
'           (in) bShow: True to force on, False to force off.
'           (in) bActInWord2007: False to do nothing in Wd2007 (see inline comment)
'
' Remarks:  This function should be used to hide our toolbar if the user declines
'           the EULA.
'-----------------------------------------------------------------------------------
Public Sub UI_ForceToolbarVisible(sName As String, bShow As Boolean, _
                                  bActInWord2007 As Boolean)
    Dim cbAveryTemplate As CommandBar
    On Error Resume Next ' no reason for any of this to cause fatal errors
    
    If (Not Word_VersionAtLeast(VER_WORD_2007)) Or bActInWord2007 Then
        ' On Word 2007, the toolbar is part of the ribbon and doesn't always
        ' show/hide well; only try if an extra flag is set (bActInWord2007
        ' is only used when Word_ValidateSupport fails)
        Set cbAveryTemplate = UI_Commandbar(sName)
        If Not cbAveryTemplate Is Nothing Then
            cbAveryTemplate.Visible = bShow
        End If
    End If
End Sub

'== UI_InsertPictureDlg ============================================================
'
' Purpose:  Accesses the built-in Insert Picture dialog.
'
' Returns:  (String) the full path to the file chosen by the user.
'-----------------------------------------------------------------------------------
Public Function UI_InsertPictureDlg() As String
    Dim dlgInsertPicture As Dialog
    Const WORD_DLG_OK = -1
    
    On Error Resume Next
    Set dlgInsertPicture = Application.Dialogs(wdDialogInsertPicture)
    ' dialog can be unavailable if selection is at the end of a table row;
    ' this move should fix that
    If dlgInsertPicture Is Nothing Then
        Selection.MoveUp wdLine, 1
        Set dlgInsertPicture = Application.Dialogs(wdDialogInsertPicture)
    End If
    ' if still failing, move to the beginning of the doc
    If dlgInsertPicture Is Nothing Then
        ActiveDocument.Range(0, 0).Select
        Set dlgInsertPicture = Application.Dialogs(wdDialogInsertPicture)
    End If
    On Error GoTo 0
    
    ' show the insert picture dialog so the user can pick a new picture
    If dlgInsertPicture Is Nothing Then
        UI_InsertPictureDlg = ""
    ElseIf dlgInsertPicture.Display() = WORD_DLG_OK Then
        ' if OK, the full path is in the Name field
        UI_InsertPictureDlg = dlgInsertPicture.Name
    Else
        UI_InsertPictureDlg = ""
    End If
End Function

'== UI_BrowseToPage ================================================================
'
' Purpose:    Displays a web page on http://www.avery.com.
' Used By:    Help button click event
' Parameters: (in)  sURL: A URL token -- something like ":page:", on the predefined
'                         list below, which is resolved by this function to a URL
'-----------------------------------------------------------------------------------
Public Sub UI_BrowseToPage(ByVal sURL As String, ByVal sErrMsg As String, _
                           Optional sErrMsgTitle As String = "")
    
    Dim sBrowserCommand As String, sSlash As String, lPos As Long
    Dim dTask As Double, sSearchText As String

    Const AT_ERROR_BROWSERNOTFOUND = 1001

    On Error GoTo Error_BrowseToPage
    ' single place to update template Help URLs
    Select Case LCase(sURL)
        Case ":home:":
            sURL = "/us/msoffice/home"
        Case ":morepredesigns:":            ' note URL tokens must be lower-case to
            sURL = "/us/msoffice/predesignedtemplates"      ' work with LCase above
        Case ":moreblanks:":
            sURL = "/us/msoffice/blankTemplates"
        Case ":about:":
            sURL = "/us/msoffice/about"
        Case ":help:":
            sURL = "/us/msoffice/support"
        Case ":readyindex:":
            sURL = "/us/msoffice/readyindex"
        Case ":indexmaker:":
            sURL = "/us/msoffice/indexmaker"
        Case ":directprint:":
            sURL = "/us/msoffice/directprint"
        Case ":printdirectprint:":
            sURL = "/us/msoffice/printdirectprint"
        Case ":printindexmaker:":
            sURL = "/us/msoffice/printindexmaker"
        Case ":printreadyindex:":
            sURL = "/us/msoffice/printreadyindex"
        Case Else
            If LCase(Left(sURL, 8)) = ":search:" Then
                sSearchText = URLEncode(Trim(Mid(sURL, 9)))
                sURL = "/quicksearch/en_us/partner-msword-template/" & sSearchText
            Else
                ' currently we do not allow any custom URLs; if you don't use one of the pre-defined tokens,
                ' you get the Avery home page:
                sURL = "/us/msoffice/home"
            End If
    End Select
    
    ' all links must be absolute paths on www.avery.com
    If Left(sURL, 1) = "/" Then
        sURL = "http://www.avery.com" & sURL
    Else
        sURL = "http://www.avery.com/"
    End If
    
    ' plan A: use the registry to find the default web browser
    sBrowserCommand = System.PrivateProfileString("", "HKEY_CLASSES_ROOT\HTTP\shell\open\command", "")
    If sBrowserCommand = "" Then
        sBrowserCommand = System.PrivateProfileString("", "HKEY_CLASSES_ROOT\htmlfile\shell\opennew\command", "")
        If sBrowserCommand = "" Then
            ' opennew works better for IE but open is more standard, so try it
            sBrowserCommand = System.PrivateProfileString("", "HKEY_CLASSES_ROOT\htmlfile\shell\open\command", "")
        End If
    End If
    
    If sBrowserCommand = "" Then
        ' can't start browser if we didn't find a path
        dTask = 0
    Else
        ' the browser command should have a %1 parameter for the filename/URL
        lPos = InStr(sBrowserCommand, "%1")
        If lPos = 0 Then
            ' no parameter -- just append the URL
            sBrowserCommand = sBrowserCommand & " " & sURL
        Else
            ' there is a parameter -- replace it
            sBrowserCommand = Left(sBrowserCommand, lPos - 1) & sURL & Mid(sBrowserCommand, lPos + 2)
        End If
    
        ' execute the command
        On Error Resume Next
        ' don't bring up an error message here; dTask=0 indicates failure
        dTask = Shell(sBrowserCommand, vbNormalFocus)
        On Error GoTo Error_BrowseToPage
    End If
    If dTask = 0 Then
        ' no app started via registry method
        If Val(System.Version) < VER_OS_VISTA Then
            ' plan B: just invoke explorer (doesn't work on Vista)
            Shell "explorer.exe " & sURL
        Else
            ' plan C: assume Internet Explorer is under the standard Program
            ' Files folder
            sSlash = Application.PathSeparator
            
            sBrowserCommand = Application.Options.DefaultFilePath(wdProgramPath)
            sBrowserCommand = Left(sBrowserCommand, InStr(4, sBrowserCommand, sSlash)) _
                              & "Internet Explorer" & sSlash & "iexplore.exe"
            If Dir(sBrowserCommand) <> "" Then
                Shell sBrowserCommand & " " & sURL
            Else
                Err.Raise AT_ERROR_BROWSERNOTFOUND
            End If
        End If
    End If
    Exit Sub

Error_BrowseToPage:
    ' the error message should have a %1 parameter to indicate where the URL should appear
    lPos = InStr(sErrMsg, "%1")
    If lPos = 0 Then
        ' no parameter -- just append the URL
        sErrMsg = sErrMsg & " " & sURL
    Else
        ' there is a parameter -- replace it
        sErrMsg = Left(sErrMsg, lPos - 1) & sURL & Mid(sErrMsg, lPos + 2)
    End If
    
    UI_MsgBox2003 sErrMsg, vbOKOnly + vbExclamation, Err.Number, sErrMsgTitle
End Sub

Private Function URLEncode(sUnencoded As String) As String
    Dim lPos As Long, lLen As Long, nChr As Integer, sEncoded As String
    
    On Error Resume Next   ' drop any chars that cause an error!
    sEncoded = ""
    lLen = Len(sUnencoded)
    For lPos = 1 To lLen
        nChr = Asc(Mid(sUnencoded, lPos, 1))
        ' we use Asc() because we can't handle Unicode in the URL anyway
        If (nChr >= 65 And nChr <= 90) Or (nChr >= 97 And nChr <= 122) _
           Or (nChr >= 48 And nChr <= 57) Then ' A..Z a..z 0..9
            sEncoded = sEncoded + Mid(sUnencoded, lPos, 1)
        ElseIf nChr >= 32 And nChr <= 125 Then
            sEncoded = sEncoded + "%" + Hex(nChr)
        ElseIf nChr >= 160 And nChr <= 191 Then
            sEncoded = sEncoded + "%C2%" + Hex(nChr)
        ElseIf nChr > 191 Then
            sEncoded = sEncoded + "%C3%" + Hex(nChr - 64)
        
        ' 0..31 and 126...160 are control characters not encoded (they are
        ' just stripped)
        End If
    Next lPos
    URLEncode = sEncoded
End Function

'== UI_ScreenUpdating ==============================================================
'
'   Purpose:    Enables or disables redraws within the Word window, allowing
'               macro activity to be hidden from the user.  Also sets the
'               wait cursor off or on.
'   Used By:    Various
'   Parameters: (in)  bShowUpdates: True for updates on, False for off
'   Returns:    N/A
'-----------------------------------------------------------------------------------
Public Sub UI_ScreenUpdating(bShowUpdates As Boolean)
    Application.ScreenUpdating = bShowUpdates
    
    If bShowUpdates Then
        Application.System.Cursor = wdCursorNormal
    Else
        Application.System.Cursor = wdCursorWait
    End If
End Sub

'== UI_ShowProgress ================================================================
'
' Purpose:  Show a progress bar on screen, with an optional Cancel button.
'
' Remarks:  fInitialValue is a percentage (0.5 = 50%).  If AllowCancel is true, make
'           sure to call UpdateProgress often and check its result.
'
'           You must call HideProgress when your code finishes (or hits an error)!
'-----------------------------------------------------------------------------------
Public Sub UI_ShowProgress(sTitle As String, bAllowCancel As Boolean, _
                               Optional fInitialValue As Single = 0)
    
    ' don't show a progress bar when Word is minimized
    If Application.WindowState <> wdWindowStateMinimize Then
        With frmProgress
            .m_sSubRangeStack = ""
            .m_bCancelFlag = False
            If sTitle <> "" Then
                .Caption = sTitle
            End If
            
            If bAllowCancel Then
                .cmdCancel.Visible = True
                .cmdCancel.Enabled = True
                .Height = .cmdCancel.Top + .cmdCancel.Height + .frameOuter.Top _
                           + .Height - .InsideHeight
            Else
                .cmdCancel.Visible = False
                .Height = (.frameOuter.Top * 2) + .frameOuter.Height _
                           + .Height - .InsideHeight
            End If
            UI_PaintProgressBar fInitialValue, True
        End With
        
        #If VBA6 Then
            ' post-Word 97 ONLY
            frmProgress.Show False
        #End If
    End If
End Sub


'== UI_UpdateProgress ==============================================================
'
'   Purpose:    Updates the progress bar to reflect percentage complete
'   Parameters: (in)  fPercentComplete: the percentage (e.g. 0.5 for 50%)
'   Returns:    (Boolean) True to continue processing, False if the user
'                         has cancelled
'-----------------------------------------------------------------------------------
Public Function UI_UpdateProgress(fPercentComplete As Single) As Boolean
    
    ' don't show a progress bar when Word is minimized
    If Application.WindowState <> wdWindowStateMinimize Then
        With frmProgress
            If .Visible = False Then
                UI_ShowProgress "", False, fPercentComplete
            Else
                .m_fCurrentPercent = fPercentComplete
                UI_PaintProgressBar UI_ScaleProgressToSubRange(fPercentComplete), False
            End If
            UI_UpdateProgress = Not .m_bCancelFlag
        End With
    End If
End Function

'== UI_IncrementProgress ===========================================================
'
' Purpose:  Adds a chunk to the progress bar.
' Returns:  (Boolean) True to continue processing, False if the user has cancelled
'
' Remarks:  Same as UpdateProgress, but designed for loops where it's hard to keep
'           track of the exact value!
'-----------------------------------------------------------------------------------
Public Function UI_IncrementProgress(fPercentIncrement As Single) As Boolean
    
    ' don't show a progress bar when Word is minimized
    If Application.WindowState <> wdWindowStateMinimize And fPercentIncrement > 0 Then
        With frmProgress
            If .Visible = False Then
                UI_ShowProgress "", False, fPercentIncrement
            Else
                .m_fCurrentPercent = .m_fCurrentPercent + fPercentIncrement
                UI_PaintProgressBar UI_ScaleProgressToSubRange(.m_fCurrentPercent), False
            End If
            UI_IncrementProgress = Not .m_bCancelFlag
        End With
    End If
End Function

'== UI_HideProgress ================================================================
'
' Purpose:  Turns off the progress bar.
'-----------------------------------------------------------------------------------
Public Function UI_HideProgress()
    Unload frmProgress
End Function

'== UI_PushProgressSubRange ========================================================
'
' Purpose:  Pushes a "sub range" onto the progress "stack".
'
' Remarks:  Subranges allow you to assign an interval on the progress bar to a
'           specific sub-operation.  For example:
'
'           PushProgressSubRange 0, 0.2     ' next operation gets first 20% of bar
'           InsertPictures
'               UpdateProgress 1/nPictures  ' automatically scaled within first 20%
'           ShiftProgressSubRange 0.2, 0.5  ' next phase of the operation
'           ...
'           PopProgressSubRange
'
'           Note that you must match up "push" and "pop" operations -- if you do not
'           the progress bar will appear to stall.  Push operations can be nested.
'-----------------------------------------------------------------------------------
Public Sub UI_PushProgressSubRange(ByVal fSubRangeStart As Single, _
                                   ByVal fSubRangeEnd As Single)
    
    If fSubRangeStart > 1 Then
        fSubRangeStart = 0
    End If
    If fSubRangeStart >= fSubRangeEnd Then
        fSubRangeEnd = 1
    End If
    
    ' start/end are treated as relative to current sub-range
    fSubRangeStart = UI_ScaleProgressToSubRange(fSubRangeStart)
    fSubRangeEnd = UI_ScaleProgressToSubRange(fSubRangeEnd)
        
    frmProgress.m_sSubRangeStack = Format(fSubRangeStart) & "_" _
                                   & Format(fSubRangeEnd) & "_" _
                                   & frmProgress.m_sSubRangeStack
    frmProgress.m_fCurrentPercent = 0
End Sub



'== UI_PopProgressSubRange =========================================================
'
' Purpose:  Removes the top "sub range" from the progress "stack".
'
' Remarks:  See remarks for PushProgressSubRange.
'-----------------------------------------------------------------------------------
Public Function UI_PopProgressSubRange()
    Dim sStackTemp As String
        
    frmProgress.m_fCurrentPercent = UI_ScaleProgressToSubRange(frmProgress.m_fCurrentPercent)
        
    sStackTemp = frmProgress.m_sSubRangeStack
    String_SplitFromList sStackTemp, "_"
    String_SplitFromList sStackTemp, "_"
    
    If sStackTemp = "_" Then
        frmProgress.m_sSubRangeStack = ""
    Else
        frmProgress.m_sSubRangeStack = sStackTemp
    End If
End Function

'== UI_ShiftProgressSubRange =======================================================
'
' Purpose:  Shifts the top "sub range" in the progress "stack".  (This effectively
'           pops it and pushes a new sub range.
'
' Remarks:  See remarks for PushProgressSubRange.
'-----------------------------------------------------------------------------------
Public Sub UI_ShiftProgressSubRange(ByVal fNewSubRangeStart As Single, _
                                ByVal fNewSubRangeEnd As Single)
                                
    UI_PopProgressSubRange
    UI_PushProgressSubRange fNewSubRangeStart, fNewSubRangeEnd
    UI_UpdateProgress 0
End Sub



'== UI_PaintProgressBar ============================================================
'
' Purpose:  Actually draws the progress bar, making sure it doesn't go backwards.
'-----------------------------------------------------------------------------------
Private Sub UI_PaintProgressBar(fPercentage As Single, bReset As Boolean)
    Const FRAME_MARGIN = 3
    Dim nBarWidth As Integer
    
    With frmProgress
        nBarWidth = CInt((.frameOuter.Width - FRAME_MARGIN) * fPercentage)
        If nBarWidth > .frameOuter.Width - FRAME_MARGIN Then
            nBarWidth = .frameOuter.Width - FRAME_MARGIN
        End If
        
        If nBarWidth = 0 Then
            .imgInner.Width = 0.5
            .imgInner.Visible = False
        ElseIf bReset Or nBarWidth > .imgInner.Width Then
            ' make sure we never go backwards except in a reset
            .imgInner.Visible = True
            .imgInner.Width = nBarWidth
        End If
    End With
    
    ' Process redraw requests
    frmProgress.Repaint
    DoEvents
End Sub

'== UI_ScaleProgressToSubRange =====================================================
'
' Purpose:  Evaluates the progress bar stack to scale progress values for sub-ranges
'
' Remarks:  See remarks for PushProgressSubRange.
'-----------------------------------------------------------------------------------
Private Function UI_ScaleProgressToSubRange(ByVal fValue As Single) As Single
    Dim fSubRangeStart As Single, fSubRangeEnd As Single
    Dim sSubRangeStack As String
    
    sSubRangeStack = frmProgress.m_sSubRangeStack
    
    If sSubRangeStack = "" Or sSubRangeStack = "_" Then
        ' no subrange -- scale 1:1
        UI_ScaleProgressToSubRange = fValue
    Else
        fSubRangeStart = Val(String_SplitFromList(sSubRangeStack, "_"))
        fSubRangeEnd = Val(String_SplitFromList(sSubRangeStack, "_"))
        
        If Not fSubRangeEnd > fSubRangeStart Then
            fSubRangeEnd = 1
        End If
        UI_ScaleProgressToSubRange = (fValue * (fSubRangeEnd - fSubRangeStart)) _
                                     + fSubRangeStart
    
        ' because we're not popping the subrange, we don't write our
        ' temporary copy back to the original stack
    End If
End Function



'== UI_SelectAndFocusFormTextBox ===================================================
'
' Purpose:  Set focus on a text box and select its contents.
'
' Params:   (in) txtBox: a text box in a userform
'
' Remarks:  Use this for a textbox that should have initial focus when a dialog box
'           appears
'-----------------------------------------------------------------------------------
Public Function UI_SelectAndFocusFormTextBox(txtBox As TextBox)
    Dim nSelLength As Integer
    
    nSelLength = Len(txtBox.Value)
    If nSelLength > 0 Then
        txtBox.SelStart = 0
        txtBox.SelLength = Len(txtBox.Value)
    End If
    txtBox.SetFocus
End Function

'== UI_SetAndSelectTextBoxText =====================================================
'
' Purpose:  Set the text within a text box and select its contents.
'
' Params:   (in) txtBox: a text box in a userform
'           (in) sValue: the new text for the box
'-----------------------------------------------------------------------------------
Public Function UI_SetAndSelectTextBoxText(txtBox As TextBox, sValue As String)
    Dim nSelLength As Integer
    
    txtBox.Value = sValue
    
    nSelLength = Len(sValue)
    If nSelLength > 0 Then
        txtBox.SelStart = 0
        txtBox.SelLength = Len(txtBox.Value)
    End If
End Function

'== UI_ReLabelAndShiftForm =========================================================
'
' Purpose:  Used to update the layout of a dialog box at runtime when a label changes
'
' Params:   (in) ctrlRelabel: the control being updated
'           (in) sNewLabel: the new label for the control
'           (in) sAltLabel: another label the control needs to be able to accomodate
'                           without resizing (normally "")
'           (in) ctrlShift1...5: other controls that need to shift layout
'           (in) bGrowOnly: never shrink controls when labels get shorter
'-----------------------------------------------------------------------------------
Public Sub UI_ReLabelAndShiftForm(ctrlReLabel As MSForms.control, _
                                  sNewLabel As String, _
                                  sAltLabel As String, _
                                  Optional ctrlShift1 As MSForms.control, _
                                  Optional ctrlShift2 As MSForms.control, _
                                  Optional ctrlShift3 As MSForms.control, _
                                  Optional ctrlShift4 As MSForms.control, _
                                  Optional ctrlShift5 As MSForms.control, _
                                  Optional bGrowOnly As Boolean = False)
    
    Dim fOldWidth As Single, fWidthShift As Single
    fOldWidth = ctrlReLabel.Width
    ctrlReLabel.WordWrap = False
    ctrlReLabel.AutoSize = True
    
    If sAltLabel = "" Then
        fWidthShift = 0
    Else
        ctrlReLabel.Caption = sAltLabel
        fWidthShift = ctrlReLabel.Width - fOldWidth
    End If
        
    ctrlReLabel.Caption = sNewLabel
    If bGrowOnly And ctrlReLabel.Width < fOldWidth Then
        ' used for buttons -- don't allow them to shrink
        ctrlReLabel.AutoSize = False
        ctrlReLabel.Width = fOldWidth
    End If
    If ctrlReLabel.Width - fOldWidth > fWidthShift Then
        fWidthShift = ctrlReLabel.Width - fOldWidth
    Else
        If sAltLabel <> "" Then
            ' the alt label was longer -- use it for now
            ' so that the dialog is resized properly
            ctrlReLabel.Caption = sAltLabel
        End If
    End If
    
    If fWidthShift > 0 Then
        If Not ctrlShift1 Is Nothing Then
            ctrlShift1.Left = ctrlShift1.Left + fWidthShift
            
            If Not ctrlShift2 Is Nothing Then
                ctrlShift2.Left = ctrlShift2.Left + fWidthShift
                
                If Not ctrlShift3 Is Nothing Then
                    ctrlShift3.Left = ctrlShift3.Left + fWidthShift
                    
                    If Not ctrlShift4 Is Nothing Then
                        ctrlShift4.Left = ctrlShift4.Left + fWidthShift
                        
                        If Not ctrlShift5 Is Nothing Then
                            ctrlShift5.Left = ctrlShift5.Left + fWidthShift
                        End If
                    End If
                End If
            End If
        End If
    End If
End Sub



'== UI_ReLabelAndShiftFormIfOverlap ================================================
'
' Purpose:  Used to update the layout of a dialog box at runtime when a label
'           changes, but only if the update causes an overlap of controls
'
' Params:   (in) ctrlRelabel: the control being updated
'           (in) sNewLabel: the new label for the control
'           (in) fSpacing: buffer zone between controls
'           (in) ctrlShift1: the control to check for overlap and shift
'           (in) bGrowOnly: never shrink controls when labels get shorter
'-----------------------------------------------------------------------------------
Public Sub UI_ReLabelAndShiftFormIfOverlap(ctrlReLabel As MSForms.control, _
                                           sNewLabel As String, _
                                           fSpacing As Single, _
                                           ctrlShift1 As MSForms.control, _
                                           Optional bGrowOnly As Boolean = False)

    Dim fNewRight As Single, fOldWidth As Single
    
    fOldWidth = ctrlReLabel.Width
    ctrlReLabel.WordWrap = False
    ctrlReLabel.AutoSize = True
    
    ctrlReLabel.Caption = sNewLabel
    If bGrowOnly And (ctrlReLabel.Width < fOldWidth) Then
        ' used for buttons -- don't allow them to shrink
        ctrlReLabel.AutoSize = False
        ctrlReLabel.Width = fOldWidth
    End If
    fNewRight = ctrlReLabel.Left + ctrlReLabel.Width
    
    If ctrlShift1.Left < fNewRight + fSpacing Then
        ctrlShift1.Left = fNewRight + fSpacing
    End If
End Sub



'== UI_SetFormUIFont ===============================================================
'
' Purpose:  Set the UI font and size for all controls in the dialog box
'
' Remarks:  Different locales may require a different UI font and size.
'-----------------------------------------------------------------------------------
Public Function UI_SetFormUIFont(form As UserForm, sFontName As String, _
                                 sFontSize As String)
    Dim ctrl As MSForms.control
    
    If sFontName <> "" And Val(sFontSize) > 0 Then
        form.Font.Name = sFontName
        form.Font.Size = Val(sFontSize)
    
        For Each ctrl In form.Controls
            ctrl.Font.Name = sFontName
            ctrl.Font.Size = Val(sFontSize)
        Next
    End If
End Function



'== UI_UpdateFormButtonLayout ======================================================
'
' Purpose:  Used to put OK and Cancel back in the bottom-right corner after a dialog
'           box layout has changed
'
' Params:   (in) fFormWidth: the new width for the form
'           (in) cmdOK: the OK button
'           (in) cmdCancel: the Cancel button, if any
'-----------------------------------------------------------------------------------
Sub UI_UpdateFormButtonLayout(fFormWidth As Single, cmdOK As MSForms.control, _
                              Optional cmdCancel As MSForms.control)

    Dim fButtonWidth As Single, fNewButtonWidth As Single
    fButtonWidth = cmdOK.Width
    cmdOK.AutoSize = True
    
    If cmdOK.Width > fButtonWidth Then
        fNewButtonWidth = cmdOK.Width
    Else
        fNewButtonWidth = fButtonWidth
    End If
    If cmdCancel Is Nothing Then
        cmdOK.AutoSize = False
        cmdOK.Width = fNewButtonWidth
        cmdOK.Left = fFormWidth - AT_DIALOG_MARGIN - fNewButtonWidth
    
    Else
        cmdCancel.AutoSize = True
        If cmdCancel.Width > fNewButtonWidth Then
            fNewButtonWidth = cmdCancel.Width
        End If
        cmdCancel.AutoSize = False
        cmdCancel.Width = fNewButtonWidth
        cmdCancel.Left = fFormWidth - AT_DIALOG_MARGIN - fNewButtonWidth
        
        cmdOK.AutoSize = False
        cmdOK.Width = fNewButtonWidth
        cmdOK.Left = fFormWidth - (2 * (fNewButtonWidth + AT_DIALOG_MARGIN))
    End If
End Sub



'== UI_ReLabelFormAndExpandDown ====================================================
'
' Purpose:  Used to update a multi-line caption (e.g. introductory text at the top
'           of a dialog box) which may shift down the rest of the dialog box.
'
' Params:   (in) ctrlRelabel: the control being updated
'           (in) sNewLabel: the new label for the control
'           (in) fDesiredRightEdge: the right edge for the control
' Returns:  (Single): the amount, if any, which the rest of the dialog box needs to
'                     be shifted down to accomodate the updated label
'-----------------------------------------------------------------------------------
Public Function UI_ReLabelFormAndExpandDown(ctrlReLabel As MSForms.control, _
                                            sNewLabel As String, _
                                            fDesiredRightEdge As Single) As Single

    Dim fOldHeight As Single, fHeightShift As Single
    fOldHeight = ctrlReLabel.Height
    ctrlReLabel.WordWrap = True
    ctrlReLabel.Caption = sNewLabel
    ctrlReLabel.Width = fDesiredRightEdge - ctrlReLabel.Left
    ctrlReLabel.AutoSize = True
    
    If ctrlReLabel.Height > fOldHeight Then
        fHeightShift = ctrlReLabel.Height - fOldHeight
    End If
    
    If fHeightShift > 0 Then
        UI_ReLabelFormAndExpandDown = fHeightShift
    Else
        UI_ReLabelFormAndExpandDown = 0
    End If
End Function


'== UI_ShiftFormDown ===============================================================
'
' Purpose:  Shifts a given control down, if it exists.
'-----------------------------------------------------------------------------------
Public Sub UI_ShiftFormDown(ctrlShift As MSForms.control, fHeightShift As Single)
    If Not ctrlShift Is Nothing Then
        ctrlShift.Top = ctrlShift.Top + fHeightShift
    End If
End Sub

'== UI_GetSystemColorRGB ===========================================================
'
' Purpose:  Returns RGB triplet with the current setting of a given system colour.
'
' Remarks:  There's no direct way to find out the background colour of a form in VBA
'           because they're set to a special value that represents the Buttonface
'           Windows colour.  But using a Windows API, we can find out what that is.
'-----------------------------------------------------------------------------------
Public Sub UI_GetSystemColorRGB(lSysColorIndex As Long, ByRef yR As Byte, _
                                ByRef yG As Byte, ByRef yB As Byte)
    Dim lRGB As Long
    lRGB = GetSysColor(lSysColorIndex)

    yR = lRGB Mod 256
    yG = (lRGB Mod 65536) \ 256
    yB = lRGB \ 65536
End Sub


Attribute VB_Name = "UtilUI2007"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' UtilUI2007:                                                               '
' ~~~~~~~~~~~                                                               '
'   Handles localized strings in the ribbon, and other Word 2007-specific   '
'   UI needs.                                                               '
'==========================================================================='
Option Explicit

' Control types in UI localization XML:
Global Const CTRLS_RIBBON = "ribbon"
Global Const CTRLS_DIALOG = "dialog"
Global Const CTRLS_MSGBOX = "messages"
Global Const CTRLS_PROGRESS = "progress"

' String types in UI localization XML:
Global Const STRING_LABEL = "label"
Global Const STRING_SCREENTIP = "screentip"
Global Const STRING_SUPERTIP = "supertip"
Global Const STRING_DATA = "data"

'== UI2007_BrowseLink ==============================================================
'
' Purpose:  Opens a web browser for a specific link on the ribbon.
'
' Params:   (in) doc: The document object for the template
'           (in) sControlId: the id of the ribbon control -- the URL is retrieved
'                            from its "data" field in the localized XML
'           (in) sText: additional text entered by the user (for search) -- it
'                       replaces "\text\" in the URL
'-----------------------------------------------------------------------------------
Public Sub UI2007_BrowseLink(doc As Document, sControlId As String, _
                             ByVal sText As String)
    
    Dim sURL As String, lPos As Long
    
    sURL = UI2007_GetLocalString(CTRLS_RIBBON, "", sControlId, STRING_DATA)
    If sURL <> "" Then
        ' Note UI_BrowseToPage will sanitize this parameter
        sURL = Replace(sURL, "\text\", sText)
    End If
    
    UI_BrowseToPage sURL, UI2007_GetLocalString(CTRLS_MSGBOX, "", "WebError", STRING_LABEL), _
                    UI2007_GetLocalString(CTRLS_MSGBOX, "", "title", STRING_LABEL)
End Sub



'== UI2007_GetLocalString ==========================================================
'
' Purpose:  Gets the localized version of a UI string from the UI strings XML.
'
' Params:   (in) sCtrlType: a CTRLS_* constant, e.g. CTRLS_RIBBON
'           (in) sParentId: used only if the control is a UserForm control;
'                           sParentId should be the .Name of the form
'           (in) sId: the control's ID or .Name property
'           (in) sStringType: a STRING_* constant, e.g. STRING_LABEL
' Returns:  (String) the localized value, or "" if no localized string found
'-----------------------------------------------------------------------------------
Public Function UI2007_GetLocalString(sCtrlType As String, sParentId As String, _
                                      sId As String, sStringType As String, _
                                      Optional nApplySymbolsMode As Long = 0 _
                                      ) As String
                                    
    Static cxpUIStrings As CustomXMLPart
    Dim cxnControl As CustomXMLNode, cxnAttribute As CustomXMLNode
    Dim cxnsStrings As CustomXMLNodes, cxnString As CustomXMLNode
    Dim sXPath As String, sAlias As String, bMatch As Boolean
    Dim sProductType As String, sProductGroup As String, sLocString As String
    
    ' we never want to fail in this function...
    On Error Resume Next
    
    If g_trRibbonConfig Is Nothing Then
        UI2007_GetLocalString = ""
        Exit Function
    Else
        If cxpUIStrings Is Nothing Then
            Set cxpUIStrings = XML_GetCustomPartBySchemaAndRootElement( _
                                            g_trRibbonConfig.Document(), _
                                            AVERY_SCHEMA, "averyUIStrings")
        End If
        sProductType = g_trRibbonConfig.CurrentSection().ProductType()
        sProductGroup = g_trRibbonConfig.CurrentSection().ProductGroup()
    End If
    If sCtrlType = "" Or sId = "" Or sStringType = "" Then
        UI2007_GetLocalString = ""
    Else
        If sParentId <> "" Then
            sXPath = sCtrlType & "[@id=""" & sParentId & """]"
        Else
            sXPath = sCtrlType
        End If
        sXPath = sXPath & "/control[@id=""" & sId & """]"
        Set cxnControl = XML_SelectSingleNode(cxpUIStrings, sXPath)
            
        If cxnControl Is Nothing Then
            UI2007_GetLocalString = ""
        ElseIf cxnControl.ChildNodes.Count = 0 Then
            ' if no strings are supplied, use the control's alias, if any
            sAlias = XML_GetAttribute(cxnControl, "alias")
            UI2007_GetLocalString = UI2007_GetLocalString(sCtrlType, "", sAlias, _
                                                          sStringType)
        Else
            ' look through each matching node -- there may be several, with
            ' different attributes that tell us which node applies, e.g.
            '  <caption productType="Mailing_AddressWithReturn">Return Addresses</caption>
            '  <caption productTypePrefix="Card">Cards</caption>
            '  <caption>Labels</caption>
            ' (Note that the first matching node is used.)
        
            Set cxnsStrings = XML_SelectNodes(cxnControl, sStringType)
            
            If Not cxnsStrings Is Nothing Then
                For Each cxnString In cxnsStrings
                    ' assume we get a match, and will return this node's text
                    bMatch = True
                    sLocString = cxnString.Text
                    
                    ' check the node's attributes for filters and modifiers
                    For Each cxnAttribute In cxnString.Attributes
                        
                        ' check productTypePrefix/productType, if present
                        If cxnAttribute.BaseName = "productTypePrefix" Then
                            bMatch = WordPort_MatchProduct(cxnAttribute.Text, sProductType, True)
                        ElseIf cxnAttribute.BaseName = "productType" Then
                            bMatch = WordPort_MatchProduct(cxnAttribute.Text, sProductType, False)
                        ElseIf cxnAttribute.BaseName = "productGroup" Then
                            bMatch = WordPort_MatchProduct(cxnAttribute.Text, sProductGroup, False)
                        ElseIf cxnAttribute.BaseName = "useMso" Then
                            ' useMso indicates we get the value from Word
                            ' this can be used in conjunction with filters, if needed
                            sLocString = Application.CommandBars.GetLabelMso( _
                                                                    cxnAttribute.Text)
                        End If
                        
                        If Not bMatch Then
                            ' if one of the attributes in this node _doesn't_ match,
                            ' stop processing this node and continue to the next
                            Exit For
                        End If
                    Next ' Attribute
                    If bMatch Then
                        ' if this string matches, use it; if not, continue to the
                        ' next string
                        If nApplySymbolsMode = 0 Then
                            UI2007_GetLocalString = sLocString
                        Else
                            UI2007_GetLocalString = String_ApplySymbols( _
                                sLocString, (nApplySymbolsMode = APPLY_SYMBOLS_LOCALE))
                        End If
                        
                        Exit Function
                    End If
                Next ' String
            End If
            
            ' if we reach this point, none of the strings matched
            UI2007_GetLocalString = ""
        End If
    End If
End Function



'== UI2007_ShowProgress ============================================================
'
' Purpose:  Show a progress bar in a Word 2007 template.
'
' Remarks:  Using sId, automatically gets the localized title for the progress bar.
'-----------------------------------------------------------------------------------
Public Sub UI2007_ShowProgress(sId As String, bAllowCancel As Boolean, _
                                   Optional fInitialValue As Single = 0)
    Dim sLocString As String
    
    sLocString = UI2007_GetLocalString(CTRLS_PROGRESS, "", sId, STRING_LABEL, _
                                       APPLY_SYMBOLS_LOCALE)
    If sLocString = "" Then
        sLocString = sId
    End If
    
    UI_ShowProgress sLocString, bAllowCancel, fInitialValue
End Sub



'== UI2007_MsgBox ==================================================================
'
' Purpose:  Show a localized message box in a Word 2007 template.
'
' Params:   (in) sPromptId: a prompt listed in the localized UI XML.
'           [in] lButtons: the VB buttons and icon constants for the message box
'           [in] lErrorCode: an error code to append to the message
' Returns:  the result of the message box (same as the built-in MsgBox function)
'-----------------------------------------------------------------------------------
Public Function UI2007_MsgBox(sPromptId As String, _
                                    Optional lButtons As Long = vbExclamation, _
                                    Optional lErrorCode As Long = 0) As Long
    
    Dim sTitle As String, sPrompt As String, sError As String
    
    sTitle = UI2007_GetLocalString(CTRLS_MSGBOX, "", "title", STRING_LABEL, _
                                   APPLY_SYMBOLS_LOCALE)
    sPrompt = UI2007_GetLocalString(CTRLS_MSGBOX, "", sPromptId, STRING_LABEL, _
                                   APPLY_SYMBOLS_ALWAYS)
    If sPrompt = "" Then
        sPrompt = sPromptId
    End If

    If lErrorCode <> 0 Then
        sError = UI2007_GetLocalString(CTRLS_MSGBOX, "", "error", STRING_LABEL, _
                                       APPLY_SYMBOLS_NONE)
        sPrompt = sPrompt & vbCr & vbCr & Replace(sError, "%1", Format(lErrorCode))
    End If
    
    UI2007_MsgBox = MsgBox(sPrompt, lButtons, sTitle)
End Function
Attribute VB_Name = "UtilWord"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' UtilWord:                                                                 '
' ~~~~~~~~~                                                                 '
'   Utility functions for common interactions with Word documents.  Many    '
'   functions help retrieve values without triggering a run-time error if   '
'   the value is missing.                                                   '
'==========================================================================='
Option Explicit

' Word constants:
Global Const VER_WORD_2000 = 9
Global Const VER_WORD_2002 = 10
Global Const VER_WORD_2003 = 11
Global Const VER_WORD_2007 = 12
Global Const VER_WORD_2010 = 14
Global Const VER_OS_VISTA = 6

Global Const WORD_DLG_OK = -1
Global Const WORD_MIXED = 9999999

Global Const PROFILE_SECTION_AVERY = "Avery Dennison"

' Picture options:
Global Const REPOSITION_NONE As Single = -99999

' State constants for refresh events... (see AveryDocumentRefresh)
Private m_docResetProofingState As Document
Private m_bNoBackgroundSpelling As Boolean
Private m_bNoBackgroundGrammar As Boolean
Private m_bMandatoryRefresh As Boolean
Private m_docScrollDoc As Document
Private m_lPctScrolled As Long

'===================================================================================
' Word Application
'-----------------------------------------------------------------------------------

'== Word_VersionAtLeast ============================================================
'
' Purpose:  Allows version-specific code to be run
'
' Params:   (in) a Word Version number (use a VER_WORD constant)
' Returns:  (Boolean) True if the running version of Word is at least the requested
'                     version.
'
' Remarks:  Remember that your code must still compile in all versions of Word.  To
'           access methods and properties not defined in all versions, you must use
'           a latebound object (assigned to an Object variable rather than a
'           specific type).
'-----------------------------------------------------------------------------------
Public Function Word_VersionAtLeast(lVersionNumber As Long) As Boolean
    On Error Resume Next
    Word_VersionAtLeast = False
    Word_VersionAtLeast = (Val(Application.Version) >= lVersionNumber)
End Function

'== Word_ShowGridlines =============================================================
'
' Purpose:  Turns on gridlines.
'
' Params:   N/A
' Returns:  N/A
'
' Remarks:  This is an app-level setting, but we sometimes turn it on because our
'           templates make so much more sense when you can see the panel edges.
'-----------------------------------------------------------------------------------
Public Function Word_ShowGridlines()
    On Error Resume Next
    If Application.Windows.Count > 0 Then
        Application.ActiveWindow.View.TableGridlines = True
    End If
End Function

'== Word_ValidateSupport ===========================================================
'
' Purpose:  Determines if the template is running in a supported version of Word.
'
' Params:   (out) sReasonMsg: if Validate fails, this parameter will be set to an
'                             error message to show to the end user.
' Returns:  (Boolean) True if the template is supported, False if it isn't.
'
' Remarks:  ValidateSupport checks for Word 2002 or later on Windows 2000 or later.
'-----------------------------------------------------------------------------------
Public Function Word_ValidateSupport(Optional ByRef sReasonMsg As String) As Boolean
    Dim fWordVersion As Single, sOS As String, sErrorCode As String
    
    On Error Resume Next
    fWordVersion = Val(Application.Version)
    sOS = Application.System.OperatingSystem
    On Error GoTo 0
    
    If fWordVersion < VER_WORD_2002 Then
        sReasonMsg = "The advanced features in this template are not " _
                     & "available because they require Microsoft Word 2002 " _
                     & "or later."
        sErrorCode = "1005-" & Application.Version
    
    ElseIf sOS = "Windows" Then
        ' Windows ME/98/95
        sReasonMsg = "The advanced features of this template are not " _
                     & "available because they require Microsoft Windows 2000 " _
                     & "or later."
        sErrorCode = "1006-" & Application.System.Version
    
    ElseIf Left(sOS, 7) <> "Windows" Then
        ' MacOS
        sReasonMsg = "The advanced features of this template are not " _
                     & "available in Macintosh versions of Microsoft Word."
    Else
        sReasonMsg = ""
    End If
    If sReasonMsg = "" Then
        Word_ValidateSupport = True
    Else
        sReasonMsg = sReasonMsg & vbCr & vbCr & "To add text to the template, type " _
                                & "the text into the table cells in this document."
        If sErrorCode <> "" Then
            sReasonMsg = sReasonMsg & vbCr & vbCr & "(Error: " & sErrorCode & ")"
        End If
        Word_ValidateSupport = False
    End If
End Function



'== Word_ProfileString =============================================================
'
' Purpose:  Gets a profile string from the registry, without throwing errors.
'
' Params:   (in) sSection, sKey: profile section and key for the string
' Returns:  (String): the value from the registry, or "" if the key isn't set
'-----------------------------------------------------------------------------------
Public Function Word_ProfileString(sSection As String, _
                                     sKey As String) As String
    ' System.ProfileString throws an error if the key doesn't exist
    On Error Resume Next
    
    Word_ProfileString = ""
    Word_ProfileString = System.ProfileString(sSection, sKey)
End Function

'===================================================================================
' Word Documents and Windows
'-----------------------------------------------------------------------------------

'== AveryDocumentRefresh ===========================================================
'
' Purpose:  Triggers a screen refresh.
'
' Remarks:  This sub needs to be public so that it can be called using .OnTime.
'
'           It is typically used at the end of fill operations -- refreshing in the
'           fill code has no effect, but refreshing during Word's "idle" loop (a
'           split second later) works.
'
'           It also handles refreshes after vertical scrolling, which overcomes a
'           Word 2002/2003 refresh bug.
'-----------------------------------------------------------------------------------
Public Sub AveryDocumentRefresh()
    On Error Resume Next    ' handle errors silently in this background function
    
    ' standard refresh (set by Word_SetDelayedRefresh)
    If m_bMandatoryRefresh Then
        Application.ScreenRefresh
    End If
    
    ' restore proofing state (set by Word_TempDisableBackgroundProofing)
    If Not (m_docResetProofingState Is Nothing) Then
        DoEvents
        ' these options default to false... so if the user never called
        ' TempDisableBackgroundProofing, or the variables somehow got cleared, we assume
        ' spelling/grammar should be on (which is the default in Word)
        
        If Not m_bNoBackgroundSpelling Then
            m_docResetProofingState.ShowSpellingErrors = True
            'Application.Options.CheckSpellingAsYouType = True
        End If
        
        If Not m_bNoBackgroundGrammar Then
            m_docResetProofingState.ShowGrammaticalErrors = True
            'Application.Options.CheckGrammarAsYouType = True
        End If
        Set m_docResetProofingState = Nothing
        m_bNoBackgroundGrammar = False
        m_bNoBackgroundSpelling = False
        
        Application.ScreenRefresh
    End If

    ' scroll-based refresh (set by Word_SetRefreshOnScroll)
    If Not (m_docScrollDoc Is Nothing) And (Application.Documents.Count > 0) Then
        If ActiveDocument.FullName = m_docScrollDoc.FullName Then
            If ActiveWindow.VerticalPercentScrolled <> m_lPctScrolled _
             And Not m_bMandatoryRefresh Then
                ' if we haven't already refreshed, do it now
                Application.ScreenRefresh
            End If
            ' save the new scroll position
            m_lPctScrolled = ActiveWindow.VerticalPercentScrolled
        End If
        ' repeat every two seconds
        Application.OnTime Now() + TimeValue("0:00:02"), "AveryDocumentRefresh"
    End If
    
    ' turn off mandatory refresh (it's a one-time thing)
    m_bMandatoryRefresh = False
End Sub

'== TempDisableBackgroundProofing ==================================================
'
' Purpose:  Temporarily disables background spelling and grammar, if necessary.
'
' Returns:  True if background proofing was disabled, False if it wasn't.
'
' Remarks:  You must call AveryDocumentRefresh to re-enable proofing.  Make sure to
'           only call this function once, or it will overwrite its own settings!
'-----------------------------------------------------------------------------------
Public Function Word_TempDisableBackgroundProofing(doc As Document) As Boolean
    
    m_bNoBackgroundSpelling = Not doc.ShowSpellingErrors
    m_bNoBackgroundGrammar = Not doc.ShowGrammaticalErrors
    ' if either feature is turned on, we need to reset the options on refresh later
    If m_bNoBackgroundSpelling And m_bNoBackgroundGrammar Then
        Set m_docResetProofingState = Nothing
    Else
        Set m_docResetProofingState = doc
        doc.ShowSpellingErrors = False
        doc.ShowGrammaticalErrors = False
    End If

    Word_TempDisableBackgroundProofing = Not (m_docResetProofingState Is Nothing)
End Function

'== Word_SetDelayedRefresh =========================================================
'
' Purpose:  Calls AveryDocumentRefresh two seconds later to refresh the document.
'
' Returns:  Nothing.  (Just a function so it isn't listed in Tools | Macros.)
'
' Remarks:  This function sets a mandatory refresh -- i.e. the app is refreshed
'           once, regardless of its current state.  See also
'           Word_SetRefreshOnScroll, below.
'-----------------------------------------------------------------------------------
Public Function Word_SetDelayedRefresh()
    m_bMandatoryRefresh = True
    Application.OnTime Now() + 0.000025, "AveryDocumentRefresh"
End Function

'== Word_SetRefreshOnScroll ========================================================
'
' Purpose:  Calls AveryDocumentRefresh every two seconds to force a refresh of the
'           document whenever it's been vertically scrolled.
'
' Remarks:  This fixes an unfortunate Word bug where table cells (cloned cells
'           in QuickFill templates for 2002/2003, and pasted cells in templates
'           where the user has clicked Add Sheet) don't get drawn after large
'           vertical scrolling.  Two seconds is judged to be fast enough to avoid
'           confusion and slow enough to avoid an unnecessary performance drag.
'-----------------------------------------------------------------------------------
Public Sub Word_SetRefreshOnScroll(doc As Document)
    If m_docScrollDoc Is Nothing Then
        ' don't initialize twice!
        Set m_docScrollDoc = doc
        m_lPctScrolled = -1 ' force initial refresh
        
        Application.OnTime Now() + 0.000025, "AveryDocumentRefresh"
    End If
End Sub

'== Word_DocStateValid =============================================================
'
' Purpose:  Determines if we're operating in a valid, workable state.
'
' Params:   (in) docActive: the ActiveDocument variable.
'           (in) docMe: the Me variable (as available in the ThisDocument class).
' Returns:  (Boolean) True if the state is valid, False if code won't run properly.
'
' Remarks:  Based on experiments with templates downloaded from web sites, the New
'           and Open events sometimes fire before the document is ready to be
'           used.  This function detects that state so that we can choose not to run
'           our code at that time.  (The user then has to click in the "web install"
'           text box to start the template manually.)
'-----------------------------------------------------------------------------------
Public Function Word_DocStateValid(docActive As Document, docMe As Document) As Boolean
    Dim bActiveDocumentOK As Boolean, bActiveTemplateOK As Boolean

    Word_DocStateValid = False
    
    On Error Resume Next
    bActiveDocumentOK = (docActive.FullName = docMe.FullName)
    bActiveTemplateOK = (docActive.AttachedTemplate.FullName = docMe.FullName)

    Word_DocStateValid = bActiveDocumentOK Or bActiveTemplateOK
End Function

'== Word_DocProp ===================================================================
'
' Purpose:  Returns a Word custom document property, without throwing errors.
'
' Params:   (in) doc: the document which contains the property
'           (in) sDocPropName: the name of the property
' Returns:  (String): the value of the property, or "" if it doesn't exist
'-----------------------------------------------------------------------------------
Public Function Word_DocProp(doc As Document, sDocPropName As String) As String

    On Error Resume Next
    Word_DocProp = ""
    Word_DocProp = doc.CustomDocumentProperties(sDocPropName).Value
End Function

'== Word_TemplateDocProp ===========================================================
'
' Purpose:  Returns a Word custom document property from the underlying template,
'           without throwing errors.
'
' Params:   (in) doc: the document whose template may contain the property
'           (in) sTemplatePropName: the name of the property
' Returns:  (String): the value of the property, or "" if it doesn't exist
'-----------------------------------------------------------------------------------
Public Function Word_TemplateDocProp(doc As Document, _
                                     sTemplatePropName As String) As String

    On Error Resume Next
    Word_TemplateDocProp = ""
    
    If Not (doc.AttachedTemplate Is Nothing) Then
        Word_TemplateDocProp = doc.AttachedTemplate.CustomDocumentProperties( _
                                                        sTemplatePropName).Value
    End If
End Function

'== Word_SetDocProp ================================================================
'
' Purpose:  Sets a Word custom document property, adding it if neccessary.
'
' Params:   (in) doc: the document which contains the property
'           (in) sDocPropName: the name of the property
'           (in) sValue: the new value for the property
'-----------------------------------------------------------------------------------
Public Sub Word_SetDocProp(doc As Document, sDocPropName As String, _
                             sValue As String)
    Dim prop As DocumentProperty

    On Error Resume Next
    Set prop = Nothing
    Set prop = doc.CustomDocumentProperties(sDocPropName)
    
    If prop Is Nothing Then
        doc.CustomDocumentProperties.Add Name:=sDocPropName, _
                                         LinkToContent:=False, Value:=sValue, _
                                         Type:=msoPropertyTypeString
    Else
        prop.Value = sValue
    End If
End Sub



'== Word_DeleteDocProp =============================================================
'
' Purpose:  Deletes a Word custom document property, without throwing errors.
'
' Params:   (in) doc: the document which contains the property
'           (in) sDocPropName: the name of the property
'-----------------------------------------------------------------------------------
Public Sub Word_DeleteDocProp(doc As Document, sDocPropName As String)
    Dim prop As DocumentProperty

    On Error Resume Next
    Set prop = Nothing
    Set prop = doc.CustomDocumentProperties(sDocPropName)
    
    If Not (prop Is Nothing) Then
        prop.Delete
    End If
End Sub

'===================================================================================
' Word Text, Text Ranges, and Bookmarks
'-----------------------------------------------------------------------------------

'== Word_CollapseRangeExcludeAnchors ===============================================
'
' Purpose:  Collapses a Word range object, avoiding floating shape anchors as
'           described in the remarks.
'
' Params:   (in) rng: the Range to collapse
' Returns:  (Range) the collapse range
'
' Remarks:  This function collapses a range to its start BUT excludes floating shape
'           anchors -- .g. if the input range is a table cell, the result will be a
'           range that sits immediately after the anchors and before the first
'           character.
'-----------------------------------------------------------------------------------
Public Function Word_CollapseRangeExcludeAnchors(rng As Range) As Range
    
    Dim rngWithoutAnchors As Range
    
    If rng Is Nothing Then
        Set Word_CollapseRangeExcludeAnchors = Nothing
    Else
        Set rngWithoutAnchors = rng.Duplicate
        rngWithoutAnchors.Start = rng.Characters(1).End - 1
        rngWithoutAnchors.Collapse wdCollapseStart
        
        Set Word_CollapseRangeExcludeAnchors = rngWithoutAnchors
    End If
End Function

'== Word_SetBookmarkText ===========================================================
'
' Purpose:  Sets the text contained within a bookmark, without deleting nearby
'           floating shapes.
'
' Params:   (in) doc: the document to update
'           (in) sBkmkName: the bookmark to update
'           (in) sFieldText: the text to place within the bookmark
'
' Remarks:  The bookmark's name may change due to this function.  WordPort sometimes
'           generates bookmark names that cannot be set through the object model.
'-----------------------------------------------------------------------------------
Public Sub Word_SetBookmarkText(doc As Document, ByVal sBkmkName As String, _
                                ByVal sFieldText As String)
    Dim rngBookmark As Range, bkmkTarget As Bookmark
    
    If Not doc.Bookmarks.Exists(sBkmkName) Then
        Exit Sub
    End If
    Set bkmkTarget = doc.Bookmarks(sBkmkName)
    Set rngBookmark = Word_AdjustedRange(bkmkTarget)
        
    ' Word_AdjustedRange trims anchors at the start and end, but a shape could still
    ' be anchored in the middle...
    Word_ConsolidateAnchors rngBookmark
    rngBookmark.Text = sFieldText
    
    Word_ReApplyBookmark rngBookmark, sBkmkName
End Sub



'== Word_ReApplyBookmark ===========================================================
'
' Purpose:  Ensures a range that has just been updated still has its bookmark
'           applied.
'
' Params:   (in) rngTarget: the updated range
'           (in) sBkmkName: the bookmark name that was originally associated with
'                           rngTarget
'
' Remarks:  The bookmark's name may change due to this function.  WordPort sometimes
'           generates bookmark names that cannot be set through the object model.
'-----------------------------------------------------------------------------------
Public Sub Word_ReApplyBookmark(rngTarget As Range, sBkmkName As String)
    Dim doc As Document, sBkmkNameClean As String
    
    Set doc = rngTarget.Document
    sBkmkNameClean = Word_CleanseBookmarkName(sBkmkName)
    
    If sBkmkNameClean <> "" Then
        If doc.Bookmarks.Exists(sBkmkName) Then
            ' delete old bookmark so we can apply new name & range
            doc.Bookmarks(sBkmkName).Delete
        End If
        ' make sure new name doesn't collide with anything (this really shouldn't
        ' happen, but just in case...)
        If doc.Bookmarks.Exists(sBkmkNameClean) Then
            doc.Bookmarks(sBkmkNameClean).Delete
        End If
        
        rngTarget.Bookmarks.Add sBkmkNameClean
    End If
End Sub

'== Word_AdjustedRange =============================================================
'
' Purpose:  Adjusts the range of a bookmark to eliminate common problems.
'
' Params:   (in) bkmk: the bookmark to examine
' Returns:  (Range): the "adjusted" range of the bookmark
'
' Remarks:  This function fixes a variety of problems, including:
'           - Empty bookmarks at the beginning of a table cell (where the user has
'             typed text just after the bookmark)
'           - Paragraph and end-of-cell marks that, if deleted, would cause text to
'             be re-formatted
'           - AutoShapes anchored at the beginning or end of the bookmark -- note
'             that autoshapes embedded in the middle are not handled, but you can
'             call Word_ConsolidateAnchors on the adjusted range to handle that.
'-----------------------------------------------------------------------------------
Public Function Word_AdjustedRange(bkmk As Bookmark) As Range
    Dim rng As Range, shpCurrent As Shape, cellCurrent As Cell
    
    Set rng = bkmk.Range.Duplicate
    If rng.StoryType = wdTextFrameStory Then
        ' expand the bookmark's range to encompass the whole text box
        rng.Expand wdStory
        
        If rng.Bookmarks.Count > 1 Then
            ' multiple bookmarks within the textbox -- undo expansion
            Set rng = bkmk.Range.Duplicate
        End If
    Else
        Set cellCurrent = Word_CellFromRange(rng)
    
        If Not cellCurrent Is Nothing Then
            If cellCurrent.Range.Bookmarks.Count <= 1 Then
                ' expand to entire table cell (if only one bookmark)
                Set rng = cellCurrent.Range.Duplicate
                rng.End = rng.End - 1   ' except the end-of-cell mark
            End If
        End If
    End If
        
    ' bookmark may include the trailing para mark, but we ignore it
    If rng.Characters(rng.Characters.Count) = vbCr Then
        rng.End = rng.End - 1
    End If
    
    ' if there's an autoshape anchored to the beginning or end of the bookmark,
    ' exclude it so we don't delete it while replacing text
    If Word_HasShapeRange(rng) Then
        For Each shpCurrent In rng.ShapeRange
            If shpCurrent.Anchor.Start = rng.Start Then
                rng.Start = shpCurrent.Anchor.End
            ElseIf shpCurrent.Anchor.End = rng.End Then
                rng.End = shpCurrent.Anchor.Start
            End If
        Next
    End If
    
    Set Word_AdjustedRange = rng
End Function

'== Word_ConsolidateAnchors ========================================================
'
' Purpose:  Deletes all text in a range except for the anchors.
'
' Params:   (in) rngTotal: the overall range to process
'
' Remarks:  Typically used after Word_AdjustedRange to "clear" a bookmark that is
'           about to be updated.
'-----------------------------------------------------------------------------------
Public Sub Word_ConsolidateAnchors(ByRef rngTotal As Range)
    Dim rngSubRange As Range

    Do While Word_HasShapeRange(rngTotal)
        Set rngSubRange = rngTotal.Duplicate
        rngTotal.Start = rngTotal.ShapeRange(1).Anchor.End
        rngSubRange.End = rngSubRange.ShapeRange(1).Anchor.Start
        
        ' call ourselves recursively in case the subrange before
        ' ShapeRange(1).Anchor includes the anchor for another shape...
        Word_ConsolidateAnchors rngSubRange
        
        ' once we're sure we're not deleting any anchors, delete the subrange
        ' (if there's anything left to it after consolidating)
        If rngSubRange.End > rngSubRange.Start Then
            rngSubRange.Delete
        End If
        
        ' repeat for any anchors that may have been after the subrange...
    Loop
End Sub

'== Word_CleanseBookmarkName =======================================================
'
' Purpose:  Returns a valid version of a given bookmark name.
'
' Params:   (in) sBookmarkName: a potentially invalid name
' Returns:  (String) the valid name
'
' Remarks:  WordPort sometimes includes decimal points in its bookmark names, which
'           the Word object model can't handle.  In order to reapply the bookmark,
'           we must strip out the decimal points.
'-----------------------------------------------------------------------------------
Public Function Word_CleanseBookmarkName(ByVal sBookmarkName As String) As String

    Dim lPosPeriod As Long, lPosUnderscore As Long
    
    sBookmarkName = Trim(sBookmarkName)
    
    lPosPeriod = InStr(sBookmarkName, ".")
    Do While lPosPeriod > 0
        lPosUnderscore = InStr(lPosPeriod + 1, sBookmarkName, "_")
        If lPosUnderscore = 0 Then
            sBookmarkName = Left(sBookmarkName, lPosPeriod - 1)
        Else
            sBookmarkName = Left(sBookmarkName, lPosPeriod - 1) _
                            & Mid(sBookmarkName, lPosUnderscore)
        End If
        lPosPeriod = InStr(sBookmarkName, ".")
    Loop
    Word_CleanseBookmarkName = sBookmarkName
End Function



'== Word_CopyStyleAndFormatting ====================================================
'
' Purpose:  Copies typical font and paragraph formatting from one range to another.
'
' Params:   (in) rngSource: the source of the formatting
'           (in) rngTarget: the range to reformat
'
' Remarks:  Obviously, this doesn't cover all possible formatting, but it is very
'           useful for making a new text box match the font properties of the
'           underlying cell.
'-----------------------------------------------------------------------------------
Public Sub Word_CopyStyleAndFormatting(rngSource As Range, rngTarget As Range, _
                                       bForceLeftAlign As Boolean)
    With rngSource
        If .Style <> "" Then
            rngTarget.Style = .Style
        End If
        If .Font.Name <> "" And .Font.Name <> rngTarget.Font.Name Then
            rngTarget.Font.Name = .Font.Name
        End If
        If .Font.Size <> WORD_MIXED And .Font.Size <> rngTarget.Font.Size Then
            rngTarget.Font.Size = .Font.Size
        End If
        If .Font.Bold <> WORD_MIXED And .Font.Bold <> rngTarget.Font.Bold Then
            rngTarget.Font.Bold = .Font.Bold
        End If
        If .Font.Italic <> WORD_MIXED And .Font.Italic <> rngTarget.Font.Italic Then
            rngTarget.Font.Italic = .Font.Italic
        End If
        If .Font.Italic <> WORD_MIXED And .Font.Italic <> rngTarget.Font.Italic Then
            rngTarget.Font.Italic = .Font.Italic
        End If
    
        If bForceLeftAlign Then
            rngTarget.ParagraphFormat.Alignment = wdAlignParagraphLeft
        ElseIf .ParagraphFormat.Alignment <> WORD_MIXED _
         And .ParagraphFormat.Alignment <> rngTarget.ParagraphFormat.Alignment Then
            rngTarget.ParagraphFormat.Alignment = .ParagraphFormat.Alignment
        End If
    End With
End Sub



'===================================================================================
' Word Tables
'-----------------------------------------------------------------------------------

'== Word_TableCell =================================================================
'
' Purpose:  Returns a cell from a table, while suppressing the VBA error that
'           occurs if it doesn't exist
'
' Params:   (in) shp: the shape that might have a text frame
' Returns:  (Boolean) True if it does, False if it doesn't
'-----------------------------------------------------------------------------------
Private Function Word_TableCell(tbl As Table, lRow As Long, lCol As Long) As Cell
    Dim cellResult As Cell, cellCurrent As Cell, lCellIndex As Long
    
    On Error Resume Next
    Set cellResult = Nothing
    If Word_VersionAtLeast(VER_WORD_2002) Then
        Set cellResult = tbl.Cell(lRow, lCol)
    Else
        ' .Cell() in Word 2000 counts columns differently
        ' but .ColumnIndex stays accurate
        For lCellIndex = 1 To lCol
            Set cellCurrent = tbl.Cell(lRow, lCellIndex)
            If Not cellCurrent Is Nothing Then
                If cellCurrent.ColumnIndex = lCol Then
                    Set cellResult = cellCurrent
                    Exit For
                End If
            End If
        Next lCellIndex
    End If
    
    If cellResult Is Nothing Then
        Set Word_TableCell = Nothing
    ElseIf cellResult.RowIndex <> lRow Then
        ' When the row number is too high, Word sometimes returns the
        ' corresponding cell in the last valid row -- we don't want this!
        Set Word_TableCell = Nothing
    Else
        Set Word_TableCell = cellResult
    End If
End Function

'== Word_CellFromRange =============================================================
'
' Purpose:  Given a Range, returns the parent Cell, if any.
'
' Params:   (in) rngInTable: a range that is expected to be in a table
' Returns:  (Cell): the parent cell, or Nothing if the range wasn't in a table.
'-----------------------------------------------------------------------------------
Public Function Word_CellFromRange(rngInTable As Range) As Cell
    On Error Resume Next
    
    Set Word_CellFromRange = Nothing
    If rngInTable.Tables.Count > 0 Then
        Set Word_CellFromRange = rngInTable.Cells(1)
    End If
End Function

'== Word_ColumnIndexFromRange ======================================================
'
' Purpose:  Returns the column index from a range that may be in a table.
'
' Params:   (in) rngInTableCell: the range
' Returns:  (Long): the column index reported by Word, or 0 if not in a table
'-----------------------------------------------------------------------------------
Public Function Word_ColumnIndexFromRange(rngInTableCell As Range) As Long
    On Error Resume Next
    Word_ColumnIndexFromRange = 0
    Word_ColumnIndexFromRange = rngInTableCell.Cells(1).ColumnIndex
End Function

'== Word_RowIndexFromRange =========================================================
'
' Purpose:  Returns the row index from a range that may be in a table.
'
' Params:   (in) rngInTableCell: the range
' Returns:  (Long): the row index reported by Word, or 0 if not in a table
'-----------------------------------------------------------------------------------
Public Function Word_RowIndexFromRange(rngInTableCell As Range) As Long
    Dim shpTextbox As Shape
    
    On Error Resume Next
    Word_RowIndexFromRange = 0
    
    If rngInTableCell.StoryType = wdTextFrameStory Then
        Set shpTextbox = Word_ParentTextBox(rngInTableCell)
        If Not (shpTextbox Is Nothing) Then
            Word_RowIndexFromRange = shpTextbox.Anchor.Cells(1).RowIndex
        End If
    Else
        Word_RowIndexFromRange = rngInTableCell.Cells(1).RowIndex
    End If
End Function

'== Word_TrimLastCellParagraph =====================================================
'
' Purpose:  Removes the last paragraph from a table cell, without destroying
'           bookmarks.
'
' Params:   (in) cellTrim: the cell with an extra paragraph
'
' Remarks:  This function assumes the last paragraph is empty (and is typically used
'           when we've added an empty last paragraph on purpose).
'-----------------------------------------------------------------------------------
Public Function Word_TrimLastCellParagraph(cellTrim As Cell)
    Dim rng As Range, sBkmkName As String
    
    Set rng = cellTrim.Range.Duplicate
    rng.End = rng.End - 1
    rng.Collapse wdCollapseEnd
    rng.Start = rng.End - 1
    
    Do While rng.Text = "" And Word_HasShapeRange(rng)
        If rng.Start > cellTrim.Range.Start Then
            rng.End = rng.End - 1
            rng.Start = rng.Start - 1
        Else
            Exit Do
        End If
    Loop
    
    If rng.Bookmarks.Count > 0 Then
        sBkmkName = rng.Bookmarks(1).Name
    Else
        sBkmkName = ""
    End If
    
    If rng.Text = vbCr Then
        rng.Delete
    End If
    
    If sBkmkName <> "" And Not (rng.Document.Bookmarks.Exists(sBkmkName)) Then
        Set rng = cellTrim.Range.Duplicate
        rng.End = rng.End - 1
        rng.Bookmarks.Add sBkmkName
    End If
End Function

'===================================================================================
' Word Text Boxes
'-----------------------------------------------------------------------------------

'== Word_HasTextFrame ==============================================================
'
' Purpose:  Checks whether an AutoShape has a text box associated with it, while
'           suppressing the VBA error that occurs if it doesnt
'
' Params:   (in) shp: the shape that might have a text frame
' Returns:  (Boolean) True if it does, False if it doesn't
'
' Remarks:  Use sparingly.  In some cases, Word can spontaneously convert AutoShapes
'           into text boxes when you access their .TextFrame.  Where possible, you
'           should be 99% sure there is a text frame (by checking name, type, etc.)
'           before calling this function.
'-----------------------------------------------------------------------------------
Public Function Word_HasTextFrame(shp As Shape) As Boolean
    Dim rngTextFrame As Range
    
    On Error Resume Next    ' accessing shp.TextFrame usually triggers an error if missing
    
    Word_HasTextFrame = False
    Set rngTextFrame = Nothing
    Set rngTextFrame = shp.TextFrame.TextRange
    Word_HasTextFrame = Not (rngTextFrame Is Nothing)
End Function

'== Word_ParentTextBox =============================================================
'
' Purpose:  Finds the parent text box for a given range, if any.
'
' Params:   (in) shp: the range that might be in a text box
'           (in) sTextCellID: the ID of the text box, if known (will run faster)
' Returns:  (Shape) the parent text box
'-----------------------------------------------------------------------------------
Public Function Word_ParentTextBox(rngInTextBox As Range, _
                              Optional sTextCellID As String = "") As Shape

    Dim rngMatch As Range, shpCheck As Shape
    Dim shpGroupItem As Shape
    Dim bFound As Boolean
    
    If rngInTextBox Is Nothing Then
        Set Word_ParentTextBox = Nothing
    ElseIf rngInTextBox.StoryType = wdTextFrameStory Then
        Set rngMatch = rngInTextBox.Duplicate
        rngMatch.Expand wdStory
        
        Set Word_ParentTextBox = Word_ShapeFromName(rngInTextBox.Document, sTextCellID)
        
        If Word_ParentTextBox Is Nothing Then
            For Each shpCheck In rngInTextBox.Document.Shapes
                If shpCheck.AutoShapeType = msoShapeRoundedRectangle Then
                    ' label edge -- ignore...
                
                ElseIf shpCheck.TextFrame.HasText Then
                    If shpCheck.TextFrame.TextRange.IsEqual(rngMatch) Then
                        Set Word_ParentTextBox = shpCheck
                        Exit For
                    End If
                ElseIf shpCheck.Type = msoCanvas Or shpCheck.Type = msoGroup Then
                    For Each shpGroupItem In shpCheck.GroupItems
                        If shpGroupItem.TextFrame.HasText Then
                            If shpGroupItem.TextFrame.TextRange.IsEqual(rngMatch) Then
                                Set Word_ParentTextBox = shpGroupItem
                                bFound = True
                                Exit For
                            End If
                        End If
                    Next
                    If bFound = True Then
                        Exit For
                    End If
                End If
            Next
        End If
    Else
        Set Word_ParentTextBox = Nothing
    End If
End Function



'== Word_TextFrameRange ============================================================
'
' Purpose:  Safely gets the range for a text box.
'
' Params:   (in) shpTextbox: the shape that might be a text box
' Returns:  (Range): the range inside the text box, or Nothing
'
' Remarks:  Use sparingly.  In some cases, Word can spontaneously convert AutoShapes
'           into text boxes when you access their .TextFrame.  Where possible, you
'           should be 99% sure there is a text frame (by checking name, type, etc.)
'           before calling this function.
'-----------------------------------------------------------------------------------
Public Function Word_TextFrameRange(shpTextbox As Shape) As Range
    On Error Resume Next
    Set Word_TextFrameRange = Nothing
    Set Word_TextFrameRange = shpTextbox.TextFrame.TextRange.Duplicate
End Function

'== Word_UpdateTextBox =============================================================
'
' Purpose:  Updates a Range with text.  If the range is in a text box, attempts to
'           keep the text vertically centered if appropriate.
'
' Params:   (in) sTextCellID: the name of the text box, if known.
'           (in) rngInsert: the range to update -- if all else fails the text will
'                           simply be added to this range.
'           (in) sText: the text to insert
'           (in) fCellHeight: the height of the cell in which the textbox is found.
'                             (This is used for vertical centering.)
'-----------------------------------------------------------------------------------
Public Sub Word_UpdateTextBox(sTextCellID As String, rngInsert As Range, _
                              sText As String, fCellHeight As Single)
    Dim shpTextbox As Shape, oLatebound As Object
    Dim fNewHeight As Single, fOldHeight As Single, cellParent As Cell
    Dim bVerticallyCenter As Boolean
    
    Set shpTextbox = Word_ParentTextBox(rngInsert, sTextCellID)
            
    If Not (shpTextbox Is Nothing) _
     And Not Word_CanVertAlignTextBoxes(rngInsert.Document) Then
        ' Word 2002/2003 -- can't center the textbox directly
        Set cellParent = Word_CellFromRange(shpTextbox.Anchor)
        If cellParent Is Nothing Then
            bVerticallyCenter = True
        Else
            bVerticallyCenter = (cellParent.VerticalAlignment = wdCellAlignVerticalCenter)
        End If
    
        If bVerticallyCenter Then
            ' note -- the existing text box may be a funny size (from the last fill)
            fOldHeight = shpTextbox.Height
            shpTextbox.TextFrame.AutoSize = True
            shpTextbox.TextFrame.TextRange.Text = sText
            Application.ScreenRefresh
            DoEvents    ' give the AutoSize a chance to happen!
            fNewHeight = shpTextbox.Height
            
            If fCellHeight > 0 And fNewHeight > fCellHeight Then
                ' textbox has grown past original boundaries...
                shpTextbox.TextFrame.AutoSize = False
                fNewHeight = fCellHeight
                shpTextbox.Height = fNewHeight
            End If
            
            If Abs(fNewHeight - fOldHeight) > 2 Then
                ' textbox has grown or shrunk by a noticeable amount --
                ' reposition to keep it centered
                
                ' note that IncrementTop would be faster, but in Word 2003 sometimes
                ' causes all the text boxes to end up in the first panel!
                shpTextbox.Top = shpTextbox.Top + ((fOldHeight - fNewHeight) / 2)
            End If
        Else
            ' not vertically centering; don't autosize...
            rngInsert.Text = sText
        End If
    Else
        ' in Word 2007, textbox centering is handled when it is created
        ' or if there's no textbox, we can also just set the text directly
        rngInsert.Text = sText
    End If
End Sub

'== Word_FormatNewTextbox ==========================================================
'
' Purpose:  Formats a new text box to suit our needs.
'
' Params:   (in) shpTextbox: the new textbox
'           (in) fInnerMargin: our desired inner margin
'
' Remarks:  User settings can affect the default formatting of text boxes.  This
'           function helps guarantee consistent results regardless of user settings.
'-----------------------------------------------------------------------------------
Public Sub Word_FormatNewTextbox(shpTextbox As Shape, fInnerMargin As Single)
    With shpTextbox
        .Line.Visible = msoFalse
        .Fill.Visible = msoFalse
        .TextFrame.MarginLeft = fInnerMargin
        .TextFrame.MarginRight = fInnerMargin
        .TextFrame.MarginTop = fInnerMargin
        .TextFrame.MarginBottom = fInnerMargin
    
        .TextFrame.TextRange.ParagraphFormat.LineSpacingRule = wdLineSpaceSingle
        .TextFrame.TextRange.ParagraphFormat.SpaceBefore = 0
        .TextFrame.TextRange.ParagraphFormat.SpaceAfter = 0
    End With
End Sub

'== Word_CanVertAlignTextBoxes =====================================================
'
' Purpose:  Determines if vertically aligning text boxes is supported in the current
'           document.
'
' Params:   (in) doc: the document to check
' Returns:  (Boolean): True if Word can vertically center a text box, False if we'd
'                      have to do it ourselves.
'
' Remarks:  Word 2007 can vertically center text boxes -- but only when the doc is
'           not in "Compatibility Mode".
'-----------------------------------------------------------------------------------
Public Function Word_CanVertAlignTextBoxes(doc As Document) As Boolean
    Const WORD_DontVertAlignInTextbox = 63
    
    If Word_VersionAtLeast(VER_WORD_2007) Then
        Word_CanVertAlignTextBoxes = Not doc.Compatibility(WORD_DontVertAlignInTextbox)
    Else
        Word_CanVertAlignTextBoxes = False
    End If
End Function

'===================================================================================
' Word AutoShapes
'    note: text box specific functions are found above
'-----------------------------------------------------------------------------------

'== Word_ShapeFromName =============================================================
'
' Purpose:  Gets a shape with a specific name from the document, without throwing
'           errors.
'
' Params:   (in) doc: the document with the shape.
'           (in) sName: the name of the shape.
' Returns:  (Shape) the shape, or Nothing if not found.
'-----------------------------------------------------------------------------------
Public Function Word_ShapeFromName(doc As Document, sName As String) As Shape
    On Error Resume Next
    Set Word_ShapeFromName = Nothing
    Set Word_ShapeFromName = doc.Shapes(sName)
End Function

'== Word_HasShapeRange =============================================================
'
' Purpose:    Utility function that determines whether a given range has a
'             valid ShapeRange collection.
' Parameters: (in)  rng: The range object which may have a ShapeRange.
' Returns:    (Boolean) True if it does, false if it doesn't.
'-----------------------------------------------------------------------------------
Public Function Word_HasShapeRange(rng As Range) As Boolean

    Word_HasShapeRange = False
    On Error Resume Next
    ' For some reason, an empty ShapeRange does not return the Nothing
    ' (null) value, so we have no choice but to try and see if an error
    ' results.
    ' The next line results in an error if there are no shapes, and the
    ' "resume next" above will cause us to skip this line, leaving the
    ' return value of the function as False.  If there are shapes, this
    ' sets the return value to True.
    Word_HasShapeRange = (rng.ShapeRange.Count > 0)
End Function

'== Word_RenameShape ===============================================================
'
' Purpose:  Renames a shape, ignoring the error that can occur if the new name is
'           invalid or in use.
'-----------------------------------------------------------------------------------
Public Sub Word_RenameShape(shp As Shape, sNewShapeName As String)
    On Error Resume Next
    shp.Name = sNewShapeName
End Sub

'== Word_DeleteShapeNotBookmarks ===================================================
'
' Purpose:  Deletes a shape without deleting any bookmarks near the anchor.
'
' Remarks:  This is used to try to preserve bookmarks when deleting the "web
'           install" text box.
'-----------------------------------------------------------------------------------
Function Word_DeleteShapeNotBookmarks(shpDelete As Shape) As Range
    Dim rngAnchor As Range, bkmk As Bookmark
    Dim qscBookmarks As QuickStringCollection, sBkmkName As String

    Set rngAnchor = shpDelete.Anchor.Duplicate
    
    If rngAnchor.Bookmarks.Count > 0 Then
        Set qscBookmarks = New QuickStringCollection
        For Each bkmk In rngAnchor.Bookmarks
            qscBookmarks.Add bkmk.Name
        Next
        rngAnchor.Collapse wdCollapseStart
    Else
        Set qscBookmarks = Nothing
    End If
    
    shpDelete.Delete
    
    If Not (qscBookmarks Is Nothing) Then
        Do Until qscBookmarks.ItemCount = 0
            sBkmkName = qscBookmarks.RemoveNext()
            If Not rngAnchor.Document.Bookmarks.Exists(sBkmkName) Then
                rngAnchor.Bookmarks.Add sBkmkName
            End If
        Loop
    End If
    
    Set Word_DeleteShapeNotBookmarks = rngAnchor
End Function

'== Word_RepositionShape ===========================================================
'
' Purpose:  Repositions a shape, setting only the values that have changed.
'
' Params:   (in) shpTarget: the shape to reposition
'           [in] Left, Top, Width, Height: updated coordinates
'
' Remarks:  Shape positioning is _slow_.  Where possible, position one shape for all
'           panels and then "clone" it using .FormattedText (see QuickEditorCore for
'           examples).
'-----------------------------------------------------------------------------------
Public Sub Word_RepositionShape(shpTarget As Shape, _
                                Optional ByVal Left As Single = REPOSITION_NONE, _
                                Optional ByVal Top As Single = REPOSITION_NONE, _
                                Optional ByVal Width As Single = REPOSITION_NONE, _
                                Optional ByVal Height As Single = REPOSITION_NONE)
    
    If Left <> REPOSITION_NONE And Abs(shpTarget.Left - Left) >= 0.1 Then
        shpTarget.Left = Left
    End If
    If Top <> REPOSITION_NONE And Abs(shpTarget.Top - Top) >= 0.1 Then
        shpTarget.Top = Top
    End If
    If Width <> REPOSITION_NONE And Abs(shpTarget.Width - Width) >= 0.1 Then
        shpTarget.Width = Width
    End If
    If Height <> REPOSITION_NONE And Abs(shpTarget.Height - Height) >= 0.1 Then
        shpTarget.Height = Height
    End If
End Sub



'== Word_ParentCanvas ==============================================================
'
' Purpose:  Determines if a shape is in a canvas, and if so finds the canvas.
'
' Params:   (in) shpCheck: the shape that may be inside a canvas
'           (out) shpCanvas: the canvas the shape is inside (if True is returned)
' Returns:  (Boolean) True if a canvas was found, False if the shape is stand-alone
'-----------------------------------------------------------------------------------
Public Function Word_ParentCanvas(shpCheck As Shape, _
                                  ByRef shpCanvas As Shape) As Boolean
    On Error Resume Next
    Word_ParentCanvas = False
    Set shpCanvas = Nothing
                                 
    If Not (shpCheck Is Nothing) Then
        ' requires On Error Resume Next (above)
        Set shpCanvas = shpCheck.ParentGroup
        If Not (shpCanvas Is Nothing) Then
            If shpCanvas.Type = msoCanvas Then
                Word_ParentCanvas = True
            Else
                ' it's probably in a group, that's not a canvas, so don't
                ' return it
                Set shpCanvas = Nothing
            End If
        End If
    End If
                                 
End Function

'== Word_FirstSelectedShape ========================================================
'
' Returns the first shape in the given Selection, if any (or Nothing if none).
'
Public Function Word_FirstSelectedShape(sel As Selection) As Shape
    On Error Resume Next
    Set Word_FirstSelectedShape = Nothing
    Set Word_FirstSelectedShape = sel.ShapeRange(1)
End Function

'== Word_SaveSelection =============================================================
'
' Saves the given documents selection into the two parameters; the selection can be
' restored later by passing both parameters to _RestoreSelection.
'
Public Sub Word_SaveSelection(doc As Document, rngSavedSel As Range, srSavedSel As ShapeRange)
    Dim sel As Selection
    Set sel = doc.ActiveWindow.Selection

    If Word_HasShapeRange(sel.Range) Then
        Set srSavedSel = sel.ShapeRange
        Set rngSavedSel = Nothing
    Else
        Set rngSavedSel = sel.Range
        Set srSavedSel = Nothing
    End If
End Sub

'== Word_RestoreSelection ==========================================================
'
' Restores a selection previously saved by _SaveSelection.
'
Public Sub Word_RestoreSelection(rngSavedSel As Range, srSavedSel As ShapeRange)
    If Not (srSavedSel Is Nothing) Then
        srSavedSel.Select
    ElseIf Not (rngSavedSel Is Nothing) Then
        rngSavedSel.Select
    End If
End Sub

'== Word_ClearUndoStack ============================================================
'
' Clears the undo stack to prevent the user from accessing partially-complete states
' or experiencing redraw bugs after using some of our features.
'
'
Public Sub Word_ClearUndoStack(doc As Document)
    If Not doc Is Nothing Then
        On Error Resume Next ' Ensures no error occurs if this operation isn't valid
        doc.UndoClear
    End If
End Sub
Attribute VB_Name = "UtilWordPort"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' UtilWordPort:                                                             '
' ~~~~~~~~~~~~~                                                             '
'   Utility functions for interpreting WordPort output, especially decoding '
'   object names to extract useful information.                             '
'==========================================================================='
Option Explicit

' Object names:
Global Const OBJECT_BOUNDARY = "Bdry"
Global Const OBJECT_AUTOSHAPE = "AutoShape"
Global Const OBJECT_PICTURE = "Picture"
' Global Const OBJECT_PICTURE = "Pic"
Global Const OBJECT_PICTURE_TABS = "PicDT"
Global Const OBJECT_PICTURE_LABEL = "PicQE"
Global Const OBJECT_TEXTBOX = "TextBox"
Global Const OBJECT_TEXT = "Text"
Global Const OBJECT_BLANK = "Blank"

Global Const PIC_ALIGN_NONE = -1

'== WordPort_ValidName =============================================================
'
' Purpose:  Determines whether a string is a WordPort-style object name.
'-----------------------------------------------------------------------------------
Public Function WordPort_ValidName(ByVal sObjectName As String) As Boolean
    
    Dim bValid As Boolean, sObjectType As String
    
    sObjectType = String_SplitFromList(sObjectName, "_")
    If sObjectType = "" Or sObjectName = "" Then
        WordPort_ValidName = False
    Else
        bValid = True
        WordPort_ExtractValue "MP", sObjectName, "_", bValid
        WordPort_ExtractValue "PF", sObjectName, "_", bValid
        WordPort_ExtractValue "PF", sObjectName, "_", bValid
        
        WordPort_ValidName = bValid
    End If
End Function

'== WordPort_DecodeName ============================================================
'
' Purpose:  Extracts encoded values from a WordPort-style object name.
'
' Params:   (in) sWordPortName: the WordPort object name
'           (out) various: values decoded from the WordPort name
' Returns:  (Boolean): True if the WordPort name is valid, False if it's a non-
'                      WordPort object (e.g. a generic autoshape)
'
' Remarks:  DecodeName returns True for a wide variety of objects (from empty cell
'           bookmarks to pre-design pictures).  Callers looking for a specific type
'           of object need to check the sObjectType parameter returned to make sure
'           it matches what they expect.
'
'           The definition of ContentIDBase and ContentID varies between object
'           types.  Many objects don't include width, height, cell name, or picture
'           alignment -- these will be returned as 0 or "".
'-----------------------------------------------------------------------------------
Public Function WordPort_DecodeName(ByVal sWordPortName As String, _
                                   ByRef sObjectType As String, _
                                   ByRef lMasterPanel As Long, _
                                   ByRef sContentIDBase As String, _
                                   ByRef lContentID As Long, _
                                   ByRef fWidth As Single, _
                                   ByRef fHeight As Single, _
                                   Optional ByRef sMergeFieldID As String) As Boolean
    
    Dim bValid As Boolean
    
    ' ensure values passed in don't sneak through if function exits early
    lMasterPanel = 0
    sContentIDBase = ""
    lContentID = 0
    fWidth = 0
    fHeight = 0
    sMergeFieldID = ""
    
    ' common (required) element: <objecttype>
    sObjectType = String_SplitFromList(sWordPortName, "_")
    If sWordPortName = "" Then
        ' could be a auto-assigned Word name, e.g. "Rectangle 4"
        String_SplitFromList sObjectType, " "
        If Val(sObjectType) > 0 Then
            lContentID = Val(sObjectType)
            sObjectType = OBJECT_AUTOSHAPE
        Else
            ' nope... no idea
            sObjectType = ""
        End If
        WordPort_DecodeName = False
    
    ElseIf sObjectType = "" Then
        WordPort_DecodeName = False
    
    Else
        bValid = True
    
        ' middle segment varies depending on object type
        If sObjectType = OBJECT_BOUNDARY Then
            ' _SH<contentID>  (must be unique; can use Word's automatic number,
            '                    e.g. 4 in "Rectangle 4"
            lContentID = WordPort_ExtractValue("SH", sWordPortName, "_", bValid)
        ElseIf sObjectType = OBJECT_BLANK Then
            ' Blank_MP<masterpanel>_panel<panel#>
            
            lMasterPanel = WordPort_ExtractValue("MP", sWordPortName, "_", bValid)
            If Left(sWordPortName, 5) = "panel" Then
                lContentID = WordPort_ExtractValue("panel", sWordPortName, "", bValid)
                sContentIDBase = "panel"
            Else
                lContentID = WordPort_ExtractValue("picture", sWordPortName, "", bValid)
                If bValid Then
                    sContentIDBase = "picture"
                End If
            End If
            
        ElseIf sObjectType = OBJECT_PICTURE_TABS Then
            ' PicRI_MP<masterpanel>_tab<tab#>
        
            lMasterPanel = WordPort_ExtractValue("MP", sWordPortName, "_", bValid)
            lContentID = WordPort_ExtractValue("tab", sWordPortName, "", bValid)
            sContentIDBase = "tab"
        
        Else
            ' _MP<masterpanel>_PF<contentIDbase>_PF<contentID>[
            lMasterPanel = WordPort_ExtractValue("MP", sWordPortName, "_", bValid)
            sContentIDBase = String_SplitFromList(sWordPortName, "_")
            If InStr(3, sContentIDBase, "PF") > 0 Then
                lContentID = Val(Mid(sContentIDBase, InStr(3, sContentIDBase, "PF") + 2))
                sContentIDBase = Left(sContentIDBase, InStr(3, sContentIDBase, "PF") - 1)
            Else
                lContentID = WordPort_ExtractValue("PF", sWordPortName, "_", bValid)
            End If
        End If
        
        If sObjectType = OBJECT_TEXT Then
            ' optional text element: _AF<mergeFieldID>
            sMergeFieldID = String_SplitFromList(sWordPortName, "_")
        Else
            ' common (optional) element: _<width>_<height>
            fWidth = Val(String_SplitFromList(sWordPortName, "_"))
            fHeight = Val(String_SplitFromList(sWordPortName, "_"))
        End If
        
        WordPort_DecodeName = bValid
    End If
End Function



'== WordPort_EncodeName ============================================================
'
' Purpose:  Writes encoded values into a WordPort-style object name.
'
' Params:   (in) sObjectType: the type of WordPort object being named
'           [in] various: values to include in the WordPort name
' Returns:  (Boolean): The encoded name, if possible, or an empty string if
'                      something failed
'
' Remarks:  EncodeName does not necessarily return the same name as WordPort would
'           create (due to length limits), so EncodeName should not be used to
'           compare against existing objects.  (Instead, Decode each object's name
'           and match the individual values.
'
'           All names created by EncodeName can be interpreted by DecodeName.
'-----------------------------------------------------------------------------------
Public Function WordPort_EncodeName(sObjectType As String, _
                                   Optional MasterPanel As Long = 0, _
                                   Optional ContentIDBase As String = "", _
                                   Optional ContentID As Long = 0, _
                                   Optional Width As Single = 0, _
                                   Optional Height As Single = 0, _
                                   Optional MergeFieldID As String = "") As String
    Dim sName As String, lPos As Long
    
    ' must keep length under 32 chars to avoid errors when updating shape name!
    
    ' common (required) element: <objecttype>
    sName = sObjectType
    
    ' middle segment varies depending on object type
    If sObjectType = OBJECT_BOUNDARY Then
        ' _SH<contentID>  (must be unique; can use Word's automatic number,
        '                    e.g. 4 in "Rectangle 4"
        sName = sName & "_SH" & ContentID
    
    ElseIf sObjectType = OBJECT_PICTURE_TABS Then
        ' PicRI_MP<masterpanel>_tab<tab#>
        sName = sName & "_MP" & MasterPanel & "_tab" & ContentID
    
    ElseIf sObjectType = OBJECT_BLANK Then
        ' Blank_<section>MP<masterpanel>_panel<panel#>
        sName = sName & "_MP" & MasterPanel & "_panel" & ContentID
            
    Else
        ' _MP<masterpanel>_PF<contentIDbase>_PF<contentID>
        sName = sName & "_MP" & MasterPanel & "_" & ContentIDBase
        sName = sName & "_PF" & ContentID
    End If
    
    If MergeFieldID <> "" Then
        ' text only: _AF<mergeFieldID>
        sName = sName & "_" & MergeFieldID
    End If
    
    ' common (optional) element: _<width>_<height>
    If Width > 0 Or Height > 0 Then
        ' round width and height to shorten
        sName = sName & "_" & Format(Width, "0") & "_" & Format(Height, "0")
    End If
    
    Do Until Len(sName) <= 32
        ' if it's too long, chop items off the end one element at a time
        lPos = String_InstrRev(sName, "_")
        sName = Left(sName, lPos - 1)
    Loop
    WordPort_EncodeName = sName
End Function

'== WordPort_ObjectFamily ==========================================================
'
' Purpose:  Extract the "family" (the masterpanel number and the initial field
'           number) from a WordPort name.
'
' Params:   (in) sObjectName: the WordPort-style object name
' Returns:  (String) the family portion of the name, or "" if the name is invalid
'
' Remarks:  The "family" can be used to match related objects on different panels.
'-----------------------------------------------------------------------------------
Public Function WordPort_ObjectFamily(ByVal sObjectName As String) As String
    
    Dim lPosMP As Long, lPosPF As Long, lPosEndFamily As Long
    Dim sContentID As String, sShortName As String

    ' we want to extract the text before the third underscore, e.g.
    ' "P_MP2_PF4" from "P_MP2_PF4_PF71_108_82"
    lPosMP = InStr(sObjectName, "_") + 1
    lPosPF = InStr(lPosMP, sObjectName, "_") + 1
    lPosEndFamily = InStr(lPosPF, sObjectName, "_")
    
    If lPosMP = 1 Or lPosPF = 1 Or lPosEndFamily = 0 Then
        WordPort_ObjectFamily = ""
    Else
        ' deal with missing underscore between two PFs, eg. "P_MP2_PF4PF71_108_82"
        sContentID = Mid(sObjectName, lPosPF, lPosEndFamily - lPosPF)
        If InStr(3, sContentID, "PF") Then
            lPosEndFamily = InStr(3, sContentID, "PF") + lPosPF - 1
        End If
    
        WordPort_ObjectFamily = Left(sObjectName, lPosEndFamily - 1)
    End If
End Function

'== WordPort_MatchBaseContentID ====================================================
'
' Purpose:  Determine if a named object has the specified Base Content ID
'
' Params:   (in) sObjectName: the WordPort object name, e.g. Picture_MP1_PF11_PF22
'           (in) sContentIDBase: the base content ID to match (e.g. PF11)
' Returns:  (Boolean) True for a match, False for no match
'-----------------------------------------------------------------------------------
Public Function WordPort_MatchBaseContentID(ByVal sObjectName As String, _
                                    ByVal sContentIDBaseMatch As String) As Boolean
    
    Dim sContentIDBase As String
    
    If WordPort_DecodeName(sObjectName, "", 0, sContentIDBase, 0, 0, 0) Then
        WordPort_MatchBaseContentID = (sContentIDBase = sContentIDBaseMatch)
    Else
        WordPort_MatchBaseContentID = False
    End If
End Function


'== WordPort_MatchProduct ==========================================================
'
' Purpose:  Determine if a product types matches a list of product types or product
'           type prefixes
'
' Params:   (in) sCheckList: space-delimited list of product types or product type
'                            prefixes
'           (in) sProductTypeMatch: a product type to match against the list
'           (in) bMatchPrefixOnly: True if sCheckList is a list of product type
'                                  prefixes, false if it's a list of product types
' Returns:  (Boolean) True for a match, False for no match
'-----------------------------------------------------------------------------------
Public Function WordPort_MatchProduct(ByVal sCheckList As String, _
                             ByVal sProductTypeMatch As String, _
                             bMatchPrefixOnly As Boolean) As Boolean
    
    Dim sCheck As String, sMatch As String
    
    sCheckList = " " & LCase(sCheckList) & " "
    If bMatchPrefixOnly Then
        sMatch = String_SplitFromList(sProductTypeMatch, "_")
    Else
        sMatch = sProductTypeMatch
    End If
    
    sMatch = " " & Trim(LCase(sMatch)) & " "
    WordPort_MatchProduct = (InStr(sCheckList, sMatch) > 0)
End Function



'== WordPort_ExtractValue ==========================================================
'
' Purpose:  Extracts a prefixed value, ensuring the correct prefix is present.
'
' Params:   (in) sNameFragment: the remainder of the WordPort-style name
'           (in) sDelimiter: the delimiter between values (typically "_")
'           (in) sPrefix: the prefix for this value (e.g. "MP", "PF")
'           (out) bValid: flag indicating whether the prefix was verified
' Returns:  (Long) the value in this segment of the name
'
' Remarks:  If the prefix doesn't match, this function sets the valid flag to False
'           but still attempts to extract the value.  Callers who are strict about
'           the format of the name must check the Valid flag.
'-----------------------------------------------------------------------------------
Private Function WordPort_ExtractValue(ByVal sPrefix As String, _
                                      ByRef sNameFragment As String, _
                                      ByVal sDelimiter As String, _
                                      ByRef bValid As Boolean) As Long
    Dim sValue As String
    sValue = String_SplitFromList(sNameFragment, sDelimiter)
    
    If sPrefix = "" Or Left(sValue, Len(sPrefix)) = sPrefix Then
        WordPort_ExtractValue = Val(Mid(sValue, Len(sPrefix) + 1))
    Else
        bValid = False
        Do While sValue <> "" And Val(sValue) = 0
            sValue = Mid(sValue, 2)
        Loop
        WordPort_ExtractValue = Val(sValue)
    End If
End Function

'== WordPort_MaxContentID ==========================================================
'
' Determines the maximum contentID already present in a document.
'
Public Function WordPort_MaxContentID(doc As Document) As Long
    Dim lMaxContentID As Long, lCheckContentID As Long
    Dim bkmk As Bookmark, shp As Shape
    
    lMaxContentID = 0
    For Each bkmk In doc.Bookmarks
        If WordPort_DecodeName(bkmk.Name, "", 0, "", lCheckContentID, 0, 0) Then
            If lCheckContentID > lMaxContentID Then
                lMaxContentID = lCheckContentID
            End If
        End If
    Next
    
    For Each shp In doc.Shapes
        If WordPort_DecodeName(shp.Name, "", 0, "", lCheckContentID, 0, 0) Then
            If lCheckContentID > lMaxContentID Then
                lMaxContentID = lCheckContentID
            End If
        End If
    Next
    WordPort_MaxContentID = lMaxContentID
End Function

'== WordPort_MinContentID ==========================================================
'
' Determines the minimum contentID present in a given range.
'
Public Function WordPort_MinContentID(rng As Range) As Long
    Dim lMinContentID As Long, lCheckContentID As Long
    Dim bkmk As Bookmark, shp As Shape
    
    lMinContentID = 0
    For Each bkmk In rng.Bookmarks
        If WordPort_DecodeName(bkmk.Name, "", 0, "", lCheckContentID, 0, 0) Then
            If lCheckContentID < lMinContentID Or lMinContentID = 0 Then
                lMinContentID = lCheckContentID
            End If
        End If
    Next
    
    If Word_HasShapeRange(rng) Then
        For Each shp In rng.ShapeRange
            If WordPort_DecodeName(shp.Name, "", 0, "", lCheckContentID, 0, 0) Then
                If lCheckContentID < lMinContentID Or lMinContentID = 0 Then
                    lMinContentID = lCheckContentID
                End If
            End If
        Next
    End If
    WordPort_MinContentID = lMinContentID
End Function

'== WordPort_ShiftBookmarkContentID ================================================
'
' Adjusts a content ID for a bookmark by a specified offset.
'
Public Function WordPort_ShiftBookmarkContentID(bkmk As Bookmark, _
                                                 lContentIDShift As Long)
    Dim rng As Range, sNewBkmkName As String
    Dim sOldBkmkName As String
    On Error Resume Next
                                                 
    If (Not (bkmk Is Nothing)) And (lContentIDShift <> 0) Then
        sOldBkmkName = bkmk.Name
        sNewBkmkName = WordPort_ShiftNameContentID(sOldBkmkName, lContentIDShift)
        If sNewBkmkName <> "" Then
            Set rng = bkmk.Range
            If Not rng.Document.Bookmarks.Exists(sNewBkmkName) Then
                rng.Document.Bookmarks.Add sNewBkmkName, rng
                If rng.Bookmarks.Exists(sOldBkmkName) Then
                    rng.Bookmarks(sOldBkmkName).Delete
                End If
            End If
        End If
    End If
End Function

'== WordPort_ShiftShapeContentID ===================================================
'
' Adjusts a content ID for a shape by a specified offset.
'
Public Function WordPort_ShiftShapeContentID(shp As Shape, _
                                              lContentIDShift As Long)
    Dim sNewShapeName As String
    On Error Resume Next
                                                 
    If (Not (shp Is Nothing)) And (lContentIDShift <> 0) Then
        sNewShapeName = WordPort_ShiftNameContentID(shp.Name, lContentIDShift)
        If sNewShapeName <> "" Then
            Word_RenameShape shp, sNewShapeName
            
            If InStr(sNewShapeName, OBJECT_TEXTBOX & "_") = 1 Then
                Dim rngFrame As Range
                
                Set rngFrame = Word_TextFrameRange(shp)
                If Not (rngFrame Is Nothing) Then
                    Dim bkmk As Bookmark
                    Dim qscAdjustBkmks As QuickStringCollection
                    Set qscAdjustBkmks = New QuickStringCollection
                    
                    For Each bkmk In rngFrame.Bookmarks
                        qscAdjustBkmks.Add bkmk.Name
                    Next
                    
                    Do Until qscAdjustBkmks.ItemCount() = 0
                        Set rngFrame = Word_TextFrameRange(shp)
                        Set bkmk = rngFrame.Bookmarks(qscAdjustBkmks.RemoveNext())
                        WordPort_ShiftBookmarkContentID bkmk, lContentIDShift
                    Loop
                End If
            End If
        End If
    End If
End Function

Private Function WordPort_ShiftNameContentID(sName As String, _
                                             lContentIDShift As Long) As String
    
    Dim sObjectType As String, lMasterPanel As Long, sContentIDBase As String
    Dim lContentID As Long, fWidth As Single, fHeight As Single, sMergeFieldID As String
    
    If WordPort_DecodeName(sName, sObjectType, lMasterPanel, sContentIDBase, _
                           lContentID, fWidth, fHeight, sMergeFieldID) Then
        WordPort_ShiftNameContentID = WordPort_EncodeName( _
                                    sObjectType, lMasterPanel, sContentIDBase, _
                                    lContentID + lContentIDShift, fWidth, fHeight, _
                                    sMergeFieldID)
    Else
        WordPort_ShiftNameContentID = ""
    End If
End Function
Attribute VB_Name = "UtilXML2007"
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' UtilXML2007:                                                              '
' ~~~~~~~~~~~~                                                              '
'   Utility functions for working with Word 2007's CustomXMLParts           '
'   collection, which is used to store template options for Word 2007       '
'   templates and localized strings for the ribbon.                         '
'==========================================================================='
Option Explicit

' XML constants:
Global Const AVERY_SCHEMA = "averytemplate2007"

'== XML_GetCustomPartBySchema ======================================================
'
' Purpose:    Finds a specific custom part in the collection of custom parts
'             for a document, given its schema URI
'
' Parameters: (in) docContainer: the doc with the part attached
'             (in) sSchemaURI: the schema (matching the xmlns attribute on
'                              the part's root element)
' Returns:    (CustomXMLPart) the part, or Nothing if not found
'
' Remarks:    If more than one part could be based on the same schema, use
'             XML_GetCustomPartBySchemaAndRootElement.
'-----------------------------------------------------------------------------------
Public Function XML_GetCustomPartBySchema(docContainer As Document, _
                                            sSchemaURI As String _
                                            ) As CustomXMLPart
    Dim cxpCurrent As CustomXMLPart
    
    For Each cxpCurrent In docContainer.CustomXMLParts
        If cxpCurrent.NamespaceURI = sSchemaURI Then
            Set XML_GetCustomPartBySchema = cxpCurrent
            Exit Function
        End If
    Next
End Function



'== XML_GetCustomPartBySchemaAndRootElement ========================================
'
' Purpose:    Finds a specific custom part in the collection of custom parts
'             for a document, given its schema URI and the name of its root
'             element tag
'
' Parameters: (in) docContainer: the doc with the part attached
'             (in) sSchemaURI: the schema (matching the xmlns attribute on
'                              the part's root element)
'             (in) sRootElement: the name of the root tag, e.g. "html"
' Returns:    (CustomXMLPart) the part, or Nothing if not found
'
' Remarks:    If only one part in a given doc is based on the schema, use
'             the simpler XML_GetCustomPartBySchema.
'-----------------------------------------------------------------------------------
Public Function XML_GetCustomPartBySchemaAndRootElement(docContainer As Document, _
                                                          sSchemaURI As String, _
                                                          sRootElement _
                                                          ) As CustomXMLPart
    Dim cxpCurrent As CustomXMLPart
    
    For Each cxpCurrent In docContainer.CustomXMLParts
        If cxpCurrent.DocumentElement Is Nothing Then
            cxpCurrent.Delete
        ElseIf cxpCurrent.NamespaceURI = sSchemaURI And sRootElement = _
                     cxpCurrent.SelectSingleNode("/*").BaseName Then
            Set XML_GetCustomPartBySchemaAndRootElement = cxpCurrent
            Exit Function
        End If
    Next
End Function



'== XML_FormatXPath ================================================================
'
' Purpose:    Applies a namespace prefix to each level of an XPath path
'
' Parameters: (in) sXPath: the path, without prefixes, like /rootElement/*
'             (in) cxpParent: the XML part, for looking up prefixes
' Returns:    The formatted path
'-----------------------------------------------------------------------------------
Private Function XML_FormatXPath(ByVal sXPath As String, _
                                 cxpParent As CustomXMLPart)
    
    Dim lPos As Long, lNextPos As Long, sNextChar As String
    Dim sDefaultPrefix As String
    
    sDefaultPrefix = cxpParent.NamespaceManager.LookupPrefix(cxpParent.NamespaceURI) & ":"
    
    lPos = 0    ' we may need to add a ns prefix at the very beginning of the string,
                ' for relative XPaths
    Do
        sNextChar = Mid(sXPath, lPos + 1, 1)
        lNextPos = InStr(lPos + 1, sXPath, ":")
        
        ' skip over segments that don't need a prefix -- //, /*, ., @
        If Not (sNextChar = "/" Or sNextChar = "*" Or sNextChar = "." Or sNextChar = "@") Then
            
            ' check if a namespace prefix (e.g. "ns0:") is already applied in this
            ' segment (before the next / or [)
            If lNextPos = 0 Or lNextPos > InStr(lPos + 1, sXPath, "/") _
             Or lNextPos > InStr(lPos + 1, sXPath, "[") Then
                ' no namespace prefix already applied to this node; apply one now
                sXPath = Left(sXPath, lPos) + sDefaultPrefix + Mid(sXPath, lPos + 1)
            End If
            ' skip over the prefix itself
            lPos = lPos + Len(sDefaultPrefix)
        End If
        ' find the next level of the path by searching for /
        lPos = InStr(lPos + 1, sXPath, "/")
    Loop Until lPos = 0
    XML_FormatXPath = sXPath
End Function



'== XML_GetPartAndNode =============================================================
'
' Purpose:  Given either a custom XML part or the base node (.DocumentElement) of a
'           part, return both the CustomXMLPart and base node of that part
'
' Params:   (in) oBaseNodeOrPart: a CustomXMLPart or CustomXMLPart.DocumentElement
' Returns:  (out) cxpParent: the Custom XML Part
'           (out) cxnBaseNode: the base node
'-----------------------------------------------------------------------------------
Private Function XML_GetPartAndNode(oBaseNodeOrPart As Object, _
                                    ByRef cxpParent As CustomXMLPart, _
                                    ByRef cxnBaseNode As CustomXMLNode) As Boolean
                                
    If TypeName(oBaseNodeOrPart) = "CustomXMLPart" Then
        Set cxpParent = oBaseNodeOrPart
        Set cxnBaseNode = cxpParent.DocumentElement
        XML_GetPartAndNode = True
    
    ElseIf TypeName(oBaseNodeOrPart) = "CustomXMLNode" Then
        Set cxnBaseNode = oBaseNodeOrPart
        Set cxpParent = cxnBaseNode.OwnerPart
        XML_GetPartAndNode = True
    
    Else
        Set cxpParent = Nothing
        Set cxnBaseNode = Nothing
        XML_GetPartAndNode = False
    End If
End Function



'== XML_SelectNodes ================================================================
'
' Purpose:    Our own version of CustomXMLNode.SelectNodes()
' Remarks:    Same as the built-in function, except that namespace prefixes
'             are not required in the XPath -- they're added automatically
'-----------------------------------------------------------------------------------
Public Function XML_SelectNodes(oBaseNodeOrPart As Object, _
                                  ByVal sXPath As String) As CustomXMLNodes
    
    Dim cxpParent As CustomXMLPart, cxnBaseNode As CustomXMLNode
    Dim cxnsResult As CustomXMLNodes
    
    On Error Resume Next
    
    If XML_GetPartAndNode(oBaseNodeOrPart, cxpParent, cxnBaseNode) Then
        sXPath = XML_FormatXPath(sXPath, cxpParent)
        
        Set cxnsResult = cxnBaseNode.SelectNodes(sXPath)
        If cxnsResult Is Nothing Then
            Set XML_SelectNodes = Nothing
        ElseIf cxnsResult.Count = 0 Then
            Set XML_SelectNodes = Nothing
        Else
            Set XML_SelectNodes = cxnsResult
        End If
    Else
        Set XML_SelectNodes = Nothing
    End If
End Function



'== XML_SelectSingleNode ===========================================================
'
' Purpose:    Our own version of CustomXMLNode.SelectSingleNode()
' Remarks:    Same as the built-in function, except that namespace prefixes
'             are not required in the XPath -- they're added automatically
'-----------------------------------------------------------------------------------
Public Function XML_SelectSingleNode(oBaseNodeOrPart As Object, _
                                       ByVal sXPath As String) As CustomXMLNode
    Dim cxpParent As CustomXMLPart, cxnBaseNode As CustomXMLNode
    
    On Error Resume Next
    
    If XML_GetPartAndNode(oBaseNodeOrPart, cxpParent, cxnBaseNode) Then
        sXPath = XML_FormatXPath(sXPath, cxpParent)
        Set XML_SelectSingleNode = cxnBaseNode.SelectSingleNode(sXPath)
    Else
        Set XML_SelectSingleNode = Nothing
    End If
End Function



'== XML_GetAttribute ===============================================================
'
' Purpose:    Returns the value of a given attribute
' Used By:    Various
'
' Parameters: (in)  cxnXMLNode: the node with the attribute
'             (in)  sAttrName: the attribute name (no prefix required)
' Returns:    The value of the attribute, or an empty string if no attribute
'
' Remarks:    Why isn't this built into Office's implementation?
'-----------------------------------------------------------------------------------
Public Function XML_GetAttribute(cxnXMLNode As CustomXMLNode, _
                                   sAttrName As String, _
                                   Optional sDefaultValue As String = "") As String
    Dim cxnAttribute As CustomXMLNode
    
    XML_GetAttribute = sDefaultValue
    If Not (cxnXMLNode Is Nothing) Then
        For Each cxnAttribute In cxnXMLNode.Attributes
            If cxnAttribute.BaseName = sAttrName Then
                XML_GetAttribute = cxnAttribute.Text
                Exit For
            End If
        Next
    End If
End Function



'== XML_GetBoolAttribute ===========================================================
'
' Purpose:    Returns the value of a given boolean attribute
' Used By:    Various
'
' Parameters: (in)  cxnXMLNode: the node with the attribute
'             (in)  sAttrName: the attribute name (no prefix required)
' Returns:    The value of the attribute (true or false ONLY)
'-----------------------------------------------------------------------------------
Public Function XML_GetBoolAttribute(cxnXMLNode As CustomXMLNode, _
                                       sAttrName As String, _
                                       Optional bDefaultValue As Boolean = False _
                                       ) As Boolean
    Dim sAttrValue As String
    
    sAttrValue = XML_GetAttribute(cxnXMLNode, sAttrName)
    
    If LCase(Trim(sAttrValue)) = "true" Then
        XML_GetBoolAttribute = True
    Else
        XML_GetBoolAttribute = Not (Val(sAttrValue) = 0)
    End If
End Function




'== XML_GetPreferredAttribute ======================================================
'
' Purpose:    Returns the value of a given "preferred" attribute, if it
'             exists, otherwise returns the value of a backup attribute
' Used By:    Various
'
' Parameters: (in)  cxnXMLNode: the node with the attribute
'             (in)  sAttrName: the preferred attribute name
'             (in)  sRequiredAttrName: the backup attribute name (i.e. an
'                       attribute which is required in the schema)
' Returns:    The value of the attribute, or an empty string if neither
'             attribute exists
'-----------------------------------------------------------------------------------
Public Function XML_GetPreferredAttribute(cxnXMLNode As CustomXMLNode, _
                                            sAttrName As String, _
                                            sRequiredAttrName As String _
                                            ) As String
    Dim cxnAttribute As CustomXMLNode
    
    XML_GetPreferredAttribute = ""
    If Not (cxnXMLNode Is Nothing) Then
        For Each cxnAttribute In cxnXMLNode.Attributes
            If cxnAttribute.BaseName = sAttrName Then
                ' this is the preferred attribute; set value and exit
                XML_GetPreferredAttribute = cxnAttribute.Text
                Exit For
            ElseIf cxnAttribute.BaseName = sRequiredAttrName Then
                ' this is the non-preferred attribute; set value but
                ' keep looking for the preferred attribute
                XML_GetPreferredAttribute = cxnAttribute.Text
            End If
        Next
    End If
End Function



'== XML_SetAttribute ===============================================================
'
' Purpose:    Sets the value of a given attribute
' Used By:    Various
'
' Parameters: (in)  cxnXMLNode: the node with the attribute
'             (in)  sAttrName: the attribute name (no prefix required)
'             (in)  sAttrValue: the new attribute value
'             (in)  bCheckExisting: False if certain the attribute does not
'                       already exists (e.g. a new node); if unsure use True
'-----------------------------------------------------------------------------------
Public Sub XML_SetAttribute(cxnXMLNode As CustomXMLNode, _
                              sAttrName As String, _
                              ByVal sAttrValue As String, _
                              bCheckExisting As Boolean)
    
    Dim cxnAttribute As CustomXMLNode
    Dim bFoundExisting As Boolean
    
    If Not (cxnXMLNode Is Nothing) Then
        If bCheckExisting Then
            For Each cxnAttribute In cxnXMLNode.Attributes
                If cxnAttribute.BaseName = sAttrName Then
                    cxnAttribute.Text = sAttrValue
                    bFoundExisting = True
                    Exit For
                End If
            Next
        End If
        If Not bFoundExisting Then
            cxnXMLNode.AppendChildNode Name:=sAttrName, _
                                        NodeType:=msoCustomXMLNodeAttribute, _
                                        NodeValue:=sAttrValue
        End If
    End If
End Sub



'== XML_SetBoolAttribute ===========================================================
'
' Purpose:    Sets the value of a given boolean attribute
' Used By:    Various
'
' Parameters: (in)  cxnXMLNode: the node in which to set the attribute
'             (in)  sAttrName: the attribute name (no prefix required)
'             (in)  sAttrValue: the new attribute value
'             (in)  bDefaultValue: the default value (if sAttrValue = bDefaultValue,
'                                  the attribute is not added, to save space)
'             (in)  bCheckExisting: False if certain the attribute does not
'                       already exists (e.g. a new node); if unsure use True
' Returns:    The value of the attribute (true or false ONLY)
'-----------------------------------------------------------------------------------
Public Function XML_SetBoolAttribute(cxnXMLNode As CustomXMLNode, _
                                       sAttrName As String, _
                                       ByVal bAttrValue As Boolean, _
                                       Optional bDefaultValue As Boolean = False, _
                                       Optional bCheckExisting As Boolean = True) As Boolean

    If bAttrValue <> bDefaultValue Then
        XML_SetAttribute cxnXMLNode, sAttrName, IIf(bAttrValue, "true", "false"), _
                         bCheckExisting
    End If
End Function

'== XML_AddChildNode ===============================================================
'
' Purpose:  Adds a child node to an XML node, and returns the new child node
'
' Params:   (in) cxnXMLNode: the new parent
'           (in) sBaseName: the name of the new node
' Returns:  (CustomXMLNode): the node added to the tree
'-----------------------------------------------------------------------------------
Public Function XML_AddChildNode(cxnXMLNode As CustomXMLNode, _
                                 sBaseName As String) As CustomXMLNode
    On Error Resume Next
    
    If cxnXMLNode Is Nothing Then
        Set XML_AddChildNode = Nothing
    Else
        cxnXMLNode.AppendChildNode sBaseName, cxnXMLNode.NamespaceURI
        
        If cxnXMLNode.ChildNodes.Count = 0 Then
            Set XML_AddChildNode = Nothing
        Else
            Set XML_AddChildNode = cxnXMLNode.LastChild
        End If
    End If
End Function
Attribute VB_Name = "frmAveryEULA"
Attribute VB_Base = "0{36BE89D9-04CE-4093-B9DF-C0F9028679E7}{2B7F693F-5AB7-47D7-BCDD-7CEC3E83B842}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' frmAveryEULA:                                                             '
' ~~~~~~~~~~~~~                                                             '
'   Displays an end-user license agreement for the user to accept.          '
'==========================================================================='
Option Explicit

' the EULA strings are stored here even for 2007 (i.e. not in the localized strings XML) to ensure they're covered by the digital signature
Const EULA01 = "AVERY DENNISON TEMPLATE END-USER LICENSE AGREEMENT" & vbCr & vbCr & "THIS TEMPLATE END-USER LICENSE AGREEMENT (""Agreement"") governs the user by you (""Customer"") of these Avery Dennison Corporation (""Avery"") software templates (""Templates"").  By copying, downloading, accessing, installing, and/or using any of these Templates, Customer agrees to be bound by the terms of this Agreement.  If Customer does not agree to the terms of this Agreement, do not use any Templates. This Agreement does not grant Customer any other rights but for the ones expressly contained herein." & vbCr & vbCr
Const EULA02 = "1. GRANT OF LICENSE:  This Agreement grants Customer a revocable, gratis, nonexclusive license to use the Templates as specified herein to print on Avery-branded products only. Customer may not modify or use any part of the Templates to print on or to non-Avery products. If Customer uses the Templates or any modified version of the Templates with products that are not Avery-branded, such use constitutes copyright infringement, and all rights granted immediately and automatically revert in full to Avery. Customer may modify and/or replace the content of the Templates (text, graphics, etc) for the purpose of customizing the output of the Templates on or to Avery-branded products. "
Const EULA03 = "Customer may also modify the Template structure(s) and specifications but only to the extent necessary to ensure the successful printing of the Templates, via Customer's printer(s), on or to Avery-branded products. Customer may distribute the Templates to third parties, so long as such third parties agree to the terms of this Agreement. Customer may not sell, resell, license, rent, lease, lend, or otherwise transfer for value, the Templates. Customer may not distribute the Templates in any stand-alone products that contain only the Templates or as part of any other product." & vbCr & vbCr
Const EULA04 = "2. INTELLECTUAL PROPERTY:  The Templates and all specifications related to size, layout, dimensions, and other pertinent information are owned by Avery or its subsidiaries or suppliers, and are protected by United States intellectual property laws and international treaty provisions." & vbCr & vbCr
Const EULA05 = "3. GUIDELINES FOR THE USE OF CLIPART AND PHOTOGRAPHIC IMAGES [This provision only applies if the Templates contain clipart and photographic images]:  Customer may, subject to any restrictions set out below:" & vbCr & vbCr & "(i) Incorporate any clipart and photo images provided with the Templates (""Images"") into Customer's own original work and publish, display, and distribute Customer's work in any media.  Customer may not, however, resell, sublicense, or otherwise make available the Images for use or distribution separate from Customer|fffd|s work." & vbCr & vbCr & "(ii) Make one (1) copy of the Images for back-up or archival purposes." & vbCr & vbCr
Const EULA06 = "Customer may not:  (i) create scandalous, obscene, defamatory, or immoral works using the Images nor use the Images for any other purpose that is prohibited by law; (ii) use or permit the use of the Images or any part thereof as a trademark or service mark, or claim any proprietary rights of any sort in the Images or any part thereof; (iii) use the Images in electronic format, on-line or in multimedia applications unless the Images are incorporated for viewing purposes only and no permission is given to download and/or save the Images for any reason; "
Const EULA07 = "(iv) rent, lease, sublicense, or lend the Images, or a copy thereof, to another person or legal entity (Customer may transfer all rights and to use the Images to another person or legal entity, provided that Customer transfers all rights to the Templates pursuant to Section 4 below); or (v) use any Images except as expressly permitted by this Agreement." & vbCr & vbCr
Const EULA08 = "4. RESERVATION OF RIGHTS. All title and rights in and to the Templates, and any copies of the Templates, are owned by Avery or its suppliers. All rights not expressly granted are reserved by Avery and its suppliers. In particular, this Agreement does not grant Customer any rights in connection with any trademarks or service marks of Avery or its suppliers. Use of any Templates for any purpose other than expressly permitted in this Agreement is prohibited and may result in severe civil and criminal penalties." & vbCr & vbCr
Const EULA09 = "5. TERMINATION. Without prejudice to any other rights, Avery may terminate this Agreement if Customer fails to comply with the terms and conditions of this Agreement. In such event, Customer agrees to destroy all copies of any Templates." & vbCr & vbCr
Const EULA10 = "6. NO WARRANTIES:  ALL TEMPLATES ARE PROVIDED ""AS IS"" WITHOUT ANY WARRANTY OF ANY KIND.  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, AVERY DISCLAIMS ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT WITH RESPECT TO THE TEMPLATES AND ALL ACCOMPANYING WRITTEN MATERIALS." & vbCr & vbCr
Const EULA11 = "7. NO LIABILITY FOR CONSEQUENTIAL DAMAGES:  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL AVERY OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS, LOSS OF PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER ECONOMIC LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE TEMPLATES, EVEN IF AVERY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  BECAUSE SOME STATES/JURISDICATIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, THE ABOVE LIMITATION MAY NOT APPLY TO CUSTOMER." & vbCr & vbCr
Const EULA12 = "ANY REFERENCE TO EVENTS, PEOPLE, PLACES, OR ENTITIES IN THE TEMPLATES IS PURELY FICTITIOUS AND NOT INTENDED TO REPRESENT ANY ACTUAL EVENT, PERSON, PLACE, OR ENTITY. AVERY DISCLAIMS ANY LIKENESS OR SIMILARITIES TO ACTUAL EVENTS, PEOPLE, PLACES, OR ENTITIES, AND ANY SUCH LIKENESS OR SIMILARITY IS UNINTENTIONAL AND PURELY COINCIDENTAL." & vbCr & vbCr
Const EULA13 = "8. APPLICABLE LAW:  The laws of the State of California shall govern the interpretation of this Agreement and any dispute relating to it.  Customer agrees to the sole jurisdiction and venue of the courts located in the County of Los Angeles, State of California.  If these Templates were acquired outside the United States, then local law may apply.  If Customer acquired these Templates in Canada, unless expressly prohibited by local law, this Agreement is governed by the laws in force in the province of Ontario, Canada, and Customer agrees to the following:" & vbCr & vbCr
Const EULA14 = "        The parties to this Agreement have expressly required that the" & vbCr & "        Agreement be drawn up in the English language./Les diff|fffd|rentes parties" & vbCr & "        de cette pr|fffd|sente Convention ont express|fffd|ment exig|fffd|es que la pr|fffd|sente" & vbCr & "        Convention soit redig|fffd|e en langue anglaise." & vbCr & vbCr
Const EULA15 = "9. U.S. GOVERNMENT RESTRICTED RIGHTS:  These Templates are provided with Restricted Rights.  Use, duplication, or disclosure by the United States Government is subject to restrictions as set forth in subparagraph (c) (1) and (2) of the Commercial Computer Software-Restricted Rights at 48 CFR 52.227-19, as applicable.  Manufacturer is Avery Dennison Corporation, 50 Pointe Drive, Brea, California 92821." & vbCr & vbCr
Const EULA16 = "10.EXPORT RESTRICTIONS:  Customer may not export or re-export the Templates or any underlying information or technology except in full compliance with all United States and other applicable laws and regulations." & vbCr & vbCr
Const EULA17 = "11. MISCELLANEOUS:  This is the entire Agreement between Avery and Customer relating to the Templates and supersedes any purchase order, communication, advertising, or representation concerning the Templates.  No change or modification of this Agreement will be valid unless it is in writing and signed by an officer of Avery." & vbCr & vbCr
Const EULA18 = "12. SEVERABILITY:  In the event that any one or more of the provisions contained in this Agreement shall for any reason be held by a court of competent jurisdiction to be unenforceable in any respect, such holding shall not affect any other provision of this Agreement, and the Agreement shall be construed as if such unenforceable provisions are not a part hereof."

'== cmdAgree_Click =================================================================
'
Private Sub cmdAgree_Click()
    Me.Tag = "Agree"
    Me.Hide
End Sub

'== cmdDisagree_Click ==============================================================
'
Private Sub cmdDisagree_Click()
    Me.Tag = "Disagree"
    Me.Hide
End Sub

'== UserForm_Initialize ============================================================
'
Private Sub UserForm_Initialize()
    Me.Caption = String_ApplySymbols(Me.Caption, True)
    
    txtLicense.Text = EULA01 & EULA02 & EULA03 & EULA04 & EULA05 & EULA06 & EULA07 & EULA08 _
                    & EULA09 & EULA10 & EULA11 & EULA12 & EULA13 & EULA14 & EULA15 & EULA16 _
                    & EULA17 & EULA18
    txtLicense.SelStart = 0
    txtLicense.SelLength = 0
    txtLicense.SetFocus
End Sub
Attribute VB_Name = "frmFormatPalette2007"
Attribute VB_Base = "0{9F9539A0-667B-440E-929D-875F5B9DAA64}{5FB7BCEC-0489-40FF-AB1E-2FF4024B7A28}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' frmFormatPalette2007:                                                     '
' ~~~~~~~~~~~~~~~~~~~~~                                                     '
'   Allows user to quickly reformat text in labels and cards.               '
'==========================================================================='
Option Explicit

Private m_docFormat As Document
Private m_lFillGroup As Long
Private m_bSuspendAlignEvents As Boolean

Public Function VisibleFillGroup() As Long
    If Me.Visible Then
        VisibleFillGroup = m_lFillGroup
    Else
        m_lFillGroup = 0
    End If
End Function

'Private Sub HideModelessPalette()
'    On Error Resume Next
'
'    g_trRibbonConfig.CurrentSection().HideModelessUI False
'    Unload Me
'End Sub

Public Sub HideFieldList()
    Dim fVerticalShift As Single
    
    lblSelectField.Visible = False
    lstSelectField.Visible = False
    fVerticalShift = lblFontSection.Top - lblSelectField.Top
    
    lblFontSection.Top = lblFontSection.Top - fVerticalShift
    frameFontSection.Top = frameFontSection.Top - fVerticalShift
    lblFontBanter.Top = lblFontBanter.Top - fVerticalShift
    cmdFormatFont.Top = cmdFormatFont.Top - fVerticalShift
    lblAlignmentSection.Top = lblAlignmentSection.Top - fVerticalShift
    frameAlignmentSection.Top = frameAlignmentSection.Top - fVerticalShift
    togAlignLeft.Top = togAlignLeft.Top - fVerticalShift
    togAlignCenter.Top = togAlignCenter.Top - fVerticalShift
    togAlignRight.Top = togAlignRight.Top - fVerticalShift
    frameButtonSection.Top = frameButtonSection.Top - fVerticalShift
    cmdOK.Top = cmdOK.Top - fVerticalShift
    
    Me.Height = Me.Height - fVerticalShift
End Sub

Public Sub FinishInit(sPaletteTitle As String, doc As Document, lFillGroup As Long)
    Dim lFieldAlign As Long
    
    Me.Caption = String_ApplySymbols(sPaletteTitle, False)
    Set m_docFormat = doc
    m_lFillGroup = lFillGroup
    m_bSuspendAlignEvents = False

    Set togAlignLeft.Picture = Application.CommandBars.GetImageMso("AlignLeft", 16, 16)
    togAlignCenter.Picture = Application.CommandBars.GetImageMso("AlignCenter", 16, 16)
    togAlignRight.Picture = Application.CommandBars.GetImageMso("AlignRight", 16, 16)
    
    If lstSelectField.Visible = True Then
        lstSelectField.ListIndex = 0
    Else
        RefreshPalette
    End If
End Sub

Private Sub cmdFormatFont_Click()
    Me.Tag = AT_FORMAT_FONT
    Me.Hide
End Sub

Private Sub cmdOK_Click()
    Me.Tag = DLG_OK
    Me.Hide
End Sub

Public Sub RefreshPalette()
    Dim lFieldAlign As Long, bEnableFormatting As Boolean
    Dim bMixedFontColour As Boolean, sBanterText As String
    Dim fBanterWidth As Single, fBanterHeight As Single
    Dim lLastComma As Long
    
    On Error Resume Next
    
    fBanterWidth = lblFontBanter.Width
    fBanterHeight = lblFontBanter.Height
    sBanterText = Text_FieldFontBanter(m_docFormat, m_lFillGroup, SelectedField(), _
                                       lFieldAlign, bMixedFontColour)
    lblFontBanter.AutoSize = True
    lblFontBanter.Width = fBanterWidth
    lblFontBanter.Caption = sBanterText
                                              
    Do Until lblFontBanter.Height <= fBanterHeight
        ' overflow!
        lLastComma = InStrRev(sBanterText, ",")
        If lLastComma > 0 Then
            sBanterText = Left(sBanterText, lLastComma - 1) & "..."
        Else
            Exit Do
        End If
        lblFontBanter.Width = fBanterWidth
        lblFontBanter.Caption = sBanterText
    Loop
    
    lblFontBanter.AutoSize = False
    lblFontBanter.Height = fBanterHeight
    lblFontBanter.Width = fBanterWidth
    
    UpdateAlignment lFieldAlign

    bEnableFormatting = Not (lblFontBanter.Caption = "")
    cmdFormatFont.Enabled = bEnableFormatting
    If bMixedFontColour Then
        cmdFormatFont.Tag = AT_FORMAT_MIXEDFONTCOLOUR
    Else
        cmdFormatFont.Tag = ""
    End If
    
    togAlignLeft.Enabled = bEnableFormatting
    togAlignCenter.Enabled = bEnableFormatting
    togAlignRight.Enabled = bEnableFormatting
End Sub

Private Sub lstSelectField_Change()
    RefreshPalette
End Sub

Public Function SelectedField() As Long
    If lstSelectField.Visible = False Then
        SelectedField = 1 ' only one field
    Else
        SelectedField = lstSelectField.ListIndex    ' 0 for <all>
    End If
End Function

Public Function UpdateAlignment(lFieldAlign As Long)
    m_bSuspendAlignEvents = True
    togAlignLeft.Value = (lFieldAlign = wdAlignParagraphLeft)
    togAlignCenter.Value = (lFieldAlign = wdAlignParagraphCenter)
    togAlignRight.Value = (lFieldAlign = wdAlignParagraphRight)
    m_bSuspendAlignEvents = False
End Function

Private Sub togAlignCenter_Click()
    On Error Resume Next
    
    If Not m_bSuspendAlignEvents Then
        Me.Tag = AT_FORMAT_ALIGN & wdAlignParagraphCenter
        Me.Hide
    End If
End Sub

Private Sub togAlignLeft_Click()
    On Error Resume Next
    
    If Not m_bSuspendAlignEvents Then
        Me.Tag = AT_FORMAT_ALIGN & wdAlignParagraphLeft
        Me.Hide
    End If
End Sub

Private Sub togAlignRight_Click()
    On Error Resume Next
    
    If Not m_bSuspendAlignEvents Then
        Me.Tag = AT_FORMAT_ALIGN & wdAlignParagraphRight
        Me.Hide
    End If
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    On Error Resume Next
    
    If CloseMode = vbFormControlMenu Then
        Me.Tag = DLG_OK
        Me.Hide
        Cancel = True
    End If
End Sub
Attribute VB_Name = "frmProgress"
Attribute VB_Base = "0{1A51BD2E-3FC7-491B-9B76-75F42149927D}{8358D1C5-C4C2-4CFA-BA0A-6DB568EB5154}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' frmProgress:                                                              '
' ~~~~~~~~~~~~                                                              '
'   Progress bar to show status of long operations.                         '
'   See the UtilUI module for the bulk of the progress bar code.            '
'==========================================================================='
Option Explicit
Public m_bCancelFlag As Boolean
Public m_sSubRangeStack As String
Public m_fCurrentPercent As Single

'== cmdCancel_Click ================================================================
'
Private Sub cmdCancel_Click()
    m_bCancelFlag = True
    cmdCancel.Enabled = False
End Sub

'== UserForm_QueryClose ============================================================
'
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then
        m_bCancelFlag = True
        Cancel = True
    End If
End Sub
Attribute VB_Name = "frmResizePics"
Attribute VB_Base = "0{28ADB4C4-D25D-4315-94AA-6FA4AC76FE04}{6C42D8C1-0FD6-477B-8F82-AF9DE992F535}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' frmResizePics:                                                            '
' ~~~~~~~~~~~~~~                                                            '
'   Provides user interface for determining the size of pictures (including '
'   support for percentage scaling and locked aspect ratio).                '
'==========================================================================='
Option Explicit

Private m_fOriginalWidth As Single
Private m_fOriginalHeight As Single
Private m_fCurrentWidth As Single
Private m_fCurrentHeight As Single

Private m_fNewWidth As Single
Private m_fNewHeight As Single
Private m_fScaleWidth As Single
Private m_fScaleHeight As Single
Private m_bMetricUnits As Boolean
Private m_bScaleOnly As Boolean

Private Const DLG_MAX_LENGTH = 6

'== InitializeValues ===============================================================
'
Public Sub InitializeValues(fCurWidth As Single, fCurHeight As Single, _
                            fSrcWidth As Single, fSrcHeight As Single, _
                            bLockAspect As Boolean, bAllSizesMatch As Boolean)
    
    m_bScaleOnly = Not bAllSizesMatch
    m_bMetricUnits = (Application.Options.MeasurementUnit = wdCentimeters _
                   Or Application.Options.MeasurementUnit = wdMillimeters)
                             
    If m_bMetricUnits Then
        lblHeightUnits.Caption = "cm"
        lblWidthUnits.Caption = "cm"
    Else
        lblHeightUnits.Caption = "in"
        lblWidthUnits.Caption = "in"
    End If
                             
    m_fCurrentHeight = fCurHeight
    m_fCurrentWidth = fCurWidth
    m_fNewHeight = fCurHeight
    m_fNewWidth = fCurWidth
    If m_bScaleOnly Or fSrcHeight = 0 Or fSrcWidth = 0 Then
        m_fOriginalHeight = fCurHeight
        m_fOriginalWidth = fCurWidth
    Else
        m_fOriginalHeight = fSrcHeight
        m_fOriginalWidth = fSrcWidth
    End If
    
    UpdateScaleHeight
    UpdateScaleWidth
    PushAllValues
    chkLockAspect.Value = bLockAspect
    
    If m_bScaleOnly Then
        UI_SelectAndFocusFormTextBox txtScaleHeight
    Else
        UI_SelectAndFocusFormTextBox txtHeight
    End If
    
    lblHeight.Enabled = Not m_bScaleOnly
    txtHeight.Enabled = Not m_bScaleOnly
    txtHeight.BackColor = IIf(m_bScaleOnly, vbButtonFace, vbWindowBackground)
    lblHeightUnits.Enabled = Not m_bScaleOnly
    lblWidth.Enabled = Not m_bScaleOnly
    txtWidth.Enabled = Not m_bScaleOnly
    txtWidth.BackColor = IIf(m_bScaleOnly, vbButtonFace, vbWindowBackground)
    lblWidthUnits.Enabled = Not m_bScaleOnly
End Sub

'== GetValues ======================================================================
'
Public Function GetValues(ByRef fWidth As Single, ByRef fHeight As Single, _
                          ByRef bLockAspect As Boolean) As Boolean
    If Me.Tag = "OK" Then
        GetValues = True
        If m_bScaleOnly Or m_fCurrentHeight = 0 Or m_fCurrentWidth = 0 Then
            fHeight = m_fScaleHeight / 100
            fWidth = m_fScaleWidth / 100
        
            fHeight = Math_Max(fHeight, 0.01)
            fHeight = Math_Min(fHeight, 100)
            fWidth = Math_Max(fWidth, 0.01)
            fWidth = Math_Min(fWidth, 100)
        Else
                        
            m_fNewHeight = Math_Min(m_fNewHeight, 800)
            m_fNewHeight = Math_Max(m_fNewHeight, 0.3)
            m_fNewWidth = Math_Min(m_fNewWidth, 800)
            m_fNewWidth = Math_Max(m_fNewWidth, 0.3)
            
            fHeight = m_fNewHeight / m_fCurrentHeight
            fWidth = m_fNewWidth / m_fCurrentWidth
        End If

        bLockAspect = chkLockAspect.Value
    Else
        GetValues = False
    End If
End Function

'== txtHeight_Enter ================================================================
'
Private Sub txtHeight_Enter()
    On Error Resume Next
    
    txtHeight.Tag = txtHeight.Value
End Sub

'== txtHeight_Exit =================================================================
'
Private Sub txtHeight_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Dim fOldHeight As Single, fNewHeight As Single
    On Error Resume Next
    
    If txtHeight.Tag <> txtHeight.Value Then
        If IsNumeric(txtHeight.Value) Then
            fNewHeight = ConvertToPoints(txtHeight.Value)
            If fNewHeight > 0 Then
                fOldHeight = m_fNewHeight
                m_fNewHeight = Math_Max(fNewHeight, 0.72)
                
                UpdateScaleHeight
                If chkLockAspect.Value Then
                    m_fNewWidth = m_fNewHeight / fOldHeight * m_fNewWidth
                    UpdateScaleWidth
                End If
                PushAllValues
            End If
        End If
    End If
End Sub

'== txtWidth_Enter =================================================================
'
Private Sub txtWidth_Enter()
    On Error Resume Next

    txtWidth.Tag = txtWidth.Value
End Sub

'== txtWidth_Exit ==================================================================
'
Private Sub txtWidth_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Dim fOldWidth As Single, fNewWidth As Single
    On Error Resume Next
    
    If txtWidth.Tag <> txtWidth.Value Then
        If IsNumeric(txtWidth.Value) Then
            fNewWidth = ConvertToPoints(txtWidth.Value)
            If fNewWidth > 0 Then
                fOldWidth = m_fNewWidth
                m_fNewWidth = Math_Max(fNewWidth, 0.72)
                
                UpdateScaleWidth
                If chkLockAspect.Value Then
                    m_fNewHeight = m_fNewWidth / fOldWidth * m_fNewHeight
                    UpdateScaleHeight
                End If
                PushAllValues
            End If
        End If
    End If
End Sub

'== txtScaleHeight_Enter ===========================================================
'
Private Sub txtScaleHeight_Enter()
    On Error Resume Next
    txtScaleHeight.Tag = txtScaleHeight.Value
End Sub

'== txtScaleHeight_Exit ============================================================
'
Private Sub txtScaleHeight_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Dim fOldScaleHeight As Single, fNewScaleHeight As Single
    On Error Resume Next

    If txtScaleHeight.Tag <> txtScaleHeight.Value Then
        If IsNumeric(txtScaleHeight.Value) Then
            fNewScaleHeight = Round(Val(txtScaleHeight.Value))
            
            If fNewScaleHeight > 0 Then
                fOldScaleHeight = m_fScaleHeight
                m_fScaleHeight = Math_Max(fNewScaleHeight, 1)
                
                UpdateHeight
                If chkLockAspect.Value Then
                    m_fScaleWidth = m_fScaleHeight / fOldScaleHeight * m_fScaleWidth
                    UpdateWidth
                End If
                PushAllValues
            End If
        End If
    End If
End Sub

'== txtScaleWidth_Enter ============================================================
'
Private Sub txtScaleWidth_Enter()
    On Error Resume Next
    txtScaleWidth.Tag = txtScaleWidth.Value
End Sub

'== txtScaleWidth_Exit =============================================================
'
Private Sub txtScaleWidth_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Dim fOldScaleWidth As Single, fNewScaleWidth As Single
    On Error Resume Next

    If txtScaleWidth.Tag <> txtScaleWidth.Value Then
        If IsNumeric(txtScaleWidth.Value) Then
            fNewScaleWidth = Round(Val(txtScaleWidth.Value))
            
            If fNewScaleWidth > 0 Then
                fOldScaleWidth = m_fScaleWidth
                m_fScaleWidth = Math_Max(fNewScaleWidth, 1)
                
                UpdateWidth
                If chkLockAspect.Value Then
                    m_fScaleHeight = m_fScaleWidth / fOldScaleWidth * m_fScaleHeight
                    UpdateHeight
                End If
                PushAllValues
            End If
        End If
    End If
End Sub

'== cmdCancel_Click ================================================================
'
Private Sub cmdCancel_Click()
    On Error Resume Next
    Me.Tag = "Cancel"
    Me.Hide
End Sub

Private Function Validate(sNumericValue As String) As Boolean
    On Error Resume Next
    Validate = False
    If IsNumeric(sNumericValue) Then
        Validate = Val(sNumericValue) > 0
    End If
End Function

'== cmdOK_Click ====================================================================
'
Private Sub cmdOK_Click()
    On Error Resume Next
        
    If txtHeight.Enabled And Not Validate(txtHeight.Value) Then
        UI_MsgBox2003 "Please enter a number greater than zero for Height.", vbExclamation, , Me.Caption
        UI_SelectAndFocusFormTextBox txtHeight
        Exit Sub
    End If
    If txtWidth.Enabled And Not Validate(txtWidth.Value) Then
        UI_MsgBox2003 "Please enter a number greater than zero for Width.", vbExclamation, , Me.Caption
        UI_SelectAndFocusFormTextBox txtWidth
        Exit Sub
    End If
    If txtScaleHeight.Enabled And Not Validate(txtScaleHeight.Value) Then
        UI_MsgBox2003 "Please enter a number greater than zero for Scale Height.", vbExclamation, , Me.Caption
        UI_SelectAndFocusFormTextBox txtScaleHeight
        Exit Sub
    End If
    If txtScaleWidth.Enabled And Not Validate(txtScaleWidth.Value) Then
        UI_MsgBox2003 "Please enter a number greater than zero for Scale Width.", vbExclamation, , Me.Caption
        UI_SelectAndFocusFormTextBox txtScaleWidth
        Exit Sub
    End If
        
    Me.Tag = "OK"
    Me.Hide
End Sub

'== UpdateHeight ===================================================================
'
Private Sub UpdateHeight()
    ' update actual height based on scale height
    m_fNewHeight = Math_Max(m_fOriginalHeight * (m_fScaleHeight / 100), 0.72)
End Sub

'== UpdateWidth ====================================================================
'
Private Sub UpdateWidth()
    ' update actual width based on scale width
    m_fNewWidth = Math_Max(m_fOriginalWidth * (m_fScaleWidth / 100), 0.72)
End Sub

'== UpdateScaleHeight ==============================================================
'
Private Sub UpdateScaleHeight()
    ' update scale height based on actual height
    m_fScaleHeight = Math_Max(m_fNewHeight / m_fOriginalHeight * 100, 1)
End Sub

'== UpdateScaleWidth ===============================================================
'
Private Sub UpdateScaleWidth()
    ' update scale width based on actual width
    m_fScaleWidth = Math_Max(m_fNewWidth / m_fOriginalWidth * 100, 1)
End Sub

'== PushAllValues ==================================================================
'
Private Sub PushAllValues()
    Dim lScaleWidth As Long, lScaleHeight As Long
    
    If Not m_bScaleOnly Then
        txtHeight.Value = ConvertFromPoints(m_fNewHeight)
        txtWidth.Value = ConvertFromPoints(m_fNewWidth)
    End If
    
    lScaleWidth = Round(m_fScaleWidth)
    lScaleHeight = Round(m_fScaleHeight)
    If lScaleWidth <> lScaleHeight And Abs(m_fScaleWidth - m_fScaleHeight) < 1.5 Then
        ' rounding error has made these different but they're really the same
        ' use the more correct one
        If Abs(lScaleHeight - m_fScaleHeight) < Abs(lScaleWidth - m_fScaleWidth) Then
            lScaleWidth = lScaleHeight
        Else
            lScaleHeight = lScaleWidth
        End If
    End If
    
    txtScaleHeight.Value = Right(Format(lScaleHeight), DLG_MAX_LENGTH)
    txtScaleWidth.Value = Right(Format(lScaleWidth), DLG_MAX_LENGTH)
End Sub

'== ConvertToPoints ================================================================
'
Private Function ConvertToPoints(sNumeric As String) As Single
    If m_bMetricUnits Then
        ConvertToPoints = Application.CentimetersToPoints(Val(sNumeric))
    Else
        ConvertToPoints = Application.InchesToPoints(Val(sNumeric))
    End If
End Function

'== ConvertFromPoints ==============================================================
'
Private Function ConvertFromPoints(fPts As Single) As String
    Dim fMeasurement As Single, sMeasurement As String
    
    If m_bMetricUnits Then
        fMeasurement = Application.PointsToCentimeters(fPts)
    Else
        fMeasurement = Application.PointsToInches(fPts)
    End If
    
    sMeasurement = Format(fMeasurement, "0.00")
    If Len(sMeasurement) > DLG_MAX_LENGTH Then
        sMeasurement = Format(Round(fMeasurement), "0")
    
        If Len(sMeasurement) > DLG_MAX_LENGTH Then
            sMeasurement = Right(sMeasurement, DLG_MAX_LENGTH)
        End If
    End If
    
    ConvertFromPoints = sMeasurement
End Function


Attribute VB_Name = "frmTextFill2007"
Attribute VB_Base = "0{A934392B-AE97-48CC-AC73-25EC06FF67E8}{E42B91FD-9BFE-45D1-95AC-E3ACFB502062}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==========================================================================='
' Avery(R) Templates for Microsoft(R) Office                                '
' Copyright (c) 2007-2010, Avery Dennison Office Products.                  '
'                                                                           '
' frmTextFill2007:                                                          '
' ~~~~~~~~~~~~~~~~                                                          '
'   Implements AutoFill dialog box.  Based on Avery's Template Specific     '
'   Autofill for front &  back tab templates.                               '
'==========================================================================='
Option Explicit
Const DLG_FIELD_LIMIT As Long = 15   ' maximum fields allowed in dialog box
                                     ' clients retrieve via FieldLimit
Private Const MULTILINE_LINE_INCREMENT As Single = 10.5 ' extra height for
                                                        ' text box, per line
                                     
' two variables that track which section & group, if any, the AutoFill dialog
' is initialized for
Private m_lSectionIndex As Long
Private m_lFillGroup As Long
Private m_bInitialized As Boolean

Private m_lMaxFieldIndex As Long
Private m_fMultiLineExtraHeight As Single
Private m_fMaxTextBoxLeft As Single
Private m_fMaxTextBoxWidth As Single

'== FieldLimit =====================================================================
'
Public Function FieldLimit() As Long
    FieldLimit = DLG_FIELD_LIMIT
End Function

'== FieldCount =====================================================================
'
Public Function FieldCount() As Long
    FieldCount = m_lMaxFieldIndex
End Function

'== IsInitialized ==================================================================
'
Public Function IsInitialized() As Boolean
    IsInitialized = m_bInitialized
End Function

'== StartInit ======================================================================
'
Public Sub StartInit(lSectionIndex As Long, lFillGroup As Long)
    If (lSectionIndex <> m_lSectionIndex) Or (lFillGroup <> m_lFillGroup) Then
        ' must re-init dialog box -- unload ourselves to clear the cache
        ' (i.e. sets section, fill group, initialized, extra height to zero)
        Unload Me
    Else
        m_bInitialized = True
    End If
End Sub

'== SetTextLabel ===================================================================
'
Public Sub SetTextLabel(lDlgFieldIndex As Long, sName As String)
    Dim ctrlLabel As MSForms.control, ctrlText As MSForms.TextBox
    
    Set ctrlText = TextControl(lDlgFieldIndex)
    Set ctrlLabel = LabelControl(lDlgFieldIndex, True)
    If Not ctrlLabel Is Nothing Then
        UI_ReLabelAndShiftForm ctrlLabel, sName & ":", "", ctrlText
        If ctrlText.Left > m_fMaxTextBoxLeft Then
            m_fMaxTextBoxLeft = ctrlText.Left
        End If
        If m_fMultiLineExtraHeight > 0 Then
            ctrlLabel.Top = ctrlLabel.Top + m_fMultiLineExtraHeight
        End If
    End If
End Sub

'== GetTextValue ===================================================================
'
Public Function GetTextValue(lDlgFieldIndex As Long, ByRef lXmlFieldIndex As Long)
    Dim ctrlText As MSForms.TextBox
    
    Set ctrlText = TextControl(lDlgFieldIndex, True)
    If ctrlText Is Nothing Then
        lXmlFieldIndex = 0
        GetTextValue = ""
    Else
        lXmlFieldIndex = Val(ctrlText.Tag)
        GetTextValue = ctrlText.Text
    End If
End Function

'== SetTextValue ===================================================================
'
Public Sub SetTextValue(lDlgFieldIndex As Long, lXmlFieldIndex As Long, _
                        sValue As String, nMultiLines As Long, _
                        fWidthFactor As Single)
    Dim ctrlText As MSForms.TextBox
    
    Set ctrlText = TextControl(lDlgFieldIndex, True)
    If Not ctrlText Is Nothing Then
        ctrlText.Text = sValue
        ctrlText.Tag = Format(lXmlFieldIndex)
        If Not m_bInitialized Then
            If m_fMultiLineExtraHeight > 0 Then
                ctrlText.Top = ctrlText.Top + m_fMultiLineExtraHeight
            End If
            If nMultiLines > 1 Then
                ' if MultiLine we need to update the form
                ctrlText.MultiLine = True
                ctrlText.Height = ctrlText.Height _
                                + MULTILINE_LINE_INCREMENT * (nMultiLines - 1)
                ctrlText.ScrollBars = fmScrollBarsVertical
            
                ' move subsequent controls down
                m_fMultiLineExtraHeight = m_fMultiLineExtraHeight _
                                + MULTILINE_LINE_INCREMENT * (nMultiLines - 1)
            Else
                ctrlText.MultiLine = False
                ctrlText.ScrollBars = fmScrollBarsNone
            End If
        
            If lDlgFieldIndex > m_lMaxFieldIndex Then
                m_lMaxFieldIndex = lDlgFieldIndex
            End If
            
            If (fWidthFactor * 8) > m_fMaxTextBoxWidth Then
                m_fMaxTextBoxWidth = fWidthFactor * 8
            End If
        End If
    End If
End Sub

'== FinishInit =====================================================================
'
Public Sub FinishInit(sUITitle As String, lSectionIndex As Long, lFillGroup As Long)
    Dim lField As Long, txtField As MSForms.TextBox, lblFix As MSForms.Label
    Dim fLabelShift As Single, fWidthIncrease As Single
    Dim fCollapseHeight As Single, fHeightShift As Single
    Dim fScrollAreaBottom As Single, fOldHeight As Single, fNewHeight As Single
    
    ' update cache to allow re-use
    m_lSectionIndex = lSectionIndex
    m_lFillGroup = lFillGroup
    
    ' if so, fix the dialog layout
    If Not m_bInitialized Then
        fLabelShift = 0
        fWidthIncrease = Math_Max(0, m_fMaxTextBoxWidth - TextControl(1).Width)
        
        For lField = 1 To m_lMaxFieldIndex
            Set txtField = TextControl(lField)
        
            If fLabelShift > 0 Then
                txtField.Width = fLabelShift + txtField.Width
            End If
            txtField.Left = m_fMaxTextBoxLeft
            
            If fWidthIncrease > 0 Then
                txtField.Width = m_fMaxTextBoxWidth
            End If
            
            If lField = m_lMaxFieldIndex Then
                fScrollAreaBottom = txtField.Top + txtField.Height + AT_DIALOG_MARGIN
            End If
        Next lField
        For lField = m_lMaxFieldIndex + 1 To DLG_FIELD_LIMIT
            TextControl(lField).Visible = False
            LabelControl(lField).Visible = False
        Next lField
        
        ' depending on height of text controls, make frame scroll, shrink
        ' frame, or do nothing...
        If fScrollAreaBottom > GroupFrame.InsideHeight Then
            GroupFrame.ScrollBars = fmScrollBarsVertical
            GroupFrame.ScrollHeight = fScrollAreaBottom
            fCollapseHeight = 0
        ElseIf fScrollAreaBottom < GroupFrame.InsideHeight - AT_DIALOG_MARGIN Then
            GroupFrame.ScrollBars = fmScrollBarsNone
            fCollapseHeight = GroupFrame.InsideHeight - fScrollAreaBottom
            GroupFrame.Height = GroupFrame.Height - fCollapseHeight
        Else
            fCollapseHeight = 0
        End If
        
        lblBrandText.Top = lblBrandText.Top - fCollapseHeight
        lblCopyright.Top = lblCopyright.Top - fCollapseHeight
        cmdOK.Top = cmdOK.Top - fCollapseHeight
        cmdCancel.Top = cmdCancel.Top - fCollapseHeight
        cmdWebHelp.Top = cmdWebHelp.Top - fCollapseHeight
        
        Height = Height - fCollapseHeight
        
        Height = cmdOK.Top + cmdOK.Height + (Height - InsideHeight) + AT_DIALOG_MARGIN
        Caption = UI2007_GetLocalString(CTRLS_RIBBON, "", RIBBON_TEXTEDIT & lFillGroup, STRING_LABEL)
        
        lblTitle.Caption = String_ApplySymbols(sUITitle, False)
        
        ' vertically center new UI title (allows for one or two lines of text)
        fOldHeight = lblTitle.Height
        lblTitle.AutoSize = True
        fNewHeight = lblTitle.Height
        lblTitle.Top = lblTitle.Top + ((fOldHeight - lblTitle.Height) / 2)
        
        ' avoid funky font size bug (SCR 5100)
        For lField = 1 To m_lMaxFieldIndex
            Set lblFix = LabelControl(lField)
            
            lblFix.AutoSize = False
            lblFix.Height = 10
            lblFix.Font.Size = 8
            
            TextControl(lField).Font.Size = 8
        Next lField
        
        m_fMultiLineExtraHeight = 0
        m_fMaxTextBoxLeft = 0
        m_bInitialized = True
    End If
End Sub

'== UnInit =========================================================================
'
Public Sub UnInit()
    ' marks a half-initialized dialog as invalid
    m_lSectionIndex = 0
    m_lFillGroup = 0
End Sub

'== cmdCancel_Click ================================================================
'
Private Sub cmdCancel_Click()
    Me.Tag = DLG_CANCEL
    Me.Hide
End Sub

'== cmdOK_Click ====================================================================
Private Sub cmdOK_Click()
    Me.Tag = DLG_OK
    Me.Hide
End Sub

'== TextControl ====================================================================
'
Private Function TextControl(lFieldIndex As Long, _
                             Optional bStrict As Boolean = False) As MSForms.TextBox
    If lFieldIndex > 0 And lFieldIndex <= DLG_FIELD_LIMIT Then
        Set TextControl = Me.Controls("txtField" & Format(lFieldIndex, "#0"))
    ElseIf bStrict Then
        Set TextControl = Nothing
    Else
        Set TextControl = txtField1
    End If
End Function

'== LabelControl ===================================================================
'
Private Function LabelControl(lFieldIndex As Long, _
                              Optional bStrict As Boolean = False) As MSForms.Label
    If lFieldIndex > 0 And lFieldIndex <= DLG_FIELD_LIMIT Then
        Set LabelControl = Me.Controls("lblField" & Format(lFieldIndex, "#0"))
    ElseIf bStrict Then
        Set LabelControl = Nothing
    Else
        Set LabelControl = lblField1
    End If
End Function

Private Sub cmdWebHelp_Click()
    UI2007_BrowseLink ActiveDocument, "buttonAveryHelp", ""
End Sub

'== UserForm_Initialize ============================================================
'
Private Sub UserForm_Initialize()
    On Error Resume Next
    
    UI_SetFormUIFont Me, "", ""
    cmdOK.Caption = "OK"
    cmdCancel.Caption = "Cancel"
    ' other relayout to be done once field names are loaded
End Sub

' InQuest injected base64 decoded content
' zjej
' v+S{
' bzWO
' z{Rr

INQUEST-PP=macro
