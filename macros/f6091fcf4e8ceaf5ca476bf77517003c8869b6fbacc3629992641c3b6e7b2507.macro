Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
    #If Win64 Then
        Dim l As LongPtr
    #Else
        Dim l As Long
    #End If

    'Check for Updates
    Dim uC As New clsUpdate
    If uC.isUpdateAvailable Then
        If MsgBox("Es ist eine neuere Programmversion verf|fffd|gbar, m|fffd|chten Sie die Anwendung schlie|fffd|en und die Downloadseite |fffd|ffnen?", vbQuestion + vbYesNo) = vbYes Then
            l = ShellExecute(0, "Open", uC.get_download_url)
            Set uC = Nothing
            Application.Quit
            Exit Sub
        End If
    End If
    
    Set uC = Nothing
    
    '//alte Auftraggeberdaten aus der Registry l|fffd|schen
    On Error Resume Next
        Call DeleteSetting("Excel2SepaXML")
    On Error GoTo 0
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "cmdMen|fffd|, 1, 0, MSForms, CommandButton"
Option Explicit

Private Sub cmdMen|fffd|_Click()
    Call frmMen|fffd|.Show(vbModeless)
End Sub
Attribute VB_Name = "cCalendar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'###############################################################
'# Calendar Control Class v2.0.0                               #
'#                                                             #
'# Team authors:                                               #
'# Krisztina Szab|fffd|                                             #
'# G|fffd|bor Mad|fffd|cs                                                #
'# Roberto Mensa (nick r)                                      #
'#                                                             #
'# https://sites.google.com/site/e90e50/calendar-control-class #
'#                                                             #
'#   The FrankensTeam                                          #
'###############################################################

'# Event Triggered By Main Object
Public Event AfterUpdate()
Public Event BeforeUpdate(ByRef Cancel As Integer)
Public Event Click()
Public Event DblClick()
Public Event KeyDown( _
    ByVal KeyCode As MSForms.ReturnInteger, _
    ByVal Shift As Integer)

'# Members for Main Object
Private WithEvents CBxY As MSForms.ComboBox
Attribute CBxY.VB_VarHelpID = -1
Private WithEvents CBxM As MSForms.ComboBox
Attribute CBxM.VB_VarHelpID = -1

Private CLb As MSForms.Label
Private mDayButtons() As cCalendar
Private mLabelButtons() As cCalendar

Private PTitleNewFont As MSForms.NewFont
Private PDayNewFont As MSForms.NewFont
Private PGridNewFont As MSForms.NewFont
'# Members for Button Object
Private WithEvents CmB As MSForms.CommandButton
Attribute CmB.VB_VarHelpID = -1
Private CmBl As MSForms.Label
Private CmBlNum As MSForms.Label
Private mcMain As cCalendar

'# For Properties
Private lPFontSize As Long
Private lPMonthLength As calMonthLength
Private lPDayLength As Long
Private bPYearFirst As Boolean
Private lPTitleFontColor As OLE_COLOR
Private lPGridFontColor As OLE_COLOR
Private lPDayFontColor As OLE_COLOR
Private lPFirstDay As calDayOfWeek
Private dValue As Date
Private lPBackColor As OLE_COLOR
Private lPMonth As Long
Private lPYear As Long
Private lPDay As Long
Private lPHeaderBackColor As OLE_COLOR
Private lPUseDefaultBackColors  As Boolean
Private bPVisible As Boolean
Private sPHeight As Single
Private sPWidth As Single
Private sPTop As Single
Private sPLeft As Single
Private lPSaturdayBackColor As OLE_COLOR
Private lPSundayBackColor As OLE_COLOR
Private lPSelectedBackColor As OLE_COLOR
Private lPUnSelectableBackColor As OLE_COLOR
Private sPControlTipText As String
Private bPTabStop As Boolean
Private lPTabIndex As Long
Private sPTag As String

Private bPShowDays As Boolean
Private bPShowTitle As Boolean
Private bPShowDateSelectors As Boolean
Private bPValueIsNull As Boolean
Private bPRightToLeft As Boolean

Private bPMACFix As Boolean 'Fix MAC transparency errors
Private bPWeekdaySelectable As Boolean
Private bPSaturdaySelectable As Boolean
Private bPSundaySelectable As Boolean
Private bPValueSelectable As Boolean '(Used in buttons too).

Private maColoredArrayTable As Variant

Private Const cDayFontColorSelected As Long = &H80000012 'Button text - Black
Private Const cDayFontColorInactive As Long = &H80000011 'Disabled text - Dark gray
Private Const cDefaultWidth As Single = 216
Private Const cDefaultHeight As Single = 144

Public Enum calDayOfWeek
    dwMonday = 1
    dwTuesday = 2
    dwWednesday = 3
    dwThursday = 4
    dwFriday = 5
    dwSaturday = 6
    dwSunday = 7
End Enum

Public Enum calMonthLength '(Used for month and day names too.)
    mlLocalLong = 0 'Local name, long form
    mlLocalShort = 1 'Local name, short form
    mlENLong = 2 'English name, long form
    mlENShort = 3 'English name, short form
End Enum

Private Enum ColorCols 'ColoredDateArray fields
    ccColor = 1
    ccFormat = 2
    ccDateList = 3
    ccSelectable = 4
End Enum

'################################################
'# Properties for Main object - Not available

Public Property Get GridCellEffect() As Long
'Property Blank - not work
'Determines the effect used to display the grid.
End Property

Public Property Get GridLinesColor() As OLE_COLOR
'Property Blank - not work
'Determines the color used to display the lines in the grid.
End Property

Public Property Get ShowHorizontalGrid() As Boolean
'Property Blank - not work
'Specifies whether the calendar display horizontal gridlines.
End Property

Public Property Get ShowVerticalGrid() As Boolean
'Property Blank - not work
'Specifies whether to display vertical gridlines.
End Property

Public Property Get HelpContextID() As Long
'Property Blank - not work
'Specifies Help identifier
End Property


'###########################
'# Properties for Main object

Public Property Get Tag() As String
    Tag = sPTag
End Property

Public Property Let Tag(sTag As String)
    sPTag = sTag
End Property

Public Property Get Parent() As Control
    If bInit Then
        Set Parent = CBxY.Parent.Parent
    Else
        Set Parent = Nothing
    End If
End Property

Public Property Get ValueIsNull() As Boolean
    ValueIsNull = bPValueIsNull
End Property

Public Property Let ValueIsNull(ByVal bValueIsNull As Boolean)
    bPValueIsNull = bValueIsNull
    If bInit Then
        Value = Value
    End If
End Property

Public Property Get ShowTitle() As Boolean
    ShowTitle = bPShowTitle
End Property

Public Property Let ShowTitle(ByVal bShowTitle As Boolean)
    bPShowTitle = bShowTitle
    If bInit Then
        CLb.Visible = bPShowTitle
        Call Move
    End If
End Property

Public Property Get ShowDays() As Boolean
    ShowDays = bPShowDays
End Property

Public Property Let ShowDays(ByVal bShowDays As Boolean)
    Dim i As Long
    bPShowDays = bShowDays
    If bInit Then
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.Visible = bShowDays
        Next
        Call Move
    End If
End Property

Public Property Get ShowDateSelectors() As Boolean
    ShowDateSelectors = bPShowDateSelectors
End Property

Public Property Let ShowDateSelectors(ByVal bShowDateSelectors As Boolean)
    bPShowDateSelectors = bShowDateSelectors
    If bInit Then
        CBxY.Visible = bShowDateSelectors
        CBxM.Visible = bShowDateSelectors
        Call Move
    End If
End Property

Public Property Get TabIndex() As Long
    TabIndex = lPTabIndex
End Property

Public Property Let TabIndex(ByVal lTabIndex As Long)
    lPTabIndex = lTabIndex
    If bInit Then
        CBxY.Parent.TabIndex = lTabIndex
    End If
End Property

Public Property Get TabStop() As Boolean
    TabStop = bPTabStop
End Property

Public Property Let TabStop(ByVal bTabStop As Boolean)
    bPTabStop = bTabStop
    If bInit Then
        CBxY.Parent.TabStop = bTabStop
    End If
End Property

Public Property Get ControlTipText() As String
    ControlTipText = sPControlTipText
End Property

Public Property Let ControlTipText(ByVal sControlTipText As String)
    Dim i As Long
    sPControlTipText = sControlTipText
    If bInit Then
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.ControlTipText = sControlTipText
        Next
        For i = 0 To 41
            mDayButtons(i).Obj_Cmb.ControlTipText = sControlTipText
        Next
        CBxM.ControlTipText = sControlTipText
        CBxY.ControlTipText = sControlTipText
        CLb.ControlTipText = sControlTipText
        'CBxY.Parent.ControlTipText = sControlTipText
    End If
End Property

Public Property Get GridFont() As MSForms.NewFont
    Set GridFont = PGridNewFont
End Property

Public Property Set GridFont(ByRef clGridNewFont As MSForms.NewFont)
    Set PGridNewFont = clGridNewFont
End Property

Public Property Get DayFont() As MSForms.NewFont
    Set DayFont = PDayNewFont
End Property

Public Property Set DayFont(ByRef clDayNewFont As MSForms.NewFont)
    Set PDayNewFont = clDayNewFont
End Property

Public Property Get TitleFont() As MSForms.NewFont
    Set TitleFont = PTitleNewFont
End Property

Public Property Set TitleFont(ByRef clTitleNewFont As MSForms.NewFont)
    Set PTitleNewFont = clTitleNewFont
End Property

Public Property Get Visible() As Boolean
    Visible = bPVisible
End Property

Public Property Let Visible(ByVal bVisible As Boolean)
    bPVisible = bVisible
    If bInit Then
        CBxY.Parent.Visible = bVisible
    End If
End Property

Public Property Get Left() As Single
    Left = sPLeft
End Property

Public Property Let Left(ByVal sLeft As Single)
    sPLeft = sLeft
    If bInit Then
        CBxY.Parent.Left = sLeft
    End If
End Property

Public Property Get Top() As Single
    Top = sPTop
End Property

Public Property Let Top(ByVal ssTop As Single)
    sPTop = ssTop
    If bInit Then
        CBxY.Parent.Top = ssTop
    End If
End Property

Public Property Get Height() As Single
    Height = sPHeight
End Property

Public Property Let Height(ByVal sHeight As Single)
    sPHeight = sHeight
    If bInit Then
        CBxY.Parent.Height = sHeight
        Call Move
    End If
End Property


Public Property Get Width() As Single
    Width = sPWidth
End Property

Public Property Let Width(ByVal sWidth As Single)
    'sWidth = Zero_Negative_Value(sWidth)
    sPWidth = sWidth
    If bInit Then
        CBxY.Parent.Width = sWidth
        Call Move
    End If
End Property

Public Property Get BackColor() As OLE_COLOR
    BackColor = lPBackColor
End Property

Public Property Let BackColor(ByVal lBackColor As OLE_COLOR)
    lPBackColor = lBackColor
    If bInit Then
        CBxY.Parent.BackColor = lBackColor
    End If
End Property

Public Property Get HeaderBackColor() As OLE_COLOR
    HeaderBackColor = lPHeaderBackColor
End Property

Public Property Let HeaderBackColor(ByVal lHeaderBackColor As OLE_COLOR)
    lPHeaderBackColor = lHeaderBackColor
    UseDefaultBackColors = False
End Property

Public Property Get UseDefaultBackColors() As Boolean
    UseDefaultBackColors = lPUseDefaultBackColors
End Property

Public Property Let UseDefaultBackColors(ByVal lUseDefaultBackColors As Boolean)
    lPUseDefaultBackColors = lUseDefaultBackColors
    Call Refresh
End Property

Public Property Get SaturdayBackColor() As OLE_COLOR
    SaturdayBackColor = lPSaturdayBackColor
End Property

Public Property Let SaturdayBackColor(ByVal lSaturdayBackColor As OLE_COLOR)
    lPSaturdayBackColor = lSaturdayBackColor
    UseDefaultBackColors = False
End Property

Public Property Get SundayBackColor() As OLE_COLOR
    SundayBackColor = lPSundayBackColor
End Property

Public Property Let SundayBackColor(ByVal lSundayBackColor As OLE_COLOR)
    lPSundayBackColor = lSundayBackColor
    UseDefaultBackColors = False
End Property

Public Property Get SelectedBackColor() As OLE_COLOR
    SelectedBackColor = lPSelectedBackColor
End Property

Public Property Let SelectedBackColor(ByVal lSelectedBackColor As OLE_COLOR)
    lPSelectedBackColor = lSelectedBackColor
    Call Refresh
End Property

Public Property Get UnSelectableBackColor() As OLE_COLOR
    UnSelectableBackColor = lPUnSelectableBackColor
End Property

Public Property Let UnSelectableBackColor(ByVal lUnSelectableBackColor As OLE_COLOR)
    lPUnSelectableBackColor = lUnSelectableBackColor
    Call Refresh
End Property

Public Property Get SaturdaySelectable() As Boolean
    SaturdaySelectable = bPSaturdaySelectable
End Property

Public Property Let SaturdaySelectable(ByVal bSaturdaySelectable As Boolean)
    bPSaturdaySelectable = bSaturdaySelectable
    Call Refresh
End Property

Public Property Get SundaySelectable() As Boolean
    SundaySelectable = bPSundaySelectable
End Property

Public Property Let SundaySelectable(ByVal bSundaySelectable As Boolean)
    bPSundaySelectable = bSundaySelectable
    Call Refresh
End Property

Public Property Get WeekdaySelectable() As Boolean
    WeekdaySelectable = bPWeekdaySelectable
End Property

Public Property Let WeekdaySelectable(ByVal bWeekdaySelectable As Boolean)
    bPWeekdaySelectable = bWeekdaySelectable
    Call Refresh
End Property

Public Property Get FirstDay() As calDayOfWeek
    FirstDay = lPFirstDay
End Property

Public Property Let FirstDay(ByVal vbFirstDay As calDayOfWeek)
    Select Case vbFirstDay
        Case 1 To 7
        Case Else
            vbFirstDay = 1
    End Select
    
    lPFirstDay = vbFirstDay
    If bInit Then
        Call ApplyWeekDayLabelChanges
        Call Refresh
    End If
End Property

Public Property Get DayFontColor() As OLE_COLOR
    DayFontColor = lPDayFontColor
End Property

Public Property Let DayFontColor(ByVal lFontColor As OLE_COLOR)
    Dim i As Long
    
    lPDayFontColor = lFontColor
    If bInit Then
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.ForeColor = lFontColor
        Next
    End If
End Property

Public Property Get GridFontColor() As OLE_COLOR
    GridFontColor = lPGridFontColor
End Property

Public Property Let GridFontColor(ByVal lFontColor As OLE_COLOR)
    lPGridFontColor = lFontColor
    Call Refresh
End Property

Public Property Let TitleFontColor(ByVal lFontColor As OLE_COLOR)
    lPTitleFontColor = lFontColor
    If bInit Then
        CLb.ForeColor = lFontColor
    End If
End Property

Public Property Get TitleFontColor() As OLE_COLOR
    TitleFontColor = lPTitleFontColor
End Property

Public Property Get Month() As Long
    Month = lPMonth
End Property

Public Property Let Month(ByVal lMonth As Long)
    If lMonth = 0 Then
        Value = Empty
    Else
        If lMonth < 0 Then lMonth = lPMonth
        lMonth = fMin(lMonth, 12)
        Value = SumMonthsToDate(dValue, lMonth - lPMonth)
    End If
    lPMonth = lMonth
End Property

Public Property Get Year() As Long
    Year = lPYear
End Property

Public Property Let Year(ByVal lYear As Long)
    If lYear = 0 Then
        Value = Empty
    Else
        Value = VBA.DateSerial(CheckYear(lYear), VBA.Month(dValue), VBA.Day(dValue))
    End If
    lPYear = lYear
End Property

Public Property Get Day() As Long
    Day = lPDay
End Property

Public Property Let Day(ByVal lDay As Long)
    If lDay = 0 Then
        Value = Empty
    Else
        If lDay < 0 Then lDay = lPDay
        lDay = fMin(lDay, VBA.Day(VBA.DateSerial(VBA.Year(dValue), VBA.Month(dValue) + 1, 0)))
        Value = VBA.DateSerial(VBA.Year(dValue), VBA.Month(dValue), lDay)
    End If
    lPDay = lDay
End Property

Public Property Get Value() As Variant
    If bPValueIsNull Or Not bPValueSelectable Then
        Value = Empty
    Else
        Value = dValue
    End If
End Property

Public Property Let Value(ByVal newDate As Variant)
    Dim Cancel As Integer '*** Integer for backward compatibility
    
    If CheckValue(newDate) = False Then newDate = Empty

    RaiseEvent BeforeUpdate(Cancel) '(Even if unselectable - for navigation.)
    
    If Cancel = 0 Then 'Not canceled.

        If bInit And Not IsEmpty(newDate) Then
            CBxY.ListIndex = VBA.Year(newDate) - 1904
            CBxM.ListIndex = VBA.Month(newDate) - 1
        End If
        
        If (bPValueIsNull = IsEmpty(newDate)) Or (newDate <> dValue) Then
            If Not IsEmpty(newDate) Then
                dValue = newDate
            End If
            bPValueIsNull = IsEmpty(newDate)
            
            Call Refresh
        End If
        
        RaiseEvent AfterUpdate '(Even if unselectable - for navigation.)
    End If
End Property

Public Property Get ValueSelectable() As Boolean
    ValueSelectable = bPValueSelectable
End Property

Public Property Get DayLength() As calMonthLength
    DayLength = lPDayLength
End Property

Public Property Let DayLength(ByVal bDayLength As calMonthLength)
    lPDayLength = bDayLength
    If bInit Then
        Call ApplyWeekDayLabelChanges
    End If
End Property

Public Property Get MonthLength() As calMonthLength
    MonthLength = lPMonthLength
End Property

Public Property Let MonthLength(ByVal iMonthLength As calMonthLength)
    lPMonthLength = iMonthLength

    If bInit Then
        CBxM.List = fMonthName(CLng(iMonthLength))
        Value = Value
    End If
End Property

Public Property Get YearFirst() As Boolean
    YearFirst = bPYearFirst
End Property

Public Property Let YearFirst(ByVal bYearFirst As Boolean)
    bPYearFirst = bYearFirst
    Call RenderLabel
End Property


Public Property Get MACFix() As Boolean
    MACFix = bPMACFix
End Property

' MAC Fix
'There is no Transparent buttons in Office in MAC.
'Update: Office 2106 in Windows banned the transparent buttons too.
'
'Normal buttons isn't resizable under a certain size - the text leaning out on the bottom.
'We use labes and transparent buttons for make little size buttons.
'
'This feaure turns off the labels.
Public Property Let MACFix(ByVal bMACFix As Boolean)
    Dim i As Long
    
    bPMACFix = bMACFix
    If bInit Then
        For i = 0 To 41
            mDayButtons(i).Obj_CmBl.Visible = Not bPMACFix
            mDayButtons(i).Obj_CmBlNum.Visible = Not bPMACFix
            mDayButtons(i).Obj_Cmb.Visible = True 'ZOrder
        Next
    End If
    Call Refresh
End Property


Public Property Get RightToLeft() As Boolean
    RightToLeft = bPRightToLeft
End Property

Public Property Let RightToLeft(ByVal bRightToLeft As Boolean)
    bPRightToLeft = bRightToLeft
    If bInit Then
        Call ApplyWeekDayLabelChanges
        Call Refresh
    End If
End Property


'###########################
'# Properties for Day button objects

Public Property Set Main(ByVal theMain As cCalendar)
    Set mcMain = theMain
End Property

Private Property Get Main() As cCalendar
    Set Main = mcMain
End Property

Public Property Get Obj_Cmb() As MSForms.CommandButton
    Set Obj_Cmb = CmB
End Property

Public Property Set Obj_Cmb(ByVal vNewValue As MSForms.CommandButton)
    Set CmB = vNewValue
End Property

Public Property Get Obj_CmBl() As MSForms.Label
    Set Obj_CmBl = CmBl
End Property

Public Property Set Obj_CmBl(ByVal vNewValue As MSForms.Label)
    Set CmBl = vNewValue
End Property

Public Property Set Obj_CmBlNum(ByVal vNewValue As MSForms.Label)
    Set CmBlNum = vNewValue
End Property

Public Property Get Obj_CmBlNum() As MSForms.Label
    Set Obj_CmBlNum = CmBlNum
End Property

Property Let Obj_ValueSelectionEnabled(bSelectable As Boolean)
    If Not mcMain Is Nothing Then
        bPValueSelectable = bSelectable
    End If
End Property

Property Get Obj_ValueSelectionEnabled() As Boolean
    If Not mcMain Is Nothing Then
        Obj_ValueSelectionEnabled = bPValueSelectable
    End If
End Property

'###########################
'# Public Methods

Public Sub AboutBox()
    MsgBox "Calendar Control Class" & vbLf & vbLf & "Autors:" & vbLf & " - r - Original Concept and Base Version" & vbLf & " - Kris - Spirit" & vbLf & " - Gabor - VBA Wizardry and New Features" & vbLf & vbLf & "The FrankensTeam"
End Sub

Public Sub Add(ByVal fForm As MSForms.UserForm)

    Dim cFrame As MSForms.Frame
    Set cFrame = fForm.Controls.Add("Forms.Frame.1")
    
    With cFrame
        .Width = IIf(sPWidth < 0, cDefaultWidth, sPWidth)
        .Height = IIf(sPHeight < 0, cDefaultHeight, sPHeight)
    End With
    
    Call Add_Calendar_into_Frame(cFrame)
    
End Sub

Public Sub Add_Calendar_into_Frame(ByVal cFrame As MSForms.Frame)
    Dim i As Long
    Dim v(199) As Variant
    Dim w As Variant
    Dim dTemp As Date
    
    For i = 0 To 199
        v(i) = CStr(1904 + i)
    Next
    
    With cFrame
        .BackColor = BackColor
        .Caption = ""
        .SpecialEffect = 0
        '.Top = IIf(sPTop = -1, .Top, sPTop)
        '.Left = IIf(sPLeft = -1, .Left, sPLeft)
        '.Width = IIf(sPWidth < 0, .Width, sPWidth)
        '.Height = IIf(sPHeight < 0, .Height, sPHeight)
        .Visible = bPVisible
        'Top = .Top
        'Left = .Left
        'Width = .Width
        'Height = .Height
    End With
    
    
    'Add this first, for proper taborder (Need TabStop.)
    Set CLb = cFrame.Controls.Add("Forms.Label.1")
    Set CBxY = cFrame.Controls.Add("Forms.ComboBox.1")
    Set CBxM = cFrame.Controls.Add("Forms.ComboBox.1")
    
    ReDim mLabelButtons(6)
    ReDim mDayButtons(41)
    w = fWeekdayName(CInt(lPDayLength))
    
    For i = 0 To 6
        Set mLabelButtons(i) = New cCalendar
        Set mLabelButtons(i).Main = Me
        Set mLabelButtons(i).Obj_CmBl = cFrame.Controls.Add("Forms.Label.1")
        With mLabelButtons(i).Obj_CmBl
            .Caption = w(((i + lPFirstDay - 1) Mod 7))
            .ForeColor = DayFontColor
            .TextAlign = fmTextAlignCenter
            .BorderStyle = fmBorderStyleSingle
            .BorderColor = &H80000010 'Button shadow  &H80000015 'Button dark shadow
            '.SpecialEffect = fmSpecialEffectEtched
            If HeaderBackColor = -1 Then
                .BackColor = cDayFontColorSelected 'Dark gray
                .BackStyle = fmBackStyleTransparent
            Else
                .BackColor = HeaderBackColor
                .BackStyle = fmBackStyleOpaque
            End If
        End With
    Next
            
    For i = 0 To 41
        Set mDayButtons(i) = New cCalendar
        Set mDayButtons(i).Main = Me
        
        Set mDayButtons(i).Obj_CmBl = cFrame.Controls.Add("Forms.Label.1")
        With mDayButtons(i).Obj_CmBl 'MAC Fix
            .TextAlign = fmTextAlignCenter
            .Visible = Not bPMACFix
        End With
        
        Set mDayButtons(i).Obj_CmBlNum = cFrame.Controls.Add("Forms.Label.1")
        With mDayButtons(i).Obj_CmBlNum
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            .Visible = Not bPMACFix
        End With
        
        Set mDayButtons(i).Obj_Cmb = cFrame.Controls.Add("Forms.CommandButton.1")
        With mDayButtons(i).Obj_Cmb
            .BackStyle = fmBackStyleTransparent 'MAC Problem: No button transparency
        End With
        
        mDayButtons(i).RightToLeft = bPRightToLeft
    Next
    
    With CBxY
        .ListRows = 5
        .List = v
        .ListIndex = VBA.Year(dValue) - 1904
        .ShowDropButtonWhen = fmShowDropButtonWhenFocus
        .font.Bold = True
        .MatchRequired = True
    End With

    With CBxM
        .ListRows = 12
        .List = fMonthName(lPMonthLength)
        .ListIndex = VBA.Month(dValue) - 1
        .ShowDropButtonWhen = fmShowDropButtonWhenFocus
        .font.Bold = True
        .MatchRequired = True
    End With
    
    With CLb
        .ForeColor = TitleFontColor
        .TextAlign = fmTextAlignCenter
        .BackStyle = fmBackStyleTransparent
    End With
    
    Call ApplyWeekDayLabelChanges
    
    Call ApplyFontChanges
    
    Call Refresh_Properities
    
    Call Move
    
End Sub

Private Sub ApplyWeekDayLabelChanges()
    Dim i As Long
    Dim w
    
    w = fWeekdayName(CInt(lPDayLength))
    For i = 0 To 6
        If bPRightToLeft Then
            mLabelButtons(6 - i).Obj_CmBl.Caption = w((i + lPFirstDay - 1) Mod 7)
        Else
            mLabelButtons(i).Obj_CmBl.Caption = w((i + lPFirstDay - 1) Mod 7)
        End If
    Next
End Sub

Private Sub ApplyFontChanges()
    Dim font As MSForms.NewFont
    Dim i As Long

    If Not PDayNewFont Is Nothing Then
        For i = 0 To 6
            Call ApplyFont(mLabelButtons(i).Obj_CmBl.font, DayFont)
        Next
    End If
            
    If Not PGridNewFont Is Nothing Then
        For i = 0 To 41
            If Not bPMACFix Then
                Set font = mDayButtons(i).Obj_CmBlNum.font
            Else
                Set font = mDayButtons(i).Obj_Cmb.font
            End If
            Call ApplyFont(font, GridFont)
        Next
    End If
    
    If Not PTitleNewFont Is Nothing Then
        Call ApplyFont(CLb.font, TitleFont)
    End If

End Sub

Private Sub ApplyFont(fTo As MSForms.NewFont, fFrom As MSForms.NewFont)

    If fTo.Bold <> fFrom.Bold Then _
        fTo.Bold = fFrom.Bold
    If fTo.Weight <> fFrom.Weight Then _
        fTo.Weight = fFrom.Weight
    If fTo.Charset <> fFrom.Charset Then _
        fTo.Charset = fFrom.Charset
    If fTo.Italic <> fFrom.Italic Then _
        fTo.Italic = fFrom.Italic
    If fTo.Name <> fFrom.Name Then _
        fTo.Name = fFrom.Name
    If fTo.Size <> fFrom.Size Then _
        fTo.Size = fFrom.Size
    If fTo.Strikethrough <> fFrom.Strikethrough Then _
        fTo.Strikethrough = fFrom.Strikethrough
    If fTo.Underline <> fFrom.Underline Then _
        fTo.Underline = fFrom.Underline

End Sub

Public Sub Move( _
        Optional vLeft, _
        Optional vTop, _
        Optional vWidth, _
        Optional vHeight, _
        Optional vLayout)
        
    Dim i As Long, l As Currency, b As Currency, lc As Currency, bc As Currency
    Dim t As Long, b_ym As Currency, b_combo_m As Currency
    
    Const h_combo As Long = 16
    Const b_combo_y As Long = 42
    b_combo_m = IIf(lPMonthLength = mlENShort Or lPMonthLength = mlLocalShort, 42, 66) '66
    b_ym = b_combo_y + 2 + b_combo_m
    
    If bInit Then
        t = IIf(ShowDays, 7, 6)
        
        With CBxY.Parent 'Frame
            sPTop = IIf(IsMissing(vTop), IIf(Top = -1, .Top, Top), vTop)
            sPLeft = IIf(IsMissing(vLeft), IIf(Left = -1, .Left, Left), vLeft)
            sPHeight = IIf(IsMissing(vHeight), IIf(Height = -1, .Height, Height), vHeight)
            sPWidth = IIf(IsMissing(vWidth), IIf(Width = -1, .Width, Width), vWidth)
            
            l = Height
            b = Width
            l = Zero_Negative_Value(l - IIf(ShowTitle Or ShowDateSelectors, h_combo, 0) - 1)
            lc = CCur(l / t)
            bc = CCur(b / 7)
            b = bc * 7
        End With
        
        If ShowTitle Then
            With CLb
                .Width = Zero_Negative_Value(IIf(ShowDateSelectors, b - b_ym, b))
                .Height = h_combo
                .Left = 0
            End With
        End If
        
        If ShowDateSelectors Then
            With CBxY
                .Width = b_combo_y
                .Height = h_combo
                .Left = IIf(ShowTitle, CLb.Width, Int((b - b_ym) / 2)) + _
                       IIf(YearFirst, 0, b_combo_m + 2)
            End With
        
            With CBxM
                .Width = b_combo_m
                .Height = h_combo
                .Left = IIf(ShowTitle, CLb.Width, Int((b - b_ym) / 2)) + _
                       IIf(YearFirst, b_combo_y + 2, 0)
            End With
        End If
        If ShowDays Then
            For i = 0 To 6
                With mLabelButtons(i).Obj_CmBl
                    .Top = IIf(ShowTitle Or ShowDateSelectors, h_combo + 2, 0)
                    .Left = (i Mod 7) * bc - IIf(i > 0, 1, 0)
                    .Height = lc
                    .Width = bc + IIf(i > 0, 1, 0)
                End With
            Next
        End If
        For i = 0 To 41
            With mDayButtons(i).Obj_Cmb
                .Top = Int(i / 7) * lc + _
                       IIf(ShowTitle Or ShowDateSelectors, h_combo + 2, 0) + _
                       IIf(ShowDays, lc, 0)
                .Left = (i Mod 7) * bc
                .Height = lc
                .Width = bc
            End With
            With mDayButtons(i).Obj_CmBl
                .Top = mDayButtons(i).Obj_Cmb.Top
                .Left = mDayButtons(i).Obj_Cmb.Left
                .Height = mDayButtons(i).Obj_Cmb.Height
                .Width = mDayButtons(i).Obj_Cmb.Width
            End With
            
            With mDayButtons(i).Obj_CmBlNum
                .Top = Int(i / 7) * lc + _
                       IIf(ShowTitle Or ShowDateSelectors, h_combo, 0) + _
                       IIf(ShowDays, lc, 0) + 6
                .Left = (i Mod 7) * bc + 3
                .Height = Zero_Negative_Value(lc - 6)
                .Width = Zero_Negative_Value(bc - 6)
            End With

        Next
        
    Else
        sPHeight = IIf(IsMissing(Height), cDefaultHeight, Height)
        sPWidth = IIf(IsMissing(Width), cDefaultWidth, Width)
    End If
End Sub

Public Sub NextDay()
    Dim d As Date
    d = dValue + 1
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub NextWeek()
    Dim d As Date
    d = dValue + 7
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub NextMonth()
    Value = SumMonthsToDate(dValue, 1)
End Sub

Public Sub NextYear()
    Dim d As Date
    d = VBA.DateSerial(CheckYear(VBA.Year(dValue) + 1), VBA.Month(dValue), VBA.Day(dValue))
    Value = d
End Sub

Public Sub PreviousDay()
    Dim d As Date
    d = dValue - 1
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub PreviousWeek()
    Dim d As Date
    d = dValue - 7
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub PreviousMonth()
    Value = SumMonthsToDate(dValue, -1)
End Sub

Public Sub PreviousYear()
    Dim d As Date
    d = VBA.DateSerial(CheckYear(VBA.Year(dValue) - 1), VBA.Month(dValue), VBA.Day(dValue))
    Value = d
End Sub

Public Sub Today()
    Value = VBA.Date
End Sub

Public Sub Refresh()
    If bInit Then
        Call Refresh_Panel(VBA.Month(dValue), VBA.Year(dValue))
        Call ApplyFontChanges
    End If
End Sub


'###########################
'# Events for Main Object Components
'###########################

Private Sub CBxY_Change()
    RenderLabel
    Refresh_Panel CBxM.ListIndex + 1, CBxY.ListIndex + 1904
End Sub

Private Sub CBxM_Change()
    RenderLabel
    Refresh_Panel CBxM.ListIndex + 1, CBxY.ListIndex + 1904
End Sub

Private Sub CmB_Click()
    Main.Obj_ValueSelectionEnabled = bPValueSelectable
    Main.Value = dValue
    If bPValueSelectable Then
        Call Main.Event_click
    End If
End Sub

Private Sub CmB_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call Main.Event_DblClick
End Sub


Private Sub CmB_KeyDown( _
    ByVal KeyCode As MSForms.ReturnInteger, _
    ByVal Shift As Integer)
    
    Dim newDate As Date

    '38 Up
    '37 Left
    '39 Right
    '40 Down
    
    newDate = dValue
    
    Select Case KeyCode
    Case 37
        If bPRightToLeft Then
            newDate = newDate + 1
        Else
            newDate = newDate - 1
        End If
    Case 39
        If bPRightToLeft Then
            newDate = newDate - 1
        Else
            newDate = newDate + 1
        End If
    Case 38
        newDate = newDate - 7
    Case 40
        newDate = newDate + 7
    Case 9
    End Select
    
    If newDate <> dValue Then
        Main.Obj_ValueSelectionEnabled = bPValueSelectable
        Main.Value = newDate
        KeyCode = 0
    Else
        If bPValueSelectable Then
            Call Main.Event_KeyDown(KeyCode, Shift)
        End If
    End If
End Sub


Private Sub Class_Initialize()
    bPShowDays = True
    bPShowTitle = True
    bPShowDateSelectors = True
    dValue = VBA.Date
    lPMonth = VBA.Month(VBA.Date)
    lPYear = VBA.Year(VBA.Date)
    lPDay = VBA.Day(VBA.Date)
    lPFontSize = 8
    lPMonthLength = 1
    lPDayLength = 1
    bPYearFirst = False
    lPTitleFontColor = &HA00000
    lPGridFontColor = &HA00000
    lPDayFontColor = &H0&
    lPFirstDay = 1
    lPBackColor = &H8000000F
    lPHeaderBackColor = 10053171 '&HFFAA99
    lPUseDefaultBackColors = True
    lPSaturdayBackColor = &H80000002
    lPSundayBackColor = &HFFAA99 '&H80000002
    lPSelectedBackColor = &H80000011
    lPUnSelectableBackColor = &H4040C0
    bPVisible = True
    sPHeight = -1
    sPWidth = -1
    sPTop = -1
    sPLeft = -1
    sPControlTipText = ""
    bPRightToLeft = False
    bPSaturdaySelectable = True
    bPSundaySelectable = True
    bPWeekdaySelectable = True
    bPValueSelectable = True
    
    bPMACFix = False
    If Val(Application.VERSION) >= 16 Then '"16.0"
        bPMACFix = True 'Office 2016 compatibility :(
    End If
    
    Set TitleFont = New MSForms.NewFont
    With TitleFont
        .Name = "Arial"
        .Size = lPFontSize + 4
        .Bold = True
    End With
    
    Set DayFont = New MSForms.NewFont
    With DayFont
        .Name = "Arial"
        .Size = lPFontSize + 2
        .Bold = True
    End With
    
    Set GridFont = New MSForms.NewFont
    With GridFont
        .Name = "Arial"
        .Size = lPFontSize
    End With

End Sub

Private Sub Class_Terminate()
    Erase mDayButtons
    Erase mLabelButtons
    Set mcMain = Nothing
    Set PTitleNewFont = Nothing
    Set PDayNewFont = Nothing
    Set PGridNewFont = Nothing
    Set CBxY = Nothing
    Set CBxM = Nothing
    Set CmB = Nothing
    Set CLb = Nothing
    Set CmBl = Nothing
End Sub

'###########################
'# Private Function

Private Function ArraY_Days(ByVal lMonth As Long, ByVal lYear As Long)
    Dim v(0 To 41) As Date, i As Long, g As Long, l As Long, p As Long, t As Date
    
    i = VBA.DateTime.Weekday(VBA.DateSerial(lYear, lMonth, 1), 1 + lPFirstDay Mod 7) - 1
    
    If i = 0 Then i = 7
    
    g = VBA.Day(VBA.DateSerial(lYear, lMonth + 1, 0)) + i
    
    p = 1
    For l = i To 0 Step -1
        v(l) = VBA.DateSerial(lYear, lMonth, p)
        p = p - 1
    Next
    
    p = 0
    For l = i To g
        p = p + 1
        v(l) = VBA.DateSerial(lYear, lMonth, p)
    Next
    
    For l = g To 41
        v(l) = VBA.DateSerial(lYear, lMonth, p)
        p = p + 1
    Next
    
    If bPRightToLeft Then
        For l = 0 To 5
            For i = 0 To 2
                t = v(l * 7 + i)
                v(l * 7 + i) = v(l * 7 + (6 - i))
                v(l * 7 + (6 - i)) = t
            Next
        Next
    End If
    
    ArraY_Days = v
End Function

Private Sub RenderLabel()
    Dim b As Currency, b_ym As Currency, b_combo_m As Long
    
    Const b_combo_y As Long = 42
    b_combo_m = IIf(lPMonthLength = mlENShort Or lPMonthLength = mlLocalShort, 42, 66) '66
    b_ym = b_combo_y + 2 + b_combo_m
    
    If bInit Then
        b = CBxY.Parent.Width
        If bPYearFirst Then
            CLb.Caption = CBxY.Value & " " & CBxM.Value
        Else
            CLb.Caption = CBxM.Value & " " & CBxY.Value
        End If
        CLb.Width = Zero_Negative_Value(IIf(ShowDateSelectors, b - b_ym, b))
        CBxM.Width = b_combo_m
        CBxY.Left = IIf(ShowTitle, CLb.Width, CCur((b - b_ym) / 2)) + _
                       IIf(YearFirst, 0, b_combo_m + 2)
        CBxM.Left = IIf(ShowTitle, CLb.Width, CCur((b - b_ym) / 2)) + _
                       IIf(YearFirst, b_combo_y + 2, 0)
        'CBxY.Left = IIf(ShowTitle, CLb.Width, IIf(CLb.Width, Int(CLb.Width / 2), 0)) + _
        '           IIf(YearFirst, 0, b_combo_m + 2)
        '
        'CBxM.Left = IIf(ShowTitle, CLb.Width, IIf(CLb.Width, Int(CLb.Width / 2), 0)) + _
        '           IIf(YearFirst, b_combo_y + 2, 0)
    End If
End Sub

Private Function bInit() As Boolean
    bInit = (Not CBxY Is Nothing)
End Function


Private Function SumMonthsToDate(dDate As Date, Optional lMonth As Long = 1) As Date
    Dim d As Date
    
    d = VBA.DateSerial( _
            VBA.Year(dDate), _
            VBA.Month(dDate) + lMonth, _
            fMin( _
                VBA.Day(dDate), _
                VBA.Day( _
                    VBA.DateSerial( _
                    VBA.Year(dDate), _
                    VBA.Month(dDate) + 1 + VBA.Abs(lMonth), _
                    0))))
                    
    If d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d)) Then
        SumMonthsToDate = d
    Else
        SumMonthsToDate = dDate
    End If
End Function

Private Function fMin(vFirstValue, ParamArray vValues())
    Dim i As Long
    fMin = vFirstValue
    
    If IsMissing(vValues) = False Then
    For i = 0 To UBound(vValues)
        If fMin > vValues(i) Then
            fMin = vValues(i)
        End If
    Next
    End If
End Function

Private Function fMonthName(lIndex As Long)
    Dim m(11), i As Long, v As Variant
    lIndex = lIndex Mod 4
    If Int(lIndex / 2) Then
        If lIndex Mod 2 Then
            v = Array("Jan", "Feb", "Mar", "Apr", "May", _
                "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
        Else
            v = Array("January", "February", "March", _
                "April", "May", "June", "July", "August", _
                "September", "October", "November", "December")
        End If
        fMonthName = v
    Else
        For i = 0 To 11
            m(i) = VBA.Strings.MonthName(i + 1, lIndex Mod 2)
        Next
        fMonthName = m
    End If
End Function


Private Function fWeekdayName(lIndex As Long)
    Dim m(6), i As Long, v As Variant
    lIndex = lIndex Mod 4
    If Int(lIndex / 2) Then
        If lIndex Mod 2 Then
            v = Array("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
        Else
            v = Array("Monday", "Tuesday", "Wednesday", _
                "Thursday", "Friday", "Saturday", "Sunday")
        End If
        fWeekdayName = v
    Else
        For i = 0 To 6
            m(i) = VBA.Strings.WeekdayName(i + 1, lIndex Mod 2, vbMonday)
        Next
        fWeekdayName = m
    End If
End Function


Private Function CheckYear(ByVal lYear As Long) As Long
    Select Case lYear
    Case Is < 1904
        CheckYear = 1904
    Case 1904 To 2103
        CheckYear = lYear
    Case Else
        CheckYear = 2103
    End Select
End Function

'###########################
'# Private Sub

Public Sub Event_DblClick()
    RaiseEvent DblClick
End Sub

Public Sub Event_click()
    RaiseEvent Click
End Sub

Public Sub Event_KeyDown( _
    ByVal KeyCode As MSForms.ReturnInteger, _
    ByVal Shift As Integer)
    
    RaiseEvent KeyDown(KeyCode, Shift)
End Sub

Private Sub Refresh_Properities()
    With Me
        .BackColor = .BackColor
        .ControlTipText = .ControlTipText
        .DayFontColor = .DayFontColor
        .DayLength = .DayLength
        .GridFontColor = .GridFontColor
        .MonthLength = .MonthLength
        If .UseDefaultBackColors = False Then
            .SaturdayBackColor = .SaturdayBackColor
            .SundayBackColor = .SundayBackColor
            .HeaderBackColor = .HeaderBackColor
        End If
        .ShowDateSelectors = .ShowDateSelectors
        .ShowDays = .ShowDays
        .ShowTitle = .ShowTitle
        .TabIndex = .TabIndex
        .TabStop = .TabStop
        .TitleFontColor = .TitleFontColor
        .ValueIsNull = .ValueIsNull
        .YearFirst = .YearFirst
    End With
End Sub

Private Sub Refresh_Selected_Day(ByVal dValue As Date, ByVal i As Long)
    Dim c As MSForms.Label
    Dim selColor As OLE_COLOR
    
    If Not bPValueIsNull Then
        bPValueSelectable = mDayButtons(i).Obj_ValueSelectionEnabled
        If bPValueSelectable Then
            selColor = lPSelectedBackColor
        Else
            selColor = lPUnSelectableBackColor
        End If
        On Error Resume Next
        mDayButtons(i).Obj_Cmb.SetFocus
        On Error GoTo 0
        If Not bPMACFix Then
            With mDayButtons(i).Obj_CmBl
                .BackStyle = fmBackStyleOpaque
                .BackColor = selColor
                .ForeColor = cDayFontColorSelected
            End With
        Else
            With mDayButtons(i).Obj_Cmb
                .BackStyle = fmBackStyleOpaque
                .BackColor = selColor
                .ForeColor = cDayFontColorSelected
            End With
        End If
        lPMonth = VBA.Month(dValue)
        lPYear = VBA.Year(dValue)
        lPDay = VBA.Day(dValue)
    End If

End Sub

Private Sub Refresh_Panel(ByVal lMonth As Long, ByVal lYear As Long)
    Dim v As Variant, i As Long, l As Long, idxSel As Variant
    Dim iDay As Long
    Dim lBackColor As OLE_COLOR
    Dim lBackColorA As Variant
    Dim colorArray42() As Variant
    Dim selArray42() As Variant
    Dim bHasColoredDateArray As Boolean
    Dim bSelectable As Boolean
    
    If Not bInit Then
        Exit Sub
    End If
    
    bHasColoredDateArray = HasColoredDateArray()
    
    v = ArraY_Days(lMonth, lYear)
    
    If bHasColoredDateArray Then
        ReDim colorArray42(0 To 41)
        ReDim selArray42(0 To 41)
        
        Call BuildDateColorArrays(colorArray42, selArray42, v(0), v(41))
    End If
    
    idxSel = Empty
    For i = 0 To 41
        mDayButtons(i).Value = v(i)
        If v(i) = dValue Then
            idxSel = i
        End If
        If Not bPMACFix Then 'MAC: no label - command button text
            '# Normal mode
            ' Text day label
            With mDayButtons(i).Obj_CmBlNum
                If .Caption <> VBA.Day(v(i)) Then
                    .Caption = VBA.Day(v(i))
                End If
                If lMonth = VBA.Month(v(i)) Then
                    If .ForeColor <> GridFontColor Then
                        .ForeColor = GridFontColor
                    End If
                Else
                    If .ForeColor <> cDayFontColorInactive Then
                        .ForeColor = cDayFontColorInactive
                    End If
                End If
            End With
            ' Day background label
            With mDayButtons(i).Obj_CmBl
                iDay = VBA.DateTime.Weekday(v(i))
                If .BackStyle = fmBackStyleOpaque Then
                    .BackStyle = fmBackStyleTransparent
                End If
                lBackColor = lPBackColor
                If UseDefaultBackColors = False Then
                    If iDay = vbSaturday Then
                        lBackColor = lPSaturdayBackColor
                        If .BackStyle <> fmBackStyleOpaque Then
                            .BackStyle = fmBackStyleOpaque
                        End If
                    ElseIf iDay = vbSunday Then
                        lBackColor = lPSundayBackColor
                        If .BackStyle <> fmBackStyleOpaque Then
                            .BackStyle = fmBackStyleOpaque
                        End If
                    End If
                    If bHasColoredDateArray Then
                        lBackColorA = colorArray42(i)
                        If Not IsEmpty(lBackColorA) Then
                            lBackColor = lBackColorA
                            If .BackStyle <> fmBackStyleOpaque Then
                                .BackStyle = fmBackStyleOpaque
                            End If
                        End If
                    End If
                End If
                If .BackColor <> lBackColor Then
                    .BackColor = lBackColor
                End If
            End With
            ' Button not altered
            With mDayButtons(i).Obj_Cmb
                If .Caption <> "" Then 'After MACFix
                    .Caption = ""
                End If
                If .BackStyle <> fmBackStyleTransparent Then 'Button visible
                    .BackStyle = fmBackStyleTransparent
                End If
            End With
        Else
            '# MAC Fix mode
            With mDayButtons(i).Obj_CmBlNum
                If .Caption <> "" Then
                    .Caption = ""
                End If
            End With
            With mDayButtons(i).Obj_CmBl
                If .BackStyle = fmBackStyleOpaque Then
                    .BackStyle = fmBackStyleTransparent
                End If
            End With
            With mDayButtons(i).Obj_Cmb
                If .Caption <> VBA.Day(v(i)) Then
                    .Caption = VBA.Day(v(i))
                End If
                If lMonth = VBA.Month(v(i)) Then
                    If .ForeColor <> GridFontColor Then
                        .ForeColor = GridFontColor
                    End If
                Else
                    If .ForeColor <> cDayFontColorInactive Then
                        .ForeColor = cDayFontColorInactive
                    End If
                End If
                If .BackStyle <> fmBackStyleOpaque Then 'Button visible
                    .BackStyle = fmBackStyleOpaque
                End If
                lBackColor = lPBackColor
                If UseDefaultBackColors = False Then
                    iDay = VBA.DateTime.Weekday(v(i))
                    If iDay = vbSaturday Then
                        lBackColor = lPSaturdayBackColor
                    ElseIf iDay = vbSunday Then
                        lBackColor = lPSundayBackColor
                    End If
                    If bHasColoredDateArray Then
                        lBackColorA = colorArray42(i)
                        If Not IsEmpty(lBackColorA) Then
                            lBackColor = lBackColorA
                        End If
                    End If
                End If
                If .BackColor <> lBackColor Then
                    .BackColor = lBackColor
                End If
            End With
        End If
        
        If Not SaturdaySelectable And iDay = vbSaturday Then
            bSelectable = False
        ElseIf Not SundaySelectable And iDay = vbSunday Then
            bSelectable = False
        ElseIf Not WeekdaySelectable And iDay <> vbSaturday And iDay <> vbSunday Then
            bSelectable = False
        Else
            bSelectable = True
        End If
        If bHasColoredDateArray Then
            If Not IsEmpty(selArray42(i)) Then
                bSelectable = selArray42(i)
            End If
        End If
        mDayButtons(i).Obj_ValueSelectionEnabled = bSelectable
        
        If CheckValue(v(i)) = False Then
            mDayButtons(i).Obj_Cmb.Locked = True
        Else
            If mDayButtons(i).Obj_Cmb.Locked = True Then
                mDayButtons(i).Obj_Cmb.Locked = False
            End If
        End If
    Next
    
    If UseDefaultBackColors = False Then
        For l = 0 To 6
            If mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleTransparent Then
                mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleOpaque
            End If
            If mLabelButtons(l).Obj_CmBl.BackColor <> lPHeaderBackColor Then
                mLabelButtons(l).Obj_CmBl.BackColor = lPHeaderBackColor
            End If
        Next
    Else
        For l = 0 To 6
            If mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleOpaque Then
               mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleTransparent
            End If
        Next
    End If
    
    If lMonth = VBA.Month(dValue) And lYear = VBA.Year(dValue) Then
        Call Refresh_Selected_Day(dValue, idxSel)
    Else
        lPMonth = 0
        lPYear = 0
        lPDay = 0
    End If
End Sub

Private Function CheckValue(d) As Boolean
    If VarType(d) = vbDate Then
        Select Case d
            Case 1462 To 74510
                CheckValue = CLng(d) = d
        End Select
    End If
End Function

Private Function Zero_Negative_Value(sNumber As Single) As Single
    If sNumber > 0 Then
        Zero_Negative_Value = sNumber
    End If
End Function

'##########################################################
'# Coloring Date Arrays

Public Function HasColoredDateArray() As Boolean
    HasColoredDateArray = Not IsEmpty(maColoredArrayTable)
End Function

Public Function AddColoredDateArray(color As OLE_COLOR, dates As Variant, Optional Selectable As Variant = Empty, Optional index As Long = -1) As Long
    Dim r As Object 'Excel.Range
    Dim dateList() As Variant
    Dim aColoredArrayTable() As Variant
    Dim aColoredArrayRec() As Variant
    Dim newIndex As Long
    Dim lUBnd As Long
    Dim dat As Variant
    Dim format As Integer '1 - 1 dimension, 2 - 1/2 dimension, 3 - 2/2 dimension
    
    If TypeName(dates) = "Variant()" Then
        dateList = dates
    ElseIf TypeName(dates) = "Range" Then
        Set r = dates
        dateList = r.Value2
    Else
        Err.Raise 20001, "Invalid input type for dates: " & TypeName(dates) & " (Valid: Range, Variant())"
    End If
    
    If Not IsEmpty(Selectable) Then
        Selectable = CBool(Selectable)
    End If

    newIndex = index
    If IsEmpty(maColoredArrayTable) Then
        If newIndex = -1 Then
            newIndex = 1
        End If
        ReDim aColoredArrayTable(1 To newIndex)
    Else
        aColoredArrayTable = maColoredArrayTable
        If newIndex = -1 Then
            newIndex = UBound(aColoredArrayTable) + 1
        End If
        If newIndex > UBound(aColoredArrayTable) Then
            ReDim Preserve aColoredArrayTable(1 To newIndex)
        End If
    End If
    
    format = 1
    On Error Resume Next
    lUBnd = UBound(dateList)
    dat = dateList(lUBnd)
    If Err.Number > 0 Then
        Err.clear
        lUBnd = UBound(dateList, 1)
        dat = dateList(lUBnd, 1)
        If Err.Number > 0 Then
            Err.Raise 20001, "Invalid date array input: " & Err.Description
        End If
        
        format = 2
        If lUBnd < UBound(dateList, 2) Then
            format = 3
        End If
    End If
    On Error GoTo 0
    
    ReDim aColoredArrayRec(1 To 4)
    aColoredArrayRec(ccColor) = color
    aColoredArrayRec(ccFormat) = format
    aColoredArrayRec(ccDateList) = dateList
    aColoredArrayRec(ccSelectable) = Selectable
    
    aColoredArrayTable(newIndex) = aColoredArrayRec
    
    maColoredArrayTable = aColoredArrayTable
    
    Call Refresh
    
    AddColoredDateArray = newIndex
End Function

Public Sub RemoveColoredDateArray(index As Long)
    Dim aColoredArrayTable() As Variant
    Dim i As Long
    Dim bWas As Boolean
    If HasColoredDateArray() Then
        aColoredArrayTable = maColoredArrayTable
        If 1 <= index And index <= UBound(aColoredArrayTable) Then
            aColoredArrayTable(index) = Empty
            bWas = False
            For i = 1 To UBound(aColoredArrayTable)
                If Not IsEmpty(aColoredArrayTable(i)) Then
                   bWas = True
                   Exit For
                End If
            Next
            If bWas Then
                maColoredArrayTable = aColoredArrayTable
            Else
                maColoredArrayTable = Empty
            End If
        End If
    End If
End Sub

Public Sub ClearAllColoredDateArrays()
    maColoredArrayTable = Empty
End Sub


Public Function IsColoredArrayExists(index As Long) As Boolean
    Dim aColoredArrayRec() As Variant
    Call GetColoredArrayRec(index, aColoredArrayRec)
    IsColoredArrayExists = Not IsEmpty(aColoredArrayRec)
End Function

Public Function GetArrayColor(index As Long) As Variant
    Dim aColoredArrayRec() As Variant
    Call GetColoredArrayRec(index, aColoredArrayRec)
    If Not IsEmpty(aColoredArrayRec) Then
        GetArrayColor = aColoredArrayRec(ccColor)
        Exit Function
    End If
    GetArrayColor = Empty
End Function

Public Sub SetArrayColor(index As Long, color As OLE_COLOR)
    Dim aColoredArrayRec() As Variant
    Call GetColoredArrayRec(index, aColoredArrayRec)
    If Not IsEmpty(aColoredArrayRec) Then
        aColoredArrayRec(ccColor) = color
        Call SetColoredArrayRec(index, aColoredArrayRec)
    End If
End Sub

Public Function GetArraySelectable(index As Long) As Variant
    Dim aColoredArrayRec() As Variant
    Call GetColoredArrayRec(index, aColoredArrayRec)
    If Not IsEmpty(aColoredArrayRec) Then
        GetArraySelectable = aColoredArrayRec(ccSelectable)
        Exit Function
    End If
    GetArraySelectable = Empty
End Function

Public Sub SetArraySelectable(index As Long, Selectable As Variant)
    Dim aColoredArrayRec() As Variant
    If Not IsEmpty(Selectable) Then
        Selectable = CBool(Selectable)
    End If
    Call GetColoredArrayRec(index, aColoredArrayRec)
    If Not IsEmpty(aColoredArrayRec) Then
        aColoredArrayRec(ccSelectable) = Selectable
        Call SetColoredArrayRec(index, aColoredArrayRec)
    End If
End Sub

Private Sub GetColoredArrayRec(index As Long, ByRef aColoredArrayRec() As Variant)
    Dim aColoredArrayTable() As Variant
    If HasColoredDateArray() Then
        aColoredArrayTable = maColoredArrayTable
        If 1 <= index And index <= UBound(aColoredArrayTable) Then
            If Not IsEmpty(aColoredArrayTable(index)) Then
                aColoredArrayRec = aColoredArrayTable(index)
                Exit Sub
            End If
        End If
    End If
    aColoredArrayRec = Empty
End Sub

Private Sub SetColoredArrayRec(index As Long, ByRef aColoredArrayRec() As Variant)
    Dim aColoredArrayTable() As Variant
    If HasColoredDateArray() Then
        aColoredArrayTable = maColoredArrayTable
        If 1 <= index And index <= UBound(aColoredArrayTable) Then
            aColoredArrayTable(index) = aColoredArrayRec
            maColoredArrayTable = aColoredArrayTable
        End If
    End If
End Sub


Private Sub BuildDateColorArrays(ByRef colorArray42() As Variant, ByRef selArray42() As Variant, ByVal fromDate As Date, ByVal toDate As Date)
    Dim aColoredArrayTable() As Variant
    Dim aColoredArrayRec() As Variant
    Dim iDate As Date
    Dim format As Integer '1 - 1 dimension, 2 - 2 dimension/1, 2 - 2 dimension/2
    Dim dateList() As Variant
    Dim i As Long
    Dim j As Long
    Dim idx As Integer

    If Not HasColoredDateArray() Then
        Exit Sub
    End If
    
    aColoredArrayTable = maColoredArrayTable
    
    For i = 1 To UBound(aColoredArrayTable)
        aColoredArrayRec = aColoredArrayTable(i)
        
        format = aColoredArrayRec(ccFormat)
        dateList = aColoredArrayRec(ccDateList)
        
        Select Case format
        Case 1
            For j = LBound(dateList) To UBound(dateList)
                iDate = dateList(j)
                If fromDate <= iDate And iDate <= toDate Then
                    idx = iDate - fromDate
                    colorArray42(idx) = aColoredArrayRec(ccColor)
                    selArray42(idx) = aColoredArrayRec(ccSelectable)
                End If
            Next
        Case 2
            For j = LBound(dateList, 1) To UBound(dateList, 1)
                iDate = dateList(j, 1)
                If fromDate <= iDate And iDate <= toDate Then
                    idx = iDate - fromDate
                    colorArray42(idx) = aColoredArrayRec(ccColor)
                    selArray42(idx) = aColoredArrayRec(ccSelectable)
                End If
            Next
        Case 3
            For j = LBound(dateList, 2) To UBound(dateList, 2)
                iDate = dateList(1, j)
                If fromDate <= iDate And iDate <= toDate Then
                    idx = iDate - fromDate
                    colorArray42(idx) = aColoredArrayRec(ccColor)
                    selArray42(idx) = aColoredArrayRec(ccSelectable)
                End If
            Next
        End Select
    Next

End Sub

Attribute VB_Name = "clsAccount"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'//Daten
Private sIBAN As String
Private sSwift As String
Private sId As String
Private sInhaber As String

Private bd As clsBankData

'//Konstruktor/Dekonstruktor
Private Sub Class_Initialize()
    Set bd = New clsBankData
End Sub

Private Sub Class_Terminate()
    Set bd = Nothing
End Sub

'//Eigenschaften
Public Property Get IBAN() As Variant
    IBAN = sIBAN
End Property

Public Property Let IBAN(ByVal vNewValue As Variant)
    If bd.isValidIBAN(vNewValue) Then
        sIBAN = vNewValue
    Else
        Err.Raise 1, "clAccount", "Die IBAN ist ung|fffd|ltig"
    End If
End Property

Public Property Get SWIFT() As Variant
    SWIFT = sSwift
End Property

Public Property Let SWIFT(ByVal vNewValue As Variant)
    If vNewValue = vbNullString Or bd.isValidBIC(vNewValue) Then
        sSwift = vNewValue
    Else
        Err.Raise 2, "clsAccount", "Der SWIFT-Code ist ung|fffd|ltig"
    End If
End Property

Public Property Get ID() As Variant
    ID = sId
End Property

Public Property Let ID(ByVal vNewValue As Variant)
    If vNewValue = vbNullString Or (Not vNewValue = vbNullString And Len(vNewValue) <= 35) Then
        sId = vNewValue
    Else
        Err.Raise 3, "clsAccount", "Die Gl|fffd|ubiger-ID ist ung|fffd|ltig"
    End If
End Property

Public Property Get Inhaber() As Variant
    Inhaber = sInhaber
End Property

Public Property Let Inhaber(ByVal vNewValue As Variant)
    If vNewValue = vbNullString Then
        Err.Raise 4, "clsAccount", "Der Kontoinhaber darf nicht leer sein"
    Else
        sInhaber = vNewValue
    End If
End Property
Attribute VB_Name = "clsAccountFactory"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const XMLNS As String = "https://jansesoft.de/Excel2SepaXML"

Private xDoc As MSXML2.DOMDocument60
Private colAccounts As Collection
Private fso As FileSystemObject
Private sFile As String

Private Sub Class_Initialize()
    Set fso = New FileSystemObject
    Set colAccounts = New Collection
    Set xDoc = New MSXML2.DOMDocument60
    
    Dim sFolder As String
    
    sFolder = Environ("AppData") & "\Excel2SepaXML"
    sFile = sFolder & "\accounts.xml"
        
    If Not fso.FolderExists(sFolder) Then
        fso.CreateFolder sFolder
    End If
    
    If Not fso.FileExists(sFile) Then
        Exit Sub
    End If
    
    Dim xListAccounts As IXMLDOMNodeList
    Dim xNodeAccount As IXMLDOMNode
    Dim cAccount As clsAccount
    
    If xDoc.Load(sFile) Then
        Set xListAccounts = xDoc.DocumentElement.FirstChild.ChildNodes
        
        For Each xNodeAccount In xListAccounts
            Set cAccount = transform_node_to_Acc(xNodeAccount)
            colAccounts.Add cAccount
        Next xNodeAccount
    Else
        MsgBox xDoc.parseError.reason, vbExclamation
    End If
    
    Set xDoc = Nothing
End Sub

Private Sub Class_Terminate()
    Set fso = Nothing
    Set colAccounts = Nothing
    Set xDoc = Nothing
End Sub

Public Sub add_Account(ByRef cAccount As clsAccount)
    Dim cAcc As clsAccount
    
    For Each cAcc In colAccounts
        If cAcc.IBAN = cAccount.IBAN Then
            Err.Raise 1, "clsAccountFactory", "Diese IBAN existiert bereits."
            Exit Sub
        End If
    Next cAcc
    
    colAccounts.Add cAccount
End Sub

Public Sub clear_Accountlist()
    Set colAccounts = New Collection
End Sub

Public Sub delete_Account(ByVal sIBAN As String)
    Dim cAccount As clsAccount
    Dim l As Long: l = 1
    
    For Each cAccount In colAccounts
        If cAccount.IBAN = sIBAN Then
            colAccounts.Remove l
            Exit Sub
        End If
        l = l + 1
    Next cAccount
End Sub

Public Function get_Accounts() As Collection
    Set get_Accounts = colAccounts
End Function

Public Function get_single_account(ByVal sIBAN As String) As clsAccount
    Dim cAccount As clsAccount
    
    For Each cAccount In colAccounts
        If cAccount.IBAN = sIBAN Then
            Set get_single_account = cAccount
            Exit Function
        End If
    Next cAccount
End Function


Public Sub save_Accounts()
    Set xDoc = New MSXML2.DOMDocument60
    
    Dim cAccount As clsAccount
    Dim xPI As MSXML2.IXMLDOMProcessingInstruction
    Dim xNodeRoot As MSXML2.IXMLDOMNode
    Dim xNodeAccounts As MSXML2.IXMLDOMNode
    
    Set xPI = xDoc.createProcessingInstruction("xml", "version=""1.0"" encoding=""UTF-8""")
    Call xDoc.InsertBefore(xPI, xDoc.ChildNodes(0))
    
    Set xNodeRoot = xDoc.createNode(NODE_ELEMENT, "Document", XMLNS)
    Call xDoc.appendChild(xNodeRoot)
    
    Set xNodeAccounts = xDoc.createNode(NODE_ELEMENT, "Accounts", XMLNS)
    Call xNodeRoot.appendChild(xNodeAccounts)
    
    For Each cAccount In colAccounts
        If Not cAccount.IBAN = vbNullString Then
            Call xNodeAccounts.appendChild(transform_acc_to_node(cAccount))
        End If
    Next cAccount
    
    xDoc.Save sFile
    
    Set xDoc = Nothing
    Set xNodeRoot = Nothing
    Set xPI = Nothing
End Sub

Private Function transform_acc_to_node(ByRef cAccount As clsAccount) As MSXML2.IXMLDOMNode
    Dim xNodeAccount As MSXML2.IXMLDOMNode
    Dim xNodeIban As MSXML2.IXMLDOMNode
    Dim xNodeSwift As MSXML2.IXMLDOMNode
    Dim xNodeId As MSXML2.IXMLDOMNode
    Dim xNodeInhaber As MSXML2.IXMLDOMNode
    
    Set xNodeAccount = xDoc.createNode(NODE_ELEMENT, "Account", XMLNS)
    Set xNodeIban = xDoc.createNode(NODE_ELEMENT, "IBAN", XMLNS)
    xNodeIban.Text = cAccount.IBAN
    Set xNodeSwift = xDoc.createNode(NODE_ELEMENT, "SWIFT", XMLNS)
    xNodeSwift.Text = cAccount.SWIFT
    Set xNodeId = xDoc.createNode(NODE_ELEMENT, "ID", XMLNS)
    xNodeId.Text = cAccount.ID
    Set xNodeInhaber = xDoc.createNode(NODE_ELEMENT, "Inhaber", XMLNS)
    xNodeInhaber.Text = cAccount.Inhaber
    
    With xNodeAccount
        Call .appendChild(xNodeIban)
        Call .appendChild(xNodeSwift)
        Call .appendChild(xNodeId)
        Call .appendChild(xNodeInhaber)
    End With
    
    Set transform_acc_to_node = xNodeAccount
End Function

Private Function transform_node_to_Acc(ByRef xNode As MSXML2.IXMLDOMNode) As clsAccount
    Dim cAccount As clsAccount
    Dim xListData As IXMLDOMNodeList
    Dim xNodeData As IXMLDOMNode
    
    Set xListData = xNode.ChildNodes
    Set cAccount = New clsAccount
    
    For Each xNodeData In xListData
        Select Case xNodeData.nodeName
            Case "IBAN"
                cAccount.IBAN = xNodeData.Text
            Case "SWIFT"
                cAccount.SWIFT = xNodeData.Text
            Case "ID"
                cAccount.ID = xNodeData.Text
            Case "Inhaber"
                cAccount.Inhaber = xNodeData.Text
        End Select
    Next xNodeData
    
    Set transform_node_to_Acc = cAccount
End Function
Attribute VB_Name = "clsBankData"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'//REGEX BIC
Private Const REGEXBICPATTERN As String = "[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}"
'//REGEX IBAN
Private Const REGEXIBANPATTERN As String = "[A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}"

Public Function isValidBIC(ByVal BIC As String) As Boolean
    Dim regEx As New RegExp
    regEx.IgnoreCase = True
    regEx.Pattern = REGEXBICPATTERN
    
    isValidBIC = regEx.test(BIC)
    Set regEx = Nothing
End Function

Public Function isValidIBAN(ByVal IBAN As String) As Boolean
    Dim IBANstr As String
    Dim i As Long
    
    IBANstr = Replace(IBAN, " ", "")
    
    Dim regEx As New RegExp
    With regEx
        .IgnoreCase = True
        .Pattern = REGEXIBANPATTERN
        If Not .test(IBAN) Then
            Set regEx = Nothing
            Exit Function
        End If
    End With
    
    Set regEx = Nothing
    
    IBANstr = Mid(IBANstr, 5) & Mid(IBANstr, 1, 4)
    
    For i = 65 To 90
        IBANstr = Replace(IBANstr, Chr(i), i - 64 + 9, , , vbTextCompare)
    Next
    
    isValidIBAN = ModuloBig(IBANstr, 97) = 1
End Function

Private Function ModuloBig(ZahlString As String, Divisor As Long) As Long
    Dim TeilStart As Long
    Dim TeilEnd As Long
    Dim Erg As Long
    Dim Rest As Long
    Dim ErgebnisGanzString As String
    Dim TeilZahl As Long
    
    TeilStart = 1
    TeilEnd = 1
    
    Do While TeilEnd <= Len(ZahlString)
        TeilZahl = Val(Rest & Mid(ZahlString, TeilStart, TeilEnd - TeilStart + 1))
    
        If TeilZahl >= Divisor Then
            Erg = Int(TeilZahl / Divisor)
            Rest = TeilZahl - Erg * Divisor
    
            ErgebnisGanzString = ErgebnisGanzString + CStr(Erg)
    
            TeilStart = TeilEnd + 1
            TeilEnd = TeilStart
        Else
            If ErgebnisGanzString <> "" Then
                ErgebnisGanzString = ErgebnisGanzString & "0"
            End If
            TeilEnd = TeilEnd + 1
        End If
    Loop
    
    If TeilStart <= Len(ZahlString) Then
        Rest = Val(Rest & Mid(ZahlString, TeilStart))
    End If
    
    ' ErgebnisGanzString enth|fffd|lt jetzt das "Ganzzahlige"
    ' Ergebnis ohne Rest, wird z.Z. aber nicht verwendet
    
    ModuloBig = Rest
End Function
Attribute VB_Name = "clsErrorLog"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim colErrorLog As Collection

Private Sub Class_Initialize()
    Set colErrorLog = New Collection
End Sub

Private Sub Class_Terminate()
    Set colErrorLog = Nothing
End Sub

Public Property Get Count() As Variant
    Count = colErrorLog.Count
End Property

Public Property Get get_Log() As Variant
    Dim l As Long
    Dim strAusgabe As String
    
    For l = 1 To colErrorLog.Count
        strAusgabe = strAusgabe & vbTab & colErrorLog.Item(l) & vbNewLine
    Next l
    
    get_Log = strAusgabe
End Property

Public Sub Add(ByVal ErrorSource As String, ByVal ErrorDescription As String)
    colErrorLog.Add (Now & vbTab & Environ("UserName") & vbTab & ErrorSource & vbTab & ErrorDescription)
End Sub
Attribute VB_Name = "clsSepaCCT"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'/Konstanten
'//GroupHeader
Private Const XMLNS As String = "urn:iso:std:iso:20022:tech:xsd:pain.001.001.03"
Private Const XMLNSXSI As String = "http://www.w3.org/2001/XMLSchema-instance"
Private Const XSISCHEMELOCATION As String = "urn:iso:std:iso:20022:tech:xsd:pain.001.001.03 pain.001.001.03.xsd"
'//PaymentInformation
'///PaymentMethod ("TRF" = Transfer)
Private Const PMTMTD As String = "TRF"
'///InstructedPriority ("HIGH", "NORM")
Private Const INSTRPRTY As String = "NORM"
'///ChargeBearer
Private Const CHRGBR As String = "SLEV"

'/Datum
Dim datStart As Date

'/XML Objekte
'//GroupHeader Doc, PI, Root und Initiation
Dim xmlDoc As MSXML2.DOMDocument60
Dim xmlPI As MSXML2.IXMLDOMProcessingInstruction
Dim xmlRoot As MSXML2.IXMLDOMNode
Dim xmlNodCstmrCdtTrfInitn As MSXML2.IXMLDOMNode

'//GroupHeader Elemente
Dim xmlNodGrpHdr As MSXML2.IXMLDOMNode
Dim xmlNodMsgId As MSXML2.IXMLDOMNode
Dim xmlNodCreDtTm As MSXML2.IXMLDOMNode
Dim xmlNodNbOfTxs As MSXML2.IXMLDOMNode
Dim xmlNodCtrlSum As MSXML2.IXMLDOMNode
Dim xmlNodInitgPty As MSXML2.IXMLDOMNode
Dim xmlNodInitgPtyNm As MSXML2.IXMLDOMNode

'//PaymentInformation Elemente
Dim xmlNodPmtInf As MSXML2.IXMLDOMNode
Dim xmlNodPmtInfId As MSXML2.IXMLDOMNode
Dim xmlNodPmtMtd As MSXML2.IXMLDOMNode
Dim xmlNodBtchBookg As MSXML2.IXMLDOMNode
Dim xmlNodPmtInfNbOfTxs As MSXML2.IXMLDOMNode
Dim xmlNodPmtInfCtrlSum As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInf As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfInstrPrty As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfSvcLvl As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfSvcLvlCd As MSXML2.IXMLDOMNode
Dim xmlNodReqdExctnDt As MSXML2.IXMLDOMNode
Dim xmlNodDbtr As MSXML2.IXMLDOMNode
Dim xmlNodDbtrNm As MSXML2.IXMLDOMNode
Dim xmlNodDbtrAcct As MSXML2.IXMLDOMNode
Dim xmlNodDbtrAcctId As MSXML2.IXMLDOMNode
Dim xmlNodDbtrAcctIdIBAN As MSXML2.IXMLDOMNode
Dim xmlNodDbtrAgt As MSXML2.IXMLDOMNode
Dim xmlNodDbtrAgtFinInstnId As MSXML2.IXMLDOMNode
Dim xmlNodUltmtDbtr As MSXML2.IXMLDOMNode
Dim xmlNodUltmtDbtrNm As MSXML2.IXMLDOMNode
Dim xmlNodChrgBr As MSXML2.IXMLDOMNode

'/Z|fffd|hler und Kontrollsumme
Dim intAnzahl As Integer, curSumme As Currency

'/Daten der SEPA-Datei
Dim strMsgId As String, strInitgPtyNm As String, strPmtInfId As String, strBtchBookg As String, strSvcLvl As String, strReqdExctnDt As String
Dim strDbtrNm As String, strDbtrAcctIBAN As String, strDbtrAgtBIC As String, strUltmtDbtrNm As String

'/Weitere Daten
Dim strPfad As String, readyState As Boolean

'/Eigenschaften
Public Property Let MessageID(ByVal vNewValue As String)
    If Len(vNewValue) > 35 Then
        MsgBox "Die Message ID darf maximal 35 Zeichen lang sein.", vbCritical
    Else
        strMsgId = Trim(vNewValue)
    End If
End Property

Public Property Let PaymentID(ByVal vNewValue As String)
    If Len(vNewValue) > 35 Then
        MsgBox "Die Payment ID darf maximal 35 Zeichen lang sein.", vbCritical
    Else
        strPmtInfId = Trim(vNewValue)
    End If
End Property

Public Property Let UrgendPayment(ByVal vNewValue As Boolean)
    If vNewValue Then
        strSvcLvl = "URGP"
    Else
        strSvcLvl = "SEPA"
    End If
End Property

Public Property Let BatchBooking(ByVal vNewValue As Boolean)
    If vNewValue Then
        strBtchBookg = "true"
    Else
        strBtchBookg = "false"
    End If
End Property

Public Property Let ExecutionDate(ByVal vNewValue As Date)
    strReqdExctnDt = format(vNewValue, "yyyy-mm-dd")
End Property

Public Property Let DebtorName(ByVal vNewValue As String)
    strInitgPtyNm = vNewValue
    strDbtrNm = vNewValue
End Property

Public Property Let DebtorIBAN(ByVal vNewValue As String)
    If Not vNewValue = vbNullString Then
        Dim bank As New clsBankData
        If bank.isValidIBAN(vNewValue) Then
            strDbtrAcctIBAN = vNewValue
        End If
    End If
    
    Set bank = Nothing
End Property

Public Property Let DebtorAgentBIC(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Exit Property
    End If
    
    Dim bank As New clsBankData
    
    If bank.isValidBIC(vNewValue) Then
        strDbtrAgtBIC = UCase(vNewValue)
    Else
        MsgBox "Die BIC kann nicht hinzugef|fffd|gt werden, da der BIC-Code nicht dem allgemeinen Muster entspricht.", vbCritical
    End If
    
    Set bank = Nothing
End Property

Public Property Let UltimateDebtorName(ByVal vNewValue As String)
    strUltmtDbtrNm = vNewValue
End Property

Public Property Let Ausgabepfad(ByVal vNewValue As String)
    Dim fso As New FileSystemObject
    If Not fso.FolderExists(vNewValue) Then
        MsgBox "Dieser Pfad existiert nicht.", vbInformation
        Exit Property
    End If
    strPfad = vNewValue
End Property

'/Konstruktor
Private Sub Class_Initialize()
    datStart = Now()
    
    '//GroupHeader Doc, PI und Root
    Set xmlDoc = New MSXML2.DOMDocument60
    
    Set xmlPI = xmlDoc.createProcessingInstruction("xml", "version=""1.0"" encoding=""UTF-8""")
    Call xmlDoc.InsertBefore(xmlPI, xmlDoc.ChildNodes(0))
    
    Set xmlRoot = xmlDoc.createNode(NODE_ELEMENT, "Document", XMLNS)
    Call xmlDoc.appendChild(xmlRoot)
    
    With xmlDoc.DocumentElement
        Call .setAttribute("xmlns", XMLNS)
        Call .setAttribute("xmlns:xsi", XMLNSXSI)
        Call .setAttribute("xsi:schemaLocation", XSISCHEMELOCATION)
    End With
    
    Set xmlNodCstmrCdtTrfInitn = xmlDoc.createNode(NODE_ELEMENT, "CstmrCdtTrfInitn", XMLNS)
    Call xmlRoot.appendChild(xmlNodCstmrCdtTrfInitn)
End Sub

Public Function check_Values() As Boolean
    If (strMsgId = vbNullString _
        Or strInitgPtyNm = vbNullString _
        Or strPmtInfId = vbNullString _
        Or strSvcLvl = vbNullString _
        Or strReqdExctnDt = vbNullString _
        Or strDbtrNm = vbNullString _
        Or strDbtrAcctIBAN = vbNullString) Then
        MsgBox "Es sind nicht alle erforderlichen Daten vorhanden.", vbCritical
        readyState = False
        check_Values = True
    Else
        readyState = True
        check_Values = False
    End If
End Function

Public Function prepare_sepa_xml() As Boolean
    If Not readyState Then
        MsgBox "Bitte f|fffd|hren Sie zuerst die Methode 'check_Values' durch.", vbInformation
        prepare_sepa_xml = True
        Exit Function
    End If
    
    '/GroupHeader Elemente
    Set xmlNodGrpHdr = xmlDoc.createNode(NODE_ELEMENT, "GrpHdr", XMLNS)
    Call xmlNodCstmrCdtTrfInitn.appendChild(xmlNodGrpHdr)
    
    Set xmlNodMsgId = xmlDoc.createNode(NODE_ELEMENT, "MsgId", XMLNS)
    xmlNodMsgId.Text = strMsgId
    Call xmlNodGrpHdr.appendChild(xmlNodMsgId)
    
    Set xmlNodCreDtTm = xmlDoc.createNode(NODE_ELEMENT, "CreDtTm", XMLNS)
    xmlNodCreDtTm.Text = format(datStart, "yyyy-mm-dd") & "T" & format(datStart, "Hh:Nn:Ss")
    Call xmlNodGrpHdr.appendChild(xmlNodCreDtTm)
    
    Set xmlNodNbOfTxs = xmlDoc.createNode(NODE_ELEMENT, "NbOfTxs", XMLNS)
    Call xmlNodGrpHdr.appendChild(xmlNodNbOfTxs)
    
    Set xmlNodCtrlSum = xmlDoc.createNode(NODE_ELEMENT, "CtrlSum", XMLNS)
    Call xmlNodGrpHdr.appendChild(xmlNodCtrlSum)
    
    Set xmlNodInitgPty = xmlDoc.createNode(NODE_ELEMENT, "InitgPty", XMLNS)
    Call xmlNodGrpHdr.appendChild(xmlNodInitgPty)
    
    Set xmlNodInitgPtyNm = xmlDoc.createNode(NODE_ELEMENT, "Nm", XMLNS)
    xmlNodInitgPtyNm.Text = strInitgPtyNm
    Call xmlNodInitgPty.appendChild(xmlNodInitgPtyNm)
    
    '//PaymentInformation Elemente
    Set xmlNodPmtInf = xmlDoc.createNode(NODE_ELEMENT, "PmtInf", XMLNS)
    Call xmlNodCstmrCdtTrfInitn.appendChild(xmlNodPmtInf)
    
    Set xmlNodPmtInfId = xmlDoc.createNode(NODE_ELEMENT, "PmtInfId", XMLNS)
    xmlNodPmtInfId.Text = strPmtInfId
    Call xmlNodPmtInf.appendChild(xmlNodPmtInfId)
    
    Set xmlNodPmtMtd = xmlDoc.createNode(NODE_ELEMENT, "PmtMtd", XMLNS)
    xmlNodPmtMtd.Text = PMTMTD
    Call xmlNodPmtInf.appendChild(xmlNodPmtMtd)
    
    If Not strBtchBookg = vbNullString Then
        Set xmlNodBtchBookg = xmlDoc.createNode(NODE_ELEMENT, "BtchBookg", XMLNS)
        xmlNodBtchBookg.Text = strBtchBookg
        Call xmlNodPmtInf.appendChild(xmlNodBtchBookg)
    End If
    
    Set xmlNodPmtInfNbOfTxs = xmlDoc.createNode(NODE_ELEMENT, "NbOfTxs", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodPmtInfNbOfTxs)
    
    Set xmlNodPmtInfCtrlSum = xmlDoc.createNode(NODE_ELEMENT, "CtrlSum", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodPmtInfCtrlSum)
    
    Set xmlNodPmtTpInf = xmlDoc.createNode(NODE_ELEMENT, "PmtTpInf", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodPmtTpInf)
    
    Set xmlNodPmtTpInfInstrPrty = xmlDoc.createNode(NODE_ELEMENT, "InstrPrty", XMLNS)
    xmlNodPmtTpInfInstrPrty.Text = INSTRPRTY
    Call xmlNodPmtTpInf.appendChild(xmlNodPmtTpInfInstrPrty)
    
    Set xmlNodPmtTpInfSvcLvl = xmlDoc.createNode(NODE_ELEMENT, "SvcLvl", XMLNS)
    Call xmlNodPmtTpInf.appendChild(xmlNodPmtTpInfSvcLvl)
    
    Set xmlNodPmtTpInfSvcLvlCd = xmlDoc.createNode(NODE_ELEMENT, "Cd", XMLNS)
    xmlNodPmtTpInfSvcLvlCd.Text = strSvcLvl
    Call xmlNodPmtTpInfSvcLvl.appendChild(xmlNodPmtTpInfSvcLvlCd)
    
    Set xmlNodReqdExctnDt = xmlDoc.createNode(NODE_ELEMENT, "ReqdExctnDt", XMLNS)
    xmlNodReqdExctnDt.Text = strReqdExctnDt
    Call xmlNodPmtInf.appendChild(xmlNodReqdExctnDt)
    
    Set xmlNodDbtr = xmlDoc.createNode(NODE_ELEMENT, "Dbtr", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodDbtr)
    
    Set xmlNodDbtrNm = xmlDoc.createNode(NODE_ELEMENT, "Nm", XMLNS)
    xmlNodDbtrNm.Text = strDbtrNm
    Call xmlNodDbtr.appendChild(xmlNodDbtrNm)
    
    Set xmlNodDbtrAcct = xmlDoc.createNode(NODE_ELEMENT, "DbtrAcct", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodDbtrAcct)
    
    Set xmlNodDbtrAcctId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
    Call xmlNodDbtrAcct.appendChild(xmlNodDbtrAcctId)
    
    Set xmlNodDbtrAcctIdIBAN = xmlDoc.createNode(NODE_ELEMENT, "IBAN", XMLNS)
    xmlNodDbtrAcctIdIBAN.Text = strDbtrAcctIBAN
    Call xmlNodDbtrAcctId.appendChild(xmlNodDbtrAcctIdIBAN)
    
    Set xmlNodDbtrAgt = xmlDoc.createNode(NODE_ELEMENT, "DbtrAgt", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodDbtrAgt)
    
    Set xmlNodDbtrAgtFinInstnId = xmlDoc.createNode(NODE_ELEMENT, "FinInstnId", XMLNS)
    Call xmlNodDbtrAgt.appendChild(xmlNodDbtrAgtFinInstnId)
    
    If strDbtrAgtBIC = vbNullString Then
        Dim xmlNodDbtrAgtFinInstnIdOthr As MSXML2.IXMLDOMNode
        Dim xmlNodDbtrAgtFinInstnIdOthrId As MSXML2.IXMLDOMNode
        
        Set xmlNodDbtrAgtFinInstnIdOthr = xmlDoc.createNode(NODE_ELEMENT, "Othr", XMLNS)
        Call xmlNodDbtrAgtFinInstnId.appendChild(xmlNodDbtrAgtFinInstnIdOthr)
        
        Set xmlNodDbtrAgtFinInstnIdOthrId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
        xmlNodDbtrAgtFinInstnIdOthrId.Text = "NOTPROVIDED"
        Call xmlNodDbtrAgtFinInstnIdOthr.appendChild(xmlNodDbtrAgtFinInstnIdOthrId)
    Else
        Dim xmlNodDbtrAgtFinInstnIdBIC As MSXML2.IXMLDOMNode
        
        Set xmlNodDbtrAgtFinInstnIdBIC = xmlDoc.createNode(NODE_ELEMENT, "BIC", XMLNS)
        xmlNodDbtrAgtFinInstnIdBIC.Text = strDbtrAgtBIC
        Call xmlNodDbtrAgtFinInstnId.appendChild(xmlNodDbtrAgtFinInstnIdBIC)
    End If
    
    If Not strUltmtDbtrNm = vbNullString Then
        Set xmlNodUltmtDbtr = xmlDoc.createNode(NODE_ELEMENT, "UltmtDbtr", XMLNS)
        Call xmlNodPmtInf.appendChild(xmlNodUltmtDbtr)
        
        Set xmlNodUltmtDbtrNm = xmlDoc.createNode(NODE_ELEMENT, "Nm", XMLNS)
        xmlNodUltmtDbtrNm.Text = strUltmtDbtrNm
        Call xmlNodUltmtDbtr.appendChild(xmlNodUltmtDbtrNm)
    End If
    
    Set xmlNodChrgBr = xmlDoc.createNode(NODE_ELEMENT, "ChrgBr", XMLNS)
    xmlNodChrgBr.Text = CHRGBR
    Call xmlNodPmtInf.appendChild(xmlNodChrgBr)
End Function

Public Function add_CreditTransferInformation(ByRef CreditInfo As clsSepaCreditInfo) As Boolean
    If check_CreditTransferInformation(CreditInfo) Then
        add_CreditTransferInformation = True
        Exit Function
    End If
    
    Dim xmlNodCdtTrfTxInf As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfPmtId As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfPmtIdEndToEndId As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfAmt As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfAmtInstdAmt As MSXML2.IXMLDOMNode
    Dim xmlAttCdtTrfTxInfAmtInstdAmt As MSXML2.IXMLDOMAttribute
    Dim xmlNodCdtTrfTxInfCdtr As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfCdtrNm As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfCdtrAcct As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfCdtrAcctId As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfCdtrAcctIBAN As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfPurp As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfPurpCd As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfRmtInf As MSXML2.IXMLDOMNode
    Dim xmlNodCdtTrfTxInfRmtInfUstrd As MSXML2.IXMLDOMNode
    
    Set xmlNodCdtTrfTxInf = xmlDoc.createNode(NODE_ELEMENT, "CdtTrfTxInf", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodCdtTrfTxInf)
    
    Set xmlNodCdtTrfTxInfPmtId = xmlDoc.createNode(NODE_ELEMENT, "PmtId", XMLNS)
    Call xmlNodCdtTrfTxInf.appendChild(xmlNodCdtTrfTxInfPmtId)
    
    Set xmlNodCdtTrfTxInfPmtIdEndToEndId = xmlDoc.createNode(NODE_ELEMENT, "EndToEndId", XMLNS)
    xmlNodCdtTrfTxInfPmtIdEndToEndId.Text = CreditInfo.get_EndToEndID
    Call xmlNodCdtTrfTxInfPmtId.appendChild(xmlNodCdtTrfTxInfPmtIdEndToEndId)
    
    Set xmlNodCdtTrfTxInfAmt = xmlDoc.createNode(NODE_ELEMENT, "Amt", XMLNS)
    Call xmlNodCdtTrfTxInf.appendChild(xmlNodCdtTrfTxInfAmt)
    
    Set xmlNodCdtTrfTxInfAmtInstdAmt = xmlDoc.createNode(NODE_ELEMENT, "InstdAmt", XMLNS)
    xmlNodCdtTrfTxInfAmtInstdAmt.Text = Replace(CStr(CreditInfo.get_Amount), ",", ".")
    Call xmlNodCdtTrfTxInfAmt.appendChild(xmlNodCdtTrfTxInfAmtInstdAmt)
    
    Set xmlAttCdtTrfTxInfAmtInstdAmt = xmlDoc.createAttribute("Ccy")
    xmlAttCdtTrfTxInfAmtInstdAmt.Value = "EUR"
    Call xmlNodCdtTrfTxInfAmtInstdAmt.Attributes.setNamedItem(xmlAttCdtTrfTxInfAmtInstdAmt)
    
    If Not CreditInfo.get_BIC = vbNullString Then
        Dim xmlNodCdtTrfTxInfCdtrAgt As MSXML2.IXMLDOMNode
        Dim xmlNodCdtTrfTxInfCdtrAgtFinInstnId As MSXML2.IXMLDOMNode
        Dim xmlNodCdtTrfTxInfCdtrAgtFinInstnIdBIC As MSXML2.IXMLDOMNode
        
        Set xmlNodCdtTrfTxInfCdtrAgt = xmlDoc.createNode(NODE_ELEMENT, "CdtrAgt", XMLNS)
        Call xmlNodCdtTrfTxInf.appendChild(xmlNodCdtTrfTxInfCdtrAgt)
        
        Set xmlNodCdtTrfTxInfCdtrAgtFinInstnId = xmlDoc.createNode(NODE_ELEMENT, "FinInstnId", XMLNS)
        Call xmlNodCdtTrfTxInfCdtrAgt.appendChild(xmlNodCdtTrfTxInfCdtrAgtFinInstnId)
        
        Set xmlNodCdtTrfTxInfCdtrAgtFinInstnIdBIC = xmlDoc.createNode(NODE_ELEMENT, "BIC", XMLNS)
        xmlNodCdtTrfTxInfCdtrAgtFinInstnIdBIC.Text = CreditInfo.get_BIC
        Call xmlNodCdtTrfTxInfCdtrAgtFinInstnId.appendChild(xmlNodCdtTrfTxInfCdtrAgtFinInstnIdBIC)
    End If
    
    Set xmlNodCdtTrfTxInfCdtr = xmlDoc.createNode(NODE_ELEMENT, "Cdtr", XMLNS)
    Call xmlNodCdtTrfTxInf.appendChild(xmlNodCdtTrfTxInfCdtr)
    
    Set xmlNodCdtTrfTxInfCdtrNm = xmlDoc.createNode(NODE_ELEMENT, "Nm", XMLNS)
    xmlNodCdtTrfTxInfCdtrNm.Text = CreditInfo.get_Name
    Call xmlNodCdtTrfTxInfCdtr.appendChild(xmlNodCdtTrfTxInfCdtrNm)
    
    Set xmlNodCdtTrfTxInfCdtrAcct = xmlDoc.createNode(NODE_ELEMENT, "CdtrAcct", XMLNS)
    Call xmlNodCdtTrfTxInf.appendChild(xmlNodCdtTrfTxInfCdtrAcct)
    
    Set xmlNodCdtTrfTxInfCdtrAcctId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
    Call xmlNodCdtTrfTxInfCdtrAcct.appendChild(xmlNodCdtTrfTxInfCdtrAcctId)
    
    Set xmlNodCdtTrfTxInfCdtrAcctIBAN = xmlDoc.createNode(NODE_ELEMENT, "IBAN", XMLNS)
    xmlNodCdtTrfTxInfCdtrAcctIBAN.Text = CreditInfo.get_IBAN
    Call xmlNodCdtTrfTxInfCdtrAcctId.appendChild(xmlNodCdtTrfTxInfCdtrAcctIBAN)
    
    If Not CreditInfo.get_Purpose = vbNullString Then
        Set xmlNodCdtTrfTxInfPurp = xmlDoc.createNode(NODE_ELEMENT, "Purp", XMLNS)
        Call xmlNodCdtTrfTxInf.appendChild(xmlNodCdtTrfTxInfPurp)
        
        Set xmlNodCdtTrfTxInfPurpCd = xmlDoc.createNode(NODE_ELEMENT, "Cd", XMLNS)
        xmlNodCdtTrfTxInfPurpCd.Text = CreditInfo.get_Purpose
        Call xmlNodCdtTrfTxInfPurp.appendChild(xmlNodCdtTrfTxInfPurpCd)
    End If
    
    Set xmlNodCdtTrfTxInfRmtInf = xmlDoc.createNode(NODE_ELEMENT, "RmtInf", XMLNS)
    Call xmlNodCdtTrfTxInf.appendChild(xmlNodCdtTrfTxInfRmtInf)
    
    Set xmlNodCdtTrfTxInfRmtInfUstrd = xmlDoc.createNode(NODE_ELEMENT, "Ustrd", XMLNS)
    xmlNodCdtTrfTxInfRmtInfUstrd.Text = CreditInfo.get_Verwendungszweck
    Call xmlNodCdtTrfTxInfRmtInf.appendChild(xmlNodCdtTrfTxInfRmtInfUstrd)
    
    intAnzahl = intAnzahl + 1
    curSumme = curSumme + CreditInfo.get_Amount
    CreditInfo.clear
End Function

Private Function check_CreditTransferInformation(ByRef CreditInfo As clsSepaCreditInfo)
    With CreditInfo
        If .get_Amount = 0 Then
            check_CreditTransferInformation = True
        ElseIf .get_EndToEndID = vbNullString Then
            check_CreditTransferInformation = True
        ElseIf .get_IBAN = vbNullString Then
            check_CreditTransferInformation = True
        ElseIf .get_Name = vbNullString Then
            check_CreditTransferInformation = True
        ElseIf .get_Verwendungszweck = vbNullString Then
            check_CreditTransferInformation = True
        End If
    End With
End Function

Public Sub create_sepa_xml()
    If intAnzahl = 0 Or curSumme = 0 Then
        MsgBox "SEPA-XML-Datei kann nicht erstellt werden, da keine Einzelinformationen vorhanden sind.", vbInformation
        Exit Sub
    ElseIf Not readyState Then
        MsgBox "SEPA-XML-Datei kann nicht erstellt werden, da die Grundinformationen nicht vorhanden oder noch nicht |fffd|berpr|fffd|ft wurden.", vbInformation
        Exit Sub
    End If
    
    xmlNodNbOfTxs.Text = CStr(intAnzahl)
    xmlNodCtrlSum.Text = Replace(CStr(curSumme), ",", ".")
    xmlNodPmtInfNbOfTxs.Text = CStr(intAnzahl)
    xmlNodPmtInfCtrlSum.Text = Replace(CStr(curSumme), ",", ".")
    
    On Error GoTo errorhandler
    If strPfad = vbNullString Then
        strPfad = ThisWorkbook.Path
    End If
    Call xmlDoc.Save(strPfad & "\CCT_" & strMsgId & "_" & strPmtInfId & ".xml")
    On Error GoTo 0
    
    MsgBox "Die SEPA-XML-Datei wurde erfolgreich erstellt." & vbCrLf & _
        "Anzahl Datens|fffd|tze: " & intAnzahl & vbCrLf & _
        "Summe Datens|fffd|tze: " & format(curSumme, "#,##0.00|fffd|"), vbInformation, "Datei erstellt"
    
    readyState = False
    clear_variables
    Exit Sub
    
errorhandler:
    MsgBox "Es ist leider ein Fehler beim erstellen der SEPA-XML-Datei aufgetreten." & vbCrLf & _
        "Fehlernummer: " & Err.Number & vbCrLf & _
        "Fehlerbeschreibung: " & Err.Description & _
        "Ausgabepfad: " & strPfad, vbCritical
End Sub

Private Sub clear_variables()
    intAnzahl = 0
    curSumme = 0
    strPfad = vbNullString
    strMsgId = vbNullString
    strInitgPtyNm = vbNullString
    strPmtInfId = vbNullString
    strBtchBookg = vbNullString
    strSvcLvl = vbNullString
    strReqdExctnDt = vbNullString
    strDbtrNm = vbNullString
    strDbtrAcctIBAN = vbNullString
    strDbtrAgtBIC = vbNullString
    strUltmtDbtrNm = vbNullString
End Sub

Private Sub Class_Terminate()
    Set xmlDoc = Nothing
End Sub


Attribute VB_Name = "clsSepaCDD"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'/Konstanten
'//GroupHeader
Private Const XMLNS As String = "urn:iso:std:iso:20022:tech:xsd:pain.008.001.02"
Private Const XMLNSXSI As String = "http://www.w3.org/2001/XMLSchema-instance"
Private Const XSISCHEMELOCATION As String = "urn:iso:std:iso:20022:tech:xsd:pain.008.001.02 pain.008.001.02.xsd"
'//PaymentInformation
'///PaymentMethod
Private Const PMTMTD As String = "DD"
'///ServiceLevel
Private Const SVCLVL As String = "SEPA"
'///ChargeBearer
Private Const CHRGBR As String = "SLEV"

'/Datum
Dim datStart As Date

'/XML Objekte
'//GroupHeader Doc, PI, Root und Initiation
Dim xmlDoc As MSXML2.DOMDocument60
Dim xmlPI As MSXML2.IXMLDOMProcessingInstruction
Dim xmlRoot As MSXML2.IXMLDOMNode
Dim xmlNodCstmrDrctDbtInitn As MSXML2.IXMLDOMNode

'//GroupHeader Elemente
Dim xmlNodGrpHdr As MSXML2.IXMLDOMNode
Dim xmlNodMsgId As MSXML2.IXMLDOMNode
Dim xmlNodCreDtTm As MSXML2.IXMLDOMNode
Dim xmlNodNbOfTxs As MSXML2.IXMLDOMNode
Dim xmlNodCtrlSum As MSXML2.IXMLDOMNode
Dim xmlNodInitgPty As MSXML2.IXMLDOMNode
Dim xmlNodInitgPtyNm As MSXML2.IXMLDOMNode

'//PaymentInformation Elemente
Dim xmlNodPmtInf As MSXML2.IXMLDOMNode
Dim xmlNodPmtInfId As MSXML2.IXMLDOMNode
Dim xmlNodPmtMtd As MSXML2.IXMLDOMNode
Dim xmlNodPmtInfNbOfTxs As MSXML2.IXMLDOMNode
Dim xmlNodPmtInfCtrlSum As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInf As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfSvcLvl As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfSvcLvlCd As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfLclInstrm As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfLclInstrmCd As MSXML2.IXMLDOMNode
Dim xmlNodPmtTpInfSeqTp As MSXML2.IXMLDOMNode
Dim xmlNodReqdColltnDt As MSXML2.IXMLDOMNode
Dim xmlNodCdtr As MSXML2.IXMLDOMNode
Dim xmlNodCdtrNm As MSXML2.IXMLDOMNode
Dim xmlNodCdtrAcct As MSXML2.IXMLDOMNode
Dim xmlNodCdtrAcctId As MSXML2.IXMLDOMNode
Dim xmlNodCdtrAcctIdIBAN As MSXML2.IXMLDOMNode
Dim xmlNodCdtrAgt As MSXML2.IXMLDOMNode
Dim xmlNodCdtrAgtFinInstnId As MSXML2.IXMLDOMNode
Dim xmlNodChrgBr As MSXML2.IXMLDOMNode

'//CreditorIdentification
Dim xmlNodCdtrSchmeId As MSXML2.IXMLDOMNode
Dim xmlNodCdtrSchmeIdId As MSXML2.IXMLDOMNode
Dim xmlNodCdtrSchmeIdIdPrvtId As MSXML2.IXMLDOMNode
Dim xmlNodCdtrSchmeIdIdPrvtIdOthr As MSXML2.IXMLDOMNode
Dim xmlNodCdtrSchmeIdIdPrvtIdOthrId As MSXML2.IXMLDOMNode
Dim xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNm As MSXML2.IXMLDOMNode
Dim xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNmPrtry As MSXML2.IXMLDOMNode

'/Z|fffd|hler und Kontrollsumme
Dim intAnzahl As Integer, curSumme As Currency

'/Daten der SEPA-Datei
Dim strMsgId As String, strInitgPtyNm As String, strPmtInfId As String, strPmtTpInfLclInstrmCd As String, strPmtTpInfSeqTp As String
Dim strReqdColltnDt As String, strCdtrNm As String, strCdtrAcctIdIBAN As String, strCdtrAgtBIC As String, strCdtrSchmeIdIdPrvtIdOthrId As String

'/Weitere Daten
Dim strPfad As String, readyState As Boolean

'/Eigenschaften
Public Property Let MessageID(ByVal vNewValue As String)
    If Len(vNewValue) > 35 Then
        MsgBox "Die Message ID darf maximal 35 Zeichen lang sein.", vbCritical
    Else
        strMsgId = Trim(vNewValue)
    End If
End Property

Public Property Let PaymentID(ByVal vNewValue As String)
    If Len(vNewValue) > 35 Then
        MsgBox "Die Payment ID darf maximal 35 Zeichen lang sein.", vbCritical
    Else
        strPmtInfId = Trim(vNewValue)
    End If
End Property

Public Property Let InstrumentCode(ByVal vNewValue As String)
    Select Case vNewValue
        Case "CORE", "B2B":
            strPmtTpInfLclInstrmCd = UCase(vNewValue)
        Case Else:
            MsgBox "InstrumentCode " & vNewValue & " nicht unterst|fffd|tzt."
    End Select
End Property

Public Property Let SequenceType(ByVal vNewValue As String)
    Select Case vNewValue
        'FRST = Erster SEPA Lastschrifteinzug bei wiederkehrende Lastschriften
        'RCUR = Folge SEPA Lastschrifteinzug bei wiederkehrende Lastschriften
        'OOFF = einmalige SEPA Lastschrift
        Case "FRST", "RCUR", "OOFF":
            strPmtTpInfSeqTp = UCase(vNewValue)
        Case Else:
            MsgBox "Sequenztyp " & vNewValue & " nicht unterst|fffd|tzt."
    End Select
End Property

Public Property Let CollectionDate(ByVal vNewValue As Date)
    strReqdColltnDt = format(vNewValue, "yyyy-mm-dd")
End Property

Public Property Let KreditorName(ByVal vNewValue As String)
    strInitgPtyNm = vNewValue
    strCdtrNm = vNewValue
End Property

Public Property Let KreditorIBAN(ByVal vNewValue As String)
    If Not vNewValue = vbNullString Then
        Dim bank As New clsBankData
        If bank.isValidIBAN(vNewValue) Then
            strCdtrAcctIdIBAN = vNewValue
        End If
    End If
    
    Set bank = Nothing
End Property

Public Property Let KreditorAgentBIC(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Exit Property
    End If
    
    Dim bank As New clsBankData
    
    If bank.isValidBIC(vNewValue) Then
        strCdtrAgtBIC = UCase(vNewValue)
    Else
        MsgBox "Die BIC kann nicht hinzugef|fffd|gt werden, da der BIC-Code nicht dem allgemeinen Muster entspricht.", vbCritical
    End If
    
    Set bank = Nothing
End Property

Public Property Let Ausgabepfad(ByVal vNewValue As String)
    Dim fso As New FileSystemObject
    If Not fso.FolderExists(vNewValue) Then
        MsgBox "Dieser Pfad existiert nicht.", vbInformation
        Exit Property
    End If
    strPfad = vNewValue
End Property

Public Property Let KreditorIdentifikation(ByVal vNewValue As String)
    If Len(vNewValue) > 35 Then
        MsgBox "Die Kreditorenidentifikation darf maximal 35 Zeichen lang sein.", vbCritical
    Else
        strCdtrSchmeIdIdPrvtIdOthrId = Trim(vNewValue)
    End If
End Property

'/Konstruktor
Private Sub Class_Initialize()
    datStart = Now()
    
    '//GroupHeader Doc, PI und Root
    Set xmlDoc = New MSXML2.DOMDocument60
    
    Set xmlPI = xmlDoc.createProcessingInstruction("xml", "version=""1.0"" encoding=""UTF-8""")
    Call xmlDoc.InsertBefore(xmlPI, xmlDoc.ChildNodes(0))
    
    Set xmlRoot = xmlDoc.createNode(NODE_ELEMENT, "Document", XMLNS)
    Call xmlDoc.appendChild(xmlRoot)
    
    With xmlDoc.DocumentElement
        Call .setAttribute("xmlns", XMLNS)
        Call .setAttribute("xmlns:xsi", XMLNSXSI)
        Call .setAttribute("xsi:schemaLocation", XSISCHEMELOCATION)
    End With
    
    Set xmlNodCstmrDrctDbtInitn = xmlDoc.createNode(NODE_ELEMENT, "CstmrDrctDbtInitn", XMLNS)
    Call xmlRoot.appendChild(xmlNodCstmrDrctDbtInitn)
End Sub

Public Function check_Values() As Boolean
    If (strMsgId = vbNullString _
        Or strInitgPtyNm = vbNullString _
        Or strPmtInfId = vbNullString _
        Or strPmtTpInfLclInstrmCd = vbNullString _
        Or strPmtTpInfSeqTp = vbNullString _
        Or strReqdColltnDt = vbNullString _
        Or strCdtrNm = vbNullString _
        Or strCdtrAcctIdIBAN = vbNullString _
        Or strCdtrSchmeIdIdPrvtIdOthrId = vbNullString) Then
        MsgBox "Es sind nicht alle erforderlichen Daten vorhanden.", vbCritical
        readyState = False
        check_Values = True
    Else
        readyState = True
        check_Values = False
    End If
End Function

Public Function prepare_sepa_xml() As Boolean
    If Not readyState Then
        MsgBox "Bitte f|fffd|hren Sie zuerst die Methode 'check_Values' durch.", vbInformation
        prepare_sepa_xml = True
        Exit Function
    End If
    
    '/GroupHeader Elemente
    Set xmlNodGrpHdr = xmlDoc.createNode(NODE_ELEMENT, "GrpHdr", XMLNS)
    Call xmlNodCstmrDrctDbtInitn.appendChild(xmlNodGrpHdr)
    
    Set xmlNodMsgId = xmlDoc.createNode(NODE_ELEMENT, "MsgId", XMLNS)
    xmlNodMsgId.Text = strMsgId
    Call xmlNodGrpHdr.appendChild(xmlNodMsgId)
    
    Set xmlNodCreDtTm = xmlDoc.createNode(NODE_ELEMENT, "CreDtTm", XMLNS)
    xmlNodCreDtTm.Text = format(datStart, "yyyy-mm-dd") & "T" & format(datStart, "Hh:Nn:Ss")
    Call xmlNodGrpHdr.appendChild(xmlNodCreDtTm)
    
    Set xmlNodNbOfTxs = xmlDoc.createNode(NODE_ELEMENT, "NbOfTxs", XMLNS)
    Call xmlNodGrpHdr.appendChild(xmlNodNbOfTxs)
    
    Set xmlNodCtrlSum = xmlDoc.createNode(NODE_ELEMENT, "CtrlSum", XMLNS)
    Call xmlNodGrpHdr.appendChild(xmlNodCtrlSum)
    
    Set xmlNodInitgPty = xmlDoc.createNode(NODE_ELEMENT, "InitgPty", XMLNS)
    Call xmlNodGrpHdr.appendChild(xmlNodInitgPty)
    
    Set xmlNodInitgPtyNm = xmlDoc.createNode(NODE_ELEMENT, "Nm", XMLNS)
    xmlNodInitgPtyNm.Text = strInitgPtyNm
    Call xmlNodInitgPty.appendChild(xmlNodInitgPtyNm)
    
    '//PaymentInformation Elemente
    Set xmlNodPmtInf = xmlDoc.createNode(NODE_ELEMENT, "PmtInf", XMLNS)
    Call xmlNodCstmrDrctDbtInitn.appendChild(xmlNodPmtInf)
    
    Set xmlNodPmtInfId = xmlDoc.createNode(NODE_ELEMENT, "PmtInfId", XMLNS)
    xmlNodPmtInfId.Text = strPmtInfId
    Call xmlNodPmtInf.appendChild(xmlNodPmtInfId)
    
    Set xmlNodPmtMtd = xmlDoc.createNode(NODE_ELEMENT, "PmtMtd", XMLNS)
    xmlNodPmtMtd.Text = PMTMTD
    Call xmlNodPmtInf.appendChild(xmlNodPmtMtd)
    
    Set xmlNodPmtInfNbOfTxs = xmlDoc.createNode(NODE_ELEMENT, "NbOfTxs", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodPmtInfNbOfTxs)
    
    Set xmlNodPmtInfCtrlSum = xmlDoc.createNode(NODE_ELEMENT, "CtrlSum", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodPmtInfCtrlSum)
    
    Set xmlNodPmtTpInf = xmlDoc.createNode(NODE_ELEMENT, "PmtTpInf", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodPmtTpInf)
    
    Set xmlNodPmtTpInfSvcLvl = xmlDoc.createNode(NODE_ELEMENT, "SvcLvl", XMLNS)
    Call xmlNodPmtTpInf.appendChild(xmlNodPmtTpInfSvcLvl)
    
    Set xmlNodPmtTpInfSvcLvlCd = xmlDoc.createNode(NODE_ELEMENT, "Cd", XMLNS)
    xmlNodPmtTpInfSvcLvlCd.Text = SVCLVL
    Call xmlNodPmtTpInfSvcLvl.appendChild(xmlNodPmtTpInfSvcLvlCd)
    
    Set xmlNodPmtTpInfLclInstrm = xmlDoc.createNode(NODE_ELEMENT, "LclInstrm", XMLNS)
    Call xmlNodPmtTpInf.appendChild(xmlNodPmtTpInfLclInstrm)
    
    Set xmlNodPmtTpInfLclInstrmCd = xmlDoc.createNode(NODE_ELEMENT, "Cd", XMLNS)
    xmlNodPmtTpInfLclInstrmCd.Text = strPmtTpInfLclInstrmCd
    Call xmlNodPmtTpInfLclInstrm.appendChild(xmlNodPmtTpInfLclInstrmCd)
    
    Set xmlNodPmtTpInfSeqTp = xmlDoc.createNode(NODE_ELEMENT, "SeqTp", XMLNS)
    xmlNodPmtTpInfSeqTp.Text = strPmtTpInfSeqTp
    Call xmlNodPmtTpInf.appendChild(xmlNodPmtTpInfSeqTp)
    
    Set xmlNodReqdColltnDt = xmlDoc.createNode(NODE_ELEMENT, "ReqdColltnDt", XMLNS)
    xmlNodReqdColltnDt.Text = strReqdColltnDt
    Call xmlNodPmtInf.appendChild(xmlNodReqdColltnDt)
    
    Set xmlNodCdtr = xmlDoc.createNode(NODE_ELEMENT, "Cdtr", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodCdtr)
    
    Set xmlNodCdtrNm = xmlDoc.createNode(NODE_ELEMENT, "Nm", XMLNS)
    xmlNodCdtrNm.Text = strCdtrNm
    Call xmlNodCdtr.appendChild(xmlNodCdtrNm)
    
    Set xmlNodCdtrAcct = xmlDoc.createNode(NODE_ELEMENT, "CdtrAcct", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodCdtrAcct)
    
    Set xmlNodCdtrAcctId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
    Call xmlNodCdtrAcct.appendChild(xmlNodCdtrAcctId)
    
    Set xmlNodCdtrAcctIdIBAN = xmlDoc.createNode(NODE_ELEMENT, "IBAN", XMLNS)
    xmlNodCdtrAcctIdIBAN.Text = strCdtrAcctIdIBAN
    Call xmlNodCdtrAcctId.appendChild(xmlNodCdtrAcctIdIBAN)
    
    Set xmlNodCdtrAgt = xmlDoc.createNode(NODE_ELEMENT, "CdtrAgt", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodCdtrAgt)
    
    Set xmlNodCdtrAgtFinInstnId = xmlDoc.createNode(NODE_ELEMENT, "FinInstnId", XMLNS)
    Call xmlNodCdtrAgt.appendChild(xmlNodCdtrAgtFinInstnId)
    
    If strCdtrAgtBIC = vbNullString Then
        Dim xmlNodCdtrAgtFinInstnIdOthr As MSXML2.IXMLDOMNode
        Dim xmlNodCdtrAgtFinInstnIdOthrId As MSXML2.IXMLDOMNode
        
        Set xmlNodCdtrAgtFinInstnIdOthr = xmlDoc.createNode(NODE_ELEMENT, "Othr", XMLNS)
        Call xmlNodCdtrAgtFinInstnId.appendChild(xmlNodCdtrAgtFinInstnIdOthr)
        
        Set xmlNodCdtrAgtFinInstnIdOthrId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
        xmlNodCdtrAgtFinInstnIdOthrId.Text = "NOTPROVIDED"
        Call xmlNodCdtrAgtFinInstnIdOthr.appendChild(xmlNodCdtrAgtFinInstnIdOthrId)
    Else
        Dim xmlNodCdtrAgtFinInstnIdBIC As MSXML2.IXMLDOMNode
        
        Set xmlNodCdtrAgtFinInstnIdBIC = xmlDoc.createNode(NODE_ELEMENT, "BIC", XMLNS)
        xmlNodCdtrAgtFinInstnIdBIC.Text = strCdtrAgtBIC
        Call xmlNodCdtrAgtFinInstnId.appendChild(xmlNodCdtrAgtFinInstnIdBIC)
    End If
    
    Set xmlNodChrgBr = xmlDoc.createNode(NODE_ELEMENT, "ChrgBr", XMLNS)
    xmlNodChrgBr.Text = CHRGBR
    Call xmlNodPmtInf.appendChild(xmlNodChrgBr)
    
    '//CreditorIdentification
    Set xmlNodCdtrSchmeId = xmlDoc.createNode(NODE_ELEMENT, "CdtrSchmeId", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodCdtrSchmeId)
    
    Set xmlNodCdtrSchmeIdId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
    Call xmlNodCdtrSchmeId.appendChild(xmlNodCdtrSchmeIdId)
    
    Set xmlNodCdtrSchmeIdIdPrvtId = xmlDoc.createNode(NODE_ELEMENT, "PrvtId", XMLNS)
    Call xmlNodCdtrSchmeIdId.appendChild(xmlNodCdtrSchmeIdIdPrvtId)
    
    Set xmlNodCdtrSchmeIdIdPrvtIdOthr = xmlDoc.createNode(NODE_ELEMENT, "Othr", XMLNS)
    Call xmlNodCdtrSchmeIdIdPrvtId.appendChild(xmlNodCdtrSchmeIdIdPrvtIdOthr)
    
    Set xmlNodCdtrSchmeIdIdPrvtIdOthrId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
    xmlNodCdtrSchmeIdIdPrvtIdOthrId.Text = strCdtrSchmeIdIdPrvtIdOthrId
    Call xmlNodCdtrSchmeIdIdPrvtIdOthr.appendChild(xmlNodCdtrSchmeIdIdPrvtIdOthrId)
    
    Set xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNm = xmlDoc.createNode(NODE_ELEMENT, "SchmeNm", XMLNS)
    Call xmlNodCdtrSchmeIdIdPrvtIdOthr.appendChild(xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNm)
    
    Set xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNmPrtry = xmlDoc.createNode(NODE_ELEMENT, "Prtry", XMLNS)
    xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNmPrtry.Text = SVCLVL
    Call xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNm.appendChild(xmlNodCdtrSchmeIdIdPrvtIdOthrSchmeNmPrtry)
End Function

Public Function add_DebitTransferInformation(ByVal DebitInfo As clsSepaDebitInfo) As Boolean
    If check_DebitTransferInformation(DebitInfo) Then
        add_DebitTransferInformation = True
        Exit Function
    End If
    
    Dim xmlNodDrctDbtTxInf As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfPmtId As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfPmtIdEndToEndId As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfInstdAmt As MSXML2.IXMLDOMNode
    Dim xmlAttDrctDbtTxInfInstdAmt As MSXML2.IXMLDOMAttribute
    Dim xmlNodDrctDbtTxInfDrctDbtTx As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInf As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfMndtId As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfDtOfSgntr As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDbtrAgt As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDbtrAgtFinInstnId As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDbtr As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDbtrNm As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDbtrAcct As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDbtrAcctId As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfDbtrAcctIdIBAN As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfRmtInf As MSXML2.IXMLDOMNode
    Dim xmlNodDrctDbtTxInfRmtInfUstrd As MSXML2.IXMLDOMNode
    
    Set xmlNodDrctDbtTxInf = xmlDoc.createNode(NODE_ELEMENT, "DrctDbtTxInf", XMLNS)
    Call xmlNodPmtInf.appendChild(xmlNodDrctDbtTxInf)
    
    Set xmlNodDrctDbtTxInfPmtId = xmlDoc.createNode(NODE_ELEMENT, "PmtId", XMLNS)
    Call xmlNodDrctDbtTxInf.appendChild(xmlNodDrctDbtTxInfPmtId)
    
    Set xmlNodDrctDbtTxInfPmtIdEndToEndId = xmlDoc.createNode(NODE_ELEMENT, "EndToEndId", XMLNS)
    xmlNodDrctDbtTxInfPmtIdEndToEndId.Text = DebitInfo.get_EndToEndID
    Call xmlNodDrctDbtTxInfPmtId.appendChild(xmlNodDrctDbtTxInfPmtIdEndToEndId)
    
    Set xmlNodDrctDbtTxInfInstdAmt = xmlDoc.createNode(NODE_ELEMENT, "InstdAmt", XMLNS)
    xmlNodDrctDbtTxInfInstdAmt.Text = Replace(CStr(DebitInfo.get_Amount), ",", ".")
    Call xmlNodDrctDbtTxInf.appendChild(xmlNodDrctDbtTxInfInstdAmt)
    
    Set xmlAttDrctDbtTxInfInstdAmt = xmlDoc.createAttribute("Ccy")
    xmlAttDrctDbtTxInfInstdAmt.Value = "EUR"
    Call xmlNodDrctDbtTxInfInstdAmt.Attributes.setNamedItem(xmlAttDrctDbtTxInfInstdAmt)
    
    Set xmlNodDrctDbtTxInfDrctDbtTx = xmlDoc.createNode(NODE_ELEMENT, "DrctDbtTx", XMLNS)
    Call xmlNodDrctDbtTxInf.appendChild(xmlNodDrctDbtTxInfDrctDbtTx)
    
    Set xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInf = xmlDoc.createNode(NODE_ELEMENT, "MndtRltdInf", XMLNS)
    Call xmlNodDrctDbtTxInfDrctDbtTx.appendChild(xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInf)
    
    Set xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfMndtId = xmlDoc.createNode(NODE_ELEMENT, "MndtId", XMLNS)
    xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfMndtId.Text = DebitInfo.get_MandateID
    Call xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInf.appendChild(xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfMndtId)
    
    Set xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfDtOfSgntr = xmlDoc.createNode(NODE_ELEMENT, "DtOfSgntr", XMLNS)
    xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfDtOfSgntr.Text = format(DebitInfo.get_DateOfSignature, "yyyy-mm-dd")
    Call xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInf.appendChild(xmlNodDrctDbtTxInfDrctDbtTxMndtRltdInfDtOfSgntr)
    
    Set xmlNodDrctDbtTxInfDbtrAgt = xmlDoc.createNode(NODE_ELEMENT, "DbtrAgt", XMLNS)
    Call xmlNodDrctDbtTxInf.appendChild(xmlNodDrctDbtTxInfDbtrAgt)
    
    Set xmlNodDrctDbtTxInfDbtrAgtFinInstnId = xmlDoc.createNode(NODE_ELEMENT, "FinInstnId", XMLNS)
    Call xmlNodDrctDbtTxInfDbtrAgt.appendChild(xmlNodDrctDbtTxInfDbtrAgtFinInstnId)
    
    If DebitInfo.get_BIC = vbNullString Then
        Dim xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthr As MSXML2.IXMLDOMNode
        Dim xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthrId As MSXML2.IXMLDOMNode
        
        Set xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthr = xmlDoc.createNode(NODE_ELEMENT, "Othr", XMLNS)
        Call xmlNodDrctDbtTxInfDbtrAgtFinInstnId.appendChild(xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthr)

        Set xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthrId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
        xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthrId.Text = "NOTPROVIDED"
        Call xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthr.appendChild(xmlNodDrctDbtTxInfDbtrAgtFinInstnIdOthrId)
    Else
        Dim xmlNodDrctDbtTxInfDbtrAgtFinInstnIdBIC As MSXML2.IXMLDOMNode
        
        Set xmlNodDrctDbtTxInfDbtrAgtFinInstnIdBIC = xmlDoc.createNode(NODE_ELEMENT, "BIC", XMLNS)
        xmlNodDrctDbtTxInfDbtrAgtFinInstnIdBIC.Text = DebitInfo.get_BIC
        Call xmlNodDrctDbtTxInfDbtrAgtFinInstnId.appendChild(xmlNodDrctDbtTxInfDbtrAgtFinInstnIdBIC)
    End If
    
    Set xmlNodDrctDbtTxInfDbtr = xmlDoc.createNode(NODE_ELEMENT, "Dbtr", XMLNS)
    Call xmlNodDrctDbtTxInf.appendChild(xmlNodDrctDbtTxInfDbtr)
    
    Set xmlNodDrctDbtTxInfDbtrNm = xmlDoc.createNode(NODE_ELEMENT, "Nm", XMLNS)
    xmlNodDrctDbtTxInfDbtrNm.Text = DebitInfo.get_Name
    Call xmlNodDrctDbtTxInfDbtr.appendChild(xmlNodDrctDbtTxInfDbtrNm)
    
    Set xmlNodDrctDbtTxInfDbtrAcct = xmlDoc.createNode(NODE_ELEMENT, "DbtrAcct", XMLNS)
    Call xmlNodDrctDbtTxInf.appendChild(xmlNodDrctDbtTxInfDbtrAcct)

    Set xmlNodDrctDbtTxInfDbtrAcctId = xmlDoc.createNode(NODE_ELEMENT, "Id", XMLNS)
    Call xmlNodDrctDbtTxInfDbtrAcct.appendChild(xmlNodDrctDbtTxInfDbtrAcctId)
    
    Set xmlNodDrctDbtTxInfDbtrAcctIdIBAN = xmlDoc.createNode(NODE_ELEMENT, "IBAN", XMLNS)
    xmlNodDrctDbtTxInfDbtrAcctIdIBAN.Text = DebitInfo.get_IBAN
    Call xmlNodDrctDbtTxInfDbtrAcctId.appendChild(xmlNodDrctDbtTxInfDbtrAcctIdIBAN)

    Set xmlNodDrctDbtTxInfRmtInf = xmlDoc.createNode(NODE_ELEMENT, "RmtInf", XMLNS)
    Call xmlNodDrctDbtTxInf.appendChild(xmlNodDrctDbtTxInfRmtInf)
    
    Set xmlNodDrctDbtTxInfRmtInfUstrd = xmlDoc.createNode(NODE_ELEMENT, "Ustrd", XMLNS)
    xmlNodDrctDbtTxInfRmtInfUstrd.Text = DebitInfo.get_Verwendungszweck
    Call xmlNodDrctDbtTxInfRmtInf.appendChild(xmlNodDrctDbtTxInfRmtInfUstrd)
    
    intAnzahl = intAnzahl + 1
    curSumme = curSumme + DebitInfo.get_Amount
    DebitInfo.clear
End Function

Private Function check_DebitTransferInformation(ByRef DebitInfo As clsSepaDebitInfo)
    With DebitInfo
        If .get_Amount = 0 Then
            check_DebitTransferInformation = True
        ElseIf .get_EndToEndID = vbNullString Then
            check_DebitTransferInformation = True
        ElseIf .get_IBAN = vbNullString Then
            check_DebitTransferInformation = True
        ElseIf .get_Name = vbNullString Then
            check_DebitTransferInformation = True
        ElseIf .get_Verwendungszweck = vbNullString Then
            check_DebitTransferInformation = True
        ElseIf .get_MandateID = vbNullString Then
            check_DebitTransferInformation = True
        ElseIf .get_DateOfSignature = "00:00:00" Then
            check_DebitTransferInformation = True
        End If
    End With
End Function

Public Sub create_sepa_xml()
    If intAnzahl = 0 Or curSumme = 0 Then
        MsgBox "SEPA-XML-Datei kann nicht erstellt werden, da keine Einzelinformationen vorhanden sind.", vbInformation
        Exit Sub
    ElseIf Not readyState Then
        MsgBox "SEPA-XML-Datei kann nicht erstellt werden, da die Grundinformationen nicht vorhanden oder noch nicht |fffd|berpr|fffd|ft wurden.", vbInformation
        Exit Sub
    End If
    
    xmlNodNbOfTxs.Text = CStr(intAnzahl)
    xmlNodCtrlSum.Text = Replace(CStr(curSumme), ",", ".")
    xmlNodPmtInfNbOfTxs.Text = CStr(intAnzahl)
    xmlNodPmtInfCtrlSum.Text = Replace(CStr(curSumme), ",", ".")
    
    On Error GoTo errorhandler
    If strPfad = vbNullString Then
        strPfad = ThisWorkbook.Path
    End If
    Call xmlDoc.Save(strPfad & "\CDD_" & strMsgId & "_" & strPmtInfId & ".xml")
    On Error GoTo 0
    
    MsgBox "Die SEPA-XML-Datei wurde erfolgreich erstellt." & vbCrLf & _
        "Anzahl Datens|fffd|tze: " & intAnzahl & vbCrLf & _
        "Summe Datens|fffd|tze: " & format(curSumme, "#,##0.00|fffd|"), vbInformation, "Datei erstellt"
    
    readyState = False
    clear_variables
    Exit Sub
    
errorhandler:
    MsgBox "Es ist leider ein Fehler beim erstellen der SEPA-XML-Datei aufgetreten." & vbCrLf & _
        "Fehlernummer: " & Err.Number & vbCrLf & _
        "Fehlerbeschreibung: " & Err.Description & _
        "Ausgabepfad: " & strPfad, vbCritical
End Sub

Private Sub clear_variables()
    intAnzahl = 0
    curSumme = 0
    strMsgId = vbNullString
    strInitgPtyNm = vbNullString
    strPmtInfId = vbNullString
    strPmtTpInfLclInstrmCd = vbNullString
    strPmtTpInfSeqTp = vbNullString
    strReqdColltnDt = "00:00:00"
    strCdtrNm = vbNullString
    strCdtrAcctIdIBAN = vbNullString
    strCdtrAgtBIC = vbNullString
    strCdtrSchmeIdIdPrvtIdOthrId = vbNullString
End Sub

Private Sub Class_Terminate()
    Set xmlDoc = Nothing
End Sub


Attribute VB_Name = "clsSepaCreditInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim strEndToEndId As String, strInstdAmt As Currency, strFinInstnIdBIC As String, strCdtrNm As String
Dim strCdtrAcctId As String, strPurpCd As String, strRmtInf As String
Dim ErrorLog As clsErrorLog

Private Sub Class_Initialize()
    Set ErrorLog = New clsErrorLog
End Sub

Public Property Get isErrorOccured() As Boolean
    isErrorOccured = ErrorLog.Count
End Property

Public Property Get get_ErrorLog() As String
    get_ErrorLog = ErrorLog.get_Log
End Property

Public Property Get get_EndToEndID() As String
    If strEndToEndId = vbNullString Then
        get_EndToEndID = "NOTPROVIDED"
    Else
        get_EndToEndID = strEndToEndId
    End If
End Property

Public Property Let EndToEndID(ByVal vNewValue As String)
    If Not vNewValue = vbNullString Then
        If Len(vNewValue) > 35 Then
            Call ErrorLog.Add("SepaCreditInfo", "Die End-To-End Referenz darf maximal 35 Zeichen lang sein.")
        Else
            strEndToEndId = vNewValue
        End If
    End If
End Property

Public Property Get get_Amount() As Currency
    get_Amount = strInstdAmt
End Property

Public Property Let Amount(ByVal vNewValue As Currency)
    If vNewValue = 0 Then
        Call ErrorLog.Add("SepaCreditInfo", "Der Betrag darf nicht 0,00|fffd| sein.")
    ElseIf vNewValue < 0 Then
        Call ErrorLog.Add("SepaCreditInfo", "Der Betrag darf nicht kleiner 0,00|fffd| sein.")
    Else
        strInstdAmt = vNewValue
    End If
End Property

Public Property Get get_BIC() As String
    get_BIC = strFinInstnIdBIC
End Property

Public Property Let BIC(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Exit Property
    End If
    
    Dim bank As New clsBankData
    
    If Not bank.isValidBIC(vNewValue) Then
        Call ErrorLog.Add("SepaCreditInfo", "Die eingegebene BIC entspricht nicht dem allgemeinen Muster.")
    Else
        strFinInstnIdBIC = vNewValue
    End If
    
    Set bank = Nothing
End Property

Public Property Get get_Name() As String
    get_Name = strCdtrNm
End Property

Public Property Let Name(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Call ErrorLog.Add("SepaCreditInfo", "Der Name darf nicht leer sein.")
    Else
        strCdtrNm = vNewValue
    End If
End Property

Public Property Get get_IBAN() As String
    get_IBAN = strCdtrAcctId
End Property

Public Property Let IBAN(ByVal vNewValue As String)
    Dim bank As New clsBankData
    
    If Not bank.isValidIBAN(vNewValue) Then
        Call ErrorLog.Add("SepaCreditInfo", "Die eingegebene IBAN ist ung|fffd|ltig.")
    Else
        strCdtrAcctId = Trim(vNewValue)
    End If
    
    Set bank = Nothing
End Property

Public Property Get get_Purpose() As String
    get_Purpose = strPurpCd
End Property

Public Property Let Purpose(ByVal vNewValue As String)
    strPurpCd = vNewValue
End Property

Public Property Get get_Verwendungszweck() As String
    get_Verwendungszweck = strRmtInf
End Property

Public Property Let Verwendungszweck(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Call ErrorLog.Add("SepaCreditInfo", "Der Verwendungszweck darf nicht leer sein.")
    ElseIf Len(vNewValue) > 140 Then
        Call ErrorLog.Add("SepaCreditInfo", "Der Verwendungszweck darf nicht mehr als 140 Zeichen lang sein.")
    Else
        strRmtInf = vNewValue
    End If
End Property

Public Sub clear()
    strEndToEndId = vbNullString
    strInstdAmt = 0
    strFinInstnIdBIC = vbNullString
    strCdtrNm = vbNullString
    strCdtrAcctId = vbNullString
    strPurpCd = vbNullString
    strRmtInf = vbNullString
    Set ErrorLog = Nothing
    Set ErrorLog = New clsErrorLog
End Sub

Private Sub Class_Terminate()
    Set ErrorLog = Nothing
End Sub
Attribute VB_Name = "clsSepaDebitInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim strEndToEndId As String, strInstdAmt As Currency, strMndtId As String, datDtOfSgntr As Date, strDbtrAgtBIC As String, strDbtrNm As String
Dim strDbtrAcctIdIBAN As String, strRmtInfUstrd As String
Dim ErrorLog As clsErrorLog

'//Konstruktor
Private Sub Class_Initialize()
    Set ErrorLog = New clsErrorLog
End Sub

'//Errorhandling
Public Property Get get_ErrorLog() As String
    get_ErrorLog = ErrorLog.get_Log
End Property

Public Property Get isErrorOccured() As Boolean
    isErrorOccured = ErrorLog.Count
End Property

'//Properties
Public Property Get get_EndToEndID() As String
    If strEndToEndId = vbNullString Then
        get_EndToEndID = "NOTPROVIDED"
    Else
        get_EndToEndID = strEndToEndId
    End If
End Property

Public Property Let EndToEndID(ByVal vNewValue As String)
    If Not vNewValue = vbNullString Then
        If Len(vNewValue) > 35 Then
            Call ErrorLog.Add("SepaDebitInfo", "Die End-To-End Referenz darf maximal 35 Zeichen lang sein.")
        Else
            strEndToEndId = vNewValue
        End If
    End If
End Property

Public Property Get get_Amount() As Currency
    get_Amount = strInstdAmt
End Property

Public Property Let Amount(ByVal vNewValue As Currency)
    If vNewValue = 0 Then
        Call ErrorLog.Add("SepaDebitInfo", "Der Betrag darf nicht 0,00|fffd| sein.")
    ElseIf vNewValue < 0 Then
        Call ErrorLog.Add("SepaDebitInfo", "Der Betrag darf nicht kleiner 0,00|fffd| sein.")
    Else
        strInstdAmt = vNewValue
    End If
End Property

Public Property Get get_MandateID() As String
    get_MandateID = strMndtId
End Property

Public Property Let MandateId(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Call ErrorLog.Add("SepaDebitInfo", "Die Mandatsreferenz darf nicht leer sein.")
        Exit Property
    End If
    
    strMndtId = vNewValue
End Property

Public Property Get get_BIC() As String
    get_BIC = strDbtrAgtBIC
End Property

Public Property Let BIC(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Exit Property
    End If
    
    Dim bank As New clsBankData

    If Not bank.isValidBIC(vNewValue) Then
        Call ErrorLog.Add("SepaDebitInfo", "Die eingegebene BIC entspricht nicht dem allgemeinen Muster.")
    Else
        strDbtrAgtBIC = vNewValue
    End If
    
    Set bank = Nothing
End Property

Public Property Get get_Name() As String
    get_Name = strDbtrNm
End Property

Public Property Let Name(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Call ErrorLog.Add("SepaDebitInfo", "Der Name darf nicht leer sein.")
    Else
        strDbtrNm = vNewValue
    End If
End Property

Public Property Get get_IBAN() As String
    get_IBAN = strDbtrAcctIdIBAN
End Property

Public Property Let IBAN(ByVal vNewValue As String)
    Dim bank As New clsBankData
    
    If Not bank.isValidIBAN(vNewValue) Then
        Call ErrorLog.Add("SepaDebitInfo", "Die eingegebene IBAN ist ung|fffd|ltig.")
    Else
        strDbtrAcctIdIBAN = Trim(vNewValue)
    End If
    
    Set bank = Nothing
End Property

Public Property Get get_Verwendungszweck() As String
    get_Verwendungszweck = strRmtInfUstrd
End Property

Public Property Let Verwendungszweck(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Call ErrorLog.Add("SepaDebitInfo", "Der Verwendungszweck darf nicht leer sein.")
    ElseIf Len(vNewValue) > 140 Then
        Call ErrorLog.Add("SepaCreditInfo", "Der Verwendungszweck darf nicht mehr als 140 Zeichen lang sein.")
    Else
        strRmtInfUstrd = vNewValue
    End If
End Property

Public Property Get get_DateOfSignature() As Date
    get_DateOfSignature = datDtOfSgntr
End Property

Public Property Let DateOfSignature(ByVal vNewValue As String)
    If vNewValue = vbNullString Then
        Call ErrorLog.Add("SepaDebitInfo", "Das Datum der Unterschrift darf nicht leer sein.")
    Else
        datDtOfSgntr = CDate(vNewValue)
    End If
End Property

Public Sub clear()
    strEndToEndId = vbNullString
    strInstdAmt = 0
    strMndtId = vbNullString
    datDtOfSgntr = DateSerial(1900, 1, 1)
    strDbtrAgtBIC = vbNullString
    strDbtrNm = vbNullString
    strDbtrAcctIdIBAN = vbNullString
    strRmtInfUstrd = vbNullString
    Set ErrorLog = New clsErrorLog
End Sub

Private Sub Class_Terminate()
    Set ErrorLog = Nothing
End Sub
Attribute VB_Name = "clsSummary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Klassendaten
Private fso As FileSystemObject
Private colSummaryEntries As Collection
Private sType_ As String
Private iCount As Integer
Private wordApp As Object
Private wordDoc As Object

'Common Property Data
Private sAusgabepfad As String
Private sExecutionDate As String
Private sMessageID  As String
Private sPaymentID As String
Private sGesamtsumme As String

'CCT Property Data
Private sBatchBooking As String
Private sUrgendPayment As String
Private sDebtorAgentBIC As String
Private sDebtorIBAN As String
Private sDebtorName As String

'CDD Property Data
Private sSequenceType As String
Private sInstrumentCode As String
Private sKreditorAgentBIC As String
Private sKreditorIBAN As String
Private sKreditorIdentifikation As String
Private sKreditorName As String

Public Property Get Ausgabepfad() As Variant
    Ausgabepfad = sAusgabepfad
End Property

Public Property Let Ausgabepfad(ByVal vNewValue As Variant)
    sAusgabepfad = vNewValue
End Property

Public Property Get BatchBooking() As Variant
    BatchBooking = sBatchBooking
End Property

Public Property Let BatchBooking(ByVal vNewValue As Variant)
    sBatchBooking = vNewValue
End Property

Public Property Get ExecutionDate() As Variant
    ExecutionDate = sExecutionDate
End Property

Public Property Let ExecutionDate(ByVal vNewValue As Variant)
    sExecutionDate = vNewValue
End Property

Public Property Get MessageID() As Variant
    MessageID = sMessageID
End Property

Public Property Let MessageID(ByVal vNewValue As Variant)
    sMessageID = vNewValue
End Property

Public Property Get PaymentID() As Variant
    PaymentID = sPaymentID
End Property

Public Property Let PaymentID(ByVal vNewValue As Variant)
    sPaymentID = vNewValue
End Property

Public Property Get UrgendPayment() As Variant
    UrgendPayment = sUrgendPayment
End Property

Public Property Let UrgendPayment(ByVal vNewValue As Variant)
    sUrgendPayment = vNewValue
End Property

Public Property Get DebtorAgentBIC() As Variant
    DebtorAgentBIC = sDebtorAgentBIC
End Property

Public Property Let DebtorAgentBIC(ByVal vNewValue As Variant)
    sDebtorAgentBIC = vNewValue
End Property

Public Property Get DebtorIBAN() As Variant
    DebtorIBAN = sDebtorIBAN
End Property

Public Property Let DebtorIBAN(ByVal vNewValue As Variant)
    sDebtorIBAN = vNewValue
End Property

Public Property Get DebtorName() As Variant
    DebtorName = sDebtorName
End Property

Public Property Let DebtorName(ByVal vNewValue As Variant)
    sDebtorName = vNewValue
End Property

Public Property Get SequenceType() As Variant
    SequenceType = sSequenceType
End Property

Public Property Let SequenceType(ByVal vNewValue As Variant)
    sSequenceType = vNewValue
End Property

Public Property Get InstrumentCode() As Variant
    InstrumentCode = sInstrumentCode
End Property

Public Property Let InstrumentCode(ByVal vNewValue As Variant)
    sInstrumentCode = vNewValue
End Property

Public Property Get KreditorAgentBIC() As Variant
    KreditorAgentBIC = sKreditorAgentBIC
End Property

Public Property Let KreditorAgentBIC(ByVal vNewValue As Variant)
    sKreditorAgentBIC = vNewValue
End Property

Public Property Get KreditorIBAN() As Variant
    KreditorIBAN = sKreditorIBAN
End Property

Public Property Let KreditorIBAN(ByVal vNewValue As Variant)
    sKreditorIBAN = vNewValue
End Property

Public Property Get KreditorIdentifikation() As Variant
    KreditorIdentifikation = sKreditorIdentifikation
End Property

Public Property Let KreditorIdentifikation(ByVal vNewValue As Variant)
    sKreditorIdentifikation = vNewValue
End Property

Public Property Get KreditorName() As Variant
    KreditorName = sKreditorName
End Property

Public Property Let KreditorName(ByVal vNewValue As Variant)
    sKreditorName = vNewValue
End Property

Private Sub Class_Initialize()
    Set fso = New FileSystemObject
    Set colSummaryEntries = New Collection
End Sub

Private Sub Class_Terminate()
    Set fso = Nothing
    If Not wordDoc Is Nothing Then
        wordDoc.Close saveChanges:=False
        Set wordDoc = Nothing
    End If
    If Not wordApp Is Nothing Then
        wordApp.Quit
        Set wordApp = Nothing
    End If
End Sub

Public Sub initialize(ByVal sType As String)
    Dim sPath As String
    Set wordApp = CreateObject("Word.Application")
    
    sType_ = sType
    Select Case sType
        Case "CCT"
            sPath = ThisWorkbook.Path & "\Formulare\Summary_CCT.docx"
        Case "CDD"
            sPath = ThisWorkbook.Path & "\Formulare\Summary_CDD.docx"
    End Select
    
    If fso.FileExists(sPath) Then
        Set wordDoc = wordApp.Documents.Open(sPath, ReadOnly:=True)
    Else
        Err.Raise 1, "clsSummary", "Die Datei """ & sPath & """ konnte nicht gefunden werden."
    End If
End Sub

Public Property Get SummaryEntries() As Collection
    Set SummaryEntries = colSummaryEntries
End Property

Public Sub add_SummaryEntry(ByVal SummaryEntry As clsSummaryEntry)
    colSummaryEntries.Add SummaryEntry
    iCount = iCount + 1
End Sub

Public Sub create_Summary()
    Dim oSummaryEntry As clsSummaryEntry
    Dim oTab As Object
    Dim oRow As Object
    
    'Dokumenteneigenschaften f|fffd|llen und Felder aktualisieren
    Select Case sType_
        Case "CCT"
            With wordDoc
                .CustomDocumentProperties("prpy_Erstellungszeit").Value = format(Now, "dd.mm.yyyy Hh:Nn:Ss")
                .CustomDocumentProperties("prpy_BatchBooking").Value = Me.BatchBooking
                .CustomDocumentProperties("prpy_ExecutionDate").Value = Me.ExecutionDate
                .CustomDocumentProperties("prpy_MessageID").Value = Me.MessageID
                .CustomDocumentProperties("prpy_PaymentID").Value = Me.PaymentID
                .CustomDocumentProperties("prpy_UrgendPayment").Value = Me.UrgendPayment
                .CustomDocumentProperties("prpy_DebtorAgentBIC").Value = Me.DebtorAgentBIC
                .CustomDocumentProperties("prpy_DebtorIBAN").Value = Me.DebtorIBAN
                .CustomDocumentProperties("prpy_DebtorName").Value = Me.DebtorName
                .CustomDocumentProperties("prpy_Anzahl").Value = iCount
                .CustomDocumentProperties("prpy_Gesamtsumme").Value = get_total
                .Fields.Update
            End With
            
            'Tabelle der Einzel|fffd|berweisungen f|fffd|llen
            Set oTab = wordDoc.Tables(1)
            
            For Each oSummaryEntry In colSummaryEntries
                Set oRow = oTab.Rows.Add
                
                With oRow
                    .Cells(1).Range.Text = oSummaryEntry.Name
                    .Cells(2).Range.Text = oSummaryEntry.IBAN
                    .Cells(3).Range.Text = oSummaryEntry.Verwendungszweck
                    .Cells(4).Range.Text = oSummaryEntry.EndToEndID
                    .Cells(5).Range.Text = format(oSummaryEntry.Amount, "#,##0.00 |fffd|")
                End With
            Next oSummaryEntry
        Case "CDD"
            With wordDoc
                .CustomDocumentProperties("prpy_Erstellungszeit").Value = format(Now, "dd.mm.yyyy Hh:Nn:Ss")
                .CustomDocumentProperties("prpy_CollectionDate").Value = Me.ExecutionDate
                .CustomDocumentProperties("prpy_MessageID").Value = Me.MessageID
                .CustomDocumentProperties("prpy_PaymentID").Value = Me.PaymentID
                .CustomDocumentProperties("prpy_SequenceType").Value = Me.SequenceType
                .CustomDocumentProperties("prpy_InstrumentCode").Value = Me.InstrumentCode
                .CustomDocumentProperties("prpy_KreditorAgentBIC").Value = Me.KreditorAgentBIC
                .CustomDocumentProperties("prpy_KreditorIBAN").Value = Me.KreditorIBAN
                .CustomDocumentProperties("prpy_KreditorIdentifikation").Value = Me.KreditorIdentifikation
                .CustomDocumentProperties("prpy_KreditorName").Value = Me.KreditorName
                .CustomDocumentProperties("prpy_Anzahl").Value = iCount
                .CustomDocumentProperties("prpy_Gesamtsumme").Value = get_total
                .Fields.Update
            End With
            
            'Tabelle der Einzellastschriften f|fffd|llen
            Set oTab = wordDoc.Tables(1)
            
            For Each oSummaryEntry In colSummaryEntries
                Set oRow = oTab.Rows.Add
                
                With oRow
                    .Cells(1).Range.Text = oSummaryEntry.Name
                    .Cells(2).Range.Text = oSummaryEntry.IBAN
                    .Cells(3).Range.Text = oSummaryEntry.MandateId
                    .Cells(4).Range.Text = oSummaryEntry.Verwendungszweck
                    .Cells(5).Range.Text = oSummaryEntry.EndToEndID
                    .Cells(6).Range.Text = format(oSummaryEntry.Amount, "#,##0.00 |fffd|")
                End With
            Next oSummaryEntry
    End Select
    
    'Dokument als PDF ausgeben
    wordDoc.SaveAs2 sAusgabepfad & "\" & sType_ & "_" & sMessageID & "_" & sPaymentID & ".pdf", 17
End Sub

Private Function get_total() As String
    Dim oSummaryEntry As clsSummaryEntry
    Dim d As Double
    
    For Each oSummaryEntry In colSummaryEntries
        d = d + oSummaryEntry.Amount
    Next oSummaryEntry
    
    get_total = format(d, "#,##0.00 |fffd|")
End Function
Attribute VB_Name = "clsSummaryEntry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Common Property Data
Private dAmount As Double
Private sBIC As String
Private sEndToEndID As String
Private sIBAN As String
Private sName As String
Private sVerwendungszweck As String

'CDD Property Data
Private sMandateId As String
Private sDate As String

Public Property Get Amount() As Variant
    Amount = dAmount
End Property

Public Property Let Amount(ByVal vNewValue As Variant)
    dAmount = vNewValue
End Property

Public Property Get BIC() As Variant
    BIC = sBIC
End Property

Public Property Let BIC(ByVal vNewValue As Variant)
    sBIC = vNewValue
End Property

Public Property Get EndToEndID() As Variant
    EndToEndID = sEndToEndID
End Property

Public Property Let EndToEndID(ByVal vNewValue As Variant)
    sEndToEndID = vNewValue
End Property

Public Property Get IBAN() As Variant
    IBAN = sIBAN
End Property

Public Property Let IBAN(ByVal vNewValue As Variant)
    sIBAN = vNewValue
End Property

Public Property Get Name() As Variant
    Name = sName
End Property

Public Property Let Name(ByVal vNewValue As Variant)
    sName = vNewValue
End Property

Public Property Get Verwendungszweck() As Variant
    Verwendungszweck = sVerwendungszweck
End Property

Public Property Let Verwendungszweck(ByVal vNewValue As Variant)
    sVerwendungszweck = vNewValue
End Property

Public Property Get MandateId() As Variant
    MandateId = sMandateId
End Property

Public Property Let MandateId(ByVal vNewValue As Variant)
    sMandateId = vNewValue
End Property

Public Property Get Date_() As Variant
    Date_ = sDate
End Property

Public Property Let Date_(ByVal vNewValue As Variant)
    sDate = format(vNewValue, "dd.mm.yyyy")
End Property
Attribute VB_Name = "clsUpdate"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const URL As String = "https://www.jansesoft.de/version/version.php"
Private Const URL_DOWNLOAD As String = "https://jansesoft.de/blog/index.php/download/download-excel2sepaxml/"
Private Const PROGRAM_NAME As String = "Excel2SepaXML"
Private Const VERSION As Integer = 8

Public Property Get get_download_url() As Variant
    get_download_url = URL_DOWNLOAD
End Property

Public Function isUpdateAvailable() As Boolean
    Dim objRequest As New WinHttp.WinHttpRequest
    
    With objRequest
        .Open "GET", URL & "?programname=" & PROGRAM_NAME & "&version=" & VERSION
        .Send
        .waitForResponse 1000
        If .statusText <> "OK" Then GoTo errorhandler
    End With
    
    On Error GoTo errorhandler
    Dim objXML As New MSXML2.DOMDocument60
    Dim objNode As MSXML2.IXMLDOMElement
    
    objXML.LoadXML (objRequest.ResponseText)
    Set objNode = objXML.SelectSingleNode("program")
    
    If Not objNode.Attributes(0).Text = PROGRAM_NAME Then
        GoTo errorhandler
    Else
        Set objNode = objXML.SelectSingleNode("program").SelectSingleNode("programversion").SelectSingleNode("version")
        
        Dim i As Integer
        
        On Error Resume Next
        i = CInt(objNode.Text)
        On Error GoTo 0
        
        If Err.Number > 0 Then
            GoTo errorhandler
        End If
        
        If i > VERSION Then
            isUpdateAvailable = True
        End If
    End If
        
    Set objRequest = Nothing
    Set objXML = Nothing
    Set objNode = Nothing
    On Error GoTo 0
    
    Exit Function
    
errorhandler:
    If Not objRequest Is Nothing Then
        Set objRequest = Nothing
    End If
    If Not objXML Is Nothing Then
        Set objXML = Nothing
    End If
    If Not objNode Is Nothing Then
        Set objNode = Nothing
    End If
End Function
Attribute VB_Name = "frmAuftraggeber"
Attribute VB_Base = "0{435E8AC3-D9D7-43F5-8063-1F2507410878}{9F97C7B9-03B6-441E-B845-BB87AE856455}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private cAccFact As clsAccountFactory

Private Sub cmdHinzuf|fffd|gen_Click()
    Dim cAccount As New clsAccount
    
    On Error GoTo errorhandler
        With cAccount
            .IBAN = Clean_Input(Me.txtIBAN)
            .SWIFT = Clean_Input(Me.txtBIC)
            .ID = Clean_Input(Me.txtID)
            .Inhaber = Me.txtKontoinhaber
        End With
    
        cAccFact.add_Account cAccount
    On Error GoTo 0
    
    Call fill_lstAccounts
    
    With Me
        .txtIBAN = vbNullString
        .txtBIC = vbNullString
        .txtID = vbNullString
        .txtKontoinhaber = vbNullString
    End With
    
errorhandler:
    If Err.Number > 0 Then
        MsgBox Err.Description, vbExclamation
    End If
End Sub

Private Sub UserForm_Initialize()
    Set cAccFact = New clsAccountFactory
    Call fill_lstAccounts
End Sub

Private Sub UserForm_Terminate()
    cAccFact.save_Accounts
    Set cAccFact = Nothing
End Sub

Private Sub cmdFertig_Click()
    Unload Me
    Call frmMen|fffd|.Show(vbModeless)
End Sub

Private Sub cmdL|fffd|schen_Click()
    If MsgBox("M|fffd|chten Sie die gew|fffd|hlte Bankverbindung wirklich l|fffd|schen?", vbQuestion + vbYesNo) = vbNo Then
        Exit Sub
    End If
    
    Call cAccFact.delete_Account(Me.lstAccounts.List(Me.lstAccounts.ListIndex, 0))
    Call fill_lstAccounts
End Sub

Private Sub cmdNeu_Click()
    Me.lstAccounts.ListIndex = -1
End Sub

Private Sub lstAccounts_Change()
    With Me
        If .lstAccounts.ListIndex <> -1 Then
            .cmdL|fffd|schen.Enabled = True
            .cmdHinzuf|fffd|gen.Enabled = False
            .cmdNeu.Enabled = True
        Else
            .cmdL|fffd|schen.Enabled = False
            .cmdHinzuf|fffd|gen.Enabled = True
            .cmdNeu.Enabled = False
        End If
    End With
End Sub

Private Sub fill_lstAccounts()
    Me.lstAccounts.clear
    
    If cAccFact.get_Accounts.Count > 0 Then
        Dim cAccount As clsAccount
        
        With lstAccounts
            For Each cAccount In cAccFact.get_Accounts
                .AddItem cAccount.IBAN
                .List(.ListCount - 1, 1) = cAccount.Inhaber
                .List(.ListCount - 1, 2) = cAccount.SWIFT
                .List(.ListCount - 1, 3) = cAccount.ID
            Next cAccount
        End With
    End If
End Sub

Private Function Clean_Input(ByVal sInput As String) As String
    sInput = Trim(sInput)
    Clean_Input = Replace(sInput, " ", "")
End Function

Attribute VB_Name = "frmCalendar"
Attribute VB_Base = "0{1238D072-252F-4727-B817-456E0A7D3D72}{A80F0DB1-6078-401C-B6BE-779F2D3F0D59}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private WithEvents Calendar As cCalendar
Attribute Calendar.VB_VarHelpID = -1
Private Target_ As Object

Public Property Let Target(ByVal vNewValue As Variant)
    If Not vNewValue Is Nothing Then
        Set Target_ = vNewValue
        On Error Resume Next
            If IsDate(Target_.Value) Then
                Calendar.Value = CDate(Target_.Value)
            End If
        On Error GoTo 0
    End If
End Property

Public Property Let Title(ByVal vNewValue As Variant)
    If Not vNewValue = vbNullString Then
        Me.Caption = vNewValue
    End If
End Property

Private Sub Calendar_Click()
    On Error Resume Next
        Target_.Value = Calendar.Value
    On Error GoTo 0
    Unload Me
End Sub

Private Sub cmdNextDay_Click()
    Calendar.NextDay
End Sub

Private Sub cmdNextMonth_Click()
    Calendar.NextMonth
End Sub

Private Sub cmdNextWeek_Click()
    Calendar.NextWeek
End Sub

Private Sub cmdPreviousDay_Click()
    Calendar.PreviousDay
End Sub

Private Sub cmdPreviousMonth_Click()
    Calendar.PreviousMonth
End Sub

Private Sub cmdPreviousWeek_Click()
    Calendar.PreviousWeek
End Sub

Private Sub cmdToday_Click()
    Calendar.Today
End Sub

Private Sub UserForm_Initialize()
    Set Calendar = New cCalendar
    With Calendar
        .Add_Calendar_into_Frame Me.frCalendar
        .UseDefaultBackColors = False
        .HeaderBackColor = RGB(205, 155, 155)
        .SaturdayBackColor = RGB(193, 123, 116)
        .SundayBackColor = RGB(119, 105, 119)
        .SelectedBackColor = RGB(2, 105, 239)
        .Refresh
        .Today
    End With
End Sub

Private Sub UserForm_Terminate()
    Set Calendar = Nothing
End Sub
Attribute VB_Name = "frmLastschrift"
Attribute VB_Base = "0{3F67945F-CA96-4F0E-8878-1F83527C4193}{6534D115-758C-460D-B7F5-276A88731C43}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private cAccFact As clsAccountFactory

Private Sub cmbAccount_Change()
    If Me.cmbAccount.ListIndex <> -1 Then
        Dim cAccount As clsAccount
        Set cAccount = cAccFact.get_single_account(Me.cmbAccount.Value)
        
        If Not cAccount Is Nothing Then
            Me.lblBIC = cAccount.SWIFT
            Me.lblIBAN = cAccount.IBAN
            Me.lblKontoinhaber = cAccount.Inhaber
            Me.lblGl|fffd|ubigerID = cAccount.ID
        End If
    End If
End Sub

Private Sub UserForm_Initialize()
    Set cAccFact = New clsAccountFactory
    Call fill_accounts
    
    With Me
        'FRST = Erster SEPA Lastschrifteinzug bei wiederkehrende Lastschriften
        'RCUR = Folge SEPA Lastschrifteinzug bei wiederkehrende Lastschriften
        'OOFF = einmalige SEPA Lastschrift
        .cmbSequenz.AddItem ("FRST")
        .cmbSequenz.AddItem ("RCUR")
        .cmbSequenz.AddItem ("OOFF")
        
        'CORE = SEPA-CORE-Basislastschrift
        'B2B = SEPA-B2B-Firmenlastschrift
        .cmdArt.AddItem ("CORE")
        .cmdArt.AddItem ("B2B")
        
        .dtpAusf|fffd|hrung.Value = Date
    End With
End Sub

Private Sub UserForm_Terminate()
    Set cAccFact = Nothing
End Sub

Private Sub cmdShowCalendar_Click()
    Dim cal As New frmCalendar
    With cal
        .Title = "Bitte Ausf|fffd|hrungsdatum w|fffd|hlen"
        .Target = Me.dtpAusf|fffd|hrung
        .Show vbModeless
    End With
    Set cal = Nothing
End Sub

Private Sub cmdStart_Click()
    With Me
        If Not .chbAutoMsgID And Me.txtMsgID = vbNullString Then
            MsgBox "Bitte geben Sie eine Message ID ein.", vbInformation
            Exit Sub
        ElseIf Not .chbAutoPymtID And Me.txtPymtID = vbNullString Then
            MsgBox "Bitte geben Sie eine Payment ID ein.", vbInformation
            Exit Sub
        ElseIf .lblPfad = "(nicht festgelegt)" Then
            MsgBox "Bitte w|fffd|hlen Sie einen Ausgabpfad.", vbInformation
            Exit Sub
        ElseIf .cmdArt = vbNullString Then
            MsgBox "Bitte w|fffd|hlen Sie eine Lastschriftart.", vbInformation
            Exit Sub
        ElseIf .cmbSequenz = vbNullString Then
            MsgBox "Bitte w|fffd|hlen Sie eine Lastschriftsequenz.", vbInformation
            Exit Sub
        ElseIf .cmbAccount.Value = vbNullString Then
            MsgBox "Bitte eine Bankverbindung w|fffd|hlen.", vbInformation
            Exit Sub
        ElseIf .lblGl|fffd|ubigerID = vbNullString Then
            MsgBox "Bitte eine Bankverbindung mit Gl|fffd|ubiger-ID w|fffd|hlen.", vbInformation
            Exit Sub
        End If
    End With
    
    Dim x As New clsSepaCDD
    Dim c As New clsSepaDebitInfo
    Dim i As Integer: i = 2
    Dim strErrors As String
    Dim sMessageID As String
    Dim sPaymentID As String
    
    If Me.chbAutoMsgID Then
        sMessageID = format(Now, "yyyymmdd-HhNnSs")
    Else
        sMessageID = Me.txtMsgID
    End If
    
    If Me.chbAutoPymtID Then
        sPaymentID = format(Now, "yyyymmdd-HhNnSs")
    Else
        sPaymentID = Me.txtPymtID
    End If
    
    'Deckblatt
    If Me.chbSummary Then
        Dim oSummary As New clsSummary
        Dim oSummaryEntry As clsSummaryEntry
        
        On Error GoTo errorhandler
            oSummary.initialize "CDD"
        On Error GoTo 0
    End If
    
    With x
        .Ausgabepfad = Me.lblPfad
        .CollectionDate = Me.dtpAusf|fffd|hrung
        .KreditorAgentBIC = Clean_Input(Me.lblBIC)
        .KreditorIBAN = Clean_Input(Me.lblIBAN)
        .KreditorIdentifikation = Clean_Input(Me.lblGl|fffd|ubigerID)
        .KreditorName = Me.lblKontoinhaber
        .MessageID = sMessageID
        .PaymentID = sPaymentID
        .SequenceType = Me.cmbSequenz
        .InstrumentCode = Me.cmdArt
        
        If .check_Values Then
            Exit Sub
        End If
        
        If .prepare_sepa_xml Then
            Exit Sub
        End If
    End With
    
    'Deckblatt
    If Me.chbSummary Then
        With oSummary
            .Ausgabepfad = Me.lblPfad
            .ExecutionDate = Me.dtpAusf|fffd|hrung
            .KreditorAgentBIC = Clean_Input(Me.lblBIC)
            .KreditorIBAN = Clean_Input(Me.lblIBAN)
            .KreditorIdentifikation = Clean_Input(Me.lblGl|fffd|ubigerID)
            .KreditorName = Me.lblKontoinhaber
            .MessageID = sMessageID
            .PaymentID = sPaymentID
            .SequenceType = Me.cmbSequenz
            .InstrumentCode = Me.cmdArt
        End With
    End If
    
    Do While Not Worksheets("SEPA_Lastschrift").Cells(i, 1) = vbNullString
        With c
            .clear
            .Amount = Worksheets("SEPA_Lastschrift").Cells(i, 2)
            .BIC = Clean_Input(Worksheets("SEPA_Lastschrift").Cells(i, 3))
            .DateOfSignature = Worksheets("SEPA_Lastschrift").Cells(i, 8)
            .EndToEndID = Worksheets("SEPA_Lastschrift").Cells(i, 6)
            .IBAN = Clean_Input(Worksheets("SEPA_Lastschrift").Cells(i, 4))
            .MandateId = Worksheets("SEPA_Lastschrift").Cells(i, 7)
            .Name = Worksheets("SEPA_Lastschrift").Cells(i, 1)
            .Verwendungszweck = Worksheets("SEPA_Lastschrift").Cells(i, 5)
            If .isErrorOccured Then
                strErrors = strErrors & "Fehler in Zeile " & i & ": " & vbNewLine & _
                    .get_ErrorLog
            Else
                Call x.add_DebitTransferInformation(c)
            End If
        End With
        
        'Deckblatt
        If Me.chbSummary Then
            Set oSummaryEntry = New clsSummaryEntry
            
            With oSummaryEntry
                .Amount = Worksheets("SEPA_Lastschrift").Cells(i, 2)
                .BIC = Clean_Input(Worksheets("SEPA_Lastschrift").Cells(i, 3))
                .Date_ = Worksheets("SEPA_Lastschrift").Cells(i, 8)
                .EndToEndID = Worksheets("SEPA_Lastschrift").Cells(i, 6)
                .IBAN = Clean_Input(Worksheets("SEPA_Lastschrift").Cells(i, 4))
                .MandateId = Worksheets("SEPA_Lastschrift").Cells(i, 7)
                .Name = Worksheets("SEPA_Lastschrift").Cells(i, 1)
                .Verwendungszweck = Worksheets("SEPA_Lastschrift").Cells(i, 5)
            End With
            
            oSummary.add_SummaryEntry oSummaryEntry
        End If
        
        i = i + 1
    Loop
    
    If Not strErrors = vbNullString Then
        If MsgBox("Es sind Fehler w|fffd|hrend der Erstellung der SEPA-XML Datei aufgetreten, m|fffd|chten Sie diese in einem Protokoll speichern?", vbQuestion + vbYesNo, "Fehler beim Erstellen") = vbYes Then
            Dim strPfad As String
            
            strPfad = Me.lblPfad
            strPfad = strPfad & "\Fehlerprotokoll.txt"
            
            Dim fso As New FileSystemObject
            Dim stream As TextStream
            
            Set stream = fso.CreateTextFile(strPfad, True, True)
            Call stream.Write(strErrors)
            
            If MsgBox("Das Fehlerprotokoll wurde unter '" & strPfad & "' abgelegt." & vbCrLf & _
                "M|fffd|chten Sie die SEPA-XML-Datei trotzdem erstellen?", vbQuestion + vbYesNo) = vbYes Then
                Call x.create_sepa_xml
                
                If Me.chbSummary Then
                    Application.StatusBar = "Erstelle Deckblatt, bitte warten.."
                    oSummary.create_Summary
                    Application.StatusBar = vbNullString
                End If
            End If
            
            Set stream = Nothing
            Set fso = Nothing
        Else
            If MsgBox("Das Fehlerprotokoll wurde verworfen." & vbCrLf & _
                "M|fffd|chten Sie die SEPA-XML-Datei trotzdem erstellen?", vbQuestion + vbYesNo) = vbYes Then
                Call x.create_sepa_xml
                
            If Me.chbSummary Then
                Application.StatusBar = "Erstelle Deckblatt, bitte warten.."
                oSummary.create_Summary
                Application.StatusBar = vbNullString
            End If
            End If
        End If
    Else
        Call x.create_sepa_xml
        
        If Me.chbSummary Then
            Application.StatusBar = "Erstelle Deckblatt, bitte warten.."
            oSummary.create_Summary
            Application.StatusBar = vbNullString
        End If
    End If
    
errorhandler:
    If Err.Number <> 0 Then
        MsgBox "Es ist leider ein Fehler aufgetreten" & vbCrLf & _
            "Fehler im Objekt: " & Err.Source & vbCrLf & _
            "Fehlerbeschreibung: " & Err.Description, vbCritical
    End If
    
    Set oSummary = Nothing
    Set oSummaryEntry = Nothing
    Set c = Nothing
    Set x = Nothing
End Sub

Private Sub chbAutoMsgID_Click()
    With Me
        If .chbAutoMsgID Then
            .txtMsgID.Enabled = False
        Else
            .txtMsgID.Enabled = True
        End If
    End With
End Sub

Private Sub chbAutoPymtID_Click()
    With Me
        If .chbAutoPymtID Then
            .txtPymtID.Enabled = False
        Else
            .txtPymtID.Enabled = True
        End If
    End With
End Sub

Private Sub cmdAbbrechen_Click()
    Unload Me
    Call frmMen|fffd|.Show(vbModeless)
End Sub

Private Sub cmdPfad_Click()
    Dim strPfad As String
    
    With Application.FileDialog(msoFileDialogFolderPicker)
        .Title = "Ausgabepfad w|fffd|hlen"
        If .Show = -1 Then
            strPfad = .SelectedItems(1)
        End If
    End With
    
    If Not strPfad = vbNullString Then
        Me.lblPfad = strPfad
    Else
        MsgBox "Keinen Speicherort gew|fffd|hlt.", vbInformation
    End If
End Sub

Private Sub fill_accounts()
    Dim cAccount As clsAccount
    
    For Each cAccount In cAccFact.get_Accounts
        Me.cmbAccount.AddItem cAccount.IBAN
    Next cAccount
End Sub

Private Function Clean_Input(ByVal sInput As String) As String
    sInput = Trim(sInput)
    Clean_Input = Replace(sInput, " ", "")
End Function
Attribute VB_Name = "frmMen|fffd|"
Attribute VB_Base = "0{9FF39C04-74FD-4031-A746-76D1400D7DD4}{BB3E919D-7C64-4C5C-9BC7-DBD908030D43}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim l As LongPtr

Private Sub cmdAuftraggeber|fffd|ndern_Click()
    Unload Me
    Call frmAuftraggeber.Show(vbModeless)
End Sub

Private Sub cmdLastschrift_Click()
    Unload Me
    Call frmLastschrift.Show(vbModeless)
End Sub

Private Sub cmd|fffd|berweisung_Click()
    Unload Me
    Call frm|fffd|berweisung.Show(vbModeless)
End Sub

Private Sub Label2_Click()
    l = ShellExecute(0, "Open", "https://jansesoft.de/blog/index.php/Excel2SepaXML/")
End Sub

Private Sub Label3_Click()
    l = ShellExecute(0, "Open", "https://jansesoft.de/blog/index.php/excel2sepaxml/dokumentation/")
End Sub

Private Sub Label4_Click()
    l = ShellExecute(0, "Open", "https://paypal.me/JanSeSoft")
End Sub
Attribute VB_Name = "frm|fffd|berweisung"
Attribute VB_Base = "0{FEC4FDAC-CE1B-4D42-BFB4-445D4C92B798}{8C1D4BF2-C61F-41CB-88A9-0FD4BC7811E3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private cAccFact As clsAccountFactory

Private Sub cmbAccount_Change()
    If Me.cmbAccount.ListIndex <> -1 Then
        Dim cAccount As clsAccount
        Set cAccount = cAccFact.get_single_account(Me.cmbAccount.Value)
        
        If Not cAccount Is Nothing Then
            Me.lblBIC = cAccount.SWIFT
            Me.lblIBAN = cAccount.IBAN
            Me.lblKontoinhaber = cAccount.Inhaber
        End If
    End If
End Sub

Private Sub UserForm_Initialize()
    Set cAccFact = New clsAccountFactory
    Call fill_accounts
    
    Me.dtpAusf|fffd|hrung = Date
End Sub

Private Sub UserForm_Terminate()
    Set cAccFact = Nothing
End Sub

Private Sub chbAutoMsgID_Click()
    With Me
        If .chbAutoMsgID Then
            .txtMsgID.Enabled = False
        Else
            .txtMsgID.Enabled = True
        End If
    End With
End Sub

Private Sub chbAutoPymtID_Click()
    With Me
        If .chbAutoPymtID Then
            .txtPymtID.Enabled = False
        Else
            .txtPymtID.Enabled = True
        End If
    End With
End Sub

Private Sub cmdAbbrechen_Click()
    Unload Me
    Call frmMen|fffd|.Show(vbModeless)
End Sub

Private Sub cmdPfad_Click()
    Dim strPfad As String
    
    With Application.FileDialog(msoFileDialogFolderPicker)
        .Title = "Ausgabepfad w|fffd|hlen"
        If .Show = -1 Then
            strPfad = .SelectedItems(1)
        End If
    End With
    
    If Not strPfad = vbNullString Then
        Me.lblPfad = strPfad
    Else
        MsgBox "Keinen Speicherort gew|fffd|hlt.", vbInformation
    End If
End Sub

Private Sub cmdShowCalendar_Click()
    Dim cal As New frmCalendar
    With cal
        .Title = "Bitte Ausf|fffd|hrungsdatum w|fffd|hlen"
        .Target = Me.dtpAusf|fffd|hrung
        .Show vbModeless
    End With
    Set cal = Nothing
End Sub

Private Sub cmdStart_Click()
    With Me
        If Not .chbAutoMsgID And Me.txtMsgID = vbNullString Then
            MsgBox "Bitte geben Sie eine Message ID ein.", vbInformation
            Exit Sub
        ElseIf Not .chbAutoPymtID And Me.txtPymtID = vbNullString Then
            MsgBox "Bitte geben Sie eine Payment ID ein.", vbInformation
            Exit Sub
        ElseIf .lblPfad = "(nicht festgelegt)" Then
            MsgBox "Bitte w|fffd|hlen Sie einen Ausgabpfad.", vbInformation
            Exit Sub
        ElseIf .cmbAccount.Value = vbNullString Then
            MsgBox "Bitte eine Bankverbindung w|fffd|hlen.", vbInformation
            Exit Sub
        End If
    End With
    
    Dim x As New clsSepaCCT
    Dim c As New clsSepaCreditInfo
    Dim i As Integer: i = 2
    Dim strErrors As String
    Dim sMessageID As String
    Dim sPaymentID As String
    
    If Me.chbAutoMsgID Then
        sMessageID = format(Now, "yyyymmdd-HhNnSs")
    Else
        sMessageID = Me.txtMsgID
    End If
    
    If Me.chbAutoPymtID Then
        sPaymentID = format(Now, "yyyymmdd-HhNnSs")
    Else
        sPaymentID = Me.txtPymtID
    End If
    
    'Deckblatt
    If Me.chbSummary Then
        Dim oSummary As New clsSummary
        Dim oSummaryEntry As clsSummaryEntry
        
        On Error GoTo errorhandler
            oSummary.initialize "CCT"
        On Error GoTo 0
    End If
    
    With x
        .Ausgabepfad = Me.lblPfad
        .BatchBooking = Me.chbBatch
        .UrgendPayment = Me.chbUrgend
        .DebtorAgentBIC = Clean_Input(Me.lblBIC)
        .DebtorIBAN = Clean_Input(Me.lblIBAN)
        .DebtorName = Me.lblKontoinhaber
        .ExecutionDate = Me.dtpAusf|fffd|hrung
        .MessageID = sMessageID
        .PaymentID = sPaymentID
        
        If .check_Values Then
            Exit Sub
        End If
        
        If .prepare_sepa_xml Then
            Exit Sub
        End If
    End With
    
    'Deckblatt
    If Me.chbSummary Then
        With oSummary
            .Ausgabepfad = Me.lblPfad
            .BatchBooking = Me.chbBatch
            .UrgendPayment = Me.chbUrgend
            .DebtorAgentBIC = Clean_Input(Me.lblBIC)
            .DebtorIBAN = Clean_Input(Me.lblIBAN)
            .DebtorName = Me.lblKontoinhaber
            .ExecutionDate = Me.dtpAusf|fffd|hrung
            .MessageID = sMessageID
            .PaymentID = sPaymentID
        End With
    End If
    
    Do While Not Worksheets("SEPA_|fffd|berweisung").Cells(i, 1) = vbNullString
        With c
            .clear
            .Amount = Worksheets("SEPA_|fffd|berweisung").Cells(i, 2)
            .BIC = Clean_Input(UCase(Worksheets("SEPA_|fffd|berweisung").Cells(i, 3)))
            .EndToEndID = Worksheets("SEPA_|fffd|berweisung").Cells(i, 6)
            .IBAN = Clean_Input(Worksheets("SEPA_|fffd|berweisung").Cells(i, 4))
            .Name = Worksheets("SEPA_|fffd|berweisung").Cells(i, 1)
            .Verwendungszweck = Worksheets("SEPA_|fffd|berweisung").Cells(i, 5)
            
            If .isErrorOccured Then
                strErrors = strErrors & "Fehler in Zeile " & i & ": " & vbNewLine & .get_ErrorLog
            Else
                Call x.add_CreditTransferInformation(c)
            End If
        End With
        
        'Deckblatt
        If Me.chbSummary Then
            Set oSummaryEntry = New clsSummaryEntry
            
            With oSummaryEntry
                .Amount = Worksheets("SEPA_|fffd|berweisung").Cells(i, 2)
                .BIC = Clean_Input(UCase(Worksheets("SEPA_|fffd|berweisung").Cells(i, 3)))
                .EndToEndID = Worksheets("SEPA_|fffd|berweisung").Cells(i, 6)
                .IBAN = Clean_Input(Worksheets("SEPA_|fffd|berweisung").Cells(i, 4))
                .Name = Worksheets("SEPA_|fffd|berweisung").Cells(i, 1)
                .Verwendungszweck = Worksheets("SEPA_|fffd|berweisung").Cells(i, 5)
            End With
            
            oSummary.add_SummaryEntry oSummaryEntry
        End If
        
        i = i + 1
    Loop
    
    If Not strErrors = vbNullString Then
        If MsgBox("Es sind Fehler w|fffd|hrend der Erstellung der SEPA-XML Datei aufgetreten, m|fffd|chten Sie diese in einem Protokoll speichern?", vbQuestion + vbYesNo, "Fehler beim Erstellen") = vbYes Then
            Dim strPfad As String
            
            strPfad = Me.lblPfad
            strPfad = strPfad & "\Fehlerprotokoll.txt"
            
            Dim fso As New FileSystemObject
            Dim stream As TextStream
            
            Set stream = fso.CreateTextFile(strPfad, True, True)
            Call stream.Write(strErrors)
            
            If MsgBox("Das Fehlerprotokoll wurde unter '" & strPfad & "' abgelegt." & vbCrLf & _
                "M|fffd|chten Sie die SEPA-XML-Datei trotzdem erstellen?", vbQuestion + vbYesNo) = vbYes Then
                Call x.create_sepa_xml
                
                If Me.chbSummary Then
                    Application.StatusBar = "Erstelle Deckblatt, bitte warten.."
                    oSummary.create_Summary
                    Application.StatusBar = vbNullString
                End If
            End If
            
            Set stream = Nothing
            Set fso = Nothing
        Else
            If MsgBox("Das Fehlerprotokoll wurde verworfen." & vbCrLf & _
                "M|fffd|chten Sie die SEPA-XML-Datei trotzdem erstellen?", vbQuestion + vbYesNo) = vbYes Then
                Call x.create_sepa_xml
                
                If Me.chbSummary Then
                    Application.StatusBar = "Erstelle Deckblatt, bitte warten.."
                    oSummary.create_Summary
                    Application.StatusBar = vbNullString
                End If
            End If
        End If
    Else
        Call x.create_sepa_xml
        
        If Me.chbSummary Then
            Application.StatusBar = "Erstelle Deckblatt, bitte warten.."
            oSummary.create_Summary
            Application.StatusBar = vbNullString
        End If
    End If
    
errorhandler:
    If Err.Number <> 0 Then
        MsgBox "Es ist leider ein Fehler aufgetreten" & vbCrLf & _
            "Fehler im Objekt: " & Err.Source & vbCrLf & _
            "Fehlerbeschreibung: " & Err.Description, vbCritical
    End If
    
    Set oSummary = Nothing
    Set oSummaryEntry = Nothing
    Set c = Nothing
    Set x = Nothing
End Sub

Private Sub fill_accounts()
    Dim cAccount As clsAccount
    
    For Each cAccount In cAccFact.get_Accounts
        Me.cmbAccount.AddItem cAccount.IBAN
    Next cAccount
End Sub

Private Function Clean_Input(ByVal sInput As String) As String
    sInput = Trim(sInput)
    Clean_Input = Replace(sInput, " ", "")
End Function
Attribute VB_Name = "functions"
Option Explicit

#If Win64 Then
    Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" ( _
        ByVal hwnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, _
        Optional ByVal lpParameters As String, Optional ByVal lpDirectory As String, Optional ByVal nShowCmd As Long) As LongPtr
#Else
    Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" ( _
        ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, _
        Optional ByVal lpParameters As String, Optional ByVal lpDirectory As String, Optional ByVal nShowCmd As Long) As Long
#End If


' InQuest injected base64 decoded content
' ~`ZrD
' "{-t	
' "{-t	
' '|'m
' '|'m
' '|'m
' '|'m
' z{b~'
' z{b~)

INQUEST-PP=macro
