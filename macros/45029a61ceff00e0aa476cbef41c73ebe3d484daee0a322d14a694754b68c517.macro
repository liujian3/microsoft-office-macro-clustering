Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'--------------------------
Private Sub Workbook_Open()
'--------------------------
  Sheets("Languages").Visible = False
  Update_Language_in_All_Pattern_Config_Sheets
  
  If ThisWorkbook.Sheets.Count = 2 Then ' Main & Language
    Load_AllExamples_Sheets
    Sheets("Main").Select
    Protect_Active_Sheet
    ActiveWindow.DisplayHeadings = False
    'Update_Grafik
  End If
  
End Sub
Attribute VB_Name = "M0_Revision_History"
' Revision History:
' ~~~~~~~~~~~~~~~~~
' 23.10.18: - Incremented FixedBytes to 11 per macro Update_All_FixedBytes
' 24.10.18: - Checking the number of channels (Max: 765)
'           - Checking the Flash Usage (Max 2000)
' 02.05.19: - Started saving and loading example sheets
' 07.05.19: - Started the graphical display of the LED states
' 14.05.19: - Goto grafik finished
' 15.05.19: - Added menue to save, load, delete sheets
' 20.05.19: - Corrected the Trend Grafic if 8 bits per value are used. Here "Wert Min/Max" are not used.
'           - Text constants could be used in the LED table if 8 bits per value are used
' 21.05.19: - Moved the LED table to the right to be able to change the column width of the LED columns
' 22.05.19: - Adapt the column with to the duartion if "D" is added to the "Grafische Anzeige" field
' 03.06.19: - Corrected "Set_LED_Val_8_Bit()" in case of empty cells
' 07.06.19: => Ver. 0.7.6
'           - Using the directory "Eigene Dokumente\MyPattern_Config_Examples" to store the files
' 19.06.19: - Support for Englisch added. Most of the Outputs are automatically shown in Englisch or German
'             depending of the Language settings in Excel and Windows.
' 24.06.19: - Still some messages which are not adapted to the language. They are marked with "ToDo: Language"
' 25.06.19: => Ver. 0.7.6
'           - Message that the columns with is limmited is cleared if no longer valid
' 26.06.19: - Translated some missing messages
' 27.06.19: - Finished the Example description
' 29.06.19: => Ver. 0.77
'           - Adapted to the different the decimal separators (Error loading Examples if german "," was used)
' 02.07.19: - Corrected the loading of pictures if a comma is used as decimal separator (German)
'             Checked all other lines in the MLL_pcf file for decimal points (LED_Attr, msoTextBox, msoPicture)
' 15.09.19: - Incremented the number of Duration entries from 20 to 30.
'           - Changed 'InNr' to 'InCh' in the geneated macro
' 19.10.19: - Corrected the loading of "Bold" the attribute in "Load_Textbox()"
'           - Save/Load buttons and ForeColor to the example file
'           - Added the morse code from Lorenz
'           - Support for 64 Bit office
'           => Ver. 0.78
' 21.10.19: - Cerrected the loading of buttons if the german comma is used
'           => Ver. 0.79
' 29.10.19: - Corrected comment in "Ergebnis" line: '\\' => '//'
'           => Ver. 0.82

Attribute VB_Name = "M1_Public_Constants_a_Variables"
Public Const MacEnab_Rng = "E1"         ' ??
Public Const LED_Cnt_Rng = "E5"         '
Public Const BitsVal_Rng = "E6"
Public Const WertMin_Rng = "E7"
Public Const WertMax_Rng = "E8"

Public Const AnaFade_Rng = "E11"
Public Const GotoMod_Rng = "E12"
Public Const GrafDsp_Rng = "E13"
Public Const Macro_N_Rng = "E17"
Public Const PARAMETER_RANGE = "D2:D17"
Public Const PARAMETER_Col = 4          ' Column D
Public Const PARAMETER_Ro11 = 2
Public Const PARAMETER_Ro1N = 20

Public Const Goto_Txt_col = 5           ' Column E            (Old 2 as constant in the code ;-( )

Public Const LED_Text_Col = 5           ' Column E            (Old 4 as constant in the code ;-( )

Public Const GrafDsp_Row = 13
Public Const GrafDsp_Col = 6            ' Column F            (Old 5)

Public Const FirstLEDTabRANGE = "E45"                     ' (Old "D45")
Public Const LEDsRANGE = "E45:EW299"                      ' (Old "D45:EV299")
Public Const Last_LEDsCol = 153         ' Column EW       ' (Old 152)
Public Const Last_LEDs_ChkAttrCol = 27  ' We just check the attributes of the first x LED columns       (Old 26)

Public Const Dauer_Row = 23
Public Const Dauer_Col1 = 6             ' Column F           (Old 5)

Public Const GoTo_Row = 42
Public Const GoTo_Col1 = 6              ' Column F           (Old 5)


' Proportional column width display in Adjust_Column_With_to_Duration()
' The quotiont Max_t / Min_t define the minimal column width.
Public Const NormWidth_MM = 4           ' If the quotient is below the normal column width (NormColWidth) is used for the small columns
Public Const Min_Width_MM = 50          ' If the quotient id greater the small columns are limmited to Min_ColWidth. In between the with is adapted proportional
Public Const NormColWidth = 6.71        ' Normal column width. Also used in Normal_Column_With
Public Const Min_ColWidth = 0.8         ' Minimal width


Public Const Transp_Start_Graph = 0.7

Public Const ExampleDir = "Pattern_Config_Examples"
Public Const MyExampleDir = "MyPattern_Config_Examples"

Public Const OVERWRITE_EXISTING_PIC = False
                           
Public Const pcfSep = 175         ' OEM char(MultiEdit): >>   Win: upperline (Line on top of the characters)


Public WertMinMaxValid As String  ' Contains the sheet name which is used to read WertMin and WertMax, ... from
Public WertMin As Integer
Public WertMax As Integer
Public BitsVal As Integer
Public LED_Scale As Double
Public LED_Offset As Double
Public StartMax As Double
Public StartMin As Double
Public SaveDirCreated As Boolean

Public ExampleName As String

Public Const StdDescStart = "Mit diesem Blatt kann die Konfiguration"
Public Const StdDescEdges = "491.25;0;767.4421;142.8818"

Public Button_Init_Proc_Finished As Boolean
Attribute VB_Name = "M2_Main"
Option Explicit

Const MAX_VARARGS = 2000 ' Limmitted by the COUNT_VARARGS macro in MobaLedLib.h

Const START_BIT = 128
Const POS_M_BIT = 64
Const GOTOENDNR = POS_M_BIT - 1
Const MAXGOTONR = GOTOENDNR - 1

Private OldMessage As String

'---------------------------------------------------------------------
Function Get_LED_Val(c As Variant, ByVal MaxVal As Integer) As Integer
'---------------------------------------------------------------------
  Dim val As Integer
  If c <> "" Then
    If IsNumeric(c) Then
         val = c.Value
         If val > MaxVal Then val = MaxVal
    Else
         Dim s As String
         s = Trim(c)
         If s = "" Or s = "." Or s = "-" Then
               val = 0
         Else: val = MaxVal
         End If
    End If
  End If
  Get_LED_Val = val
End Function

'----------------------------------------------------------------------------------
Private Function Get_LED_Val_8_Bit(c As Variant, ByVal MaxVal As Integer) As String
'----------------------------------------------------------------------------------
  Dim val As Integer
  If c <> "" Then
    If IsNumeric(c) Then
         val = c.Value
         If val > MaxVal Then val = MaxVal
         Get_LED_Val_8_Bit = val
    Else
         Dim s As String
         s = Trim(c)
         If s = "" Or s = "." Or s = "-" Then
            Get_LED_Val_8_Bit = 0
         ElseIf Len(s) > 1 Then
            Get_LED_Val_8_Bit = s
         Else
            Get_LED_Val_8_Bit = MaxVal
         End If
    End If
  Else: Get_LED_Val_8_Bit = 0                                               ' 03.06.19:
  End If
End Function

'--------------------------------------------------------------------------------------------------------------
Private Function Calc_DecStr_Normal(Rng As Range, LastRow As Long, MaxColumn As Long, BitLen As Long) As String
'--------------------------------------------------------------------------------------------------------------
  Dim ColCnt As Long, c As Range
  Dim col As Range, Bits As String, MaxVal As Integer
  MaxVal = (2 ^ BitLen) - 1
  For Each col In Rng.Columns
      If col.Column > MaxColumn Then Exit For
      ColCnt = ColCnt + 1
      Dim Cnt As Long
      For Each c In col.Cells
          If c.Row > LastRow Then Exit For
          'Debug.Print "R:" & c.Row & "  C:" & c.Column
          If c.Value <> "" Then Cnt = Cnt + 1
          Dim val As Integer
          val = Get_LED_Val(c, MaxVal)                                                ' 07.05.19: Extracted calculation to separate function
          Bits = WorksheetFunction.Dec2Bin(val, BitLen) + Bits
      Next c
  Next col
  
  Dim BitCnt As Long, ByteCnt As Long
  BitCnt = Len(Bits)
  'Debug.Print Len(Bits) & ": " & Bits & "  "   ' Debug
  Dim DecStr As String
  While Len(Bits) > 0
     ByteCnt = ByteCnt + 1
     DecStr = DecStr & "," & WorksheetFunction.Bin2Dec(Right(Bits, 8))
     If Len(Bits) > 8 Then
           Bits = Left(Bits, Len(Bits) - 8)
     Else: Bits = ""
     End If
  Wend
  'Debug.Print "Used bytes: " & ByteCnt
  If ByteCnt > MAX_VARARGS Then
     MsgBox Get_Language_Str("Error: Number of used bytes to high !") & MAX_VARARGS & Get_Language_Str(" bytes are possible.") & vbCr & _
            "The current configuration uses " & ByteCnt & " bytes ;-(", vbCritical, _
            Get_Language_Str("Error to many bytes used")
  End If
  'Debug.Print DecStr      ' Debug
  
  Dim FreeBits As Long
  FreeBits = ByteCnt * 8 - BitCnt
  Calc_DecStr_Normal = FreeBits & ":" & DecStr
End Function


'--------------------------------------------------------------------------------------------------------------
Private Function Calc_DecStr_8_Bits(Rng As Range, LastRow As Long, MaxColumn As Long, BitLen As Long) As String   ' 20.05.19
'--------------------------------------------------------------------------------------------------------------
  Dim ColCnt As Long, c As Range, col As Range, MaxVal As Integer, DecStr As String, BitCnt As Long, ByteCnt As Long
  MaxVal = (2 ^ BitLen) - 1
  For Each col In Rng.Columns
      If col.Column > MaxColumn Then Exit For
      ColCnt = ColCnt + 1
      Dim Cnt As Long
      For Each c In col.Cells
          If c.Row > LastRow Then Exit For
          'Debug.Print "R:" & c.Row & "  C:" & c.Column
          If c.Value <> "" Then Cnt = Cnt + 1
          DecStr = DecStr & "," & Get_LED_Val_8_Bit(c, MaxVal)
          ByteCnt = ByteCnt + 1
      Next c
  Next col

  If ByteCnt > MAX_VARARGS Then
     MsgBox Get_Language_Str("Error: Number of used bytes to high !") & MAX_VARARGS & Get_Language_Str(" bytes are possible.") & vbCr & _
            Get_Language_Str("The current configuration uses ") & ByteCnt & " bytes ;-(", vbCritical, _
            Get_Language_Str("Error to many bytes used")
  End If
  
  Calc_DecStr_8_Bits = "0:" & DecStr  ' 0 Free bits
End Function

'-------------------------------------------------------------------------------------------------------------
Function CalculatePattern(ChannelsRange As Variant, BitLenRange As Variant, PatternRange As Variant) As String
'-------------------------------------------------------------------------------------------------------------
' The first character contains the number of free bits which is needed for the calculation
' of the number of states in the Arduino program
  Dim Rng As Range, Channels As Long, BitLen As Long
  ' ToDo: |fffd|bergebene Variablen Typen pr|fffd|fen...
  Channels = ChannelsRange
  BitLen = BitLenRange
  Set Rng = PatternRange
  Dim FirstRow As Long, LastRow As Long, MaxVal As Integer
  FirstRow = Rng.Row
  LastRow = FirstRow + Channels - 1
  MaxVal = (2 ^ BitLen) - 1
  Dim c As Range, MaxColumn As Long
  
  MaxColumn = LastFilledColumn(Rng, LastRow) ' Find the last used column
  '' Find the last used column
  'For Each c In Rng
  '    If c.Row > LastRow Then Exit For
  '    If IsFilled(c) And c.Column > MaxColumn Then MaxColumn = c.Column
  'Next c
  
  If BitLen < 8 Then
        CalculatePattern = Calc_DecStr_Normal(Rng, LastRow, MaxColumn, BitLen)
  Else: CalculatePattern = Calc_DecStr_8_Bits(Rng, LastRow, MaxColumn, BitLen)
  End If
End Function


'--------------------------------------------------------------------------------------------------------------------------------------
Function Calculate_Goto(ChannelsRange As Variant, GotoModeRange As Variant, GotoTabRange As Variant, PatternRange As Variant) As String
'--------------------------------------------------------------------------------------------------------------------------------------
  If GotoModeRange <> 1 Then Exit Function
  
  Dim Rng As Range, Channels As Long
  ' ToDo: |fffd|bergebene Variablen Typen pr|fffd|fen...
  Channels = ChannelsRange
  Set Rng = PatternRange
  Dim FirstRow As Long, LastRow As Long
  FirstRow = Rng.Row
  LastRow = FirstRow + Channels - 1
  
  Dim MaxColumn As Long
  MaxColumn = LastFilledColumn(Rng, LastRow) ' Find the last used column
  Calculate_Goto = "  " ' Separator for debugging
  
  Dim c As Range, ColumnNr As Long
  Dim Unknown As String, WrongNumberFound As String
  For Each c In GotoTabRange
      ColumnNr = ColumnNr + 1
      If c.Column > MaxColumn Then Exit For
      Dim Words() As String, w As Variant, Start As Boolean, GotoP As Boolean, GoEnd As Boolean, Pos_M As Boolean, Number As Integer
      Start = False
      GotoP = False
      GoEnd = False
      Pos_M = False
      Number = 0
      Words = Split(Replace(Replace(Replace(Replace(Replace(UCase(c), "-", " - "), "S", " S "), "P", " P "), "E", " E "), "G", " G "), " ")
      For Each w In Words
        Select Case w
          Case "":   ' Nothing
          Case "S":  Start = True
          Case "P":  Pos_M = True
          Case "G":  GotoP = True
          Case "E":  GoEnd = True
          Case Else: ' Check if its a number
                     If IsNumeric(w) Then
                          Number = val(w)
                     Else
                          Unknown = Unknown & " '" & w & "'"
                     End If
          
        End Select
      Next w
      Dim Nr As Integer
      Nr = 0
      If Start Then Nr = Nr + START_BIT
      If Pos_M Then Nr = Nr + POS_M_BIT
      If GotoP Then
         If Number <= 0 Or Number > MAXGOTONR Then
               WrongNumberFound = WrongNumberFound & ", " & ColumnNr
         Else: Nr = Nr + Number
         End If
      ElseIf GoEnd Then
         Nr = Nr + GOTOENDNR
      End If
      'Debug.Print Format(ColumnNr, "@@@") & ": Nr=" & Format(Nr, "@@@") & "  Start=" & Format(Start, "@@@@@@@") & " GoEnd=" & Format(GoEnd, "@@@@@@@") & " Goto=" & Format(GotoP, "@@@@@@@") & " " & Number ' Debug
      Calculate_Goto = Calculate_Goto & "," & Nr
  Next c
  If WrongNumberFound <> "" Then WrongNumberFound = Mid(WrongNumberFound, 2) ' Remove leading ","
  
  'Debug.Print ' Debug
  Dim Message As String
  If Unknown <> "" Then Message = Message & Get_Language_Str("Ignored expresions: ") & Unknown & vbCr
  If WrongNumberFound <> "" Then Message = Message & Get_Language_Str("Falsche oder fehlende Nummer in Spalte gefunden: ") & WrongNumberFound & vbCr & _
                                                     Get_Language_Str("(G|fffd|ltiger Bereich: 1..63)")
  If Message <> OldMessage Then
     OldMessage = Message
     If Message <> "" Then MsgBox Message, vbOKOnly, Get_Language_Str("Problems in Goto tabele:")
  End If
  'Debug.Print Message
End Function

'---------------------------------------------------
Public Sub Update_Grafik_from_Str(GrafDsp As String)
'---------------------------------------------------
  Dim OldUpdating As Boolean
  OldUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
    
    
  ' Check the "Grafische Anzeige:" field
  Dim GrafDsp_U As String, Show_AnalogTrend As Boolean, Show_Goto_Graph As Boolean, Show_CorrectWidth As Boolean
  GrafDsp_U = UCase(GrafDsp)
    
  If InStr(GrafDsp_U, "1") > 0 Then
     Show_AnalogTrend = True
     Show_Goto_Graph = True
  End If
    
  If InStr(GrafDsp_U, "L") > 0 Then Show_AnalogTrend = True
  If InStr(GrafDsp_U, "G") > 0 Then Show_Goto_Graph = True
  If InStr(GrafDsp_U, "D") > 0 Then Show_CorrectWidth = True
       
  If Show_CorrectWidth Then
        Adjust_Column_With_to_Duration
  Else: Normal_Column_With
  End If
    
    
  If Show_AnalogTrend Then
        Draw_Analog_Trend_of_Sheet
  Else: Del_Analog_Trend_Objects
  End If
    
  If Show_Goto_Graph Then
        Draw_All_Arrows
  Else: Delete_Goto_Graph
  End If
    
  Application.ScreenUpdating = OldUpdating
End Sub


'--------------------------------------------------------------
Public Sub Global_Worksheet_Change(ByVal Target As Excel.Range)
'--------------------------------------------------------------
' This function is called if the worksheet is changed.
' It performs several checks after a user input depending form the column of the changed cell:

    If Target.CountLarge <= 1 Then
       Hide_Show_GotoLines_If_Enabled
       Update_Grafik_from_Str Range(GrafDsp_Rng)
    End If
    
End Sub

'---------------------
Public Sub Main_Menu()
'---------------------
  MainMenu_Form.Show
End Sub


Attribute VB_Name = "M3_Analog_Trend"
Option Explicit

Private Const Is_Reachable = 1
Private Const Is_Goto1_Col = 2
Private Const Is_Start_Col = 10

Public Reachable_Col() As Integer  ' Values see above
Public Came_From_Col() As Integer
Public PosColArray() As Long
Public PosList As String

#Const Debug_Reachable = False

'------------------------------------------------------------------------------------------------------------------------------------
Sub Draw_Analog_Trend(c As Variant, ByVal h1 As Double, ByVal h2 As Double, rgb As MsoRGBType, Optional Transparency As Double = 0.5)
'------------------------------------------------------------------------------------------------------------------------------------
  Dim x1 As Double, y0 As Double, x2 As Double, y1 As Double, y2 As Double
  If h1 = 0 And h2 = 0 Then Exit Sub
  With c
    If h1 = h2 Then
      If h1 * .Height < 1 Then h1 = 1 / .Height ' Make small rects visible
      If h2 * .Height < 1 Then h2 = 1 / .Height
    Else
      If h1 > h2 Then
         If h1 * .Height < 1 Then h1 = 1 / .Height ' Make small triangles visible
      Else
         If h2 * .Height < 1 Then h2 = 1 / .Height
      End If
    End If
    x1 = .Left
    y0 = .Top + .Height
    x2 = .Left + .Width
    y1 = .Top + .Height * (1 - h2)
    y2 = .Top + .Height * (1 - h1)
  End With
    With ActiveSheet.Shapes.BuildFreeform(msoEditingAuto, x1, y0)
        .AddNodes msoSegmentLine, msoEditingAuto, x2, y0
        .AddNodes msoSegmentLine, msoEditingAuto, x2, y1
        .AddNodes msoSegmentLine, msoEditingAuto, x1, y2
        .ConvertToShape.Select
    End With
    With Selection.ShapeRange
      .Line.Visible = msoFalse
      .Name = "Analog_Trend"
      With .Fill
        .ForeColor.rgb = rgb
        .Transparency = Transparency
      End With
    End With
    Selection.OnAction = "'Click_TrendGrafik """ & c.Row & " " & c.Column & """'" ' To be able to move the cursor to the selected cell
End Sub

'--------------------------------------------------------------------------
Private Function Get_Avg_LED_Raw(r As Variant, MaxVal As Integer) As Double
'--------------------------------------------------------------------------
  Dim c As Variant, val As Double
  For Each c In r
     val = val + Get_LED_Val(c, MaxVal)
  Next c
  Get_Avg_LED_Raw = val / r.Count
End Function

'--------------------------
Sub Check_WertMinMaxValid()
'--------------------------
  If ActiveSheet.Name <> WertMinMaxValid Then
     WertMinMaxValid = ActiveSheet.Name
     If Range(BitsVal_Rng) < 8 Then
          WertMin = Range(WertMin_Rng)
          WertMax = Range(WertMax_Rng)
     Else ' If 8 bits are used WertMin and WertMax are not used
          WertMin = 0
          WertMax = 255
     End If
     BitsVal = (2 ^ Range(BitsVal_Rng)) - 1
     LED_Scale = (WertMax - WertMin) / BitsVal
     LED_Offset = WertMin
     StartMax = WertMax / 255
     StartMin = WertMin / 255
  End If
End Sub

'-------------------------------------------------------
Private Function Get_Avg_LED_Val(r As Variant) As Double
'-------------------------------------------------------
  Get_Avg_LED_Val = Get_Avg_LED_Raw(r, BitsVal) * LED_Scale + LED_Offset
End Function


'-----------------------------------------------------------------
Private Function Color_to_RGBColor(colorVal As Long) As MsoRGBType
'-----------------------------------------------------------------
' Convert a color given as a long number to a MsoRGBType
  Color_to_RGBColor = rgb((colorVal Mod 256), ((colorVal \ 256) Mod 256), (colorVal \ 65536))
End Function


' Anzeige im GoTo-Mode:
' ~~~~~~~~~~~~~~~~~~~~~
' Wenn der GoTo Mode aktiviert ist, und "Analoges |fffd|berblenden" = X ist,
' dann h|fffd|ngt das Bild von der GotoZeile (GoTo_Row) ab.
' Wenn die entsprechende Spalte angesprungen werden kann, dann h|fffd|ngt
' die Start Helligkeit von der ltzen Spalte ab. Zur darstellung werden
' zwei |fffd|berlagerte Dreiecke verwendet. Das eine kommt von 0, das andere von 100%
' Folgende Eintr|fffd|ge in der GoTo Tabelle markieren eine Spalte welche angesprungen
' werden kann:
'  - Erste Spalte
'  - 'S' = Startsplate
'  - 'P' = Position f|fffd|r Goto
'
' Besonderheit:
' Wenn die vorangegangene Spalte ein 'E' enth|fffd|lt, und die aktuelle Spalte
' keine Startspalte ist, dann kann sie nicht angesprungen werden.
' => Hier wird nichts angezeigt

'-------------------------------------------------------------
Public Function Get_Number_from_Str(ByVal c As String) As Long
'-------------------------------------------------------------
    Dim NrStr As String, i As Long
    For i = 1 To Len(c)
       If IsNumeric(Mid(c, i, 1)) Then
            NrStr = NrStr + Mid(c, i, 1)
       Else
            If NrStr <> "" Then Exit For ' First not numeric character after prior numeric characters
       End If
    Next i
  If NrStr = "" Then
        Get_Number_from_Str = -1
  Else: Get_Number_from_Str = val(NrStr)
  End If
End Function


'---------------------------------------
Private Sub Update_Following(r As Range)
'---------------------------------------
  Dim c As Variant, val As String
  For Each c In r
     val = UCase(c.Offset(0, -1))
     If Reachable_Col(c.Column - GoTo_Col1) > 0 Or InStr(val, "G") > 0 Or InStr(val, "E") > 0 Then Exit For
     
     Reachable_Col(c.Column - GoTo_Col1) = Is_Reachable
     #If Debug_Reachable Then
       c.Offset(1, 0).Value = c.Offset(1, 0).Value + "+" ' Debug
     #End If
  Next
End Sub

'---------------------------
Sub Calc_Reachable_Columns()
'---------------------------
' Generate an array which contains marks for all reachable columns
' A column is reachable if
' - it's the first column
' - it's marked with 'S' = Startcolumn
' - prior columns are reachable and don't contain an 'G'= Goto or 'E' = End
' - it contains a 'P' which is reached from a reachable column
  Dim c As Variant, LastCol As Long, i As Long, GotoCells As Range, val As String
  Dim PosCnt As Long
  Dim FirstLEDsRow As Long, LastLEDsRow As Long, LastLEDsCol As Long, ArraySize As Long
  FirstLEDsRow = Range(FirstLEDTabRANGE).Row
  LastLEDsRow = FirstLEDsRow + Range(LED_Cnt_Rng) - 1
  LastLEDsCol = LastFilledColumn(Range(LEDsRANGE), LastLEDsRow) ' Find the last used column
  
  LastCol = LastUsedColumnInRow(ActiveSheet, GoTo_Row)
  If LastLEDsCol > LastCol Then LastCol = LastLEDsCol
  ArraySize = LastCol - GoTo_Col1 + 1
  If ArraySize <= 0 Then Exit Sub
  ReDim Reachable_Col(ArraySize)
  ReDim Came_From_Col(ArraySize)
  
  If Range(GotoMod_Rng) <> "1" Then
     For i = 0 To ArraySize
        Reachable_Col(i) = Is_Reachable
     Next
     Exit Sub
  End If

  #If Debug_Reachable Then
     Dim OldEvents As Boolean
     OldEvents = Application.EnableEvents
     Application.EnableEvents = False
  #End If
  
  PosList = " "

  Set GotoCells = Range(Cells(GoTo_Row, GoTo_Col1), Cells(GoTo_Row, LastCol))
  For Each c In GotoCells
      val = UCase(c)
      If InStr(val, "P") > 0 Then
         ReDim Preserve PosColArray(PosCnt + 1)
         PosColArray(PosCnt) = c.Column
         PosCnt = PosCnt + 1
         PosList = PosList & PosCnt & " "
      End If
      If i = 0 Or InStr(val, "S") > 0 Then
         Reachable_Col(i) = Is_Start_Col
      Else
         Dim PriorGotoVal As String
         PriorGotoVal = UCase(Cells(GoTo_Row, c.Column - 1))
         If Reachable_Col(i - 1) > 0 Then
            If InStr(PriorGotoVal, "G") = 0 _
               And InStr(PriorGotoVal, "E") = 0 Then
               Reachable_Col(i) = Is_Reachable
            End If
         End If
      End If
      #If Debug_Reachable Then
        With Cells(GoTo_Row + 1, c.Column) ' debug
          If Reachable_Col(i) > 0 Then .Value = "r" Else .Value = ""
        End With
      #End If
      i = i + 1
  Next c
  
  
  ' Check the goto entries
  Dim Updated As Boolean
  Do
    i = 0
    Updated = False
    For Each c In GotoCells
        val = UCase(c)
        If Reachable_Col(i) > 0 Then
           If InStr(val, "G") > 0 Then
              Dim p As Long
              p = Get_Number_from_Str(val)
              If p > 0 And InStr(PosList, " " & p & " ") > 0 Then
                 Dim ArrayPos As Long
                 ArrayPos = PosColArray(p - 1) - GoTo_Col1
                 If Reachable_Col(ArrayPos) = 0 Then
                      Updated = True
                      If PosColArray(p - 1) + 1 <= LastCol Then ' Other columns following ?
                         Update_Following Range(Cells(GoTo_Row, PosColArray(p - 1) + 1), Cells(GoTo_Row, LastCol))
                      End If
                      Reachable_Col(ArrayPos) = Is_Goto1_Col
                      Came_From_Col(ArrayPos) = c.Column
                      #If Debug_Reachable Then
                        Cells(GoTo_Row + 1, PosColArray(p - 1)) = "G1" ' debug
                      #End If
                 Else ' Was reachable before
                      If Came_From_Col(ArrayPos) <> c.Column Then
                         Reachable_Col(ArrayPos) = Is_Start_Col
                         #If Debug_Reachable Then
                            Cells(GoTo_Row + 1, PosColArray(p - 1)) = "R" ' debug
                         #End If
                      End If
                 End If
                 
              End If
           End If
        End If
        i = i + 1
    Next c
  Loop Until Updated = False
  
  #If Debug_Reachable Then
  ' Debug Check Reachable_Col()
  i = 0
  For Each c In GotoCells
    If (Reachable_Col(i) > 0) <> (c.Offset(1, 0) <> "") Then
       c.Offset(1, 0).Select
       MsgBox "Error Reachable_Col(" & i & ") <> Debug Line (See selected cell)"
    End If
    If Reachable_Col(i) = Is_Start_Col Then c.Offset(1, 0).Value = "S" & c.Offset(1, 0).Value
    i = i + 1
  Next
  Application.EnableEvents = OldEvents
  #End If
  
End Sub

'--------------------------------------------------------------------------------------------------------
Private Sub Draw_GotoMode_Symbol(cc As Range, LastVal As Double, ActVal As Double, rgb_col As MsoRGBType)
'--------------------------------------------------------------------------------------------------------
  Dim ArrayPos As Long, val As Long, CameFrom_R As Range
  ArrayPos = cc.Column - GoTo_Col1
  Select Case Reachable_Col(ArrayPos)
    Case Is_Start_Col: Draw_Analog_Trend cc, StartMin, ActVal / 255, rgb_col
                       Draw_Analog_Trend cc, StartMax, ActVal / 255, rgb_col, Transp_Start_Graph
    Case Is_Goto1_Col: Set CameFrom_R = Range(Cells(cc.Row, Came_From_Col(ArrayPos)), Cells(cc.Row + cc.Rows.Count - 1, Came_From_Col(ArrayPos)))
                       'CameFrom_R.Select ' Debug
                       val = Get_Avg_LED_Val(CameFrom_R)
                       Draw_Analog_Trend cc, val / 255, ActVal / 255, rgb_col
    Case Else:         Draw_Analog_Trend cc, LastVal / 255, ActVal / 255, rgb_col
  End Select
End Sub



'----------------------------------------
Private Sub Line_Analog_Trend(r As Range)
'----------------------------------------
' Generate a analog trend picture for the given range.
' The picture is a rectangle, a triangle or a one sided trapeze.
' The range could be one row or several rows.
' If several rows are given the average value of one column is used.
' Uses the fill color of the left cell next to the given range
' or yellow if the cell is not filled.
  Dim c As Variant, rgb_col As MsoRGBType
  Dim ActVal As Double, LastVal As Double, LastRow As Long, LastCol As Long, AnaFade As Integer, GotoMod As Boolean
  
  With Cells(r.Row, r.Column - 1) ' Read the interior color
    If .Interior.Color <> 16777215 Then
         rgb_col = Color_to_RGBColor(.Interior.Color)
    Else
         rgb_col = rgb(255, 255, 0)
    End If
  End With
  
  Check_WertMinMaxValid ' Make sure that the constants WertMin, WertMax, BitsVal, LED_Scale, LED_Offset are valid
  
  LastRow = r.Rows.Count - 1
  LastCol = r.Columns.Count - 1
  LastVal = Get_Avg_LED_Val(Range(Cells(r.Row, r.Column + LastCol), Cells(r.Row + LastRow, r.Column + LastCol)))
  Select Case UCase(Range(AnaFade_Rng))
     Case "1": AnaFade = 1
     Case "X": AnaFade = 2
  End Select
  GotoMod = Range(GotoMod_Rng) = "1"
  
  For Each c In r
     If c.Row = r.Row Then
        Dim cc As Range ' All Cells in the column
        Set cc = Range(c, c.Offset(LastRow, 0))
        ActVal = Get_Avg_LED_Val(cc)
        If c.Column - GoTo_Col1 >= 0 Then                                   ' 25.6.19:
            If Reachable_Col(c.Column - GoTo_Col1) > 0 Then
                If GotoMod And AnaFade = 2 Then
                     Draw_GotoMode_Symbol cc, LastVal, ActVal, rgb_col
                Else
                     If AnaFade = 0 Then LastVal = ActVal
                     Draw_Analog_Trend cc, LastVal / 255, ActVal / 255, rgb_col
                End If
            End If
        End If
        LastVal = ActVal
     End If
  Next c
End Sub

'--------------------------------------------------
Private Function IsLEDGroup(Row As Long) As Boolean
'--------------------------------------------------
  Dim r As Long, col As Long, FillCol As MsoRGBType
  col = Range(FirstLEDTabRANGE).Column
  FillCol = Cells(Row, col).Interior.Color
  If FillCol = 16777215 Then Exit Function
  For r = Row + 1 To Row + 2
    If Cells(r, col).Interior.Color <> FillCol Then Exit Function
  Next
 IsLEDGroup = True
End Function

'--------------------------------------
Public Sub Draw_Analog_Trend_of_Sheet()
'--------------------------------------
  Dim WasProtected As Boolean
  WasProtected = ActiveSheet.ProtectContents
  If WasProtected Then ActiveSheet.Unprotect
  
  Dim OldUpdating As Boolean, LastSel As Variant
  Set LastSel = ActiveCell
  OldUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  WertMinMaxValid = "" ' To read WertMin and WertMax, ... from the sheet again
  
  
  Dim FirstLEDsRow As Long, FirstLEDsCol As Long, LastLEDsRow As Long, LastLEDsCol As Long, Row As Long
  FirstLEDsRow = Range(FirstLEDTabRANGE).Row
  FirstLEDsCol = Range(FirstLEDTabRANGE).Column + 1
  LastLEDsRow = FirstLEDsRow + Range(LED_Cnt_Rng) - 1
  LastLEDsCol = LastFilledColumn(Range(LEDsRANGE), LastLEDsRow) ' Find the last used column
  
  Del_Analog_Trend_Objects
  
  If LastLEDsCol > 0 Then ' Is anything entered in the LEDs table ?
    Calc_Reachable_Columns
    
    For Row = FirstLEDsRow To LastLEDsRow
        If (Row - FirstLEDsRow) Mod 3 = 0 And IsLEDGroup(Row) Then
             Line_Analog_Trend Range(Cells(Row, FirstLEDsCol), Cells(Row + 2, LastLEDsCol))
             Row = Row + 2
        Else
             Line_Analog_Trend Range(Cells(Row, FirstLEDsCol), Cells(Row, LastLEDsCol))
        End If
    Next Row
  End If
  Application.ScreenUpdating = OldUpdating
  LastSel.Select
  
  If WasProtected Then Protect_Active_Sheet
End Sub

'UT------------------------------------------
Private Sub Test_Draw_Analog_Trend_of_Sheet()
'UT------------------------------------------
  Dim Start
  Start = Timer
  Draw_Analog_Trend_of_Sheet
  Debug.Print "Duration: " & Round(Timer - Start, 2)
End Sub

'------------------------------------
Public Sub Del_Analog_Trend_Objects()
'------------------------------------
  Dim WasProtected As Boolean
  WasProtected = ActiveSheet.ProtectContents
  If WasProtected Then ActiveSheet.Unprotect

  Dim o As Variant
  For Each o In ActiveSheet.Shapes
    If o.Type = msoFreeform And Left(o.Name, Len("Analog_Trend")) = "Analog_Trend" Then o.Delete
  Next o
  If WasProtected Then Protect_Active_Sheet
End Sub

'------------------
Sub Update_Grafik()
'------------------
' Is called if the "Aktualisieren" Button is pressed
  Application.EnableEvents = True ' In case it was disabled prior due to a bug
  If IsAltKeyDown() Then
        Update_Grafik_from_Str ""
  Else
       If Range(GrafDsp_Rng) <> "" Then
             Update_Grafik_from_Str Range(GrafDsp_Rng)
       Else: Update_Grafik_from_Str "1"
       End If
  End If
End Sub

'--------------------------------------
Public Sub Click_TrendGrafik(Txt As String)
'--------------------------------------
' This function is called if the user clics to the trend grafic if the sheet is protected
' Since the Grafic overlaps the cell there is no oter way to select the cell with the mouse
  Dim Par() As String
  Par = Split(Txt, " ")
  Cells(val(Par(0)), val(Par(1))).Select
End Sub
Attribute VB_Name = "M3_Column_With"
Option Explicit

'-----------------------------------------------------------------------------------------------
Private Function Get_Duration(c As Range, ByRef FirstEmptyCol As Long, Values() As Long) As Long
'-----------------------------------------------------------------------------------------------
  
  If c.Value = "" Then
       If FirstEmptyCol = 0 Then FirstEmptyCol = c.Column
       Get_Duration = Values((c.Column - FirstEmptyCol) Mod (FirstEmptyCol - Dauer_Col1))
  Else
       Dim v As Double, s As String
       s = c.Value
       v = val(s)
       If InStr(s, "Sec") > 0 Or InStr(s, "Sek") > 0 Or InStr(s, "sec") > 0 Or InStr(s, "sek") > 0 Then
          v = v * 1000
       ElseIf InStr(s, "Min") > 0 Then
          v = v * 60 * 1000
       End If
       Get_Duration = v
  End If
End Function



'------------------------------------------
Public Sub Adjust_Column_With_to_Duration()
'------------------------------------------
  Dim FirstLEDsRow As Long, LastLEDsRow As Long, LastLEDsCol As Long, col As Long
  FirstLEDsRow = Range(FirstLEDTabRANGE).Row
  LastLEDsRow = FirstLEDsRow + Range(LED_Cnt_Rng) - 1
  LastLEDsCol = LastFilledColumn(Range(LEDsRANGE), LastLEDsRow) ' Find the last used column
  
  Dim ms As Long, Min_t As Long, Max_t As Long, Values() As Long, i As Long, FirstEmptyCol As Long
  ReDim Values(LastLEDsCol - Dauer_Col1)
  Min_t = 999999
  For col = Dauer_Col1 To LastLEDsCol
    With Cells(Dauer_Row, col)
      ms = Get_Duration(Cells(Dauer_Row, col), FirstEmptyCol, Values)
      Values(i) = ms
      i = i + 1
      If ms > Max_t Then Max_t = ms
      If ms < Min_t Then Min_t = ms
    End With
  Next col
  
  If Max_t = Min_t Then
     Normal_Column_With
     Exit Sub
  End If
  
  If Min_t = 0 Then
     MsgBox Get_Language_Str("Error in function 'Adjust_Column_With_to_Duration' ;-(")
     Normal_Column_With
     Exit Sub
  End If
  
  Dim WasProtected As Boolean
  WasProtected = ActiveSheet.ProtectContents
  If WasProtected Then ActiveSheet.Unprotect
  
  Dim Min_Width As Double, Max_width As Double, Max2Min As Double
  'Debug.Print "Max_t / Min_t =  " & Max_t / Min_t 'Debug
  Max2Min = Max_t / Min_t
  If Max2Min < NormWidth_MM Then
     Min_Width = NormColWidth
  ElseIf Max2Min > Min_Width_MM Then
     Min_Width = Min_ColWidth
  Else
     Dim m As Double, b As Double
     m = (NormColWidth - Min_ColWidth) / (NormWidth_MM - Min_Width_MM)
     b = NormColWidth - m * NormWidth_MM
     Min_Width = m * Max2Min + b
  End If
  
  Max_width = Min_Width * Max_t / Min_t
  Dim ScaleF As Double
  ScaleF = (Max_width - Min_Width) / (Max_t - Min_t)
  
  Application.StatusBar = ""
  Dim MessageShown As Boolean
  i = 0
  For col = Dauer_Col1 To LastLEDsCol
    With Cells(Dauer_Row, col)
      ms = Values(i)
      i = i + 1
      Dim w As Double
      w = (ms - Min_t) * ScaleF + Min_Width
      If w > 100 Then
         w = 100 ' Maximal width in excel is limmited to 255
         If Not MessageShown Then Application.StatusBar = Get_Language_Str("Achtung die Darstellung der Spaltenbreite wurde begrenzt")
         MessageShown = True
      End If
      .ColumnWidth = w
    End With
  Next col
  If Not MessageShown Then
     If Application.StatusBar = Get_Language_Str("Achtung die Darstellung der Spaltenbreite wurde begrenzt") Then
        Application.StatusBar = ""
     End If
  End If
  If WasProtected Then Protect_Active_Sheet
End Sub

'UT------------------------
Private Sub Test_MaxWidth()
'UT------------------------
Dim i As Long
  With Cells(1, 7)
    For i = 250 To 260
       .ColumnWidth = i
    Next
  End With
End Sub

'------------------------------
Public Sub Normal_Column_With()
'------------------------------
  Dim WasProtected As Boolean
  WasProtected = ActiveSheet.ProtectContents
  If WasProtected Then ActiveSheet.Unprotect
  
  Dim FirstLEDsRow As Long, LastLEDsRow As Long, LastLEDsCol As Long, col As Long
  FirstLEDsRow = Range(FirstLEDTabRANGE).Row
  LastLEDsRow = FirstLEDsRow + Range(LED_Cnt_Rng) - 1
  LastLEDsCol = LastFilledColumn(Range(LEDsRANGE), LastLEDsRow) ' Find the last used column
  
  For col = Dauer_Col1 To LastLEDsCol
    With Cells(Dauer_Row, col)
      If .ColumnWidth <> NormColWidth Then .ColumnWidth = NormColWidth
    End With
  Next col
  Application.StatusBar = ""

  If WasProtected Then Protect_Active_Sheet
End Sub


Attribute VB_Name = "M3_Goto_Gr_Calc_Height"
Option Explicit

Type GotoListEntry_t
  Start As Long
  Ende As Long
  Min As Long
  Max As Long
  Dist As Long
  Inside_Cnt As Long
  OutsideCnt As Long
End Type



' Different arangements:
'
'   |     |  |         |   |  |  |     |    |  |    |
'   |\____/  |         |   |  |  |     |    |  |    |
'   \________/         \___\__/__/     \____/  \____/
'

'----------------------------------------------------------------------------
Public Function Calc_Height_GotoArrow(ByVal GotoArrowTab As String) As String
'----------------------------------------------------------------------------
  ' Fill the array
  Dim StrEnt As Variant, GotoList() As GotoListEntry_t, StrArray() As String, Nr As Long
  StrArray = Split(GotoArrowTab, " ")
  ReDim GotoList(UBound(StrArray))
  For Each StrEnt In StrArray
     Dim Cols() As String
     Cols = Split(StrEnt, ",")
     GotoList(Nr).Start = val(Cols(0))
     GotoList(Nr).Ende = val(Cols(1))
     If GotoList(Nr).Start < GotoList(Nr).Ende Then
           GotoList(Nr).Min = GotoList(Nr).Start
           GotoList(Nr).Max = GotoList(Nr).Ende
     Else: GotoList(Nr).Min = GotoList(Nr).Ende
           GotoList(Nr).Max = GotoList(Nr).Start
     End If
     GotoList(Nr).Dist = Abs(GotoList(Nr).Start - GotoList(Nr).Ende)
     Nr = Nr + 1
  Next
  
  ' Calc Inside_Cnt and OutsideCnt
  Dim A As Long, t As Long
  For A = 0 To UBound(GotoList)
      Dim Min As Long, Max As Long
      Min = GotoList(A).Min
      Max = GotoList(A).Max
      For t = 0 To UBound(GotoList)
          If A <> t Then
             If GotoList(t).Min <= Min And GotoList(t).Max >= Max Then
                GotoList(A).OutsideCnt = GotoList(A).OutsideCnt + 1
             ElseIf GotoList(t).Min >= Min And GotoList(t).Max <= Max Then
                GotoList(A).Inside_Cnt = GotoList(A).Inside_Cnt + 1
             End If
          End If
      Next t
  Next A
  
  Dim res As String
  For Nr = 0 To UBound(GotoList)
    Dim h As Double
    h = (1 + GotoList(Nr).Inside_Cnt) / (GotoList(Nr).OutsideCnt + GotoList(Nr).Inside_Cnt + 1)
    res = res & GotoList(Nr).Start & "," & GotoList(Nr).Ende & "," & h & " "
  Next Nr
  
  Calc_Height_GotoArrow = Left(res, Len(res) - 1)
  
End Function


'UT-------------------------
Private Sub Test_GotoArrow()
'UT-------------------------
  Dim List_w_Height As String
  List_w_Height = Calc_Height_GotoArrow("5,20 6,20 7,20 8,20 9,20 10,20 11,20 12,20 13,20 14,20 15,20 16,20 17,20 18,20 19,20") ' LocalVar Sound
  Delete_Goto_Graph
  Draw_GotoArrowTab List_w_Height, LastUsedColumnInRow(ActiveSheet, GoTo_Row)
End Sub

Attribute VB_Name = "M3_Goto_Graph"
Option Explicit

'-----------------------------
Public Sub Delete_Goto_Graph()
'-----------------------------
  Dim WasProtected As Boolean
  WasProtected = ActiveSheet.ProtectContents
  If WasProtected Then ActiveSheet.Unprotect
  
  Dim o As Variant
  For Each o In ActiveSheet.Shapes
    If Left(o.Name, Len("Goto_Graph")) = "Goto_Graph" Then o.Delete
  Next o
  
  If WasProtected Then Protect_Active_Sheet
End Sub


'----------------------------------------------------------------------------------------------
Sub Draw_GotoArrowXY(x1 As Double, x2 As Double, y As Double, h As Double, Color As MsoRGBType)
'----------------------------------------------------------------------------------------------
' Draw a curved arrow from x1, y to x2, y.
' h defines the height. Positive numbers draw the arrow below y, negative above y
' http://www.herber.de/mailing/vb/html/xlobjfreeformbuilder.htm
  Dim o As Variant
  With ActiveSheet
    With .Shapes.BuildFreeform(msoEditingCorner, x1, y) ' Startpunkt
      '                                             Richt1   Richt2    Ende
      .AddNodes msoSegmentCurve, msoEditingCorner, x1, y, (x1 + x2) / 2, y + 2 * h, x2, y
      Set o = .ConvertToShape
    End With
    '.Shapes (.Shapes.Count) ' Debug
    With o
      With .Line
        .EndArrowheadStyle = msoArrowheadTriangle
        .ForeColor.rgb = Color
      End With
      .Name = "Goto_Graph_CurvedArrow" & ActiveSheet.Shapes.Count
    End With
  End With
End Sub

'-----------------------------------------------------------------------------------------
Sub Draw_GotoArrow(ByVal r1 As Range, ByVal r2 As Range, h As Double, Color As MsoRGBType)
'-----------------------------------------------------------------------------------------
  If r1 <> r2 Then
        Draw_GotoArrowXY r1.Left + r1.Width * 0.5, r2.Left + r2.Width * 0.5, r1.Top + r1.Height, h, Color
  Else: Draw_GotoArrowXY r1.Left + r1.Width * 0.3, r2.Left + r2.Width * 0.7, r1.Top + r1.Height, h, rgb(255, 0, 0)
  End If
End Sub


'UT------------------------------
Private Sub Test_Draw_GotoArrow()
'UT------------------------------
  'Delete_Goto_Graph
  'Draw_GotoArrowXY 100, 200, 100, 50, rgb(255, 0, 0)
  Draw_GotoArrow ActiveCell, ActiveCell.Offset(0, 2), 60, rgb(0, 0, 255)
End Sub


'----------------------------------------------------------------------------------------------------------------------
Private Sub Draw_StraitArrow(r As Range, Txt As String, h As Double, dx As Double, Dir As Integer, Color As MsoRGBType)
'----------------------------------------------------------------------------------------------------------------------
Const tdx = -10
Const tdy = -16
Const th = 72
  Dim x As Double, y As Double, x0 As Double, y0 As Double
  If Dir = 1 Then
        x = r.Left + r.Width * 0.3
  Else: x = r.Left + r.Width * 0.7
  End If
  y = r.Top
  x0 = x - dx
  y0 = y - h
  Dim o As Variant
  With ActiveSheet.Shapes.AddConnector(msoConnectorStraight, x0, y0, x, y)
    If Dir = 1 Then
          .Line.EndArrowheadStyle = msoArrowheadStealth   ' Other type: msoArrowheadTriangle
    Else: .Line.BeginArrowheadStyle = msoArrowheadStealth ' Other type: msoArrowheadOval
    End If
    .Line.ForeColor.rgb = Color
    .Name = "Goto_Graph_Arrow" & ActiveSheet.Shapes.Count
  End With
        
  With ActiveSheet.Shapes.AddLabel(msoTextOrientationHorizontal, x0 + tdx, y0 + tdy, 40, th)
    .TextFrame2.TextRange.Characters.Text = Txt
    .Name = "Goto_Graph_Label" & ActiveSheet.Shapes.Count
  End With
End Sub

'-----------------------------------------------------------------
Private Sub Draw_StartArrow(ByVal r As Range, ByVal Txt As String)
'-----------------------------------------------------------------
    Draw_StraitArrow r, Txt, 30, 10, 1, rgb(0, 128, 0)
End Sub

'---------------------------------------------------------------
Private Sub Draw_EndArrow(ByVal r As Range, ByVal Txt As String)
'---------------------------------------------------------------
    Draw_StraitArrow r, Txt, 17, -10, -1, rgb(128, 0, 0)
End Sub


'UT-------------------------------
Private Sub Test_Draw_StartArrow()
'UT-------------------------------
  Delete_Goto_Graph
  Draw_StartArrow ActiveCell, "7"
  
  Draw_EndArrow ActiveCell, "E"
  ActiveCell.Select
End Sub

'-------------------------------------------------------------------
Sub Draw_GotoArrowTab(ByVal GotoArrowTab As String, LastCol As Long)
'-------------------------------------------------------------------
  ' Draw the Goto arrows
  Dim MaxH As Double, GNr As Long
  MaxH = Cells(GoTo_Row + 1, 1).Height * 0.8
  Dim ArrowTabEntry As Variant, ArrTabArr() As String
  ArrTabArr = Split(GotoArrowTab, " ")
  For Each ArrowTabEntry In ArrTabArr
      Dim Cols() As String, h As Double
      Cols = Split(ArrowTabEntry, ",")
      GNr = GNr + 1
      If UBound(Cols) = 2 Then ' Three parameters given ?
            h = MaxH * Cols(2)
      Else: h = MaxH * GNr / (UBound(ArrTabArr) + 1) ' Old format without height
      End If
      
      Dim Color As MsoRGBType
      If val(Cols(1)) <= LastCol Then ' Inside the valid range ?
            Color = rgb(0, 0, 255) ' Blue
      Else: Color = rgb(255, 153, 0) ' Orange
      End If
      Draw_GotoArrow Cells(GoTo_Row, val(Cols(0))), Cells(GoTo_Row, val(Cols(1))), h, Color
  Next ArrowTabEntry
End Sub

'---------------------------
Public Sub Draw_All_Arrows()
'---------------------------
  Dim WasProtected As Boolean
  WasProtected = ActiveSheet.ProtectContents
  If WasProtected Then ActiveSheet.Unprotect
  
  Dim OldScrUpd As Boolean
  OldScrUpd = Application.ScreenUpdating
  Application.ScreenUpdating = False
  Delete_Goto_Graph
  
  If Range(GotoMod_Rng) <> "1" Then Exit Sub
  
  Calc_Reachable_Columns
  
  Dim LastCol As Long, GotoCells As Range, c As Variant, v As String, SNr As Long
  Dim GotoArrowTab As String, LastLEDsCol As Long, LastLEDsRow As Long, FirstLEDsRow As Long
  FirstLEDsRow = Range(FirstLEDTabRANGE).Row
  LastLEDsRow = FirstLEDsRow + Range(LED_Cnt_Rng) - 1
  LastLEDsCol = LastFilledColumn(Range(LEDsRANGE), LastLEDsRow) ' Find the last used column
  LastCol = LastUsedColumnInRow(ActiveSheet, GoTo_Row)
  If LastLEDsCol > LastCol Then LastCol = LastLEDsCol
  
  If LastCol >= GoTo_Col1 Then
    Set GotoCells = Range(Cells(GoTo_Row, GoTo_Col1), Cells(GoTo_Row, LastCol))
    For Each c In GotoCells
        v = UCase(c)
        If SNr = 0 Or InStr(v, "S") > 0 Then
           Draw_StartArrow c, SNr
           SNr = SNr + 1
        End If
        
        If InStr(v, "E") > 0 And Reachable_Col(c.Column - GoTo_Col1) > 0 Then
           Draw_EndArrow c, "E"
        End If
        
        ' Fill the GotoArrowTab list
        If InStr(v, "G") > 0 And Reachable_Col(c.Column - GoTo_Col1) > 0 Then
           Dim p As Long
           p = Get_Number_from_Str(v)
           If p > 0 Then
              If InStr(PosList, " " & p & " ") > 0 Then
                    GotoArrowTab = GotoArrowTab & c.Column & "," & PosColArray(p - 1) & " "
              Else: GotoArrowTab = GotoArrowTab & c.Column & "," & LastCol + 1 & " "
              End If
           End If
        End If
    Next c
    
    ' Draw the Goto arrows
    If GotoArrowTab <> "" Then
    Dim List_w_Height As String
      List_w_Height = Calc_Height_GotoArrow(Left(GotoArrowTab, Len(GotoArrowTab) - 1))
      Draw_GotoArrowTab List_w_Height, LastCol
    End If
  End If
  If WasProtected Then Protect_Active_Sheet
  Application.ScreenUpdating = OldScrUpd
End Sub

'----------------------------------------------
Private Sub Hide_Show_GotoLines(Hide As Boolean)
'----------------------------------------------
  If Rows(GoTo_Row & ":" & GoTo_Row).EntireRow.Hidden <> Hide Then          ' 25.06.19: Old: "& GoTo_Row + 1"
    Dim WasProtected As Boolean
    WasProtected = ActiveSheet.ProtectContents
    If WasProtected Then ActiveSheet.Unprotect
    If Hide Then
          Rows(GoTo_Row - 1).RowHeight = 12: Rows(GoTo_Row + 1).RowHeight = 15
    Else: Rows(GoTo_Row - 1).RowHeight = 60: Rows(GoTo_Row + 1).RowHeight = 60
    End If
    Rows(GoTo_Row & ":" & GoTo_Row).EntireRow.Hidden = Hide                 ' 25.06.19: Don't hide "Bitte Tabelle ausf|fffd|llen..." line Old: "& GoTo_Row + 1"
    If WasProtected Then Protect_Active_Sheet
  End If
End Sub

'UT-----------------------------------
Private Sub Test_Hide_Show_GotoLines()
'UT-----------------------------------
  Hide_Show_GotoLines Not Rows(GoTo_Row & ":" & GoTo_Row + 1).EntireRow.Hidden
End Sub

'------------------------------------------
Public Sub Hide_Show_GotoLines_If_Enabled()
'------------------------------------------
  Hide_Show_GotoLines Range(GotoMod_Rng) <> "1"
End Sub
Attribute VB_Name = "M4_Save_Sheet_Data"
Option Explicit

'--------------------------------------------------------------------------------------------------------------------------------------
Private Sub Print_TableRow(Sh As Worksheet, FileNr As Integer, r As Long, FirstCol As Long, LastCol As Long, WithEmptyCells As Boolean)
'--------------------------------------------------------------------------------------------------------------------------------------
  With Sh
    Dim c As Long, LastUsedCol As Long
    LastUsedCol = LastFilledColumn(.Range(.Cells(r, LED_Text_Col), .Cells(r, LastCol)), r)
    For c = FirstCol To LastUsedCol
      If WithEmptyCells = False And Trim(.Cells(r, c)) = "" Then Exit For
      If c > FirstCol Then Print #FileNr, Chr(pcfSep);
      If .Cells(r, c).HasFormula Then
            Print #FileNr, Replace(Trim(.Cells(r, c).FormulaLocal), r, "~");
      Else: Print #FileNr, Trim(.Cells(r, c));
      End If
    Next c
    Print #FileNr, ""
  End With
End Sub

'-----------------------------------------------------
Private Function Get_Cell_Attrib(c As Range) As String
'-----------------------------------------------------
  Dim s As String
  With c
    If .Font.Color <> 0 Then s = "c" & .Font.Color & ","
    If .Interior.Color <> 16777215 Then s = s & "i" & .Interior.Color & ","
    If .Font.Bold Then s = s & "B" & ","
    If .Font.Italic Then s = s & "I" & ","
    If .Font.Underline <> -4142 Then s = s & "U" & .Font.Underline & ","
    If .WrapText Then s = s & "W" & ","
    If .Orientation <> xlHorizontal Then s = s & "O" & .Orientation & ","
  End With
  If Len(s) > 0 Then Get_Cell_Attrib = Left(s, Len(s) - 1)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Print_Attrib_of_TableRow(Sh As Worksheet, FileNr As Integer, r As Long, LastCol As Long)
'---------------------------------------------------------------------------------------------------
  With Sh
    Dim c As Long, Line As String
    For c = LED_Text_Col To LastCol
      Line = Line & Get_Cell_Attrib(.Cells(r, c)) & Chr(pcfSep)
    Next c
    While Right(Line, 1) = Chr(pcfSep)
      Line = Left(Line, Len(Line) - 1)
    Wend
    Print #FileNr, Line
  End With
End Sub





#If True Then                                                               ' 24.06.19:
'---------------------------------------------------------------------------------------------
Private Function Find_Row_with_Txt_in_Col(Sh As Worksheet, col As Long, Txt As String) As Long
'---------------------------------------------------------------------------------------------
' New function which uses the Language sheet instead of searching in the sheet.
' => The position must match with the position in the language sheet
'    => It's not possible use this function with old sheets
' The old function dosn't work if the language in the sheet is not german
  Dim PosStr As String
  PosStr = Find_Cell_Pos_by_Name(Txt) ' Find the position in the language sheet
  If PosStr = "" Then
     MsgBox "Error: '" & Txt & "' not found in the laguage sheet", vbCritical, "Error"
     Exit Function
  End If
  
  Find_Row_with_Txt_in_Col = Range(PosStr).Row
End Function
#Else ' Old function
'---------------------------------------------------------------------------------------------
Private Function Find_Row_with_Txt_in_Col(Sh As Worksheet, col As Long, Txt As String) As Long
'---------------------------------------------------------------------------------------------
  Dim r As Long
  With Sh
    For r = 1 To LastUsedRowIn(Sh)
       If .Cells(r, col) = Txt Then
           Find_Row_with_Txt_in_Col = r
           Exit Function
       End If
    Next r
  End With
End Function
#End If



'--------------------------------------------------------------------------------------------------------------
Private Sub Print_Typ_and_Pos(FileNr As Integer, TypeName As String, o As Variant, Optional Str As String = "")
'--------------------------------------------------------------------------------------------------------------
  Print #FileNr, TypeName & Chr(pcfSep) & o.Left & ";" & o.Top & ";" & o.Width & ";" & o.Height;
  'The Print command always uses the decimal point undependent form the user options.
  If Str <> "" Then Print #FileNr, Chr(pcfSep) & Str;
  Print #FileNr, ""
End Sub

'---------------------------------------------------------------
Private Sub Debug_Print_Shape_Info(Name As String, o As Variant)
'---------------------------------------------------------------
  Debug.Print "Unsupportet " & Name & " type:" & o.Type & " '" & o.Name & "' Top:" & o.Top & " Left:" & o.Left & " Width:" & o.Width & " Height:" & o.Height & " TopLeftCell:" & o.TopLeftCell.Row & "," & o.TopLeftCell.Column
  On Error GoTo ErrorSelect
  'o.Select ' Debug
  Exit Sub
ErrorSelect:
  Debug.Print "Error Selecting shape"
End Sub

'------------------------------------------------------
Private Function Get_Points_Str(o As Variant) As String
'------------------------------------------------------
  Dim i As Long, p As Variant, s As String
  
  For i = 1 To o.Nodes.Count
     For Each p In o.Nodes.Item(i).Points
        s = s & p & ";"
     Next p
  Next i
  Get_Points_Str = Left(s, Len(s) - 1)
End Function


'---------------------------------------------------------------------------------------------------
Private Sub SendKeyWithDelay(ProgId As Variant, WaitMs As Long, Delimiter As String, Text As String)
'---------------------------------------------------------------------------------------------------
  Dim Part As Variant
  For Each Part In Split(Text, Delimiter)
     AppActivate ProgId
     Application.SendKeys Part, True
     Sleep (WaitMs)
  Next Part
End Sub

' ToDO:
' St|fffd|rtzt ab beim Speichern von Grafiken wenn mehrere Sheets ausgew|fffd|hlt sind
' Problem in "Save_Picture(o As Variant) As String" Befehl "o.Select"
' Vermutlich kann das Bild nicht ausgew|fffd|hlt werden wenn mehrere Seiten
' ausgew|fffd|hlt sind. Momentan ist das nicht so schlim weil die Bilder ja alle gespeichert sind

'----------------------------------------------------
Private Function Save_Picture(o As Variant) As String
'----------------------------------------------------
  
  If Left(o.Name, Len("Picture")) = "Picture" Then
     Dim NewName As String, OldUpd As Boolean
     OldUpd = Application.ScreenUpdating
     Application.ScreenUpdating = True
     o.Select
     Sleep 500
     NewName = InputBox(Get_Language_Str("Enter the name of the picture"))
     If NewName <> "" Then
           o.Name = NewName
     Else: End
     End If
     Application.ScreenUpdating = OldUpd
  End If
  
  Dim PicName As String
  PicName = ThisWorkbook.Path & "\" & ExampleDir & "\" & o.Name & ".png"
  
  If OVERWRITE_EXISTING_PIC And Dir(PicName) <> "" Then Kill PicName
  
  Save_Picture = o.Name & ".png"
    
  If Dir(PicName) = "" Then
    o.Copy
    ' Open Paint to save the picture
    Dim paintID As Variant
    paintID = Shell("C:\Windows\System32\mspaint.exe", vbNormalFocus)
    Sleep 1000 ' Wait until paint is ready
    ' Description of the following SendKeyWithDelay line:
    ' ^w        = Dialog change width
    ' {RIGHT}   = Change size in pixel not percent
    ' %h        = ALT+H = Goto Horizontal size field
    ' 1;{ENTER} = Enter the width 1
    ' ^v        = Paste picture from clipboard
    ' ^s        = Open Save dialog
    ' PicName.. = Enter the picture name and press enter
    ' %{F4}     = Close the window
    SendKeyWithDelay paintID, 500, ";", "^w;{RIGHT};%h;1;{ENTER};^v;;^s;;;;"
    SendKeyWithDelay paintID, 500, ";", PicName & "{ENTER};;;%{F4}"
  End If
End Function

'---------------------------------------------------------
Private Function Get_TextBoxAttrib(o As Variant) As String
'---------------------------------------------------------
' Get the text attributes from a text box.
' Currently only "Bold" and "ForColor" is supported
'
  Dim c As Variant, BoldStart As Long, IsBold As Boolean, i As Long
  Dim ForColor As Long, ColorStart As Long                                  ' 19.10.19:
  ForColor = rgb(0, 0, 0)
  For Each c In o.TextFrame2.TextRange.Characters
    i = i + 1
    
    If c.Font.Fill.ForeColor.rgb <> ForColor Or i = Len(o.TextFrame.Characters.Text) Then ' 19.10.19:
        If ColorStart > 0 Then Get_TextBoxAttrib = Get_TextBoxAttrib & "F" & ColorStart & "," & i - 1 & "," & ForColor & " "
        If c.Font.Fill.ForeColor.rgb <> rgb(0, 0, 0) Then
              ColorStart = i
        Else: ColorStart = 0
        End If
        ForColor = c.Font.Fill.ForeColor.rgb
    End If
    
    
    If c.Font.Bold Then
       If IsBold = False Then
          BoldStart = i
          IsBold = True
       End If
    Else
       If IsBold Then
          Get_TextBoxAttrib = Get_TextBoxAttrib & "B" & BoldStart & "," & i - 1 & " "
          IsBold = False
       End If
    End If
  Next
  If Get_TextBoxAttrib <> "" Then
     Get_TextBoxAttrib = "{Attrib}" & Left(Get_TextBoxAttrib, Len(Get_TextBoxAttrib) - 1)
  End If
End Function

'------------------------------------------
Private Sub Save_Objects(FileNr As Integer)
'------------------------------------------
' Problem:
' Es gibt unendlich viele Objekte in Excel
' => Ich werde mich zun|fffd|chst auf die Textbox und die Bilder konzentrieren
  Dim o As Variant
  For Each o In ActiveSheet.Shapes
    'If o.Type <> msoComment Then o.Select ' Debug
    Select Case o.Type
      Case msoAutoShape:       ' 1: Rectangle, Triangle, Sprechblase
                               Select Case o.AutoShapeType
                               '   Case msoShapeRightTriangle:             Print_Typ_and_Pos FileNr, "msoTriangle", o
                               '   Case msoShapeRectangle:                 Print_Typ_and_Pos FileNr, "msoShapeRectangle", o
                               '  'Case msoShapeRoundedRectangularCallout: Print_Typ_and_Pos FileNr, "msoShapeRoundedRectangularCallout", o ' Sprechblase
                                  Case Else: Debug_Print_Shape_Info "msoAutoShape", o
                               End Select
      Case msoComment:         ' 4: Comment
                               ' ToDo: Print Comments in the LEDs range
                               
      Case msoFreeform:        ' 5: Freeform (Nicht rechtwinkliges Dreieck z.B.)
                               'Print_Typ_and_Pos FileNr, "msoFreeform", o, Get_Points_Str(o)
                               
      Case msoGroup:           ' 6: Group
      
      Case msoPicture, _
           msoLinkedPicture:   ' 11, 13: Picture
                               If o.Name <> "MainMenu" Then
                                  Print_Typ_and_Pos FileNr, "msoPicture", o, Save_Picture(o)
                               End If
                               
      Case msoTextBox:         ' 17: TextBox
                               If Left(o.Name, Len("Goto_Graph")) <> "Goto_Graph" And o.Name <> "InternalTextBox" Then  ' "InternalTextBox" = "by Hardi"
                                  Print_Typ_and_Pos FileNr, "msoTextBox", o, o.TextFrame.Characters.Text & Get_TextBoxAttrib(o)
                               End If
      Case msoFormControl:     ' 8: Button                                  ' 19.10.19:
                               If o.AlternativeText <> "Aktualisieren" And o.AlternativeText <> "Neues Blatt" Then
                                  Print_Typ_and_Pos FileNr, "msoFormControl", o, o.AlternativeText & Chr(pcfSep) & Replace(o.OnAction, ThisWorkbook.Name & "!", "")
                               End If
      Case Else:               Debug_Print_Shape_Info "shape", o
    End Select
  Next o
End Sub

'----------------------------------------------------------------------------------------------------------------------------------------
Public Sub Save_One_Sheet(Sh As Worksheet, ByVal DestName As String, Optional AppendFile As Boolean = True, Optional SheetName As String)
'----------------------------------------------------------------------------------------------------------------------------------------
' The names in the created sheet are german independant from the
' active language in the sheet to simplify the file loading.

  CreateFolder DestName
  
  Dim FileNr As Integer
  FileNr = FreeFile
  If AppendFile Then
        Open DestName For Append As #FileNr
  Else: Open DestName For Output As #FileNr
  End If
  
  If AppendFile Then Print #FileNr, ""
  Print #FileNr, "SheetName" & Chr(pcfSep);
  If SheetName = "" Then
        Print #FileNr, Sh.Name
  Else: Print #FileNr, SheetName
  End If
  
  With Sh
    .Cells(1, 1).Select ' for better comparison of the copied sheet
    Dim r As Long
    For r = PARAMETER_Ro11 To PARAMETER_Ro1N
        If .Cells(r, PARAMETER_Col + 1).Interior.Color = 65535 Then
           Dim GermanName As String
           GermanName = Get_German_Name(.Cells(r, PARAMETER_Col))
           If GermanName <> "" Then
              Print #FileNr, GermanName & Chr(pcfSep) & .Cells(r, PARAMETER_Col + 1)
           End If
        End If
    Next r
  End With
  
  
  r = Find_Row_with_Txt_in_Col(Sh, LED_Text_Col, "Dauer")                   ' 24.06.19: Adapted this and the following lines to multiple languages
  If r > 0 Then
     Print #FileNr, "Dauer" & Chr(pcfSep);
     Print_TableRow Sh, FileNr, r, Dauer_Col1, Last_LEDsCol, False  ' Duration Row    ' 21.05.19: Replaced 24 by Last_LEDsCol
  End If
  
  r = Find_Row_with_Txt_in_Col(Sh, Goto_Txt_col, "Goto Tabelle")
  If r > 0 Then
     Print #FileNr, "Goto Tabelle" & Chr(pcfSep);
     Print_TableRow Sh, FileNr, r, GoTo_Col1, Last_LEDsCol, True  ' Goto Table
  End If
  
  ' LED Tab
  Dim LastFillRow As Long
  LastFillRow = LastFilledRowIn_w_Attrib(Sh, LED_Text_Col, Last_LEDsCol, Last_LEDs_ChkAttrCol)
  Dim LEDTabRow As Long
  LEDTabRow = Find_Row_with_Txt_in_Col(Sh, LED_Text_Col, "Spalte Nr  ->")
  If LEDTabRow = 0 Then LEDTabRow = Find_Row_with_Txt_in_Col(Sh, LED_Text_Col, "Status Nr  ->")

  If LEDTabRow = 0 Then
     MsgBox Get_Language_Str("Error: LED table not found"), vbCritical
  Else
    For r = LEDTabRow + 1 To LastFillRow
       Print #FileNr, "LED_Tab" & Chr(pcfSep);
       Print_TableRow Sh, FileNr, r, LED_Text_Col, Last_LEDsCol, True
    Next r
      
    For r = LEDTabRow + 1 To LastFillRow
       Print #FileNr, "LED_Attr" & Chr(pcfSep); ActiveSheet.Rows(r).RowHeight & Chr(pcfSep);
       Print_Attrib_of_TableRow Sh, FileNr, r, Last_LEDsCol ', True
    Next r
  End If
  
  Save_Objects FileNr
  
  Close #FileNr
End Sub

'------------------------------------------------
Public Sub Save_All_Sheets_to(FileName As String)
'------------------------------------------------
  Dim Sh As Variant, AppendSheet As Boolean
  Del_All_Sheets_which_contain_Copy_in_their_Name
  Application.ScreenUpdating = False
  For Each Sh In ThisWorkbook.Sheets
     If Sh.Name <> "Main" And Sh.Name <> "Languages" Then
        Sh.Activate
        Save_One_Sheet ActiveSheet, FileName, AppendSheet
        AppendSheet = True
     End If
  Next Sh
  Application.ScreenUpdating = True
End Sub

'-------------------------------------------
Public Function Get_MyExampleDir() As String
'-------------------------------------------
  Dim Dir As String
  Dir = Environ("USERPROFILE") & "\Documents\" & MyExampleDir
  CreateFolder Dir & "\"
  Get_MyExampleDir = Dir
End Function


'----------------------------
Private Sub Save_All_Sheets()
'----------------------------
  Save_All_Sheets_to Get_MyExampleDir() & "\AllExamples.MLL_pcf"
  'Save_All_Sheets_to ThisWorkbook.Path & "\" & ExampleDir & "\AllExamples.MLL_pcf"
End Sub

'UT------------------------------
Private Sub Test_Save_One_Sheet()
'UT------------------------------
  Save_One_Sheet ActiveSheet, ThisWorkbook.Path & "\" & ExampleDir & "\TestExample.MLL_pcf", False
End Sub
Attribute VB_Name = "M5_Load_Sheet_Data"
Option Explicit



'--------------------------------------------------
Private Sub Set_Cell(Desc As String, val As String)
'--------------------------------------------------
' Write val to the cell which matches the given Desc in the language sheet.
  Dim c As Variant
  For Each c In Range(PARAMETER_RANGE)
    If Trim(c) = Desc Then
       c.Offset(0, 1) = val
       Exit Sub
    End If
  Next c
  
  Dim RngStr As String
  RngStr = Find_Cell_Pos_by_Name(Desc)
  If RngStr <> "" Then
     Range(RngStr).Offset(0, 1) = val
     Exit Sub
  End If
  MsgBox Get_Language_Str("Error: '") & Desc & "' " & Get_Language_Str("not found in") & "'Set_Cell'"
End Sub

'-------------------------------------------------------------------------------------------
Function Get_Cell(ByVal DescArray As Variant, Optional GenError As Boolean = True) As String
'-------------------------------------------------------------------------------------------
  Dim c As Variant, Desc As Variant, DescStr As String
  If Not IsArray(DescArray) Then DescArray = Array(DescArray)
  For Each Desc In DescArray
    For Each c In Range(PARAMETER_RANGE)
      If Trim(c) = Desc Then
         Get_Cell = c.Offset(0, 1)
         Exit Function
      End If
      
      Dim RngStr As String
      RngStr = Find_Cell_Pos_by_Name(Desc)
        If RngStr <> "" Then
        Get_Cell = Range(RngStr).Offset(0, 1)
        Exit Function
      End If
      
    Next c
    DescStr = DescStr & " '" & Desc & "' &"
  Next Desc
  
  If GenError Then MsgBox Get_Language_Str("Error: '") & Left(DescStr, Len(DescStr) - 1) & "' " & "' " & Get_Language_Str("not found in") & "'Get_Cell()'"
End Function


'UT------------------------
Private Sub Test_Get_Cell()
'UT------------------------
  Debug.Print Get_Cell(Array("Analoges |fffd|berblend", "Test"))
End Sub

'-------------------------
Private Sub Del_Text_Box()
'-------------------------
  Dim o As Variant
  For Each o In ActiveSheet.Shapes
    Select Case o.Type
      Case msoTextBox: ' 17: TextBox
                       'o.Select ' Debug
                       o.Delete
    End Select
  Next o
End Sub

'-----------------------------
Private Sub Clear_Sheet_Data()
'-----------------------------
  With ActiveSheet
    .Unprotect
    ' Set deault values
    Set_Cell "Erste RGB LED:", "1"              ' The Cell position is searched the Language sheet => It's independant from the current language
    Set_Cell "Startkanal der RGB LED:", 0
    Set_Cell "Schalter Nummer:", "SI_1"
    Set_Cell "Anzahl der Ausgabe Kan|fffd|le:", 2
    Set_Cell "Bits pro Wert:", 1
    Set_Cell "Wert Min:", 0
    Set_Cell "Wert Max:", 255
    Set_Cell "Wert ausgeschaltet:", 0
    Set_Cell "Mode:", 0
    Set_Cell "Analoges |fffd|berblenden:", 0
    Set_Cell "Goto Mode:", 0
    Set_Cell "Grafische Anzeige:", ""
    
    ' Clear the LEDs table
    With .Range(LEDsRANGE)
       .ClearContents
       With .Interior
        .Pattern = xlNone
        .TintAndShade = 0
        .PatternTintAndShade = 0
       End With
       With .Font
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
       End With
    End With
    
    Del_Text_Box
    
    Del_Analog_Trend_Objects
  End With
End Sub

'------------------------------------------------------------------------------------------------------------------------
Private Function Unic_SheetName(ByVal SheetName As String, Optional Add_to_Duplicate_Name As String = "_Copy_") As String
'------------------------------------------------------------------------------------------------------------------------
  Dim OrgName As String, Cnt As Long
  OrgName = SheetName
  While SheetEx(SheetName)
     Cnt = Cnt + 1
     SheetName = OrgName & Add_to_Duplicate_Name & Cnt
  Wend
  Unic_SheetName = SheetName
End Function

'----------------------------------------------------------------------------------------------------------------------------------------
Private Sub Create_New_Sheet(SheetName As String, Optional Add_to_Duplicate_Name As String = "_Copy_", Optional AfterSheetName As String)
'----------------------------------------------------------------------------------------------------------------------------------------
  Dim OrgName As String
  OrgName = SheetName
  SheetName = Unic_SheetName(SheetName, Add_to_Duplicate_Name)
  
  Dim AfterSheet As Worksheet
  Set AfterSheet = Sheets(Sheets.Count)
  If SheetEx(OrgName) Then Set AfterSheet = Sheets(OrgName)
  If AfterSheetName <> "" Then Set AfterSheet = Sheets(AfterSheetName)
  Sheets("Main").Copy After:=AfterSheet
  ThisWorkbook.Activate
  ActiveSheet.Name = SheetName
  
  
  Sheets("Main").Select          ' For some reasons the "Akualisieren" Button gets selected after the "Sheets("Main").Copy" command above.
  Range(FirstLEDTabRANGE).Select ' This generates later problems because the sheet is protected and the Button shouldent be selected. ?!?
  Sheets(SheetName).Select       ' I love Excel ...
  
  Clear_Sheet_Data
  Range(MacEnab_Rng) = ""
End Sub

'-------------------------
Private Sub Add_by_Hardi()
'-------------------------
  ActiveSheet.Shapes.AddLabel(msoTextOrientationHorizontal, 443, 0, 55, 5).Select
  Selection.ShapeRange(1).TextFrame2.TextRange.Characters.Text = "by Hardi"
  Selection.ShapeRange.TextFrame2.TextRange.Font.Fill.ForeColor.rgb = rgb(0, 0, 255)
  Selection.ShapeRange.Name = "InternalTextBox"
  Selection.Placement = xlFreeFloating
End Sub


'---------------------
Public Sub New_Sheet()
'---------------------
' Is called if the "Neues Blatt" Button is pressed
  
  Dim CopyFormSheet As String
  Select Case MsgBox(Get_Language_Str("Sollen die Einstellungen des aktuellen Blatts |fffd|bernonnen werden?"), vbYesNoCancel + vbQuestion, Get_Language_Str("Neues Blatt anlegen"))
    Case vbCancel: Exit Sub
    Case vbYes: CopyFormSheet = ActiveSheet.Name
  End Select
    
  Dim Name As String
  Name = InputBox(Get_Language_Str("Name des neuen Blattes?"), Get_Language_Str("Neues Blatt anlegen"), Unic_SheetName(CopyFormSheet, "_"))
  If Name <> "" Then
     If CopyFormSheet <> "" Then
        Dim TempName As String
        TempName = ThisWorkbook.Path & "\" & ExampleDir & "\TempExample.MLL_pcf"
        Save_One_Sheet Sheets(CopyFormSheet), TempName, False, Unic_SheetName(Name, "_")
        Load_Sheets TempName, AfterSheetName:=CopyFormSheet
        Translate_Standard_Description_Box
     Else
        Create_New_Sheet Name, Add_to_Duplicate_Name:="_", AfterSheetName:="Main"
        Load_Textbox StdDescEdges & Chr(pcfSep) & _
                     Get_Language_Str(StdDescStart)
        Range(Macro_N_Rng) = Replace_Illegal_Char(ActiveSheet.Name)
        Add_by_Hardi
     End If
     Range(FirstLEDTabRANGE).Select
     Protect_Active_Sheet
  End If
End Sub


'---------------------------------------
Sub Translate_Standard_Description_Box()
'---------------------------------------
  Dim o As Variant
  For Each o In ActiveSheet.Shapes
    Select Case o.Type
      Case msoTextBox: ' 17: TextBox
                       Dim Txt As String
                       If o.Name = "Description Message" Then
                          If Get_ExcelLanguage() <> 0 Then ' Left(o.TextFrame.Characters.Text, Len(StdDescStart)) = StdDescStart Then
                             Dim WasProtected As Boolean
                             WasProtected = ActiveSheet.ProtectContents
                             If WasProtected Then ActiveSheet.Unprotect
                             o.Delete
                             Load_Textbox StdDescEdges & Chr(pcfSep) & Get_Language_Str(StdDescStart), "Description Message"
                             If WasProtected Then Protect_Active_Sheet
                             Exit For
                          End If
                       End If
    End Select
  Next o
End Sub


'-----------------------------------------
Private Sub Load_Dauer_Tab(Line As String)
'-----------------------------------------
  Dim c As Variant, i As Long
    For Each c In Split(Line, Chr(pcfSep))
      Cells(Dauer_Row, Dauer_Col1 + i) = Replace(c, "~", Dauer_Row)
      i = i + 1
    Next c
End Sub

'----------------------------------------
Private Sub Load_GoTo_Tab(Line As String)
'----------------------------------------
  Dim c As Variant, i As Long
    For Each c In Split(Line, Chr(pcfSep))
      Cells(GoTo_Row, GoTo_Col1 + i) = c
      i = i + 1
    Next c
End Sub



'-------------------------------------------------------------
Private Sub Load_LED_Tab(Line As String, ByRef LTabNr As Long)
'-------------------------------------------------------------
  With Range(FirstLEDTabRANGE)
    Dim c As Variant, i As Long
    i = -1
    For Each c In Split(Line, Chr(pcfSep))
        If i <> -1 And c <> "" Then
           .Offset(LTabNr, i) = c
        End If
        i = i + 1
    Next c
  End With
  LTabNr = LTabNr + 1
End Sub

'-------------------------------------------------------
Private Sub Set_Attrib(r As Range, ByVal attr As String)
'-------------------------------------------------------
  Dim A As Variant
  With r
    For Each A In Split(attr, ",")
      Select Case Left(A, 1)
        Case "c": .Font.Color = Mid(A, 2)
        Case "i": .Interior.Color = Mid(A, 2)
        Case "B": .Font.Bold = True
        Case "I": .Font.Italic = True
        Case "U": .Font.Underline = Mid(A, 2)
        Case "W": .WrapText = True
        Case "O": .Orientation = val(Mid(A, 2))
        Case Else: MsgBox "Error: Unknown attribut: '" & A & "'"
      End Select
    Next A
  End With
End Sub

'-------------------------------------------------------------
Private Sub Load_LED_Att(Line As String, ByRef LAttNr As Long)
'-------------------------------------------------------------
  With Range(FirstLEDTabRANGE)
    Dim c As Variant, i As Long
    i = -2
    For Each c In Split(Line, Chr(pcfSep))
        If i = -1 Then .Offset(LAttNr, 0).EntireRow.RowHeight = NrStr2d(c)
        If i >= 0 And c <> "" Then
           Set_Attrib .Offset(LAttNr, i), c
        End If
        i = i + 1
    Next c
  End With
  LAttNr = LAttNr + 1
End Sub

'-------------------------------------------------------------------
Sub Load_Textbox(ByVal Line As String, Optional Name As String = "")
'-------------------------------------------------------------------
  Dim Params() As String, Edges() As String
  Params = Split(Line, Chr(pcfSep))
  Edges = Split(CorrectKomma(Params(0)), ";")
  
  Dim Line2 As String, Parts() As String
  Line2 = Mid(Line, Len(Params(0)) + 2)
  Line2 = Replace(Line2, "{Attrib}", Chr(1))
  Parts = Split(Line2, Chr(1))
  
  ActiveSheet.Shapes.AddLabel(msoTextOrientationHorizontal, val(Edges(0)), val(Edges(1)), val(Edges(2)), val(Edges(3))).Select ' 21.10.19: Added Val()
  Selection.Placement = xlFreeFloating
  
  Selection.ShapeRange(1).TextFrame2.TextRange.Characters.Text = Parts(0)
  If Name <> "" Then Selection.ShapeRange(1).Name = Name
  
  If UBound(Parts) = 1 Then
     Dim c As Variant, Par() As String
     For Each c In Split(Parts(1), " ")
       Select Case Left(c, 1)
         Case "B", "F": ' Bold / ForeColor
                   Par = Split(Mid(c, 2), ",")                              ' 19.10.19: Old:
                   Dim Start As Long, Lenghth As Long
                   Start = val(Par(0))
                   Lenghth = val(Par(1)) - val(Par(0)) + 1                  ' 19.10.19: Second parameter is the lenght and not the end position
                   Select Case Left(c, 1)
                      Case "B": Selection.ShapeRange(1).TextFrame2.TextRange.Characters(Start, Lenghth).Font.Bold = msoTrue
                      Case "F": Selection.ShapeRange(1).TextFrame2.TextRange.Characters(Start, Lenghth).Font.Fill.ForeColor.rgb = Par(2) ' 19.10.19:
                   End Select
       End Select
     Next
  End If
End Sub


'----------------------------------------------------------------
Sub Show_Rotating_Status(Message As String, ByRef RotPos As Integer)           ' 27.10.19:
'----------------------------------------------------------------
  Const RotatingChr = "-\|/"
  If RotPos > 4 Or RotPos < 1 Then RotPos = 1
  Application.StatusBar = Message & Mid(RotatingChr, RotPos, 1)
  RotPos = RotPos + 1
  Sleep 100
  DoEvents
End Sub

'--------------------------------------------
Sub Load_msoFormControl(ByVal Line As String)                               ' 19.10.19:
'--------------------------------------------
' Load Button
  Dim Params() As String, Edges() As String
  Params = Split(Line, Chr(pcfSep))
  Edges = Split(CorrectKomma(Params(0)), ";")
  ActiveSheet.Buttons.Add(val(Edges(0)), val(Edges(1)), val(Edges(2)), val(Edges(3))).Select ' 21.10.19: Added Val()
  Selection.Characters.Text = Params(1)
  Selection.OnAction = Params(2)
  Dim Init_Proc As String
  Init_Proc = Params(2) & "_Init"
  Button_Init_Proc_Finished = False
  
  Dim OldStatus As String, OldEvents As Boolean
  OldStatus = Application.StatusBar
  OldEvents = Application.EnableEvents
  Application.OnTime Now, Init_Proc
  Application.EnableEvents = True
  Dim Message As String, RotPos As Integer
  Message = "Warte auf '" & Init_Proc & "'"
  While Not Button_Init_Proc_Finished
     Show_Rotating_Status Message, RotPos
  Wend
  Application.StatusBar = OldStatus
  Application.EnableEvents = OldEvents
End Sub

'---------------------------------------
Private Sub Load_Picture(Line As String)
'---------------------------------------
  Dim Params() As String, Edges() As String, PicName As String
  Params = Split(Line, Chr(pcfSep))
  Edges = Split(CorrectKomma(Params(0)), ";")                               ' 02.07.19: Added: CorrectKomma()
  PicName = ThisWorkbook.Path & "\" & ExampleDir & "\" & Params(1)
  On Error GoTo LoadError
  ActiveSheet.Pictures.Insert(PicName).Select
  On Error GoTo 0
  Selection.ShapeRange.Left = val(Edges(0)) ' 21.10.19: Added Val()
  Selection.ShapeRange.Top = val(Edges(1))
  Selection.Name = NoExt(Params(1))
  Selection.Placement = xlFreeFloating
  Exit Sub
LoadError:
  MsgBox Get_Language_Str("Fehler beim laden des Bildes: ") & "'" & PicName & "'", vbCritical, Get_Language_Str("Fehler")
End Sub

'-----------------------------------
Private Sub Set_Defaults_for_Sheet()
'-----------------------------------
' The Cell positions are searched the Language sheet => It's independant from the current language
  If Get_Cell("Grafische Anzeige:") = "" And Get_Cell(Array("Analoges |fffd|berblenden:", "Analoges |fffd|berblenden"), False) = "1" Then
     Set_Cell "Grafische Anzeige:", 1
  End If
  Hide_Show_GotoLines_If_Enabled
  Add_by_Hardi
  ActiveWindow.DisplayHeadings = False
  
  If Get_Cell("Grafische Anzeige:") = "1" Then
     Draw_All_Arrows
     Draw_Analog_Trend_of_Sheet
  End If
End Sub

'-----------------------------------------------------------------------
Sub Load_Sheets(SourceName As String, Optional AfterSheetName As String)
'-----------------------------------------------------------------------
  Dim FileNr As Integer, OldSheet As Worksheet, AddedSheets As Long, SrcPath As String
  Set OldSheet = ActiveSheet
  Application.EnableEvents = False
  FileNr = FreeFile
  If Dir(SourceName) = "" Then
     MsgBox Get_Language_Str("Fehler: Die Datei '") & SourceName & "' " & Get_Language_Str("existiert nicht."), vbCritical, Get_Language_Str("Fehler")
     Exit Sub
  End If
  Open SourceName For Input As #FileNr
  Dim Line As String, LNr As Long, LTabNr As Long, LAttNr As Long, ScrUpd As Boolean, FirstSheet As Boolean
  FirstSheet = True
  LNr = 0
  ScrUpd = Application.ScreenUpdating
  Application.ScreenUpdating = False
  Application.Calculation = xlCalculationManual
  While Not EOF(FileNr) ' Loop over all lines in the file
    LNr = LNr + 1
    Line Input #FileNr, Line
    Line = Replace(Line, vbTab, Chr(pcfSep)) ' To be able to read old files which have been separeted by tab
    If Line <> "" Then
        Dim Tokens() As String
        Tokens = Split(Line, Chr(pcfSep))
        Select Case Tokens(0)
            Case "" ' Nothing
            Case "SheetName":            ' Start of a new sheet
                                         If Not FirstSheet Then ' Do we have to finish the previous sheet
                                            Set_Defaults_for_Sheet
                                            Protect_Active_Sheet ' Protect the previos sheet
                                         End If
                                         If Len(Application.StatusBar) >= 255 Then ' Status bar is limmited to 255 characters. If it's longer excel crashes ;-(
                                            Dim Tmp As String
                                            Tmp = Application.StatusBar
                                            While Right(Tmp, 1) = "."
                                               Tmp = Mid(Tmp, 1, Len(Tmp) - 1)
                                            Wend
                                            Application.StatusBar = Tmp
                                         End If
                                         Application.StatusBar = Application.StatusBar & "." ' 19.10.19:
                                         FirstSheet = False
                                         Create_New_Sheet Tokens(1), AfterSheetName:=AfterSheetName
                                         LTabNr = 0
                                         LAttNr = 0
                                         AddedSheets = AddedSheets + 1
            Case "Dauer":                Load_Dauer_Tab Mid(Line, Len(Tokens(0)) + 2)
            Case "Goto Tabelle":         Load_GoTo_Tab Mid(Line, Len(Tokens(0)) + 2)
            Case "LED_Tab":              Load_LED_Tab Line, LTabNr
            Case "LED_Attr":             Load_LED_Att Line, LAttNr
            Case "Analoges |fffd|berblenden": Set_Cell "Analoges |fffd|berblenden:", Tokens(1) ' Two different spellings used ;-(
            Case "msoTextBox":           Load_Textbox Mid(Line, Len(Tokens(0)) + 2)
            Case "msoFormControl":       Load_msoFormControl Mid(Line, Len(Tokens(0)) + 2)
            Case "msoPicture":           Load_Picture Mid(Line, Len(Tokens(0)) + 2)
            Case Else:                   Set_Cell Trim(Tokens(0)), Tokens(1)
        End Select
    End If
  Wend
  
  ' All sheets loade
  If Not FirstSheet Then ' Do we have to finish the previous sheet (In case there was no sheet in the configuration file)
     Set_Defaults_for_Sheet
     Protect_Active_Sheet ' Protect the previos sheet
  End If
  Application.Calculation = xlCalculationAutomatic
  Application.EnableEvents = True
  Calculate
  Application.ScreenUpdating = ScrUpd
  Close #FileNr
  If AddedSheets > 1 Then OldSheet.Activate
End Sub

'-------------------------------------
Public Sub Del_All_Sheets_Excep_Main()
'-------------------------------------
  Dim Sh As Variant
  Application.Calculation = xlCalculationManual
  For Each Sh In ThisWorkbook.Sheets
     If Sh.Name <> "Main" And Sh.Name <> "Languages" Then
         Application.DisplayAlerts = False
         Sheets(Sh.Name).Delete
         Application.DisplayAlerts = True
     End If
  Next Sh
  Application.Calculation = xlCalculationAutomatic
End Sub

'-----------------------------------------------------------
Public Sub Del_All_Sheets_which_contain_Copy_in_their_Name()
'-----------------------------------------------------------
  Dim Sh As Variant, OldSheet As Worksheet
  Set OldSheet = ActiveSheet
  Application.Calculation = xlCalculationManual
  For Each Sh In ThisWorkbook.Sheets
     If InStr(Sh.Name, "_Copy_") Then
         Application.DisplayAlerts = False
         Sheets(Sh.Name).Delete
         Application.DisplayAlerts = True
     End If
  Next Sh
  Application.Calculation = xlCalculationAutomatic
  On Error Resume Next ' In case the sheet was deleted
  OldSheet.Activate
  On Error GoTo 0
End Sub

'-----------------------------------
Public Sub Load_AllExamples_Sheets()
'-----------------------------------
  Application.Calculation = xlCalculationAutomatic ' In case the previous macro was aborted
  Application.StatusBar = Get_Language_Str("Lade Beispielseiten...")
  Dim ExamplesName As String
  ExamplesName = ThisWorkbook.Path & "\" & ExampleDir & "\AllExamples.MLL_pcf" ' "\AllExamples_Ohne_Pic.MLL_pcf"
  If Dir(ExamplesName) <> "" Then
        Load_Sheets ExamplesName
        If Left(Application.StatusBar, Len(Get_Language_Str("Lade Beispielseiten..."))) = Get_Language_Str("Lade Beispielseiten...") Then ' Still the same status line and no error message
           Application.StatusBar = Get_Language_Str("Beispiele geladen")
        End If
  Else: Application.StatusBar = Get_Language_Str("Error loading: ") & ExamplesName
  End If
  Application.Calculation = xlCalculationAutomatic
End Sub

'UT------------------------------
Private Sub Test_Load_One_Sheet()
'UT------------------------------
  Application.Calculation = xlCalculationAutomatic ' In case the previous macro was aborted
  Load_Sheets ThisWorkbook.Path & "\" & ExampleDir & "\TestExample.MLL_pcf", AfterSheetName:="Main"
  Application.Calculation = xlCalculationAutomatic
End Sub
Attribute VB_Name = "M6_Language"
Option Explicit


' Other languages could be added in the hidden sheet "Languages"
' In addition Get_ExcelLanguage() must be adapted

' Current languages:
'  0 = German
'  1 = English

Const FirstLangRow = 3  ' Row number 3
Const LangType_Col = 1
Const LangParamCol = 2
Const FirstLangCol = 3


'--------------------------------------------------------------------------------------------------------------
Private Function Update_Language_in_Pattern_Config_Sheet(ByVal Sh As Worksheet, DestLang As Integer) As Boolean
'--------------------------------------------------------------------------------------------------------------
  Dim LSh As Worksheet, OldSel As Variant
  Set OldSel = Selection
  Set LSh = ThisWorkbook.Sheets("Languages")
  With Sh
    ' Check if the language has to be changed by comparing the first string
    Dim c As Long, FirstMsg As String, ActLang As Integer

    ActLang = -1
    FirstMsg = .Range(LSh.Cells(FirstLangRow, LangParamCol))
    For c = FirstLangCol To LastUsedColumnInRow(LSh, FirstLangRow)
       If FirstMsg = LSh.Cells(FirstLangRow, c) Then
          ActLang = c - FirstLangCol
          Exit For
        End If
    Next
    If ActLang = -1 Then
       MsgBox "Error: '" & FirstMsg & "' not found in the Languages sheet", vbCritical, "Language Error"
       Exit Function
    End If
    If (ActLang = DestLang) Then Exit Function ' Language is correct
    
    ' Unprotect the sheet
    Dim WasProtected As Boolean
    WasProtected = ActiveSheet.ProtectContents
    If WasProtected Then ActiveSheet.Unprotect
    
    ' Debug
    Dim MaxLang As Integer
    MaxLang = LastUsedColumnInRow(LSh, FirstLangRow) - FirstLangCol
    If DestLang = -1 Then ' -1 could be used for debugging
       DestLang = ActLang + 1
       If ActLang >= MaxLang Then DestLang = 0
    End If
    
    
    ' Replace the texts
    Dim r As Long, LangCol As Integer
    LangCol = FirstLangCol + DestLang
    For r = FirstLangRow To LastUsedRowIn(LSh)
        Dim Param As String, Tmp As String
        Param = LSh.Cells(r, LangParamCol)
        Tmp = LSh.Cells(r, LangCol)
        Select Case LSh.Cells(r, LangType_Col)
           Case "":             ' Nothing
           Case "Cell":         .Range(Param).FormulaR1C1 = Tmp ' Cell values and formulas
           Case "NumberFormat": .Range(Param).NumberFormat = Tmp
           Case "Button":       .Shapes.Range(Array(Param)).Select
                                Selection.Characters.Text = Tmp
           Case "Comment":      ' Comments
                                With .Range(Param).Comment
                                  .Text Text:=Replace(Tmp, vbLf, Chr(10))
                                  .Shape.TextFrame.Characters(1, Len(Tmp)).Font.Bold = False  ' ToDo: Bolt aus Sheet lesen
                                End With
                                
           Case "ErrorMessage": .Range(Param).Validation.ErrorMessage = Tmp
           Case "ErrorTitle":   .Range(Param).Validation.ErrorTitle = Tmp
           ' ToDo Warnungen
        End Select
    Next r
    
  End With
  If WasProtected Then Protect_Active_Sheet
  OldSel.Select
  Update_Language_in_Pattern_Config_Sheet = True
  'Debug.Print "Updated Language in " & Sh.Name ' Debug
End Function



'UT-------------------------------------------------------
Private Sub Test_Update_Language_in_Pattern_Config_Sheet()
'UT-------------------------------------------------------
  Dim OldEvents As Boolean, OldUpdate As Boolean
  OldEvents = Application.EnableEvents
  OldUpdate = Application.ScreenUpdating
  Application.EnableEvents = False
  Application.ScreenUpdating = False

  Update_Language_in_Pattern_Config_Sheet ActiveSheet, -1
  Application.EnableEvents = OldEvents
  Application.ScreenUpdating = OldUpdate
End Sub


'-------------------------------------------------
Sub Update_Language_in_All_Pattern_Config_Sheets()
'-------------------------------------------------
' Set the language of all sheets to the achtive display language in excel

  Dim OldEvents As Boolean, OldUpdate As Boolean, OldSheet As Worksheet
  Set OldSheet = ActiveSheet
  OldEvents = Application.EnableEvents
  OldUpdate = Application.ScreenUpdating
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  
  Dim Sh As Variant, DestLang As Integer
  DestLang = Get_ExcelLanguage
  'DestLang = 1 ' debug
  For Each Sh In ThisWorkbook.Sheets
     If Sh.Name <> "Languages" Then
        Sh.Activate ' Necessary for the button names ;-(
        Translate_Standard_Description_Box                                  ' 27.06.19:
        If Update_Language_in_Pattern_Config_Sheet(Sh, DestLang) = False And Sh.Name = "Main" Then Exit For
     End If
  Next Sh
  OldSheet.Activate
  Application.EnableEvents = OldEvents
  Application.ScreenUpdating = OldUpdate
End Sub

'--------------------------------------
Function Get_ExcelLanguage() As Integer
'--------------------------------------
' Return a number corrosponding to the actual language used in excel
'  0 = German
'  1 = English and all other languages
' The number must match to the position in the language strings in M6_Language_Constants
'
' Is working if the office language is changed or the Window language
  Get_ExcelLanguage = 1

'Debug.Print "Achtung: Get_ExcelLanguage() liefert immer 1"
'Exit Function

  Select Case Application.LanguageSettings.LanguageID(msoLanguageIDUI)
     ' Language ID's: https://docs.microsoft.com/en-us/previous-versions/office/developer/office-2007/aa432635(v=office.12)
     Case msoLanguageIDGerman, msoLanguageIDGermanAustria, msoLanguageIDGermanLiechtenstein, msoLanguageIDGermanLuxembourg, msoLanguageIDSwissGerman
          Get_ExcelLanguage = 0
  End Select
End Function

'UT---------------------------------
Private Sub Test_Get_ExcelLanguage()
'UT---------------------------------
  Debug.Print "Get_ExcelLanguage()=" & Get_ExcelLanguage()
End Sub


'-------------------------------------------------------------
Function Find_Cell_Pos_by_Name(ByVal Desc As String) As String
'-------------------------------------------------------------
' Find the given Desc in the language sheet and return the
' destination position as string.
'
' If Desc is not found "" is returned
  Dim LSh As Worksheet, res As Variant
  Set LSh = ThisWorkbook.Sheets("Languages")
  With LSh
    Set res = LSh.Cells.Find(What:=Desc, After:=.Range("A1"), LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, SearchFormat:=False)
    If Not res Is Nothing Then
       Find_Cell_Pos_by_Name = .Cells(res.Row, LangParamCol).Value
    End If
  End With
  
End Function

'UT-------------------------------------
Private Sub Test_Find_Cell_Pos_by_Name()
'UT-------------------------------------
  Debug.Print "Find_Cell_Pos_by_Name(""Bits pro Wert:"")='" & Find_Cell_Pos_by_Name("Bits pro Wert:") & "'"
  Debug.Print "Find_Cell_Pos_by_Name(""Bits per value:"")='" & Find_Cell_Pos_by_Name("Bits per value:") & "'"
End Sub

'-------------------------------------------------------
Function Get_German_Name(ByVal Desc As String) As String
'-------------------------------------------------------
  Dim LSh As Worksheet, res As Variant
  Set LSh = ThisWorkbook.Sheets("Languages")
  With LSh
    Set res = LSh.Cells.Find(What:=Desc, After:=.Range("A1"), LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, SearchFormat:=False)
    If Not res Is Nothing Then
          Get_German_Name = .Cells(res.Row, FirstLangCol).Value
    Else: MsgBox "Error '" & Desc & "' not found in 'Get_German_Name'", vbCritical, "Error"
    End If
  End With
End Function


'-----------------------------------------------------------------------------------------------------------------------------------
Function Get_Language_Str(ByVal Desc As String, Optional GenError As Boolean = True, Optional Look_At As Integer = xlPart) As String
'-----------------------------------------------------------------------------------------------------------------------------------
' Find the given Desc in the language sheet and return the
' string in the actual language
'
' If Desc is not found "" is returned
  Dim LSh As Worksheet, res As Variant
  Set LSh = ThisWorkbook.Sheets("Languages")
  With LSh
    Set res = LSh.Cells.Find(What:=Desc, After:=.Range("A1"), LookIn:=xlFormulas, LookAt:=Look_At, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, SearchFormat:=False)
    If Not res Is Nothing Then
       Get_Language_Str = .Cells(res.Row, FirstLangCol + Get_ExcelLanguage()).Value
       Exit Function
    End If
  End With
  If GenError Then
        MsgBox "Error '" & Desc & "' not found in 'Get_Language_Str'", vbCritical, "Error"
  Else: Get_Language_Str = Desc
        Debug.Print "Translation not found for '" & Replace(Desc, vbCr, "!") & "'"
  End If
End Function

'-------------------------------------------
Sub Change_Language_in_Dialog(dlg As Object)
'-------------------------------------------
Dim o As Variant
   For Each o In dlg.Controls
      If o.ControlTipText <> "" Then o.ControlTipText = Get_Language_Str(o.ControlTipText)
      
      If o.Caption <> "by Hardi" And Left(o.Caption, 4) <> "http" Then
         o.Caption = Replace(Get_Language_Str(Replace(o.Caption, vbCr, "|"), False, xlWhole), "|", vbCr)
      End If
   Next o
End Sub


'UT---------------------------------
Sub Test_Change_Language_in_Dialog()
'UT---------------------------------
  Change_Language_in_Dialog MainMenu_Form
End Sub
Attribute VB_Name = "M7_Morsecode"
Option Explicit

' This Modul has been written by Lorenz
' with some smal modifications by Hardi

' Revision History:
' ~~~~~~~~~~~~~~~~~
' 17.10.19: - Speed Up
' 19.10.19: - Suport for special codes like {SOS}
'           - Error checks

' ToDo:
' - Use the public constants: FirstLEDTabRANGE, ...


'-------------------------------
Public Sub Make_Morsecode_Init()
'-------------------------------
' Ist called when the sheet is copied with the "Neues Blatt" button or loaded from a file
  Dim OldUpdating As Boolean, OldEvents As Boolean
  OldUpdating = Application.ScreenUpdating
  OldEvents = Application.EnableEvents
  Application.ScreenUpdating = False
  Application.EnableEvents = False
  Range("M2") = "Morsetext"
  Range("M3") = "Dauer Dit in ms": Range("M3").Characters(Start:=7, Length:=3).Font.FontStyle = "Kursiv"
  Range("M4") = "Spruchanfang/-ende senden"
  Range("M5") = "Nach dem Erstellen vorf|fffd|ren": Range("M5").HorizontalAlignment = xlRight
  
  Range("N2") = "{SOS} Rettet Hardi"
  Range("N3") = "240"
  Range("N4") = "Nein"
  Range("N5") = "Ja"
  
  Range("N2:N5").Interior.Color = 65535
  Range("O2:P2").Interior.Color = 65535
    
  Hide_Second_Pic
  Application.ScreenUpdating = OldUpdating
  Application.EnableEvents = OldEvents
  Button_Init_Proc_Finished = True
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub One_Char(Zeichencode As Integer, ByRef Zellcounter As Long, Morsezeichen() As String)
'---------------------------------------------------------------------------------------------------
Dim Zaehlerincode As Integer, c As String
    c = Chr(Zeichencode)
    For Zaehlerincode = 1 To Len(Morsezeichen(Zeichencode))
        Select Case Mid(Morsezeichen(Zeichencode), Zaehlerincode, 1)
            Case "|fffd|":   Cells(45, Zellcounter).Value = "X"
                        Cells(47, Zellcounter).Value = "."
                        Cells(46, Zellcounter).Value = c
                        Zellcounter = Zellcounter + 1
            Case "-":   Range(Cells(45, Zellcounter), Cells(45, Zellcounter + 2)).Value = "X"
                        Range(Cells(47, Zellcounter), Cells(47, Zellcounter + 2)).Value = "-"
                        Range(Cells(46, Zellcounter), Cells(46, Zellcounter + 2)).Value = c
                        Zellcounter = Zellcounter + 3
            Case "_", " ":
                        Zellcounter = Zellcounter + 1
            Case Else: MsgBox "Wrong character in 'Morsezeichen(" & Zeichencode & ")'", vbCritical, "Interner Fehler"
        End Select
    Next Zaehlerincode
End Sub



'------------------------------------------------------------------------------------------------------------------------------------
Public Sub Make_Morsecode()
'------------------------------------------------------------------------------------------------------------------------------------
Dim Zaehler As Double
'Dim Zaehlerincode As Integer
Dim Zeichencode As Integer
Dim Morsezeichen(1 To 255) As String
Dim Morsecode As String
Dim Ditdauer As Double
Dim Spruchanfangende As String
Dim Zellcounter As Long

Application.EnableEvents = False                                            ' 17.10.19: Hardi:
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual

' Morsetable corresponding to ASCII codes
Morsezeichen(32) = "_"

' Additional codes from https://de.wikipedia.org/wiki/Morsezeichen#@-Zeichen  19.10.19: Hardi
' How to handle special signals ?
Morsezeichen(Asc("|fffd|")) = "|fffd| - - |fffd| -"         '
Morsezeichen(Asc("|fffd|")) = "|fffd| - - |fffd| -"         '
Morsezeichen(Asc("|fffd|")) = "|fffd| - |fffd| -"           '
Morsezeichen(Asc("|fffd|")) = "|fffd| - |fffd| |fffd| -"         '
Morsezeichen(Asc("|fffd|")) = "|fffd| |fffd| - |fffd| |fffd|"         '
Morsezeichen(Asc("|fffd|")) = "- - - |fffd|"           '  (OE)
Morsezeichen(Asc("|fffd|")) = "|fffd| |fffd| - -"           '
' ??       "- - - -" CH
Morsezeichen(Asc("|fffd|")) = "|fffd| |fffd| |fffd| - - |fffd| |fffd|"     '  (SZ)
Morsezeichen(Asc("|fffd|")) = "- - |fffd| - -"
Morsezeichen(Asc(".")) = "|fffd| - |fffd| - |fffd| -"       '  (AAA)
Morsezeichen(Asc(",")) = "- - |fffd| |fffd| - -"       '  (MIM)
Morsezeichen(Asc(":")) = "- - - |fffd| |fffd| |fffd|"       '  (OS)
Morsezeichen(Asc(";")) = "- |fffd| - |fffd| - |fffd|"       '  (NNN)
Morsezeichen(Asc("?")) = "|fffd| |fffd| - - |fffd| |fffd|"       '  (IMI)
Morsezeichen(Asc("-")) = "- |fffd| |fffd| |fffd| |fffd| -"       '  (BA)
Morsezeichen(Asc("_")) = "|fffd| |fffd| - - |fffd| -"       '  (UK)
Morsezeichen(Asc("(")) = "- |fffd| - - |fffd|"         '  (KN)
Morsezeichen(Asc(")")) = "- |fffd| - - |fffd| -"       '  (KK)
Morsezeichen(Asc("'")) = "|fffd| - - - - |fffd|"       '  (JN)
Morsezeichen(Asc("=")) = "- |fffd| |fffd| |fffd| -"         '  (BT)
Morsezeichen(Asc("+")) = "|fffd| - |fffd| - |fffd|"         '  (AR)
Morsezeichen(Asc("/")) = "- |fffd| |fffd| - |fffd|"         '  (DN)
Morsezeichen(Asc("@")) = "|fffd| - - |fffd| - |fffd|"       '  (AC)

Morsezeichen(48) = "-_-_-_-_-" ' 0
Morsezeichen(49) = "|fffd|_-_-_-_-"
Morsezeichen(50) = "|fffd|_|fffd|_-_-_-"
Morsezeichen(51) = "|fffd|_|fffd|_|fffd|_-_-"
Morsezeichen(52) = "|fffd|_|fffd|_|fffd|_|fffd|_-"
Morsezeichen(53) = "|fffd|_|fffd|_|fffd|_|fffd|_|fffd|"
Morsezeichen(54) = "-_|fffd|_|fffd|_|fffd|_|fffd|"
Morsezeichen(55) = "-_-_|fffd|_|fffd|_|fffd|"
Morsezeichen(56) = "-_-_-_|fffd|_|fffd|"
Morsezeichen(57) = "-_-_-_-_|fffd|" ' 9

Morsezeichen(65) = "|fffd|_-"         ' A
Morsezeichen(66) = "-_|fffd|_|fffd|_|fffd|"
Morsezeichen(67) = "-_|fffd|_-_|fffd|"
Morsezeichen(68) = "-_|fffd|_|fffd|"
Morsezeichen(69) = "|fffd|"
Morsezeichen(70) = "|fffd|_|fffd|_-_|fffd|"
Morsezeichen(71) = "-_-_|fffd|"
Morsezeichen(72) = "|fffd|_|fffd|_|fffd|_|fffd|"
Morsezeichen(73) = "|fffd|_|fffd|"
Morsezeichen(74) = "|fffd|_-_-_-"
Morsezeichen(75) = "-_|fffd|_-"
Morsezeichen(76) = "|fffd|_-_|fffd|_|fffd|"
Morsezeichen(77) = "-_-"
Morsezeichen(78) = "-_|fffd|"
Morsezeichen(79) = "-_-_-"
Morsezeichen(80) = "|fffd|_-_-_|fffd|"
Morsezeichen(81) = "-_-_|fffd|_-"
Morsezeichen(82) = "|fffd|_-_|fffd|"
Morsezeichen(83) = "|fffd|_|fffd|_|fffd|"
Morsezeichen(84) = "-"
Morsezeichen(85) = "|fffd|_|fffd|_-"
Morsezeichen(86) = "|fffd|_|fffd|_|fffd|_-"
Morsezeichen(87) = "|fffd|_-_-"
Morsezeichen(88) = "-_|fffd|_|fffd|_-"
Morsezeichen(89) = "-_|fffd|_-_-"
Morsezeichen(90) = "-_-_|fffd|_|fffd|"   ' Z

Zellcounter = 6 ' Number of Cell to fill with LED command
Morsecode = Cells(2, 14).Value ' String contains morse text to send
Ditdauer = Cells(3, 14).Value ' Duration of Dit
Spruchanfangende = Cells(4, 14).Value
If Spruchanfangende = "Ja" Then
  Morsecode = "KA " & Morsecode & "AR" ' Add start and end codes to morsecode
End If  ' send start and end code yes/no


Range("F23:EW23").Value = ""
Range("F45:EW45").Value = ""
Range("F46:EW46").Value = ""
Range("F47:EW47").Value = ""

Morsecode = UCase(Morsecode)  ' Set all Letters in Morsecode to uppercase

Cells(23, Zellcounter).Value = Ditdauer ' Duration Ditdauer into first cell of "Dauer"

Dim WrongChar As String
For Zaehler = 1 To Len(Morsecode) ' Loop for length of morse code sentence
    Dim c As String
    c = Mid(Morsecode, Zaehler, 1)
    Zeichencode = Asc(c)
    If c <> "{" And Morsezeichen(Zeichencode) = "" Then                     ' 19.10.19: Hardi
       If InStr(WrongChar, c) = 0 Then
          WrongChar = WrongChar & c & " "
       End If
    End If
    
    If c = "{" Then ' Handle special signals                                ' 19.10.19: Hardi
                        Dim Parts As Variant, ix As Integer
                        Parts = Split(Mid(Morsecode, Zaehler), "}")
                        Select Case Mid(Parts(0), 2)
                          Case "KA", "BT", "AR", "VE", "SK", "SOS", "HH", "OE", "SZ", "AAA", "MIM", "OS", _
                               "NNN", "IMI", "BA", "UK", "KN", "KK", "JN", "BT", "AR", "DN", "AC":
                                      For ix = 2 To Len(Parts(0))
                                          One_Char Asc(Mid(Parts(0), ix, 1)), Zellcounter, Morsezeichen
                                          Zellcounter = Zellcounter + 1
                                      Next
                          Case Else: MsgBox "Unbekanntes Spezial Signal '" & Parts(0) & "}'", vbCritical, "Unbekanntes Signal"
                        End Select
                        Zaehler = Zaehler + Len(Parts(0)) + 1
    Else
        #If 1 Then
        One_Char Zeichencode, Zellcounter, Morsezeichen
        #Else
        For Zaehlerincode = 1 To Len(Morsezeichen(Zeichencode))
            Select Case Mid(Morsezeichen(Zeichencode), Zaehlerincode, 1)
                Case "|fffd|":   Cells(45, Zellcounter).Value = "X"
                            Cells(47, Zellcounter).Value = "."
                            Cells(46, Zellcounter).Value = Mid(Morsecode, Zaehler, 1)
                            Zellcounter = Zellcounter + 1
                Case "-":   Range(Cells(45, Zellcounter), Cells(45, Zellcounter + 2)).Value = "X"
                            Range(Cells(47, Zellcounter), Cells(47, Zellcounter + 2)).Value = "-"
                            Range(Cells(46, Zellcounter), Cells(46, Zellcounter + 2)).Value = Mid(Morsecode, Zaehler, 1)
                            Zellcounter = Zellcounter + 3
                Case "_", " ":
                            Zellcounter = Zellcounter + 1
                Case Else: MsgBox "Wrong character in 'Morsezeichen(" & Zeichencode & ")'", vbCritical, "Interner Fehler"
            End Select
        Next Zaehlerincode
        #End If
    End If
    Zellcounter = Zellcounter + 3
Next

Zellcounter = Zellcounter - 3                                               ' 17.10.19: Hardi
Cells(45, Zellcounter) = "."  ' Turn of the led at the end of the code

If WrongChar <> "" Then
   MsgBox "Achtung die folgenden Zeichen existieren nicht im Morse Alphabet:" & vbCr & _
          "  " & WrongChar & vbCr & _
          "Die Zeichen wurden weggelassen", vbCritical, "Falsche Zeichen erkannt"
End If

If Zellcounter > 148 + 5 Then
   MsgBox "Der Morsecode ist zu lang (" & Zellcounter - 5 & "). Maximal 148 Abschnitte sind m|fffd|glich.", vbInformation, "Morsecode zu lang"
   ' Problem: Der Range mit dem die Macros "CalculatePattern", ... aufgerufen werden ist nicht gr|fffd||fffd|er
   '          damit die Berechnung bei anderen sheets nicht zu lange dauert.
   '          => Erst mal muss diese L|fffd|nge reichen.
End If
Application.EnableEvents = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
ActiveSheet.Calculate

If Cells(5, 14).Value = "Ja" Then
   Simulate_MorseCode Ditdauer, Zellcounter
End If
End Sub

'--------------------------------------------
Private Function Find_Second_Pic() As Variant
'--------------------------------------------
  Dim o As Variant, Nr As Integer
  For Each o In ActiveSheet.Shapes
    'If o.Type <> msoComment Then o.Select ' Debug
    Select Case o.Type
      Case msoPicture, _
           msoLinkedPicture:
                             If o.Name <> "MainMenu" Then
                                Nr = Nr + 1
                                If Nr = 2 Then
                                   Set Find_Second_Pic = o
                                   Exit Function
                                End If
                            End If
      End Select
  Next
  Set Find_Second_Pic = Nothing
End Function

'--------------------------------------------------------------------------------
Private Sub Simulate_MorseCode(ByVal Ditdauer As Long, ByVal Zellcounter As Long)
'--------------------------------------------------------------------------------
    Dim Led_An As Variant, i As Integer
    Set Led_An = Find_Second_Pic
    Dim Zaehler As Long, StartActCell As Long
    Application.Cursor = xlWait ' Otherwise the cursor flashes
    For Zaehler = 6 To Zellcounter
        If Cells(45, Zaehler).Value = "X" Then
             If StartActCell = 0 Then StartActCell = Zaehler
             Cells(46, Zaehler).Interior.ColorIndex = 6
        Else
             If StartActCell > 0 Then
                Range(Cells(46, StartActCell), Cells(46, Zaehler)).Interior.ColorIndex = 2
                StartActCell = 0
             End If
        End If
        
        Led_An.Visible = (Cells(45, Zaehler).Value = "X") ' Show / Hide the flash light
        
        ActiveSheet.Calculate
        DoEvents
        Sleep Ditdauer
    Next
    'Cells(46, Zaehler - 1).Interior.ColorIndex = 2
    If StartActCell > 0 Then
       Range(Cells(46, StartActCell), Cells(46, Zaehler)).Interior.ColorIndex = 2
    End If
    Led_An.Visible = False

    Application.Cursor = xlDefault
End Sub

'UT----------------------------------
Private Sub Test_Simulate_MorseCode()
'UT----------------------------------
  Simulate_MorseCode 240, 30
End Sub


'----------------------------
Private Sub Hide_Second_Pic()
'----------------------------
  Dim Led_An As Variant
  Set Led_An = Find_Second_Pic()
  If Led_An Is Nothing Then
        MsgBox "Fehler die Bilder wurden nicht geladen. Bitte sicherstellen, dass sie in der 'MLL_pcf' Datei VOR dem Button (msoFormControl) stehen.", vbCritical, "Fehler in Beispiel Datei"
  Else: Led_An.Visible = False
  End If
End Sub
Attribute VB_Name = "M8_Tools"
Option Explicit

#If VBA7 Then 'For 64 Bit Systems
  Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) ' 19.10.19:
#Else
  Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

'---------------------------------------
Function IsFilled(c As Range) As Boolean
'---------------------------------------
  IsFilled = Trim(c) <> ""
End Function


'---------------------------------------------------------------
Function LastFilledColumn(Rng As Range, LastRow As Long) As Long
'---------------------------------------------------------------
  Dim c As Range, MaxColumn As Long
  ' Find the last used column
  For Each c In Rng
      If c.Row > LastRow Then Exit For
      If IsFilled(c) And c.Column > MaxColumn Then MaxColumn = c.Column
  Next c
  LastFilledColumn = MaxColumn
End Function

'-----------------------------------------------
Function LastUsedRowIn(Sheet As Variant) As Long
'-----------------------------------------------
' return the last used row in the given sheet.
' The sheet could be given as sheet name or as worksheets variable.
Dim Sh As Variant
  If VarType(Sheet) = vbString Then
        Set Sh = Sheets(Sheet)
  Else: Set Sh = Sheet
  End If
  LastUsedRowIn = Sh.UsedRange.Rows(Sh.UsedRange.Rows.Count).Row
  Set Sh = Nothing
End Function



'---------------------------------------------------------------
Function LastUsedColumnInRow(Sh As Worksheet, Row As Long) As Long
'---------------------------------------------------------------
  LastUsedColumnInRow = Sh.Cells(Row, Sh.Columns.Count).End(xlToLeft).Column
End Function

'---------------------------------------------------------------------------------------------
Function LastFilledRowIn(Sh As Worksheet, FirstCheckCol As Long, LastCheckCol As Long) As Long
'---------------------------------------------------------------------------------------------
  Dim Row As Long
  Row = LastUsedRowIn(Sh)
  With Sh
    'While LastFilledColumn(.Range(.Cells(Row, FirstCheckCol), .Cells(Row, LastCheckCol)), Row) = 0 And Row > 0
    While .Cells(Row, FirstCheckCol).End(xlToRight).Column > LastCheckCol
      Row = Row - 1
    Wend
    LastFilledRowIn = Row
  End With
End Function

'UT------------------------------------------
Private Sub Test_LastFilledRowIn()
'UT------------------------------------------
  Dim Start
  Start = Timer
  Debug.Print LastFilledRowIn(ActiveSheet, 4, Last_LEDsCol) & "Duration: " & Round(Timer - Start, 2)
End Sub

'--------------------------------
Function LastUsedColumn() As Long
'--------------------------------
  LastUsedColumn = ActiveSheet.UsedRange.Columns(ActiveSheet.UsedRange.Columns.Count).Column
End Function

'--------------------------------------------------
Function LastUsedColumnIn(Sheet As Variant) As Long
'--------------------------------------------------
Dim Sh As Variant
  If VarType(Sheet) = vbString Then
        Set Sh = Sheets(Sheet)
  Else: Set Sh = Sheet
  End If

  LastUsedColumnIn = Sh.UsedRange.Columns(Sh.UsedRange.Columns.Count).Column
  Set Sh = Nothing
End Function

'----------------------------------------------------------------------------------------
Private Function Row_Filled_w_Attrib(Rng As Range, LastAttrCheckCol As Long) As Boolean
'----------------------------------------------------------------------------------------
' Check if the row in the given Range is used
' - The whole range is checked for characters
' - Only the first columns until LastAttrCheckCol are checked for fill color
  Dim c As Range
  If Rng.End(xlToRight).Column <= Rng.Column + Rng.Columns.Count Then
     Row_Filled_w_Attrib = True
     Exit Function
  End If
  For Each c In Rng
      If c.Column > LastAttrCheckCol Then Exit Function
      If c.Interior.Color <> 16777215 Then
         Row_Filled_w_Attrib = True
         Exit Function
      End If
  Next c
End Function

'--------------------------------------------------------------------------------------------------------------------------------
Function LastFilledRowIn_w_Attrib(Sh As Worksheet, FirstCheckCol As Long, LastCheckCol As Long, LastAttrCheckCol As Long) As Long
'--------------------------------------------------------------------------------------------------------------------------------
  Dim Row As Long, Last_u_Col As Long
  Row = LastUsedRowIn(Sh)
  With Sh
    While Row_Filled_w_Attrib(.Range(.Cells(Row, FirstCheckCol), .Cells(Row, LastCheckCol)), LastAttrCheckCol) = 0 And Row > 0
      Row = Row - 1
    Wend
    LastFilledRowIn_w_Attrib = Row
  End With
End Function

'UT----------------------------------------
Private Sub Test_LastFilledRowIn_w_Attrib()
'UT----------------------------------------
  Dim Start
  Start = Timer
  Debug.Print LastFilledRowIn_w_Attrib(ActiveSheet, 4, Last_LEDsCol, Last_LEDs_ChkAttrCol) & "Duration: " & Round(Timer - Start, 2)
End Sub


'-------------------------------
Function SheetEx(Name As String)
'-------------------------------
  Dim s As Variant
  For Each s In Sheets
     If s.Name = Name Then
        SheetEx = True
        Exit Function
     End If
  Next
End Function


'---------------------------------------------------------
Function Replace_Illegal_Char(ByVal s As String) As String
'---------------------------------------------------------
  Const OldChars = "|fffd|,  |fffd|,  |fffd|,  |fffd|,  |fffd|,  |fffd|,  |fffd|"
  Const NewChars = "ae, oe, ue, Ae, Oe, Ue, ss"
  Dim OldList() As String, NewList() As String, i As Long, res As String
  OldList = Split(OldChars, ",")
  NewList = Split(NewChars, ",")
  res = s
  For i = 0 To UBound(OldList) - 1
      res = Replace(res, Trim(OldList(i)), Trim(NewList(i)))
  Next
  
  res = Replace(res, " ", "_")
  
  For i = 1 To Len(res)
    Dim c As String * 1
    c = Mid(res, i, 1)
    If c >= "0" And c <= "9" Or _
       c >= "A" And c <= "Z" Or _
       c >= "a" And c <= "z" Or _
       c = "_" Then
       Replace_Illegal_Char = Replace_Illegal_Char & c
    End If
  Next
  
End Function

'UT------------------------------------
Private Sub Test_Replace_Illegal_Char()
'UT------------------------------------
  Debug.Print Replace_Illegal_Char("Hallo Was Geht |fffd||fffd|(2346$ Test")
End Sub

'---------------------------------------------
Function FileNameExt(Name As String) As String
'---------------------------------------------
' Return name and extention without path
Dim Pos As Long, Pos2 As Long, Temp As String
  Pos = InStrRev(Name, "\")
  Pos2 = InStrRev(Name, "/")                             ' 22.11.13: Added to support also links like https://share.gm.com/sites/gmesc/WHO/Shared%20Documents/Documents/Other/Testresults.xlsm
  If Pos2 > Pos Then Pos = Pos2
  If Pos > 0 Then
     Temp = Mid(Name, Pos + 1)
  Else
     Pos = InStrRev(Name, ":")
     If Pos > 0 Then
          Temp = Mid(Name, Pos + 1)
     Else
          Temp = Name
     End If
  End If
  FileNameExt = Temp
End Function

'------------------------------------------------
Function FilePath(ByVal Name As String) As String
'------------------------------------------------
  FilePath = Left(Name, Len(Name) - Len(FileNameExt(Name)))
End Function

'----------------------------------------
Function NoExt(Name As String) As String
'----------------------------------------
' Cut of the extention of a filename
Dim Pos As Long
  Pos = InStrRev(Name, ".")
  If Pos > 0 Then
        NoExt = Left(Name, Pos - 1)
  Else: NoExt = Name
  End If
End Function

'------------------------------------------------
Function FileName(ByVal Name As String) As String
'------------------------------------------------
' Return name without extention and path
  FileName = NoExt(FileNameExt(Name))
End Function

'-------------------------
Sub Protect_Active_Sheet()
'-------------------------
  ActiveSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True, AllowFormattingCells:=True, AllowInsertingHyperlinks:=True
End Sub

'------------------------------------------------------
Private Function GetPathOnly(sPath As String) As String
'------------------------------------------------------
 GetPathOnly = Left(sPath, InStrRev(sPath, "\", Len(sPath)) - 1)
End Function


'--------------------------------------------------------
Public Function CreateFolder(sFolder As String) As String
'--------------------------------------------------------
' http://www.freevbcode.com/ShowCode.asp?ID=257
On Error GoTo ErrorHandler
Dim s As String
s = GetPathOnly(sFolder)
If Dir(s, vbDirectory) = "" Then
  s = CreateFolder(s)
  MkDir s
End If
CreateFolder = sFolder
Exit Function

ErrorHandler:
Exit Function
End Function

'--------------------------------------------
Function NrStr2d(ByVal s As String) As Double
'--------------------------------------------
  If Application.International(xlDecimalSeparator) = "," Then
        NrStr2d = val(Replace(s, ".", ","))
  Else: NrStr2d = val(Replace(s, ",", "."))
  End If
End Function

'-------------------------------------------
Function CorrectKomma(s As String) As String
'-------------------------------------------
If Application.International(xlDecimalSeparator) = "," Then
      CorrectKomma = Replace(s, ".", ",")
Else: CorrectKomma = Replace(s, ",", ".")
End If
End Function

Sub t()
  Dim res As Variant
  res = Application.International(xlDecimalSeparator)
End Sub

Attribute VB_Name = "M9_modKeyState"
Option Explicit
Option Compare Text
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modKeyState
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
' This module contains functions for testing the state of the SHIFT, ALT, and CTRL
' keys.
'
' http://www.cpearson.com/excel/keytest.aspx
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''''
' Declaration of GetKeyState API function. This
' tests the state of a specified key.
''''''''''''''''''''''''''''''''''''''''''''''''''''
#If VBA7 Then 'For 64 Bit Systems
   Private Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer ' 19.10.19:
#Else
   Private Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
#End If
''''''''''''''''''''''''''''''''''''''''''
' This constant is used in a bit-wise AND
' operation with the result of GetKeyState
' to determine if the specified key is
' down.
''''''''''''''''''''''''''''''''''''''''''
Private Const KEY_MASK As Integer = &HFF80 ' decimal -128

'''''''''''''''''''''''''''''''''''''''''
' KEY CONSTANTS. Values taken
' from VC++ 6.0 WinUser.h file.
'''''''''''''''''''''''''''''''''''''''''
Private Const VK_LSHIFT = &HA0
Private Const VK_RSHIFT = &HA1
Private Const VK_LCONTROL = &HA2
Private Const VK_RCONTROL = &HA3
Private Const VK_LMENU = &HA4
Private Const VK_RMENU = &HA5
'''''''''''''''''''''''''''''''''''''''''
' The following four constants simply
' provide other names, CTRL and ALT,
' for CONTROL and MENU. "CTRL" and
' "ALT" are more familiar than
' "CONTROL" and "MENU". These constants
' provide no additional functionality.
' They simply provide more familiar
' names.
'''''''''''''''''''''''''''''''''''''''''
Private Const VK_LALT = VK_LMENU
Private Const VK_RALT = VK_RMENU
Private Const VK_LCTRL = VK_LCONTROL
Private Const VK_RCTRL = VK_RCONTROL

 ''''''''''''''''''''''''''''''''''''''''''''
' The following constants are used to specify,
' when testing CTRL, ALT, or SHIFT, whether
' the Left key, the Right key, either the
' Left OR Right, or BOTH the Left AND Right
' key is down.
'
' By default, the key-test procedures make
' no distinction between the Left and Right
' keys.
''''''''''''''''''''''''''''''''''''''''''''
Public Const BothLeftAndRightKeys = 0   ' Note: Bit-wise AND of LeftKey and RightKey
Public Const LeftKey = 1
Public Const RightKey = 2
Public Const LeftKeyOrRightKey = 3      ' Note: Bit-wise OR of LeftKey and RightKey


Public Function IsShiftKeyDown(Optional LeftOrRightKey As Long = LeftKeyOrRightKey)
''''''''''''''''''''''''''''''''''''''''''''''''
' IsShiftKeyDown
' Returns TRUE or FALSE indicating whether the
' SHIFT key is down.
'
' If LeftOrRightKey is omitted or LeftKeyOrRightKey,
' the function return TRUE if either the left or the
' right SHIFT key is down. If LeftKeyOrRightKey is
' LeftKey, then only the Left SHIFT key is tested.
' If LeftKeyOrRightKey is RightKey, only the Right
' SHIFT key is tested. If LeftOrRightKey is
' BothLeftAndRightKeys, the codes tests whether
' both the Left and Right keys are down. The default
' is to test for either Left or Right, making no
' distiction between Left and Right.
''''''''''''''''''''''''''''''''''''''''''''''''
    Dim res As Long
    
    Select Case LeftOrRightKey
        Case LeftKey
            res = GetKeyState(VK_LSHIFT) And KEY_MASK
        Case RightKey
            res = GetKeyState(VK_RSHIFT) And KEY_MASK
        Case BothLeftAndRightKeys
            res = (GetKeyState(VK_LSHIFT) And GetKeyState(VK_RSHIFT) And KEY_MASK)
        Case Else
            res = GetKeyState(vbKeyShift) And KEY_MASK
    End Select
    
    IsShiftKeyDown = CBool(res)
End Function

Public Function IsControlKeyDown(Optional LeftOrRightKey As Long = LeftKeyOrRightKey) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''
' IsControlKeyDown
' Returns TRUE or FALSE indicating whether the
' CTRL key is down.
'
' If LeftOrRightKey is omitted or LeftKeyOrRightKey,
' the function return TRUE if either the left or the
' right CTRL key is down. If LeftKeyOrRightKey is
' LeftKey, then only the Left CTRL key is tested.
' If LeftKeyOrRightKey is RightKey, only the Right
' CTRL key is tested. If LeftOrRightKey is
' BothLeftAndRightKeys, the codes tests whether
' both the Left and Right keys are down. The default
' is to test for either Left or Right, making no
' distiction between Left and Right.
''''''''''''''''''''''''''''''''''''''''''''''''
    Dim res As Long
    
    Select Case LeftOrRightKey
        Case LeftKey
            res = GetKeyState(VK_LCTRL) And KEY_MASK
        Case RightKey
            res = GetKeyState(VK_RCTRL) And KEY_MASK
        Case BothLeftAndRightKeys
            res = (GetKeyState(VK_LCTRL) And GetKeyState(VK_RCTRL) And KEY_MASK)
        Case Else
            res = GetKeyState(vbKeyControl) And KEY_MASK
    End Select
    
    IsControlKeyDown = CBool(res)

End Function

Public Function IsAltKeyDown(Optional LeftOrRightKey As Long = LeftKeyOrRightKey) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''
' IsAltKeyDown
' Returns TRUE or FALSE indicating whether the
' ALT key is down.
'
' If LeftOrRightKey is omitted or LeftKeyOrRightKey,
' the function return TRUE if either the left or the
' right ALT key is down. If LeftKeyOrRightKey is
' LeftKey, then only the Left ALT key is tested.
' If LeftKeyOrRightKey is RightKey, only the Right
' ALT key is tested. If LeftOrRightKey is
' BothLeftAndRightKeys, the codes tests whether
' both the Left and Right keys are down. The default
' is to test for either Left or Right, making no
' distiction between Left and Right.
''''''''''''''''''''''''''''''''''''''''''''''''
    Dim res As Long
    
    Select Case LeftOrRightKey
        Case LeftKey
            res = GetKeyState(VK_LALT) And KEY_MASK
        Case RightKey
            res = GetKeyState(VK_RALT) And KEY_MASK
        Case BothLeftAndRightKeys
            res = (GetKeyState(VK_LALT) And GetKeyState(VK_RALT) And KEY_MASK)
        Case Else
            res = GetKeyState(vbKeyMenu) And KEY_MASK
    End Select
    
    IsAltKeyDown = CBool(res)

End Function

'UT---------------
Private Sub Test()
'UT---------------
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Test
' This is a procedrue to test and demonstrate the Key-State
' functions above. Since you can't run a macro in the VBA
' Editor if the SHIFT, ALT, or CTRL key is down, this procedure
' uses OnTime to execute the ProcTest test procedure. OnTime
' will call ProcTest two seconds after running this Test
' procedure. Immediately after executing Test, press the
' key(s) (Left/Right SHIFT, ALT, or CTRL) you want to test
' for. The procedure called by OnTime, ProcTest, displays the
' status of the Left/Right SHIFT, ALT, and CTRL keys.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Application.OnTime Now + TimeSerial(0, 0, 2), "ProcTest", , True
End Sub


'UT-------------------
Private Sub ProcTest()
'UT-------------------
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ProcTest
' This procedure simply displays the status of the Left adn Right
' SHIFT, ALT, and CTRL keys.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Debug.Print "SHIFT KEY: ", "LEFT: " & CStr(IsShiftKeyDown(LeftKey)), _
                           "RIGHT: " & CStr(IsShiftKeyDown(RightKey)), _
                           "EITHER: " & CStr(IsShiftKeyDown(LeftKeyOrRightKey)), _
                           "BOTH:   " & CStr(IsShiftKeyDown(BothLeftAndRightKeys))
                        
Debug.Print "ALT KEY:   ", "LEFT: " & CStr(IsAltKeyDown(LeftKey)), _
                           "RIGHT: " & CStr(IsAltKeyDown(RightKey)), _
                           "EITHER: " & CStr(IsAltKeyDown(LeftKeyOrRightKey)), _
                           "BOTH:   " & CStr(IsAltKeyDown(BothLeftAndRightKeys))
                        
Debug.Print "CTRL KEY:   ", "LEFT: " & CStr(IsControlKeyDown(LeftKey)), _
                            "RIGHT: " & CStr(IsControlKeyDown(RightKey)), _
                            "EITHER: " & CStr(IsControlKeyDown(LeftKeyOrRightKey)), _
                            "BOTH:   " & CStr(IsControlKeyDown(BothLeftAndRightKeys))

End Sub

Attribute VB_Name = "MainMenu_Form"
Attribute VB_Base = "0{DF1022AD-C172-4243-9B71-63D512861894}{30D850C5-064B-4385-84CA-C0D1FD04E20E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'------------------------------
Private Sub CloseButton_Click()
'------------------------------
  Unload Me
End Sub

'-----------------------------------------
Private Sub DeleteActualPageButton_Click()
'-----------------------------------------
  Application.Calculation = xlCalculationManual
  Dim Sh As Variant
  For Each Sh In ActiveWindow.SelectedSheets
    With Sh
      If .Name <> "Main" Then
           Application.DisplayAlerts = False
           Sheets(.Name).Delete
           Application.DisplayAlerts = True
      Else
           If ActiveWindow.SelectedSheets.Count = 1 Then
              MsgBox Get_Language_Str("Das Sheet 'Main' kann nicht gel|fffd|scht werden"), vbCritical, Get_Language_Str("Error")
           End If
      End If
    End With
  Next Sh
  Application.Calculation = xlCalculationAutomatic
End Sub

'-------------------------------------------
Private Sub DeleteAlleExamplesButton_Click()
'-------------------------------------------
  Del_All_Sheets_Excep_Main
End Sub

'-----------------------------
Private Sub HelpButton_Click()
'-----------------------------
  Dim HelpName As String, Loc As Variant, ErrMsg As String
  Const Locations = "..\; ;..\Doc\" ' Search in the prior, the current and the 'doc' directory
  For Each Loc In Split(Locations, ";")
      HelpName = ThisWorkbook.Path & "\" & Loc & Get_Language_Str("MobaLedLib Ein kurzer Ueberblick.pdf")
      If Dir(HelpName) = "" Then
            If ErrMsg = "" Then ErrMsg = Get_Language_Str("Fehler: Die Hilfe Datei ist nicht vorhanden:") & vbCr & HelpName
      Else: ActiveWorkbook.FollowHyperlink HelpName
            Exit Sub
      End If
  Next Loc
  
  If MsgBox(ErrMsg & vbCr & vbCr & Get_Language_Str("Soll die Hilfe aus dem Internet ge|fffd|ffnet werden?"), _
            vbQuestion + vbYesNo, Get_Language_Str("Fehler beim |fffd|ffnen der Hilfe")) = vbYes Then
     ActiveWorkbook.FollowHyperlink Get_Language_Str("https://github.com/Hardi-St/MobaLedLib/raw/master/MobaLedLib%20Ein%20kurzer%20Ueberblick.pdf")
  End If
End Sub


'-----------------------------
Private Sub LinkGitHub_Click()
'-----------------------------
  ActiveWorkbook.FollowHyperlink "https://github.com/Hardi-St/MobaLedLib"
End Sub

'-----------------------------
Private Sub LinkStummi_Click()
'-----------------------------
  ActiveWorkbook.FollowHyperlink "https://www.stummiforum.de/viewtopic.php?t=165060"
End Sub



'---------------------------------------
Private Sub LoadAllExamlesButton_Click()
'---------------------------------------
  Application.Calculation = xlCalculationAutomatic ' In case the previous macro was aborted
  
  Application.StatusBar = Get_Language_Str("Lade Beispielseiten...")
  
  Load_Sheets ThisWorkbook.Path & "\" & ExampleDir & "\AllExamples.MLL_pcf"
    
  If Left(Application.StatusBar, Len(Get_Language_Str("Lade Beispielseiten..."))) = Get_Language_Str("Lade Beispielseiten...") Then ' Still the same status line and no error message
     Application.StatusBar = Get_Language_Str("Beispiele geladen")
  End If

  Application.Calculation = xlCalculationAutomatic
End Sub

'------------------------------------
Private Sub LoadExampleButton_Click()
'------------------------------------
  If ExampleName = "" Then ExampleName = Get_MyExampleDir & "\TestExample.MLL_pcf"
  On Error Resume Next
  ChDrive (ExampleName)
  ChDir (FilePath(ExampleName))
  On Error GoTo 0
  Dim res As Variant
  res = Application.GetOpenFilename(fileFilter:=Get_Language_Str("Pattern configurator example (*.MLL_pcf), *.MLL_pcf"), Title:=Get_Language_Str("Load Examples"))
  If res <> False Then
     ExampleName = res
     Application.Calculation = xlCalculationAutomatic ' In case the previous macro was aborted
     Load_Sheets ExampleName
     Application.Calculation = xlCalculationAutomatic
  End If
End Sub

'------------------------------------------
Private Sub SaveActualExampleButton_Click()
'------------------------------------------
  Application.Calculation = xlCalculationManual
  
  If SaveDirCreated = False Then
     ChDir (Get_MyExampleDir())
     SaveDirCreated = True
  End If
     
  If ActiveWindow.SelectedSheets.Count = 1 Then
     ExampleName = Get_MyExampleDir() & "\" & ActiveSheet.Name & "_Example.MLL_pcf"
  End If
  If ExampleName = "" Then ExampleName = Get_MyExampleDir() & "\TestExample.MLL_pcf"
  On Error Resume Next
  ChDrive (ExampleName)
  ChDir (FilePath(ExampleName))
  On Error GoTo 0
  Dim res As Variant
  res = Application.GetSaveAsFilename(ExampleName, fileFilter:=Get_Language_Str("Pattern configurator example (*.MLL_pcf), *.MLL_pcf"), Title:=Get_Language_Str("Save examples"))
  If res <> False Then
     ExampleName = res
     Dim Sh As Variant, AppendSheet As Boolean, Names As String
     For Each Sh In ActiveWindow.SelectedSheets
      With Sh
        .Activate
        Save_One_Sheet ActiveSheet, ExampleName, AppendSheet
        Names = Names & .Name & ", "
        AppendSheet = True
      End With
    Next Sh
    MsgBox Get_Language_Str("Die folgenden Beispiel Seite(n) wurden gespeichert:") & vbCr & _
           "  " & Left(Names, Len(Names) - 2)
  End If
  Application.Calculation = xlCalculationAutomatic
End Sub

'----------------------------------------
Private Sub SaveAllExamplesButton_Click()
'----------------------------------------
  Save_All_Sheets_to Get_MyExampleDir() & "\MyExamples.MLL_pcf"
End Sub


'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  Change_Language_in_Dialog MainMenu_Form
End Sub

Attribute VB_Name = "Modul1"
Sub Makro2()
Attribute Makro2.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro2 Makro
'

'
    With Selection
        .HorizontalAlignment = xlRight
        .VerticalAlignment = xlBottom
        .WrapText = False
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .MergeCells = False
    End With
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'--------------------------------------------------------
Private Sub Worksheet_Change(ByVal Target As Excel.Range)
'--------------------------------------------------------
' This function is called if the worksheet is changed.
' It performs several checks after a user input depending form the column of the changed cell:
  Global_Worksheet_Change Target
End Sub


' InQuest injected base64 decoded content
' jx.j
' jx.j
' jx.j
' 1jjez
' njQ1jjex

INQUEST-PP=macro
