Attribute VB_Name = "A_Main"
Option Explicit
' ---------------------------------------------------------------------------------------
' Haupt-Aufbereitungsroutine
' ---------------------------------------------------------------------------------------

' globale Variablen und Konstanten
'Public Const C_FILENAME_TEMPLATE = "Strukturbericht_template_v0.1.xlsb"
Public Const C_FILENAME_CSV = "MoTeL_Strukturreport.txt"
Public Const C_FILENAME_LOG_FILE = "Strukturbericht_Logfile.txt"
Public Const C_TABELLE_CSVTMP = "CSV"
Public Const C_WS_INPUT = "Kopf mit Parameter"
Public Const C_WS_MSG = "Meldungen"
Public Const C_WS_MODUL = "Modul-Sachnummern"
Public Const C_WS_INITIAL = "initial_sheet"
Public Const C_COLUMN_CONTENT_PICTURE = "PIC"           'Spalte enth|fffd|lt Pfadangabe zu Bildern
Public Const C_COLUMN_CONTENT_LINK = "URL"              'Spalte enth|fffd|lt URL (also einen Link)
Public Const C_COLUMN_CONTENT_STANDARD = "STD"          'Spalte soll in "Standard" formatiert werden

' Dieter Spielbauer 16.11.2016: Freigabelayout
Public Const C_SPRACHE_DE = "D"                         'Sprachkennzeichen (in der CSV-Datei)
Public Const C_SPRACHE_EN = "E"

' Workbook Variablen
Public wb_output   As Workbook   ' Ausgabe Workbook
Public wb_csv      As Workbook   ' Workbook f|fffd|r die CSV-datei
Public wb_template As Workbook   ' Workbook mit dem Template Sheet
Public wb_macro    As Workbook   ' Workbook mit den Makros

' Allgemeine Worksheets
Public ws_output      As Worksheet
Public ws_input       As Worksheet
Public ws_csv         As Worksheet
Public ws_template    As Worksheet
    
'einface variablen
Public gv_LogFile_path    As String
Public lngLogFile         As Long                   'Variable f|fffd|r LogFile
Public gv_col_max         As Long
Public gv_step_desc       As String
Public gv_step            As Integer
Public gv_steps           As Integer
Public objModSpalten      As New spalten
Public lngKommentarSpalte As Long                   'Nummer der Kommentarspalte
Public lngSpalteMax       As Long
Public lngZeilenz|fffd|hler    As Long                   'Offset innerhalb Zielarbeitsblatt
Public gv_filename        As String
Public lngZeilenFixierung As Long                   'Zeile die fixiert werden soll
Public lngSpaltenFixierung As Long                  'Spalte die fixiert werden soll
Public gv_row_cnt_pos_lines As Long                 'Anzahl der Positionszeilen
Public gv_set_pictures     As Boolean               'Logik zum Bilder einf|fffd|gen durchf|fffd|hren
Public gv_set_hyperlinks   As Boolean               'Logik zum Hyperlink einf|fffd|gen durchf|fffd|hren
Public gv_col_odp          As Long                  'Spalte Beziehungswissen
' Dieter Spielbauer 16.11.2016: Freigabelayout
Public gv_sprache         As String                 'Sprachkennzeichen (in der CSV-Datei)

' Entwicklermodus
Public blnAktivEntwickeln As Boolean

'---------------------------------------------------------------------------------------
' Diese Routine wird direkt beim |fffd|ffnen des Workbbok aufgerufen
'--------------------------------------------------------------------------------------
Sub on_auto_open_workbook()
        
    '-------------------------------------------------------
    ' Pr|fffd|fe ob das Makro bereits ausgef|fffd|hrt wurde
    ' Falls ja: CSV-Datei nicht erneut verabeiten
    '-------------------------------------------------------
    Call check_maco_already_run
    
    '--------------------------------------
    ' Stelle fest ob Aktiv entwickelt wird
    '--------------------------------------
    blnAktivEntwickeln = CheckAktivEntwickeln


   ' Userform mit der Fortschrittsinformation anzeigen
   ProgressInformation.Show
   
End Sub

' ---------------------------------------------------------------------------------------
' Einsprungsroutine
' Diese Routine wird beim |fffd|ffnen aufgerufen und
' f|fffd|hrt den kompletten Import und Aufbau des Reports durch
' ---------------------------------------------------------------------------------------
Sub main()

    On Error Resume Next
    
    Const lc_max_steps = 7
    
    Dim bStatusBar       As Boolean
    Dim lv_full_filename As String
'-----------------------------------------------------------------------------------------

    ' schalte Statusleiste an
    gv_set_pictures = False
    gv_set_hyperlinks = False
    bStatusBar = Application.DisplayStatusBar
    Application.DisplayStatusBar = True
    'Im Entwicklermodus die Fortschrittsanzeige ausblenden
    If blnAktivEntwickeln = True Then
        Unload ProgressInformation
    End If
    
    'Ermittle f|fffd|r die Fortschrittsanzeige die Anzahl der zu durchlaufenden Schritte
    gv_steps = lc_max_steps
    gv_step = 0
    
    '------------------------------------------------------------------------------------------
    'LogFile anlegen und Kopf schreiben
    '------------------------------------------------------------------------------------------
    gv_LogFile_path = ActiveWorkbook.Path + "\"
    Kill gv_LogFile_path + C_FILENAME_LOG_FILE
    lngLogFile = CLng(Format(Time, "hh")) * 3600 + CLng(Format(Time, "nn")) * 60 + _
                 CLng(Format(Time, "ss"))
    Call LogFile("Start macro Strukturbericht: " + ActiveWorkbook.name)
    Call LogFile("===========================================================================")


    '------------------------------------------------------------------------------------------
    ' Erzeuge Ausgabe Workbook
    '------------------------------------------------------------------------------------------
    Call Create_Output_Workbook
    
    
    '------------------------------------------------------------------------------------------
    ' CSV Datei importieren
    '------------------------------------------------------------------------------------------
    Call Import_CSV

    
    '------------------------------------------------------------------------------------------
    'Selektionsparameterblatt erstellen
    '------------------------------------------------------------------------------------------
    Call Selektionsparameterblatt
    
    '-------------------------------------------------------------------
    ' Das Sheet mit den Nachrichten-Meldungen erzeugen (falls vorhanden)
    '-------------------------------------------------------------------
    Call Meldungensblatt
    
    '-------------------------------------------------------------------
    ' Das Sheet mit den Modul-Sachnummern erzeugen (falls vorhanden)
    '-------------------------------------------------------------------
    Call Create_ModulSNR_Sheet

    
    '------------------------------------------------------------------------------------------
    'Spalten|fffd|berschriften erstellen
    '------------------------------------------------------------------------------------------
    Call |fffd|berschrift_erstellen
    
    
    '------------------------------------------------------------------------------------------
    'Tabelleninhalt erstellen
    '------------------------------------------------------------------------------------------
    Call Create_Table_Content
    
            
    '------------------------------------------------------------------------------------------
    ' Ausgabesheets formatieren
    '------------------------------------------------------------------------------------------
    Call FormatOutputSheets
    

    ' Dieter Spielbauer 16.11.2016: Freigabelayout
    Call Check_Freigabe_formatieren

    ' Dieter Spielbauer 16.11.2016: Freigabelayout
    If gv_Freigabe_formatieren = True Then
        ' Ausgabesheet im Freigabelayout formatieren
        Call Freigabe_formatieren
        ' l|fffd|sche die Datensheets, wenn nicht im DebugMode
        If blnAktivEntwickeln = False Then
            Call Freigabe_DeleteDataSheets(0)
        End If
    Else
        ' l|fffd|sche die Datensheets, wenn nicht im DebugMode
        If blnAktivEntwickeln = False Then
            Call DeleteDataSheets(0)
        End If
    End If


    '------------------------------------------------------------------------------------------
    ' Speichere die Datei unter einem neuen Namen mit
    ' einem erzeugten Timestamp, falls die Datei zuf|fffd|llig offen ist
    '------------------------------------------------------------------------------------------
    '(Dauert bei 40.000 Zeilen mit 1500 Spalten etwa 80 Sekunden =>Deswegen ggf. deaktivieren, wenn es Kunden zu lange dauert)
    'Call SaveExcelFile

    
    '------------------------------------------------------------------------------------------
    ' Abschlie|fffd|ende Aktivit|fffd|ten
    '------------------------------------------------------------------------------------------
    'Sanduhr ausstellen
    Application.Cursor = xlDefault
    
    'Logfile abschlie|fffd|en
    Call LogFile("===========================================================================")
    Call LogFile("End macro Strukturbericht")
    
    ' Erfolgsmeldung
    Unload ProgressInformation
    DisplayProgress ("Creating report sheets finished ...")
    MsgBox "Creating report sheets finished...", vbInformation
    
    'Stelle Eventing und Screen Updating wieder her
    Application.ScreenUpdating = True
    ' Excel bekommt die Kontrolle |fffd|ber die Statusbar zur|fffd|ck
    Application.StatusBar = False
    Application.DisplayStatusBar = bStatusBar
    
    'Erstelle einenMen|fffd|punkt, |fffd|ber den das Makro von Herrn Leuchtmann
    'aufgerufen werden kann,welches die Analysespalte auswertet
    Call Symbolleiste_erweitern
    
    
    ' schliesse dieses Workbook, dass die Makros enth|fffd|lt
    If blnAktivEntwickeln = False Then
       'wb_macro.Close savechanges:=False
    End If
    
End Sub




Attribute VB_Name = "B_Import"
Option Explicit

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' CSV-Datei importieren
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Import_CSV()
    
    On Error GoTo Fehler
    
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Import CSV file...")
    
    '|fffd|ffne die CSV Datei
    'BEGIN REPLACE - TPA139391 - M.Quintern - 2014-06-13
    '-------------------------------------------------------------------------------------------------------------
    'In den USA wird in CSV-Dateien als dezimaltrenner Komma "," erwartet in Deutschland jedoch ein Semikolon ";"
    'Damit dies unabh|fffd|ngig von den L|fffd|ndereinstellungen einheitlich behandelt werden kann, muss die CSV-Datei
    'als ".TXT" vorliegen. Dann kann beim Workbooks.Open Befehl die Zus|fffd|tze Format & Delimiter benutzen um
    'das Trennzeichen f|fffd|r die CSV-Daten zu definieren. Zus|fffd|tzlich ist es wichtig den Zusatz Local auf False zu setzen
    'damit die lokalen L|fffd|ndereinstellungen nicht gezogen werden
    '-------------------------------------------------------------------------------------------------------------
    'Workbooks.Open Filename:=wb_macro.Path + "\" + C_FILENAME_CSV, Local:=True
    '<QXN0093 - 02.02.2017 - One file>
    If SheetExists(C_TABELLE_CSVTMP) = False Then
      Workbooks.Open Filename:=wb_macro.Path + "\" + C_FILENAME_CSV, Format:=6, Delimiter:=";", Local:=False
      Set wb_csv = ActiveWorkbook
      wb_csv.Sheets(1).Move Before:=wb_output.Sheets(1)
    Else
      Worksheets(C_TABELLE_CSVTMP).Move Before:=wb_output.Sheets(1)
    End If
    '</QXN0093 - 02.02.2017 - One file>
    'Workbooks.Opentest Filename:=wb_macro.Path + "\" + C_FILENAME_CSV, Local:=False, ThousandsSeparator:=".", _
    '                   DecimalSeparator:=",", TextQualifier:="""", Semicolon:=True, DataType:=xlDelimited, Origin:=xlWindows
    'END REPLACE - TPA139391 - M.Quintern - 2014-06-13
    
    'CSV-Sheet in Ausgabeworkbook verschieben

    Set ws_csv = wb_output.Sheets(1)
    ws_csv.name = C_TABELLE_CSVTMP
    
    'maximale Spaltenanzahl ermitteln
    gv_col_max = ws_csv.UsedRange.Columns.Count
    
    Call LogFile(gv_step_desc)
    Exit Sub
        
Fehler:
   'Fehler ausgeben
    MsgBox "Error during import the CSV file. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End
End Sub
' ---------------------------------------------------------------------------------------
' Diese Routine erzeugt das Ausgabeworkbook und kopiert das Template dort hinein
' ---------------------------------------------------------------------------------------
Public Sub Create_Output_Workbook()

Dim lv_template As String
'----------------------------------------------------------------------------------------
    
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Create Output Workbook...")
    
    ' Sichere die globalen Variablen zum aktuellen Workbook
    Set wb_macro = ActiveWorkbook
            
    ' Erzeuge das Ausgabe-Workbook (unter verwendung des templates)
    'lv_template = wb_macro.Path + "\" + C_FILENAME_TEMPLATE
    'Workbooks.Open Filename:=lv_template
    Set wb_output = ActiveWorkbook
    Set ws_output = wb_output.Sheets(C_WS_INITIAL)
    'Set wb_template = ActiveWorkbook
    'Set ws_template = wb_template.Sheets("initial_sheet")
      
    ' Erzeuge das Ausgabe-Workbook (mit einem Dummy-Worksheet)
    'Set wb_output = Workbooks.Add(xlWBATWorksheet)
    'Set wb_output = Workbooks.Add(xlWBATExcel4MacroSheet)
    'Sheets("Tabelle1").Copy Before:=Workbooks("MoTeL_Strukturreport_v8.4.xlsm").Sheets(1)
    'Template sheet mit den makros |fffd|bernehmen
    'ws_template.Copy Before:=wb_output.Sheets(1)
'    Set ws_output = wb_output.Sheets(1)
    
    'Call transfer_macro_code
    'Output Workbook unter neuen namen speichern
    Call save_as_macro
    
    Call LogFile(gv_step_desc)
End Sub

'----------------------------------------------------------------------------------------
' kopiert Modul M_Farben_setzen aus dieser Datei in andere Arbeitsmappe.
'----------------------------------------------------------------------------------------
Sub transfer_macro_code()

 'Modul1 dieser Mappe in neue Datei exportieren
 Dim lv_Pfad As String

 lv_Pfad = ThisWorkbook.Path & "\M_Farben_setzen.bas"

'Modul1 aus dieser Mappe exportieren
 Application.VBE.ActiveVBProject.VBComponents("M_Farben_setzen").export lv_Pfad

 Set wb_output = Workbooks.Add
 Set ws_output = wb_output.Sheets(1)

 'Modul1 in neue Mappe importieren
 With wb_output
  Application.VBE.ActiveVBProject.VBComponents.Import lv_Pfad
 End With

 'Kopie von Modul1 l|fffd|schen
 Kill lv_Pfad

 MsgBox "Modul in neue Mappe kopiert", , ""

End Sub




'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Tabellenblatt aus bestehenden Workbook kopieren
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Copy_Sheet_From_Workbook() As Boolean


    On Error GoTo Fehler
    
    Application.DisplayAlerts = False

    Sheets(1).Copy Before:=wb_output.Sheets(1)

    Application.DisplayAlerts = True

    Copy_Sheet_From_Workbook = True
    Exit Function

Fehler:
   'Fehler ausgeben
    Copy_Sheet_From_Workbook = False
    MsgBox "Ung|fffd|ltiges Datenformat in Datei: '" + ActiveWorkbook.name + "'" + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End

End Function


    





' ---------------------------------------------------------------------------------------
' erzeugt zu einem Bereich aus dem Orignalsheet eines eigenes Worksheet
' Voraussetzung: das richtige Workbook wb2 muss aktuell selektiert sein
' ---------------------------------------------------------------------------------------
Sub Create_Table_Sheet(ws As Worksheet, _
                       sName As String, _
                       iStartRow As Long, _
                       iEndRow As Long)

    Dim wsNew As Worksheet

    ' neues Sheet hinzuf|fffd|gen
    On Error GoTo Fehler

    ' f|fffd|ge ein Sheet hinzu
    Set wsNew = Sheets.Add

    ' nenne das Sheet wie den Namen
    wsNew.name = sName

    ' kopiere den Bereich
    ws.Range(ws.Cells(iStartRow, 1), ws.Cells(iEndRow, 255)).Copy
    ' Paste ihn in das neue Sheet
    wsNew.Paste
    
    Exit Sub
    
Fehler:
    MsgBox Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End

End Sub


' ---------------------------------------------------------------------------------------
' Kopiert den Inhalt der angegebenen Zeilen aus ws in das sheet wsNew
' (Nur Weerte, ohne Formatierungen)
' ---------------------------------------------------------------------------------------
Sub Copy_values_into_sheet(ws As Worksheet, _
                           wsNew As Worksheet, _
                           iStartRow As Long, _
                           iEndRow As Long)


    On Error GoTo Fehler

    ' kopiere den Bereich
    ws.Range(ws.Cells(iStartRow, 1), ws.Cells(iEndRow, gv_col_max)).Copy
    ' Paste ihn in das neue Sheet
    wsNew.Range("A1").PasteSpecial Paste:=xlPasteFormulas
    
    Exit Sub
    
Fehler:
    MsgBox Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End

End Sub
Attribute VB_Name = "C_Insert_Content"
Option Explicit

Dim gv_kommart_col As Long
' ---------------------------------------------------------------------------------------
' Ausgabeshets foramtieren
' ---------------------------------------------------------------------------------------
Public Sub FormatOutputSheets()

    Dim lv_row1 As String
    Dim lv_row2 As String
    Dim lv_rows As String
    Dim lngI As Long
    
    'gv_step = gv_step + 1
    'Call UpdateProgress(gv_step, gv_steps, "Format output sheets...")
    
    'Oberste Zeile mit technischen Spaltenbezeichnungen ausblenden
    ws_output.Rows(1).EntireRow.Hidden = True
    
    'Name f|fffd|r Sheet mit Produktstruktur setzen
    ws_output.name = ws_input.Cells(1, 1).Value
    
    'Fenster fixieren
    ws_output.Cells(lngZeilenFixierung, lngSpaltenFixierung).Select
    ActiveWindow.FreezePanes = True
    
    'Autofilter setzen
    lv_row1 = lngZeilenFixierung - 1
    lv_row2 = gv_row_cnt_pos_lines + lngZeilenFixierung - 1
    lv_rows = lv_row1 + ":" + lv_row2
    ws_output.Rows(lv_rows).AutoFilter
    ' >>>>> Begin Insert - Mirko Quintern - QX43392 - 02.12.2008
    'Pr|fffd|fe f|fffd|r welche Spalte der Autofilter so gesetzt werden soll , sodass keine leeren Werte angezeigt werden
    'For lngI = 1 To objModSpalten.Count
    '    If objModSpalten.Item(lngI).blnSetFilter = True Then
    '        Selection.AutoFilter Field:=objModSpalten.Item(lngI).lngColumnIndex, _
    '                             Criteria1:="<>", _
    '                             Operator:=xlAnd
    '    End If
    'Next
    ' <<<<< Ende  Insert - Mirko Quintern - QX43392 - 02.12.2008
    
    For lngI = 1 To objModSpalten.Count

        'Bedingte Formatierung f|fffd|r Kommunalit|fffd|tsspalten setzen
        If Left(objModSpalten.Item(lngI).strSAPID, 5) = "KOMM_" Then
            Call Set_Conditional_Format_for_KOMM(lngI)
        End If
        ' ab Rel 16.1 auch f|fffd|r die Kommunalit|fffd|tsspalten des Derivats
        If Left(objModSpalten.Item(lngI).strSAPID, 6) = "DKOMM_" Then
            Call Set_Conditional_Format_for_KOMM_derivat(lngI)
        End If
        ' Julian Mayer 9.2.2016: Farbe der Komm-Art doch nicht einf|fffd|rben
        'If Left(objModSpalten.Item(lngI).strSAPID, 13) = "/BMW/PEP_KOMM" Then
        '    Call Set_Conditional_Format_for_KOMMART(lngI)
        'End If
    
    Next lngI
    
    Call LogFile("Process Routine 'FormatOutputSheets'")

End Sub

' ---------------------------------------------------------------------------------------
' Speichere die Datei unter einem neuen Namen mit
' einem erzeugten Timestamp, falls die Datei zuf|fffd|llig offen ist
' ---------------------------------------------------------------------------------------
Sub SaveExcelFile()
Dim lv_excel_version As Long

    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Save created Excel-file ...")
    wb_output.Save

    Call LogFile(gv_step_desc)
End Sub



' ---------------------------------------------------------------------------------------
' l|fffd|sche alle Datensheets aus dem Workbook
' ---------------------------------------------------------------------------------------
Sub DeleteDataSheets(dummy As Integer)

    Dim ws As Worksheet
    
    ' wir wollen keine R|fffd|ckfragen von Excel
    Application.DisplayAlerts = False

    For Each ws In Sheets
        If ws.name <> ws_output.name And _
           ws.name <> C_WS_INPUT And _
           ws.name <> C_WS_MSG And _
           ws.name <> C_WS_MODUL Then
                'Sheet l|fffd|schen
                ws.Delete
        End If
    Next ws

    Application.DisplayAlerts = True
    
    Call LogFile("Delete temporary Worksheets")

End Sub




' ---------------------------------------------------------------------------------------
' Selektionsparameterblatt erstellen
' (INPUT Parameter auf dem Selektionsschirm zur definition desStrukturberichts)
' => Routine wurde aus dem ehemeligen makro zum erstellen des Strukturberichts |fffd|bernommen
'    und geringf|fffd|gig angepasst
' ---------------------------------------------------------------------------------------
Sub Selektionsparameterblatt()
'7.3.06 die Verzeichniszeilen sollen hier auch dargestellt werden

    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Create Sheet with selection parameters...")

    On Error GoTo Fehler
    Dim lngI As Long
    Dim blnVorhanden As Boolean
    Dim lngHeader1 As Long
    Dim lngHeader2 As Long
    Dim lngHeader3 As Long
    Dim lngHeader4 As Long
    Dim lngHeader5 As Long
    Dim lngHeader6 As Long
    Dim i As Long
    Dim StartRow As Long
    Dim EndRow As Long
    Dim LastValue As String
    Dim lv_step As Long
    Const lc_steps As Long = 4
    
    Application.ScreenUpdating = False
    
    
    '---------------------------------------------------------------
    ' jetzt f|fffd|r den Block "K" ein neues Sheet erzeugen
    '---------------------------------------------------------------
    ' Initialisierung
    StartRow = 0
    EndRow = 0
    LastValue = ""
    
    wb_output.Activate
    ' jetzt suche den Bereich "K" und kopiere die Daten in ein neues Worksheet um
    For i = 1 To Sheets(C_TABELLE_CSVTMP).UsedRange.Rows.Count + 1
        If Sheets(C_TABELLE_CSVTMP).Cells(i, 1) <> LastValue Then
            ' kopiere den Bereich in ein eigenes Blatt
            If i > 1 And LastValue = "K" Then
                EndRow = i - 1
                Create_Table_Sheet Sheets(C_TABELLE_CSVTMP), LastValue, StartRow, EndRow
                Set ws_input = Sheets(LastValue)
                blnVorhanden = True
                Exit For
            End If
            StartRow = i
            LastValue = Sheets(C_TABELLE_CSVTMP).Cells(i, 1)
        End If
    Next i

    If blnVorhanden = True Then
        If ws_input.UsedRange.Rows.Count >= 1 And Len(ws_input.Range("A" + CStr(1)).Value) > 0 Then
            blnVorhanden = True
        Else
            blnVorhanden = False
        End If
    End If

    
    If blnVorhanden = True Then
        '|fffd|berfl|fffd|ssiges l|fffd|schen
        For lngI = 4 To 1 Step -1
            ws_input.Columns(lngI).EntireColumn.Delete
        Next
            
        
        'Formatierung der Zeilen
        For lngI = 2 To ws_input.UsedRange.Rows.Count
            Select Case ws_input.Range("C" + CStr(lngI)).Value
            Case "Header1"
                ws_input.Range("A" + CStr(lngI)).Font.Bold = True
            Case "Header2"
                ws_input.Range("A" + CStr(lngI)).Font.Underline = True
            Case "Header3"
                'ws_input.Range("A" + CStr(lngI)).Font.Italic = True
            Case "Header4"
                'no formatting
            Case "Header5"
                'no formatting
            Case "Header6"
                'no formatting
            End Select
        Next
          
        
        ' Gruppierung der Zeilen
        For lngI = 2 To ws_input.UsedRange.Rows.Count
            If ws_input.Range("C" + CStr(lngI)).Value = "Header5" Then
                If ws_input.Range("C" + CStr(lngI + 1)).Value > "Header5" Then
                    lngHeader6 = lngI + 1
                    lngI = lngI + 1
                    Do While ws_input.Range("C" + CStr(lngI + 1)).Value >= ws_input.Range("C" + CStr(lngI)).Value
                        lngI = lngI + 1
                    Loop
                    ws_input.Range(Cells(lngHeader6, 1), Cells(lngI, 1)).Rows.Group
                    
                End If
            End If
        Next
        
        For lngI = 2 To ws_input.UsedRange.Rows.Count
            If ws_input.Range("C" + CStr(lngI)).Value = "Header4" Then
                If ws_input.Range("C" + CStr(lngI + 1)).Value > "Header4" Then
                    lngHeader5 = lngI + 1
                    lngI = lngI + 1
                    Do While ws_input.Range("C" + CStr(lngI + 1)).Value >= ws_input.Range("C" + CStr(lngI)).Value
                        lngI = lngI + 1
                    Loop
                    ws_input.Range(Cells(lngHeader5, 1), Cells(lngI, 1)).Rows.Group
                    
                End If
            End If
        Next
        
        
        
        For lngI = 2 To ws_input.UsedRange.Rows.Count
            If ws_input.Range("C" + CStr(lngI)).Value = "Header3" Then
                If ws_input.Range("C" + CStr(lngI + 1)).Value > "Header3" Then
                    lngHeader4 = lngI + 1
                    lngI = lngI + 1
                    Do While ws_input.Range("C" + CStr(lngI + 1)).Value >= ws_input.Range("C" + CStr(lngI)).Value
                        lngI = lngI + 1
                    Loop
                    ws_input.Range(Cells(lngHeader4, 1), Cells(lngI, 1)).Rows.Group
                    
                End If
            End If
        Next
        
    
        For lngI = 2 To ws_input.UsedRange.Rows.Count
            If ws_input.Range("C" + CStr(lngI)).Value = "Header2" Then
                If ws_input.Range("C" + CStr(lngI - 1)).Value <> ws_input.Range("C" + CStr(lngI)).Value Then
                    lngHeader2 = lngI
                End If
                Do While ws_input.Range("C" + CStr(lngI + 1)).Value >= "Header2"
                    lngI = lngI + 1
                    If ws_input.Range("C" + CStr(lngI)).Value = "Header2" Then
                        ws_input.Range(Cells(lngHeader2 + 1, 1), Cells(lngI - 1, 1)).Rows.Group
                        lngHeader2 = lngI
                    ElseIf ws_input.Range("C" + CStr(lngI + 1)).Value < "Header2" Then
                        ws_input.Range(Cells(lngHeader2 + 1, 1), Cells(lngI, 1)).Rows.Group
                    End If
                Loop
                'ws_input.Range(Cells(lngHeader2, 1), Cells(lngI, 1)).Rows.Group
                
            End If
        Next
        
    
        For lngI = 1 To ws_input.UsedRange.Rows.Count
            If ws_input.Range("C" + CStr(lngI)).Value = "Header1" Then
                If ws_input.Range("C" + CStr(lngI + 1)).Value > "Header1" Then
                    lngHeader1 = lngI
                    Do While ws_input.Range("C" + CStr(lngI + 1)).Value > "Header1"
                        lngI = lngI + 1
                    Loop
                    ws_input.Range(Cells(lngHeader1 + 1, 1), Cells(lngI, 1)).Rows.Group
                    'lngHeader1 = lngI
                End If
            End If
        Next
            
        
        ws_input.UsedRange.Font.Size = 8
        ws_input.Columns(3).EntireColumn.Delete
        'Technische Parameternamen verbergen
        ws_input.Columns(3).EntireColumn.Hidden = True
        ws_input.Columns(2).EntireColumn.HorizontalAlignment = xlLeft
        
        ws_input.Outline.ShowLevels RowLevels:=4
        ws_input.Outline.ShowLevels RowLevels:=3
        ws_input.Outline.ShowLevels RowLevels:=2
        ws_input.Outline.ShowLevels RowLevels:=1
        
        With ws_input.Outline
            .AutomaticStyles = False
            .SummaryRow = xlAbove
            .SummaryColumn = xlRight
        End With
        'ws_input.ApplyOutlineStyles

        ws_input.name = C_WS_INPUT
        ws_input.Columns(1).EntireColumn.AutoFit
    
    End If
    
    Call LogFile(gv_step_desc)
    
    Exit Sub
Fehler:
   'Fehler ausgeben
    MsgBox "Error creating sheet with selection parameters. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End
        
End Sub

' ---------------------------------------------------------------------------------------
' erzeugt zu einem Bereich aus dem Orignalsheet eines eigenes Worksheet
' ---------------------------------------------------------------------------------------
Sub Create_Table_Sheet(ws As Worksheet, _
                       sName As String, _
                       iStartRow As Long, _
                       iEndRow As Long)

    Dim wsNew As Worksheet

    ' f|fffd|ge ein Sheet hinzu
    Set wsNew = Sheets.Add(Sheets(1))

    ' nenne das Sheet wie den Namen
    wsNew.name = sName

    ' kopiere den Bereich
    ws.Range(ws.Cells(iStartRow, 1), ws.Cells(iEndRow, gv_col_max)).Copy
    ' Paste ihn in das neue Sheet
    wsNew.Paste

End Sub



' ---------------------------------------------------------------------------------------
' Die Prozedur |fffd|berschrift_erstellen erstellt drei Spaltenzeilen f|fffd|r den Strukturreport.
' => Routine wurde aus dem ehemeligen Makro zum erstellen des Strukturberichts |fffd|bernommen
'    und geringf|fffd|gig angepasst
' ---------------------------------------------------------------------------------------
Sub |fffd|berschrift_erstellen()

    On Error GoTo Fehler
    Dim strVergleich As String
    Dim strGruppe As String
    Dim lngS1 As Long
    Dim lngS2 As Long
    Dim lngI As Long
    Dim lngY As Long
    Dim lngBezSpalteMax As Long
    Dim lv_ERSTE_BEZ_SPALTE As Long
    Dim strBezug As String
    Dim lv_all_cols As String
    Dim lv_progress_msg As String
    
    
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Set column headers and formats...")
    
    lngZeilenz|fffd|hler = 0
    gv_col_odp = 0
    
    '---------------------------------------------------------------------------
    'Spalteninformationen aus CSV Datei einlesen
    '---------------------------------------------------------------------------
    Informationen_einlesen

    'Spaltenindizes schreiben
    lngS2 = 0
    ws_output.Select

    ' Gehe |fffd|ber alle Spalten
    For lngI = 1 To objModSpalten.Count
        
        lngS2 = lngS2 + 1
                        
        If objModSpalten.Item(lngI).strSAPID = "COMMENT_IND" Then
            lngKommentarSpalte = lngS2
        End If
        
        'SAP-Spalten-ID setzen
        Range(ABezug_berechnen(lngS2) + "1") = objModSpalten.Item(lngI).strSAPID

        'Z|fffd|hle Anzahl der Strukturstufen
        If Left(objModSpalten.Item(lngI).strSAPID, 5) = "PNAME" Then
            lngBezSpalteMax = lngBezSpalteMax + 1
        End If
            
        ' >>>>> Begin Insert - Mirko Quintern - QX43392 - 02.12.2008
        'Spaltenindex puffern
        objModSpalten.Item(lngI).lngColumnIndex = Range(ABezug_berechnen(lngS2) + "1").Column
        ' <<<<< Ende  Insert - Mirko Quintern - QX43392 - 02.12.2008
        
        'Merke ID der BZW Spalte
        If objModSpalten.Item(lngI).strSAPID = "KNOWLEDGE" Then
            gv_col_odp = objModSpalten.Item(lngI).lngColumnIndex
        End If
        lngSpalteMax = lngS2
    Next


    '-----------------------------------------------------------------------------
    'Spaltenformate setzen
    '-----------------------------------------------------------------------------
    'Call LogFile("  Beginn Spaltenformate setzen...")
    'If Not Formate_setzen(objModSpalten) Then
    '    GoTo FEHLER
    'End If
    'Call LogFile("  Ende Spaltenformate setzen...")

    lngZeilenz|fffd|hler = lngZeilenz|fffd|hler + 2
    lngZeilenFixierung = lngZeilenz|fffd|hler + 4

    
    lngS1 = 1
    lngS2 = 1
    lngI = 1
    
    '|fffd|berschriftenzeilen Fett formatieren
    Rows(CStr(lngZeilenz|fffd|hler) + ":" + CStr(lngZeilenz|fffd|hler + 2)).Font.Bold = True

    
    '|fffd|berschriftenzeilen schreiben
    'Call LogFile("  Beginn |fffd|berschriftenzeilen schreiben...")
    lv_all_cols = objModSpalten.Count
    While lngI <= objModSpalten.Count
    

            lngS1 = lngS2
            strVergleich = objModSpalten.Item(lngI).strGruppe
            strGruppe = objModSpalten.Item(lngI).strGruppe
    
            'GruppenSpalte
            Cells(lngZeilenz|fffd|hler, lngS2).Value = objModSpalten.Item(lngI).strGruppe
            
            While lngI <= objModSpalten.Count And _
                  strVergleich = strGruppe
                  
                'Fortschritt f|fffd|r Benutzer aktualisieren
                lv_progress_msg = lngI
                lv_progress_msg = "Process column " + lv_progress_msg + " of " + lv_all_cols
                Call UpdateProgressDetails(lv_progress_msg)
   
                           
                'Spalten|fffd|berschrift setzen
                If objModSpalten.Item(lngI).strFeldname2 <> "" Then
                    Cells((lngZeilenz|fffd|hler + 1), lngS2).Value = _
                        objModSpalten.Item(lngI).strFeldname2
                Else
                    Cells((lngZeilenz|fffd|hler + 1), lngS2).Value = _
                        objModSpalten.Item(lngI).strFeldname1
                End If
                
                'Spaltenbreite
                Columns(lngI).ColumnWidth = objModSpalten.Item(lngI).dblBreite
                
                'Schriftart
                Columns(lngI).Font.name = objModSpalten.Item(lngI).strSchriftart
                'Schriftgr|fffd||fffd|e
                Columns(lngI).Font.Size = objModSpalten.Item(lngI).dblSchriftgrad
                
                'Rahmen setzen, wenn es sich nicht um eine Strukturstufen Spalte handelt
                If Left(objModSpalten.Item(lngI).strSAPID, 5) <> "PNAME" Then
                     Call Rahmen_setzen_range(Range(Cells(lngZeilenz|fffd|hler, lngS2), Cells((lngZeilenz|fffd|hler + 2), lngS2)), xlThin)
                End If
                
                '|fffd|berschrift um 90|fffd| drehen
                If UCase(objModSpalten.Item(lngI).strUeberschriftQuer) = "X" Then
                    With Cells((lngZeilenz|fffd|hler + 1), lngS2)
                        .HorizontalAlignment = xlLeft
                        .Orientation = 90
                    End With
                End If
                
                'Format f|fffd|r Spalte setzen
                If objModSpalten.Item(lngI).strFormat <> "" Then
                    With Range(Selection.Cells(Selection.Cells.Count), Cells(Rows.Count, Selection.Column))
                        .NumberFormatLocal = objModSpalten.Item(lngI).strFormat
                    End With
                End If
                

                
                'Strukturspalten erzeugen
                If Left(objModSpalten.Item(lngI).strSAPID, 5) = "PNAME" And lv_ERSTE_BEZ_SPALTE < 1 Then
                    lv_ERSTE_BEZ_SPALTE = lngS2
                    lngBezSpalteMax = lv_ERSTE_BEZ_SPALTE + lngBezSpalteMax - 1
                    For lngS2 = lngS2 To lngBezSpalteMax
                        
                        
                        If lngS2 < lngBezSpalteMax Then
                            Columns(lngS2).ColumnWidth = 1.45
                            lngI = lngI + 1
                        End If
                        Columns(lngS2).NumberFormat = "@"
                        With Cells((lngZeilenz|fffd|hler + 2), lngS2)
                            .Value = CStr(lngS2 - lv_ERSTE_BEZ_SPALTE)
                            'Schriftart
                            .Font.name = objModSpalten.Item(lngI).strSchriftart
                            'Schriftgr|fffd||fffd|e
                            .Font.Size = objModSpalten.Item(lngI).dblSchriftgrad
                        End With
                    Next
                    'Spaltenbreite der letzten Strukturspalte setzen
                    Columns((lngS2 - 1)).ColumnWidth = objModSpalten.Item(lngI).dblBreite
                Else
                    lngS2 = lngS2 + 1
                End If
                
                lngI = lngI + 1
                If lngI <= objModSpalten.Count Then
                    strGruppe = objModSpalten.Item(lngI).strGruppe
                Else
                    strGruppe = ""
                End If
        Wend
        
        'Spaltengruppe Zellen verbinden
        Range(Cells(lngZeilenz|fffd|hler, lngS1), Cells(lngZeilenz|fffd|hler, (lngS2 - 1))).Select
        Call Rahmen_setzen_range(Range(Cells(lngZeilenz|fffd|hler, lngS1), Cells(lngZeilenz|fffd|hler, (lngS2 - 1))), xlThin)
        If lngS2 > lngS1 + 1 Then
            With Selection
                .HorizontalAlignment = xlCenter
                .MergeCells = True
            End With
        End If
    Wend
    
    'Nach den Strukturspalten soll sp|fffd|ter fixiert werden
    lngSpaltenFixierung = lngBezSpalteMax + 1
    
    'Zeilenumbruch f|fffd|r |fffd|berschriftszeile immer erlauben/aktivieren
    Rows(3).WrapText = True
        
    'Rahmen setzen
    Call Rahmen_setzen(ABezug_berechnen(1) + CStr(lngZeilenz|fffd|hler) + ":" + _
        ABezug_berechnen(lngSpalteMax) + CStr(lngZeilenz|fffd|hler + 2), xlThin)
    
    'Fortschritt ins Logfile
    Call LogFile(gv_step_desc)
    
    Exit Sub
Fehler:
   'Fehler ausgeben
    MsgBox "Error creating column headers. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End

End Sub


' ---------------------------------------------------------------------------------------
' Die Prozedur Informationen_einlesen liest alle Zeilen der CSV Datei in die einzelnen
' Arrays ein.
' ---------------------------------------------------------------------------------------
Private Function Informationen_einlesen() As Boolean

    On Error GoTo Fehler
    Dim lngI As Long
    Dim lngY As Long
    Dim lngZ As Long
    'Dim blnVorhanden As Boolean
    Dim nVorhanden As Long
    Dim lngZeile As Long
    Dim lngSpalte As Long
    Dim blnVerdichtet As Boolean
    Dim blnLeer As Boolean
    Dim strHilfModul As String
    Dim arrLangtextSpalteMod() As Long   'Z|fffd|hler f|fffd|r die LangtextSpalten
    Dim arrLangtextSpalteVIP() As Long   'Z|fffd|hler f|fffd|r die LangtextSpalten
    Dim lngSpaltenNotDisplayMod As Long ' Z|fffd|hler f|fffd|r das Langtextspaltenarray
    Dim lngSpaltenNotDisplayVIP As Long ' Z|fffd|hler f|fffd|r das Langtextspaltenarray
    Dim lngRowCount As Long
    Dim lv_string As String
    Dim strVererbungKommentareMod() As String           'alle Attribute die bei Kommentar vererbt werden sollen
    Dim lngVererbungKommentareMod As Long               'Z|fffd|hler f|fffd|r die Attribute die bei Kommentar vererbt werden sollen
    
    
    ReDim arrLangtextSpalteMod(0)
    ReDim arrLangtextSpalteVIP(0)

    ws_csv.Select

    Set objModSpalten = New spalten
    
    lngRowCount = ActiveSheet.UsedRange.Rows.Count
    For lngI = 1 To lngRowCount
    
                    
        Select Case Range("A" + CStr(lngI)).Value

        Case "O":
            'Name derzu generierenden Excel-Datei setzen
            gv_filename = ActiveSheet.Cells(lngI, 6).Value
' Dieter Spielbauer 16.11.2016: Freigabelayout
            'Sprachkennzeichen aus der CSV-Datei |fffd|bernehmen
            gv_sprache = ActiveSheet.Cells(lngI, 7).Value

        Case "S":
        'Spalteninformation |fffd|ber die Motel-Daten
            If (UCase(CStr(Range("F" + CStr(lngI)).Value)) <> "X") Or _
                UCase(CStr(Range("E" + CStr(lngI)).Value)) = "MODUL" Then
                    objModSpalten.Add ActiveSheet, lngI, strVererbungKommentareMod, lngVererbungKommentareMod
                    If objModSpalten.Item(objModSpalten.Count).blnFormatStandard = True Then
                        arrLangtextSpalteMod(UBound(arrLangtextSpalteMod)) = lngSpaltenNotDisplayMod + objModSpalten.Count
                        ReDim Preserve arrLangtextSpalteMod(UBound(arrLangtextSpalteMod) + 1)
                    End If
            Else
                MsgBox ("In der CSV sind noch Spalten definert die nicht angezeigt werden sollen")
                '###TODO: CSV Datei analysieren!!!!
                Stop
                lngSpaltenNotDisplayMod = lngSpaltenNotDisplayMod + 1
            End If
        Case "P":
            Exit For
            'Positionen |fffd|ber die Modul-Positionen
            'strFehlernummer = "F005"
            'lngDaten = lngDaten + 1
            'objModDaten.Add ActiveSheet, lngI, arrLangtextSpalteMod
        Case Else
        End Select
        
        If Trim(Range("A" + CStr(lngI)).Value) = "" Then
            Exit For
        End If
    Next
                
    Informationen_einlesen = True
    Exit Function
    
Fehler:
   'Fehler ausgeben
    MsgBox "Error reading column information from CSV-file. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End
        
End Function

'*****************************************************************************************
'* Die Prozedur ABezug_berechnen ermittelt aus dem numerischen Spaltenindex den
'* alphanumerischen Spaltenindex.
'**|fffd|nderungsnachweis**********************************************************************
'* V00  07.08.2003  MSG Systems AG
'*****************************************************************************************
Public Function ABezug_berechnen(lngZ|fffd|hler As Long) As String

    'On Error Resume Next
    On Error GoTo Fehler
    Const LC_ABC As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    Dim lv_count_second As Integer
    Dim lv_count_third  As Integer
    Dim lv_count_first  As Integer
'==========================================================================

    If lngZ|fffd|hler <= 26 Then
        lv_count_first = lngZ|fffd|hler
        ABezug_berechnen = Mid(LC_ABC, lngZ|fffd|hler, 1)
        
    ElseIf lngZ|fffd|hler <= 702 Then 'Insert - Mirko Quintern - QX43392 - 28.10.2009
        
        lv_count_first = Fix((lngZ|fffd|hler - 1) / 26)
        lv_count_second = lngZ|fffd|hler Mod 26
        If lv_count_second = 0 Then
            lv_count_second = 26
        End If
            ABezug_berechnen = Mid(LC_ABC, lv_count_first, 1) + _
                               Mid(LC_ABC, lv_count_second, 1)
        
    '>>>>> Begin Insert - Mirko Quintern - QX43392 - 28.10.2009
    Else

        lv_count_first = Fix((lngZ|fffd|hler - 27) / 676)
        
        lv_count_second = Fix((((lngZ|fffd|hler - 27) Mod 676)) / 26) + 1
        If lv_count_second = 0 Then
            lv_count_second = 26
        End If
        
        lv_count_third = lngZ|fffd|hler Mod 26
        If lv_count_third = 0 Then
           lv_count_third = 26
        End If
        
        ABezug_berechnen = Mid(LC_ABC, lv_count_first, 1) + _
                           Mid(LC_ABC, lv_count_second, 1) + _
                           Mid(LC_ABC, lv_count_third, 1)
    '<<<<< End Insert - Mirko Quintern - QX43392 - 28.10.2009
    End If

Exit Function

Fehler:
   'Fehler ausgeben
    MsgBox "Error in routine 'ABezug_berechnen'. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
End Function

'*****************************************************************************************
'* Die Prozedur Formate_setzen formatiert alle Spalten des Strukturreportes.
'**|fffd|nderungsnachweis**********************************************************************
'* V00  07.08.2003  MSG Systems AG
'*****************************************************************************************
Public Function Formate_setzen(objSpalten As spalten) As Boolean

    On Error GoTo Fehler
    Dim lngI As Long
    Dim lngY As Long
    Dim strBezug As String
    Dim lngID As Long
    Dim bModulGefunden As Boolean

    'Call LogFile("  Beginn Formate setzen")
    bModulGefunden = False

    For lngY = 1 To objSpalten.Count
        strBezug = ABezug_berechnen(objSpalten.Item(lngY).lngColumnIndex) _
                   + ":" + _
                   ABezug_berechnen(objSpalten.Item(lngY).lngColumnIndex)

        If objSpalten.Item(lngY).strFormat <> "" Then
            Columns(strBezug).NumberFormatLocal = objSpalten.Item(lngY).strFormat
        Else
            Columns(strBezug).NumberFormat = "@"
        End If
        'Spaltenbreite
        Columns(strBezug).ColumnWidth = objSpalten.Item(lngY).dblBreite
        'Schriftart
        Columns(strBezug).Font.name = objSpalten.Item(lngY).strSchriftart
        'Schriftgr|fffd||fffd|e
        Columns(strBezug).Font.Size = objSpalten.Item(lngY).dblSchriftgrad
        'Automatischer zeilenumbruch
        If Not objSpalten.Item(lngY).lngZeilenumbruch = 0 Then
            Columns(strBezug).WrapText = True
        End If
        'FETT
        If Not objSpalten.Item(lngY).lngFett = 0 Then
            Columns(strBezug).Font.Bold = True
        End If
        'Kursiv
        If Not objSpalten.Item(lngY).lngKursiv = 0 Then
            Columns(strBezug).Font.Italic = True
        End If
        'Unterstrichen
        If Not objSpalten.Item(lngY).lngUnterstrichen = 0 Then
            Columns(strBezug).Font.Underline = xlUnderlineStyleSingle
        End If
        
        'Schriftfarbe
        Columns(strBezug).Font.colorIndex = objSpalten.Item(lngY).lngVordergrund
        'Hintergrundfarbe
        Columns(strBezug).Interior.colorIndex = objSpalten.Item(lngY).lngHintergrund
        'XLS-Standardformat setzen?
        If objSpalten.Item(lngY).blnFormatStandard = True Then
            Columns(strBezug).NumberFormat = "General"
        End If
        
        ' >>> Insert - Mirko Quintern - QX43392 - 25.02.2010
        'Horizontale Ausrichting (L / C / R / oder <space> = Standard )
        If objSpalten.Item(lngY).strHorizontalAlignment = "C" Then
            Columns(strBezug).HorizontalAlignment = xlCenter
        ElseIf objSpalten.Item(lngY).strHorizontalAlignment = "L" Then
            Columns(strBezug).HorizontalAlignment = xlLeft
        ElseIf objSpalten.Item(lngY).strHorizontalAlignment = "R" Then
            Columns(strBezug).HorizontalAlignment = xlRight
        End If
        ' <<< Insert - Mirko Quintern - QX43392 - 25.02.2010
        
        'Rahmen setzen, wenn es sich nicht um eine Strukturstufen Spalte handelt
        If Left(objModSpalten.Item(lngY).strSAPID, 5) <> "PNAME" Then
            With Columns(strBezug).Borders(xlEdgeLeft)
                .LineStyle = xlContinuous
                .Weight = xlThin
                .colorIndex = xlAutomatic
            End With
            With Columns(strBezug).Borders(xlEdgeRight)
                .LineStyle = xlContinuous
                .Weight = xlThin
                .colorIndex = xlAutomatic
            End With
        End If
    Next
        
    Formate_setzen = True
    Exit Function
Fehler:
    Formate_setzen = False
   'Fehler ausgeben
    MsgBox "Error formating headxer columns. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End
    
End Function

'*****************************************************************************************
'* Die Prozedur Rahmen_setzen legt den Rahmen f|fffd|r einen Bezug fest.
'**|fffd|nderungsnachweis**********************************************************************
'* V00  18.08.2003  MSG Systems AG
'*****************************************************************************************
Public Sub Rahmen_setzen(strBezug As String, lngDicke As XlBorderWeight)

    On Error Resume Next
    
    With Range(strBezug).Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With
    With Range(strBezug).Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With
    With Range(strBezug).Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With
    With Range(strBezug).Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With

End Sub

'*****************************************************************************************
'* Die Prozedur Rahmen_setzen legt den Rahmen f|fffd|r einen Bezug fest.
'**|fffd|nderungsnachweis**********************************************************************
'* V00  18.08.2003  MSG Systems AG
'*****************************************************************************************
Public Sub Rahmen_setzen_range(i_range, lngDicke As XlBorderWeight)

    On Error Resume Next
    
    With i_range.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With
    With i_range.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With
    With i_range.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With
    With i_range.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = lngDicke
        .colorIndex = xlAutomatic
    End With

End Sub


'---------------------------------------------------------------------------------------
' Tabelleninhalt erstellen (inklusive Formatierungen)
'------------------------------------------------------------------------------------------
Sub Create_Table_Content()

    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Fill table content...")

    Const lc_steps As Long = 4
    Const lc_max_sheet_rows = 5000
    
    Dim lngI                 As Long
    Dim blnVorhanden         As Boolean
    Dim ws_tab               As New Worksheet
    Dim lngHeader1           As Long
    Dim lngHeader2           As Long
    Dim lngHeader3           As Long
    Dim lngHeader4           As Long
    Dim i                    As Long
    Dim StartRow             As Long
    Dim EndRow               As Long
    Dim LastValue            As String
    Dim lv_row_count         As Double
    Dim lv_row               As Double
    Dim lv_last_row_sheet    As Long
    Dim lv_row_cnt_pos_lines As Long
    Dim lv_sheet_count       As Integer
    Dim lv_sheetname         As String
    Dim lv_paste_row         As Double
    Dim lv_rows              As String
    Dim lv_progress_msg      As String
    Dim lv_finished_lines    As Long
    Dim lv_all_lines         As String
    Dim lv_col               As Long
'-------------------------------------------------------------------------------
        
    On Error GoTo Fehler
    
    Application.ScreenUpdating = False
        
    '---------------------------------------------------------------
    ' jetzt f|fffd|r den Bereich "P" ein neues Sheet erzeugen
    '---------------------------------------------------------------
    ' jetzt suche den Bereich "P" und kopiere die Daten in ein neues Worksheet um
    lv_last_row_sheet = Sheets(C_TABELLE_CSVTMP).UsedRange.Rows.Count
    For i = 1 To lv_last_row_sheet
            
        ' kopiere den Bereich in ein eigenes Blatt und verarbeite diese Daten
        If Sheets(C_TABELLE_CSVTMP).Cells(i, 1).Value = "P" Then
            'Ermittle die Anzahl der Postions-Zeilen
            gv_row_cnt_pos_lines = lv_last_row_sheet - i + 1
            StartRow = i
            'Fertig mit Metadatenbestimmung f|fffd|r Positionszeilenverarbeitung
            '(FOR-Schleife verlassen)
            Exit For
        End If
    Next i
     
    lv_row_cnt_pos_lines = gv_row_cnt_pos_lines
    '------------------------------------------------------------------------
    ' ## Blockabfertigung der Positionszeilen ##
    ' Aus Performacegr|fffd|nden, werden immer nur eine bestimmte maximale Anzahl
    ' von Zeilen in einem sheet verarbeitet
    '------------------------------------------------------------------------
    While lv_row_cnt_pos_lines > 0
        
        
        ' Anzahl der noch zu verarbeitetenden Zeilen neu berechnen
        lv_row_cnt_pos_lines = lv_row_cnt_pos_lines - lc_max_sheet_rows
                
        'Neues workshsheet anlegen
        lv_sheetname = "POS_TMP"
        Set ws_tab = Sheets.Add
        ws_tab.name = lv_sheetname
        
        'Endzeile des Sheets definieren
        EndRow = StartRow + lc_max_sheet_rows
        If EndRow >= lv_last_row_sheet Then
            EndRow = lv_last_row_sheet
        End If
        
        '-----------------------------------------------------------------------------
        'Spaltenformate setzen
        '-----------------------------------------------------------------------------
        ws_tab.Activate
        If Not Formate_setzen(objModSpalten) Then
            GoTo Fehler
        End If
        Columns("A:A").Insert Shift:=xlToRight
        Columns("A:A").Insert Shift:=xlToRight
        'Defaultm|fffd||fffd|ig ist die vertikale Ausrichtung = OBEN
        ws_tab.Cells.VerticalAlignment = xlTop
        
        'Daten ins bereits vorformartierte Sheet einf|fffd|gen
        Call Copy_values_into_sheet(Sheets(C_TABELLE_CSVTMP), ws_tab, StartRow, EndRow)
        'Startzeile f|fffd|r kommenden Block festlegen
        StartRow = EndRow + 1
                                        
        
       '------------------------------------------------------------
       ' Finale Sheet formatierungen durchf|fffd|hren
       '------------------------------------------------------------
       'Zeilengruppierung vornehmen
        lv_row_count = ws_tab.UsedRange.Rows.Count
        For lv_row = 1 To lv_row_count
            If ws_tab.Cells(lv_row, 2).Value = "1" Then
                ws_tab.Rows(lv_row).Group
            End If
        Next
        
        'Steuerspalten l|fffd|schen
        ws_tab.Columns(1).Delete Shift:=xlToLeft
        ws_tab.Columns(1).Delete Shift:=xlToLeft
        

        
        '--------------------------------------------------------------------------------
        ' Ggf. Hyperlinks generieren
        '--------------------------------------------------------------------------------
        If gv_set_hyperlinks = True Then
            
            For lv_col = 1 To objModSpalten.Count
                'Pr|fffd|fe, ob es sich um eine Spalte mit einer URL handelt
                '=>Wenn das dder Fall ist, soll die hinterlegte URL als Hyperlink eingef|fffd|gt werden
                Call Insert_Hyperlink(lv_col, objModSpalten)
            Next
        End If
        
        '  F|fffd|hrende Maskierungszeichen entfernen
        ' (Zahlen die in texten gesichert werden sollen und auch ein plus "+"
        '  mit einem f|fffd|hrenden "'" |fffd|bertragen, damit es vom Excel beim import
        '  nicht als Formel bzw. zahl interpretiert wird)
        Call Remove_Leading_mask_signs(ws_tab)
                
        '--------------------------------------------------------------------------
        'Fertigen Tabellen-Block in das finale Output-Sheet einf|fffd|gen
        '--------------------------------------------------------------------------
        lv_row_count = ws_tab.UsedRange.Rows.Count
        ws_tab.Range(ws_tab.Cells(1, 1), ws_tab.Cells(lv_row_count, lngSpalteMax)).Copy
        lv_rows = ws_tab.UsedRange.Rows.Count
        lv_rows = "1:" + lv_rows
        ws_tab.Rows(lv_rows).Copy
        If lv_paste_row = 0 Then
         lv_paste_row = lngZeilenFixierung
        Else
         lv_paste_row = lv_paste_row + lc_max_sheet_rows + 1
        End If
        ws_output.Cells(lv_paste_row, 1).PasteSpecial
        
        'tempor|fffd|res Worksheet wiederl|fffd|schen
        Application.DisplayAlerts = False
        ws_tab.Delete
        Application.DisplayAlerts = True
        
        'Fortschritt f|fffd|r Benutzer aktualisieren
        lv_finished_lines = lv_finished_lines + lc_max_sheet_rows
        If lv_finished_lines > gv_row_cnt_pos_lines Then
            lv_finished_lines = gv_row_cnt_pos_lines
        End If
        lv_progress_msg = lv_finished_lines
        lv_all_lines = gv_row_cnt_pos_lines
        lv_progress_msg = lv_progress_msg + " lines of " + lv_all_lines + " finished..."
        Call UpdateProgressDetails(lv_progress_msg)
    Wend
    
    'Rahmen unter die letzte Zeile
    lv_row_count = ws_output.UsedRange.Rows.Count
    With ws_output.Range(ws_output.Cells(lv_row_count, 1), ws_output.Cells(lv_row_count, lngSpalteMax)).Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .colorIndex = xlAutomatic
    End With
    
    'Outputsheet aktivieren (selektieren)
    ws_output.Select
    
    'Zeige nur gruppierungsebene 1
    ws_output.Outline.ShowLevels RowLevels:=1
    'Gruppierungskennzeichen vor der Zeile anzeigen
    ws_output.Outline.SummaryRow = xlAbove
    
    'Log schreiben
    Call LogFile(gv_step_desc)
        
        
    
    '--------------------------------------------------------------------------------
    ' Ggf. Bilder einf|fffd|gen
    '--------------------------------------------------------------------------------
    If gv_set_pictures = True Then
        
        lv_progress_msg = "Import Pictures..."
        Call UpdateProgressDetails(lv_progress_msg)
        
        For lv_col = 1 To objModSpalten.Count
            'Pr|fffd|fe, ob es sich um eine Spalte mit der Pfadangabe zu einem Bild handelt
            '=> Wenn das der Fall ist, wird das Bild in die Zelle eingef|fffd|gt
            Call Insert_Picture(lv_col, objModSpalten)
        Next
        
        'Log schreiben
        Call LogFile(lv_progress_msg)
    End If
    
    Exit Sub
    '--------------------------------------------------------------------------------
    ' Ggf. Hyperlinks generieren
    '--------------------------------------------------------------------------------
    If gv_set_hyperlinks = True Then
        
        lv_progress_msg = "Create Hyperlinks..."
        Call UpdateProgressDetails(lv_progress_msg)
        
        For lv_col = 1 To objModSpalten.Count
            'Pr|fffd|fe, ob es sich um eine Spalte mit einer URL handelt
            '=>Wenn das dder Fall ist, soll die hinterlegte URL als Hyperlink eingef|fffd|gt werden
            Call Insert_Hyperlink(lv_col, objModSpalten)
        Next
        
        'Log schreiben
        Call LogFile(lv_progress_msg)
    End If
        
    Exit Sub
Fehler:
   'Fehler ausgeben
    MsgBox "Error creating sheet with table content for ""Strukturbericht"". Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End
        
End Sub

'--------------------------------------------------------------------------------------------------------------
'Pr|fffd|fe, ob es sich um eine Spalte mit der Pfadangabe zu einem Bild handelt
'=> Wenn das der Fall ist, wird das Bild in die Zelle eingef|fffd|gt
'--------------------------------------------------------------------------------------------------------------
Sub Insert_Picture(iv_col As Long, objSpalten As spalten)

Dim lv_row      As Long
Dim lv_start_row As Long
Dim lo_pic      As Picture
Dim lo_pic_tmp  As Picture
Dim lv_pic_path As String
Dim lv_ColumnContent As String
Dim lv_columnwidth As Double

'<QXN0093 - 02.02.2017 - One file>
Dim lo_drw      As Picture
Dim lv_drw_name As String
'</QXN0093 - 02.02.2017 - One file>

On Error Resume Next

lv_start_row = lngZeilenFixierung
' Pr|fffd|fe, ob es sich bei der Spalte um eine handelt, die Bilder enthalten darf
lv_ColumnContent = objSpalten.Item(iv_col).strColumnContent
If lv_ColumnContent = C_COLUMN_CONTENT_PICTURE Then

    'Screenupdating aktivieren
    '(Zwar schlecht f|fffd|r die Performance, aber wenn das nicht gemacht wird kann es vorkommen,
    ' dass das Bild nicht an der richtigen Stelle eingef|fffd|gt wird)
    Application.ScreenUpdating = True
    
    ' Gehe |fffd|ber alle Werte in dieser Spalte
    For lv_row = lv_start_row To ActiveSheet.UsedRange.Rows.Count
    
        If Cells(lv_row, iv_col).Value <> "" Then
        
            Set lo_pic_tmp = Nothing
            Set lo_pic = Nothing
                    
            ' Vollst|fffd|ndigen Pfad vom Bild festlegen
            '<QXN0093 - 02.02.2017 - One file>
            If SheetExists("PIC") = False Then
              lv_pic_path = wb_macro.Path + "\" + Cells(lv_row, iv_col).Value
              Set lo_pic_tmp = ActiveSheet.Pictures.Insert(lv_pic_path)
            Else
                lv_pic_path = Cells(lv_row, iv_col).Value
                'Set lo_pic_tmp = ActiveSheet.Pictures.Insert(lv_pic_path)
                For Each lo_drw In ActiveWorkbook.Worksheets("PIC").DrawingObjects
                    lv_drw_name = lo_drw.name
                    If lv_drw_name = lv_pic_path Then
                        Set lo_pic_tmp = lo_drw
                        Exit For
                    End If
                Next
            End If
            '</QXN0093 - 02.02.2017 - One file>
            If Not lo_pic_tmp Is Nothing Then
                
                'Lege eine Kopie vom Bild an
                '(Ist f|fffd|r Excel-Version 2013 leider notwendig, da ansonsten nur ein Link
                ' zum Bild eingef|fffd|gt wird, was dazu f|fffd|hrt, dass das Bild nicht mehr angezeigt werden kann
                ' wenn das Excel von einem anderen PC aus ge|fffd|ffnet wird auf dem die originalen Bilddateien
                ' nicht vorhanden sind)
                lo_pic_tmp.CopyPicture
                Set lo_pic = ActiveSheet.Pictures.Paste
                lo_pic_tmp.Delete
                
                lo_pic.Top = Cells(lv_row, iv_col).Top + 2
                lo_pic.Left = Cells(lv_row, iv_col).Left + 2
                
                
                Cells(lv_row, iv_col).Value = ""
                
                'Bildgr|fffd||fffd|e ggf. anpasen
                If lo_pic.Height > 300 Then
                    lo_pic.Height = 300
                End If
                If lo_pic.Width > 400 Then
                    lo_pic.Width = 400
                End If
                
                ' ggf Zeilenh|fffd|he an Bild anpassen
                If Rows(lv_row).RowHeight < lo_pic.Height Then
                    'Zeilenh|fffd|he ist in der selben Ma|fffd|einheit wie das Bild
                    Rows(lv_row).RowHeight = lo_pic.Height + 4
                End If
                
                ' ggf. Spaltenbreite an Bild anpassen
                If Columns(iv_col).Width < lo_pic.Width Then
                    'Spaltenbreite ist in einer anderen Ma|fffd|einheit wie das Bild
                    'deswegen muss hier umgerechnet werden
                    Columns(iv_col).ColumnWidth = (lo_pic.Width + 4) * (Columns(iv_col).ColumnWidth / Columns(iv_col).Width)
                End If
                
                'begin of insert, Q366520, 08.09.2015
                'Eigenschaft "Von Zellposition und -gr|fffd||fffd|e abh|fffd|ngig" setzen (muss am Ende der Bildgr|fffd||fffd|enbestimmung passieren)
                lo_pic.Placement = xlMoveAndSize
                'end of insert
                
            End If
        End If
    Next
    'Screensupdating wieder deaktivieren (Grund: Performance)
    Application.ScreenUpdating = False
End If
End Sub

'--------------------------------------------------------------------------------------------------------------
'Pr|fffd|fe, ob es sich um eine Spalte mit einer URL handelt
'=>Wenn das dder Fall ist, soll die hinterlegte URL als Hyperlink eingef|fffd|gt werden
'--------------------------------------------------------------------------------------------------------------
Sub Insert_Hyperlink(iv_col As Long, objSpalten As spalten)

Dim strHelp As String
Dim strLinkname As String
Dim lngRow As Long
Dim strURL As String
Dim lv_ColumnContent As String
Dim lv_start_row As Long

On Error Resume Next
      
lv_start_row = lngZeilenFixierung
lv_start_row = 1

' handelt es sich um die Spalte mit den Linkdaten?
lv_ColumnContent = objSpalten.Item(iv_col).strColumnContent
If lv_ColumnContent = C_COLUMN_CONTENT_LINK Then

    ' Gehe |fffd|ber alle Werte in dieser Spalte
    For lngRow = lv_start_row To ActiveSheet.UsedRange.Rows.Count
    
        'ist ein Link angegeben?
        If InStr(1, Cells(lngRow, iv_col).Value, "<lnk>") <> 0 Then
        
            'Link beim Separateor <lnk> in Linkname und URL aufteilen
            strLinkname = ""
            strURL = ""
            strHelp = Cells(lngRow, iv_col).Value
            'Linknamen ermitteln
            strLinkname = Left(strHelp, InStr(1, strHelp, "<lnk>") - 1)
            'Url ermitteln
            strURL = Mid(strHelp, InStr(1, strHelp, "<lnk>") + 5)
            ' Linknamen zur|fffd|ck in die Zelle schreiben
            If strLinkname <> "" Then
                Cells(lngRow, iv_col).Value = strLinkname
            End If
            'Hyperlink einf|fffd|gen
            If strURL <> "" Then
                ActiveSheet.Hyperlinks.Add Anchor:=Cells(lngRow, iv_col), _
                                           Address:=strURL, _
                                           TextToDisplay:=strLinkname
            End If
        End If
    Next
End If


End Sub ' <<<<< Ende  Insert - Mirko Quintern - QX43392 - 30.04.2009

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Erzeuge sheet mit Meldungen
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sub Meldungensblatt()

    On Error GoTo Fehler
    Dim lngI As Long
    Dim blnVorhanden As Boolean
    Dim sMeld As Worksheet
    Dim i As Long
    Dim StartRow As Long
    Dim EndRow As Long
    Dim LastValue As String
    Dim lv_step As Long
    Const lc_steps As Long = 4
    
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Create Sheet with messages...")
    Application.ScreenUpdating = False
    
    '---------------------------------------------------------------
    ' jetzt f|fffd|r den Block "M" ein neues Sheet erzeugen
    '---------------------------------------------------------------
    ' Initialisierung
    StartRow = 0
    EndRow = 0
    LastValue = ""

    ' jetzt suche den Bereich "M" und kopiere die Daten in ein neues Worksheet um
    For i = 1 To Sheets(C_TABELLE_CSVTMP).UsedRange.Rows.Count + 1
        If Sheets(C_TABELLE_CSVTMP).Cells(i, 1) <> LastValue Then
            ' kopiere den Bereich in ein eigenes Blatt
            If i > 1 And LastValue = "M" Then
                EndRow = i - 1
                Create_Table_Sheet Sheets(C_TABELLE_CSVTMP), LastValue, StartRow, EndRow
                Set sMeld = Sheets(LastValue)
                blnVorhanden = True
                Exit For
            End If
            StartRow = i
            LastValue = Sheets(C_TABELLE_CSVTMP).Cells(i, 1)
        End If
    Next i

    If blnVorhanden = True Then
        If sMeld.UsedRange.Rows.Count >= 1 And Len(sMeld.Range("A" + CStr(1)).Value) > 0 Then
            blnVorhanden = True
        Else
            blnVorhanden = False
        End If
    End If
    
    If blnVorhanden = True Then
        sMeld.UsedRange.Rows.Font.Size = 8
        sMeld.Range("A1").EntireRow.Insert
        sMeld.Range("D1").EntireColumn.Delete
        sMeld.Range("C1").EntireColumn.Delete
        sMeld.Range("A1").EntireColumn.Delete
        
        sMeld.Range("A1").Value = "lfd. Nummer"
        sMeld.Range("B1").Value = "Meldungstyp"
        sMeld.Range("C1").Value = "MeldungsNr"
        sMeld.Range("D1").Value = "MeldungsID"
        sMeld.Range("E1").Value = "Text"
        
        For lngI = 1 To 6
            Rahmen_setzen sMeld.Cells(1, lngI).Address, xlThin
            sMeld.Cells(1, lngI).Font.Bold = True
            sMeld.Columns(lngI).AutoFit
        Next
            
        sMeld.Rows(1).RowHeight = 2 * sMeld.Rows(1).RowHeight
        sMeld.Move After:=Sheets(Sheets.Count)

        sMeld.name = C_WS_MSG
        Set sMeld = Nothing
    End If

    Call LogFile(gv_step_desc)
    Exit Sub
Fehler:
   'Fehler ausgeben
    MsgBox "Error creating sheet with messages. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End
        
End Sub


'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'  F|fffd|hrende Leeerzeichen in der Spalte f|fffd|r das Beziehungswissen entfernen
' (Beziehungswissen wird mit einem f|fffd|hrenden <space> |fffd|bertragen, damit
'  es vom Excel beim import nicht als Formel interpretiert wird)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sub Remove_Leading_Spaces_From_ODP()

    'If gv_col_odp <> 0 Then
        'Columns(gv_col_odp).Replace What:=" +", Replacement:="+", LookAt:=xlPart,
         Cells.Replace What:=" +", Replacement:="+", lookat:=xlPart, _
            SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _
            ReplaceFormat:=False
    'End If

End Sub

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'  F|fffd|hrende Maskierungszeichen ' entfernen
' (Zahlen die in Texten gesichert werden sollen und auch ein plus "+"
'  werden mit einem f|fffd|hrenden "'" |fffd|bertragen, damit es vom Excel beim import
'  nicht als Formel bzw. zahl interpretiert wird)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sub Remove_Leading_mask_signs(i_ws As Worksheet)

i_ws.Cells.Replace What:="'", Replacement:="'", _
                        lookat:=xlPart, _
                        MatchCase:=False, _
                        SearchFormat:=False, ReplaceFormat:=False
   
'Call LogFile("Remove leading mask signs")

End Sub

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'Bedingte Formatierung f|fffd|r Kommunalit|fffd|tsspalten setzen
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sub Set_Conditional_Format_for_KOMM(iv_col As Long)

    With Columns(iv_col)
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""gsa"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""g"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""gt"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""s"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""ssa"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""st"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""n"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""nsa"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""nt"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""sbb"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 8 'hellblau
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""sbbsa"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 8 'hellblau
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""bb"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 5 'blau
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""bbsa"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 5 'blau
            
    End With
  
End Sub
Sub Set_Conditional_Format_for_KOMM_derivat(iv_col As Long)
    
    With Columns(iv_col)
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""n"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""nNT"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""nSA"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""nNTSA"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""s"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""sNT"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""sSA"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""sNTSA"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""g"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""gNT"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""gSA"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""gNTSA"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
    End With
        
End Sub
Sub Set_Conditional_Format_for_KOMMART(iv_col As Long)

    With Columns(iv_col)
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""GT"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 4 'gr|fffd|n
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""ST"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 6 'gelb
        
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""NT"""
        .FormatConditions(Columns(iv_col).FormatConditions.Count).Interior.colorIndex = 3 'rot
            
    End With

End Sub

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' QX43392 - 27.07.2010 - Modul-Sachnummern
' Erzeuge das Sheet mit den Modul-Sachnummern (falls in CSV vorhanden)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sub Create_ModulSNR_Sheet()

    On Error GoTo Fehler
    Dim lngI As Long
    Dim blnColVorhanden As Boolean
    Dim blnHeadVorhanden As Boolean
    Dim blnTabVorhanden As Boolean
    Dim ws_head As Worksheet
    Dim ws_col As Worksheet
    Dim ws_tab As Worksheet
    Dim ws_msnr As Worksheet
    Dim lv_row As Double
    Dim lv_col As Double
    Dim lv_column_idx    As Integer
    Dim rangename        As String
    Dim cellvalue        As String
    Dim pasterow         As Integer
    Dim pastecolumn      As Integer
    Dim end_column As Double
    Dim lv_row_col_desc As Double
    Dim lv_column_count  As Double
    Dim lv_insert_row As Double
    Dim lv_row_count As Double
    Dim i As Long
    Dim StartRow As Long
    Dim EndRow As Long
    Dim LastValue As String
    Dim lv_step As Long
    Const lc_steps As Long = 4
    Dim lv_namespace As String
    
    'Anwender |fffd|ber aktuellen Step informieren
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Create Sheet Modul-Sachnummern...")
    Application.ScreenUpdating = False
   
    Set ws_msnr = Sheets("Modul-Sachnummern")
    '-------------------------------------------------------------------------------
    ' jetzt f|fffd|r die Bl|fffd|cke "HEA_MSNR" "COL_MSNR" "TAB_MSNR" ein neues Sheet erzeugen
    '-------------------------------------------------------------------------------
    ' Initialisierung
    StartRow = 0
    EndRow = 0
    LastValue = ""
    lv_namespace = "HEA_MSNR"

    ' jetzt suche den Bereich "HEA_MSNR" und kopiere die Daten in ein neues Worksheet um
    For i = 1 To Sheets(C_TABELLE_CSVTMP).UsedRange.Rows.Count + 1
        If Sheets(C_TABELLE_CSVTMP).Cells(i, 1) <> LastValue Then
            ' kopiere den Bereich in ein eigenes Blatt
            If i > 1 And LastValue = lv_namespace Then
                EndRow = i - 1
                Create_Table_Sheet Sheets(C_TABELLE_CSVTMP), LastValue, StartRow, EndRow
                Set ws_head = Sheets(LastValue)
                blnHeadVorhanden = True
                Exit For
            End If
            StartRow = i
            LastValue = Sheets(C_TABELLE_CSVTMP).Cells(i, 1)
        End If
    Next i

    ' Initialisierung
    StartRow = 0
    EndRow = 0
    LastValue = ""
    lv_namespace = "COL_MSNR"

    ' jetzt suche den Bereich "HEA_MSNR" und kopiere die Daten in ein neues Worksheet um
    For i = 1 To Sheets(C_TABELLE_CSVTMP).UsedRange.Rows.Count + 1
        If Sheets(C_TABELLE_CSVTMP).Cells(i, 1) <> LastValue Then
            ' kopiere den Bereich in ein eigenes Blatt
            If i > 1 And LastValue = lv_namespace Then
                EndRow = i - 1
                Create_Table_Sheet Sheets(C_TABELLE_CSVTMP), LastValue, StartRow, EndRow
                Set ws_col = Sheets(LastValue)
                blnColVorhanden = True
                Exit For
            End If
            StartRow = i
            LastValue = Sheets(C_TABELLE_CSVTMP).Cells(i, 1)
        End If
    Next i


    ' Initialisierung
    StartRow = 0
    EndRow = 0
    LastValue = ""
    lv_namespace = "TAB_MSNR"

    ' jetzt suche den Bereich "HEA_MSNR" und kopiere die Daten in ein neues Worksheet um
    For i = 1 To Sheets(C_TABELLE_CSVTMP).UsedRange.Rows.Count + 1
        If Sheets(C_TABELLE_CSVTMP).Cells(i, 1) <> LastValue Then
            ' kopiere den Bereich in ein eigenes Blatt
            If i > 1 And LastValue = lv_namespace Then
                EndRow = i - 1
                Create_Table_Sheet Sheets(C_TABELLE_CSVTMP), LastValue, StartRow, EndRow
                Set ws_tab = Sheets(LastValue)
                blnTabVorhanden = True
                Exit For
            End If
            StartRow = i
            LastValue = Sheets(C_TABELLE_CSVTMP).Cells(i, 1)
        End If
    Next i
        
    If blnColVorhanden = True Then
        '-------------------------------------------------------------------------
        ' Spalten im Excelsheet erweitern
        '-------------------------------------------------------------------------
        ' Spaltenanzahl ermitteln
        lv_column_count = ws_col.UsedRange.Rows.Count
        ' Zeile der Spalten|fffd|berschrift ermitteln
        lv_row_col_desc = ws_msnr.Range("COL_MSNR").row
    
        ' Spalten im Excelsheet erweitern
        For lv_column_idx = 4 To lv_column_count
            ' Neue Spalte Einf|fffd|gen
            With ws_msnr.Columns(2)
                 .Copy
                 .Insert Shift:=xlRight
            End With
        Next
        
        '-------------------------------------------------------------------------
        ' Tabelleninhalt f|fffd|llen
        '-------------------------------------------------------------------------
        'Tabelle erweitern
        lv_insert_row = ws_msnr.Range("TAB_MSNR").row + 1
        If blnTabVorhanden = True Then
            lv_row_count = ws_tab.UsedRange.Rows.Count
            For i = 4 To lv_row_count
                ' Neue Zeile Einf|fffd|gen
                With ws_msnr.Rows(lv_insert_row)
                    .Copy
                    .Insert Shift:=xlDown
                End With
            Next
            
            'ermittle die letzte Spalte bis zu welcher kopiert werden soll
            end_column = ws_msnr.Range("END_COLUMN_MSNR").Column
            
            ' Tabelleninhalt kopieren
            ws_tab.Range(ws_tab.Cells(1, 2), ws_tab.Cells(lv_row_count, end_column)).Copy
            ws_msnr.Range("TAB_MSNR").PasteSpecial Paste:=xlPasteFormulas
        End If
        
        '-------------------------------------------------------------------------
        ' Spalten|fffd|berschriften setzen
        '-------------------------------------------------------------------------
        'Jetzt k|fffd|nnen die einzelnen Spalteninformationen eingef|fffd|gt werden
        For lv_column_idx = 1 To lv_column_count
            
            ' Die vierte Spalte soll rechtsb|fffd|ndig sein
            If lv_column_idx = 4 Then
                ws_msnr.Columns(lv_column_idx).EntireColumn.HorizontalAlignment = xlRight
            End If
            
            ' Enter in Zelle simulieren (soll nicht mehr gemacht werden, weil Zahlen teilweise falsch konvertiert werden)
            'If lv_row_count > 1 Then
            '    ws_msnr.Range(ws_msnr.Cells(lv_insert_row - 1, lv_column_idx), _
            '                  ws_msnr.Cells(lv_insert_row + lv_row_count - 1, lv_column_idx)).TextToColumns
            'End If
            
            ' => Spalten|fffd|berschrift setzen
            ws_msnr.Cells(lv_row_col_desc, lv_column_idx).Value = ws_col.Cells(lv_column_idx, 2).Value
            ' => Spaltenbreite optimieren
            ws_msnr.Columns(lv_column_idx).EntireColumn.AutoFit
        Next
        ' Spalten|fffd|berschriften Sollen horizontal links ausgerichtet werden
        ws_msnr.Rows(lv_row_col_desc).EntireRow.HorizontalAlignment = xlLeft
        
        
        'Fensterfixierung setzen (bereits im Template erledigt)
        'ws_msnr.Cells(lv_insert_row, 1).Select
        'ws_msnr.FreezePanes = True
        
        '-------------------------------------------------------------------------
        ' Infos aus dem Header setzen
        '-------------------------------------------------------------------------
        If blnHeadVorhanden = True Then
            lv_col = Range("HEAD_MSNR").Column
            lv_row = Range("HEAD_MSNR").row
            ws_msnr.Cells(lv_row, lv_col).Value = ws_head.Cells(1, 2).Value
            ws_msnr.Cells(lv_row, lv_col + 3).Value = ws_head.Cells(1, 3).Value
        End If
        
        ' wir wollen keine R|fffd|ckfragen von Excel
        Application.DisplayAlerts = False
        If blnHeadVorhanden Then
            ws_head.Delete
        End If
        If blnColVorhanden Then
        ws_col.Delete
        End If
        If blnTabVorhanden Then
            ws_tab.Delete
        End If
        Application.DisplayAlerts = True
    Else
        ' wir wollen keine R|fffd|ckfragen von Excel
        Application.DisplayAlerts = False
        ws_msnr.Delete
        Application.DisplayAlerts = True
    End If
    
    'Anwender |fffd|ber aktuellen Fortschritt im Step informieren
    Call LogFile(gv_step_desc)
    Exit Sub
Fehler:
   'Fehler ausgeben
    MsgBox "Error creating sheet 'Modul-Sachnummern'. Detailed error description:" + Chr(13) & Chr(10) + _
            Err.Description, vbCritical
    'Kompletten Makroablauf beenden
    End
        
End Sub

Attribute VB_Name = "D_HELPFUNCTIONS"
Option Explicit
Public Const C_MEN|fffd|TEXT = "Analysespalte auswerten"
'<QXN0093 - 02.02.2017 - One file>
'-------------------------------------------------------------------------------
' Diese Routine pr|fffd|ft ob das worksheet existiert
'-------------------------------------------------------------------------------
Public Function SheetExists(iv_name As String) As Boolean
    On Error Resume Next
    Dim lo_sht As Worksheet
    For Each lo_sht In ActiveWorkbook.Worksheets
        If lo_sht.name = iv_name Then
          SheetExists = True
          Exit Function
        End If
    Next
    SheetExists = False
 End Function
'</QXN0093 - 02.02.2017 - One file>

'-------------------------------------------------------------------------------
' Diese Routine erzeugt einen Men|fffd|punkt, |fffd|ber den ein Makro aufgerufen werden kann
' wlches die Analysespalte auswertet
'-------------------------------------------------------------------------------
Sub Symbolleiste_erweitern()
Dim commandBarButton As commandBarButton
Call Symbol_l|fffd|schen
Set commandBarButton = Application.CommandBars("Formatting").Controls.Add(msoControlButton)
With commandBarButton
  .Caption = C_MEN|fffd|TEXT
  '.FaceId = 66
  .OnAction = "setColors"
  .Style = msoButtonCaption
  .Visible = True
End With
End Sub

'-------------------------------------------------------------------------------
' Diese Routine entfernt den hinzugef|fffd|gten Men|fffd|punkt wieder
'-------------------------------------------------------------------------------
Sub Symbol_l|fffd|schen()
  On Error Resume Next
  
  'If gv_dont_remove_menu = False Then
      Application.CommandBars("Formatting").Controls(C_MEN|fffd|TEXT).Delete
  'End If
End Sub
' ---------------------------------------------------------------------------------------
' in dieser Routine wird  nach jedem gr|fffd|sseren
' Schritt der Progress in die Statusbar geschrieben
' ---------------------------------------------------------------------------------------
Sub DisplayProgress(sStatusText As String)
    Application.ScreenUpdating = True

    Application.StatusBar = sStatusText

    Application.ScreenUpdating = False
End Sub


' ---------------------------------------------------------------------------------------
' gebe den Dateinamen ohne die Endung zur|fffd|ck
' ---------------------------------------------------------------------------------------
Function GetSaveAsName() As String
    If gv_filename = "" Then
        gv_filename = "Strukturbericht"
    End If
    GetSaveAsName = wb_macro.Path + "\" + gv_filename + "_" + GetTimestamp
End Function


' ---------------------------------------------------------------------------------------
' gebe einen Timestamp zur|fffd|ck
' ---------------------------------------------------------------------------------------
Function GetTimestamp() As String
    Dim s As String, s2 As String

    s = CStr(Year(Now))

    s2 = CStr(Month(Now))
    If Len(s2) = 1 Then
        s2 = "0" + s2
    End If
    s = s + s2

    s2 = CStr(Day(Now))
    If Len(s2) = 1 Then
        s2 = "0" + s2
    End If
    s = s + s2 + "_"

    s2 = CStr(Hour(Now))
    If Len(s2) = 1 Then
        s2 = "0" + s2
    End If
    s = s + s2

    s2 = CStr(Minute(Now))
    If Len(s2) = 1 Then
        s2 = "0" + s2
    End If
    s = s + s2

    s2 = CStr(Second(Now))
    If Len(s2) = 1 Then
        s2 = "0" + s2
    End If
    s = s + s2

    GetTimestamp = s
End Function


' ---------------------------------------------------------------------------------------
' Sch|fffd|tzen des Worksheets und des Workbooks
' ---------------------------------------------------------------------------------------
Public Sub Protect(dummy As Integer)

Dim l_ws1 As Worksheet
Dim pw    As String

    ' Passwort erzeugen => wird nicht gew|fffd|nscht!
    'pw = CStr(Second(Now) + 13) + ws_output.name + CStr(Second(Now) + 27)

    'Jedes Worksheet im Output_Workbook sch|fffd|tzen
    For Each l_ws1 In wb_output.Worksheets
    
        l_ws1.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    Next
    
    ' und auch das Workbook
    wb_output.Protect Password:=pw, Structure:=True, Windows:=False
End Sub




'-------------------------------------------------------------------
'Aktualisiert die User-Form mit den Progress Information
' ( Anwender |fffd|ber aktuellen Stand informieren, damit er wei|fffd|,
'   worauf er gerade wartet und nicht denkt, dass die Anwendung
'   abgest|fffd|rzt ist, oder sich aufgeh|fffd|ngt hat )
'-------------------------------------------------------------------
Sub UpdateProgress(iv_step As Integer, iv_steps As Integer, iv_text As String)

Dim lv_message As String
Dim lv_step    As String
Dim lv_steps   As String

' Erstelle Ausgabenachricht
  lv_step = iv_step
  lv_steps = iv_steps
  gv_step_desc = iv_text
  lv_message = "Step " + lv_step + "/" + lv_steps + ": " + iv_text

    'Aktualisiere die UserForm mit der Progressinformation
    With ProgressInformation
        .FrameProgress.Caption = Format(lv_message)
        .LabelProgress.Width = iv_step / iv_steps * (.FrameProgress.Width - 10)
        .Repaint
    End With
    
    'Gebe die Progress-Nachricht auch in der Statusbar aus
    DisplayProgress (lv_message)
    
    Call UpdateProgressDetails("")
End Sub

Sub UpdateProgressDetails(iv_text As String)

    'Aktualisiere die UserForm mit der Progressinformation
    With ProgressInformation
        .LabelProgress.Caption = iv_text
        .Repaint
    End With
    
End Sub

' Unbenennen von Namensbereichen
Public Sub renames()
Dim lo_name As name
Dim lv_name As String

For Each lo_name In ActiveWorkbook.Names


    If Left(lo_name.name, 6) = "STRUC_" Then
        ' Namensbereich l|fffd|schen
        lv_name = "PART_" + Right(lo_name.name, 2)
        ActiveWorkbook.Names(lo_name.name).name = lv_name
    End If

Next
End Sub

'-----------------------------------------------------------------------
' Show open fiel Dialog to select a filename with path
'-----------------------------------------------------------------------
Function GetSingleFileNameWithPath() As String

Dim Filter As String, Title As String
Dim FilterIndex As Integer
Dim Filename As Variant
'-----------------------------------------------------------------------

' Definefile filters
Filter = "Excel Files (*.xls),*.xls," & _
         "Excel Files (*.xlsx),*.xlsx," & _
         "Text Files (*.txt),*.txt," & _
         "CSV Files (*.csv),*.csv," & _
         "All Files (*.*),*.*"

' Default Filter to *.*
FilterIndex = 5

' Set Dialog Caption
Title = "Select a File to Open"


'ChDrive ("C")
ChDir (ActiveWorkbook.Path)
With Application
    ' Set File Name to selected File
    Filename = .GetOpenFilename(Filter, FilterIndex, Title)
    ' Reset Start Drive/Path
    ChDrive (Left(.DefaultFilePath, 1))
    ChDir (.DefaultFilePath)
End With

' Exit on Cancel
If Filename = False Then
    MsgBox "No file was selected."
    Exit Function
Else
    GetSingleFileNameWithPath = Filename
End If
End Function


'---------------------------------------------------------------------------------------
' VBA stellt standardm|fffd||fffd|ig keine Funktion bereit, um die Endung einer Datei zu ermitteln.
' Sofern diese sich wie |fffd|blich durch einen Punkt getrennt am Ende des Dateinamens befindet,
' l|fffd|sst sich eine solche Funktion allerdings leicht per VBA nachbauen.
' Beschreibung
' Die Funktion DateiendungErmitteln erwartet lediglich die Angabe eines Dateinamens
' mit oder ohne Verzeichnisangabe.
'----------------------------------------------------------------------------------------
Public Function DateiendungErmitteln(strDateiname As String) As String

    DateiendungErmitteln = Mid(strDateiname, InStrRev(strDateiname, ".") + 1)

End Function

'---------------------------------------------------------------------------------------
' Die Funktion DateiNameOhneEndungErmitteln erwartet lediglich die Angabe eines Dateinamens
' ohne(!!) Verzeichnisangabe.
'----------------------------------------------------------------------------------------
Public Function DateiNameOhneEndungErmitteln(strDateiname As String) As String

    DateiNameOhneEndungErmitteln = Left(strDateiname, InStrRev(strDateiname, ".") - 1)

End Function


'----------------------------------------------------------------------------------------
' LogFile schreibt das LogFile
'----------------------------------------------------------------------------------------
Public Sub LogFile(strText As String)

    On Error Resume Next
    Dim lngZeit  As Long
    Dim strZeile As String
    
    lngZeit = CLng(Format(Time, "hh")) * 3600 + CLng(Format(Time, "nn")) * 60 + _
        CLng(Format(Time, "ss"))
        
    strZeile = Format(Date, "dd.mm.yyyy") + " " + Format(Time, "hh:nn:ss") + "  " + _
        Format(lngZeit - lngLogFile, "00") + " sec.  " + strText
    
    Open gv_LogFile_path + C_FILENAME_LOG_FILE For Append As #1
    Write #1, strZeile
    Close #1
    lngLogFile = lngZeit

End Sub


'----------------------------------------------------------------------------------------
' Pr|fffd|fe ob das Makro bereits ausgef|fffd|hrt wurde
' Falls ja: CSV-Datei nicht erneut verabeiten
'----------------------------------------------------------------------------------------
Sub check_maco_already_run()
On Error Resume Next
Dim ws_initial As Worksheet

' Ist das initialie Sheet noch da?
Set ws_initial = Sheets(C_WS_INITIAL)

If ws_initial Is Nothing Then
    'Nein: Dann Makro beenden
    End
End If



End Sub
Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Dim already_started As Boolean

Private Sub Workbook_Open()
    
    'Erstelle einen Men|fffd|punkt, |fffd|ber den das Makro von Herrn Leuchtmann
    'aufgerufen werden kann,welches die Analysespalte auswertet
    Call Symbolleiste_erweitern
    
    'Diese Routine wird beim |fffd|ffnen des Excel datei durchlaufen
    If already_started = False Then
        already_started = True
        Call on_auto_open_workbook
    End If
End Sub

'---------------------------------------------------------------------------------------
' Diese Routine wird aufgerufen wenn der User auf "Inhalte aktivieren" klickt
'--------------------------------------------------------------------------------------
Private Sub Workbook_Activate()
    ' Prozessiere normale Startmethode
    If already_started = False Then
        already_started = True
        Call on_auto_open_workbook
    End If
End Sub


Private Sub Workbook_BeforeClose(Cancel As Boolean)
    'Entferne den Men|fffd|punkt, |fffd|ber den das Makro von Herrn Leuchtmann
    'aufgerufen werden kann, welches die Analysespalte auswertet
    Call Symbol_l|fffd|schen
End Sub


Attribute VB_Name = "E_SAVE"
Option Explicit
'-----------------------------------------------------------------------------
' Excel-Datei im neuen Format speichern
'-----------------------------------------------------------------------------
Sub save_new()
    wb_output.SaveAs FileFormat:=xlOpenXMLWorkbook, ConflictResolution:=xlUserResolution, _
       Filename:=GetSaveAsName + ".xlsx"
End Sub
'-----------------------------------------------------------------------------
' Excel-Datei im neuen Format speichern
'-----------------------------------------------------------------------------
Sub save_as_macro()
    wb_output.SaveAs FileFormat:=xlOpenXMLWorkbookMacroEnabled, ConflictResolution:=xlUserResolution, _
       Filename:=GetSaveAsName + ".xlsm"
End Sub
Attribute VB_Name = "FREIGABE_Anleitung_E"
Attribute VB_Base = "0{816F1545-E35A-4783-B6F1-6D7BCBCDBE75}{928F6EF2-D08C-4BD4-8190-E8C894877343}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




Private Sub CheckBox1_Click()

    Range("B1") = CheckBox1
    
End Sub

Private Sub CommandButton1_Click()

    Unload Me
    
End Sub

Private Sub Image1_Click()

End Sub

Private Sub Label10_Click()

End Sub

Private Sub Label2_Click()

End Sub

Private Sub Label4_Click()

End Sub

Private Sub Label7_Click()

End Sub

Private Sub Label8_Click()

End Sub

Private Sub Label9_Click()

End Sub

Private Sub UserForm_Click()

End Sub
Attribute VB_Name = "F_FREIGABE_Formatieren"
' Dieter Spielbauer 16.11.2016: Freigabelayout
' Dieter Spielbauer 27.03.2017: Erweiterungen zum Rel. 17.1
' Dieter Spielbauer 20.11.2017: Erweiterungen nach Rel. 17.2

' ---------------------------------------------------------------------------------------
'Globale Konstanten zum FREIGABE Makro
Public Const C_WS_VORLAGE = "Freigabe_Vorlage"
Public Const C_WS_TEXTELEMENTE = "Textelemente"
Public Const C_WS_WERTETABELLEN = "Wertetabellen"
Public Const C_WS_FREIGABE_OUTPUT = "Freigabe_St|fffd|cklistenbericht"

Public Const C_LAYOUT_FREIGABE = "/FREIGABE"

'Globale Variablen
Public gv_Freigabe_formatieren As Boolean
Public gv_ws_freigabe_output As String

' ---------------------------------------------------------------------------------------
'Pr|fffd|fen ob Formatierung nach Freigabe vorliegt
' ---------------------------------------------------------------------------------------
Sub Check_Freigabe_formatieren()

    Dim rng As Range

    'Pr|fffd|ft ob Layoutvariante /FREIGABE verwendet wurde
    Set rng = ActiveWorkbook.Sheets(C_WS_INPUT).Range("C:C").Find("P_LAYOUT", lookat:=xlWhole)
    
    If rng Is Nothing Then
        gv_Freigabe_formatieren = False
        Exit Sub
    End If
    
    If ActiveWorkbook.Sheets(C_WS_INPUT).Cells(rng.row, 2) = C_LAYOUT_FREIGABE Then
        gv_Freigabe_formatieren = True
    Else
        gv_Freigabe_formatieren = False
    End If

End Sub

' ---------------------------------------------------------------------------------------
'Strukturbericht entsprechend dem FREIGABE-Layout umformatieren
' ---------------------------------------------------------------------------------------
Sub Freigabe_formatieren()
    
    Const c_col_width_struktur = 1          'Spalten 1 bis (z-1) des Strukturblocks
    Const c_col_width_struktur_letzte = 37  'Letzte Spalte des Strukturblocks
    Const c_row_height_header = 165         'Zeilenh|fffd|he f|fffd|r Spalten|fffd|berschriften
    Const c_row_height_daten = 13           'Zeilenh|fffd|he f|fffd|r Datenzeilen
        
    Dim letzte_spalte As Double
    Dim letzte_zeile As Double

    Dim vorlage_letzte_spalte As Double
    Dim position_alt, position_neu As Double
    Dim spaltenname As String
    Dim spalten_texte() As String
    
    Dim idx_vorlage, idx_spalte, anzahl As Double
    Dim anzahl_spalten_struktur, anzahl_spalten_typen As Double
    Dim anzahl_filter As Double
    Dim rng, rn2, rn3 As Range
    Dim idx_zeile As Double

    Call LogFile("Freigabeformat Beginn")
    
    On Error GoTo Fehler
    
    gv_steps = 4
    gv_step = 1
    Call UpdateProgress(gv_step, gv_steps, "Freigabeformat prepare ...")

'Tabelle mit sprachabh|fffd|ngigen Textelementen vorbereiten
    Call LogFile("sprachabh|fffd|ngige Textelemente vorbereiten")
    Call Prepare_Textelemente
    
'Wertetabellen mit sprachanbh|fffd|ngigen Text erg|fffd|nzen
    Call LogFile("Wertetabellen erg|fffd|nzen")
    Call Prepare_Wertetabellen
    
'letzte Spalte und Zeile im Strukturbericht ermitteln
    Sheets(ws_output.name).Activate
    letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
    letzte_zeile = ActiveCell.SpecialCells(xlLastCell).row

'Screenupdate aus
    With Application
        .ScreenUpdating = False
        .EnableEvents = False
        .Calculation = xlCalculationManual
    End With

'Vorformatiern Kopfbereich
    Call LogFile("Vorformatiern Kopfbereich")
    
    'Zeile mit |fffd|berschriften zu Spaltengruppen l|fffd|schen
    Rows("2:2").EntireRow.Delete Shift:=xlUp
      
    'Zeilen mit Spalten|fffd|berschriften vorformatieren
    Range(Cells(2, 1), Cells(4, letzte_spalte)).Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .ThemeColor = 1
        .TintAndShade = 0
        .Weight = xlThick
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .ThemeColor = 1
        .TintAndShade = 0
        .Weight = xlThick
    End With
    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .ThemeColor = 1
        .TintAndShade = 0
        .Weight = xlThick
    End With
    With Selection.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .ThemeColor = 1
        .TintAndShade = 0
        .Weight = xlThick
    End With
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = RGB(126, 115, 84)
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorAccent1
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .ThemeColor = xlThemeColorDark1
        .TintAndShade = 0
    End With

'DS 27.03.17
'Gruppierungen zu Zeilen kopieren
    Call LogFile("Gruppierungen zu Zeilen kopieren")
    Sheets(ws_output.name).Activate
    Range(Rows(5), Rows(letzte_zeile)).EntireRow.Copy
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    Rows(5).EntireRow.Insert
    Range(Columns(1), Columns(letzte_spalte)).EntireColumn.Delete
    
'Spalten entsprechend der Vorlage umsortieren und in neues Worksheet |fffd|bernehmen
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Freigabeformat resort columns ...")
    
    Call LogFile("Spalten entsprechend der Vorlage umsortieren")
    
    Sheets(C_WS_VORLAGE).Activate
    vorlage_letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
    
'   Alle Spalten in der Vorlage verarbeiten und die Spalten im Strukturbericht dabei
'   entsprechend der Reihenfolge der Vorlage umsortieren
    idx_vorlage = 1
    Do While idx_vorlage <= vorlage_letzte_spalte

        Sheets(C_WS_VORLAGE).Activate
        spaltenname = Cells(1, idx_vorlage)
        
        If spaltenname = "" Then
            Exit Do
        End If
        
        Sheets(ws_output.name).Activate
        
        If spaltenname = "PNAME_XX" Then
            'Strukturspalten -> als Block verschieben
            Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("PNAME_", lookat:=xlPart)
            position_alt = rng.Column
            'Anzahl der vorhandenen Spalten im Strukturblock ermitteln
            idx_spalte = position_alt
            anzahl = 0
            Do While idx_spalte <= letzte_spalte
                idx_spalte = idx_spalte + 1
                If Left(Cells(1, idx_spalte), 6) = "PNAME_" Then
                    anzahl = anzahl + 1
                Else
                    Exit Do
                End If
            Loop
            position_neu = position_neu + 1
            Range(Columns(position_alt), Columns(position_alt + anzahl)).EntireColumn.Cut
            Sheets(C_WS_FREIGABE_OUTPUT).Activate
            Columns(position_neu).EntireColumn.Insert Shift:=xlToRight
            position_neu = position_neu + anzahl
            
            'Index f|fffd|r die Verarbeitung der Vorlage verschieben
            Sheets(C_WS_VORLAGE).Activate
            anzahl = 0
            Do While idx_vorlage <= vorlage_letzte_spalte
                idx_vorlage = idx_vorlage + 1
                If Cells(1, idx_vorlage) = "PNAME_XX" Then
                    anzahl = anzahl + 1
                Else
                    Exit Do
                End If
            Loop
            anzahl_spalten_struktur = anzahl
            
'DS 20.11.17 Filterspalten
        ElseIf spaltenname = "FLT_XX" Then
            'Filterspalten (falls vorhanden!) -> als Block verschieben
            Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("FLT_", lookat:=xlPart)
            If Not rng Is Nothing Then
                position_alt = rng.Column
                'Anzahl der vorhandenen Filterspalten ermitteln
                idx_spalte = position_alt
                anzahl = 0
                Do While idx_spalte <= letzte_spalte
                    idx_spalte = idx_spalte + 1
                    If Left(Cells(1, idx_spalte), 4) = "FLT_" Then
                        anzahl = anzahl + 1
                    Else
                        Exit Do
                    End If
                Loop
                position_neu = position_neu + 1
                Range(Columns(position_alt), Columns(position_alt + anzahl)).EntireColumn.Cut
                Sheets(C_WS_FREIGABE_OUTPUT).Activate
                Columns(position_neu).EntireColumn.Insert Shift:=xlToRight
                position_neu = position_neu + anzahl
                'Anzahl der vorhandenen Filter
                anzahl_filter = anzahl + 1
            End If
            idx_vorlage = idx_vorlage + 1
        
        ElseIf spaltenname = "TYPR_XX" Then
            'Typspalten (falls vorhanden!) -> als Block verschieben
            Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("TYPR_", lookat:=xlPart)
            If Not rng Is Nothing Then
                position_alt = rng.Column
                'Anzahl der vorhandenen Typspalten ermitteln
                idx_spalte = position_alt
                anzahl = 0
                Do While idx_spalte <= letzte_spalte
                    idx_spalte = idx_spalte + 1
                    If Left(Cells(1, idx_spalte), 5) = "TYPR_" Then
                        anzahl = anzahl + 1
                    Else
                        Exit Do
                    End If
                Loop
                position_neu = position_neu + 1
                Range(Columns(position_alt), Columns(position_alt + anzahl)).EntireColumn.Cut
                Sheets(C_WS_FREIGABE_OUTPUT).Activate
                Columns(position_neu).EntireColumn.Insert Shift:=xlToRight
                position_neu = position_neu + anzahl
            End If
            idx_vorlage = idx_vorlage + 1
        
        Else
            'Sonstige Spalten
            Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
            If rng Is Nothing Then
                'Zus|fffd|tzliche Spalten in der Vorlage die im Original nicht vorhanden sind -> leere Spalten einf|fffd|gen
                position_neu = position_neu + 1
                Sheets(C_WS_FREIGABE_OUTPUT).Activate
                Columns(position_neu).Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove
                Cells(1, position_neu) = spaltenname
                letzte_spalte = letzte_spalte + 1
                idx_vorlage = idx_vorlage + 1
    
            Else
                'normale Spalte im Original vorhanden -> gegebenenfalls verschieben
                position_alt = rng.Column
                position_neu = position_neu + 1
 
                idx_spalte = position_alt
                anzahl = 0
                Do While idx_vorlage <= vorlage_letzte_spalte
                    'n|fffd|chste Spalte pr|fffd|fen
                    Sheets(C_WS_VORLAGE).Activate
                    idx_vorlage = idx_vorlage + 1
                    spaltenname = Cells(1, idx_vorlage)
                    
                    If spaltenname = "" Then
                        Exit Do
                    End If
                    
                    Sheets(ws_output.name).Activate
                    idx_spalte = idx_spalte + 1
                    
                    'Pr|fffd|fen ob nachfolgende Spalten in Vorlage und Original identisch sind
                    If Cells(1, idx_spalte) = spaltenname Then
                        anzahl = anzahl + 1
                    Else
                        Exit Do
                    End If
                Loop
                'If position_alt <> position_neu Then
                    Sheets(ws_output.name).Activate
                    Range(Columns(position_alt), Columns(position_alt + anzahl)).EntireColumn.Cut
                    Sheets(C_WS_FREIGABE_OUTPUT).Activate
                    Columns(position_neu).EntireColumn.Insert Shift:=xlToRight
                'End If
                position_neu = position_neu + anzahl
                
            End If
            
        End If
    Loop
    
'   Letzte Spalte im neu aufgebauten Worksheet ermitteln
'DS 27.03.17
    'Sheets(C_WS_FREIGABE_OUTPUT).Activate
    'letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
    letzte_spalte = position_neu

'   Vor dem Kopieren des Kopfbereichs aus der Vorlage alle Spalten|fffd|berschriften ermitteln
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    idx_spalte = 0
    Do While idx_spalte < letzte_spalte
        idx_spalte = idx_spalte + 1
        ReDim Preserve spalten_texte(idx_spalte)
        'Pr|fffd|fen ob zur Spalte ein abweichender Text vorhanden ist
        spalten_texte(idx_spalte) = GetTextelementByID("S", Cells(1, idx_spalte))
        If spalten_texte(idx_spalte) = "" Then
            '..ansonsten den Text aus dem Strukturbericht |fffd|bernehmen
            spalten_texte(idx_spalte) = RTrim(Cells(2, idx_spalte))
        End If
    Loop

'Kopfbereich aus der Vorlage kopieren"
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Freigabeformat copy header ...")
    
    Call LogFile("Kopf kopieren")

    'Teil1 Anfang bis Strukturspalten
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find("PNAME_XX", lookat:=xlWhole)
    ActiveSheet.Range(Cells(2, 1), Cells(4, rng.Column - 1)).Copy
    
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    Cells(2, 1).Select
    Selection.PasteSpecial Paste:=xlPasteColumnWidths, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
    ActiveSheet.Paste
    
'DS 20.11.17 Filterspalten
'    'Teil2 Nach Strukturspalten bis Typspalten
'    Sheets(C_WS_VORLAGE).Activate
'    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find("PNAME_XX", lookat:=xlWhole)
'    spaltenname = Cells(1, rng.Column + anzahl_spalten_struktur + 1)
'    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find("TYPR_XX", lookat:=xlWhole)
'    ActiveSheet.Range(Cells(2, rng.Column + anzahl_spalten_struktur + 1), Cells(4, rn2.Column - 1)).Copy
    'Teil2 Nach Strukturspalten bis Filterspalten
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find("PNAME_XX", lookat:=xlWhole)
    spaltenname = Cells(1, rng.Column + anzahl_spalten_struktur + 1)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find("FLT_XX", lookat:=xlWhole)
    ActiveSheet.Range(Cells(2, rng.Column + anzahl_spalten_struktur + 1), Cells(4, rn2.Column - 1)).Copy
    
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
    Cells(2, rng.Column).Select
    Selection.PasteSpecial Paste:=xlPasteColumnWidths, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
    ActiveSheet.Paste
    
    'Teil3 nach Typspalten bis Ende
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find("TYPR_XX", lookat:=xlWhole)
    spaltenname = Cells(1, rng.Column + 1)
    ActiveSheet.Range(Cells(2, rng.Column + 1), Cells(4, vorlage_letzte_spalte)).Copy
    
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
    Cells(2, rng.Column).Select
    Selection.PasteSpecial Paste:=xlPasteColumnWidths, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
    ActiveSheet.Paste

    Call LogFile("Spalten|fffd|berschriften |fffd|bernehmen (zur|fffd|ckschreiben)")

'   (zuvor gesicherte) Spalten|fffd|berschriften |fffd|bernehmen (zur|fffd|ckschreiben)
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    idx_spalte = 0
    Do While idx_spalte < letzte_spalte
        idx_spalte = idx_spalte + 1
        If spalten_texte(idx_spalte) <> "" Then
            Cells(2, idx_spalte) = spalten_texte(idx_spalte)
        End If
    Loop

'Spezielle Formatierungen zu einzelnen Spalten erg|fffd|nzen
    gv_step = gv_step + 1
    Call UpdateProgress(gv_step, gv_steps, "Freigabeformat finalize ...")
    
    Call LogFile("Spezielle Formatierungen zu einzelnen Spalten erg|fffd|nzen")

    Sheets(C_WS_FREIGABE_OUTPUT).Activate

'   Spalte VZK formatieren
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("/BMW/PEP_VZK", lookat:=xlWhole)
    
    If Not rng Is Nothing Then
        With Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column))
            .FormatConditions.Add Type:=xlTextString, String:="BG", TextOperator:=xlContains
            .FormatConditions(1).Interior.Color = RGB(255, 0, 0)
            .FormatConditions.Add Type:=xlTextString, String:="GS", TextOperator:=xlContains
            .FormatConditions(2).Interior.Color = RGB(255, 0, 0)
            .FormatConditions.Add Type:=xlTextString, String:="UN", TextOperator:=xlContains
            .FormatConditions(3).Interior.Color = RGB(255, 0, 0)
            .FormatConditions.Add Type:=xlTextString, String:="B1", TextOperator:=xlContains
            .FormatConditions(4).Interior.Color = RGB(255, 255, 255)
            .FormatConditions.Add Type:=xlTextString, String:="B2", TextOperator:=xlContains
            .FormatConditions(5).Interior.Color = RGB(255, 255, 255)
            .FormatConditions.Add Type:=xlTextString, String:="B3", TextOperator:=xlContains
            .FormatConditions(6).Interior.Color = RGB(255, 255, 255)
            .FormatConditions.Add Type:=xlTextString, String:="GU", TextOperator:=xlContains
            .FormatConditions(7).Interior.Color = RGB(255, 255, 255)
            .FormatConditions.Add Type:=xlTextString, String:="", TextOperator:=xlContains
            .FormatConditions(8).Interior.Color = RGB(255, 255, 0)
        End With
    End If

'DS 29.09.17
'   Spalte WHZ-Kz (Wiederholteil-Kz) formatieren
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("/BMW/PEP_ITMSKZ", lookat:=xlWhole)
    
    If Not rng Is Nothing Then
        With Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column))
            .FormatConditions.Add Type:=xlTextString, String:="X", TextOperator:=xlContains
            .FormatConditions(1).Interior.Color = RGB(255, 0, 0)
        End With
    End If

'   Spalte Bezugstart abh|fffd|ngig von Bezugsart, PTE-Art und Sachnummer formatieren
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("/BMW/PEPBA", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("PTE_ART", lookat:=xlWhole)
    Set rn3 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("MATERIAL", lookat:=xlWhole)

    If Not rng Is Nothing And Not rn2 Is Nothing And Not rn3 Is Nothing Then
        idx_zeile = 4
        Do While idx_zeile < letzte_zeile
            idx_zeile = idx_zeile + 1
            If Cells(idx_zeile, rng.Column) = "" And Cells(idx_zeile, rn3.Column) <> "" _
            And Cells(idx_zeile, rn2.Column) = "" Then
                Cells(idx_zeile, rng.Column).Interior.Color = RGB(255, 0, 0)
            End If
        Loop
    End If
    
'   Spalte VCR und formatieren
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(letzte_zeile, letzte_spalte)).Find("/BMW/PEP_VCR", lookat:=xlWhole)
    
    If Not rng Is Nothing Then
        With Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column))
            .FormatConditions.Add Type:=xlTextString, String:="n", TextOperator:=xlContains
            .FormatConditions(1).Interior.Color = RGB(255, 255, 0)
        End With
    End If

'Filter und Berichtsdatum"
    Dim created_at, filter_param As String
    
    Set rng = ActiveWorkbook.Sheets(C_WS_INPUT).Range("C:C").Find("CREATED_AT", lookat:=xlWhole)
    If Not rng Is Nothing Then
        created_at = ActiveWorkbook.Sheets(C_WS_INPUT).Cells(rng.row, 2)
    End If
    ActiveSheet.Shapes("Datum").TextFrame.Characters.text = created_at

    Set rng = ActiveWorkbook.Sheets(C_WS_INPUT).Range("C:C").Find("FILTER_NAME", lookat:=xlWhole)
    If rng Is Nothing Then
        'Aufl|fffd|sung mit manuellen G|fffd|ltigkeitsparametern
        Set rng = ActiveWorkbook.Sheets(C_WS_INPUT).Range("C:C").Find("P_ADAT", lookat:=xlWhole)
        If Not rng Is Nothing Then
            'Datum
            filter_param = ActiveWorkbook.Sheets(C_WS_INPUT).Cells(rng.row, 2)
        End If
        
        Set rng = ActiveWorkbook.Sheets(C_WS_INPUT).Range("C:C").Find("P_ADATTY", lookat:=xlWhole)
        If Not rng Is Nothing Then
            'Terminart
            filter_param = filter_param & "/" & ActiveWorkbook.Sheets(C_WS_INPUT).Cells(rng.row, 2)
        End If
        
        Set rng = ActiveWorkbook.Sheets(C_WS_INPUT).Range("C:C").Find("P_AVSP", lookat:=xlWhole)
        If Not rng Is Nothing Then
            'Vorserienparameter
            filter_param = filter_param & "/" & ActiveWorkbook.Sheets(C_WS_INPUT).Cells(rng.row, 2)
        End If
    Else
'DS 20.11.17 Filterspalten
        If anzahl_filter = 0 Then
          'Aufl|fffd|sung mit genau einem iPPE-Filter -> Filtername ausgeben
          filter_param = ActiveWorkbook.Sheets(C_WS_INPUT).Cells(rng.row, 2)
        Else
          'Aufl|fffd|sung mit mehreren iPPE-Filtern -> Hinweis ausgeben
          filter_param = GetTextelementByID("T", "Filter_MehrfachFilter")
        End If
    End If
    ActiveSheet.Shapes("Filter").TextFrame.Characters.text = filter_param
    
'Sprachabh|fffd|ngige Texte zu Feldern und Buttons anpassen
'DS 20.11.2017 Aufruf der Anleitung |fffd|ber Button mit Icon "Info"
'    ActiveSheet.Shapes("Freigabe_Anleitung_Text").TextFrame.Characters.text _
'                = GetTextelementByID("B", "Freigabe_Anleitung_Text")
    ActiveSheet.Shapes("Button_Position_neu").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_Position_neu")
    ActiveSheet.Shapes("Button_Position_geaendert").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_Position_geaendert")
    ActiveSheet.Shapes("Button_Position_loeschen").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_Position_loeschen")

    ActiveSheet.Shapes("Filter_Text").TextFrame.Characters.text _
                = GetTextelementByID("T", "Filter_Text")
    ActiveSheet.Shapes("Datum_Text").TextFrame.Characters.text _
                = GetTextelementByID("T", "Datum_Text")
    
'DS 27.03.17 Stammdatenmakro
    ActiveSheet.Shapes("Button_Stammdatenmakro").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_Stammdatenmakro")
    ActiveSheet.Shapes("Button_Zeichnungshinweis").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_Zeichnungshinweis")
    ActiveSheet.Shapes("Button_VZK").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_VZK")
    ActiveSheet.Shapes("Button_Export").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_Export")
    ActiveSheet.Shapes("Button_Freigabehinweis").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_Freigabehinweis")
    ActiveSheet.Shapes("Button_QServ_Analyse").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_QServ_Analyse")
'DS 27.03.17 PTE-Info
    ActiveSheet.Shapes("Button_PTEInfo").TextFrame.Characters.text _
                = GetTextelementByID("B", "Button_PTEInfo")
    
'Datenbereich f|fffd|r Dropdown aus der Vorlage zuweisen"
'DS 27.03.17 PTE-Info
    spaltenname = "DUMMY_PTEINFO_REL"
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
    If Not rng Is Nothing Then
        Cells(5, rng.Column).Copy
        Sheets(C_WS_FREIGABE_OUTPUT).Activate
        Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
        If Not rng Is Nothing Then
            Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column)).Select
            ActiveSheet.Paste
        End If
    End If
    
'DS 29.03.19 PTE-Setzteil
    spaltenname = "DUMMY_PTESETZTEIL_WUE"
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
    If Not rng Is Nothing Then
        Cells(5, rng.Column).Copy
        Sheets(C_WS_FREIGABE_OUTPUT).Activate
        Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
        If Not rng Is Nothing Then
            Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column)).Select
            ActiveSheet.Paste
        End If
    End If
    
    spaltenname = "DUMMY_VERFUEG_SERIE"
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
    If Not rng Is Nothing Then
        Cells(5, rng.Column).Copy
        Sheets(C_WS_FREIGABE_OUTPUT).Activate
        Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
        If Not rng Is Nothing Then
            Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column)).Select
            ActiveSheet.Paste
        End If
    End If
    
    spaltenname = "DUMMY_VERFUEG_ERSATZ"
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
    If Not rng Is Nothing Then
        Cells(5, rng.Column).Copy
        Sheets(C_WS_FREIGABE_OUTPUT).Activate
        Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
        If Not rng Is Nothing Then
            Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column)).Select
            ActiveSheet.Paste
        End If
    End If
    
    spaltenname = "DUMMY_DH"
    Sheets(C_WS_VORLAGE).Activate
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, vorlage_letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
    If Not rng Is Nothing Then
        Cells(5, rng.Column).Copy
        Sheets(C_WS_FREIGABE_OUTPUT).Activate
        Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find(spaltenname, lookat:=xlWhole)
        If Not rng Is Nothing Then
            Range(Cells(5, rng.Column), Cells(letzte_zeile, rng.Column)).Select
            ActiveSheet.Paste
        End If
    End If
    
'Formatierung von Datenzeilen
    Call LogFile("Formatierung von Datenzeilen")

    Sheets(C_WS_FREIGABE_OUTPUT).Activate

'   geht die Zeilen durch und f|fffd|rbt Knoten ein"
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("HIERST_BAU", lookat:=xlWhole)
    
    idx_zeile = 4
    Do While idx_zeile < letzte_zeile
        idx_zeile = idx_zeile + 1
        'Formatiert
        If ActiveSheet.Cells(idx_zeile, rng.Column) = "" Then
            ActiveSheet.Range(Cells(idx_zeile, 1), Cells(idx_zeile, letzte_spalte)).Interior.Color = RGB(0, 112, 193)
            ActiveSheet.Range(Cells(idx_zeile, 1), Cells(idx_zeile, letzte_spalte)).Font.Bold = True
            ActiveSheet.Range(Cells(idx_zeile, 1), Cells(idx_zeile, letzte_spalte)).Font.Color = RGB(255, 255, 255)
        End If
    Loop

'Spaltenbreite der Strukturtiefe anpassen
    Call LogFile("Spaltenbreite der Strukturtiefe anpassen")
    
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("PNAME_", lookat:=xlPart)
    ' Anzahl der Spalten im Strukturblock ermitteln
    idx_spalte = rng.Column
    anzahl = 0
    Do While idx_spalte <= letzte_spalte
        idx_spalte = idx_spalte + 1
        If Left(Cells(1, idx_spalte), 6) = "PNAME_" Then
            anzahl = anzahl + 1
        Else
            Exit Do
        End If
    Loop
    ' Spalten 1 bis (z-1) Strukturblocks schmal
    Range(Columns(rng.Column), Columns(rng.Column + anzahl)).Select
    Selection.ColumnWidth = c_col_width_struktur
    ' Letzte Spalte des Strukturblocks breiter
    Columns(rng.Column + anzahl).Select
    Selection.ColumnWidth = c_col_width_struktur_letzte
    
'Gitternetz anlegen
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    
    With Range(Cells(5, 1), Cells(letzte_zeile, letzte_spalte))
        With .Borders
            .LineStyle = xlContinuous
            .colorIndex = xlAutomatic
            .TintAndShade = 0
            .Weight = xlThin
        End With
    End With

'Zeilenh|fffd|he festlegen damit Umbruch verwendet werden kann"
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    
    Range(Rows("5:5"), Rows(letzte_zeile)).RowHeight = c_row_height_daten

    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("OBJNAME", lookat:=xlWhole)
    If Not rng Is Nothing Then
        Range(Cells(5, rng.Column), Cells(letzte_zeile, letzte_spalte)).WrapText = True
    End If
    
'Bezeichnung ohne Zeilenumbruch
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("PNAME_", lookat:=xlPart)
    Cells(2, rng.Column).WrapText = False

'Gruppieren
    Call LogFile("Gruppieren")
    
    Sheets(C_WS_FREIGABE_OUTPUT).Activate

'   Material bis VCR
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("MATERIAL", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("/BMW/PEP_VCR", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column - 1)).Columns.Group
    End If

'   Untergruppierung zu Farbcode
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("/BMW/PEPFKZ", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("/BMW/PEP_EXC_BEZ", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column)).Columns.Group
    End If
    
'DS 09.08.19 Materialkurztext Englisch
'   Materialkurztext Englisch
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("MAKTX_EN", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column), Columns(rng.Column)).Columns.Group
    End If
    
'DS 20.11.17 Filterspalten
'   Filterspalten
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("FLT_", lookat:=xlPart)
    If Not rng Is Nothing Then
        ' Anzahl der Typspalten ermitteln
        idx_spalte = rng.Column
        anzahl = 0
        Do While idx_spalte <= letzte_spalte
            idx_spalte = idx_spalte + 1
            If Left(Cells(1, idx_spalte), 4) = "FLT_" Then
                anzahl = anzahl + 1
            Else
                Exit Do
            End If
        Loop
        Range(Columns(rng.Column + 1), Columns(rng.Column + anzahl)).Columns.Group
    End If

'   Typspalten
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("TYPR_", lookat:=xlPart)
    If Not rng Is Nothing Then
        ' Anzahl der Typspalten ermitteln
        idx_spalte = rng.Column
        anzahl = 0
        Do While idx_spalte <= letzte_spalte
            idx_spalte = idx_spalte + 1
            If Left(Cells(1, idx_spalte), 5) = "TYPR_" Then
                anzahl = anzahl + 1
            Else
                Exit Do
            End If
        Loop
        Range(Columns(rng.Column + 1), Columns(rng.Column + anzahl)).Columns.Group
    End If

'DS 09.08.19 Posvar-GUID
'   Posvar-GUID
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("PVGUID", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column), Columns(rng.Column)).Columns.Group
    End If
    
'   Gewicht, |fffd|nderungsnr. (bis Schraubfalldaten)
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_GEW_AENR", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_SF", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column - 1)).Columns.Group
    End If

'   Schraubfalldaten (bis Produktionstechn. Erg|fffd|nzungen)
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_SF", lookat:=xlWhole)
'DS 27.03.17 Anpassung der Gruppierung wegen PTE-Infoblock
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_PTEINFO_REL", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column - 1)).Columns.Group
    End If

'   Produktionstechn. Erg|fffd|nzungen (bis Hinweisschilder)
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_PTE", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_HWS", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column - 1)).Columns.Group
    End If

'   Hinweisschilder (bis QServ)
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_HWS", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_QSERV", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column - 1)).Columns.Group
    End If

'   QServ (bis Bemerkung)
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_QSERV", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_BEMERKUNG", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column - 1)).Columns.Group
    End If

'   Lieferantendaten (bis MMG-Reviews)
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_LIEF", lookat:=xlWhole)
    Set rn2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_MMG_REVIEW", lookat:=xlWhole)
    If Not rng Is Nothing And Not rn2 Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(rn2.Column - 1)).Columns.Group
    End If
    
'DS 29.09.17
'   MMG-Reviews (bis Ende)
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_MMG_REVIEW", lookat:=xlWhole)
    If Not rng Is Nothing Then
        Range(Columns(rng.Column + 1), Columns(letzte_spalte)).Columns.Group
    End If
    
'DS 27.03.17
'    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=1
    
'Filter, vorfiltern
    Call LogFile("Filter, vorfiltern")
    
    Sheets(C_WS_FREIGABE_OUTPUT).Activate
    
    Range(Cells(4, 1), Cells(4, letzte_spalte)).Select
    Selection.AutoFilter
    
    'Strukturstufe 0 vorfiltern
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("HIERST_BAU", lookat:=xlWhole)
    If Not rng Is Nothing Then
        Range(Cells(4, 1), Cells(4, letzte_spalte)).AutoFilter Field:=rng.Column, Criteria1:="=00", Operator:=xlOr, Criteria2:="="
    End If
    
    With ActiveSheet.Outline
        .AutomaticStyles = False
        .SummaryRow = xlAbove
        .SummaryColumn = xlLeft
'DS 27.03.17
'        .ShowLevels RowLevels:=3, ColumnLevels:=3
'        .ShowLevels RowLevels:=2, ColumnLevels:=2
        .ShowLevels RowLevels:=1, ColumnLevels:=1
    End With
    
'Zeile mit technischen Spaltenamen ausblenden
    Rows("1:1").Select
    Selection.RowHeight = 0

'H|fffd|he |fffd|berschriften anpassen
    Rows("2:2").Select
    Selection.RowHeight = c_row_height_header
    
'Fensterfixierung
    Call LogFile("Fensterfixierung")
    
    ActiveWindow.FreezePanes = False
    Range("Z5").Select
    ActiveWindow.FreezePanes = True
    
'Endzelle festlegen
    Range("B5").Activate

'Sprachabh|fffd|ngige Formulare umbenennen
    Call LogFile("Sprachabh|fffd|ngige Formulare umbenennen")
    If gv_sprache = C_SPRACHE_DE Then
        ThisWorkbook.VBProject.VBComponents("Freigabe_Anleitung_D").name = "Freigabe_Anleitung"
        ThisWorkbook.VBProject.VBComponents("Legende_Freigabehinweis_D").name = "Legende_Freigabehinweis"
    Else
        ThisWorkbook.VBProject.VBComponents("Freigabe_Anleitung_E").name = "Freigabe_Anleitung"
        ThisWorkbook.VBProject.VBComponents("Legende_Freigabehinweis_E").name = "Legende_Freigabehinweis"
    End If
    
'Nicht ben|fffd|tigte Sheets l|fffd|schen & neue anlegen"
    Application.DisplayAlerts = False
    
    'Selektionsparameter ausblenden
    Sheets(C_WS_INPUT).Visible = False
    
    'Textelemente und Wertetabellen ausblenden
    Sheets(C_WS_TEXTELEMENTE).Visible = False
    Sheets(C_WS_WERTETABELLEN).Visible = False
    
    'Daten umbenennen
    gv_ws_freigabe_output = GetTextelementByID("T", "WS_Output_FREIGABE")
    Sheets(C_WS_FREIGABE_OUTPUT).name = gv_ws_freigabe_output
    
    Application.DisplayAlerts = True
    Sheets(gv_ws_freigabe_output).Select
    
'Screenupdate wieder an
    With Application
        .ScreenUpdating = True
        .EnableEvents = True
        .Calculation = xlCalculationAutomatic
    End With

    Call LogFile("Freigabeformat fertig")

    Exit Sub

Fehler:

    MsgBox ("Formatierung wurde abgebrochen Fehler: " & Err.Description)


End Sub

'Tabelle mit sprachabh|fffd|ngigen Textelementen entsprechend der ermittelten Sprache vorbereiten
Sub Prepare_Textelemente()

    Dim indexSpalte As Double
    
    Sheets(C_WS_TEXTELEMENTE).Activate
    
    'Spaltenindex zur aktuellen Sprache ermitteln
    If gv_sprache = C_SPRACHE_DE Then
      indexSpalte = 2
    Else
      indexSpalte = 3
    End If

    'Spalte zur aktuellen Sprache an Position 2 (nach Text-Key) verschieben
    If indexSpalte <> 2 Then
        Columns(indexSpalte).EntireColumn.Cut
        Columns(2).EntireColumn.Insert Shift:=xlToRight
    End If
    
    'Spalten zu allen anderen Sprachen (ab Position 3) l|fffd|schen
    indexSpalte = 3
    Do
        If Cells(1, indexSpalte) = "" Then
            Exit Do
        End If
        Columns(indexSpalte).EntireColumn.Delete                 'Spalte l|fffd|schen
    Loop

End Sub

' ---------------------------------------------------------------------------------------
' l|fffd|sche alle Datensheets aus dem Workbook
' ---------------------------------------------------------------------------------------
Sub Freigabe_DeleteDataSheets(dummy As Integer)

    Dim ws As Worksheet
    
    ' wir wollen keine R|fffd|ckfragen von Excel
    Application.DisplayAlerts = False

    For Each ws In Sheets
        If ws.name <> gv_ws_freigabe_output And _
           ws.name <> C_WS_INPUT And _
           ws.name <> C_WS_MSG And _
           ws.name <> C_WS_MODUL And _
           ws.name <> C_WS_TEXTELEMENTE And _
           ws.name <> C_WS_WERTETABELLEN Then
                'Sheet l|fffd|schen
                ws.Delete
        End If
    Next ws

    Application.DisplayAlerts = True
    
    Call LogFile("Delete temporary Worksheets")

End Sub

' ---------------------------------------------------------------------------------------
'Sprachabh|fffd|ngiges Textelement zu einer Tyext-ID ermitteln
' ---------------------------------------------------------------------------------------
Function GetTextelementByID(ByVal strType As String, ByVal strTextID As String) As String

    Static letzteZeile As Double

    Dim activeWsSave As String
    Dim rng As Range
    Dim textKey As String
    Dim text As String
    
    activeWsSave = ActiveSheet.name
    Sheets(C_WS_TEXTELEMENTE).Activate
    
    If letzteZeile = 0 Then
        letzteZeile = ActiveCell.SpecialCells(xlLastCell).row
    End If

    textKey = strType & "#" & strTextID
    
    Set rng = ActiveSheet.Range(Cells(3, 1), Cells(letzteZeile, 1)).Find(textKey, lookat:=xlWhole)
    If Not rng Is Nothing Then
        text = Cells(rng.row, 2)
    End If
    
    Sheets(activeWsSave).Activate
    
    GetTextelementByID = text

End Function

' ---------------------------------------------------------------------------------------
'Wertetabellen mit sprachabh|fffd|ngigen Texten erg|fffd|nzen
' ---------------------------------------------------------------------------------------
Sub Prepare_Wertetabellen()

    Dim letzte_zeile As Double
    Dim index_zeile As Double
    Dim text_id As String
    Dim text As String

    Sheets(C_WS_WERTETABELLEN).Activate
    letzte_zeile = ActiveCell.SpecialCells(xlLastCell).row
    
    index_zeile = 0
    Do While index_zeile < letzte_zeile
        index_zeile = index_zeile + 1
        If Cells(index_zeile, 1) <> "" And Cells(index_zeile, 2) <> "" Then
            text_id = Cells(index_zeile, 1) & Cells(index_zeile, 2)
            text = GetTextelementByID("D", text_id)
            If text <> "" Then
                Cells(index_zeile, 3) = text
            End If
        End If
    Loop

End Sub

Attribute VB_Name = "Freigabe_Anleitung"
Attribute VB_Base = "0{54C031F4-EFB7-46BA-9D55-F15F12B233BD}{7B42D55A-E308-4D12-8845-0DD3AAFB4A45}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Private Sub CheckBox1_Click()

    Range("B1") = CheckBox1
    
End Sub

Private Sub CommandButton1_Click()

    Unload Me
    
End Sub

Private Sub Image1_Click()

End Sub

Private Sub Label2_Click()

End Sub

Private Sub Image3_Click()

End Sub

Private Sub Label16_Click()

End Sub

Private Sub Label4_Click()

End Sub

Private Sub Label6_Click()

End Sub

Private Sub Label7_Click()

End Sub

Private Sub Label8_Click()

End Sub

Private Sub UserForm_Click()

End Sub
Attribute VB_Name = "G_FREIGABE_Hilfsfunktionen"
' Dieter Spielbauer 16.11.2016: Freigabelayout
' Dieter Spielbauer 27.03.2017: Erweiterungen zum Rel. 17.1
' Dieter Spielbauer 20.11.2017: Erweiterungen nach Rel. 17.2

' ---------------------------------------------------------------------------------------
' Index der zuletzt ge|fffd|nderten/hinzugef|fffd|gten Zeile
' ---------------------------------------------------------------------------------------
Public gv_zeile_save As Long

'DS 27.03.17
Public Const C_ZEILE_BACKUP = 2000
Public Const C_COLUMNLEVELS_MAX = 8


'DS 20.11.17
' ---------------------------------------------------------------------------------------
' Position l|fffd|schen
' ---------------------------------------------------------------------------------------
Sub Freigabe_Pos_Loeschen()

    Dim letzte_spalte As Long
    Dim idx_zeile As Long
    Dim rng As Range

    'alle Spaltengruppierungen zum Kopieren und Einf|fffd|rben aufheben
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=C_COLUMNLEVELS_MAX
    
    idx_zeile = ActiveCell.row
    'Zeile f|fffd|r Undo-Funktion merken
    gv_zeile_save = idx_zeile
    
    letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_AEND", lookat:=xlWhole)
    
    'erste Spalte zum Kopieren einblenden
    Columns("A:A").Select
    Selection.ColumnWidth = 1

    'ausgew|fffd|hlte Zeile kopieren
    Range(Cells(idx_zeile, 1), Cells(idx_zeile, letzte_spalte)).Copy Destination:=Sheets(C_WS_INPUT).Cells(C_ZEILE_BACKUP, 1)
    
    'erste Spalte nach dem Kopieren wieder ausblenden
    Columns("A:A").Select
    Selection.ColumnWidth = 0
    
    Cells(idx_zeile, rng.Column).Select
    Cells(idx_zeile, rng.Column) = GetTextelementByID("T", "Position_entfall")
    With Selection.EntireRow.Interior
       .Pattern = xlSolid
       .PatternColorIndex = xlAutomatic
       .Color = RGB(217, 150, 148)
    End With
    
    'Felder zur Dokumentation der |fffd|nderung markieren
    'DS 19.12.16: bisherige Zeile nicht durchgestrichen darstellen
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_BEMERKUNG", lookat:=xlWhole)
    Range(Cells(idx_zeile, 1), Cells(idx_zeile, rng.Column - 1)).Font.Strikethrough = True

    'alle Spaltengruppierungen wieder aktivieren
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=1

End Sub

' ---------------------------------------------------------------------------------------
' Position |fffd|ndern
' ---------------------------------------------------------------------------------------
Sub Freigabe_Pos_Aendern()

    Dim letzte_spalte As Long
    Dim idx_zeile As Long
    Dim rng As Range

    'alle Spaltengruppierungen zum Kopieren und Einf|fffd|rben aufheben
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=C_COLUMNLEVELS_MAX
    
    idx_zeile = ActiveCell.row
    'Zeile f|fffd|r Undo-Funktion merken
    gv_zeile_save = idx_zeile
    
    letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_AEND", lookat:=xlWhole)
    
'DS 27.03.17 - Begin
    'erste Spalte zum Kopieren einblenden
    Columns("A:A").Select
    Selection.ColumnWidth = 1

    'ausgew|fffd|hlte Zeile kopieren
    Range(Cells(idx_zeile, 1), Cells(idx_zeile, letzte_spalte)).Copy Destination:=Sheets(C_WS_INPUT).Cells(C_ZEILE_BACKUP, 1)
    
    'erste Spalte nach dem Kopieren wieder ausblenden
    Columns("A:A").Select
    Selection.ColumnWidth = 0
'DS 27.03.17 - End
    
    Cells(idx_zeile, rng.Column).Select
    Cells(idx_zeile, rng.Column) = GetTextelementByID("T", "Position_bisher")
    With Selection.EntireRow.Interior
       .Pattern = xlSolid
       .PatternColorIndex = xlAutomatic
       .Color = RGB(250, 192, 144)
    End With
    
    'Felder zur Dokumentation der |fffd|nderung markieren
    'DS 19.12.16: bisherige Zeile nicht durchgestrichen darstellen
    'Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_BEMERKUNG", lookat:=xlWhole)
    'Range(Cells(idx_zeile, 1), Cells(idx_zeile, rng.Column - 1)).Font.Strikethrough = True

    'neue Zeile f|fffd|r |fffd|nderung einf|fffd|gen
    ActiveCell.Offset(1).EntireRow.Insert , CopyOrigin:=xlFormatFromLeftOrAbove
    ActiveCell.Offset(1).EntireRow.Select
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = RGB(184, 204, 228)
    End With
    With Selection.EntireRow.Font
        .Color = RGB(0, 0, 0)
        .Strikethrough = False
        Cells(idx_zeile + 1, rng.Column) = GetTextelementByID("T", "Position_geaendert")
    End With
    
    'alle Spaltengruppierungen wieder aktivieren
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=1

    'DS 19.12.16: keine Vorbelegung
    'Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_VERFUEG_SERIE", lookat:=xlWhole)
    'Cells(idx_zeile + 1, rng.Column) = GetTextelementByID("T", "Auswahl_Daten")
    'Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_VERFUEG_ERSATZ", lookat:=xlWhole)
    'Cells(idx_zeile + 1, rng.Column) = GetTextelementByID("T", "Auswahl_Daten")
    'Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_DH", lookat:=xlWhole)
    'Cells(idx_zeile + 1, rng.Column) = GetTextelementByID("T", "Auswahl_Daten")

End Sub

' ---------------------------------------------------------------------------------------
' Position hinzuf|fffd|gen
' ---------------------------------------------------------------------------------------
Sub Freigabe_Pos_Hinzu()
    
    Dim letzte_spalte As Long
    Dim idx_zeile As Long
    Dim rng As Range

'DS 27.03.17
    'alle Spaltengruppierungen zum Einf|fffd|rben aufheben
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=C_COLUMNLEVELS_MAX

    idx_zeile = ActiveCell.row
    'Zeile f|fffd|r Undo-Funktion merken
    gv_zeile_save = idx_zeile
    
    letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_AEND", lookat:=xlWhole)
    
    'neue Zeile einf|fffd|gen
    ActiveCell.Offset(1).EntireRow.Insert , CopyOrigin:=xlFormatFromLeftOrAbove
    ActiveCell.Offset(1).EntireRow.Select

    With Selection.Interior
        .Color = RGB(194, 214, 154)
    End With

    Cells(idx_zeile + 1, rng.Column) = GetTextelementByID("T", "Position_neu")
    
'DS 27.03.17
    'alle Spaltengruppierungen wieder aktivieren
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=1
    
End Sub

' ---------------------------------------------------------------------------------------
' Undo Position |fffd|ndern / hinzuf|fffd|gen
' ---------------------------------------------------------------------------------------
Sub Freigabe_Pos_Back()

    Dim letzte_spalte As Long
    Dim rng As Range

    Dim text_Position_geaendert As String
    Dim text_Position_neu As String

    'Screenupdate aus
    With Application
            .ScreenUpdating = False
            .EnableEvents = False
            .Calculation = xlCalculationManual
    End With
    
    'sprachabh|fffd|ngige Texte zur Markierung der ge|fffd|nderten bzw. neuen Positionen ermitteln
    text_Position_geaendert = GetTextelementByID("T", "Position_geaendert")
    text_Position_neu = GetTextelementByID("T", "Position_neu")
    text_Position_geloescht = GetTextelementByID("T", "Position_entfall")
    
    'alle Spaltengruppierungen zum Einf|fffd|rben aufheben
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=C_COLUMNLEVELS_MAX

    letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
    Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_AEND", lookat:=xlWhole)
    
    Dim ws_name As String
    ws_name = ActiveSheet.name
    
    If Cells(gv_zeile_save + 1, rng.Column) = text_Position_geaendert Then
        'Ge|fffd|nderte Position zur|fffd|cknehmen
        'neue Zeile l|fffd|schen
        Rows(gv_zeile_save + 1).Select
        Selection.Delete Shift:=xlUp
        
        'Zeile aus dem Backup wiederherstellen
        Sheets(C_WS_INPUT).Activate
        Range(Cells(C_ZEILE_BACKUP, 1), Cells(C_ZEILE_BACKUP, letzte_spalte)).Copy
        Sheets(ws_name).Activate
        Rows(gv_zeile_save).Select
        Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=True, Transpose:=False
    
        Rows(gv_zeile_save).Select
        Application.CutCopyMode = False
        With Selection.Font
            .FontStyle = "Standard"
            .Strikethrough = False
            .Superscript = False
            .Subscript = False
            .OutlineFont = False
            .Shadow = False
            .Underline = xlUnderlineStyleNone
            .colorIndex = 3
            .TintAndShade = 0
        End With
        With Selection.Font
            .colorIndex = xlAutomatic
            .TintAndShade = 0
        End With
        With Selection.Interior
            .Pattern = xlNone
            .TintAndShade = 0
            .PatternTintAndShade = 0
        End With
        Cells(gv_zeile_save, rng.Column).Select
        Selection.ClearContents

    ElseIf Cells(gv_zeile_save + 1, rng.Column) = text_Position_neu Then
        'Neue Position l|fffd|schen
        Rows(gv_zeile_save + 1).Select
        Selection.Delete Shift:=xlUp
        
    ElseIf Cells(gv_zeile_save, rng.Column) = text_Position_geloescht Then
        'Gel|fffd|schte Position zur|fffd|cknehmen
        'Zeile aus dem Backup wiederherstellen
        Sheets(C_WS_INPUT).Activate
        Range(Cells(C_ZEILE_BACKUP, 1), Cells(C_ZEILE_BACKUP, letzte_spalte)).Copy
        Sheets(ws_name).Activate
        Rows(gv_zeile_save).Select
        Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=True, Transpose:=False
    
        Rows(gv_zeile_save).Select
        Application.CutCopyMode = False
        With Selection.Font
            .FontStyle = "Standard"
            .Strikethrough = False
            .Superscript = False
            .Subscript = False
            .OutlineFont = False
            .Shadow = False
            .Underline = xlUnderlineStyleNone
            .colorIndex = 3
            .TintAndShade = 0
        End With
        With Selection.Font
            .colorIndex = xlAutomatic
            .TintAndShade = 0
        End With
        With Selection.Interior
            .Pattern = xlNone
            .TintAndShade = 0
            .PatternTintAndShade = 0
        End With
        Cells(gv_zeile_save, rng.Column).Select
        Selection.ClearContents
    
    End If
    
    'alle Spaltengruppierungen wieder aktivieren
    ActiveSheet.Outline.ShowLevels RowLevels:=0, ColumnLevels:=1

    Rows(gv_zeile_save).Font.colorIndex = xlAutomatic
    Cells(gv_zeile_save, rng.Column) = ""

    'Screenupdate wieder an
    With Application
        .ScreenUpdating = True
        .EnableEvents = True
        .Calculation = xlCalculationAutomatic
    End With
    
End Sub

' ---------------------------------------------------------------------------------------
' Anleitung anzeigen
' ---------------------------------------------------------------------------------------
Sub Call_Freigabe_Anleitung()

    Freigabe_Anleitung.Show

End Sub

' ---------------------------------------------------------------------------------------
' Legende zu Freigabehinweis anzeigen
' ---------------------------------------------------------------------------------------
Sub Call_Legende_Freigabehinweis()

    Legende_Freigabehinweis.Show

End Sub

' ---------------------------------------------------------------------------------------
' QServ Analyse starten
' ---------------------------------------------------------------------------------------
Sub Freigabe_QServ()

    Dim rng1, rng2, rng3, rng4, rng5 As Range
    Dim idx_zeile, letzte_zeile, letzte_spalte As Double

    letzte_zeile = ActiveCell.SpecialCells(xlLastCell).row
    letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column

    'Qserv ungroup
    Set rng1 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_QSERV", lookat:=xlWhole)
    Set rng2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_BEMERKUNG", lookat:=xlWhole)
    Range(Columns(rng1.Column), Columns(rng2.Column - 1)).EntireColumn.Hidden = False

    'Spalte Ausschlusskennzeichen Klammer

    Set rng1 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("KLAMM_AUS", lookat:=xlWhole)
   
    idx_zeile = 4
    Do
        idx_zeile = idx_zeile + 1
        ' |fffd|berpr|fffd|fung ob letzte Zeile
        If idx_zeile = letzte_zeile Then
            Exit Do
        End If
        
        'Pr|fffd|ft & Formatiert
        If ActiveSheet.Cells(idx_zeile, rng1.Column) = "X" Then
            ActiveSheet.Cells(idx_zeile, rng1.Column).Interior.Color = 65535
        End If
    Loop

    'Spalte Standardbenennung Materialdaten & Standardbenennung Generisches Teil

    Set rng1 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("SB_T_BEZ", lookat:=xlWhole)
    Set rng2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("GEN_TEIL_SB_T_BEZ", lookat:=xlWhole)
    Set rng3 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("MATERIAL", lookat:=xlWhole)
   
    idx_zeile = 4
    Do
        idx_zeile = idx_zeile + 1
        ' |fffd|berpr|fffd|fung ob letzte Zeile
        If idx_zeile = letzte_zeile Then
            Exit Do
        End If
        
        'Pr|fffd|ft & Formatiert
        If ActiveSheet.Cells(idx_zeile, rng1.Column) <> "" And ActiveSheet.Cells(idx_zeile, rng2.Column) = "" Then
            ActiveSheet.Cells(idx_zeile, rng1.Column).Interior.Color = 65535
        End If
        
        If ActiveSheet.Cells(idx_zeile, rng1.Column) = "" And ActiveSheet.Cells(idx_zeile, rng3.Column) <> "" Then
            ActiveSheet.Cells(idx_zeile, rng1.Column).Interior.Color = 255
        End If
        
        If ActiveSheet.Cells(idx_zeile, rng1.Column) = "" And ActiveSheet.Cells(idx_zeile, rng2.Column) <> "" Then
            ActiveSheet.Cells(idx_zeile, rng1.Column).Interior.Color = 255
        End If
    
        If ActiveSheet.Cells(idx_zeile, rng1.Column) <> ActiveSheet.Cells(idx_zeile, rng2.Column) _
        And ActiveSheet.Cells(idx_zeile, rng2.Column) <> "" Then
            ActiveSheet.Cells(idx_zeile, rng1.Column).Interior.Color = 255
            ActiveSheet.Cells(idx_zeile, rng2.Column).Interior.Color = 255
        End If
    Loop
    
    'Spalte Standardbenennung Klammerbedingungen

    Set rng1 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("KL_BEZWI", lookat:=xlWhole)
    Set rng2 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("KNOWLEDGE", lookat:=xlWhole)
    Set rng3 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("BEZEI", lookat:=xlWhole)
    Set rng4 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("KGA_BEZWI", lookat:=xlWhole)
    Set rng5 = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("MATERIAL", lookat:=xlWhole)

    idx_zeile = 4
    Do
        idx_zeile = idx_zeile + 1
        ' |fffd|berpr|fffd|fung ob letzte Zeile
        If idx_zeile = letzte_zeile Then
            Exit Do
        End If
        
        'Pr|fffd|ft & Formatiert
        If ActiveSheet.Cells(idx_zeile, rng1.Column) = ActiveSheet.Cells(idx_zeile, rng2.Column) _
        And ActiveSheet.Cells(idx_zeile, 9) <> "" Then
            ActiveSheet.Cells(idx_zeile, rng1.Column).Interior.Color = 65535
        End If
    
        If ActiveSheet.Cells(idx_zeile, rng1.Column) = "" And ActiveSheet.Cells(idx_zeile, rng3.Column) = "" _
        And ActiveSheet.Cells(idx_zeile, rng4.Column) = "" And ActiveSheet.Cells(idx_zeile, rng5.Column) <> "" Then
            ActiveSheet.Cells(idx_zeile, rng1.Column).Interior.Color = 255
        End If
    Loop
    
End Sub


' ---------------------------------------------------------------------------------------
' WS exportieren
' ---------------------------------------------------------------------------------------
Sub Freigabe_Export()

'DS 27.03.17 |fffd|berarbeitung der Exportfunktion (komplett)
    Dim wbThis, wbStueck As Workbook
    Dim wksStueck As Worksheet
    Dim idx_zeile As Double
    
    Dim idx_zeile_end As Double
    Dim anzahl_zeilen As Double
    
    Dim bresult As Boolean
    
    'Deaktiviert OnChange Makro
    Application.EnableEvents = False
    
    Set wksStueck = ActiveSheet
    
    bresult = Application.Dialogs(xlDialogSaveAs).Show
    If bresult = False Then
        Exit Sub
    End If
      
    'Gruppierte Zeilen vor dem L|fffd|schen einblenden
    With ActiveSheet.Outline
        .ShowLevels RowLevels:=3
    End With

    'Filter nach dem Aufklappen der Gruppierungen nochmal anwenden
    ActiveSheet.AutoFilter.ApplyFilter
    
    'Datenbereich nach oben pr|fffd|fen
    anzahl_zeilen = 0
    For idx_zeile = wksStueck.UsedRange.row + wksStueck.UsedRange.Rows.Count To 4 Step -1
        If wksStueck.Rows(idx_zeile).Hidden = True Then
            If anzahl_zeilen = 0 Then
                'Endzeile der zu l|fffd|schenden Zeilen merken
                idx_zeile_end = idx_zeile
            End If
            'Anzahl der zu l|fffd|schenden Zeilen erh|fffd|hen
            anzahl_zeilen = anzahl_zeilen + 1
        Else
            If anzahl_zeilen > 0 Then
                'Block mit zu l|fffd|schenden Zeilen entfernen
                wksStueck.Range(Rows(idx_zeile_end), Rows(idx_zeile_end - anzahl_zeilen + 1)).EntireRow.Delete
            End If
            'Anzahl der zu l|fffd|schenden Zeilen initialisieren
            anzahl_zeilen = 0
        End If
    Next
    
    'Filter l|fffd|schen
    Rows("4:4").Select
    ActiveSheet.ShowAllData
    
    'Gruppierte Zeilen ausblenden
    With ActiveSheet.Outline
        .ShowLevels RowLevels:=3
        .ShowLevels RowLevels:=2
        .ShowLevels RowLevels:=1
    End With
   
    'Arbeitsmappe sichern
    ActiveWorkbook.Save
    
    'Aktiviert OnChange Makro
    Application.EnableEvents = True

End Sub













Attribute VB_Name = "Legende_Freigabehinweis"
Attribute VB_Base = "0{4706669B-37A8-43BA-8997-B76836366D2E}{E550A6C8-BD6F-4705-BA3C-D5002D2A57E7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub Label1_Click()

End Sub

Private Sub Image1_Click()

End Sub

Private Sub UserForm_Click()

End Sub
Attribute VB_Name = "Legende_Freigabehinweis_E"
Attribute VB_Base = "0{0E04A090-1F14-47F5-8EB5-43604F007EEB}{BF47C332-9C31-464C-BDCE-17584D411C5E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub Label1_Click()

End Sub

Private Sub Image1_Click()

End Sub

Private Sub UserForm_Click()

End Sub
Attribute VB_Name = "M_Farben_setzen"
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'   Ersteller dieser Routine ist: Thomas Leuchtmann & Daniel Wienholtz, BMW
'   Das Coding wurde per Copy and Paste am 11.04.2012 von Mirko Quintern
'   in das Excel |fffd|bernommen (Anforderung aus TPA 105974)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Option Explicit
' Daniel Wienholtz, L5-92  24.02.2012
' Aus der Vorlage von Herrn Thomas Leuchtmann (+), BMW
' Das Makro setColors() hat zwei Aufgaben:
' 1) Lesen der Ergebnis-Spalte ("Ergebnis Instanzanalyse")
'    und aufgrund der Fehlermeldung die
'    entsprechende Spalte in dieser Zeile markieren
' 2) Konsistenz-Pr|fffd|fungen
'    Ermitteln der Anzahl der Instanzen und
'    |fffd|berpr|fffd|fung der Mengen und daraufhin Ausgeben von
'    Fehlermeldungen und Markieren der entsprechenden Spalten
'
' Historie   Name         Bemerkung
' ========== ============ =============================
' 20.12.2011 Wienholtz    |fffd|bernahme des Makros von Release 11.1 (12.04.2011)
'                         Umstrukturierung auf Tabellenverwaltung mit Schleifen zur einfacheren Steuerung
'                         Enum SpaltenFelder, Arrays spalten, header, farbspalten
'                         Anpassungen der Analysefunktionen gem|fffd||fffd| TPA 94288
' 14.02.2012 Wienholtz    Einf|fffd|rben der Zeilen im Ergebnis Instanzanalyse gem|fffd||fffd| Mail S. Dragan-Walter
'                         analog zum PDM-WEB-Client
' 15.02.2012 Wienholtz    "VC2 unvollst|fffd|ndig" mit neuem Algorithmus (f|fffd|r Vererbung auf Unterstrukturen) ausgewertet
' 21.02.2012 Wienholtz    Korrektur Einf|fffd|rbung des letzten Zeichens einer Zelle (blieb immer Schwarz)
' 24.02.2012 Wienholtz    Anpassung auf Auswertung mehrerer Filter

Enum SpaltenFelder
    Snr = 0
    Kogr
    PPG
    Modulorg
    BezWi
    Menge
    vcr
    PV
    AendNrInst
    Elem11
    Elem12
    Elem13
    Elem21
    Elem22
    Elem23
    Elem31
    Elem32
    Elem33
    VectX
    VectY
    VectZ
    DokForm
    DokuID
    VC2Kz
    vzk
    HB
    FreigHinw
    PVZI
    InstVer
    ZHIN
    DMU
    Listenende
End Enum
Enum Befuellart
    Immer = 0
    Nichtleer = 1
End Enum

Dim spalten(0 To Listenende - 1) As Integer
Dim header As Variant
Dim farbspalten As Variant
Dim farbspalteninfo As Variant
Dim zeilenfaerbung As Variant
Dim zeilenfaerbungteiltexte As Variant
Dim ergebnisspalten As Variant


Const t  As String = vbTab ' Konstante, die chr(9)=TAB enth|fffd|lt.
Const leer As String = "            "

Const Parameter As String = "Kopf mit Parameter", m_struk As String = "Strukturbericht"
Const colorIndex As Integer = 3, colorIndex2 As Integer = 38, colorIndex3 As Integer = 10
' colorIndex = 3      ' knallrot = 3
' colorIndex2 = 38    ' pink = 38
' colorIndex3 = 10    ' dunkelgr|fffd|n
Dim gelbRGB As Long, violettRGB As Long, dklgruenRGB As Long, rotRGB As Long, blauRGB As Long




Sub Init()


gelbRGB = RGB(180, 180, 0)
violettRGB = RGB(255, 0, 255)
dklgruenRGB = RGB(0, 128, 0)
rotRGB = RGB(255, 0, 0)
blauRGB = RGB(0, 0, 255)

' Das Array header enth|fffd|lt die Spalten|fffd|berschriften genau in der Reihenfolge, wie die Enum SpaltenFelder vorgibt
'  ("Listenende" braucht nat|fffd|rlich keine Korrespondenz)
header = Array("Material", "KoGr", "PPG", "Modulorg.", "Beziehungswissen", "Menge", "VCR", _
                "Objekt-Name", "|fffd|nd.Nr. Instanz", "Element 1.1 (absolut)", "Element 1.2 (absolut)", _
                "Element 1.3 (absolut)", "Element 2.1 (absolut)", "Element 2.2 (absolut)", _
                "Element 2.3 (absolut)", "Element 3.1 (absolut)", "Element 3.2 (absolut)", _
                "Element 3.3 (absolut)", "Verschiebung X-Richtung (absolut)", _
                "Verschiebung Y-Richtung (absolut)", "Verschiebung Z-Richtung (absolut)", _
                "Dokumentformat", "Doku-ID", "Kennz. VC2", "VZK", "HB", "Freigabehinweis", "ZI", "Ver.", "Zeichnungshinweis", "DMU")

' Das Array farbspalten beschreibt in der Struktur
'    <Suchbegriff = 0><Tab><Spaltennummer = 1><Tab><Farbnummer = 2><Tab><F|fffd|llbedingung = 3>
' welcher Suchtext (in der Spalte Ergebnis Instanzanalyse) in der Spalte Spaltennummer (gem|fffd||fffd| Enum SpaltenFelder) welche Hintergrundfarbe erzeugen soll,
' wenn die Bedingung (Enum Befuellart) erf|fffd|llt ist
farbspalten = Array( _
"*KoGr ist nicht gefuellt*" & t & Kogr & t & colorIndex & t & Immer, _
"*PPG ist nicht gefuellt*" & t & PPG & t & colorIndex & t & Immer, _
"*Modulorg. ist nicht gefuellt*" & t & Modulorg & t & colorIndex & t & Immer, _
"*VC steht auf N*" & t & vcr & t & colorIndex & t & Immer, _
"*Widerspruch im Beziehungswissen PosVar*" & t & BezWi & t & colorIndex & t & Immer, _
"*Menge ist nicht gefuellt*" & t & Menge & t & colorIndex & t & Immer, _
"*Identische Lage*" & t & Elem11 & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & Elem12 & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & Elem13 & t & colorIndex & t & Nichtleer, _
"*Identische Lage*" & t & Elem21 & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & Elem22 & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & Elem23 & t & colorIndex & t & Nichtleer, _
"*Identische Lage*" & t & Elem31 & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & Elem32 & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & Elem33 & t & colorIndex & t & Nichtleer, _
"*Identische Lage*" & t & VectX & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & VectY & t & colorIndex & t & Nichtleer, "*Identische Lage*" & t & VectZ & t & colorIndex & t & Nichtleer, _
"*Anzahl unstimmig*" & t & Menge & t & colorIndex & t & Nichtleer, _
"*Fehlende Instanz*" & t & vcr & t & colorIndex & t & Immer, _
"*VCR = N und Instanz vorhanden*" & t & PPG & t & colorIndex & t & Immer, _
"*VC2 unvollstaendig und 5Y veroeffentlicht*" & t & VC2Kz & t & colorIndex & t & Immer, _
"*Modulorg. ist nicht gefuellt*" & t & Modulorg & t & colorIndex & t & Immer, _
"*Freigabehinweis*" & t & FreigHinw & t & colorIndex & t & Immer, _
"*Vorzugskennung*" & t & vzk & t & colorIndex & t & Immer, _
"*TAIS ZI hoeher*" & t & InstVer & t & colorIndex & t & Nichtleer)

'"*TAIS ZI hoeher*" & t & PVZI & t & colorIndex & t & Nichtleer, -- wird nicht eingef|fffd|rbt
'DMU bzw. ZHW bekommen keine Einf|fffd|rbung!

'If c.Value Like "*Widerspruch im Beziehungswissen PosVar |fffd| Instanz*" Then
'das - vertr|fffd|gt er nicht...

ReDim farbspalteninfo(UBound(farbspalten), 3) As Variant
Dim i As Long, eintrag As Variant
For i = 0 To UBound(farbspalten)
    eintrag = Split(farbspalten(i), t)
    farbspalteninfo(i, 0) = eintrag(0)
    farbspalteninfo(i, 1) = eintrag(1)
    farbspalteninfo(i, 2) = eintrag(2)
    farbspalteninfo(i, 3) = eintrag(3)
Next i
' Das Array zeilenfaerbung beschreibt in der Struktur
'    <Kombisuchtext = 0><Tab><Zeilenteiltext = 1><Tab><Farbnummer = 2>
' welcher Kombisuchtext (in der ganzen Zelle der Ergebnis Instanzanalyse) zur Einf|fffd|rbung der (Teil-)Zeile,
' die den Zeilenteiltext enth|fffd|lt, mit welcher Textfarbe f|fffd|hrt
' Das Array wird von vorn nach hinten durchgearbeitet, d.h. sp|fffd|tere Eintr|fffd|ge |fffd|bertrumpfen fr|fffd|here!
zeilenfaerbung = Array( _
"*Fehlende Instanz*" & t & "Fehlende Instanz" & t & gelbRGB, _
"*Fehlende Instanz in Ordnung*" & t & "Fehlende Instanz in Ordnung" & t & dklgruenRGB, _
"*Anzahl unstimmig*" & t & "Anzahl unstimmig" & t & violettRGB, _
"*VC steht auf N*" & t & "VC steht auf N" & t & dklgruenRGB, _
"*Identische Lage*" & t & "Identische Lage" & t & rotRGB, _
"*VCR = N und Instanz vorhanden*" & t & "VCR = N und Instanz vorhanden*" & t & dklgruenRGB, _
"*VC2 unvollstaendig und 5Y veroeffentlicht*" & t & "VC2 unvollstaendig und 5Y veroeffentlicht" & t & blauRGB, _
"*Freigabehinweis*" & t & "Freigabehinweis" & t & blauRGB, _
"*Freigabehinweis A*" & t & "Freigabehinweis A" & t & dklgruenRGB, _
"*TAIS ZI hoeher*" & t & "TAIS ZI hoeher" & t & rotRGB, _
"*Vorzugskennung*" & t & "Vorzugskennung" & t & rotRGB, _
"*DMU*" & t & "DMU" & t & blauRGB, _
"*ZHW*" & t & "ZHW" & t & blauRGB)

ReDim zeilenfaerbungteiltexte(UBound(zeilenfaerbung), 2) As Variant
For i = 0 To UBound(zeilenfaerbung)
    eintrag = Split(zeilenfaerbung(i), t)
    zeilenfaerbungteiltexte(i, 0) = eintrag(0)
    zeilenfaerbungteiltexte(i, 1) = eintrag(1)
    zeilenfaerbungteiltexte(i, 2) = eintrag(2)
Next i

ergebnisspalten = Array()
End Sub
                


Sub setColors()
'
' Dieses Makro hat zwei Aufgaben:
' 1) Lesen der Ergebnis-Spalte ("Ergebnis Instanzanalyse")
'    und aufgrund der Fehlermeldung die
'    entsprechende Spalte in dieser Zeile markieren
' 2) Konsistenz-Pr|fffd|fungen
'    Ermitteln der Anzahl der Instanzen und
'    |fffd|berpr|fffd|fung der Mengen und daraufhin Ausgeben von
'    Fehlermeldungen und Markieren der entsprechenden Spalten
'
' Wenn die Spalte "Ergebnis Instanzanalyse" oder
' eine der Spalten
'
'   Material,
'   KoGr,
'   PPG,
'   Modulorg.,
'   Beziehungswissen,
'   Menge,
'   VCR,
'   Objekt-Name,
'   |fffd|nd.Nr. Instanz,
'   Element 1.1 (absolut)
'   Element 1.2 (absolut)
'   Element 1.3 (absolut)
'   Element 2.1 (absolut)
'   Element 2.2 (absolut)
'   Element 2.3 (absolut)
'   Element 3.1 (absolut)
'   Element 3.2 (absolut)
'   Element 3.3 (absolut)
'   Verschiebung X-Richtung (absolut)
'   Verschiebung Y-Richtung (absolut)
'   Verschiebung Z-Richtung (absolut)
'   Dokumentformat
'   Doku-ID
'   Kennz. VC2
'   VZK
'   HB
'   Freigabehinweis
'
'   fehlt,
'   ==> Makro abbrechen
'
'
' zuerst die Anzahl der Zeilen ermitteln
' mind. eine Spalte sollte immer gef|fffd|llt sein (hier Spalte 1)
'
' colorIndex zum Einf|fffd|rben der Spalten zur Fehlermeldung
' colorIndex2 zum Einf|fffd|rben der Fehlermeldungs-Spalte ("Ergebnis Instanzanalyse")
'
' |fffd|brigens: Es hei|fffd|t Cells("A1:B1") aber Cells(zeile,spalte)...
'
'  0 = wei|fffd|
'  1 = schwarz
'  2 = wei|fffd|
'  3 = knallrot
'  4 = gr|fffd|n
'  5 = dunkelblau
'  6 = gelb
'  7 = leuchtendviolett
'  8 = leuchtendt|fffd|rkis
'  9 = braun
' 10 = dunkelgr|fffd|n
' 11 = nachtblau
' 12 = dunkeloliv
' 13 = dunkelviolett
' 14 = mittelgr|fffd|n
' 15 = mittelgrau
' 16 = dunkelgrau
' 17 = taubenblau
' 18 = dunkelviolett
' 19 = hellocker
' 20 = hellt|fffd|rkis
' 21 = dunkelviolett
' 22 = altrosa (helltomate)
' 23 = mittelblau
' 24 = hellgrau
' 25 = nachtblau
' 26 = leuchtendviolett
' 27 = gelb
' 28 = leuchtendt|fffd|rkis
' 29 = dunkelviolett
' 30 = dunkelbraun
' 31 = mittelgr|fffd|n
' 32 = dunkelblau
' 33 = leuchtendt|fffd|rkis
' 34 = hellt|fffd|rkis
' 35 = hellblaugr|fffd|n
' 36 = hellgelb
' 37 = hellblau
' 38 = pink
' 39 = hellviolett
' 40 = hell-lachs
' 41 = blau
' 42 = t|fffd|rkis
' 43 = hell.oliv
' 44 = orange
' 45 = hellbraun (kirsch-holz)
' 46 = rotbraun
' 47 = dunkelviolett
' 48 = dunkelgrau
' 49 = dunkelpreussischblau
' 50 = gr|fffd|n
'

Dim verbose As Integer, kzVM As Integer, kzMO As Integer, kzUSK As Integer, kzBP As Integer
Dim txt As String
Dim c As Range
Dim Antwort
Dim leerSpalte As Integer, leerSpalteZeile As Long, zeileUeber As Long
Dim i As Long
Dim Zeile As Long, zeileF1 As Long, zeileFL1 As Long ' aktuelle, erste und unterste (gef|fffd|llte) Zeile
Dim col1 As Integer
Dim kz As Integer ' signalisiert Abbruch
Dim spaltenErg As Long



'Beschleunigung und Info:

Application.ScreenUpdating = False
Application.StatusBar = "Initialisierung Daten f|fffd|r Einf|fffd|rbung"

Call Init

'
' Im sp|fffd|teren Makro kann die folgende Abfrage entfallen

verbose = 0
' Antwort = MsgBox("M|fffd|chten Sie jeden Schritt sehen ?", vbYesNo)
' If Antwort = vbYes Then verbose = 1

' Lesen Parameter
    
Worksheets(Parameter).Select

Call getParameters(kzVM, kzUSK, kzMO, kzBP)

'  kzMO = 900

If kzVM >= 900 Or _
    kzUSK >= 900 Or _
    kzMO >= 900 Then
    
    txt = ""
    If kzVM >= 900 Then txt = "Parameter Vorlagematerial" & Chr(10)
    If kzUSK >= 900 Then txt = txt & "Parameter USK" & Chr(10)
    If kzMO >= 900 Then txt = txt & "Parameter Modulorganisation" & Chr(10)
    
    txt = txt & Chr(10) & "fehlt in Blatt '" & Parameter & "'" _
    & Chr(10) & Chr(10) & "==> Makro-Abbruch"
    
    If verbose = 0 Then
        For Each c In Range("C1:C1").Cells
            c.Value = txt
            c.Interior.colorIndex = colorIndex2
            Next
        Exit Sub
    End If
    
    MsgBox txt, , "Fehler in Blatt '" & Parameter & "'"
    
    Exit Sub
    
End If

If verbose = 1 Then
    MsgBox "kzVM  = " & kzVM & Chr(10) _
            & "kzUSK = " & kzUSK & Chr(10) _
            & "kzMO  = " & kzMO
End If

Antwort = MsgBox("Modulorg. pr|fffd|fen ?", vbYesNo)
If Antwort = vbYes Then kzMO = 1
' wlz: wenn kzMO vorher schon auf 1 war, warum dann die Abfrage?
'      Oder sollte die Pr|fffd|fung abgeschaltet werden, wenn mit Nein geantwortet wird?

' Lesen Strukturreport

Worksheets(m_struk).Select

'  A -> IV = 26 * 10 - 4 = 256 Spalten

' Bestimmen der ersten leeren Spalte
' wlz: (auf Basis Zeile 2)
leerSpalte = 0
leerSpalteZeile = 2
For Each c In Range("A2:IV2").Cells
    If c.Value = "" Then
        leerSpalte = c.Column
        Exit For
    End If
Next
    
If leerSpalte = 0 Then leerSpalte = 1
    
'Bestimmen der |fffd|berschriftszeile und der Spalte der Instanzanalyse
' wlz: (suchbereich erste 20 Zeilen)
For Each c In Range("A1:IV20").Cells
    zeileUeber = c.row
    spaltenErg = c.Column
    If c.Value Like "*Ergebnis Instanzanalyse*" Then Exit For
Next
    
If zeileUeber = 20 And spaltenErg = 256 Then
    
    txt = "Spalte 'Ergebnis Instanzanalyse' fehlt" & Chr(10) & " => Makro-Abbruch"
    
    If verbose = 0 Then
        With Cells(leerSpalteZeile, leerSpalte)
            .Value = txt
            .Interior.colorIndex = colorIndex2
        End With
    End If
    
    MsgBox txt
    Exit Sub
End If

' Bestimmen aller Spalten des Ergebnis Instanzanalyse f|fffd|r die verschiedenen Filter:
For i = 1 To 256
    If Cells(zeileUeber, i).Value Like "*Ergebnis Instanzanalyse*" Then
        ReDim Preserve ergebnisspalten(UBound(ergebnisspalten) + 1)
        ergebnisspalten(UBound(ergebnisspalten)) = i
    End If
Next i

If verbose = 1 Then
    txt = "|fffd|berschrifts-Zeile: " & zeileUeber & Chr(10) _
     & "Spalte Ergebnis Instanzanalyse: "
    For i = 0 To UBound(ergebnisspalten)
        txt = txt & " " & ergebnisspalten(i)
    Next i
    MsgBox txt
End If

' In zeileUeber, spalteErg steht "Ergebnis Instanzanalyse"
' wlz: Bestimmen der |fffd|brigen (relevanten) Spaltennummern anhand der |fffd|berschriften
For Each c In Range(Cells(zeileUeber, 1), Cells(zeileUeber, 256))
    For i = 0 To UBound(spalten)
        If c.Value = header(i) Then
            spalten(i) = c.Column
            Exit For
        End If
    Next i
Next
    
'   spalteE11 = ""
'   spalteVX = ""
txt = ""
For i = 0 To UBound(spalten)
    If spalten(i) = 0 Then
        If txt <> "" Then txt = txt & Chr(10)
        txt = txt & "Spalte '" & header(i) & "' fehlt"
    End If
Next i
    
If txt <> "" Then
    txt = txt & Chr(10) & Chr(10) & " ==> Makro-Abbruch"
    
    If verbose = 0 Then
        With Cells(leerSpalteZeile, leerSpalte)
            If .Value = "" Then
                .Value = txt
            Else
                .Value = .Value & Chr(10) & txt
            End If
            .Interior.colorIndex = colorIndex2
        End With
        Call ReactivateRefreshForEnd
        Exit Sub
    End If
    
    MsgBox txt
    Call ReactivateRefreshForEnd
    Exit Sub
    
End If
    
If verbose = 1 Then
    ' Ausgabe der Spaltenzuordnungergebnisse
    txt = ""
    For i = 0 To UBound(spalten)
        If i > 1 Then txt = txt & Chr(10)
        txt = txt & "Spalte " & header(i) & ": " & spalten(i)
    Next i
    MsgBox txt
     
End If

 zeileF1 = zeileUeber + 1
 Zeile = zeileF1
 col1 = 1
' Suchen erste gef|fffd|llte Zeile einer sonst immer gef|fffd|llten Spalte (hier Spalte 1)
For Each c In Range(Cells(Zeile, col1), Cells(61000, col1))
    zeileF1 = c.row
    txt = c.Value
    If c.Value > "" Then Exit For
Next

' wlz: Hier w|fffd|re eine Pr|fffd|fung auf zeileF1 < 61000, bzw. Erfolg sinnvoll!
If Cells(zeileF1, col1).Value = "" Then
    MsgBox "Es wurden keine Inhalte gefunden"
    Exit Sub
End If

 If verbose = 1 Then
    MsgBox "1.gef|fffd|llte Zeile in Spalte 1: " & Chr(10) _
    & "Zeile: " & zeileF1 & Chr(10) _
    & "Text: " & txt
 End If
 
' In (zeileF1,1) steht der 1. Text > blank

Zeile = zeileF1
zeileFL1 = 0
' Suchen letzte Zeile einer immer gef|fffd|llten Spalte
' wlz: auch hier Spalte 1. Das Maximalergebnis ist 63000

For Each c In Range(Cells(Zeile, col1), Cells(63000, col1))
    If c.Value = "" Then Exit For
    zeileFL1 = c.row
    txt = c.Value
Next
    
If verbose = 1 Then
    MsgBox "letzte Zeile in Spalte 1: " & zeileFL1 & Chr(10) _
            & "Text: " & txt
End If


'----------------------------------------------------
'Lesen der in der Ergebnis-Spalte gef|fffd|llten Zeilen

If verbose = 1 Then
    MsgBox "Lesen Ergebnis-Spalte" & Chr(10) _
            & "Bearbeiten bereits gef|fffd|llte Fehlermeldungen"
End If

For i = Zeile To zeileFL1
        Application.StatusBar = "Durchlauf 1/2, Zeile " & i & " von " & zeileFL1
            
'        If c.Value = "" Then
'        Else
        
         Call ZeileGefuellteErgSpalte(verbose, m_struk, i, kz, colorIndex, colorIndex2)
            
'        End If
            
        If kz = 1 Then
            Call ReactivateRefreshForEnd
            Exit Sub
        End If
        
        'wlz: Pr|fffd|fen, ob in erster Spalte was steht (das ist hier |fffd|berfl|fffd|ssig, wenn c nicht von Prozedur ZeileGefuellteErgSpalte in der Position ver|fffd|ndert wird!
        '     Das ist auch nicht der Fall. Nur der Inhalt von c wird angefasst)
        '     Denn die Schleife geht nur bis zeileFL1, die so definiert war, dass es die letzte Zeile ist, in der Spalte 1 gef|fffd|llt ist...
    '    Ready = 0
    '    For Each c01 In Range(Cells(c.Row, col1), Cells(c.Row, col1))
    '        If c01.Value = "" Then
    '            Ready = 1
    '            Exit For
    '        End If
    '    Next
        
    '    If Ready = 1 Then Exit For
                
Next i
' Lesen der PosVars
Dim PosV
'B00000017131760 |fffd|berlauf dfrow1 --> dfrow1 und dfrow2 von Integer auf Long
Dim dfrow1 As Long, dfrow2 As Long, dokformat As String, snrdf1 As String, snrdf2 As String
Dim snrPV As String, ziPV As String, rowPV As Long, zhinPV As String, dmuPV As String
Dim farbkz As Integer, nextrow As Long
Dim HBval, instanz_vorh, FHw
Dim ccc As Range
Dim VZKName As String
Dim kz_vc2_str As String ' je Strukturstufentiefe ein Zeichen (" " oder "2"), nie mehr als die aktuelle SS + 1 (SS = 0 => 1 Zeichen)!
Dim name As String

If verbose = 1 Then
    MsgBox "Lesen Ergebnis-Spalte beendet" & Chr(10) _
    & "Lesen PosVars"
End If
' Pr|fffd|fen auf leere KoGr, PPG, (ModulStufe 2)
PosV = ""
dfrow1 = 0
dfrow2 = 0
dokformat = ""
snrdf1 = ""
snrdf2 = ""
' snrPV ist die Sachnummer der letzten PV bzw. POS
snrPV = ""
kz_vc2_str = ""

For Each c In Range(Cells(zeileF1, spalten(PV)), Cells(zeileFL1, spalten(PV)))

    Application.StatusBar = "Durchlauf 2/2, Zeile " & c.row & " von " & zeileFL1
    
'   Dieses Farbkz zeigt an, wenn die Ergebnis-Spalte in dieser Tabellen-Zeile
'   Zeilen mit unterschiedlichen Farben bekommen soll.
'   Als letztes Upro zu dieser Zeile wird, wenn farbkz = 1 ist, multiColorCell
'   aufgerufen. Damit dieser Mechanismus funktioniert, muss farbkz an die Upros
'   |fffd|bergeben werden und dort genau dann gesetzt werden, wenn innerhalb einer Zelle
'   eine nicht schwarze Zeile ausgegeben werden soll

    farbkz = 0

    If c.Value Like "P*" Or c.Value Like "BKK*" Then
        ' wlz: eigentlich immer der Fall, die Objekte hei|fffd|en im Beispiel POS* oder PV*...
        With Cells(c.row, spalten(HB))
            HBval = .Value
            ' wlz: hb ist die Strukturstufe
        End With
        snrPV = Cells(c.row, spalten(Snr)).Value

'      Dokumentformat = 5Y ?
       ' wlz: Offenbar wird dokformat |fffd|ber die Zeilen hinweg gemerkt. Wenn es sich um ein 5Y handelt, wird aber 5Y1 geschrieben?!
       '      Das wird dann erst in der n|fffd|chsten Zeile auf 5Y umgesetzt, wenn dort KEIN DOKFORMAT eingetragen ist (sonst leer oder wieder 5Y1)
       '      Die snrdf1 ist die Sachnummer der Hauptzeile mit 5Y(1)-Dokument
       '      Die snrdf2 ist die Sachnummer der Folgezeile
       If dokformat = "5Y1" Then
          dokformat = "5Y"
       End If

       With Cells(c.row, spalten(DokForm))
       
           If .Value = "5Y" Then
              dokformat = "5Y1"
              dfrow1 = c.row
              
              snrdf1 = Cells(c.row, spalten(Snr)).Value
              
           Else
              If .Value = "" Then
'                dokform bleibt unver|fffd|ndert !
              Else
                 dokformat = ""
              End If
           End If
       
       End With
       
'      VC2 = 2 bei gesetztem dokform ?

       If dokformat = "5Y" Then
       
          With Cells(c.row, spalten(Snr))
              snrdf2 = .Value
          End With
          
          dfrow2 = 0
       
          With Cells(c.row, spalten(VC2Kz))
          
              If .Value = "2" Then
                 dfrow2 = c.row
              End If
          
          End With
          
          If dfrow2 = 0 Then
             snrdf2 = ""
          End If
          
          If snrdf1 = snrdf2 Then
          
             If c.Value Like "BKK*" Then

                Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, "VC2", _
                colorIndex, colorIndex2, farbkz)
                
                Call einfaerbenZelle(dfrow1, "DokForm", spalten(DokForm), colorIndex)
                      
                If kz = 1 Then
                    Call ReactivateRefreshForEnd
                    Exit Sub
                End If
                
             End If
             
          End If
       
       End If
       
'      VZK

       With Cells(c.row, spalten(vzk))

           VZKName = ""

           If .Value = "NN" Then
              VZKName = "VZK NN"
           End If
           If .Value = "GS" Then
              VZKName = "VZK GS"
           End If
           If .Value = "UN" Then
              VZKName = "VZK UN"
           End If
           If .Value = "BG" And c.Value Like "P*" And HBval = "00" Then
              VZKName = "VZK BG"
           End If
           
           If VZKName Like "VZK*" Then
           
                Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, VZKName, _
                colorIndex, colorIndex2, farbkz)
                
           End If

       End With

'      gibt es Instanzen ?

       If Cells(c.row, spalten(AendNrInst)).Value = "" Then
              instanz_vorh = ""
       Else
              instanz_vorh = 1
       End If

        ' Ist evtl. in der n|fffd|chsten Zeile eine Instanz vorhanden?
       If c.row < zeileFL1 And instanz_vorh = "" Then

          nextrow = c.row + 1
          If Cells(nextrow, spalten(AendNrInst)).Value <> "" And _
             Cells(nextrow, spalten(PV)).Value = c.Value Then
                 instanz_vorh = 1
          End If

       End If
        
       If Cells(c.row, spalten(Kogr)).Value = "" Then
                        
                    Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, "KoGr", _
                    colorIndex, colorIndex2, farbkz)
                    
                    If kz = 1 Then
                        Call ReactivateRefreshForEnd
                        Exit Sub
                    End If
                            
                        
                    Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, "PPG", _
                    colorIndex, colorIndex2, farbkz)
                    
                    If kz = 1 Then
                        Call ReactivateRefreshForEnd
                        Exit Sub
                    End If
                    
        End If

        If Cells(c.row, spalten(VC2Kz)).Value = "2" Then
                kz_vc2_str = Left(kz_vc2_str & leer, HBval) & "2"
        Else
                kz_vc2_str = Left(kz_vc2_str & leer, HBval) & " "
        End If

        If kz_vc2_str Like "*2*" Then ' d.h. es ist auf dieser oder einer dar|fffd|berliegenden Strukturstufe ein VC2-Kz = 2 gesetzt
            For i = 0 To UBound(ergebnisspalten)
                Call changeText(Cells(c.row, ergebnisspalten(i)), farbkz)
            Next
        End If

        FHw = Cells(c.row, spalten(FreigHinw)).Value

        If kzBP = 1 And c.Value Like "P*" Then
'           If kzBP = 1 Then

               If FHw = "A" Then
                    For i = 0 To UBound(ergebnisspalten)
                        Call addText(Cells(c.row, ergebnisspalten(i)), farbkz)
                    Next
               End If

        End If

        If FHw = "E" Or FHw = "C" Or FHw = "N" Or FHw = "P" Or FHw = "V" Then
            
            name = "Freigabehinweis" & instanz_vorh

            Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, name, _
            colorIndex, colorIndex2, farbkz)
                      
            If kz = 1 Then
                 Call ReactivateRefreshForEnd
                 Exit Sub
             End If

        End If
        
        If kzMO = 1 Then
                If Cells(c.row, spalten(Modulorg)).Value = "" Then
                
                    
                        Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, "Modulorg", _
                        colorIndex, colorIndex2, farbkz)
                        
                        If kz = 1 Then
                            Call ReactivateRefreshForEnd
                            Exit Sub
                        End If
                        
                
                End If
        End If
            
'       Anforderung Pr|fffd|fung ZI TAIS zu Dokument
'       Anforderung Pr|fffd|fung DMU-/Zeichnungsheinweis
        ' Bestimmen der Sachnummer der PV / Unterscheidung ob Instanz oder nicht:
        If Cells(c.row, spalten(AendNrInst)).Value = "" Then
            ' Keine Instanz, merken der Snr und des ZI f|fffd|r n|fffd|chste Durchl|fffd|ufe
            snrPV = Cells(c.row, spalten(Snr)).Value
            ziPV = Cells(c.row, spalten(PVZI)).Value
            zhinPV = Cells(c.row, spalten(ZHIN)).Value
            dmuPV = Cells(c.row, spalten(DMU)).Value
            rowPV = c.row
        Else
            ' Instanz, Vergleich mit gemerkten Daten
            '           Anforderung Pr|fffd|fung ZI TAIS zu Dokument
            If Cells(c.row, spalten(Snr)).Value = snrPV And ziPV <> "" And Cells(c.row, spalten(InstVer)).Value <> "" Then
                ' Stringvergleich bei ZI allein reicht leider nicht aus, da dort Z > AA, aber wir haben A,B,...,Z,AA,AB,...,AZ,BA,...
                If Len(Trim(Cells(c.row, spalten(InstVer)).Value)) < Len(Trim(ziPV)) Or _
                    Trim(Cells(c.row, spalten(InstVer)).Value) < Trim(ziPV) Then
                    ' Fehlerfall
                    ' Eintrag bei der Instanz
                        Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, "TAISZI", _
                        colorIndex, colorIndex2, farbkz)
                        If kz = 1 Then
                            Call ReactivateRefreshForEnd
                            Exit Sub
                        End If
                    ' Eintrag bei der PV (Umsetzen??? Nein!)
                      '  Set ccc = Cells(rowPV, spalten(Erg))
                      '  If ccc.Value Like "*TAIS ZI hoeher*" Then
                      '  Else
                      '      Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, ccc, kz, "TAISZI", _
                      '      colorIndex, colorIndex2, farbkz)
                      '      If kz = 1 Then Exit Sub
                      '  End If
                    ' Ende Eintrag bei der PV
                End If
            End If
            '           Anforderung Pr|fffd|fung DMU-/Zeichnungsheinweis
            name = ""
            If Cells(c.row, spalten(Snr)).Value = dmuPV Then name = "DMU"
            If Cells(c.row, spalten(Snr)).Value = zhinPV Then
                If name <> "" Then
                    name = "DMU/ZHIN"
                Else
                    name = "ZHIN"
                End If
            End If
            If name <> "" Then
                    Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, c.row, kz, name, _
                        colorIndex, colorIndex2, farbkz)
                    If kz = 1 Then
                        Call ReactivateRefreshForEnd
                        Exit Sub
                    End If
                    ' Eintrag bei der PV (Umsetzen??? Nein!)
                    '    Set ccc = Cells(rowPV, spalten(Erg))
                    '    Call ZeileNichtGefuellteErgSpalte(verbose, m_struk, ccc, kz, name, _
                    '        colorIndex, colorIndex2, farbkz)
                    '    If kz = 1 Then Exit Sub
                    ' Ende Eintrag bei der PV
            End If
            
        End If

            
'           Dieser Aufruf sollte als letztes UPRO der Zeile c.Row aufgerufen werden
            'If farbkz = 1 Then
            '       Call multiColorCell(Cells(c.Row, spalten(Erg)), colorIndex3)
            'End If
        For i = 0 To UBound(ergebnisspalten)
            Call multiColorCellNeu(Cells(c.row, ergebnisspalten(i)))
        Next i
    End If
    
Next
    
    
    If verbose = 1 Then
        MsgBox "Lesen PosVars beendet" & Chr(10) _
        & "==> Makro-Ende <=="
    End If
    Call ReactivateRefreshForEnd
    
End Sub
Sub ReactivateRefreshForEnd()
    Application.ScreenUpdating = True
    Application.StatusBar = ""
End Sub

Sub ZeileGefuellteErgSpalte(verbose, m_struk, row As Long, kz, colorIndex, colorIndex2)
Dim Antwort As String
Dim vkz As Integer
Dim i As Integer, j As Integer
Dim cc As Range



For j = 0 To UBound(ergebnisspalten)
    Set cc = Cells(row, ergebnisspalten(j))
    If cc.Value <> "" Then
        If verbose = 1 Then
            Antwort = MsgBox("Bearbeiten Fehlermeldung(en):" & Chr(10) _
                         & cc.Value & Chr(10) _
                         , vbYesNoCancel, "Zeile: " & row & " Spalte: " & cc.Column)
            kz = 0
            If Antwort = vbCancel Then kz = 1
            If kz = 1 Then Exit Sub
            If Antwort = vbNo Then GoTo NextErgebnis
        End If
        vkz = 0
        For i = 0 To UBound(farbspalten)
            ' farbspalteninfo = Split(farbspalten(i), t) 'bei Init bereits erledigt
            ' Farbspalten hat die Struktur <Suchbegriff = 0><Tab><Spaltennummer = 1><Tab><Farbnummer = 2><Tab><F|fffd|llbedingung = 3>
            If cc.Value Like farbspalteninfo(i, 0) Then
                With Cells(row, spalten(farbspalteninfo(i, 1)))
                    If farbspalteninfo(i, 3) = Immer Or .Value <> "" Then
                        .Interior.colorIndex = farbspalteninfo(i, 2)
                    End If
                End With
                vkz = 1
            End If
        Next i
        'If c.Value Like "*Widerspruch im Beziehungswissen PosVar |fffd| Instanz*" Then
        'das - vertr|fffd|gt er nicht...
        
        If vkz = 0 Then
            '
            ' neue Fehlermeldungen k|fffd|nnen hier nur erkannt werden,
            ' wenn sonst keine Fehlermeldungen in dieser Zeile stehen
            '
            If verbose = 1 Then
                MsgBox "neue Fehlermeldung" & Chr(10) _
                    & "in 'ZeileGefuellteErgSpalte' :" & Chr(10) _
                    & cc.Value & Chr(10) _
                    & "Zeile: " & row, , "Spalte: " & cc.Column & " neue Fehlermeldung !"
            End If
                    
            If cc.Value Like "*neue Fehlermeldung*" Then
            Else
                    
                cc.Value = cc.Value & " <== neue Fehlermeldung !"
                        
                cc.Interior.colorIndex = colorIndex2
            
            End If
        End If
    End If
NextErgebnis:
Next j
End Sub


Sub ZeileNichtGefuellteErgSpalte(verbose, m_struk, row As Long, kz, name, _
        colorIndex, colorIndex2, farbkz)

Dim Antwort As String
Dim verbose1 As Integer
Dim fehlertext As String, fehlerteiltext As String
Dim FHwval As String
Dim inst_vorh
Dim txt As String, txt1 As String, txt2 As String
Dim ccc As Range
Dim i As Integer


If verbose = 1 Then
    Antwort = MsgBox("Bearbeiten Fehler:" & Chr(10) _
                 & name & Chr(10) _
                 , vbYesNoCancel, "Zeile: " & row)
    kz = 0
    If Antwort = vbCancel Then kz = 1
    If kz = 1 Then Exit Sub
    If Antwort = vbNo Then Exit Sub
    verbose1 = 1
End If

Select Case name
    Case "KoGr"
        fehlertext = "KoGr ist nicht gefuellt"
        fehlerteiltext = "*" & fehlertext & "*"
    Case "PPG"
        fehlertext = "PPG ist nicht gefuellt"
        fehlerteiltext = "*" & fehlertext & "*"
    Case "Modulorg"
        fehlertext = "Modulorg. ist nicht gefuellt"
        fehlerteiltext = "*" & fehlertext & "*"
    Case "Menge fehlt"
        fehlertext = "Menge ist nicht gefuellt"
        fehlerteiltext = "*" & fehlertext & "*"
    Case "VC2"
        fehlertext = "VC2 unvollstaendig und 5Y veroeffentlicht"
        fehlerteiltext = "*" & fehlertext & "*"
    Case "Einbau-Lage"
        fehlertext = "Fehler Identische Lage"
        fehlerteiltext = "*Identische Lage*"
    Case "Fehlende Instanz"
        fehlertext = "Fehlende Instanz"
        fehlerteiltext = "*" & fehlertext & "*"
    Case "VCR = N"
        fehlertext = "VCR = N und Instanz vorhanden"
        fehlerteiltext = "*" & fehlertext & "*"
    Case "VZK NN"
        fehlertext = "Vorzugskennung NN, nicht f|fffd|r Neukonstruktionen"
        fehlerteiltext = "*Vorzugskennung*"
    Case "VZK GS"
        fehlertext = "Vorzugskennung GS, Freigabe nicht m|fffd|glich"
        fehlerteiltext = "*Vorzugskennung*"
    Case "VZK UN"
        fehlertext = "Vorzugskennung UN, Freigabe nicht m|fffd|glich"
        fehlerteiltext = "*Vorzugskennung*"
    Case Is = "VZK BG"
        fehlertext = "Vorzugskennung BG, ab Produktlinie LK gesperrt"
        fehlerteiltext = "*Vorzugskennung*"
    Case Is = "TAISZI"
        fehlertext = "TAIS ZI hoeher"
        fehlerteiltext = "*" & fehlertext & "*"
    Case Is = "DMU"
        fehlertext = "DMU"
        fehlerteiltext = "*" & fehlertext & "*"
    Case Is = "ZHIN"
        fehlertext = "ZHW"
        fehlerteiltext = "*" & fehlertext & "*"
    Case Is = "DMU/ZHIN"
        fehlertext = "DMU/ZHW"
        fehlerteiltext = "*" & fehlertext & "*"
    Case Else
        If name Like "Anzahl unstimmig*" Then
            fehlertext = name
            fehlerteiltext = "Anzahl unstimmig*"
        End If
End Select
If fehlertext <> "" Then
    For i = 0 To UBound(ergebnisspalten)
    With Cells(row, ergebnisspalten(i))
        If name = "VCR = N" Then
              If .Value Like "*VC steht auf N*" Then
                 .Value = Replace(.Value, "VC steht auf N", "VCR = N und Instanz vorhanden")
              End If
        ElseIf name = "DMU/ZHIN" Then
              If Not .Value Like "*DMU/ZHW*" Then
                If .Value Like "*DMU*" Then
                    .Value = Replace(.Value, "DMU", "DMU/ZHW")
                ElseIf .Value Like "*ZHW*" Then
                    .Value = Replace(.Value, "ZHW", "DMU/ZHW")
                End If
              End If
        End If
    
    
            
        If .Value = "" Then
            .Value = fehlertext
        Else
            If .Value Like fehlerteiltext Then
            Else
                .Value = .Value & Chr(10) & fehlertext
            End If
        End If
        
            
    End With
    Next
    
    Call ZeileGefuellteErgSpalte(verbose1, m_struk, row, kz, colorIndex, colorIndex2)
    If kz = 1 Then Exit Sub
End If




If name Like "Freigabehinweis*" Then

    With Cells(row, spalten(FreigHinw))
        FHwval = .Value
    End With

    If name = "Freigabehinweis" Then
       inst_vorh = ""
    Else
       inst_vorh = 1
    End If
    
    For i = 0 To UBound(ergebnisspalten)
    With Cells(row, ergebnisspalten(i))

        If Not (.Value Like "*Freigabehinweis*") Then
    
            farbkz = 1
    
            txt1 = "Freigabehinweis " & FHwval & ", nicht relevant f|fffd|r PSN"
            txt2 = txt1 & ", Instanz vorhanden"
            
            If inst_vorh = 1 Then
               txt = txt2
            Else
               txt = txt1
            End If
    
            If .Value = "" Then
               .Value = txt
            Else
    
               If .Value Like "*Fehlende Instanz*" Or _
                  .Value Like "*Instanz vorhanden*" Or _
                  inst_vorh = "" Then
                  .Value = .Value & Chr(10) & txt1
               Else
                  .Value = .Value & Chr(10) & txt2
               End If
              
            End If
            
        End If
    End With
    Next

    Call ZeileGefuellteErgSpalte(verbose1, m_struk, row, kz, colorIndex, colorIndex2)
    'If kz = 1 Then Exit Sub
    Exit Sub

End If

If verbose = 0 Or fehlertext <> "" Then Exit Sub

MsgBox "Unbehandelter Name in" & Chr(10) _
        & "'ZeileNichtGefuellteErgSpalte'" & Chr(10) _
        & "Zeile: " & row, , "Zeile: " & row & " unbehandelter Name !"

End Sub

Sub changeText(c, farbkz)
Dim txt1 As String, txt2 As String
txt1 = "Fehlende Instanz"
txt2 = "Fehlende Instanz in Ordnung, da VC2 unvollst|fffd|ndig"

If c.Value = txt1 Then
   c.Value = txt2
   farbkz = 1
   Exit Sub
End If

If c.Value Like "*Fehlende Instanz in Ordnung*" Then Exit Sub

If c.Value Like "*Fehlende Instanz*" Then
   c.Select
   Selection.Replace What:=txt1, Replacement:=txt2
   farbkz = 1
End If

End Sub

Sub addText(c, farbkz)
Dim txt1 As String

If c.Value Like "*Freigabehinweis A*" Then Exit Sub

txt1 = "Freigabehinweis A, nicht relevant f|fffd|r Bauphase"

farbkz = 1

If c.Value = "" Then
   c.Value = txt1
   Exit Sub
End If

c.Value = c.Value & Chr(10) & txt1

End Sub

Sub multiColorCell(c, colorIndex)
Dim txt1 As String, txt2 As String, txtL1 As String, txtL2 As String
Dim lens1 As Integer, leng1 As Integer, lens2 As Integer, leng2 As Integer
Dim kz As Integer, kz1 As Integer, kz2 As Integer, max As Integer
Dim ii As Integer, i As Integer, start As Integer, ok As Integer

' Diese Routine ist nicht elegant, aber alle extra einzuf|fffd|rbenden Zeilen einer
' Zelle m|fffd|ssen in einer Methode bearbeitet werden.
' Welche Zeile umgef|fffd|rbt wird und welche nicht, richtet sich nur nach dem Text.
' Die Reihenfolge der Zeilen muss unver|fffd|ndert bleiben

If c.Value = "" Then Exit Sub

' Diese Texte werden gesucht. Sie sind i.a. k|fffd|rzer, als die tats|fffd|chlichen Texte
' lens<n> = L|fffd|nge des gesuchten Textes txt<n>
' leng<n> = L|fffd|nge des gesamten Textes txt<n>

txt1 = "Freigabehinweis A, nicht relevant"
lens1 = 33
leng1 = 46

txt2 = "Fehlende Instanz in Ordnung"
lens2 = 27
leng2 = 49

' txt3 = "Freigabehinweis ?, nicht relevant f|fffd|r PSN"
' lens3 = 41
' leng3 = 41

' txt4 = "Freigabehinweis ?, nicht relevant f|fffd|r PSN, Instanz vorhanden"
' lens4 = 60
' leng4 = 60

txtL1 = "*" & txt1 & "*"
txtL2 = "*" & txt2 & "*"
' txtL3 = "*" & txt3 & "*"
' txtL4 = "*" & txt4 & "*"

kz1 = 0
kz2 = 0
' kz3 = 0
' kz4 = 0

If c.Value Like txtL1 Then kz1 = 1
If c.Value Like txtL2 Then kz2 = 1
' If c.Value Like txtL3 Then kz3 = 1
' If c.Value Like txtL4 Then
'    kz3 = 0
'    kz4 = 1
' End If

' Max = kz1 + kz2 + kz3 + kz4
max = kz1 + kz2

'If c.Row = 16 Then
'   MsgBox "Zeile " & c.Row & Chr(10) _
'          & c.Value & Chr(10) _
'          & " ---------------- " & Chr(10) _
'          & "Freigabehinweis A     " & kz1 & Chr(10) _
'          & "Fehlende Instanz i.O. " & kz2 & Chr(10) _
'          & "Freigabehinweis ..PSN " & kz3 & Chr(10) _
'          & "Freigabehinweis ...vh " & kz4 & Chr(10) _
'          & "Max " & Max
'End If
       
If max = 0 Then Exit Sub

c.Characters.Font.colorIndex = 0

kz = 0
ii = 0
For i = 1 To 500
    start = 0
    If ii < i Then ii = i
    If ii = 1 Then start = 1
    If c.Characters(start:=ii, Length:=1).text = Chr(10) Then start = ii + 1
    If ii > i And ii > start Then ii = ii + 1
    If start > 0 Then
'      zu viele If-Else-Cascaden vertr|fffd|gt er nicht. deshalb |fffd|ber ok
       ok = 0
       Call checkString(kz1, ok, c, start, lens1, leng1, txt1, kz, max, ii, "=", colorIndex)
       If kz = max Then Exit Sub
       Call checkString(kz2, ok, c, start, lens2, leng2, txt2, kz, max, ii, "=", colorIndex)
       If kz = max Then Exit Sub
'        Call checkString(kz3, ok, c, Start, lens3, leng3, txt3, kz, Max, ii, "Like", colorIndex)
'        If kz = Max Then Exit Sub
'        Call checkString(kz4, ok, c, Start, lens4, leng4, txt4, kz, Max, ii, "Like", colorIndex)
'        If kz = Max Then Exit Sub
       If ok = 0 Then ii = ii + 1
    End If

Next

End Sub

Sub multiColorCellNeu(c As Range)
    ' Algorithmus zur Einf|fffd|rbung der einzelnen Textzeilen von (Ergebnisspalten-)Zellen
    ' Wenn in Gesamtzellentext der Suchstring (zu einer Zeile von Array zeilenfaerbung) gefunden wird,
    ' dann wird jede Zeile (durch chr(10) markierte Begrenzung), die den Zeilenteiltext enth|fffd|lt, mit der Farbe eingef|fffd|rbt
    Dim i As Long
    If c.Value = "" Then Exit Sub
    For i = 0 To UBound(zeilenfaerbung)
        Dim pos0 As Long, zBeginn As Long, zEnde As Long
        
'        teiltexte = Split(zeilenfaerbung(i), t) ' wird mit zeilenfaerbungteiltexte bereits vorbereitet (Performance)
        If c.Value Like zeilenfaerbungteiltexte(i, 0) Then
            pos0 = 1
            While pos0 > 0
                pos0 = InStr(pos0, c.Value, zeilenfaerbungteiltexte(i, 1))
                If pos0 > 0 Then
                    zBeginn = InStrRev(c.Value, Chr(10), pos0)
                    zEnde = InStr(pos0, c.Value, Chr(10))
                    If zBeginn = 0 Then zBeginn = 1
                    If zEnde = 0 Then zEnde = Len(c.Value) + 1 ' wlz 21.2.12: Eins mehr, um auch das letzte Zeichen zu erwischen
                    c.Characters(start:=zBeginn, Length:=zEnde - zBeginn).Font.Color = zeilenfaerbungteiltexte(i, 2)
                    pos0 = pos0 + Len(zeilenfaerbungteiltexte(i, 1))
                End If
            Wend
            
        End If
    Next i
End Sub

Sub checkString(kzn, ok, c, start, lensn, lengn, txtn, kz, max, ii, op, colorIndex)
Dim Length As Integer
If kzn = 1 And ok = 0 Then
   If op = "=" Then
      If c.Characters(start:=start, Length:=lensn).text = txtn Then
         Length = lengn
         c.Characters(start:=start, Length:=Length).Font.colorIndex = colorIndex
         kz = kz + 1
         If kz = max Then Exit Sub
         kzn = ""
         ok = 1
         ii = start + Length
      End If
   Else
      If c.Characters(start:=start, Length:=lensn).text Like txtn Then
         Length = lengn
         c.Characters(start:=start, Length:=Length).Font.colorIndex = colorIndex
         kz = kz + 1
         If kz = max Then Exit Sub
         kzn = ""
         ok = 1
         ii = start + Length
      End If
   End If

End If

End Sub

Sub getParameters(kzVM, kzUSK, kzMO, kzBP)
Dim c As Range
Dim zeileVM, zeileUSK, zeileMO1, zeileMO2, zeileBP, zeileMO
'   welche Parameter gibt es
' wlz: wieder ein anderer Range, diesmal bis 62000... Ist aber auf dem Parameter-Sheet
' wlz: Was ist das Ziel der Funktion?
'      kzVM ist  0, wenn Zeile Vorlagenmaterial vorhanden, aber nichts eingetragen
'                1, wenn Zeile Vorlagenmaterial vorhanden und etwas eingetragen
'                2, wenn Zeile Vorlagenmaterial vorhanden und etwas eingetragen und kzUSK = 1
'              999, wenn Zeile Vorlagenmaterial nicht vorhanden
'      kzUSK ist 0, wenn Zeile USK vorhanden und etwas eingetragen (au|fffd|er "nein") !?!?!?!?
'                1, wenn Zeile USK vorhanden, aber nichts oder "nein" eingetragen
'              999, wenn Zeile USK nicht vorhanden
'      kzMO ist  0, wenn Zeile Modulorganisation oder wenigstens Modul-Stufe2 vorhanden und nichts oder "nein" eingetragen
'                1, wenn Zeile Modulorganisation oder wenigstens Modul-Stufe2 vorhanden und etwas eingetragen (au|fffd|er "nein")
'              999, wenn werder Zeile Modulorganisation noch Modul-Stufe2 vorhanden
'      kzBP ist  0, wenn Zeile Bauphase vorhanden, aber nichts oder "nein" eingetragen
'                1, wenn Zeile Bauphase vorhanden und etwas eingetragen (au|fffd|er "nein")
'              999, wenn Zeile Bauphase nicht vorhanden
'      Wenn eines von den dreien kzVM, kzUSK und kzMO 999 ist, hat jedes der anderen drei nur die Werte 999 oder 0.
For Each c In Range(Cells(1, 1), Cells(62000, 1))
    If c.Value = "" Then Exit For
    If c.Value = "Vorlagematerial" Then zeileVM = c.row
    If c.Value = "USK" Then zeileUSK = c.row
    If c.Value = "Modulorganisation" Then zeileMO1 = c.row
    If c.Value = "Modul-Stufe 2" Then zeileMO2 = c.row
    If c.Value = "Bauphase" Then zeileBP = c.row
    Next
    
zeileMO = ""

If zeileMO1 = "" And zeileMO2 = "" Then
Else
    If zeileMO1 = "" Then
        zeileMO = zeileMO2
    Else
        zeileMO = zeileMO1
    End If
End If

kzVM = 0
kzUSK = 0
kzMO = 0
kzBP = 0

' zeileVM = ""
' zeileUSK = ""
' zeileMO = ""
' zeileBP = ""
    
If zeileVM = "" Then kzVM = 999
If zeileUSK = "" Then kzUSK = 999
If zeileMO = "" Then kzMO = 999
If zeileBP = "" Then kzBP = 999

' WICHTIG ! der folgende Block darf NICHT ans Ende rutschen !
' sonst wird er ggf. nicht ausgef|fffd|hrt - wenn einer der anderen >= 900 ist
'   kzBP
For Each c In Range(Cells(zeileBP, 2), Cells(zeileBP, 2))
    If c.Value = "" Or c.Value = "nein" Then
    Else: kzBP = 1
    End If
    Next

If kzVM >= 900 Or _
    kzUSK >= 900 Or _
    kzMO >= 900 Then Exit Sub
    
'   welche Parameter sind gesetzt
'   kzVM
For Each c In Range(Cells(zeileVM, 2), Cells(zeileVM, 2))
    If c.Value > "" Then kzVM = 1
    Next
'   kzUSK
For Each c In Range(Cells(zeileUSK, 2), Cells(zeileUSK, 2))
    If c.Value = "" Or c.Value = "nein" Then kzUSK = 1
    Next
'   kzMO
For Each c In Range(Cells(zeileMO, 2), Cells(zeileMO, 2))
    If c.Value = "" Or c.Value = "nein" Then
    Else: kzMO = 1
    End If
    Next
    
If kzVM = 1 And kzUSK = 1 Then kzVM = 2

End Sub

Sub einfaerbenZelle(Zeile, name, spalteDokForm, colorIndex)

If name = "DokForm" Then
        Cells(Zeile, spalteDokForm).Interior.colorIndex = colorIndex
End If

End Sub



Attribute VB_Name = "ProgressInformation"
Attribute VB_Base = "0{FDC76564-C7C8-4062-A7B5-F3B9C1EEF799}{32303576-836A-488B-BAA5-8E5290C86E29}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit


'------------------------------------------------------------
'Diese Routine wird beim aufruf der Userform aufgerufen
'------------------------------------------------------------
Private Sub UserForm_activate()

        'Rufe die Main-Funktion auf
        Call main
End Sub
Attribute VB_Name = "Spalte"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
    
'Das CSV-File gibt f|fffd|r die Spalten der Reports folgende Informationen, durch ';' getrennt, mit:
'Spalte 1: Zeilenart:  S, R (siehe Informationen einlesen)
'Spalte 2: Nummerierung, fortlaufend, wird nicht benutzt
'Spalte 3: Deltakennzeichen, wird nicht benutzt
'Spalte 4: unbekannt
Public strSAPID As String                                 'ID der Spalte SAP System, technischer Feldname, 5.Spalte
Public strNoDisplay As String                             'anzeigen oder nicht anzeigen, 6.Spalte
Public strGruppe As String                                'Gruppenname, 7. Spalte
Public strFeldname1 As String                             '|fffd|berschrift, 8.Spalte
Public strFeldname2 As String                             '|fffd|berschrift alternativ, 9.Spalte
Public dblBreite As Double                                'Breite der Spalte, 10.Spalte
Public lngZeilenumbruch As Long                           'Zeilenumbruch der Zellen in dieser Spalte, 11.Spalte
Public strSchriftart As String                            'Schriftart der Spalte, 12.Spalte
Public dblSchriftgrad As Double                           'Schriftgr|fffd||fffd|e, 13.Spalte
Public lngFett As Long                                    'fett, 14.Spalte
Public lngKursiv As Long                                  'kursiv, 15.Spalte
Public lngUnterstrichen As Long                           'unterstrichen, 16.Spalte
Public lngVordergrund As Long                             'Vordergrundfarbe, 17.Spalte
Public lngHintergrund As Long                             'Hintergrundfarbe, 18.Spalte
Public strUeberschriftQuer As String                      'x wenn |fffd|berschrift quer, 19. Spalte
Public strFormat As String                                'Format der Spalte (so wie es Excel versteht) wird |fffd|bergeben
Public blnFormatStandard As Boolean                       'Excel Standardformatierung "general" => Wird gesetzt wenn strColumnContent = "STD"
Public lngColumnIndex  As Long                            'Spaltenindex >>>>>Insert - Mirko Quintern - QX43392 - 02.12.2008
Public strHorizontalAlignment As String                   'Horizontale Ausrichting (L / C / R / oder <space> = Standard )>>> Insert - Mirko Quintern - QX43392 - 25.02.2010
Public strColumnContent As String                         'Spalteninhalt (Text, Standard, Hyperlink oder Bild) >>> Insert - Mirko Quintern - QX43392 - 11.11.2010


Public Sub SpaltenEinlesen(sInput As Excel.Worksheet, lngI As Long, ByRef arrVererbungskomm As Variant, lngVererbungskomm As Long)
' regelt das Einlesen der Spalten aus dem txt-File f|fffd|r Nicht-VIP und VIP Spalteninformationen
' BSp 04.04.2006

With sInput
                
        'Technischer Spaltenname
        strSAPID = CStr(.Range("E" + CStr(lngI)).Value)
        strNoDisplay = CStr(.Range("F" + CStr(lngI)).Value)
        If strNoDisplay = "X" Then
            MsgBox "No display spalten d|fffd|rfen |fffd|ber die CSV datei nicht mehr |fffd|bergeben werden", vbCritical
            Stop
            End
        End If
        
        'Feldgruppenzugeh|fffd|rigkeit
        strGruppe = .Range("G" + CStr(lngI)).Value
        '|fffd|berschrift 1
        strFeldname1 = .Range("H" + CStr(lngI)).Value
        '|fffd|berschrift 2
        strFeldname2 = .Range("I" + CStr(lngI)).Value
        'Spaltenbreite
        dblBreite = CDbl(.Range("J" + CStr(lngI)).Value)
        
        'Zeilenumbruch zulassen?
        If UCase(.Range("K" + CStr(lngI)).Value) = "X" Then
            lngZeilenumbruch = 1
        Else
            lngZeilenumbruch = 0
        End If
        
        'Schriftart
        strSchriftart = CStr(.Range("L" + CStr(lngI)).Value)
        'Schriftgr|fffd||fffd|e
        dblSchriftgrad = CDbl(.Range("M" + CStr(lngI)).Value)
        'Fett
        If UCase(.Range("N" + CStr(lngI)).Value) = "X" Then
            lngFett = 1
        Else
            lngFett = 0
        End If
        'Kursiv
        If UCase(.Range("O" + CStr(lngI)).Value) = "X" Then
            lngKursiv = 1
        Else
            lngKursiv = 0
        End If
        'Unterstrichen
        If UCase(.Range("P" + CStr(lngI)).Value) = "X" Then
            lngUnterstrichen = 1
        Else
            lngUnterstrichen = 0
        End If
        'Vordergrundfarbe
        lngVordergrund = .Range("Q" + CStr(lngI)).Value
        'Hintergrundfarbe
        If .Range("R" + CStr(lngI)).Value = "KO" Then
        Else
            lngHintergrund = .Range("R" + CStr(lngI)).Value
        End If
        '|fffd|berschrift um 90|fffd| drehen
        strUeberschriftQuer = .Range("S" + CStr(lngI)).Value
        'Zellen-Nummernformat
        strFormat = .Range("T" + CStr(lngI)).Value
            
        ' >>> Insert - Mirko Quintern - QX43392 - 25.02.2010
        'Horizontale Ausrichting (L / C / R / oder <space> = Standard )
        strHorizontalAlignment = .Range("W" + CStr(lngI)).Value
        ' <<< Insert - Mirko Quintern - QX43392 - 25.02.2010
        
        ' >>> Insert - Mirko Quintern - QX43392 - 11.11.2010
        'Spalteninhalt (Text, Zahl Hyperlink oder Bild)
        strColumnContent = .Range("X" + CStr(lngI)).Value
        ' <<< Insert - Mirko Quintern - QX43392 - 11.11.2010
        
        '>>> Insert - MQ - 04.03.2011 - #15527 - Standardformat bereits hier festlegen
        If strColumnContent = C_COLUMN_CONTENT_STANDARD Then
            blnFormatStandard = True
        ElseIf strColumnContent = C_COLUMN_CONTENT_PICTURE Then
            gv_set_pictures = True
        ElseIf strColumnContent = C_COLUMN_CONTENT_LINK Then
            gv_set_hyperlinks = True
        End If
        '<<< Insert - MQ - 04.03.2011 - #15527 - Standardformat bereits hier festlegen
End With


End Sub


Attribute VB_Name = "Spalten"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit



Dim mSpalten As New Collection
'Private mAttributes As Collection


Public Sub Add(sInput As Excel.Worksheet, lngI As Long, ByRef arrVk As Variant, lngVk As Long)
Dim sp As New Spalte
    sp.SpaltenEinlesen sInput, lngI, arrVk, lngVk
    mSpalten.Add sp, "" & lngI
End Sub
Public Sub AddFMT(lngI As Long)
Dim sp As New Spalte
    mSpalten.Add sp, "" & lngI
End Sub


Public Function Count() As Long
    Count = mSpalten.Count
End Function

Public Function Item(i As Long) As Spalte
    If i < 1 Or i > mSpalten.Count Then
        Set Item = Nothing
    Else
        Set Item = mSpalten(i)
    End If
End Function






Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'-----------------------------------------------------------------------
' Eingef|fffd|gt durch FREIGABE-Formatierung
' Durch das Erstellen der Makros wird die interaktive Legende funktional
'-----------------------------------------------------------------------
Private Sub Worksheet_Change(ByVal Target As Excel.Range)
 
   Dim letzte_spalte As Double
   Dim rng As Range
 
'  Spalte zur |fffd|nderungsmarkierung ermitteln
   letzte_spalte = ActiveCell.SpecialCells(xlLastCell).Column
   Set rng = ActiveSheet.Range(Cells(1, 1), Cells(1, letzte_spalte)).Find("DUMMY_AEND", lookat:=xlWhole)
   If rng Is Nothing Then
       Exit Sub
   End If
   If Cells(Target.row, Target.Column) = Cells(Target.row, rng.Column) Then
       Exit Sub
   Else
       Target.Font.colorIndex = 3
       If Cells(Target.row, rng.Column) = "" Then
          Cells(Target.row, rng.Column) = GetTextelementByID("T", "Position_geaendert")
      End If
  End If
 
End Sub

Attribute VB_Name = "Y_ENTWICKLERMODUS"
Option Explicit
'---------------------------------------------------------------------------------
' Stelle fest ob Aktiv entwickelt wird
'---------------------------------------------------------------------------------
Public Function CheckAktivEntwickeln() As Boolean

Dim lngReturn As Long
Dim lv_AktivEntwickeln As Boolean
    
  lv_AktivEntwickeln = False        'Komplette Funktionalit|fffd|t
  'lv_AktivEntwickeln = True         'Abgespeckte Funktionalit|fffd|t
  
  Dim EnvString
  EnvString = Environ("username")
  
  'If Environ("username") = "Q331898" Or Environ("username") = "q331898" Or Environ("username") = "d058580" Then
  '  lv_AktivEntwickeln = True
  'End If
  
  If lv_AktivEntwickeln Then
      lngReturn = MsgBox("ACHTUNG: Aktuell ist der Entwicklermodus aktiviert." & _
                          vbCrLf & "Soll ein Testlauf im Entwicklermodus durchgef|fffd|hrt werden? <Ja>" & _
                          vbCrLf & " - Bei <Nein> wird das Makro im Echtmodus ausgef|fffd|hrt" & _
                          vbCrLf & " - Bei <Abbrechen> wird das Makro NICHT ausgef|fffd|hrt", _
                          vbYesNoCancel, "Wird aktiv Entwickelt?")
      Select Case lngReturn
      Case vbCancel
          'Userform mit Fortschrittsanzeige deaktivieren
          Unload ProgressInformation
          'Makro komplett beenden
          End
      Case vbYes
          lv_AktivEntwickeln = True
      Case vbNo
          lv_AktivEntwickeln = False
      End Select
  End If
  
  'Aktionen NUR durchf|fffd|hren, wenn nicht entwickelt wird
  If lv_AktivEntwickeln = False Then
      'Sanduhr einstellen
      Application.Cursor = xlWait
      'f|fffd|r bestm|fffd|gliche Performance wird Screenupdating abgeschaltet
      Application.ScreenUpdating = False
  Else
    ' und stelle Eventing und Updating wieder her
    Application.ScreenUpdating = True
    ' Excel bekommt die Kontrolle |fffd|ber die Statusbar zur|fffd|ck
    Application.StatusBar = False
    'Sanduhr ausstellen
    Application.Cursor = xlDefault
    'Userform mit Fortschrittsanzeige deaktivieren
    Unload ProgressInformation
  End If
  
  CheckAktivEntwickeln = lv_AktivEntwickeln

End Function

' InQuest injected base64 decoded content
' mzsh
' mzsh
' )^J)

INQUEST-PP=macro
