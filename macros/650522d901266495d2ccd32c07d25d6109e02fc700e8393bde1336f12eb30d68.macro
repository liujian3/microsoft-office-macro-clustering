Attribute VB_Name = "JsonConverter"
''
' VBA-JSON v2.2.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-JSON
'
' JSON Converter for VBA
'
' Errors:
' 10001 - JSON parse error
'
' @class JsonConverter
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
'
' Based originally on vba-json (with extensive changes)
' BSD license included below
'
' JSONLib, http://code.google.com/p/vba-json/
'
' Copyright (c) 2013, Ryo Yokoyama
' All rights reserved.
'
' Redistribution and use in source and binary forms, with or without
' modification, are permitted provided that the following conditions are met:
'     * Redistributions of source code must retain the above copyright
'       notice, this list of conditions and the following disclaimer.
'     * Redistributions in binary form must reproduce the above copyright
'       notice, this list of conditions and the following disclaimer in the
'       documentation and/or other materials provided with the distribution.
'     * Neither the name of the <organization> nor the
'       names of its contributors may be used to endorse or promote products
'       derived from this software without specific prior written permission.
'
' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
' DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
' DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
' (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
' LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
' ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
' SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' === VBA-UTC Headers
#If Mac Then

#If VBA7 Then

' 64-bit Mac (2016)
Private Declare PtrSafe Function utc_popen Lib "libc.dylib" Alias "popen" _
    (ByVal utc_Command As String, ByVal utc_Mode As String) As LongPtr
Private Declare PtrSafe Function utc_pclose Lib "libc.dylib" Alias "pclose" _
    (ByVal utc_File As Long) As LongPtr
Private Declare PtrSafe Function utc_fread Lib "libc.dylib" Alias "fread" _
    (ByVal utc_Buffer As String, ByVal utc_Size As LongPtr, ByVal utc_Number As LongPtr, ByVal utc_File As LongPtr) As LongPtr
Private Declare PtrSafe Function utc_feof Lib "libc.dylib" Alias "feof" _
    (ByVal utc_File As LongPtr) As LongPtr

#Else

' 32-bit Mac
Private Declare Function utc_popen Lib "libc.dylib" Alias "popen" _
    (ByVal utc_Command As String, ByVal utc_Mode As String) As Long
Private Declare Function utc_pclose Lib "libc.dylib" Alias "pclose" _
    (ByVal utc_File As Long) As Long
Private Declare Function utc_fread Lib "libc.dylib" Alias "fread" _
    (ByVal utc_Buffer As String, ByVal utc_Size As Long, ByVal utc_Number As Long, ByVal utc_File As Long) As Long
Private Declare Function utc_feof Lib "libc.dylib" Alias "feof" _
    (ByVal utc_File As Long) As Long

#End If

#ElseIf VBA7 Then

' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724421.aspx
' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724949.aspx
' http://msdn.microsoft.com/en-us/library/windows/desktop/ms725485.aspx
Private Declare PtrSafe Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
Private Declare PtrSafe Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
Private Declare PtrSafe Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long

#Else

Private Declare Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
Private Declare Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
Private Declare Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long

#End If

#If Mac Then

#If VBA7 Then
Private Type utc_ShellResult
    utc_Output As String
    utc_ExitCode As LongPtr
End Type

#Else

Private Type utc_ShellResult
    utc_Output As String
    utc_ExitCode As Long
End Type

#End If

#Else

Private Type utc_SYSTEMTIME
    utc_wYear As Integer
    utc_wMonth As Integer
    utc_wDayOfWeek As Integer
    utc_wDay As Integer
    utc_wHour As Integer
    utc_wMinute As Integer
    utc_wSecond As Integer
    utc_wMilliseconds As Integer
End Type

Private Type utc_TIME_ZONE_INFORMATION
    utc_Bias As Long
    utc_StandardName(0 To 31) As Integer
    utc_StandardDate As utc_SYSTEMTIME
    utc_StandardBias As Long
    utc_DaylightName(0 To 31) As Integer
    utc_DaylightDate As utc_SYSTEMTIME
    utc_DaylightBias As Long
End Type

#End If
' === End VBA-UTC


Private Type json_Options
    ' VBA only stores 15 significant digits, so any numbers larger than that are truncated
    ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
    ' See: http://support.microsoft.com/kb/269370
    '
    ' By default, VBA-JSON will use String for numbers longer than 15 characters that contain only digits
    ' to override set `JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True`
    UseDoubleForLargeNumbers As Boolean

    ' The JSON standard requires object keys to be quoted (" or '), use this option to allow unquoted keys
    AllowUnquotedKeys As Boolean

    ' The solidus (/) is not required to be escaped, use this option to escape them as \/ in ConvertToJson
    EscapeSolidus As Boolean
End Type
Public JsonOptions As json_Options

' ============================================= '
' Public Methods
' ============================================= '

''
' Convert JSON string to object (Dictionary/Collection)
'
' @method ParseJson
' @param {String} json_String
' @return {Object} (Dictionary or Collection)
' @throws 10001 - JSON parse error
''
Public Function ParseJson(ByVal JsonString As String) As Object
    Dim json_Index As Long
    json_Index = 1

    ' Remove vbCr, vbLf, and vbTab from json_String
    JsonString = VBA.Replace(VBA.Replace(VBA.Replace(JsonString, VBA.vbCr, ""), VBA.vbLf, ""), VBA.vbTab, "")

    json_SkipSpaces JsonString, json_Index
    Select Case VBA.Mid$(JsonString, json_Index, 1)
    Case "{"
        Set ParseJson = json_ParseObject(JsonString, json_Index)
    Case "["
        Set ParseJson = json_ParseArray(JsonString, json_Index)
    Case Else
        ' Error: Invalid JSON string
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(JsonString, json_Index, "Expecting '{' or '['")
    End Select
End Function

''
' Convert object (Dictionary/Collection/Array) to JSON
'
' @method ConvertToJson
' @param {Variant} JsonValue (Dictionary, Collection, or Array)
' @param {Integer|String} Whitespace "Pretty" print json with given number of spaces per indentation (Integer) or given string
' @return {String}
''
Public Function ConvertToJson(ByVal JsonValue As Variant, Optional ByVal Whitespace As Variant, Optional ByVal json_CurrentIndentation As Long = 0) As String
    Dim cSA As New clsStringAppend
    Dim json_Index As Long
    Dim json_LBound As Long
    Dim json_UBound As Long
    Dim json_IsFirstItem As Boolean
    Dim json_Index2D As Long
    Dim json_LBound2D As Long
    Dim json_UBound2D As Long
    Dim json_IsFirstItem2D As Boolean
    Dim json_Key As Variant
    Dim json_Value As Variant
    Dim json_DateStr As String
    Dim json_Converted As String
    Dim json_SkipItem As Boolean
    Dim json_PrettyPrint As Boolean
    Dim json_Indentation As String
    Dim json_InnerIndentation As String

    json_LBound = -1
    json_UBound = -1
    json_IsFirstItem = True
    json_LBound2D = -1
    json_UBound2D = -1
    json_IsFirstItem2D = True
    json_PrettyPrint = Not IsMissing(Whitespace)

    Select Case VBA.VarType(JsonValue)
    Case VBA.vbNull
        ConvertToJson = "null"
    Case VBA.vbDate
        ' Date
        json_DateStr = ConvertToIso(VBA.CDate(JsonValue))

        ConvertToJson = """" & json_DateStr & """"
    Case VBA.vbString
        ' String (or large number encoded as string)
        If Not JsonOptions.UseDoubleForLargeNumbers And json_StringIsLargeNumber(JsonValue) Then
            ConvertToJson = JsonValue
        Else
            ConvertToJson = """" & json_Encode(JsonValue) & """"
        End If
    Case VBA.vbBoolean
        If JsonValue Then
            ConvertToJson = "true"
        Else
            ConvertToJson = "false"
        End If
    Case VBA.vbArray To VBA.vbArray + VBA.vbByte
        If json_PrettyPrint Then
            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
                json_InnerIndentation = VBA.String$(json_CurrentIndentation + 2, Whitespace)
            Else
                json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
                json_InnerIndentation = VBA.Space$((json_CurrentIndentation + 2) * Whitespace)
            End If
        End If

        ' Array
        cSA.Append "["

        On Error Resume Next

        json_LBound = LBound(JsonValue, 1)
        json_UBound = UBound(JsonValue, 1)
        json_LBound2D = LBound(JsonValue, 2)
        json_UBound2D = UBound(JsonValue, 2)

        If json_LBound >= 0 And json_UBound >= 0 Then
            For json_Index = json_LBound To json_UBound
                If json_IsFirstItem Then
                    json_IsFirstItem = False
                Else
                    ' Append comma to previous line
                    cSA.Append ","
                End If

                If json_LBound2D >= 0 And json_UBound2D >= 0 Then
                    ' 2D Array
                    If json_PrettyPrint Then
                        cSA.Append vbNewLine
                    End If
                    cSA.Append json_Indentation & "["

                    For json_Index2D = json_LBound2D To json_UBound2D
                        If json_IsFirstItem2D Then
                            json_IsFirstItem2D = False
                        Else
                            cSA.Append ","
                        End If

                        json_Converted = ConvertToJson(JsonValue(json_Index, json_Index2D), Whitespace, json_CurrentIndentation + 2)

                        ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                        If json_Converted = "" Then
                            ' (nest to only check if converted = "")
                            If json_IsUndefined(JsonValue(json_Index, json_Index2D)) Then
                                json_Converted = "null"
                            End If
                        End If

                        If json_PrettyPrint Then
                            json_Converted = vbNewLine & json_InnerIndentation & json_Converted
                        End If

                        cSA.Append json_Converted
                    Next json_Index2D

                    If json_PrettyPrint Then
                        cSA.Append vbNewLine
                    End If

                    cSA.Append json_Indentation & "]"
                    json_IsFirstItem2D = True
                Else
                    ' 1D Array
                    json_Converted = ConvertToJson(JsonValue(json_Index), Whitespace, json_CurrentIndentation + 1)

                    ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                    If json_Converted = "" Then
                        ' (nest to only check if converted = "")
                        If json_IsUndefined(JsonValue(json_Index)) Then
                            json_Converted = "null"
                        End If
                    End If

                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & json_Converted
                    End If

                    cSA.Append json_Converted
                End If
            Next json_Index
        End If

        On Error GoTo 0

        If json_PrettyPrint Then
            cSA.Append vbNewLine

            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
            Else
                json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
            End If
        End If

        cSA.Append json_Indentation & "]"

        ConvertToJson = cSA.Report

    ' Dictionary or Collection
    Case VBA.vbObject
        If json_PrettyPrint Then
            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
            Else
                json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
            End If
        End If

        ' Dictionary
        If VBA.TypeName(JsonValue) = "Dictionary" Then
            cSA.Append "{"
            For Each json_Key In JsonValue.Keys
                ' For Objects, undefined (Empty/Nothing) is not added to object
                json_Converted = ConvertToJson(JsonValue(json_Key), Whitespace, json_CurrentIndentation + 1)
                If json_Converted = "" Then
                    json_SkipItem = json_IsUndefined(JsonValue(json_Key))
                Else
                    json_SkipItem = False
                End If

                If Not json_SkipItem Then
                    If json_IsFirstItem Then
                        json_IsFirstItem = False
                    Else
                        cSA.Append ","
                    End If

                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & """" & json_Key & """: " & json_Converted
                    Else
                        json_Converted = """" & json_Key & """:" & json_Converted
                    End If

                    cSA.Append json_Converted
                End If
            Next json_Key

            If json_PrettyPrint Then
                cSA.Append vbNewLine

                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If

            cSA.Append json_Indentation & "}"

        ' Collection
        ElseIf VBA.TypeName(JsonValue) = "Collection" Then
            cSA.Append "["
            For Each json_Value In JsonValue
                If json_IsFirstItem Then
                    json_IsFirstItem = False
                Else
                    cSA.Append ","
                End If

                json_Converted = ConvertToJson(json_Value, Whitespace, json_CurrentIndentation + 1)

                ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                If json_Converted = "" Then
                    ' (nest to only check if converted = "")
                    If json_IsUndefined(json_Value) Then
                        json_Converted = "null"
                    End If
                End If

                If json_PrettyPrint Then
                    json_Converted = vbNewLine & json_Indentation & json_Converted
                End If

                cSA.Append json_Converted
            Next json_Value

            If json_PrettyPrint Then
                cSA.Append vbNewLine

                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If

            cSA.Append json_Indentation & "]"
        End If

        ConvertToJson = cSA.Report
    Case VBA.vbInteger, VBA.vbLong, VBA.vbSingle, VBA.vbDouble, VBA.vbCurrency, VBA.vbDecimal
        ' Number (use decimals for numbers)
        ConvertToJson = VBA.Replace(JsonValue, ",", ".")
    Case Else
        ' vbEmpty, vbError, vbDataObject, vbByte, vbUserDefinedType
        ' Use VBA's built-in to-string
        On Error Resume Next
        ConvertToJson = JsonValue
        On Error GoTo 0
    End Select
End Function

' ============================================= '
' Private Functions
' ============================================= '

Private Function json_ParseObject(json_String As String, ByRef json_Index As Long) As Dictionary
    Dim json_Key As String
    Dim json_NextChar As String

    Set json_ParseObject = New Dictionary
    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> "{" Then
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '{'")
    Else
        json_Index = json_Index + 1

        Do
            json_SkipSpaces json_String, json_Index
            If VBA.Mid$(json_String, json_Index, 1) = "}" Then
                json_Index = json_Index + 1
                Exit Function
            ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                json_Index = json_Index + 1
                json_SkipSpaces json_String, json_Index
            End If

            json_Key = json_ParseKey(json_String, json_Index)
            json_NextChar = json_Peek(json_String, json_Index)
            If json_NextChar = "[" Or json_NextChar = "{" Then
                Set json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
            Else
                json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
            End If
        Loop
    End If
End Function

Private Function json_ParseArray(json_String As String, ByRef json_Index As Long) As Collection
    Set json_ParseArray = New Collection

    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> "[" Then
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '['")
    Else
        json_Index = json_Index + 1

        Do
            json_SkipSpaces json_String, json_Index
            If VBA.Mid$(json_String, json_Index, 1) = "]" Then
                json_Index = json_Index + 1
                Exit Function
            ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                json_Index = json_Index + 1
                json_SkipSpaces json_String, json_Index
            End If

            json_ParseArray.Add json_ParseValue(json_String, json_Index)
        Loop
    End If
End Function

Private Function json_ParseValue(json_String As String, ByRef json_Index As Long) As Variant
    json_SkipSpaces json_String, json_Index
    Select Case VBA.Mid$(json_String, json_Index, 1)
    Case "{"
        Set json_ParseValue = json_ParseObject(json_String, json_Index)
    Case "["
        Set json_ParseValue = json_ParseArray(json_String, json_Index)
    Case """", "'"
        json_ParseValue = json_ParseString(json_String, json_Index)
    Case Else
        If VBA.Mid$(json_String, json_Index, 4) = "true" Then
            json_ParseValue = True
            json_Index = json_Index + 4
        ElseIf VBA.Mid$(json_String, json_Index, 5) = "false" Then
            json_ParseValue = False
            json_Index = json_Index + 5
        ElseIf VBA.Mid$(json_String, json_Index, 4) = "null" Then
            json_ParseValue = Null
            json_Index = json_Index + 4
        ElseIf VBA.InStr("+-0123456789", VBA.Mid$(json_String, json_Index, 1)) Then
            json_ParseValue = json_ParseNumber(json_String, json_Index)
        Else
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['")
        End If
    End Select
End Function

Private Function json_ParseString(json_String As String, ByRef json_Index As Long) As String
    Dim json_Quote As String
    Dim json_Char As String
    Dim json_Code As String
    Dim cSA As New clsStringAppend

    json_SkipSpaces json_String, json_Index

    ' Store opening quote to look for matching closing quote
    json_Quote = VBA.Mid$(json_String, json_Index, 1)
    json_Index = json_Index + 1

    Do While json_Index > 0 And json_Index <= Len(json_String)
        json_Char = VBA.Mid$(json_String, json_Index, 1)

        Select Case json_Char
        Case "\"
            ' Escaped string, \\, or \/
            json_Index = json_Index + 1
            json_Char = VBA.Mid$(json_String, json_Index, 1)

            Select Case json_Char
            Case """", "\", "/", "'"
                cSA.Append json_Char
                json_Index = json_Index + 1
            Case "b"
                cSA.Append vbBack
                json_Index = json_Index + 1
            Case "f"
                cSA.Append vbFormFeed
                json_Index = json_Index + 1
            Case "n"
                cSA.Append vbCrLf
                json_Index = json_Index + 1
            Case "r"
                cSA.Append vbCr
                json_Index = json_Index + 1
            Case "t"
                cSA.Append vbTab
                json_Index = json_Index + 1
            Case "u"
                ' Unicode character escape (e.g. \u00a9 = Copyright)
                json_Index = json_Index + 1
                json_Code = VBA.Mid$(json_String, json_Index, 4)
                cSA.Append VBA.ChrW(VBA.Val("&h" + json_Code))
                json_Index = json_Index + 4
            End Select
        Case json_Quote
            json_ParseString = cSA.Report
            json_Index = json_Index + 1
            Exit Function
        Case Else
            cSA.Append json_Char
            json_Index = json_Index + 1
        End Select
    Loop
End Function

Private Function json_ParseNumber(json_String As String, ByRef json_Index As Long) As Variant
    Dim json_Char As String
    Dim json_Value As String
    Dim json_IsLargeNumber As Boolean

    json_SkipSpaces json_String, json_Index

    Do While json_Index > 0 And json_Index <= Len(json_String)
        json_Char = VBA.Mid$(json_String, json_Index, 1)

        If VBA.InStr("+-0123456789.eE", json_Char) Then
            ' Unlikely to have massive number, so use simple append rather than buffer here
            json_Value = json_Value & json_Char
            json_Index = json_Index + 1
        Else
            ' Excel only stores 15 significant digits, so any numbers larger than that are truncated
            ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
            ' See: http://support.microsoft.com/kb/269370
            '
            ' Fix: Parse -> String, Convert -> String longer than 15/16 characters containing only numbers and decimal points -> Number
            ' (decimal doesn't factor into significant digit count, so if present check for 15 digits + decimal = 16)
            json_IsLargeNumber = IIf(InStr(json_Value, "."), Len(json_Value) >= 17, Len(json_Value) >= 16)
            If Not JsonOptions.UseDoubleForLargeNumbers And json_IsLargeNumber Then
                json_ParseNumber = json_Value
            Else
                ' VBA.Val does not use regional settings, so guard for comma is not needed
                json_ParseNumber = VBA.Val(json_Value)
            End If
            Exit Function
        End If
    Loop
End Function

Private Function json_ParseKey(json_String As String, ByRef json_Index As Long) As String
    ' Parse key with single or double quotes
    If VBA.Mid$(json_String, json_Index, 1) = """" Or VBA.Mid$(json_String, json_Index, 1) = "'" Then
        json_ParseKey = json_ParseString(json_String, json_Index)
    ElseIf JsonOptions.AllowUnquotedKeys Then
        Dim json_Char As String
        Do While json_Index > 0 And json_Index <= Len(json_String)
            json_Char = VBA.Mid$(json_String, json_Index, 1)
            If (json_Char <> " ") And (json_Char <> ":") Then
                json_ParseKey = json_ParseKey & json_Char
                json_Index = json_Index + 1
            Else
                Exit Do
            End If
        Loop
    Else
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '""' or '''")
    End If

    ' Check for colon and skip if present or throw if not present
    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> ":" Then
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting ':'")
    Else
        json_Index = json_Index + 1
    End If
End Function

Private Function json_IsUndefined(ByVal json_Value As Variant) As Boolean
    ' Empty / Nothing -> undefined
    Select Case VBA.VarType(json_Value)
    Case VBA.vbEmpty
        json_IsUndefined = True
    Case VBA.vbObject
        Select Case VBA.TypeName(json_Value)
        Case "Empty", "Nothing"
            json_IsUndefined = True
        End Select
    End Select
End Function

Private Function json_Encode(ByVal json_Text As Variant) As String
    ' Reference: http://www.ietf.org/rfc/rfc4627.txt
    ' Escape: ", \, /, backspace, form feed, line feed, carriage return, tab
    Dim json_Index As Long
    Dim json_Char As String
    Dim json_AscCode As Long
    Dim cSA As New clsStringAppend

    For json_Index = 1 To VBA.Len(json_Text)
        json_Char = VBA.Mid$(json_Text, json_Index, 1)
        json_AscCode = VBA.AscW(json_Char)

        ' When AscW returns a negative number, it returns the twos complement form of that number.
        ' To convert the twos complement notation into normal binary notation, add 0xFFF to the return result.
        ' https://support.microsoft.com/en-us/kb/272138
        If json_AscCode < 0 Then
            json_AscCode = json_AscCode + 65536
        End If

        ' From spec, ", \, and control characters must be escaped (solidus is optional)

        Select Case json_AscCode
        Case 34
            ' " -> 34 -> \"
            json_Char = "\"""
        Case 92
            ' \ -> 92 -> \\
            json_Char = "\\"
        Case 47
            ' / -> 47 -> \/ (optional)
            If JsonOptions.EscapeSolidus Then
                json_Char = "\/"
            End If
        Case 8
            ' backspace -> 8 -> \b
            json_Char = "\b"
        Case 12
            ' form feed -> 12 -> \f
            json_Char = "\f"
        Case 10
            ' line feed -> 10 -> \n
            json_Char = "\n"
        Case 13
            ' carriage return -> 13 -> \r
            json_Char = "\r"
        Case 9
            ' tab -> 9 -> \t
            json_Char = "\t"
        Case 0 To 31, 127 To 65535
            ' Non-ascii characters -> convert to 4-digit hex
            json_Char = "\u" & VBA.Right$("0000" & VBA.Hex$(json_AscCode), 4)
        End Select

        cSA.Append json_Char
    Next json_Index

    json_Encode = cSA.Report
End Function

Private Function json_Peek(json_String As String, ByVal json_Index As Long, Optional json_NumberOfCharacters As Long = 1) As String
    ' "Peek" at the next number of characters without incrementing json_Index (ByVal instead of ByRef)
    json_SkipSpaces json_String, json_Index
    json_Peek = VBA.Mid$(json_String, json_Index, json_NumberOfCharacters)
End Function

Private Sub json_SkipSpaces(json_String As String, ByRef json_Index As Long)
    ' Increment index to skip over spaces
    Do While json_Index > 0 And json_Index <= VBA.Len(json_String) And VBA.Mid$(json_String, json_Index, 1) = " "
        json_Index = json_Index + 1
    Loop
End Sub

Private Function json_StringIsLargeNumber(json_String As Variant) As Boolean
    ' Check if the given string is considered a "large number"
    ' (See json_ParseNumber)

    Dim json_Length As Long
    Dim json_CharIndex As Long
    json_Length = VBA.Len(json_String)

    ' Length with be at least 16 characters and assume will be less than 100 characters
    If json_Length >= 16 And json_Length <= 100 Then
        Dim json_CharCode As String
        Dim json_Index As Long

        json_StringIsLargeNumber = True

        For json_CharIndex = 1 To json_Length
            json_CharCode = VBA.Asc(VBA.Mid$(json_String, json_CharIndex, 1))
            Select Case json_CharCode
            ' Look for .|0-9|E|e
            Case 46, 48 To 57, 69, 101
                ' Continue through characters
            Case Else
                json_StringIsLargeNumber = False
                Exit Function
            End Select
        Next json_CharIndex
    End If
End Function

Private Function json_ParseErrorMessage(json_String As String, ByRef json_Index As Long, ErrorMessage As String)
    ' Provide detailed parse error message, including details of where and what occurred
    '
    ' Example:
    ' Error parsing JSON:
    ' {"abcde":True}
    '          ^
    ' Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['

    Dim json_StartIndex As Long
    Dim json_StopIndex As Long

    ' Include 10 characters before and after error (if possible)
    json_StartIndex = json_Index - 10
    json_StopIndex = json_Index + 10
    If json_StartIndex <= 0 Then
        json_StartIndex = 1
    End If
    If json_StopIndex > VBA.Len(json_String) Then
        json_StopIndex = VBA.Len(json_String)
    End If

    json_ParseErrorMessage = "Error parsing JSON:" & VBA.vbNewLine & _
                             VBA.Mid$(json_String, json_StartIndex, json_StopIndex - json_StartIndex + 1) & VBA.vbNewLine & _
                             VBA.Space$(json_Index - json_StartIndex) & "^" & VBA.vbNewLine & _
                             ErrorMessage
End Function



''
' VBA-UTC v1.0.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-UtcConverter
'
' UTC/ISO 8601 Converter for VBA
'
' Errors:
' 10011 - UTC parsing error
' 10012 - UTC conversion error
' 10013 - ISO 8601 parsing error
' 10014 - ISO 8601 conversion error
'
' @module UtcConverter
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '

' (Declarations moved to top)

' ============================================= '
' Public Methods
' ============================================= '

''
' Parse UTC date to local date
'
' @method ParseUtc
' @param {Date} UtcDate
' @return {Date} Local date
' @throws 10011 - UTC parsing error
''
Public Function ParseUtc(utc_UtcDate As Date) As Date
    On Error GoTo utc_ErrorHandling

#If Mac Then
    ParseUtc = utc_ConvertDate(utc_UtcDate)
#Else
    Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
    Dim utc_LocalDate As utc_SYSTEMTIME

    utc_GetTimeZoneInformation utc_TimeZoneInfo
    utc_SystemTimeToTzSpecificLocalTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_UtcDate), utc_LocalDate

    ParseUtc = utc_SystemTimeToDate(utc_LocalDate)
#End If

    Exit Function

utc_ErrorHandling:
    Err.Raise 10011, "UtcConverter.ParseUtc", "UTC parsing error: " & Err.Number & " - " & Err.Description
End Function

''
' Convert local date to UTC date
'
' @method ConvertToUrc
' @param {Date} utc_LocalDate
' @return {Date} UTC date
' @throws 10012 - UTC conversion error
''
Public Function ConvertToUtc(utc_LocalDate As Date) As Date
    On Error GoTo utc_ErrorHandling

#If Mac Then
    ConvertToUtc = utc_ConvertDate(utc_LocalDate, utc_ConvertToUtc:=True)
#Else
    Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
    Dim utc_UtcDate As utc_SYSTEMTIME

    utc_GetTimeZoneInformation utc_TimeZoneInfo
    utc_TzSpecificLocalTimeToSystemTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_LocalDate), utc_UtcDate

    ConvertToUtc = utc_SystemTimeToDate(utc_UtcDate)
#End If

    Exit Function

utc_ErrorHandling:
    Err.Raise 10012, "UtcConverter.ConvertToUtc", "UTC conversion error: " & Err.Number & " - " & Err.Description
End Function

''
' Parse ISO 8601 date string to local date
'
' @method ParseIso
' @param {Date} utc_IsoString
' @return {Date} Local date
' @throws 10013 - ISO 8601 parsing error
''
Public Function ParseIso(utc_IsoString As String) As Date
    On Error GoTo utc_ErrorHandling

    Dim utc_Parts() As String
    Dim utc_DateParts() As String
    Dim utc_TimeParts() As String
    Dim utc_OffsetIndex As Long
    Dim utc_HasOffset As Boolean
    Dim utc_NegativeOffset As Boolean
    Dim utc_OffsetParts() As String
    Dim utc_Offset As Date

    utc_Parts = VBA.Split(utc_IsoString, "T")
    utc_DateParts = VBA.Split(utc_Parts(0), "-")
    ParseIso = VBA.DateSerial(VBA.CInt(utc_DateParts(0)), VBA.CInt(utc_DateParts(1)), VBA.CInt(utc_DateParts(2)))

    If UBound(utc_Parts) > 0 Then
        If VBA.InStr(utc_Parts(1), "Z") Then
            utc_TimeParts = VBA.Split(VBA.Replace(utc_Parts(1), "Z", ""), ":")
        Else
            utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "+")
            If utc_OffsetIndex = 0 Then
                utc_NegativeOffset = True
                utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "-")
            End If

            If utc_OffsetIndex > 0 Then
                utc_HasOffset = True
                utc_TimeParts = VBA.Split(VBA.Left$(utc_Parts(1), utc_OffsetIndex - 1), ":")
                utc_OffsetParts = VBA.Split(VBA.Right$(utc_Parts(1), Len(utc_Parts(1)) - utc_OffsetIndex), ":")

                Select Case UBound(utc_OffsetParts)
                Case 0
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), 0, 0)
                Case 1
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), 0)
                Case 2
                    ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), Int(VBA.Val(utc_OffsetParts(2))))
                End Select

                If utc_NegativeOffset Then: utc_Offset = -utc_Offset
            Else
                utc_TimeParts = VBA.Split(utc_Parts(1), ":")
            End If
        End If

        Select Case UBound(utc_TimeParts)
        Case 0
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), 0, 0)
        Case 1
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), 0)
        Case 2
            ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), Int(VBA.Val(utc_TimeParts(2))))
        End Select

        ParseIso = ParseUtc(ParseIso)

        If utc_HasOffset Then
            ParseIso = ParseIso + utc_Offset
        End If
    End If

    Exit Function

utc_ErrorHandling:
    Err.Raise 10013, "UtcConverter.ParseIso", "ISO 8601 parsing error for " & utc_IsoString & ": " & Err.Number & " - " & Err.Description
End Function

''
' Convert local date to ISO 8601 string
'
' @method ConvertToIso
' @param {Date} utc_LocalDate
' @return {Date} ISO 8601 string
' @throws 10014 - ISO 8601 conversion error
''
Public Function ConvertToIso(utc_LocalDate As Date) As String
    On Error GoTo utc_ErrorHandling

    ConvertToIso = VBA.Format$(ConvertToUtc(utc_LocalDate), "yyyy-mm-ddTHH:mm:ss.000Z")

    Exit Function

utc_ErrorHandling:
    Err.Raise 10014, "UtcConverter.ConvertToIso", "ISO 8601 conversion error: " & Err.Number & " - " & Err.Description
End Function

' ============================================= '
' Private Functions
' ============================================= '

#If Mac Then

Private Function utc_ConvertDate(utc_Value As Date, Optional utc_ConvertToUtc As Boolean = False) As Date
    Dim utc_ShellCommand As String
    Dim utc_Result As utc_ShellResult
    Dim utc_Parts() As String
    Dim utc_DateParts() As String
    Dim utc_TimeParts() As String

    If utc_ConvertToUtc Then
        utc_ShellCommand = "date -ur `date -jf '%Y-%m-%d %H:%M:%S' " & _
            "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & "' " & _
            " +'%s'` +'%Y-%m-%d %H:%M:%S'"
    Else
        utc_ShellCommand = "date -jf '%Y-%m-%d %H:%M:%S %z' " & _
            "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & " +0000' " & _
            "+'%Y-%m-%d %H:%M:%S'"
    End If

    utc_Result = utc_ExecuteInShell(utc_ShellCommand)

    If utc_Result.utc_Output = "" Then
        Err.Raise 10015, "UtcConverter.utc_ConvertDate", "'date' command failed"
    Else
        utc_Parts = Split(utc_Result.utc_Output, " ")
        utc_DateParts = Split(utc_Parts(0), "-")
        utc_TimeParts = Split(utc_Parts(1), ":")

        utc_ConvertDate = DateSerial(utc_DateParts(0), utc_DateParts(1), utc_DateParts(2)) + _
            TimeSerial(utc_TimeParts(0), utc_TimeParts(1), utc_TimeParts(2))
    End If
End Function

Private Function utc_ExecuteInShell(utc_ShellCommand As String) As utc_ShellResult
#If VBA7 Then
    Dim utc_File As LongPtr
    Dim utc_Read As LongPtr
#Else
    Dim utc_File As Long
    Dim utc_Read As Long
#End If

    Dim utc_Chunk As String

    On Error GoTo utc_ErrorHandling
    utc_File = utc_popen(utc_ShellCommand, "r")

    If utc_File = 0 Then: Exit Function

    Do While utc_feof(utc_File) = 0
        utc_Chunk = VBA.Space$(50)
        utc_Read = utc_fread(utc_Chunk, 1, Len(utc_Chunk) - 1, utc_File)
        If utc_Read > 0 Then
            utc_Chunk = VBA.Left$(utc_Chunk, utc_Read)
            utc_ExecuteInShell.utc_Output = utc_ExecuteInShell.utc_Output & utc_Chunk
        End If
    Loop

utc_ErrorHandling:
    utc_ExecuteInShell.utc_ExitCode = utc_pclose(utc_File)
End Function

#Else

Private Function utc_DateToSystemTime(utc_Value As Date) As utc_SYSTEMTIME
    utc_DateToSystemTime.utc_wYear = VBA.Year(utc_Value)
    utc_DateToSystemTime.utc_wMonth = VBA.Month(utc_Value)
    utc_DateToSystemTime.utc_wDay = VBA.Day(utc_Value)
    utc_DateToSystemTime.utc_wHour = VBA.Hour(utc_Value)
    utc_DateToSystemTime.utc_wMinute = VBA.Minute(utc_Value)
    utc_DateToSystemTime.utc_wSecond = VBA.Second(utc_Value)
    utc_DateToSystemTime.utc_wMilliseconds = 0
End Function

Private Function utc_SystemTimeToDate(utc_Value As utc_SYSTEMTIME) As Date
    utc_SystemTimeToDate = DateSerial(utc_Value.utc_wYear, utc_Value.utc_wMonth, utc_Value.utc_wDay) + _
        TimeSerial(utc_Value.utc_wHour, utc_Value.utc_wMinute, utc_Value.utc_wSecond)
End Function

#End If






Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_Open()
    InitAddinVariables
End Sub
Attribute VB_Name = "clsDataValue"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private pregionnr As String
Private pregionname As String
Private pfreq As String
Private pperiod As String
Private ptopic As String
Private pvariable As String
Private pvalue As String
Private psortvalue As String

Public Property Get sortvalue() As String
    sortvalue = psortvalue
End Property

Public Property Let sortvalue(ByVal sNewValue As String)
    psortvalue = sNewValue
End Property

Public Property Get regionnr() As String
    regionnr = pregionnr
End Property

Public Property Get regionName() As String
    regionName = pregionname
End Property

Public Property Get freq() As String
    freq = pfreq
End Property

Public Property Get period() As String
    period = pperiod
End Property

Public Property Get topic() As String
    topic = ptopic
End Property

Public Property Get variable() As String
    variable = pvariable
End Property

Public Property Get value() As String
    value = pvalue
End Property

Public Property Let value(ByVal sNewValue As String)
    pvalue = sNewValue
End Property

Public Property Let variable(ByVal sNewValue As String)
    pvariable = sNewValue
End Property

Public Property Let topic(ByVal sNewValue As String)
    ptopic = sNewValue
End Property

Public Property Let period(ByVal sNewValue As String)
    pperiod = sNewValue
End Property

Public Property Let freq(ByVal sNewValue As String)
    pfreq = sNewValue
End Property

Public Property Let regionName(ByVal sNewValue As String)
    pregionname = sNewValue
End Property

Public Property Let regionnr(ByVal sNewValue As String)
    pregionnr = sNewValue
End Property
Attribute VB_Name = "clsStringAppend"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'---------------------------------------------------------------------------------------
' Module    : clsStringAppend
' Author    : Philip Swannell
' Date      : 26-Jan-2018
' Purpose   : Class for constructing strings in a loop, avoiding "Shlemiel the painter" performance
'---------------------------------------------------------------------------------------
Option Base 1
Dim m_TheString As String
Dim m_NumCharsWritten As Long
Dim m_NumCharsStored As Long

Public Function Report()
1         On Error GoTo ErrHandler
2         Report = VBA.Left$(m_TheString, m_NumCharsWritten)
3         Exit Function
ErrHandler:
4         Err.Raise vbObjectError + 1, , "#clsStringAppend.Report (line " & CStr(Erl) + "): " & Err.Description & "!"
End Function

Private Function Max(x As Long, y As Long)
1         If x > y Then
2             Max = x
3         Else
4             Max = y
5         End If
End Function

Public Sub Append(TheString As String)
          Dim L As Long
          Dim NumCharsToAdd As Long
1         On Error GoTo ErrHandler
2         L = VBA.Len(TheString)
          
3         If L + m_NumCharsWritten > m_NumCharsStored Then
4             NumCharsToAdd = Max(L, m_NumCharsStored)
5             m_TheString = m_TheString + VBA.Space$(NumCharsToAdd)
6             m_NumCharsStored = m_NumCharsStored + NumCharsToAdd
7         End If

8         Mid$(m_TheString, m_NumCharsWritten + 1, L) = TheString
9         m_NumCharsWritten = m_NumCharsWritten + L

10        Exit Sub
ErrHandler:
11        Err.Raise vbObjectError + 1, , "#clsStringAppend.Append (line " & CStr(Erl) + "): " & Err.Description & "!"
End Sub
Attribute VB_Name = "clsUser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private pPassword As String
Private pUser As String
Private pToken As String

Public Property Get Password() As String
    Password = pPassword
End Property

Public Property Let Password(value As String)
    pPassword = value
End Property

Public Property Get User() As String
    User = pUser
End Property

Public Property Let User(value As String)
    pUser = value
End Property

Public Property Get Token() As String
    Token = pToken
End Property

Public Property Let Token(value As String)
    pToken = value
End Property
Attribute VB_Name = "frmAbout"
Attribute VB_Base = "0{A1B0356A-16F9-457C-A413-0E475D8E9642}{FEB803D2-0476-4E4B-92C1-276F614D7787}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub lblEmail_Click()
    On Error GoTo ErrHandler
    
    Dim linkText As String
    
    linkText = "mailto:" & lblEmail.Caption
    ActiveWorkbook.FollowHyperlink Address:=linkText, NewWindow:=True
    Unload Me
    Exit Sub
ErrHandler:
    MsgBox "Cannot open " & linkText & "!", vbCritical, APPTITLE
End Sub

Private Sub lblLink_Click()
    On Error GoTo ErrHandler
    
    Dim linkText As String
    
    linkText = "https://" & lblLink.Caption
    ActiveWorkbook.FollowHyperlink Address:=linkText, NewWindow:=True
    Unload Me
    Exit Sub
ErrHandler:
    MsgBox "Cannot open " & linkText & "!", vbCritical, APPTITLE
End Sub
Attribute VB_Name = "frmGetData"
Attribute VB_Base = "0{E0F46C1F-D33F-4BFC-883B-F579867A16A8}{1AA3EF0B-5F6A-4211-B678-A0D2DE765D73}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim dictVariables As Dictionary
Dim FullList_Period As Variant
Dim FullList_RegionName As Variant
Dim FilterStyle As XlContainsOperator
Dim DisableMyEvents_RegionName As Boolean
Dim DisableMyEvents_Period As Boolean
Dim AbortOne_RegionName As Boolean
Dim AbortOne_Period As Boolean
Const xlNoFilter As Long = xlNone

Private Sub Label12_Click()

End Sub

Private Sub Label2_Click()

End Sub

Private Sub UserForm_Initialize()
    Dim i As Integer, sht As Worksheet, uniqueValues As Dictionary, lastRow As Integer
    Dim rangeAddress As String
    
    rangeAddress = "'" & ActiveCell.Parent.Name & "'!" & ActiveCell.Address(External:=False)
    txtDestRange.Text = rangeAddress
    
    Set sht = ThisWorkbook.Worksheets(1)
    sht.AutoFilterMode = False
    Set uniqueValues = GetUniqueValues(sht.UsedRange.Offset(1).Resize(sht.UsedRange.Rows.Count - 1), 1)
    
    'fill Level 1 list
    For i = 1 To uniqueValues.Count
        lstLevel1.AddItem uniqueValues.Keys(i - 1)
    Next
    
'    lastRow = sht.Cells(sht.Rows.Count, "F").End(xlUp).Row
'    Set MyList = sht.Range("F2:F" & lastRow)
'    uiChosen = frmGetData.ChooseFromList_RegionName(MyList, xlFilterStyle:=xlBeginsWith)
'    lastRow = sht.Cells(sht.Rows.Count, "G").End(xlUp).Row
'    Set MyList = sht.Range("G2:G" & lastRow)
'    uiChosen = frmGetData.ChooseFromList_Period(MyList, xlFilterStyle:=xlBeginsWith)
End Sub

Private Sub UserForm_Terminate()
    Dim sht As Worksheet
    
    Set sht = ThisWorkbook.Worksheets(1)
    sht.AutoFilterMode = False
    Unload Me
End Sub

Private Sub cboPeriod_Change()
    Dim oneItem As Variant
    Dim FilteredItems() As String
    Dim NotFlag As Boolean
    Dim Pointer As Long, i As Long
    
    If DisableMyEvents_Period Then Exit Sub
    If AbortOne_Period Then AbortOne_Period = False: Exit Sub
    If TypeName(FullList_Period) Like "*()" Then
        ReDim FilteredItems(1 To UBound(FullList_Period))
        DisableMyEvents_Period = True
        Pointer = 0
        With cboPeriod
            Select Case FilterStyle
                Case xlBeginsWith: .Tag = LCase(.Text) & "*"
                Case xlContains: .Tag = "*" & LCase(.Text) & "*"
                Case xlDoesNotContain: .Tag = "*" & LCase(.Text) & "*": NotFlag = True
                Case xlEndsWith: .Tag = "*" & LCase(.Text)
                Case xlNoFilter: .Tag = "*"
            End Select
            
            For Each oneItem In FullList_Period
                If (LCase(oneItem) Like .Tag) Xor NotFlag Then
                    Pointer = Pointer + 1
                    FilteredItems(Pointer) = oneItem
                End If
            Next oneItem
            
            .List = FilteredItems
            .DropDown
        
            DisableMyEvents_Period = False
            If Pointer = 1 Then .ListIndex = 0
        End With
    End If
    FillFormula
End Sub

Private Sub cboPeriod_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Select Case KeyCode
        Case vbKeyReturn: Call FillFormula
        Case vbKeyUp, vbKeyDown: AbortOne_Period = True
    End Select
End Sub

Private Sub cboRegionName_Change()
    Dim oneItem As Variant
    Dim FilteredItems() As String
    Dim NotFlag As Boolean
    Dim Pointer As Long, i As Long
    
    If DisableMyEvents_RegionName Then Exit Sub
    If AbortOne_RegionName Then AbortOne_RegionName = False: Exit Sub
    If TypeName(FullList_RegionName) Like "*()" Then
        ReDim FilteredItems(1 To UBound(FullList_RegionName))
        DisableMyEvents_RegionName = True
        Pointer = 0
        With cboRegionName
            Select Case FilterStyle
                Case xlBeginsWith: .Tag = LCase(.Text) & "*"
                Case xlContains: .Tag = "*" & LCase(.Text) & "*"
                Case xlDoesNotContain: .Tag = "*" & LCase(.Text) & "*": NotFlag = True
                Case xlEndsWith: .Tag = "*" & LCase(.Text)
                Case xlNoFilter: .Tag = "*"
            End Select
            
            For Each oneItem In FullList_RegionName
                If (LCase(oneItem) Like .Tag) Xor NotFlag Then
                    Pointer = Pointer + 1
                    FilteredItems(Pointer) = oneItem
                End If
            Next oneItem
            
            .List = FilteredItems
            .DropDown
        
            DisableMyEvents_RegionName = False
            If Pointer = 1 Then .ListIndex = 0
        End With
    End If
    FillFormula
End Sub

Private Sub cboRegionName_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Select Case KeyCode
        Case vbKeyReturn: Call FillFormula
        Case vbKeyUp, vbKeyDown: AbortOne_RegionName = True
    End Select
End Sub

Private Sub txtRegionNumber_Change()
    FillFormula
End Sub

Private Sub lstLevel1_Click()
    Dim filteredRange As Range, Area As Range, cl As Range, i As Integer, sht As Worksheet, uniqueValues As Dictionary
    
    btnGetData.Enabled = False
    txtFormula.Text = ""
    lstLevel2.Clear
    lstLevel3.Clear
    
    Set uniqueValues = New Dictionary
    Set sht = ThisWorkbook.Worksheets(1)
    With sht
        .AutoFilterMode = False
        With .UsedRange
            .AutoFilter
            .AutoFilter Field:=1, Criteria1:=lstLevel1.Text
        End With
    
        Set filteredRange = .AutoFilter.Range.Offset(1).Resize(.AutoFilter.Range.Rows.Count - 1).SpecialCells(xlCellTypeVisible)
    
        For Each Area In filteredRange.Areas
            For Each cl In Area.Columns(2).Cells
                On Error Resume Next
                uniqueValues.Add .Cells(cl.Row, 2).Value2, Empty
                On Error GoTo 0
            Next cl
        Next Area
    End With
    'fill Level 2 list
    For i = 1 To uniqueValues.Count
        lstLevel2.AddItem uniqueValues.Keys(i - 1)
    Next
End Sub

Private Sub lstLevel2_Click()
    Dim filteredRange As Range, Area As Range, cl As Range, i As Integer, sht As Worksheet, uniqueValues As Dictionary
    
    btnGetData.Enabled = False
    txtFormula.Text = ""
    lstLevel3.Clear
    
    Set dictVariables = New Dictionary
    Set sht = ThisWorkbook.Worksheets(1)
    With sht
        .AutoFilterMode = False
        With .UsedRange
            .AutoFilter
            .AutoFilter Field:=1, Criteria1:=lstLevel1.Text
            .AutoFilter Field:=2, Criteria1:=lstLevel2.Text
        End With
    
        Set filteredRange = .AutoFilter.Range.Offset(1).Resize(.AutoFilter.Range.Rows.Count - 1).SpecialCells(xlCellTypeVisible)
    
        For Each Area In filteredRange.Areas
            For Each cl In Area.Columns(3).Cells
                On Error Resume Next
                dictVariables.Add .Cells(cl.Row, 3).Value2, .Cells(cl.Row, 4).Value2
                On Error GoTo 0
            Next cl
        Next Area
    End With
    'fill Level 2 list
    For i = 1 To dictVariables.Count
        lstLevel3.AddItem dictVariables.Keys(i - 1)
    Next
End Sub

Private Sub lstLevel3_Click()
    btnGetData.Enabled = True
    FillFormula
    
    'fill the region and period lists
    Dim uiChosen As String, sht As Worksheet, lastRow As Integer

    Set sht = ThisWorkbook.Worksheets(1)
    sht.AutoFilterMode = False
    
    'find the selected variable in column C
    Dim found As Range
    Set found = sht.Columns(3).Find(What:=lstLevel3.Text, After:=sht.Range("C1"), LookIn:=xlFormulas, _
        LookAt:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, SearchFormat:=False)

    If found Is Nothing Then
        'fill with full lists
        Dim MyList As Range
        lastRow = sht.Cells(sht.Rows.Count, "G").End(xlUp).Row
        Set MyList = sht.Range("G2:G" & lastRow)
        uiChosen = frmGetData.ChooseFromList_RegionName(MyList, xlFilterStyle:=xlBeginsWith)
        lastRow = sht.Cells(sht.Rows.Count, "H").End(xlUp).Row
        Set MyList = sht.Range("H2:H" & lastRow)
        uiChosen = frmGetData.ChooseFromList_Period(MyList, xlFilterStyle:=xlBeginsWith)
    Else
        Dim arrValues() As String
        arrValues = Split(sht.Cells(found.Row, "E").Value2, ",")
        uiChosen = frmGetData.ChooseFromList_RegionName(arrValues, xlFilterStyle:=xlBeginsWith)
        arrValues = Split(sht.Cells(found.Row, "F").Value2, ",")
        uiChosen = frmGetData.ChooseFromList_Period(arrValues, xlFilterStyle:=xlBeginsWith)
    End If
End Sub

Private Sub btnGetData_Click()
    Dim seriesName As String, regionName As String, regionNumber As String, yearValue As String, colData As Collection
    
    FillFormula
    seriesName = dictVariables(lstLevel3.Text)
    regionName = cboRegionName.Text
    regionNumber = txtRegionNumber.Text
    yearValue = cboPeriod.Text
    If seriesName = "" Then
        MsgBox "No series name avaialble!", vbCritical, APPTITLE
        Exit Sub
    End If
    Me.Hide
    Set colData = GetData(seriesName, regionName, regionNumber, yearValue)
    If colData Is Nothing Then
        MsgBox "No data avaialble!", vbCritical, APPTITLE
        Me.Show
        Exit Sub
    End If
    Unload Me
    DoEvents
    DumpData ActiveCell, txtFormula.Text, colData
End Sub

Private Sub FillFormula()
    Dim seriesName As String, regionName As String, regionNumber As String, yearValue As String, colData As Collection
    
    If lstLevel3.Text <> "" Then
        seriesName = dictVariables(lstLevel3.Text)
    End If
    regionName = cboRegionName.Text
    regionNumber = txtRegionNumber.Text
    yearValue = cboPeriod.Text
    txtFormula.Text = FORMULAFIXEDPART & "(" & seriesName & "," & regionName & "," & regionNumber & "," & yearValue & ")" & "|" & lstLevel3.Text
End Sub

Public Function ChooseFromList_Period(ListSource As Variant, Optional Default As String, Optional xlFilterStyle As XlContainsOperator = xlBeginsWith) As String

    Dim Pointer As Long, oneItem As Variant

    If TypeName(ListSource) = "Range" Then
        With ListSource
            Set ListSource = Application.Intersect(.Cells, .Parent.UsedRange)
        End With
        If ListSource Is Nothing Then Exit Function
        If ListSource.Cells.Count = 1 Then
            ReDim FullList_Period(1 To 1): FullList_Period(1) = ListSource.value
        ElseIf ListSource.Rows.Count = 1 Then
            FullList_Period = Application.Transpose(Application.Transpose(ListSource))
        Else
            FullList_Period = Application.Transpose(ListSource)
        End If
    ElseIf TypeName(ListSource) Like "*()" Then
        ReDim FullList_Period(1 To 1)
        For Each oneItem In ListSource
            Pointer = Pointer + 1
            If UBound(FullList_Period) < Pointer Then ReDim Preserve FullList_Period(1 To 2 * Pointer)
            FullList_Period(Pointer) = oneItem
        Next oneItem
        If Pointer > 0 Then ReDim Preserve FullList_Period(1 To Pointer)
    ElseIf Not IsObject(ListSource) Then
        ReDim FullList_Period(1 To 1)
        FullList_Period(1) = CStr(ListSource)
    Else
        Err.Raise 1004
    End If
    
    FilterStyle = xlFilterStyle

    DisableMyEvents_Period = True
    cboPeriod.Text = Default
    cboPeriod.List = FullList_Period
    DisableMyEvents_Period = False
End Function

Public Function ChooseFromList_RegionName(ListSource As Variant, Optional Default As String, Optional xlFilterStyle As XlContainsOperator = xlBeginsWith) As String

    Dim Pointer As Long, oneItem As Variant

    If TypeName(ListSource) = "Range" Then
        With ListSource
            Set ListSource = Application.Intersect(.Cells, .Parent.UsedRange)
        End With
        If ListSource Is Nothing Then Exit Function
        If ListSource.Cells.Count = 1 Then
            ReDim FullList_RegionName(1 To 1): FullList_RegionName(1) = ListSource.value
        ElseIf ListSource.Rows.Count = 1 Then
            FullList_RegionName = Application.Transpose(Application.Transpose(ListSource))
        Else
            FullList_RegionName = Application.Transpose(ListSource)
        End If
    ElseIf TypeName(ListSource) Like "*()" Then
        ReDim FullList_RegionName(1 To 1)
        For Each oneItem In ListSource
            Pointer = Pointer + 1
            If UBound(FullList_RegionName) < Pointer Then ReDim Preserve FullList_RegionName(1 To 2 * Pointer)
            FullList_RegionName(Pointer) = oneItem
        Next oneItem
        ReDim Preserve FullList_RegionName(1 To Pointer)
    ElseIf Not IsObject(ListSource) Then
        ReDim FullList_RegionName(1 To 1)
        FullList_RegionName(1) = CStr(ListSource)
    Else
        Err.Raise 1004
    End If
    
    FilterStyle = xlFilterStyle

    DisableMyEvents_RegionName = True
    cboRegionName.Text = Default
    cboRegionName.List = FullList_RegionName
    DisableMyEvents_RegionName = False
End Function

Attribute VB_Name = "frmLogin"
Attribute VB_Base = "0{1A0A99AF-B18D-4E1B-9C5B-5A29F049494D}{34481A5B-4A16-40BD-A240-9EE64EFD1C8A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub btnReset_Click()
    If MsgBox("This will reset the saved credentials. Continue?", vbQuestion + vbYesNo, APPTITLE) = vbYes Then
        SaveSetting APPTITLE, LOGINSECTION, "User", ""
        SaveSetting APPTITLE, LOGINSECTION, "Pass", ""
        Set crtUser = Nothing
        txtUser.Text = ""
        txtPassword.Text = ""
    End If
End Sub

Private Sub UserForm_Initialize()
    GetUserFromSettings
    If Not crtUser Is Nothing Then
        txtUser.Text = crtUser.User
        txtPassword.Text = crtUser.Password
    End If
End Sub

Private Sub GoBut_Click()
    On Error GoTo ErrHandler

    Dim colResponse As Collection
    
    lblWait.Visible = True
    DoEvents
    Set colResponse = SendLogin(txtUser.Text, txtPassword.Text)
    lblWait.Visible = False
    
    If colResponse Is Nothing Then
        MsgBox "Something went wrong, please try again!", vbExclamation, APPTITLE
        Exit Sub
    End If
    
    If colResponse.Count = 0 Then
        MsgBox "Something went wrong, please try again!", vbExclamation, APPTITLE
        Exit Sub
    Else
        SaveSetting APPTITLE, LOGINSECTION, "User", txtUser.Text
        SaveSetting APPTITLE, LOGINSECTION, "Pass", txtPassword.Text
        Set crtUser = New clsUser
        crtUser.User = txtUser.Text
        crtUser.Password = txtPassword.Text
        crtUser.Token = colResponse(1)
        Unload Me
    End If
    
    Exit Sub

ErrHandler:
    lblWait.Visible = False
    MsgBox Err.Description, vbCritical, "GoBut_Click - Detailed error description"
End Sub
Attribute VB_Name = "frmProgBar"
Attribute VB_Base = "0{373AB8B2-EA8F-4296-B0C2-5B0A36FE850F}{79AC8226-7540-44D2-BC2B-74041BA4187F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Const GWL_STYLE = -16
Private Const WS_CAPTION = &HC00000

#If VBA7 Then
    Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
#Else
    Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
#End If

Private Sub HideFormTitleBar(frm As Object)
    Dim windowHandle As Long, frmHandle As Long
    
    frmHandle = FindWindowA(vbNullString, frm.Caption)
    windowHandle = GetWindowLong(frmHandle, GWL_STYLE)
    windowHandle = windowHandle And (Not WS_CAPTION)
    Call SetWindowLong(frmHandle, GWL_STYLE, windowHandle)
    Call DrawMenuBar(frmHandle)
End Sub

Private Sub UserForm_Initialize()
    #If IsMac Then
        Exit Sub
    #End If
    lblProg.Width = 0
    Me.Height = Me.Height - 10
    HideFormTitleBar Me
End Sub

Attribute VB_Name = "modAPI"
Option Explicit

Public API_URL_BASE As String 'slash terminate

Public crtUser As clsUser

Public Function SendLogin(strUser As String, strPassword As String) As Collection
    On Error GoTo ErrorHandler

    Dim createUrl As String

    'build the api url
    If API_URL_BASE = "" Then
        InitAddinVariables
    End If
    createUrl = API_URL_BASE & "tokens"

    Dim req As Object
    Dim strJSon As String
    Dim error As String
    Dim JSON As Object
    Dim node As Variant, Item As Variant
    Dim colResponse As New Collection
    Dim post_data As String, status As Integer
    
    'post data to web
    Set req = CreateObject("Msxml2.XMLHTTP.6.0")
'    Set req = CreateObject("Msxml2.ServerXMLHTTP.6.0")
'    req.setTimeouts 15000, 15000, 15000, 15000
    req.Open "POST", createUrl, False
    req.setRequestHeader "Authorization", "Basic " & Base64Encode(strUser & ":" & strPassword)
    req.setRequestHeader "Content-Type", "application/json"
    req.Send 'CVar(post_data)
    req.getAllResponseHeaders
'    Debug.Print req.responseText
    strJSon = req.responseText
    status = req.status

    Select Case status
        Case 200 'OK
        Case Else
            error = "Invalid login"
            MsgBox error & "!" & vbCrLf & "Status: " & status & "." & vbCrLf & "Response: " & strJSon, vbCritical
            GoTo exitFunction
    End Select

    Set JSON = ParseJson(strJSon)
    
    'check for valid JSON response
    If JSON Is Nothing Then
        Set SendLogin = Nothing
        error = "Invalid response from server"
        MsgBox error & "!", vbCritical, APPTITLE
        GoTo exitFunction
    End If
    
    'retrieve data
    If Not IsEmpty(JSON("token")) Then
        colResponse.Add JSON("token")
        Set SendLogin = colResponse
    Else
        Set SendLogin = Nothing
    End If

exitFunction:
    ' return dataset
    Set req = Nothing
    Set JSON = Nothing
    Set colResponse = Nothing
    Set node = Nothing
    Exit Function
    
ErrorHandler:
    Set req = Nothing
    Set JSON = Nothing
    Set colResponse = Nothing
    Set node = Nothing
    MsgBox "Unable to get data from server. Please check your internet connection", vbCritical, APPTITLE
    MsgBox Err.Description, vbCritical, "SendLogin - Detailed error description"
End Function

Public Function GetSeries() As Collection
    On Error GoTo ErrorHandler

    Dim createUrl As String

    If Not IsUserLoggedIn Then
        frmLogin.Show
    End If
    
    If crtUser Is Nothing Then
        Exit Function
    Else
        If crtUser.Token = "" Then
            Exit Function
        End If
    End If
    
    'build the api url
    If API_URL_BASE = "" Then
        InitAddinVariables
    End If
    createUrl = API_URL_BASE & "series"

    Dim req As Object
    Dim strJSon As String
    Dim error As String
    Dim JSON As Object
    Dim node As Variant, Item As Variant
    Dim colResponse As New Collection
    Dim post_data As String, status As Integer
    
    frmProgBar.Show
    PercentCompleted 0, "Downloading data..."
    
    'post data to web
    Set req = CreateObject("Msxml2.XMLHTTP.6.0")
'    Set req = CreateObject("Msxml2.ServerXMLHTTP.6.0")
'    req.setTimeouts 15000, 15000, 15000, 15000
    req.Open "GET", createUrl, False
    req.setRequestHeader "Authorization", "Bearer " & crtUser.Token
    req.setRequestHeader "Content-Type", "application/json"
    req.Send 'CVar(post_data)
    req.getAllResponseHeaders
'    Debug.Print req.responseText
    strJSon = req.responseText
    status = req.status

    Select Case status
        Case 200 'OK
        Case Else
            error = "Invalid response from server"
            MsgBox error & "!" & vbCrLf & "Status: " & status & "." & vbCrLf & "Response: " & strJSon, vbCritical
            GoTo exitFunction
    End Select

    PercentCompleted 0.3, "Parsing JSON response..."
    Set JSON = ParseJson(strJSon)
    
    'check for valid JSON response
    If JSON Is Nothing Then
        Set GetSeries = Nothing
        error = "Invalid response from server"
        MsgBox error & "!", vbCritical, APPTITLE
        GoTo exitFunction
    End If
    
    'retrieve data
    Dim objSeries As Variant
    On Error Resume Next
    Set objSeries = JSON("series")
    On Error GoTo 0
    If Not IsEmpty(objSeries) Then
        PercentCompleted 0.6, "Preparing data (" & CStr(objSeries.Count) & " items)..."
        For Each Item In objSeries
            colResponse.Add Item
        Next
        Set GetSeries = colResponse
'        MsgBox colResponse.Count
    Else
        Set GetSeries = Nothing
    End If

    Unload frmProgBar

exitFunction:
    ' return dataset
    Set req = Nothing
    Set JSON = Nothing
    Set colResponse = Nothing
    Set node = Nothing
    Exit Function
    
ErrorHandler:
    Unload frmProgBar

    Set req = Nothing
    Set JSON = Nothing
    Set colResponse = Nothing
    Set node = Nothing
    MsgBox "Unable to get data from server. Please check your internet connection", vbCritical, APPTITLE
    MsgBox Err.Description, vbCritical, "GetSeries - Detailed error description"
End Function

Public Function GetData(seriesName As String, regionName As String, regionNumber As String, yearValue As String) As Collection
    On Error GoTo ErrorHandler

    Dim createUrl As String, noRetries As Integer

    If seriesName = "" Then
        MsgBox "Unable to get data (missing series name)!", vbCritical, APPTITLE
        Exit Function
    End If
    
    If Not IsUserLoggedIn Then
        frmLogin.Show
    End If
    
    If crtUser Is Nothing Then
        Exit Function
    Else
        If crtUser.Token = "" Then
            Exit Function
        End If
    End If
    
    'build the api url
    If API_URL_BASE = "" Then
        InitAddinVariables
    End If
    createUrl = API_URL_BASE & "series" & "/" & seriesName

    Dim req As Object
    Dim strJSon As String
    Dim error As String, errDesc As String
    Dim JSON As Object
    Dim node As Variant, Item As Variant
    Dim colResponse As Collection
    Dim post_data As String, status As Integer
    
    frmProgBar.Show
    PercentCompleted 0, "Downloading data..."
    
    If yearValue <> "" Then
        post_data = "?" & "year=" & yearValue
        If regionName <> "" Then
            post_data = post_data & "&" & "region=" & regionName
        End If
        If regionNumber <> "" Then
            post_data = post_data & "&" & "regionnr=" & regionNumber
        End If
    ElseIf regionName <> "" Then
        post_data = "?" & "region=" & regionName
        If yearValue <> "" Then
            post_data = post_data & "&" & "year=" & yearValue
        End If
        If regionNumber <> "" Then
            post_data = post_data & "&" & "regionnr=" & regionNumber
        End If
    ElseIf regionNumber <> "" Then
        post_data = "?" & "regionnr=" & regionNumber
        If yearValue <> "" Then
            post_data = post_data & "&" & "year=" & yearValue
        End If
        If regionName <> "" Then
            post_data = post_data & "&" & "region=" & regionName
        End If
    End If
    
    noRetries = 1
TryAgain:
    'post data to web
    Set req = CreateObject("Msxml2.XMLHTTP.6.0")
'    Set req = CreateObject("Msxml2.ServerXMLHTTP.6.0")
'    req.setTimeouts 5000, 5000, 15000, 15000
    req.Open "GET", createUrl & post_data, False
    req.setRequestHeader "Authorization", "Bearer " & crtUser.Token
    req.setRequestHeader "Content-Type", "application/json"
    req.Send CVar(post_data)
    
    req.getAllResponseHeaders
'    Debug.Print req.responseText
    strJSon = req.responseText
    status = req.status

    Select Case status
        Case 200 'OK
        Case 401 'unauthorized access -> issue a login and get the token
            If noRetries > 2 Then
                GoTo exitFunction
            End If
            Dim colLogin As Collection
            Set colLogin = SendLogin(crtUser.User, crtUser.Password)
            If colLogin Is Nothing Then
                MsgBox "Something went wrong, please try again!", vbExclamation, APPTITLE
                GoTo exitFunction
            End If
            If colLogin.Count = 0 Then
                MsgBox "Something went wrong, please try again!", vbExclamation, APPTITLE
                GoTo exitFunction
            Else
                noRetries = noRetries + 1
                crtUser.Token = colLogin(1)
                GoTo TryAgain
            End If
        Case Else
            error = "Invalid response from server"
            MsgBox error & "!" & vbCrLf & "Status: " & status & "." & vbCrLf & "Response: " & strJSon, vbCritical
            GoTo exitFunction
    End Select

    PercentCompleted 0.3, "Parsing JSON response..."
    Set JSON = ParseJson(strJSon)
    
    'check for valid JSON response
    If JSON Is Nothing Then
        error = "Invalid response from server"
        MsgBox error & "!", vbCritical, APPTITLE
        GoTo exitFunction
    End If
    
    'check for errors
    Dim responseMessage As Variant
    On Error Resume Next
    Set responseMessage = JSON("message")
    On Error GoTo 0
    If Not IsEmpty(responseMessage) Then
        MsgBox JSON("message"), vbCritical, APPTITLE
        GoTo exitFunction
    End If
    
    PercentCompleted 0.6, "Preparing data (" & CStr(JSON.Count) & " items)..."
    'all OK
    Dim dataValue As clsDataValue
    Set colResponse = New Collection
    For Each Item In JSON
        Set dataValue = New clsDataValue
        dataValue.freq = Item("freq")
        dataValue.period = Item("period")
        dataValue.regionName = Item("regionname")
        dataValue.regionnr = Item("regionnr")
        dataValue.topic = Item("topic")
        dataValue.value = Item("value")
        dataValue.variable = Item("variable")
        dataValue.sortvalue = Item("regionname") & "|" & Item("period")
        colResponse.Add dataValue
    Next
'    Set colResponse = CollectionSorted(colResponse, "sortvalue", True)
    Set GetData = colResponse
'    MsgBox colResponse.Count

exitFunction:
    Unload frmProgBar
    
    ' return dataset
    Set req = Nothing
    Set JSON = Nothing
    Set colResponse = Nothing
    Set node = Nothing
    Exit Function
    
ErrorHandler:
    Unload frmProgBar

    Set req = Nothing
    Set JSON = Nothing
    Set colResponse = Nothing
    Set node = Nothing
    MsgBox "Unable to get data from server. Please check your internet connection", vbCritical, APPTITLE
    MsgBox Err.Description, vbCritical, "GetTDS - Detailed error description"
End Function

Public Sub test()
    GetData "Anteil mit GA oder Halbtax", "", "261", "2017"
End Sub
Attribute VB_Name = "modExcel"
Option Explicit

Public Const FORMULAFIXEDPART As String = "NovaDBGetData"

Public stopRefreshing As Boolean

Public Sub RefreshWorkbook()
    On Error GoTo ErrorHandler
    
    Dim sht As Worksheet, i As Integer, cntFormulas As Integer
    
    If MsgBox("This will refresh all downloaded data in active workbook, continue?", vbQuestion + vbYesNo, APPTITLE) = vbNo Then
        Exit Sub
    End If
    
    cntFormulas = 0
    For Each sht In ActiveWorkbook.Worksheets
        If stopRefreshing Then
            stopRefreshing = False
            Exit For
        End If
        i = i + 1
        Application.StatusBar = "Refreshing sheet " & sht.Name & "..."
        DoEvents
        cntFormulas = cntFormulas + RefreshSheet(sht, False)
    Next
    Application.StatusBar = False
    MsgBox "Done! " & CStr(cntFormulas) & " formulas refreshed.", vbInformation, APPTITLE
    
    Exit Sub
ErrorHandler:
    stopRefreshing = False
    Application.StatusBar = False
    Application.ScreenUpdating = True
    MsgBox Err.Description, vbCritical, "RefreshWorkbook - Detailed error description"
End Sub

Public Function RefreshSheet(crtSheet As Worksheet, askConfirmation As Boolean) As Integer
    On Error GoTo ErrorHandler

    Dim rangeFound As Range, tmpRange As Range, strFormula As String, arrFormula() As String, cntFormulas As Integer, arrFormula1() As String
    Dim seriesName As String, regionName As String, regionNumber As String, yearValue As String, colData As Collection, rngDest As Range
    
    If askConfirmation Then
        If MsgBox("This will refresh all downloaded data in active sheet, continue?", vbQuestion + vbYesNo, APPTITLE) = vbNo Then
            Exit Function
        End If
    End If
    
    If crtSheet Is Nothing Then
        Exit Function
    End If
    cntFormulas = 0
    Application.ScreenUpdating = False
    Set rangeFound = FindAll(crtSheet.UsedRange, FORMULAFIXEDPART, xlValues, xlPart, xlByColumns)
    If Not rangeFound Is Nothing Then
        For Each tmpRange In rangeFound
            strFormula = tmpRange.Value2 'FORMULAFIXEDPART & "(" & seriesName & "," & regionName & "," & regionNumber & "," & yearValue & ")" 'NovaDBGetData(age_20_39,Zurich,216,2017,$K$12:$M$12)
'            arrFormula = Split(strFormula, FORMULAFIXEDPART)
            arrFormula1 = Split(strFormula, "|")
            arrFormula = Split(arrFormula1(0), FORMULAFIXEDPART)
            If UBound(arrFormula) > 0 Then
                strFormula = Mid(arrFormula(1), 2, Len(arrFormula(1)) - 2) 'remove first and last ()
                arrFormula = Split(strFormula, ",")
                If UBound(arrFormula) > 3 Then
                    Set rngDest = crtSheet.Range(arrFormula(4))
                    rngDest.Clear
                    seriesName = arrFormula(0)
                    regionName = arrFormula(1)
                    regionNumber = arrFormula(2)
                    yearValue = arrFormula(3)
                    If seriesName <> "" Then
                        cntFormulas = cntFormulas + 1
                        Set colData = GetData(seriesName, regionName, regionNumber, yearValue)
                        If Not colData Is Nothing Then
                            strFormula = FORMULAFIXEDPART & "(" & seriesName & "," & regionName & "," & regionNumber & "," & yearValue & ")" & _
                                "|" & arrFormula1(1)
                            DumpData tmpRange, strFormula, colData, False
                        End If
                    End If
                End If
            End If
        Next
    End If
    Application.ScreenUpdating = True
    If askConfirmation Then
        MsgBox "Done! " & CStr(cntFormulas) & " formulas refreshed.", vbInformation, APPTITLE
    End If
    RefreshSheet = cntFormulas
    
    Exit Function
ErrorHandler:
    Application.ScreenUpdating = True
    MsgBox Err.Description, vbCritical, "RefreshSheet - Detailed error description"
End Function

Public Sub DumpData(destCell As Range, strFormula As String, colData As Collection, Optional updateScreen As Boolean = True)
    On Error GoTo ErrorHandler

    Dim crtSheet As Worksheet, crtCell As Range, dataRange As Range, i As Long, tmpDataValue As clsDataValue
    Dim firstRow As Long, lastRow As Long, firstCol As Integer, lastCol As Integer
    Dim arrValues() As Variant, countValues As Long, decSep As String, textVal As String
    
    decSep = CreateObject("WScript.Shell").RegRead("HKCU\Control Panel\International\sDecimal")
    countValues = colData.Count
    Set crtSheet = destCell.Worksheet
    Set crtCell = destCell
    crtCell.Font.Bold = True
    firstRow = crtCell.Row + 1
    lastRow = firstRow + countValues '- 1
    firstCol = crtCell.Column
    lastCol = firstCol + 3
    Set dataRange = crtSheet.Range(crtSheet.Cells(firstRow, firstCol), crtSheet.Cells(lastRow, lastCol))
    If Not RangeIsEmpty(dataRange) Then
        If MsgBox("Downloaded data will overwrite non-empty cells, continue?", vbQuestion + vbYesNo, APPTITLE) = vbNo Then
            Exit Sub
        End If
    End If
    
    frmProgBar.Show
    PercentCompleted 0, "Preparing data..."
    ReDim arrValues(countValues, 3)
    arrValues(0, 0) = "region"
    arrValues(0, 1) = "period"
    'extract display value from formula
    Dim arrFormula() As String
    arrFormula = Split(strFormula, "|")
    If UBound(arrFormula) > 0 Then
        arrValues(0, 2) = arrFormula(1)
        strFormula = arrFormula(0)
    Else
        arrValues(0, 2) = "value"
    End If
    For i = 1 To countValues
        PercentCompleted i / countValues, "Writing item " & CStr(i) & " from " & CStr(countValues) & "..."
        Set tmpDataValue = colData(i)
        arrValues(i, 0) = tmpDataValue.regionName
        arrValues(i, 1) = tmpDataValue.period
        textVal = tmpDataValue.value
        If IsNumeric(textVal) Then
            textVal = Replace(textVal, ".", decSep)
            arrValues(i, 2) = CSng(textVal)
        Else
            arrValues(i, 2) = tmpDataValue.value
        End If
    Next
    Unload frmProgBar
    
    If updateScreen Then
        Application.ScreenUpdating = False
    End If
    Dim destRange As Range
    Set destRange = dataRange.Cells(1).Resize(UBound(arrValues, 1) + 1, UBound(arrValues, 2))
    destRange.value = arrValues
    SortMultipleColumns destRange, 1, 2
    'write formula in cell
    strFormula = Left(strFormula, Len(strFormula) - 1) & "," & destRange.Address & ")"
    strFormula = strFormula & "|" & arrValues(0, 2)
    crtCell.Value2 = strFormula
    If updateScreen Then
        Application.ScreenUpdating = True
    End If
    
    Exit Sub
ErrorHandler:
    Unload frmProgBar
    Application.ScreenUpdating = True
    MsgBox Err.Description, vbCritical, "DumpData - Detailed error description"
End Sub

Private Function RangeIsEmpty(ByVal SourceRange As Range) As Boolean
    RangeIsEmpty = (WorksheetFunction.CountA(SourceRange) = 0)
End Function

Private Sub SortMultipleColumns(rng As Range, col1 As Integer, col2 As Integer)
    rng.Sort Key1:=rng.Cells(1, col1), Order1:=xlAscending, Key2:=rng.Cells(1, col2), Order2:=xlAscending, Header:=xlYes
End Sub

Attribute VB_Name = "modFindAll"
Option Explicit
Option Compare Text
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This module contains two functions, FindAll and FindAllOnWorksheets that are use
' to find values on a worksheet or multiple worksheets.
'
' FindAll searches a range and returns a range containing the cells in which the
'   searched for text was found. If the string was not found, it returns Nothing.

' FindAllOnWorksheets searches the same range on one or more workshets. It return
'   an array of ranges, each of which is the range on that worksheet in which the
'   value was found. If the value was not found on a worksheet, that worksheet's
'   element in the returned array will be Nothing.
'
' In both functions, the parameters that control the search have the same meaning
' and effect as they do in the Range.Find method.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Function FindAll(SearchRange As Range, _
                FindWhat As Variant, _
               Optional LookIn As XlFindLookIn = xlValues, _
                Optional LookAt As XlLookAt = xlWhole, _
                Optional SearchOrder As XlSearchOrder = xlByRows, _
                Optional MatchCase As Boolean = False, _
                Optional BeginsWith As String = vbNullString, _
                Optional EndsWith As String = vbNullString, _
                Optional BeginEndCompare As VbCompareMethod = vbTextCompare) As Range
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' FindAll
' This searches the range specified by SearchRange and returns a Range object
' that contains all the cells in which FindWhat was found. The search parameters to
' this function have the same meaning and effect as they do with the
' Range.Find method. If the value was not found, the function return Nothing. If
' BeginsWith is not an empty string, only those cells that begin with BeginWith
' are included in the result. If EndsWith is not an empty string, only those cells
' that end with EndsWith are included in the result. Note that if a cell contains
' a single word that matches either BeginsWith or EndsWith, it is included in the
' result.  If BeginsWith or EndsWith is not an empty string, the LookAt parameter
' is automatically changed to xlPart. The tests for BeginsWith and EndsWith may be
' case-sensitive by setting BeginEndCompare to vbBinaryCompare. For case-insensitive
' comparisons, set BeginEndCompare to vbTextCompare. If this parameter is omitted,
' it defaults to vbTextCompare. The comparisons for BeginsWith and EndsWith are
' in an OR relationship. That is, if both BeginsWith and EndsWith are provided,
' a match if found if the text begins with BeginsWith OR the text ends with EndsWith.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'    On Error GoTo errhandler

Dim FoundCell As Range
Dim FirstFound As Range, SecondFound As Range
Dim LastCell As Range
Dim ResultRange As Range
Dim XLookAt As XlLookAt
Dim Include As Boolean
Dim CompMode As VbCompareMethod
Dim Area As Range
Dim MaxRow As Long
Dim MaxCol As Long
Dim BeginB As Boolean
Dim EndB As Boolean
Dim maxResults As Integer


CompMode = BeginEndCompare
If BeginsWith <> vbNullString Or EndsWith <> vbNullString Then
    XLookAt = xlPart
Else
    XLookAt = LookAt
End If

' this loop in Areas is to find the last cell
' of all the areas. That is, the cell whose row
' and column are greater than or equal to any cell
' in any Area.
For Each Area In SearchRange.Areas
    With Area
        If .Cells(.Cells.Count).Row > MaxRow Then
            MaxRow = .Cells(.Cells.Count).Row
        End If
        If .Cells(.Cells.Count).Column > MaxCol Then
            MaxCol = .Cells(.Cells.Count).Column
        End If
    End With
Next Area
Set LastCell = SearchRange.Worksheet.Cells(MaxRow, MaxCol)


On Error Resume Next
'On Error GoTo 0
Set FoundCell = SearchRange.Find(What:=FindWhat, _
        After:=LastCell, _
        LookIn:=LookIn, _
        LookAt:=XLookAt, _
        SearchOrder:=SearchOrder, _
        MatchCase:=MatchCase)

If Not FoundCell Is Nothing Then
    maxResults = 0
    Set FirstFound = FoundCell
    'Set ResultRange = FoundCell
    'Set FoundCell = SearchRange.FindNext(after:=FoundCell)
    Do Until False ' Loop forever. We'll "Exit Do" when necessary.
        maxResults = maxResults + 1
        Include = False
        If BeginsWith = vbNullString And EndsWith = vbNullString Then
            Include = True
        Else
            If BeginsWith <> vbNullString Then
                If StrComp(Left(FoundCell.Text, Len(BeginsWith)), BeginsWith, BeginEndCompare) = 0 Then
                    Include = True
                End If
            End If
            If EndsWith <> vbNullString Then
                If StrComp(Right(FoundCell.Text, Len(EndsWith)), EndsWith, BeginEndCompare) = 0 Then
                    Include = True
                End If
            End If
        End If
        If Include = True Then
            If ResultRange Is Nothing Then
                Set ResultRange = FoundCell
            Else
                Set ResultRange = Application.Union(ResultRange, FoundCell)
            End If
        End If
        Set FoundCell = SearchRange.FindNext(After:=FoundCell)
        If (FoundCell Is Nothing) Then
            Exit Do
        End If
        If (FoundCell.Address = FirstFound.Address) Then
            Exit Do
        End If
        If Not SecondFound Is Nothing Then
            If (FoundCell.Address = SecondFound.Address) Then
                Exit Do
            End If
        End If
        If (maxResults > 10) Then 'maxim 10 results, to avoid infinit loops
            Exit Do
        End If
        If maxResults = 1 Then
            Set SecondFound = FoundCell
        End If
    Loop
End If
    
Set FindAll = ResultRange

    Exit Function

ErrHandler:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure FindAll of Sub modFindAll"

End Function

Function FindAllOnWorksheets(InWorkbook As Workbook, _
                InWorksheets As Variant, _
                SearchAddress As String, _
                FindWhat As Variant, _
                Optional LookIn As XlFindLookIn = xlValues, _
                Optional LookAt As XlLookAt = xlWhole, _
                Optional SearchOrder As XlSearchOrder = xlByRows, _
                Optional MatchCase As Boolean = False, _
                Optional BeginsWith As String = vbNullString, _
                Optional EndsWith As String = vbNullString, _
                Optional BeginEndCompare As VbCompareMethod = vbTextCompare) As Variant
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' FindAllOnWorksheets
' This function searches a range on one or more worksheets, in the range specified by
' SearchAddress.
'
' InWorkbook specifies the workbook in which to search. If this is Nothing, the active
'   workbook is used.
'
' InWorksheets specifies what worksheets to search. InWorksheets can be any of the
' following:
'   - Empty: This will search all worksheets of the workbook.
'   - String: The name of the worksheet to search.
'   - String: The names of the worksheets to search, separated by a ':' character.
'   - Array: A one dimensional array whose elements are any of the following:
'           - Object: A worksheet object to search. This must be in the same workbook
'               as InWorkbook.
'           - String: The name of the worksheet to search.
'           - Number: The index number of the worksheet to search.
' If any one of the specificed worksheets is not found in InWorkbook, no search is
' performed. The search takes place only after everything has been validated.
'
' The other parameters have the same meaning and effect on the search as they do
' in the Range.Find method.
'
' Most of the code in this procedure deals with the InWorksheets parameter to give
' the absolute maximum flexibility in specifying which sheet to search.
'
' This function requires the FindAll procedure, also in this module or avaialable
' at www.cpearson.com/Excel/FindAll.aspx.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim WSArray() As String
Dim WS As Worksheet
Dim Wb As Workbook
Dim ResultRange() As Range
Dim WSNdx As Long
Dim r As Range
Dim SearchRange As Range
Dim FoundRange As Range
Dim WSS As Variant
Dim N As Long


'''''''''''''''''''''''''''''''''''''''''''
' Determine what Workbook to search.
'''''''''''''''''''''''''''''''''''''''''''
If InWorkbook Is Nothing Then
    Set Wb = ActiveWorkbook
Else
    Set Wb = InWorkbook
End If

'''''''''''''''''''''''''''''''''''''''''''
' Determine what sheets to search
'''''''''''''''''''''''''''''''''''''''''''
If IsEmpty(InWorksheets) = True Then
    ''''''''''''''''''''''''''''''''''''''''''
    ' Empty. Search all sheets.
    ''''''''''''''''''''''''''''''''''''''''''
    With Wb.Worksheets
        ReDim WSArray(1 To .Count)
        For WSNdx = 1 To .Count
            WSArray(WSNdx) = .Item(WSNdx).Name
        Next WSNdx
    End With

Else
    '''''''''''''''''''''''''''''''''''''''
    ' If Object, ensure it is a Worksheet
    ' object.
    ''''''''''''''''''''''''''''''''''''''
    If IsObject(InWorksheets) = True Then
        If TypeOf InWorksheets Is Excel.Worksheet Then
            ''''''''''''''''''''''''''''''''''''''''''
            ' Ensure Worksheet is in the WB workbook.
            ''''''''''''''''''''''''''''''''''''''''''
            If StrComp(InWorksheets.Parent.Name, Wb.Name, vbTextCompare) <> 0 Then
                ''''''''''''''''''''''''''''''
                ' Sheet is not in WB. Get out.
                ''''''''''''''''''''''''''''''
                Exit Function
            Else
                ''''''''''''''''''''''''''''''
                ' Same workbook. Set the array
                ' to the worksheet name.
                ''''''''''''''''''''''''''''''
                ReDim WSArray(1 To 1)
                WSArray(1) = InWorksheets.Name
            End If
        Else
            '''''''''''''''''''''''''''''''''''''
            ' Object is not a Worksheet. Get out.
            '''''''''''''''''''''''''''''''''''''
        End If
    Else
        '''''''''''''''''''''''''''''''''''''''''''
        ' Not empty, not an object. Test for array.
        '''''''''''''''''''''''''''''''''''''''''''
        If IsArray(InWorksheets) = True Then
            '''''''''''''''''''''''''''''''''''''''
            ' It is an array. Test if each element
            ' is an object. If it is a worksheet
            ' object, get its name. Any other object
            ' type, get out. Not an object, assume
            ' it is the name.
            ''''''''''''''''''''''''''''''''''''''''
            ReDim WSArray(LBound(InWorksheets) To UBound(InWorksheets))
            For WSNdx = LBound(InWorksheets) To UBound(InWorksheets)
                If IsObject(InWorksheets(WSNdx)) = True Then
                    If TypeOf InWorksheets(WSNdx) Is Excel.Worksheet Then
                        ''''''''''''''''''''''''''''''''''''''
                        ' It is a worksheet object, get name.
                        ''''''''''''''''''''''''''''''''''''''
                        WSArray(WSNdx) = InWorksheets(WSNdx).Name
                    Else
                        ''''''''''''''''''''''''''''''''
                        ' Other type of object, get out.
                        ''''''''''''''''''''''''''''''''
                        Exit Function
                    End If
                Else
                    '''''''''''''''''''''''''''''''''''''''''''
                    ' Not an object. If it is an integer or
                    ' long, assume it is the worksheet index
                    ' in workbook WB.
                    '''''''''''''''''''''''''''''''''''''''''''
                    Select Case UCase(TypeName(InWorksheets(WSNdx)))
                        Case "LONG", "INTEGER"
                            Err.Clear
                            '''''''''''''''''''''''''''''''''''
                            ' Ensure integer if valid index.
                            '''''''''''''''''''''''''''''''''''
                            Set WS = Wb.Worksheets(InWorksheets(WSNdx))
                            If Err.Number <> 0 Then
                                '''''''''''''''''''''''''''''''
                                ' Invalid index.
                                '''''''''''''''''''''''''''''''
                                Exit Function
                            End If
                            ''''''''''''''''''''''''''''''''''''
                            ' Valid index. Get name.
                            ''''''''''''''''''''''''''''''''''''
                            WSArray(WSNdx) = Wb.Worksheets(InWorksheets(WSNdx)).Name
                        Case "STRING"
                            Err.Clear
                            '''''''''''''''''''''''''''''''''''''
                            ' Ensure valid name.
                            '''''''''''''''''''''''''''''''''''''
                            Set WS = Wb.Worksheets(InWorksheets(WSNdx))
                            If Err.Number <> 0 Then
                                '''''''''''''''''''''''''''''''''
                                ' Invalid name, get out.
                                '''''''''''''''''''''''''''''''''
                                Exit Function
                            End If
                            WSArray(WSNdx) = InWorksheets(WSNdx)
                    End Select
                End If
                'WSArray(WSNdx) = InWorksheets(WSNdx)
            Next WSNdx
        Else
            ''''''''''''''''''''''''''''''''''''''''''''
            ' InWorksheets is neither an object nor an
            ' array. It is either the name or index of
            ' the worksheet.
            ''''''''''''''''''''''''''''''''''''''''''''
            Select Case UCase(TypeName(InWorksheets))
                Case "INTEGER", "LONG"
                    '''''''''''''''''''''''''''''''''''''''
                    ' It is a number. Ensure sheet exists.
                    '''''''''''''''''''''''''''''''''''''''
                    Err.Clear
                    Set WS = Wb.Worksheets(InWorksheets)
                    If Err.Number <> 0 Then
                        '''''''''''''''''''''''''''''''
                        ' Invalid index, get out.
                        '''''''''''''''''''''''''''''''
                        Exit Function
                    Else
                        WSArray = Array(Wb.Worksheets(InWorksheets).Name)
                    End If
                Case "STRING"
                    '''''''''''''''''''''''''''''''''''''''''''''''''''
                    ' See if the string contains a ':' character. If
                    ' so, the InWorksheets contains a string of multiple
                    ' worksheets.
                    '''''''''''''''''''''''''''''''''''''''''''''''''''
                    If InStr(1, InWorksheets, ":", vbBinaryCompare) > 0 Then
                        ''''''''''''''''''''''''''''''''''''''''''
                        ' ":" character found. split apart sheet
                        ' names.
                        ''''''''''''''''''''''''''''''''''''''''''
                        WSS = Split(InWorksheets, ":")
                        Err.Clear
                        N = LBound(WSS)
                        If Err.Number <> 0 Then
                            '''''''''''''''''''''''''''''
                            ' Unallocated array. Get out.
                            '''''''''''''''''''''''''''''
                            Exit Function
                        End If
                        If LBound(WSS) > UBound(WSS) Then
                            '''''''''''''''''''''''''''''
                            ' Unallocated array. Get out.
                            '''''''''''''''''''''''''''''
                            Exit Function
                        End If
                            
                                                
                        ReDim WSArray(LBound(WSS) To UBound(WSS))
                        For N = LBound(WSS) To UBound(WSS)
                            Err.Clear
                            Set WS = Wb.Worksheets(WSS(N))
                            If Err.Number <> 0 Then
                                Exit Function
                            End If
                            WSArray(N) = WSS(N)
                         Next N
                    Else
                        Err.Clear
                        Set WS = Wb.Worksheets(InWorksheets)
                        If Err.Number <> 0 Then
                            '''''''''''''''''''''''''''''''''
                            ' Invalid name, get out.
                            '''''''''''''''''''''''''''''''''
                            Exit Function
                        Else
                            WSArray = Array(InWorksheets)
                        End If
                    End If
            End Select
        End If
    End If
End If
'''''''''''''''''''''''''''''''''''''''''''
' Ensure SearchAddress is valid
'''''''''''''''''''''''''''''''''''''''''''
On Error Resume Next
For WSNdx = LBound(WSArray) To UBound(WSArray)
    Err.Clear
    Set WS = Wb.Worksheets(WSArray(WSNdx))
    ''''''''''''''''''''''''''''''''''''''''
    ' Worksheet does not exist
    ''''''''''''''''''''''''''''''''''''''''
    If Err.Number <> 0 Then
        Exit Function
    End If
    Err.Clear
    Set r = Wb.Worksheets(WSArray(WSNdx)).Range(SearchAddress)
    If Err.Number <> 0 Then
        ''''''''''''''''''''''''''''''''''''
        ' Invalid Range. Get out.
        ''''''''''''''''''''''''''''''''''''
        Exit Function
    End If
Next WSNdx

''''''''''''''''''''''''''''''''''''''''
' SearchAddress is valid for all sheets.
' Call FindAll to search the range on
' each sheet.
''''''''''''''''''''''''''''''''''''''''
ReDim ResultRange(LBound(WSArray) To UBound(WSArray))
For WSNdx = LBound(WSArray) To UBound(WSArray)
    Set WS = Wb.Worksheets(WSArray(WSNdx))
    Set SearchRange = WS.Range(SearchAddress)
    Set FoundRange = FindAll(SearchRange:=SearchRange, _
                    FindWhat:=FindWhat, _
                    LookIn:=LookIn, LookAt:=LookAt, _
                    SearchOrder:=SearchOrder, _
                    MatchCase:=MatchCase, _
                    BeginsWith:=BeginsWith, _
                    EndsWith:=EndsWith)
    
    If FoundRange Is Nothing Then
        Set ResultRange(WSNdx) = Nothing
    Else
        Set ResultRange(WSNdx) = FoundRange
    End If
Next WSNdx

FindAllOnWorksheets = ResultRange

End Function
Attribute VB_Name = "modProgBar"
Option Explicit

Public Sub PercentCompleted(pctdone As Single, msg As String)
    With frmProgBar
        .lblCaption.Caption = CInt(pctdone * 100) & "% Complete"
        .lblProg.Width = pctdone * (.frameProg.Width)
        .lblMessage.Caption = msg
    End With
    DoEvents
End Sub

Attribute VB_Name = "modRibbon"
Option Explicit

Dim ribbonUI As IRibbonUI
Dim PressedState As Boolean

'*********************************
'Menu / Ribbon Button Actions
'*********************************
Public Sub onLoadNovaDB(Ribbon As IRibbonUI)
    Set ribbonUI = Ribbon
End Sub

Public Sub CallbackSettings(Optional control As Variant)
    frmLogin.Show
End Sub

Public Sub CallbackGetData(Optional control As Variant)
    If ActiveWorkbook Is Nothing Then
        MsgBox "Open a workbook!", vbCritical, APPTITLE
        Exit Sub
    End If
    frmGetData.Show
End Sub

Public Sub CallbackRefreshSheet(Optional control As Variant)
    If ActiveWorkbook Is Nothing Then
        MsgBox "Open a workbook!", vbCritical, APPTITLE
        Exit Sub
    End If
    RefreshSheet ActiveSheet, True
End Sub

Public Sub CallbackRefreshWorkbook(Optional control As Variant)
    If ActiveWorkbook Is Nothing Then
        MsgBox "Open a workbook!", vbCritical, APPTITLE
        Exit Sub
    End If
    RefreshWorkbook
End Sub

Public Sub CallbackRefreshStop(Optional control As Variant)
    If ActiveWorkbook Is Nothing Then
        MsgBox "Open a workbook!", vbCritical, APPTITLE
        Exit Sub
    End If
    If MsgBox("Refreshing process will stop, continue?", vbQuestion + vbYesNo, APPTITLE) = vbNo Then
        Exit Sub
    End If
    stopRefreshing = True
    MsgBox "Refreshing will stop after the current sheet is processed.", vbInformation, APPTITLE
End Sub

Public Sub CallbackAbout(Optional control As Variant)
    frmAbout.Show
End Sub
'
'Public Sub SpellButton(control As Variant, pressed As Boolean)
'    PressedState = pressed
'    SpellingState = Not PressedState
'    ribbonUI.InvalidateControl ("SpellButton")
'End Sub
'
'Public Sub DataFormButton(Optional control As Variant)
'    If Application.Workbooks.Count > 0 Then
'        frmOverlengthCheck.Show vbModeless
'    Else
'        MsgBox "Please open new or existing workbook first!", vbExclamation, APPTITLE
'    End If
'End Sub
'
'Public Sub PrevButton(Optional control As Variant)
'    If Application.Workbooks.Count > 0 Then
'        If ActiveCell.Row > 2 Then
'            If adoptClicked Then
'                adoptClicked = False
'                MsgBox "You didn't apply the adopted string!"
'                Exit Sub
'            End If
'            ActiveCell.Offset(SelectVisibleRow(-1), 0).Select
'        End If
'    Else
'        MsgBox "Please open new or existing workbook first!", vbExclamation, APPTITLE
'    End If
'End Sub
'
'Public Sub NextButton(Optional control As Variant)
'    If Application.Workbooks.Count > 0 Then
'        If ActiveCell.Row < ActiveSheet.Rows.Count Then
'            If adoptClicked Then
'                adoptClicked = False
'                MsgBox "You didn't apply the adopted string!"
'                Exit Sub
'            End If
'            ActiveCell.Offset(SelectVisibleRow(1), 0).Select
'        End If
'    Else
'        MsgBox "Please open new or existing workbook first!", vbExclamation, APPTITLE
'    End If
'End Sub
'
'Public Sub PostFirstButton(Optional control As Variant)
'    Dim found As Range
'    Dim wbName As String
'
'    wbName = ActiveWorkbook.Name
'    If Application.Workbooks.Count > 0 Then
'        GoToBlank dictLanguages(wbName).TargetLang.result, 1
'    Else
'        MsgBox "Please open new or existing workbook first!", vbExclamation, APPTITLE
'    End If
'End Sub
'
'Public Sub PostNextButton(Optional control As Variant)
'    Dim found As Range
'    Dim wbName As String
'
'    wbName = ActiveWorkbook.Name
'    If Application.Workbooks.Count > 0 Then
'        GoToBlank dictLanguages(wbName).TargetLang.result, ActiveCell.Row
'    Else
'        MsgBox "Please open new or existing workbook first!", vbExclamation, APPTITLE
'    End If
'End Sub
'
'Public Sub PostPrevButton(Optional control As Variant)
'    Dim found As Range
'    Dim wbName As String
'
'    wbName = ActiveWorkbook.Name
'    If Application.Workbooks.Count > 0 Then
'        GoToBlank dictLanguages(wbName).TargetLang.result, ActiveCell.Row, True
'    Else
'        MsgBox "Please open new or existing workbook first!", vbExclamation, APPTITLE
'    End If
'End Sub
'
'Public Sub ChangeTargetLanguage(Optional control As Variant)
'    frmTarget.Show
'End Sub
'
'Public Sub CallbackGetFileOpen(control As IRibbonControl, ByRef returnedVal)
'    returnedVal = (Application.Workbooks.Count > 0)
'End Sub
'
'Public Sub CallbackGetActiveAndLogin(control As IRibbonControl, ByRef returnedVal)
'    returnedVal = toolActive And Not (crtUser Is Nothing)
'End Sub
'
'Public Sub CallbackGetActive(control As IRibbonControl, ByRef returnedVal)
'    Select Case control.ID
'        Case "Activation"
'            returnedVal = Not toolActive
'        Case "Admin"
'            If Not (crtUser Is Nothing) Then
'                returnedVal = toolActive And (crtUser.User = "umeinz")
'            Else
'                returnedVal = False
'            End If
'        Case Else
'            returnedVal = toolActive
'    End Select
'
''    If control.ID = "Activation" Then
''        returnedVal = Not toolActive
''    Else
''        returnedVal = toolActive
''    End If
'End Sub
'
'Public Sub CallbackGetLogin(control As IRibbonControl, ByRef returnedVal)
'    Select Case control.ID
'        Case "LoginButton"
'            returnedVal = (crtUser Is Nothing)
'        Case "LogoutButton"
'            returnedVal = Not (crtUser Is Nothing)
'        Case "crtUser"
'            returnedVal = Not (crtUser Is Nothing)
'    End Select
'End Sub

Public Sub UpdateToolbar()
    ribbonUI.Invalidate
End Sub
'
'Public Sub ActivateButton(Optional control As Variant)
'    Dim response
'
'    response = MsgBox(APPTITLE & " will be activated for the active workbook. Are you sure?", vbQuestion + vbYesNo, APPTITLE)
'    If response = vbNo Then
'        Exit Sub
'    End If
'
'    CreateHiddenSheet ActiveWorkbook.Name
'    toolActive = True
'    ribbonUI.Invalidate
'End Sub
'
'Public Sub StatisticsButton(Optional control As Variant)
'
'    On Error GoTo StatisticsButton_Error
'
'    Dim wbName As String, crtSheet As Worksheet, statSheet As Worksheet, varLang As Variant
'    Dim postNo As Long, lastRow As Long, i As Integer
'
'    Application.ScreenUpdating = False
'    Set crtSheet = ActiveSheet
'    lastRow = ActiveSheet.Cells(ActiveSheet.Rows.Count, "A").End(xlUp).Row
'    wbName = ActiveWorkbook.Name
'    Set statSheet = ActiveWorkbook.Worksheets.Add
'    With statSheet
'        .Name = "Statistics"
'        .Cells.NumberFormat = "General"
'        .Range("A2").Value2 = "Confirmed (OK)"
'        .Range("A3").Value2 = "Corrected (NOK)"
'        .Range("A4").Value2 = "New translations (N/R)"
'        If dictLanguages.Count > 0 Then
'            If dictLanguages.Exists(wbName) Then
'                    i = 1
'                    For Each varLang In dictLanguages(wbName).OtherLang.Items
'                        If varLang.result <> "" Then
'                            i = i + 1
'                            .Cells(1, i).Value2 = varLang.Name
'                            .Cells(2, i).Value2 = Application.WorksheetFunction.CountIf(crtSheet.Range(varLang.result & "2:" & varLang.result & lastRow), "OK")
'                            .Cells(3, i).Value2 = Application.WorksheetFunction.CountIf(crtSheet.Range(varLang.result & "2:" & varLang.result & lastRow), "NOK")
'                            .Cells(4, i).Value2 = Application.WorksheetFunction.CountIf(crtSheet.Range(varLang.result & "2:" & varLang.result & lastRow), "TRA")
'                        End If
'                    Next
'            End If
'        End If
'        .Cells.Columns.AutoFit
'    End With
'    SaveWorksheetAsWorkbook statSheet, ActiveWorkbook.Path & Application.PathSeparator & "stats_" & wbName
'    Application.DisplayAlerts = False
'    statSheet.Delete
'    Application.EnableEvents = True
'    Application.DisplayAlerts = True
'
'    On Error GoTo 0
'    Exit Sub
'
'StatisticsButton_Error:
'
'    Application.EnableEvents = True
'    Application.DisplayAlerts = True
'    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure StatisticsButton of Sub modRibbon"
'
'End Sub
'
'Public Sub CheckActive(bActive As Boolean)
'    toolActive = bActive
'    If Not ribbonUI Is Nothing Then
'        ribbonUI.Invalidate
'    End If
'End Sub
'
'Public Sub CallbackGetLabel(control As IRibbonControl, ByRef returnedVal)
'    Dim wbName As String
'
'    Select Case control.ID
'        Case "crtUser"
'            If crtUser Is Nothing Then
'                returnedVal = "Hello"
'            Else
'                returnedVal = crtUser.Name
'            End If
'        Case "PostNo"
'            If Application.Workbooks.Count > 0 Then
'                returnedVal = GetEmptyRecords & vbCrLf & " records"
'            End If
'        Case "OriginalLanguage"
'            If Application.Workbooks.Count > 0 Then
'                wbName = ActiveWorkbook.Name
'                If dictLanguages.Count > 0 Then
'                    If dictLanguages.Exists(wbName) Then
'                        If Not IsEmpty(dictLanguages(wbName).TargetLang) Then
'                            returnedVal = "Target language" & vbCrLf & dictLanguages(wbName).TargetLang.Name
'                        End If
'                    End If
'                End If
'            End If
'        Case "SpellButton"
'            ' UM 01-11-17
'            If PressedState = False Then
'                returnedVal = "Spell check" & vbCrLf & GetLangName(Application.SpellingOptions.DictLang)
'            Else
'                returnedVal = "Spell check" & vbCrLf & "Off"
'            End If
'            'UM Ende
'    End Select
'End Sub
'
'Public Sub CallbackGetImage(control As IRibbonControl, ByRef returnedVal)
'    Dim wbName As String
'
'    Select Case control.ID
'        Case "SpellButton"
'            Select Case PressedState
'                Case False
'                    If Application.Workbooks.Count > 0 Then
'                        wbName = ActiveWorkbook.Name
'                        If dictLanguages.Count > 0 Then
'                            If dictLanguages.Exists(wbName) Then
'                                If Not IsEmpty(dictLanguages(wbName).TargetLang) Then
'                                    If GetLangID(dictLanguages(wbName).TargetLang.Name) = Application.SpellingOptions.DictLang Then
'                                        returnedVal = "GroupProofing"
'                                    Else
'                                        'UM 01-11-17
'                                        returnedVal = "Risks"
'                                        ' UM Ende
'                                    End If
'                                End If
'                            End If
'                        End If
'                    End If
'                Case True
'                    returnedVal = "TextSmallCaps"
'            End Select
'    End Select
'End Sub
'
'Public Sub UpdateCrtUserLabel()
'    If ribbonUI Is Nothing Then
'        MsgBox "An error occured, please save your work and restart Excel!", vbExclamation
'        Exit Sub
'    End If
'    ribbonUI.Invalidate
'End Sub
'
'Public Sub UpdatePostNoLabel()
'    If ribbonUI Is Nothing Then
'        MsgBox "An error occured, please save your work and restart Excel!", vbExclamation
'        Exit Sub
'    End If
'    ribbonUI.InvalidateControl ("PostNo")
'End Sub
'
'Public Sub UpdateLanguageLabel()
'    If ribbonUI Is Nothing Then
'        MsgBox "An error occured, please save your work and restart Excel!", vbExclamation
'        Exit Sub
'    End If
'    ribbonUI.Invalidate
'End Sub
Attribute VB_Name = "modUtils"
Option Explicit

Public Const APPTITLE = "Nova-DB Excel-Add-In"
Public Const LOGINSECTION = "Login"

Public Sub InitAddinVariables()
    API_URL_BASE = "https://nova-db.com/api/v1/"
    GetUserFromSettings
End Sub

Public Function Base64Encode(inData) As String
    Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    Dim sOut As String, i As Integer
    
    'For each group of 3 bytes
    For i = 1 To Len(inData) Step 3
        Dim nGroup, pOut
        
        'Create one long from this 3 bytes.
        nGroup = &H10000 * Asc(Mid(inData, i, 1)) + &H100 * MyASC(Mid(inData, i + 1, 1)) + MyASC(Mid(inData, i + 2, 1))
        
        'Oct splits the long To 8 groups with 3 bits
        nGroup = Oct(nGroup)
        
        'Add leading zeros
        nGroup = String(8 - Len(nGroup), "0") & nGroup
        
        'Convert To base64
        pOut = Mid(Base64, CLng("&o" & Mid(nGroup, 1, 2)) + 1, 1) + Mid(Base64, CLng("&o" & Mid(nGroup, 3, 2)) + 1, 1) + Mid(Base64, CLng("&o" & Mid(nGroup, 5, 2)) + 1, 1) + _
            Mid(Base64, CLng("&o" & Mid(nGroup, 7, 2)) + 1, 1)
        
        'Add the part To OutPut string
        sOut = sOut + pOut
    Next
    Select Case Len(inData) Mod 3
        Case 1: '8 bit final
            sOut = Left(sOut, Len(sOut) - 2) + "=="
        Case 2: '16 bit final
            sOut = Left(sOut, Len(sOut) - 1) + "="
    End Select
    Base64Encode = sOut
End Function

Private Function MyASC(OneChar)
    If OneChar = "" Then MyASC = 0 Else MyASC = Asc(OneChar)
End Function

Public Sub GetUserFromSettings()
    Dim userName As String, pass As String
    
    userName = GetSetting(APPTITLE, LOGINSECTION, "User")
    pass = GetSetting(APPTITLE, LOGINSECTION, "Pass")
    If userName <> "" And pass <> "" Then
        Set crtUser = New clsUser
        crtUser.User = userName
        crtUser.Password = pass
    End If
End Sub

Public Function IsUserLoggedIn() As Boolean
    IsUserLoggedIn = False
    If Not crtUser Is Nothing Then
        If crtUser.Token <> "" Then
            IsUserLoggedIn = True
        End If
    End If
End Function

Public Function GetUniqueValues(rng As Range, colNo As Integer) As Dictionary
    Dim data(), unique As Dictionary, i As Long
    
    data = rng.value
    
    Set unique = New Dictionary
    For i = 1 To UBound(data)
        unique(data(i, colNo)) = Empty
    Next
    Set GetUniqueValues = unique
End Function

Public Function CollectionSorted(col As Collection, psSortPropertyName As String, pbAscending As Boolean, Optional psKeyPropertyName As String) As Collection
    Dim obj As Object
    Dim i As Integer
    Dim j As Integer
    Dim iMinMaxIndex As Integer
    Dim vMinMax As Variant
    Dim vValue As Variant
    Dim bSortCondition As Boolean
    Dim bUseKey As Boolean
    Dim sKey As String
    
    bUseKey = (psKeyPropertyName <> "")
    
    For i = 1 To col.Count - 1
        Set obj = col(i)
        vMinMax = CallByName(obj, psSortPropertyName, VbGet)
        iMinMaxIndex = i
        
        For j = i + 1 To col.Count
            Set obj = col(j)
            vValue = CallByName(obj, psSortPropertyName, VbGet)
            
            If (pbAscending) Then
                bSortCondition = (vValue < vMinMax)
            Else
                bSortCondition = (vValue > vMinMax)
            End If
            
            If (bSortCondition) Then
                vMinMax = vValue
                iMinMaxIndex = j
            End If
            
            Set obj = Nothing
        Next j
        
        If (iMinMaxIndex <> i) Then
            Set obj = col(iMinMaxIndex)
            
            col.Remove iMinMaxIndex
            If (bUseKey) Then
                sKey = CStr(CallByName(obj, psKeyPropertyName, VbGet))
                col.Add obj, sKey, i
            Else
                col.Add obj, , i
            End If
            
            Set obj = Nothing
        End If
        
        Set obj = Nothing
    Next i
    Set CollectionSorted = col
End Function


' InQuest injected base64 decoded content
' K+-zd
' xZ+-

INQUEST-PP=macro
