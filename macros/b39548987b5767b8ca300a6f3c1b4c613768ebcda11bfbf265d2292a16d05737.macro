Attribute VB_Name = "CodeFH"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Mnemo As String
Public code As String

Attribute VB_Name = "CodesPrestations"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private m_collCodesPrestations As Collection


Public Function addCodes(strMnemonique As String, strCodeFH As String) As String
    Dim tmpCode As New CodeFH
    tmpCode.Mnemo = strMnemonique
    tmpCode.code = strCodeFH
    
    If existeCode(strMnemonique) Then
        addCodes = "Code " & strMnemonique & " d|fffd|j|fffd| connu. Valeur """ & strCodeFH & """ ignor|fffd|e."
    Else
        m_collCodesPrestations.Add tmpCode, strMnemonique
        addCodes = ""
    End If
    
End Function

Private Sub Class_Initialize()
    Set m_collCodesPrestations = New Collection
End Sub

Public Property Get CodeFH(strMnemonique As String) As String
    Dim tmpVar As Variant
    Dim tmpCode As CodeFH
    
    If existeCode(strMnemonique) Then
        For Each tmpVar In m_collCodesPrestations
            Set tmpCode = tmpVar
            If tmpCode.Mnemo = strMnemonique Then
                CodeFH = tmpCode.code
                Exit For
            End If
        Next
    Else
        CodeFH = ""
    End If
End Property
'
Private Function existeCode(strMnemonique As String) As Boolean
    Dim retVal As Boolean
    Dim tmpVar As Variant
    Dim tmpCode As CodeFH
    
    retVal = False
    For Each tmpVar In m_collCodesPrestations
        Set tmpCode = tmpVar
        If tmpCode.Mnemo = strMnemonique Then
            retVal = True
            Exit For
        End If
    Next
    
    existeCode = retVal
End Function


Public Sub chargerCodesDeFeuille(ByRef wksCodes As Worksheet, ByRef logElem As Logger)
    Dim lngLigne As Long
    Dim tmpRet As String
    
    lngLigne = 4
    While Len(Trim(wksCodes.Cells(lngLigne, 1))) > 0
        tmpRet = Me.addCodes(UCase(Trim(wksCodes.Cells(lngLigne, 1))), Trim(wksCodes.Cells(lngLigne, 3)))
        If Len(tmpRet) > 0 Then
            logElem.ajoutWarning "chargerCodesDeFeuille", tmpRet
        End If
        lngLigne = lngLigne + 1
    Wend
End Sub
Attribute VB_Name = "Contrat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Classe : Contrat
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Permettre la g|fffd|n|fffd|ration du fichier XML "Interface Prestations" sur base des informations m|fffd|moris|fffd|es
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    15.06.2015    | Version initiale
'

'Impl|fffd|mente l'interface IScript
Implements IContrat


Private strRefContrat As String
Private blnDefini As Boolean
Private plaPlanning As IPlanning
Private collScripts As Collection
Private blnRefPointeuseDefinie As Boolean


Private Sub Class_Initialize()
    strRefContrat = ""
    blnDefini = False
    Set plaPlanning = New Planning
    Set collScripts = New Collection
    blnRefPointeuseDefinie = False
End Sub

'#UnitTestOK
Public Property Get IContrat_estDefini() As Boolean
    IContrat_estDefini = blnDefini
End Property

Private Property Get IContrat_estDefinieReferencePointeuse() As Boolean
    IContrat_estDefinieReferencePointeuse = blnDefini And blnRefPointeuseDefinie
End Property

'#UnitTestOK
Private Function IContrat_estIdentique(objOth As IContrat) As Boolean
    Dim retVal As Boolean
    Dim scr As IScript, refInt As IRefInterne
    Dim collOthScript As Collection
    Dim othScr As IScript
    
    retVal = True
    
    If Me.IContrat_estDefini = objOth.estDefini Then
        'uniquement si contrat d|fffd|fini
        If blnDefini Then
            If strRefContrat = objOth.ReferencePointeuse Then
                'Test du planning et des rubriques
                If Not plaPlanning.estIdentique(objOth.Prestations) Then
                    retVal = False
                End If
                'Test sur les rubriques
                If retVal Then
                    If collScripts.Count = objOth.CodesDivers.Count Then
                    'Comparer une |fffd| une (! ordre important)
                        Set collOthScript = objOth.CodesDivers
                        For Each scr In collScripts
                            If retVal Then
                                If estDansRubriques(scr.CodeRubrique, collOthScript) Then
                                    Set refInt = scr
                                    Set othScr = collOthScript.Item(refInt.referenceInterne)
                                    retVal = scr.estIdentique(othScr)
                                Else
                                    retVal = False
                                End If
                            End If
                        Next
                    Else
                        retVal = False
                    End If
                End If
            Else
                retVal = False
            End If
        End If
    Else
        retVal = False
    End If
    
    IContrat_estIdentique = retVal
End Function

'Propri|fffd|t|fffd| : r|fffd|f|fffd|rence de pointeuse. Identifiant du biniou
'#UnitTestOK
Public Property Get IContrat_ReferencePointeuse() As String
    IContrat_ReferencePointeuse = IIf(blnDefini And blnRefPointeuseDefinie, strRefContrat, "")
End Property

'Donn|fffd|e membre : les prestations li|fffd|es au contrat
'#UnitTestOK
Public Property Get IContrat_Prestations() As IPlanning
    Set IContrat_Prestations = plaPlanning
End Property

'Donn|fffd|e membre : les codes divers li|fffd|s au contrat
'#UnitTestOK
Public Property Get IContrat_CodesDivers() As Collection
    Set IContrat_CodesDivers = collScripts
End Property


'#UnitTestOK
Public Function IContrat_definirContrat(Optional strReferencePointeuse As String = "") As Boolean
    Dim retVal As Boolean
    retVal = True
    If Len(Trim(strReferencePointeuse)) > 0 Then
        strRefContrat = strReferencePointeuse
        blnRefPointeuseDefinie = True
    End If
    
    blnDefini = retVal
    IContrat_definirContrat = retVal
End Function

'#UnitTestOK
Public Function IContrat_ajouterPrestation(dtDate As Date, strCodePrestation As String, dblNbHeures As Double, blnIndicateurPNuit As Boolean, blnIndicateurPEquipe As Boolean) As Boolean
    Dim retVal As Boolean
    retVal = True
    
    If blnDefini Then
        If plaPlanning.estDefini Then
            'test si p|fffd|riode correspond
            retVal = (plaPlanning.PeriodePaie = Format(dtDate, "YYYYMM"))
        Else
            retVal = plaPlanning.definirPeriodePaie(Year(dtDate), Month(dtDate))
        End If
        If retVal Then
            retVal = plaPlanning.ajouterPrestation(Day(dtDate), strCodePrestation, dblNbHeures, blnIndicateurPNuit, blnIndicateurPEquipe)
        End If
    Else
        retVal = False
    End If
    
    IContrat_ajouterPrestation = retVal
End Function

'Retourne Faux si :
' r|fffd|f|fffd|rence contrat non d|fffd|finie
' ou si une rubrique avec le m|fffd|me code existe d|fffd|j|fffd|
'#UnitTestOK
Public Function IContrat_ajouterRubrique(enumRubrique As RubriqueScripts, strCodeRubrique As String, dblNbRubrique As Double) As Boolean
    Dim retVal As Boolean
    Dim scr As IScript
    Dim strRef As String
    Dim refInt As IRefInterne
    
    retVal = False
    If blnDefini Then
        If Not estDansRubriques(strCodeRubrique, collScripts) Then
            Set scr = New Script
            retVal = scr.definirDonneesRubrique(enumRubrique, strCodeRubrique, dblNbRubrique)
        End If
    End If
    If retVal Then
        ' => scr est d|fffd|fini et l'ajout des donn|fffd|es est ok. On peut ajouter |fffd| la collection
        strRef = C_PREFIX_SCRIPT & strCodeRubrique
        Set refInt = scr
        refInt.referenceInterne = strRef
        collScripts.Add scr, strRef
    End If
    
    IContrat_ajouterRubrique = retVal
End Function

'#UnitTestOK via ajout de rubrique
Private Function estDansRubriques(strCodeRubrique As String, ByRef currColl As Collection) As Boolean
    Dim retVal As Boolean
    Dim scr As IScript
    
    retVal = False
    
    For Each scr In currColl
        If scr.CodeRubrique = strCodeRubrique Then retVal = True
    Next
    
    estDansRubriques = retVal
    
End Function
Attribute VB_Name = "Feuil6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Figeage"
Public Sub FigeageFormulesReferences(Optional blnModeInteractif As Boolean = True, Optional ByRef wksTgt As Worksheet = Nothing)
    Dim rg As Range
    Dim dtTest As Date
    
    If wksTgt Is Nothing Then
        Set wksTgt = ActiveSheet
    Else
        wksTgt.Activate
    End If
    
    If estNomDeMois(wksTgt.Name, dtTest) Then
        
        If blnModeInteractif Then
            If MsgBox("Un certain nombre de formules pr|fffd|sentes dans cette feuille - et uniquement cette feuille - seront remplac|fffd|es par leurs valeurs. Ceci aura pour effets :" & vbCrLf & _
                   " => de diminuer la charge de calcul sur votre ordinateur;" & vbCrLf & _
                   " => de dissocier la feuille active de l'horaire par d|fffd|faut pr|fffd|vu dans la feuille 'GH-Travailleurs' (pour permettre la gestion de l'|fffd|volution de l'horaire dans le temps);" & vbCrLf & _
                   " => de d|fffd|sactiver compl|fffd|tement les calculs de couverture horaire (seconde partie du tableau);" & vbCrLf & _
                   " => de modifier la couleur de l'ent|fffd|te du tableau (fond gris au lieu de bleu)." & vbCrLf & vbCrLf & _
                   "Cependant, vous conserverez la possibilit|fffd| de modifier les prestations a posteriori, avec prise en compte dans les feuilles d|fffd|pendantes et les r|fffd|capitulatifs." & vbCrLf & vbCrLf & _
                   "Cette fonctionnalit|fffd| ne devrait |fffd|tre r|fffd|alis|fffd|e que sur des feuilles situ|fffd|es dans le pass|fffd|." & vbCrLf & vbCrLf & _
                   "ATTENTION : Il ne sera pas possible d'annuler cette action !" & vbCrLf & vbCrLf & _
                   "|fffd|tes-vous certain(e) de vouloir proc|fffd|der |fffd| ce figeage ?", vbExclamation + vbYesNo, "Figeage de formules") = vbNo Then
                Exit Sub
            End If
        End If
        
        UCM_Unprotect
        wksTgt.EnableCalculation = False
        Application.ScreenUpdating = False
        
        EnleverFormulesGrilleHoraire wksTgt
        EnleverFormulesRecapitulatifCouverture wksTgt
        DefinirCouleurEnTete wksTgt
        
        wksTgt.Outline.ShowLevels , 1
        
        Application.CutCopyMode = False
        Application.ScreenUpdating = True
        
        With wksTgt.Range("E4")
            .Select
            .Activate
        End With
        UCM_Protect
    Else
        If blnModeInteractif Then
            MsgBox "Cette fonctionnalit|fffd| n'est disponible que sur les feuilles de prestations.", vbInformation + vbOKOnly, "Figeage de formules"
        End If
    End If
End Sub



Private Sub DefinirCouleurEnTete(ByRef wksTgt As Worksheet)
    Dim rgEnd As Range
    Dim rgSel As Range
    
    wksTgt.Range("A1").Activate
    
    Set rgEnd = Cells.Find(What:="Heures Supp. APRES", After:=ActiveCell, SearchOrder:=xlByRows)
    Set rgSel = Range(wksTgt.Cells(1, 1), wksTgt.Cells(3, rgEnd.Column))
    
    With rgSel.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorDark2
        .TintAndShade = INT_TEINTE_FIGE
        .PatternTintAndShade = 0
    End With
End Sub



Private Sub EnleverFormulesGrilleHoraire(ByRef wksTgt As Worksheet)
    Dim lngColonne As Long, lngLigne As Long, lngLigneMax As Long
    Dim rg As Range
    
    lngLigne = 3
    lngColonne = 6
    lngLigneMax = 4
    
    While Len(Trim(wksTgt.Cells(lngLigneMax, 2))) > 0
        lngLigneMax = lngLigneMax + 3
    Wend
    
    Set rg = wksTgt.Cells(lngLigne, lngColonne)
    While Len(rg.MergeArea.Cells(1, 1).Value) > 0
        If UCase(rg.MergeArea.Cells(1, 1)) = "CODE" Or UCase(rg.Cells(1, 1)) = "DE" Or UCase(rg.Cells(1, 1)) = "A" Then
            wksTgt.Range(wksTgt.Cells(lngLigne, lngColonne), wksTgt.Cells(lngLigneMax, lngColonne)).Select
            Selection.Copy
            Selection.PasteSpecial xlPasteValues
            DoEvents
        End If
    
        lngColonne = lngColonne + 1
        Set rg = wksTgt.Cells(lngLigne, lngColonne)
    Wend
End Sub


Private Sub EnleverFormulesRecapitulatifCouverture(ByRef wksTgt As Worksheet)
    Dim lngLigne As Long, lngLigneMax As Long
    Dim rg As Range
    
    lngLigne = 3
    lngLigneMax = 4
    
    While Len(Trim(wksTgt.Cells(lngLigneMax, 2))) > 0
        lngLigneMax = lngLigneMax + 3
    Wend
    
    lngLigneMax = lngLigneMax + 2
    
    Set rg = wksTgt.Rows(lngLigneMax & ":" & lngLigneMax + 30)
    
    rg.Copy
    rg.PasteSpecial xlPasteValues
    
    
End Sub

Attribute VB_Name = "GLOB_GestionGHT"
Public Type InfosPrestations
    AM_Code As String
    AM_Deb As Double
    AM_Fin As Double
    PM_Code As String
    PM_Deb As Double
    PM_Fin As Double
End Type


Public Type ReferencesCellulesPrestations
    AM_Code As String
    AM_Deb As String
    AM_Fin As String
    PM_Code As String
    PM_Deb As String
    PM_Fin As String
End Type

Public Enum JourSemaine
    lundi = 1
    mardi
    mercredi
    jeudi
    vendredi
    samedi
    dimanche
End Enum

Public Enum TypeInfosPrestations
    CodePrestation_Matin
    HeureDebutPrestation_Matin
    HeureFinPrestation_Matin
    CodePrestation_Aprem
    HeureDebutPrestation_Aprem
    HeureFinPrestation_Aprem
End Enum

Public Function libJour(nbJ As JourSemaine) As String
    Select Case nbJ
        Case lundi
            libJour = "Lundi"
        Case mardi
            libJour = "Mardi"
        Case mercredi
            libJour = "Mercredi"
        Case jeudi
            libJour = "Jeudi"
        Case vendredi
            libJour = "Vendredi"
        Case samedi
            libJour = "Samedi"
        Case dimanche
            libJour = "Dimanche"
    End Select
End Function




Public Sub testGHT(Optional blnDoNotShowMe As Boolean = True)
    Dim gh As New GrillesHoraires
    
    gh.ChargerGrillesAPartirDeFeuille ActiveSheet
    
End Sub
Attribute VB_Name = "GLOB_GestionRepertoires"
Option Explicit

'
'
' Module : GestionRepertoires
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
'**********
'  D|fffd|finir, de mani|fffd|re standardis|fffd|e, les r|fffd|pertoires de travail et de destination des fichiers d'interface Prestations
'
' Auteur
'********
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale  | Usage
' --------------------------------------+-------------------+--------------------------------------
'  Logger                               | 1.0               | Gestion du logging d'informations
'
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.0      |    10.06.2015    | Version initiale
'  1.1      |    30.06.2015    | Ajout gestion logging
'


' D|fffd|clarations n|fffd|cessaires pour pouvoir obtenir le r|fffd|pertoire "Mes Documents"
Private Declare Function lstrlenW Lib "kernel32" (ByVal lpString As Long) As Long

Private Declare Function SHGetFolderPath Lib "shfolder.dll" Alias "SHGetFolderPathA" _
     (ByVal hwndOwner As Long, ByVal nFolder As Long, ByVal hToken As Long, ByVal dwReserved As Long, ByVal lpszPath As String) As Long


' ForcerClient : si contient qq chose : force le comportement comme si on |fffd|tait un client
' Vide : traitement sur base UCM
Public Const forcerClient As String = ""


' Fonction : definirRepertoiresTravail
'
' Permet de d|fffd|finir les r|fffd|pertoires de travail de la macro en fonction des r|fffd|gles suivantes :
' Utilisateur SSA :
'     sous P:\SS\Support\Succu\Intersuccu\Automatisation\<no_dossier>\[...]
' Autres utilisateurs :
'     sous <Mes Documents Utilisateur>\UCM-Automatisation\[...]
'
'  En entr|fffd|e :
'       * le num|fffd|ro de dossier
'       * trois variables pour la m|fffd|morisation des r|fffd|pertoires manipul|fffd|s
'  En sortie :
'       * n|fffd|ant
'  Effets de bord :
'       * les trois variables de r|fffd|pertoire sont compl|fffd|t|fffd|es de mani|fffd|re ad hoc
'
' Usage :
'    1. d|fffd|finir quatre variables de type String
'
'    Dim strNoDossier As String
'    Dim strRepTravail As String
'    Dim strRepArchive As String
'    Dim strRepEnvoi As String
'
'    2. compl|fffd|ter le num|fffd|ro de dossier
'
'    strNoDossier = ....
'
'    3. appeler la fonction definirRepertoiresTravail avec les param|fffd|tres ad|fffd|quats
'
'    definirRepertoiresTravail strNoDossier, strRepTravail, strRepArchive, strRepEnvoi
'

'Public Sub definirRepertoiresTravail(ByVal strNoDossier As String, _
'                                      ByRef strRepTravail As String, _
'                                      ByRef strRepArchive As String, _
'                                      ByRef strRepEnvoi As String, _
'                                      Optional ByRef log As Logger)
'    If estPosteDeTravailUCM Then
'        If Not log Is Nothing Then log.ajoutDebug "definirRepertoiresTravail", "Poste de travail : UCM"
'        definirPathUCM strNoDossier, strRepTravail, strRepArchive, strRepEnvoi
'    Else
'        If Not log Is Nothing Then log.ajoutDebug "definirRepertoiresTravail", "Poste de travail : hors UCM"
'        definirPathClient strRepTravail, strRepArchive, strRepEnvoi
'    End If
'    If Not log Is Nothing Then
'        log.ajoutDebug "definirRepertoiresTravail", "R|fffd|pertoire de travail : " & strRepTravail
'        log.ajoutDebug "definirRepertoiresTravail", "R|fffd|pertoire d'envoi    : " & strRepEnvoi
'        log.ajoutDebug "definirRepertoiresTravail", "R|fffd|pertoire archivage  : " & strRepArchive
'    End If
'End Sub

'D|fffd|finit les r|fffd|pertoires de travail en mode "UCM"
Private Sub definirPathUCM(ByVal strNoDossier As String, _
                           ByRef strRepTravail As String, _
                           ByRef strRepArchive As String, _
                           ByRef strRepEnvoi As String)
    strRepTravail = "\\100S011\INTERSIEGES\SS\Succu\Intersuccu\Automatisation\" & strNoDossier & "\"
    strRepArchive = strRepTravail & "trait|fffd|s\"
    strRepEnvoi = strRepTravail & "envoi\"
    
    creerRepertoires strRepTravail, strRepArchive, strRepEnvoi
End Sub


'D|fffd|finit les r|fffd|pertoires de travail en mode "Client"
'Private Sub definirPathClient(ByRef strRepTravail As String, _
'                              ByRef strRepArchive As String, _
'                              ByRef strRepEnvoi As String)
'    strRepTravail = parametresMacroUCM.RepertoireBase
'    strRepArchive = strRepTravail & "trait|fffd|s\"
'    strRepEnvoi = strRepTravail & "envoi\"
'    strRepTravail = strRepTravail & "en_cours\"
'    creerRepertoires strRepTravail, strRepArchive, strRepEnvoi
'End Sub

''Fonction creerRepertoires
'Cr|fffd|e les r|fffd|pertoires de travail si ceux-ci n'existent pas
' Input : 3 variables globales : strRepTravail, strRepArchive et strRepEnvoi
Private Sub creerRepertoires(ByVal strRepTravail As String, _
                             ByVal strRepArchive As String, _
                             ByVal strRepEnvoi As String)
    'Cr|fffd|ation si non existants
    If Dir(strRepTravail, vbDirectory) = "" Then MkDir strRepTravail
    If Dir(strRepArchive, vbDirectory) = "" Then MkDir strRepArchive
    If Dir(strRepEnvoi, vbDirectory) = "" Then MkDir strRepEnvoi
End Sub


''Fonction : estPosteDeTravailUCM
' Input : n|fffd|ant
' output : Bool|fffd|en : Vrai si le poste de travail est un poste UCM
'                    Faux dans le cas contraire
' La d|fffd|termination du poste de travail UCM se base sur la pr|fffd|sence du domaine INTRA, g|fffd|r|fffd| par le DNS INTRA.PME-NET.NET
Public Function estPosteDeTravailUCM(Optional blnBypassForce As Boolean = False) As Boolean
    Dim blnDom As Boolean, blnDns As Boolean
    
    If blnBypassForce Then
        blnDom = IIf(Environ("UserDomain") = "INTRA", True, False)
        blnDns = IIf(Environ("UserDnsDomain") = "INTRA.PME-NET.NET", True, False)
    Else
        blnDom = IIf(Environ("UserDomain") = "INTRA" & forcerClient, True, False)
        blnDns = IIf(Environ("UserDnsDomain") = "INTRA.PME-NET.NET" & forcerClient, True, False)
    End If
    'D|fffd|sactiver le commentaire False pour valider les traitements en local
    estPosteDeTravailUCM = blnDom And blnDns 'And False
End Function


 

'' Fonction pour lire le nom du r|fffd|pertoire "Mes Documents" de l'utilisateur connect|fffd|.
Public Function lectureMesDocuments()
     Dim sBuffer As String
     sBuffer = Space$(260)
     If SHGetFolderPath(&H0, &H5, -1, &H0, sBuffer) = 0 Then
         lectureMesDocuments = Left$(sBuffer, lstrlenW(StrPtr(sBuffer)))
     End If
End Function




Attribute VB_Name = "GLOB_JoursFeries"
Option Explicit

'
'
'
'   Calcul des jours f|fffd|ri|fffd|s belges
'
'
'

'Fonction : estFerie
'Param|fffd|tres :
'      dtTest : date sur laquelle le test doit |fffd|tre r|fffd|alis|fffd|
'      strDescFerie : chaine de caract|fffd|re qui, dans le cas o|fffd| le jour est f|fffd|ri|fffd|, donne la description textuelle du jour f|fffd|ri|fffd|
'Valeur de retour :
'      bool|fffd|en : Vrai si la dtTest en param|fffd|tre correspond |fffd| un jour f|fffd|ri|fffd| belge
'
' Sont f|fffd|ri|fffd|s :
' Jours fixes
'      1er janvier : jour de l'an
'      1er mai : F|fffd|te du Travail
'      21 juillet : F|fffd|te Nationale
'      15 ao|fffd|t : Assomption
'      1er Novembre : Toussaint
'      11 Novembre : Armistice 14-18
'      25 D|fffd|cembre : No|fffd|l
' Jours variables :
'      D|fffd|termination selon la date de P|fffd|ques : algorithme de Carter pour les ann|fffd|es sup|fffd|rieures |fffd| 1900
'      Lundi de P|fffd|ques : P|fffd|ques + 1 jour
'      Ascension : P|fffd|ques + 39 jours
'      Lundi de Pentec|fffd|te : P|fffd|ques + 50 jours
'
Public Function estFerie(dtTest As Date, ByRef strDescFerie As String) As Boolean
    Dim intJJ As Long, intMM As Long, intAA As Long
    Dim blnRetVal As Boolean
    Dim dtPaques As Date
    
    blnRetVal = False
    intJJ = Day(dtTest)
    intMM = Month(dtTest)
    intAA = Year(dtTest)
    strDescFerie = ""
    'Check des valeurs fixes
    Select Case intMM
        Case 1
            If intJJ = 1 Then
                blnRetVal = True  'Jour de l'an
                strDescFerie = "Jour de l'An"
            End If
            
        Case 5
            If intJJ = 1 Then
                blnRetVal = True  'F|fffd|te du Travail
                strDescFerie = "F|fffd|te du Travail"
            End If
        Case 7
            If intJJ = 21 Then
                blnRetVal = True  'F|fffd|te Nationale
                strDescFerie = "F|fffd|te Nationale"
            End If
        Case 8
            If intJJ = 15 Then
                blnRetVal = True  'Assomption
                strDescFerie = "Assomption"
            End If
        Case 11
            If intJJ = 1 Then
                blnRetVal = True  'Toussaint
                strDescFerie = "Toussaint"
            End If
            If intJJ = 11 Then
                blnRetVal = True  'Armistice 14-18
                strDescFerie = "Armistice 14-18"
            End If
        Case 12
            If intJJ = 25 Then
                blnRetVal = True 'No|fffd|l
                strDescFerie = "No|fffd|l"
            End If
    End Select
    
    
    'Check des valeurs variables
    dtPaques = Paques(intAA)
    'Lundi de P|fffd|ques
    If dtTest = DateAdd("d", 1, dtPaques) Then
        blnRetVal = True
        strDescFerie = "Lundi de P|fffd|ques"
    End If
    'Ascension
    If dtTest = DateAdd("d", 39, dtPaques) Then
        blnRetVal = True
        strDescFerie = "Ascension"
    End If
    'Lundi de pentec|fffd|te
    If dtTest = DateAdd("d", 50, dtPaques) Then
        blnRetVal = True
        strDescFerie = "Lundi de Pentec|fffd|te"
    End If
    
    estFerie = blnRetVal
End Function


Public Function Paques(ByVal lngAnnee As Long) As Date
 'Calcul de la date du dimanche de P|fffd|ques |fffd| partir de l'ann|fffd|e 325
 'Performance par million d'appel :
 '   - Entre 325 et 1582 et entre 1900 et 2099   => 1/4 de seconde
 '   - Ann|fffd|e sup|fffd|rieure |fffd| 1582 hors 1900 - 2099 => 1/2 de seconde
 'Philben - v1.0 - Free to use
    
    Dim a As Long, b As Long, c As Long, d As Long, e As Long, f As Long
    
    If lngAnnee < 10000 Then    'Limite sup|fffd|rieure des dates sous Access (31 d|fffd|cembre 9999)
        Select Case lngAnnee
            Case 1900 To 2099    'Algorithme de Carter
                a = (204 - 11 * (lngAnnee Mod 19)) Mod 30 + 22
                Paques = DateSerial(lngAnnee, 3, a + 6 + (a > 49) - (lngAnnee + lngAnnee \ 4 + a + (a > 49)) Mod 7)
            Case Is > 1582    'Propos|fffd| en 1876 dans la revue Nature (d|fffd|riv|fffd| de l'algorithme de Delambre)
                a = lngAnnee Mod 19: b = lngAnnee \ 100: c = lngAnnee Mod 100
                d = (19 * a + b - b \ 4 - (b - (b + 8) \ 25 + 1) \ 3 + 15) Mod 30
                e = (32 + 2 * (b Mod 4) + 2 * (c \ 4) - d - c Mod 4) Mod 7
                f = d + e - 7 * ((a + 11 * d + 22 * e) \ 451) + 114
                Paques = DateSerial(lngAnnee, f \ 31, f Mod 31 + 1)
            Case Is > 324    'Algorithme de Oudin pour les dates juliennes < 1583 d|fffd|crit par Claus Tondering
                a = (19 * (lngAnnee Mod 19) + 15) Mod 30
                Paques = DateSerial(lngAnnee, 3, 28 + a - (lngAnnee + lngAnnee \ 4 + a) Mod 7)
        End Select
    End If
 End Function
Attribute VB_Name = "GLOB_MainModule"
'Option Explicit
'
'Public strTimeStamp As String
'
'Public Sub GestionCompleteFichierPrestations()
'    Dim logElem As Logger
'    Dim wkbLog As Workbook
'    Dim wksPrest As Worksheet
'    Dim strFuncName As String
'    Dim uFormRes As usrFormResultatTraitement
'    Dim strRepTravail As String, strRepArchive As String, strRepEnvoi As String
'    Dim strFileNameLog As String
'    Dim strMsgFinalErr As String
'
'
'    'On s'assure de prendre en compte les modifications |fffd|ventuelles des param|fffd|tres
'   ' ThisWorkbook.ResetParams
'
'    strTimeStamp = Format(Now, "YYYY-MM-DD_hhmmss")
'    strFuncName = "GestionCompleteFichierPrestations"
'
'    'M|fffd|moriser feuille en cours
'    Set wksPrest = ActiveSheet
'
'    'On s'assure |fffd|tre sur la feuille |fffd| traiter
'    If MsgBox("G|fffd|n|fffd|rer les prestations du mois " & wksPrest.Name & " pour le dossier " & parametresMacroUCM.NomDossier & " ?", vbYesNo + vbQuestion, "Confirmation de traitement") = vbYes Then
'        'Cr|fffd|ation UserForm R|fffd|sultat
'        Set uFormRes = New usrFormResultatTraitement
'
'        'Cr|fffd|ation du logger
'        Set logElem = New Logger
'        Set wkbLog = Workbooks.Add
'
'        logElem.creerFeuilleLog "Log " & strTimeStamp, wkbLog
'        logElem.ajoutInfo strFuncName, "Initialisation du m|fffd|canisme de logging."
'
'        'Rattacher le user Form R|fffd|sultat au log pour lier les |fffd|critures d'informations
'        Set logElem.userFormResultat = uFormRes
'
'        'D|fffd|termination des r|fffd|pertoires de traitement
'        '(une fois le log d|fffd|fini, chaque commentaire devrait |fffd|tre |fffd|galement inscrit
'        ' dans le log en forme info ou debug)
'        logElem.ajoutDebug strFuncName, "D|fffd|termination des r|fffd|pertoires de traitement."
'        definirRepertoiresTravail parametresMacroUCM.NumeroDossier, strRepTravail, strRepArchive, strRepEnvoi, logElem
'
'        strFileNameLog = "LOG_" & strTimeStamp & ".xlsx"
'        logElem.ajoutDebug strFuncName, "Nom du log g|fffd|n|fffd|r|fffd| : " & strFileNameLog
'
'        wksPrest.Parent.Activate
'        wksPrest.Activate
'
'        logElem.ajoutDebug strFuncName, "Ex|fffd|cution traitement de transformation"
'        If transformationExcelVersPlat(logElem, wksPrest, strRepTravail) Then
'            logElem.ajoutDebug strFuncName, "Ex|fffd|cution de la g|fffd|n|fffd|ration XML"
'            GenerationFichierIntegration parametresMacroUCM.NumeroDossier, logElem, uFormRes
'            logElem.ajoutDebug strFuncName, "G|fffd|n|fffd|ration termin|fffd|e."
'        Else
'            logElem.ajoutInfo strFuncName, "Traitement de g|fffd|n|fffd|ration annul|fffd| en raison d'erreurs pr|fffd|alables.", True
'        End If
'
'        logElem.ajoutDebug strFuncName, "Sauvegarde du log."
'        logElem.ajoutInfo strFuncName, "Log sauvegard|fffd| sous le nom " & strFileNameLog & " dans le r|fffd|pertoire " & strRepArchive, True
'
'
'        strMsgFinalErr = "Traitement termin|fffd| avec "
'        Select Case uFormRes.lblNbErr.Tag
'            Case 0
'                strMsgFinalErr = strMsgFinalErr & "aucune erreur "
'            Case 1
'                strMsgFinalErr = strMsgFinalErr & "une erreur "
'            Case Else
'                strMsgFinalErr = strMsgFinalErr & uFormRes.lblNbErr.Tag & " erreurs "
'        End Select
'
'        Select Case uFormRes.lblNbAlertes.Tag
'            Case 0
'                strMsgFinalErr = strMsgFinalErr & "et aucune alerte."
'            Case 1
'                strMsgFinalErr = strMsgFinalErr & "et une alerte."
'            Case Else
'                strMsgFinalErr = strMsgFinalErr & "et " & uFormRes.lblNbAlertes.Tag & " alertes."
'        End Select
'
'        logElem.ajoutInfo strFuncName, strMsgFinalErr, True
'
'        'Sauvegarde du fichier log
'        logElem.ajoutDebug strFuncName, "Fermeture fichier log"
'        wkbLog.SaveAs strRepArchive & strFileNameLog
'        wkbLog.Close
'
'        'Affichage du userForm
'        uFormRes.Show
'
'    End If
'End Sub
Attribute VB_Name = "GLOB_PremierePartie"
Option Explicit



'Public Function transformationExcelVersPlat(ByRef logElem As Logger, ByRef wksPrest As Worksheet, strRepTravail As String) As Boolean
'    Dim retVal As Boolean
'    Dim strFuncName As String
'    Dim strFileName As String
'    Dim FSO As New FileSystemObject
'    Dim outputFlatFile As TextStream
'
'
'
'    Dim rg As Range
'
'    strFuncName = "transformationExcelVersPlat"
'
'    retVal = validationFeuillePrestations(logElem, wksPrest)
'
'    If retVal Then
'        logElem.ajoutInfo strFuncName, "==> Validation de la structure de feuille... OK !", True
'
'        strFileName = parametresMacroUCM.NumeroDossier & "_donnees_interm.txt"   '<=== D|fffd|finir le nom du fichier d'output
'        Set outputFlatFile = FSO.OpenTextFile(strRepTravail & strFileName, ForWriting, True)
'
'        retVal = examenFeuilleEtGenerationOutput(logElem, wksPrest, outputFlatFile)
'
'        ' Ceci est facilit|fffd| par l'utilisation de la fonction outputFlatFileLine
'        'Exemple
'        'outputFlatFileLine outputFlatFile, wksPrest, 2, "201612", "01", "H", "0001.00", 750, False, False
'
'        If retVal Then
'            EnleverFormules wksPrest
'            wksPrest.Tab.Color = RGB(150, 210, 150)
'        End If
'
'        outputFlatFile.Close
'        Set outputFlatFile = Nothing
'    Else
'        logElem.ajoutErreur strFuncName, "==> Validation de la structure de feuille... KO !"
'    End If
'
'    transformationExcelVersPlat = retVal   'forcer l'arr|fffd|t en mettant false
'End Function

'Private Sub EnleverFormules(ByRef wksTgt As Worksheet)
'    Dim lngColonne As Long, lngLigne As Long, lngLigneMax As Long
'    Dim rg As Range
'
'    lngLigne = 3
'    lngColonne = 6
'    lngLigneMax = 4
'
'
'    While Len(Trim(wksTgt.Cells(lngLigneMax, 2))) > 0
'        lngLigneMax = lngLigneMax + 3
'    Wend
'
'    wksTgt.Activate
'    UCM_Unprotect
'
'    Set rg = wksTgt.Cells(lngLigne, lngColonne)
'    While Len(rg.MergeArea.Cells(1, 1).Value) > 0
'        If UCase(rg.MergeArea.Cells(1, 1)) = "CODE" Or UCase(rg.Cells(1, 1)) = "DE" Or UCase(rg.Cells(1, 1)) = "A" Then
'            wksTgt.Range(wksTgt.Cells(lngLigne, lngColonne), wksTgt.Cells(lngLigneMax, lngColonne)).Select
'            Selection.Copy
'            Selection.PasteSpecial xlPasteValues
'            DoEvents
'        End If
'
'        lngColonne = lngColonne + 1
'        Set rg = wksTgt.Cells(lngLigne, lngColonne)
'    Wend
'
'    UCM_Protect
'End Sub

'
'Private Function examenFeuilleEtGenerationOutput(ByRef logElem As Logger, ByRef wksPrest As Worksheet, ByRef outputFile As TextStream) As Boolean
'    Dim retVal As Boolean
'    Dim strNomFonction As String
'
'    Dim GHS As New GrillesHoraires              ' Ensemble des donn|fffd|es de tous les travailleurs
'    Dim GHT As GrilleHoraireTravailleur         ' Pour un travailleur donn|fffd|
'    Dim codesFh As New CodesPrestations         ' Liste des codes d|fffd|finis dans la feuille ad hoc
'
'    Dim lngLigne As Long, lngColonne As Long    ' Permettent de parcourir les lignes et colonnes de la feuille
'    Dim lngDernierJourSemaine As Long           ' M|fffd|morise la position de la colonne suivant le bloc hebd. en cours
'
'    Dim dblNbHrsSem As Double                   ' Nombre d'heures sur la semaine (formule total feuille)
'    Dim dblNbHrsSuppSem As Double               '
'    Dim dblNbHrsSuppBaseQuot As Double
'
'    Dim dblPrestContractuellesPrevues As Double ' Pour les semaines incompl|fffd|tes, permet de calculer le nombre
'                                                ' d'heures que le travailleur aurait du faire en fonction de son
'                                                ' horaire normal
'
'
'    ' Tableaux permettant la gestion de chaque jour de la semaine. Ces tableaux sont r|fffd|initialis|fffd|s
'    ' par l'instruction redim en d|fffd|but de chaque traitement de semaine.
'    Dim dblNbHrsTotJour() As Double
'    Dim dblNbHrsDepassementHoraire() As Double
'    Dim arrDetailPrestations() As InfosPrestationsJour
'
'    Dim dblHrsComplDispoSansSupp As Double
'    Dim dblHrsSuppAllocation As Double
'    Dim dblHorNormalHebd As Double
'    Dim nbJoursSem As Long
'    Dim blnTempsPartiel As Boolean
'    Dim dtJour As Date
'    Dim blnTrtTrav As Boolean
'    Dim cpt As Long
'    Dim lngJourEnCours As Long
'    Dim strCurrCode As String
'    Dim strDescFer As String
'    Dim dblDureeSuppA9 As Double
'
'    retVal = True
'    strNomFonction = "examenFeuilleEtGenerationOutput"
'
'            logElem.ajoutDebug strNomFonction, _
'                                "R|fffd|cup|fffd|ration des informations horaires des travailleurs"
'    GHS.ChargerGrillesAPartirDeFeuille wksPrest.Parent.Worksheets("GH - Travailleurs")
'
'            logElem.ajoutDebug strNomFonction, _
'                                "Chargement des donn|fffd|es relatives aux codes de prestation."
'    codesFh.chargerCodesDeFeuille wksPrest.Parent.Sheets("Codes de prestations"), logElem
'
'
'    'Parcours des travailleurs
'    lngLigne = C_PR_LIGNE_DEB                    'Position de d|fffd|part normale : 4
'
'    While Len(Trim(wksPrest.Cells(lngLigne, C_PR_COL_NOM))) > 0
'        'Lire les donn|fffd|es du travailleur
'        logElem.ajoutDebug strNomFonction, "Traitement travailleur " & wksPrest.Cells(lngLigne, C_PR_COL_NUM) & " - " & wksPrest.Cells(lngLigne, C_PR_COL_NOM)
'
'        blnTrtTrav = True
'
'        'R|fffd|cup|fffd|rer les informations de la grille horaire de ce travailleur
'        Set GHT = GHS.GHTravailleur(CStr(wksPrest.Cells(lngLigne, C_PR_COL_NUM)))
'        If GHT Is Nothing Then
'            blnTrtTrav = False
'            logElem.ajoutErreur strNomFonction, "Le travailleur '" & Format(wksPrest.Cells(lngLigne, C_PR_COL_NUM), "000000") & "' (" & wksPrest.Cells(lngLigne, C_PR_COL_NOM) & ") n'existe pas dans la feuille des grilles horaires travailleurs."
'            logElem.ajoutInfo strNomFonction, "Les donn|fffd|es pour ce travailleur n'ont pas |fffd|t|fffd| int|fffd|gr|fffd|es dans le fichier de prestations |fffd| destination d'appipay.", True
'        End If
'
'        If blnTrtTrav Then
'            dblHorNormalHebd = GHT.HrsHebd * 24
'            blnTempsPartiel = ((38 - dblHorNormalHebd) > EPSILON)
'            If blnTempsPartiel Then
'                logElem.ajoutWarning strNomFonction, "Attention : le travailleur " & GHT.nom & " (" & GHT.num & ") est |fffd| temps partiel !"
'                logElem.ajoutInfo strNomFonction, "Il convient de g|fffd|rer les |fffd|ventuelles heures compl|fffd|mentaires manuellement |fffd| l'aide des codes HC, HC1 et HC2.", True
'                dblHrsComplDispoSansSupp = 12#
'            End If
'
'            lngColonne = C_PR_COL_DET_PRES_START
'
'            While InStr(wksPrest.Cells(C_PR_LIGNE_TITRE, lngColonne), "APRES") <= 0
'                logElem.ajoutDebug strNomFonction, "Traitement de la semaine commen|fffd|ant le " & Format(wksPrest.Cells(C_PR_LIGNE_TITRE, lngColonne), "dd/mm") & "."
'
'                'If wksPrest.Cells(C_PR_LIGNE_TITRE, lngColonne) = DateSerial(2018, 7, 9) Then Stop
'                DoEvents
'                'R|fffd|initialisation des tableaux
'                ReDim dblNbHrsTotJour(1 To 7)
'                ReDim arrDetailPrestations(1 To 7)
'
'                dblNbHrsSuppBaseQuot = 0#
'                dblPrestContractuellesPrevues = 0#
'                nbJoursSem = 0
'
'                lngDernierJourSemaine = lngColonne
'                'D|fffd|termination de la colonne contenant le dernier jour de la semaine.
'
'                While InStr(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine), "Synth|fffd|se") <= 0
'                    'Ajouter le total des prestations du jour dans le tableau interm|fffd|diaire
'                    DoEvents
'                    dtJour = wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine)
'                    lngJourEnCours = Weekday(dtJour, vbMonday)
'                    dblNbHrsTotJour(lngJourEnCours) = (wksPrest.Cells(lngLigne, lngDernierJourSemaine + 3) + _
'                                                       wksPrest.Cells(lngLigne + 1, lngDernierJourSemaine + 3) + _
'                                                       wksPrest.Cells(lngLigne + 2, lngDernierJourSemaine + 3)) * 24
'
'                    Set arrDetailPrestations(lngJourEnCours) = New InfosPrestationsJour
'                    For cpt = 0 To 2
'                        If Len(Trim(wksPrest.Cells(lngLigne + cpt, lngDernierJourSemaine))) > 0 Then
'                            strCurrCode = codesFh.CodeFH(wksPrest.Cells(lngLigne + cpt, lngDernierJourSemaine))
'                            'Forcer le code de prestation en mode HS si WE ou f|fffd|ri|fffd|
'                            If strCurrCode = "0001.00" And (estDimancheOuFerie(dtJour) Or Weekday(dtJour) = vbSaturday) Then
'                                strCurrCode = getCodeSupp(dtJour)
'                            End If
'
'                            arrDetailPrestations(lngJourEnCours).ajouterPrestation strCurrCode, _
'                                                    wksPrest.Cells(lngLigne + cpt, lngDernierJourSemaine + 3) * 24
'                        End If
'                    Next
'                    'M|fffd|moriser, le nombre d'heures suppl|fffd|mentaires de type d|fffd|passement 9 hrs par jour au niveau de la prestation quotidienne
'                    dblDureeSuppA9 = dblNbHrsTotJour(Weekday(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine), vbMonday)) - 9
'                    If dblDureeSuppA9 > EPSILON Then
'                        dblNbHrsSuppBaseQuot = dblNbHrsSuppBaseQuot + dblDureeSuppA9
'                        arrDetailPrestations(lngJourEnCours).ConvertirPrestations dblDureeSuppA9, _
'                                            getCodeSupp(dtJour)
'                    End If
'
'                    dblPrestContractuellesPrevues = dblPrestContractuellesPrevues + (GHT.NbHrsPrevues(Weekday(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine), vbMonday)) * 24)
'                    nbJoursSem = nbJoursSem + 1
'                    lngDernierJourSemaine = lngDernierJourSemaine + 4
'                Wend
'                        logElem.ajoutDebug strNomFonction, "Dernier jour de la semaine : " & Format(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine - 4), "dd/mm") & "."
'                dblNbHrsSem = wksPrest.Cells(lngLigne, lngDernierJourSemaine) * 24
'                dblNbHrsSuppSem = wksPrest.Cells(lngLigne + 2, lngDernierJourSemaine) * 24
'                dblHrsSuppAllocation = Round(dblNbHrsSuppSem - dblNbHrsSuppBaseQuot, 5)
'                        logElem.ajoutDebug strNomFonction, "     * Nombre de jours sur la semaine      : " & _
'                                                                    nbJoursSem
'                        logElem.ajoutDebug strNomFonction, "     * Nombre d'heures sur la semaine      : " & _
'                                                                    Round(dblNbHrsSem, 5) & IIf(blnTempsPartiel, " - Tmp Part", "")
'                        logElem.ajoutDebug strNomFonction, "       Horaire normal du travailleur (H)   : " & _
'                                                                    Round(dblHorNormalHebd, 5)
'                        logElem.ajoutDebug strNomFonction, "       Horaire pr|fffd|vu cette semaine         : " & _
'                                                                    Round(dblPrestContractuellesPrevues, 5)
'                        logElem.ajoutDebug strNomFonction, "     * Nombre d'heures supp sur la semaine : " & _
'                                                                    Round(dblNbHrsSuppSem, 5)
'                        logElem.ajoutDebug strNomFonction, "     * Nombre d'heures supp mode + 9 hr    : " & _
'                                                                    Round(dblNbHrsSuppBaseQuot, 5)
'                        logElem.ajoutDebug strNomFonction, "     * Nombre d'heures supp |fffd| allouer      : " & _
'                                                                    Round(dblHrsSuppAllocation, 5)
'
'                If dblNbHrsSem < EPSILON Then
'                    'contrat actif sur le dernier jour de la semaine ?
'                    If GHT.contratActif(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine - 4)) And nbJoursSem > 1 Then
'                        logElem.ajoutWarning strNomFonction, "Travailleur " & GHT.nom & " (" & GHT.num & ") : absence de prestations |fffd| contr|fffd|ler sur semaine " & _
'                                                Format(wksPrest.Cells(C_PR_LIGNE_TITRE, lngColonne), "dd/mm") & "-" & Format(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine - 4), "dd/mm")
'                    End If
'                Else
'                    'If Not blnTempsPartiel Then
'                    'Temps plein - pas d'heures compl
'                        'Attribution des heures suppl|fffd|mnetaires
'                        lngDernierJourSemaine = lngColonne
'                        While InStr(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine), "Synth|fffd|se") <= 0
'                            dtJour = wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine)
'                            lngJourEnCours = Weekday(dtJour, vbMonday)
'                            dblHrsSuppAllocation = arrDetailPrestations(lngJourEnCours).ConvertirPrestations(dblHrsSuppAllocation, getCodeSupp(dtJour))
'                            'arrDetailPrestations(lngJourEnCours).GenererOuptutTemporaire outputFile, GHT.Num, Format(dtJour, "YYYYMMDD")
'
'                            lngDernierJourSemaine = lngDernierJourSemaine + 4
'                        Wend
'                        If dblHrsSuppAllocation > EPSILON Then
'                            'Pas assez d'heures pour allouer => on diminue la limite effective ...
'                            lngDernierJourSemaine = lngColonne
'                            While InStr(wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine), "Synth|fffd|se") <= 0
'                                dtJour = wksPrest.Cells(C_PR_LIGNE_TITRE, lngDernierJourSemaine)
'                                lngJourEnCours = Weekday(dtJour, vbMonday)
'                                dblHrsSuppAllocation = arrDetailPrestations(lngJourEnCours).ConvertirPrestations(dblHrsSuppAllocation, getCodeSupp(dtJour), , 2#)
'                                'arrDetailPrestations(lngJourEnCours).GenererOuptutTemporaire outputFile, GHT.Num, Format(dtJour, "YYYYMMDD")
'                                lngDernierJourSemaine = lngDernierJourSemaine + 4
'                            Wend
'                        End If
'                        'Et on peut |fffd| pr|fffd|sent sortir les prestations !
'
'                        While InStr(wksPrest.Cells(C_PR_LIGNE_TITRE, lngColonne), "Synth|fffd|se") <= 0
'                            dtJour = wksPrest.Cells(C_PR_LIGNE_TITRE, lngColonne)
'                            lngJourEnCours = Weekday(dtJour, vbMonday)
'                            arrDetailPrestations(lngJourEnCours).GenererOuptutTemporaire outputFile, GHT.num, Format(dtJour, "YYYYMMDD")
'
'                            lngColonne = lngColonne + 4
'                        Wend
'                End If
'
'                'Semaine suivante ou fin, svp :-)
'                lngColonne = lngDernierJourSemaine + 1 'Et hop, on passe |fffd| la semaine suivante
'            Wend
'        End If
'        retVal = retVal And blnTrtTrav
'
'        'Passer au travailleur suivant, si pr|fffd|sent.
'        Set GHT = Nothing
'        lngLigne = lngLigne + 3
'    Wend
'
'    examenFeuilleEtGenerationOutput = retVal
'End Function

Private Function estDimancheOuFerie(dtJour As Date) As Boolean
    Dim strTmpDesc As String
    
    
    estDimancheOuFerie = (Weekday(dtJour) = vbSunday Or estFerie(dtJour, strTmpDesc))
    
End Function

Private Function getCodeSupp(dtJour As Date) As String
    Dim retVal As String
    
    If estDimancheOuFerie(dtJour) Then
        If estCampagne(dtJour) Then
            retVal = "0336.01"
        Else
            retVal = "0330.03"
        End If
    Else
        If estCampagne(dtJour) Then
            retVal = "0336.00"
        Else
            retVal = "0330.02"
        End If
    End If
    getCodeSupp = retVal
End Function
Private Function validationFeuillePrestations(ByRef logElem As Logger, ByRef wksPrest As Worksheet)
    Dim retVal As Boolean
    Dim dtTmp As Date
    Dim rg As Range
    
    retVal = estNomDeMois(wksPrest.Name, dtTmp)
        
    'On a bien un tableau au format demand|fffd|.
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_NUM, C_PR_LIGNE_TITRE, "Mois : ", logElem)
    
    'Validation particuli|fffd|re : on teste la date !
    If Not (wksPrest.Cells(1, 2) = dtTmp) Then
        retVal = False
        logElem.ajoutErreur "validationFeuillePrestations", "La date mentionn|fffd|e en cellule B1 n'est pas valide !", True
    End If
        
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_NUM, C_PR_LIGNE_TITRE + 1, "Infos Travailleur", logElem)
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_NUM, C_PR_LIGNE_TITRE + 2, "Num|fffd|ro UCM", logElem)
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_NOM, C_PR_LIGNE_TITRE + 2, "Nom", logElem)
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_POLE, C_PR_LIGNE_TITRE + 2, "P|fffd|le", logElem)
    
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_HRS_SUPP_PREC, C_PR_LIGNE_TITRE, "Heures Supp. AVANT", logElem)
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_HRS_SEM_PREC, C_PR_LIGNE_TITRE, "Total Hrs hebd sur mois pr|fffd|c.", logElem)
    
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_DET_PRES_START, C_PR_LIGNE_TITRE + 2, "Code", logElem)
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_DET_PRES_START + 1, C_PR_LIGNE_TITRE + 2, "De", logElem)
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_DET_PRES_START + 2, C_PR_LIGNE_TITRE + 2, "A", logElem)
    retVal = retVal And validationColonne(wksPrest, C_PR_COL_DET_PRES_START + 3, C_PR_LIGNE_TITRE + 2, "Nb Hrs", logElem)
    
    Set rg = wksPrest.Range("FF1").End(xlToLeft)
    retVal = retVal And validationColonne(wksPrest, rg.Column, C_PR_LIGNE_TITRE, "Heures Supp. APRES", logElem)

    validationFeuillePrestations = retVal
End Function

'Seconde version, accessible |fffd| partir d'autres objets, simplifiant l'|fffd|criture de lignes de prestations temporaires
'Public Function impressionLigne(ByRef outF As TextStream, lngNumTrav As Long, strDtPrest As String, _
'                            strCodeFH As String, NbCentiemesUnite As Long)
'    Dim retVal As Boolean
'    Dim strFuncName As String
'    Dim strContenuLigne As String
'
'    retVal = True
'    strFuncName = "outputFlatFileLine"
'
'    strContenuLigne = "A" & parametresMacroUCM.NumeroDossier
'    strContenuLigne = strContenuLigne & Format(lngNumTrav, "000000")
'    strContenuLigne = strContenuLigne & String(6, " ")
'    strContenuLigne = strContenuLigne & strDtPrest
'    strContenuLigne = strContenuLigne & "H"
'    strContenuLigne = strContenuLigne & Left(strCodeFH & String(10, " "), 10)
'    strContenuLigne = strContenuLigne & Right(String(10, "0") & CStr(NbCentiemesUnite), 10)
'
'    outF.WriteLine strContenuLigne
'    Debug.Print strContenuLigne
'    impressionLigne = retVal
'
'End Function

'
'Private Function outputFlatFileLine(ByRef outF As TextStream, ByRef wksPrest As Worksheet, lngNumLigne As Long, strMMPrest As String, _
'                                    strDay As String, strTypeLigne As String, strCodeRubrique As String, _
'                                    NbCentiemesUnite As Long, blnPNuit As Boolean, blnPEquipe As Boolean) As Boolean
'    Dim retVal As Boolean
'    Dim strFuncName As String
'    Dim strContenuLigne As String
'
'    retVal = True
'    strFuncName = "outputFlatFileLine"
'
'    'Position 1   - longueur 1    : la lettre 'A'
'    '         2   -          6    : Empcode (parametresMacroUCM.NumeroDossier)
'    strContenuLigne = "A" & parametresMacroUCM.NumeroDossier
'    '         8   -          6    : Travcode
'    strContenuLigne = strContenuLigne & Right(String(6, "0") & wksPrest.Cells(lngNumLigne, C_PREST_COL_NUM_TRAV), 6)
'    '         14  -          6    : Reference pointeuse
'    strContenuLigne = strContenuLigne & String(6, " ")
'    '         20  -          4    : Ann|fffd|e de la prestation
'    '         24  -          2    : Mois de la prestation
'    '         26  -          2    : Jour de la prestation
'    strContenuLigne = strContenuLigne & strMMPrest & Right("00" & strDay, 2)
'    '         28  -          1    : Code de type information (H pour prestas, M pour rubr.)
'    strContenuLigne = strContenuLigne & strTypeLigne
'    '         29  -          10   : Code de prestation/rubrique (format ffff.vv ou ffff.vvvv)
'    strContenuLigne = strContenuLigne & Left(strCodeRubrique & String(10, " "), 10)
'    '         39  -          10   : Quantit|fffd| (montant ou nb hrs) exprim|fffd|s en centi|fffd|mes (d'heures ou d'euros)
'    strContenuLigne = strContenuLigne & Right(String(10, "0") & CStr(NbCentiemesUnite), 10)
'    '         49  -          1    : Indicateur '1' si la prime d'|fffd|quipe est applicable globalement
'    strContenuLigne = strContenuLigne & IIf(blnPEquipe, "1", "0")
'    '         50  -          1    : Indicateur '1' si la prime de nuit est applicable globalement
'    strContenuLigne = strContenuLigne & IIf(blnPNuit, "1", "0")
'
'    outF.WriteLine strContenuLigne
'
'    outputFlatFileLine = retVal
'End Function

Private Function validationColonne(ByRef wksPrest As Worksheet, lngNumCol As Long, lngNumLigne As Long, _
                                   strTexteAttendu As String, ByRef logE As Logger, _
                                   Optional blnCaseInsensitive As Boolean = True) As Boolean
    Dim retVal As Boolean
    Dim strFuncName As String
    strFuncName = "GLOB_PremierePartie::validationColonne"
    retVal = True
    
    logE.ajoutDebug strFuncName, "Validation colonne '" & ColonneParLettre(lngNumCol) & "' pour trouver le texte '" & strTexteAttendu & "'"
    If blnCaseInsensitive Then
        logE.ajoutDebug strFuncName, "Mode : Case Insensitive"
        If Not (LCase(Trim(wksPrest.Cells(lngNumLigne, lngNumCol).Value)) = LCase(Trim(strTexteAttendu))) Then
            logE.ajoutErreur strFuncName, "La colonne '" & ColonneParLettre(lngNumCol) & _
                        "' doit contenir la valeur '" & strTexteAttendu & "' en ligne " & _
                        lngNumLigne & " (ou une variante minuscules/majuscules)."
            retVal = False
        Else
            logE.ajoutDebug strFuncName, "Validation OK"
        End If
    Else
        logE.ajoutDebug strFuncName, "Mode : Case Sensitive"
        If Not (Trim(wksPrest.Cells(lngNumLigne, lngNumCol).Value) = Trim(strTexteAttendu)) Then
            logE.ajoutErreur strFuncName, "La colonne '" & ColonneParLettre(lngNumCol) & _
                        "' doit contenir la valeur '" & strTexteAttendu & "' en ligne " & _
                        lngNumLigne & " (sans variante minuscules/majuscules)."
            retVal = False
        End If
    End If
        
    validationColonne = retVal
End Function
                    



Private Function ColonneParLettre(lngNbCol As Long) As String
     ColonneParLettre = Split(ActiveSheet.Cells(1, lngNbCol).Address, "$")(1)
End Function


Attribute VB_Name = "GLOB_Reconduction"


Public Sub encapsTest(Optional blnDoNotShowMe As Boolean = True)

    CreationFeuilleMensuelle 8, 2018
End Sub





Public Sub CreationFeuilleMensuelle(lngMois As Long, lngAnnee As Long)
    '1. S'assurer que la feuille n'existe pas.
    
    '2. Cr|fffd|er la feuille
    
    '3. Charger les donn|fffd|es des GH travailleurs
End Sub
Attribute VB_Name = "GLOB_SecondePartie"
'Option Explicit
'
''
''
'' Module : SecondePartie
''
'' Fichier de base pour |fffd|dition :
''  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
''
'' Important :
''  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
''  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
''
'' Objectif
'' *********
''  R|fffd|aliser, de mani|fffd|re standardis|fffd|e, la lecture et la gestion des |fffd|missions de fichiers Interface Prestations
''  Se base sur le(s) fichier(s) plat(s) g|fffd|n|fffd|r|fffd| par la premi|fffd|re macro.
''
'' Auteur
'' *******
''  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
''
'' D|fffd|pendances
'' ************
''  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale  | Type
'' --------------------------------------+-------------------+-------------------
''  IGenerateur                          |     1.00          | Classe (Interface)
''  ITravailleur                         |     1.00          | Classe (Interface)
''  IContrat                             |     1.00          | Classe (Interface)
''  IPlanning                            |     1.00          | Classe (Interface)
''  IJourPrestations                     |     1.00          | Classe (Interface)
''  IRefInterne                          |     1.00          | Classe (Interface)
''  IScript                              |     1.00          | Classe (Interface)
''  IPrestation                          |     1.00          | Classe (Interface)
''  GenerateurXML                        |     1.00          | Classe (Impl.)
''  Travailleur                          |     1.00          | Classe (Impl.)
''  Contrat                              |     1.00          | Classe (Impl.)
''  Planning                             |     1.00          | Classe (Impl.)
''  JourPrestations                      |     1.00          | Classe (Impl.)
''  Prestation                           |     1.00          | Classe (Impl.)
''  Script                               |     1.00          | Classe (Impl.)
''  Logger                               |     1.00          | Classe (Impl.)
''  GestionRepertoires                   |     1.00          | Module
''  UtilitairesXML                       |     1.00          | Module
''  DefinitionConstantes                 |     1.00          | Module
''
'' Versions
''**********
''  N|fffd|       |       Date       | Description des changements
''  1.00     |    10.06.2015    | Version initiale
''
'Private Const INIT_VAL As String = "XXXXXXXXXXXXXX"
'
'Public Sub testGen(Optional blnDoNotShowMe As Boolean = True)
'    GenerationFichierIntegration "000015"
'End Sub
'
'
'Public Sub GenerationFichierIntegration(Optional strNoDossierIn As String = "", Optional logElem As Logger = Nothing, Optional ufRes As usrFormResultatTraitement = Nothing)
'    Dim strFuncName As String           ' Nom de la fonction pour logging
'
'    Dim wkbk As Workbook                ' Classeur Excel de travail
'    Dim tmpWks As Worksheet             ' Feuille destin|fffd|e |fffd| contenir les donn|fffd|es trait|fffd|es
'    Dim collFiles As Collection         ' Nom des fichiers charg|fffd|s pour transfert si traitement ok
'    Dim log As Logger                   ' Objet pour enregistrement des logs
'    Dim strNoDossier As String          ' Num|fffd|ro de dossier pour lequel on va travailler...
'    Dim strRepTravail As String         ' Emplacement du r|fffd|pertoire dans lequel se trouvent les donn|fffd|es |fffd| traiter
'    Dim strRepArchive As String         ' Emplacement du r|fffd|pertoire dans lequel on archive les fichiers trait|fffd|s et le log
'    Dim strRepEnvoi As String           ' Emplacement de destination des fichiers XML g|fffd|n|fffd|r|fffd|s
'    Dim strTimeStamp As String
'
'
'    'Dim rngR As Range
'    Dim nbLignes As Long
'    Dim strFName As String
'    Dim genXml As IGenerateur
'
'    Dim strFToMove
'
'    'Initialisations
'    strFuncName = "GenerationFichierIntegration"
'
'    Set collFiles = New Collection
'    If logElem Is Nothing Then
'        Set wkbk = Workbooks.Add
'        Set log = New Logger
'        If Not (ufRes Is Nothing) Then
'            Set log.userFormResultat = ufRes
'        End If
'
'        log.creerFeuilleLog "temp_log", wkbk
'        log.ajoutInfo strFuncName, "Initialisation du m|fffd|canisme de logging"
'    Else
'        Set log = logElem
'        Set wkbk = logElem.parentWorkbook
'        If Len(strNoDossierIn) > 0 Then
'            log.ajoutInfo strFuncName, "Ex|fffd|cution de la g|fffd|n|fffd|ration du fichier XML pour le dossier " & strNoDossierIn
'        Else
'            log.ajoutErreur strFuncName, "Ex|fffd|cution d'une g|fffd|n|fffd|ration avec mention de logger => Num|fffd|ro de dossier n|fffd|cessaire"
'            Exit Sub
'        End If
'    End If
'    Set tmpWks = wkbk.Worksheets.Add(After:=wkbk.Sheets(wkbk.Sheets.Count))
'
'    'Gestion du num|fffd|ro de dossier
'    log.ajoutDebug strFuncName, "Obtention du num|fffd|ro de dossier"
'    If Len(Trim(strNoDossierIn)) = 0 Then
'        strNoDossier = ObtenirNumeroDossier(log)
'    Else
'        strNoDossier = strNoDossierIn
'    End If
'    log.ajoutInfo strFuncName, "Num|fffd|ro de dossier : " & strNoDossier
'
'    'Sortie imm|fffd|diate si le num|fffd|ro de dossier n'est pas donn|fffd|
'    If Len(Trim(strNoDossier)) = 0 Then
'        log.ajoutWarning strFuncName, "Annulation du traitement |fffd| la demande de l'utilisateur"
'        Exit Sub
'    End If
'
'    'Gestion des r|fffd|pertoires de travail
'    log.ajoutDebug strFuncName, "appel de fonction : definirRepertoiresTravail"
'    definirRepertoiresTravail strNoDossier, strRepTravail, strRepArchive, strRepEnvoi, log
'
'    'Initialisation du g|fffd|n|fffd|rateur XML
'    log.ajoutDebug strFuncName, "D|fffd|finition du g|fffd|n|fffd|rateur XML"
'    Set genXml = New GenerateurXML
'    log.ajoutDebug strFuncName, "D|fffd|finition du num|fffd|ro de dossier pour le g|fffd|n|fffd|rateur XML"
'    genXml.Dossier = strNoDossier
'
'    log.ajoutDebug strFuncName, "Calcul timestamp de g|fffd|n|fffd|ration"
'    strTimeStamp = Replace(genXml.DateEnvoi, "-", "")
'    strTimeStamp = Replace(strTimeStamp, ":", "")
'    strTimeStamp = Replace(strTimeStamp, ".0", "")
'    strTimeStamp = Replace(strTimeStamp, "T", "_")
'    log.ajoutInfo strFuncName, "TimeStamp ex|fffd|cution : " & strTimeStamp, True
'
'    log.ajoutDebug strFuncName, "D|fffd|finition des noms des feuilles de travail"
'    tmpWks.Name = "Trt_Data_" & strNoDossier & "_" & strTimeStamp
'    log.renomme "Log_" & strTimeStamp
'
'    'Chargement des donn|fffd|es des fichiers dans la feuille de travail
'    log.ajoutDebug strFuncName, "appel de fonction : chargementFichiers"
'    nbLignes = chargementFichiers(tmpWks, strRepTravail, collFiles, log)
'    log.ajoutInfo strFuncName, "Nombre de fichiers : " & collFiles.Count
'
'    'Traitement des donn|fffd|es pr|fffd|sentes dans la feuille de travail (tri|fffd|es...)
'    log.ajoutDebug strFuncName, "appel de fonction parsingData"
'    parsingData tmpWks, nbLignes, genXml, log
'
'    'G|fffd|n|fffd|ration du fichier XML d'output
'    strFName = strRepEnvoi & strNoDossier & "_RP_" & genXml.Periode & "_" & strTimeStamp & ".xml"
'    log.ajoutInfo strFuncName, "G|fffd|n|fffd|ration du XML dans '" & strFName & "'", True
'    If genXml.GenererOutput(strFName) Then
'        'En cas de succ|fffd|s :
'        ' * synth|fffd|se pour le client
'        genXml.GenererSynthese strFName, ufRes
'        ' * d|fffd|placement des fichiers trait|fffd|s dans le r|fffd|pertoire d'archives
'        For Each strFToMove In collFiles
'            log.ajoutInfo strFuncName, "D|fffd|placement de '" & strFToMove & "' vers '" & strRepArchive & "'", True
'            FileCopy strRepTravail & strFToMove, strRepArchive & strTimeStamp & "_" & strFToMove
'            Kill strRepTravail & strFToMove
'        Next
'    End If
'
'    'Sauvegarde des donn|fffd|es trait|fffd|es uniquement si la fonction est responsable de la cr|fffd|ation du log !
'    If logElem Is Nothing Then
'        log.ajoutDebug strFuncName, "Sauvegarde du log et des donn|fffd|es trait|fffd|es (" & strRepArchive & strTimeStamp & "_log.xlsx)", True
'        wkbk.SaveAs strRepArchive & strTimeStamp & "_log.xlsx"
'        wkbk.Close
'        Set wkbk = Nothing
'    End If
'End Sub
'
''Examine les lngLignes dans la feuille tmpWks
''Pr|fffd|requis : la liste est tri|fffd|e !
'
'Private Function parsingData(ByRef wksSrc As Worksheet, lngLignes As Long, ByRef generateur As IGenerateur, logf As Logger) As Boolean
'    'Acc|fffd|der aux donn|fffd|es
'    Dim cptLigne As Long
'    Dim strContenu As String
'    Dim strFuncName As String
'    Dim strDossier As String
'    Dim oTrav As ITravailleur
'    Dim oContr As IContrat
'    Dim prevTravNum As String
'    Dim prevRefPoint As String
'    Dim retVal As Boolean
'    Dim dtPrest As Date
'
'    retVal = True
'
'    strFuncName = "parsingData"
'
'    prevTravNum = INIT_VAL
'    prevRefPoint = INIT_VAL
'
'    For cptLigne = 1 To lngLignes
'        strContenu = wksSrc.Range("A" & CStr(cptLigne)).Value
'        logf.ajoutInfo strFuncName, "Traitement ligne : " & strContenu
'        If cptLigne = 1 Then
'            logf.ajoutDebug strFuncName, "D|fffd|finition de la p|fffd|riode de paie"
'            logf.ajoutInfo strFuncName, "P|fffd|riode de paie : " & Mid(strContenu, 20, 4) & " - " & Mid(strContenu, 24, 2)
'            generateur.definirPeriodePaie CLng(Mid(strContenu, 20, 4)), CLng(Mid(strContenu, 24, 2))
'        End If
'        If UCase(Mid(strContenu, 1, 1)) = "A" Then
'            If Trim(Mid(strContenu, 2, 6)) <> generateur.Dossier Then
'                'Erreur : pas le bon num|fffd|ro de dossier
'                logf.ajoutErreur strFuncName, "Le num|fffd|ro de dossier dans le fichier |fffd| traiter ne correspond pas"
'                logf.ajoutInfo strFuncName, "Num|fffd|ro de dossier |fffd| traiter : " & generateur.Dossier
'                logf.ajoutInfo strFuncName, "Num|fffd|ro de dossier dans le fichier : " & Trim(Mid(strContenu, 2, 6))
'                logf.ajoutInfo strFuncName, "N|fffd| de ligne : " & cptLigne
'                parsingData = False
'                Exit Function
'            Else
'                If Trim(Mid(strContenu, 8, 6)) <> prevTravNum Then
'                    'On change de travailleur (autre num|fffd|ro)
'                    logf.ajoutDebug strFuncName, "Changement de travailleur"
'                    logf.ajoutInfo strFuncName, "Travailleur : " & Mid(strContenu, 8, 6)
'                    'Cl|fffd|ture du contrat en cours sur le travailleur en cours
'                    If Not oContr Is Nothing Then
'                        'Si oContr est d|fffd|fini, oTrav l'est aussi !
'                        logf.ajoutDebug strFuncName, "ajout du contrat '" & oContr.ReferencePointeuse & "' au travailleur '" & oTrav.NumeroTravailleur & "'"
'                        oTrav.ajouteContrat oContr
'                        Set oContr = Nothing
'                    End If
'                    'Cl|fffd|ture du travailleur en cours
'                    If Not oTrav Is Nothing Then
'                        logf.ajoutDebug strFuncName, "ajout du travailleur '" & oTrav.NumeroTravailleur & "' pour g|fffd|n|fffd|ration"
'                        generateur.ajouterTravailleur oTrav
'                        Set oTrav = Nothing
'                    End If
'
'                    'D|fffd|finition d'un nouveau travailleur
'                    logf.ajoutDebug strFuncName, "Cr|fffd|ation d'un nouveau travailleur '" & Mid(strContenu, 8, 6) & "'"
'                    Set oTrav = New Travailleur
'                    oTrav.NumeroTravailleur = Trim(Mid(strContenu, 8, 6))
'                    prevTravNum = oTrav.NumeroTravailleur
'                    'OK pour premi|fffd|re ligne car contenu diff|fffd|rent de la valeur d'init
'                End If
'
'                ' On change de r|fffd|f|fffd|rence pointeuse => autre contrat
'                ' si m|fffd|me travailleur : simple cloture du contrat
'                ' si autre travailleur, contrat g|fffd|r|fffd| au niveau de la cloture du trav. pr|fffd|c|fffd|dent
'                If UCase(Trim(Mid(strContenu, 14, 6))) <> prevRefPoint Then
'                    If Not oTrav Is Nothing Then
'                        If Not oContr Is Nothing Then
'                            logf.ajoutDebug strFuncName, "Fin de la gestion des donn|fffd|es du contrat '" & oContr.ReferencePointeuse & "'"
'                            oTrav.ajouteContrat oContr
'                            Set oContr = Nothing
'                        End If
'                    End If
'                End If
'
'                'Contrat n'existe pas encore (ou plus...) => on le cr|fffd|e
'                If oContr Is Nothing Then
'                    logf.ajoutDebug strFuncName, "Cr|fffd|ation du contrat '" & Trim(Mid(strContenu, 14, 6)) & "' pour le travailleur '" & oTrav.NumeroTravailleur & "'"
'                    Set oContr = New contrat
'                    oContr.definirContrat UCase(Trim(Mid(strContenu, 14, 6)))
'                    prevRefPoint = UCase(Trim(Mid(strContenu, 14, 6)))
'                'Else
'                    'Contrat existe, on l'utilise
'                    ' Comme pas de changement, c'est toujours celui qui est bon...
'                End If
'                'Lecture des infos
'                logf.ajoutDebug strFuncName, "D|fffd|termination de la date de prestation"
'                dtPrest = DateSerial(CLng(Mid(strContenu, 20, 4)), _
'                                    CLng(Mid(strContenu, 24, 2)), _
'                                    CLng(Mid(strContenu, 26, 2)))
'                logf.ajoutInfo strFuncName, "Date de prestation : " & Format(dtPrest, "dd/mm/yyyy")
'                'Gestion des prestations
'                Select Case UCase(Mid(strContenu, 28, 1))
'                    Case "H"
'                        logf.ajoutDebug strFuncName, "ajout infos prestations"
'                        oContr.ajouterPrestation dtPrest, Trim(Mid(strContenu, 29, 10)), _
'                                    CDbl(Trim(Mid(strContenu, 39, 10))) / 100, _
'                                    (Mid(strContenu & String(10, " "), 50, 1) = "1"), _
'                                    (Mid(strContenu & String(10, " "), 49, 1) = "1")
'                    Case "M"
'                        logf.ajoutDebug strFuncName, "ajout infos montants"
'                        oContr.ajouterRubrique RubriqueMontant, Trim(Mid(strContenu, 29, 10)), _
'                                    CDbl(Trim(Mid(strContenu, 39, 10))) / 100
'                    Case "U"
'                        logf.ajoutDebug strFuncName, "ajout infos unit|fffd|s"
'                        oContr.ajouterRubrique RubriqueUnites, Trim(Mid(strContenu, 29, 10)), _
'                                    CDbl(Trim(Mid(strContenu, 39, 10)))
'                End Select
'
'            End If
'        Else
'            'Cas non trait|fffd| : operys
'            logf.ajoutErreur strFuncName, "Traitement Operys non support|fffd|"
'            logf.ajoutInfo strFuncName, "N|fffd| de ligne : " & cptLigne
'            parsingData = False
'            Exit Function
'        End If
'    Next
'
'    'Finalisation
'    If Not oContr Is Nothing Then
'        If Not oTrav Is Nothing Then
'            logf.ajoutDebug strFuncName, "ajout du dernier contrat '" & oContr.ReferencePointeuse & "' pour le travailleur '" & oTrav.NumeroTravailleur & "'"
'            oTrav.ajouteContrat oContr
'        End If
'        logf.ajoutDebug strFuncName, "ajout du dernier travailleur '" & oTrav.NumeroTravailleur & "'"
'        generateur.ajouterTravailleur oTrav
'    End If
'    Set oTrav = Nothing
'    Set oContr = Nothing
'
'    logf.ajoutDebug strFuncName, "Valeur de retour : " & retVal
'    parsingData = retVal
'    'D|fffd|finir la p|fffd|riode de paie
'End Function
'
'
'' Chargement des fichiers pr|fffd|sents dans le r|fffd|pertoire de travail
'' Principe : on charge tous les fichiers dans une feuille qu'on va manipuler par la suite.
'' retourne le nombre de ligne charg|fffd|es dans la feuille temporaire
'' Les donn|fffd|es sont tri|fffd|es par ordre croissant.
'Private Function chargementFichiers(ByRef wksDest As Worksheet, ByVal strRepTrav As String, ByRef oCollection As Collection, logf As Logger) As Long
'    Dim lngFileNb As Long
'    Dim strFName As String
'    Dim strBuff As String
'    Dim cptLigne As Long
'
'    'handle de fichier et compteur
'    lngFileNb = FreeFile
'    cptLigne = 1
'
'    'Parcours de tous les fichiers pr|fffd|sents - le nommage n'est important que pour l'aspect visuel de l'utilisateur
'    strFName = Dir(strRepTrav)
'    Do While strFName <> ""
'        logf.ajoutInfo "chargementFichiers", "Chargement du fichier '" & strFName & "'"
'        'Debug.Print strFName
'        DoEvents
'        Open strRepTrav & strFName For Input As #lngFileNb
'        Do Until EOF(lngFileNb)
'            DoEvents
'            Line Input #lngFileNb, strBuff
'            logf.ajoutDebug "chargementFichiers", "Contenu : >>" & strBuff & "<<"
'            wksDest.Range("A" & CStr(cptLigne)).Value = strBuff
'            cptLigne = cptLigne + 1
'        Loop
'        oCollection.Add strFName
'        Close #lngFileNb
'        strFName = Dir
'    Loop
'
'    'Rectification du nombre de lignes r|fffd|ellement lues
'    cptLigne = cptLigne - 1
'
'    'Tri de l'ensemble des donn|fffd|es
'    logf.ajoutInfo "chargementFichiers", "Tri des donn|fffd|es charg|fffd|es (" & cptLigne & IIf(cptLigne > 1, " lignes)", " ligne)")
'    wksDest.Sort.SortFields.Clear
'    wksDest.Sort.SortFields.Add Key:=Range("A1:A" & CStr(cptLigne)) _
'        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
'    With wksDest.Sort
'        .SetRange Range("A1:A" & CStr(cptLigne))
'        .Header = xlGuess
'        .MatchCase = False
'        .Orientation = xlTopToBottom
'        .SortMethod = xlPinYin
'        .Apply
'    End With
'
'    'Valeur de retour : le nombre de lignes
'    chargementFichiers = cptLigne
'
'End Function
'
'
'
'
'
''' Fonction : ObtenirNumeroDossier
''   Input : n|fffd|ant
''  Output : chaine de caract|fffd|re en 6 positions indiquant le num|fffd|ro de dossier en cours de traitement
''           alternativement : chaine vide mentionnant un arr|fffd|t d|fffd|clench|fffd| par l'utilisateur
'Private Function ObtenirNumeroDossier(log As Logger) As String
'    'Variables locales
'    Dim retVal As String
'    Dim strValue As String
'    Dim blnContinuer As Boolean
'    Dim cpt As Long
'
'    'Initialisations diverses
'    retVal = ""
'    blnContinuer = True
'
'    'Lire le num|fffd|ro de dossier
'    While blnContinuer
'        strValue = InputBox("Veuillez introduire le num|fffd|ro de dossier en 6 positions (format Geco-GeFac-FH)" & vbCrLf & _
'                            "(0 pour annuler)", "Num|fffd|ro de dossier ?", "000000")
'
'        For cpt = 1 To Len(strValue)
'            If Not IsNumeric(Mid(strValue, cpt, 1)) Then
'                Mid(strValue, cpt, 1) = "X"
'            End If
'        Next
'
'        If IsNumeric(strValue) Then
'            If CLng(strValue) = 0 Then
'                MsgBox "Annulation |fffd| la demande de l'utilisateur.", vbInformation, "Annulation"
'                log.ajoutInfo "ObtenirNumeroDossier", "Arr|fffd|t du traitement |fffd| la demande de l'utilisateur"
'                blnContinuer = False
'                retVal = ""
'            ElseIf CLng(strValue) <= 0 Or CLng(strValue) > 999999 Then
'                MsgBox "Le num|fffd|ro de dossier n'est pas valide ! Veuillez utiliser un nombre entre 1 et 999999.", vbOKOnly + vbCritical
'            Else
'                blnContinuer = False
'                retVal = Right("000000" & Trim(strValue), 6)
'            End If
'        Else
'            MsgBox "Le num|fffd|ro de dossier n'est pas valide ! Veuillez utiliser le format ForHRM (sans lettre).", vbOKOnly + vbCritical
'        End If
'    Wend
'
'
'    'D|fffd|finition de la valeur de retour
'    ObtenirNumeroDossier = retVal
'
'End Function
'
'
Attribute VB_Name = "GLOB_UtilitairesExcel"

Public Function obtenirNomFeuilleMoisSuivant(ByRef wkb As Workbook, ByRef dtMois As Date)
    Dim strNomFeuille As String
    
    strNomFeuille = obtenirNomFeuilleMoisMax(wkb)
    'Condition toujours vraie. Test utilis|fffd| pour son effet de bord : obtenir la date
    If estNomDeMois(strNomFeuille, dtMois) Then
        dtMois = DateSerial(Year(dtMois), Month(dtMois) + 1, 1)
    End If
    obtenirNomFeuilleMoisSuivant = Format(Month(dtMois), "00") & "-" & Format(Year(dtMois), "0000")
End Function

Public Function obtenirNomFeuilleMoisMax(Optional ByRef wkb As Workbook) As String
    Dim cpt As Long, lngNbSheets As Long
    Dim wks As Worksheet, trtWkb As Workbook
    Dim dtTmp As Date, dtMax As Date
    
    dtMax = DateSerial(2018, 1, 5)
    
    If wkb Is Nothing Then
        Set trtWkb = ThisWorkbook
    Else
        Set trtWkb = wkb
    End If
    lngNbSheets = trtWkb.Sheets.Count
    
    For Each wks In trtWkb.Sheets
        If estNomDeMois(wks.Name, dtTmp) Then
            If dtTmp > dtMax Then
                dtMax = dtTmp
            End If
        End If
    Next
    If dtMax = DateSerial(2018, 1, 5) Then
        dtMax = DateSerial(Year(Now), Month(Now), 1)
    End If
    
    obtenirNomFeuilleMoisMax = Format(Month(dtMax), "00") & "-" & Format(Year(dtMax), "0000")
    
End Function


'Supprime, si elle existe, la feuille portant le nom transmis en param|fffd|tre.
Public Sub SheetKiller(strName As String, Optional ByRef wkb As Workbook)
    Dim cpt As Long, lngNbSheets As Long
    Dim trtWkb As Workbook
    
    If wkb Is Nothing Then
        Set trtWkb = ActiveWorkbook
    Else
        Set trtWkb = wkb
    End If
    
    lngNbSheets = trtWkb.Sheets.Count
    
    For cpt = lngNbSheets To 1 Step -1
        If trtWkb.Sheets(cpt).Name = strName Then
            Application.DisplayAlerts = False
            trtWkb.Sheets(cpt).Delete
            Application.DisplayAlerts = True
        End If
    Next
End Sub


'Teste si une feuille strNomFeuille existe dans le workbook wkb
Public Function feuilleExiste(strNomFeuille As String, ByRef wkb As Workbook)
   Dim wks As Worksheet
   
   On Error Resume Next
   Set wks = wkb.Sheets(strNomFeuille)
   
   On Error GoTo 0
   feuilleExiste = Not wks Is Nothing
End Function


'Teste si le nom d'une feuille est un nom de mois. Si c'est le cas, retourne le premier jour du mois concern|fffd|
Public Function estNomDeMois(strSheetName As String, ByRef dtPremJourMois As Date) As Boolean

    Dim strNomFeuilleTrt() As String
    Dim strTest As String
    Dim blnCorrect As Boolean
    
    On Error GoTo ErrHandler
    
    blnCorrect = False
    
    strNomFeuilleTrt = Split(strSheetName, "-")
    If UBound(strNomFeuilleTrt) - LBound(strNomFeuilleTrt) = 1 Then
        'On a bien deux |fffd|l|fffd|ments s|fffd|par|fffd|s par un tiret
        If strNomFeuilleTrt(1) = Format(CLng(strNomFeuilleTrt(1)), "0000") And strNomFeuilleTrt(0) = Format(CLng(strNomFeuilleTrt(0)), "00") Then
            ' Les deux parties sont bien constitu|fffd|es de deux nombres
            dtPremJourMois = DateSerial(CLng(strNomFeuilleTrt(1)), CLng(strNomFeuilleTrt(0)), 1)
            blnCorrect = True
        End If
    End If
    
Sortie:
    estNomDeMois = blnCorrect
    Exit Function
    
ErrHandler:
    If Err.Number = 13 Then
        'Erreur de conversion de type de donn|fffd|es, li|fffd| |fffd| la ligne de conversion du nom en type Long
        blnCorrect = False
        Err.Clear
    End If
    Resume Sortie
End Function



Public Sub testNomMois(Optional blnDoNotShowMe As Boolean = True)
    Dim dtTmp As Date
    Dim wkb As Workbook
    Dim wks As Worksheet
    Set wkb = ThisWorkbook
    
    For Each wks In wkb.Sheets
        Debug.Print wks.Name & " : ";
        If estNomDeMois(wks.Name, dtTmp) Then
            Debug.Print Format(dtTmp, "YYYY-MM-DD")
        Else
            Debug.Print "KO"
        End If
    Next
End Sub


Public Function safeDate(dtDate As Date) As Date
    safeDate = DateSerial(Year(dtDate), Month(dtDate), Day(dtDate))
End Function


Public Function existeGrillesHorairesFichierCourant(ByRef wksGH As Worksheet) As Boolean
    Dim retVal As Boolean
    Dim wkb As Workbook
    Dim wks As Worksheet
    retVal = False
    
    Set wkb = ActiveWorkbook
    
    For Each wks In wkb.Worksheets
        If wks.Name = "GH - Travailleurs" Then
            retVal = True
            Set wksGH = wks
            Exit For
        End If
    Next
    
    existeGrillesHorairesFichierCourant = retVal
End Function

Attribute VB_Name = "GLOB_UtilitairesXML"
Option Explicit

'
'
' Module : UtilitairesXML
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Fournir un certain nombre de fonctions n|fffd|cessaires pour g|fffd|n|fffd|rer des fichiers XML.
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  GestionRepertoires                   |     1.00
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'

'Ecriture dans un fichier
Public Sub outputRawData(intFileHandler As Long, strContent As String)
    Print #intFileHandler, strContent
End Sub

Public Sub SingleTagContent(intFileHandler As Long, intNbTab As Long, strTagName As String, strTagValue As String)
    outputRawData intFileHandler, getSingleTagContent(intNbTab, strTagName, strTagValue)
End Sub

Public Sub StartTag(intFileHandler As Long, intNbTab As Long, strTagName As String)
    outputRawData intFileHandler, getStartTagContent(intNbTab, strTagName)
End Sub

Public Sub EndTag(intFileHandler As Long, intNbTab As Long, strTagName As String)
    outputRawData intFileHandler, getEndTagContent(intNbTab, strTagName)
End Sub



Public Function getEndTagContent(intNbTab As Long, strTagName As String)
    getEndTagContent = getStartTagContent(intNbTab, "/" & strTagName)
End Function

Public Function getStartTagContent(intNbTab As Long, strTagName As String)
    getStartTagContent = String(intNbTab, vbTab) & "<" & strTagName & ">"
End Function

Public Function getSingleTagContent(intNbTab As Long, strTagName As String, strTagValue As String) As String
    getSingleTagContent = String(intNbTab, vbTab) & "<" & strTagName & ">" & strTagValue & "</" & strTagName & ">"
End Function
Attribute VB_Name = "GLOB_WindowsAPI"
Option Explicit

Public Const GWL_STYLE = -16
Public Const WS_CAPTION = &HC00000

Public Declare PtrSafe Function GetWindowLong _
                       Lib "user32" Alias "GetWindowLongA" ( _
                       ByVal hWnd As Long, _
                       ByVal nIndex As Long) As Long
Public Declare PtrSafe Function SetWindowLong _
                       Lib "user32" Alias "SetWindowLongA" ( _
                       ByVal hWnd As Long, _
                       ByVal nIndex As Long, _
                       ByVal dwNewLong As Long) As Long
Public Declare PtrSafe Function DrawMenuBar _
                       Lib "user32" ( _
                       ByVal hWnd As Long) As Long
Public Declare PtrSafe Function FindWindowA _
                       Lib "user32" (ByVal lpClassName As String, _
                       ByVal lpWindowName As String) As Long


' Regroupe les d|fffd|clarations n|fffd|cessaires pour l'acc|fffd|s aux API de Windows
' Toutes les APIS d|fffd|clar|fffd|es (en amont) sont priv|fffd|es. Une fonction d'acc|fffd|s est d|fffd|finie plus bas dans le module.

Private Declare PtrSafe Function GetPrivateProfileString _
         Lib "kernel32" _
         Alias "GetPrivateProfileStringA" _
         (ByVal lpApplicationName As String, _
         ByVal lpKeyName As Any, _
         ByVal lpDefault As String, _
         ByVal lpReturnedString As String, _
         ByVal nSize As Long, _
         ByVal lpFileName As String) As Long
 

Private Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" _
         Alias "WritePrivateProfileStringA" _
         (ByVal lpApplicationName As String, _
         ByVal lpKeyName As Any, _
         ByVal lpString As Any, _
         ByVal lpFileName As String) As Long
 
Private Declare PtrSafe Function GetSystemDefaultLCID Lib "kernel32" () As Long

Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" _
        Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
        
    
 
' A partir de ce point : Fonctions d'acc|fffd|s
 
Public Function EcritureIniString(strFileName As String, strSection As String, strCle As String, strValeur As String) As Boolean
    Dim lngReponse As Long
    
    lngReponse = WritePrivateProfileString(strSection, strCle, strValeur, strFileName)
    EcritureIniString = IIf(lngReponse = 1, True, False)
End Function
 
Public Function LectureIniString(strFileName As String, strSection As String, strCle As String) As String
    Dim strBuffer As String, lngBufferSize As Long, lngLongueurReponse As Long
    
    strBuffer = Space$(255)
    lngBufferSize = 255
    lngLongueurReponse = GetPrivateProfileString(strSection, strCle, "", strBuffer, lngBufferSize, strFileName)
    
    LectureIniString = Left$(strBuffer, lngLongueurReponse)
End Function
 


Public Function ObtenirSeparateurDecimal() As String
    Dim strTampon As String
    Dim lngLongueurTampon As Long
    Dim lngReturnValue As Long
    Dim LCID As Long
    
    LCID = GetSystemDefaultLCID
    
    lngLongueurTampon = 255
    strTampon = String$(lngLongueurTampon, vbNullChar)
    
    lngReturnValue = GetLocaleInfo(LCID, &HE, strTampon, lngLongueurTampon)
    
    If lngReturnValue > 0 Then
        ObtenirSeparateurDecimal = Left$(strTampon, lngReturnValue - 1)
    End If
End Function



Sub HideTitleBar(frm As Object)
    Dim lngWindow As Long
    Dim lFrmHdl As Long
    lFrmHdl = FindWindowA(vbNullString, frm.Caption)
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    Call SetWindowLong(lFrmHdl, GWL_STYLE, lngWindow)
    Call DrawMenuBar(lFrmHdl)
End Sub

Attribute VB_Name = "GenerateurXML"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Classe : GenerateurXML
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Permettre la g|fffd|n|fffd|ration du fichier XML "Interface Prestations" sur base des informations m|fffd|moris|fffd|es
'  Fonctionnalit|fffd|s disponibles :
'   * D|fffd|finir les param|fffd|tres de base : num|fffd|ro de dossier
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  UtilitairesXML                       | 1.00
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale - support pointeuse appipay
'

'Impl|fffd|mente l'interface Generateur
Implements IGenerateur



Private Const C_VERSION As String = "1.0"
Private Const C_FORMAT As String = "XML appipay"

Private strGenName As String
Private strDossier As String
Private blnDossier As Boolean
Private strNomDossier As String
Private lngAnnee As Long
Private lngMois As Long
Private strPeriodePaie As String
Private blnPeriodePaie As Boolean
Private strDateEnvoi As String
Private collTravailleurs As Collection

Private Sub Class_Initialize()
    'D|fffd|finition des valeurs fig|fffd|es
    strGenName = "UCM-automatisation - " & C_FORMAT & " - v." & C_VERSION
    strDateEnvoi = Format(Now, "YYYY-MM-DD") & "T" & Format(Now, "hh:mm:ss") & ".0"
    
    'Initialisation des valeurs internes
    strDossier = ""
    strNomDossier = ""
    lngAnnee = Year(Now)
    lngMois = Month(Now)
    strPeriodePaie = ""
    Set collTravailleurs = New Collection
    
    'Indicateurs de compl|fffd|tion de donn|fffd|es
    blnDossier = False
    blnPeriodePaie = False
End Sub

Private Function IGenerateur_ajouterTravailleur(newTrav As ITravailleur) As Boolean
    Dim retVal As Boolean
    
    retVal = True
    If existeTravailleur(newTrav.NumeroTravailleur) Then retVal = False
    
    If retVal Then collTravailleurs.Add newTrav, newTrav.NumeroTravailleur
    
    IGenerateur_ajouterTravailleur = retVal
End Function


Private Function existeTravailleur(strNumTrav As String) As Boolean
    Dim travTest As ITravailleur
    Dim retVal As Boolean
    
    retVal = False
    
    For Each travTest In collTravailleurs
        If travTest.NumeroTravailleur = strNumTrav Then retVal = True
    Next
    
    existeTravailleur = retVal
End Function

' NoDossier contient le num|fffd|ro du dossier pour lequel nous g|fffd|n|fffd|rons un XML
' Le contenu de cette propri|fffd|t|fffd| doit |fffd|tre valide.
' Origine : Interface du g|fffd|n|fffd|rateur
'#UnitTestOK
Public Property Get IGenerateur_Dossier() As String
    If blnDossier Then
        IGenerateur_Dossier = strDossier
    Else
        IGenerateur_Dossier = "undef."
    End If
End Property
Public Property Let IGenerateur_Dossier(ByVal strValue As String)
    strDossier = strValue
    blnDossier = True
End Property

Private Sub IGenerateur_GenererSynthese(ByVal strFileName As String, ByRef ufRes As usrFormResultatTraitement)
    Dim trav As ITravailleur
    Dim contrat As IContrat
    Dim cpt As Long
    
    If Me.IGenerateur_estDefDossier And Me.IGenerateur_estDefPeriode Then
        ufRes.AjouterInfo "  => N|fffd| de dossier          : " & strDossier
        ufRes.AjouterInfo "  => P|fffd|riode paie           : " & strPeriodePaie
        ufRes.AjouterInfo "  => Date envoi             : " & strDateEnvoi
        ufRes.AjouterInfo "  => Nombre de travailleurs : " & collTravailleurs.Count
        For Each trav In collTravailleurs
            ufRes.AjouterInfo "       * Trav. " & trav.NumeroTravailleur & " (Contrats : " & trav.Contrats.Count & ")"
            For Each contrat In trav.Contrats
                If trav.Contrats.Count > 1 Then
                    ufRes.AjouterInfo "            * Contrat " & contrat.ReferencePointeuse
                End If
                ufRes.AjouterInfo "            * Nb Jours Prestation : " & contrat.Prestations.JoursPrestations.Count
                For cpt = 1 To contrat.Prestations.getNbCodes
                    ufRes.AjouterInfo String(15, " ") & "* " & contrat.Prestations.getPrestDetails(cpt)
                Next
            Next
                    
            
        Next
        
    End If

End Sub

'Nom du dossier (facultatif)
' Si rempli, est communiqu|fffd| dans le XML
' Aucun contr|fffd|le sur la valeur
'#UnitTestOK
Public Property Get IGenerateur_NomDossier() As String
    IGenerateur_NomDossier = strNomDossier
End Property
Public Property Let IGenerateur_NomDossier(ByVal strValue As String)
    strNomDossier = strValue
End Property

' Propri|fffd|t|fffd| Read-Only
' Nom du fournisseur pour appipay
Public Property Get IGenerateur_Fournisseur() As String
    IGenerateur_Fournisseur = strGenName
End Property

'Propri|fffd|t|fffd| Read-Only
' Date de la g|fffd|n|fffd|ration du fichier
Public Property Get IGenerateur_DateEnvoi() As String
    IGenerateur_DateEnvoi = strDateEnvoi
End Property





'#UnitTestEnCours
Public Function IGenerateur_GenererOutput(ByVal strFileName As String) As Boolean
    Dim retVal As Boolean
    Dim trav As ITravailleur
    
    If Me.IGenerateur_estDefDossier And Me.IGenerateur_estDefPeriode Then
        
        Dim fh As Long 'File Handler
        fh = FreeFile
        
        Open strFileName For Output As #fh
        
        StartTag fh, 0, "?xml version=""1.0"" encoding=""UTF-8""?"
        StartTag fh, 0, "ReceptionPointeuse xmlns=""http://www.ucm.be/appipay/ReceptionPointeuse/1.0"""
        
        SingleTagContent fh, 1, "dossier", strDossier
        SingleTagContent fh, 1, "fournisseur", strGenName
        If Not Len(strNomDossier) = 0 Then
            SingleTagContent fh, 1, "nomEmployeur", strNomDossier
        End If
        SingleTagContent fh, 1, "periodePaie", strPeriodePaie
        SingleTagContent fh, 1, "dateEnvoi", strDateEnvoi
        
        If collTravailleurs.Count > 0 Then
            StartTag fh, 1, "travailleurs"
            For Each trav In collTravailleurs
                GenererOutputTravailleur fh, 2, trav
            Next
            EndTag fh, 1, "travailleurs"
        End If
        
        EndTag fh, 0, "ReceptionPointeuse"
        
        Close #fh
        retVal = True
    Else
        retVal = False
    End If
    
    IGenerateur_GenererOutput = retVal
End Function


Private Sub GenererOutputTravailleur(ByVal fileH As Long, nbTabs As Long, trav As ITravailleur)
    Dim contr As IContrat
    
    StartTag fileH, nbTabs, "travailleur"
    
    SingleTagContent fileH, nbTabs + 1, "numeroTravailleur", trav.NumeroTravailleur
    'D|fffd|sactivation mention NISS
    'SingleTagContent fileH, nbTabs + 1, "nissTravailleur", String(11, "0")
    
    If trav.Contrats.Count > 0 Then
        StartTag fileH, nbTabs + 1, "contrats"
        For Each contr In trav.Contrats
            GenererOutputContrat fileH, nbTabs + 2, contr
        Next
        EndTag fileH, nbTabs + 1, "contrats"
    End If
    
    EndTag fileH, nbTabs, "travailleur"
End Sub


Private Sub GenererOutputContrat(ByVal fileH As Long, nbTabs As Long, contrat As IContrat)
    Dim scr As IScript
    Dim pla As IPlanning
    
    StartTag fileH, nbTabs, "contrat"
    
    If contrat.estDefinieReferencePointeuse Then
        SingleTagContent fileH, nbTabs + 1, "referencePointeuse", contrat.ReferencePointeuse
    End If
    
    If contrat.CodesDivers.Count > 0 Then
        StartTag fileH, nbTabs + 1, "ScriptPeriode"
        StartTag fileH, nbTabs + 2, "rubriques"
        
        For Each scr In contrat.CodesDivers
            GenererOutputScript fileH, nbTabs + 3, scr
        Next
        
        EndTag fileH, nbTabs + 2, "rubriques"
        EndTag fileH, nbTabs + 1, "ScriptPeriode"
    End If
    
    If contrat.Prestations.estDefini Then
        GenererOutputPlanning fileH, nbTabs + 1, contrat.Prestations
    End If
    
    EndTag fileH, nbTabs, "contrat"
End Sub

Private Sub GenererOutputPlanning(ByVal fileH As Long, nbTabs As Long, Planning As IPlanning)
    Dim JourPrestations As IJourPrestations
    
    StartTag fileH, nbTabs, "Planning"
    
    For Each JourPrestations In Planning.JoursPrestations
        GenererOutputJourPrestations fileH, nbTabs + 1, JourPrestations
    Next
    
    EndTag fileH, nbTabs, "Planning"
End Sub

Private Sub GenererOutputJourPrestations(ByVal fileH As Long, nbTabs As Long, jourP As IJourPrestations)
    Dim prest As IPrestation
    StartTag fileH, nbTabs, "Jour"
    
    SingleTagContent fileH, nbTabs + 1, "jourMois", jourP.DatePrestation
    If jourP.Prestations.Count > 0 Then
        StartTag fileH, nbTabs + 1, "prestations"
        For Each prest In jourP.Prestations
            GenererOutputPrestation fileH, nbTabs + 2, prest
        Next
        EndTag fileH, nbTabs + 1, "prestations"
        
    End If
    
    EndTag fileH, nbTabs, "Jour"
End Sub

Private Sub GenererOutputPrestation(ByVal fileH As Long, nbTabs As Long, prest As IPrestation)
    Dim strPrimesContent As String
    
    strPrimesContent = ""
    
    StartTag fileH, nbTabs, "Prestation"
    
    SingleTagContent fileH, nbTabs + 1, "numLigne", prest.numLigne
    SingleTagContent fileH, nbTabs + 1, "codePaie", prest.codePaie
    'Correction : heure au format XX.XX
    SingleTagContent fileH, nbTabs + 1, "nbrHeures", Replace(CStr(Format(prest.NbHeures, "#0.00")), ",", ".")
    
    'Uniquement pour le code de prestation vis|fffd|
'    If prest.codePaie = "0001.00" Then
'        'A reproduire pour chaque type de prime
'        'Id|fffd|alement => constituer un tableau et globaliser le traitement.
'        If parametresMacroUCM.PrimeNuitActive Then
'            If Len(strPrimesContent) > 0 Then strPrimesContent = strPrimesContent & vbCrLf
'            strPrimesContent = strPrimesContent & getStartTagContent(nbTabs + 2, "prime") & vbCrLf
'            strPrimesContent = strPrimesContent & getSingleTagContent(nbTabs + 3, "codePrime", "PNUIT") & vbCrLf
'            strPrimesContent = strPrimesContent & getSingleTagContent(nbTabs + 3, "valeur", IIf(prest.primeNuit, "YES", "NO")) & vbCrLf
'            strPrimesContent = strPrimesContent & getEndTagContent(nbTabs + 2, "prime")
'        End If
'        If parametresMacroUCM.PrimeEquipeActive Then
'            If Len(strPrimesContent) > 0 Then strPrimesContent = strPrimesContent & vbCrLf
'            strPrimesContent = strPrimesContent & getStartTagContent(nbTabs + 2, "prime") & vbCrLf
'            strPrimesContent = strPrimesContent & getSingleTagContent(nbTabs + 3, "codePrime", "PEQUIPE") & vbCrLf
'            strPrimesContent = strPrimesContent & getSingleTagContent(nbTabs + 3, "valeur", IIf(prest.primeEquipe, "YES", "NO")) & vbCrLf
'            strPrimesContent = strPrimesContent & getEndTagContent(nbTabs + 2, "prime")
'        End If
'    End If
    
    If Len(strPrimesContent) > 0 Then
        StartTag fileH, nbTabs + 1, "primes"
        outputRawData fileH, strPrimesContent
        EndTag fileH, nbTabs + 1, "primes"
    End If
    EndTag fileH, nbTabs, "Prestation"
End Sub


Private Sub GenererOutputScript(ByVal fileH As Long, nbTabs As Long, scr As IScript)
    StartTag fileH, nbTabs, "rubrique"
    
    SingleTagContent fileH, nbTabs + 1, "codePaie", scr.CodeRubrique
    If scr.TypeRubrique = typeRubriqueMontant Then
        SingleTagContent fileH, nbTabs + 1, "montant", Round(scr.Montant, 2)
    ElseIf scr.TypeRubrique = typeRubriqueUnite Then
        SingleTagContent fileH, nbTabs + 1, "nbrUnite", CLng(scr.NbUnites)
    End If
    
    EndTag fileH, nbTabs, "rubrique"
End Sub


'D|fffd|finition de la p|fffd|riode de paie courante
' Contr|fffd|les : ann|fffd|e >= 2015 et <= 2100
' Mois compris entre 1 et 12
' Retourne True si la d|fffd|finition est correcte
' Retourne False s'il y a un probl|fffd|me
'#UnitTestOK
Public Function IGenerateur_definirPeriodePaie(ByVal lngAnneeNew As Long, ByVal lngMoisNew As Long) As Boolean
    blnPeriodePaie = True
    strPeriodePaie = ""
    
    If lngAnneeNew < 2015 Or lngAnneeNew > 2100 Then
        blnPeriodePaie = False
        'Debug.Print "GenerateurXML :: definirPeriodePaie : ann|fffd|e introduite incorrecte (entre 2015 et 2100) : " & lngAnneeNew
    End If
    
    If lngMoisNew < 1 Or lngMoisNew > 12 Then
        blnPeriodePaie = False
        'Debug.Print "GenerateurXML :: definirPeriodePaie : mois introduit incorrect (entre 1 et 12 !) : " & lngMoisNew
    End If
     
    If blnPeriodePaie Then
        lngAnnee = lngAnneeNew
        lngMois = lngMoisNew
        strPeriodePaie = CStr(lngAnnee) & Right("00" & CStr(lngMois), 2)
    End If
    
    IGenerateur_definirPeriodePaie = blnPeriodePaie
End Function

'#UnitTestOK
Public Property Get IGenerateur_Periode() As String
    IGenerateur_Periode = CStr(lngAnnee) & Right("00" & CStr(lngMois), 2)
End Property

'#UnitTestOK
Public Property Get IGenerateur_estDefDossier() As Boolean
    IGenerateur_estDefDossier = blnDossier
End Property

'#UnitTestOK
Public Property Get IGenerateur_estDefPeriode() As Boolean
    IGenerateur_estDefPeriode = blnPeriodePaie
End Property

Attribute VB_Name = "GenerationFeuilles"

'Permet le test de la g|fffd|n|fffd|ration des feuilles

Public Sub testGeneration(Optional blnDoNotShowMe As Boolean = True)
    
'    SheetKiller ("07-2018")
'    SheetKiller ("08-2018")
'    SheetKiller ("09-2018")
'    SheetKiller ("01-2019")
    GenererFeuillePrestations ActiveWorkbook, 7, 2018
    GenererFeuillePrestations ActiveWorkbook, 8, 2018
    GenererFeuillePrestations ActiveWorkbook, 9, 2018
    GenererFeuillePrestations ActiveWorkbook, 10, 2018
    GenererFeuillePrestations ActiveWorkbook, 11, 2018
    GenererFeuillePrestations ActiveWorkbook, 12, 2018
    GenererFeuillePrestations ActiveWorkbook, 1, 2019
    Debug.Print "Termin|fffd|"
End Sub


Public Sub generationAnnee(Optional blnDoNotShowMe As Boolean = True)
    GenererFeuillePrestations ActiveWorkbook, 9, 2018
    GenererFeuillePrestations ActiveWorkbook, 10, 2018
    GenererFeuillePrestations ActiveWorkbook, 11, 2018
    GenererFeuillePrestations ActiveWorkbook, 12, 2018
    GenererFeuillePrestations ActiveWorkbook, 1, 2019
    Debug.Print "Termin|fffd|"
End Sub




'G|fffd|n|fffd|re, pour le mois consid|fffd|r|fffd|, la feuille de prestations dans son ensemble, en g|fffd|rant les liens avec la feuille pr|fffd|c|fffd|dente.
Public Sub GenererFeuillePrestations(ByRef wkb As Workbook, lngMois As Long, lngAnnee As Long)
    Dim wks As Worksheet
    Dim lngNbJoursMois As Long
    Dim GHS As New GrillesHoraires
    Dim cptTravs As Long, lngLigneActivePourInsertion As Long
    Dim strPrevMonthSheet As String, lngPrevA As Long, lngPrevM As Long
    Dim wksTmp As Worksheet
    
    Debug.Print "G|fffd|n|fffd|ration en cours : " & lngMois & " " & lngAnnee
    
    Application.ScreenUpdating = False
    
    lngPrevM = lngMois - 1
    lngPrevA = lngAnnee
    If lngPrevM = 0 Then
        lngPrevM = 12
        lngPrevA = lngAnnee - 1
    End If
    
    strPrevMonthSheet = Format(lngPrevM, "00") & "-" & Format(lngPrevA, "0000")
        
    Set wks = wkb.Sheets.Add(ActiveWorkbook.Sheets(1))
    wks.Name = Format(lngMois, "00") & "-" & Format(lngAnnee, "0000")
    wks.Activate
    wks.EnableCalculation = False
    If feuilleExiste(strPrevMonthSheet, ActiveWorkbook) Then
        Set wksTmp = wkb.Sheets(strPrevMonthSheet)
        wksTmp.Outline.ShowLevels , 3
    End If
    
    lngNbJoursMois = calculerNbJoursDansLeMois(lngMois, lngAnnee)
    
    'Cr|fffd|ation des trois premi|fffd|res lignes
    ajouterTitreTableauPrestations wks, lngMois, lngAnnee, lngNbJoursMois
    
    lngLigneActivePourInsertion = C_PR_LIGNE_DEB
    ' lire les travailleurs et les ajouter au tableau.
    If GHS.ChargerGrillesAPartirDeFeuille(wks.Parent.Sheets("GH - Travailleurs")) Then
        For cptTravs = 1 To GHS.Count
            'Pour chaque travailleur dans la liste des travailleurs |fffd| traiter, cr|fffd|ation des trois lignes n|fffd|cessaires par travailleur.
            lngLigneActivePourInsertion = ajouterLignesTravailleur(wks, lngMois, lngAnnee, lngNbJoursMois, GHS.GHTravailleur(cptTravs), lngLigneActivePourInsertion, strPrevMonthSheet)
        Next
    End If
    
    lngLigneActivePourInsertion = lngLigneActivePourInsertion + 3
    
    'Cr|fffd|ation du tableau de r|fffd|capitulatif : couverture des ETP
    ajouterTableauRecapitulatif wks, lngLigneActivePourInsertion, lngNbJoursMois
    
    'Finalisation de la feuille
    wks.EnableCalculation = True
    wks.Activate
    wks.Range("A1").Activate
    wks.Range("E4:E6").Select
    ActiveWindow.FreezePanes = True

    ' Regroupement des semaines
    wks.Outline.ShowLevels 1, 1
    'R|fffd|activation du calcul |fffd| la fin pour ne pas |fffd|tre ennuy|fffd| lors de la cr|fffd|ation de la feuille...
    
    Application.ScreenUpdating = True
    
    wks.Parent.Save
    
    UCM_Protect
    
    If Not wksTmp Is Nothing Then
        wksTmp.Outline.ShowLevels , 1
    End If
End Sub

'Retourne le num|fffd|ro de ligne suivant pour l'insertion subs|fffd|quente.
Private Function ajouterLignesTravailleur(ByRef wks As Worksheet, lngMois As Long, lngAnnee As Long, lngNbJoursMois As Long, GHT As GrilleHoraireTravailleur, lngNumLigne As Long, strMoisPrec As String) As Long
    Dim lngCpt As Long, lngColonne As Long
    Dim strRangeBlocComplet As String
    Dim rg As Range, fc As FormatCondition
    Dim strFormuleHrsSupp As String
    
    Dim lngPremJour As Long 'M|fffd|morisation pour le calcul des sommes
    Dim lngNbRecapHebd As Long  'G|fffd|rer le d|fffd|calage
    
    'D|fffd|terminer si contrat actif
    If DateSerial(lngAnnee, lngMois, 1) <= GHT.FinContrat And DateSerial(lngAnnee, lngMois + 1, -1) >= GHT.DebutContrat Then
        
        travAjouterInfosSignaletique wks, GHT, lngNumLigne, lngAnnee, lngMois
        strFormuleHrsSupp = "=" & travAjouterCompteursMoisPrec(wks, GHT, lngNumLigne, strMoisPrec)
        
        'Traitement des blocs de jours...
        lngPremJour = C_PR_COL_DET_PRES_START                  'pour g|fffd|rer le regroupement par semaine.
        lngNbRecapHebd = 0              'pour le d|fffd|calage des cellules par rapport au jour du mois
        
        For lngCpt = 1 To lngNbJoursMois
            lngColonne = C_PR_COL_DET_PRES_START + lngNbRecapHebd + C_PR_NB_COLS_PAR_JOUR * (lngCpt - 1)    'position de d|fffd|part + nombre de cellules de synth|fffd|se hebdomadaires + 1 bloc de 4 colonnes par jour
            
            If InStr(wks.Cells(C_PR_LIGNE_TITRE, lngColonne), "Synth|fffd|se") > 0 Then
                strFormuleHrsSupp = strFormuleHrsSupp & "+" & travAjouterInformationsSyntheseHebdomadaire(wks, GHT, lngNumLigne, lngColonne, lngNbRecapHebd, strMoisPrec, lngPremJour)
                
                'Incr|fffd|mentation et m|fffd|morisation de la nouvelle zone hebdomadaire
                lngColonne = lngColonne + 1
                lngNbRecapHebd = lngNbRecapHebd + 1
                lngPremJour = lngColonne
            End If
            
            travRemplirInfosJour wks, GHT, lngNumLigne, lngColonne, lngAnnee, lngMois, lngCpt
        Next
        
        'Se positionner sur la colonne suivante
        If InStr(wks.Cells(lngNumLigne, lngColonne), "Synth|fffd|se") > 0 Then
            lngColonne = lngColonne + 1
        Else
            lngColonne = lngColonne + 4
        End If
        
        'Synth|fffd|se derni|fffd|re semaine partielle
        strFormuleHrsSupp = strFormuleHrsSupp & "+" & travAjouterInformationsSyntheseHebdomadaire(wks, GHT, lngNumLigne, lngColonne, lngNbRecapHebd, strMoisPrec, lngPremJour)
        
        'Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne, lngColonne))
        'rg.Merge
        'rg.Cells(1, 1).Formula = "=calculHrsPrestees(" & obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, IIf(lngPremJour = 4, 5, lngPremJour), lngColonne - 1) & ")"
        'formaterRangeTableauPrestations wks, rg.Address
        'formaterRangeTotalHrsSem rg
        'Set rg = Nothing
        
        ' Hrs Supp apr|fffd|s
        lngColonne = lngColonne + 1
        Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne, lngColonne))
        rg.Merge
        formaterRangeTableauPrestations wks, rg.Address
        rg.Interior.Color = COLOR_BG_COMPUTED
        rg.Font.Color = ColorConstants.vbMagenta
        rg.Font.Bold = True
        rg.Cells(1, 1).Formula = strFormuleHrsSupp
        rg.Cells(1, 1).NumberFormat = "[hh]:mm"
        
        Set rg = Nothing
        
        'Et du coup, on ajoute les trois lignes n|fffd|cessaires pour le travailleur suivant
        ajouterLignesTravailleur = lngNumLigne + 3
    Else
        'on ne fait rien, d|fffd|s lors on reste sur la ligne |fffd| ajouter
        ajouterLignesTravailleur = lngNumLigne
    End If
    
End Function

'Fonctionnalit|fffd| permettant la cr|fffd|ation d'un tableau de gestion de couverture des ETP.
Private Sub ajouterTableauRecapitulatif(ByRef wks As Worksheet, lngNumLigne As Long, lngNbJoursMois As Long)
    Dim lngLigneFinZonePrestations As Long
    Dim rg As Range
    Dim cptHrs As Long
    Dim cptJour As Long
    Dim nbSyntheses As Long
    Dim lngColonne As Long
    Dim fc As FormatCondition
    
    nbSyntheses = 0
    
    lngLigneFinZonePrestations = lngNumLigne - 1
    
    ajouterTitreTableauRecapitulatif wks, lngNumLigne, lngNbJoursMois
    
    For cptHrs = 0 To 23
        DoEvents
        nbSyntheses = 0
        Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne + 1 + cptHrs, lngNumLigne + 1 + cptHrs, C_PR_COL_NUM, C_PR_COL_HRS_SUPP_PREC))
        rg.Merge
        rg.Cells(1, 1) = "De " & Format(cptHrs, "00") & ":00 |fffd| " & Format(cptHrs, "00") & ":59"
        formaterRangeTableauRecapitulatif rg, cptHrs
        Set rg = Nothing
        formaterRangeTableauRecapitulatif wks.Cells(lngNumLigne + 1 + cptHrs, C_PR_COL_HRS_SEM_PREC), cptHrs, False
        
        For cptJour = 1 To lngNbJoursMois
            DoEvents
            lngColonne = C_PR_COL_DET_PRES_START + nbSyntheses + C_PR_NB_COLS_PAR_JOUR * (cptJour - 1)
            If InStr(wks.Cells(1, lngColonne), "Synth") > 0 Then
                'Traiter la synth|fffd|se
                Set rg = wks.Cells(lngNumLigne + cptHrs + 1, lngColonne)
                formaterRangeTableauRecapitulatif rg, cptHrs, False
                lngColonne = lngColonne + 1
                nbSyntheses = nbSyntheses + 1
            End If
            Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne + cptHrs + 1, lngNumLigne + cptHrs + 1, lngColonne, lngColonne + 3))
            formaterRangeTableauRecapitulatif rg, cptHrs, False
            
            wks.Range(wks.Cells(lngNumLigne + cptHrs + 1, lngColonne), wks.Cells(lngNumLigne + cptHrs + 1, lngColonne + 1)).Merge
            wks.Range(wks.Cells(lngNumLigne + cptHrs + 1, lngColonne + 2), wks.Cells(lngNumLigne + cptHrs + 1, lngColonne + 3)).Merge
                        
            'Formule r|fffd|cup|fffd|ration des informations sur le nombre de personnes requises |fffd| ces jours et heures
            Set rg = wks.Cells(lngNumLigne + cptHrs + 1, lngColonne)
            rg.Formula = "=HLOOKUP(""" & codeJour(Weekday(wks.Cells(1, lngColonne))) & """,Couverture," & cptHrs + 2 & ",FALSE)"
            deprotectionCellules wks, rg.Address
            
            'Formule de calcul des ETP occup|fffd|s ce jour et heure
            Set rg = wks.Cells(lngNumLigne + cptHrs + 1, lngColonne + 2)
            rg.Formula = "=calculCouvertureETP(R4C[-2]:R" & lngLigneFinZonePrestations & "C," & cptHrs & ")"
            rg.Interior.Color = COLOR_BG_COMPUTED
            
            'D|fffd|finition de la mise en forme conditionnelle
            Set fc = rg.FormatConditions.Add(Type:=xlCellValue, Operator:=xlLess, Formula1:="=" & obtenirAdresseRange(wks, lngNumLigne + cptHrs + 1, lngNumLigne + cptHrs + 1, lngColonne, lngColonne))
            fc.SetFirstPriority
            fc.Font.Color = 255
            fc.Font.TintAndShade = 0
            fc.Font.Bold = True
            fc.Interior.PatternColorIndex = xlAutomatic
            fc.Interior.Color = 65535
            fc.Interior.TintAndShade = 0
            fc.StopIfTrue = False
            
            Set rg = Nothing
        Next
    Next
End Sub


Private Sub ajouterTitreTableauPrestations(ByRef wks As Worksheet, lngMois As Long, lngAnnee As Long, lngNbJoursMois As Long)

    Dim cptJour As Long             ' Boucle sur le jour
    Dim lngColDeb As Long           ' Colonne de d|fffd|but du jour
    Dim lngNbRecHebd As Long        ' Nombre de colonne de synth|fffd|se hebdomadaire introduits
    Dim lngDebZoneHebd As Long      ' Colonne de d|fffd|but pour le regroupement hebdomadaire
    Dim dtCourante As Date          ' Date en cours de traitement
    Dim strLibFerie As String
    Dim rg As Range
    
    wks.Cells(C_PR_LIGNE_TITRE, C_PR_COL_NUM) = "Mois : "
    wks.Cells(C_PR_LIGNE_TITRE + 1, C_PR_COL_NUM) = "Infos Travailleur"
    wks.Cells(C_PR_LIGNE_TITRE + 2, C_PR_COL_NUM) = "Num|fffd|ro UCM"
    
    wks.Cells(C_PR_LIGNE_TITRE, C_PR_COL_NOM) = DateSerial(lngAnnee, lngMois, 1)
    wks.Cells(C_PR_LIGNE_TITRE, C_PR_COL_NOM).NumberFormat = "mmmm yyy"
    wks.Cells(C_PR_LIGNE_TITRE + 2, C_PR_COL_NOM) = "Nom"
    wks.Cells(C_PR_LIGNE_TITRE + 2, C_PR_COL_POLE) = "P|fffd|le"
    wks.Cells(C_PR_LIGNE_TITRE, C_PR_COL_HRS_SUPP_PREC) = "Heures Supp. AVANT"
    wks.Cells(C_PR_LIGNE_TITRE, C_PR_COL_HRS_SEM_PREC) = "Total Hrs hebd sur mois pr|fffd|c."
    
    fusionnerRange wks, "B1:C1"
    fusionnerRange wks, "A2:C2"
    fusionnerRange wks, "D1:D3"
    fusionnerRange wks, "E1:E3"
    formaterRangeTitre wks, "A1:C3"
    formaterRangeTitre wks, "D1:E3"
    
    wks.Columns(1).ColumnWidth = 10
    wks.Columns(2).ColumnWidth = 24
    wks.Columns(3).ColumnWidth = 15
    
    lngNbRecHebd = 0
    lngDebZoneHebd = C_PR_COL_DET_PRES_START
     
    For cptJour = 1 To lngNbJoursMois
        lngColDeb = C_PR_COL_DET_PRES_START + lngNbRecHebd + (C_PR_NB_COLS_PAR_JOUR * (cptJour - 1))
        dtCourante = DateSerial(lngAnnee, lngMois, cptJour)
        
        If Weekday(dtCourante, vbMonday) = 1 And Day(dtCourante) > 1 Then
            'On est lundi => insertion du r|fffd|capitulatif hebdomadaire en bonne place
            wks.Cells(1, lngColDeb) = "Synth|fffd|se Hebd. du " & Format(wks.Cells(1, IIf(lngDebZoneHebd = C_PR_COL_DET_PRES_START, C_PR_COL_DET_PRES_START + 1, lngDebZoneHebd)), "dd/mm") & " au " & Format(wks.Cells(1, lngColDeb - C_PR_NB_COLS_PAR_JOUR), "dd/mm")
            
            fusionnerRange wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)
            formaterRangeTitre wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)
            wks.Range(obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)).ColumnWidth = 12
            wks.Range(obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngDebZoneHebd, lngColDeb - 1)).Group
            
            
            lngColDeb = lngColDeb + 1
            lngDebZoneHebd = lngColDeb              'Marquer pour la prochaine zone hebdomadaire
            
            lngNbRecHebd = lngNbRecHebd + 1
        End If
        
        
        Set rg = wks.Cells(C_PR_LIGNE_TITRE, lngColDeb)
        With rg
            .Value = dtCourante
            .NumberFormat = "dddd dd"
        End With
        
        wks.Cells(C_PR_LIGNE_TITRE + 2, lngColDeb) = "Code"
        wks.Cells(C_PR_LIGNE_TITRE + 2, lngColDeb + 1) = "De"
        wks.Cells(C_PR_LIGNE_TITRE + 2, lngColDeb + 2) = "A"
        wks.Cells(C_PR_LIGNE_TITRE + 2, lngColDeb + 3) = "Nb Hrs"
        
        fusionnerRange wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 1, lngColDeb, lngColDeb + 3)
        formaterRangeTitre wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb + 3)
    
        Set rg = wks.Cells(C_PR_LIGNE_TITRE, lngColDeb)
        With rg
            If estFerie(dtCourante, strLibFerie) Then
                DoEvents
                .Font.Italic = True
                .Font.Bold = True
                .Font.Size = .Font.Size + 1
                .Font.Color = RGB(250, 150, 150)
                .Cells(1, 1).AddComment strLibFerie
            End If
        End With
        
        If estCampagne(dtCourante) Then
            wks.Range(wks.Cells(C_PR_LIGNE_TITRE, lngColDeb), wks.Cells(C_PR_LIGNE_TITRE + 2, lngColDeb + 3)).Font.Color = COLOR_FT_CAMPAGNE_JR
        End If
        
        adapterLargeurColonnes wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb + 3)
        
    Next
    lngColDeb = C_PR_COL_DET_PRES_START + lngNbRecHebd + (C_PR_NB_COLS_PAR_JOUR * lngNbJoursMois)
    
    
    'Partielle si le jour pr|fffd|c|fffd|dent n'est pas un dimanche, sinon, c'est une synth|fffd|se classique...
    If Weekday(wks.Cells(C_PR_LIGNE_TITRE, lngColDeb - 4)) = vbSunday Then
        wks.Cells(C_PR_LIGNE_TITRE, lngColDeb) = "Synth|fffd|se Hebd. du " & Format(wks.Cells(C_PR_LIGNE_TITRE, IIf(lngDebZoneHebd = C_PR_COL_DET_PRES_START, C_PR_COL_DET_PRES_START + 1, lngDebZoneHebd)), "dd/mm") & " au " & Format(wks.Cells(C_PR_LIGNE_TITRE, lngColDeb - C_PR_NB_COLS_PAR_JOUR), "dd/mm")
    Else
        wks.Cells(C_PR_LIGNE_TITRE, lngColDeb) = "Synth|fffd|se partielle du " & Format(wks.Cells(C_PR_LIGNE_TITRE, IIf(lngDebZoneHebd = C_PR_COL_DET_PRES_START, C_PR_COL_DET_PRES_START + 1, lngDebZoneHebd)), "dd/mm") & " au " & Format(wks.Cells(C_PR_LIGNE_TITRE, lngColDeb - C_PR_NB_COLS_PAR_JOUR), "dd/mm")
    End If
    fusionnerRange wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)
    formaterRangeTitre wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)
    wks.Range(obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)).ColumnWidth = 12
    wks.Range(obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngDebZoneHebd, lngColDeb - 1)).Group
    
    
    lngColDeb = lngColDeb + 1
    wks.Cells(C_PR_LIGNE_TITRE, lngColDeb) = "Heures Supp. APRES"
    fusionnerRange wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)
    formaterRangeTitre wks, obtenirAdresseRange(wks, C_PR_LIGNE_TITRE, C_PR_LIGNE_TITRE + 2, lngColDeb, lngColDeb)
    
End Sub


'Permet l'ajout de la ligne de titre du tableau de r|fffd|capitulatif de couverture ETP par jour et heure
Private Sub ajouterTitreTableauRecapitulatif(ByRef wks As Worksheet, lngNumLigne As Long, lngNbJoursMois As Long)
    Dim rg As Range
    Dim nbSyntheses As Long
    Dim cptJour As Long
    Dim lngColonne As Long
    
    'Colonnes 1 |fffd| 4
    Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne, lngNumLigne, C_PR_COL_NUM, C_PR_COL_HRS_SUPP_PREC))
    With rg
        .Merge
        formaterRangeTitre wks, .Address, True
        .Cells(1, 1) = "Couverture Horaire (en ETP)"
    End With
    
    Set rg = Nothing
    
    'Colonne 5 : vide (pas d'info |fffd| y mettre...)
    formaterRangeTitre wks, "E" & lngNumLigne & ":E" & lngNumLigne, True
    
    nbSyntheses = 0
    
    'Parcourir l'ensemble des jours du mois
    For cptJour = 1 To lngNbJoursMois
        DoEvents
        lngColonne = C_PR_COL_DET_PRES_START + nbSyntheses + C_PR_NB_COLS_PAR_JOUR * (cptJour - 1)
        If InStr(wks.Cells(C_PR_LIGNE_TITRE, lngColonne), "Synth") > 0 Then
            'Traiter la synth|fffd|se : cellule vide
            formaterRangeTitre wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne, lngColonne, lngColonne), True
            lngColonne = lngColonne + 1
            nbSyntheses = nbSyntheses + 1
        End If
        formaterRangeTitre wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne, lngColonne, lngColonne + 3), True
        
        'Titres des colonnes par jour (merge de 4 vers 2)
        wks.Cells(lngNumLigne, lngColonne) = "Requis"
        wks.Cells(lngNumLigne, lngColonne + 2) = "Pr|fffd|sents"
        wks.Range(wks.Cells(lngNumLigne, lngColonne), wks.Cells(lngNumLigne, lngColonne + 1)).Merge
        wks.Range(wks.Cells(lngNumLigne, lngColonne + 2), wks.Cells(lngNumLigne, lngColonne + 3)).Merge
        
        If estCampagne(wks.Cells(C_PR_LIGNE_TITRE, lngColonne)) Then
            'Couleur sp|fffd|cifique pour les jours de campagne
            wks.Range(wks.Cells(lngNumLigne, lngColonne), wks.Cells(lngNumLigne, lngColonne + 3)).Font.Color = COLOR_FT_CAMPAGNE_RECAP
        End If
    Next
End Sub



'Retourne l'adresse de la cellule contenant le compteur HrsSupp pr|fffd|c|fffd|dent
Private Function travAjouterCompteursMoisPrec(ByRef wks As Worksheet, ByRef GHT As GrilleHoraireTravailleur, lngNumLigne As Long, strMoisPrec As String) As String
    Dim rg As Range
    Dim retVal As String
    
    If feuilleExiste(strMoisPrec, wks.Parent) Then
        'remplir le solde pr|fffd|c|fffd|dent par r|fffd|f|fffd|rence |fffd| la feuille consid|fffd|r|fffd|e
        Set rg = wks.Cells(lngNumLigne, C_PR_COL_HRS_SUPP_PREC)
        rg.Formula = obtenirReferenceTotalPrecedent(wks, strMoisPrec, GHT.num)
        rg.NumberFormat = "[hh]:mm"
        rg.Font.Bold = True
        rg.Font.Color = ColorConstants.vbMagenta
        rg.Interior.Color = COLOR_BG_COMPUTED
        Set rg = Nothing
        
        
        'remplir le total des hrs de la semaine pr|fffd|c|fffd|dente pour disposer de l'information
        Set rg = wks.Cells(lngNumLigne, C_PR_COL_HRS_SEM_PREC)
        rg.Formula = obtenirFormuleTotalSemaineACheval(wks, strMoisPrec, GHT.num)
        rg.NumberFormat = "[hh]:mm"
        rg.Interior.Color = COLOR_BG_COMPUTED
        Set rg = Nothing
    Else
        'remplir avec rien :-)
        Set rg = wks.Cells(lngNumLigne, C_PR_COL_HRS_SUPP_PREC)
        rg.NumberFormat = "[hh]:mm"
        rg.Font.Bold = True
        rg.Font.Color = ColorConstants.vbMagenta
        rg.Interior.Color = COLOR_BG_ENTRY
        rg.Locked = False
        Set rg = Nothing
        
        
        'remplir le total des hrs de la semaine pr|fffd|c|fffd|dente pour disposer de l'information
        Set rg = wks.Cells(lngNumLigne, C_PR_COL_HRS_SEM_PREC)
        rg.NumberFormat = "[hh]:mm"
        rg.Interior.Color = COLOR_BG_ENTRY
        rg.Locked = False
        Set rg = Nothing
    
    End If
    
    retVal = wks.Cells(lngNumLigne, C_PR_COL_HRS_SUPP_PREC).Address
                    
    fusionnerRange wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, C_PR_COL_HRS_SUPP_PREC, C_PR_COL_HRS_SUPP_PREC)
    fusionnerRange wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, C_PR_COL_HRS_SEM_PREC, C_PR_COL_HRS_SEM_PREC)
    formaterRangeTableauPrestations wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, C_PR_COL_HRS_SUPP_PREC, C_PR_COL_HRS_SEM_PREC)
    
    travAjouterCompteursMoisPrec = retVal
End Function



'Retourne l'adresse de la cellule qui contient le nombre d'heures suppl|fffd|mentaires
Private Function travAjouterInformationsSyntheseHebdomadaire(ByRef wks As Worksheet, ByRef GHT As GrilleHoraireTravailleur, lngNumLigne As Long, lngColonne As Long, lngNbRecapHebd As Long, strMoisPrec As String, lngPremJour As Long) As String
    Dim rg As Range
    Dim retVal As String
    
    formaterRangeTableauPrestations wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne, lngColonne)
                
    'Calcul du total des heures encod|fffd|es
    'Regrouper les deux premi|fffd|res cellules
    wks.Range(obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 1, lngColonne, lngColonne)).Merge
    Set rg = wks.Cells(lngNumLigne, lngColonne)
    
    'Limiter si la premi|fffd|re semaine commence le 1er du mois. Merci le mois d'octobre 2018 !
    If lngNbRecapHebd = 0 And feuilleExiste(strMoisPrec, wks.Parent) And lngColonne <= C_PR_COLONNE_MAX_6_JOURS Then
        rg.Formula = "=calculHrsPrestees(" & obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, IIf(lngPremJour = 4, 5, lngPremJour), lngColonne - 1) & "," & _
                                obtenirRangeSemIncompleteMoisPrecedent(wks, strMoisPrec, GHT.num) & ")"
    Else
        rg.Formula = "=calculHrsPrestees(" & obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, IIf(lngPremJour = 4, 5, lngPremJour), lngColonne - 1) & ")"
    End If
    formaterRangeTotalHrsSem rg, GHT
    Set rg = Nothing
    
    'Calcul Hrs Supp Semaine
    Set rg = wks.Cells(lngNumLigne + 2, lngColonne)
    If lngNbRecapHebd = 0 And feuilleExiste(strMoisPrec, wks.Parent) And lngColonne <= C_PR_COLONNE_MAX_6_JOURS Then
        rg.Formula = "=calculHrsSupp(" & obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, IIf(lngPremJour = 4, 5, lngPremJour), lngColonne - 1) & "," & _
                                obtenirRangeSemIncompleteMoisPrecedent(wks, strMoisPrec, GHT.num) & ")" & obtenirFormuleDeductionHeuresSuppDernSemaine(wks, strMoisPrec, GHT.num)
    Else
        rg.Formula = "=calculHrsSupp(" & obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, IIf(lngPremJour = 4, 5, lngPremJour), lngColonne - 1) & ")"
    End If
    formaterRangeTotalHrsSem rg, GHT, True
    retVal = rg.Address
    
    Set rg = Nothing
    
    travAjouterInformationsSyntheseHebdomadaire = retVal
End Function

Private Function travAjouterInfosSignaletique(ByRef wks As Worksheet, ByRef GHT As GrilleHoraireTravailleur, lngNumLigne As Long, lngAnnee As Long, lngMois As Long)
    Dim blnDebutContrat As Boolean, blnFinContrat As Boolean
    Dim dtDebutContrat As Date, dtFinContrat As Date
    Dim rg As Range
    
    dtDebutContrat = GHT.DebutContrat
    dtFinContrat = GHT.FinContrat
    blnDebutContrat = (Year(dtDebutContrat) = lngAnnee And Month(dtDebutContrat) = lngMois)
    blnFinContrat = (Year(dtFinContrat) = lngAnnee And Month(dtFinContrat) = lngMois)
    
    wks.Cells(lngNumLigne, C_PR_COL_NUM) = GHT.num
    wks.Cells(lngNumLigne, C_PR_COL_NUM).NumberFormat = "###### 000000"
    fusionnerRange wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, C_PR_COL_NUM, C_PR_COL_NUM)
    
    wks.Cells(lngNumLigne, C_PR_COL_NOM) = GHT.nom
    fusionnerRange wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, C_PR_COL_NOM, C_PR_COL_NOM)
    
    ' G|fffd|rer le p|fffd|le de mani|fffd|re dynamique
    wks.Cells(lngNumLigne, C_PR_COL_POLE) = GHT.obtenirFormuleReferencePole
    fusionnerRange wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, C_PR_COL_POLE, C_PR_COL_POLE)
    
    Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, C_PR_COL_NUM, C_PR_COL_POLE))
    formaterRangeTableauPrestations wks, rg.Address
    
    If blnDebutContrat Then
        If blnFinContrat Then
            rg.Cells(1, 1).AddComment "Contrat sur le mois en cours (du " & Day(dtDebutContrat) & " au " & Day(dtFinContrat) & ")"
            rg.Interior.Color = RGB(250, 250, 150)
        Else
            rg.Cells(1, 1).AddComment "D|fffd|but de contrat au " & Format(dtDebutContrat, "dd/mm")
            rg.Interior.Color = RGB(150, 250, 150)
        End If
    Else
        If blnFinContrat Then
            rg.Cells(1, 1).AddComment "Fin de contrat au " & Format(dtFinContrat, "dd/mm")
            rg.Interior.Color = RGB(250, 150, 150)
        Else
            rg.Cells(1, 1).ClearComments
            rg.Interior.ColorIndex = 0
        End If
    End If
    
End Function

Private Sub travRemplirInfosJour(ByRef wks As Worksheet, ByRef GHT As GrilleHoraireTravailleur, lngNumLigne As Long, lngColonne As Long, lngAnnee As Long, lngMois As Long, lngCpt As Long)
    Dim strRangeBlocComplet As String
    Dim rg As Range
    Dim fc As FormatCondition
    
    strRangeBlocComplet = obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne, lngColonne + 3)
            
    'Seulement si le contrat est actif |fffd| la date d|fffd|finie
    If GHT.contratActif(DateSerial(lngAnnee, lngMois, lngCpt)) Then
        'formules pour les codes de prestations
        wks.Cells(lngNumLigne, lngColonne).Formula = GHT.obtenirFormuleRef(Weekday(DateSerial(lngAnnee, lngMois, lngCpt) - 1), CodePrestation_Matin)
        wks.Cells(lngNumLigne + 1, lngColonne).Formula = GHT.obtenirFormuleRef(Weekday(DateSerial(lngAnnee, lngMois, lngCpt) - 1), CodePrestation_Aprem)
        
        'Formules pour les heures de d|fffd|but
        wks.Cells(lngNumLigne, lngColonne + 1).Formula = GHT.obtenirFormuleRef(Weekday(DateSerial(lngAnnee, lngMois, lngCpt) - 1), HeureDebutPrestation_Matin)
        wks.Cells(lngNumLigne + 1, lngColonne + 1).Formula = GHT.obtenirFormuleRef(Weekday(DateSerial(lngAnnee, lngMois, lngCpt) - 1), HeureDebutPrestation_Aprem)
        
        'Formules pour les heures de fin de prestations
        wks.Cells(lngNumLigne, lngColonne + 2).Formula = GHT.obtenirFormuleRef(Weekday(DateSerial(lngAnnee, lngMois, lngCpt) - 1), HeureFinPrestation_Matin)
        wks.Cells(lngNumLigne + 1, lngColonne + 2).Formula = GHT.obtenirFormuleRef(Weekday(DateSerial(lngAnnee, lngMois, lngCpt) - 1), HeureFinPrestation_Aprem)
    End If
    
    wks.Cells(lngNumLigne, lngColonne + 3).Formula = "=IF(RC[-1]="""",0,RC[-1])-IF(RC[-2]="""",0,RC[-2])"
    wks.Cells(lngNumLigne + 1, lngColonne + 3).Formula = "=IF(RC[-1]="""",0,RC[-1])-IF(RC[-2]="""",0,RC[-2])"
    wks.Cells(lngNumLigne + 2, lngColonne + 3).Formula = "=IF(RC[-1]="""",0,RC[-1])-IF(RC[-2]="""",0,RC[-2])"
    
    Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne + 3, lngColonne + 3))
    'Debug.Print rg.Font.Name
    rg.Interior.Color = COLOR_BG_COMPUTED
    'wks.Range(wks.Cells(lngNumLigne, lngColonne + 1), wks.Cells(lngNumLigne + 2, lngColonne + 3)).NumberFormat = "[hh]:mm"
    wks.Range(strRangeBlocComplet).NumberFormat = "[hh]:mm"
    
    formaterRangeTableauPrestations wks, strRangeBlocComplet
    
    dropDownPrestations wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne, lngColonne)
    
    'd|fffd|protection inclus le fait de d|fffd|finir le bg sur COLOR_BG_ENTRY
    deprotectionCellules wks, obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne, lngColonne + 2)
    
    Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigne, lngNumLigne + 2, lngColonne + 3, lngColonne + 3))
    Set fc = rg.FormatConditions.Add(Type:=xlCellValue, Operator:=xlEqual, Formula1:="=0")
    
    fc.SetFirstPriority
    fc.Font.Color = COLOR_BG_COMPUTED
    fc.Interior.PatternColorIndex = xlAutomatic
    fc.Interior.Color = COLOR_BG_COMPUTED
    fc.StopIfTrue = True

End Sub

Private Sub formaterRangeTableauPrestations(ByRef wks As Worksheet, strRange As String)
    Dim rg As Range
    
    Set rg = wks.Range(strRange)
    
    With rg
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    
        .Font.Name = "Calibri"
        .Font.Size = 11
    
        .Borders(xlDiagonalDown).LineStyle = xlNone
        .Borders(xlDiagonalUp).LineStyle = xlNone
    End With
    
    definirStyleBordure rg, xlEdgeLeft, xlDouble, xlThick, 2
    definirStyleBordure rg, xlEdgeBottom, xlContinuous, xlMedium, 9
    definirStyleBordure rg, xlEdgeRight, xlDouble, xlThick, 2
    definirStyleBordure rg, xlInsideVertical, xlContinuous, xlThin, 2
    definirStyleBordure rg, xlInsideHorizontal, xlContinuous, xlThin, 2
End Sub



Private Sub formaterRangeTableauRecapitulatif(ByRef rg As Range, cptHrs As Long, Optional blnBold As Boolean = True)
    rg.HorizontalAlignment = xlCenter
    rg.VerticalAlignment = xlCenter
    
    rg.Font.Name = "Calibri"
    rg.Font.Size = 11
    rg.Font.Bold = blnBold
    
    If cptHrs Mod 2 = 1 Then
        rg.Interior.Color = 10086143
    End If
    
    rg.Borders(xlDiagonalDown).LineStyle = xlNone
    rg.Borders(xlDiagonalUp).LineStyle = xlNone
    
    definirStyleBordure rg, xlEdgeLeft, xlDouble, xlThick, 2
    definirStyleBordure rg, xlEdgeBottom, xlContinuous, xlThin, 2
    definirStyleBordure rg, xlEdgeRight, xlDouble, xlThick, 2
    definirStyleBordure rg, xlInsideVertical, xlContinuous, xlThin, 2
    definirStyleBordure rg, xlInsideHorizontal, xlContinuous, xlThin, 2
    
End Sub
Private Sub formaterRangeTitre(ByRef wks As Worksheet, strRange As String, Optional blnSecondTableau As Boolean = False, Optional blnCampagne As Boolean = False)
    Dim rg As Range
    
    Set rg = wks.Range(strRange)
    
    With rg
        .WrapText = True
        .VerticalAlignment = xlCenter
        .HorizontalAlignment = xlCenter
        
        .Font.Name = "Calibri"
        .Font.FontStyle = "Gras"
        .Font.Size = 12
        .Font.ThemeColor = xlThemeColorDark1
    
        .Interior.Pattern = xlSolid
        .Interior.PatternColorIndex = xlAutomatic
        If blnSecondTableau Then
            .Interior.ThemeColor = xlThemeColorAccent2
        Else
            .Interior.ThemeColor = xlThemeColorAccent1
        End If
        .Interior.TintAndShade = 0
        .Interior.PatternTintAndShade = 0
        
        .Borders(xlDiagonalDown).LineStyle = xlNone
        .Borders(xlDiagonalUp).LineStyle = xlNone
    End With
    
    definirStyleBordure rg, xlEdgeLeft, xlDouble, xlThick
    definirStyleBordure rg, xlEdgeTop, xlDouble, xlThick
    definirStyleBordure rg, xlEdgeBottom, xlDouble, xlThick, 2
    definirStyleBordure rg, xlEdgeRight, xlDouble, xlThick
    definirStyleBordure rg, xlInsideVertical, xlContinuous, xlThin
    definirStyleBordure rg, xlInsideHorizontal, xlContinuous, xlThin
End Sub

Private Sub formaterRangeTotalHrsSem(ByRef rg As Range, ByRef GHT As GrilleHoraireTravailleur, Optional blnMiseEnFormeHrsSupp As Boolean = False)
    Dim fc As FormatCondition
    
    With rg
        .Interior.Color = COLOR_BG_COMPUTED
        If blnMiseEnFormeHrsSupp Then
            .Font.Color = RGB(30, 30, 210)
            .NumberFormat = """(HS: ""[hh]:mm"")"""
        Else
            Set fc = rg.FormatConditions.Add(xlCellValue, xlLess, "=" & GHT.HrsHebd)
            fc.Font.Bold = True
            fc.Font.Italic = False
            fc.Font.Color = vbRed
            fc.Interior.Color = vbYellow
            fc.Font.TintAndShade = 0
            fc.StopIfTrue = True
            
            Set fc = rg.FormatConditions.Add(xlCellValue, xlEqual, "=" & GHT.HrsHebd)
            fc.Font.Bold = True
            fc.Font.Italic = False
            fc.Font.Color = RGB(20, 75, 20)
            fc.Font.TintAndShade = 0
            fc.StopIfTrue = True
                
            Set fc = rg.FormatConditions.Add(xlCellValue, xlGreater, "=" & GHT.HrsHebd)
            fc.Font.Bold = True
            fc.Font.Italic = False
            fc.Font.Color = vbBlue
            fc.Font.TintAndShade = 0
            fc.StopIfTrue = True
            
            If Abs(38 - Round((GHT.HrsHebd * 24), 4)) > EPSILON Then
                rg.Cells(1, 1).AddComment "Temps de travail : " & formatHeure(GHT.HrsHebd * 24)
            End If
            .NumberFormat = "[hh]:mm"
        End If
        .Font.Bold = True
        '.Merge
        .VerticalAlignment = xlCenter
        .HorizontalAlignment = xlCenter
    End With
End Sub

'    Selection.FormatConditions(1).StopIfTrue = False
'    Selection.FormatConditions.add Type:=xlCellValue, Operator:=xlGreater, _
'        Formula1:="=" & 38 / 24
'    Selection.FormatConditions(Selection.FormatConditions.Count).SetFirstPriority
'    With Selection.FormatConditions(1).Font
'        .Bold = True
'        .Italic = False
'   1973970
'        .ThemeColor = xlThemeColorAccent5
'        .TintAndShade = 0
'    End With
'    Selection.FormatConditions(1).StopIfTrue = False


Public Function formatHeure(dblNbHrs As Double) As String
    'dblNbHrs est au format d|fffd|cimal.
    'L'affichage est au format horaire
    formatHeure = Format(Fix(dblNbHrs), "00") & ":" & Format(Fix(60 * (dblNbHrs - Fix(dblNbHrs))), "00")
End Function

Private Sub miseEnFormeConditionnelleMasquerNuls(ByRef wks As Worksheet, strRange As String)
    Dim rg As Range
    Dim fc As FormatCondition
    
    Set rg = wks.Range(strRange)
    Set fc = rg.FormatConditions.Add(Type:=xlCellValue, Operator:=xlEqual, Formula1:="=0")
    
    With fc
        .SetFirstPriority
        .Interior.ColorIndex = xlColorIndexNone
        .Font.ColorIndex = xlColorIndexNone
        '.Font.ThemeColor = xlThemeColorDark1
        '.Font.TintAndShade = 0
        '.Interior.PatternColorIndex = xlAutomatic
        '.Interior.ThemeColor = xlThemeColorDark1
        '.Interior.TintAndShade = 0
        .StopIfTrue = True
    End With
End Sub


Private Sub adapterLargeurColonnes(ByRef wks As Worksheet, strRange As String)
    Dim rg As Range
    
    Set rg = wks.Range(strRange)
        
    With rg
        .ColumnWidth = 4.78
        .WrapText = True
    End With
End Sub

Private Sub dropDownPrestations(ByRef wks As Worksheet, strRange As String)
    Dim rg As Range

    Set rg = wks.Range(strRange)
    
    With rg.Validation
        .Delete
        .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:="=INDIRECT(""CodesPrestations[Code Excel]"")"
        .IgnoreBlank = True
        .InCellDropdown = True
        .InputTitle = ""
        .ErrorTitle = ""
        .InputMessage = ""
        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With
End Sub

Private Sub fusionnerRange(ByRef wks As Worksheet, strRange As String)
    Dim rg As Range
    
    Set rg = wks.Range(strRange)
    
    With rg
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
        .Merge
    End With
End Sub

Private Function obtenirFormuleDeductionHeuresSuppDernSemaine(ByRef wks As Worksheet, strNomFeuilleCible As String, lngNumTrav As Long) As String
    Dim retVal As String
    
    Dim lngLigne As Long, lngColonne As Long
    Dim lngColBegin As Long, lngColEnd As Long
    Dim wksT As Worksheet
    
    retVal = "-'" & strNomFeuilleCible & "'!"
    
    Set wksT = wks.Parent.Sheets(strNomFeuilleCible)
    
    'D|fffd|termination de la ligne sur laquelle le travailleur se trouve.
    lngLigne = 4
    While wksT.Cells(lngLigne, 1) <> lngNumTrav And Len(Trim(wksT.Cells(lngLigne, 2))) > 0
        lngLigne = lngLigne + 3
    Wend
    
    'D|fffd|termination de la colonne "Nb Hrs" du dernier jour du mois
    lngColonne = wksT.Range("FU3").End(xlToLeft).Column + 1
    
    If wksT.Cells(lngLigne, 1) = lngNumTrav Then
        If InStr(wksT.Cells(1, lngColonne), "partielle") >= 0 Then
        
'        lngColEnd = lngColonne
'        While InStr(Trim(wksT.Cells(1, lngColonne)), "Hebd") <= 0
'            lngColonne = lngColonne - 1
'            'Debug.Print strNomFeuilleCible & " : " & Trim(wksT.Cells(1, lngColonne))
'        Wend
'        lngColBegin = lngColonne + 1
            retVal = retVal & wksT.Cells(lngLigne + 2, lngColonne).Address
        End If
    Else
        'Cas de figure o|fffd| le travailleur concern|fffd| n'est pas trouv|fffd| dans la feuille pr|fffd|c|fffd|dente.
        retVal = ""
    End If
    
    obtenirFormuleDeductionHeuresSuppDernSemaine = retVal
End Function



Private Function obtenirRangeSemIncompleteMoisPrecedent(ByRef wks As Worksheet, strNomFeuilleCible As String, lngNumTrav As Long) As String
    Dim retVal As String
    
    Dim lngLigne As Long, lngColonne As Long
    Dim lngColBegin As Long, lngColEnd As Long
    Dim wksT As Worksheet
    
    retVal = "'" & strNomFeuilleCible & "'!"
    
    Set wksT = wks.Parent.Sheets(strNomFeuilleCible)
    wksT.Outline.ShowLevels , 3
    'D|fffd|termination de la ligne sur laquelle le travailleur se trouve.
    lngLigne = 4
    While wksT.Cells(lngLigne, 1) <> lngNumTrav And Len(Trim(wksT.Cells(lngLigne, 2))) > 0
        lngLigne = lngLigne + 3
    Wend
    
    'D|fffd|termination de la colonne "Nb Hrs" du dernier jour du mois
    lngColonne = wksT.Range("FU3").End(xlToLeft).Column
    
    If wksT.Cells(lngLigne, 1) = lngNumTrav Then
        lngColEnd = lngColonne
        While InStr(Trim(wksT.Cells(1, lngColonne)), "Hebd") <= 0
            lngColonne = lngColonne - 1
            'Debug.Print strNomFeuilleCible & " : " & Trim(wksT.Cells(1, lngColonne))
        Wend
        lngColBegin = lngColonne + 1
        
        retVal = retVal & obtenirAdresseRange(wksT, lngLigne, lngLigne + 2, lngColBegin, lngColEnd)
    Else
        'Cas de figure o|fffd| le travailleur concern|fffd| n'est pas trouv|fffd| dans la feuille pr|fffd|c|fffd|dente.
        retVal = ""
    End If
    
    wksT.Outline.ShowLevels , 1
    obtenirRangeSemIncompleteMoisPrecedent = retVal
End Function



Private Sub definirStyleBordure(ByRef rg As Range, nomBordure As XlBordersIndex, typeTrait As XlLineStyle, epaisseurTrait As XlBorderWeight, Optional lngColorTheme As Long = 1, Optional lngTint As Long = 0)
    With rg.Borders(nomBordure)
        .LineStyle = typeTrait
        .ThemeColor = lngColorTheme
        .TintAndShade = lngTint
        .Weight = epaisseurTrait
    End With
End Sub

'Cette fonction ne peut pas |fffd|tre appel|fffd|e si la derni|fffd|re semaine du mois cibl|fffd| est compl|fffd|te, c'est-|fffd|-dire si le premier jour du mois qui suit celui de la feuille cible commence un lundi !
Private Function obtenirFormuleTotalSemaineACheval(ByRef wks As Worksheet, strNomFeuilleCible As String, lngNumTrav As Long) As String
    Dim retVal As String
    Dim blnContinuer As Boolean
    Dim lngLigne As Long, lngColonne As Long
    Dim wksT As Worksheet
    Dim rg As Range
    
    'Permet de faciliter la gestion de l'alimentation de la fonction.
    retVal = "=0"
    
    Set wksT = wks.Parent.Sheets(strNomFeuilleCible)
    
    wksT.Outline.ShowLevels , 3
    'D|fffd|termination de la ligne sur laquelle le travailleur se trouve.
    lngLigne = 4
    While wksT.Cells(lngLigne, 1) <> lngNumTrav And Len(Trim(wksT.Cells(lngLigne, 2))) > 0
        lngLigne = lngLigne + 3
    Wend
    
    'D|fffd|termination de la colonne "Nb Hrs" du dernier jour du mois
    lngColonne = wksT.Range("FU3").End(xlToLeft).Column - 3
    
    'Constitution de la formule par ajout successif des jours.
    If wksT.Cells(lngLigne, 1) = lngNumTrav Then
        'Ajout de la somme des NbHrs, quelque soit le code utilis|fffd| !
        blnContinuer = True
        
        While blnContinuer 'Weekday(wksT.Cells(1, lngColonne), vbMonday) <> 1
            retVal = retVal & "+SUM('" & strNomFeuilleCible & "'!" & obtenirAdresseRange(wksT, lngLigne, lngLigne + 2, lngColonne + 3, lngColonne + 3) & ")"
            If Weekday(wksT.Cells(1, lngColonne), vbMonday) = 1 Then
                blnContinuer = False
            End If
            lngColonne = lngColonne - 4
        Wend
    Else
        'Le travailleur n'est pas pr|fffd|sent sur la feuille.
        retVal = ""
    End If
    
    wksT.Outline.ShowLevels , 1
    'Mettre la formule au propre...
    obtenirFormuleTotalSemaineACheval = Replace(retVal, "0+", "")
    
End Function


Private Function obtenirReferenceTotalPrecedent(ByRef wks As Worksheet, strNomFeuilleCible As String, lngNumTrav As Long) As String
    Dim retVal As String
    Dim lngLigne As Long, lngColonne As Long
    Dim wksT As Worksheet
    Dim rg As Range
    
    retVal = "='" & strNomFeuilleCible & "'!"
    
    lngLigne = 4
    lngColonne = 110
    Set wksT = wks.Parent.Sheets(strNomFeuilleCible)
    
    While wksT.Cells(lngLigne, 1) <> lngNumTrav And Len(Trim(wksT.Cells(lngLigne, 2))) > 0
        lngLigne = lngLigne + 3
    Wend
    If wksT.Cells(lngLigne, 1) = lngNumTrav Then
        While UCase(Trim(wksT.Cells(1, lngColonne))) <> "HEURES SUPP. APRES"
            lngColonne = lngColonne + 1
        Wend
        Set rg = wksT.Cells(lngLigne, lngColonne)
        retVal = retVal & rg.Address
    Else
        retVal = ""
    End If
    
    obtenirReferenceTotalPrecedent = retVal
End Function


'Principe : premier jour du mois suivant, moins 1...
Private Function calculerNbJoursDansLeMois(lngMois As Long, lngAnnee As Long) As Long
    calculerNbJoursDansLeMois = Day(DateSerial(lngAnnee, lngMois + 1, 1) - 1)
End Function

Private Function codeJour(wkDay As Long) As String
    Dim retVal As String
    
    Select Case wkDay
        Case vbMonday
            retVal = "lundi"
        Case vbTuesday
            retVal = "mardi"
        Case vbWednesday
            retVal = "mercredi"
        Case vbThursday
            retVal = "jeudi"
        Case vbFriday
            retVal = "vendredi"
        Case vbSaturday
            retVal = "samedi"
        Case vbSunday
            retVal = "dimanche"
    End Select

    codeJour = retVal

End Function




Private Sub deprotectionCellules(ByRef wks As Worksheet, strRange As String, Optional bgColor As Long = COLOR_BG_ENTRY)
    Dim rg As Range
    On Error Resume Next
    Set rg = wks.Range(strRange)
    rg.Locked = False
    rg.FormulaHidden = False
    rg.Interior.Color = bgColor
    
End Sub


Public Function estCampagne(dtJourTest As Date) As Boolean
    Dim retVal As Boolean
    retVal = False
    
    Select Case Month(dtJourTest)
        Case 8
            retVal = (Day(dtJourTest) >= 20)
        Case 9
            retVal = True
        Case 10
            retVal = (Day(dtJourTest) <= 15)
        Case 11
            retVal = (Day(dtJourTest) >= 20)
        Case 12
            retVal = (Day(dtJourTest) <= 23)
    End Select
    
    estCampagne = retVal
End Function


Private Function obtenirAdresseRange(ByRef wks As Worksheet, lgTop As Long, lgBottom As Long, colGauche As Long, colDroite As Long) As String
    obtenirAdresseRange = Range(wks.Cells(lgTop, colGauche), wks.Cells(lgBottom, colDroite)).Address
End Function









Public Sub ajoutTravailleurFeuilleExistante(ByRef ufSrc As usFNouvTrav)
    Dim dtDebut As Date, dtFin As Date
    Dim strNom As String, strPole As String, lngNum As Long
    Dim dtFeuilleTrt As Date
    
    
    dtDebut = safeDate(ufSrc.dtDebutContrat)
    If ufSrc.chkFinContrat Then
        dtFin = safeDate(ufSrc.dtFinContrat)
    Else
        dtFin = DateSerial(9999, 12, 31)
    End If
    strNom = ufSrc.nomPrenom
    strPole = ufSrc.cmbPole.Value
    lngNum = CLng(ufSrc.numUCM)
    
    lngNum = ajouterTravDansGH(lngNum, strNom, strPole, dtDebut, dtFin)
    
    ajouterTravDansFeuillesMensuelles lngNum, strNom, strPole, dtDebut, dtFin
End Sub


Private Function ajouterTravDansFeuillesMensuelles(num As Long, nom As String, pole As String, dtDeb As Date, dtFin As Date)
    Dim wks As Worksheet
    Dim dtTest As Date
    Dim strNom As String
    Dim blnCanContinue As Boolean
    
    blnCanContinue = True
    dtTest = DateSerial(Year(dtDeb), Month(dtDeb), 1)
    
    
    'Trouver la premi|fffd|re feuille disponible
    strNom = Format(dtDeb, "MM-YYYY")
        
    'Trouver le premier mois sur lequel r|fffd|aliser la mise |fffd| jour (il se peut que la feuille
    ' n'existe plus => on doit alors tester le mois suivant, jusqu'|fffd| ce qu'on tombe sur le premier mois disponible
    'A l'inverse, si la feuille existe, on ne bouge pas...
    While Not feuilleExiste(strNom, ActiveWorkbook)
        DoEvents
        dtTest = DateAdd("m", "1", dtTest)
        strNom = Format(dtTest, "MM-YYYY")
    Wend
    
    While dtTest < dtFin And blnCanContinue
        blnCanContinue = False
        DoEvents
        If feuilleExiste(strNom, ActiveWorkbook) Then
            ajoutDuTravailleurDansLaFeuille ActiveWorkbook.Sheets(strNom), num, dtTest
            blnCanContinue = True
        End If
        dtTest = DateAdd("m", "1", dtTest)
        strNom = Format(dtTest, "MM-YYYY")
    Wend
    
'    For Each wks In ActiveWorkbook.Worksheets
'        If estNomDeMois(wks.Name, dtTest) Then
'            If DateSerial(Year(dtTest), Month(dtTest) + 1, 1) > dtDeb Then
'                'contrat a commenc|fffd| avant le mois suivant, donc celui-ci est peut-etre concern|fffd|
'                If dtTest <= dtFin Then
'                    'cr|fffd|ation dans la feuille
'                    ajoutDuTravailleurDansLaFeuille wks, num, dtTest
'                End If
'            End If
'        End If
'    Next
End Function



Private Sub ajoutDuTravailleurDansLaFeuille(ByRef wks As Worksheet, num As Long, dtReference As Date)
    Dim GHS As New GrillesHoraires
    Dim GHT As GrilleHoraireTravailleur
    Dim cpt As Long
    Dim lngLigne As Long
    Dim rg As Range
    Dim lngMois As Long, lngAnnee As Long
    Dim dtMoisPrec As Date
    
    lngMois = Month(dtReference)
    lngAnnee = Year(dtReference)
    
    dtMoisPrec = DateSerial(lngAnnee, lngMois - 1, 1)
    
    GHS.ChargerGrillesAPartirDeFeuille wks.Parent.Worksheets("GH - Travailleurs")
    For cpt = 1 To GHS.Count
        Set GHT = GHS.GHTravailleur(cpt)
        If GHT.num = num Then
            Exit For
        End If
    Next
    
    lngLigne = obtenirDerni|fffd|reLigneTravailleur(wks) + 3
    wks.Activate
    UCM_Unprotect
    Set rg = wks.Rows(lngLigne & ":" & lngLigne + 2)
    rg.Select
    rg.Insert xlShiftDown
    Application.CutCopyMode = False
    
    ajouterLignesTravailleur wks, lngMois, lngAnnee, calculerNbJoursDansLeMois(lngMois, lngAnnee), GHT, lngLigne, Format(dtMoisPrec, "MM-YYYY")
    
    'Si la feuille |fffd|tait d|fffd|j|fffd| fig|fffd|e pour les formules, on recommence ce figeage
    UCM_Protect
    
    Set rg = wks.Cells(1, 1)
    If rg.Interior.TintAndShade = INT_TEINTE_FIGE Then
        FigeageFormulesReferences False, wks
    End If
    
End Sub

Public Sub testAjout(Optional blnDoNotShowMe As Boolean = True)
    ajouterTravDansGH 152, "JAUMOTTE Sandrine", "Administration", Now, Now + 600000
End Sub

'Retourne le num|fffd|ro de travailleur adapt|fffd| en fonction du nombre de lignes d|fffd|j|fffd| pr|fffd|sentes pour ce travailleur.
Private Function ajouterTravDansGH(num As Long, nom As String, pole As String, dtDeb As Date, dtFin As Date) As Long
    Dim wks As Worksheet
    Dim lngNumLigneTrt As Long
    Dim rg As Range, rg2 As Range
    Dim cpt As Long
    Dim lngRetVal As Long
    
    Set wks = ActiveSheet.Parent.Worksheets("GH - Travailleurs")
    wks.Activate
    UCM_Unprotect
    
    lngNumLigneTrt = obtenirDerni|fffd|reLigneTravailleur(wks)
    Set rg = wks.Rows(lngNumLigneTrt & ":" & lngNumLigneTrt + 1)
    Set rg2 = wks.Rows(lngNumLigneTrt + 2 & ":" & lngNumLigneTrt + 3)
    rg.Copy
    rg2.Select
    rg2.Insert xlShiftDown
    
    Application.CutCopyMode = False
    
    lngNumLigneTrt = lngNumLigneTrt + 2
    lngRetVal = num + (1000000 * Application.WorksheetFunction.CountIf(wks.Range("AI:AI"), num))
    
    wks.Cells(lngNumLigneTrt, C_GH_COL_NUM) = lngRetVal
    wks.Cells(lngNumLigneTrt, C_GH_COL_NOM) = nom
    wks.Cells(lngNumLigneTrt, C_GH_COL_POLE) = pole
    wks.Cells(lngNumLigneTrt, C_GH_COL_DEB_CTR) = dtDeb
    If Year(dtFin) < 3000 Then
        wks.Cells(lngNumLigneTrt, C_GH_COL_FIN_CTR) = dtFin
    Else
        Set rg = wks.Cells(lngNumLigneTrt, C_GH_COL_FIN_CTR)
        rg.MergeArea.ClearContents
    End If
    For cpt = 0 To 4
        wks.Cells(lngNumLigneTrt, C_GH_COL_START_SEM + (4 * cpt)) = "PR"
        wks.Cells(lngNumLigneTrt, C_GH_COL_START_SEM + (4 * cpt) + 1) = 8 / 24
        wks.Cells(lngNumLigneTrt, C_GH_COL_START_SEM + (4 * cpt) + 2) = 12 / 24
        wks.Cells(lngNumLigneTrt + 1, C_GH_COL_START_SEM + (4 * cpt)) = "PR"
        wks.Cells(lngNumLigneTrt + 1, C_GH_COL_START_SEM + (4 * cpt) + 1) = 12.5 / 24
        wks.Cells(lngNumLigneTrt + 1, C_GH_COL_START_SEM + (4 * cpt) + 2) = 16.1 / 24
    Next
    For cpt = 5 To 6
        Set rg = wks.Range(obtenirAdresseRange(wks, lngNumLigneTrt, lngNumLigneTrt + 1, C_GH_COL_START_SEM + (4 * cpt), C_GH_COL_START_SEM + (4 * cpt) + 2))
        rg.ClearContents
    Next

    UCM_Protect
    
    ajouterTravDansGH = lngRetVal
End Function



Attribute VB_Name = "GrilleHoraireTravailleur"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private m_lngNumTrav As Long
Private m_strNomTrav As String
Private m_dblNbHrs As Double
Private m_dtDebContrat As Date
Private m_dtFinContrat As Date
Private m_strPole As String
Private m_lngLigne As Long
Private m_strNomWks As String

Private m_arrInfosPrestations(1 To 7) As InfosPrestations
Private m_arrReferencesCellules(1 To 7) As ReferencesCellulesPrestations


Public Property Get contratActif(dtTest As Date) As Boolean
    contratActif = ((m_dtDebContrat <= dtTest) And (dtTest <= m_dtFinContrat))
End Property


'Permet de r|fffd|cup|fffd|rer l'heure de d|fffd|but ou de fin de prestation pr|fffd|vue sur la matin|fffd|e ou l'apr|fffd|s-midi (0 si pas d|fffd|fini)
Public Function obtenirHeurePrestation(jourSem As JourSemaine, blnPrestMatin As Boolean, blnHeureDeb As Boolean) As Double
    If blnPrestMatin Then
        If blnHeureDeb Then
            obtenirHeurePrestation = m_arrInfosPrestations(jourSem).AM_Deb
        Else
            obtenirHeurePrestation = m_arrInfosPrestations(jourSem).AM_Fin
        End If
    Else
        If blnHeureDeb Then
            obtenirHeurePrestation = m_arrInfosPrestations(jourSem).PM_Deb
        Else
            obtenirHeurePrestation = m_arrInfosPrestations(jourSem).PM_Fin
        End If
    End If
End Function

Private Function obtenirDureeTravail(jourSem As JourSemaine, blnPrestMatin As Boolean) As Double
    If blnPrestMatin Then
        obtenirDureeTravail = m_arrInfosPrestations(jourSem).AM_Fin - m_arrInfosPrestations(jourSem).AM_Deb
    Else
        obtenirDureeTravail = m_arrInfosPrestations(jourSem).PM_Fin - m_arrInfosPrestations(jourSem).PM_Deb
    End If
End Function

'Permet de r|fffd|cup|fffd|rer le code de prestation pr|fffd|vu sur la matin|fffd|e ou l'apr|fffd|s-midi
Public Function obtenirCodePrestation(jourSem As JourSemaine, blnPrestMatin As Boolean) As String
    If blnPrestMatin Then
        obtenirCodePrestation = m_arrInfosPrestations(jourSem).AM_Code
    Else
        obtenirCodePrestation = m_arrInfosPrestations(jourSem).PM_Code
    End If
End Function

Public Function obtenirFormuleRef(jourSem As JourSemaine, typeInfo As TypeInfosPrestations) As String
    Dim strRef As String
    strRef = Me.obtenirReferenceCellule(jourSem, typeInfo)
    
    obtenirFormuleRef = "=if(isblank(" & strRef & "),""""," & strRef & ")"
End Function

'Permet de r|fffd|cup|fffd|rer la r|fffd|f|fffd|rence |fffd| utiliser pour acc|fffd|der |fffd| l'information de la grille horaire.
Public Function obtenirReferenceCellule(jourSem As JourSemaine, typeInfo As TypeInfosPrestations)
    Select Case typeInfo
        Case CodePrestation_Matin
            obtenirReferenceCellule = m_arrReferencesCellules(jourSem).AM_Code
        Case CodePrestation_Aprem
            obtenirReferenceCellule = m_arrReferencesCellules(jourSem).PM_Code
        Case HeureDebutPrestation_Matin
            obtenirReferenceCellule = m_arrReferencesCellules(jourSem).AM_Deb
        Case HeureDebutPrestation_Aprem
            obtenirReferenceCellule = m_arrReferencesCellules(jourSem).PM_Deb
        Case HeureFinPrestation_Matin
            obtenirReferenceCellule = m_arrReferencesCellules(jourSem).AM_Fin
        Case HeureFinPrestation_Aprem
            obtenirReferenceCellule = m_arrReferencesCellules(jourSem).PM_Fin
    End Select
End Function

Public Function obtenirFormuleReferencePole() As String
    obtenirFormuleReferencePole = "='" & m_strNomWks & "'!$C$" & m_lngLigne
End Function

'Permet l'ajout, dans l'ensemble des donn|fffd|es manipul|fffd|es, de toutes les r|fffd|f|fffd|rences n|fffd|cessaires sur base de l'adresse de la cellule sup|fffd|rieure gauche d'un bloc de 2 lignes et 3 colonnes
Public Sub ajouterReferencesCellules(jourSem As JourSemaine, strNomFeuille As String, strColonneCodeAM As String, lngLigneCodeAM As Long)
    Dim strPrefixeColonne As String
    Dim strTmpCol As String
    
    strTmpCol = Right(strColonneCodeAM, 1)
    If Len(strColonneCodeAM) > 1 Then
        strPrefixeColonne = Left(strColonneCodeAM, 1)
    End If
    
    With m_arrReferencesCellules(jourSem)
        .AM_Code = "'" & strNomFeuille & "'!$" & strPrefixeColonne & strTmpCol & "$" & lngLigneCodeAM
        .PM_Code = "'" & strNomFeuille & "'!$" & strPrefixeColonne & strTmpCol & "$" & (lngLigneCodeAM + 1)
        .AM_Deb = "'" & strNomFeuille & "'!$" & strPrefixeColonne & Chr(Asc(strTmpCol) + 1) & "$" & lngLigneCodeAM
        .PM_Deb = "'" & strNomFeuille & "'!$" & strPrefixeColonne & Chr(Asc(strTmpCol) + 1) & "$" & (lngLigneCodeAM + 1)
        .AM_Fin = "'" & strNomFeuille & "'!$" & strPrefixeColonne & Chr(Asc(strTmpCol) + 2) & "$" & lngLigneCodeAM
        .PM_Fin = "'" & strNomFeuille & "'!$" & strPrefixeColonne & Chr(Asc(strTmpCol) + 2) & "$" & (lngLigneCodeAM + 1)
    End With
    
    'Stocker le num|fffd|ro de ligne du travailleur dans la feuille
    m_lngLigne = lngLigneCodeAM
    m_strNomWks = strNomFeuille
End Sub

'Ajouter les donn|fffd|es relatives aux prestations
Public Sub ajouterInfosPrestations(jourSem As JourSemaine, strCodePrestAM As String, dblHrDebAM As Double, dblHrFinAM As Double, strCodePrestPM As String, dblHrDebPM As Double, dblHrFinPM As Double)
    With m_arrInfosPrestations(jourSem)
        .AM_Code = strCodePrestAM
        .AM_Deb = dblHrDebAM
        .AM_Fin = dblHrFinAM
        .PM_Code = strCodePrestPM
        .PM_Deb = dblHrDebPM
        .PM_Fin = dblHrFinPM
    End With
End Sub

'Accesseurs pour date de fin du contrat
'Par d|fffd|faut :  31/12/9999
Public Property Get FinContrat() As Date
        FinContrat = m_dtFinContrat
End Property
Public Property Let FinContrat(dtVal As Date)
    m_dtFinContrat = dtVal
End Property

'Accesseurs pour date de d|fffd|but du contrat
Public Property Get DebutContrat() As Date
    DebutContrat = m_dtDebContrat
End Property
Public Property Let DebutContrat(dtVal As Date)
    m_dtDebContrat = dtVal
End Property


'Accesseurs pour dur|fffd|e horaire
Public Property Get HrsHebd() As Double
    HrsHebd = m_dblNbHrs
End Property
Public Property Let HrsHebd(dblVal As Double)
    m_dblNbHrs = dblVal
End Property

'Accesseurs pour p|fffd|le d'activit|fffd|
Public Property Get pole() As String
    pole = m_strPole
End Property
Public Property Let pole(strVal As String)
    m_strPole = strVal
End Property



'Accesseurs pour num|fffd|ro travailleur
Public Property Get num() As Long
    num = m_lngNumTrav
End Property
Public Property Let num(lngVal As Long)
    m_lngNumTrav = lngVal
End Property

'Accesseurs pour nom travailleur
Public Property Get nom() As String
    nom = m_strNomTrav
End Property
Public Property Let nom(strVal As String)
    m_strNomTrav = strVal
End Property


Public Property Get NbHrsPrevues(jourSem As JourSemaine) As Double
    NbHrsPrevues = obtenirDureeTravail(jourSem, True) + obtenirDureeTravail(jourSem, False)
End Property


Private Sub Class_Initialize()
    m_dtFinContrat = DateSerial(9999, 12, 31)
End Sub



Public Sub DebugInfo()
    Dim cptJ As JourSemaine
    Debug.Print "Donn|fffd|es Travailleur - GH"
    Debug.Print "Num : " & Format(m_lngNumTrav, "000000") & " - Nom : " & m_strNomTrav
    Debug.Print "P|fffd|le : " & m_strPole
    Debug.Print "Dur|fffd|e hebd : " & m_dblNbHrs & " jour, soit " & Round(m_dblNbHrs * 24, 2) & " hrs."
    Debug.Print "Contrat : " & Format(m_dtDebContrat, "dd/mm/yyyy") & "-" & Format(m_dtFinContrat, "dd/mm/yyyy")
    Debug.Print "Prestations : "
    For cptJ = lundi To dimanche
        With m_arrInfosPrestations(cptJ)
            Debug.Print libJour(cptJ) & " (" & ((.AM_Fin - .AM_Deb) + (.PM_Fin - .PM_Deb)) * 24 & " hrs.)"
            If Len(.AM_Code) > 0 Then
                Debug.Print "   AM : " & .AM_Code & " de " & Format(.AM_Deb, "0.0000") & " (" & Format(.AM_Deb, "hh:mm") & " h.) |fffd| " & Format(.AM_Fin, "0.0000") & " (" & Format(.AM_Fin, "hh:mm") & " h.)" & " - Dur|fffd|e " & (.AM_Fin - .AM_Deb) * 24 & " hrs."
            Else
                Debug.Print "   AM : pas de prestation."
            End If
            If Len(.PM_Code) > 0 Then
                Debug.Print "   PM : " & .PM_Code & " de " & Format(.PM_Deb, "0.0000") & " (" & Format(.PM_Deb, "hh:mm") & " h.) |fffd| " & Format(.PM_Fin, "0.0000") & " (" & Format(.PM_Fin, "hh:mm") & " h.)" & " - Dur|fffd|e " & (.PM_Fin - .PM_Deb) * 24 & " hrs."
            Else
                Debug.Print "   PM : pas de prestation."
            End If
        End With
        
        Debug.Print "   R|fffd|f|fffd|rences"
        With m_arrReferencesCellules(cptJ)
            Debug.Print "      -> AM Code : " & .AM_Code
            Debug.Print "      -> AM DEB  : " & .AM_Deb
            Debug.Print "      -> AM Fin  : " & .AM_Fin
            Debug.Print "      -> PM Code : " & .PM_Code
            Debug.Print "      -> PM DEB  : " & .PM_Deb
            Debug.Print "      -> PM Fin  : " & .PM_Fin
        End With
    Next
End Sub
Attribute VB_Name = "GrillesHoraires"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Utilise : C_GH_LIGNE_DEB _
            C_GH_COL_NUM _
            C_GH_COL_NOM _
            C_GH_COL_TOT _
            C_GH_COL_DEB_CTR _
            C_GH_COL_FIN_CTR    d|fffd|finis dans IHM_DefinitionsConstantes


'In : feuille de calcul contenant la GH
'     PAS de contr|fffd|le effectu|fffd| dans cette fonction !
'Chgt |fffd|tat : objet contient une collection de GHTravailleur

'
Private m_collGHTravs As Collection


Public Property Get GHTravailleur(lngIndex) As GrilleHoraireTravailleur
    Set GHTravailleur = m_collGHTravs.Item(lngIndex)
End Property

Public Property Get Count() As Long
    Count = m_collGHTravs.Count
End Property


'Chargement des donn|fffd|es GH |fffd| partir de la feuille de gestion
Public Function ChargerGrillesAPartirDeFeuille(ByRef wksGH As Worksheet) As Boolean

    Dim retVal As Boolean
    Dim tmpGHT As GrilleHoraireTravailleur
    Dim lngNbLigne As Long
    Dim cptJour As JourSemaine
    Dim tmpRg As Range
    Dim strColName As String
    
    retVal = True
    lngNbLigne = C_GH_LIGNE_DEB
    
    While Len(Trim(wksGH.Cells(lngNbLigne, C_GH_COL_NOM))) > 0
        
        Set tmpGHT = New GrilleHoraireTravailleur
        
        With tmpGHT
            .num = wksGH.Cells(lngNbLigne, C_GH_COL_NUM)
            .nom = wksGH.Cells(lngNbLigne, C_GH_COL_NOM)
            .pole = wksGH.Cells(lngNbLigne, C_GH_COL_POLE)
            .HrsHebd = wksGH.Cells(lngNbLigne, C_GH_COL_TOT)
            .DebutContrat = wksGH.Cells(lngNbLigne, C_GH_COL_DEB_CTR)
            If Not IsEmpty(wksGH.Cells(lngNbLigne, C_GH_COL_FIN_CTR)) Then
                .FinContrat = wksGH.Cells(lngNbLigne, C_GH_COL_FIN_CTR)
            End If
            
            For cptJour = lundi To dimanche
                Set tmpRg = wksGH.Cells(lngNbLigne, (cptJour - 1) * 4 + C_GH_COL_START_SEM)
                strColName = tmpRg.Address(True, False, xlA1)
                                
                .ajouterReferencesCellules cptJour, wksGH.Name, Left(strColName, InStr(strColName, "$") - 1), lngNbLigne
                
                .ajouterInfosPrestations cptJour, wksGH.Cells(lngNbLigne, (cptJour - 1) * 4 + C_GH_COL_START_SEM).Value, _
                                                  wksGH.Cells(lngNbLigne, (cptJour - 1) * 4 + C_GH_COL_START_SEM + 1).Value + 0, _
                                                  wksGH.Cells(lngNbLigne, (cptJour - 1) * 4 + C_GH_COL_START_SEM + 2).Value + 0, _
                                                  wksGH.Cells(lngNbLigne + 1, (cptJour - 1) * 4 + C_GH_COL_START_SEM).Value, _
                                                  wksGH.Cells(lngNbLigne + 1, (cptJour - 1) * 4 + C_GH_COL_START_SEM + 1).Value + 0, _
                                                  wksGH.Cells(lngNbLigne + 1, (cptJour - 1) * 4 + C_GH_COL_START_SEM + 2).Value + 0
            Next
            
        End With
        
        m_collGHTravs.Add tmpGHT, CStr(tmpGHT.num)
        'tmpGHT.DebugInfo
        
        Set tmpGHT = Nothing
        
        lngNbLigne = lngNbLigne + 2
    Wend

 
    ChargerGrillesAPartirDeFeuille = retVal

End Function

Private Sub Class_Initialize()
    Set m_collGHTravs = New Collection
End Sub
Attribute VB_Name = "HrsSuppTrav"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public nom As String
Public num As Long
Public pole As String

Private m_dblSemestre1 As Double
Private m_dblSemestre2Camp As Double
Private m_dblSemestre2HorsCamp As Double

Private m_dblSemestre1Prestees As Double
Private m_dblSemestre2CampPrestees As Double
Private m_dblSemestre2HorsCampPrestees As Double

Public Property Get NbHrsPremierSemestre() As Double
    NbHrsPremierSemestre = m_dblSemestre1
End Property
Public Property Get NbHrsDeuxi|fffd|meSemestreHorsCampagne() As Double
    NbHrsDeuxi|fffd|meSemestreHorsCampagne = m_dblSemestre2HorsCamp
End Property
Public Property Get NbHrsDeuxi|fffd|meSemestreCampagne() As Double
    NbHrsDeuxi|fffd|meSemestreCampagne = m_dblSemestre2Camp
End Property

Public Property Get NbHrsPremierSemestrePrestees() As Double
    NbHrsPremierSemestrePrestees = m_dblSemestre1Prestees
End Property
Public Property Get NbHrsDeuxi|fffd|meSemestreHorsCampagnePrestees() As Double
    NbHrsDeuxi|fffd|meSemestreHorsCampagnePrestees = m_dblSemestre2HorsCampPrestees
End Property
Public Property Get NbHrsDeuxi|fffd|meSemestreCampagnePrestees() As Double
    NbHrsDeuxi|fffd|meSemestreCampagnePrestees = m_dblSemestre2CampPrestees
End Property


Private Sub ajouterHeuresHorsCampPremSem(dtEffet As Date, nbHrs As Double)
    If dtEffet <= Now Then
        m_dblSemestre1Prestees = m_dblSemestre1Prestees + nbHrs
    Else
        m_dblSemestre1 = m_dblSemestre1 + nbHrs
    End If
End Sub

Private Sub ajouterHeuresHorsCampDeuxSem(dtEffet As Date, nbHrs As Double)
    If dtEffet <= Now Then
        m_dblSemestre2HorsCampPrestees = m_dblSemestre2HorsCampPrestees + nbHrs
    Else
        m_dblSemestre2HorsCamp = m_dblSemestre2HorsCamp + nbHrs
    End If
End Sub

Private Sub ajouterHeuresCampDeuxSem(dtEffet As Date, nbHrs As Double)
    If dtEffet <= Now Then
        m_dblSemestre2CampPrestees = m_dblSemestre2CampPrestees + nbHrs
    Else
        m_dblSemestre2Camp = m_dblSemestre2Camp + nbHrs
    End If
End Sub



Public Sub ajouterHsSupp(dtEffet As Date, nbHrs As Double)
    Dim mois As Long, jour As Long
    mois = Month(dtEffet)
    jour = Day(dtEffet)
    
    Select Case Month(dtEffet)
        Case 1
            ajouterHeuresHorsCampDeuxSem dtEffet, nbHrs
        Case 2 To 7
            ajouterHeuresHorsCampPremSem dtEffet, nbHrs
        Case 8
            If jour < 20 Then
                ajouterHeuresHorsCampDeuxSem dtEffet, nbHrs
            Else
                ajouterHeuresCampDeuxSem dtEffet, nbHrs
            End If
        Case 9
            ajouterHeuresCampDeuxSem dtEffet, nbHrs
        Case 10
            If jour <= 15 Then
                ajouterHeuresCampDeuxSem dtEffet, nbHrs
            Else
                ajouterHeuresHorsCampDeuxSem dtEffet, nbHrs
            End If
        Case 11
            If jour < 20 Then
                ajouterHeuresHorsCampDeuxSem dtEffet, nbHrs
            Else
                ajouterHeuresCampDeuxSem dtEffet, nbHrs
            End If

        Case 12
            If jour <= 23 Then
                ajouterHeuresCampDeuxSem dtEffet, nbHrs
            Else
                ajouterHeuresHorsCampDeuxSem dtEffet, nbHrs
            End If
    End Select
End Sub
Attribute VB_Name = "IContrat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Interface : IContrat
'
' Objectif
' *********
'  D|fffd|finir un contrat de base pour la gestion des contrats des travailleurs
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'

Public Enum RubriqueScripts
    RubriqueUnites = 1
    RubriqueMontant = 2
End Enum

'Propri|fffd|t|fffd| : r|fffd|f|fffd|rence de pointeuse. Identifiant du biniou
Public Property Get ReferencePointeuse() As String
End Property

'Donn|fffd|e membre : les prestations li|fffd|es au contrat
Public Property Get Prestations() As IPlanning
End Property

'Donn|fffd|e membre : les codes divers li|fffd|s au contrat
Public Property Get CodesDivers() As Collection
End Property

Public Property Get estDefini() As Boolean
End Property

Public Property Get estDefinieReferencePointeuse() As Boolean
End Property

Public Function definirContrat(Optional strReferencePointeuse As String = "") As Boolean
End Function

Public Function ajouterPrestation(dtDate As Date, strCodePrestation As String, dblNbHeures As Double, blnIndicateurPNuit As Boolean, blnIndicateurPEquipe As Boolean) As Boolean
End Function

Public Function ajouterRubrique(enumRubrique As RubriqueScripts, strCodeRubrique As String, dblNbRubrique As Double) As Boolean
End Function

Public Function estIdentique(objOth As IContrat) As Boolean
End Function

'Public Sub PrintDebug()
'End Sub

Attribute VB_Name = "IGenerateur"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Interface : IGenerateurXML
'
' Objectif
' *********
'  D|fffd|finir un contrat de base pour la g|fffd|n|fffd|ration d'un output donn|fffd|, sur base de certaines informations
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'


'num|fffd|ro de dossier |fffd| utiliser
Public Property Get Dossier() As String
End Property
Public Property Let Dossier(ByVal strValue As String)
End Property

'Nom du dossier
Public Property Get NomDossier() As String
End Property
Public Property Let NomDossier(ByVal strValue As String)
End Property

'Chaine repr|fffd|sentant le nom du g|fffd|n|fffd|rateur
Public Property Get Fournisseur() As String
End Property
'read-only

'Chaine repr|fffd|sentant la date de g|fffd|n|fffd|ration
Public Property Get DateEnvoi() As String
End Property
'read-only

'Chaine repr|fffd|sentant la p|fffd|riode concern|fffd|e par la g|fffd|n|fffd|ration de prestations
Public Property Get Periode() As String
End Property
'read-only


'Propri|fffd|t|fffd|s de contr|fffd|le
Public Property Get estDefDossier() As Boolean
End Property
Public Property Get estDefPeriode() As Boolean
End Property



'   M|fffd|thodes
'd|fffd|finition de la p|fffd|riode de paie
Public Function definirPeriodePaie(ByVal lngAnnee As Long, ByVal lngMois As Long) As Boolean
End Function


'd|fffd|finition des travailleurs pour lesquels le g|fffd|n|fffd|rateur doit produire les informations
Public Function ajouterTravailleur(ByRef newTrav As ITravailleur) As Boolean
End Function

'Permet l'enregistrement de l'output ad|fffd|quat dans le fichier sp|fffd|cifi|fffd|.
'Retourne Vrai si le fichier a bien |fffd|t|fffd| g|fffd|n|fffd|r|fffd|
Public Function GenererOutput(ByVal strFileName As String) As Boolean
End Function

Public Sub GenererSynthese(ByVal strFileName As String, ByRef ufRes As usrFormResultatTraitement)
End Sub

Attribute VB_Name = "IHM_DefinitionConstantes"
Option Explicit
'
'
' Module : DefinitionConstantes
'
' Objectif
' *********
'  D|fffd|finition de constantes utilis|fffd|es dans plusieurs modules autres
'  Sp|fffd|ficifit|fffd|s d|fffd|finies pour la macro de type Holmat (ou autre)
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Usages
' ************
'  Nom des modules "utilisateurs"    | Version minimale
' -----------------------------------+------------------
'  JourPrestations                   |     1.00
'  Contrat                           |     1.00
'  zzTest_JourPrestations            |     1.00
'  zzTest_Contrat                    |     1.00
'  zzTest_Planning                   |     1.00
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    30.06.2015    | Version initiale

'
'
' Constantes |fffd| d|fffd|finir pour se faciliter la vie
'
'
'Mot de passe pour la protection/d|fffd|protection des feuilles
Public Const C_PASSWORD As String = "UCMAutom10"
Public Const C_MDP_CLIENT As String = "CAP48-Ucm"


'D|fffd|finition des |fffd|l|fffd|ments n|fffd|cessaires pour le menu via Compl|fffd|ments
Public Const CSTR_NOM_MENU As String = "Op|fffd|rations de Solidarit|fffd| - UCM"  '<== Ce qui s'affiche comme point d'entr|fffd|e dans les compl|fffd|ments
Public Const CSTR_CMD_CTRL As String = "Test Fonctionnalit|fffd|"  '<== Entr|fffd|e de menu
Public Const CSTR_CMD_TTIP As String = "Permet l'ex|fffd|cution de la commande de test de fonctionnalit|fffd|"  '<== Tooltip li|fffd| |fffd| cette commande

'Constantes utilis|fffd|es dans feuille de prestations
Public Const LIG_TITRE As Long = 3              ' Num|fffd|ro de la ligne de titre pour les validations pr|fffd|liminaires
Public Const LIG_DEBUT_TRAV As Long = 5         ' Num|fffd|ro de la premi|fffd|re ligne |fffd| traiter
'Int|fffd|grer ici ce qui peut |fffd|tre utile, tel que :
Public Const EPSILON As Double = 0.000000001

' Num|fffd|ros de colonnes (plus ais|fffd|, par la suite de r|fffd|f|fffd|rencer COL_PREST_NUM_TRAV qu'une valeur num|fffd|rique...
'Obligatoire : |fffd| d|fffd|finir
Public Const C_PREST_COL_NUM_TRAV As Long = 1    '<== Colonne qui contient le num|fffd|ro de travailleur



Public Const C_GH_LIGNE_DEB As Long = 3
Public Const C_GH_COL_NUM As Long = 1
Public Const C_GH_COL_NOM As Long = 2
Public Const C_GH_COL_POLE As Long = 3
Public Const C_GH_COL_START_SEM As Long = 4
Public Const C_GH_COL_TOT As Long = 32
Public Const C_GH_COL_DEB_CTR As Long = 33
Public Const C_GH_COL_FIN_CTR As Long = 34

Public Const C_PR_LIGNE_TITRE As Long = 1
Public Const C_PR_LIGNE_DEB As Long = 4
Public Const C_PR_COL_NUM As Long = 1
Public Const C_PR_COL_NOM As Long = 2
Public Const C_PR_COL_POLE As Long = 3
Public Const C_PR_COL_HRS_SUPP_PREC As Long = 4
Public Const C_PR_COL_HRS_SEM_PREC As Long = 5
Public Const C_PR_COL_DET_PRES_START As Long = 6

Public Const C_PR_NB_COLS_PAR_JOUR As Long = 4
Public Const C_PR_COLONNE_MAX_6_JOURS As Long = 30
'5 colonnes d'infos + 6*4 colonnes => 29

Public Const C_REC_COL_NUM As Long = 1
Public Const C_REC_COL_NOM As Long = 2
Public Const C_REC_COL_POLE As Long = 3
Public Const C_REC_COL_HRS_1P As Long = 4
Public Const C_REC_COL_HRS_1AP As Long = 5
Public Const C_REC_COL_HRS_2P As Long = 6
Public Const C_REC_COL_HRS_2AP As Long = 7
Public Const C_REC_COL_HRS_2_VP As Long = 8
Public Const C_REC_COL_HRS_2_VAP As Long = 9
Public Const C_REC_COL_HRS_TOT As Long = 10
Public Const C_REC_LG_HEAD1 As Long = 1
Public Const C_REC_LG_HEAD2 As Long = 2
Public Const C_REC_LG_HEAD3 As Long = 4
Public Const C_REC_LG_TITRE_TAB As Long = 6
Public Const C_REC_LG_START_DATA As Long = 7


' Alternativement, on peut mettre en place une d|fffd|tection automatique des num|fffd|ros de colonnes sur base de la pr|fffd|sence de
' texte sp|fffd|cifique dans la ligne de titre.



'
'
' En cas d'utilisation d'un fichier INI (d|fffd|conseill|fffd| !)
'
'
' Public Const C_INI_FILENAME As String = "\UCM_Automatisation.ini"



'
'
'  NE P|fffd|S MODIFIER CE QUI SUIT !
'
'

'Menu via Compl|fffd|ments
Public Const CSTR_CMD_EXEC As String = "ExecCommande1"    '<== Nom de la proc |fffd| ex|fffd|cuter (ne pas changer)

'Cl|fffd|s pour les identifiants dans le processus de G|fffd|n|fffd|ration XML
Public Const C_PREFIX_PRESTA As String = "ID-PR"
Public Const C_PREFIX_SCRIPT As String = "ID-SC"

' Couleurs, au cas o|fffd| ce serait n|fffd|cessaire...
Public Const COLOR_GREY As Long = 10921638
Public Const COLOR_BG_JF As Long = 9163007
Public Const COLOR_BG_ENTRY As Long = 10079487
Public Const COLOR_BG_COMPUTED As Long = 15921906
Public Const COLOR_FT_CAMPAGNE_JR As Long = 6740479
Public Const COLOR_FT_CAMPAGNE_RECAP As Long = 10498160

Public Const INT_TEINTE_FIGE As Double = -0.499984740745262

Attribute VB_Name = "IHM_InterfaceMenu"
Option Explicit


Sub AjoutMenuX(Optional blnDoNotShowMe As Boolean = True)
    'On Error Resume Next
    Dim myMenuBar As CommandBar
    Dim newMenu As CommandBarPopup
    Dim newMenu2 As CommandBarPopup
    Dim newMenu3 As CommandBarPopup
    Dim ctrl As CommandBarControl
    
    Set myMenuBar = CommandBars.ActiveMenuBar
    Set newMenu = myMenuBar.Controls.Add(Type:=msoControlPopup, Temporary:=True)
    newMenu.Caption = CSTR_NOM_MENU

'    Set ctrl = newMenu.Controls.add(Type:=msoControlButton)
'    ctrl.Caption = CSTR_CMD_CTRL
'    ctrl.OnAction = CSTR_CMD_EXEC
'    ctrl.Enabled = True
'    ctrl.TooltipText = CSTR_CMD_TTIP
'
    
    Set newMenu2 = newMenu.Controls.Add(msoControlPopup)
    newMenu2.BeginGroup = True
    newMenu2.Caption = "Gestion"
    
    If ThisWorkbook.blnEstGestionnaire Then
            
        Set newMenu3 = newMenu2.Controls.Add(msoControlPopup)
        newMenu3.BeginGroup = True
        newMenu3.Caption = "Traitements sur la feuille en cours"
            
'        Set ctrl = newMenu3.Controls.Add(msoControlButton)
'        ctrl.Caption = "G|fffd|n|fffd|ration prestations pour Appipay"
'        ctrl.OnAction = "gestPrestApp"
'        ctrl.Enabled = True
            
'        Set ctrl = newMenu3.Controls.Add(msoControlButton)
'        ctrl.Caption = "Tri par p|fffd|le"
'        ctrl.OnAction = "gestTriPole"
'        ctrl.Enabled = True

        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "Figer les formules"
        ctrl.OnAction = "gestFigerFormules"
        ctrl.Enabled = True
        
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "Filtrage par p|fffd|le"
        ctrl.OnAction = "gestFiltragePole"
        ctrl.Enabled = True
        
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "Remise |fffd| z|fffd|ro des heures supp ""AVANT"""
        ctrl.OnAction = "gestRazHrsSuppAvant"
        ctrl.Enabled = True
            
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "Suppression des feuilles ant|fffd|rieures"
        ctrl.OnAction = "gestSupprFeuilles"
        ctrl.Enabled = True
            
            
            
        Set newMenu3 = newMenu2.Controls.Add(msoControlPopup)
        newMenu3.BeginGroup = True
        newMenu3.Caption = "Gestion des travailleurs"
        
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "Ajouter un travailleur"
        ctrl.OnAction = "gestAjoutTrav"
        ctrl.Enabled = True
        
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "Cl|fffd|turer un contrat"
        ctrl.OnAction = "gestClotureContrat"
        ctrl.Enabled = True
        
        
        Set newMenu3 = newMenu2.Controls.Add(msoControlPopup)
        newMenu3.BeginGroup = True
        newMenu3.Caption = "Reporting"
        
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "G|fffd|n|fffd|ration du r|fffd|capitulatif HS |fffd| la date du jour"
        ctrl.OnAction = "gestRecapHS"
        ctrl.Enabled = True
        
        
        Set newMenu3 = newMenu2.Controls.Add(msoControlPopup)
        newMenu3.BeginGroup = True
        newMenu3.Caption = "Gestion du fichier"
        
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "R|fffd|alisation d'un backup"
        ctrl.OnAction = "gestBackup"
        ctrl.Enabled = True
        
        Set ctrl = newMenu3.Controls.Add(msoControlButton)
        ctrl.Caption = "Cr|fffd|ation du mois suivant"
        ctrl.OnAction = "gestMoisSuivant"
        ctrl.Enabled = True
        
        
        
    Else
        Set ctrl = newMenu2.Controls.Add(msoControlButton)
        ctrl.Caption = "Activer les commandes de gestion"
        ctrl.OnAction = "ActiverCommandesGestion"
        ctrl.Enabled = True
        ctrl.TooltipText = "Permet l'introduction du mot de passe donnant acc|fffd|s aux fonctionnalit|fffd|s avanc|fffd|es"
        
    End If
    'Sp|fffd|cifique pour permettre la gestion de protections des feuilles
    'Cette fonctionnalit|fffd| n'est disponible qu'|fffd| partir d'un poste UCM par d|fffd|faut.
    If estPosteDeTravailUCM() Then
        Set newMenu2 = newMenu.Controls.Add(Type:=msoControlPopup)
        newMenu2.BeginGroup = True
        newMenu2.Caption = "Gestion UCM"
        
        Set newMenu3 = newMenu2.Controls.Add(Type:=msoControlPopup)
        newMenu3.BeginGroup = True
        newMenu3.Caption = "Protection"
        
        Set ctrl = newMenu3.Controls.Add(Type:=msoControlButton)
        ctrl.Caption = "D|fffd|prot|fffd|ger"
        ctrl.OnAction = "UCM_Unprotect"
        ctrl.Enabled = True
        ctrl.TooltipText = "D|fffd|protection de la feuille courante"
        
        Set ctrl = newMenu3.Controls.Add(Type:=msoControlButton)
        ctrl.Caption = "Prot|fffd|ger"
        ctrl.OnAction = "UCM_Protect"
        ctrl.Enabled = True
        ctrl.TooltipText = "Prot|fffd|ger la feuille courante"
    End If

End Sub

'Proc|fffd|dure de supperssion du menu
'--------------------------------
Sub SuppressionMenuX(strNomMenu As String)
    On Error Resume Next
    Dim myMenuBar As CommandBar
    
    Set myMenuBar = CommandBars.ActiveMenuBar
    myMenuBar.Controls(strNomMenu).Delete
End Sub

Public Sub ResetMenu(Optional blnDoNotShowMe As Boolean = True)
    SuppressionMenuX CSTR_NOM_MENU
    AjoutMenuX
End Sub


'Le contr|fffd|le n'est accessible que sur les feuilles dont le nom est structur|fffd| de la mani|fffd|re suivante :
' 2 parties s|fffd|par|fffd|es par un espace.
' 1|fffd|re partie commence par les 4 premiers caract|fffd|res des mois en fran|fffd|ais
' 2|fffd|me partie = chaine identique |fffd| la conversion de son contenu en type Long

'Public Sub ExecCommande1(Optional blnDoNotShowMe As Boolean = True)
'
'    Debug.Print ActiveCell.Font.Color
'
'
''    GestionCompleteFichierPrestations  'Voir Module GLOB_MainModule
'End Sub

        
        
Public Sub gestRazHrsSuppAvant(Optional blnDoNotShowMe As Boolean = True)
    If ThisWorkbook.ResetParams Then
        cleanupHrsSuppAvant
    End If
End Sub

        
Public Sub gestFiltragePole(Optional blnDoNotShowMe As Boolean = True)
    Dim usF As New usrFFiltragePole
    usF.definirFeuilleCible ActiveSheet
    
    usF.Show

End Sub


Public Sub gestTriPole(Optional blnDoNotShowMe As Boolean = True)
    
'    If ThisWorkbook.ResetParams Then
'        verificationPourMiseAJour
'        TriFeuilleEnCoursSurPoles
'    End If
'
End Sub


Public Sub gestClotureContrat(Optional blnDoNotShowMe As Boolean = True)
    Dim ufClot As New usFFinContrat
    
    If ThisWorkbook.ResetParams Then
        verificationPourMiseAJour
        ufClot.Show
    End If
End Sub
Public Sub gestAjoutTrav(Optional blnDoNotShowMe As Boolean = True)
    Dim ufCreationTrav As New usFNouvTrav
    
    If ThisWorkbook.ResetParams Then
        verificationPourMiseAJour
        ufCreationTrav.Show
        If ufCreationTrav Is Nothing Then Exit Sub
        If ufCreationTrav.DonneesValidees Then
            ajoutTravailleurFeuilleExistante ufCreationTrav
        End If
    End If
End Sub

Public Sub gestRecapHS(Optional blnDoNotShowMe As Boolean = True)
    
    Dim recaphs As RecapHrsSupp
    
    If ThisWorkbook.ResetParams Then
        
        verificationPourMiseAJour
    
        Set recaphs = New RecapHrsSupp
        Set recaphs.FeuilleGH = ActiveWorkbook.Sheets("GH - Travailleurs")
        recaphs.generer
    End If
End Sub


Public Sub gestFigerFormules(Optional blnDoNotShowMe As Boolean = True)
    
    If ThisWorkbook.ResetParams Then
        verificationPourMiseAJour
        FigeageFormulesReferences
    End If

End Sub
Public Sub gestPrestApp(Optional blnDoNotShowMe As Boolean = True)

    MsgBox "Cette fonctionnalit|fffd| a |fffd|t|fffd| d|fffd|sactiv|fffd|e (gestion unique des heures suppl|fffd|mentaires)"
    'If ThisWorkbook.ResetParams Then
    '    verificationPourMiseAJour
    '    GestionCompleteFichierPrestations
    'End If
End Sub

Public Sub gestMoisSuivant(Optional blnDoNotShowMe As Boolean = True)
    Dim wkb As Workbook
    Dim strNomNouvelleFeuille As String
    Dim dtNouveauMois As Date
    
    
    If ThisWorkbook.ResetParams Then
        Set wkb = ActiveWorkbook
        
        strNomNouvelleFeuille = obtenirNomFeuilleMoisSuivant(wkb, dtNouveauMois)
        If MsgBox("Voulez-vous cr|fffd|er la nouvelle feuille '" & strNomNouvelleFeuille & "' ?", vbYesNo, "Confirmation de cr|fffd|ation de feuille.") = vbYes Then
            GenererFeuillePrestations wkb, Month(dtNouveauMois), Year(dtNouveauMois)
        End If
    End If
End Sub

Public Sub gestBackup(Optional blnDoNotShowMe As Boolean = True)
    Dim strCurrRep As String
    Dim objFSO As FileSystemObject
    Dim strCurrFile As String
    Dim wkb As Workbook
    
    If ThisWorkbook.ResetParams Then
        verificationPourMiseAJour
        Set wkb = ActiveWorkbook
        Set objFSO = New FileSystemObject
        
        strCurrRep = wkb.Path
        strCurrFile = wkb.FullName
        
        If Not (objFSO.FolderExists(strCurrRep & "\backups")) Then
            objFSO.CreateFolder strCurrRep & "\backups"
        End If
        
        'Pour maintenir la caract|fffd|ristique "gestionnaire"
        wkb.SaveAs strCurrRep & "\backups\" & Format(Now, "YYYYMMDD_hhmmss") & "_" & wkb.Name
        Kill strCurrFile
        wkb.SaveAs strCurrFile
    End If
End Sub
  
  
Public Sub gestSupprFeuilles(Optional blnDoNotShowMe As Boolean = True)

    If ThisWorkbook.ResetParams Then
        verificationPourMiseAJour
        
        SuppressionFeuillesAnterieures
    End If
    
End Sub

Public Sub ActiverCommandesGestion(Optional blnDoNotShowMe As Boolean = True)
    'Demander le mot de passe
    'lib|fffd|rer si ok
    Dim ufPw As New usrFPassword
    
    With ufPw
        HideTitleBar ufPw
        .Show
        
        If .TextBox1.Text = C_MDP_CLIENT Then
            ThisWorkbook.blnEstGestionnaire = True
            ResetMenu
        End If
    End With
    
End Sub

Public Sub UCM_Unprotect(Optional blnDoNotShow As Boolean = True)
    ActiveSheet.Unprotect C_PASSWORD
    'Debug.Print "Password : " & C_PASSWORD
End Sub

Public Sub UCM_Protect(Optional blnDoNotShow As Boolean = True)
    Dim wks As Worksheet
    Set wks = ActiveSheet
    wks.EnableOutlining = True
    wks.Protect C_PASSWORD, True, True, True, True, True, False, False, False, False, False, False, True, False, False, False
    
End Sub






Attribute VB_Name = "IJourPrestations"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'
'
' Interface : IJourPrestations
'
' Objectif
' *********
'  D|fffd|finir un contrat de base pour la gestion des prestations pour un jour donn|fffd|
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'


Public Property Get estDefini() As Boolean
End Property

Public Property Get DatePrestation() As String
End Property


Public Property Get Prestations() As Collection
End Property

'Retourne Vrai si la date a bien |fffd|t|fffd| d|fffd|finie
'Attention : la d|fffd|finition d'une date diff|fffd|rente provoque la suppression des prestations d|fffd|j|fffd| connues
Public Function definirJourPrestations(lngAnnee As Long, lngMois As Long, intJour As Long) As Boolean
End Function

Public Function ajouterPrestation(strCodePrestation As String, dblNbHeures As Double, blnIndicateurPNuit As Boolean, blnIndicateurPEquipe As Boolean) As Boolean
End Function

Public Function estIdentique(ByRef objOth As IJourPrestations) As Boolean
End Function

Public Sub PrintDebug()
End Sub


Attribute VB_Name = "INI_GlobalObjects"
Option Explicit

Public parametresMacroUCM As Params


' Cette fonction a pour objectif de cr|fffd|er un fichier ini, dans le m|fffd|me r|fffd|pertoire que le fichier excel courant,
' dans le but de fournir des param|fffd|tres de base corrects.
' A n'utiliser que si on choisi cette mani|fffd|re de stocker les param|fffd|tres :s :s
'
'
Public Sub initialisationFichierIni(Optional blnDoNotShowMe As Boolean = True)
    'D|fffd|termination de l'emplacement du fichier courant
'    Dim strIniFileName As String
'    strIniFileName = ActiveWorkbook.Path & C_INI_FILENAME
'
'    EcritureIniString strIniFileName, "UTILISATEUR", "GUID", C_INI_USER_GUID_MAN_LOC
'
'    EcritureIniString strIniFileName, "ENVIRONNEMENT", "REPERTOIRE_BASE", "{MYDOCUMENTS}\UCM-Automatisation\"
'
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_DIMANCHE_ACTIF", 0
'    EcritureIniString strIniFileName, "CONTROLES", "WARN_DIMANCHE_VISIBLE", 0
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_CODES_PRESTATIONS_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "WARN_CODES_PRESTATIONS_VISIBLE", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_REF_POINTEUSES_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "WARN_REF_POINTEUSES_VISIBLE", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_NB_HRS_PREST_JOURN_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "WARN_NB_HRS_PREST_JOURN_VISIBLE", 0
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_FIN_MOIS_NEGATIFS_CPT1_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_FIN_MOIS_NEGATIFS_CPT2_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_FIN_MOIS_NEGATIFS_CPT3_ACTIF", 0
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_FIN_MOIS_NEGATIFS_CPT4_ACTIF", 0
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_FIN_MOIS_NEGATIFS_CPT5_ACTIF", 0
'    EcritureIniString strIniFileName, "CONTROLES", "WARN_SOLDES_FIN_MOIS_NEGATIFS_VISIBLE", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_DEBUT_MOIS_CPT1_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_DEBUT_MOIS_CPT2_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_DEBUT_MOIS_CPT3_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_DEBUT_MOIS_CPT4_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "CTRL_SOLDES_DEBUT_MOIS_CPT5_ACTIF", 1
'    EcritureIniString strIniFileName, "CONTROLES", "WARN_SOLDES_DEBUT_MOIS_VISIBLE", 1
'
'    EcritureIniString strIniFileName, "CONTROLE_PRESTATIONS", "NB_HRS_PREST_JOURN_MINIMUM", "3.0"
'    EcritureIniString strIniFileName, "CONTROLE_PRESTATIONS", "NB_HRS_PREST_JOURN_MAXIMUM", "9.0"
'
End Sub

Attribute VB_Name = "IPlanning"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'
'
' Interface : IPlanning
'
' Objectif
' *********
'  D|fffd|finir un contrat de base pour la gestion des plannings de prestation (=relev|fffd|s)
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'


'D|fffd|finition de la p|fffd|riode de calcul de paie => permet de g|fffd|n|fffd|rer un tableau de jours...
Public Function definirPeriodePaie(lngAnnee As Long, lngMois As Long) As Boolean
End Function


Public Function ajouterPrestation(intJour As Long, strCodePaie As String, dblHeures As Double, blnIndicateurPNuit As Boolean, blnIndicateurPEquipe As Boolean) As Boolean
End Function

Public Property Get JoursPrestations() As Collection
End Property


Public Property Get PeriodePaie() As String
End Property

Public Function estIdentique(objOth As IPlanning) As Boolean
End Function

Public Function estDefini() As Boolean
End Function


Public Function getNbCodes() As Long
End Function

Public Function getPrestDetails(nbCode As Long) As String
End Function

Attribute VB_Name = "IPrestation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'
'
' Interface : IPrestation
'
' Objectif
' *********
'  D|fffd|finir un contrat de base pour la gestion des prestations
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'

Public Property Get numLigne() As Long
End Property

Public Property Get codePaie() As String
End Property

Public Property Get NbHeures() As Double
End Property

Public Property Let primeNuit(blnPrimeNuitActive As Boolean)
End Property

Public Property Let primeEquipe(blnPrimeNuitActive As Boolean)
End Property

Public Property Get primeNuit() As Boolean
End Property
Public Property Get primeEquipe() As Boolean
End Property


Public Function definirPrestation(newNumLigne As Long, newCodePaie As String, newNbHrs As Double) As Boolean
End Function

'Retourne True si l'objet en param|fffd|tre est identique
Public Function estIdentique(objOther As IPrestation) As Boolean
End Function



Attribute VB_Name = "IRefInterne"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Interface : IRefInterne
'
' Objectif
' *********
'  Permet d'ajouter une r|fffd|f|fffd|rence interne |fffd| un objet
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'

Public Property Get referenceInterne() As String
End Property
Public Property Let referenceInterne(newVal As String)
End Property

Attribute VB_Name = "IScript"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Interface : IScript
'
' Objectif
' *********
'  D|fffd|finir un contrat de base pour la gestion des rubriques int|fffd|gr|fffd|es dans les scripts
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'
Public Enum TypeRubriqueEnum
    typeRubriqueUnite = 1
    typeRubriqueMontant = 2
    typeRubriqueNonDefini = 3
End Enum


'Donn|fffd|e membre : la rubrique |fffd| d|fffd|finir
Public Property Get CodeRubrique() As String
End Property

'Type de rubrique : montant ou unit|fffd| ?
Public Property Get TypeRubrique() As TypeRubriqueEnum
End Property

' Montant associ|fffd| si type Montant
Public Property Get Montant() As Double
End Property

' Montant associ|fffd| si type Montant
Public Property Get NbUnites() As Double
End Property

'Permet de d|fffd|finir le type de rubrique.
'Retourne False en cas d'erreur
'Public Function definirTypeRubrique(newTypeRubr As TypeRubriqueEnum) As Boolean
'End Function


'Permet de d|fffd|finir les |fffd|l|fffd|ments constitutifs d'une rubrique de type Script
Public Function definirDonneesRubrique(newTypeRubr As TypeRubriqueEnum, newCodeRubrique As String, newNumValue As Double) As Boolean
End Function

'Permet de d|fffd|terminer si un script est |fffd|gal au script en cours
Public Function estIdentique(otherScript As IScript) As Boolean
End Function
Attribute VB_Name = "ITravailleur"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Interface : ITravailleur
'
' Objectif
' *********
'  D|fffd|finir un contrat de base pour la gestion des travailleurs
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  N|fffd|ant
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'




'D|fffd|finit le num|fffd|ro du travailleur
Public Property Get NumeroTravailleur() As String
End Property
Public Property Let NumeroTravailleur(newNumeroTravailleur As String)
End Property

'D|fffd|finit le nom du travailleur
Public Property Get NomTravailleur() As String
End Property
Public Property Let NomTravailleur(newNomTravailleur As String)
End Property


'Donn|fffd|e membre : les contrats du travailleur
Public Property Get Contrats() As Collection
End Property


'Retourne Vrai si le contrat dont la r|fffd|f|fffd|rence est donn|fffd|e existe
Public Function existeContrat(strReferencePointeuse As String) As Boolean
End Function


Public Function ajouteContrat(newContrat As IContrat) As Boolean
End Function
Attribute VB_Name = "InfosPrestationsJour"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private m_arrCodesPrest() As String
Private m_arrDureesPrest() As String
Private m_lngNbPrestations As Long


'Permet la conversion d'un certain nombre d'heures "0001.00" en un autre type.
'Retourne le nombre d'heures non converties
'Ne convertit que les heures au del|fffd| de 7:36 (soit 7,6 hrs)
Public Function ConvertirPrestations(dblDureeConversion As Double, strCodeDest As String, Optional strCodeSource As String = "0001.00", Optional dblLimiteInferieure As Double = 7.6) As Double
    Dim dblDureeConvertie As Double
    Dim cpt As Long
    
    If Not existeDansCodes(strCodeSource) Then
        dblDureeConvertie = 0#
    Else
        For cpt = 1 To m_lngNbPrestations
            'On ne peut convertir QUE les heures de prestations normales
            If m_arrCodesPrest(cpt) = strCodeSource Then
                'Uniquement si on a plus de x heures sur la journ|fffd|e (valeur d|fffd|finie par le deuxi|fffd|me param|fffd|tre optionnel)
                If m_arrDureesPrest(cpt) > dblLimiteInferieure Then
                    dblDureeConvertie = m_arrDureesPrest(cpt) - dblLimiteInferieure
                    'Limitation de la dur|fffd|e de conversion au "pot" |fffd| convertir
                    If dblDureeConvertie >= dblDureeConversion Then
                        dblDureeConvertie = dblDureeConversion
                    End If
                    m_arrDureesPrest(cpt) = m_arrDureesPrest(cpt) - dblDureeConvertie
                    ajouterPrestation strCodeDest, dblDureeConvertie
                End If
                Exit For
            End If
        Next
    End If
    'on retourne le nombre d'heures restant |fffd| convertir
    ConvertirPrestations = dblDureeConversion - dblDureeConvertie
End Function

'Date au format AAAAMMJJ
'Public Sub GenererOuptutTemporaire(ByRef outF As TextStream, lngNumTrav As Long, strDtPrest As String)
'    Dim cpt As Long
'    For cpt = 1 To m_lngNbPrestations
'        impressionLigne outF, lngNumTrav, strDtPrest, m_arrCodesPrest(cpt), Round(m_arrDureesPrest(cpt) * 100, 0)
'    Next
'End Sub



'Repr|fffd|sente, pour un jour donn|fffd|, les prestations d'un travailleur
Public Sub ajouterPrestation(strCodeFH As String, dblDuree As Double)
    If dblDuree > EPSILON Then
        If existeDansCodes(strCodeFH) Then
            augmenterValeurPrestations strCodeFH, dblDuree
        Else
            m_lngNbPrestations = m_lngNbPrestations + 1
            ReDim Preserve m_arrCodesPrest(m_lngNbPrestations)
            ReDim Preserve m_arrDureesPrest(m_lngNbPrestations)
            m_arrCodesPrest(m_lngNbPrestations) = strCodeFH
            m_arrDureesPrest(m_lngNbPrestations) = dblDuree
        End If
    End If
End Sub

Private Function existeDansCodes(strCodeFH As String) As Boolean
    Dim retVal As Boolean
    Dim cpt As Long
    
    
    retVal = False
    For cpt = 0 To m_lngNbPrestations
        If m_arrCodesPrest(cpt) = strCodeFH Then
            retVal = True
            Exit For
        End If
    Next
    existeDansCodes = retVal
    
End Function


Private Sub augmenterValeurPrestations(strCodeFH As String, dblDuree As Double)
    Dim cpt As Long
    
    For cpt = 1 To m_lngNbPrestations
        If m_arrCodesPrest(cpt) = strCodeFH Then
            m_arrDureesPrest(cpt) = m_arrDureesPrest(cpt) + dblDuree
            Exit For
        End If
    Next
End Sub

Private Sub Class_Initialize()
    m_lngNbPrestations = 0
    ReDim m_arrCodesPrest(m_lngNbPrestations)
    ReDim m_arrDureesPrest(m_lngNbPrestations)
End Sub
Attribute VB_Name = "JourPrestations"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Classe : JourPrestations
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Permettre la g|fffd|n|fffd|ration du fichier XML "Interface Prestations" sur base des informations m|fffd|moris|fffd|es
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  DefinitionConstantes                 | 1.0
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    15.06.2015    | Version initiale
'

'Impl|fffd|mente l'interface IScript
Implements IJourPrestations
Implements IRefInterne

Private blnDefini As Boolean
Private collPrestations As Collection
Private dtDatePrestation As Date

Private strRefInterne As String

Private Sub Class_Initialize()
    blnDefini = False
    Set collPrestations = Nothing
    dtDatePrestation = Now
End Sub

'#UnitTestOK
Public Property Get IJourPrestations_estDefini() As Boolean
    IJourPrestations_estDefini = blnDefini
End Property

'#UnitTestOK
Public Property Get IJourPrestations_datePrestation() As String
    IJourPrestations_datePrestation = IIf(blnDefini, Format(dtDatePrestation, "yyyy-mm-dd"), "")
End Property

'#UnitTestOK
Private Function IJourPrestations_estIdentique(ByRef objOth As IJourPrestations) As Boolean
    Dim retVal As Boolean
    Dim cpt As Long
    Dim presta As IPrestation
    Dim presta2 As IPrestation
    Dim refPresta As IRefInterne
    Dim prestations2 As Collection
    retVal = True
    
    
    
    
    If Not (blnDefini = objOth.estDefini) Then retVal = False
    If blnDefini Then
        If retVal And Not (Format(dtDatePrestation, "yyyy-mm-dd") = objOth.DatePrestation) Then retVal = False
        
        If retVal And Not ((collPrestations Is Nothing) = (objOth.Prestations Is Nothing)) Then retVal = False
        
        If retVal And Not collPrestations Is Nothing Then
            If Not (collPrestations.Count = objOth.Prestations.Count) Then
                retVal = False
            Else
                Set prestations2 = objOth.Prestations
                
                For Each presta In collPrestations
                    Set refPresta = presta
                    
                    Set presta2 = prestations2.Item(refPresta.referenceInterne)
                    If Not presta.estIdentique(presta2) Then
                        retVal = False
                        Exit For
                    End If
                Next
            End If
        End If
    End If
    
    IJourPrestations_estIdentique = retVal
End Function

'#UnitTestOK
Public Property Get IJourPrestations_Prestations() As Collection
    Set IJourPrestations_Prestations = IIf(blnDefini, collPrestations, Nothing)
End Property

'Retourne Vrai si la date a bien |fffd|t|fffd| d|fffd|finie
'Attention : la d|fffd|finition d'une date diff|fffd|rente provoque la suppression des prestations d|fffd|j|fffd| connues
'#UnitTestOK
Public Function IJourPrestations_definirJourPrestations(lngAnnee As Long, lngMois As Long, intJour As Long) As Boolean
    Dim tmpDate As Date
    
    tmpDate = DateSerial(lngAnnee, lngMois, intJour)
    If blnDefini Then
        If Not (dtDatePrestation = tmpDate) Then
            dtDatePrestation = tmpDate
            blnDefini = True
            Set collPrestations = New Collection
        End If
    Else
        dtDatePrestation = tmpDate
        blnDefini = True
        Set collPrestations = New Collection
    End If
    
    IJourPrestations_definirJourPrestations = blnDefini
    
End Function

'#UnitTestOK
Public Function IJourPrestations_ajouterPrestation(strCodePrestation As String, dblNbHeures As Double, blnIndicateurPNuit As Boolean, blnIndicateurPEquipe As Boolean) As Boolean
    Dim retVal As Boolean
    Dim pres As IPrestation
    Dim refI As IRefInterne
    Dim nbElems As Long
    
    
    
    retVal = True
    If blnDefini Then
        nbElems = collPrestations.Count
        
        Set pres = New Prestation
        If pres.definirPrestation(nbElems + 1, strCodePrestation, dblNbHeures) Then
            If strCodePrestation = "0001.00" Then
                pres.primeEquipe = blnIndicateurPEquipe
                pres.primeNuit = blnIndicateurPNuit
            End If
            
            Set refI = pres
            refI.referenceInterne = C_PREFIX_PRESTA & CStr(nbElems + 1)
            collPrestations.Add pres, refI.referenceInterne
        Else
            retVal = False
        End If
    Else
        retVal = False
    End If
    
    IJourPrestations_ajouterPrestation = retVal
End Function


Private Property Let IRefInterne_referenceInterne(RHS As String)
    strRefInterne = RHS
End Property

Private Property Get IRefInterne_referenceInterne() As String
    IRefInterne_referenceInterne = strRefInterne
End Property


Private Sub IJourPrestations_PrintDebug()
    Dim prst As IPrestation
    Debug.Print "Jour Prestation"
    Debug.Print " -> R|fffd|f|fffd|rence interne : " & strRefInterne
    Debug.Print " -> Date prestation   : " & Format(dtDatePrestation, "yyyy-mm-dd")
    Debug.Print " -> Prestations       : "
    For Each prst In collPrestations
        Debug.Print "    --> Code / Nb Hrs : " & prst.codePaie & " / " & prst.NbHeures & " (" & prst.numLigne & ")"
    Next
    
End Sub

Attribute VB_Name = "Logger"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'
'
' Classe : Logger
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Logging d'informations dans une feuille cibl|fffd|e
'
'  D|fffd|finition d'|fffd|num|fffd|ration : LogLevel
'
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  DefinitionConstantes                 | 1.0
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    30.06.2015    | Version initiale
'

'D|fffd|finir le type de logging souhait|fffd|
Private Const MIN_LOG_LEVEL As Long = 0 '   Valeurs  : 0=>Debug    1=>info     2 => warning    3=> Erreur

Private blnDefini As Boolean
Private strNom As String
Private wksLog As Worksheet
Private currLigne As Long
Private lien_ufRes As usrFormResultatTraitement

Public Enum LogLevel
    LevelDebug = 0
    LevelInfo = 1
    LevelWarning = 2
    LevelError = 3
End Enum



Private Sub Class_Initialize()
    blnDefini = False
    currLigne = 2
    Set wksLog = Nothing
    Set lien_ufRes = Nothing
End Sub

Public Property Set userFormResultat(newufR As usrFormResultatTraitement)
    Set lien_ufRes = newufR
End Property

Public Property Get userFormResultat() As usrFormResultatTraitement
    Set userFormResultat = lien_ufRes
End Property

Public Property Get nom() As String
    nom = strNom
End Property

Public Function renomme(nouveauNom As String) As Boolean
    Dim retVal As Boolean
    
    If blnDefini Then
        strNom = nouveauNom
        wksLog.Name = nouveauNom
    Else
        retVal = False
    End If
    
    renomme = retVal
End Function

Public Function creerFeuilleLog(strNomFeuille As String, wkbActif As Workbook) As Boolean
    Dim retVal As Boolean
    retVal = False
    
    If blnDefini Then
        retVal = False
        ajoutErreur "creerFeuilleLog", "Cr|fffd|ation impossible, feuille de log d|fffd|j|fffd| d|fffd|finie"
    Else
        Set wksLog = wkbActif.Worksheets.Add
        wksLog.Name = strNomFeuille
        wksLog.Range("A1").Value = "Date"
        wksLog.Range("B1").Value = "Heure"
        wksLog.Range("C1").Value = "Niveau"
        wksLog.Range("D1").Value = "Texte"
        wksLog.Range("E1").Value = "Source"
        ajoutInfo "creerFeuilleLog", "Cr|fffd|ation de la feuille de log"
        strNom = strNomFeuille
        blnDefini = True
    End If
    
    creerFeuilleLog = retVal
End Function

Public Function ajoutDebug(strSrc As String, strDesc As String, Optional ShowInForm As Boolean = False) As Boolean
    If ShowInForm Then
        lien_ufRes.AjouterInfo strDesc
    End If
    
    If MIN_LOG_LEVEL <= LevelDebug Then
        ajoutDebug = ajoutLogElem(LevelDebug, strSrc, strDesc)
    Else
        ajoutDebug = True
    End If
    If estPosteDeTravailUCM Then Debug.Print strDesc
End Function

Public Function ajoutInfo(strSrc As String, strDesc As String, Optional ShowInForm As Boolean = False) As Boolean
    If ShowInForm Then
        lien_ufRes.AjouterInfo strDesc
    End If
    If MIN_LOG_LEVEL <= LevelInfo Then
        ajoutInfo = ajoutLogElem(LevelInfo, strSrc, strDesc)
    Else
        ajoutInfo = True
    End If
End Function

Public Function ajoutWarning(strSrc As String, strDesc As String, Optional ShowInForm As Boolean = True) As Boolean
    If ShowInForm Then
        lien_ufRes.AjouterAlerte strDesc
    End If
    
    If MIN_LOG_LEVEL <= LevelWarning Then
        ajoutWarning = ajoutLogElem(LevelWarning, strSrc, strDesc)
    Else
        ajoutWarning = True
    End If
End Function

Public Function ajoutErreur(strSrc As String, strDesc As String, Optional ShowInForm As Boolean = True) As Boolean
    If ShowInForm Then
        lien_ufRes.AjouterErreur strDesc
    End If
    
    If MIN_LOG_LEVEL <= LevelError Then
        ajoutErreur = ajoutLogElem(LevelError, strSrc, strDesc)
    Else
        ajoutErreur = True
    End If
End Function

Private Function ajoutLogElem(level As LogLevel, strSrc As String, strDesc As String) As Boolean
    Dim retVal As Boolean
    retVal = False
    
    wksLog.Range("A" & CStr(currLigne)).Value = Format(Now, "dd-mm-yyyy")
    wksLog.Range("B" & CStr(currLigne)).Value = Format(Now, "hh:mm:ss")
    Select Case level
        Case LevelInfo
            wksLog.Range("C" & CStr(currLigne)).Value = "Info"
        Case LevelWarning
            wksLog.Range("C" & CStr(currLigne)).Value = "Alerte"
        Case LevelDebug
            wksLog.Range("C" & CStr(currLigne)).Value = "Debug"
        Case LevelError
            wksLog.Range("C" & CStr(currLigne)).Value = "Erreur"
    End Select
    wksLog.Range("D" & CStr(currLigne)).Value = IIf(Left(strDesc, 1) = "=", "'" & strDesc, strDesc)
    wksLog.Range("E" & CStr(currLigne)).Value = strSrc
    
    currLigne = currLigne + 1
    ajoutLogElem = retVal
End Function

Public Function parentWorkbook() As Workbook
    Set parentWorkbook = wksLog.Parent
End Function

Attribute VB_Name = "Mises_A_Jour"


Public Sub verificationPourMiseAJour(Optional blnDoNotShowMe As Boolean = True)
    Dim wksTmp As Worksheet, wksParams As Worksheet
    Dim blnValide As Boolean
    Dim rg As Range
    Dim lngLigneCible As Long
    
    '1. V|fffd|rifier s'il y a des mises |fffd| jour |fffd| effectuer
    blnValide = False
    
    For Each wksTmp In ActiveWorkbook.Sheets
        If wksTmp.Name = "GH - Travailleurs" Then
            blnValide = True
            Exit For
        End If
    Next
    
    'On n'est pas dans le bon fichier => on sort sans autre forme de proc|fffd|s
    If Not blnValide Then Exit Sub
    
    'Feuille param|fffd|tres
    Set wksParams = ActiveWorkbook.Sheets("Param|fffd|tres")
    
    lngLigneCible = initTitres(wksParams)
    
    
    
    lngLigneCible = Mise_A_Jour_1(wksParams, lngLigneCible)
    lngLigneCible = Mise_A_Jour_2(wksParams, lngLigneCible)
    lngLigneCible = Mise_A_Jour_3(wksParams, lngLigneCible)
    lngLigneCible = Mise_A_Jour_4(wksParams, lngLigneCible)
'    lngLigneCible = Mise_A_Jour_5(wksParams, lngLigneCible)
    
'Pour ajouter une mise |fffd| jour :
    'cr|fffd|er Mise_A_Jour_nnn
    's'assurer que la valeur de retour est le num|fffd|ro de ligne cible ant|fffd|rieur + 1
    
End Sub


'D|fffd|finir les informations de P|fffd|les comme |fffd|tant une r|fffd|f|fffd|rence vers la feuille GH-Travailleurs
' Pour autant que la feuille concerne le mois en cours ou un mois suivant
Private Function Mise_A_Jour_5(ByRef wksP As Worksheet, lngLigneCible As Long) As Long
    Dim wksTmp As Worksheet
    Dim dtTmp As Date
    Dim lngLigne As Long, lngColonne As Long
    
    Dim GHTS As New GrillesHoraires
    Dim gh As GrilleHoraireTravailleur
    
    GHTS.ChargerGrillesAPartirDeFeuille (wksP.Parent.Sheets("GH - Travailleurs"))
    
    Application.ScreenUpdating = False
    Application.Cursor = xlWait
    
    If Len(Trim(wksP.Cells(lngLigneCible, 13))) = 0 Then
        
        For Each wksTmp In wksP.Parent.Worksheets
            If estNomDeMois(wksTmp.Name, dtTmp) Then
                If Year(dtTmp) > Year(Now) Or ((Year(dtTmp) = Year(Now)) And (Month(dtTmp) >= Month(Now))) Then
                    'Parcours des lignes du tableau et attribution de la formule pour r|fffd|cup|fffd|rer
                    wksTmp.Activate
                                    
                    lngLigne = C_PR_LIGNE_DEB
                    While Len(Trim(wksTmp.Cells(lngLigne, C_PR_COL_NOM))) > 0
                        Set gh = GHTS.GHTravailleur(0)
                        lngLigne = lngLigne + 3
                    Wend
                End If
            End If
        Next
        
        wksP.Activate
        UCM_Unprotect
        wksP.Cells(lngLigneCible, 13).Value = "POLES"
        wksP.Cells(lngLigneCible, 14).Value = "P|fffd|le r|fffd|cup|fffd|r|fffd| dans la feuille GH Trav et non en dur"
        wksP.Cells(lngLigneCible, 15).Value = Format(Now, "dd/mm/yyyy")
        UCM_Protect
    End If
    
    Application.Cursor = xlDefault
    Application.ScreenUpdating = True
    
    Mise_A_Jour_5 = lngLigneCible + 1
End Function


Private Function Mise_A_Jour_4(ByRef wksP As Worksheet, lngLigneCible As Long) As Long
    Dim wksTmp As Worksheet, dtTmp As Date
    Dim rg As Range
    
    If Len(Trim(wksP.Cells(lngLigneCible, 13))) = 0 Then
        
        For Each wksTmp In wksP.Parent.Sheets
            If estNomDeMois(wksTmp.Name, dtTmp) Or wksTmp.Name = "GH - Travailleurs" Then
                wksTmp.Activate
                UCM_Unprotect
                
                Set rg = wksTmp.Columns("A:A")
                rg.NumberFormat = "###### 000000"
                
                UCM_Protect
            End If
        Next
        
        wksP.Activate
        UCM_Unprotect
        wksP.Cells(lngLigneCible, 13).Value = "NUM T"
        wksP.Cells(lngLigneCible, 14).Value = "Adaptation num|fffd|ros Travailleurs (gestion lignes multiples)"
        wksP.Cells(lngLigneCible, 15).Value = Format(Now, "dd/mm/yyyy")
        UCM_Protect
    End If

    Mise_A_Jour_4 = lngLigneCible + 1
End Function


' Correction du contenu de la colonne E => les donn|fffd|es ne doivent pas s'y trouver !
'
Private Function Mise_A_Jour_3(ByRef wksP As Worksheet, lngLigneCible As Long) As Long
    Dim wksTmp As Worksheet
    Dim lngLigne As Long, lngColonne As Long
    
    If Len(Trim(wksP.Cells(lngLigneCible, 13))) = 0 Then
        
        Set wksTmp = wksP.Parent.Sheets("10-2018")
        wksTmp.Activate
        UCM_Unprotect
            
        lngLigne = 4
        lngColonne = 5
        While Len(Trim(wksTmp.Cells(lngLigne, 2))) > 0
            'Debug.Print lngLigne & " : " & Format(wksTmp.Cells(lngLigne, lngColonne) * 24)
            wksTmp.Cells(lngLigne, lngColonne) = 0
            lngLigne = lngLigne + 3
        Wend
        UCM_Protect
        
        wksP.Activate
        UCM_Unprotect
        wksP.Cells(lngLigneCible, 13).Value = "CALC"
        wksP.Cells(lngLigneCible, 14).Value = "10-2019 : Hrs Sem. Pr|fffd|c. |fffd| 0 (d|fffd|but de mois = lundi)"
        wksP.Cells(lngLigneCible, 15).Value = Format(Now, "dd/mm/yyyy")
        UCM_Protect
    End If

    Mise_A_Jour_3 = lngLigneCible + 1
End Function


' Toutes les feuilles sont prot|fffd|g|fffd|es !
'

Private Function Mise_A_Jour_2(ByRef wksP As Worksheet, lngLigneCible As Long) As Long
    Dim wksTmp As Worksheet
    
    If Len(Trim(wksP.Cells(lngLigneCible, 13))) = 0 Then
        
        For Each wksTmp In wksP.Parent.Sheets
            If Not wksTmp.ProtectContents Then
                wksTmp.Activate
                UCM_Protect
            End If
        Next
        
        
            wksP.Activate
            UCM_Unprotect
            wksP.Cells(lngLigneCible, 13).Value = "PROT"
            wksP.Cells(lngLigneCible, 14).Value = "Toutes les feuilles sont prot|fffd|g|fffd|es"
            wksP.Cells(lngLigneCible, 15).Value = Format(Now, "dd/mm/yyyy")

            UCM_Protect
    End If

    Mise_A_Jour_2 = lngLigneCible + 1
End Function


'Ajout de commentaires sur les en-t|fffd|tes au niveau des heures suppl|fffd|mentaires
'
Private Function Mise_A_Jour_1(ByRef wksP As Worksheet, lngLigneCible As Long) As Long
    Dim blnFinal As Boolean
    Dim wksTmp As Worksheet
    Dim dtPremJr As Date
    Dim rg As Range
    
    If Len(Trim(wksP.Cells(lngLigneCible, 13))) = 0 Then
        blnFinal = False
        
        For Each wksTmp In wksP.Parent.Sheets
            If estNomDeMois(wksTmp.Name, dtPremJr) Then
                wksTmp.Activate
                UCM_Unprotect
                Set rg = obtenirRangeHeader(wksTmp, "HEURES SUPP. AVANT")
                If Not rg Is Nothing Then
                    rg.AddComment "Heures suppl|fffd|mentaires cumul|fffd|es depuis le 1er f|fffd|vrier de la p|fffd|riode consid|fffd|r|fffd|e, non compris le mois en cours."
                End If
                
                Set rg = obtenirRangeHeader(wksTmp, "HEURES SUPP. APRES")
                If Not rg Is Nothing Then
                    rg.AddComment "Heures suppl|fffd|mentaires cumul|fffd|es depuis le 1er f|fffd|vrier de la p|fffd|riode consid|fffd|r|fffd|e, y compris le mois en cours."
                End If
                UCM_Protect
            End If
        Next
        
        
        'If blnFinal Then

            wksP.Activate
            UCM_Unprotect
            wksP.Cells(lngLigneCible, 13).Value = "COMM HRS SUPP"
            wksP.Cells(lngLigneCible, 14).Value = "Ajout de commentaires explicatifs sur les heures supp avant/apr|fffd|s"
            wksP.Cells(lngLigneCible, 15).Value = Format(Now, "dd/mm/yyyy")

            wksP.Range("M:M").ColumnWidth = 15
            wksP.Range("N:N").ColumnWidth = 60
            wksP.Range("O:O").ColumnWidth = 10
            wksP.Range("K:L").ColumnWidth = 0

            UCM_Protect
        'End If
        
        
    End If

    Mise_A_Jour_1 = lngLigneCible + 1
End Function


Private Function initTitres(ByRef wksP As Worksheet) As Long
    If Len(Trim(wksP.Cells(1, 13).Value)) = 0 Then
        wksP.Activate
        UCM_Unprotect
        With wksP
            .Cells(1, 13).Value = "Historique des mises |fffd| jour"
            .Cells(1, 13).Style = .Cells(1, 1).Style
            .Cells(1, 14).Style = .Cells(1, 1).Style
            .Cells(1, 15).Style = .Cells(1, 1).Style
            
            .Range("M:M").ColumnWidth = 15
            .Range("N:N").ColumnWidth = 15
            .Range("O:O").ColumnWidth = 50
        
            .Cells(2, 13).Value = "CODE MAJ"
            .Cells(2, 14).Value = "DESC MAJ"
            .Cells(2, 15).Value = "DATE MAJ"
            
            
            .Range("M2:O2").Interior.Color = .Range("M1:M1").Borders(xlEdgeBottom).Color
            .Range("M2:O2").Font.Color = vbWhite
            .Range("M2:O2").Font.Bold = True
        End With
        
        
        UCM_Protect
    End If
    
    initTitres = 3
End Function



Private Function obtenirRangeHeader(ByRef wksT As Worksheet, strTitreCherche As String, Optional lngLigne As Long = 1) As Range
    Dim lngColonne As Long
    
    lngColonne = 1
    
    While UCase(Trim(wksT.Cells(lngLigne, lngColonne))) <> UCase(strTitreCherche) And lngColonne <= 250 '"HEURES SUPP. APRES"
        lngColonne = lngColonne + 1
    Wend
    
    If lngColonne >= 250 Then
        Set obtenirRangeHeader = Nothing
    Else
        Set obtenirRangeHeader = wksT.Cells(lngLigne, lngColonne)
    End If
    
End Function
Attribute VB_Name = "Module2"
Public Sub testtest()
    'Dim wks As Worksheet
    Dim dtDeb As Date
    Dim dtFin As Date
    Dim dtTest As Date
    Dim strNom As String
    Dim blnCanContinue As Boolean
    
    
    dtDeb = #4/15/2018#
    dtFin = #11/12/2020#
    
    blnCanContinue = True
    dtTest = DateSerial(Year(dtDeb), Month(dtDeb), 1)
    
    
    'Trouver la premi|fffd|re feuille disponible
    strNom = Format(dtDeb, "MM-YYYY")
        
    'Trouver le premier mois sur lequel r|fffd|aliser la mise |fffd| jour (il se peut que la feuille
    ' n'existe plus => on doit alors tester le mois suivant, jusqu'|fffd| ce qu'on tombe sur le premier mois disponible
    'A l'inverse, si la feuille existe, on ne bouge pas...
    While Not feuilleExiste(strNom, ActiveWorkbook)
        DoEvents
        Debug.Print "Feuille " & strNom & " non trouv|fffd|e"
        dtTest = DateAdd("m", "1", dtTest)
        strNom = Format(dtTest, "MM-YYYY")
    Wend
    
    blnCanContinue = True
    While dtTest < dtFin And blnCanContinue
        blnCanContinue = False
        DoEvents
        If feuilleExiste(strNom, ActiveWorkbook) Then
            blnCanContinue = True
            Debug.Print "ajoutDuTravailleurDansLaFeuille " & strNom
        End If
        dtTest = DateAdd("m", "1", dtTest)
        strNom = Format(dtTest, "MM-YYYY")
    Wend
    
End Sub
Attribute VB_Name = "Params"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
' Classe : Params
'
' Fichier de base pour |fffd|dition :
'  Aucun - |fffd| externaliser
'
' Objectif
' *********
'  Permettre la gestion uniforme de fichiers de param|fffd|trisation
'
' Mode d'emploi
' *************
'   D|fffd|finir les param|fffd|tres suppl|fffd|mentaires |fffd| traiter
'     Pour chacun :
'       - d|fffd|finir un type de donn|fffd|es pour stocker la valeur
'       - cr|fffd|er un Getter
'       - mettre |fffd| jour la proc|fffd|dure ReloadFromWorkSheet pour r|fffd|cup|fffd|rer la valeur dans la feuille
'
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    20.08.2015    | Version initiale
'

Private m_blnDefini As Boolean
Private m_strFileName As String     'Uniquement pour gestion via fichier INI
Private m_wksParams As Worksheet    'Uniquement pour gestion via feuille Excel

'Private m_strNumDossier As String       'Num|fffd|ro du dossier pour lequel la macro est d|fffd|finie
'Private m_strNomDossier As String       'Nom du dossier pour lequel la macro est d|fffd|finie
'Private m_strRepertoireBase As String   'Repertoire de base pour le travail sur la macro
                                        'Uniquement pour clients externes !




'D|fffd|finir les param|fffd|tres que l'on d|fffd|sire stocker
'Private m_typeNomMembre as TypeSouhait|fffd|

'D|fffd|finir les Getters pour ces param|fffd|tres
'Public Property Get NomMembre() As TypeSouhaite
'    NomMembre = m_typeNomMembre
'End Property

Private Sub ReloadFromWorkSheet()
'    If m_wksParams Is Nothing Then
'        Debug.Print "La feuille n'est pas d|fffd|finie !"
'    Else
        
'        m_strNumDossier = m_wksParams.Range("NUM_DOSSIER").Value
'        m_strNomDossier = m_wksParams.Range("NOM_DOSSIER").Value
        
'        m_strRepertoireBase = m_wksParams.Range("REP_BASE").Value
'    End If
End Sub

'
'
' Les fonctions qui suivent sont des fonctions pr|fffd|d|fffd|finies - ne pas modifier sans certitude !
'
'
'


''Getter sur Num|fffd|ro de dossier
'Public Property Get NumeroDossier() As String
'    NumeroDossier = Right(String(6, "0") & m_strNumDossier, 6)
'End Property
''Getter sur Nom de dossier
'Public Property Get NomDossier() As String
'    NomDossier = m_strNomDossier
'End Property
''Getter sur R|fffd|pertoire de base
'Public Property Get RepertoireBase() As String
'    RepertoireBase = m_strRepertoireBase
'End Property

' Fonctionnalit|fffd| pour recharger les param|fffd|tres avant l'ex|fffd|cution du processus.
'Ceci doit |fffd|tre appel|fffd| en d|fffd|but de traitement pour forcer ce rechargement.
Public Sub ResetParamsFromSource()
    ReloadFromWorkSheet
End Sub


'Wrapper pour le chargement des param|fffd|tres. Cette fonction appelle, apr|fffd|s alimentation de la r|fffd|f|fffd|rence
' interne |fffd| la feuille, la fonction dans laquelle sont d|fffd|finies les chargements.
Public Function InitFromWorkSheet(ByRef wksSheetParams As Worksheet)
    'Appel avec Nothing sans impact pour le reste du traitement
    Set m_wksParams = wksSheetParams
    
    'Tout le chargement des param|fffd|tres se fait dans cette proc|fffd|dure
    ReloadFromWorkSheet
    m_blnDefini = True
End Function


Private Sub Class_Initialize()
    m_blnDefini = False
    m_strFileName = ""
    Set m_wksParams = Nothing
End Sub



'Permet de savoir si un objet param|fffd|tres est initialis|fffd| ou non
Public Property Get estInitialise() As Boolean
    estInitialise = m_blnDefini
End Property


'D|fffd|finir les Getters n|fffd|cessaires pour chaque param|fffd|tre |fffd| manipuler


Attribute VB_Name = "Planning"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Classe : Planning
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Permettre la g|fffd|n|fffd|ration du fichier XML "Interface Prestations" sur base des informations m|fffd|moris|fffd|es
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'  DefinitionConstantes                 | 1.0
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    15.06.2015    | Version initiale
'

'Impl|fffd|mente l'interface IScript
Implements IPlanning

Private Const C_PREFIX_JPREST As String = "ID-JP"


'Stockage sous forme de tableau pour faciliter le traitement

Private arrJoursPrestations() As IJourPrestations
Private arrJourPrestationDefini() As Boolean

Private arrCodesPrestations() As String
Private arrCptPrestation() As Double
Private m_nbCodes As Long

Private lngMois As Long
Private lngAnnee As Long
Private blnDefini As Boolean
Private intNbJours As Long

Private Sub Class_Initialize()
    m_nbCodes = 0
    ReDim arrCodesPrestations(0 To m_nbCodes)
    ReDim arrCptPrestation(0 To m_nbCodes)
End Sub


Public Function IPlanning_getNbCodes() As Long
    IPlanning_getNbCodes = m_nbCodes
End Function

Public Function IPlanning_getPrestDetails(nbCode As Long) As String
    If nbCode >= 1 And nbCode <= m_nbCodes Then
        IPlanning_getPrestDetails = Left(arrCodesPrestations(nbCode) & "        ", 10) & " : " & formatHeure(arrCptPrestation(nbCode))
    Else
        IPlanning_getPrestDetails = ""
    End If
End Function

Private Function ajouterRecapPrestations(strCode As String, nbHrs As Double) As Boolean
    Dim cpt As Long
    Dim blnOK As Boolean
    
    blnOK = False
    For cpt = 1 To m_nbCodes
        If arrCodesPrestations(cpt) = strCode Then
            arrCptPrestation(cpt) = arrCptPrestation(cpt) + nbHrs
            blnOK = True
            Exit For
        End If
    Next
    
    If Not blnOK Then
        m_nbCodes = m_nbCodes + 1
        ReDim Preserve arrCodesPrestations(0 To m_nbCodes)
        ReDim Preserve arrCptPrestation(0 To m_nbCodes)
        arrCodesPrestations(cpt) = strCode
        arrCptPrestation(cpt) = arrCptPrestation(cpt) + nbHrs
    End If
            
End Function

'Seules les valeurs 1..12 pour le mois, et 2015..2075 pour l'ann|fffd|e
'#UnitTestOK
Public Function IPlanning_definirPeriodePaie(lngAnneeDef As Long, lngMoisDef As Long) As Boolean
    Dim retVal As Boolean
    Dim testDate As Date
    Dim cpt As Long
    Dim JourPrest As JourPrestations
    retVal = True
    
    'D|fffd|finir le mois, calculer le nombre de jours, cr|fffd|er les deux tableaux et les initialiser...
    If lngMoisDef >= 1 And lngMoisDef <= 12 And lngAnneeDef >= 2015 And lngAnneeDef <= 2075 Then
        lngMois = lngMoisDef
        lngAnnee = lngAnneeDef
        testDate = DateSerial(lngAnneeDef, lngMoisDef, 1)
        testDate = DateAdd("m", 1, testDate)
        testDate = DateAdd("d", -1, testDate)
        intNbJours = Day(testDate)
        
        ReDim arrJoursPrestations(1 To intNbJours)
        ReDim arrJourPrestationDefini(1 To intNbJours)
        
        For cpt = 1 To intNbJours
            arrJourPrestationDefini(cpt) = False
            
            Set JourPrest = New JourPrestations
            If JourPrest.IJourPrestations_definirJourPrestations(lngAnneeDef, lngMoisDef, cpt) Then
                Set arrJoursPrestations(cpt) = JourPrest
            Else
                retVal = False
            End If
        Next
    Else
        retVal = False
    End If
    
    blnDefini = retVal
    
    IPlanning_definirPeriodePaie = retVal
End Function


'#UnitTestOK
Public Function IPlanning_ajouterPrestation(intJour As Long, strCodePaie As String, dblHeures As Double, blnIndicateurPNuit As Boolean, blnIndicateurPEquipe As Boolean) As Boolean
    Dim retVal As Boolean
    
    retVal = True
    
    If blnDefini And intJour <= intNbJours Then
        retVal = arrJoursPrestations(intJour).ajouterPrestation(strCodePaie, dblHeures, blnIndicateurPNuit, blnIndicateurPEquipe)
        If retVal Then
            ajouterRecapPrestations strCodePaie, dblHeures
            
            arrJourPrestationDefini(intJour) = True
        End If
    Else
        retVal = False
    End If
    
    IPlanning_ajouterPrestation = True
End Function

Private Function IPlanning_estDefini() As Boolean
    IPlanning_estDefini = blnDefini
End Function

'#UnitTestOK
Private Function IPlanning_estIdentique(objOth As IPlanning) As Boolean
    Dim retVal As Boolean
    Dim PrestOth As Collection, PrestMe As Collection
    Dim JP As IJourPrestations, othJP As IJourPrestations
    Dim refInt As IRefInterne, strRef As String, refIntOth As IRefInterne
    Dim blnChecked As Boolean, blnResult As Boolean
    
    retVal = True
        
    If Not Me.IPlanning_PeriodePaie = objOth.PeriodePaie Then retVal = False
    Set PrestMe = Me.IPlanning_JoursPrestations
    Set PrestOth = objOth.JoursPrestations
    
    If PrestMe.Count = PrestOth.Count Then
        For Each JP In PrestMe
            Set refInt = JP
            strRef = refInt.referenceInterne
            blnChecked = False
            For Each othJP In PrestOth
                Set refIntOth = othJP
                If refIntOth.referenceInterne = strRef Then
                    blnChecked = True
                    blnResult = JP.estIdentique(othJP)
                    If Not blnResult Then
                        retVal = False
                    End If
                End If
            Next
            
            If Not blnChecked Then retVal = False
            If Not retVal Then Exit For
        Next
    Else
        retVal = False
    End If
    
    IPlanning_estIdentique = retVal
End Function

'Permet de r|fffd|cup|fffd|rer les jours de prestation d|fffd|finis sous forme d'une collection
'Retourne a minima une collection vide (Count=0)
'#UnitTestOK
Public Property Get IPlanning_JoursPrestations() As Collection
    Dim collTemp As Collection
    Dim cpt As Long
    Dim refInt As IRefInterne
    
    Set collTemp = New Collection
    
    For cpt = 1 To intNbJours
        If arrJourPrestationDefini(cpt) Then
            Set refInt = arrJoursPrestations(cpt)
            refInt.referenceInterne = C_PREFIX_JPREST & CStr(cpt)
            collTemp.Add arrJoursPrestations(cpt), C_PREFIX_JPREST & CStr(cpt)
        End If
    Next
    
    Set IPlanning_JoursPrestations = collTemp
End Property


'Obtenir la p|fffd|riode au format AAAAMM
'#UnitTestOK
Public Property Get IPlanning_PeriodePaie() As String
    IPlanning_PeriodePaie = IIf(blnDefini, CStr(lngAnnee) & Right("00" & CStr(lngMois), 2), "")
End Property
Attribute VB_Name = "Prestation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Classe : Prestation
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Permettre la g|fffd|n|fffd|ration du fichier XML "Interface Prestations" sur base des informations m|fffd|moris|fffd|es
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    15.06.2015    | Version initiale
'


'Impl|fffd|mente l'interface IScript
Implements IPrestation
Implements IRefInterne

Private lngNumLigne As Long
Private strCodePaie As String
Private dblNbHeures As Double
Private strRefInterne As String

Private m_blnPrimeNuitDefinie As Boolean
Private m_blnPrimeEquipeDefinie As Boolean


'#UnitTestOK
Private Sub Class_Initialize()
    lngNumLigne = 0
    strCodePaie = ""
    dblNbHeures = 0#
End Sub


'#UnitTestOK
Private Function IPrestation_estIdentique(objOther As IPrestation) As Boolean
    Dim retVal As Boolean
    retVal = True
    
    If Not (lngNumLigne = objOther.numLigne And _
                strCodePaie = objOther.codePaie And _
                dblNbHeures = objOther.NbHeures) Then
        retVal = False
    End If
    
    IPrestation_estIdentique = retVal
End Function

'#UnitTestOK
Public Property Get IPrestation_numLigne() As Long
    IPrestation_numLigne = lngNumLigne
End Property

'#UnitTestOK
Public Property Get IPrestation_codePaie() As String
    IPrestation_codePaie = strCodePaie
End Property

'#UnitTestOK
Public Property Get IPrestation_NbHeures() As Double
    IPrestation_NbHeures = dblNbHeures
End Property

'#UnitTestOK
Public Function IPrestation_definirPrestation(newNumLigne As Long, newCodePaie As String, newNbHrs As Double) As Boolean
    Dim retVal As Boolean
    
    retVal = True
    
    lngNumLigne = newNumLigne
    strCodePaie = newCodePaie
    dblNbHeures = newNbHrs
    
    IPrestation_definirPrestation = retVal
End Function


Private Property Let IPrestation_primeEquipe(blnPrimeEquipeDef As Boolean)
    m_blnPrimeEquipeDefinie = blnPrimeEquipeDef
End Property

Private Property Get IPrestation_primeEquipe() As Boolean
    IPrestation_primeEquipe = m_blnPrimeEquipeDefinie
End Property

Private Property Let IPrestation_primeNuit(blnPrimeNuitDef As Boolean)
    m_blnPrimeNuitDefinie = blnPrimeNuitDef
End Property

Private Property Get IPrestation_primeNuit() As Boolean
    IPrestation_primeNuit = m_blnPrimeNuitDefinie
End Property


Private Property Let IRefInterne_referenceInterne(RHS As String)
    strRefInterne = RHS
End Property

Private Property Get IRefInterne_referenceInterne() As String
    IRefInterne_referenceInterne = strRefInterne
End Property
Attribute VB_Name = "RAZ_FeuilleActive"
Option Explicit


Public Sub cleanupHrsSuppAvant(Optional blnDoNotShowMe As Boolean = True)
    Dim wks As Worksheet, wksAct As Worksheet
    Dim dtMois As Date, dtMoisAct As Date, dtRef As Date
    Dim numLigne As Long
    Dim rgCell As Range
    Dim blnActive As Boolean
    Dim strForm() As String
    Dim dblValueBefore As Double
    
    Dim rgEnd As Range

    'Objectif : pour la feuille courante, pour autant qu'elle ait |fffd|t|fffd| fig|fffd|e !
    ' Pour chaque ligne travailleur
    '     Mettre, dans la cellule HrsSuppAvant, un commentaire qui contiendra le nombre d'hrs supp pr|fffd|c|fffd|dente
    '     Remettre |fffd| 0 cette valeur (supprimer la formule)
    '     Supprimer, dans les formules des colonnes "Total Hrs hebd sur mois pr|fffd|c." et la premi|fffd|re synth|fffd|se hebd
    '              toute mention de la feuille pr|fffd|c|fffd|dente
    ' Activer chaque feuille l'une apr|fffd|s l'autre pour activer les mises |fffd| jour.
    
    Set wks = ActiveSheet
    
    If estNomDeMois(wks.Name, dtMois) Then
        If wks.Cells(1, 4) = "Heures Supp. AVANT" Then
            dtRef = dtMois
            'R|fffd|aliser un backup du fichier
            gestBackup
            
            'S'assurer que la feuille est fig|fffd|e
            FigeageFormulesReferences False, wks
            
            wks.Range("A1").Activate
            Set rgEnd = Cells.Find(What:="Synth|fffd|se Hebd. du", After:=ActiveCell, SearchOrder:=xlByRows)
            
            UCM_Unprotect
            numLigne = 4
            While Len(Trim(wks.Cells(numLigne, 2))) > 0
                If Not IsEmpty(wks.Cells(numLigne, 4)) Then
                    Set rgCell = wks.Cells(numLigne, 4)
                    With rgCell.AddComment
                        .Text "Ancienne valeur avant RAZ : " & formatHeureExcel(rgCell.Value)
                    End With
                    rgCell.Value = 0#
                    
                    'Nettoyage des r|fffd|f|fffd|rences sur total hrs hebd sur mois pr|fffd|c|fffd|dent
                    Set rgCell = wks.Cells(numLigne, 5)
                    rgCell.Value = rgCell.Value
                    
                    'Nettoyage formule premi|fffd|re semaine si n|fffd|cessaire
                    Set rgCell = wks.Cells(numLigne, rgEnd.Column)
                    If InStr(rgCell.Formula, ",") > 0 Then
                        dblValueBefore = rgCell.Value
                        strForm = Split(rgCell.Formula, ",")
                        rgCell.Formula = strForm(0) & ")"
                        
                        rgCell.Formula = strForm(0) & ") + E" & numLigne
                        If rgCell.MergeCells Then
                            rgCell.MergeArea.Locked = False
                        Else
                            rgCell.Locked = False
                        End If
                    End If
                    
                    Set rgCell = wks.Cells(numLigne + 2, rgEnd.Column)
                    If InStr(rgCell.Formula, ",") > 0 Then
                        dblValueBefore = rgCell.Value
                        strForm = Split(rgCell.Formula, ",")
                        rgCell.Formula = strForm(0) & ")"
                        rgCell.Formula = Replace(strForm(0) & ")+(" & (dblValueBefore - rgCell.Value) & ")", ",", ".")
                        If rgCell.MergeCells Then
                            rgCell.MergeArea.Locked = False
                        Else
                            rgCell.Locked = False
                        End If
                    End If
                End If
                
                numLigne = numLigne + 3
            Wend
            
            UCM_Protect
            
            blnActive = True
            
            ' Propager les modifications apport|fffd|es en activant toutes les feuilles depuis la feuille modifi|fffd|e
            ' (gestion des compteurs de cumul)
            While blnActive
                blnActive = False
                For Each wksAct In ActiveWorkbook.Worksheets
                    If estNomDeMois(wksAct.Name, dtMoisAct) Then
                        If dtMoisAct = DateAdd("m", 1, dtMois) Then
                            'Debug.Print "Activation feuille suivante : " & wksAct.Name
                            blnActive = True
                            dtMois = dtMoisAct
                            wksAct.Activate
                            DoEvents
                        End If
                    End If
                Next
            Wend
            
            dtMois = dtRef
            'Supprimer les feuilles ant|fffd|rieures
            If MsgBox("D|fffd|sirez-vous supprimer les feuilles ant|fffd|rieures |fffd| la feuille du mois " & wks.Name & "?", vbYesNo + vbQuestion, "Confirmation n|fffd|cessaire !") = vbYes Then
                blnActive = True
                While blnActive
                    blnActive = False
                    For Each wksAct In wks.Parent.Worksheets
                        If estNomDeMois(wksAct.Name, dtMoisAct) Then
                            If dtMoisAct = DateAdd("m", -1, dtMois) Then
                                Application.DisplayAlerts = False
                                wksAct.Delete
                                Application.DisplayAlerts = True
                                dtMois = dtMoisAct
                                DoEvents
                            End If
                        End If
                    Next
                Wend
            End If
            
            'Se remettre sur la feuille trait|fffd|e
            wks.Activate

        Else
            MsgBox "Impossible de traiter cette feuille : ne correspond pas |fffd| la structure des feuilles de prestations."
        End If
    Else
        MsgBox "Cette fonctionnalit|fffd| ne peut |fffd|tre utilis|fffd|e que sur une feuille de prestations mensuelles"
    End If
    
    
End Sub

'Permet d'afficher une valeur d'heures au format excel sous forme |fffd|tendue (partie enti|fffd|re * 24 hrs)
Public Function formatHeureExcel(dblVal As Double) As String
    Dim dblTmp As Double
    Dim nbHrs As Long
    Dim nbMin As Long
    
    nbHrs = Int(dblVal) * 24
    dblTmp = (dblVal - Int(dblVal)) * 24
    
    nbHrs = nbHrs + Int(dblTmp)
    dblTmp = (dblTmp - Int(dblTmp)) * 60
    
    nbMin = Round(dblTmp, 0)
    
    formatHeureExcel = Format(nbHrs, "##00") & ":" & Format(nbMin, "00")
End Function
Attribute VB_Name = "RecapHrsSupp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private m_wksGH As Worksheet
Private m_wkbAct As Workbook
Private m_annee As Long

Private m_collItems As Collection



Public Property Set FeuilleGH(ByRef newVal As Worksheet)
    Set m_wksGH = newVal
    Set m_wkbAct = m_wksGH.Parent
End Property

Public Property Let AnneeDebut(newVal As Long)
    m_annee = newVal
End Property

Public Sub generer()
    Dim cpt As Long
    Dim dtTmp As Date
    Dim strNomFeuille As String
    Dim wks As Worksheet
    Dim lngLigne As Long, lngColonne As Long
    Dim currTravInfo As HrsSuppTrav
    Dim destBook As Workbook
    Dim strKey As String
    
    
    For cpt = 1 To 12
        DoEvents
        dtTmp = DateSerial(m_annee, cpt + 1, 1)
        strNomFeuille = Format(dtTmp, "MM-YYYY")
        If feuilleExiste(strNomFeuille, m_wkbAct) Then
            Set wks = m_wkbAct.Sheets(strNomFeuille)
            'R|fffd|cup|fffd|ration des donn|fffd|es HS sur cette feuille
            lngLigne = C_PR_LIGNE_DEB
            While Len(Trim(wks.Cells(lngLigne, C_PR_COL_NOM))) > 0
                'obtenir r|fffd|f|fffd|rence sur le travailleur
                strKey = UCase(Left(wks.Cells(lngLigne, C_PR_COL_POLE), 3)) & CStr(wks.Cells(lngLigne, C_PR_COL_NUM))
                If travailleurExisteDansColl(strKey) Then
                    Set currTravInfo = m_collItems(strKey)
                Else
                    Set currTravInfo = New HrsSuppTrav
                    currTravInfo.num = wks.Cells(lngLigne, C_PR_COL_NUM)
                    currTravInfo.nom = wks.Cells(lngLigne, C_PR_COL_NOM)
                    currTravInfo.pole = wks.Cells(lngLigne, C_PR_COL_POLE)
                    m_collItems.Add currTravInfo, strKey
                End If
                
                lngColonne = C_PR_COL_DET_PRES_START
                While InStr(wks.Cells(C_PR_LIGNE_TITRE, lngColonne), "partielle") <= 0 And InStr(wks.Cells(C_PR_LIGNE_TITRE, lngColonne), "Heures Supp") <= 0
                    DoEvents
                    If InStr(wks.Cells(C_PR_LIGNE_TITRE, lngColonne), "Synth|fffd|se") > 0 Then
                        Debug.Print strNomFeuille & ".("; lngLigne & ", " & lngColonne & " ) : " & wks.Cells(C_PR_LIGNE_TITRE, lngColonne - 4) & "-" & wks.Cells(lngLigne + 2, lngColonne)
                        currTravInfo.ajouterHsSupp wks.Cells(C_PR_LIGNE_TITRE, lngColonne - 4), wks.Cells(lngLigne + 2, lngColonne)
                        lngColonne = lngColonne + 1
                    Else
                        lngColonne = lngColonne + 4
                    End If
                Wend
                lngLigne = lngLigne + 3
            Wend
            
        End If
    Next
    
    'On a tout r|fffd|cup|fffd|r|fffd|
    
    If Len(Dir(m_wkbAct.Path & "\R|fffd|capitulatifs HS.xlsx")) > 0 Then
        Set destBook = Workbooks.Open(m_wkbAct.Path & "\R|fffd|capitulatifs HS.xlsx")
        Set wks = destBook.Worksheets.Add
    Else
        Set destBook = Workbooks.Add
        destBook.SaveAs m_wkbAct.Path & "\R|fffd|capitulatifs HS.xlsx"
        Set wks = destBook.Worksheets(1)
    End If
    
    wks.Name = "HS " & Format(Now, "YYYYMMDD hhmm")
    
    
    wks.Cells(C_REC_LG_HEAD1, C_REC_COL_NUM) = "R|fffd|capitulatif Heures Suppl|fffd|mentaires"
    wks.Cells(C_REC_LG_HEAD2, C_REC_COL_NUM) = "R|fffd|alis|fffd| le " & Format(Now, "dd/mm/yyyy")
    
    wks.Cells(C_REC_LG_HEAD3, C_REC_COL_NUM) = "P|fffd|riode : f|fffd|vrier " & m_annee & " |fffd| janvier " & m_annee + 1
    
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_NUM) = "Num|fffd|ro UCM"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_NOM) = "Nom"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_POLE) = "P|fffd|le"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_HRS_1P) = "HS 1er Semestre (Prest|fffd|es)"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_HRS_1AP) = "HS 1er Semestre (|fffd| prester)"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_HRS_2P) = "HS 2|fffd|me Semestre (Prest|fffd|es)"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_HRS_2AP) = "HS 2|fffd|me Semestre (|fffd| prester)"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_HRS_2_VP) = "HSV 2|fffd|me semestre (Prest|fffd|es)"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_HRS_2_VAP) = "HSV 2|fffd|me semestre (|fffd| prester)"
    wks.Cells(C_REC_LG_TITRE_TAB, C_REC_COL_HRS_TOT) = "Total annuel"
    
    lngLigne = C_REC_LG_START_DATA
    For Each currTravInfo In m_collItems
        wks.Cells(lngLigne, C_REC_COL_NUM) = currTravInfo.num
        wks.Cells(lngLigne, C_REC_COL_NOM) = currTravInfo.nom
        wks.Cells(lngLigne, C_REC_COL_POLE) = currTravInfo.pole
        wks.Cells(lngLigne, C_REC_COL_HRS_1P) = currTravInfo.NbHrsPremierSemestrePrestees
        wks.Cells(lngLigne, C_REC_COL_HRS_1AP) = currTravInfo.NbHrsPremierSemestre
        wks.Cells(lngLigne, C_REC_COL_HRS_2P) = currTravInfo.NbHrsDeuxi|fffd|meSemestreHorsCampagnePrestees
        wks.Cells(lngLigne, C_REC_COL_HRS_2AP) = currTravInfo.NbHrsDeuxi|fffd|meSemestreHorsCampagne
        wks.Cells(lngLigne, C_REC_COL_HRS_2_VP) = currTravInfo.NbHrsDeuxi|fffd|meSemestreCampagnePrestees
        wks.Cells(lngLigne, C_REC_COL_HRS_2_VAP) = currTravInfo.NbHrsDeuxi|fffd|meSemestreCampagne
        wks.Cells(lngLigne, C_REC_COL_HRS_TOT) = "=SUM(RC[-6]:RC[-1])"
        
        lngLigne = lngLigne + 1
    Next
    
    formaterFeuilleRecap wks, lngLigne - 1
    destBook.Save
    
    destBook.Activate
End Sub

Private Sub formaterFeuilleRecap(ByRef wks As Worksheet, lngMaxLigne As Long)
    Dim rg As Range
    Dim strTableName As String
    
    Set rg = wks.Range("A1:J1")
    With rg
        .Font.Color = RGB(150, 150, 210)
        .Font.Size = "16"
        .Merge
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    Set rg = wks.Range("A2:J2")
    With rg
        .Font.Color = RGB(150, 150, 210)
        .Font.Size = "12"
        .Merge
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    Set rg = wks.Range("A4:J4")
    With rg
        .Font.Color = RGB(150, 150, 210)
        .Font.Size = "12"
        .Font.Underline = xlUnderlineStyleSingle
        .Merge
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    strTableName = "Recap" & Format(Now, "yymmdd_hhmm")
    wks.ListObjects.Add(xlSrcRange, Range("$A$6:$J$" & lngMaxLigne), , xlYes).Name = _
        strTableName
    'wks.Range(strTableName & "[#All]").Select
    wks.ListObjects(strTableName).TableStyle = "TableStyleMedium3"

    'D|fffd|finition s|fffd|paration de colonnes
    Set rg = wks.Range(strTableName & "[[HS 1er Semestre (Prest|fffd|es)]:[HS 1er Semestre (|fffd| prester)]]")
    
    With rg.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
        .Weight = XlBorderWeight.xlMedium
    End With
    rg.Borders(xlEdgeTop).LineStyle = xlNone
    rg.Borders(xlEdgeBottom).LineStyle = xlNone
    With rg.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
        .Weight = XlBorderWeight.xlMedium
    End With
    rg.Borders(xlInsideVertical).LineStyle = xlNone
    rg.Borders(xlInsideHorizontal).LineStyle = xlNone
    
    Set rg = wks.Range(strTableName & "[[HSV 2|fffd|me semestre (Prest|fffd|es)]:[HSV 2|fffd|me semestre (|fffd| prester)]]")

    rg.Borders(xlDiagonalDown).LineStyle = xlNone
    rg.Borders(xlDiagonalUp).LineStyle = xlNone
    With rg.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
        .Weight = XlBorderWeight.xlThin
    End With
    rg.Borders(xlEdgeTop).LineStyle = xlNone
    rg.Borders(xlEdgeBottom).LineStyle = xlNone
    With rg.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
        .Weight = xlMedium
    End With
    
    'Mise en forme des nombres
    wks.Columns("A:J").EntireColumn.AutoFit
    wks.Range(strTableName & "[[HS 1er Semestre (Prest|fffd|es)]:[Total annuel]]").NumberFormat = "[hh]:mm;[Red][hh]:mm;\-;@"
    wks.Range(strTableName & "[[Num|fffd|ro UCM]:[Total annuel]]").HorizontalAlignment = xlCenter
    wks.Range(strTableName & "[[Num|fffd|ro UCM]]").NumberFormat = "###### 000000"
    wks.Range(strTableName & "[[Total annuel]]").Font.Bold = True
    
    'Tri
    wks.ListObjects(strTableName).Sort.SortFields.Clear
    wks.ListObjects(strTableName).Sort.SortFields.Add Key:=Range(strTableName & "[[#All],[Num|fffd|ro UCM]]"), SortOn:= _
        xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    With wks.ListObjects(strTableName).Sort
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .SortMethod = xlPinYin
        .Apply
    End With
    
    'D|fffd|sactivation des filtres
    'wks.ListObjects(strTableName).ShowAutoFilterDropDown = False
    
    'Largeur de colonnes
    Set rg = wks.Range("D:I")
    rg.ColumnWidth = 9
    
    'Adaptation des headers
    Set rg = wks.Range(strTableName & "[#Headers]")
    With rg
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlTop
        .WrapText = True
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .MergeCells = False
        .RowHeight = 63
    End With
    
    wks.Range("A1").Select
End Sub

'
'
'    Range( _
'        "Recap181022_1559[[HS 1er Semestre (Prest|fffd|es)]:[HS 1er Semestre (|fffd| prester)]]") _
'        .Select
'    With Selection.Borders(xlEdgeLeft)
'        .LineStyle = xlContinuous
'        .ColorIndex = xlAutomatic
'        .TintAndShade = 0
'        .Weight = xlMedium
'    End With
'    Selection.Borders(xlEdgeTop).LineStyle = xlNone
'    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
'    With Selection.Borders(xlEdgeRight)
'        .LineStyle = xlContinuous
'        .ColorIndex = xlAutomatic
'        .TintAndShade = 0
'        .Weight = xlMedium
'    End With
'    Selection.Borders(xlInsideVertical).LineStyle = xlNone
'    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
'    Range( _
'        "Recap181022_1559[[HSV 2|fffd|me semestre (Prest|fffd|es)]:[HSV 2|fffd|me semestre (|fffd| prester)]]" _
'        ).Select
'    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
'    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
'    With Selection.Borders(xlEdgeLeft)
'        .LineStyle = xlContinuous
'        .ColorIndex = xlAutomatic
'        .TintAndShade = 0
'        .Weight = xlMedium
'    End With
'    Selection.Borders(xlEdgeTop).LineStyle = xlNone
'    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
'    With Selection.Borders(xlEdgeRight)
'        .LineStyle = xlContinuous
'        .ColorIndex = xlAutomatic
'        .TintAndShade = 0
'        .Weight = xlMedium
'    End With
'    Selection.Borders(xlInsideVertical).LineStyle = xlNone
'    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
'    Range("Recap181022_1559[HS 1er Semestre (Prest|fffd|es)]").Select
'End Sub


Private Function travailleurExisteDansColl(strKey As String) As Boolean
    Dim retVal As Boolean
    Dim test As Variant
    retVal = True
    
    On Error Resume Next
    Set test = m_collItems(strKey)
    If Err.Number <> 0 Then
        Err.Clear
        retVal = False
    End If
    travailleurExisteDansColl = retVal
    
    On Error GoTo 0
End Function

Private Sub Class_Initialize()
    Set m_collItems = New Collection
    'Dans le cas o|fffd| l'initialisation ne serait pas r|fffd|alis|fffd|e
    m_annee = Year(Now)
    If Month(Now) = 1 Then
        m_annee = m_annee - 1
    End If
End Sub
Attribute VB_Name = "Script"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Classe : Script
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Permettre la g|fffd|n|fffd|ration du fichier XML "Interface Prestations" sur base des informations m|fffd|moris|fffd|es
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    15.06.2015    | Version initiale
'

'Impl|fffd|mente l'interface IScript
Implements IScript
Implements IRefInterne


Private blnDefini As Boolean
Private enumTypeRubrique As TypeRubriqueEnum
Private strCodeRubrique As String
Private dblMontant As Double
Private dblUnite As Double
Private strRefInterne As String

Private Sub Class_Initialize()
    blnDefini = False
    enumTypeRubrique = typeRubriqueNonDefini
    strCodeRubrique = ""
    dblMontant = 0
    dblUnite = 0
End Sub

'#UnitTestOK
Private Property Let IRefInterne_referenceInterne(RHS As String)
    strRefInterne = RHS
End Property

'#UnitTestOK
Private Property Get IRefInterne_referenceInterne() As String
    IRefInterne_referenceInterne = strRefInterne
End Property

'Donn|fffd|e membre : la rubrique |fffd| d|fffd|finir
'#UnitTestOK
Public Property Get IScript_CodeRubrique() As String
    If blnDefini Then
        IScript_CodeRubrique = strCodeRubrique
    Else
        IScript_CodeRubrique = ""
    End If
End Property

'#UnitTestOK
Private Function IScript_estIdentique(otherScript As IScript) As Boolean
    Dim retVal As Boolean
    retVal = True
    
    If Not (strCodeRubrique = otherScript.CodeRubrique And _
            enumTypeRubrique = otherScript.TypeRubrique) Then
        retVal = False
    Else
        Select Case otherScript.TypeRubrique
            Case typeRubriqueMontant
                If Not (dblMontant = otherScript.Montant) Then retVal = False
            Case typeRubriqueUnite
                If Not (dblUnite = otherScript.NbUnites) Then retVal = False
        End Select
    End If
    
    IScript_estIdentique = retVal
End Function

'Type de rubrique : montant ou unit|fffd| ?
'Controle : NonDefini => non admis
''
'#UnitTestOK
Public Property Get IScript_TypeRubrique() As TypeRubriqueEnum
    If blnDefini Then
        IScript_TypeRubrique = enumTypeRubrique
    Else
        IScript_TypeRubrique = typeRubriqueNonDefini
    End If
End Property

' Montant associ|fffd| si type Montant
'#UnitTestOK
Public Property Get IScript_Montant() As Double
    IScript_Montant = IIf(blnDefini, dblMontant, 0)
End Property


' Montant associ|fffd| si type Unit|fffd|
'#UnitTestOK
Public Property Get IScript_NbUnites() As Double
    IScript_NbUnites = IIf(blnDefini, dblUnite, 0)
End Property


'Permet de d|fffd|finir les |fffd|l|fffd|ments constitutifs d'une rubrique de type Script
'#UnitTestOK
Public Function IScript_definirDonneesRubrique(newTypeRubr As TypeRubriqueEnum, newCodeRubrique As String, newNumValue As Double) As Boolean
    Dim retVal As Boolean

    If newTypeRubr = typeRubriqueNonDefini Then
        retVal = False
        blnDefini = False
        Class_Initialize
    Else
        retVal = True
        Class_Initialize
        enumTypeRubrique = newTypeRubr
        Select Case enumTypeRubrique
            Case typeRubriqueMontant
                dblMontant = newNumValue
            Case typeRubriqueUnite
                dblUnite = newNumValue
        End Select
        strCodeRubrique = newCodeRubrique
        blnDefini = True
    End If

    IScript_definirDonneesRubrique = retVal
End Function


Attribute VB_Name = "SuppressionFeuille"
Public Sub SuppressionFeuillesAnterieures(Optional blnDoNotShowMe As Boolean = True)


'    Dim rg As Range
    Dim dtTest As Date
    
    If estNomDeMois(ActiveSheet.Name, dtTest) Then
        
        If MsgBox("Toutes les feuilles ant|fffd|rieures |fffd| la feuille " & ActiveSheet.Name & " seront supprim|fffd|es. Ceci aura pour effets :" & vbCrLf & _
                   " => de r|fffd|duire la taille de votre fichier;" & vbCrLf & _
                   " => de supprimer toute r|fffd|f|fffd|rence, dans la feuille active, |fffd| une quelconque feuille ant|fffd|rieure." & vbCrLf & _
                   "Il ne sera pas possible d'annuler cette action !" & vbCrLf & vbCrLf & _
                   "|fffd|tes-vous certain.e de vouloir proc|fffd|der |fffd| cette suppression ?", vbExclamation + vbYesNo, "Suppression de feuilles ant|fffd|rieures") = vbNo Then
            Exit Sub
        End If
        
        Set rg = ActiveSheet.Cells
        
        UCM_Unprotect
        ActiveSheet.EnableCalculation = False
        Application.ScreenUpdating = False
        
' Traitement de nettoyage

        Range("E4").Select
        
        Application.ScreenUpdating = True
        UCM_Protect
    Else
        MsgBox "Cette fonctionnalit|fffd| n'est disponible que sur les feuilles de prestations.", vbInformation + vbOKOnly, "Suppression de feuilles ant|fffd|rieures"
    End If

End Sub
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Public blnEstGestionnaire As Boolean


Private Sub Workbook_BeforeClose(Cancel As Boolean)
    SuppressionMenuX CSTR_NOM_MENU
End Sub

Private Sub Workbook_Open()
    SuppressionMenuX CSTR_NOM_MENU
    
    If estPosteDeTravailUCM Then
        blnEstGestionnaire = True
    Else
        blnEstGestionnaire = False
    End If
    'Afficher le menu
    AjoutMenuX
End Sub


'Cette fonction doit |fffd|tre appel|fffd|e lorsque la feuille active est correctement d|fffd|finie.
'Retourne Vrai si le fichier actif est bien d|fffd|fini
Public Function ResetParams() As Boolean
    Dim retVal As Boolean
    
    Dim wkbRef As Workbook
    Set wkbRef = ActiveWorkbook
    
    retVal = validerPresenceFeuillesFichierPrestations(wkbRef)
    If retVal Then
        If parametresMacroUCM Is Nothing Then
            Set parametresMacroUCM = New Params
            parametresMacroUCM.InitFromWorkSheet wkbRef.Sheets("Param|fffd|tres")
        Else
            parametresMacroUCM.ResetParamsFromSource
        End If
    Else
        MsgBox "Veuillez vous positionner sur un fichier de prestations valide avant l'ex|fffd|cution de cette commande.", vbCritical + vbOKOnly, "Impossible d'ex|fffd|cuter cette commande"
    End If
    
    ResetParams = retVal
End Function


Private Function validerPresenceFeuillesFichierPrestations(ByRef wkb As Workbook) As Boolean
    Dim retVal As Boolean
    Dim wks As Worksheet
    Dim dtTest As Date
    
    'Au moins une feuille au format "mois" ?
    retVal = False
    For Each wks In wkb.Worksheets
        If estNomDeMois(wks.Name, dtTest) Then
            retVal = True
            Exit For
        End If
    Next
    
    retVal = retVal And feuilleExiste("Param|fffd|tres", wkb)
    retVal = retVal And feuilleExiste("Codes de prestations", wkb)
    retVal = retVal And feuilleExiste("GH - Travailleurs", wkb)
    
    
    validerPresenceFeuillesFichierPrestations = retVal
    
End Function
Attribute VB_Name = "Travailleur"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'
'
' Classe : Travailleur
'
' Fichier de base pour |fffd|dition :
'  M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\Macro Int|fffd|gration Prestations - Partie 2.xlsm
'
' Important :
'  Chaque utilisation de ce module doit |fffd|tre inventori|fffd|e en cas de n|fffd|cessit|fffd| de diffusion d'une nouvelle version
'  Rappel : fichier d'inventaire : M:\SS\Support\Espace |fffd|quipes\Equipe BIS\03 - Automatisation\03 - D|fffd|veloppements\
'
' Objectif
' *********
'  Permettre la g|fffd|n|fffd|ration du fichier XML "Interface Prestations" sur base des informations m|fffd|moris|fffd|es
'
' Auteur
' *******
'  Thierry Elnikoff (thierry.elnikoff@ucm.be - extension 576)
'
' D|fffd|pendances
' ************
'  Nom du module devant |fffd|tre int|fffd|gr|fffd|    | Version minimale
' --------------------------------------+------------------
'
' Versions
'**********
'  N|fffd|       |       Date       | Description des changements
'  1.00     |    10.06.2015    | Version initiale
'

'Impl|fffd|mente l'interface Travailleur
Implements ITravailleur
Private Const C_PREFIX_CONTRAT As String = "ID-CTRT"

Private strNumeroTravailleur As String
Private blnNumeroTravailleurDefini As Boolean
Private strNomTravailleur As String


Private collContrats As Collection


Private Sub Class_Initialize()
    strNumeroTravailleur = ""
    strNomTravailleur = ""
    blnNumeroTravailleurDefini = False
    Set collContrats = New Collection
End Sub

'D|fffd|finit le num|fffd|ro du travailleur
'#UnitTestOK
Public Property Get ITravailleur_NumeroTravailleur() As String
    ITravailleur_NumeroTravailleur = strNumeroTravailleur
End Property
Public Property Let ITravailleur_NumeroTravailleur(newNumeroTravailleur As String)
    strNumeroTravailleur = newNumeroTravailleur
End Property

'#UnitTestOK
Public Property Get ITravailleur_NomTravailleur() As String
    ITravailleur_NomTravailleur = strNomTravailleur
End Property
Public Property Let ITravailleur_NomTravailleur(newNomTravailleur As String)
    strNomTravailleur = newNomTravailleur
End Property


'Points suivants : attente d|fffd|veloppement contrat

'Donn|fffd|e membre : les contrats du travailleur
Public Property Get ITravailleur_Contrats() As Collection
    Set ITravailleur_Contrats = collContrats
End Property


'Retourne Vrai si le contrat dont la r|fffd|f|fffd|rence est donn|fffd|e existe
Public Function ITravailleur_existeContrat(strReferencePointeuse As String) As Boolean
    Dim retVal As Boolean
    retVal = False
    
    Dim ctrt As IContrat
    
    For Each ctrt In collContrats
        If ctrt.ReferencePointeuse = strReferencePointeuse Then retVal = True
    Next
    
    ITravailleur_existeContrat = retVal
End Function


'Retourne Faux si la r|fffd|f|fffd|rence de contrat existe d|fffd|j|fffd|
' ou           si le contrat n'est pas initialis|fffd|
Public Function ITravailleur_ajouteContrat(newContrat As IContrat) As Boolean
    Dim retVal As Boolean
    retVal = True
    
    If Not newContrat.estDefini Then
        retVal = False
    End If
    'Check r|fffd|f|fffd|rence contrat pas encore disponible
    If retVal And Me.ITravailleur_existeContrat(newContrat.ReferencePointeuse) Then
        retVal = False
    End If
    
    If retVal Then
        collContrats.Add newContrat, C_PREFIX_CONTRAT & newContrat.ReferencePointeuse
    End If
    
    ITravailleur_ajouteContrat = retVal
End Function

Attribute VB_Name = "TriFeuille"
Public Sub TriFeuilleEnCoursSurPoles(Optional blnDoNotShowMe As Boolean = True)
    Dim wks As Worksheet
    Dim dtTest As Date
    Dim nbTrav As Long, numLigne As Long
    Dim nbLigneFin As Long
    Dim rg As Range, rg2 As Range           'Objets pour traitement de copie
    Dim cpt1 As Long, cpt2 As Long
    
    Set wks = ActiveSheet
    
    If estNomDeMois(wks.Name, dtTest) Then
        UCM_Unprotect
        wks.EnableCalculation = False
        
        nbLigneFin = obtenirDerni|fffd|reLigneTravailleur(wks)
        nbTrav = (nbLigneFin - 1) / 3
        
        'A partir de la ligne trav suivante (nblignefin + 3), ajouter nbTrav * 3 lignes
        
        For cpt1 = 1 To nbTrav - 1
            For cpt2 = cpt1 + 1 To nbTrav
                If ligneEstPlusPetite(wks, cpt2 * 3 + 1, cpt1 * 3 + 1) Then
                    Debug.Print "Inversion lignes " & cpt2 * 3 + 1 & " <---> " & cpt1 * 3 + 1
                    inverserLignesTravailleurs wks, cpt2 * 3 + 1, cpt1 * 3 + 1, nbLigneFin + 3
                End If
            Next
        Next
        
        wks.EnableCalculation = True
        UCM_Protect
    End If


End Sub

'
Private Sub inverserLignesTravailleurs(wks As Worksheet, nbLigne1 As Long, nbLigne2 As Long, nbLigneTemp As Long, Optional tailleBloc As Long = 3)
    Dim rg1 As Range, rg2 As Range, rgTemp As Range
    Dim cpt As Long
    
    Set rg1 = wks.Rows(nbLigne1 & ":" & nbLigne1 + tailleBloc - 1)
    Set rg2 = wks.Rows(nbLigne2 & ":" & nbLigne2 + tailleBloc - 1)
    Set rgTemp = wks.Rows(nbLigneTemp & ":" & nbLigneTemp)
    
    'Insertion des lignes n|fffd|cessaires en fin de bloc
    For cpt = 1 To tailleBloc
        rgTemp.Rows.Insert xlShiftDown, xlFormatFromRightOrBelow
    Next
    Set rgTemp = wks.Rows(nbLigneTemp & ":" & nbLigneTemp + tailleBloc - 1)
    

    'Copie de rg1 vers temp
    rg1.Select
    rg1.Copy
    rgTemp.PasteSpecial xlPasteAll
    
    'Copie de rg2 vers rg1
    rg2.Select
    rg2.Copy
    rg1.PasteSpecial xlPasteAll
    
    'Copie de temp vers rg2
    rgTemp.Select
    rgTemp.Copy
    rg2.PasteSpecial xlPasteAll
    
    'Suppression des lignes cr|fffd||fffd|es au tout d|fffd|but
    rgTemp.Delete xlShiftUp
    
End Sub


Public Sub testInversion(Optional blnDoNotShowMe As Boolean = True)
    Dim wks As Worksheet
    
    Set wks = ActiveSheet
    
    inverserLignesTravailleurs wks, 10, 13, 49
End Sub


' Retourne Vrai si la ligne correspondant au num|fffd|ro de ligne 1 est "plus petite" que la ligne avec le num|fffd|ro de ligne 2
'  C'est-|fffd|-dire :
'    Si la donn|fffd|e dans le p|fffd|le est plus petite ou
'    Si, le p|fffd|le |fffd|tant |fffd|gal, le nom est plus petit
Private Function ligneEstPlusPetite(ByRef wks As Worksheet, nbLigne1 As Long, nbLigne2 As Long) As Boolean
    Dim blnRetVal As Boolean
    
    blnRetVal = False
    
    If wks.Cells(nbLigne1, C_PR_COL_POLE) < wks.Cells(nbLigne2, C_PR_COL_POLE) Then
        blnRetVal = True
    ElseIf (wks.Cells(nbLigne1, C_PR_COL_POLE) = wks.Cells(nbLigne2, C_PR_COL_POLE)) And _
            (wks.Cells(nbLigne1, C_PR_COL_NOM) < wks.Cells(nbLigne2, C_PR_COL_NOM)) Then
        blnRetVal = True
    End If
    
    ligneEstPlusPetite = blnRetVal
End Function
Attribute VB_Name = "UtilitairesFeuilles"

Public Function obtenirDerni|fffd|reLigneTravailleur(ByRef wks As Worksheet) As Long
    Dim lngLigne As Long
    Dim nbJump As Long
    If wks.Name = "GH - Travailleurs" Then
        lngLigne = C_GH_LIGNE_DEB
        nbJump = 2
    Else
        lngLigne = C_PR_LIGNE_DEB
        nbJump = 3
    End If
        
    While Len(wks.Cells(lngLigne, 2)) > 0
        lngLigne = lngLigne + nbJump
    Wend
        
    obtenirDerni|fffd|reLigneTravailleur = lngLigne - nbJump
End Function
Attribute VB_Name = "fonctionsWorkSheet"
'
''Public Sub testFctPerso()
''    Dim rg As Range
''
''    Set rg = ActiveSheet.Range("E4:X6")
''
''    Debug.Print calculHrsPrestees(rg)
''
''End Sub
'
'
'Public Function calculHrsSupp(ByRef rg As Range) As Double
'    Dim nbLignes As Long
'    Dim nbCols As Long
'    Dim lngCol As Long, lngLigne As Long
'
'    Dim dblHrsDepassement As Double
'    Dim dblHrsSuppSemaine As Double
'    Dim dblHrsPrestees As Double
'    Dim dblTmp As Double
'
'
'    retVal = 0#
'    dblHrsDepassement = 0#
'
'    nbLignes = rg.Rows.Count
'    nbCols = rg.Columns.Count
'
'    If nbLignes <> 3 Or nbCols Mod 4 <> 0 Then
'       'debug.Pri
'       calculHrsSupp = xlErrNA
'       Debug.Print "Couverture range incorrecte : 3 lignes et multiple de 4 colonnes" & rg.Address(, , , True)
'       Exit Function
'    End If
'
'    dblHrsPrestees = calculHrsPrestees(rg)
'    If dblHrsPrestees - (38# / 24) > 0.00001 Then
'        dblHrsSuppSemaine = dblHrsPrestees - (38# / 24)
''        Debug.Print "Sem : " & Format(dblHrsSuppSemaine, "[hh]:mm")
'    Else
'        dblHrsSuppSemaine = 0#
'    End If
'
'    For lngCol = 1 To nbCols Step 4
'        dblTmp = 0#
'        For lngLigne = 1 To 3
'            If Len(Trim(rg.Cells(lngLigne, lngCol))) > 0 Then
'                dblTmp = dblTmp + rg.Cells(lngLigne, lngCol + 3)
'            End If
'        Next
'
'        If dblTmp - (9# / 24) > 0.0001 Then
'            dblHrsDepassement = dblHrsDepassement + (Round(dblTmp * 24 - (9#), 3))
'        End If
'    Next
'    'Debug.Print "Sem : " & dblHrsDepassement * 24
'
'    calculHrsSupp = Application.WorksheetFunction.Max(dblHrsDepassement / 24, dblHrsSuppSemaine)
'End Function
'
'
'
'Public Function calculHrsPrestees(ByRef rg As Range, Optional rg2 As Range = Nothing) As Double
'    Dim nbLignes As Long
'    Dim nbCols As Long
'    Dim lngCol As Long, lngLigne As Long
'
'    Dim retVal As Double
'    Dim rgLigne As Range
'
'    retVal = 0#
'
'    nbLignes = rg.Rows.Count
'    nbCols = rg.Columns.Count
'
'    If nbLignes <> 3 Or nbCols Mod 4 <> 0 Then
'       'debug.Pri
'       calculHrsPrestees = xlErrNA
'       Debug.Print "Couverture range incorrecte : 3 lignes et multiple de 4 colonnes"
'       Exit Function
'    End If
'
'    For Each rgLigne In rg.Rows
'        With rgLigne
'            For lngCol = 1 To nbCols Step 4
'                If Len(Trim(.Cells(1, lngCol))) > 0 Then
'                    retVal = retVal + .Cells(1, lngCol + 3)
'                End If
'            Next
'        End With
'    Next
'
'    If rg2 Is Nothing Then
'        calculHrsPrestees = retVal
'    Else
'        calculHrsPrestees = retVal + calculHrsPrestees(rg2)
'    End If
'
'End Function
'
'
'
'Public Function calculCouvertureETP(ByRef rg As Range, lngHeureDebut As Long) As Double
'    Dim nbLignes As Long
'    Dim nbCols As Long
'    Dim LigneActive As Range
'    Dim retVal As Double
'    Dim strCode As String
'    Dim hrDeb As Double, hrFin As Double, dblTmp As Double
'
'    nbLignes = rg.Rows.Count
'    nbCols = rg.Columns.Count
'    retVal = 0#
'
'    If nbCols <> 3 Then
'        calculCouvertureETP = xlErrNA
'        Debug.Print "La fonction n|fffd|cessite trois colonnes dans le range !"
'        Exit Function
'    End If
'
'
'    For Each LigneActive In rg.Rows
'        With LigneActive
'            strCode = UCase(Trim(.Cells(1, 1).Value))
'
'            If strCode = "P" Or strCode = "PR" Then
'                hrDeb = .Cells(1, 2).Value * 24
'                hrFin = .Cells(1, 3).Value * 24
'                If hrFin > lngHeureDebut Then
'                    dblTmp = Application.WorksheetFunction.Min(lngHeureDebut + 1, hrFin) - Application.WorksheetFunction.Max(lngHeureDebut, hrDeb)
'                    'Debug.Print "hr chk : " & lngHeureDebut & " - hrDeb/Fin : " & hrDeb & "/" & hrFin & " ==> " & dblTmp
'                    If dblTmp > EPSILON Then
'                        retVal = retVal + dblTmp
'                    End If
'                End If
'            End If
'        End With
'    Next
'    calculCouvertureETP = retVal
'
'End Function
'
'
'
Attribute VB_Name = "usFFinContrat"
Attribute VB_Base = "0{5CFCF718-1205-4330-91FE-E4D98B7A6882}{BE1F0A31-6782-4EFA-8682-0E30B4B6E260}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private m_wksGHTrav As Worksheet
Private m_GHTravs As GrillesHoraires
Private m_blnLoad As Boolean



Private Sub cmbListe_Change()
    If Me.cmbListe.ListIndex >= 0 Then
        Me.dtSelection.Enabled = True
        Me.cmdCloture.Enabled = True
    End If
End Sub



Private Function fmtDate(dtDate As Date) As String
    fmtDate = Format(safeDate(dtDate), "dd/mm/yyyy")
End Function

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdCloture_Click()
    Dim wks As Worksheet
    Dim dtTest As Date
    'Tester si OK pour cloture
        'on est dans la commande, activ|fffd|e uniquement sur la s|fffd|lection d'un travailleur
        'Valider la date
    If validationDateFinContrat Then
        'Parcours des feuilles et examen
        For Each wks In m_wksGHTrav.Parent.Worksheets
            If estNomDeMois(wks.Name, dtTest) Then
                traiterFeuille wks, safeDate(dtTest), safeDate(dtSelection)
            End If
        Next
    'En fin de traitement : mise |fffd| jour de la date de fin de contrat sur la feuille GH - Travailleurs
        enregistrerFinContratDansGH
        
    End If 'Fin trt date de fin de contrat valid|fffd|e
    Me.Hide
End Sub

Private Sub enregistrerFinContratDansGH()
    Dim gh As GrilleHoraireTravailleur
    Dim lngLigne As Long
    Dim blnContinue As Boolean
    
    m_wksGHTrav.Activate
    Set gh = obtenirGHTravailleur
    lngLigne = C_GH_LIGNE_DEB
    With m_wksGHTrav
        blnContinue = True
        While blnContinue
            If Len(.Cells(lngLigne, C_GH_COL_NOM)) = 0 Then
                blnContinue = False
            ElseIf .Cells(lngLigne, C_GH_COL_NUM) <> gh.num Then
                lngLigne = lngLigne + 2
            Else
                UCM_Unprotect
                .Cells(lngLigne, C_GH_COL_FIN_CTR) = safeDate(Me.dtSelection)
                blnContinue = False
                UCM_Protect
            End If
        Wend
    End With
    
End Sub


Private Sub traiterFeuille(ByRef wks As Worksheet, dtPremJourMois As Date, dtCloture As Date)
    If Year(dtCloture) < Year(dtPremJourMois) Then
        SupprimerTravailleurDansFeuille wks
    ElseIf Year(dtCloture) = Year(dtPremJourMois) Then
        If Month(dtCloture) < Month(dtPremJourMois) Then
            SupprimerTravailleurDansFeuille wks
        ElseIf Month(dtCloture) = Month(dtPremJourMois) Then
            CloturerTravailleurDansFeuille wks
        End If
    End If
End Sub

Private Sub CloturerTravailleurDansFeuille(ByRef wks As Worksheet)
    Dim lngLigne As Long
    Dim rg As Range, rg2 As Range
    Dim dtClot As Date
    Dim strLibComment As String
    Dim lngCol As Long
    dtClot = safeDate(Me.dtSelection)
    
    lngLigne = obtenirTravLigneDansFeuille(wks)
    'on pourrait ne pas trouver le travailleur dans la feuille, bien que cela soit peu plausible
    If lngLigne > C_PR_LIGNE_DEB Then
        'D|fffd|finir la couleur + commentaire
        wks.Activate
        UCM_Unprotect
        
        Set rg = wks.Range(wks.Cells(lngLigne, C_PR_COL_NUM), wks.Cells(lngLigne, C_PR_COL_POLE))
        Set rg2 = rg.Cells(1, 1)
        If Not rg2.Comment Is Nothing Then
            strLibComment = "Contrat sur le mois en cours (du " & Left(Right(rg2.Comment.Text, 5), 2) & _
                                " au " & Day(dtClot) & ")"
            rg2.Comment.Delete
            rg2.AddComment strLibComment
            rg.Interior.Color = RGB(250, 250, 150)
        Else
            strLibComment = "Fin de contrat au " & Format(dtClot, "dd/mm")
            
            rg2.AddComment strLibComment
            rg.Interior.Color = RGB(250, 150, 150)
        End If
        'Supprimer les prestations |fffd| partir de la date de cloture, non comprise
        lngCol = C_PR_COL_DET_PRES_START
        While wks.Cells(C_PR_LIGNE_TITRE, lngCol) <> dtClot
            lngCol = lngCol + 1
        Wend
        lngCol = lngCol + C_PR_NB_COLS_PAR_JOUR
        While InStr(wks.Cells(C_PR_LIGNE_TITRE, lngCol), "APRES") < 1
            If InStr(wks.Cells(C_PR_LIGNE_TITRE, lngCol), "Synth|fffd|se") > 0 Then
                lngCol = lngCol + 1
            Else
                'on est sur une date
                Set rg = wks.Range(wks.Cells(lngLigne, lngCol), wks.Cells(lngLigne + 2, lngCol + 2))
                rg.Activate
                wks.Outline.ShowLevels , 2
                rg.ClearContents
                lngCol = lngCol + C_PR_NB_COLS_PAR_JOUR
            End If
        Wend
        UCM_Protect
    End If
End Sub

Private Sub SupprimerTravailleurDansFeuille(ByRef wks As Worksheet)
    Dim lngLigne As Long
    
    lngLigne = obtenirTravLigneDansFeuille(wks)
    
    'on pourrait ne pas trouver le travailleur dans la feuille
    If lngLigne > C_PR_LIGNE_DEB Then
        wks.Activate
        UCM_Unprotect
        
        wks.Rows(lngLigne & ":" & lngLigne + 2).EntireRow.Delete
        UCM_Protect
    End If
End Sub


Private Function obtenirTravLigneDansFeuille(ByRef wks As Worksheet) As Long
    Dim gh As GrilleHoraireTravailleur
    Dim lngLigne As Long
    
    Set gh = obtenirGHTravailleur
    
    lngLigne = C_PR_LIGNE_DEB
    While wks.Cells(lngLigne, C_PR_COL_NUM) <> gh.num
        lngLigne = lngLigne + 3
    Wend
    If wks.Cells(lngLigne, C_PR_COL_NUM) <> gh.num Then
        lngLigne = -1
    End If
    
    obtenirTravLigneDansFeuille = lngLigne
End Function

Private Function obtenirGHTravailleur() As GrilleHoraireTravailleur
    Dim gh As GrilleHoraireTravailleur
    Set gh = m_GHTravs.GHTravailleur(CLng(Me.cmbListe.List(Me.cmbListe.ListIndex, 0)))
    Set obtenirGHTravailleur = gh
End Function
    

Private Sub dtSelection_Change()
    validationDateFinContrat
End Sub

Private Function validationDateFinContrat() As Boolean
    Dim retVal As Boolean
    retVal = True
    If safeDate(Me.dtSelection.Value) < safeDate(Me.cmbListe.List(Me.cmbListe.ListIndex, 1)) Then
        MsgBox "La date de cl|fffd|ture (" & fmtDate(Me.dtSelection.Value) & ") ne peut |fffd|tre ant|fffd|rieure |fffd| la date de d|fffd|but de contrat (" & _
                    fmtDate(Me.cmbListe.List(Me.cmbListe.ListIndex, 1)) & ").", vbCritical + vbOKOnly, "Date de fin incorrecte !"
        Me.dtSelection.SetFocus
        retVal = False
    End If
    validationDateFinContrat = retVal
End Function



Private Sub UserForm_Activate()
    If Not m_blnLoad Then
        Unload Me
    Else
        Me.dtSelection.Enabled = False
        Me.cmdCloture.Enabled = False
    End If
End Sub

Private Sub UserForm_Initialize()
    Dim cpt As Long
    Dim GHT As GrilleHoraireTravailleur
    Dim strLibelle As String
    
    Set m_GHTravs = New GrillesHoraires
     
    If existeGrillesHorairesFichierCourant(m_wksGHTrav) Then
        m_GHTravs.ChargerGrillesAPartirDeFeuille m_wksGHTrav
        For cpt = 1 To m_GHTravs.Count
            Set GHT = m_GHTravs.GHTravailleur(cpt)
            If Year(GHT.FinContrat) = 9999 Then
                strLibelle = Format(GHT.num, "###### 000000") & " - " & GHT.nom & " ( D|fffd|but contrat : " & Format(GHT.DebutContrat, "dd/mm/yyyy") & ")"
                Me.cmbListe.AddItem cpt
                Me.cmbListe.List(Me.cmbListe.ListCount - 1, 0) = cpt
                Me.cmbListe.List(Me.cmbListe.ListCount - 1, 1) = GHT.DebutContrat
                Me.cmbListe.List(Me.cmbListe.ListCount - 1, 2) = strLibelle
            End If
        Next
        Me.dtSelection.Value = DateSerial(Year(Now), Month(Now), Day(Now))
        m_blnLoad = True
    Else
        MsgBox "Le fichier actif ne contient pas les grilles horaires des travailleurs !" & vbCrLf & _
                "Ouvrez et activez le fichier de gestion des prestations.", vbCritical + vbOKOnly, "Impossible de traiter la demande"
        m_blnLoad = False
    End If
End Sub

Attribute VB_Name = "usFNouvTrav"
Attribute VB_Base = "0{B42A2248-BDF6-466E-9ADF-2407B2FDE55C}{1EA72BE5-1FCF-4C33-AC74-EDAE2E7DEB01}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private m_blnDataCorrectes As Boolean
Private m_wksGHTrav As Worksheet
Private m_GHTravs As GrillesHoraires
Private m_blnLoad As Boolean


Public Property Get DonneesValidees() As Boolean
    DonneesValidees = m_blnDataCorrectes
End Property

Private Sub chkFinContrat_Change()
    Me.dtFinContrat.Enabled = Me.chkFinContrat.Value
End Sub

Private Sub cmdCancel_Click()
    Hide
End Sub

Private Sub cmdCloture_Click()
    If controleDonnees Then
        m_blnDataCorrectes = True
        Hide
    End If
End Sub

Private Function controleDonnees() As Boolean
    Dim retVal As Boolean
    Dim ctrl As Control
    Dim gh As GrilleHoraireTravailleur
    Dim strMsg As String
    Dim cpt As Long
    
    
    strMsg = ""
    
    If Not IsNumeric(Me.numUCM) Then
        strMsg = "Le num|fffd|ro de travailleur UCM doit |fffd|tre un nombre entier, sans 0 initiaux !" & vbCrLf
        Set ctrl = Me.numUCM
    ElseIf CStr(CLng(Me.numUCM)) <> Me.numUCM Then
        strMsg = "Le num|fffd|ro de travailleur UCM doit |fffd|tre un nombre entier, sans 0 initiaux !" & vbCrLf
        Set ctrl = Me.numUCM
    End If
    
    If Len(Me.cmbPole.Value) = 0 Then
        strMsg = strMsg & "Veuillez s|fffd|lectionner un p|fffd|le pour ce travailleur." & vbCrLf
        If ctrl Is Nothing Then Set ctrl = Me.cmbPole
    End If
    
    If Len(Me.nomPrenom.Value) = 0 Then
        strMsg = strMsg & "Veuillez introduire le nom (et pr|fffd|nom) du travailleur." & vbCrLf
        If ctrl Is Nothing Then Set ctrl = Me.nomPrenom
    End If
    If Me.chkFinContrat Then
        If safeDate(Me.dtFinContrat) < safeDate(Me.dtDebutContrat) Then
            strMsg = strMsg & "La date de fin de contrat doit |fffd|tre plus grande que la date de d|fffd|but de contrat." & vbCrLf
            If ctrl Is Nothing Then Set ctrl = Me.dtFinContrat
        End If
    End If
        'Validation p|fffd|riodes dans le cas o|fffd| on n'a pas de date de fin
    If IsNumeric(Me.numUCM) Then
        For cpt = 1 To m_GHTravs.Count
            Set gh = m_GHTravs.GHTravailleur(cpt)
            If gh.num = CLng(Me.numUCM) Then
                'V|fffd|rifier qu'il n'y a pas de chevauchement
                If safeDate(Me.dtDebutContrat) < gh.FinContrat Then
                    If Year(gh.FinContrat) > 3000 Then
                        strMsg = strMsg & "Ce travailleur a d|fffd|j|fffd| un contrat |fffd| dur|fffd|e ind|fffd|termin|fffd|e." & vbCrLf
                    Else
                        strMsg = strMsg & "Ce travailleur a d|fffd|j|fffd| un contrat qui se termine le " & Format(gh.FinContrat, "dd/mm/yyyy") & "." & vbCrLf
                    End If
                    If ctrl Is Nothing Then Set ctrl = Me.dtDebutContrat
                End If
            End If
        Next
    End If
    
    If Len(strMsg) > 0 Then
        MsgBox strMsg, vbOKOnly + vbCritical, "Donn|fffd|es incorrectes !"
        ctrl.SetFocus
        controleDonnees = False
    Else
        controleDonnees = True
    End If
    
End Function





Private Sub numUCM_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Dim gh As GrilleHoraireTravailleur
    Dim cpt As Long
    
    If Len(Me.numUCM) > 0 Then
        For cpt = 1 To m_GHTravs.Count
            Set gh = m_GHTravs.GHTravailleur(cpt)
            If gh.num = CLng(Me.numUCM) Then
                Me.nomPrenom = gh.nom
            End If
        Next
    End If
End Sub

Private Sub UserForm_Activate()
    If Not m_blnLoad Then
        Unload Me
    End If
End Sub

Private Sub UserForm_Initialize()
    Me.cmbPole.AddItem "AAP/B|fffd|n|fffd|voles"
    Me.cmbPole.AddItem "Administration"
    Me.cmbPole.AddItem "Communication"
    Me.cmbPole.AddItem "Ev|fffd|nements"

    Me.dtDebutContrat = DateSerial(Year(Now), Month(Now), 1)
    Me.dtFinContrat = DateSerial(Year(Now), Month(Now) + 1, 0)
    Me.chkFinContrat.Value = False
    Me.dtFinContrat.Enabled = False
    
    m_blnDataCorrectes = False
    
    Set m_GHTravs = New GrillesHoraires
     
    If existeGrillesHorairesFichierCourant(m_wksGHTrav) Then
        m_GHTravs.ChargerGrillesAPartirDeFeuille m_wksGHTrav
        m_blnLoad = True
    Else
        MsgBox "Le fichier actif ne contient pas les grilles horaires des travailleurs !" & vbCrLf & _
                "Ouvrez et activez le fichier de gestion des prestations.", vbCritical + vbOKOnly, "Impossible de traiter la demande"
        m_blnLoad = False
    End If
End Sub
Attribute VB_Name = "usrFFiltragePole"
Attribute VB_Base = "0{8E235C07-BA99-498A-9354-01FA28A388AA}{3B7A6A4B-1FA8-447D-A68A-0BD8EBD17880}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private m_wksTarget As Worksheet


Private Sub cmdCancel_Click()
    Me.Hide
End Sub

Private Sub CommandButton1_Click()
    
    Dim lngLigne As Long
    Dim dtTest As Date
    
    
    If m_wksTarget Is Nothing Then
        Set m_wksTarget = ActiveSheet
    End If
    If Not (estNomDeMois(m_wksTarget.Name, dtTest)) Then
        MsgBox "Veuillez vous positionner sur une feuille de prestations valide.", vbCritical + vbOKOnly, "Erreur !"
        Exit Sub
    End If
    
    m_wksTarget.Activate
    UCM_Unprotect
    m_wksTarget.EnableCalculation = False
    Application.ScreenUpdating = False
    
    
    lngLigne = C_PR_LIGNE_DEB
    If InStr(Me.cmbSel.Value, "Tous") > 0 Then
        While Len(Trim(m_wksTarget.Cells(lngLigne, C_PR_COL_NOM))) > 0
            lngLigne = lngLigne + 3
        Wend
        Rows(C_PR_LIGNE_DEB & ":" & lngLigne - 1).Hidden = False
    Else
        While Len(Trim(m_wksTarget.Cells(lngLigne, C_PR_COL_NOM))) > 0
            DoEvents
                
            m_wksTarget.Rows(lngLigne & ":" & lngLigne + 2).Hidden = (UCase(m_wksTarget.Cells(lngLigne, C_PR_COL_POLE)) <> UCase(Me.cmbSel.Value))
            
            lngLigne = lngLigne + 3
        Wend
    End If
    
    m_wksTarget.EnableCalculation = True
    UCM_Protect
    Application.ScreenUpdating = True
    Me.Hide
End Sub

Private Sub UserForm_Initialize()
    Me.cmbSel.AddItem "-- Tous --"
    Me.cmbSel.AddItem "AAP/B|fffd|n|fffd|voles"
    Me.cmbSel.AddItem "Administration"
    Me.cmbSel.AddItem "Communication"
    Me.cmbSel.AddItem "Ev|fffd|nements"
    
    Me.cmbSel.Value = "-- Tous --"
End Sub

Public Sub definirFeuilleCible(ByRef wks As Worksheet)
    Set m_wksTarget = wks
End Sub
Attribute VB_Name = "usrFPassword"
Attribute VB_Base = "0{3CE16888-73E1-45B2-8D39-9E55ACF4A5F0}{AF1AF832-3B6A-47AE-898D-0B3448E19C5D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub CommandButton1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Me.TextBox1.PasswordChar = ""
End Sub

Private Sub CommandButton1_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Me.TextBox1.PasswordChar = "*"
End Sub

Private Sub CommandButton2_Click()
    Me.Hide
End Sub

Attribute VB_Name = "usrFormResultatTraitement"
Attribute VB_Base = "0{73EFE689-260A-4C7E-95E2-8A4F3BE3B747}{62B571C4-34F8-43F4-9F98-BF5582C47B82}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private m_strTitre As String

Private Const C_DEF_TITRE As String = "R|fffd|capitulatif :: Traitement des prestations"

Private Sub Btn_Print_Click()
    Dim Tableau() As Variant
    Dim i As Long
    Dim j As Byte

    Application.ScreenUpdating = False
    Workbooks.Add 'cr|fffd|ation d'un nouveau classeur temporaire

    With listBoxMessages
        Tableau() = .List
        j = .ColumnCount
        i = .ListCount
        Range("A1:" & Cells(i, j).Address) = Tableau()
    End With
    'option pour adapter la largeur des colonnes |fffd| la taille des donn|fffd|es
    ActiveSheet.Range("A1:" & Cells(i, j).Address).EntireColumn.AutoFit
    ActiveSheet.Columns("A:A").ColumnWidth = 88
    ActiveSheet.Columns("A:A").Select
    With Selection.Font
        .Name = "Courier New"
        .Size = 10
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ThemeColor = xlThemeColorLight1
        .TintAndShade = 0
        .ThemeFont = xlThemeFontNone
    End With
    With Selection
        .HorizontalAlignment = xlGeneral
        .VerticalAlignment = xlBottom
        .WrapText = True
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .MergeCells = False
    End With
    With ActiveSheet.PageSetup
        .LeftHeader = ""
        .CenterHeader = m_strTitre
        .RightHeader = ""
        .LeftFooter = "&D - &T"
        .CenterFooter = ""
        .RightFooter = "&P/&N"
        .LeftMargin = Application.InchesToPoints(0.7)
        .RightMargin = Application.InchesToPoints(0.7)
        .TopMargin = Application.InchesToPoints(0.75)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)
        .Zoom = 100
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = ""
        .EvenPage.CenterHeader.Text = ""
        .EvenPage.RightHeader.Text = ""
        .EvenPage.LeftFooter.Text = ""
        .EvenPage.CenterFooter.Text = ""
        .EvenPage.RightFooter.Text = ""
        .FirstPage.LeftHeader.Text = ""
        .FirstPage.CenterHeader.Text = ""
        .FirstPage.RightHeader.Text = ""
        .FirstPage.LeftFooter.Text = ""
        .FirstPage.CenterFooter.Text = ""
        .FirstPage.RightFooter.Text = ""
    End With
    ActiveWorkbook.PrintOut 'impression
    ActiveWorkbook.Close False 'suppression du classeur temporaire
    Application.ScreenUpdating = True
End Sub


Private Sub Btn_quitter_Click()
    Me.Hide
End Sub


Sub UserForm_Initialize()
    Me.listBoxMessages.Clear
    Me.lblNbErr.Tag = 0
    Me.lblNbAlertes.Tag = 0
    Me.lblNbErr.Caption = "Nombre d'erreurs : " & Me.lblNbErr.Tag
    Me.lblNbAlertes.Caption = "Nombre d'alertes : " & Me.lblNbAlertes.Tag
    m_strTitre = C_DEF_TITRE
End Sub


Public Sub DefinirTitre(strTitre As String)
    If Len(Trim(strTitre)) = 0 Then
        m_strTitre = C_DEF_TITRE
    Else
        m_strTitre = strTitre
    End If
End Sub

Public Sub AjouterErreur(strTexte As String)
    Dim nbErr As Long
    nbErr = CLng(Me.lblNbErr.Tag)
    
    Me.lblNbErr.Tag = nbErr + 1
    Me.listBoxMessages.AddItem "ERREUR : " & strTexte
    
    Me.lblNbErr.Caption = "Nombre d'erreurs : " & Me.lblNbErr.Tag
End Sub

Public Sub AjouterAlerte(strTexte As String)
    Dim nbErr As Long
    nbErr = CLng(Me.lblNbAlertes.Tag)
    
    Me.lblNbAlertes.Tag = nbErr + 1
    Me.listBoxMessages.AddItem "ALERTE : " & strTexte
    
    Me.lblNbAlertes.Caption = "Nombre d'alertes : " & Me.lblNbAlertes.Tag
End Sub

Public Sub AjouterInfo(strTexte As String, Optional strSoulignement As String = "", Optional blnLigneApres As Boolean = False)
    Me.listBoxMessages.AddItem strTexte
    If Len(Trim(strSoulignement)) = 1 Then
        Me.listBoxMessages.AddItem String(Len(strTexte) + 1, Trim(strSoulignement))
    ElseIf Len(Trim(strSoulignement)) > 1 Then
        Me.listBoxMessages.AddItem strSoulignement
    End If
    If blnLigneApres Then
        Me.listBoxMessages.AddItem " "
    End If
End Sub


' InQuest injected base64 decoded content
' )exz+j*
' )exKFzw
' z{.zY^
' z+j*
' ,J('jW
' y:-jQ
' +-j{^
' &z{^
' )^J)
' .('z
' &F(!
' j)ez

INQUEST-PP=macro
