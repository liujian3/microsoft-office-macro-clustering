Attribute VB_Name = "FormMyMsgBox"
Attribute VB_Base = "0{5B735278-58D9-4963-A0F7-41CC38492E09}{C8F5F683-6DAC-4CAD-86AF-0542754FBE07}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public EmailSubj As String
Public HomePageUrl As String
Public lBut As Long
Public Xpos As Long
Public Ypos As Long

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub OK_Bt_Click()
    BotAcionado = 1
    Hide
End Sub
Private Sub Cancel_Bt_Click()
    BotAcionado = 2
    Hide
End Sub

Private Sub Ignore_Bt_Click()
    BotAcionado = 3
    Hide
End Sub

Private Sub UserForm_Activate()
    Dim CountLines As Long
    Dim Lins
    Dim l As Long

    With Alert_Tb
        .Width = 284
        'Lins = Split(.Text, vbCrLf)
        Lins = MySplit(.Text, vbCrLf)
        For l = 0 To UBound(Lins)
            CountLines = CountLines + 1 + Int(Len(Lins(l)) / 75)
        Next
        .Height = (1 + CountLines) * 12
        If .Height > 16 * 12 Then
            .Height = 15 * 12
            .SpecialEffect = fmSpecialEffectSunken
            .SetFocus
            .SelStart = 0
        End If
    End With

    Icon_Lb.Caption = IIf(lBut <> 1, "?", "i")
    Cancel_Bt.Visible = lBut <> 1
    Ignore_Bt.Visible = lBut = 3

    OK_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "Sim", "Yes"), "OK")
    Cancel_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "N|fffd|o", "No"), IIf(IsPortg, "Cancelar", "Cancel"))
    Ignore_Bt.Caption = IIf(IsPortg, "Ignorar", "Ignore")

    OK_Bt.Top = Alert_Tb.Top + Alert_Tb.Height + 5
    Cancel_Bt.Top = OK_Bt.Top
    Ignore_Bt.Top = OK_Bt.Top
    HomePage_Lb.Top = OK_Bt.Top + 7.5
    Email_Lb.Top = HomePage_Lb.Top

    Email_Lb.Left = Width - Email_Lb.Width - (Width - InsideWidth) - 4    'Email_Lb.Left = Width - Email_Lb.Width - 8    'Em COM add-in |fffd| preciso transformar width e height em Twips
    Height = HomePage_Lb.Top + OK_Bt.Height + (Height - InsideHeight) - 2    'Height = HomePage_Lb.Top + OK_Bt.Height + (Height - InsideHeight - (Width - InsideWidth) / 2) + 2    'Entre parentese: altura da barra de t|fffd|tulo(caption)

    If lBut = 1 Then OK_Bt.Left = 135
    If lBut = 2 Then OK_Bt.Left = 90: Cancel_Bt.Left = 180
    If Xpos <> 0 Then Left = Xpos
    If Ypos <> 0 Then Top = Ypos
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then BotAcionado = IIf(Cancel_Bt.Visible, 2, 1)
End Sub
Attribute VB_Name = "Mod1ConstByUtility"
Option Explicit

'==== Utility Const List. To other Office app, change Excel and Xl is sufficent. To other utility, change Calendar
Public Const sAddInNameByApp As String = "ExcelCalendar"    'AppUtilityNameInt
Public Const sAddInCaptByApp As String = "Popup Calendar for Excel"    'UtilityNameExt for App in En
Public Const sAddInCaptByAppPt As String = "Calend|fffd|rio Popup para Excel"    'UtilityNameExt para App em Pt
Public Const sDLLProgId As String = "AddInXlCalendar.ExcelDesigner"    'AddInXlUtilityNameInt.AppDesigner
Public Const sAppTarget As String = "Excel"    'Useful when installing to other Office app and not Excel

Public Const sCOMAddInFileName As String = "ExcelCalendar.dll"
Public Const sAddInFileName As String = "ExcelCalendar.xla"    'XLA, DOT, PPA, MDB...
Public Const sEXEAddInFileName As String = "ExcelCalendarLoadExe.xla"    'XLA, DOT, PPA, MDB...
Public Const AttachFileNames As String = "ExcelCalendarHotKey.xla;ExcelCalendarClick.wav;ExcelCalendar.ini;ExcelCalendar.xlam"            'Attached in installer and created while running
Public Const AttachFileNamesEXEAddIn As String = "ExcelCalendar.exe"    'Attached in installer and created while running in exe
Public Const AttachFileNames64bit As String = "ExcelCalendar.exe.manifest;FM20.DLL;FM20ENU.DLL"    'Attached in installer and created while running in 64bit
Public Const AttachFileNamesComm As String = "FM20.DLL;FM20ENU.DLL"    'Attached files that are commom with another utilities or version

Public Const sOfficeVerReqMin As String = "9.0"     'Office Version required to Install - Min
Public Const sOfficeVerReqMax As String = "16.0"     'Office Version required to Install - Max
Public Const sAppVerReqToRun As String = ""    'Excel 12 (2007) or Excel 14 (2010)"    'Application Versions required to run utility. Let empty if Office riquired to install is sufficiente

Public Const sSuccessMsg As String = "Do not forget! The ''Calendar'' command will be available on Sheet Mouse Rigth-click Menu when you restart the Excel."
Public Const sSuccessMsgPt As String = "N|fffd|o se esque|fffd|a! O comando ''Calend|fffd|rio'' estar|fffd| dispon|fffd|vel no Menu de Atalho de Clique Direito na planilha (Menu de Contexto) ao reiniciar o Excel."

Public Const lIsPortg As Long = 0    '0-Detect  1-Always portugues 2-Never Portuguese(always English) Useful to atend Extenso and SpellNumber for specic lang

Attribute VB_Name = "Mod1Global"
Option Explicit

#If VBA7 Then
    Private Declare PtrSafe Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
    Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As LongPtr, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
#Else
    Private Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
    Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
#End If

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128                           '  Maintenance string for PSS usage
End Type
'  dwPlatformId defines:
Private Const VER_PLATFORM_WIN32s = 0
Private Const VER_PLATFORM_WIN32_WINDOWS = 1
Private Const VER_PLATFORM_WIN32_NT = 2
#If VBA7 Then
    Private Declare PtrSafe Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long
    Public Declare PtrSafe Function GetKeyState32 Lib "user32" Alias "GetKeyState" (ByVal nKey As Long) As Integer
#Else
    Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long
    Public Declare Function GetKeyState32 Lib "user32" Alias "GetKeyState" (ByVal vKey As Integer) As Integer
#End If

Public AddInTitle As String    'Orlando's AppCalendar
Public appHostApp     'As PowerPoint.Application  'As Word.Application  'As Application falha no word
Public dHostAppVer As Double
Public bIsCOMAddin As Boolean: Public bIsEXEAddIn As Boolean   'Auto detect by Project File Name ext and option user
Public sStartupPath As String
Public Fn As Variant
Public PathInst As String

Sub PleaseWait(bShow As Boolean)
    If bShow Then
        If Val(Application.Version) > 8 Then
            UserFormWait.Caption = IIf(IsPortg, "POR FAVOR", "PLEASE") & String(8, 32)
            UserFormWait.Label1.Caption = IIf(IsPortg, "AGUARDE...", "WAIT...")
            #If VBA6 Then
                UserFormWait.Show 0
            #End If
        Else
            Application.StatusBar = IIf(IsPortg, "AGUARDE...", "WAIT...")
        End If
    Else
        If Val(Application.Version) > 8 Then
            UserFormWait.Hide
        Else
            Application.StatusBar = False
        End If
    End If
End Sub

Sub PleaseWaitExeIndep(bShow As Boolean)
'Para evitar o vacuo ao reiniciar convertido para EXE, roda o PleaseWait.exe externo e independente
    Dim lRet As Long
    Dim sTempFolder As String    'Em usu|fffd|rio limitado, o reiniciar com eleva|fffd||fffd|o de direito leva o temp para o do administrador, ent|fffd|o o temp aqui deve ser o de tr|fffd|s n|fffd|vel abaixo no path deste e n|fffd|o TempForder()
    sTempFolder = ThisWorkbook.Path
    sTempFolder = Left(sTempFolder, InStrRev(sTempFolder, "\") - 1)
    sTempFolder = Left(sTempFolder, InStrRev(sTempFolder, "\") - 1)
    sTempFolder = Left(sTempFolder, InStrRev(sTempFolder, "\") - 1)

    If bShow Then
        If Dir(ThisWorkbook.Path & "\PleaseWait.exe") = "" Then Exit Sub
        On Error Resume Next
        FileCopy ThisWorkbook.Path & "\PleaseWait.exe", sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe"
        If Err.Number <> 0 Or Dir(sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe") = "" Then Exit Sub
        lRet = Shell(sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe", vbNormalFocus)
        If lRet = 0 Then Kill sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe"
    Else
        PleaseWait True
        On Error Resume Next    'S|fffd| vai ser poss|fffd|vel deletar depois que ele se fechar ao detectar o PleaseWait acima
        Do While Dir(sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe") <> "" And lRet < 10
            MyWait 0.5
            lRet = lRet + 1
            Kill sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe"
        Loop
        PleaseWait False
    End If
End Sub

Function IsInstallAsCOMAddin() As Boolean
    Dim sGuid
    sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\Clsid", "", False)
    IsInstallAsCOMAddin = sGuid <> "Error"
End Function

Function IsInstallAsAddin() As Boolean
    If sAddInFileName = "" And sEXEAddInFileName = "" Then Exit Function
    If WbIsOpen(sAddInFileName) Or WbIsOpen(sEXEAddInFileName) Then IsInstallAsAddin = True: Exit Function

    Dim ad As AddIn
    For Each ad In AddIns


        If LCase(ad.Name) = LCase(sAddInFileName) Or LCase(ad.Name) = LCase(sEXEAddInFileName) Then
            If Dir(ad.FullName) <> "" Then IsInstallAsAddin = True    'Only is installed, if registered and the exists
            Exit For
        End If
    Next

End Function

Sub VerifRestDisabledItems()
'Verify and restore if disabledItem in each Office Version. Since Office 10.0 user can disable thru
'an alert project that crash the app when starting. Unfortunately almost none knows as enable again
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim sNameRet As String
    Dim sDataRet As String
    Dim retRegEnumKey
    Dim i As Long
    Dim v As Long
    Dim sApplication As String: sApplication = sAppTarget    '"Excel"
    Dim sAppVersion As String
    'Const sAddInNameByApp As String = "ExcelStopwatch" 'Usado para testar com instalador em Install_ExcelStopwatchGPF.zip montado para instalar uma DLL que gera GPF

    For v = 10 To Val(Left(sOfficeVerReqMax, 2))  'Office Versions
        sAppVersion = v & ".0"
        retRegEnumKey = fRegEnumKey(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Resiliency\DisabledItems", True, True)
        If TypeName(retRegEnumKey) = "String()" Then
            For i = 0 To UBound(retRegEnumKey, 2)
                sNameRet = Replace(retRegEnumKey(1, i), Chr(0) & Chr(0), " ")
                sNameRet = LCase(Trim(Replace(sNameRet, Chr(0), "")))
                If InStr(1, sNameRet, LCase(sAddInNameByApp)) > 0 Then
                    If RegOpenKeyEx(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Resiliency\DisabledItems", 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then      'Open key
                        sDataRet = retRegEnumKey(0, i)
                        RegDeleteValue OpenKeyHdl, sDataRet    'Delete the value
                        RegCloseKey OpenKeyHdl    'Close the handle
                    End If
                End If
            Next
        End If
    Next
End Sub

Function WbIsOpen(WbName As String) As Boolean
    Dim Wb As Workbook
    On Error Resume Next
    Set Wb = Workbooks(WbName)
    WbIsOpen = Not Wb Is Nothing
    Err.Clear
End Function

Sub Sair()
    If XLtoEXE_IsThisWbExe() Then ThisWorkbook.Close False Else Application.Quit
End Sub














Public Function IsWinNT(sVersion As String) As Boolean
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    Select Case sVersion
    Case "Any": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT)
    Case "XP": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 5)
    Case "Vista": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 0)
    Case "Win7": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 1)   'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1
    Case "Win8": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 2)   'Win7 e Win8 se distinguem apenas apenas em dwMinorVersion, 1 e 2
    Case Else: Stop
    End Select
End Function

Public Function IsOffice64_bit() As Boolean
    #If VBA7 Then
        '  Code is running in the new VBA7 editor
        #If Win64 Then
            IsOffice64_bit = True    'Code is running in 64-bit version of Microsoft Office
        #Else
            '  Code is running in 32-bit version of Microsoft Office
        #End If
    #Else
        ' Code is running in VBA version 6 or earlier
    #End If
End Function

Public Function IsThereCTR() As Boolean
'When an Office application is running with Click-To-Run (CTR) technology of Office 365, fm20.dll run virtually then EXE Add-in
'also need to this like with Office 64-bit. Como CTR pode rodar onde tem vers|fffd|o instalada normal (MSI-b) e n|fffd|o h|fffd| como distinguir
'como e qual vai ser o tipo escolhido pelo usu|fffd|rio, ent|fffd|o se houve CTR configurada instala para rodar sempre virtualizado.
    Dim sRet As String
    sRet = GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\14.0\" & "Common\InstallRoot\Virtual", "Virtual" & sAppTarget, False)                           'Office 2010
    If sRet = "Error" Then sRet = GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\15.0\" & "Common\InstallRoot\Virtual", "Virtual" & sAppTarget, False)    'Office 2013
    If sRet = "Error" Then sRet = GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\16.0\" & "Common\InstallRoot\Virtual", "Virtual" & sAppTarget, False)    'Office 2016
    IsThereCTR = Not (sRet = "Error" Or Len(sRet) < 3)
End Function

Function HasAdminPrivilege() As Boolean
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim lRet As Long
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion", 0, KEY_ALL_ACCESS, OpenKeyHdl)     'Only test to open a key, do not change
    If OpenKeyHdl <> 0 Then RegCloseKey OpenKeyHdl     'Close the key
    HasAdminPrivilege = (lRet = 0) And HasAdminPrivilege2
End Function

Function HasAdminPrivilege2() As Boolean    'In Chinese Win7 despite it is has privilage to access register, it hasn't full rights to access Program Files folder than we need test this also.
    Dim sProgFileDir As String
    On Error Resume Next
    sProgFileDir = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)    'Personal - MyDocuments
    If Len(sProgFileDir) > 5 Then
        sProgFileDir = sProgFileDir & "\OrlandoApp.inf"
        If Not IsLock(sProgFileDir) Then
            If Dir(sProgFileDir) <> "" Then If FileLen(sProgFileDir) = 0 Then Kill sProgFileDir    'Len 0 to make sure any third party contents.
            HasAdminPrivilege2 = (Err.Number = 0)
        End If
    End If
End Function

Public Function IsLock(sFile As String) As Boolean
    Dim hFile As Long
    On Error Resume Next
    hFile = FreeFile
    '    Open sFile For Binary Lock Write As #hFile 'Only for write
    Open sFile For Append As #hFile                        'For read and write
    Close #hFile
    IsLock = Err.Number <> 0
End Function

Function TempFolder() As String
'Get Temp Folder
    Dim fctRet As Long
    TempFolder = String$(255, 0)
    fctRet = GetTempPath(255, TempFolder)
    If fctRet <> 0 Then
        TempFolder = Left(TempFolder, fctRet)
        If Right(TempFolder, 1) = "\" Then TempFolder = Left(TempFolder, Len(TempFolder) - 1)
    Else
        TempFolder = ""
    End If
End Function

Public Function ShiftDown()
'Verif. if Shift is pressed
    ShiftDown = (GetKeyState32(16) < 0)
End Function

Public Function CtrlDown()
'Verif. if Ctrl is pressed
    CtrlDown = (GetKeyState32(17) < 0)
End Function

Sub ButtonLanguage(Optional bLight As Boolean = False)
'Adjust sheets according language and Office version. bLight is to activate the sheet of detected language, if False,
'use the first that can be of any language making possible to use utility default language.
    Dim SheethLng As Worksheet
    IsPortg = IIf(lIsPortg = 0, Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070, lIsPortg = 1)    'Application.International(xlCountryCode) = 55
    On Error Resume Next: If Application.Visible = False Then Application.Visible = True   'Need in Office 365 because SplashScreen of expired and buy can hide.
    If bLight Then
        Set SheethLng = ThisWorkbook.Sheets(IIf(IsPortg, "Portugu|fffd|s", "English"))
        If SheethLng Is Nothing Then Set SheethLng = ThisWorkbook.Sheets(1)
    Else
        Set SheethLng = ThisWorkbook.Sheets(1)
    End If

    ThisWorkbook.Windows(1).WindowState = xlMaximized
    With SheethLng
        .Activate
        .Range("A1").Select
        .Unprotect

        'Centralize in Window
        If bLight Then
            .Columns("B:B").ColumnWidth = (Application.UsableWidth - .Range("C1:E1").Width) * .Columns("D:D").ColumnWidth / .Columns("D:D").Width / 2    '+ 1.5
        Else
            .Columns("B:B").ColumnWidth = 2.14
        End If
        .Columns("F:F").ColumnWidth = .Columns("B:B").ColumnWidth

        'Adjust shapes after converted to Office 2007
        If Val(Application.Version) >= 11 + 1 Then
            Dim shp As Shape
            For Each shp In ActiveSheet.Shapes
                shp.TextFrame.ReadingOrder = xlLTR
            Next
        End If

        .Protect
    End With
End Sub

Function InstallMSAddnDrDLL() As Boolean
'To register/unregister COM, requires MSAddnDr.DLL, then verify and install if need. This was need from Office 2013 (15).
    If IsMSAddnDrDLLInstall Then InstallMSAddnDrDLL = True: Exit Function

    'Install dll
    Dim sPathInst As String
    sPathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "CommonFilesDir", False)
    If sPathInst = "Error" Then sPathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "CommonFilesDir", False)
    If sPathInst = "Error" Or Len(sPathInst) < 5 Then MyMsgBox "CommonFilesDir not found.", 1, sAddInCaptByApp & " - Fail!": Exit Function
    sPathInst = sPathInst & "\DESIGNER"
    If Dir(sPathInst, vbDirectory) = "" Then MyMsgBox "CommonFilesDir\DESIGNER not found.", 1, sAddInCaptByApp & " - Fail!": Exit Function
    If PathTemp = "" Then Stop: PathTemp = ThisWorkbook.Path    'Useful in debug. |fffd| muito pouco prov|fffd|vel que estes MsgBox aconte|fffd|am, vou deixar por seguran|fffd|a mas simples sem muito detalhe.
    If Dir(sPathInst & "\" & "MSAddnDr.DLL") = "" Then MyMoveFile "MSAddnDr.DLL", PathTemp, sPathInst, True
    If Dir(sPathInst & "\" & "MSAddnDr.DLL") = "" Then MyMsgBox "MSAddnDr.DLL not found or not copied.", 1, sAddInCaptByApp & " - Fail!": Exit Function

    InstallMSAddnDrDLL = True
    Dim bInstalled As Boolean
    bInstalled = RegisterServer(sPathInst & "\" & "MSAddnDr.DLL", True)
    If bInstalled Then MyWait 1: bInstalled = IsMSAddnDrDLLInstall    'Conferir

    If Not bInstalled Then
        If IsPortg Then
            Msg1 = "Ao registrar a DLL no Windows (MSAddnDr.DLL)." & vbCrLf & vbCrLf & _
                   "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
            Msg2 = sAddInCaptByAppPt & " - Falha!"
        Else
            Msg1 = "When registering the DLL on Windows (MSAddnDr.DLL)." & vbCrLf & vbCrLf & _
                   "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
            Msg2 = sAddInCaptByApp & " - Fail!"
        End If
        MyMsgBox Msg1, 1, Msg2
        InstallMSAddnDrDLL = False
        Exit Function
    End If
End Function

Function IsMSAddnDrDLLInstall() As Boolean
    Dim sGuid, sDLLProgId
    sDLLProgId = "MSAddnDr.AddInDesigner"
    sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\Clsid", "", False)
    IsMSAddnDrDLLInstall = sGuid <> "Error"

    If IsMSAddnDrDLLInstall Then   'Por segurana|fffd|a, se o arquivo n|fffd|o for encontrado, considerar n|fffd|o registrada. Algo dificil de acontecer na pr|fffd|tica, mas nos teste com CTR se for desregistrada e deletada a DLL o sGuid continua reportando ok, ou seja, o registro referente o CTR n|fffd|o |fffd| atualizado com RegSvr32.exe /u, inclusive se a dll n|fffd|o for deletada continua funcionando. Talvez possa acontecer se CTV e MSI-b instalandos e o MSI-b venha a ser desinstalado.
        Dim sDllPath As String
        sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "CLSID\" & sGuid & "\InprocServer32", "", False)
        IsMSAddnDrDLLInstall = (Len(sDllPath) > 0 And Len(Dir(sDllPath))) > 0
    End If
End Function
Attribute VB_Name = "Mod1Install"
Option Explicit
Public PathTemp As String

Sub Install()
    IsPortg = IIf(lIsPortg = 0, Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070, lIsPortg = 1)     'Application.International(xlCountryCode) = 55
    Set appHostApp = Application
    dHostAppVer = Val(Application.Version)
    AddInTitle = "Orlando's " & sAddInNameByApp
    sStartupPath = Application.StartupPath

    'Office version required to install - Min
    If Val(Application.Version) < Val(sOfficeVerReqMin) Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "S|fffd| |fffd| poss|fffd|vel instalar este utilit|fffd|rio no " & sAppTarget & " " & sOfficeVerReqMin & " ou mais recente!"
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "Only it is possible to install this utility on " & sAppTarget & " " & sOfficeVerReqMin & " or later!"
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        MyMsgBox Msg1, 1, Msg2
        Exit Sub
    End If

    'Office version required to install - Max
    If Val(Application.Version) > Val(sOfficeVerReqMax) Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "Nova vers|fffd|o do Office desconhecida para esta vers|fffd|o do " & sAddInCaptByAppPt & "! Clique no link Ajuda, logo abaixo, para baixar uma nova vers|fffd|o compat|fffd|vel."
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "New Office version unknown to this " & sAddInCaptByApp & " version! Click Help link, soon below, to download a new compatible version."
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        MyMsgBox Msg1, 1, Msg2
        Exit Sub
    End If

    'Application versions required to run the utility
    If sAppVerReqToRun <> "" Then
        Dim bReqOk As Boolean
        For Each Fn In Split(sAppVerReqToRun, " or ")
            bReqOk = OpenEspVerAppObj(True, Left(Fn, InStr(1, Fn, " ") - 1), Mid(Fn, InStr(1, Fn, " ") + 1))
            If bReqOk Then Exit For
        Next
        If Not bReqOk Then
            PleaseWait False
            If IsPortg Then
                Msg1 = "Embora este utilit|fffd|rio possa ser instalado, ele requer para rodar a instala|fffd||fffd|o de pelo menos: " & MyReplace(sAppVerReqToRun, "or", "ou") & "! Continua assim mesmo?"
                Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Rodar!"
            Else
                Msg1 = "Although this utility can be installed, it requires to run the installation of at least: " & sAppVerReqToRun & "! Continue anyway?"
                Msg2 = sAddInCaptByApp & " - Impossible to Run!"
            End If
            If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub
        End If
    End If

    PathTemp = TempFolder()
    PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)    'Personal - MyDocuments
    If PathInst = "Error" Then PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Or Len(PathInst) < 5 Then PathInst = "C:"
    PathInst = PathInst & "\OrlandoApp"

    'Uninstall early version
    If IsInstallAsCOMAddin Or IsInstallAsAddin Or (sCOMAddInFileName <> "" And Dir(PathInst & "\" & sCOMAddInFileName) <> "") _
       Or (sAddInFileName <> "" And Dir(PathInst & "\" & sAddInFileName) <> "") Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "H|fffd| uma instala|fffd||fffd|o anterior ainda n|fffd|o removida." & vbCrLf & vbCrLf & "A seguir, voc|fffd| ser|fffd| redirecionado para o desinstalador que precisar|fffd| fechar o " & sAppTarget & " para completar a desinstala|fffd||fffd|o." & vbCrLf & vbCrLf & "Por favor, tente instalar novamente logo ap|fffd|s o " & sAppTarget & " ser fechado."
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "There is a previous installation not removed yet." & vbCrLf & vbCrLf & "Next, you'll be redirected to the uninstaller that will need to close " & sAppTarget & " to complete the uninstallation." & vbCrLf & vbCrLf & "Please, try to install again soon after " & sAppTarget & " is closed."
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        MyMsgBox Msg1, 1, Msg2
        UnInstall
        Exit Sub
    End If

    'Choose COM Add-in, EXE Add-in, or Add-in if available
    PathTemp = ThisWorkbook.Path
    UserFormAddInOpts.Show
    If BotAcionado = 0 Then Exit Sub
    If BotAcionado = 1 Then bIsCOMAddin = True: bIsEXEAddIn = False    'Inst. as COM add-in
    If BotAcionado = 2 Then bIsCOMAddin = False: bIsEXEAddIn = True    'Inst. as EXE Add-in
    If BotAcionado = 3 Then bIsCOMAddin = False: bIsEXEAddIn = False    'Inst. as Add-in

    'Antes verificar se tem privilegio de admin para registrar DLL, se n|fffd|o, reopen asking
    If bIsCOMAddin Then If Not HasAdminPrivilege Then CloseReOpenExcelToRegDLL: Exit Sub
    If Not bIsCOMAddin Then PathInst = Application.UserLibraryPath & "OrlandoApp"    'This folder doesn't need privileg elevation and moreover add-in is installed only for active limited user ou logge adm user
ReTry:
    PleaseWait False
    UserFormInst.folder_Tb.Value = PathInst
    UserFormInst.Show
    If BotAcionado = 3 Then Exit Sub

    PathInst = UserFormInst.folder_Tb.Value
    If UserFormInst.Xlstart_OpB.Value Then PathInst = Application.StartupPath

    On Error Resume Next
    If Dir(PathInst, vbDirectory) = "" Then MkDir PathInst
    If Err.Number <> 0 Then
        If IsPortg Then
            Msg1 = "Talvez voc|fffd| n|fffd|o tenha direitos suficientes para criar pastas neste local do disco ou rede. Tentar novamente?" & vbCrLf & vbCrLf & _
                   "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Criar Pasta!"
        Else
            Msg1 = "Maybe you haven't sufficient rights to create folders in this place on the disk or network. Try again?" & vbCrLf & vbCrLf & _
                   "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
            Msg2 = sAddInCaptByApp & " - Impossible to Create Folder!"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then GoTo ReTry Else Exit Sub
    End If

    'Pacote usando o aplicativo XLtoExe onde todos arquivos j|fffd| foram extra|fffd|dos
    Dim i As Long
    PleaseWait True
    MyWait 1

    'Conferindo extra|fffd||fffd|o
    Do While Dir(PathTemp & "\" & IIf(bIsCOMAddin, sCOMAddInFileName, IIf(bIsEXEAddIn, sEXEAddInFileName, sAddInFileName))) = ""
        MyWait 1
        i = i + 1
        If i > 40 Then
            MsgBox IIf(IsPortg, "Ao extrair arquivos para a pasta " & PathTemp & ".", "When extract files to " & PathTemp & " folder."), vbCritical, IIf(IsPortg, "Falha!", "Fail!")
            Exit Sub
        End If
    Loop

    If bIsCOMAddin Then VerifRestDisabledItems

    Dim bSuccess As Boolean
    If bIsCOMAddin Then bSuccess = InstallAsCOMAddIn Else bSuccess = InstallAsAddIn
    PleaseWait False
    If bSuccess Then
        If IsPortg Then
            Msg1 = sSuccessMsgPt
            Msg2 = sAddInCaptByAppPt & " - Instalado com Sucesso"
        Else
            Msg1 = sSuccessMsg
            Msg2 = sAddInCaptByApp & " - Installed with Success"
        End If
        MyMsgBox Msg1, 1, Msg2
    End If
    ThisWorkbook.Saved = True
    If Not bIsCOMAddin And AppVerCountInReg > 1 Then
        InstallAddIn_AllOthersViaReg PathInst & "\" & IIf(bIsEXEAddIn, sEXEAddInFileName, sAddInFileName)    'If there is more than one installed Excel, register All Others via reg but current that is already done here xxxxx
    Else
        If XLtoEXE_IsThisWbExe() Then ThisWorkbook.Close False Else Application.Quit
    End If
End Sub

Private Function InstallAsCOMAddIn() As Boolean
    If Not InstallMSAddnDrDLL Then Exit Function    'To register/unregister COM, requires MSAddnDr.DLL, then verify and install if need.
'Install dll
    InstallAsCOMAddIn = True
    MyMoveFile sCOMAddInFileName, PathTemp, PathInst, True
    If UserFormInst.AsAddIn_OpB.Value Then    'Op|fffd||fffd|o |fffd|nica para COM
        For Each Fn In Split(AttachFileNames, ";")
            If Dir(PathTemp & "\" & Fn) <> "" Then MyMoveFile CStr(Fn), PathTemp, PathInst, True
        Next
        Dim bInstalled As Boolean
        bInstalled = RegisterServer(PathInst & "\" & sCOMAddInFileName, True)
        If bInstalled Then MyWait 1: bInstalled = IsInstallAsCOMAddin    'Conferir

        If Not bInstalled Then
            If IsPortg Then
                Msg1 = "Ao registrar a DLL no Windows." & vbCrLf & vbCrLf & _
                       "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
                Msg2 = sAddInCaptByAppPt & " - Falha!"
            Else
                Msg1 = "When registering the DLL on Windows." & vbCrLf & vbCrLf & _
                       "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
                Msg2 = sAddInCaptByApp & " - Fail!"
            End If
            MyMsgBox Msg1, 1, Msg2
            InstallAsCOMAddIn = False
            Exit Function
        End If

        If UserFormInst.AllWinUsers_Chb.Value Then
            #If VBA7 Then
                Dim OpenKeyHdl As LongPtr
            #Else
                Dim OpenKeyHdl As Long
            #End If
            Dim lRet As Long
            Dim SecurAttr As SECURITY_ATTRIBUTES

            'Create local machine subkey for AddIn is used for All Win User
            If GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "", False) = "Error" Then
                RegCreateKeyEx HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, _
                               0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                               KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
                RegCloseKey OpenKeyHdl
            End If

            'Set value at subkey copying from HKEY_CURRENT_USER
            Dim vStoreValu
            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "LoadBehavior", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "LoadBehavior", REG_DWORD, CLng(vStoreValu)

            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "FriendlyName", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "FriendlyName", REG_SZ, CStr(vStoreValu)

            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "CommandLineSafe", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "CommandLineSafe", REG_DWORD, CLng(vStoreValu)

            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "Description", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "Description", REG_SZ, CStr(vStoreValu)
        End If
    End If
End Function


Private Function InstallAsAddIn() As Boolean
'Install Xla
    InstallAsAddIn = True
    MyMoveFile IIf(bIsEXEAddIn, sEXEAddInFileName, sAddInFileName), PathTemp, PathInst, True
    If UserFormInst.AsAddIn_OpB.Value Then
        For Each Fn In Split(AttachFileNames & IIf(bIsEXEAddIn, ";" & AttachFileNamesEXEAddIn, "") & IIf(bIsEXEAddIn And (IsOffice64_bit Or IsThereCTR), ";" & AttachFileNames64bit, ""), ";")
            If Dir(PathTemp & "\" & Fn) <> "" Then MyMoveFile CStr(Fn), PathTemp, PathInst, True
        Next
        Dim bInstalled As Boolean
        On Error Resume Next
        AddIns.Add Filename:=PathInst & "\" & IIf(bIsEXEAddIn, sEXEAddInFileName, sAddInFileName)
        Application.EnableEvents = False: AddIns(AddInTitle).Installed = True: Application.EnableEvents = True
        bInstalled = Err.Number = 0
        If bInstalled Then MyWait 1: bInstalled = IsInstallAsAddin    'Conferir

        If Not bInstalled Then
            If IsPortg Then
                Msg1 = "Ao registrar o Add-in no Windows."
                Msg2 = sAddInCaptByAppPt & " - Falha!"
            Else
                Msg1 = "When registering the Add-in on Windows."
                Msg2 = sAddInCaptByApp & " - Fail!"
            End If
            MyMsgBox Msg1, 1, Msg2
            InstallAsAddIn = False
            Exit Function
        End If
    Else
        For Each Fn In Split(AttachFileNames & IIf(bIsEXEAddIn, ";" & AttachFileNamesEXEAddIn, "") & IIf(bIsEXEAddIn And (IsOffice64_bit Or IsThereCTR), ";" & AttachFileNames64bit, ""), ";")
            If Dir(PathTemp & "\" & Fn) <> "" Then MyMoveFile CStr(Fn), PathTemp, PathInst & "\" & "..", True    'In XLSTART data files are one level down for Excel not load too
        Next
        Workbooks.Open PathInst & "\" & sAddInFileName
    End If
End Function

Private Sub CloseReOpenExcelToRegDLL()
    PleaseWait False
    If XLtoEXE_IsThisWbExe() Then
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para registrar a DLL, vou ser reiniciado automaticamente pedindo-lhe acesso ao registro." & vbCrLf & vbCrLf & "Por favor, pressione OK e permita."
            Msg2 = sAddInCaptByAppPt & " - Instala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to register the DLL, I will be restarted automatically asking you access to the register." & vbCrLf & vbCrLf & "Please, press OK and allow."
            Msg2 = sAddInCaptByApp & " - Install"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            lXLtoEXE_AutoReopen = 2
            lXLtoEXE_WaitReopen = 0
            sXLtoEXE_CmdLineReopen = "Install"
            If XLtoEXE_SyncProperties(True) Then
                PleaseWait True: PleaseWaitExeIndep True: PleaseWait False
                ThisWorkbook.Saved = True
                ThisWorkbook.Close False    'Application.Quit
            End If
        End If
    Else
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para registrar a DLL, agora |fffd| necess|fffd|rio fechar e voc|fffd| deve me reiniciar logo depois como administrador e ent|fffd|o acionar o bot|fffd|o Instalar novamente."
            Msg2 = sAddInCaptByAppPt & " - Instala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to register the DLL, now it must close and you should restart me afterwards immediately as administrator and then press Install button again."
            Msg2 = sAddInCaptByApp & " - Install"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            ThisWorkbook.Saved = True
            Application.Quit
        End If
    End If
End Sub

Sub MyMoveFile(vFiles As String, vOrigPath As String, vDestPath As String, bOnlyCopy As Boolean)
    Dim vFilename As String
    vFilename = Dir(vOrigPath & "\" & vFiles)
    While vFilename <> ""
        On Error Resume Next: If Dir(vDestPath & "\" & vFilename) <> "" Then Kill vDestPath & "\" & vFilename    'Pre kill is need to move only, but to copy need for test if file is locked to avoid error.
        If Err.Number <> 0 Then
            vFilename = Dir()
        Else
            If bOnlyCopy Then
                FileCopy vOrigPath & "\" & vFilename, vDestPath & "\" & vFilename
                vFilename = Dir()
            Else
                Name vOrigPath & "\" & vFilename As vDestPath & "\" & vFilename
                If Err.Number = 0 Then vFilename = Dir(vOrigPath & "\" & vFiles) Else vFilename = Dir()    'If move fail increment Dir(), not reset it.
            End If
        End If
    Wend
End Sub

Private Function OpenEspVerAppObj(Optional bVerfOnly As Boolean = False, Optional sApplication As String = "Excel", Optional sAppVersion As String = "12 (2007)") As Boolean
    Dim ret As Long
    Dim sAppExeFile As String
    OpenEspVerAppObj = False
    On Error Resume Next
    'If install and where
    sAppExeFile = GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\InstallRoot", "Path", False)
    If sAppExeFile = "Error" Then sAppExeFile = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\InstallRoot", "Path", False)
    If sAppExeFile = "Error" Or Len(sAppExeFile) < 5 Then Exit Function

    Select Case sApplication
    Case "Access"
        sAppExeFile = sAppExeFile & "Msaccess.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function

    Case "Excel"
        sAppExeFile = sAppExeFile & "Excel.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function

    Case "PowerPoint"
        sAppExeFile = sAppExeFile & "Powerpnt.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function

    Case "Word"
        sAppExeFile = sAppExeFile & "Winword.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function
    End Select

    OpenEspVerAppObj = True
End Function
Attribute VB_Name = "Mod1Uninstall"
Option Explicit
Dim sTempFile As String
Dim bCloseReOpenExcel As Boolean
Dim sFileAddInNameToUnByReg As String    'Alem de indicar o path e name do adding, |fffd| um flag para unregistra o Add-in para todos via register (mesmo s|fffd| um |fffd| necess|fffd|rio para limpar a chave Addin manager) xxxxx
Dim bReopenedToDelDll As Boolean    'Para, se tiver uninstall dll, n|fffd|o tentar desregistrar possivel adding registrado por falha

Sub UnInstall()
    IsPortg = IIf(lIsPortg = 0, Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070, lIsPortg = 1)    'Application.International(xlCountryCode) = 55
    Set appHostApp = Application
    dHostAppVer = Val(Application.Version)
    AddInTitle = "Orlando's " & sAddInNameByApp
    sStartupPath = Application.StartupPath

    sTempFile = TempFolder() & "\" & sAddInNameByApp & "DllPath.tmp"

    PleaseWait False
    If Dir(sTempFile) = "" And sXLtoEXE_CmdLineReopen <> "UnInstall" Then
        If IsPortg Then
            Msg1 = "Ser|fffd| verificada a exist|fffd|ncia de uma instala|fffd||fffd|o anterior e, em seguida, ela ser|fffd| devidamente removida. OK?"
            Msg2 = sAddInCaptByAppPt & " - DesInstalar"
        Else
            Msg1 = "It will be verified a previous installation and, after that, it will be duly removed. OK?"
            Msg2 = sAddInCaptByApp & " - UnInstall"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub
        PleaseWait True: If fExitEXEAddIn Then If fExitEXEAddIn Then Err.Raise vbObjectError + 1, "UnInstall", "Cannot stop " & AttachFileNamesEXEAddIn & " running!"
    Else
        PleaseWaitExeIndep False: PleaseWait True: bReopenedToDelDll = True
        MyWait 2    'To give time to other eventual instance of sAppTarget closes
    End If

    'Antes verificar se tem privilegio de admin para desregistrar DLL, se n|fffd|o, reopen asking
    If IsInstallAsCOMAddin And Not HasAdminPrivilege Then CloseReOpenExcelToUnregDLL: Exit Sub

    If UnInstallAsCOMAddIn Then
        If UnInstallAsAddIn Then
            VerifRestDisabledItems
            If IsPortg Then
                Msg1 = "Arquivos e comando do " & sAddInCaptByAppPt & " foram removidos."
                Msg2 = sAddInCaptByAppPt & " - DesInstala|fffd||fffd|o Conclu|fffd|da"
            Else
                Msg1 = sAddInCaptByApp & " files and command were removed."
                Msg2 = sAddInCaptByApp & " - UnInstall Finished"
            End If
            If MyMsgBox(Msg1, 1, Msg2) = 1 Then
                ThisWorkbook.Saved = True
                If sFileAddInNameToUnByReg = "" Or bReopenedToDelDll Then
                    Application.Quit
                Else
                    UnInstallAddIn_AllViaReg sFileAddInNameToUnByReg, 0    'primeiro fazer a partir desta inst|fffd|ncia para que a seguinte logue no registro j|fffd| limpo. Isso foi necess|fffd|rio no Excel 2010 em XP para ficar total limpo, inclusive Add-in Manager.
                    CloseReOpenExcelToDelDLL "'UnInstallAddIn_AllViaReg """ & sFileAddInNameToUnByReg & """,""" & fGetApp_hWnd & """'"       'Se houver mais de um Excel registrado, unregistrer o Add-in para todos via register xxxxx
                End If
            End If
        End If
    Else
        If bCloseReOpenExcel Then
            bCloseReOpenExcel = False
            If sAppTarget = "Excel" Then
                If HasAdminPrivilege Then CloseReOpenExcelToDelDLL "UnInstall" Else CloseReOpenExcelToUnregDLL    'Abrir outra inst|fffd|ncia |fffd| melhor que reopen mas precisa ter direito admin
            Else
                'N|fffd|o |fffd| necess|fffd|rio o Excel est|fffd| fechado pra remover a dll e sim o sAppTarget, bastando ReTry imediatamente.
                'Mantive o mesmo esquema, pois se falhar na pr|fffd|xima tentativa j|fffd| vai completando a desinstala|fffd||fffd|o
                ' CloseAllAccess True    'Qure retorne True or False, retenta pode ser que d|fffd| certo nesta execu|fffd||fffd|o mesmo
                UnInstall
            End If
        End If
    End If
End Sub

Private Function UnInstallAsCOMAddIn() As Boolean
    Dim sGuid As String
    Dim sDllPath As String

    PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Then PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Or Len(PathInst) < 5 Then PathInst = "C:"
    PathInst = PathInst & "\OrlandoApp"

    If IsInstallAsCOMAddin Then    'Uninstall from reg saving info in tmp file, close aplic, reopen, and then recall to delete the files
        'Get Dll Path on register
        sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\Clsid", "", False)
        sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "CLSID\" & sGuid & "\InprocServer32", "", False)

        'Se for Office 64-bits e como a instala|fffd||fffd|o s|fffd| pode ter sido feita pelo 32-bit ent|fffd|o a pasta
        'deve ser detectada via Wow6432Node no registro e o unregister ir|fffd| ser feito via RegSvr32.exe.
        'Exceto isto, nada foi alterado no codigo de uninstall pra 32-bit.
        If Not (Len(sDllPath) > 0 And Len(Dir(sDllPath))) > 0 And IsOffice64_bit Then
            sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "Wow6432Node\CLSID\" & sGuid & "\InprocServer32", "", False)
        End If

        Dim sDllPathPct    'Se a dll registrada n|fffd|o for encontrada ou estiver inacess|fffd|vel, usar a do pacote. Isto |fffd| s|fffd| para desregistrar, o processo continua como se sDllPath existisse inclusive reopen
        If Not (Len(sDllPath) > 0 And Len(Dir(sDllPath))) > 0 Then
            sDllPathPct = ThisWorkbook.Path & "\" & sCOMAddInFileName
            If Not (Len(sDllPathPct) > 0 And Len(Dir(sDllPathPct))) > 0 Then sDllPathPct = ""
        End If

        PathTemp = ThisWorkbook.Path: If Not InstallMSAddnDrDLL Then Exit Function   'To register/unregister COM, requires MSAddnDr.DLL, then verify and install if need. A priori isto s|fffd| seria necess|fffd|rio em uma tenhativa de instala|fffd||fffd|o de uma vers|fffd|o anterior que normalmente n|fffd|o pode acontecer, pois os antigos n|fffd|o rodam no 2013. Fica aqui em teste ou por seguran|fffd|a.

        If Not IsOffice64_bit Then
            RegisterServer IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
        Else
            RegisterServerShell32 IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
        End If

        'Se a dll registrada falhar ainda por algum outro motivo falhar, corrompida por exemplo,
        'tenta usar a do pacote se ainda n|fffd|o foi usada
        MyWait 1
        If IsInstallAsCOMAddin And sDllPathPct = "" Then   'Conferir
            sDllPathPct = ThisWorkbook.Path & "\" & sCOMAddInFileName
            If Not (Len(sDllPathPct) > 0 And Len(Dir(sDllPathPct))) > 0 Then sDllPathPct = ""
            If sDllPathPct <> "" Then
                If Not IsOffice64_bit Then
                    RegisterServer IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
                Else
                    RegisterServerShell32 IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
                End If
                MyWait 1
            End If
        End If

        If IsInstallAsCOMAddin Then    'Conferir novamente
            If IsPortg Then
                Msg1 = "Ao desregistrar a DLL no Windows." & vbCrLf & vbCrLf & _
                       "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
                Msg2 = sAddInCaptByAppPt & " - Falha!"
            Else
                Msg1 = "When unregister the DLL on Windows." & vbCrLf & vbCrLf & _
                       "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
                Msg2 = sAddInCaptByApp & " - Fail!"
            End If
            MyMsgBox Msg1, 1, Msg2
            PleaseWait False
            Exit Function
        End If

        'Delete local machine subkey for AddIn is used for All Win User
        If Not GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "LoadBehavior", False) = "Error" Then _
 RegDeleteKey HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId

        sDllPath = MyReplace(UCase(sDllPath), UCase("\" & sCOMAddInFileName), "")

        If Dir(sDllPath & "\LembreteDirProj.txt") <> "" Then sDllPath = PathInst    'Avoid to delete in folder project

        Open sTempFile For Output As #1
        Write #1, sDllPath
        Close #1
        bCloseReOpenExcel = True    'Para Quit Excel fora da fun|fffd||fffd|o, pois n|fffd|o sai quando perde o foco
        Exit Function
    Else
        'Get Dll Path on temp file
        If Dir(sTempFile) <> "" Then
            Open sTempFile For Input As #1
            Input #1, sDllPath
            Close #1
        Else
            sDllPath = PathInst
        End If

        'Delete files and folder
        Dim i As Double
        Do
            i = i + 1
            MyWait i
            On Error Resume Next
            If Dir(PathInst & "\" & sCOMAddInFileName) <> "" Then Kill PathInst & "\" & sCOMAddInFileName
            If Dir(sDllPath & "\" & sCOMAddInFileName) <> "" Then Kill sDllPath & "\" & sCOMAddInFileName
        Loop While Err.Number <> 0 And i < 5
        If Err.Number = 0 Then
            For Each Fn In Split(AttachFileNames, ";")
                If Dir(PathInst & "\" & Fn) <> "" Then Kill PathInst & "\" & Fn
                If Dir(sDllPath & "\" & Fn) <> "" Then Kill sDllPath & "\" & Fn
            Next
            If Dir(PathInst & "\*.*") = "" And Dir(PathInst, vbDirectory) <> "" Then RmDir PathInst
            If Dir(sTempFile) <> "" Then Kill sTempFile
            PleaseWait False
        Else
            PleaseWait False
            'Antes verificar se n|fffd|o |fffd| falta de privilegio de admin para deletar DLL em pastas protegidas, se n|fffd|o, reopen asking. Isso acontece quando a DLL foi desregistrada por outros meios e n|fffd|o deletou os arquivo ou at|fffd| por falha aqui.
            If Not HasAdminPrivilege Then bCloseReOpenExcel = True: Exit Function

            If IsPortg Then
                Msg1 = "Acesso n|fffd|o permitido. Feche todas as janelas do " & sAppTarget & " e depois tente novamente." _
                     & vbCrLf & vbCrLf & "Veja ainda se seus direitos de acessos s|fffd|o suficientes para excluir arquivos na pasta " & IIf(Dir(PathInst & "\" & sCOMAddInFileName) <> "", PathInst, sDllPath) & "."
                Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Excluir!"
            Else
                Msg1 = "Access denied. Close all " & sAppTarget & " windows and then try again." _
                     & vbCrLf & vbCrLf & "See still if your access rights are sufficient to delete files in " & IIf(Dir(PathInst & "\" & sCOMAddInFileName) <> "", PathInst, sDllPath) & " folder."
                Msg2 = sAddInCaptByApp & " - Impossible to Delete!"
            End If
            MyMsgBox Msg1, 1, Msg2
            Exit Function
        End If
    End If
    UnInstallAsCOMAddIn = True
End Function

Private Function UnInstallAsAddIn() As Boolean
    Dim PathInst As String
    Dim ad As AddIn

    UnInstallAsAddIn = True
    If sAddInFileName = "" And sEXEAddInFileName = "" Then Exit Function

    PathInst = ""
    For Each ad In AddIns
        If ad.Name = sAddInFileName Or ad.Name = sEXEAddInFileName Then
            PathInst = ad.Path: sFileAddInNameToUnByReg = ad.FullName
            Exit For
        End If
    Next

    On Error Resume Next


    'Deactivate Add
    AddIns("Orlando's Excel Calendar").Installed = False    'Vers|fffd|o antiga com AddInTitle diferente
    AddIns(AddInTitle).Installed = False
    If WbIsOpen(sAddInFileName) Then Workbooks(sAddInFileName).Close False
    If WbIsOpen(sEXEAddInFileName) Then Workbooks(sEXEAddInFileName).Close False

    'Delete files and folder...
    'In Anywhere detected if loaded
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst, False

    'InDefautOrlando
    PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Then PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Or Len(PathInst) < 5 Then
        PathInst = ""
    Else
        If Dir(PathInst & "\OrlandoApp", vbDirectory) = "" Then
            PathInst = ""
        Else
            PathInst = PathInst & "\OrlandoApp"
        End If
    End If
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst, True

    'InDefautOrlando-InUserLibrary
    PathInst = Application.UserLibraryPath & "OrlandoApp"
    If Dir(PathInst, vbDirectory) = "" Then PathInst = ""
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst, True

    'In XLSTART
    PathInst = Application.StartupPath
    If Dir(PathInst, vbDirectory) = "" Then PathInst = ""
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst & "\" & "..", False    'In XLSTART data files are one level down

    UnInstallAsAddIn = Not IsInstallAsAddin
End Function

Private Sub DelAddInFlFld(AddInPath As String, AddInDataPath As String, bFldToo As Boolean)   'Delete files and the folder
    On Error Resume Next
    If Dir(AddInPath & "\" & sAddInFileName) <> "" Then Kill AddInPath & "\" & sAddInFileName
    If Dir(AddInPath & "\" & sEXEAddInFileName) <> "" Then Kill AddInPath & "\" & sEXEAddInFileName
    For Each Fn In Split(AttachFileNames & ";" & AttachFileNamesEXEAddIn & ";" & AttachFileNames64bit, ";")
        If InStr(1, AttachFileNamesComm, Fn, vbTextCompare) = 0 Then    'Skip common files
            If Dir(AddInDataPath & "\" & Fn) <> "" Then Kill AddInDataPath & "\" & Fn
        End If
    Next
    If bFldToo Then
        For Each Fn In Split(AttachFileNamesComm, ";")    'Del commom file if poss|fffd|ble
            If Dir(AddInDataPath & "\" & Fn) <> "" And UCase(Fn) Like "FM20*.DLL" And Dir(AddInDataPath & "\*.exe.manifest") = "" Then Kill AddInDataPath & "\" & Fn    'FM dlls is use in virtualization
        Next

        If Dir(AddInPath & "\*.*") = "" And Dir(AddInPath, vbDirectory) <> "" Then RmDir AddInPath
    End If
End Sub

Private Sub CloseReOpenExcelToUnregDLL()
    PleaseWait False
    If XLtoEXE_IsThisWbExe() Then
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para desregistrar a DLL, vou ser reiniciado automaticamente pedindo-lhe acesso ao registro." & vbCrLf & vbCrLf & " Por favor, pressione OK e permita."
            Msg2 = sAddInCaptByAppPt & " - Desinstala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to unregister the DLL, I will be restarted automatically asking you access to the register." & vbCrLf & vbCrLf & "Please, press OK and allow."
            Msg2 = sAddInCaptByApp & " - Uninstall"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            lXLtoEXE_AutoReopen = 2
            lXLtoEXE_WaitReopen = 0
            sXLtoEXE_CmdLineReopen = "UnInstall"
            If XLtoEXE_SyncProperties(True) Then
                PleaseWait True: PleaseWaitExeIndep True: PleaseWait False
                ThisWorkbook.Saved = True
                ThisWorkbook.Close False    'Application.Quit
            End If
        End If
    Else
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para desregistrar a DLL, agora |fffd| necess|fffd|rio fechar e voc|fffd| deve me reiniciar logo depois como administrador e ent|fffd|o acionar o bot|fffd|o Desinstalar novamente."
            Msg2 = sAddInCaptByAppPt & " - Desinstala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to unregister the DLL, now it must close and you should restart me afterwards immediately as administrator and then press Uninstall button again."
            Msg2 = sAddInCaptByApp & " - Uninstall"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            ThisWorkbook.Saved = True
            Application.Quit
        End If
    End If
End Sub

Sub CloseReOpenExcelToDelDLL(sOnTimeCallMacro As String)    'sOnTimeCallMacro deve vir j|fffd| com o nome da macro e poss|fffd|veis argumentos no formato "'MyMacro """ & Arg1 & """,""" & Arg2 & """'"
    Dim Wb As Workbook
    'Shell Application.Path & "\Excel.exe  /r " & ThisWorkbook.FullName, vbMinimizedFocus
    Dim Perc As Long
    Dim ExcelObj As Excel.Application

    Dim ActExcelObj As Excel.Application
    Set ActExcelObj = Application    'Deu maior estabilidade
    ThisWorkbook.Saved = True

    Do
        Perc = Perc + 1
        If Perc > 10 Then
            If MsgBox(IIf(IsPortg, "N|fffd|o foi poss|fffd|vel criar um novo objeto Excel.Application para deletar a DLL! Tentar mais uma vez?", "Could not create a new Excel.Application object to delete the DLL! Try again?"), vbOKCancel + vbCritical, IIf(IsPortg, "Falha!", "Fail!")) = vbCancel Then
                BotAcionado = 1
                Exit Sub
            End If
        End If
        Set ExcelObj = New Excel.Application
        Application.StatusBar = ExcelObj.Version
        MyWait 1
    Loop Until ExcelObj.Caption <> ActExcelObj.Caption

    ExcelObj.WindowState = xlMinimized 'Isto porque no Exc 97 n|fffd|o fica oculto
    If ExcelObj.Visible Then DoEvents Else ExcelObj.Visible = True    'Visivel e minimizado fica at|fffd| mais discreto e eventualment evita Excel travar oculto como no caso n|fffd|o ativado ou em erro.

    ExcelObj.EnableEvents = False
    ExcelObj.Workbooks.Open ThisWorkbook.FullName, 0, True, , "123"
    ExcelObj.EnableEvents = True
    For Each Wb In ActExcelObj.Workbooks
        If Wb.Name <> ActExcelObj.ThisWorkbook.Name Then
            Wb.Close
        End If
    Next
    For Each Wb In ActExcelObj.Workbooks
        Wb.Saved = True
    Next

    If dHostAppVer < 12 Then
        ExcelObj.OnTime Now, sOnTimeCallMacro  'xxxxx      'Esta chamada romota do OnTime falhou no Excel 2019 64, ent|fffd|o tranferi este OnTime para um novo Sub para ser chamando remotamente com Run e ent|fffd|o chamar OnTime localmente. Talvez o Run seja mais preciso porque aceita o path completo no nome da macro.
    Else
        ExcelObj.Run "'" & ThisWorkbook.FullName & "'!UnInstallAddIn_AllViaReg2", sOnTimeCallMacro    'mas s|fffd| funciona do 12 em diante.
    End If

    MyWait 1
    'ExcelObj.Visible = True   'Agora |fffd| sempre vis|fffd|vel.
    PleaseWait False

    Dim i As Long
    For i = 1 To 20    'Deu maior estabilidade
        ActExcelObj.ThisWorkbook.Saved = True
        DoEvents
    Next
    If XLtoEXE_IsThisWbExe() Then
        lXLtoEXE_AutoReopen = 3    'To XLtoEXE tries to make the exit without reopen
        If XLtoEXE_SyncProperties(True) Then ThisWorkbook.Close False Else ActExcelObj.Quit
    Else
        ActExcelObj.Quit
    End If
End Sub

Public Sub UnInstallAddIn_AllViaReg2(sOnTimeCallMacro As String)
    Application.OnTime Now, sOnTimeCallMacro    'xxxxx
End Sub

Public Sub UnInstallAddIn_AllViaReg(sFileAddInName As String, App_hWnd As Long)
    Dim sOptOpenVal As String    ':sFileAddInName = Application.UserLibraryPath & "OrlandoApp" & "\ExcelCalendarLoadExe.xla"
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim i As Long
    Dim v As Long
    Dim sApplication As String: sApplication = sAppTarget    '"Excel"
    Dim sAppVersion As String

    If App_hWnd <> 0 Then    'Para dar tempo a outra inst|fffd|ncia que chamou fechar, continua quando n|fffd|o exitir mais a janela com App_hWnd ou, se existir, a class n|fffd|o pertencer ao appCaller. Ignora se chamado da inst|fffd|ncia corrente com App_hWnd = 0 como flag.
        Dim RetVal As Long, RetClass As String
        Const sAppClass As String = "XLMAIN"
        Do
            MyWait 0.3
            RetClass = Space(256)
            RetVal = GetClassName(App_hWnd, RetClass, 256)
            If RetVal = 0 Or Left(RetClass, RetVal) <> sAppClass Then Exit Do
            i = i + 1
        Loop While i < 80
        MyWait 0.5
    End If

    'Clean OPENs values in each App version
    For v = Val(Left(sOfficeVerReqMin, 2)) To Val(Left(sOfficeVerReqMax, 2))  'Office Versions
        sAppVersion = v & ".0"
        i = 0
        Do
            sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "OPEN" & IIf(i = 0, "", i), False)
            If sOptOpenVal = "Error" Then sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "OPEN" & IIf(i = 0, "", i), False)
            If LCase(sOptOpenVal) = """" & LCase(sFileAddInName) & """" Then
                If RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then      'Open key
                    RegDeleteValue OpenKeyHdl, "OPEN" & IIf(i = 0, "", i)    'Delete the value
                    RegCloseKey OpenKeyHdl    'Close the handle
                    'MsgBox "ok delete for " & sFileAddInName
                End If
            End If
            i = i + 1
        Loop While sOptOpenVal <> "Error"
    Next

    'Clean values in "Add-in Manager" for each App version
    For v = Val(Left(sOfficeVerReqMin, 2)) To Val(Left(sOfficeVerReqMax, 2))  'Office Versions
        sAppVersion = v & ".0"
        sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Add-in Manager", sFileAddInName, False)
        If sOptOpenVal = "Error" Then sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Add-in Manager", sFileAddInName, False)
        If LCase(sOptOpenVal) = "" Then
            If RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Add-in Manager", 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then      'Open key
                RegDeleteValue OpenKeyHdl, sFileAddInName    'Delete the value
                RegCloseKey OpenKeyHdl    'Close the handle
                'MsgBox "ok delete for " & sFileAddInName
            End If
        End If
    Next

    If App_hWnd = 0 Then Exit Sub    'Se chamada da mesma inst|fffd|ncia ainda vai continuar
    ThisWorkbook.Saved = True: Application.Quit
End Sub

Sub UnInstallAddIn_AllOthersViaReg(sFileAddInName As String)
    Dim sOptOpenVal As String    ':sFileAddInName = Application.UserLibraryPath & "OrlandoApp" & "\ExcelCalendarLoadExe.xla"
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim i As Long
    Dim v As Long
    Dim sApplication As String: sApplication = sAppTarget    '"Excel"
    Dim sAppVersion As String

    'Clean OPENs values in each App version, but current
    For v = Val(Left(sOfficeVerReqMin, 2)) To Val(Left(sOfficeVerReqMax, 2))  'Office Versions
        If v <> dHostAppVer Then
            sAppVersion = v & ".0"
            i = 0
            Do
                sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "OPEN" & IIf(i = 0, "", i), False)
                If sOptOpenVal = "Error" Then sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "OPEN" & IIf(i = 0, "", i), False)
                If LCase(sOptOpenVal) = """" & LCase(sFileAddInName) & """" Then
                    If RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then      'Open key
                        RegDeleteValue OpenKeyHdl, "OPEN" & IIf(i = 0, "", i)    'Delete the value
                        RegCloseKey OpenKeyHdl    'Close the handle
                        'MsgBox "ok delete for " & sFileAddInName
                    End If
                End If
                i = i + 1
            Loop While sOptOpenVal <> "Error"
        End If
    Next

    'Clean values in "Add-in Manager" for each App version, but current
    For v = Val(Left(sOfficeVerReqMin, 2)) To Val(Left(sOfficeVerReqMax, 2))  'Office Versions
        If v <> dHostAppVer Then
            sAppVersion = v & ".0"
            sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Add-in Manager", sFileAddInName, False)
            If sOptOpenVal = "Error" Then sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Add-in Manager", sFileAddInName, False)
            If LCase(sOptOpenVal) = "" Then
                If RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Add-in Manager", 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then      'Open key
                    RegDeleteValue OpenKeyHdl, sFileAddInName    'Delete the value
                    RegCloseKey OpenKeyHdl    'Close the handle
                    'MsgBox "ok delete for " & sFileAddInName
                End If
            End If
        End If
    Next
End Sub

Sub InstallAddIn_AllOthersViaReg(sFileAddInName As String)
    Dim sOptOpenVal As String    ':sFileAddInName = Application.UserLibraryPath & "OrlandoApp" & "\ExcelCalendarLoadExe.xla"
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim i As Long
    Dim v As Long
    Dim sApplication As String: sApplication = sAppTarget    '"Excel"
    Dim sAppVersion As String

    UnInstallAddIn_AllOthersViaReg sFileAddInName    'Antes limpar tudo em Others but current para ent|fffd|o instalar

    'Look for next OPENs values in each App version but currente and create it
    For v = Val(Left(sOfficeVerReqMin, 2)) To Val(Left(sOfficeVerReqMax, 2))    'Office Versions
        If v <> dHostAppVer Then
            sAppVersion = v & ".0"
            'First see if exist the Excel version instaled
            sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "FirstRun", False)
            If sOptOpenVal = "Error" Then sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "FirstRun", False)
            If sOptOpenVal = "0" Then
                i = 0
                Do
                    sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "OPEN" & IIf(i = 0, "", i), False)
                    If sOptOpenVal = "Error" Then sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "OPEN" & IIf(i = 0, "", i), False)
                    If sOptOpenVal = "Error" Then Exit Do
                    i = i + 1
                Loop

                'MsgBox "Create here for excel " & v
                'Set open command value at AppNameFile subkey
                SetKeyValue HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "OPEN" & IIf(i = 0, "", i), REG_SZ, """" & sFileAddInName & """"

            End If
        End If
    Next

    ThisWorkbook.Saved = True: If XLtoEXE_IsThisWbExe() Then ThisWorkbook.Close False Else Application.Quit
End Sub

Function AppVerCountInReg() As Long    'Conta quantos instala|fffd||fffd|es tem registros aptos para instalar AddIns
    Dim sOptOpenVal As String
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim i As Long
    Dim v As Long
    Dim sApplication As String: sApplication = sAppTarget    '"Excel"
    Dim sAppVersion As String

    For v = Val(Left(sOfficeVerReqMin, 2)) To Val(Left(sOfficeVerReqMax, 2))    'Office Versions
        sAppVersion = v & ".0"
        sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "FirstRun", False)
        If sOptOpenVal = "Error" Then sOptOpenVal = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Options", "FirstRun", False)
        If sOptOpenVal = "0" Then AppVerCountInReg = AppVerCountInReg + 1
    Next
End Function

Function fGetApp_hWnd()    'As Variable because can be Long or LongPtr in Office 64-bit
    Dim sClassByVer As String
    Dim dHostAppVer As Double

    dHostAppVer = Val(Application.Version)
    sClassByVer = "XLMain"

    On Error Resume Next
    If dHostAppVer > 9 Then fGetApp_hWnd = Application.hWnd: Exit Function
    If Application.Windows.Count > 0 Then
        fGetApp_hWnd = FindWindow(sClassByVer, Application.Caption & " - " & Application.ActiveWindow.Caption)
        If fGetApp_hWnd = 0 Then fGetApp_hWnd = FindWindow(sClassByVer, Application.ActiveWindow.Caption & " - " & Application.Caption)
    End If
    If fGetApp_hWnd = 0 Then fGetApp_hWnd = FindWindow(sClassByVer, Application.Caption)
    If fGetApp_hWnd = 0 Then fGetApp_hWnd = FindWindow(sClassByVer, vbNullString)
    Err.Clear
End Function

Function fExitEXEAddIn() As Boolean
'Exit old exe installed running. |fffd|til no Excel sem XLtoEXE.
    Dim CmdBarCtrl As CommandBarButton
    If sEXEAddInFileName = "" Then Exit Function Else On Error Resume Next
    Dim ad As AddIn, bIsInstall As Boolean
    For Each ad In AddIns
        Err.Clear: Msg1 = ad.Path & ad.Name
        If Err.Number = 0 Then
            If LCase(ad.Name) = LCase(sEXEAddInFileName) Then
                If Dir(ad.Path & Application.PathSeparator & ad.Name) <> "" Then bIsInstall = True    'Only is installed, if registered and the exists
                Exit For
            End If
        End If
    Next
    If Not bIsInstall Then Exit Function

    AddInTitle = "Orlando's " & sAddInNameByApp
    Set CmdBarCtrl = Application.CommandBars.FindControl(Tag:=AddInTitle)
    If Not CmdBarCtrl Is Nothing Then
        CmdBarCtrl.Parameter = "fExit"
        CmdBarCtrl.Execute
        If CmdBarCtrl.Parameter = "" Then    'Se vazio, o comando Exit foi acionado ent|fffd|o esperar sa|fffd|da e limpeza normal. Se n|fffd|o, |fffd| bot|fffd|o de uma execu|fffd||fffd|o anterior ent|fffd|o deletar aqui mesmo para resetar
            MyWait 4, False   'Do not sleep the process
        Else
            Do While Not CmdBarCtrl Is Nothing
                If Not CmdBarCtrl.BuiltIn Then CmdBarCtrl.Delete
                Set CmdBarCtrl = Application.CommandBars.FindControl(Tag:=AddInTitle)
            Loop
        End If
        fExitEXEAddIn = True
        Set CmdBarCtrl = Nothing
    End If
End Function

Attribute VB_Name = "Mod2RegEdit"
Option Explicit

Public Const REG_SZ As Long = &H1
Public Const REG_DWORD As Long = &H4
Public Const REG_BINARY As Long = &H3

Public Const HKEY_CLASSES_ROOT As Long = &H80000000
Public Const HKEY_CURRENT_USER As Long = &H80000001
Public Const HKEY_LOCAL_MACHINE As Long = &H80000002
Public Const HKEY_USERS As Long = &H80000003

Public Const KEY_ALL_ACCESS As Long = &H3F
Private Const KEY_QUERY_VALUE As Long = &H1
Public Const REG_OPTION_NON_VOLATILE As Long = 0

Private Const ERROR_MORE_DATA As Long = 234
Private Const ERROR_NO_MORE_ITEMS = 259

Public Type SECURITY_ATTRIBUTES
    nLength As Long
    #If VBA7 Then
    lpSecurityDescriptor As LongPtr
    #Else
    lpSecurityDescriptor As Long
    #End If
    bInheritHandle As Long
End Type

#If VBA7 Then
    Public Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As LongPtr) As Long
    Public Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As SECURITY_ATTRIBUTES, phkResult As LongPtr, lpdwDisposition As Long) As Long
    Public Declare PtrSafe Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As LongPtr, ByVal lpSubKey As String) As Long
    Public Declare PtrSafe Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As LongPtr, ByVal lpValueName As String) As Long
    Private Declare PtrSafe Function RegQueryValueExStr Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, ByRef lpType As Long, ByVal lpData As String, ByRef lpcbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegQueryValueExLng Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, ByRef lpType As Long, lpData As Long, ByRef lpcbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegQueryValueExByt Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, ByRef lpType As Long, lpData As Byte, ByRef lpcbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Public Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As LongPtr) As Long
    Private Declare PtrSafe Function RegSetValueExStr Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpData As String, ByVal cbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegSetValueExLng Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Long, ByVal cbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegSetValueExByt Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Byte, ByVal cbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
#Else
    Public Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
    Public Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As SECURITY_ATTRIBUTES, phkResult As Long, lpdwDisposition As Long) As Long
    Public Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As Long, ByVal lpSubKey As String) As Long
    Public Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long
    Private Declare Function RegQueryValueExStr Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, ByVal lpData As String, ByRef lpcbData As Long) As Long                                      'Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegQueryValueExLng Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, lpData As Long, ByRef lpcbData As Long) As Long                                      'Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegQueryValueExByt Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, lpData As Byte, ByRef lpcbData As Long) As Long                                      'Note that if you declare the lpData parameter as String, you must pass it By Value.
    Public Declare Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
    Private Declare Function RegSetValueExStr Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpData As String, ByVal cbData As Long) As Long                                  ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegSetValueExLng Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Long, ByVal cbData As Long) As Long                                  ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegSetValueExByt Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Byte, ByVal cbData As Long) As Long                                  ' Note that if you declare the lpData parameter as String, you must pass it By Value.
#End If

Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type
#If VBA7 Then
    Private Declare PtrSafe Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As LongPtr, ByVal dwIndex As Long, ByVal lpName As String, lpcbName As Long, ByVal lpReserved As LongPtr, ByVal lpClass As String, lpcbClass As Long, lpftLastWriteTime As FILETIME) As Long
    Private Declare PtrSafe Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" (ByVal hKey As LongPtr, ByVal dwIndex As Long, ByVal lpValueName As String, lpcbValueName As Long, ByVal lpReserved As LongPtr, lpType As Long, lpData As String, lpcbData As Long) As Long
#Else
    Private Declare Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpName As String, lpcbName As Long, ByVal lpReserved As Long, ByVal lpClass As String, lpcbClass As Long, lpftLastWriteTime As FILETIME) As Long
    Private Declare Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" (ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpValueName As String, lpcbValueName As Long, ByVal lpReserved As Long, lpType As Long, lpData As String, lpcbData As Long) As Long                                            'Note that if you declare the lpData parameter as String, you must pass it By Value.
#End If

Sub FileExtAssociation(sExt As String, sAppName As String, sAppFullNameFile As String)
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim lRet As Long
    Dim SecurAttr As SECURITY_ATTRIBUTES

    'Create root extension subkey (.xxx)
    If GetRegValue(HKEY_CLASSES_ROOT, sExt, "", False) = "Error" Then
        RegCreateKeyEx HKEY_CLASSES_ROOT, sExt, _
                       0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                       KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
        RegCloseKey OpenKeyHdl
    End If

    'Create root Application subkey about file extension (AppNameFile subkey)
    If GetRegValue(HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", "", False) = "Error" Then
        RegCreateKeyEx HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", _
                       0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                       KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
        RegCloseKey OpenKeyHdl
    End If

    'Set open command value at AppNameFile subkey
    SetKeyValue HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", "", REG_SZ, """" & sAppFullNameFile & """" & " %1"

    'Define a description for the extension file as default value at AppNameFile subkey.
    SetKeyValue HKEY_CLASSES_ROOT, sAppName & "File", "", REG_SZ, sAppName & " File"

    'Set default value at extension subkey to look for commands at AppNameFile subkey
    SetKeyValue HKEY_CLASSES_ROOT, sExt, "", REG_SZ, sAppName & "File"

End Sub

#If VBA7 Then
Function SetValueEx(ByVal hKey As LongPtr, sValueName As String, lType As Long, vlpData As Variant) As Long
#Else
Function SetValueEx(ByVal hKey As Long, sValueName As String, lType As Long, vlpData As Variant) As Long
#End If
#If VBA7 Then
    Dim OpenKeyHdl As LongPtr
#Else
    Dim OpenKeyHdl As Long
#End If


Dim blpData() As Byte
Dim llpData As Long
Dim slpData As String

Select Case lType
Case REG_BINARY
    blpData = vlpData
    SetValueEx = RegSetValueExStr(hKey, _
                                  sValueName, _
                                  0&, _
                                  lType, _
                                  blpData(0), _
                                  UBound(blpData) - LBound(blpData) - 1)

Case REG_SZ
    slpData = vlpData & Chr$(0)
    SetValueEx = RegSetValueExStr(hKey, _
                                  sValueName, _
                                  0&, _
                                  lType, _
                                  slpData, _
                                  Len(slpData))

Case REG_DWORD
    llpData = vlpData
    SetValueEx = RegSetValueExLng(hKey, _
                                  sValueName, _
                                  0&, _
                                  lType, _
                                  llpData, _
                                  4)
End Select
End Function

Sub SetKeyValue(lKey As Long, sSubKey As String, _
                sValueName As String, lType As Long, vValue As Variant)
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If

    'open the key
    RegOpenKeyEx lKey, sSubKey, 0, KEY_ALL_ACCESS, OpenKeyHdl

    'Set the value
    SetValueEx OpenKeyHdl, sValueName, lType, vValue

    'Close the key
    RegCloseKey OpenKeyHdl

End Sub

'Get Registry Value, Arguments:
'1 - Reg Key (Ex.: HKEY_LOCAL_MACHINE),
'2 - Reg SubKey (Ex.: "Software\Microsoft\Windows\CurrentVersion"),
'3 - Name of Value (Ex.:"ProgramFilesDir" or "" for default)
'4 - Convert to text like written in reg files (*.reg)
Function GetRegValue(lKey As Long, sSubKey As String, sValueName As String, ConvRegText)
    Dim sRet As String * 255  'Fixed-length strings
    Dim lRet As Long
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim lType As Long
    Dim lLen As Long
    Dim sDataRet As String
    Dim lDataRet As Long
    Dim abDataRet() As Byte
    Dim i As Integer
    Dim BrkLine As Long

    lRet = RegOpenKeyEx(lKey, sSubKey, 0, KEY_QUERY_VALUE, OpenKeyHdl)

    lRet = RegQueryValueExLng(OpenKeyHdl, sValueName, 0&, lType, 0&, lLen)
    If lRet And lRet <> ERROR_MORE_DATA Then
        RegCloseKey OpenKeyHdl
        GetRegValue = "Error"
        Exit Function
    End If

    Select Case lType
    Case REG_DWORD
        lRet = RegQueryValueExLng(OpenKeyHdl, sValueName, _
                                  0&, lType, lDataRet, lLen)
        GetRegValue = CLng(lDataRet)

        If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=dword:" & Left("00000000", 8 - Len(Hex(GetRegValue))) & Hex(GetRegValue)

    Case REG_SZ
        sDataRet = String$(lLen - 1, 0)
        lRet = RegQueryValueExStr(OpenKeyHdl, sValueName, _
                                  0&, lType, sDataRet, lLen)
        GetRegValue = sDataRet

        If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=" & GetRegValue

    Case Else   'REG_BINARY and others
        ReDim abDataRet(lLen)
        lRet = RegQueryValueExByt(OpenKeyHdl, sValueName, _
                                  0&, lType, abDataRet(0), lLen)
        GetRegValue = abDataRet

        If ConvRegText Then
            If lType = REG_BINARY Then
                GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=hex:"
                sDataRet = String$(lLen, 0)
                lRet = RegQueryValueExStr(OpenKeyHdl, sValueName, 0&, lType, sDataRet, lLen)
                BrkLine = Len(GetRegValue)
                For i = 1 To lLen
                    If BrkLine >= 77 Then
                        BrkLine = 2
                        GetRegValue = GetRegValue & "\" & Chr(10) & "  "
                    End If
                    GetRegValue = GetRegValue _
                                & IIf(Len(Hex(Asc(Mid(sDataRet, i, 1)))) = 1, "0", "") _
                                & Hex(Asc(Mid(sDataRet, i, 1))) & ","
                    BrkLine = BrkLine + 3
                Next
            Else
                If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=" & GetRegValue
            End If
        End If
    End Select
    RegCloseKey OpenKeyHdl
End Function

Function fRegEnumKey(lKey As Long, sSubKey As String, bEnumKeys As Boolean, bEnumValues As Boolean)
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim lCount As Long
    Dim sNameRet As String
    Dim lLenNameRet As Long
    Dim sDataRet As String
    Dim lLenDataRet As Long
    Dim fRetArr() As String
    Dim ft As FILETIME

    ReDim fRetArr(1, 0)

    If bEnumKeys Then    'Enumerate the keys
        If RegOpenKeyEx(lKey, sSubKey, 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then     'Open key
            lLenNameRet = 255: sNameRet = String$(255, 0)    'Buffering
            Do While RegEnumKeyEx(OpenKeyHdl, lCount, sNameRet, lLenNameRet, ByVal 0&, vbNullString, ByVal 0&, ft) <> ERROR_NO_MORE_ITEMS    'Enumerate the keys
                If lCount > 0 Then ReDim Preserve fRetArr(1, UBound(fRetArr, 2) + 1)
                fRetArr(0, UBound(fRetArr, 2)) = Left$(sNameRet, lLenNameRet)
                lCount = lCount + 1    'Next key
                sNameRet = String$(255, 0)
                lLenNameRet = 255
            Loop
            RegCloseKey OpenKeyHdl    'Close key
        Else
            fRegEnumKey = False    'Error when opening Key
            Exit Function
        End If
    End If

    If bEnumValues Then    'Enumerate the values
        lCount = 0
        If RegOpenKeyEx(lKey, sSubKey, 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then     'Open key
            lLenNameRet = 255: lLenDataRet = 255: sNameRet = String$(255, 0): sDataRet = String$(255, 0)    'Buffering
            Do While RegEnumValue(OpenKeyHdl, lCount, sNameRet, lLenNameRet, 0, ByVal 0&, ByVal sDataRet, lLenDataRet) <> ERROR_NO_MORE_ITEMS
                If fRetArr(0, UBound(fRetArr, 2)) <> "" Then ReDim Preserve fRetArr(1, UBound(fRetArr, 2) + 1)
                fRetArr(0, UBound(fRetArr, 2)) = Left$(sNameRet, lLenNameRet)
                fRetArr(1, UBound(fRetArr, 2)) = Left$(sDataRet, lLenDataRet - 1)
                lCount = lCount + 1    'Next key
                lLenNameRet = 255: lLenDataRet = 255: sNameRet = String$(255, 0): sDataRet = String$(255, 0)
            Loop
            RegCloseKey OpenKeyHdl    'Close key
        Else
            fRegEnumKey = False    'Error when opening Key
            Exit Function
        End If
    End If

    fRegEnumKey = fRetArr
End Function
Attribute VB_Name = "Mod4DllRegServer"
'Obtive no VB NG mas tenho dois outros que tamb|fffd|m funcionam
#If VBA7 Then
    Private Declare PtrSafe Function LoadLibraryA Lib "kernel32" (ByVal lLibFileName As String) As LongPtr
    Private Declare PtrSafe Function CreateThread Lib "kernel32" (lThreadAttributes As Any, ByVal lStackSize As LongPtr, ByVal lStartAddress As LongPtr, ByVal lParameter As LongPtr, ByVal lCreationFlags As Long, lThreadId As Long) As LongPtr
    Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal lMilliseconds As Long) As Long
    Private Declare PtrSafe Function GetProcAddress Lib "kernel32" (ByVal hModule As LongPtr, ByVal lProcName As String) As LongPtr
    Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As LongPtr) As Long
    Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
    Private Declare PtrSafe Function GetExitCodeThread Lib "kernel32" (ByVal hThread As LongPtr, lExitCode As Long) As Long
    Private Declare PtrSafe Sub ExitThread Lib "kernel32" (ByVal lExitCode As Long)
#Else
    Private Declare Function LoadLibraryA Lib "kernel32" (ByVal lLibFileName As String) As Long
    Private Declare Function CreateThread Lib "kernel32" (lThreadAttributes As Any, ByVal lStackSize As Long, ByVal lStartAddress As Long, ByVal larameter As Long, ByVal lCreationFlags As Long, lThreadId As Long) As Long
    Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal lMilliseconds As Long) As Long
    Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lProcName As String) As Long
    Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
    Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
    Private Declare Function GetExitCodeThread Lib "kernel32" (ByVal hThread As Long, lExitCode As Long) As Long
    Private Declare Sub ExitThread Lib "kernel32" (ByVal lExitCode As Long)
#End If

'Purpose   :    This function registers and Unregisters OLE components
'Inputs    :    sFilePath                       The path to the DLL/OCX or ActiveX EXE
'               bRegister                       If True Registers the control, else unregisters control
'Outputs   :    Returns True if successful
'Author    :    Andrewb
'Date      :    04/09/2000
'Notes     :    This effectively replaces RegSvr32.exe by loading the library and
'               calling the register or unregister functions exposed by all OLE components.
'Revisions :    Updated to include code for registering ActiveX Exes.

Function RegisterServer(sFilePath As String, Optional bRegister As Boolean = True) As Boolean
    #If VBA7 Then
        Dim lLibAddress As LongPtr
        Dim lProcAddress As LongPtr
        Dim lThread As LongPtr
    #Else
        Dim lLibAddress As Long
        Dim lProcAddress As Long
        Dim lThread As Long
    #End If
    Dim lThreadId As Long
    Dim lSuccess As Long
    Dim lExitCode As Long
    Dim sRegister As String
    Const clMaxTimeWait As Long = 20000    'Wait 20 secs for register to complete

    On Error GoTo ExitFunc
    If Len(sFilePath) > 0 And Len(Dir(sFilePath)) > 0 Then
        'File exists
        If UCase$(Right$(sFilePath, 3)) = "EXE" Then
            'Register/Unregister ActiveX EXE
            If bRegister Then
                'Register EXE
                Shell sFilePath & " /REGSERVER", vbHide
            Else
                'Unregister ActiveX EXE
                Shell sFilePath & " /UNREGSERVER", vbHide
            End If
            RegisterServer = True
        Else
            'Register/Unregister DLL
            If bRegister Then
                sRegister = "DllRegisterServer"
            Else
                sRegister = "DllUnregisterServer"
            End If

            'Load library into current process
            lLibAddress = LoadLibraryA(sFilePath)

            If lLibAddress Then
                'Get address of the DLL function
                lProcAddress = GetProcAddress(lLibAddress, sRegister)

                If lProcAddress Then
                    'Found interface, make call to component
                    lThread = CreateThread(ByVal 0&, 0&, ByVal lProcAddress, ByVal 0&, 0&, lThreadId)
                    If lThread Then
                        'Created thread
                        lSuccess = (WaitForSingleObject(lThread, clMaxTimeWait) = 0)
                        If Not lSuccess Then
                            'Failed to register, close thread
                            Call GetExitCodeThread(lThread, lExitCode)
                            Call ExitThread(lExitCode)
                            RegisterServer = False
                        Else
                            'Register control
                            RegisterServer = True
                            Call CloseHandle(lThread)
                        End If
                    End If
                Else
                    'Object doesn't expose OLE interface
                    FreeLibrary lLibAddress
                End If
                Call FreeLibrary(lLibAddress)
            End If
        End If
    End If
ExitFunc:
    On Error GoTo 0
End Function

Sub RegisterServerShell32(sFilePath As String, Optional bRegister As Boolean = True)
'No Office 64-bit n|fffd|o aceita instalar, mas pode ser preciso desinstalar se tiver sido instalado
'antes, infelizmente, ao unregistrar via API, falha em LoadLibraryA(sFilePath) mesmo sFilPath
'esteja correto. Entao tentar aqui via shell RegSvr32 em vez da fun|fffd||fffd|o RegisterServer
    If Len(sFilePath) > 0 And Len(Dir(sFilePath)) > 0 Then
        If bRegister Then
            Shell "RegSvr32.exe /s """ & sFilePath & """"
        Else
            Shell "RegSvr32.exe /u /s """ & sFilePath & """"
        End If
        MyWait 5
    End If
End Sub
Attribute VB_Name = "ModMyMsgBox"
Option Explicit
Public Const LOCALE_USER_DEFAULT& = &H400
Public Const LOCALE_SENGLANGUAGE = &H1001   'English name of language
Public Const LOCALE_SLANGUAGE = &H2   'localized name of language
Public Const LOCALE_SLIST = &HC         '  list item separator
Public Const LOCALE_SDECIMAL = &HE         '  decimal separator
Public Const LOCALE_STHOUSAND = &HF         '  thousand separator
Public Const LOCALE_ICOUNTRY = &H5         '  country code
Public Const LOCALE_ITIME = &H23        '  time format specifier
Public Const LOCALE_SDATE = &H1D        '  date separator
Public Const LOCALE_STIME = &H1E        '  time separator
#If VBA7 Then
    Private Declare PtrSafe Function apiGetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
    Private Declare PtrSafe Function GetVersion Lib "kernel32" () As Long
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" Alias "WNetGetUserA" (ByVal lpName As String, ByVal lpUserName As String, lpnLength As Long) As Long
    Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr
#Else
    Private Declare Function apiGetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
    Private Declare Function GetVersion Lib "kernel32" () As Long
    Declare Function WNetGetUser Lib "mpr.dll" Alias "WNetGetUserA" (ByVal lpName As String, ByVal lpUserName As String, lpnLength As Long) As Long
    Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
#End If

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128                           '  Maintenance string for PSS usage
End Type
'  dwPlatformId defines:
Private Const VER_PLATFORM_WIN32s = 0
Private Const VER_PLATFORM_WIN32_WINDOWS = 1
Private Const VER_PLATFORM_WIN32_NT = 2
#If VBA7 Then
    Private Declare PtrSafe Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (lpVersionInformation As OSVERSIONINFO) As Long
#Else
    Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long
#End If

Public BotAcionado As Integer
Public IsPortg As Boolean
Public Msg1 As String
Public Msg2 As String

Public Function MyMsgBox(sPrompt As String, lBut As Long, sTitle As String, Optional Xpos As Long, Optional Ypos As Long)
    With FormMyMsgBox
        .Caption = sTitle
        .Alert_Tb = sPrompt
        .lBut = lBut
        .Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
        .Email_Lb.ControlTipText = "orlando@cpap.com.br"
        .EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInCaptByApp
        .HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
        .HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
        .HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=InstAjuda", "More.asp?IdC=InstHelp")
        .Xpos = Xpos    '* Twips 'Twips usa em COM Add-in
        .Ypos = Ypos    '* Twips
        .Show  '1   '|fffd| preciso usar em COM add-in
    End With
    Unload FormMyMsgBox
    MyMsgBox = BotAcionado
End Function

Sub MyWait(PauseSeg As Double, Optional bSleep As Boolean = True)
    Dim Start
    Start = Timer
    Do While Timer < Start + PauseSeg
        DoEvents
        If bSleep Then Sleep 1  'Com Sleep o CPU Usage cai de 100% para seus 0 ou 2% normal, mas p|fffd|e o processo para dormir e deve ser evitado se for esperado alguma a|fffd||fffd|o nele a partir de outro processo
    Loop
End Sub

Function gLocInfo(vType As Long) As String
    Dim vStr As String, vLng As Long
    Dim ret As Long
    vStr = String$(255, 0)
    vLng = 255 - 1
    ret = apiGetLocaleInfo(LOCALE_USER_DEFAULT, vType, vStr, vLng)
    If ret <> 0 Then
        gLocInfo = Left$(vStr, ret - 1)
    End If
End Function

Function SendEMailByURL(oCtrl As Object, EmailUrl As String, Subj As String, Msg As String, bCtrlError As Boolean) As Boolean
    Dim URL As String
    Dim ret As Long

    Err.Clear
    If Not oCtrl Is Nothing Then
        If oCtrl.MousePointer = fmMousePointerHourGlass Then Exit Function
        oCtrl.MousePointer = fmMousePointerHourGlass
        oCtrl.ForeColor = &H80FF&
        DoEvents
    End If

    If Subj <> "" Then                                     'Indica para montar uma URL para email
        If appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word" Then _
 appHostApp.StatusBar = IIf(IsPortg, "Preparando E-mail. Aguarde...", "Preparing Email. Wait...")

        '& in Hex
        Subj = MyReplace(Subj, "&", "%26")
        Msg = MyReplace(Msg, "&", "%26")

        'Spaces in Hex
        Subj = MyReplace(Subj, " ", "%20")
        Msg = MyReplace(Msg, " ", "%20")

        'CRLF in Hex
        Msg = MyReplace(Msg, vbCrLf, "%0D%0A")

        URL = "mailto:" & EmailUrl & "?subject=" & Subj & "&body=" & Msg

        'Launch Start command with URL (Falha no Win2000)
        'Ret = Shell(Left("Start " & URL, 460), vbHide)
    Else
        URL = EmailUrl
    End If

    If Not bCtrlError And InStr(1, URL, "#") = 0 Then
        'A vantagem do ShellExecute |fffd| que no m|fffd|todo FollowHyperlink a lingua do Navegador n|fffd|o |fffd| enviada
        'e tem que ter documento aberto. Vou usar FollowHyperlink s|fffd| quando precisar controlar erro e
        'se houver bookmark
        ShellExecute 0&, vbNullString, Left(URL, 457), vbNullString, vbNullString, vbNormalFocus
    Else
        Dim sBookmark As String
        If InStr(1, URL, "#") = 0 Then
            sBookmark = ""
        Else
            sBookmark = Mid(URL, InStr(1, URL, "#"))
            URL = Left(URL, InStr(1, URL, "#") - 1)
        End If

        On Error Resume Next
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            If appHostApp.ActiveWorkbook Is Nothing Then appHostApp.Workbooks.Add
            appHostApp.ActiveWorkbook.FollowHyperlink Left(URL, 457), sBookmark, True       'DifAppMet
        Case "Microsoft Word"
            If appHostApp.ActiveDocument Is Nothing Then appHostApp.Documents.Add
            appHostApp.ActiveDocument.FollowHyperlink Left(URL, 457), sBookmark, True
        Case "Microsoft PowerPoint"
            If appHostApp.ActivePresentation Is Nothing Then appHostApp.Presentations.Add
            appHostApp.ActivePresentation.FollowHyperlink Left(URL, 457), sBookmark, True
        Case "Microsoft Access"
            appHostApp.FollowHyperlink Left(URL, 457), sBookmark, True
        End Select
    End If
    If Err.Number = 0 Then MyWait 10
    If Subj <> "" And (appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word") Then _
 appHostApp.StatusBar = False

    If Err.Number <> 0 Then MsgBox Err.Description
    If Not oCtrl Is Nothing Then oCtrl.MousePointer = fmMousePointerCustom
    SendEMailByURL = Err.Number = 0
    Err.Clear
End Function

Function MyReplace(vText As String, vTxtFind As String, vTxtRep As String)
'Word 6.0 VBA doesn't have Replace function
    Dim lPos As Long
    lPos = 1 - Len(vTxtRep)
vStart:
    lPos = InStr(lPos + Len(vTxtRep), vText, vTxtFind)
    If lPos = 0 Or vTxtFind = "" Then
        MyReplace = vText
        Exit Function
    End If
    vText = Left(vText, lPos - 1) & vTxtRep & Right(vText, Len(vText) - lPos - Len(vTxtFind) + 1)
    GoTo vStart
End Function

Function MySplit(ByVal sString As String, Optional sDelim As String, Optional lLimit As Long = -1, Optional bCompare As Long = 0) As Variant
'Excel 97 and Word6 haven't Split function
    Dim sSplitArr() As String
    Dim lPos As Long
    Dim i As Long
    Dim R As Long

    If sString = "" Or lLimit = 0 Then
        MySplit = Array()
        Exit Function
    End If

    If sDelim = "" Then
        ReDim Preserve sSplitArr(i)
        sSplitArr(i) = sString
    Else
        lPos = InStr(1, sString, sDelim, bCompare)
        If lPos = 0 Then
            ReDim Preserve sSplitArr(i)
            sSplitArr(i) = sString
        Else
            R = 2
            Do
                ReDim Preserve sSplitArr(i)
                If R > 1 Then
                    sSplitArr(i) = Left(sString, lPos - 1)
                    sString = Mid(sString, lPos + Len(sDelim))
                Else
                    sSplitArr(i) = sString
                    sString = ""
                End If
                lPos = InStr(1, sString, sDelim, bCompare)
                R = R - 1 - 1 * (lPos > 0)
                If lLimit <> -1 And i = lLimit - 1 Then
                    sSplitArr(i) = sSplitArr(i) & IIf(R > 0, sDelim & sString, "")
                    Exit Do
                End If
                i = i + 1
            Loop While R > 0
        End If
    End If
    MySplit = sSplitArr
End Function

Function EmlMsg() As String
    Dim WinVer As String
    Dim AppVer As String
    EmlMsg = ""
    EmlMsg = EmlMsg & IIf(IsPortg, "Prezado", "Dear") & " Orlando,"
    EmlMsg = EmlMsg & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Gostaria...", "I would like...")
    EmlMsg = EmlMsg & vbCrLf & vbCrLf & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Atenciosamente,", "Regards,") & vbCrLf & vbCrLf & vbCrLf

    EmlMsg = EmlMsg & "___" & vbCrLf
    EmlMsg = EmlMsg & GetWinUserName & vbCrLf    'O acc e pp n|fffd|o tem appHostApp.UserName e Win user me parece mais

    Select Case appHostApp.Name
    Case "Microsoft Excel"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)  'DifAppMet
    Case "Microsoft Word"
        WinVer = appHostApp.System.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft PowerPoint"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft Access"
        WinVer = GetOperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    End Select

    AppVer = gLocInfo(LOCALE_ICOUNTRY)
    AppVer = IIf(AppVer = 1, "English", IIf(AppVer = 55, "Portugu|fffd|s", "Language " & AppVer))
    AppVer = appHostApp.Name & " " & dHostAppVer & " (" & AppVer & ")"
    EmlMsg = EmlMsg & WinVer & vbCrLf
    EmlMsg = EmlMsg & AppVer & vbCrLf
End Function

Public Function GetOperatingSystem() As String
    Dim Ver As Long, WinVer As Long
    Ver = GetVersion()
    WinVer = Ver And &HFFFF&
    'retrieve the windows version
    GetOperatingSystem = "Windows " & Format((WinVer Mod 256) + ((WinVer \ 256) / 100), "Fixed")
End Function

Function GetWinUserName() As String
    Dim vStr As String, ret As Long, lpName As String
    vStr = String$(255, 0)
    ret = WNetGetUser(lpName, vStr, 255)
    If ret = 0 Then GetWinUserName = Left$(vStr, InStr(vStr, Chr(0)) - 1)
End Function

Public Function IsWinNTVista() As Boolean    'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1.
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNTVista = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 0)
End Function

Public Function IsWinNT7() As Boolean    'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1.
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNT7 = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 1)
End Function


Attribute VB_Name = "ModXLtoEXE"
Option Explicit
Public sXLtoEXE_ThisWbPathExe As String    'Name of the EXE file on the disk
Public sXLtoEXE_ThisWbNameExe As String    'Path where the EXE file is found on the disk.
Public lXLtoEXE_hWnd As Long    'Handle of a window that XLtoEXE creates in Windows specially for the VBA project watches it and take action when it fails to run for some reason, for example, misuse of Ctrl+Alt+Del.

Public lXLtoEXE_AutoReopen As Long    'To XLtoEXE auto reopen after all closed, set 1 for normal reopen or 2 for reopen asking privilege elevation. And, especially, 3 to quit the same way, but not reopen.
Public lXLtoEXE_WaitReopen As Long    'Wait in seconds to auto reopen.
Public sXLtoEXE_CmdLineReopen As String    'Command line argument to be passed to the VBA project when opening or auto reopening.
Public lXLtoEXE_AvoidAccessVBE As Long    'Set as 1 to avoid access to VBE, 2 to allow, and 0 to follow the option set when converting.
Public lXLtoEXE_SaveNow As Long    'Set as 1 to XLtoEXE save this project now. This useful when all data is saved in attached files. If the project is read-only or there is not to save, it will be ignored.
Public sXLtoEXE_SaveAsExe As String    'Set a full name for a new EXE file that will be created from the open EXE with the current changes by still to save. The current EXE will be closed without the changes and the new one will be open in its place already due saved. If the project is read-only, it will be ignored.
Public sXLtoEXE_SaveCopyAsExe As String    'Set a full name for a new EXE file that will be created from the open EXE with the current changes by still to save. The current EXE will continue open as it is and the new one will be closed duly saved with the changes. If the project is read-only, it will be ignored.
Public sXLtoEXE_TrustWbNames As String    'List of trusted workbook names (with or without path) for XLtoEXE allows in exclusive window. Use ';' as separator. Path will be required on all names if there is at least one path separator character '\' on the list.

'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
'" If XLtoEXE_IsThisWbExe() function return True, moreover to indicate a converted XL to
'" EXE, it captures and attributes values to sXLtoEXE_ThisWbPathExe and sXLtoEXE_ThisWbNameExe
'" public variables informed by XLtoEXE to be used in any part of this VBA project.
'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Function XLtoEXE_IsThisWbExe() As Boolean
    Dim XLtoEXEtmpLog As String
    Dim hFile As Long
    hFile = FreeFile
    XLtoEXEtmpLog = ThisWorkbook.Path & "\XLtoEXE.log"
    If Dir(XLtoEXEtmpLog, vbHidden) = "" Then Exit Function
    On Error Resume Next
    Open XLtoEXEtmpLog For Input As #hFile
    Input #hFile, sXLtoEXE_ThisWbPathExe
    Input #hFile, sXLtoEXE_ThisWbNameExe
    Input #hFile, sXLtoEXE_CmdLineReopen
    Input #hFile, lXLtoEXE_hWnd
    Close #hFile
    If Err.Number = 0 Then
        If LCase(Dir(sXLtoEXE_ThisWbPathExe & "\" & sXLtoEXE_ThisWbNameExe)) = LCase(sXLtoEXE_ThisWbNameExe) _
           Then XLtoEXE_IsThisWbExe = True
    End If
End Function


'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
'" XLtoEXE_SyncProperties() function is used by XLtoEXE to Synchronize properties of this
'" workbook changed at run-time. If you need to change a value of a property, you change it
'" and call this function with True in argument. If it has succces, it will return True.
'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Public Function XLtoEXE_SyncProperties(bChangingProperties As Boolean)
    Static bGettingProperties As Boolean    'True while properties are got.
    If bChangingProperties Then
        bGettingProperties = True
        Dim i As Long
        Application.Interactive = False
        Do While bGettingProperties And i < 20
            i = i + 1
            MyWait 0.5
        Loop
        XLtoEXE_SyncProperties = Not bGettingProperties
        lXLtoEXE_SaveNow = 0: sXLtoEXE_SaveAsExe = "": sXLtoEXE_SaveCopyAsExe = ""
        Application.Interactive = True
    Else
        XLtoEXE_SyncProperties = Array(bGettingProperties, lXLtoEXE_AutoReopen, _
                                       lXLtoEXE_WaitReopen, sXLtoEXE_CmdLineReopen, lXLtoEXE_AvoidAccessVBE, _
                                       lXLtoEXE_SaveNow, sXLtoEXE_SaveAsExe, sXLtoEXE_SaveCopyAsExe, sXLtoEXE_TrustWbNames)
    End If
    bGettingProperties = False
End Function

'Sub MyWait(PauseSeg As Double)
'    Dim Start
'    Start = Timer
'    Do While Timer < Start + PauseSeg
'        DoEvents
'    Loop
'End Sub






Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    If ActiveSheet.ProtectContents Then Application.GoTo Cells(Target.Row, 1)
End Sub

Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    If ActiveSheet.ProtectContents Then Application.GoTo Cells(Target.Row, 1)
End Sub

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()



'To complete uninstall if fail
    Dim sTempFile As String
    sTempFile = TempFolder() & "\" & sAddInNameByApp & "DllPath.tmp"
    'Ontime foi necess|fffd|rio porque um bug no Excell2000 dispara o evento apesar de
    'EnableEvents=false n|fffd|o liberando a outra execu|fffd||fffd|o do Excel para fechar
    If Dir(sTempFile) <> "" Then Application.OnTime Now() + TimeValue("00:00:01"), "UnInstall"

    If XLtoEXE_IsThisWbExe() Then
        If sXLtoEXE_CmdLineReopen = "Install" Then PleaseWaitExeIndep False: PleaseWait True: Application.OnTime Now() + TimeValue("00:00:01"), "Install"
        If sXLtoEXE_CmdLineReopen = "UnInstall" Then PleaseWaitExeIndep False: PleaseWait True: Application.OnTime Now() + TimeValue("00:00:01"), "UnInstall"
    End If

    ButtonLanguage True
    ThisWorkbook.Saved = True
End Sub

Attribute VB_Name = "UserFormAddInOpts"
Attribute VB_Base = "0{FE555A0B-913A-449E-ADFA-2833B71487DF}{56FE2050-B594-4523-A077-FF72186004B3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim EmailSubj As String
Dim HomePageUrl As String

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then BotAcionado = 0
End Sub
Private Sub Cancel_Bt_Click()
    BotAcionado = 0
    Unload Me
End Sub

Private Sub COMAddIn_Bt_Click()
    If IsOffice64_bit Then    'Office 32-bit version required to install COM add-in
        If IsPortg Then
            Msg1 = "Esta vers|fffd|o do " & sAppTarget & " 64-bit ainda n|fffd|o suporta os atuais suplementos COM!" _
                 & vbCrLf & vbCrLf & "Obs.: Voc|fffd| est|fffd| certo que necessita usar o " & sAppTarget & " 64-bit? A Microsoft recomenda a vers|fffd|o 32-bit exceto em grande quantidade de dados que possa superar seus limites. A vers|fffd|o 32-bit, al|fffd|m de mais completa, |fffd| perceptivelmente t|fffd|o r|fffd|pida quanto |fffd| de 64-bit, mesmo rodando em Windows 64-bit." _
                 & vbCrLf & vbCrLf & "Continuar para instalar como Suplemento EXE. OK?"
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "This version of " & sAppTarget & " 64-bit does not support the existing COM add-ins yet!" _
                 & vbCrLf & vbCrLf & "Note: Are you sure that you need to use " & sAppTarget & " 64-bit? Microsoft recommends the 32-bit version except in large amount of data that can overcome its limits. The 32-bit version, beyond more complete, is noticeably as fast as 64-bit version even if running on Windows 64-bit." _
                 & vbCrLf & vbCrLf & "Continue to install as EXE Add-in. OK?"
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then EXEAddIn_Bt_Click
        Exit Sub
    End If

    BotAcionado = 1
    Unload Me
End Sub

Private Sub EXEAddIn_Bt_Click()
    BotAcionado = 2
    Unload Me
End Sub

Private Sub AddIn_Bt_Click()
    BotAcionado = 3
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    COMAddIn_Bt.Enabled = (sCOMAddInFileName <> "" And Dir(PathTemp & "\" & sCOMAddInFileName) <> "")
    EXEAddIn_Bt.Enabled = (sEXEAddInFileName <> "" And Dir(PathTemp & "\" & sEXEAddInFileName) <> "")
    AddIn_Bt.Enabled = (sAddInFileName <> "" And Dir(PathTemp & "\" & sAddInFileName) <> "")

    If IsPortg Then
        Caption = sAddInCaptByAppPt & " - Instala|fffd||fffd|o - Selecionar uma Op|fffd||fffd|o de Suplemento"
        AddIn_Bt.Caption = Replace(AddIn_Bt.Caption, "OfficeApp", sAppTarget): AddIn_Bt.Caption = Replace(AddIn_Bt.Caption, "PowerPoint", "PPoint")
        Details_Lb.Caption = Replace(Details_Lb.Caption, "OfficeApp", sAppTarget): Details_Lb.Caption = Replace(Details_Lb.Caption, "PowerPoint", "PPoint")

        Feature3_Lb.Caption = Replace(Feature3_Lb.Caption, "OfficeApp", sAppTarget)
        Feature6_Lb.Caption = Replace(Feature6_Lb.Caption, "OfficeApp", sAppTarget)
        Feature7_Lb.Caption = Replace(Feature7_Lb.Caption, "OfficeApp", sAppTarget)

        COMAddIn_Feature1_Lb.Caption = IIf(COMAddIn_Bt.Enabled, "Sim", "N|fffd|o"): If Not COMAddIn_Bt.Enabled Then COMAddIn_Feature1_Lb.BackColor = RGB(255, 0, 0)
        If IsOffice64_bit Then COMAddIn_Feature3_Lb.BackColor = RGB(255, 0, 0)
        EXEAddIn_Feature1_Lb.Caption = IIf(EXEAddIn_Bt.Enabled, "Sim", "N|fffd|o"): If Not EXEAddIn_Bt.Enabled Then EXEAddIn_Feature1_Lb.BackColor = RGB(255, 0, 0)
        AddIn_Feature1_Lb.Caption = IIf(AddIn_Bt.Enabled, "Sim", "N|fffd|o"): If Not AddIn_Bt.Enabled Then AddIn_Feature1_Lb.BackColor = RGB(255, 0, 0)

        EXEAddIn_Feature8_Lb.Caption = Right(sEXEAddInFileName, 3) & "/exe"
        AddIn_Feature8_Lb.Caption = Right(sEXEAddInFileName, 3)
        AddIn_Feature1_Lb.Caption = IIf(AddIn_Bt.Enabled, "Yes", "No"): If Not AddIn_Bt.Enabled Then AddIn_Feature1_Lb.BackColor = RGB(255, 0, 0)
    Else
        Caption = sAddInCaptByApp & " - Installation - Choose an Add-in Option"
        InstallAs_Lb.Caption = "Install as:"
        COMAddIn_Bt.Caption = "COM Add-in"
        EXEAddIn_Bt.Caption = "EXE Add-in"
        AddIn_Bt.Caption = sAppTarget & " Add-in"
        Cancel_Bt.Caption = "Cancel"
        ShowDetails_Chb.Caption = "Show details comparing Add-ins options and availability:"

        Details_Lb.Caption = "Here you can have three add-in options: EXE Add-in, COM Add-in, or OfficeApp Add-in. The latter two run on Windows in the same process or memory space of OfficeApp and are well detailed technologies in OfficeApp documentation and in good books about VBA, while EXE Add-in is a special name here for a mix of those two technologies where the same VBA code is run in separate EXE process and a small OfficeApp Add-in makes the connection between the two processes. Despite the differences in the technologies, this utility is fully functional in any of them. So, what can decide on your choice are the features below compared:"
        Details_Lb.Caption = Replace(Details_Lb.Caption, "OfficeApp", sAppTarget)
        If sAppTarget <> "PowerPoint" Then Details_Lb.Height = Details_Lb.Height - 8

        Feature1_Lb.Caption = "- Availability in this package:"
        Feature2_Lb.Caption = "- Requires rights elevation in Windows:"
        Feature3_Lb.Caption = "- " & sAppTarget & " 64-bit supportability:"
        Feature4_Lb.Caption = "- Performance in the load:"
        Feature5_Lb.Caption = "- Performance in the functionalities:"
        Feature6_Lb.Caption = "- Interference in the " & sAppTarget & " performance:"
        Feature7_Lb.Caption = "- Risk of " & sAppTarget & " crash:"
        Feature8_Lb.Caption = "- Main file extension:"

        COMAddIn_Feature1_Lb.Caption = IIf(COMAddIn_Bt.Enabled, "Yes", "No"): If Not COMAddIn_Bt.Enabled Then COMAddIn_Feature1_Lb.BackColor = RGB(255, 0, 0)
        COMAddIn_Feature2_Lb.Caption = "Yes"
        COMAddIn_Feature3_Lb.Caption = "No": If IsOffice64_bit Then COMAddIn_Feature3_Lb.BackColor = RGB(255, 0, 0)
        COMAddIn_Feature4_Lb.Caption = "Great"
        COMAddIn_Feature5_Lb.Caption = "Great"
        COMAddIn_Feature6_Lb.Caption = "Little"
        COMAddIn_Feature7_Lb.Caption = "Low"
        COMAddIn_Feature8_Lb.Caption = "dll"

        EXEAddIn_Feature1_Lb.Caption = IIf(EXEAddIn_Bt.Enabled, "Yes", "No"): If Not EXEAddIn_Bt.Enabled Then EXEAddIn_Feature1_Lb.BackColor = RGB(255, 0, 0)
        EXEAddIn_Feature2_Lb.Caption = "No"
        EXEAddIn_Feature3_Lb.Caption = "Yes"
        EXEAddIn_Feature4_Lb.Caption = "Great"
        EXEAddIn_Feature5_Lb.Caption = "Good/great"
        EXEAddIn_Feature6_Lb.Caption = "Very little"
        EXEAddIn_Feature7_Lb.Caption = "Very low"
        EXEAddIn_Feature8_Lb.Caption = Right(sEXEAddInFileName, 3) & "/exe"

        AddIn_Feature1_Lb.Caption = IIf(AddIn_Bt.Enabled, "Yes", "No"): If Not AddIn_Bt.Enabled Then AddIn_Feature1_Lb.BackColor = RGB(255, 0, 0)
        AddIn_Feature2_Lb.Caption = "No"
        AddIn_Feature3_Lb.Caption = "Yes"
        AddIn_Feature4_Lb.Caption = "Poor"
        AddIn_Feature5_Lb.Caption = "Great"
        AddIn_Feature6_Lb.Caption = "Medium"
        AddIn_Feature7_Lb.Caption = "Medium"
        AddIn_Feature8_Lb.Caption = Right(sEXEAddInFileName, 3)
    End If

    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")

    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp
    Email_Lb.Left = Width - Email_Lb.Width - (Width - InsideWidth) - 4    'Email_Lb.Left = Width - Email_Lb.Width - 8

    Height = 46 + (Height - InsideHeight)       'Height = 70
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub ShowDetails_Chb_Click()
    If ShowDetails_Chb.Value Then
        Height = 265 + (Height - InsideHeight)       'Height = 289
        InstallAs_Lb.Top = 127.5
        COMAddIn_Bt.Top = 123
        EXEAddIn_Bt.Top = 123
        AddIn_Bt.Top = 123

        EXEAddIn_Bt.Left = EXEAddIn_Feature1_Lb.Left + EXEAddIn_Feature1_Lb.Width - EXEAddIn_Bt.Width
        COMAddIn_Bt.Left = COMAddIn_Feature1_Lb.Left + COMAddIn_Feature1_Lb.Width - COMAddIn_Bt.Width
        AddIn_Bt.Left = AddIn_Feature1_Lb.Left + AddIn_Feature1_Lb.Width - AddIn_Bt.Width
        InstallAs_Lb.Left = EXEAddIn_Bt.Left - InstallAs_Lb.Width - 5
    Else
        Height = 46 + (Height - InsideHeight)       'Height = 70
        InstallAs_Lb.Top = 9.5
        COMAddIn_Bt.Top = 5
        EXEAddIn_Bt.Top = 5
        AddIn_Bt.Top = 5

        InstallAs_Lb.Left = 5
        COMAddIn_Bt.Left = 58
        EXEAddIn_Bt.Left = 151.4
        AddIn_Bt.Left = 245.8
    End If
End Sub



Attribute VB_Name = "UserFormInst"
Attribute VB_Base = "0{A8EDAD52-D477-478C-B443-C684656CE87F}{C2AD67F8-1A5C-465D-A517-552BEB01F067}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim EmailSubj As String
Dim HomePageUrl As String

Private Sub Instal_Bt_Click()
    If IsPortg Then
        Msg1 = "CONTRATO DE LICEN|fffd|A DE USO:" & vbCrLf & _
               "Antes de acionar o bot|fffd|o OK para efetivar a instala|fffd||fffd|o, voc|fffd| deve ler e concordar com alguns termos e condi|fffd||fffd|es abaixo relacionados. Caso n|fffd|o concorde ou n|fffd|o se enquadre com algum destes termos e condi|fffd||fffd|es, acione o bot|fffd|o Cancelar para suspender a instala|fffd||fffd|o." & vbCrLf & _
               "1 - Voc|fffd| se compromete a N|fffd|O distribuir este utilit|fffd|rio, mas agrade|fffd|o recomenda|fffd||fffd|es a amigos para uma visita ao meu site em http://cpap.com.br/orlando/ (veja link no canto esquerdo inferior deste alerta) onde eles mesmos podem baixar este e outros;" & vbCrLf & _
               "2 - Embora n|fffd|o preste suporte, |fffd| bem vindo qualquer email com sugest|fffd|es para melhoramentos, mas n|fffd|o espere resposta, pelo menos de imediato. Email de agradecimento para alimenta|fffd||fffd|o do ego tamb|fffd|m |fffd| bem vindo, afinal est|fffd| |fffd| a |fffd|nica recompensa pelas horas, neur|fffd|nios e vista despendidos frente ao computador;" & vbCrLf & _
               "3 - Voc|fffd| deve ter baixado (download) o arquivo diretamente de meu site em http://cpap.com.br/orlando/ (veja link no canto esquerdo inferior deste alerta)  e que o tamanho do arquivo em bytes em seu computador corresponde ao descrito no site. Isto |fffd| um importante ind|fffd|cio de que o arquivo n|fffd|o foi alterado por v|fffd|rus, mas s|fffd| um ind|fffd|cio, pois o seu sistema eventualmente j|fffd| pode conter v|fffd|rus ou o v|fffd|rus pode inteligentemente ter conservado o tamanho original do arquivo;" & vbCrLf & _
               "4 - Este utilit|fffd|rio |fffd| oferecido gratuitamente para pessoas f|fffd|sicas em meu site tal como est|fffd| sem nenhum tipo de garantia, n|fffd|o cabendo nenhuma reclama|fffd||fffd|o de sua parte sobre suporte e preju|fffd|zos de qualquer natureza no uso ou abuso do mesmo;" & vbCrLf & _
               "5 - Voc|fffd| assume todos os riscos resultantes do uso ou do desempenho deste utilit|fffd|rio e de qualquer servi|fffd|o de suporte;" & vbCrLf & _
               "6 - Na extens|fffd|o m|fffd|xima permitida pela legisla|fffd||fffd|o aplic|fffd|vel, me isento de todas as condi|fffd||fffd|es e garantias relacionadas a:  comercializa|fffd||fffd|o, adequa|fffd||fffd|o a uma finalidade espec|fffd|fica, aus|fffd|ncia de v|fffd|rus, respostas e resultados completos e corretos e aus|fffd|ncia de esfor|fffd|o de aprimoramento;" & vbCrLf & _
               "7 - Na extens|fffd|o m|fffd|xima permitida pela legisla|fffd||fffd|o aplic|fffd|vel, em nenhuma hip|fffd|tese eu serei respons|fffd|vel por quaisquer danos especiais, incidentais, indiretos, punitivos ou conseq|fffd|enciais (incluindo, sem limita|fffd||fffd|es, danos por: lucros cessantes, perda de informa|fffd||fffd|es confidenciais ou outras, interrup|fffd||fffd|o nos neg|fffd|cios, danos pessoais, perda de privacidade, falha no cumprimento de qualquer obriga|fffd||fffd|o (inclusive de boa f|fffd| e com cuidados razo|fffd|veis), neglig|fffd|ncia e qualquer outra perda financeira ou de qualquer natureza) resultantes do ou de qualquer forma relacionados com o uso ou inabilidade no uso deste utilit|fffd|rio;" & vbCrLf & _
               "8 - Caso a legisla|fffd||fffd|o vigente n|fffd|o permita a total isen|fffd||fffd|o acima descrita, fica ent|fffd|o minha responsabilidade limitada ao valor efetivamente pago por voc|fffd| a mim por este utilit|fffd|rio ou R10,00 (dez reais) em moeda brasileira o que for maior;" & vbCrLf & _
               "9 - Como j|fffd| frisei acima, a gratuidade deste utilit|fffd|rio se destina exclusivamente para pessoas f|fffd|sicas. Pessoas jur|fffd|dicas, sejam p|fffd|blicas ou privadas, devem adquirir uma licen|fffd|a de uso. Favor entrar em contato clicando no email orlando@cpap.com.br no canto direito inferior deste alerta;" & vbCrLf & _
               "10 - Fora das condi|fffd||fffd|es acima descritas, n|fffd|o |fffd| permitida a utiliza|fffd||fffd|o, a reprodu|fffd||fffd|o, a modifica|fffd||fffd|o ou a distribui|fffd||fffd|o n|fffd|o autorizada no todo e de partes  deste utilit|fffd|rio, estando sujeito |fffd|s penalidades da lei em vigor sobre direitos autorais. Copyright by Francisco Orlando Magalh|fffd|es Filho. Todos os direitos reservados."

        Msg2 = sAddInCaptByAppPt & " - Contrato de Licen|fffd|a de Uso"
    Else
        Msg1 = "USE LICENSE AGREEMENT:" & vbCrLf & _
               "Before to action the OK button to effective the installation, you have to read and concord with some terms and conditions that will be listed below. If you do not concord or do not fit with some of this terms and conditions, action the Cancel button to suspend the installation." & vbCrLf & _
               "1 - You commit yourself with not deliver this utility, but I thank recommendations to your friends to visit my site at http://cpap.com.br/orlando/ (see link at left down corner of this alert) where they same can download this and others ones;" & vbCrLf & _
               "2 - Although I don't offer support, it is welcome any email with suggestions to improvements, but don't wait reply, at least of immediate. Email with thanks to feed the ego is welcome too, after all this is the unique reward by hours, neurons and eyes wasted in front of the computer;" & vbCrLf & _
               "3 - You have to have downloaded the file directly from my site at http://cpap.com.br/orlando/ (see link at left down corner of this alert) and that file size in bytes on your computer correspond with described on site. This is a important indication that the file wasn't changed by virus, but only an indication, since your system eventually already can contain virus or the virus can have preserved the original file size;" & vbCrLf & _
               "4 - This utility is offered freely for home user at my site AS IS without any warranty, do not fit any claim from you about support and loss of any kind in use or abuse of the same;" & vbCrLf & _
               "5 - You assume all consequent risks of the use or of the performance of this utility and of the any support service;" & vbCrLf & _
               "6 - In maximum extension allowed by applicable legislation, I absolve myself of all the conditions and warranties related with: commercialization, adequacy to a specific purpose, virus absence, complete and correct replies, complete and correct results and effort improvement absence;" & vbCrLf & _
               "7 - In maximum extension allowed by applicable legislation, in any hypothesis I will be responsible by any special, incidental, indirect, punitive or consequential harms (including, without limitations, harms by: ceasing profits, loss of confidential data or others, interruption in businesses, personal harms, loss of privacy, fault in the fulfillment of any obligation (inclusively of good faith and with reasonable attendances), negligence and any other financial loss or of any kind) resulting of or any form related with the use or  inabilities of the use this utility;" & vbCrLf & _
               "8 - Case the current legislation do not allow the total immunity above written, it stays then my responsibility limited to the value effectively paid by you to me for this utility or R$ 10,00 (ten reais) in Brazilian currency what will be the larger;" & vbCrLf & _
               "9 - How I already emphasize above, the free of charge of this utility is exclusively to home users. Public or private companies have to acquire a use license. Please contact clicking orlando@cpap.com.br email in the right down corner of this alert;" & vbCrLf & _
               "10 - Outside above written conditions, it is not allowed the unauthorized utilization, reproduction, modification or distribution of the whole and parts of this utility, being subject to current law penalty about international author rights. Copyright by Francisco Orlando Magalh|fffd|es Filho. All rights reserved."
        Msg2 = sAddInCaptByApp & " - Use License Agreement"
    End If
    If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub
    BotAcionado = 1
    Hide
End Sub

Private Sub Cancel_Bt_Click()
    BotAcionado = 3
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    Dim sStartUp As String
    Dim i As Integer
    sStartUp = sStartupPath
    For i = Len(sStartUp) - 2 To 1 Step -1
        If Mid(sStartUp, i, 1) = "\" Then Exit For
    Next
    sStartUp = UCase(Mid(sStartUp, i + 1, 255))
    Xlstart_OpB.Enabled = Not bIsCOMAddin And Not bIsEXEAddIn
    AsAddIn_OpB.Value = True
    If IsPortg Then
        Caption = sAddInCaptByAppPt & " - Instala|fffd||fffd|o como " & IIf(bIsCOMAddin, "Suplemento COM (dll)", IIf(bIsEXEAddIn, "Suplemento EXE (" & Right(sEXEAddInFileName, 3) & "/exe)", "Suplemento Padr|fffd|o (" & Right(sAddInFileName, 3) & ")"))
        Frame1.Caption = "Instalar Arquivo na Pasta: "
        Xlstart_OpB.Caption = sStartUp & ", pasta padr|fffd|o do " & sAppTarget & ", para ser carregado pelo " & sAppTarget & " ao iniciar"
        AsAddIn_OpB.Caption = "EXCLUSIVA, descrita abaixo, para ser carregado pelo " & sAppTarget & " como " & IIf(bIsCOMAddin, "Suplemento COM", "Suplemento") & " instalado:"
        BrowserFld_Lb.ControlTipText = "Procurar pasta"
        AllWinUsers_Chb.Caption = "Para todos os usu|fffd|rios deste Windows, inclusive os sem n|fffd|vel de administrador"
        Cancel_Bt.Caption = "Cancelar"
        Instal_Bt.Caption = "Continuar"
    Else
        Caption = sAddInCaptByApp & " - Installation as " & IIf(bIsCOMAddin, "COM Add-in (dll)", IIf(bIsEXEAddIn, "EXE Add-in (" & Right(sAddInFileName, 3) & "/exe)", "Add-in (" & Right(sAddInFileName, 3) & ")"))
        Frame1.Caption = "Install File in the Folder: "
        Xlstart_OpB.Caption = sStartUp & ", " & sAppTarget & " default folder, to be loaded by " & sAppTarget & " when starting up"
        AsAddIn_OpB.Caption = "EXCLUSIVE, described below, to be loaded by " & sAppTarget & " as installed " & IIf(bIsCOMAddin, "COM ", "") & "add-in:"
        AllWinUsers_Chb.Caption = "For all users of this Windows, inclusive the ones without level of administrator"
        BrowserFld_Lb.ControlTipText = "Search folder"
        Cancel_Bt.Caption = "Cancel"
        Instal_Bt.Caption = "Continue"
    End If

    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")

    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & " - " & IIf(bIsCOMAddin, "COM Add-in (dll)", IIf(bIsEXEAddIn, "EXE Add-in (" & Right(sAddInFileName, 3) & "/exe)", "Add-in (" & Right(sAddInFileName, 3) & ")"))
    Email_Lb.Left = Width - Email_Lb.Width - (Width - InsideWidth) - 4    'Email_Lb.Left = Width - Email_Lb.Width - 8
    If Not IsWinNT("Any") Or Not bIsCOMAddin Then AllWinUsers_Chb.Enabled = False: AllWinUsers_Chb.Value = False
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then BotAcionado = 3
End Sub

Private Sub BrowserFld_Lb_Click()
    Dim sFolderName As String

    If IsPortg Then
        Msg1 = "A menos que voc|fffd| tenha uma raz|fffd|o espec|fffd|fica para mudar a pasta para instala|fffd||fffd|o, o melhor seria usar a pasta sugerida como padr|fffd|o." & vbCrLf & vbCrLf & "Indicar outra pasta assim mesmo?"
        Msg2 = sAddInCaptByAppPt & " - Alterar Pasta para Instala|fffd||fffd|o!"
    Else
        Msg1 = "Unless you have a specific reason to change the folder for installation, the best would be to use the suggested folder as the default." & vbCrLf & vbCrLf & "Select another folder anyway?"
        Msg2 = sAddInCaptByApp & " - Change Folder for Installation!"
    End If
    If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub

    sFolderName = GetFolderName(IIf(IsPortg, "Indique a pasta para instala|fffd||fffd|o.", "Select the folder for installation."), "")
    If sFolderName <> "" Then folder_Tb.Value = sFolderName
End Sub

Function GetFolderName(sSubTitle As String, IniRootFolder As String) As String
    Dim ShAppObj, ShAppObjFld
    Const BIF_returnonlyfsdirs As Long = &H1
    Set ShAppObj = CreateObject("Shell.Application")    'From Microsoft Shell Controls And Automation library
    Set ShAppObjFld = ShAppObj.BrowseForFolder(FindWindow("ThunderDFrame", Caption), sSubTitle, BIF_returnonlyfsdirs, CStr(IniRootFolder))
    If Not ShAppObjFld Is Nothing Then GetFolderName = ShAppObjFld.Items.Item.Path
End Function

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub
Attribute VB_Name = "UserFormWait"
Attribute VB_Base = "0{14CFA018-476B-4660-B9C1-C3CAC958FCCA}{A23E71C6-1C0A-4D5B-BF5A-4031F7C70068}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


' InQuest injected base64 decoded content
' ]"sZ
' RprE

INQUEST-PP=macro
