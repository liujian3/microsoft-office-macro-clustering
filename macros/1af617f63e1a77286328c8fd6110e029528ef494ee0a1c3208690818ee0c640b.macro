Attribute VB_Name = "ClassPopMenuEv"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Class module to hook pop menus

Private WithEvents cbbButton As Office.CommandBarButton
Attribute cbbButton.VB_VarHelpID = -1

Private Sub Class_Initialize()
    Set cbbButton = appHostApp.CommandBars.FindControl(Tag:="PopMenuTag")
End Sub

Private Sub Class_Terminate()
    Set cbbButton = Nothing
End Sub

Private Sub cbbButton_Click(ByVal Ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    If Ctrl.Tag = "PopMenuTag" Then
        PopMenuOpt = CLng(Mid(Ctrl.Parameter, Len("PopMenuClick1")))
        CancelDefault = True
    End If
End Sub

Attribute VB_Name = "FormMyMsgBox"
Attribute VB_Base = "0{49779522-B6E3-4FAD-9452-597C0ED50ED7}{D4ED30A7-424E-4477-8EE2-404C30A67234}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public EmailSubj As String
Public HomePageUrl As String
Public lBut As Long
'Public Xpos As Long  xxxxx
'Public Ypos As Long  xxxxx
Public App_hWnd1 As Long: Dim Form_hWnd1 As Long: Public lWaitAndRetValue As Long: Public bAlwaysOnTop As Boolean

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub Ok_Bt_Click()
    BotAcionado = 1
    If lWaitAndRetValue = 2 Then Hide Else Unload Me
End Sub
Private Sub Cancel_Bt_Click()
    BotAcionado = 2
    If lWaitAndRetValue = 2 Then Hide Else Unload Me
End Sub

Private Sub Ignore_Bt_Click()
    BotAcionado = 3
    If lWaitAndRetValue = 2 Then Hide Else Unload Me
End Sub

Private Sub UserForm_Activate()
    Dim CountLines As Long
    Dim Lins
    Dim l As Long

    With Alert_Tb
        .Width = 284
        Lins = MySplit(.Text, vbCrLf)        'Lins = Split(.Text, vbCrLf)
        For l = 0 To UBound(Lins)
            CountLines = CountLines + 1 + Int(Len(Lins(l)) / 70)    '75
        Next
        .Height = (1 + CountLines) * 12
        If .Height > 16 * 12 Then
            .Height = 15 * 12
            .SpecialEffect = fmSpecialEffectSunken
            .SetFocus
            .SelStart = 0
        End If
    End With



    Icon_Lb.Caption = IIf(lBut <> 1, "?", "i")
    Cancel_Bt.Visible = lBut <> 1
    Ignore_Bt.Visible = lBut = 3

    Ok_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "Sim", "Yes"), "OK")
    Cancel_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "N|fffd|o", "No"), IIf(IsPortg, "Cancelar", "Cancel"))
    Ignore_Bt.Caption = IIf(IsPortg, "Ignorar", "Ignore")

    Ok_Bt.Top = Alert_Tb.Top + Alert_Tb.Height + 5
    Cancel_Bt.Top = Ok_Bt.Top
    Ignore_Bt.Top = Ok_Bt.Top
    HomePage_Lb.Top = Ok_Bt.Top + 7.5
    Email_Lb.Top = HomePage_Lb.Top
    Email_Lb.Left = Width / Twips - Email_Lb.Width - (Width / Twips - InsideWidth) - 4    'Email_Lb.Left = Width / Twips - Email_Lb.Width - 8    'Em COM add-in |fffd| preciso transformar width e height em Twips
    Height = (HomePage_Lb.Top + Ok_Bt.Height) * Twips + (Height - InsideHeight * Twips) - 1 * Twips    'Height = (HomePage_Lb.Top + Ok_Bt.Height) * Twips + (Height - InsideHeight * Twips - (Width - InsideWidth * Twips) / 2) + 2 * Twips  'Entre parentese: altura da barra de t|fffd|tulo(caption)
    If lBut = 1 Then Ok_Bt.Left = 135
    If lBut = 2 Then Ok_Bt.Left = 90: Cancel_Bt.Left = 180
    '    If Xpos <> 0 Then Left = Xpos    xxxxx
    '    If Ypos <> 0 Then Top = Ypos     xxxxx

    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)

    'Basear o form na janela do Excel. Depois da op|fffd||fffd|o bUnanchExcelWin sempre no form que chamou OnTop se
    SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd1: If bAlwaysOnTop Then SetWindowPos Form_hWnd1, HWND_TOPMOST, 0, 0, 0, 0, flags    'If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then BotAcionado = IIf(Cancel_Bt.Visible, 2, 1): If Ignore_Bt.Visible Then BotAcionado = 3    'Cancel = 1 'Ao fechar pelo X do form, se houver bot|fffd|o ignorar pode desabilitar o controle ou o bot|fffd|o ignorar passa ser Cancel padr|fffd|o, preferi assim.
End Sub

Attribute VB_Name = "Mod1Stopwatch"
Option Explicit
Public Const VerDate As Date = #7/18/2017#
Public IniDate As Date
Public bIsCOMAddin As Boolean: Public bCOMinDebug As Boolean
'Public ObjToVBA As StopwatchObjToVBA    'Esse m|fffd|d. de class n|fffd|o |fffd| necess|fffd|rio em add-in. Remover e comentar essa linha

'Declara|fffd||fffd|es API
Declare Function GetKeyState Lib "user32" (ByVal vKey As Integer) As Integer
Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hdc As Long) As Long
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Public Const SM_CXSCREEN = 0
Public Const SM_CYSCREEN = 1
Const LOGPIXELSX = 88        '  Logical pixels/inch in X
Const LOGPIXELSY = 90        '  Logical pixels/inch in Y

Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Type POINTAPI
    X As Long
    Y As Long
End Type
Public ScreenRx As Long
Public ScreenRy As Long

Declare Function sndPlaySound32 Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
'uFlags can be one these value or a sum:
'&H0 - SND_SYNC - played synchronously (Not return until the sound ends)
'&H1 - SND_ASYNC - played asynchronously.
'&H2 - SND_NODEFAULT - if the sound cannot be found, the function returns silently without playing the default sound.
'&H8 - SND_LOOP - continue to play continuously until sndPlaySound is called again with the lpszSoundName$ parameter set to null. You must also specify the SND_ASYNC flag to loop sounds.
'&H10 - SND_NOSTOP - if a sound is currently playing, the function will immediately return False without playing the requested sound.

Public Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hWnd As Long) As Long
Public Declare Function GetActiveWindow Lib "user32" () As Long
Public Declare Function SetWindowText Lib "user32" Alias "SetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String) As Long

'Public EventApp As New ClassEventApp
'Public vEnableEvents As Boolean
Public OkInsert As Boolean
'Public HotKey As String




'Declara|fffd||fffd|es p|fffd|blicas para a Cron|fffd|metro
Public CronometroPosTop As Long, CronometroPosLeft As Long
Public CronometroElapsedIni As Variant, CronometroElapsedAtu As String
Public vModalChange As Boolean
Public vShowingModeless As Boolean
Public bCallBYfStopwatchIni As Boolean
Public bFromAutoPopCellIni As Boolean    'Informa que veio de autopopup de sele|fffd||fffd|o de cell
Public WavFile As String

Public PopMenuOpt As Long
Public sAddInNameByApp As String  'ExcelStopwatch
Public sAddInCaptByApp As String  'ExcelStopwatch for Excel, Cron|fffd|metro para Excel
Public AddInTitle As String  'Orlando's ExcelStopwatch

Public bAlertAboutNewVer As Boolean
Public bArrKeysCancel As Boolean
Public sDecimalSep As String
Public sThousandsSep As String

Public bGetLastSetFail As Boolean
Public sIniDateChk As String    'Para garantir a integridade da data
Public sLastDisplay As String, dbLastElapsed As Double









Public appHostApp     'As PowerPoint.Application  'As Word.Application  'As Application falha no word
Public Twips As Long
Public CmdBarBut As Office.CommandBarButton
Public vClassPopMenuEv As ClassPopMenuEv
Public bReleasedModeless As Boolean    'Be free from created modeless procedure. Good to release the menu
Public sDLLProgId As String
Public dHostAppVer As Double
Public App_hWnd As Long
'Public Form_hWnd As Long

Public sINIfile As String
Public sPathSep As String
Public hFile As Long
Public sFileDescr As String

Private Declare Function GetTempPath Lib "kernel32" _
                                     Alias "GetTempPathA" (ByVal nBufferLength As Long, _
                                                           ByVal lpBuffer As String) As Long

Public Const GWL_HWNDPARENT As Long = -8
Private Const GWL_STYLE = (-16)
Private Const WS_THICKFRAME = &H40000
Private Const WS_MINIMIZEBOX = &H20000
Private Const WS_MAXIMIZEBOX = &H10000
Private Const GWL_EXSTYLE = (-20)
Public Const WS_CAPTION As Long = &HC00000
Public Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Public Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Public Declare Function SetForegroundWindow Lib "user32" (ByVal hWnd As Long) As Long

'Public Const WS_BORDER = &H800000
'Public Const WS_DLGFRAME = &H400000
'Public Const WS_EX_CLIENTEDGE = &H200
'Public Const WS_EX_LAYERED = &H80000
'Public Const LWA_ALPHA = &H2&
'Public Const WS_EX_WINDOWEDGE = &H100
Public Const WS_EX_STATICEDGE = &H20000
Public Const WS_EX_APPWINDOW As Long = &H40000   'Show on taskbar
Public Const WS_EX_TOOLWINDOW As Long = &H80     'Tool Window (Small titlebar withoud any control except Close control)
'Public Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Public Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Public Declare Function GetClientRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long
Public Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long
Public Declare Function AdjustWindowRectEx Lib "user32" (lpRect As RECT, ByVal dsStyle As Long, ByVal bMenu As Long, ByVal dwEsStyle As Long) As Long
Public Declare Function MoveWindow Lib "user32" (ByVal hWnd As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Public Declare Function BeginDeferWindowPos Lib "user32" (ByVal nNumWindows As Long) As Long
Public Declare Function DeferWindowPos Lib "user32" (ByVal hWinPosInfo As Long, ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
Public Declare Function EndDeferWindowPos Lib "user32" (ByVal hWinPosInfo As Long) As Long

Public Const SWP_NOMOVE = 2
Public Const SWP_NOSIZE = 1
Public Const flags = SWP_NOMOVE Or SWP_NOSIZE
Public Const HWND_BOTTOM = 1
Public Const HWND_TOP = 0
Public Const SWP_SHOWWINDOW = &H40
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2

Declare Function EnumChildWindows Lib "user32" (ByVal hWndParent As Long, ByVal lpEnumFunc As Long, ByVal lParam As Long) As Long
Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long

Type WINDOWPLACEMENT
    Length As Long
    flags As Long
    showCmd As Long
    ptMinPosition As POINTAPI
    ptMaxPosition As POINTAPI
    rcNormalPosition As RECT
End Type
Private Declare Function GetWindowPlacement Lib "user32" (ByVal hWnd As Long, lpwndpl As WINDOWPLACEMENT) As Long
Const SW_HIDE = 0
Const SW_SHOWNORMAL = 1
Const SW_NORMAL = 1
Public Const SW_SHOWMINIMIZED = 2
Const SW_SHOWMAXIMIZED = 3
Const SW_MAXIMIZE = 3
Const SW_SHOWNOACTIVATE = 4
Const SW_SHOW = 5
Const SW_MINIMIZE = 6
Const SW_SHOWMINNOACTIVE = 7
Const SW_SHOWNA = 8
Const SW_RESTORE = 9
Const SW_SHOWDEFAULT = 10
Const SW_MAX = 10
Declare Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long

'Api declarations for get mouse button state
Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
Const SM_SWAPBUTTON = 23
Enum MouseButtonConstants
    vbLeftButton = 1
    vbRightButton = 2
    vbMiddleButton = 4
End Enum

Function ScreenResol(lCoord As Long) As Long
    Dim lDC As Long
    Static Resol(1) As Long
    If Resol(0) = 0 Then
        lDC = GetDC(0)
        Resol(0) = GetDeviceCaps(lDC, LOGPIXELSX)
        Resol(1) = GetDeviceCaps(lDC, LOGPIXELSY)
        lDC = ReleaseDC(0, lDC)
    End If
    ScreenResol = Resol(lCoord)
End Function

Sub StopwatchFromCmB()
'Para acionar do menu |fffd| necess|fffd|rio esse OnTime, pois enquanto um c|fffd|digo n|fffd|o finaliza o menu
'do bot|fffd|o acionado fica travado e tamb|fffd|m impede entrada pelo teclado em formul|fffd|rio Modeless
'E ainda em evento ao mostrar ao mostrar formul|fffd|rio o evento em COMAddin n|fffd|o dispara em seguida
'    appHostApp.OnTime Now, ThisWorkbook.Name & "!Stopwatch"
End Sub

Sub Stopwatch()
    Dim fRet
    Dim CountDown As Boolean
    Dim InitialElapsed As Variant 'Na vers|fffd|o 4.0 guarda captura inicial para verif. possib. de countdown para datetime depois da cr|fffd|tica de tempo trabalhando com CronometroElapsedIni, ficando semelhante ao em fStopwatch.

    Dim dNowAtStart As Date, lTickCountAtStart As Long
    dNowAtStart = Now: lTickCountAtStart = GetTickCount()  'Como o log do split acontece com PrintPapel, este deve ficar depois dos processos inicial de cr|fffd|tica, split e cria|fffd||fffd|o do userform que podem demorar, ent|fffd|o guarda o Now junto ao GetTickCount() aqui ao iniciar. Ignorar este gap foi um bug descoberto na vers|fffd|o 4.0.

    If CollectionInst Is Nothing Then Set CollectionInst = New Collection
    If bMultDisable And CollectionInst.Count > 0 Then Exit Sub Else If CollectionInst.Count >= 300 Then Exit Sub    'O VBA parece s|fffd| suportar 307 inst|fffd|ncias, vou limitar silenciosamente em 300.

    If dHostAppVer > 11 + 1 + 2 + 1 + 1 Then
        If IsPortg Then
            Msg1 = "Nova vers|fffd|o do " & appHostApp.Name & " desconhecida para esta vers|fffd|o do " & sAddInCaptByApp & "! Clique no link Ajuda, logo abaixo, para baixar uma nova vers|fffd|o compat|fffd|vel."
            Msg2 = sAddInCaptByApp & " - Falha!"
        Else
            Msg1 = "New " & appHostApp.Name & " version unknown to this " & sAddInCaptByApp & " version! Click Help link, soon below, to download a new compatible version."
            Msg2 = sAddInCaptByApp & " - Fail!"
        End If
        MyMsgBox Msg1, 1, Msg2
        Exit Sub
    End If
    FormPosition

    'Captando e validando dados a partir da c|fffd|lula ativa
    On Error Resume Next
    Select Case appHostApp.Name
    Case "Microsoft Excel"
        If Not bResetAtPopupIni Then If appHostApp.ActiveWindow.ActiveCell.HasFormula Then appHostApp.ActiveWindow.ActiveCell.Calculate    'Implementei na vers|fffd|o 4.0. Acredito que calcular s|fffd| a c|fffd|lula seja suficiente, pois j|fffd| calculate Sheet gera ampuleta ent|fffd|o calculate wb ou CalculateFull e CalculateFullRebuild nem pensar.
        If Not bResetAtPopupIni Then InitialElapsed = appHostApp.ActiveWindow.ActiveCell.Value Else InitialElapsed = 0
        Set rngActCelStartIni = appHostApp.ActiveWindow.ActiveCell    'C|fffd|lula Ativa ao Iniciar
        Set ActShAtPopupIni = appHostApp.ActiveWindow.ActiveSheet    'Planilha ativa ao iniciar

    Case "Microsoft Word"
        If Not bResetAtPopupIni Then InitialElapsed = appHostApp.Selection.Text Else InitialElapsed = 0    'Diferente do Extenso e calculador, o melhor |fffd| capturar s|fffd| a sele|fffd||fffd|o e deixar para o DateValue resolver
    Case "Microsoft PowerPoint"
        If Not bResetAtPopupIni Then InitialElapsed = appHostApp.ActiveWindow.Selection.TextRange.Text Else InitialElapsed = 0
    Case "Microsoft Access"
        If Not bResetAtPopupIni Then InitialElapsed = appHostApp.Screen.ActiveControl.SelText Else InitialElapsed = 0     'Necess|fffd|ria estas tr|fffd|s linhas, pois texto selecionado deve prevalecer e o .value inexplicavel e incostantemente custuma retornar null
        If Not bResetAtPopupIni Then If InitialElapsed = "" Then InitialElapsed = appHostApp.Screen.ActiveControl.Value
        If Not bResetAtPopupIni Then If IsNull(InitialElapsed) Then InitialElapsed = appHostApp.Screen.ActiveControl.Text
    End Select
    On Error GoTo 0

    If vModalIni = "" Or bCallBYfStopwatchIni Then ReadINISetting    'Ler or reler tamb|fffd|m se tiver sido usado por uma instancia chamada por fStopw
    If IsError(InitialElapsed) Then CronometroElapsedIni = 0 Else CronometroElapsedIni = InitialElapsed
    If CronometroElapsedIni = Empty Or IsEmpty(CronometroElapsedIni) Or IsNull(CronometroElapsedIni) Then CronometroElapsedIni = 0    'No PPoint s|fffd| func. IsEmpty e no Access IsNull
    If CronometroElapsedIni <> 0 Then IsTimeExtend CronometroElapsedIni, CronometroElapsedIni, CountDown    'S|fffd| interessa o retorno nos argumentos, pois vai continuar de qualquer jeito.
    bCDtoDTimeIni = False: If IsDate(InitialElapsed) Then If Year(InitialElapsed) > Year(Now) - 10 And Year(InitialElapsed) < Year(Now) + 10 Then CronometroElapsedIni = (CDbl(InitialElapsed) - CDbl(Now)) * 24 * 60 * 60: CountDown = True: bCDtoDTimeIni = True: dbCDtoDTimeIni = CDbl(InitialElapsed): If CronometroElapsedIni < 0 Then CronometroElapsedIni = 0    'Verf. se |fffd| um date/time atual n|fffd|o extrapolando muito ao now, ent|fffd|o vai pra countdown para o mesmo date/time.

    bCallBYfStopwatchIni = False
    Dim UserFormStopwatch1 As UserFormStopwatch
    Set UserFormStopwatch1 = New UserFormStopwatch    'Aqui dispara inicializar

    UserFormStopwatch1.bCntDown = CountDown
    UserFormStopwatch1.lBotPress = 0
    Set UserFormStopwatch1.rngActCelStart = rngActCelStartIni
    Set UserFormStopwatch1.ActShAtPopup = ActShAtPopupIni
    UserFormStopwatch1.bActSplitShAtSplit = bSplitAtPopupIni And Not bSplitInBkGrAtPopupIni
    UserFormStopwatch1.dbElapsed = IIf(bResetAtPopupIni, 0, IIf(bMultDisable And CronometroElapsedIni = 0, dbLastElapsed, CronometroElapsedIni))
    If sLastDisplay <> "" Then sLastDisplay = IIf(bResetAtPopupIni, String(Len(sLastDisplay) - 1, Chr(160)) & "0", sLastDisplay)
    If bStartAtPopupIni Then
        If CountDown Then
            If bCDtoDTimeIni Then dNowAtStart = Now: lTickCountAtStart = GetTickCount() - 400: UserFormStopwatch1.dbElapsed = (CDbl(InitialElapsed) - CDbl(dNowAtStart)) * 24 * 60 * 60: If UserFormStopwatch1.dbElapsed < 0 Then UserFormStopwatch1.dbElapsed = 0    'Calcular novamente para ficar mais exato,pois o now j|fffd| deve ter mudado. Antecipar um delay de -400 foi obtido por tentativa de ajuste a formulas na planilha AuctionCountdown2.xls.
            UserFormStopwatch1.dbStart = lTickCountAtStart / 1000 + UserFormStopwatch1.dbElapsed    'Se contando para uma data, aqui n|fffd|o tem import|fffd|ncia, pois o exato pode e ser|fffd| feito em UserForm_Activate de UserFormStopwatch.
        Else
            UserFormStopwatch1.dbStart = lTickCountAtStart / 1000 - UserFormStopwatch1.dbElapsed
        End If
        If bSplitAtPopupIni Or bSplitInBkGrAtPopupIni Then UserFormStopwatch1.xLbSplit_Click
        UserFormStopwatch1.lBotPress = 1
        UserFormStopwatch1.PrintPapel UserFormStopwatch1.dbElapsed, dNowAtStart, "Popup", "", sLastDisplay
        UserFormStopwatch1.PrintPapel UserFormStopwatch1.dbElapsed, dNowAtStart, IIf(bResetAtPopupIni, "Start", "Restart"), "", sLastDisplay
    Else
        If bSplitAtPopupIni Or bSplitInBkGrAtPopupIni Then UserFormStopwatch1.xLbSplit_Click
        UserFormStopwatch1.lBotPress = IIf(UserFormStopwatch1.dbElapsed = 0, 0, 2)
        UserFormStopwatch1.PrintPapel UserFormStopwatch1.dbElapsed, dNowAtStart, "Popup", "", sLastDisplay
    End If

    vModalIni = 0: UserFormStopwatch1.lWaitAndRetValue = 0    'Em chamadas da IU, n|fffd|o vejo necessidade de retorno de valor pelo c|fffd|digo, ou seja, pode rodar livre em unassycrony way e sempre modeless.
    fRet = fStopwatch1(UserFormStopwatch1)
    If fRet = False And TypeName(fRet) = "Boolean" Then Exit Sub    'Cancel by user
    On Error Resume Next
    'If bSplit Then ActShAtPopup.Activate
    If bInsActCelStartIni And Not rngActCelStartIni Is Nothing Then rngActCelStartIni.Value = fRet Else appHostApp.ActiveWindow.ActiveCell.Value = fRet
    '    bSplit = False
End Sub

Sub testf()
    Dim fRet
    'fStopwatch 0.1, False, True, , , , , , True, "aabb", , "fila"

    fRet = fStopwatch(, , True, , , , , , True, "Sheet3", , , , , , 2)
    'fRet = appHostApp.Run("ExcelStopwatch.xla!fStopwatch", , , False, , , , , , True, "Sheet3")
    '    fStopwatch 0.0001, False, True, , , , True
End Sub

Function fStopwatch(Optional InitialElapsed, Optional ResetAtPopup, _
                    Optional StartAtPopup, Optional DisplaySize, _
                    Optional DisplayMode, Optional DecimalPlaces, _
                    Optional CountDown, Optional PaperRibbon, _
                    Optional SplitA, Optional SplitSheet, _
                    Optional SplitWorkbook, Optional SplitStartCellRef, _
                    Optional ActivateSplitSheet, Optional LeftPos, Optional TopPos, _
                    Optional ShareSplitSheet, Optional WaitAndRetValue, Optional CtrlPanelSize, _
                    Optional StopInsMode, Optional SnapshotSetting, Optional SavedSettingFile, _
                    Optional ResetMode, Optional OtherButtsMode, Optional CellAsButTriggSlc, _
                    Optional EchoDisplayInCell, Optional SkinSetting, Optional CountdownSetting)

    If IsMissing(ResetAtPopup) Then ResetAtPopup = True Else ResetAtPopup = CBool(ResetAtPopup) 'Na vers|fffd|o 4.0 possibilita trabalha todos argumentos como Variable evitanto Err 13 em chamadas via COM. Vem coment|fffd|rio com IsMissing em LembreteAlterParaVer4p0.txt.
    If IsMissing(StartAtPopup) Then StartAtPopup = "" Else StartAtPopup = CStr(StartAtPopup)
    If IsMissing(DisplaySize) Then DisplaySize = 0 Else DisplaySize = CLng(DisplaySize)
    If IsMissing(DisplayMode) Then DisplayMode = 0 Else DisplayMode = CLng(DisplayMode)
    If IsMissing(DecimalPlaces) Then DecimalPlaces = -1 Else DecimalPlaces = CLng(DecimalPlaces)
    If IsMissing(CountDown) Then CountDown = False Else CountDown = CBool(CountDown)
    If IsMissing(PaperRibbon) Then PaperRibbon = False Else PaperRibbon = CBool(PaperRibbon)
    If IsMissing(SplitA) Then SplitA = False Else SplitA = CBool(SplitA)
    If IsMissing(SplitSheet) Then SplitSheet = "" Else SplitSheet = CStr(SplitSheet)
    If IsMissing(SplitWorkbook) Then SplitWorkbook = "" Else SplitWorkbook = CStr(SplitWorkbook)
    If IsMissing(SplitStartCellRef) Then SplitStartCellRef = "" Else SplitStartCellRef = CStr(SplitStartCellRef)
    If IsMissing(ActivateSplitSheet) Then ActivateSplitSheet = True Else ActivateSplitSheet = CBool(ActivateSplitSheet)
    If IsMissing(LeftPos) Then LeftPos = "" Else LeftPos = CStr(LeftPos)
    If IsMissing(TopPos) Then TopPos = "" Else TopPos = CStr(TopPos)
    If IsMissing(ShareSplitSheet) Then ShareSplitSheet = False Else ShareSplitSheet = CBool(ShareSplitSheet)
    If IsMissing(WaitAndRetValue) Then WaitAndRetValue = 0 Else WaitAndRetValue = CLng(WaitAndRetValue)
    If IsMissing(CtrlPanelSize) Then CtrlPanelSize = 0 Else CtrlPanelSize = CLng(CtrlPanelSize)
    If IsMissing(StopInsMode) Then StopInsMode = "" Else StopInsMode = CStr(StopInsMode)
    If IsMissing(SnapshotSetting) Then SnapshotSetting = "" Else SnapshotSetting = CStr(SnapshotSetting)
    If IsMissing(SavedSettingFile) Then SavedSettingFile = "" Else SavedSettingFile = CStr(SavedSettingFile)
    If IsMissing(ResetMode) Then ResetMode = 0 Else ResetMode = CLng(ResetMode)
    If IsMissing(OtherButtsMode) Then OtherButtsMode = -1 Else OtherButtsMode = CLng(OtherButtsMode)
    If IsMissing(CellAsButTriggSlc) Then CellAsButTriggSlc = -1 Else CellAsButTriggSlc = CLng(CellAsButTriggSlc)
    If IsMissing(EchoDisplayInCell) Then EchoDisplayInCell = -1 Else EchoDisplayInCell = CLng(EchoDisplayInCell)
    If IsMissing(SkinSetting) Then SkinSetting = "" Else SkinSetting = CStr(SkinSetting)
    If IsMissing(CountdownSetting) Then CountdownSetting = "" Else CountdownSetting = CStr(CountdownSetting)

    Dim UserFormStopwatch1 As UserFormStopwatch
    Dim dNowAtStart As Date, lTickCountAtStart As Long
    dNowAtStart = Now: lTickCountAtStart = GetTickCount() - 400   'Como o log do split acontece com PrintPapel, este deve ficar depois dos processos inicial de cr|fffd|tica, split e cria|fffd||fffd|o do userform que podem demorar, ent|fffd|o guarda o Now junto ao GetTickCount() aqui ao iniciar. Ignorar este gap foi um bug descoberto na vers|fffd|o 4.0. Antecipar um delay de -400 foi obtido por tentativa de ajuste a formulas na planilha AuctionCountdown2.xls.

    If CollectionInst Is Nothing Then Set CollectionInst = New Collection
    'If bMultDisable And CollectionInst.Count > 0 Then 'J|fffd| rodando 'Com LoopAPI pode rodar v|fffd|rios simultaneamente. Vou permiti mesmo configurado como bMultDisable=true que vai servir s|fffd| para interface
    '   fStopwatch = "Error 3"
    '   Exit Function
    'End If
    If CollectionInst.Count >= 300 Then fStopwatch = "Error 1": Exit Function   'O VBA parece s|fffd| suportar 307 inst|fffd|ncias, vou limitar silenciosamente em 300.

    'Se split e Not ShareSplitSheet, evitar rodar mais de um cron|fffd|metro em um mesmo range
    If SplitWorkbook = "" And (SplitSheet <> "" Or SplitStartCellRef <> "") And Not appHostApp.ActiveWorkbook Is Nothing Then SplitWorkbook = appHostApp.ActiveWorkbook.Name
    If SplitSheet = "" And SplitStartCellRef <> "" And Not appHostApp.ActiveWindow.ActiveSheet Is Nothing Then SplitSheet = appHostApp.ActiveWindow.ActiveSheet.Name
    If SplitStartCellRef = "" Then SplitStartCellRef = "$A$1"
    If SplitA And Not ShareSplitSheet Then
        For Each UserFormStopwatch1 In CollectionInst
            With UserFormStopwatch1
                If .bCallBYfStopwatch Then
                    If LCase(SplitStartCellRef) = LCase(.sSplitStartCellRef) And _
                       LCase(SplitSheet) = LCase(.shSplit.Name) And _
                       LCase(SplitWorkbook) = LCase(.wbSplit.Name) Then
                        Msg1 = IIf(IsPortg, "A planilha '" & SplitSheet & "' na pasta de trabalho '" & SplitWorkbook & "' j|fffd| tem uma divis|fffd|o ativa iniciada em " & SplitStartCellRef & ".", _
                                   "The sheet '" & SplitSheet & "' in the workbook '" & SplitWorkbook & "' already has an active split started on " & SplitStartCellRef & ".")
                        Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Divis|fffd|o J|fffd| Ativa!", " - Split Already Active!")
                        MyMsgBox Msg1, 1, Msg2
                        fStopwatch = "Error 3"
                        On Error GoTo 0    'Se n|fffd|o limpar, vai ecoar no c|fffd|digo que chamou
                        Exit Function
                    End If
                End If
            End With
        Next
    End If

    If vModalIni = "" Or bCallBYfStopwatchIni Then ReadINISetting    'Ler or reler tamb|fffd|m se tiver sido usado por uma instancia chamada por fStopw
    WriteINISetting    'Grava para preservar UI cfg atual e restaurar quando necess|fffd|rio
    OpenDefaultSetting    'Restaura a configura|fffd||fffd|o padr|fffd|o original, pois |fffd| melhor do que usar a imprevis|fffd|vel configura|fffd||fffd|o padr|fffd|o atual.

    'Abrir arquivo de config. salvo indicado. Todas as vari|fffd|v sem argum. segue o INI atual e tamb|fffd|m os de argum. vazios ou com padr|fffd|o propositalmente inadequado
    If SavedSettingFile <> "" Then
        ReadINISetting CStr(SavedSettingFile)
        If bGetLastSetFail Then
            Msg1 = IIf(IsPortg, "Ao abrir o arquivo de congigura|fffd||fffd|o '" & SplitSheet & "' indicado.", _
                       "To open '" & SplitSheet & "' indicated setting file.")
            Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Falhou!", " - Failed!")
            MyMsgBox Msg1, 1, Msg2
            fStopwatch = "Error 4"
            ReadINISetting    'Restaura UI cfg
            On Error GoTo 0    'Se n|fffd|o limpar, vai ecoar no c|fffd|digo que chamou
            Exit Function
        End If
    End If

    Set rngActCelStartIni = appHostApp.ActiveWindow.ActiveCell    'C|fffd|lula Ativa ao Iniciar
    Set ActShAtPopupIni = appHostApp.ActiveWindow.ActiveSheet    'Planilha ativa ao iniciar

    FormPosition
    If TopPos <> "" Then
        If TopPos = "$" Then
            CronometroPosTop = dLastPosTopIni
        ElseIf VBA.Left(TopPos, 1) = "$" Then
            If IsNumeric(Mid(TopPos, 2)) Then CronometroPosTop = Val(Mid(TopPos, 2))
        Else
            If IsNumeric(TopPos) Then CronometroPosTop = CronometroPosTop + Val(TopPos)
        End If
    End If

    If LeftPos <> "" Then
        If LeftPos = "$" Then
            CronometroPosLeft = dLastPosLeftIni
        ElseIf VBA.Left(LeftPos, 1) = "$" Then
            If IsNumeric(Mid(LeftPos, 2)) Then CronometroPosLeft = Val(Mid(LeftPos, 2))
        Else
            If IsNumeric(LeftPos) Then CronometroPosLeft = CronometroPosLeft + Val(LeftPos)
        End If
    End If

    vModalIni = IIf(WaitAndRetValue = 2, 1, 0)

    'Obtendo e validando dados passados pelos argumentos
    If IsMissing(InitialElapsed) Then CronometroElapsedIni = 0 Else CronometroElapsedIni = InitialElapsed
    If CronometroElapsedIni = Empty Or IsEmpty(CronometroElapsedIni) Or IsNull(CronometroElapsedIni) Then CronometroElapsedIni = 0    'No PPoint s|fffd| func. IsEmpty e no Access IsNull
    If CronometroElapsedIni <> 0 Then IsTimeExtend CronometroElapsedIni, CronometroElapsedIni, CBool(CountDown)     'S|fffd| interessa o retorno nos argumentos, pois vai continuar de qualquer jeito. Guarda CronometroElapsedIni orig para verif. possib. de countdowsn para datetime depois de ReadINISetting.
    bCDtoDTimeIni = False: If IsDate(InitialElapsed) Then If Year(InitialElapsed) > Year(Now) - 10 And Year(InitialElapsed) < Year(Now) + 10 Then CronometroElapsedIni = (CDbl(InitialElapsed) - CDbl(Now)) * 24 * 60 * 60: CountDown = True: bCDtoDTimeIni = True: dbCDtoDTimeIni = CDbl(InitialElapsed): If CronometroElapsedIni < 0 Then CronometroElapsedIni = 0  'Verf. se |fffd| um date/time atual n|fffd|o extrapolando muito ao now, ent|fffd|o vai pra countdown para o mesmo date/time.

    bResetAtPopupIni = ResetAtPopup    'Padr|fffd|o def. no arg.
    bStartAtPopupIni = InStr(1, StartAtPopup, "1") > 0
    bMultStartAttachIni = InStr(1, StartAtPopup, "2") > 0
    bMultStopAttachIni = InStr(1, StartAtPopup, "3") > 0
    bMultRestartAttachIni = InStr(1, StartAtPopup, "4") > 0
    bMultStopInsAttachIni = InStr(1, StartAtPopup, "5") > 0
    bMultResetAttachIni = InStr(1, StartAtPopup, "6") > 0
    bMultStartStopsAttachIni = InStr(1, StartAtPopup, "7") > 0
    bMultRestartStopsAttachIni = InStr(1, StartAtPopup, "8") > 0
    bMultStartStopInssAttachIni = InStr(1, StartAtPopup, "9") > 0
    bMultRestartStopInssAttachIni = InStr(1, StartAtPopup, "A") > 0

    If bMultDisable Then bMultDisable = Not (bMultResetAttachIni Or bMultStopAttachIni Or bMultRestartAttachIni)

    If DisplaySize > 0 Then lDispSizeIni = DisplaySize    'Padr|fffd|o INI atual
    If lDispSizeIni < 2 Then lDispSizeIni = 26 Else If lDispSizeIni > 500 Then lDispSizeIni = 500

    If DisplayMode > 0 Then lModeIni = DisplayMode    'Padr|fffd|o INI atual
    If lModeIni < 1 Or lModeIni > 10 Then lModeIni = 3

    If DecimalPlaces >= 0 Then lNumDecimIni = DecimalPlaces    'Padr|fffd|o INI atual
    If lNumDecimIni < 0 Then lNumDecimIni = 0 Else If lNumDecimIni > 5 Then lNumDecimIni = 5

    If CtrlPanelSize > 0 Then lCtrlPanelSizeIni = CtrlPanelSize    'Padr|fffd|o INI atual
    If lCtrlPanelSizeIni < 3 Then lCtrlPanelSizeIni = 3 Else If lCtrlPanelSizeIni > 50 Then lCtrlPanelSizeIni = 50

    Dim i As Long
    If StopInsMode <> "" Then    'Padr|fffd|o INI atual se vazio ou zero.
        If IsNumeric(Split(StopInsMode, ";")(0)) Then i = Split(StopInsMode, ";")(0): If i < 1 Or i > 6 Then Else lStopInsModeIni = i
        If UBound(Split(StopInsMode, ";")) >= 1 Then If IsNumeric(Split(StopInsMode, ";")(1)) Then i = Split(StopInsMode, ";")(1): If i < 1 Or i > 2 Then Else bInsActCelStartIni = (i = 2)
        If UBound(Split(StopInsMode, ";")) >= 2 Then If IsNumeric(Split(StopInsMode, ";")(2)) Then i = Split(StopInsMode, ";")(2): If i < 1 Or i > 6 Then Else lInsOvrCntsIni = i
        If UBound(Split(StopInsMode, ";")) >= 3 Then If IsNumeric(Split(StopInsMode, ";")(3)) Then i = Split(StopInsMode, ";")(3): If i < 1 Or i > 6 Then Else lInsAlsoDTimeIni = i
    End If

    If ResetMode > 0 Then lResetModeIni = ResetMode    'Padr|fffd|o INI atual
    If lResetModeIni < 1 Or lResetModeIni > 4 Then lResetModeIni = 1    'Reset default e antigo

    If OtherButtsMode >= 0 Then lOtherButtsModeIni = OtherButtsMode    'Padr|fffd|o INI atual
    If lOtherButtsModeIni < 0 Or lOtherButtsModeIni > (1 Or 2 Or 4 Or 8 Or 16 Or 32 Or 64) Then lOtherButtsModeIni = 0      'Bitwise

    If CellAsButTriggSlc >= 0 Then lCellAsButTriggSlcIni = CellAsButTriggSlc    'Padr|fffd|o INI atual
    If lCellAsButTriggSlcIni < 0 Or lCellAsButTriggSlcIni > (1 Or 2 Or 4 Or 8 Or 16 Or 32 Or 64 Or 128 Or 256 Or 512 Or 1024 Or 2048 Or 4096) Then lCellAsButTriggSlcIni = (0 Or 2 Or 4 Or 256 Or 2048)      'Bitwise

    If EchoDisplayInCell >= 0 Then lEchoDisplayInCellIni = EchoDisplayInCell    'Padr|fffd|o INI atual
    If lEchoDisplayInCellIni < 0 Or lEchoDisplayInCellIni > (1 Or 2 Or 4) Then lEchoDisplayInCellIni = (0 Or 2 Or 4)    'Bitwise

    If SkinSetting <> "" Then
        If IsNumeric(Split(SkinSetting, ";")(0)) Then
            i = Split(SkinSetting, ";")(0)
            bHideTitleBarIni = (i And 1) = 1
            bAutoHideCtrlPanelIni = (i And 2) = 2
            bAnchActCelStartIni = (i And 4) = 4
            bAnchCelAdjHeightIni = (i And 8) = 8
            bAnchCelAdjWidthIni = (i And 16) = 16
            bUnanchExcelWinIni = (i And 32) = 32
            bAlwaysOnTopIni = (i And 64) = 64
            bEnableBackgrondIni = (i And 128) = 128
        End If
        If UBound(Split(SkinSetting, ";")) >= 1 Then If IsNumeric(Split(SkinSetting, ";")(1)) Then i = Split(SkinSetting, ";")(1): If i < 0 Or i > 4 Then Else lClickOnDisplayIni = i
        If UBound(Split(SkinSetting, ";")) >= 2 Then If IsNumeric(Split(SkinSetting, ";")(2)) Then i = Split(SkinSetting, ";")(2) + 1: If i < 1 Or i > &HFFFFFF + 1 Then Else lColorBackgroundIni = i - 1    'Background color '+1 para ficar similar a cr|fffd|tica em ReadINISetting
        If UBound(Split(SkinSetting, ";")) >= 3 Then If Len(Split(SkinSetting, ";")(3)) > 5 Then sPictFileIni = Split(SkinSetting, ";")(3)
        If UBound(Split(SkinSetting, ";")) >= 4 Then If IsNumeric(Split(SkinSetting, ";")(4)) Then i = Split(SkinSetting, ";")(4) + 1: If i < 0 + 1 Or i > 4 + 1 Then Else lPictAlignmentIni = i - 1    '+1 para ficar similar a cr|fffd|tica em ReadINISetting
        If UBound(Split(SkinSetting, ";")) >= 5 Then If IsNumeric(Split(SkinSetting, ";")(5)) Then i = Split(SkinSetting, ";")(5): If i < 0 Or i > 3 Then Else lPictSizeModeIni = i
        If UBound(Split(SkinSetting, ";")) >= 6 Then If IsNumeric(Split(SkinSetting, ";")(6)) Then i = Split(SkinSetting, ";")(6): If i < 0 Or i > 1 Then Else bPictTilingIni = (i = 1)
        If UBound(Split(SkinSetting, ";")) >= 7 Then
            If IsNumeric(Split(SkinSetting, ";")(7)) Then
                i = Split(SkinSetting, ";")(7)
                bTranspDisplayIni = (i And 1) = 1
                bTranspCtrlPanelIni = (i And 2) = 2
                bTranspSnapshotLbIni = (i And 4) = 4
                bTranspPaperIni = (i And 8) = 8
            End If
        End If
    End If

    If SnapshotSetting <> "" Then
        Dim s As String
        s = Split(SnapshotSetting, ";")(0)
        If IsNumeric(Split(s, "|")(0)) Then
            i = Split(s, "|")(0)
            If i >= 0 And i <= 10 Then lSnapshotNumbIni = i    'Segue argum., se ausente (padr|fffd|o 0) ou se entre 0 e 10. Se informado negativo (-1) ou > 10, padr|fffd|o INI atual
            Dim lCtrl As Long
            For lCtrl = 0 To 10
                arrSnpshtLbIni(lCtrl) = ""    '|fffd| melhor limpar, pois, ao acionar mais de um, a repeti|fffd||fffd|o de r|fffd|tulos n|fffd|o parece conveniente
                If lCtrl = 0 Then    'Base snapshot or snapshot0
                    If UBound(Split(s, "|")) >= 1 Then arrSnpshtLbIni(lCtrl) = Split(s, "|")(1)    'UserNote for base snapshot.
                    If UBound(Split(s, "|")) >= 2 Then bUserNoteLastIni = Split(s, "|")(2) = "1"
                Else    'Label snapshot 1-10
                    If UBound(Split(SnapshotSetting, ";")) >= lCtrl Then
                        s = Split(SnapshotSetting, ";")(lCtrl)
                        arrSnpshtLbIni(lCtrl) = Split(s, "|")(0)
                        If UBound(Split(s, "|")) >= 1 Then If IsNumeric(Split(s, "|")(1)) Then i = Split(s, "|")(1) + 1: If i < 1 Or i > &HFFFFFF + 1 Then Else arrBackColorIni(lCtrl) = i - 1   'Background color '+1 para ficar similar a cr|fffd|tica em ReadINISetting
                        If UBound(Split(s, "|")) >= 2 Then If IsNumeric(Split(s, "|")(2)) Then i = Split(s, "|")(2) + 1: If i < 1 Or i > &HFFFFFF + 1 Then Else arrForeColorIni(lCtrl) = i - 1   'Foreground color ...
                        If UBound(Split(s, "|")) >= 3 Then If Len(Split(s, "|")(3)) > 5 Then arrsWavSndAtSnpshtLbIni(lCtrl) = Split(s, "|")(3): arrbSndAtSnpshtLbIni(lCtrl) = True    'Se vier arquivo de som, habilita tambem
                    End If
                End If
            Next
        End If
    End If

    Dim dbElapsed As Double
    If CountdownSetting <> "" Then
        If IsNumeric(Split(CountdownSetting, ";")(0)) Then
            dbElapsed = Split(CountdownSetting, ";")(0) * 24 * 60 * 60   ': dbElapsed = (TimeValue("02:01:12") + TimeValue("00:00:01") / 2) * 24 * 60 * 60
            If dbElapsed < CDbl(Now) Then
                lCDHourIni = Int(dbElapsed / 60 / 60)
                lCDMinIni = Int((dbElapsed - lCDHourIni * 60 * 60) / 60)
                lCDSecIni = Int((dbElapsed - lCDHourIni * 60 * 60 - lCDMinIni * 60))
                If Round(dbElapsed - Int(dbElapsed), 3) = 0 Then lCDSecFractIni = 0 Else lCDSecFractIni = Mid(CStr(Round(dbElapsed - Int(dbElapsed), 3)), 3)
            Else
                bCDtoDTimeIni = True
                dbCDtoDTimeIni = dbElapsed
            End If
        Else
            lCDSecFractIni = 0
        End If
        If UBound(Split(CountdownSetting, ";")) >= 1 Then
            If IsNumeric(Split(CountdownSetting, ";")(1)) Then
                i = Split(CountdownSetting, ";")(1)
                bCDBeepIni = (i And 1) = 1
                bCDWavIni = (i And 2) = 2
                bCDRunIni = (i And 4) = 4
                bCDAlertIni = (i And 8) = 8
                bCDReCntdownIni = (i And 16) = 16
                bCDQuitIni = (i And 32) = 32
                bCDStartIni = (i And 64) = 64
                bCDRestartIni = (i And 128) = 128
                bCDSpeakIni = (i And 256) = 256
            End If
        End If
        If UBound(Split(CountdownSetting, ";")) >= 2 Then If IsNumeric(Split(CountdownSetting, ";")(2)) Then i = Split(CountdownSetting, ";")(2): If i > 0 Then lCDBeepIni = i
        If UBound(Split(CountdownSetting, ";")) >= 3 Then If Len(Split(CountdownSetting, ";")(3)) > 5 Then sCDFileWavIni = Split(CountdownSetting, ";")(3)
        If UBound(Split(CountdownSetting, ";")) >= 4 Then If Len(Split(CountdownSetting, ";")(4)) > 5 Then sCDFileRunIni = Split(CountdownSetting, ";")(4)
        If UBound(Split(CountdownSetting, ";")) >= 5 Then If Len(Split(CountdownSetting, ";")(5)) > 0 Then sCDTxtAlertIni = Split(CountdownSetting, ";")(5)
        If UBound(Split(CountdownSetting, ";")) >= 6 Then If IsNumeric(Split(CountdownSetting, ";")(6)) Then i = Split(CountdownSetting, ";")(6): If i > 0 Then lCDSpeakIni = i
    End If

    bPaperRibbonIni = PaperRibbon

    bCallBYfStopwatchIni = True
    Set UserFormStopwatch1 = New UserFormStopwatch    'Aqui dispara inicializar

    UserFormStopwatch1.bCntDown = CountDown
    If UserFormStopwatch1.bCntDown Then
        If CountdownSetting = "" Then UserFormStopwatch1.bCDQuit = True    'Sempre sair ao final da contagem regressiva possibilitando a|fffd||fffd|es imediatas. Na vers|fffd|o 4.0 pode ser configurado via argumento.
        'bResetAtPopupIni = False 'Acredito que isso era necess|fffd|rio em vers|fffd|es antigas. Comentei na vers|fffd|o 4.0.
    End If

    UserFormStopwatch1.lBotPress = 0
    UserFormStopwatch1.dbElapsed = IIf(bResetAtPopupIni, 0, IIf(bMultDisable And IsMissing(InitialElapsed), dbLastElapsed, CronometroElapsedIni))
    If sLastDisplay <> "" Then sLastDisplay = IIf(bResetAtPopupIni, String(Len(sLastDisplay) - 1, Chr(160)) & "0", sLastDisplay)

    If bStartAtPopupIni Then
        If UserFormStopwatch1.bCntDown Then
            If bCDtoDTimeIni Then dNowAtStart = Now: lTickCountAtStart = GetTickCount() - 400: UserFormStopwatch1.dbElapsed = (CDbl(InitialElapsed) - CDbl(dNowAtStart)) * 24 * 60 * 60: If UserFormStopwatch1.dbElapsed < 0 Then UserFormStopwatch1.dbElapsed = 0   'Calcular novamente para ficar mais exato,pois o now j|fffd| deve ter mudado. Antecipar um delay de -400 foi obtido por tentativa de ajuste a formulas na planilha AuctionCountdown2.xls.
            UserFormStopwatch1.dbStart = lTickCountAtStart / 1000 + UserFormStopwatch1.dbElapsed
        Else
            UserFormStopwatch1.dbStart = lTickCountAtStart / 1000 - UserFormStopwatch1.dbElapsed
        End If
        UserFormStopwatch1.lBotPress = 1
    Else
        UserFormStopwatch1.lBotPress = IIf(UserFormStopwatch1.dbElapsed = 0, 0, 2)
    End If

    Set UserFormStopwatch1.rngActCelStart = rngActCelStartIni
    Set UserFormStopwatch1.ActShAtPopup = ActShAtPopupIni

    On Error Resume Next
    If SplitSheet <> "" Then
        Set UserFormStopwatch1.shSplit = appHostApp.Workbooks(SplitWorkbook).Sheets(SplitSheet)
        If UserFormStopwatch1.shSplit Is Nothing Then
            Msg1 = IIf(IsPortg, "A planilha '" & SplitSheet & "' na pasta de trabalho '" & SplitWorkbook & "' n|fffd|o foi encontrada!", _
                       "The sheet '" & SplitSheet & "' in the workbook '" & SplitWorkbook & "' wasn't found!")
            Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Falha!", " - Fail!")
            MyMsgBox Msg1, 1, Msg2
            fStopwatch = "Error 1"
            Unload UserFormStopwatch1
            On Error GoTo 0    'Se n|fffd|o limpar, vai ecoar no c|fffd|digo que chamou
            Exit Function
        End If
    End If

    If UserFormStopwatch1.shSplit Is Nothing Then
        UserFormStopwatch1.sSplitStartCellRef = appHostApp.Range(SplitStartCellRef).Address
        Msg1 = IIf(IsPortg, "A refer|fffd|ncia '" & SplitStartCellRef & "' |fffd| invalida ou n|fffd|o foi encontrada!", _
                   "The reference '" & SplitStartCellRef & "' is invalid or wasn't found!")
    Else
        UserFormStopwatch1.sSplitStartCellRef = UserFormStopwatch1.shSplit.Range(SplitStartCellRef).Address
        Msg1 = IIf(IsPortg, "A refer|fffd|ncia '" & SplitStartCellRef & "' na planilha '" & SplitSheet & "' |fffd| invalida ou n|fffd|o foi encontrada!", _
                   "The reference '" & SplitStartCellRef & "' in the sheet '" & SplitSheet & "' is invalid or wasn't found!")
    End If
    If UserFormStopwatch1.sSplitStartCellRef = "" Then
        Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Falha!", " - Fail!")
        MyMsgBox Msg1, 1, Msg2
        fStopwatch = "Error 2"
        Unload UserFormStopwatch1
        On Error GoTo 0    'Se n|fffd|o limpar, vai ecoar no c|fffd|digo que chamou
        Exit Function
    End If
    UserFormStopwatch1.sSplitStartCellRef = SplitStartCellRef
    If Not UserFormStopwatch1.shSplit Is Nothing Then Set UserFormStopwatch1.wbSplit = UserFormStopwatch1.shSplit.Parent
    UserFormStopwatch1.bActSplitShAtSplit = ActivateSplitSheet

    UserFormStopwatch1.bSplit = SplitA
    If UserFormStopwatch1.bSplit Then
        If Not UserFormStopwatch1.shSplit Is Nothing And UserFormStopwatch1.bActSplitShAtSplit Then UserFormStopwatch1.shSplit.Activate
        With UserFormStopwatch1
            .LbSplit.Caption = IIf(IsPortg, "Instt|fffd|neo", "Snapshot")
            .PrintPapel UserFormStopwatch1.dbElapsed, Now, "Popup", "", sLastDisplay
        End With
        If Not UserFormStopwatch1.bActSplitShAtSplit Then On Error Resume Next: UserFormStopwatch1.ActShAtPopup.Activate: On Error GoTo 0
    End If

    UserFormStopwatch1.PrintPapel UserFormStopwatch1.dbElapsed, dNowAtStart, "Popup", "", sLastDisplay
    If bStartAtPopupIni Then UserFormStopwatch1.PrintPapel UserFormStopwatch1.dbElapsed, dNowAtStart, IIf(bResetAtPopupIni Or UserFormStopwatch1.bCntDown, "Start", "Restart"), "", sLastDisplay

    UserFormStopwatch1.lWaitAndRetValue = WaitAndRetValue
    fStopwatch = fStopwatch1(UserFormStopwatch1)
End Function

Sub OpenDefaultSetting()
'Cria um arquivo ini v|fffd|lido com linhas em branco e l|fffd| com o ReadINISetting, assim vari|fffd|veis ficam vazia e default |fffd| apliado
    Dim sINIfile1 As String
    Dim i As Long

    If sINIfile = "" Then GetINIfile
    sINIfile1 = Replace(sINIfile, ".ini", "") & "DefaultTmp.ini"

    On Error Resume Next
    hFile = FreeFile
    Open sINIfile1 For Output As #hFile
    Write #hFile, sFileDescr
    For i = 1 To 200
        Write #hFile, ""
    Next
    Close #hFile
    If Err.Number <> 0 Then
        MyMsgBox IIf(IsPortg, "N|fffd|o foi poss|fffd|vel salvar e ler a configura|fffd||fffd|o padr|fffd|o no arquivo INI em:", "It wasn't possible to save and read the default setting on INI file at:") & vbCrLf & sINIfile1, 1, sAddInCaptByApp & IIf(IsPortg, " - Erro! " & Err.Description, " - Error! " & Err.Description)
        Exit Sub
    End If

    ReadINISetting CStr(sINIfile1)
    If Dir(sINIfile1) <> "" Then Kill sINIfile1
End Sub

Private Function fStopwatch1(UserFormStopwatch1 As UserFormStopwatch)
    sDecimalSep = gLocInfo(LOCALE_SDECIMAL)
    sThousandsSep = gLocInfo(LOCALE_STHOUSAND)
ModalChange:
    vModalChange = False
    OkInsert = False

    lCountInstAdd = lCountInstAdd + 1
    CollectionInst.Add UserFormStopwatch1, CStr(lCountInstAdd)     'Add some keys and items
    UserFormStopwatch1.sCountInstAdd = CStr(lCountInstAdd)


    If dHostAppVer > 8 Then
        #If VBA6 Then
            UserFormStopwatch1.Show vModalIni    'UserFormStopwatch.Show vModalini Qualquer que seja o valor de vModalini ser|fffd| sempre modeless
        #End If
    Else
        fStopwatch1 = False: Exit Function    'UserFormStopwatch1.Show
    End If

    If UserFormStopwatch1.lWaitAndRetValue = 0 Then    'Roda de assincrono sem espera por valor de retorno antigo bReleasedModeless
        fStopwatch1 = False
        Exit Function
    End If

    If UserFormStopwatch1.lWaitAndRetValue = 1 Then    'If modeless and not Released, esperando ret. de valor
        Do While UserFormStopwatch1.Visible: MyWait 0.1: Loop
    End If
    If UserFormStopwatch1.lWaitAndRetValue > 0 Then Unload UserFormStopwatch1

    If vModalChange Then GoTo ModalChange
    '    bArrKeysCancel = False
    'Unload |fffd| necess|fffd|rio para acionar evento_initialize no pr|fffd|xmimo show
    '    Unload UserFormStopwatch1 : Unload UserFormCntDown: Set wbSplit = Nothing: Set shSplit = Nothing: sSplitStartCellRef = ""
    If OkInsert Then fStopwatch1 = CDbl(CronometroElapsedAtu / 24 / 60 / 60) Else fStopwatch1 = False
End Function

Sub GetApp_hWnd()
    Dim sClassByVer As String
    Select Case appHostApp.Name
    Case "Microsoft Excel"
        If dHostAppVer > 9 Then App_hWnd = appHostApp.hWnd
        If App_hWnd = 0 Then sClassByVer = "XLMain"
    Case "Microsoft Word"
        sClassByVer = "OpusApp"
        App_hWnd = 0    'Zero because in Word each doc window has different handle and have to get of ActiveWindow. Gear a bug pointed by rick_aiello@yahoo.com
    Case "Microsoft PowerPoint"
        sClassByVer = "PP" & Choose(Int(dHostAppVer) - 7, 97, 9, 10, 11, 12, "", "T", "T", "T") & "FrameClass"
        App_hWnd = 0    'Zero because like in Word...
    Case "Microsoft Access"
        App_hWnd = appHostApp.hWndAccessApp
    End Select

    If App_hWnd = 0 And sClassByVer <> "" Then
        On Error Resume Next
        If appHostApp.Windows.Count > 0 Then
            App_hWnd = FindWindowA(sClassByVer, appHostApp.Caption & " - " & appHostApp.ActiveWindow.Caption)
            If App_hWnd = 0 Then App_hWnd = FindWindowA(sClassByVer, appHostApp.ActiveWindow.Caption & " - " & appHostApp.Caption)
        End If
        If App_hWnd = 0 Then App_hWnd = FindWindowA(sClassByVer, appHostApp.Caption)
        If App_hWnd = 0 Then App_hWnd = FindWindowA(sClassByVer, vbNullString)    'KB288902 informa ClassNames at|fffd| o 2007
        Err.Clear
    End If
End Sub

Sub FormPosition()
    Dim Result
    WavFile = ThisDLLPath & sPathSep & sAddInNameByApp & "Click.wav"
    If VBA.FileSystem.Dir(WavFile) = "" Then
        If appHostApp.Name <> "Microsoft Access" Then
            WavFile = appHostApp.Path & sPathSep & sAddInNameByApp & "Click.wav"
        Else
            WavFile = appHostApp.SysCmd(9) & sPathSep & sAddInNameByApp & "Click.wav"  'acSysCmdAccessDir
        End If
        If VBA.FileSystem.Dir(WavFile) = "" Then WavFile = ""
    End If

    ScreenRx = GetSystemMetrics(SM_CXSCREEN) * 72 / ScreenResol(0)    'Convert Pixel to Point
    ScreenRy = GetSystemMetrics(SM_CYSCREEN) * 72 / ScreenResol(1)
    Dim Point As POINTAPI
    Result = GetCursorPos(Point)
    If Result <> 0 Then
        CronometroPosLeft = Point.X * 0.75
        CronometroPosTop = Point.Y * 0.75
    Else
        CronometroPosTop = 0
        CronometroPosLeft = 20
    End If
End Sub

Sub FixForm(hWinHld As Long)
'Fixar form
    Dim lStyle As Long
    lStyle = GetWindowLongA(hWinHld, GWL_STYLE)
    lStyle = lStyle And Not WS_THICKFRAME    'Fixar tamanho
    lStyle = lStyle And Not WS_MINIMIZEBOX
    lStyle = lStyle And Not WS_MAXIMIZEBOX
    SetWindowLongA hWinHld, GWL_STYLE, lStyle

    lStyle = GetWindowLongA(hWinHld, GWL_EXSTYLE)
    lStyle = lStyle And Not WS_EX_APPWINDOW     'N|fffd|o exibir na barra de tarefa do Windows. S|fffd| |fffd| |fffd|til em COM add-in, mas n|fffd|o tem problema usar em xla
    SetWindowLongA hWinHld, GWL_EXSTYLE, lStyle

    DrawMenuBar hWinHld    'Atualizar barra
End Sub

Public Sub formSizeble(fhWnd As Long, bHideTitleBar As Boolean)
    Dim lStyle As Long
    'fhWnd = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), sCaption)
    lStyle = GetWindowLongA(fhWnd, GWL_STYLE)
    lStyle = lStyle Or WS_THICKFRAME
    If bIsCOMAddin Then lStyle = lStyle And Not WS_MINIMIZEBOX
    If bIsCOMAddin Then lStyle = lStyle And Not WS_MAXIMIZEBOX
    If bHideTitleBar Then lStyle = lStyle And Not WS_CAPTION Else lStyle = lStyle Or WS_CAPTION
    lStyle = lStyle And Not WS_EX_TOOLWINDOW
    SetWindowLongA fhWnd, GWL_STYLE, lStyle

    lStyle = GetWindowLongA(fhWnd, GWL_EXSTYLE)
    lStyle = lStyle And Not WS_EX_APPWINDOW    'N|fffd|o exibir na barra de tarefa do Windows. S|fffd| |fffd| |fffd|til em COM add-in, mas n|fffd|o tem problema usar em xla
    lStyle = lStyle Or WS_EX_TOOLWINDOW    'Barra de t|fffd|tulo extreita sem controle exceto fechar
    SetWindowLongA fhWnd, GWL_EXSTYLE, lStyle

    DrawMenuBar fhWnd    'Atualizar barra
End Sub

Sub AddMenu(vBarName, ByVal vAdd As Long, vPosDown As Boolean)    'vAdd: 0-Exclui 1-Adiciona 2-Move se existir
    Dim vBarra As Office.CommandBar
    Dim vBeginGroup As Boolean
    vBeginGroup = True
    If TypeName(vBarName) = "CommandBar" Then
        Set vBarra = vBarName
    Else
        Set vBarra = appHostApp.CommandBars(vBarName)
    End If

    Dim c As Office.CommandBarControl

    On Error GoTo ExitNow   'Se falhar ao deletar, |fffd| porque foi chamada do menu
    For Each c In vBarra.Controls
        If c.Tag = AddInTitle And Len(AddInTitle) > 0 Then    'Se AddInTitle vazio (len=0), deletaria todos. No Excel 2003 saindo com form modeless aberto as variaveis se perdem, exceto constantes. Ent|fffd|o n|fffd|o delata ao sair, mas como foi criado tempor...
            If vAdd = 2 Then
                Set CmdBarBut = c
                CmdBarBut.Move Before:=IIf(vPosDown, vBarra.Controls.Count, 1)
                vAdd = 3    'Confirma move por existir
            Else
                c.Delete
            End If
        Else
            If (VBA.Left(c.Tag, 10) = "Orlando's " Or VBA.Right(c.Tag, 11) = " do Orlando") _
               And c.Index > 3 Then vBeginGroup = False    'Se j|fffd| existir de um outro utilit|fffd|rio em baixo n|fffd|o inserir separador
        End If
    Next
    If vAdd = 0 Then GoTo ExitNow
    If vAdd = 3 Then
        CmdBarBut.BeginGroup = vBeginGroup And vPosDown
    Else
        '        Set CmdBarBut = vBarra.Controls.Add(IIf(vBarra.Type = msoBarTypePopup, msoControlButton, msoControlPopup), , , IIf(vPosDown, vBarra.Controls.Count, 1), True)
        Set CmdBarBut = vBarra.Controls.Add(msoControlButton, , , IIf(vPosDown, vBarra.Controls.Count, 1), True)
        With CmdBarBut
            .Style = IIf(vBarra.Type = msoBarTypePopup, msoButtonIconAndCaption, msoButtonIcon)    ' msoButtonCaption
            .BeginGroup = vBeginGroup And vPosDown
            .Caption = IIf(IsPortg, "Cron|fffd|metro", "Stopwatch") & IIf(HotKeyIni = "" Or appHostApp.Name = "Microsoft PowerPoint" Or appHostApp.Name = "Microsoft Access", "", "     " & Replace(Replace(Replace(HotKeyIni, "+", "Shift+"), "^", "Ctrl+"), "%", "Alt+"))
            If Not bIsCOMAddin And appHostApp.Name = "Microsoft Word" Then .OnAction = "StopwatchAddInDot"              'usa evento
            .Tag = AddInTitle
            .FaceId = 734    '33 Deixei para o Clock
        End With
    End If
ExitNow:
End Sub

Public Sub PopMenu(bFromAutoPopCell As Boolean, Form_hWnd1 As Long, bAppMinimized As Boolean)
    Dim PopMenuBar6 As Office.CommandBar
    On Error Resume Next
    appHostApp.CommandBars("PopMenuBar6").Delete
    On Error GoTo 0
    Set PopMenuBar6 = appHostApp.CommandBars _
                      .Add(Name:="PopMenuBar6", Position:=msoBarPopup, _
                           Temporary:=True)
    With PopMenuBar6

        With .Controls.Add(Type:=msoControlButton)
            .Caption = IIf(vModalIni = 1, IIf(IsPortg, "N|fffd|o Modal", "Modeless"), "Modal")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick1"
            '.OnAction = "'PopMenuClick ""PopMenuClick1""'"
            .Enabled = False  'S|fffd| pode funcionar em n|fffd|o modal
            .Visible = False
        End With

        With .Controls.Add(Type:=msoControlPopup)
            '            .BeginGroup = (vModalPreserv = "" And bUsarOnTimeAPI) Or appHostApp.Name = "Microsoft Excel"
            .Caption = IIf(IsPortg, "Pontos de In|fffd|cio no ", "Start Points in ") & Replace(appHostApp.Name, "Microsoft ", "")
            '            .Visible = vModalPreserv = ""

            If appHostApp.Name = "Microsoft Excel" Then    'AutoPopup Selecting Cells
                With .Controls.Add(Type:=msoControlPopup)
                    .Caption = IIf(IsPortg, "AutoPopup Selecionando C|fffd|lulas", "AutoPopup Selecting Cells")
                    '                    .BeginGroup = True
                    With .Controls.Add(Type:=msoControlButton)
                        .BeginGroup = True
                        .Caption = IIf(IsPortg, "Popup em C|fffd|lulas com Formato de Tempo", "Popup in Time Format Cells")
                        .Tag = "PopMenuTag"
                        .Parameter = "PopMenuClick12"
                        '.OnAction = "'PopMenuClick ""PopMenuClick12""'"
                        .State = IIf(bPopupFormatSelIni, msoButtonDown, msoButtonUp)
                    End With

                    With .Controls.Add(Type:=msoControlPopup)
                        .Caption = IIf(IsPortg, "Popup em C|fffd|lulas Espec|fffd|ficas", "Popup in Specific Cells")
                        Dim n As Name
                        Dim Rng As Range
                        Dim bDefined As Boolean
                        If Not appHostApp.ActiveWorkbook Is Nothing Then
                            For Each n In appHostApp.ActiveWorkbook.Names
                                If VBA.Left(LCase(n.Name), Len("PopupStopwatch")) = LCase("PopupStopwatch") Then
                                    On Error Resume Next
                                    Set Rng = appHostApp.Intersect(appHostApp.Selection, n.RefersToRange)
                                    If Err.Number = 0 And Not Rng Is Nothing Then
                                        bDefined = True
                                        Set Rng = n.RefersToRange
                                        Exit For
                                    End If
                                End If
                            Next
                        End If
                        If Rng Is Nothing Then Set Rng = appHostApp.Selection

                        On Error Resume Next
                        With .Controls.Add(Type:=msoControlButton)
                            .Caption = IIf(IsPortg, "Definir C|fffd|lulas Popups em ", "Define Popup Cells in ") & Rng.Address
                            .Tag = "PopMenuTag"
                            .Parameter = "PopMenuClick11"
                            '.OnAction = "'PopMenuClick ""PopMenuClick2""'"
                            .Enabled = Err.Number = 0 And Not bDefined And Rng.Areas.Count = 1
                        End With
                        With .Controls.Add(Type:=msoControlButton)
                            .Caption = IIf(IsPortg, "Remover Popup das C|fffd|lulas em ", "Remove Popup from Cells in ") & Rng.Address
                            .Tag = "PopMenuTag"
                            .Parameter = "PopMenuClick11"
                            '.OnAction = "'PopMenuClick ""PopMenuClick2""'"
                            .Enabled = Err.Number = 0 And bDefined And Rng.Areas.Count = 1
                        End With
                        On Error GoTo 0
                        Set Rng = Nothing
                    End With
                    With .Controls.Add(Type:=msoControlButton)
                        .Caption = IIf(IsPortg, "Habilitar Popup Selecionando C|fffd|lulas", "Enable Popup Selecting Cells")
                        .Tag = "PopMenuTag"
                        .Parameter = "PopMenuClick10"
                        '.OnAction = "'PopMenuClick ""PopMenuClick4""'"
                        '                bPopupSelIni = Not EventApp.App Is Nothing
                        .State = IIf(bPopupSelIni, msoButtonDown, msoButtonUp)
                        .Visible = False    'Achei melhor ocultar e fazer sempre popup ao ler INI
                    End With
                End With
            End If

            With .Controls.Add(Type:=msoControlPopup)
                .Caption = IIf(IsPortg, "Menu de Contexto", "Righ-click Menu")
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Nenhum", "None")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick130"
                    '.OnAction = "PopMenuClick50"
                    .State = IIf(lShortMenuPosIni = 0, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .BeginGroup = True
                    .Caption = IIf(IsPortg, "Comando Cron|fffd|metro em Cima", "Stopwatch Command Up")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick13"
                    '.OnAction = "PopMenuClick5"
                    .State = IIf(lShortMenuPosIni = 1, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Comando Cron|fffd|metro em Baixo", "Stopwatch Command Down")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick14"
                    '.OnAction = "PopMenuClick6"
                    .State = IIf(lShortMenuPosIni = 2, msoButtonDown, msoButtonUp)
                End With
            End With

            With .Controls.Add(Type:=msoControlPopup)
                .Caption = IIf(IsPortg, "Barra de Ferram. Padr|fffd|o", "Standard Toolbar")
                If dHostAppVer >= 11 + 1 Then .Caption = IIf(IsPortg, "Guia Suplementos na Faixa", "Ribbon Add-ins Tab")
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Nenhum", "None")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick54"
                    '.OnAction = "PopMenuClick54"
                    .State = IIf(lToolbarPosIni = 0, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .BeginGroup = True
                    .Caption = IIf(IsPortg, "Comando Cron|fffd|metro |fffd| Esquerda", "Stopwatch Command Left")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick55"
                    '.OnAction = "PopMenuClick55"
                    .State = IIf(lToolbarPosIni = 1, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Comando Cron|fffd|metro |fffd| Direita", "Stopwatch Command Right")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick65"
                    '.OnAction = "PopMenuClick65"
                    .State = IIf(lToolbarPosIni = 2, msoButtonDown, msoButtonUp)
                End With
            End With


            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Tecla de Atalho", "Hot Key") & IIf(HotKeyIni = "", "", "     " & Replace(Replace(Replace(HotKeyIni, "+", "Shift+"), "^", "Ctrl+"), "%", "Alt+"))
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick15"
                '.OnAction = "PopMenuClick15"
                '            .Enabled = False
                '                .Visible = vModalPreserv = "" And appHostApp.Name <> "Microsoft PowerPoint" And appHostApp.Name <> "Microsoft Access"
            End With
        End With


        With .Controls.Add(Type:=msoControlPopup)
            .Caption = IIf(IsPortg, "Conduta no Popup", "Behavior at Popup")
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Zerar no Popup", "Reset at Popup")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick2"
                '.OnAction = "'PopMenuClick ""PopMenuClick2""'"
                .State = IIf(bResetAtPopupIni, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Captura C|fffd|lula Ativa no Popup", "Capture Active Cell at Popup")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick2"
                '.OnAction = "'PopMenuClick ""PopMenuClick2""'"
                .State = IIf(Not bResetAtPopupIni, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Iniciar no Popup", "Start at Popup")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick3"
                '.OnAction = "'PopMenuClick ""PopMenuClick3""'"
                .State = IIf(bStartAtPopupIni, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Dividir no Popup", "Split at Popup")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick4"
                '.OnAction = "'PopMenuClick ""PopMenuClick4""'"
                .State = IIf(bSplitAtPopupIni, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Dividir no Popup em Segundo Plano", "Split at Popup in Background")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick5"
                '.OnAction = "'PopMenuClick ""PopMenuClick5""'"
                .State = IIf(bSplitInBkGrAtPopupIni, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Popup na Posi|fffd||fffd|o do Mouse", "Popup at Mouse Position")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick51"
                '.OnAction = "'PopMenuClick ""PopMenuClick51""'"
                .State = IIf(bPopupAtLastPosIni, msoButtonUp, msoButtonDown)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Popup na |fffd|ltima Posi|fffd||fffd|o Salva", "Popup at Last Saved Position")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick51"
                '.OnAction = "'PopMenuClick ""PopMenuClick51""'"
                .State = IIf(bPopupAtLastPosIni, msoButtonDown, msoButtonUp)
            End With
        End With

        With .Controls.Add(Type:=msoControlPopup)
            .BeginGroup = True
            .Caption = IIf(IsPortg, "Conduta do Bot|fffd|o PararIns", "StopIns Button Behavior")
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Parar, Inserir  e Fechar (Vermelho)", "Stop, Insert, and Close (Red)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick6"
                '.OnAction = "'PopMenuClick ""PopMenuClick6""'"
                .State = IIf(lStopInsModeIni = 1, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Parar, Inserir e Zerar (Marrom)", "Stop, Insert, and Reset (Brown)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick61"
                '.OnAction = "'PopMenuClick ""PopMenuClick61""'"
                .State = IIf(lStopInsModeIni = 2, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Parar, Inserir, Zerar e Iniciar (Oliva)", "Stop, Insert, Reset, and Start (Olive)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick62"
                '.OnAction = "'PopMenuClick ""PopMenuClick62""'"
                .State = IIf(lStopInsModeIni = 3, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Parar e Inserir (Laranja)", "Stop and Insert (Orange)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick7"
                '.OnAction = "'PopMenuClick ""PopMenuClick7""'"
                .State = IIf(lStopInsModeIni = 4, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Inserir (Branco)", "Insert (Blank)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick8"
                '.OnAction = "'PopMenuClick ""PopMenuClick8""'"
                .State = IIf(lStopInsModeIni = 5, msoButtonDown, msoButtonUp)
            End With

            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar", "Disable")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick9"
                '.OnAction = "'PopMenuClick ""PopMenuClick9""'"
                .State = IIf(lStopInsModeIni = 6, msoButtonDown, msoButtonUp)
            End With

            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Inserir na C|fffd|lula Ativa Atual", "Insert in Current Active Cell")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick900"
                '.OnAction = "'PopMenuClick ""PopMenuClick900""'"
                .State = IIf(Not bInsActCelStartIni And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Inserir na C|fffd|lula Ativa quando Iniciou", "Insert in Active Cell When Started") & IIf(bFromAutoPopCell, " (AutoPopup)", "")
                If bFromAutoPopCell Then .Caption = IIf(IsPortg, "Inserir na C|fffd|lula Inicial do AutoPopup (Inalter|fffd|vel)", "Insert in AutoPopup Start Cell (Unalterable)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick900"
                '.OnAction = "'PopMenuClick ""PopMenuClick900""'"
                .State = IIf(bInsActCelStartIni Or bFromAutoPopCell, msoButtonDown, msoButtonUp)
                .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6    'Instancia de autopopup sempre insere...
            End With

            'xxxxxxxxxxxxxxxx

            With .Controls.Add(Type:=msoControlPopup)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Havendo Conte|fffd|do na C|fffd|lula", "Having Contents in the Cell")
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Inserir Sobrescrevendo", "Insert Overwriting")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9001"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9001""'"
                    .State = IIf(lInsOvrCntsIni = 1 Or bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With

                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "N|fffd|o Inserir", "Not Insert")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9002"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9002""'"
                    .State = IIf(lInsOvrCntsIni = 2 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With

                With .Controls.Add(Type:=msoControlButton)
                    .BeginGroup = True
                    .Caption = IIf(IsPortg, "Mover para Baixo e Inserir na Pr|fffd|xima C|fffd|lula Vazia e Desprotegida", "Move Down and Insert in Next Empty and Unprotected Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9003"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9003""'"
                    .State = IIf(lInsOvrCntsIni = 3 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Mover para Direita e Inserir na Pr|fffd|xima C|fffd|lula Vazia e Desprotegida", "Move Right and Insert in Next Empty and Unprotected Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9004"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9004""'"
                    .State = IIf(lInsOvrCntsIni = 4 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Mover para Cima e Inserir na Pr|fffd|xima C|fffd|lula Vazia e Desprotegida", "Move Up and Insert in Next Empty and Unprotected Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9005"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9005""'"
                    .State = IIf(lInsOvrCntsIni = 5 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Mover para Esquerda e Inserir na Pr|fffd|xima C|fffd|lula Vazia e Desprotegida", "Move Left and Insert in Next Empty and Unprotected Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9006"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9006""'"
                    .State = IIf(lInsOvrCntsIni = 6 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
            End With


            With .Controls.Add(Type:=msoControlPopup)
                .Caption = IIf(IsPortg, "Inserir Tamb|fffd|m Data e Hora", "Insert Also Date and Time")
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "N|fffd|o Inserir", "Not Insert")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick90001"
                    '.OnAction = "'PopMenuClick ""PopMenuClick90001""'"
                    .State = IIf(lInsAlsoDTimeIni = 1 Or bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With

                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Inserir Como Coment|fffd|rio na Mesma C|fffd|lula", "Insert As Comment in the Same Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick90002"
                    '.OnAction = "'PopMenuClick ""PopMenuClick90002""'"
                    .State = IIf(lInsAlsoDTimeIni = 2 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With

                With .Controls.Add(Type:=msoControlButton)
                    .BeginGroup = True
                    .Caption = IIf(IsPortg, "Inserir na C|fffd|lula |fffd| Direita", "Insert in the Right Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick90003"
                    '.OnAction = "'PopMenuClick ""PopMenuClick90003""'"
                    .State = IIf(lInsAlsoDTimeIni = 3 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Inserir na C|fffd|lula |fffd| Esquerda", "Insert in the Left Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick90004"
                    '.OnAction = "'PopMenuClick ""PopMenuClick90004""'"
                    .State = IIf(lInsAlsoDTimeIni = 4 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Inserir na C|fffd|lula Abaixo", "Insert in the Below Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick90005"
                    '.OnAction = "'PopMenuClick ""PopMenuClick90005""'"
                    .State = IIf(lInsAlsoDTimeIni = 5 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Inserir na C|fffd|lula Acima", "Insert in the Above Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick90006"
                    '.OnAction = "'PopMenuClick ""PopMenuClick90006""'"
                    .State = IIf(lInsAlsoDTimeIni = 6 And Not bFromAutoPopCell, msoButtonDown, msoButtonUp)
                    .Enabled = Not bFromAutoPopCell And lStopInsModeIni <> 6   'Instancia de autopopup sempre insere...
                End With
            End With


            'xxxxxxxxxxxxx

        End With

        With .Controls.Add(Type:=msoControlPopup)
            .Caption = IIf(IsPortg, "Conduta do Bot|fffd|o Reset", "Reset Button Behavior")
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Reset (Cinza)", "Reset (Gray)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick91"
                '.OnAction = "'PopMenuClick ""PopMenuClick6""'"
                .State = IIf(lResetModeIni = 1, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Reset e Iniciar (Verde)", "Reset and Start (Green)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick92"
                '.OnAction = "'PopMenuClick ""PopMenuClick7""'"
                .State = IIf(lResetModeIni = 2, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Inserir, Reset e Iniciar (Branco)", "Insert, Reset, and Start (Blank)")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick93"
                '.OnAction = "'PopMenuClick ""PopMenuClick8""'"
                .State = IIf(lResetModeIni = 3, msoButtonDown, msoButtonUp)
            End With

            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar", "Disable")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick94"
                '.OnAction = "'PopMenuClick ""PopMenuClick9""'"
                .State = IIf(lResetModeIni = 4, msoButtonDown, msoButtonUp)
            End With
        End With



        'xxxx
        With .Controls.Add(Type:=msoControlPopup)
            .Caption = IIf(IsPortg, "Conduta de Outros Bot|fffd|es", "Other Buttons Behavior")

            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar Bot|fffd|o Parar", "Disable Stop Button")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick941"
                '.OnAction = "'PopMenuClick ""PopMenuClick941""'"
                .State = IIf((lOtherButtsModeIni And 1) = 1, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar Bot|fffd|o Reiniciar", "Disable Restart Button")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick942"
                '.OnAction = "'PopMenuClick ""PopMenuClick942""'"
                .State = IIf((lOtherButtsModeIni And 2) = 2, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar Bot|fffd|o Contagem Regressiva(CntRegr)", "Disable Countdown(CntDown) Button")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick943"
                '.OnAction = "'PopMenuClick ""PopMenuClick943""'"
                .State = IIf((lOtherButtsModeIni And 4) = 4, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar Bot|fffd|o Dividir", "Disable Split Button")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick944"
                '.OnAction = "'PopMenuClick ""PopMenuClick944""'"
                .State = IIf((lOtherButtsModeIni And 8) = 8, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar Bot|fffd|o Copiar", "Disable Copy Button")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick945"
                '.OnAction = "'PopMenuClick ""PopMenuClick945""'"
                .State = IIf((lOtherButtsModeIni And 16) = 16, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar Bot|fffd|o Colar", "Disable Paste Button")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick946"
                '.OnAction = "'PopMenuClick ""PopMenuClick946""'"
                .State = IIf((lOtherButtsModeIni And 32) = 32, msoButtonDown, msoButtonUp)
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Desabilitar Bot|fffd|o Exibir Painel(ep)", "Disable Show Panel(sp) Button")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick947"
                '.OnAction = "'PopMenuClick ""PopMenuClick947""'"
                .State = IIf((lOtherButtsModeIni And 64) = 64, msoButtonDown, msoButtonUp)
            End With

            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, IIf(lOtherButtsModeIni = 0, "Desabilitar", "Habilitar") & " Todos", IIf(lOtherButtsModeIni = 0, "Disable", "Enable") & " All")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick948"
                '.OnAction = "'PopMenuClick ""PopMenuClick948""'"
            End With

        End With







        With .Controls.Add(Type:=msoControlPopup)
            .BeginGroup = True
            .Caption = IIf(IsPortg, "C|fffd|lula do Excel como Bot|fffd|o", "Excel Cell as Button")
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Habilitar", "Enable")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick9401"
                '.OnAction = "'PopMenuClick ""PopMenuClick9401""'"
                .State = IIf((lCellAsButTriggSlcIni And 1) = 1, msoButtonDown, msoButtonUp)
            End With

            With .Controls.Add(Type:=msoControlPopup)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Pressiona ao Selecionar C|fffd|lulas", "Trigger when Selecting Cells")
                .Enabled = (lCellAsButTriggSlcIni And 1) = 1
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Com Formato de Tempo", "With Time Format")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9402"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9402""'"
                    .State = IIf((lCellAsButTriggSlcIni And 2) = 2, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Com Conte|fffd|do Vazio", "With Empty Contents")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9403"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9403""'"
                    .State = IIf((lCellAsButTriggSlcIni And 4) = 4, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .BeginGroup = True
                    .Caption = IIf(IsPortg, "Na Planilha Ativa quando Iniciou", "In Active Sheet when Started")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9404"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9404""'"
                    .State = IIf((lCellAsButTriggSlcIni And 8) = 8, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Na Linha Ativa quando Iniciou", "In Active Row when Started")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9405"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9405""'"
                    .State = IIf((lCellAsButTriggSlcIni And 16) = 16, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Na Coluna Ativa quando Iniciou", "In Active Column when Started")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9406"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9406""'"
                    .State = IIf((lCellAsButTriggSlcIni And 32) = 32, msoButtonDown, msoButtonUp)
                End With
            End With

            With .Controls.Add(Type:=msoControlPopup)
                .Caption = IIf(IsPortg, "Conduta ao Pressionar", "Behaviour when Triggering")
                .Enabled = (lCellAsButTriggSlcIni And 1) = 1
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Parar, Inserir e Fechar", "Stop, Insert, and Close")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9407"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9407""'"
                    .State = IIf((lCellAsButTriggSlcIni And 64) = 64, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Parar, Inserir e Zerar", "Stop, Insert, and Reset")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9408"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9408""'"
                    .State = IIf((lCellAsButTriggSlcIni And 128) = 128, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Parar, Inserir, Zerar e Iniciar", "Stop, Insert, Reset, and Start")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9409"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9409""'"
                    .State = IIf((lCellAsButTriggSlcIni And 256) = 256, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Parar e Inserir", "Stop and Insert")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9410"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9410""'"
                    .State = IIf((lCellAsButTriggSlcIni And 512) = 512, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Inserir", "Insert")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick9411"
                    '.OnAction = "'PopMenuClick ""PopMenuClick9411""'"
                    .State = IIf((lCellAsButTriggSlcIni And 1024) = 1024, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .BeginGroup = True
                    .Caption = IIf(IsPortg, "Inserir na C|fffd|lula Ativa Atual", "Insert in Current Active Cell")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick94012"
                    '.OnAction = "'PopMenuClick ""PopMenuClick94012""'"
                    .State = IIf((lCellAsButTriggSlcIni And 2048) = 2048, msoButtonDown, msoButtonUp)
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = IIf(IsPortg, "Inserir na C|fffd|lula Ativa quando Iniciou", "Insert in Active Cell When Started") & IIf(bFromAutoPopCell, " (AutoPopup)", "")
                    .Tag = "PopMenuTag"
                    .Parameter = "PopMenuClick94013"
                    '.OnAction = "'PopMenuClick ""PopMenuClick94013""'"
                    .State = IIf((lCellAsButTriggSlcIni And 4096) = 4096, msoButtonDown, msoButtonUp)
                End With
            End With

        End With


        With .Controls.Add(Type:=msoControlPopup)
            .Caption = IIf(IsPortg, "C|fffd|lula do Excel como Visor", "Excel Cell as Display")
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Ecoar Visor na C|fffd|lula Ativa quando Iniciou", "Echo Display in Active Cell When Started")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick94001"
                '.OnAction = "'PopMenuClick ""PopMenuClick94001""'"
                .State = IIf((lEchoDisplayInCellIni And 1) = 1, msoButtonDown, msoButtonUp)
                '.Enabled = Not bFromAutoPopCell
            End With
            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Ecoar s|fffd| em C|fffd|lulas com Formato de Tempo", "Echo Only on Time Format Cells")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick94002"
                '.OnAction = "'PopMenuClick ""PopMenuClick94002""'"
                .State = IIf((lEchoDisplayInCellIni And 2) = 2, msoButtonDown, msoButtonUp)
                .Enabled = (lEchoDisplayInCellIni And 1) = 1
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Auto-ocultar Cron|fffd|metro ao Afastar o Mouse", "Autohide Stopwatch When Mouse Move Away")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick94003"
                '.OnAction = "'PopMenuClick ""PopMenuClick94003""'"
                .State = IIf((lEchoDisplayInCellIni And 4) = 4, msoButtonDown, msoButtonUp)
                .Enabled = (lEchoDisplayInCellIni And 1) = 1
            End With
        End With


        With .Controls.Add(Type:=msoControlPopup)
            .BeginGroup = True
            .Caption = IIf(IsPortg, "M|fffd|ltiplas Inst|fffd|ncias", "Multiple Instances")
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Iniciar aos Iniciar em Outras Inst|fffd|ncias", "Attach Start to Start Buttons in Other Instances") & " *"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick151"
                '.OnAction = "'PopMenuClick ""PopMenuClick151""'"
                .State = IIf(bMultStartAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable And Not bMultStartStopsAttachIni And Not bMultStartStopInssAttachIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Iniciar aos Parar em Outras Inst|fffd|ncias", "Attach Start to Stop Buttons in Other Instances") & " |fffd|"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick1511"
                '.OnAction = "'PopMenuClick ""PopMenuClick154""'"
                .State = IIf(bMultStartStopsAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable And Not bMultStartAttachIni And Not bMultStartStopInssAttachIni    'And Not bMultStopAttachIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Iniciar aos PararIns em Outras Inst|fffd|ncias", "Attach Start to StopIns Buttons in Other Instances") & " |fffd|"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick1512"
                '.OnAction = "'PopMenuClick ""PopMenuClick1112""'"
                .State = IIf(bMultStartStopInssAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable And Not bMultStartAttachIni And Not bMultStartStopsAttachIni    'And Not bMultStopAttachIni
            End With

            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Reiniciar aos Reiniciar em Outras Inst|fffd|ncias", "Attach Restart to Restart Buttons in Other Instances") & " *"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick152"
                '.OnAction = "'PopMenuClick ""PopMenuClick153""'"
                .State = IIf(bMultRestartAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable And Not bMultRestartStopsAttachIni And Not bMultRestartStopInssAttachIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Reiniciar aos Parar em Outras Inst|fffd|ncias", "Attach Restart to Stop Buttons in Other Instances") & " |fffd|"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick1521"
                '.OnAction = "'PopMenuClick ""PopMenuClick154""'"
                .State = IIf(bMultRestartStopsAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable And Not bMultRestartAttachIni And Not bMultRestartStopInssAttachIni   'And Not bMultStopAttachIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Reiniciar aos PararIns em Outras Inst|fffd|ncias", "Attach Restart to StopIns Buttons in Other Instances") & " |fffd|"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick1522"
                '.OnAction = "'PopMenuClick ""PopMenuClick154""'"
                .State = IIf(bMultRestartStopInssAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable And Not bMultRestartAttachIni And Not bMultRestartStopsAttachIni    'And Not bMultStopAttachIni
            End With

            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Parar aos Parar em Outras Inst|fffd|ncias", "Attach Stop to Stop Buttons in Other Instances") & " *"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick153"
                '.OnAction = "'PopMenuClick ""PopMenuClick152""'"
                .State = IIf(bMultStopAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable    'And Not bMultStartStopsAttachIni And Not bMultRestartStopsAttachIni And Not bMultStartStopInssAttachIni And Not bMultRestartStopInssAttachIni  'Comentei aqui e dois acima, pois parece n|fffd|o haver problema em atar Stops enquanto estes est|fffd|o atados a Starts, mas vou disatar sempre que atar cruzado.
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o PararIns aos PararIns em Outras Inst|fffd|ncias", "Attach StopIns to StopIns Buttons in Other Instances") & " *"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick154"
                '.OnAction = "'PopMenuClick ""PopMenuClick154""'"
                .State = IIf(bMultStopInsAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Atar Bot|fffd|o Zerar aos Zerar em Outras Inst|fffd|ncias", "Attach Reset to Reset Buttons in Other Instances") & " *"
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick155"
                '.OnAction = "'PopMenuClick ""PopMenuClick155""'"
                .State = IIf(bMultResetAttachIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bMultDisable
            End With

            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Desabilitar M|fffd|ltiplas Inst|fffd|ncias", "Disable Multiple Instances")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick156"
                '.OnAction = "'PopMenuClick ""PopMenuClick156""'"
                .State = IIf(bMultDisable, msoButtonDown, msoButtonUp)
            End With
        End With

        With .Controls.Add(Type:=msoControlPopup)
            .Caption = IIf(IsPortg, "Sons", "Sounds")
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Som Ao Iniciar", "Sound At Start")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick161"
                '.OnAction = "'PopMenuClick ""PopMenuClick161""'"
                .State = IIf(bSndAtStartIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bSndDisableAllIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Som Ao Parar", "Sound At Stop")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick162"
                '.OnAction = "'PopMenuClick ""PopMenuClick162""'"
                .State = IIf(bSndAtStopIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bSndDisableAllIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Som Ao Reiniciar", "Sound At Restart")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick163"
                '.OnAction = "'PopMenuClick ""PopMenuClick163""'"
                .State = IIf(bSndAtRestartIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bSndDisableAllIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Som Ao PararIns", "Sound At StopIns")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick164"
                '.OnAction = "'PopMenuClick ""PopMenuClick164""'"
                .State = IIf(bSndAtStopInsIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bSndDisableAllIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Som Ao Instant|fffd|neo", "Sound At Snapshot")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick165"
                '.OnAction = "'PopMenuClick ""PopMenuClick165""'"
                .State = IIf(bSndAtSnapshotIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bSndDisableAllIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = IIf(IsPortg, "Som Ao Zerar", "Sound At Reset")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick166"
                '.OnAction = "'PopMenuClick ""PopMenuClick166""'"
                .State = IIf(bSndAtResetIni, msoButtonDown, msoButtonUp)
                .Enabled = Not bSndDisableAllIni
            End With
            With .Controls.Add(Type:=msoControlButton)
                .BeginGroup = True
                .Caption = IIf(IsPortg, "Desabilitar Todos os Sons", "Disable All Sounds")
                .Tag = "PopMenuTag"
                .Parameter = "PopMenuClick167"
                '.OnAction = "'PopMenuClick ""PopMenuClick167""'"
                .State = IIf(bSndDisableAllIni, msoButtonDown, msoButtonUp)
            End With
        End With

        With .Controls.Add(Type:=msoControlButton)
            .Caption = IIf(IsPortg, "Configura|fffd||fffd|es de Face...", "Skin Settings...")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick16"
            '.OnAction = "'PopMenuClick ""PopMenuClick16""'"
        End With

        With .Controls.Add(Type:=msoControlButton)
            .BeginGroup = True
            .Caption = IIf(IsPortg, "Restaurar Configura|fffd||fffd|o Padr|fffd|o", "Restore Default Setting")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick159"
            '.OnAction = "'PopMenuClick ""PopMenuClick159""'"
            .Enabled = IsNotDftSetting
        End With
        With .Controls.Add(Type:=msoControlButton)
            .Caption = IIf(IsPortg, "Abrir Configura|fffd||fffd|o...", "Open Setting...")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick157"
            '.OnAction = "'PopMenuClick ""PopMenuClick157""'"
        End With
        With .Controls.Add(Type:=msoControlButton)
            .Caption = IIf(IsPortg, "Salvar Configura|fffd||fffd|o Como...", "Save Setting As...")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick158"
            '.OnAction = "'PopMenuClick ""PopMenuClick158""'"
        End With

        With .Controls.Add(Type:=msoControlButton)
            .BeginGroup = True
            .Caption = IIf(IsPortg, "Fechar", "Close")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick17"
            '.OnAction = "'PopMenuClick ""PopMenuClick17""'"
        End With
        With .Controls.Add(Type:=msoControlButton)
            .Caption = IIf(IsPortg, "Fechar Todas as Inst|fffd|ncias Abertas", "Close All Open Instances")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick18"
            '.OnAction = "'PopMenuClick ""PopMenuClick18""'"
            .Visible = CollectionInst.Count > 1
        End With
        With .Controls.Add(Type:=msoControlButton)
            .Caption = IIf(IsPortg, "Sair", "Exit")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick19"
            '.OnAction = "'PopMenuClick ""PopMenuClick19""'"
        End With

        With .Controls.Add(Type:=msoControlButton)
            .BeginGroup = True
            .Caption = IIf(IsPortg, "Sobre o Cron|fffd|metro", "About Stopwatch")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick20"
            '.OnAction = "'PopMenuClick ""PopMenuClick20""'"
        End With

        With .Controls.Add(Type:=msoControlButton)
            .Caption = IIf(IsPortg, "Desinstalar ou Desconectar...", "Uninstall or Disconnect...")
            .Tag = "PopMenuTag"
            .Parameter = "PopMenuClick21"
            '.OnAction = "'PopMenuClick ""PopMenuClick21""'"
            '            .Visible = bIsCOMAddin 'Como n|fffd|o pretendo distribuir o xla, vou fazer instru|fffd||fffd|es s|fffd| para COM add-in
        End With

        Set vClassPopMenuEv = New ClassPopMenuEv

        On Error Resume Next
        SetForegroundWindow App_hWnd    'No PowerPoint < 10, bCOMinDebug e Excel 2013 SDI falha, se n|fffd|o ativar. Antes usei GetActWinCaption, mas o evento Activate de FormMyMsgBox n|fffd|o vai disparava. N|fffd|o sei porque mesmo usando DoEvent
        Dim WinEst As WINDOWPLACEMENT, rtn As Long: WinEst.Length = Len(WinEst): rtn = GetWindowPlacement(App_hWnd, WinEst)
        If rtn = 1 And WinEst.showCmd = SW_SHOWMINIMIZED Then ShowWindow App_hWnd, SW_RESTORE: SetForegroundWindow Form_hWnd1: bAppMinimized = True      'Se n|fffd|o tiver ancorado na janela do App e esta estiver minimizada, o popup falha, ent|fffd|o restaura e depois minimiza s|fffd| no final Menu_Lb_Click se n|fffd|o o evento Activate de FormMyMsgBox n|fffd|o dispara tamb|fffd|m. Usei API para todos, pois o Access n|fffd|o tem WindowState property e |fffd| mais est|fffd|vel dispensando MyWait
        .ShowPopup
        SetForegroundWindow Form_hWnd1

    End With
    appHostApp.CommandBars("PopMenuBar6").Delete
    Set PopMenuBar6 = Nothing
    Set vClassPopMenuEv = Nothing
End Sub

'Private Sub PopMenuClick()
''Posi|fffd||fffd|o do menu clickado. Separa|fffd||fffd|o conta
'    PopMenuOpt = appHostApp.Caller(1)
'End Sub

Sub ShortMenuPos(vAdd As Long, Optional vPosDown As Boolean = True)
'vAdd: 0-Exclui 1-Adiciona 2-Move, se existir
    Select Case appHostApp.Name
    Case "Microsoft Excel"
        AddMenu "Cell", vAdd, vPosDown
        AddMenu "XLM Cell", vAdd, vPosDown
    Case "Microsoft Word"
        Dim bNormSvd As Boolean
        bNormSvd = appHostApp.NormalTemplate.Saved
        AddMenu "Text", vAdd, vPosDown
        AddMenu "Table Text", vAdd, vPosDown
        AddMenu "Fields", vAdd, vPosDown
        AddMenu "Form Fields", vAdd, vPosDown
        AddMenu "Headings", vAdd, vPosDown
        appHostApp.NormalTemplate.Saved = bNormSvd
    Case "Microsoft PowerPoint"
        AddMenu "Shapes", vAdd, vPosDown
        AddMenu "Spelling", vAdd, vPosDown
        AddMenu "Table Cells", vAdd, vPosDown
        AddMenu "Frames", vAdd, vPosDown
        If dHostAppVer > 9 Then AddMenu "Slide Gap", vAdd, vPosDown
        '        AddMenu "Tables", vAdd, vPosDown
        '        AddMenu "Outliner", vAdd, vPosDown
        '        AddMenu "Slide Show", vAdd, vPosDown 'N|fffd|o funcionou
        '        AddMenu "Slide Show Short Popup", vAdd, vPosDown 'N|fffd|o funcionou
    Case "Microsoft Access"
        AddMenu "Table Design Datasheet Cell", vAdd, vPosDown
        AddMenu "Form View Popup", vAdd, vPosDown
        AddMenu "Form Datasheet", vAdd, vPosDown
        AddMenu "Form Datasheet Cell", vAdd, vPosDown
        AddMenu "Form View Subform Control", vAdd, vPosDown
        AddMenu "Query Design Datasheet Cell", vAdd, vPosDown
        AddMenu "Form View Control", vAdd, vPosDown
    End Select
End Sub

Sub ToolbarPos(vAdd As Long, Optional vPosDown As Boolean = True)
'vAdd: 0-Exclui 1-Adiciona 2-Move, se existir
    Select Case appHostApp.Name
    Case "Microsoft Excel"
        AddMenu "Standard", vAdd, vPosDown
        AddMenu "Chart Menu Bar", vAdd, vPosDown
    Case "Microsoft Word"
        Dim bNormSvd As Boolean
        bNormSvd = appHostApp.NormalTemplate.Saved
        AddMenu "Standard", vAdd, vPosDown
        appHostApp.NormalTemplate.Saved = bNormSvd
    Case "Microsoft PowerPoint"
        AddMenu "Standard", vAdd, vPosDown
    Case "Microsoft Access"
        AddMenu "Database", vAdd, vPosDown
        AddMenu "Formatting (Form/Report)", vAdd, vPosDown
        AddMenu "Table Datasheet", vAdd, vPosDown
    End Select
End Sub

Sub XlaExit()
    If HotKeyIni <> "" Then appHostApp.OnKey HotKeyIni, ""
    appHostApp.ThisWorkbook.Close False
End Sub

'Public Function GetbPopupFormatSel()
''Para ser usado pelo CellEasyEntry
'    GetbPopupFormatSel = bPopupFormatSel And bPopupSel
'End Function

Public Function fGetVersion(Optional lFlag As Long) As String
    If CollectionInst Is Nothing Then Set CollectionInst = New Collection
    If lFlag = 0 Then fGetVersion = "4.0.0"
    If lFlag = 1 Then fGetVersion = CollectionInst.Count
    If lFlag = 2 Then Cancel_Bt_ClickMult True: fGetVersion = 0
End Function

Sub WriteINISetting(Optional sINISavedByUsr As String)
    Dim sINIfile1 As String    'Necess|fffd|rio devido ao save as
    If sINISavedByUsr = "" Then
        If sINIfile = "" Then GetINIfile
        Dim bINInew As Boolean
        If VBA.FileSystem.Dir(sINIfile) = "" Then bINInew = True Else If VBA.FileSystem.FileLen(sINIfile) = 0 Then bINInew = True
        If bGetLastSetFail Then bINInew = True    'Se houve alguma falha na leitura considerar novo tamb|fffd|m
        sIniDateChk = CheckSum4(VBA.Strings.Format(IniDate, "mm/dd/yyyy"))
        sINIfile1 = sINIfile
    Else
        sINIfile1 = sINISavedByUsr
    End If


    On Error GoTo ErrorHandler
    hFile = FreeFile
    Open sINIfile1 For Output As #hFile
    Write #hFile, sFileDescr
    Write #hFile, IniDate
    Write #hFile, sIniDateChk

    Write #hFile, vModalIni
    Write #hFile, bPopupFormatSelIni
    Write #hFile, bPopupSelIni
    Write #hFile, HotKeyIni
    Write #hFile, lShortMenuPosIni
    Write #hFile, bResetAtPopupIni
    Write #hFile, bStartAtPopupIni
    Write #hFile, bSplitAtPopupIni
    Write #hFile, bSplitInBkGrAtPopupIni
    Write #hFile, bPaperRibbonIni
    Write #hFile, bPopupAtLastPosIni
    Write #hFile, dLastPosTopIni
    Write #hFile, dLastPosLeftIni

    Write #hFile, lModeIni
    Write #hFile, lNumDecimIni + 1  'Adiciona 1 para se ao ler for 0 considera indefinido e adota 2 o padr|fffd|o
    Write #hFile, lCtrlPanelSizeIni
    Write #hFile, lDispSizeIni
    Write #hFile, lStopInsModeIni
    Write #hFile, bInsActCelStartIni

    Write #hFile, bMultDisable
    Write #hFile, bMultStartAttachIni
    Write #hFile, bMultStopAttachIni
    Write #hFile, bMultRestartAttachIni
    Write #hFile, bMultStopInsAttachIni
    Write #hFile, bMultResetAttachIni

    Write #hFile, bUserNoteLastIni
    Write #hFile, lSnapshotNumbIni

    Write #hFile, bSndDisableAllIni
    Write #hFile, bSndAtStartIni
    Write #hFile, bSndAtStopIni
    Write #hFile, bSndAtRestartIni
    Write #hFile, bSndAtStopInsIni
    Write #hFile, bSndAtSnapshotIni
    Write #hFile, bSndAtResetIni
    Write #hFile, sWavSndAtStartIni
    Write #hFile, sWavSndAtStopIni
    Write #hFile, sWavSndAtRestartIni
    Write #hFile, sWavSndAtStopInsIni
    Write #hFile, sWavSndAtSnapshotIni
    Write #hFile, sWavSndAtResetIni

    Write #hFile, lClickOnDisplayIni
    Write #hFile, bEnableBackgrondIni
    Write #hFile, lColorBackgroundIni + 1  'Adiciona 1 para se ao ler for 0 considera indefinido e adota padr|fffd|o
    Write #hFile, sPictFileIni
    Write #hFile, lPictAlignmentIni + 1  'Adiciona 1 para se ao ler for 0 considera indefinido e adota padr|fffd|o
    Write #hFile, lPictSizeModeIni
    Write #hFile, bPictTilingIni
    Write #hFile, bTranspDisplayIni
    Write #hFile, bTranspCtrlPanelIni
    Write #hFile, bTranspSnapshotLbIni
    Write #hFile, bTranspPaperIni
    Write #hFile, bHideTitleBarIni

    Dim lCtrl As Long
    For lCtrl = 0 To 10
        Write #hFile, arrSnpshtLbIni(lCtrl)     'Snapshot labels
        Write #hFile, arrBackColorIni(lCtrl) + 1    'Background colors. Adiciona 1 para se ao ler for 0 considera indefinido e n|fffd|o a cor preta 0 e adota a cor padr|fffd|o
        Write #hFile, arrForeColorIni(lCtrl) + 1    'Foreground colors
        Write #hFile, arrbSndAtSnpshtLbIni(lCtrl)
        Write #hFile, arrsWavSndAtSnpshtLbIni(lCtrl)
    Next

    Write #hFile, lResetModeIni
    Write #hFile, bMultStartStopsAttachIni
    Write #hFile, bMultRestartStopsAttachIni
    Write #hFile, bAutoHideCtrlPanelIni
    Write #hFile, bAnchActCelStartIni
    Write #hFile, bAnchCelAdjWidthIni
    Write #hFile, bAnchCelAdjHeightIni
    Write #hFile, bUnanchExcelWinIni
    Write #hFile, bAlwaysOnTopIni
    Write #hFile, lToolbarPosIni
    Write #hFile, bMultStartStopInssAttachIni
    Write #hFile, bMultRestartStopInssAttachIni
    Write #hFile, lInsOvrCntsIni
    Write #hFile, lInsAlsoDTimeIni

    Write #hFile, lCDHourIni
    Write #hFile, lCDMinIni
    Write #hFile, lCDSecIni
    Write #hFile, lCDSecFractIni
    Write #hFile, bCDtoDTimeIni
    Write #hFile, dbCDtoDTimeIni
    Write #hFile, bCDBeepIni
    Write #hFile, lCDBeepIni
    Write #hFile, bCDQuitIni
    Write #hFile, bCDWavIni
    Write #hFile, sCDFileWavIni
    Write #hFile, bCDRunIni
    Write #hFile, sCDFileRunIni
    Write #hFile, bCDAlertIni
    Write #hFile, sCDTxtAlertIni
    Write #hFile, bCDStartIni
    Write #hFile, bCDSpeakIni
    Write #hFile, lCDSpeakIni
    Write #hFile, bCDRestartIni
    Write #hFile, bCDReCntdownIni

    Write #hFile, lOtherButtsModeIni
    Write #hFile, lCellAsButTriggSlcIni
    Write #hFile, lEchoDisplayInCellIni

    Close #hFile

    'Se foi criado novo com sucesso, alertar sobre nova vers|fffd|o se vers|fffd|o com mais de 1ano e meio
    If bINInew And Date > VerDate + 3 * 180 Then bAlertAboutNewVer = True
    Exit Sub
ErrorHandler:
    Close #hFile
    MyMsgBox IIf(IsPortg, "N|fffd|o foi poss|fffd|vel salvar a nova configura|fffd||fffd|o no arquivo INI em:", "It wasn't possible to save the new setting on INI file at:") & vbCrLf & sINIfile1, 1, sAddInCaptByApp & IIf(IsPortg, " - Erro! " & Err.Description, " - Error! " & Err.Description)
End Sub

Sub ReadINISetting(Optional sINISavedByUsr As String)
    Dim sINIfile1 As String    'Necess|fffd|rio devido ao open saved as
    If sINISavedByUsr = "" Then
        If sINIfile = "" Then GetINIfile    'Se ainda n|fffd|o tiver definido, define e fica valendo para ler e escrever
        sINIfile1 = sINIfile
    Else
        sINIfile1 = sINISavedByUsr
    End If
    bGetLastSetFail = False

    On Error Resume Next
    hFile = FreeFile
    Open sINIfile1 For Input As #hFile
    Input #hFile, Msg1
    If sINISavedByUsr <> "" And Msg1 <> sFileDescr Then
        Msg1 = IIf(IsPortg, "Arquivo: " & Dir(sINIfile1) & vbCrLf & "Caminho: " & Left(sINIfile1, Len(sINIfile1) - Len(Dir(sINIfile1))) & vbCrLf & vbCrLf & "Arquivo desconhecido ou corrompido! Abrir de qualquer maneira?", "File: " & Dir(sINIfile1) & vbCrLf & "Path: " & Left(sINIfile1, Len(sINIfile1) - Len(Dir(sINIfile1))) & vbCrLf & vbCrLf & "Unknown or corrupt file! Open anyway?")
        Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Falha! Abrindo Configura|fffd||fffd|o Salva Em:", " - Fail! Opening Saved Setting In:")
        If MyMsgBox(Msg1, 2, Msg2) = 2 Then Close #hFile: Exit Sub
    End If

    If sINISavedByUsr <> "" Then    'Se lendo SavedSetting by user ignore date instalation
        Input #hFile, Msg1
        Input #hFile, Msg1
    Else
        Input #hFile, IniDate
        Input #hFile, sIniDateChk
    End If
    Input #hFile, vModalIni
    Input #hFile, bPopupFormatSelIni
    Input #hFile, bPopupSelIni
    Input #hFile, HotKeyIni
    Input #hFile, lShortMenuPosIni
    Input #hFile, bResetAtPopupIni
    Input #hFile, bStartAtPopupIni
    Input #hFile, bSplitAtPopupIni
    Input #hFile, bSplitInBkGrAtPopupIni
    Input #hFile, bPaperRibbonIni
    Input #hFile, bPopupAtLastPosIni
    Input #hFile, dLastPosTopIni
    Input #hFile, dLastPosLeftIni

    Input #hFile, lModeIni
    Input #hFile, lNumDecimIni
    Input #hFile, lCtrlPanelSizeIni
    Input #hFile, lDispSizeIni
    Input #hFile, lStopInsModeIni
    Input #hFile, bInsActCelStartIni

    Input #hFile, bMultDisable
    Input #hFile, bMultStartAttachIni
    Input #hFile, bMultStopAttachIni
    Input #hFile, bMultRestartAttachIni
    Input #hFile, bMultStopInsAttachIni
    Input #hFile, bMultResetAttachIni

    Input #hFile, bUserNoteLastIni
    Input #hFile, lSnapshotNumbIni

    Input #hFile, bSndDisableAllIni
    Input #hFile, bSndAtStartIni
    Input #hFile, bSndAtStopIni
    Input #hFile, bSndAtRestartIni
    Input #hFile, bSndAtStopInsIni
    Input #hFile, bSndAtSnapshotIni
    Input #hFile, bSndAtResetIni
    Input #hFile, sWavSndAtStartIni
    Input #hFile, sWavSndAtStopIni
    Input #hFile, sWavSndAtRestartIni
    Input #hFile, sWavSndAtStopInsIni
    Input #hFile, sWavSndAtSnapshotIni
    Input #hFile, sWavSndAtResetIni

    Input #hFile, lClickOnDisplayIni
    Input #hFile, bEnableBackgrondIni
    Input #hFile, lColorBackgroundIni
    Input #hFile, sPictFileIni
    Input #hFile, lPictAlignmentIni
    Input #hFile, lPictSizeModeIni
    Input #hFile, bPictTilingIni
    Input #hFile, bTranspDisplayIni
    Input #hFile, bTranspCtrlPanelIni
    Input #hFile, bTranspSnapshotLbIni
    Input #hFile, bTranspPaperIni
    Input #hFile, bHideTitleBarIni

    Dim lCtrl As Long
    For lCtrl = 0 To 10
        Input #hFile, arrSnpshtLbIni(lCtrl)     'Snapshot labels
        Input #hFile, arrBackColorIni(lCtrl)     'Background colors
        Input #hFile, arrForeColorIni(lCtrl)     'Foreground colors
        Input #hFile, arrbSndAtSnpshtLbIni(lCtrl)
        Input #hFile, arrsWavSndAtSnpshtLbIni(lCtrl)
    Next

    Input #hFile, lResetModeIni
    Input #hFile, bMultStartStopsAttachIni
    Input #hFile, bMultRestartStopsAttachIni
    Input #hFile, bAutoHideCtrlPanelIni
    Input #hFile, bAnchActCelStartIni
    Input #hFile, bAnchCelAdjWidthIni
    Input #hFile, bAnchCelAdjHeightIni
    Input #hFile, bUnanchExcelWinIni
    Input #hFile, bAlwaysOnTopIni
    Input #hFile, lToolbarPosIni
    Input #hFile, bMultStartStopInssAttachIni
    Input #hFile, bMultRestartStopInssAttachIni
    Input #hFile, lInsOvrCntsIni
    Input #hFile, lInsAlsoDTimeIni

    Input #hFile, lCDHourIni
    Input #hFile, lCDMinIni
    Input #hFile, lCDSecIni
    Input #hFile, lCDSecFractIni
    Input #hFile, bCDtoDTimeIni
    Input #hFile, dbCDtoDTimeIni
    Input #hFile, bCDBeepIni
    Input #hFile, lCDBeepIni
    Input #hFile, bCDQuitIni
    Input #hFile, bCDWavIni
    Input #hFile, sCDFileWavIni
    Input #hFile, bCDRunIni
    Input #hFile, sCDFileRunIni
    Input #hFile, bCDAlertIni
    Input #hFile, sCDTxtAlertIni
    Input #hFile, bCDStartIni
    Input #hFile, bCDSpeakIni
    Input #hFile, lCDSpeakIni
    Input #hFile, bCDRestartIni
    Input #hFile, bCDReCntdownIni

    Msg1 = "": Msg2 = Err.Number     'No pr|fffd|ximo usa provisoriamente um String, assim ao falhar em ini antigo ou na falta faz = -1 para na cr|fffd|tica abaixo definir o default e ignorar erro.
    Input #hFile, Msg1: If IsNumeric(Msg1) Then lOtherButtsModeIni = Msg1 Else lOtherButtsModeIni = -1: If Msg2 = "0" Then Err.Clear
    Msg1 = ""
    Input #hFile, Msg1: If IsNumeric(Msg1) Then lCellAsButTriggSlcIni = Msg1 Else lCellAsButTriggSlcIni = -1: If Msg2 = "0" Then Err.Clear
    Msg1 = ""
    Input #hFile, Msg1: If IsNumeric(Msg1) Then lEchoDisplayInCellIni = Msg1 Else lEchoDisplayInCellIni = -1: If Msg2 = "0" Then Err.Clear

    Close #hFile

    If Err.Number <> 0 Then
        bGetLastSetFail = True    'Sinaliza para usa cfg padr|fffd|o e tentar ler novamente da pr|fffd|xima vez
    ElseIf sINISavedByUsr = "" Then
        'Se j|fffd| existir INI funcional:
        'Alertar sobre nova vers|fffd|o, se IniDate lido estiver corrompido, pois pode ter sido proposital
        If sIniDateChk <> CheckSum4(VBA.Strings.Format(IniDate, "mm/dd/yyyy")) Then
            bAlertAboutNewVer = True: IniDate = 0
        Else
            'Alertar sobre nova vers|fffd|o a cada seis meses. Para evitar cria|fffd||fffd|o proposital de ini com data muito no futuro, criticar
            'atraso de seis meses tamb|fffd|m, mas s|fffd| em data ap|fffd|s VerDate, assim suporta problema eventual no rel|fffd|gio do computador
            If Date >= VerDate Then If VBA.Math.Abs(Date - IniDate) > 180 Then bAlertAboutNewVer = True    'Alertar s|fffd| quando o utilit|fffd|rio for requisitado realmente de prefer|fffd|ncia em cima de um form, pois alertar ao trabalhar em bakground confunde
        End If
    End If

    If sINISavedByUsr <> "" And Err.Number <> 0 Then    'Alertar se falhar em alguma vari|fffd|vel ao usr saved setting
        Msg1 = IIf(IsPortg, "Arquivo: " & Dir(sINIfile1) & vbCrLf & "Caminho: " & Left(sINIfile1, Len(sINIfile1) - Len(Dir(sINIfile1))) & vbCrLf & vbCrLf & "Arquivo desconhecido ou corrompido!", "File: " & Dir(sINIfile1) & vbCrLf & "Path: " & Left(sINIfile1, Len(sINIfile1) - Len(Dir(sINIfile1))) & vbCrLf & vbCrLf & "Unknown or corrupt file!")
        Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Falha! Abrindo Configura|fffd||fffd|o Salva Em:", " - Fail! Opening Saved Setting In:")
        MyMsgBox Msg1, 1, Msg2
    End If

    'Criticar vari|fffd|veis obtidas
    If IniDate = 0 Then IniDate = Date
    If Not (vModalIni = 1 Or vModalIni = 0) Or vModalIni = "" Then vModalIni = 0: bHideTitleBarIni = True   'Booleans default true here to follow first set default by fail or by set default command.
    bPopupSelIni = True    'If Not (bPopupSelini = True Or bPopupSelini = False) Then bPopupSelini = False 'Desabilitei essa caracter|fffd|stica, pois a confus|fffd|o |fffd| maior que a utilidade. Se n|fffd|o quiser popup em cels desabilita no format e n|fffd|o define celss
    If Not (bResetAtPopupIni = True Or bResetAtPopupIni = False) Or bResetAtPopupIni = "" Then bResetAtPopupIni = True
    If bSplitAtPopupIni And bSplitInBkGrAtPopupIni Then bSplitAtPopupIni = False: bSplitInBkGrAtPopupIni = False    'Anormal os dois falsos
    If lModeIni < 1 Or lModeIni > 10 Then lModeIni = 3
    If lNumDecimIni < 0 + 1 Or lNumDecimIni > 5 + 1 Then lNumDecimIni = 2 Else lNumDecimIni = lNumDecimIni - 1
    If lCtrlPanelSizeIni < 3 Or lCtrlPanelSizeIni > 50 Then lCtrlPanelSizeIni = 10
    If lDispSizeIni < 2 Or lDispSizeIni > 500 Then lDispSizeIni = 26
    If lStopInsModeIni < 1 Or lStopInsModeIni > 6 Then lStopInsModeIni = 1    'StpInsCls default e antigo
    If lInsOvrCntsIni < 1 Or lInsOvrCntsIni > 6 Then lInsOvrCntsIni = 1       'Insert overwriting default e antigo
    If lInsAlsoDTimeIni < 1 Or lInsAlsoDTimeIni > 6 Then lInsAlsoDTimeIni = 1       'Not insert default e antigo
    If lClickOnDisplayIni < 0 Or lClickOnDisplayIni > 4 Then lClickOnDisplayIni = 0    '
    'Vari|fffd|veis Boolean de padr|fffd|o falso n|fffd|o precisa criticar. Quando o padr|fffd|o |fffd| True tem que ser definida como variant para criticar como em bResetAtPopupini

    If HotKeyIni <> "" Then If Not fHotKey(HotKeyIni, True, True) Then HotKeyIni = ""    'Falhou limpa. Talvez isto n|fffd|o seja necess|fffd|rio

    If bUserNoteLastIni = Empty Or Not (bUserNoteLastIni = True Or bUserNoteLastIni = False) Then bUserNoteLastIni = True
    If lSnapshotNumbIni < 0 Or lSnapshotNumbIni > 10 Then lSnapshotNumbIni = 0
    For lCtrl = 0 To 10
        If arrBackColorIni(lCtrl) < 1 Or arrBackColorIni(lCtrl) > &HFFFFFF + 1 Then arrBackColorIni(lCtrl) = IIf(lCtrl = 0, &H8000&, &HFFFFFF) Else arrBackColorIni(lCtrl) = arrBackColorIni(lCtrl) - 1    'Background colors
        If arrForeColorIni(lCtrl) < 1 Or arrForeColorIni(lCtrl) > &HFFFFFF + 1 Then arrForeColorIni(lCtrl) = IIf(lCtrl = 0, &HFFFF00, &H0&) Else arrForeColorIni(lCtrl) = arrForeColorIni(lCtrl) - 1    'Foreground colors
    Next

    If lColorBackgroundIni < 1 Or lColorBackgroundIni > &HFFFFFF + 1 Then lColorBackgroundIni = &H8000000F Else lColorBackgroundIni = lColorBackgroundIni - 1    'Background color
    If lPictAlignmentIni < 0 + 1 Or lPictAlignmentIni > 4 + 1 Then lPictAlignmentIni = 2 Else lPictAlignmentIni = lPictAlignmentIni - 1

    If lResetModeIni < 1 Or lResetModeIni > 4 Then lResetModeIni = 1    'Reset only default e antigo

    If lShortMenuPosIni < 0 Or lShortMenuPosIni > 2 Then lShortMenuPosIni = 2
    If lToolbarPosIni < 0 Or lToolbarPosIni > 2 Then lToolbarPosIni = 0
    If lShortMenuPosIni = 0 And lToolbarPosIni = 0 Then lShortMenuPosIni = 2    'Tem que ter um bot|fffd|o, embora ainda possa ter hotkey e autopop

    If lOtherButtsModeIni < 0 Or lOtherButtsModeIni > (1 Or 2 Or 4 Or 8 Or 16 Or 32 Or 64) Then lOtherButtsModeIni = 0    'Bitwise
    If lCellAsButTriggSlcIni < 0 Or lCellAsButTriggSlcIni > (1 Or 2 Or 4 Or 8 Or 16 Or 32 Or 64 Or 128 Or 256 Or 512 Or 1024 Or 2048 Or 4096) Then lCellAsButTriggSlcIni = (0 Or 2 Or 4 Or 256 Or 2048)    'Bitwise
    If lEchoDisplayInCellIni < 0 Or lEchoDisplayInCellIni > (1 Or 2 Or 4) Then lEchoDisplayInCellIni = (0 Or 2 Or 4)      'Bitwise
End Sub

Function IsNotDftSetting() As Boolean    'Verify if setting is default. The same ReadINISetting structure and value after reading a blank ini file
    IsNotDftSetting = _
    vModalIni <> 0 Or _
    bPopupFormatSelIni Or _
                      bPopupSelIni = False Or _
                      HotKeyIni <> "" Or _
                      lShortMenuPosIni <> 2 Or _
                      bResetAtPopupIni = False Or _
                      bStartAtPopupIni Or _
                      bSplitAtPopupIni Or _
                      bSplitInBkGrAtPopupIni Or _
                      bPaperRibbonIni Or _
                      bPopupAtLastPosIni: If IsNotDftSetting Then Exit Function
    'dLastPosTopIni
    'dLastPosLeftIni

    IsNotDftSetting = _
    lModeIni <> 3 Or _
    lNumDecimIni <> 2 Or _
                      lCtrlPanelSizeIni <> 10 Or _
                      lDispSizeIni <> 26 Or _
                      lStopInsModeIni <> 1 Or _
                      lInsOvrCntsIni <> 1 Or _
                      lInsAlsoDTimeIni <> 1 Or _
                      bInsActCelStartIni: If IsNotDftSetting Then Exit Function

    IsNotDftSetting = _
    bMultDisable Or _
    bMultStartAttachIni Or _
                      bMultStopAttachIni Or _
                      bMultRestartAttachIni Or _
                      bMultStopInsAttachIni Or _
                      bMultResetAttachIni: If IsNotDftSetting Then Exit Function

    IsNotDftSetting = _
    bUserNoteLastIni = False Or _
                      lSnapshotNumbIni <> 0: If IsNotDftSetting Then Exit Function

    IsNotDftSetting = _
    bSndDisableAllIni Or _
                      bSndAtStartIni Or _
                      bSndAtStopIni Or _
                      bSndAtRestartIni Or _
                      bSndAtStopInsIni Or _
                      bSndAtSnapshotIni Or _
                      bSndAtResetIni Or _
                      sWavSndAtStartIni <> "" Or _
                      sWavSndAtStopIni <> "" Or _
                      sWavSndAtRestartIni <> "" Or _
                      sWavSndAtStopInsIni <> "" Or _
                      sWavSndAtSnapshotIni <> "" Or _
                      sWavSndAtResetIni <> "": If IsNotDftSetting Then Exit Function

    IsNotDftSetting = _
    lClickOnDisplayIni <> 0 Or _
                      bEnableBackgrondIni Or _
                      lColorBackgroundIni <> -2147483633 Or _
                      sPictFileIni <> "" Or _
                      lPictAlignmentIni <> 2 Or _
                      lPictSizeModeIni <> 0 Or _
                      bPictTilingIni Or _
                      bTranspDisplayIni Or _
                      bTranspCtrlPanelIni Or _
                      bTranspSnapshotLbIni Or _
                      bTranspPaperIni Or _
                      bHideTitleBarIni = False: If IsNotDftSetting Then Exit Function

    Dim lCtrl As Long
    For lCtrl = 0 To 10
        IsNotDftSetting = _
        arrSnpshtLbIni(lCtrl) <> "" Or _
                          (lCtrl > 0 And arrBackColorIni(lCtrl) <> 16777215) Or _
                          (lCtrl > 0 And arrForeColorIni(lCtrl) <> 0) Or _
                          arrbSndAtSnpshtLbIni(lCtrl) Or _
                          arrsWavSndAtSnpshtLbIni(lCtrl) <> "": If IsNotDftSetting Then Exit Function
    Next

    IsNotDftSetting = _
    lResetModeIni <> 1 Or _
                      bMultStartStopsAttachIni Or _
                      bMultRestartStopsAttachIni Or _
                      bAutoHideCtrlPanelIni Or _
                      bAnchActCelStartIni Or _
                      bAnchCelAdjWidthIni Or _
                      bAnchCelAdjHeightIni Or _
                      bUnanchExcelWinIni Or _
                      bAlwaysOnTopIni Or _
                      lToolbarPosIni <> 0 Or _
                      bMultStartStopInssAttachIni Or _
                      bMultRestartStopInssAttachIni Or _
                      lOtherButtsModeIni <> 0 Or _
                      lCellAsButTriggSlcIni <> (0 Or 2 Or 4 Or 256 Or 2048) Or _
                      lEchoDisplayInCellIni <> (0 Or 2 Or 4)
End Function

Sub GetINIfile()
    Dim i As Long

    'Primeiro tenta junto ao xla, se falhar vai para o temp. Normalmente em usu|fffd|rio Restrito.
    Select Case appHostApp.Name
    Case "Microsoft Excel", "Microsoft Word"
        sPathSep = appHostApp.PathSeparator
        sINIfile = IIf(LCase(ThisDLLPath) = LCase(appHostApp.StartupPath), appHostApp.StartupPath & sPathSep & "..", _
                       ThisDLLPath) & sPathSep & sAddInNameByApp & ".ini"
    Case "Microsoft PowerPoint", "Microsoft Access"
        sPathSep = "\"
        sINIfile = ThisDLLPath & sPathSep & sAddInNameByApp & ".ini"
    End Select

    On Error Resume Next
    For i = 1 To 3
        Err.Number = 0
        hFile = FreeFile
        'Open sINIfile For Binary Lock Write As #hFile 'Only for write
        Open sINIfile For Append As #hFile                        'For read and write
        Close #hFile
        If Err.Number = 0 Then Exit For
        MyWait 0.3
    Next

    If Err.Number <> 0 Then
        If TempFolder <> "" Then
            'Em Temp tenta a subpasta OrlandoApp, se n|fffd|o existir cria e se n|fffd|o tiver sucesso vai no raiz mesmo
            If VBA.FileSystem.Dir(TempFolder & sPathSep & "OrlandoApp", vbDirectory) <> "" Then
                sINIfile = TempFolder & sPathSep & "OrlandoApp" & sPathSep & sAddInNameByApp & ".ini"
            Else
                Err.Clear
                VBA.FileSystem.MkDir TempFolder & sPathSep & "OrlandoApp"
                If Err.Number <> 0 Then
                    sINIfile = TempFolder & sPathSep & sAddInNameByApp & ".ini"
                Else
                    sINIfile = TempFolder & sPathSep & "OrlandoApp" & sPathSep & sAddInNameByApp & ".ini"
                End If
            End If
        End If
    End If

    sFileDescr = IIf(IsPortg, ";Este arquivo cont|fffd|m a configura|fffd||fffd|o inicial de " & sAddInCaptByApp & ". Ele pode ser exclu|fffd|do sem problemas", ";This file contains the initial setting of " & sAddInCaptByApp & ". It can delete without problems.")
End Sub

Function TempFolder() As String
'Get Temp Folder
    Dim fctRet As Long
    TempFolder = String$(255, 0)
    fctRet = GetTempPath(255, TempFolder)
    If fctRet <> 0 Then
        TempFolder = VBA.Left(TempFolder, fctRet)
        If Right(TempFolder, 1) = sPathSep Then TempFolder = VBA.Left(TempFolder, Len(TempFolder) - 1)
    Else
        TempFolder = ""
    End If
End Function

Public Sub AlertAboutNewVer()
    Static lDelay As Long

    If lDelay <> 0 Then Exit Sub    'Alerta uma |fffd|nica vez a cada execu|fffd||fffd|o
    If IniDate = 0 Then ReadINISetting    'Ler vari|fffd|veis, se ainda n|fffd|o tiver lido
    If bGetLastSetFail Then WriteINISetting    'Salva vari|fffd|veis padr|fffd|o, se houve falha na |fffd|ltima leitura
    If Not bAlertAboutNewVer Then Exit Sub    'Se em read e write n|fffd|o houve justificativa para alert sai

    If IsPortg Then
        Msg1 = "Esta vers|fffd|o j|fffd| tem mais de seis meses:" & vbCrLf & vbCrLf & _
               "OK - Suspender este alerta por um ou seis meses se conseguir abrir a homepage para voc|fffd| visitar e ver atualiza|fffd||fffd|es ou" & vbCrLf & vbCrLf & _
               "Cancelar - Alertar novamente na pr|fffd|xima execu|fffd||fffd|o. Se Ctrl + Shift estiverem pressionados, este alerta tamb|fffd|m ser|fffd| suspenso por seis meses sem visita |fffd| homepage."
        Msg2 = sAddInCaptByApp
    Else
        Msg1 = "This version already has more than six months:" & vbCrLf & vbCrLf & _
               "OK - Suspend this alert for one or six months if it gets to open the homepage for you visit and see updates or" & vbCrLf & vbCrLf & _
               "Cancel - Alert again in the next execution. If Ctrl + Shift are pushed, this alert will be suspended too for six month without homepage visit."
        Msg2 = sAddInCaptByApp
    End If
    If MyMsgBox(Msg1, 2, Msg2) = 2 Then
        lDelay = 1
    Else
        lDelay = 2
        On Error Resume Next
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            appHostApp.ActiveWorkbook.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True  'DifAppMet
        Case "Microsoft Word"
            appHostApp.ActiveDocument.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True
        Case "Microsoft PowerPoint"
            appHostApp.ActivePresentation.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True
        Case "Microsoft Access"
            appHostApp.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True
        End Select
        If Err.Number <> 0 Then MsgBox Err.Description Else lDelay = 3: MyWait 2: VBA.Interaction.AppActivate GetAppWinCaption
    End If
    If CtrlDown And ShiftDown Then
        lDelay = 3
        Do While CtrlDown Or ShiftDown: MyWait 0.1: Loop
    End If
    If lDelay > 1 Then    'Se n|fffd|o vai adiar n|fffd|o precisa salvar e em cancelamento |fffd| melhor n|fffd|o alterar nada, pois pode ser algum desajuste no rel|fffd|gio conhecido pelo usu|fffd|rio.
        IniDate = Date + Choose(lDelay, 0, -150, 0)
        WriteINISetting
    End If
End Sub

Function GetActWinCaption() As String
    Dim vStr As String
    Dim ret As Long
    vStr = String(GetWindowTextLength(GetActiveWindow), Chr$(0))
    ret = GetWindowText(GetActiveWindow, vStr, Len(vStr) + 1)
    If ret <> 0 Then
        GetActWinCaption = vStr
    End If
End Function

Function GetAppWinCaption() As String
    Dim vStr As String
    Dim ret As Long
    vStr = String(GetWindowTextLength(App_hWnd), Chr$(0))
    ret = GetWindowText(App_hWnd, vStr, Len(vStr) + 1)
    If ret <> 0 Then
        GetAppWinCaption = vStr
    End If
    If appHostApp.Name = "Microsoft Excel" And InStr(1, vStr, "Microsoft Visual Basic - ") > 0 Then GetAppWinCaption = appHostApp.Caption    'Rerun em debug o titulo do app altera para a jan do VBE
End Function

Function ThisDLLPath() As String
    Static sDllPath As String
    If sDllPath <> "" Then ThisDLLPath = sDllPath: Exit Function
    If bIsCOMAddin Then
        Dim sProjectRef As String
        Dim sGuid As String
        On Error Resume Next
        sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\CLSID", "")
        sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "CLSID\" & sGuid & "\InprocServer32", "")
        If InStr(1, UCase(sDllPath), UCase("\vb6debug.dll")) Then    'In debug mode
            sDllPath = "T:\ComoMVP\MeuSite\Projetos\" & Replace(sAddInNameByApp, Replace(appHostApp.Name, "Microsoft ", ""), "") & "\" & sAddInNameByApp
            bCOMinDebug = True
        Else
            If Dir(sDllPath) <> "" Then sDllPath = VBA.Left(sDllPath, Len(sDllPath) - Len(Dir(sDllPath)) - 1) Else sDllPath = ""
        End If
        If Err.Number <> 0 Then sDllPath = ""
    Else
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            sDllPath = appHostApp.ThisWorkbook.Path
        Case "Microsoft Word"
            Dim d    'Pode ser document ou add-in
            For Each d In appHostApp.Documents
                If sDllPath <> "" Then Exit For
                If d.Name = "WordStopwatch.dot" Then sDllPath = d.Path
            Next
            For Each d In appHostApp.AddIns
                If sDllPath <> "" Then Exit For
                If d.Name = "WordStopwatch.dot" Then sDllPath = d.Path
            Next
        Case "Microsoft PowerPoint"
            For Each d In appHostApp.AddIns
                If sDllPath <> "" Then Exit For
                If d.Name = "PowerPointStopwatch" Then sDllPath = d.Path
            Next
        Case "Microsoft Access"
            sDllPath = appHostApp.CurrentProject.Path
        End Select
    End If
    ThisDLLPath = sDllPath
End Function

Public Function CellHasTimeFormat(sFormat As String) As Boolean
    Dim f
    For Each f In Array("h:m", "h:s", "m:h", "m:s", "s:h", "s:m", "m]:s")
        If InStr(1, sFormat, f) > 0 Then
            CellHasTimeFormat = True
            Exit Function
        End If
    Next
End Function

Public Function IsTimeExtend(ByVal vValueIni, Optional TimeValueRet, Optional bNegatSign As Boolean) As Boolean
'Verify if vValueIni, a variant numeric or text, can be time, returning time and sign by argument ref
    IsTimeExtend = True
    On Error Resume Next    'N|fffd|o parece necess|fffd|rio, mas vou deixa
    If IsNumeric(vValueIni) Then
        If vValueIni * 1 < 0 Then    'Se capt. um n|fffd|mero puro negativo marcar para tempo negativo (contagem regressiva)
            vValueIni = "@" & CDec(vValueIni)
        ElseIf TypeName(vValueIni) = "String" Then   'Se capt. um n|fffd|mero e for texto, marcar para completar formato de tempo
            vValueIni = "@" & vValueIni
        End If
    End If

    If IsNumeric(vValueIni) Then
        If vValueIni < 24522 Then    'Limitei o tempo a 24522 dias (aprox. 67 anos), pois |fffd| o m|fffd|x. suportado sem overflow em WriteTbVisor().              .
            vValueIni = vValueIni * 24 * 60 * 60
        Else    'Tempos maiores considera como date/time e descarta o date.
            vValueIni = (vValueIni - Int(vValueIni)) * 24 * 60 * 60
        End If
    ElseIf IsDate(vValueIni) Then
        'Verf. se o text tem formato de date/time. E tambem, se vValueIni Variant/Date como pode vir por fStopwatch de apenas dias, o IsNumeric n|fffd|o reconhece como n|fffd|mero.
        vValueIni = CDate(vValueIni) * 1
        If CDbl(vValueIni) < 24522 Then    'Limitei o tempo a 24522 dias (aprox. 67 anos), pois |fffd| o m|fffd|x. suportado sem overflow em WriteTbVisor().              .
            vValueIni = CDbl(vValueIni) * 24 * 60 * 60
        Else    'Tempos maiores considera como date/time e descarta o date.
            vValueIni = (CDbl(vValueIni) - Int(vValueIni)) * 24 * 60 * 60
        End If
    ElseIf InStr(1, vValueIni, "|fffd|") + InStr(1, vValueIni, "|fffd|") + InStr(1, vValueIni, "'") + InStr(1, vValueIni, """") > 0 Then
        'Converter grau, min e sec somando em um dec de seconds e reconv para text no format de :
        If VBA.Left(vValueIni, 1) = "-" Then bNegatSign = True
        If VBA.Left(vValueIni, 1) = "(" And Right(vValueIni, 1) = ")" Then bNegatSign = True
        vValueIni = GetGrdMinSec("|fffd|") * 60 * 60 + GetGrdMinSec("|fffd|") * 60 * 60 + GetGrdMinSec("'") * 60 + GetGrdMinSec("""")
    Else
        Dim vValueIniFrac
        If VBA.Left(vValueIni, 1) = "@" Then vValueIni = Mid(vValueIni, 2)

        ' Verf. se o text pode ser tempo, se negativo validar para contagem regressiva
        If VBA.Left(vValueIni, 1) = "-" Then vValueIni = Mid(vValueIni, 2): bNegatSign = True
        If VBA.Left(vValueIni, 2) = "'-" Then vValueIni = Mid(vValueIni, 3): bNegatSign = True
        If VBA.Left(vValueIni, 2) = "(-" And Right(vValueIni, 1) = ")" Then vValueIni = Mid(vValueIni, 3, Len(vValueIni) - 3): bNegatSign = True
        If VBA.Left(vValueIni, 1) = "(" And Right(vValueIni, 1) = ")" Then vValueIni = Mid(vValueIni, 2, Len(vValueIni) - 2): bNegatSign = True
        If VBA.Left(vValueIni, 1) = "'" Then vValueIni = Mid(vValueIni, 2)

        If InStr(1, vValueIni, ".") > 0 Then     'Qualquer valor n|fffd|m. ap|fffd|s , ou . ser|fffd| tido como d|fffd|cimos de seg.
            vValueIniFrac = Mid(vValueIni, InStr(1, vValueIni, ".") + 1)
            vValueIni = VBA.Left(vValueIni, InStr(1, vValueIni, ".") - 1)
        End If
        If InStr(1, vValueIni, ",") > 0 Then
            vValueIniFrac = Mid(vValueIni, InStr(1, vValueIni, ",") + 1)
            vValueIni = VBA.Left(vValueIni, InStr(1, vValueIni, ",") - 1)
        End If

        If Len(vValueIni) - Len(Replace(vValueIni, ":", "")) = 0 Then vValueIni = "00:" & vValueIni
        If Len(vValueIni) - Len(Replace(vValueIni, ":", "")) = 1 Then vValueIni = "00:" & vValueIni
        Dim lDays As Long    'Na vers|fffd|o 4.0 reconhece o formato com days, tipo d hh:mm:ss, tamb|fffd|m como de tempo. Extraindo e adicionando em seguida.
        If InStr(1, vValueIni, " ") > 0 Then If InStr(1, vValueIni, " ") < InStr(1, vValueIni, ":") Then If IsNumeric(Left(vValueIni, InStr(1, vValueIni, " ") - 1)) Then lDays = Left(vValueIni, InStr(1, vValueIni, " ") - 1): vValueIni = Trim(Mid(vValueIni, InStr(1, vValueIni, " ") + 1))

        If IsDate(vValueIni) And IsNumeric(vValueIniFrac) Then    'Na vers|fffd|o 4.0 exige numeric para Frac tamb|fffd|m, pois onde tinha '2.0 days' validava como no ex. AuctionCountdown1.xls.
            If Not IsNumeric(vValueIniFrac) Or vValueIniFrac = Empty Then vValueIniFrac = "0" Else vValueIniFrac = VBA.Left(vValueIniFrac, 10)
            vValueIni = Hour(vValueIni) * 60 * 60 + Minute(vValueIni) * 60 + Second(vValueIni) + CLng(vValueIniFrac) / 10 ^ Len(vValueIniFrac) + lDays * 24 * 60 * 60
        Else
            IsTimeExtend = False: bNegatSign = False
            vValueIni = 0
        End If
    End If
    TimeValueRet = vValueIni
    On Error GoTo 0
End Function

Private Function GetGrdMinSec(sGMS As String) As Double
    Dim i As Long
    Dim i1 As Long
    Dim i2 As String
    i = InStr(1, CronometroElapsedIni, sGMS)
    If i = 0 Then Exit Function

    For i1 = i - 1 To 1 Step -1
        If IsNumeric(Mid(CronometroElapsedIni, i1, 1)) Then
            i2 = Mid(CronometroElapsedIni, i1, 1) & i2
        ElseIf InStr(1, CronometroElapsedIni, ".") = 0 And (Mid(CronometroElapsedIni, i1, 1) = "," Or Mid(CronometroElapsedIni, i1, 1) = ".") Then
            i2 = "." & i2
        Else
            Exit For
        End If
    Next
    GetGrdMinSec = Val(i2)
End Function

Public Function ShiftDown()
'Verif. se shift est|fffd| pressionada
    ShiftDown = (GetKeyState(16) < 0)
End Function

Public Function CtrlDown()
'Verif se Ctrl est|fffd| pressionada
    CtrlDown = (GetKeyState(17) < 0)
End Function

Function IsMouseDown(ByVal Button As MouseButtonConstants) As Boolean     'As MouseButtonConstants
    If Not GetSystemMetrics(SM_SWAPBUTTON) = 0 Then        'If user has swapped L-R buttons
        If Button = vbLeftButton Then
            Button = vbRightButton
        ElseIf Button = vbRightButton Then
            Button = vbLeftButton
        End If
    End If
    IsMouseDown = CBool(GetAsyncKeyState(Button) And &H8000)
End Function

Function CheckSum2(CheckString)
    Dim i
    Dim ac
    Dim cs
    For i = 1 To Len(CheckString)
        ac = ac + (i * Asc(Mid(CheckString, i, 1)))
    Next
    cs = (ac And &HFF0000) \ 65536    ' third byte
    cs = cs + (ac And &HFF00&) \ 256  ' + second byte
    cs = (cs + (ac And 255)) And 255  ' + low byte
    CheckSum2 = Right("0" & Hex(cs), 2)
End Function

Function CheckSum4(CheckString)
'Especial checksum com quatro caracteres
    CheckSum4 = CheckSum2(CheckString)
    CheckSum4 = CheckSum4 & CheckSum2("osftdgsgdj uyhtyp6jgj dj" & CheckSum4)
End Function
Attribute VB_Name = "Mod2StopwatchModeless"
Option Explicit
Public Declare Function GetTickCount Lib "kernel32" () As Long

Public vModalIni
Public bPopupFormatSelIni As Boolean
Public bPopupSelIni As Boolean
Public HotKeyIni As String
Public lShortMenuPosIni As Long
Public lToolbarPosIni As Long
Public bResetAtPopupIni    'Variante para que quando indef. definir o padr|fffd|o True
Public bStartAtPopupIni As Boolean
Public bSplitAtPopupIni As Boolean
Public bSplitInBkGrAtPopupIni As Boolean    'Split in background at popup
Public bPaperRibbonIni As Boolean
Public bPopupAtLastPosIni As Boolean
Public dLastPosTopIni As Double
Public dLastPosLeftIni As Double

Public lModeIni As Long
Public lNumDecimIni As Long
Public lDispSizeIni As Double
Public lCtrlPanelSizeIni As Long
Public lStopInsModeIni As Long, lInsOvrCntsIni As Long, lInsAlsoDTimeIni As Long, lOtherButtsModeIni As Long, lCellAsButTriggSlcIni As Long, lEchoDisplayInCellIni As Long   'StopIns button modes, Cell as button trigger selecting cells options, echo options.
Public bInsActCelStartIni As Boolean    'Insere na c|fffd|lula que estava ativa ao iniciar
Public rngActCelStartIni As Range    'C|fffd|lula ativa ao iniciar
Public ActShAtPopupIni As Worksheet    'Planilha ativa ao iniciar

Public bUserNoteLastIni    'As Boolean'Variante para que quando indef. definir o padr|fffd|o True
Public lSnapshotNumbIni As Long
Public arrBackColorIni(10) As Long    'Background colors
Public arrForeColorIni(10) As Long    'Foreground colors
Public arrSnpshtLbIni(10) As String    'Snapshot labels

Public lCDHourIni As Long
Public lCDMinIni As Long
Public lCDSecIni As Long
Public lCDSecFractIni As String
Public bCDtoDTimeIni As Boolean
Public dbCDtoDTimeIni As Double
Public bCDBeepIni As Boolean
Public lCDBeepIni As Long
Public bCDQuitIni As Boolean
Public bCDWavIni As Boolean
Public sCDFileWavIni As String
Public bCDRunIni As Boolean
Public sCDFileRunIni As String
Public bCDAlertIni As Boolean
Public sCDTxtAlertIni As String
Public bCDStartIni As Boolean
Public bCDSpeakIni As Boolean
Public lCDSpeakIni As Long
Public bCDRestartIni As Boolean
Public bCDReCntdownIni As Boolean

Public bMultDisable As Boolean
Public bMultStartAttachIni As Boolean
Public bMultStopAttachIni As Boolean
Public bMultRestartAttachIni As Boolean
Public bMultStopInsAttachIni As Boolean
Public bMultResetAttachIni As Boolean

Public bSndDisableAllIni As Boolean
Public bSndAtStartIni As Boolean
Public bSndAtStopIni As Boolean
Public bSndAtRestartIni As Boolean
Public bSndAtStopInsIni As Boolean
Public bSndAtSnapshotIni As Boolean
Public bSndAtResetIni As Boolean
Public arrbSndAtSnpshtLbIni(10) As Boolean    'Snapshot labels
Public sWavSndAtStartIni As String
Public sWavSndAtStopIni As String
Public sWavSndAtRestartIni As String
Public sWavSndAtStopInsIni As String
Public sWavSndAtSnapshotIni As String
Public sWavSndAtResetIni As String
Public arrsWavSndAtSnpshtLbIni(10) As String    'Snapshot labels

Public lClickOnDisplayIni As Long    '0 a 4 dft 0
Public bEnableBackgrondIni As Boolean
Public lColorBackgroundIni As Long
Public sPictFileIni As String
Public lPictAlignmentIni As Long    '0 a 4 dft 2
Public lPictSizeModeIni As Long    '0 a 3 dft 0 sem 2
Public bPictTilingIni As Boolean
Public bTranspDisplayIni As Boolean    'dft true
Public bTranspCtrlPanelIni As Boolean
Public bTranspSnapshotLbIni As Boolean
Public bTranspPaperIni As Boolean
Public bHideTitleBarIni As Boolean
Public bAutoHideCtrlPanelIni As Boolean
Public bAnchActCelStartIni As Boolean
Public bAnchCelAdjWidthIni As Boolean
Public bAnchCelAdjHeightIni As Boolean
Public bUnanchExcelWinIni As Boolean
Public bAlwaysOnTopIni As Boolean

Public FitaPapelIni() As String    'N|fffd|o salva fita, mas transfere para nova |fffd|ltima fechada
Public lResetModeIni As Long   'Reset button modes
Public bMultStartStopsAttachIni As Boolean
Public bMultRestartStopsAttachIni As Boolean
Public bMultStartStopInssAttachIni As Boolean
Public bMultRestartStopInssAttachIni As Boolean
Public sOpenSettingFile As String


'PickColor
Private Type CHOOSECOLORSTRUCTURE
    lStructSize As Long
    hWnd As Long
    hInstance As Long
    rgbResult As Long
    lpCustColors As String
    flags As Long
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type
Private Const CC_RGBINIT = &H1
Private Const CC_FULLOPEN = &H2
Private Const CC_PREVENTFULLOPEN = &H4
Private Const CC_SHOWHELP = &H8
Private Const CC_ENABLEHOOK = &H10
Private Const CC_ENABLETEMPLATE = &H20
Private Const CC_ENABLETEMPLATEHANDLE = &H40
Private Const CC_SOLIDCOLOR = &H80
Private Const CC_ANYCOLOR = &H100
Private Declare Function ChooseColor Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As CHOOSECOLORSTRUCTURE) As Long

'For loop in API
Declare Function SetTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long, _
                                        ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
Declare Function KillTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long) As Long
Public LoopAPIid As Long       'Ret Id from SetTimer to kill loop
Public IntervMilSec As Long
Dim UserFormStopwatch1 As UserFormStopwatch
Dim lLastLoopIncomp As Long
Public lCountInstAdd As Long
Public CollectionInst As Collection
Public lGetScrPosMeth As Long

Sub StartLoopAPI()
    IntervMilSec = 60    ' Loop frequency in mileseconds
    LoopAPIid = SetTimer(0&, 0&, IntervMilSec, AddressOf LoopAPICallback)
End Sub

Function LoopAPICallback(ByVal hWnd As Long, ByVal uMsg As Long, ByVal idEvent As Long, ByVal dwTime As Long)
'This function is called back by Windows API in loop.
'O mais seguro |fffd| sempre chamar sub ou function, pois se colocar algo do ou que trave o aplicativo aqui, acontece sai de repente sem GPF
    If lLastLoopIncomp < 2 Then    'Pode acontecer de travar em um loop e o API continuar chamando ent|fffd|o |fffd| melhor desviar.
        lLastLoopIncomp = 2
        For Each UserFormStopwatch1 In CollectionInst
            UserFormStopwatch1.LoopAPI
        Next
        lLastLoopIncomp = 1
    End If
End Function

Sub KillLoopAPI()
    On Error Resume Next
    KillTimer 0&, LoopAPIid
    LoopAPIid = 0
    lLastLoopIncomp = 0
End Sub

Sub OpenMultInstNow()    'Usado s|fffd| em debug quando appHostApp j|fffd| existe.
    Dim i As Long: Dim ret: appHostApp.ExecuteExcel4Macro "APP.ACTIVATE()"
    ret = VBA.InputBox("Insira a quantidade", "Quantidade", 10): If ret = "" Then Exit Sub
    For i = 1 To ret: MyWait 0.1: Stopwatch: Next
End Sub

Sub xLbStartStop_ClickMult(ByVal lBotPress As Long, Optional sCountInstAddCall As String, Optional lTickCountDownFix1 As Long, Optional dTimeDownFix1 As Date)
'Faz um loop para simular o acionamento do bot|fffd|o StartStop em todas inst|fffd|ncias attached e igual situa|fffd||fffd|o.
'Ficou mais simples apenas desviando pra c|fffd| e chamando ou rechamando xLbStartStop_Click ou xLbStopIns_Click em cada inst|fffd|ncia.
    Dim lTickCountMultFix As Long    'Fixar GetTickCount e Time para que os eventos ao longo do loop se d|fffd| no mesmo tick e tempo.
    Dim dTime As Date
    lTickCountMultFix = IIf(lTickCountDownFix1 = 0, GetTickCount(), lTickCountDownFix1)
    dTime = IIf(dTimeDownFix1 = 0, Now, dTimeDownFix1)

    For Each UserFormStopwatch1 In CollectionInst
        With UserFormStopwatch1
            If .bMultStartAttach And lBotPress = 0 And .lBotPress = 0 Then
                .xLbStartStop_Click True, lTickCountMultFix, dTime
            ElseIf .bMultStopAttach And lBotPress = 1 And .lBotPress = 1 Then .xLbStartStop_Click True, lTickCountMultFix, dTime
            ElseIf .bMultRestartAttach And lBotPress = 2 And .lBotPress = 2 Then .xLbStartStop_Click True, lTickCountMultFix, dTime
            ElseIf .bMultStartStopsAttach And lBotPress = 0 And .lBotPress = 1 Then .xLbStartStop_Click True, lTickCountMultFix, dTime                      'As contando que v|fffd|o parar.
            ElseIf .bMultStartStopsAttach And lBotPress = 0 And .lBotPress = 0 And sCountInstAddCall = .sCountInstAdd Then .xLbStartStop_Click True, lTickCountMultFix, dTime                   'As que v|fffd|o iniciar contagem. Por padr|fffd|o s|fffd| acionar uma, a que chamou ou foi clicada.
            ElseIf .bMultRestartStopsAttach And lBotPress = 2 And .lBotPress = 1 Then .xLbStartStop_Click True, lTickCountMultFix, dTime                      'As contando que v|fffd|o parar.
            ElseIf .bMultRestartStopsAttach And lBotPress = 2 And .lBotPress = 2 And sCountInstAddCall = .sCountInstAdd Then .xLbStartStop_Click True, lTickCountMultFix, dTime                    'A que vai Reiniciar contagem. Por padr|fffd|o s|fffd| acionar uma, a que chamou ou foi clicada.
            ElseIf .bMultStartStopInssAttach And lBotPress = 0 And .lBotPress = 1 And .lStopInsMode <> 6 Then .xLbStopIns_Click .lStopInsMode, True, lTickCountMultFix, dTime, .bInsActCelStart                      'As contando que v|fffd|o parar.
            ElseIf .bMultStartStopInssAttach And lBotPress = 0 And .lBotPress = 0 And sCountInstAddCall = .sCountInstAdd Then .xLbStartStop_Click True, lTickCountMultFix, dTime                  'As que v|fffd|o iniciar contagem. Por padr|fffd|o s|fffd| acionar uma, a que chamou ou foi clicada.
            ElseIf .bMultRestartStopInssAttach And lBotPress = 2 And .lBotPress = 1 And .lStopInsMode <> 6 Then .xLbStopIns_Click .lStopInsMode, True, lTickCountMultFix, dTime, .bInsActCelStart                     'As contando que v|fffd|o parar.
            ElseIf .bMultRestartStopInssAttach And lBotPress = 2 And .lBotPress = 2 And sCountInstAddCall = .sCountInstAdd Then .xLbStartStop_Click True, lTickCountMultFix, dTime    'A que vai Reiniciar contagem. Por padr|fffd|o s|fffd| acionar uma, a que chamou ou foi clicada.
            End If
        End With
    Next
End Sub

Sub xLbSet_ClickMult(lResetMode1 As Long)
'Faz um loop para simular o acionamento do bot|fffd|o Reset em todas inst|fffd|ncias attached e igual situa|fffd||fffd|o.
'Ficou mais simples apenas desviando pra c|fffd| e chamando ou rechamando xLbSet_Click em cada inst.
    Dim lTickCountMultFix As Long    'Fixar GetTickCount e Time para que os eventos ao longo do loop se d|fffd| no mesmo tick e tempo. Passar via arg. para fazer os ajustes.
    Dim dTime As Date
    lTickCountMultFix = GetTickCount()
    dTime = Now

    For Each UserFormStopwatch1 In CollectionInst
        With UserFormStopwatch1
            If .bMultResetAttach And .lResetMode <> 4 Then
                .xLbSet_Click lResetMode1, True, lTickCountMultFix, dTime
            End If
        End With
    Next
End Sub

Sub xLbStopIns_ClickMult(lStopInsMode1 As Long)
'Faz um loop para simular o acionamento do bot|fffd|o StopIns em todas inst|fffd|ncias attached e igual situa|fffd||fffd|o.
'Ficou mais simples apenas desviando pra c|fffd| e chamando ou rechamando xLbStopIns_Click em cada inst.
    Dim lTickCountMultFix As Long    'Fixar GetTickCount e Time para que os eventos ao longo do loop se d|fffd| no mesmo tick e tempo. Passar via arg. para fazer os ajustes.
    Dim dTime As Date
    lTickCountMultFix = GetTickCount()
    dTime = Now

    For Each UserFormStopwatch1 In CollectionInst
        With UserFormStopwatch1
            If .bMultStopInsAttach And .lStopInsMode <> 6 Then
                .xLbStopIns_Click lStopInsMode1, True, lTickCountMultFix, dTime, .bInsActCelStart
            End If
        End With
    Next
End Sub

Sub xLbStopIns_TriggSlcCellMult(Target As Range)
'Faz um loop para simular o acionamento do bot|fffd|o StopIns em todas instancias configuradas para Trigger selecting cell bem similar xLbStopIns_ClickMult que tamb|fffd|m chama xLbStopIns_Click.
    Dim lTickCountMultFix As Long    'Fixar GetTickCount e Time para que os eventos ao longo do loop se d|fffd| no mesmo tick e tempo. Passar via arg. para fazer os ajustes.
    Dim dTime As Date
    lTickCountMultFix = GetTickCount()
    dTime = Now

    For Each UserFormStopwatch1 In CollectionInst
        With UserFormStopwatch1
            If (.lCellAsButTriggSlc And 1) = 1 Then
                If ((.lCellAsButTriggSlc And 2) = 2 And Not CellHasTimeFormat(Target.NumberFormat)) _
                   Or ((.lCellAsButTriggSlc And 4) = 4 And (Target.Value <> Empty Or Target.HasFormula)) _
                   Or ((.lCellAsButTriggSlc And 8) = 8 And (appHostApp.ActiveWindow.ActiveSheet.Name <> .ActShAtPopup.Name Or appHostApp.ActiveWindow.ActiveSheet.Parent.Name <> .ActShAtPopup.Parent.Name)) _
                   Or ((.lCellAsButTriggSlc And 16) = 16 And Target.Row <> .rngActCelStart.Row) _
                   Or ((.lCellAsButTriggSlc And 32) = 32 And Target.Column <> .rngActCelStart.Column) Then
                    'N|fffd|o pressiona se n|fffd|o passar nas restri|fffd||fffd|es definidas.
                Else
                    Dim lStopInsMode1 As Long: lStopInsMode1 = IIf((.lCellAsButTriggSlc And 64) = 64, 1, IIf((.lCellAsButTriggSlc And 128) = 128, 2, IIf((.lCellAsButTriggSlc And 256) = 256, 3, IIf((.lCellAsButTriggSlc And 512) = 512, 4, 5))))
                    Dim bInsActCelStart1 As Boolean: bInsActCelStart1 = (.lCellAsButTriggSlc And 4096) = 4096
                    .xLbStopIns_Click lStopInsMode1, True, lTickCountMultFix, dTime, bInsActCelStart1
                End If
            End If
        End With
    Next
End Sub

Sub Cancel_Bt_ClickMult(bSilence As Boolean)
'Faz um loop para simular o acionamento do bot|fffd|o close em todas instancias aberta via menu
    If CollectionInst.Count > 1 And Not bSilence Then If MyMsgBox(IIf(IsPortg, "Fechar todas as " & CollectionInst.Count & " inst|fffd|ncias abertas. OK?", _
                                                                  "Close all " & CollectionInst.Count & " open instances. OK?"), 2, sAddInCaptByApp) = 2 Then Exit Sub
    For Each UserFormStopwatch1 In CollectionInst
        With UserFormStopwatch1
            .Cancel_Bt_Click
        End With
    Next
End Sub

Sub QuitMultForce()    'Sair for|fffd|ado sem questionamento.
    On Error Resume Next
    KillLoopAPI
    For Each UserFormStopwatch1 In CollectionInst
        Unload UserFormStopwatch1
    Next
    Set CollectionInst = Nothing: lCountInstAdd = 0
End Sub

Public Function PickColor(lColor As Long, fhWnd As Long) As Long
    Dim CCS As CHOOSECOLORSTRUCTURE
    With CCS
        .lStructSize = Len(CCS)
        .hWnd = fhWnd    'FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), sCaption)   'fhWnd    'Modal
        .rgbResult = IIf(IsNumeric(lColor), lColor, 0)
        .flags = CC_ANYCOLOR Or CC_RGBINIT
        .lpCustColors = String$(16 * 4, 0)
        ChooseColor CCS
        PickColor = .rgbResult
    End With
End Function

Function fGetIntCode(Flag) As String    '|fffd|til para tornar modos e eventos na planilha independente da l|fffd|ngua, por exemplo, em vez de procurar por Snapshot ou Instt|fffd|neo, procura por "(4)*". Assim, um mesmo c|fffd|digo VBA pode rodar com en e pt.
    If TypeName(Flag) = "Boolean" Then
        fGetIntCode = IIf(Flag, "(2) ", "(1) ")  'Code for mode Stopwatch or Countdown
    Else    'Code for event
        If Flag = "Popup" Or Flag = "Popup" Then fGetIntCode = "(1) "
        If Flag = "Start" Or Flag = "Iniciar" Then fGetIntCode = "(2) "
        If Flag = "Expire" Or Flag = "Expirar" Then fGetIntCode = "(3) "
        If Flag Like "Snapshot*" Or Flag Like "Instt|fffd|neo*" Then fGetIntCode = "(4) "
        If Flag = "Stop" Or Flag = "Parar" Then fGetIntCode = "(5) "
        If Flag = "Restart" Or Flag = "Reiniciar" Then fGetIntCode = "(6) "
        If Flag = "Cancel" Or Flag = "Cancelar" Then fGetIntCode = "(7) "

        If Flag = "Reset" Or Flag = "Zerar" Then fGetIntCode = "(8) "
        If Flag = "ResetS" Or Flag = "ZerarI" Then fGetIntCode = "(81) "
        If Flag = "ResetIS" Or Flag = "ZerarII" Then fGetIntCode = "(82) "

        If Flag = "StpInsCls" Or Flag = "ParInsFec" Then fGetIntCode = "(9) "
        If Flag = "StpInsRst" Or Flag = "ParInsZer" Then fGetIntCode = "(91) "
        If Flag = "StpInRsSt" Or Flag = "ParInZeIn" Then fGetIntCode = "(92) "
        If Flag = "StopIns" Or Flag = "PararIns" Then fGetIntCode = "(93) "
        If Flag = "Insert" Or Flag = "Inserir" Then fGetIntCode = "(94) "
    End If
End Function
Attribute VB_Name = "Mod3ScreenCellPos"
Option Explicit
'Esse m|fffd|dulo |fffd| o mesmo usado em CellEasyEntry e popup IconForm do calend, calculator, clock, stopwatch
'e deve ser editado em MyFormPosition10_64.xls na subpasta projeto do CellEasy para depois ecoar. Ver hist|fffd|rico no Mod4Hist.

Public lTop                                                'As Long
Public lLeft                                               'As Long
Public dZoom As Double

Dim lActCellCol As Long
Dim lActCellRow As Long
Dim lActPaneTopRow As Long
Dim lActPane As Long

Dim lPane1TopRow As Long
Dim lPane1LeftCol As Long
Dim lPane2TopRow As Long
Dim lPane2LeftCol As Long
Dim lPane3TopRow As Long
Dim lPane3LeftCol As Long
Dim lPane4TopRow As Long
Dim lPane4LeftCol As Long

Dim CtrlFrames_Top
Dim CtrlFrames_Left

Dim CellA1Coord_Top
Dim CellA1Coord_Left

Dim RowHeaderWidth As Single
Dim ColHeaderHeigth As Single
Dim RowOutlineWidth As Single
Dim ColOutlineHeigth As Single

Dim FormulaBarHeightR1                                     'Altura da primeira linha em points
Dim FormulaBarHeightR2                                     'Altura da segunda linha e acima em points

Dim Excel7_hWnd As Long

Function fGetScrPosMeth() As Boolean
'Usar lGetScrPosMeth = 2 como padr|fffd|o por ser mais silencioso e usar 3 apenas em zoom ou se for detectado
'que a janela da planiha n|fffd|o pode ocupar todo o espa|fffd|o da janela do aplic. o que pode indicar
'risco de Task Pane(TP) ou CTP ou alerts ancorada |fffd| direita ou |fffd| cima no Excel 2007 ou 2010.

'For|fffd|ar m|fffd|todos anteriores ao 4. Comentar este bloco depois de editado e testado, mas n|fffd|o tem problem se ficar.
    Dim sTestFlag As String: If appHostApp.ActiveWindow.ActiveCell.Column > 1 Then sTestFlag = appHostApp.ActiveWindow.ActiveCell.Offset(0, -1).Value
    If appHostApp.ActiveWindow.ActiveSheet.Range("A1").Value Like "Meth*" Then
        If sTestFlag = "1" Then lGetScrPosMeth = 1: fGetScrPosMeth = True: Exit Function
        If sTestFlag = "2" Then lGetScrPosMeth = 2: fGetScrPosMeth = True: Exit Function
        If sTestFlag = "22" Then lGetScrPosMeth = 22       'For|fffd|ar escolha usada antes do m|fffd|todo 4.
        If sTestFlag = "3" Then lGetScrPosMeth = 3: fGetScrPosMeth = True: Exit Function
        If sTestFlag = "4" Then lGetScrPosMeth = 4: GetExcel7ClsWinPosAPI: fGetScrPosMeth = True: Exit Function
        If sTestFlag = "5" Then lGetScrPosMeth = 5: fGetScrPosMeth = (dHostAppVer >= 11 + 1): Exit Function    'S|fffd| do 12 em diante.
    End If

    If dHostAppVer >= 11 + 1 Then lGetScrPosMeth = 5: fGetScrPosMeth = True: Exit Function    'O 5 vai ser padr|fffd|o do 2007 em diante onde |fffd| suportado, pois n|fffd|o tem nenhuma restri|fffd||fffd|o.
    If lGetScrPosMeth <> 22 And GetExcel7ClsWinPosAPI And appHostApp.ActiveWindow.View <> 3 Then lGetScrPosMeth = 4: fGetScrPosMeth = True: Exit Function    'O 4 |fffd| mais preciso, n|fffd|o tem nenhuma restri|fffd||fffd|o e vai ser o padr|fffd|o desde que, por seguran|fffd|a de ser novo n|fffd|o falhe, ao obter a posi|fffd||fffd|o de EXCEL7 class window by API. Se falhar ignora e procura a melhor op|fffd||fffd|o conform anteriormente. Em teste para ignorar 4 basta comentar esta linha.
    lGetScrPosMeth = 2

    'O 3 |fffd| mais preciso em zoom, mas n|fffd|o funciona se freeze em janela protegida. Nesta vers|fffd|o 4, vou de 2 em zoom tamb|fffd|m qualquer coisa descomento linha abaixo
    '    If appHostApp.ActiveWindow.Zoom / 100 <> 1 And Not (appHostApp.ActiveWorkbook.ProtectWindows And appHostApp.ActiveWindow.FreezePanes) Then lGetScrPosMeth = 3

    'O 2 n|fffd|o funciona com TP ou CTP ancorada no 2007 ou 2010
    If dHostAppVer >= 11 + 1 And appHostApp.DisplayFormulaBar And FormulaBarHeightR1 = 0 Then GetFormulaBarHeight
    If lGetScrPosMeth = 2 And dHostAppVer >= 11 + 1 Then
        If appHostApp.UsableWidth < appHostApp.Width - 4.5 * 3 Then lGetScrPosMeth = 3    'No 2010 foi necess|fffd|ri um fator de seg. de 3
        If appHostApp.UsableHeight < appHostApp.Height - 4.5 _
           - IIf(appHostApp.CommandBars("Ribbon").Visible, 147, 0) _
           - IIf(appHostApp.DisplayFormulaBar, IIf(appHostApp.FormulaBarHeight = 1, FormulaBarHeightR1, FormulaBarHeightR1 + FormulaBarHeightR2 * (appHostApp.FormulaBarHeight - 1)), 0) Then lGetScrPosMeth = 3
    End If

    'Sair se 3 e janela protegida com panes freeze. Com o filtro acima isso s|fffd| vai acontecer no 2007 ou 2010
    If lGetScrPosMeth = 3 And appHostApp.ActiveWorkbook.ProtectWindows And appHostApp.ActiveWindow.FreezePanes Then Exit Function

    'Sair se em xlPageLayoutView
    If appHostApp.ActiveWindow.View = 3 Then Exit Function    '3 = xlPageLayoutView

    fGetScrPosMeth = True
End Function

Sub GetScreenCellPos(TargetCell As Range)
    GetPanesInfo                                           'Get Active and positions panes
    If lGetScrPosMeth <> 5 Then GetActWindowCellPos TargetCell    'Get Cell Position in Active Window

    With appHostApp
        Select Case lGetScrPosMeth
        Case 1
            'Using normally VBA PointsToScreenPixels method
            'P|fffd|cimo em zoom. Pode ser corrigido por fator mas s|fffd| com Linhas e colunas standard.
            'Tamb|fffd|m pode falhar em linha n|fffd|o standard
            'Com frame s|fffd| funciona em pane 1 no Excel 2002, 2003, 2007 e 2010 talvez bug
            'Acho que o nome deste m|fffd|todo n|fffd|o com diz com seu retorn, acho que ele transforma coordenadas de uma janela em coordenadas de tela tudo em pixel
            Dim xFatCorZoom
            xFatCorZoom = 1                                '0.75  1.019607 '0.50  1.058825 '1.5   1.019608  '2     0.999999    '3     1.0000003
            lTop = .ActiveWindow.PointsToScreenPixelsY(lTop * dZoom * xFatCorZoom * ScreenResol(1) / 72) * 72 / ScreenResol(1)
            lLeft = .ActiveWindow.PointsToScreenPixelsX(lLeft * dZoom * ScreenResol(0) / 72) * 72 / ScreenResol(0)
        Case 2
            'Calculando diretamente os frames de controle da janela do aplic. e da jan. da planilha
            'Esse |fffd| quase perfeito at|fffd| em zoom e sem flicks em planilha com standard stylus.
            'S|fffd| n|fffd|o funciona com TP ou CTP ancorada no 2007 ou 2010
            'Inconveniente de flicks em planilha n|fffd|o com standard stylus, mas praticamente impercept|fffd|veis e s|fffd| uma vez ao entrar o alterar cen|fffd|rios.
            GetCtrlFrames
            lTop = .Top + CtrlFrames_Top + IIf(dHostAppVer >= 11 + 1 + 2 + 1, IIf(.WindowState = xlMaximized, -19.25, -22.25), .ActiveWindow.Top) + (lTop - .ActiveWindow.ActiveSheet.Rows(lPane1TopRow).Top) * dZoom
            lLeft = .Left + CtrlFrames_Left + IIf(dHostAppVer >= 11 + 1 + 2 + 1, IIf(.WindowState = xlMaximized, -5.25, -10.5), .ActiveWindow.Left) + (lLeft - .ActiveWindow.ActiveSheet.Columns(lPane1LeftCol).Left) * dZoom
        Case 3
            'Misto de 1 e 2 onde calcula a coord do canto superior da janela da plan. com PointsToScreenPixels
            'method o mesmo que o canto superior da c|fffd|lula A1 quando vis|fffd|vel no painel 1
            'Esse tamb|fffd|m |fffd| quase perfeito at|fffd| em zoom |fffd| melhor e funciona com TP ou CTP ancorada no 2007 ou 2010
            'S|fffd| n|fffd|o funciona em workbook com janela protegida e freeze congelado
            'O inconveniente |fffd| flicker pois tem que fazer scroll para A1 na janela ou no painel1 e ainda descongelando se necess
            GetCellA1Coord
            lTop = CellA1Coord_Top + (lTop - .ActiveWindow.ActiveSheet.Rows(lPane1TopRow).Top) * dZoom
            lLeft = CellA1Coord_Left + (lLeft - .ActiveWindow.ActiveSheet.Columns(lPane1LeftCol).Left) * dZoom
        Case 4
            'Variante do 2 onde calcula via API logo a posi|fffd||fffd|o da janela EXCEL7 class e assim s|fffd| fica faltando
            'os frames internos de GetCtrlFrames de onde extrai o GetCtrlFramesInt. N|fffd|o parece ter restri|fffd||fffd|es de
            'funcionamento e |fffd| mais perfeito que o 2 onde os frames externos davam muito problema conform vers|fffd|es
            'do Windows e Excel e eram corrigidos por tentativa com fatores no final. Vou usar como padr|fffd|o, mas
            'por seguran|fffd|a GetExcel7ClsWinPosAPI vai ser feito ainda em fGetScrPosMeth para, se falhar, procurar
            'outro m|fffd|todo conforme anteriormente. Tem potencial para ser |fffd|nico.
            GetCtrlFramesInt
            lTop = CtrlFrames_Top + (lTop - .ActiveWindow.ActiveSheet.Rows(lPane1TopRow).Top) * dZoom
            lLeft = CtrlFrames_Left + (lLeft - .ActiveWindow.ActiveSheet.Columns(lPane1LeftCol).Left) * dZoom

        Case 5
            'Using normally VBA PointsToScreenPixels method para objeto Pane that is new in 2007.
            'S|fffd| funciona no Excel 2007 em diante com precis|fffd|o at|fffd| em zoom em todos os modos de visualiza|fffd||fffd|o e sem
            'flirks. N|fffd|o h|fffd| como n|fffd|o ser o padr|fffd|o.
            lTop = TargetCell.Top
            lLeft = TargetCell.Left
            lTop = .ActiveWindow.Panes(lActPane).PointsToScreenPixelsY(lTop) * 72 / ScreenResol(1)
            lLeft = .ActiveWindow.Panes(lActPane).PointsToScreenPixelsX(lLeft) * 72 / ScreenResol(0)
            dZoom = .ActiveWindow.Zoom / 100    'Este methodo n|fffd|o necessita e nem calcula e antes pode at|fffd| atrapalhar, mas |fffd| uma vari|fffd|vel p|fffd|blica |fffd|til ao projeto.

        End Select
    End With
End Sub

Sub GetPanesInfo()
    With appHostApp
        On Error Resume Next
        'In XLM, panes are fixes then 1 = Upper, left, or upper-left/2 = Right or upper-right
        '/3 = Lower or lower-left/4 = Lower-right
        lPane1TopRow = .ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,1)")
        lPane1LeftCol = .ExecuteExcel4Macro("INDEX(GET.WINDOW(13),,1)")
        lPane2TopRow = .ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,2)")
        lPane2LeftCol = .ExecuteExcel4Macro("INDEX(GET.WINDOW(13),,2)")
        lPane3TopRow = .ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,3)")
        lPane3LeftCol = .ExecuteExcel4Macro("INDEX(GET.WINDOW(13),,3)")
        lPane4TopRow = .ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,4)")
        lPane4LeftCol = .ExecuteExcel4Macro("INDEX(GET.WINDOW(13),,4)")
        On Error GoTo 0
        lActCellRow = .ActiveWindow.ActiveCell.Row
        lActCellCol = .ActiveWindow.ActiveCell.Column

        'Get Active Pane
        lActPane = 0
        If Not .ActiveWindow.FreezePanes Then
            lActPane = .ActiveWindow.ActivePane.Index
            'lActPane = .ExecuteExcel4Macro("GET.WINDOW(17)")
        Else
            If .ActiveWindow.SplitVertical <> 0 And .ActiveWindow.SplitHorizontal <> 0 Then
                If lActCellCol < lPane2LeftCol And lActCellRow < lPane3TopRow Then lActPane = 1
                If lActPane = 0 And lActCellCol >= lPane2LeftCol And lActCellRow < lPane4TopRow Then lActPane = 2
                If lActPane = 0 And lActCellCol < lPane4LeftCol And lActCellRow >= lPane3TopRow Then lActPane = 3
                If lActPane = 0 Then lActPane = 4
            ElseIf .ActiveWindow.SplitVertical <> 0 Then
                If lActCellRow < lPane3TopRow Then lActPane = 1 Else lActPane = 2
            ElseIf .ActiveWindow.SplitHorizontal <> 0 Then
                If lActCellCol < lPane2LeftCol Then lActPane = 1 Else lActPane = 2
            End If
        End If
    End With
End Sub

Sub GetActWindowCellPos(TargetCell As Range)
    Dim lPaneThick As Double                               ' 4    'Grossura do divisor de pain|fffd|is

    With appHostApp
        dZoom = .ActiveWindow.Zoom / 100
        lPaneThick = IIf(.ActiveWindow.FreezePanes, 0.1, 4 + 1 + IIf(IsWinNT7, 1, 0) + IIf(IsWinNT8, 1, 0) + IIf(dHostAppVer >= 11 + 1 + 2 + 1, -2.5, 0)) / dZoom    'Como n|fffd|o se altera com o zoom, divide para depois multiplicar.

        Select Case lActPane
        Case 1
            lTop = TargetCell.Top
            lLeft = TargetCell.Left
            lActPaneTopRow = lPane1TopRow
        Case 2
            If .ActiveWindow.SplitHorizontal > 0 And .ActiveWindow.SplitVertical > 0 Then
                lTop = TargetCell.Top
                lLeft = TargetCell.Left + .ActiveWindow.SplitHorizontal / dZoom + .ActiveWindow.ActiveSheet.Columns(lPane1LeftCol).Left - .ActiveWindow.ActiveSheet.Columns(lPane2LeftCol).Left + lPaneThick
                lActPaneTopRow = lPane2TopRow
            Else
                If .ActiveWindow.SplitHorizontal > 0 Then
                    lTop = TargetCell.Top
                    lLeft = TargetCell.Left + .ActiveWindow.SplitHorizontal / dZoom + .ActiveWindow.ActiveSheet.Columns(lPane1LeftCol).Left - .ActiveWindow.ActiveSheet.Columns(lPane2LeftCol).Left + lPaneThick
                    lActPaneTopRow = lPane2TopRow
                Else
                    lTop = TargetCell.Top + .ActiveWindow.SplitVertical / dZoom + .ActiveWindow.ActiveSheet.Rows(lPane1TopRow).Top - .ActiveWindow.ActiveSheet.Rows(lPane3TopRow).Top + lPaneThick    'Em XLM painel em baixo s|fffd| o 3 ou 4
                    lLeft = TargetCell.Left
                    lActPaneTopRow = lPane3TopRow
                End If
            End If
        Case 3
            lTop = TargetCell.Top + .ActiveWindow.SplitVertical / dZoom + .ActiveWindow.ActiveSheet.Rows(lPane1TopRow).Top - .ActiveWindow.ActiveSheet.Rows(lPane3TopRow).Top + lPaneThick
            lLeft = TargetCell.Left
            lActPaneTopRow = lPane3TopRow
        Case 4
            lTop = TargetCell.Top + .ActiveWindow.SplitVertical / dZoom + .ActiveWindow.ActiveSheet.Rows(lPane2TopRow).Top - .ActiveWindow.ActiveSheet.Rows(lPane4TopRow).Top + lPaneThick
            lLeft = TargetCell.Left + .ActiveWindow.SplitHorizontal / dZoom + .ActiveWindow.ActiveSheet.Columns(lPane3LeftCol).Left - .ActiveWindow.ActiveSheet.Columns(lPane4LeftCol).Left + lPaneThick
            lActPaneTopRow = lPane4TopRow
        End Select
    End With
End Sub


Private Sub GetCtrlFrames()

'VERTICAL COORDINATE
'App title Bar Height
    CtrlFrames_Top = GetSystemMetrics(4)                   '+ GetSystemMetrics(15)     'SM_CYCAPTION + SM_CYMENU

'Tool bars Height (Aproveita o loop para obter o left logo)
    Dim Cb                                                 'As CommandBar
    Const msoBarTop = 1                                    'Para remover ref. Microsoft Office 9.0 Object Library
    Const msoBarMenuBar = 6
    Const msoBarLeft = 0
    Dim RowIdxArr_Top() As Long
    Dim RowIdxArr_Left() As Long
    Dim i As Long
    ReDim RowIdxArr_Top(0)
    ReDim RowIdxArr_Left(0)

    If dHostAppVer < 11 + 1 Then
        For Each Cb In appHostApp.CommandBars
            With Cb
                If .Visible = True And (.Position = msoBarTop Or .Position = msoBarMenuBar) Then
                    If .RowIndex > 0 Then
                        If .RowIndex > UBound(RowIdxArr_Top) Then ReDim Preserve RowIdxArr_Top(.RowIndex)
                        If .Height > RowIdxArr_Top(.RowIndex) Then RowIdxArr_Top(.RowIndex) = .Height
                    End If
                ElseIf .Visible = True And .Position = msoBarLeft Then
                    If .RowIndex > 0 Then
                        If .RowIndex > UBound(RowIdxArr_Left) Then ReDim Preserve RowIdxArr_Left(.RowIndex)
                        If .Width > RowIdxArr_Left(.RowIndex) Then RowIdxArr_Left(.RowIndex) = .Width
                    End If
                End If
            End With
        Next
    Else
        With appHostApp.CommandBars("Ribbon")
            If .Visible Then
                ReDim Preserve RowIdxArr_Top(.RowIndex)
                RowIdxArr_Top(.RowIndex) = .Height
            End If
        End With

        'Barra usada para o alerta seguran|fffd|a de macros e links Id 2149, sem nome e Index 145
        'mas n|fffd|o sei se varia por isso |fffd| melhor usar o loop para localizar
        For Each Cb In appHostApp.CommandBars
            If Cb.ID = 2149 And Cb.Visible Then
                ReDim Preserve RowIdxArr_Top(Cb.RowIndex)
                RowIdxArr_Top(Cb.RowIndex) = Cb.Height
            End If
        Next
    End If

    For i = 0 To UBound(RowIdxArr_Top)
        CtrlFrames_Top = CtrlFrames_Top + RowIdxArr_Top(i)
    Next

    'Formula bar Height
    If appHostApp.DisplayFormulaBar Then
        If dHostAppVer >= 11 + 1 Then
            CtrlFrames_Top = CtrlFrames_Top + IIf(appHostApp.FormulaBarHeight = 1, FormulaBarHeightR1, FormulaBarHeightR1 + FormulaBarHeightR2 * (appHostApp.FormulaBarHeight - 1)) * (ScreenResol(1) / 72)
            CtrlFrames_Top = CtrlFrames_Top - 9 + IIf(IsWinNTVista, 6, 0) + IIf(IsWinNT7, 6, 0) + IIf(IsWinNT8, 3, 0)    'Ajuste fino.
        Else
            CtrlFrames_Top = CtrlFrames_Top + GetSystemMetrics(3)    '17
        End If
    Else
        If dHostAppVer >= 11 + 1 Then CtrlFrames_Top = CtrlFrames_Top - 11 + IIf(IsWinNTVista, 6, 0) + IIf(IsWinNT7, 6, 0) + IIf(IsWinNT8, 6, 0)    'Ajuste fino.
    End If

    'Outline Height
    Dim Lev As Long
    Dim c
    If appHostApp.ActiveWindow.DisplayOutline Then
        Lev = 0
        i = appHostApp.ExecuteExcel4Macro("GET.DOCUMENT(12)")    'Because UsedRange method destry undo levels
        For Each c In appHostApp.ActiveWindow.ActiveSheet.Columns
            If Lev < c.OutlineLevel Then Lev = c.OutlineLevel
            If c.Column >= i Then Exit For
        Next
        If Lev > 1 Then
            GetOutlineDimensionTop Lev
            CtrlFrames_Top = CtrlFrames_Top + ColOutlineHeigth * (ScreenResol(1) / 72)    '* dZoom
        End If
    End If

    'Column header Height
    If appHostApp.ActiveWindow.DisplayHeadings Then
        If 2 = 3 Then
            CtrlFrames_Top = CtrlFrames_Top + appHostApp.ActiveWindow.ActiveSheet.StandardHeight * (ScreenResol(1) / 72) * dZoom    'StandardHeight e bem preciso em qualquer cenario, inclusive em zoom.
        Else
            GetHeadersDimensionTop                         'Tinha desabilitado nas vers|fffd|es anteriores porque estava usando PointsToScreenPixelsX em vez de Y.
            CtrlFrames_Top = CtrlFrames_Top + ColHeaderHeigth * (ScreenResol(1) / 72)    '* dZoom
        End If
    End If

    'Se a estrutura de janela estiver protegida no 2010 |fffd| necessario um ajuste
    If dHostAppVer >= 11 + 1 + 2 Then CtrlFrames_Top = CtrlFrames_Top + IIf(appHostApp.ActiveWorkbook.ProtectWindows, -6, 0)

    'End fine adjust to return the same as PointsToScreenPixelsY method
    CtrlFrames_Top = CtrlFrames_Top + GetSystemMetrics(4) + IIf(dHostAppVer < 11 + 1, 9.5 - 1, -16.5) + IIf(dHostAppVer >= 11 + 1 + 2, 3, 0) + IIf(IsWinNT7, IIf(dHostAppVer < 11 + 1, 9.3, 0), 0) + IIf(IsWinNT8, IIf(dHostAppVer < 11 + 1, 9.3, 2), 0) + IIf(IsOffice64_bit, 1, 0)    'Os ultimos fatores consegui por tentativa esta relacionado com o t|fffd|tulo e outras dimensoes da janela no Windows diferente no Win7 e Win8. Este workaround mostrou-se mais pr|fffd|tico e eficiente do que rever uma a uma aquelas dimens|fffd|es conform tentiva em xMyFormPositions6.xls e xxMyFormPositions6.xls

    'Zoom adjust acordling rows from top
    CtrlFrames_Top = CtrlFrames_Top + (lActCellRow - lActPaneTopRow) * IIf(dZoom = 0.75, 0.25, 0)

    'Convert Pixel to Point
    CtrlFrames_Top = CtrlFrames_Top * 72 / ScreenResol(1)



    'HORIZONTAL COORDINATE
    'Border
    CtrlFrames_Left = GetSystemMetrics(32)                 'SM_CXFRAME

    'Tool bars width
    For i = 0 To UBound(RowIdxArr_Left)
        CtrlFrames_Left = CtrlFrames_Left + RowIdxArr_Left(i)
    Next

    'Outline Width
    If appHostApp.ActiveWindow.DisplayOutline Then
        Dim lRowsUR As Long
        Dim lRowsVrf As Long
        Dim lRowsSkip As Long

        lRowsUR = appHostApp.ExecuteExcel4Macro("GET.DOCUMENT(10)")    'appHostApp.ActiveWindow.ActiveSheet.UsedRange.Rows.Count 'Because UsedRange method destry undo levels
        'Para acelera o loop verifica no m|fffd|x 3000 linhas. 1000 prim. 1000 |fffd|lt. e 1000 pelo centro logo ap|fffd|s 1/3
        If lRowsUR <= 3000 Then
            lRowsVrf = 3000
        Else
            lRowsVrf = 1000
            lRowsSkip = lRowsUR / 3
        End If
        Lev = 0

        Dim RowsVrfRng As Range
        Dim ar, rw
        Static lLevLast As Long
        Static sShLast As String
        Static sTimerLast As Single

        'Apesar de otimizado este loop pode incomodar selecionando com tecla pressionada. Ent|fffd|o, se j|fffd| possou por aqui a menos de 10 seg, aproveita |fffd|ltimo na mesma sh
        If lLevLast > 0 And Abs(sTimerLast - Timer) < 10 And sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name Then
            Lev = lLevLast
        Else
            If lRowsVrf > 1000 Then
                Set RowsVrfRng = appHostApp.ActiveWindow.ActiveSheet.Range("A1:A" & IIf(lRowsUR > 0 And lRowsUR < lRowsVrf, lRowsUR, lRowsVrf))
            Else
                Set RowsVrfRng = appHostApp.Union(appHostApp.ActiveWindow.ActiveSheet.Range("A1:A" & lRowsVrf), _
                                                  appHostApp.ActiveWindow.ActiveSheet.Range("A" & lRowsVrf + lRowsSkip & ":A" & lRowsVrf + lRowsSkip + lRowsVrf - 1), _
                                                  appHostApp.ActiveWindow.ActiveSheet.Range("A" & lRowsUR - lRowsVrf + 1 & ":A" & lRowsUR))
            End If
            For Each ar In RowsVrfRng.Areas
                For Each rw In ar.Rows
                    If Lev < rw.OutlineLevel Then Lev = rw.OutlineLevel
                Next
            Next
            lLevLast = Lev
        End If
        sTimerLast = Timer
        sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name

        If Lev > 1 Then
            GetOutlineDimensionLeft Lev
            CtrlFrames_Left = CtrlFrames_Left + RowOutlineWidth * (ScreenResol(0) / 72)
        End If
    End If

    'Row header Width
    If appHostApp.ActiveWindow.DisplayHeadings Then
        'Width change acordling len number of the last row visible
        If appHostApp.ActiveWindow.SplitVertical = 0 Then
            Lev = appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,1)") + Int(appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(16),,1)"))
        Else
            Lev = appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,3)") + Int(appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(16),,3)"))
        End If
        Lev = Len(Lev & "")

        GetHeadersDimensionLeft Lev
        CtrlFrames_Left = CtrlFrames_Left + RowHeaderWidth * (ScreenResol(0) / 72)
    End If

    'Se a estrutura de janela estiver protegida no 2010 |fffd| necessario um ajuste
    If dHostAppVer >= 11 + 1 + 2 Then CtrlFrames_Left = CtrlFrames_Left + IIf(appHostApp.ActiveWorkbook.ProtectWindows, -6, 0)

    'End fine adjust to return the same as PointsToScreenPixelsX method
    CtrlFrames_Left = CtrlFrames_Left + IIf(dHostAppVer < 11 + 1, 4, -1) + IIf(dHostAppVer >= 11 + 1 + 2, 3, 0) + IIf(IsWinNT7, 4, 0) + IIf(IsWinNT8, 4, 0) + IIf(IsOffice64_bit, 0, 0)

    'Zoom adjust acordling col from left
    '    CtrlFrames_Left = CtrlFrames_Left + 0

    'Convert Pixel to Point
    CtrlFrames_Left = CtrlFrames_Left * 72 / ScreenResol(0)
End Sub

Private Sub GetFormulaBarHeight()
'Obtem a altura das linhas da formula bar se em exibicao no Excel 2007 ou 2010 ocultando
'exibindo, pois esta configuracao nunca |fffd| protegida. Funciona em qualquer cen|fffd|rio.
    Dim bScreenUpdtIni As Boolean
    Dim lFormulaBarHeightIni As Long
    bScreenUpdtIni = appHostApp.ScreenUpdating
    lFormulaBarHeightIni = appHostApp.FormulaBarHeight

    appHostApp.ScreenUpdating = False
    appHostApp.FormulaBarHeight = 1
    appHostApp.DisplayFormulaBar = False
    FormulaBarHeightR1 = appHostApp.Height - appHostApp.UsableHeight
    appHostApp.DisplayFormulaBar = True
    FormulaBarHeightR1 = (appHostApp.Height - appHostApp.UsableHeight) - FormulaBarHeightR1

    FormulaBarHeightR2 = appHostApp.Height - appHostApp.UsableHeight
    appHostApp.FormulaBarHeight = 2
    FormulaBarHeightR2 = (appHostApp.Height - appHostApp.UsableHeight) - FormulaBarHeightR2

    appHostApp.DisplayFormulaBar = True
    appHostApp.ScreenUpdating = bScreenUpdtIni
    appHostApp.FormulaBarHeight = lFormulaBarHeightIni
End Sub

Private Sub GetOutlineDimensionTop(lLev As Long)
'Obtem a altura total da faixa atual j|fffd| com zoom. Funciona em qualquer cen|fffd|rio e ficou t|fffd|o preciso
'e silencioso que at|fffd| eliminei IsStdStyle que era totalmente silencioso, mas muito restrito e n|fffd|o t|fffd|o
'preciso e ainda exigia ajustes por tentativa a cada vers|fffd|o.
'Houve uma ideia de obter uma |fffd|nica vez a cada execu|fffd||fffd|o o tamanho das subfaixa 1 e 2 e rest. como
'linhas em GetFormulaBarHeight acima em uma pasta temp, mas n|fffd|o funcionou porque no 2007 ou 2010
'varia se a pasta corrente tiver zoom menor que 100 e tiver sido criada em outras vers|fffd|es do Excel.
'Ver MyFormPositions4Lixo.xls
    Dim lActPane1 As Long
    Static lLevLast As Long
    Static dZoomLast As Double
    Static sShLast As String
    Static bFreezePanes As Boolean

    'Evita flicks aproveitando ultimo se mesmo...
    If lLev = lLevLast And dZoom = dZoomLast And sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name _
       And bFreezePanes = appHostApp.ActiveWindow.FreezePanes Then Exit Sub

    lActPane1 = appHostApp.ActiveWindow.ActivePane.Index
    appHostApp.ActiveWindow.DisplayOutline = False

    If appHostApp.ActiveWindow.FreezePanes Then            'PointsToScreenPixels s|fffd| |fffd| preciso se ativar pane 1 que n|fffd|o |fffd| possivel se freeze, felizmente neste caso GET.CELL(4 |fffd| perfeito
        ColOutlineHeigth = appHostApp.ExecuteExcel4Macro("GET.CELL(43)")
        appHostApp.ActiveWindow.DisplayOutline = True
        ColOutlineHeigth = appHostApp.ExecuteExcel4Macro("GET.CELL(43)") - ColOutlineHeigth
    Else
        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(1).Activate

        ColOutlineHeigth = appHostApp.ActiveWindow.PointsToScreenPixelsY(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Top * ScreenResol(1) / 72) * 72 / ScreenResol(1)
        appHostApp.ActiveWindow.DisplayOutline = True
        ColOutlineHeigth = appHostApp.ActiveWindow.PointsToScreenPixelsY(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Top * ScreenResol(1) / 72) * 72 / ScreenResol(1) - ColOutlineHeigth

        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(lActPane1).Activate
    End If

    lLevLast = lLev
    dZoomLast = dZoom
    sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name
    bFreezePanes = appHostApp.ActiveWindow.FreezePanes
End Sub

Private Sub GetOutlineDimensionLeft(lLev As Long)
'Idem...
    Dim lActPane1 As Long
    Static lLevLast As Long
    Static dZoomLast As Double
    Static sShLast As String
    Static bFreezePanes As Boolean

    'Evita flicks aproveitando ultimo se mesmo...
    If lLev = lLevLast And dZoom = dZoomLast And sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name _
       And bFreezePanes = appHostApp.ActiveWindow.FreezePanes Then Exit Sub

    lActPane1 = appHostApp.ActiveWindow.ActivePane.Index
    appHostApp.ActiveWindow.DisplayOutline = False

    If appHostApp.ActiveWindow.FreezePanes Then            'PointsToScreenPixels s|fffd| |fffd| preciso se ativar pane 1 que n|fffd|o |fffd| possivel se freeze, felizmente neste caso GET.CELL(4 |fffd| perfeito
        RowOutlineWidth = appHostApp.ExecuteExcel4Macro("GET.CELL(42)")
        appHostApp.ActiveWindow.DisplayOutline = True
        RowOutlineWidth = appHostApp.ExecuteExcel4Macro("GET.CELL(42)") - RowOutlineWidth
    Else
        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(1).Activate

        RowOutlineWidth = appHostApp.ActiveWindow.PointsToScreenPixelsX(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Left * ScreenResol(0) / 72) * 72 / ScreenResol(0)
        appHostApp.ActiveWindow.DisplayOutline = True
        RowOutlineWidth = appHostApp.ActiveWindow.PointsToScreenPixelsX(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Left * ScreenResol(0) / 72) * 72 / ScreenResol(0) - RowOutlineWidth

        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(lActPane1).Activate
    End If

    lLevLast = lLev
    dZoomLast = dZoom
    sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name
    bFreezePanes = appHostApp.ActiveWindow.FreezePanes
End Sub

Private Sub GetHeadersDimensionTop()
'Idem...
    Dim lActPane1
    Static dZoomLast As Double
    Static sShLast As String
    Static bFreezePanes As Boolean

    'Evita flicks aproveitando ultimo se mesmo...
    If dZoom = dZoomLast And sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name _
       And bFreezePanes = appHostApp.ActiveWindow.FreezePanes Then Exit Sub
    lActPane1 = appHostApp.ActiveWindow.ActivePane.Index
    appHostApp.ActiveWindow.DisplayHeadings = False

    If appHostApp.ActiveWindow.FreezePanes Then            'PointsToScreenPixels s|fffd| |fffd| preciso se ativar pane 1 que n|fffd|o |fffd| possivel se freeze, felizmente neste caso GET.CELL(4 |fffd| perfeito
        ColHeaderHeigth = appHostApp.ExecuteExcel4Macro("GET.CELL(43)")
        appHostApp.ActiveWindow.DisplayHeadings = True
        ColHeaderHeigth = appHostApp.ExecuteExcel4Macro("GET.CELL(43)") - ColHeaderHeigth
    Else
        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(1).Activate

        ColHeaderHeigth = appHostApp.ActiveWindow.PointsToScreenPixelsY(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Top * ScreenResol(1) / 72) * 72 / ScreenResol(1)
        appHostApp.ActiveWindow.DisplayHeadings = True
        ColHeaderHeigth = appHostApp.ActiveWindow.PointsToScreenPixelsY(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Top * ScreenResol(1) / 72) * 72 / ScreenResol(1) - ColHeaderHeigth

        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(lActPane1).Activate
    End If

    dZoomLast = dZoom
    sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name
    bFreezePanes = appHostApp.ActiveWindow.FreezePanes
End Sub

Private Sub GetHeadersDimensionLeft(lLev As Long)
'Idem...
    Dim lActPane1
    Static lLevLast As Long
    Static dZoomLast As Double
    Static sShLast As String
    Static bFreezePanes As Boolean

    'Evita flicks aproveitando ultimo se mesmo...
    If lLev = lLevLast And dZoom = dZoomLast And sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name _
       And bFreezePanes = appHostApp.ActiveWindow.FreezePanes Then Exit Sub

    lActPane1 = appHostApp.ActiveWindow.ActivePane.Index
    appHostApp.ActiveWindow.DisplayHeadings = False

    If appHostApp.ActiveWindow.FreezePanes Then            'PointsToScreenPixels s|fffd| |fffd| preciso se ativar pane 1 que n|fffd|o |fffd| possivel se freeze, felizmente neste caso GET.CELL(4 |fffd| perfeito
        RowHeaderWidth = appHostApp.ExecuteExcel4Macro("GET.CELL(42)")
        appHostApp.ActiveWindow.DisplayHeadings = True
        RowHeaderWidth = appHostApp.ExecuteExcel4Macro("GET.CELL(42)") - RowHeaderWidth
    Else
        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(1).Activate

        RowHeaderWidth = appHostApp.ActiveWindow.PointsToScreenPixelsX(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Left * ScreenResol(0) / 72) * 72 / ScreenResol(0)
        appHostApp.ActiveWindow.DisplayHeadings = True
        RowHeaderWidth = appHostApp.ActiveWindow.PointsToScreenPixelsX(appHostApp.ActiveWindow.ActiveSheet.Range("A1").Left * ScreenResol(0) / 72) * 72 / ScreenResol(0) - RowHeaderWidth

        If lActPane1 <> 1 Then appHostApp.ActiveWindow.Panes(lActPane1).Activate
    End If

    lLevLast = lLev
    dZoomLast = dZoom
    sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name
    bFreezePanes = appHostApp.ActiveWindow.FreezePanes
End Sub

Private Sub GetCellA1Coord()
    Dim bIsPaneFreeze As Boolean
    Dim lPane1ScrolRow As Long
    Dim lPane1ScrolCol As Long
    Dim vActCell As Range
    Set vActCell = appHostApp.ActiveWindow.ActiveCell

    lPane1ScrolRow = appHostApp.ActiveWindow.Panes(1).ScrollRow
    lPane1ScrolCol = appHostApp.ActiveWindow.Panes(1).ScrollColumn
    bIsPaneFreeze = appHostApp.ActiveWindow.FreezePanes
    If bIsPaneFreeze Then
        appHostApp.ActiveWindow.SplitRow = appHostApp.ActiveWindow.SplitRow    'Evitar perda do split no unfreeze, se tiver sido feito direto sem split. Isso aconcece no 2007 e 2010 feito pela Ribbon, mas pode acontecer tamb|fffd|m no 2003
        appHostApp.ActiveWindow.SplitColumn = appHostApp.ActiveWindow.SplitColumn
        appHostApp.ActiveWindow.FreezePanes = False
    End If
    If lActPane <> 1 Then appHostApp.ActiveWindow.Panes(1).Activate

    appHostApp.ActiveWindow.Panes(1).ScrollColumn = 1
    CellA1Coord_Left = appHostApp.ActiveWindow.PointsToScreenPixelsX(appHostApp.Cells(lPane1ScrolRow, 1).Left * ScreenResol(0) / 72) * 72 / ScreenResol(0)
    appHostApp.ActiveWindow.Panes(1).ScrollColumn = lPane1ScrolCol

    appHostApp.ActiveWindow.Panes(1).ScrollRow = 1
    CellA1Coord_Top = appHostApp.ActiveWindow.PointsToScreenPixelsY(appHostApp.Cells(1, lPane1ScrolCol).Top * ScreenResol(0) / 72) * 72 / ScreenResol(1)
    appHostApp.ActiveWindow.Panes(1).ScrollRow = lPane1ScrolRow

    'Aqui s|fffd| precisaria ativar o pane no entanto distorce o pane1 e se c|fffd|lula n|fffd|o tiver inteira em
    'um pane a sele|fffd||fffd|o scroll ou at|fffd| muda. Por isso tem que estocar os scroll para o reajuste
    If appHostApp.ActiveWindow.Panes.Count > 1 Then
        Dim lPane2ScrolRow As Long
        Dim lPane2ScrolCol As Long
        lPane2ScrolRow = appHostApp.ActiveWindow.Panes(2).ScrollRow
        lPane2ScrolCol = appHostApp.ActiveWindow.Panes(2).ScrollColumn
    End If

    If appHostApp.ActiveWindow.Panes.Count > 2 Then
        Dim lPane3ScrolRow As Long
        Dim lPane3ScrolCol As Long
        Dim lPane4ScrolRow As Long
        Dim lPane4ScrolCol As Long
        lPane3ScrolRow = appHostApp.ActiveWindow.Panes(3).ScrollRow
        lPane3ScrolCol = appHostApp.ActiveWindow.Panes(3).ScrollColumn
        lPane4ScrolRow = appHostApp.ActiveWindow.Panes(4).ScrollRow
        lPane4ScrolCol = appHostApp.ActiveWindow.Panes(4).ScrollColumn
    End If

    appHostApp.ActiveWindow.Panes(lActPane).Activate
    vActCell.Select
    appHostApp.ActiveWindow.Panes(1).ScrollColumn = lPane1ScrolCol
    appHostApp.ActiveWindow.Panes(1).ScrollRow = lPane1ScrolRow

    If appHostApp.ActiveWindow.Panes.Count > 1 Then
        appHostApp.ActiveWindow.Panes(2).ScrollRow = lPane2ScrolRow
        appHostApp.ActiveWindow.Panes(2).ScrollColumn = lPane2ScrolCol
    End If
    If appHostApp.ActiveWindow.Panes.Count > 2 Then
        appHostApp.ActiveWindow.Panes(3).ScrollRow = lPane3ScrolRow
        appHostApp.ActiveWindow.Panes(3).ScrollColumn = lPane3ScrolCol
        appHostApp.ActiveWindow.Panes(4).ScrollRow = lPane4ScrolRow
        appHostApp.ActiveWindow.Panes(4).ScrollColumn = lPane4ScrolCol
    End If

    If bIsPaneFreeze Then appHostApp.ActiveWindow.FreezePanes = True
End Sub

Private Function GetExcel7ClsWinPosAPI() As Boolean
'Excel7 class window position by API
    If App_hWnd = 0 Then App_hWnd = appHostApp.hWnd
    Excel7_hWnd = 0
    EnumChildWindows App_hWnd, AddressOf EnumChildProc, ByVal 0&
    If Excel7_hWnd = 0 Then Exit Function

    'GetFormBordAPI
    Dim R As RECT, Rc As RECT, bw, th
    GetWindowRect Excel7_hWnd, R
    GetClientRect Excel7_hWnd, Rc
    bw = ((R.Right - R.Left) - (Rc.Right - Rc.Left)) / 2   'Border witdh
    'th = ((R.Bottom - R.Top) - (Rc.Bottom - Rc.Top)) - 2 * bw    'Title height
    th = ((R.Bottom - R.Top) - (Rc.Bottom - Rc.Top)) - 1.714 * bw    'Title height 'N|fffd|o sei mas n|fffd|o |fffd| 2, mas menos

    CtrlFrames_Top = R.Top + th
    CtrlFrames_Left = R.Left + bw

    GetExcel7ClsWinPosAPI = (R.Right - R.Left) > 0 And (Rc.Right - Rc.Left) > 0
End Function

Private Sub GetCtrlFramesInt()
'Antes fazer ajustes finos para adaptar a posi|fffd||fffd|o de saida |fffd|s anteriores. Geral e com painel n|fffd|o congelado
    CtrlFrames_Top = CtrlFrames_Top + 3 + IIf(IsWinNTVista, 3, 0) + IIf(IsWinNT7, 3, 0) + IIf(IsWinNT8, 3, 0) + IIf(dHostAppVer >= 11 + 1 + 2 + 1, -7, 0)    'Ajuste fino.
    CtrlFrames_Left = CtrlFrames_Left + 0
    If Not appHostApp.ActiveWindow.FreezePanes Then
        Select Case lActPane
        Case 1
        Case 2
            If appHostApp.ActiveWindow.SplitHorizontal > 0 And appHostApp.ActiveWindow.SplitVertical > 0 Then
                CtrlFrames_Left = CtrlFrames_Left - 0.5
            Else
                If appHostApp.ActiveWindow.SplitHorizontal > 0 Then
                    CtrlFrames_Left = CtrlFrames_Left - 0.5
                Else
                    CtrlFrames_Top = CtrlFrames_Top - 0.5 + IIf(IsOffice64_bit, 1, 0)
                End If
            End If
        Case 3
            CtrlFrames_Top = CtrlFrames_Top - 0.5 + IIf(IsOffice64_bit, 1, 0)
        Case 4
            CtrlFrames_Top = CtrlFrames_Top - 0.5 + IIf(IsOffice64_bit, 1, 0)
            CtrlFrames_Left = CtrlFrames_Left - 0.5
        End Select
    End If

    'VERTICAL COORDINATE (Intern Excel7 window)
    'Outline Height
    Dim Lev As Long: Dim i As Long
    Dim c
    If appHostApp.ActiveWindow.DisplayOutline Then
        Lev = 0
        i = appHostApp.ExecuteExcel4Macro("GET.DOCUMENT(12)")    'Because UsedRange method destry undo levels
        For Each c In appHostApp.ActiveWindow.ActiveSheet.Columns
            If Lev < c.OutlineLevel Then Lev = c.OutlineLevel
            If c.Column >= i Then Exit For
        Next
        If Lev > 1 Then
            GetOutlineDimensionTop Lev
            CtrlFrames_Top = CtrlFrames_Top + ColOutlineHeigth * (ScreenResol(1) / 72)    '* dZoom
        End If
    End If

    'Column header Height
    If appHostApp.ActiveWindow.DisplayHeadings Then
        If 2 = 3 Then
            CtrlFrames_Top = CtrlFrames_Top + appHostApp.ActiveWindow.ActiveSheet.StandardHeight * (ScreenResol(1) / 72) * dZoom    'StandardHeight e bem preciso em qualquer cenario, inclusive em zoom.
        Else
            GetHeadersDimensionTop                         'Tinha desabilitado nas vers|fffd|es anteriores porque estava usando PointsToScreenPixelsX em vez de Y.
            CtrlFrames_Top = CtrlFrames_Top + ColHeaderHeigth * (ScreenResol(1) / 72)    '* dZoom
        End If
    End If

    'Zoom adjust acordling rows from top
    CtrlFrames_Top = CtrlFrames_Top + (lActCellRow - lActPaneTopRow) * IIf(dZoom = 0.75, 0.25, 0)

    'Convert Pixel to Point
    CtrlFrames_Top = CtrlFrames_Top * 72 / ScreenResol(1)


    'HORIZONTAL COORDINATE
    'Outline Width
    If appHostApp.ActiveWindow.DisplayOutline Then
        Dim lRowsUR As Long
        Dim lRowsVrf As Long
        Dim lRowsSkip As Long

        lRowsUR = appHostApp.ExecuteExcel4Macro("GET.DOCUMENT(10)")    'appHostApp.ActiveWindow.ActiveSheet.UsedRange.Rows.Count 'Because UsedRange method destry undo levels
        'Para acelera o loop verifica no m|fffd|x 3000 linhas. 1000 prim. 1000 |fffd|lt. e 1000 pelo centro logo ap|fffd|s 1/3
        If lRowsUR <= 3000 Then
            lRowsVrf = 3000
        Else
            lRowsVrf = 1000
            lRowsSkip = lRowsUR / 3
        End If
        Lev = 0

        Dim RowsVrfRng As Range
        Dim ar, rw
        Static lLevLast As Long
        Static sShLast As String
        Static sTimerLast As Single

        'Apesar de otimizado este loop pode incomodar selecionando com tecla pressionada. Ent|fffd|o, se j|fffd| possou por aqui a menos de 10 seg, aproveita |fffd|ltimo na mesma sh
        If lLevLast > 0 And Abs(sTimerLast - Timer) < 10 And sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name Then
            Lev = lLevLast
        Else
            If lRowsVrf > 1000 Then
                Set RowsVrfRng = appHostApp.ActiveWindow.ActiveSheet.Range("A1:A" & IIf(lRowsUR > 0 And lRowsUR < lRowsVrf, lRowsUR, lRowsVrf))
            Else
                Set RowsVrfRng = appHostApp.Union(appHostApp.ActiveWindow.ActiveSheet.Range("A1:A" & lRowsVrf), _
                                                  appHostApp.ActiveWindow.ActiveSheet.Range("A" & lRowsVrf + lRowsSkip & ":A" & lRowsVrf + lRowsSkip + lRowsVrf - 1), _
                                                  appHostApp.ActiveWindow.ActiveSheet.Range("A" & lRowsUR - lRowsVrf + 1 & ":A" & lRowsUR))
            End If
            For Each ar In RowsVrfRng.Areas
                For Each rw In ar.Rows
                    If Lev < rw.OutlineLevel Then Lev = rw.OutlineLevel
                Next
            Next
            lLevLast = Lev
        End If
        sTimerLast = Timer
        sShLast = appHostApp.ActiveWorkbook.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Name

        If Lev > 1 Then
            GetOutlineDimensionLeft Lev
            CtrlFrames_Left = CtrlFrames_Left + RowOutlineWidth * (ScreenResol(0) / 72)
        End If
    End If

    'Row header Width
    If appHostApp.ActiveWindow.DisplayHeadings Then
        'Width change acordling len number of the last row visible
        If appHostApp.ActiveWindow.SplitVertical = 0 Then
            Lev = appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,1)") + Int(appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(16),,1)"))
        Else
            Lev = appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(14),,3)") + Int(appHostApp.ExecuteExcel4Macro("INDEX(GET.WINDOW(16),,3)"))
        End If
        Lev = Len(Lev & "")

        GetHeadersDimensionLeft Lev
        CtrlFrames_Left = CtrlFrames_Left + RowHeaderWidth * (ScreenResol(0) / 72)
    End If

    'Zoom adjust acordling col from left
    'CtrlFrames_Left = CtrlFrames_Left + 0

    'Convert Pixel to Point
    CtrlFrames_Left = CtrlFrames_Left * 72 / ScreenResol(0)
End Sub

Public Function EnumChildProc(ByVal lhWnd As Long, ByVal lParam As Long) As Long
    Dim RetVal As Long
    Dim WinClassBuf As String * 255, WinTitleBuf As String * 255
    Dim WinClass As String, WinTitle As String

    RetVal = GetClassName(lhWnd, WinClassBuf, 255): If RetVal > 0 Then WinClass = VBA.Left$(WinClassBuf, RetVal)
    RetVal = GetWindowText(lhWnd, WinTitleBuf, 255): If RetVal > 0 Then WinTitle = VBA.Left$(WinTitleBuf, RetVal)
    'Debug.Print "Thread Window Class = "; WinClass; ", Title = "; WinTitle    'Em vez de inspeciona com Debug.Print o melhor |fffd| usar o Spy+ do VB6

    EnumChildProc = True                                   'Continuar a procura.
    If WinClass = "EXCEL7" Then                            'Se encontrar a class
        If WinTitle Like appHostApp.ActiveWorkbook.Name & "*" Then    'Se encontrar a class e t|fffd|tulo
            Excel7_hWnd = lhWnd
            EnumChildProc = False                          'Para a procura se encontrou,
        End If
    End If
End Function












Attribute VB_Name = "Mod4GetRegValue"
Option Explicit

Public Const vStr As Long = 255
Public Const REG_BINARY = 3&
Public Const REG_DWORD = 4&
Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" _
                            (ByVal hKey As Long, ByVal lpSubKey As String, _
                             phkResult As Long) As Long
Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" _
                                 (ByVal hKey As Long, _
                                  ByVal lpValueName As String, _
                                  ByVal lpReserved As Long, _
                                  ByRef lpType As Long, _
                                  ByVal lpData As String, _
                                  ByRef lpcbData As Long) As Long  ' Note that if you declare the lpData _
                                                                   'parameter as String, you must pass it By Value.
Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Public Const HKEY_CLASSES_ROOT = &H80000000
Public Const HKEY_CURRENT_USER = &H80000001
Public Const HKEY_LOCAL_MACHINE = &H80000002

Private Declare Function RegDeleteKey Lib "advapi32.dll" _
                                      Alias "RegDeleteKeyA" _
                                      (ByVal hKey As Long, _
                                       ByVal lpSubKey As String) As Long

Private Declare Function RegDeleteValue Lib "advapi32.dll" _
                                        Alias "RegDeleteValueA" _
                                        (ByVal hKey As Long, _
                                         ByVal lpValueName As String) As Long



'Get Registry Value, Arguments:
'1 - Reg Key (Ex.: HKEY_LOCAL_MACHINE),
'2 - Reg SubKey (Ex.: "Software\Microsoft\Windows\CurrentVersion"),
'3 - Name of Value (Ex.:"ProgramFilesDir" or "" for default)
Function GetRegValue(Key As Long, SubKey As String, ValueName As String) As String
    Dim RetStr As String * vStr   'Fixed-length strings
    Dim fctRet As Long
    Dim OpenKeyHdl As Long
    Dim vType As Long
    Dim vLen As Long
    Dim i As Integer

    GetRegValue = "Error"
    vLen = vStr
    fctRet = RegOpenKey(Key, SubKey, OpenKeyHdl)
    If fctRet <> 0 Then Exit Function

    fctRet = RegQueryValueEx(OpenKeyHdl, ValueName, 0&, vType, RetStr, vLen)
    RegCloseKey OpenKeyHdl
    If fctRet <> 0 Then Exit Function

    If vType = REG_BINARY Then
        GetRegValue = ""
        For i = 1 To vLen
            GetRegValue = GetRegValue _
                        & IIf(Len(Hex(Asc(Mid(RetStr, i, 1)))) = 1, "0", "") _
                        & Hex(Asc(Mid(RetStr, i, 1))) & " "
        Next
        Exit Function
    End If

    If vType = REG_DWORD Then
        GetRegValue = "0x"
        For i = 4 To 1 Step -1
            GetRegValue = GetRegValue _
                        & IIf(Len(Hex(Asc(Mid(RetStr, i, 1)))) = 1, "0", "") _
                        & Hex(Asc(Mid(RetStr, i, 1)))
        Next
        Exit Function
    End If

    GetRegValue = VBA.Left(RetStr, vLen - 1)
End Function

Private Sub TestGet()
'Teste 1 Outlook Journal
    MsgBox GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Shared Tools\Outlook\Journaling\Microsoft Excel", "Enabled")
    'Teste 2 Stopwatch
    MsgBox GetRegValue(HKEY_CLASSES_ROOT, "MSCAL.Stopwatch", "")
    'Teste 2 Resolu|fffd||fffd|o do v|fffd|deo
    '    MsgBox appHostApp.WorksheetFunction.Clean(GetRegValue(HKEY_LOCAL_MACHINE, "Config\0001\Display\Settings", "Resolution"))
    'Teste 3 Pastas padr|fffd|es
    MsgBox GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Desktop")
    MsgBox GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Programs")
    MsgBox GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir")
    MsgBox GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesPath")
End Sub

Sub DeleteKey(Key As Long, SubKey As String)
    Call RegDeleteKey(Key, SubKey)
End Sub

Sub DeleteKeyValue(Key As Long, SubKey As String, ValueName As String)
    Dim OpenKeyHdl As Long
    Dim fctRet As Long
    fctRet = RegOpenKey(Key, SubKey, OpenKeyHdl)
    If fctRet <> 0 Then Exit Sub
    Call RegDeleteValue(OpenKeyHdl, ValueName)
    RegCloseKey OpenKeyHdl
End Sub

Attribute VB_Name = "Mod9GetFileNameAPI"
Option Explicit                                            'Igual
' demo project showing how to call the GetSaveFileName and GetOpenFileName API functions
' by Bryan Stafford of New Vision Software|fffd| - newvision@mvps.org (Save_And_Open_File_Dialog_Demo.zip)
' this demo is released into the public domain "as is" without
' warranty or guaranty of any kind.  In other words, use at
' your own risk.


' this demo also shows how the view type for the file list can be set before the
' dialog is shown by sending the undocumented windows messages discovered by Brad Martinez
' (http://www.mvps.org/btmtz/index.html).  THANKS Brad!  you can find more information
' in Brad's listview demo on his site.

'***********************************************************************
' MESSAGES PROVIDED BY Brad Martinez
' view menu command IDs fall within the FCIDM_SHVIEWFIRST/LAST
' range defined in ShlObj.h:
Private Const FCIDM_SHVIEW_LARGEICON As Long = &H7029&     ' 28713
Private Const FCIDM_SHVIEW_SMALLICON As Long = &H702A&     ' 28714
Private Const FCIDM_SHVIEW_LIST As Long = &H702B&          ' 28715
Private Const FCIDM_SHVIEW_REPORT As Long = &H702C&        ' 28716
Private Const FCIDM_SHVIEW_THUMBNAIL As Long = &H702D&     ' 28717
Private Const FCIDM_SHVIEW_TILE As Long = &H702E&          ' 28718
'***********************************************************************

Private Const WM_COMMAND As Long = &H111&

Private Enum OPENFILENAME_FLAGS
    OFN_ALLOWMULTISELECT = &H200
    OFN_CREATEPROMPT = &H2000
    OFN_ENABLEHOOK = &H20
    OFN_ENABLETEMPLATE = &H40
    OFN_ENABLETEMPLATEHANDLE = &H80
    OFN_EXTENSIONDIFFERENT = &H400&
    OFN_FILEMUSTEXIST = &H1000
    OFN_HIDEREADONLY = &H4&
    OFN_NOCHANGEDIR = &H8&
    OFN_NOLONGNAMES = &H40000
    OFN_NONETWORKBUTTON = &H20000
    OFN_NOREADONLYRETURN = &H8000
    OFN_NOTESTFILECREATE = &H10000
    OFN_NOVALIDATE = &H100
    OFN_OVERWRITEPROMPT = &H2&
    OFN_PATHMUSTEXIST = &H800
    OFN_READONLY = &H1
    OFN_SHAREAWARE = &H4000
    OFN_SHAREFALLTHROUGH = 2
    OFN_SHAREWARN = 0
    OFN_SHARENOWARN = 1
    OFN_SHOWHELP = &H10
    OFS_MAXPATHNAME = 128

    ' #if /* WINVER >= 0x0400 */
    OFN_EXPLORER = &H80000                                 '// new look commdlg
    OFN_NODEREFERENCELINKS = &H100000
    OFN_LONGNAMES = &H200000                               '// force long names for 3.x modules
    OFN_ENABLEINCLUDENOTIFY = &H400000                     '// send include message to callback
    OFN_ENABLESIZING = &H800000                            '// enables the sizing for the dialog
    ' #endif /* WINVER >= 0x0400 */

    '#if (_WIN32_WINNT >= 0x0500)
    'OFN_USESHELLITEM = &H1000000               '// disabling support for IShellItem for now (see comdlg32\commdlg.h)
    OFN_DONTADDTORECENT = &H2000000
    OFN_FORCESHOWHIDDEN = &H10000000                       '// Show All files including System and hidden files
    '#endif // (_WIN32_WINNT >= 0x0500)

    '//FlagsEx Values
    '#if (_WIN32_WINNT >= 0x0500)
    OFN_EX_NOPLACESBAR = &H1
    '#endif // (_WIN32_WINNT >= 0x0500)

End Enum

Private Type OPENFILENAME
    'Para detalhes sobre essa estrutua ver: http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/commondialogboxlibrary/commondialogboxreference/commondialogboxstructures/openfilename.asp?frame=true
    lStructSize As Long
    hWndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    flags As OPENFILENAME_FLAGS
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String

    ' new members of this struct added in version 5 of the shell
    ' we can still use this struct with older versions of the shell
    ' because we pass the size of the struct expected by the function
    pvReserved As Long
    dwReserved As Long
    FlagsEx As Long
End Type

Private Declare Function GetSaveFileName Lib "comdlg32" Alias "GetSaveFileNameA" (lpOpenfilename As OPENFILENAME) As Long
Private Declare Function GetOpenFilename Lib "comdlg32" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long

Private Declare Function CommDlgExtendedError Lib "comdlg32" () As Long

Private Type NMHDR
    hwndFrom As Long
    idfrom As Long
    code As Long
End Type


' messages used in the hook proc
Private Const WM_NOTIFY As Long = &H4E&

Private Const CDN_FIRST As Long = (0& - 601&)
Private Const CDN_LAST As Long = (0& - 699&)

' Notifications when Open or Save dialog status changes
Private Const CDN_INITDONE As Long = (CDN_FIRST - &H0&)
Private Const CDN_SELCHANGE As Long = (CDN_FIRST - &H1&)
Private Const CDN_FOLDERCHANGE As Long = (CDN_FIRST - &H2&)
Private Const CDN_SHAREVIOLATION As Long = (CDN_FIRST - &H3&)
Private Const CDN_HELP As Long = (CDN_FIRST - &H4&)
Private Const CDN_FILEOK As Long = (CDN_FIRST - &H5&)
Private Const CDN_TYPECHANGE As Long = (CDN_FIRST - &H6&)
Private Const CDN_INCLUDEITEM As Long = (CDN_FIRST - &H7&)

Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWndParent&, ByVal hWndChildAfter&, ByVal lpClassName$, ByVal lpWindowName$) As Long

Private Declare Function CallWindowProc Lib "user32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc&, ByVal hWnd&, ByVal Msg&, ByVal wParam&, ByVal lParam&) As Long


Private Declare Function GetFileVersionInfoSize Lib "Version.dll" Alias "GetFileVersionInfoSizeA" (ByVal lptstrFilename$, lpdwHandle&) As Long
Private Declare Function GetFileVersionInfo Lib "Version.dll" Alias "GetFileVersionInfoA" (ByVal lptstrFilename$, ByVal dwHandle&, ByVal dwLen&, lpData As Any) As Long
Private Declare Function VerQueryValue Lib "Version.dll" Alias "VerQueryValueA" (pBlock As Any, ByVal lpSubBlock As String, lplpBuffer As Any, puLen As Long) As Long


Private Const WM_SETREDRAW As Long = &HB&
Private Const WM_GETMINMAXINFO As Long = &H24&
Private Const WM_WINDOWPOSCHANGING As Long = &H46&


Private Const WM_RBUTTONUP As Long = &H205&

Private Const MK_RBUTTON As Long = &H2&

Private Const GWL_WNDPROC As Long = (-4&)

Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (lpDest As Any, lpSource As Any, ByVal cBytes As Long)

Private Declare Function GetDesktopWindow Lib "user32" () As Long

Private Declare Function GetParent Lib "user32" (ByVal hWnd&) As Long

Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd&, ByVal wMsg&, wParam As Any, lParam As Any) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hWnd&, ByVal wMsg&, wParam As Any, lParam As Any) As Long
Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd&, ByVal nIndex&, ByVal dwNewLong&) As Long

Declare Function SetCurrentDirectory Lib "kernel32" Alias "SetCurrentDirectoryA" (ByVal lpPathName As String) As Long
Public bUseHook As Boolean
Public hWndForm As Long

Public Function DialogHookProc(ByVal hDlg&, ByVal nMsg&, ByVal wParam&, ByVal lParam&) As Long
' this is the dialog hook proc.  it is called by the dialog to inform us when certian
' actions occur.

' the hDlg param in a hook proc is the handle of a sub dialog created to contain any
' controls that we might want to add to the parent dialog.  to get the actual handle
' to the dialog itself, we need to use the GetParent function.

    Dim hLV&, lpNMHDR As NMHDR

    Select Case nMsg
        ' the WM_NOTIFY message with a code of CDN_FOLDERCHANGE is sent when the
        ' folder view is changing before the dialog is displayed.
    Case WM_NOTIFY
        CopyMemory lpNMHDR, ByVal lParam, Len(lpNMHDR)

        Select Case lpNMHDR.code
            '*******************************************************************************
            ' code that calles the undocumemted messages for changing the listview's view
            ' Thanks go to Brad Martinez for discovering these messages
        Case CDN_FOLDERCHANGE
            hLV = FindWindowEx(GetParent(hDlg), 0, "SHELLDLL_DefView", vbNullString)

            If hLV Then
                Call SendMessage(hLV, WM_COMMAND, ByVal FCIDM_SHVIEW_REPORT, ByVal 0&)
            End If
            '*******************************************************************************

        End Select

    End Select

End Function

Private Function ReturnProcAddress(ByVal lpProc&) As Long
' helper function to return the address of the hook proc
    ReturnProcAddress = lpProc
End Function

Private Function Is2KShell() As Boolean
' this function returns the version of the Comdlg32.dll on the system
' this info is used to determine which version of the OPENFILENAME struct
' should be passed to the dialog functions

    Dim nBuffsize&, nDiscard&, lpBuffer&, nVerMajor&, abytBuffer() As Byte

    Const FILE_NAME As String = "Comdlg32.dll"

    nBuffsize = GetFileVersionInfoSize(FILE_NAME, nDiscard)

    If nBuffsize > 0 Then
        ReDim abytBuffer(nBuffsize - 1) As Byte

        Call GetFileVersionInfo(FILE_NAME, 0&, nBuffsize, abytBuffer(0))

        If VerQueryValue(abytBuffer(0), "\", lpBuffer, nDiscard) Then
            CopyMemory nVerMajor, ByVal lpBuffer + 10, 2&

            If nVerMajor >= 5 Then Is2KShell = True
        End If
    End If

End Function

'======================
' demo project showing how to call the GetSaveFileName and GetOpenFileName API functions
' by Bryan Stafford of New Vision Software|fffd| - newvision@mvps.org
' this demo is released into the public domain "as is" without
' warranty or guaranty of any kind.  In other words, use at
' your own risk.

' this demo also shows how the view type for the file list can be set before the
' dialog is shown by sending the undocumented windows messages discovered by Brad Martinez
' (http://www.mvps.org/btmtz/index.html).  THANKS Brad!  you can find more information
' in Brad's listview demo on his site.

Public Function GetSaveAsFilenameAPI(sInitialFilename As String, sFileFilter As String, lFilterIndex As Long) As String

    Dim lpOFN As OPENFILENAME, sTemp$, nStrEnd&, sInitialDir$

    sInitialDir = CurDir

    ' initialize the struct params
    With lpOFN
        .lStructSize = Len(lpOFN)

        ' if the 2K version of the common dialog dll is not present, subtract the byte count for the
        ' last three members of the struct
        If Is2KShell() = False Then .lStructSize = .lStructSize - 12

        .hWndOwner = hWndForm

        ' tell it we want a "doc" extension.  filter strings are explained in
        ' the OPENFILENAME documentation in the MSDN
        .lpstrFilter = sFileFilter
        .nFilterIndex = lFilterIndex
        .lpstrFile = sInitialFilename & String$(700, 0)
        .nMaxFile = 700
        .lpstrFileTitle = String$(260, 0)
        .nMaxFileTitle = 260
        .lpstrInitialDir = sInitialDir
        '.lpstrTitle = sTitle
        .flags = OFN_EXTENSIONDIFFERENT Or OFN_NOCHANGEDIR Or OFN_OVERWRITEPROMPT Or _
                 OFN_HIDEREADONLY Or OFN_EXPLORER Or OFN_ENABLESIZING Or OFN_FORCESHOWHIDDEN
        .lpstrDefExt = "doc"

        ' if the "Change File View" checkbox is checked, enable the hook proc and change
        ' the view before the dialog is displayed
        If bUseHook Then
            .flags = .flags Or OFN_ENABLEHOOK
            .lpfnHook = ReturnProcAddress(AddressOf Mod9GetFileNameAPI.DialogHookProc)
        End If
    End With

    If GetSaveFileName(lpOFN) Then
        sTemp = lpOFN.lpstrFile
        nStrEnd = InStr(sTemp, vbNullChar)
        If nStrEnd > 1 Then
            GetSaveAsFilenameAPI = Left$(sTemp, nStrEnd - 1)
            SetCurrentDirectory Left(GetSaveAsFilenameAPI, Len(GetSaveAsFilenameAPI) - Len(Dir(GetSaveAsFilenameAPI)))
        Else
            GetSaveAsFilenameAPI = vbNullString
        End If
    Else
        GetSaveAsFilenameAPI = vbNullString
    End If

End Function

Public Function GetOpenFilenameAPI(sFileFilter As String, lFilterIndex As Long, sTitle As String, bMultSel As Boolean) As String

    Dim lpOFN As OPENFILENAME, sTemp$, nStrEnd&, sInitialDir$

    sInitialDir = CurDir

    ' initialize the struct params
    With lpOFN
        .lStructSize = Len(lpOFN)

        ' if the 2K version of the common dialog dll is not present, subtract the byte count for the
        ' last three members of the struct
        If Is2KShell() = False Then .lStructSize = .lStructSize - 12

        .hWndOwner = hWndForm

        ' tell it we want to display all files.  filter strings are explained in
        ' the OPENFILENAME documentation in the MSDN
        .lpstrFilter = sFileFilter
        .nFilterIndex = lFilterIndex
        .lpstrFile = String$(700, 0)
        .nMaxFile = 700
        .lpstrFileTitle = String$(260, 0)
        .nMaxFileTitle = 260
        .lpstrInitialDir = sInitialDir
        .lpstrTitle = sTitle
        .flags = OFN_EXTENSIONDIFFERENT Or OFN_NOCHANGEDIR Or OFN_OVERWRITEPROMPT Or _
                 OFN_HIDEREADONLY Or OFN_EXPLORER Or OFN_ENABLESIZING Or OFN_FORCESHOWHIDDEN
        If bMultSel Then .flags = .flags Or OFN_ALLOWMULTISELECT

        ' if the "Change File View" checkbox is checked, enable the hook proc and change
        ' the view before the dialog is displayed
        If bUseHook Then
            .flags = .flags Or OFN_ENABLEHOOK
            .lpfnHook = ReturnProcAddress(AddressOf Mod9GetFileNameAPI.DialogHookProc)
        End If
    End With

    If GetOpenFilename(lpOFN) Then
        sTemp = lpOFN.lpstrFile
        nStrEnd = InStr(sTemp, vbNullChar)
        If nStrEnd > 1 Then
            If (lpOFN.flags And OFN_ALLOWMULTISELECT) = OFN_ALLOWMULTISELECT Then
                sTemp = Replace(sTemp, vbNullChar & vbNullChar, "")
                If Right(sTemp, 1) = vbNullChar Then sTemp = Left(sTemp, Len(sTemp) - 1)
                GetOpenFilenameAPI = sTemp
                If InStr(GetOpenFilenameAPI, vbNullChar) > 0 Then
                    SetCurrentDirectory Split(sTemp, vbNullChar)(0)
                Else
                    SetCurrentDirectory Left(GetOpenFilenameAPI, Len(GetOpenFilenameAPI) - Len(Dir(GetOpenFilenameAPI)))
                End If
            Else
                GetOpenFilenameAPI = Left$(sTemp, nStrEnd - 1)
                SetCurrentDirectory Left(GetOpenFilenameAPI, Len(GetOpenFilenameAPI) - Len(Dir(GetOpenFilenameAPI)))
            End If
        Else
            GetOpenFilenameAPI = vbNullString
        End If
    Else
        GetOpenFilenameAPI = vbNullString
    End If

End Function

'====== Aqui para aproveitar as APIs. Some exe valid property:"FileDescription", "LegalCopyright", "LegalTrademarks", "ProductName", "FileVersion", "ProductVersion", "InternalName", "OriginalFilename", "Comments"
Function GetVersionProperty(FileName As String, Property As String) As String
    Dim VerInfoSize As Long, lpdwHandle As Long, buffer() As Byte
    Dim strLangCharSet As String, lpData As Long, cbData As Long

    'Query the size of the version info data
    VerInfoSize = GetFileVersionInfoSize(FileName, lpdwHandle)
    If VerInfoSize = 0 Then Exit Function

    'Create the version info buffer and query the data
    ReDim buffer(0 To VerInfoSize - 1)
    If GetFileVersionInfo(FileName, 0, VerInfoSize, buffer(0)) = 0 Then Exit Function

    'Query the language/character set identifier
    If VerQueryValue(buffer(0), "\VarFileInfo\Translation", lpData, cbData) = 0 Then Exit Function
    CopyMemory lpData, ByVal lpData, 4
    strLangCharSet = Hex$(lpData)                          'convert to hex
    strLangCharSet = Right$("00000000" & strLangCharSet, 8)    'pad leading zeroes
    strLangCharSet = Right$(strLangCharSet, 4) & Left$(strLangCharSet, 4)    'swap the upper and lower words

    'Query the original file name
    Dim s As String
    If VerQueryValue(buffer(0), "\StringFileInfo\" & strLangCharSet & "\" & Property, lpData, cbData) = 0 Then Exit Function
    s = Space$(cbData)
    CopyMemory ByVal s, ByVal lpData, cbData
    GetVersionProperty = Left$(s, InStr(s, vbNullChar) - 1)

    If Property = "FileVersion" Or Property = "ProductVersion" Then    'Fiz um formato duplo um para ficar semelhante ao do Windows Explorer e outro como VB com major, minor e revision
        Dim lFileVerMajor As Long
        Dim lFileVerMinor As Long
        Dim lFileVerRevision As Long
        lFileVerRevision = UBound(Split(GetVersionProperty, "."))
        lFileVerMajor = CLng(Split(GetVersionProperty, ".")(0))    '1
        lFileVerMinor = CLng(Split(GetVersionProperty, ".")(1))    '0
        If lFileVerRevision < 2 Then lFileVerRevision = 0 Else lFileVerRevision = CLng(Split(GetVersionProperty, ".")(2))    '974
        GetVersionProperty = lFileVerMajor & "." & lFileVerMinor & ".0." & lFileVerRevision    '"1.0.0.974"
        'GetVersionProperty = GetVersionProperty & "   VB: " & lFileVerMajor & "." & Format(lFileVerMinor, "00") & "." & Format(lFileVerRevision, "0000")     '"1.00.0974"
    End If

End Function



Attribute VB_Name = "ModMyMsgBox"
Option Explicit
Public Const LOCALE_USER_DEFAULT& = &H400
Public Const LOCALE_SENGLANGUAGE = &H1001   'English name of language
Public Const LOCALE_SLANGUAGE = &H2   'localized name of language
Public Const LOCALE_SLIST = &HC         '  list item separator
Public Const LOCALE_SDECIMAL = &HE         '  decimal separator
Public Const LOCALE_STHOUSAND = &HF         '  thousand separator
Public Const LOCALE_ICOUNTRY = &H5         '  country code
Public Const LOCALE_ITIME = &H23        '  time format specifier
Public Const LOCALE_SDATE = &H1D        '  date separator
Public Const LOCALE_STIME = &H1E        '  time separator
Private Declare Function apiGetLocaleInfo Lib "kernel32" _
                                          Alias "GetLocaleInfoA" (ByVal Locale As Long, _
                                                                  ByVal LCType As Long, ByVal lpLCData As String, _
                                                                  ByVal cchData As Long) As Long
Private Declare Function GetVersion Lib "kernel32" () As Long
Declare Function WNetGetUser Lib "mpr.dll" _
                             Alias "WNetGetUserA" (ByVal lpName As String, _
                                                   ByVal lpUserName As String, lpnLength As Long) As Long

Private Declare Function ShellExecute Lib "shell32.dll" _
                                      Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, _
                                                             ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, _
                                                             ByVal nShowCmd As Long) As Long

Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128                           '  Maintenance string for PSS usage
End Type
'  dwPlatformId defines:
Private Const VER_PLATFORM_WIN32s = 0
Private Const VER_PLATFORM_WIN32_WINDOWS = 1
Private Const VER_PLATFORM_WIN32_NT = 2
Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long

Public BotAcionado As Integer
Public IsPortg As Boolean
Public Msg1 As String
Public Msg2 As String

Public Function MyMsgBox(sPrompt As String, lBut As Long, sTitle As String, Optional lModal As Long = vbModal, Optional Xpos As Long, Optional Ypos As Long, Optional App_hWnd1 As Variant, Optional WaitAndRetValue As Long = 2, Optional AlwaysOnTop As Boolean)
    Dim FormMyMsgBox1 As FormMyMsgBox
    Set FormMyMsgBox1 = New FormMyMsgBox    'Aqui dispara inicializar

    With FormMyMsgBox1
        .Caption = sTitle
        .Alert_Tb = sPrompt
        .lBut = lBut
        .Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
        .Email_Lb.ControlTipText = "orlando@cpap.com.br"
        .EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o Popup ", "Information about Popup ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
        .HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
        .HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
        .HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")
        '        .Email_Lb.Visible = Not IsAlreadyDcExe
        '        .HomePage_Lb.Visible = Not IsAlreadyDcExe
        If .Width > 2 * 311 Then Twips = 20 Else Twips = 1    'Em ComAddin as dimens|fffd|es do formul|fffd|rio |fffd| em twip, mas as posi|fffd||fffd|es dos controles continuma em pontos
        If ScreenRx = 0 Then FormPosition     'Na vers|fffd|o 4.0 um MyMsgBox pode ser o primeiro form a posicionar na tela.
        If Xpos > 0 Then .Left = Xpos * Twips Else .Left = (ScreenRx / 2 - .Width / 2) * Twips  'Twips usa-se em COM Add-in, essa a |fffd|nica diferen|fffd|a, pois as dimens|fffd|es do formul|fffd|rio |fffd| em twip, mas as posi|fffd||fffd|es dos controles continuam em pontos.
        If Ypos > 0 Then .Top = Ypos * Twips Else .Top = (ScreenRy / 2 - .Height / 2) * Twips    'Na vers|fffd|o 4.0 para arg Ypos n|fffd|o for informado ou negativo em form oculto, centraliza na tela.
        .lWaitAndRetValue = WaitAndRetValue    '0 - Modeless sem espera; 1 - Modeless com espera; 2 - Modal com espera
        .App_hWnd1 = IIf(IsMissing(App_hWnd1), App_hWnd, CLng(App_hWnd1))
        .bAlwaysOnTop = AlwaysOnTop
        .Height = 75 * Twips                                   'Se apresenta pequena para se expandir por cima no activate, evita marca na tela
        .Show IIf(WaitAndRetValue = 2, 1, 0)  '1   '|fffd| preciso usar em COM add-in

        If .lWaitAndRetValue = 0 Then    'Roda de assincrono sem espera por valor de retorno antigo bReleasedModeless
            BotAcionado = 0
        ElseIf .lWaitAndRetValue = 1 Then     'If modeless and not Released, esperando ret. de valor
            Do While .Visible: MyWait 0.1: Loop
        End If
    End With
    If WaitAndRetValue > 0 Then Unload FormMyMsgBox1
    MyMsgBox = BotAcionado
End Function

Sub MyWait(PauseSeg As Double)
    Dim Start
    Start = Timer
    Do
        DoEvents
        Sleep 1                                            'Com isso o CPU Usage cai de 100% para seus 0 ou 2% normal
        If Start > Timer Then Start = Start - 86400        'A fun|fffd||fffd|o Timer reset meia-noite. Essa falha ficou tempo sem ser percebido por s|fffd| acontecer a meia-noite e s|fffd| com o sleep cresceu a probabilidade
    Loop While Timer < Start + PauseSeg                    'While no final possibilita myWait 0 para DoEvents e sleep para reduzir o usage da CPU para ser usado em loops
End Sub

Function gLocInfo(vType As Long) As String
    Dim vStr As String, vLng As Long
    Dim ret As Long
    vStr = String$(255, 0)
    vLng = 255 - 1
    ret = apiGetLocaleInfo(LOCALE_USER_DEFAULT, vType, vStr, vLng)
    If ret <> 0 Then
        gLocInfo = VBA.Left$(vStr, ret - 1)
    End If
End Function

Function SendEMailByURL(oCtrl As Object, EmailUrl As String, Subj As String, Msg As String, bCtrlError As Boolean) As Boolean
    Dim URL As String
    Dim ret As Long

    If Not oCtrl Is Nothing Then
        If oCtrl.MousePointer = fmMousePointerHourGlass Then Exit Function
        oCtrl.MousePointer = fmMousePointerHourGlass
        oCtrl.ForeColor = &H80FF&
        DoEvents
    End If

    If Subj <> "" Then                                     'Indica para montar uma URL para email
        If appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word" Then _
 appHostApp.StatusBar = IIf(IsPortg, "Preparando E-mail. Aguarde...", "Preparing Email. Wait...")

        '& in Hex
        Subj = MyReplace(Subj, "&", "%26")
        Msg = MyReplace(Msg, "&", "%26")

        'Spaces in Hex
        Subj = MyReplace(Subj, " ", "%20")
        Msg = MyReplace(Msg, " ", "%20")

        'CRLF in Hex
        Msg = MyReplace(Msg, vbCrLf, "%0D%0A")

        URL = "mailto:" & EmailUrl & "?subject=" & Subj & "&body=" & Msg

        'Launch Start command with URL (Falha no Win2000)
        'Ret = Shell(Left("Start " & URL, 460), vbHide)
    Else
        URL = EmailUrl
    End If

    If Not bCtrlError And InStr(1, URL, "#") = 0 Then
        'A vantagem do ShellExecute |fffd| que no m|fffd|todo FollowHyperlink a lingua do Navegador n|fffd|o |fffd| enviada
        'e tem que ter documento aberto. Vou usar FollowHyperlink s|fffd| quando precisar controlar erro e
        'se houver bookmark
        ShellExecute 0&, vbNullString, Left(URL, 457), vbNullString, vbNullString, vbNormalFocus
    Else
        Dim sBookmark As String
        If InStr(1, URL, "#") = 0 Then
            sBookmark = ""
        Else
            sBookmark = Mid(URL, InStr(1, URL, "#"))
            URL = Left(URL, InStr(1, URL, "#") - 1)
        End If

        On Error Resume Next
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            If appHostApp.ActiveWorkbook Is Nothing Then appHostApp.Workbooks.Add
            appHostApp.ActiveWorkbook.FollowHyperlink Left(URL, 457), sBookmark, True       'DifAppMet
        Case "Microsoft Word"
            If appHostApp.ActiveDocument Is Nothing Then appHostApp.Documents.Add
            appHostApp.ActiveDocument.FollowHyperlink Left(URL, 457), sBookmark, True
        Case "Microsoft PowerPoint"
            If appHostApp.ActivePresentation Is Nothing Then appHostApp.Presentations.Add
            appHostApp.ActivePresentation.FollowHyperlink Left(URL, 457), sBookmark, True
        Case "Microsoft Access"
            appHostApp.FollowHyperlink Left(URL, 457), sBookmark, True
        End Select
    End If
    If Err.Number = 0 Then MyWait 10
    If Subj <> "" And (appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word") Then _
 appHostApp.StatusBar = False

    If Err.Number <> 0 Then MsgBox Err.Description
    If Not oCtrl Is Nothing Then oCtrl.MousePointer = fmMousePointerCustom
    SendEMailByURL = Err.Number = 0
    Err.Clear
End Function

Function MyReplace(ByVal vText As String, vTxtFind As String, vTxtRep As String)
'Word 6.0 VBA doesn't have Replace function
    Dim lPos As Long
    lPos = 1 - Len(vTxtRep)
vStart:
    lPos = InStr(lPos + Len(vTxtRep), vText, vTxtFind)
    If lPos = 0 Or vTxtFind = "" Then
        MyReplace = vText
        Exit Function
    End If
    vText = VBA.Left(vText, lPos - 1) & vTxtRep & Right(vText, Len(vText) - lPos - Len(vTxtFind) + 1)
    GoTo vStart
End Function

Function MySplit(ByVal sString As String, Optional sDelim As String, Optional lLimit As Long = -1, Optional bCompare As Long = 0) As Variant
'Excel 97 and Word6 haven't Split function
    Dim sSplitArr() As String
    Dim lPos As Long
    Dim i As Long
    Dim R As Long

    If sString = "" Or lLimit = 0 Then
        MySplit = Array()
        Exit Function
    End If

    If sDelim = "" Then
        ReDim Preserve sSplitArr(i)
        sSplitArr(i) = sString
    Else
        lPos = InStr(1, sString, sDelim, bCompare)
        If lPos = 0 Then
            ReDim Preserve sSplitArr(i)
            sSplitArr(i) = sString
        Else
            R = 2
            Do
                ReDim Preserve sSplitArr(i)
                If R > 1 Then
                    sSplitArr(i) = VBA.Left(sString, lPos - 1)
                    sString = Mid(sString, lPos + Len(sDelim))
                Else
                    sSplitArr(i) = sString
                    sString = ""
                End If
                lPos = InStr(1, sString, sDelim, bCompare)
                R = R - 1 - 1 * (lPos > 0)
                If lLimit <> -1 And i = lLimit - 1 Then
                    sSplitArr(i) = sSplitArr(i) & IIf(R > 0, sDelim & sString, "")
                    Exit Do
                End If
                i = i + 1
            Loop While R > 0
        End If
    End If
    MySplit = sSplitArr
End Function

Function EmlMsg() As String
    Dim WinVer As String
    Dim AppVer As String
    EmlMsg = ""
    EmlMsg = EmlMsg & IIf(IsPortg, "Prezado", "Dear") & " Orlando,"
    EmlMsg = EmlMsg & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Gostaria...", "I would like...")
    EmlMsg = EmlMsg & vbCrLf & vbCrLf & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Atenciosamente,", "Regards,") & vbCrLf & vbCrLf & vbCrLf

    EmlMsg = EmlMsg & "___" & vbCrLf
    EmlMsg = EmlMsg & GetWinUserName & vbCrLf    'O acc e pp n|fffd|o tem appHostApp.UserName e Win user me parece mais

    Select Case appHostApp.Name
    Case "Microsoft Excel"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)  'DifAppMet
    Case "Microsoft Word"
        WinVer = appHostApp.System.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft PowerPoint"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft Access"
        WinVer = GetOperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    End Select

    AppVer = gLocInfo(LOCALE_ICOUNTRY)
    AppVer = IIf(AppVer = 1, "English", IIf(AppVer = 55, "Portugu|fffd|s", "Language " & AppVer))
    AppVer = appHostApp.Name & " " & dHostAppVer & " (" & AppVer & ")"
    EmlMsg = EmlMsg & WinVer & vbCrLf
    EmlMsg = EmlMsg & AppVer & vbCrLf
End Function

Public Function GetOperatingSystem() As String
    Dim Ver As Long, WinVer As Long
    Ver = GetVersion()
    WinVer = Ver And &HFFFF&
    'retrieve the windows version
    GetOperatingSystem = "Windows " & VBA.Format((WinVer Mod 256) + ((WinVer \ 256) / 100), "Fixed")
End Function

Function GetWinUserName() As String
    Dim vStr As String, ret As Long, lpName As String
    vStr = String$(255, 0)
    ret = WNetGetUser(lpName, vStr, 255)
    If ret = 0 Then GetWinUserName = VBA.Left$(vStr, InStr(vStr, Chr(0)) - 1)
End Function

Public Function IsWinNTVista() As Boolean    'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1.
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNTVista = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 0)
End Function

Public Function IsWinNT7() As Boolean    'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1.
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNT7 = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 1)
End Function

Public Function IsWinNT8() As Boolean    'Vista, Win7 e Win8 se distinguem apenas apenas em dwMinorVersion, 0, 1 e 2.
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNT8 = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 2)
End Function

Public Function IsOffice64_bit() As Boolean
    #If VBA7 Then
        '  Code is running in the new VBA7 editor
        #If Win64 Then
            IsOffice64_bit = True                          'Code is running in 64-bit version of Microsoft Office
        #Else
            '  Code is running in 32-bit version of Microsoft Office
        #End If
    #Else
        ' Code is running in VBA version 6 or earlier
    #End If
End Function

Public Function MyClean(ByVal sString As String, Optional ByVal lChrI As Long = -1, Optional ByVal lChrF As Long) As String
    Dim lChr As Long
    If lChrI < 0 And lChrF = 0 Then    'Printable Extended ASCII MyClean("str")
        sString = MyClean(sString, 0, 31)
        sString = MyClean(sString, 127, 127)
    ElseIf lChrI = 0 And lChrF = 0 Then    'Printable ASCII MyClean("str", 0)(Only seen on US Keyboard)
        sString = MyClean(sString, 0, 31)
        sString = MyClean(sString, 127, 255)
    Else
        For lChr = lChrI To lChrF
            If Len(sString) = 0 Then Exit For
            Do While InStr(sString, Chr(lChr)) > 0
                sString = Replace(sString, Chr(lChr), "")
            Loop
        Next
    End If
    MyClean = sString
End Function







Attribute VB_Name = "ModOnTime"
Option Explicit
Declare Function SetTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long, _
                                        ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
Declare Function KillTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long) As Long

Dim SetTimerID As Long    'Ret Id from SetTimer to off
Dim sProcedure As String

'Essa const |fffd| tempor|fffd|ria. Ver coment|fffd|rio em ...Projetos\Stopwatch\OfficeStopwatch\Lembrete.txt se|fffd||fffd|o problemas
Public Const bUsarOnTimeAPI As Boolean = False

Public Sub StartOnTimeAPI(ByVal dSec As Double)
    SetTimerID = SetTimer(0&, 0&, CLng(dSec * 1000), AddressOf SetTimerCallback)
End Sub

Public Sub StopOnTimeAPI()
    KillTimer 0&, SetTimerID
End Sub

Function SetTimerCallback(ByVal hWnd As Long, ByVal uMsg As Long, ByVal idEvent As Long, ByVal dwTime As Long)
    StopOnTimeAPI
    Select Case sProcedure
    Case "MyMacro"
        MyMacro
    Case "Stopwatch"
        Stopwatch
    Case "Menu_Lb_ClickCont"
        '        UserFormStopwatch.Menu_Lb_ClickCont
    End Select
End Function

Sub OnTimeAPI(dSec As Double, sProcedure1 As String)
    sProcedure = sProcedure1
    StartOnTimeAPI dSec
End Sub

'Testa copiando tudo para VBE do Excel
Sub Test()
    OnTimeAPI 0.001, "MyMacro"
End Sub

Sub MyMacro()
    MsgBox "Hi"
End Sub

''HotKeys
'Dim appHostApp
'Dim HotKey As String
'Dim ThisDLLPath
'Dim sPathSep
'
'Sub TestConect()
'    ThisDLLPath = "E:\ComoMVP\MeuSite\Projetos\Stopwatch\OfficeStopwatch"
'    sPathSep = "\"
'    Set appHostApp = Application
'    fHotKey "%+^t", True, False
'End Sub
'
'Sub testDesConect()
'    ThisDLLPath = "E:\ComoMVP\MeuSite\Projetos\Stopwatch\OfficeStopwatch"
'    sPathSep = "\"
'    Set appHostApp = Application
'    fHotKey "%+^t", False, False
'End Sub

Function fHotKey(sHotKey As String, bConect As Boolean, bSilence As Boolean) As Boolean
    Dim Ad
    Dim sAdName As String

    On Error GoTo ErrorHandler

    Select Case appHostApp.Name
    Case "Microsoft Excel"
        sAdName = "ExcelStopwatchHotKey.xla"
        If bConect Then
            'Load addin
            If bIsCOMAddin Then appHostApp.Workbooks.Open FileName:=ThisDLLPath & sPathSep & sAdName
            'Assign hotkey
            If Err.Number = 0 Then appHostApp.OnKey sHotKey, IIf(bIsCOMAddin, "VBAProjectExcelStopwatch.Module1.ExcelStopwatchHotKey", "VBAProjectExcelStopwatch.Mod1Stopwatch.Stopwatch")
        Else
            'Unassign hotkey
            appHostApp.OnKey sHotKey, ""
            'Unload  addin
            If bIsCOMAddin Then appHostApp.Workbooks(sAdName).Close False
        End If

    Case "Microsoft Word"
        Dim bNormSvd As Boolean
        Dim lKeyCode As Long
        Select Case Len(sHotKey)
        Case 1
            lKeyCode = appHostApp.BuildKeyCode(GetWdKey(sHotKey, 1))
        Case 2
            lKeyCode = appHostApp.BuildKeyCode(GetWdKey(sHotKey, 1), GetWdKey(sHotKey, 2))
        Case 3
            lKeyCode = appHostApp.BuildKeyCode(GetWdKey(sHotKey, 1), GetWdKey(sHotKey, 2), GetWdKey(sHotKey, 3))
        Case 4
            lKeyCode = appHostApp.BuildKeyCode(GetWdKey(sHotKey, 1), GetWdKey(sHotKey, 2), GetWdKey(sHotKey, 3), GetWdKey(sHotKey, 4))
        End Select

        sAdName = "WordStopwatchHotKey.dot"
        If bConect Then
            'Load addin
            If bIsCOMAddin Then Set Ad = appHostApp.AddIns.Add(FileName:=ThisDLLPath & sPathSep & sAdName, Install:=True)
            'Assign hotkey
            appHostApp.CustomizationContext = appHostApp.NormalTemplate
            bNormSvd = appHostApp.NormalTemplate.Saved
            appHostApp.KeyBindings.Add KeyCode:=lKeyCode, KeyCategory:=2, _
                                       Command:=IIf(bIsCOMAddin, "VBAProjectWordStopwatch.Module1.WordStopwatchHotKey", "VBAProjectWordStopwatch.Mod1Stopwatch.Stopwatch")    '2=wdKeyCategoryMacro
            appHostApp.NormalTemplate.Saved = bNormSvd
        Else
            'Unassign hotkey
            bNormSvd = appHostApp.NormalTemplate.Saved
            appHostApp.FindKey(KeyCode:=lKeyCode).Clear
            appHostApp.NormalTemplate.Saved = bNormSvd
            'Unload  addin
            If bIsCOMAddin Then
                For Each Ad In appHostApp.AddIns
                    If Ad.Name = sAdName Then Ad.Delete
                Next
            End If
        End If
    Case "Microsoft PowerPoint"
        'PowerPoint n|fffd|o tem OnKey ou equivalente. Alguns usam API chamando uma DLL de terceiro que possilvelmente usar addressof
    Case "Microsoft Access"
        'Access n|fffd|o tem OnKey ou equivalente. Tem AutoKeys macro como AutoOpen e fica no banco de dados
    End Select
    fHotKey = True
    Exit Function
ErrorHandler:
    If Not bSilence Then MyMsgBox IIf(IsPortg, "Erro! " & Err.Description, "Error! " & Err.Description) & vbCrLf & sAdName, 1, sAddInCaptByApp & IIf(IsPortg, " - Tecla de Atalho ", " - Hotkey ") & sHotKey
End Function

Private Function GetWdKey(sSring As String, lPos) As Long    'As WdKey
    If lPos < 1 Then GetWdKey = 255: Exit Function    '255=wdNoKey
    Select Case Mid(sSring, lPos, 1)
    Case "%"
        GetWdKey = 1024  'wdKeyAlt
    Case "+"
        GetWdKey = 256    'wdKeyShift
    Case "^"
        GetWdKey = 512    'wdKeyControl
    Case ""
        GetWdKey = 255    'wdNoKey
    Case Else
        GetWdKey = Asc(UCase(Mid(sSring, lPos, 1)))
    End Select
End Function




Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
'Implements IDTExtensibility2

Private WithEvents HostApp As Excel.Application
Attribute HostApp.VB_VarHelpID = -1
Private WithEvents cbbButton As Office.CommandBarButton
Attribute cbbButton.VB_VarHelpID = -1
Dim bRibbon As Boolean

Dim LastEnterTime As Single
Dim LastEnterAddr As String

'Private Sub IDTExtensibility2_OnConnection(ByVal _
 Application As Object, ByVal ConnectMode As _
 AddInDesignerObjects.ext_ConnectMode, ByVal AddInInst _
 As Object, custom() As Variant)
Private Sub Workbook_Open()
'Store startup reference
    IsPortg = GetIsPortg   'IsPortg = Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070                   'appHostApp.International(xlCountryCode) = 55
'   sDLLProgId = AddInInst.ProgId
    bIsCOMAddin = sDLLProgId <> ""
    If bIsCOMAddin Then
        '        sAddInNameByApp = Split(AddInInst.Description, " - ")(0)
        '        sAddInCaptByApp = Split(AddInInst.Description, " - ")(1)
    Else
        sAddInNameByApp = "ExcelStopwatch"
        sAddInCaptByApp = "Stopwatch for Excel"
    End If
    If IsPortg Then sAddInCaptByApp = MyReplace(sAddInCaptByApp, "Stopwatch for", "Cron|fffd|metro para")
    AddInTitle = "Orlando's " & sAddInNameByApp

    'N|fffd|o conecta, se o ExcelStopwatch (ou o OfficeStopwatch) j|fffd| tiver se conectado. N|fffd|o h|fffd| conflito apenas para evitar uma duplicidade sem nenhum benef|fffd|cio
    If Not Application.CommandBars.FindControl(Tag:= _
                                                    "Orlando's " & IIf(sAddInNameByApp = "OfficeStopwatch", "ExcelStopwatch", "OfficeStopwatch")) Is Nothing Then Exit Sub

    Set HostApp = Application
    dHostAppVer = Val(HostApp.Version)
    If dHostAppVer < 9 Then Exit Sub Else App_hWnd = GetActiveWindow    'Neces. no 9, pois mais seguro que FindWindowA porque o Excel n|fffd|o |fffd| MDI e poder ter mais de uma janela
    Set appHostApp = HostApp

    'Se COM e o add-in xla j|fffd| aberto, deixa menu para ele, pois serve para todas vers|fffd|es do Excel
    If bIsCOMAddin Then
        On Error Resume Next
        Msg1 = HostApp.Workbooks("ExcelStopwatch.xla").Name    'Testa se est|fffd| aberto
        If Err.Number = 0 Then HostApp.Run "ExcelStopwatch.xla!fGetVersion"    'Testa se |fffd| meu e a vers|fffd|o
        If Err.Number = 0 Then Exit Sub
        On Error GoTo 0
    End If

    'To call from RibbonX thru ExcelStopwatch.xlam
    If dHostAppVer >= 11 + 1 + 2 Then
        On Error Resume Next
        If VBA.FileSystem.Dir(ThisDLLPath & "\ExcelStopwatch.xlam") <> "" Then
            appHostApp.Workbooks.Open ThisDLLPath & "\ExcelStopwatch.xlam"
            DoEvents
            bRibbon = (Err.Number = 0)
        End If
        On Error GoTo 0
    End If

    ReadINISetting

    ' Add the commandbar
    ShortMenuPos IIf(lShortMenuPosIni <> 0, 1, 0), lShortMenuPosIni = 2: ToolbarPos IIf(lToolbarPosIni <> 0, 1, 0), lToolbarPosIni = 2
    Set cbbButton = appHostApp.CommandBars.FindControl(Tag:=AddInTitle)

    'Se COM class Object to show in VBA
    '    Set ObjToVBA = New StopwatchObjToVBA
    '    AddInInst.Object = ObjToVBA
End Sub
Private Sub Workbook_AddinInstall()
'    AddMenu "Cell", False, True
'    AddMenu "XLM Cell", False, True
    Workbook_Open
End Sub

'Private Sub IDTExtensibility2_OnAddInsUpdate(custom() As Variant)
''
'End Sub
'
'Private Sub IDTExtensibility2_OnBeginShutdown(custom() As Variant)
'    If CollectionInst.Count > 0 Then QuitMultForce    'Antes garantir tudo fechado, pois se houver instancias com op|fffd||fffd|o 'Unanchored form Excel Window', gera GPF no Excel 15 e alerta de erro em vers|fffd|es anteriores.
'End Sub

'Private Sub IDTExtensibility2_OnDisconnection(ByVal _
 '        RemoveMode As AddInDesignerObjects.ext_DisconnectMode, _
 '        custom() As Variant)
Private Sub Workbook_BeforeClose(Cancel As Boolean)
    If dHostAppVer < 9 Or TypeName(appHostApp) = "Nothing" Then Exit Sub      'A |fffd|ltima |fffd| pare evitar beforeClose novamente, pois em xla ao fechar e cancelar de um alerta de salvar ele j|fffd| aconteceu

'RemoveToolbar
    ShortMenuPos 0: ToolbarPos 0
    If bRibbon Then On Error Resume Next: appHostApp.Workbooks("ExcelStopwatch.xlam").Close False

    'UnAssign HotKey
    If HotKeyIni <> "" Then fHotKey HotKeyIni, False, True

    'remove references to shutdown
    '    Set ObjToVBA = Nothing    'Necess|fffd|rio se n|fffd|o fica gerando GPF as sair do Excel
    Set cbbButton = Nothing
    Set appHostApp = Nothing
    Set HostApp = Nothing
End Sub

Private Sub IDTExtensibility2_OnStartupComplete(custom() As Variant)
'
End Sub

Private Sub cbbButton_Click(ByVal Ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    If vModalIni = 0 And vShowingModeless Then Exit Sub  'N|fffd|o sei porque, mas ao reposicionar o menu em COM add-in cada click fica redobrado
    Dim rngSel As Range, c As Range, lCnt As Long
    If TypeName(appHostApp.Selection) = "Range" Then Set rngSel = appHostApp.Selection: lCnt = rngSel.Cells.Count
    Msg1 = IIf(IsPortg, "H|fffd| " & lCnt & " c|fffd|lulas selecionadas. Criar inst|fffd|ncias ancoradas do Cron|fffd|metro " & IIf(Not bAnchActCelStartIni And (lEchoDisplayInCellIni And 1) = 1, "devido o ecoar visor ", "") & "em todas as c|fffd|lulas que tenham formato de tempo e valor de tempo v|fffd|lido?", _
               "There are " & lCnt & " selected cells. Create anchored instances of the Stopwatch " & IIf(Not bAnchActCelStartIni And (lEchoDisplayInCellIni And 1) = 1, "due echoing display ", "") & "in all cells which have time format and valid time value?")
    Msg2 = sAddInCaptByApp & IIf(IsPortg, " - M|fffd|ltiplas Inst|fffd|ncias Ancoradas em C|fffd|lulas!", " - Multiple Instances Anchored in Cell!")
    If lCnt > 1 And (bAnchActCelStartIni Or (lEchoDisplayInCellIni And 1) = 1) And Not bMultDisable Then MyMsgBox Msg1, 3, Msg2: If BotAcionado = 2 Then lCnt = 1 Else If BotAcionado = 3 Then Exit Sub
    If Err.Number <> 0 Or lCnt < 2 Or Not (bAnchActCelStartIni Or (lEchoDisplayInCellIni And 1) = 1) Or bMultDisable Then
        If bUsarOnTimeAPI Then OnTimeAPI 0.01, "Stopwatch" Else Stopwatch
    Else
        appHostApp.EnableEvents = False
        For Each c In rngSel
            If CellHasTimeFormat(c.NumberFormat) And IsTimeExtend(c.Value) Then
                c.Select
                If bUsarOnTimeAPI Then OnTimeAPI 0.01, "Stopwatch" Else Stopwatch
            End If
        Next
        rngSel.Select
        appHostApp.EnableEvents = True
    End If
End Sub

Private Sub HostApp_SheetChange(ByVal Sh As Object, ByVal Target As Range)
    LastEnterAddr = Target.Cells(1, 1).Address & Target.Parent.Name & Target.Parent.Parent.Name              'appHostApp.ActiveWindow.ActiveCell.Address
    LastEnterTime = Timer
End Sub

Private Sub HostApp_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)
    If IsMouseDown(vbRightButton) Then Exit Sub
    If dHostAppVer < 11 + 1 Then
        If Target.Cells.Count > 1 Then Exit Sub
    Else
        If Target.Cells.CountLarge > 1 Then Exit Sub
    End If
    On Error Resume Next
    If IsError(Target.Value) Then Exit Sub
    On Error GoTo 0
    If Target.Value <> Empty Then If Not IsTimeExtend(Target.Value) Then Exit Sub    'N|fffd|o popup se o conte|fffd|do n|fffd|o for de tempo

    Dim n As Name
    Dim Rng As Excel.Range: Set Rng = appHostApp.ActiveWindow.ActiveCell
    Dim UserFormStopwatch1 As UserFormStopwatch

    'Close se multinstance disable and 'Close when changing active cell' option on
    'If Not CollectionInst Is Nothing And bMultDisable And bCloseChgCell Then Cancel_Bt_ClickMult

    'Verif. se j|fffd| exist outro auto popup rodando na cel. Na vers|fffd|o 4.0, tamb|fffd|m se j|fffd| existir ecoando display.
    If Not CollectionInst Is Nothing Then
        For Each UserFormStopwatch1 In CollectionInst
            With UserFormStopwatch1
                If .bFromAutoPopCell Or (.lEchoDisplayInCell And 1) = 1 Then
                    If Rng.Address = .rngActCelStart.Address And _
                       Rng.Parent.Name = .rngActCelStart.Parent.Name And _
                       Rng.Parent.Parent.Name = .rngActCelStart.Parent.Parent.Name Then
                        Exit Sub
                    End If
                End If
            End With
        Next
    End If

    If vModalIni = "" Or bCallBYfStopwatchIni Then ReadINISetting    'Ler or reler tamb|fffd|m se tiver sido usado por uma instancia chamada por fStopw
    If Rng.Address & Rng.Parent.Name & Rng.Parent.Parent.Name = LastEnterAddr And Abs(Timer - LastEnterTime) <= 0.5 Then Exit Sub      'Evitar, ao dar Enter, popup como se houvesse alterado a sele|fffd||fffd|o

    For Each n In appHostApp.ActiveWorkbook.Names
        If VBA.Left(LCase(n.Name), Len("PopupStopwatch")) = LCase("PopupStopwatch") Then
            On Error Resume Next
            Set Rng = appHostApp.Intersect(Target, n.RefersToRange)
            If Err.Number = 0 And Not Rng Is Nothing Then
                bArrKeysCancel = True
                bFromAutoPopCellIni = True
                Stopwatch    'StopwatchFromCmB
                Exit Sub
            End If
        End If
    Next

    Dim f
    If bPopupFormatSelIni Then
        If CellHasTimeFormat(Target.NumberFormat) Then
            bArrKeysCancel = True
            bFromAutoPopCellIni = True
            Stopwatch    'StopwatchFromCmB
            Exit Sub
        End If
    End If

    If lCountInstAdd > 0 Then xLbStopIns_TriggSlcCellMult Target
End Sub

Function GetIsPortg()
'Empacotei a linha abaixo nesta fun|fffd||fffd|o(ou sub) porque no Excel 2003, se ela for usada diretamente no OpenEvent
'provoca GPF ao carregar projeto decompilado que tenha tamanho maior que 200Kb decompilado (500 compilado)
'   GetIsPortg = Application.International(xlCountryCode) = 55
    GetIsPortg = Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070                 'appHostApp.International(xlCountryCode) = 55
End Function

Attribute VB_Name = "UserFormCntDown"
Attribute VB_Base = "0{9F9BDA9F-AFF3-4624-B5BE-207CB1B8636C}{60595B62-1F82-4784-9C29-BCAEDD1E95C7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim EmailSubj As String
Dim HomePageUrl As String
Public UserFormStopwatch1 As UserFormStopwatch
Dim Form_hWnd1 As Long
Dim vEnableEvents As Boolean
Dim lSt As Long, lInc As Long, lEOMonth As Long, lRstEOMonth As Long

Private Sub Cancel_Bt_Click()
    Set UserFormStopwatch1.UserFormCntDown1 = Nothing
    Unload Me
End Sub

Private Sub CDStartFrom_OpB_Click()
    CDtoDTime_OpB.Value = False 'Em COM existe um bug onde ao clicar em um option os outros n|fffd|o s|fffd|o falseados automaticamente, requerendo falsear nos eventos click primeiro e depois chamar c|fffd|digo, por isso xCDtoDTime_OpB_Click foi isolado.
    xCDtoDTime_OpB_Click
End Sub
Private Sub CDtoDTime_OpB_Click()
    CDStartFrom_OpB.Value = False
    xCDtoDTime_OpB_Click
End Sub
Private Sub xCDtoDTime_OpB_Click()
    CDtoDTime_Tb.Enabled = CDtoDTime_OpB.Value: DTPickerEmbedTbEnlarge CDtoDTime_Tb, CDtoDTime_OpB.Value
    CDHour_Tb.Enabled = Not CDtoDTime_OpB.Value: SpinButton1.Enabled = CDHour_Tb.Enabled
    CDMin_Tb.Enabled = CDHour_Tb.Enabled: SpinButton2.Enabled = CDHour_Tb.Enabled
    CDSec_Tb.Enabled = CDHour_Tb.Enabled: SpinButton3.Enabled = CDHour_Tb.Enabled
    CDSecFract_Tb.Enabled = CDHour_Tb.Enabled: SpinButton4.Enabled = CDHour_Tb.Enabled
End Sub

Private Sub CDSpeak_ChB_Click()
'Testar Test-To-Speach
    On Error Resume Next
    If vEnableEvents Then
        Msg1 = "Hi!"    'IIf(IsPortg, "Falar |fffd|ltimos segundos", "Speak last seconds")
    Else
        Msg1 = ""    'Testar em sil|fffd|ncio
    End If
    If CDSpeak_ChB.Value Then appHostApp.Speech.Speak Msg1
    If Err.Number <> 0 Then
        Msg1 = IIf(IsPortg, "Talvez seu Excel n|fffd|o tenha ainda o recurso 'Text-To-Speech (Texto-Para-Voz)' instalado. Se n|fffd|o, voc|fffd| precisa instal|fffd|-lo. Veja como em: http://support.microsoft.com/kb/288986/pt ", "Maybe your Excel haven't 'Text-To-Speech' feature installed yet. If not, you need to install it. See how at: http://office.microsoft.com/en-us/help/HA102223271033.aspx")
        Msg2 = IIf(IsPortg, "Falar |fffd|ltimos Segundos - Falha!", "Speak Last Seconds - Fail!")
        MyMsgBox Msg1, 1, Msg2, , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        CDSpeak_ChB.Value = False
    End If
End Sub

'Private Sub CDBeep_ChB_Click() 'Comentei, pois suportar Beep e Wav parece interessante se Wav falhar.
'    If CDBeep_ChB.Value Then CDWav_ChB.Value = False
'End Sub
'Private Sub CDWav_ChB_Click()
'    If CDWav_ChB.Value Then CDBeep_ChB.Value = False
'End Sub

Private Sub CDRecntdown_ChB_Click()
    If CDRecntdown_ChB.Value Then CDRecntdown_ChB.Value = True: CDStart_ChB.Value = False: CDRestart_ChB.Value = False: CDQuit_ChB.Value = False
End Sub
Private Sub CDStart_ChB_Click()
    If CDStart_ChB.Value Then CDRecntdown_ChB.Value = False: CDStart_ChB.Value = True: CDRestart_ChB.Value = False: CDQuit_ChB.Value = False
End Sub
Private Sub CDRestart_ChB_Click()
    If CDRestart_ChB.Value Then CDRecntdown_ChB.Value = False: CDStart_ChB.Value = False: CDRestart_ChB.Value = True: CDQuit_ChB.Value = False
End Sub
Private Sub CDQuit_ChB_Click()
    If CDQuit_ChB.Value Then CDRecntdown_ChB.Value = False: CDStart_ChB.Value = False: CDRestart_ChB.Value = False: CDQuit_ChB.Value = True
End Sub

Private Sub LbCancel_Click()
    Cancel_Bt_Click
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then
        'Cancel = True
        Cancel_Bt_Click
    End If
End Sub

Private Sub LbStartStop_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbStartStop.SpecialEffect = fmSpecialEffectSunken: xLbStartStop_Click: End Sub
Private Sub LbStartStop_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbStartStop.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbCancel_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbCancel.SpecialEffect = fmSpecialEffectSunken: End Sub
Private Sub LbCancel_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbCancel.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSaveSetting_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSaveSetting.SpecialEffect = fmSpecialEffectSunken: End Sub
Private Sub LbSaveSetting_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSaveSetting.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbDefaultSetting_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbDefaultSetting.SpecialEffect = fmSpecialEffectSunken: End Sub
Private Sub LbDefaultSetting_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbDefaultSetting.SpecialEffect = fmSpecialEffectEtched: End Sub

Private Sub xLbStartStop_Click()
    Dim lTickCountDownFix As Long    'Fix o tick
    Dim dTimeDownFix As Date
    lTickCountDownFix = GetTickCount()
    dTimeDownFix = Now

    Cancel_Bt.SetFocus
    If Not IsNumeric(CDHour_Tb.Value) Then
        MyMsgBox CDHour_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDHour_Tb.SetFocus
        Exit Sub
    End If
    If Not IsNumeric(CDMin_Tb.Value) Then
        MyMsgBox CDMin_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDMin_Tb.SetFocus
        Exit Sub
    End If
    If Not IsNumeric(CDSec_Tb.Value) Then
        MyMsgBox CDSec_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDSec_Tb.SetFocus
        Exit Sub
    End If
    If Not IsNumeric(CDSecFract_Tb.Value) Then
        MyMsgBox CDSecFract_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDSecFract_Tb.SetFocus
        Exit Sub
    End If
    If CDtoDTime_OpB.Value And Not IsDate(CDtoDTime_Tb.Value) Then
        MyMsgBox CDtoDTime_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDtoDTime_Tb.SetFocus
        Exit Sub
    End If
    If Not IsNumeric(CDBeep_Tb.Value) Then
        MyMsgBox CDBeep_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDBeep_Tb.SetFocus
        Exit Sub
    End If
    If Not IsNumeric(CDSpeak_Tb.Value) Then
        MyMsgBox CDSpeak_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDSpeak_Tb.SetFocus
        Exit Sub
    End If

    Dim dbCDElapsed As Double    'Necess|fffd|rio pois .dbCDElapsed pode estar sendo usado em outra recontagem
    If Not CDtoDTime_OpB.Value Then
        dbCDElapsed = CDHour_Tb * 3600 + CDMin_Tb * 60 + CDSec_Tb + CDSecFract_Tb / 10 ^ Len(CDSecFract_Tb)
    Else
        lTickCountDownFix = GetTickCount(): dTimeDownFix = Now    'Calcular novamente para ficar mais exato,pois o now j|fffd| deve ter mudado.
        dbCDElapsed = (CDbl(DateValue(CDtoDTime_Tb.Text) + TimeValue(CDtoDTime_Tb.Text)) - CDbl(dTimeDownFix)) * 24 * 60 * 60
    End If
    If dbCDElapsed <= 0 Then    'Necess|fffd|rio definir um tempo pelo menos segundos.
        MyMsgBox IIf(CDtoDTime_OpB.Value, CDtoDTime_Tb.Value, CDSec_Tb.Value), 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido ou Expirado!", " - Invalid Value or Expired!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        If CDtoDTime_OpB.Value Then CDtoDTime_Tb.SetFocus Else CDSec_Tb.SetFocus
        Exit Sub
    End If

    With UserFormStopwatch1
        If .bCntDown = False Then
            .dbElapsedCurr = .dbElapsed
            If .lBotPress = 1 Then .PrintPapel .dbElapsedCurr, dTimeDownFix, .LbStartStop.Caption, "", .WriteTbVisor(.dbElapsedCurr)                'Se estiver contando e logando |fffd| interessante para registra no log
        End If
        .dbCDElapsed = dbCDElapsed
        .lBotPress = 1
        .bCntDown = True
        .PrintPapel .dbCDElapsed, dTimeDownFix, LbStartStop.Caption, "", .WriteTbVisor(.dbCDElapsed)
        If CDtoDTime_OpB.Value Then lTickCountDownFix = GetTickCount() - 400: dTimeDownFix = Now: .dbCDElapsed = (CDbl(DateValue(CDtoDTime_Tb.Text) + TimeValue(CDtoDTime_Tb.Text)) - CDbl(dTimeDownFix)) * 24 * 60 * 60    'Calcular novamente para ficar mais exato,pois o now j|fffd| deve ter mudado. Antecipar um delay de -400 foi obtido por tentativa de ajuste a formulas na planilha AuctionCountdown2.xls.
        .dTimeDownFix = dTimeDownFix: .lTickCountDownFix = lTickCountDownFix: .dbStart = .lTickCountDownFix / 1000 + .dbCDElapsed: .LoopAPI: .lTickCountDownFix = 0  'LoopAPI agora para sincronizar o TickCount fixado.

        .lCDHour = CDHour_Tb.Value
        .lCDMin = CDMin_Tb.Value
        .lCDSec = CDSec_Tb.Value
        .lCDSecFract = CDSecFract_Tb.Value
        .bCDtoDTime = CDtoDTime_OpB.Value
        .dbCDtoDTime = CDbl(DateValue(CDtoDTime_Tb.Text) + TimeValue(CDtoDTime_Tb.Text))
        .bCDBeep = CDBeep_ChB.Value
        .lCDBeep = CDBeep_Tb.Value
        .bCDQuit = CDQuit_ChB.Value
        .bCDWav = CDWav_ChB.Value
        .sCDFileWav = CDFileWav_Tb.Value
        .bCDRun = CDRun_ChB.Value
        .sCDFileRun = CDFileRun_Tb.Value
        .bCDAlert = CDAlert_ChB.Value
        .sCDTxtAlert = CDTxtAlert_Tb.Value
        .bCDStart = CDStart_ChB.Value
        .bCDSpeak = CDSpeak_ChB.Value
        .lCDSpeak = CDSpeak_Tb.Value
        .bCDRestart = CDRestart_ChB.Value
        .bCDReCntdown = CDRecntdown_ChB.Value
        Set .UserFormCntDown1 = Nothing
    End With

    Unload Me    'Hide
End Sub

Private Sub LbSaveSetting_Click()    'Cancela contagem regressiva, mas antes de fechar o form salva configura|fffd||fffd|o feita. |fffd|til para configurar sem iniciar contagem como nas instru|fffd||fffd|es do exemplo para cronometrar receita. Novo na vers|fffd|o 4.0
    If Not IsNumeric(CDBeep_Tb.Value) Then
        MyMsgBox CDBeep_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDBeep_Tb.SetFocus
        Exit Sub
    End If
    If Not IsNumeric(CDSpeak_Tb.Value) Then
        MyMsgBox CDSpeak_Tb.Value, 1, Caption & IIf(IsPortg, " - Valor Inv|fffd|lido!", " - Invalid Value!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
        LbStartStop.SpecialEffect = fmSpecialEffectEtched
        CDSpeak_Tb.SetFocus
        Exit Sub
    End If

    With UserFormStopwatch1
        .bCDBeep = CDBeep_ChB.Value
        .lCDBeep = CDBeep_Tb.Value
        .bCDQuit = CDQuit_ChB.Value
        .bCDWav = CDWav_ChB.Value
        .sCDFileWav = CDFileWav_Tb.Value
        .bCDRun = CDRun_ChB.Value
        .sCDFileRun = CDFileRun_Tb.Value
        .bCDAlert = CDAlert_ChB.Value
        .sCDTxtAlert = CDTxtAlert_Tb.Value
        .bCDStart = CDStart_ChB.Value
        .bCDSpeak = CDSpeak_ChB.Value
        .lCDSpeak = CDSpeak_Tb.Value
        .bCDRestart = CDRestart_ChB.Value
        .bCDReCntdown = CDRecntdown_ChB.Value
        .WriteINISetting1
    End With

    Cancel_Bt_Click
End Sub

Private Sub LbDefaultSetting_Click()    'Restaura config padr|fffd|o. Novo na vers|fffd|o 4.0
    CDHour_Tb.Value = 0
    CDMin_Tb.Value = 0
    CDSec_Tb.Value = 0
    CDSecFract_Tb.Value = 0
    CDtoDTime_OpB.Value = False
    CDtoDTime_Tb.Value = Format(Now + TimeSerial(0, 0, 60), "yyyy-mm-dd hh:nn:ss")
    CDBeep_ChB.Value = False
    CDBeep_Tb.Value = 10
    CDQuit_ChB.Value = False
    CDWav_ChB.Value = False
    CDFileWav_Tb.Value = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "MediaPath") & "\TADA.WAV"    '"C:\WINDOWS\MEDIA\TADA.WAV"
    CDRun_ChB.Value = False
    CDFileRun_Tb.Value = "Notepad.exe"
    CDAlert_ChB.Value = False
    CDTxtAlert_Tb.Value = IIf(IsPortg, "A Contagem Regressiva Expirou!", "The Coutdown Expire!")
    CDStart_ChB.Value = False
    CDSpeak_ChB.Value = False
    CDSpeak_Tb.Value = 10
    CDRestart_ChB.Value = False
    CDRecntdown_ChB.Value = False
End Sub

Private Sub CDWavBrowser_Lb_Click()
    Dim vFileName
    Static ChDirOne As Boolean
    If ChDirOne = False And (CDFileWav_Tb.Value = "" Or Dir(CDFileWav_Tb.Value) = "") Then
        If Mid(ThisDLLPath, 2, 1) = ":" Then ChDrive ThisDLLPath
        ChDir ThisDLLPath
        ChDirOne = True
    Else
        If CDFileWav_Tb.Value <> "" And Dir(CDFileWav_Tb.Value) <> "" Then
            vFileName = Left(CDFileWav_Tb.Value, InStrRev(CDFileWav_Tb.Value, appHostApp.PathSeparator))
            If Mid(vFileName, 2, 1) = ":" Then ChDrive vFileName
            ChDir vFileName
        End If
    End If
    If IsPortg Then
        vFileName = appHostApp.GetOpenFilename("Sons (*.wav),*.wav,Todos (*.*),*.*", , "Selecionar WAV")
    Else
        vFileName = appHostApp.GetOpenFilename("Sounds (*.wav),*.wav,All Files (*.*),*.*", , "Select WAV")
    End If
    If vFileName = False Then Exit Sub
    CDFileWav_Tb.Value = vFileName
End Sub

Private Sub CDRunBrowser_Lb_Click()
    Dim vFileName
    Static ChDirOne As Boolean
    If ChDirOne = False And (CDFileRun_Tb.Value = "" Or Dir(CDFileRun_Tb.Value) = "") Then
        If Mid(ThisDLLPath, 2, 1) = ":" Then ChDrive ThisDLLPath
        ChDir ThisDLLPath
        ChDirOne = True
    Else
        If CDFileRun_Tb.Value <> "" And Dir(CDFileRun_Tb.Value) <> "" Then
            vFileName = Left(CDFileRun_Tb.Value, InStrRev(CDFileRun_Tb.Value, appHostApp.PathSeparator))
            If Mid(vFileName, 2, 1) = ":" Then ChDrive vFileName
            ChDir vFileName
        End If
    End If
    If IsPortg Then
        vFileName = appHostApp.GetOpenFilename("Programas (*.exe;*.com),*.exe;*.com,Todos (*.*),*.*", , "Selecionar Programa")
    Else
        vFileName = appHostApp.GetOpenFilename("Programs (*.exe;*.com),*.exe;*.com,All Files (*.*),*.*", , "Select Program")
    End If
    If vFileName = False Then Exit Sub
    CDFileRun_Tb.Value = vFileName
End Sub




Private Sub UserForm_Activate()
    Static OneTime As Boolean
    If OneTime Then Exit Sub Else OneTime = True

    Top = UserFormStopwatch1.Top - 30 * Twips    'Exibir um pouco acima para ao clicar no bot|fffd|o Start n|fffd|o mover cron|fffd|metro devido mouse_move.
    If UserFormStopwatch1.Left - 100 * Twips < -8 * Twips Then Left = -8 * Twips Else Left = UserFormStopwatch1.Left - 100 * Twips
    If UserFormStopwatch1.lCDSecFract = "" And UserFormStopwatch1.bCDtoDTime = False Then
        LbDefaultSetting_Click
    Else
        CDHour_Tb.Value = UserFormStopwatch1.lCDHour
        CDMin_Tb.Value = UserFormStopwatch1.lCDMin
        CDSec_Tb.Value = UserFormStopwatch1.lCDSec
        CDSecFract_Tb.Value = IIf(UserFormStopwatch1.lCDSecFract = "", 0, UserFormStopwatch1.lCDSecFract)
        CDtoDTime_OpB.Value = UserFormStopwatch1.bCDtoDTime
        CDtoDTime_Tb.Value = Format(UserFormStopwatch1.dbCDtoDTime, "yyyy-mm-dd hh:nn:ss")
        CDBeep_ChB.Value = UserFormStopwatch1.bCDBeep
        CDBeep_Tb.Value = UserFormStopwatch1.lCDBeep
        CDQuit_ChB.Value = UserFormStopwatch1.bCDQuit
        CDWav_ChB.Value = UserFormStopwatch1.bCDWav
        CDFileWav_Tb.Value = UserFormStopwatch1.sCDFileWav
        CDRun_ChB.Value = UserFormStopwatch1.bCDRun
        CDFileRun_Tb.Value = UserFormStopwatch1.sCDFileRun
        CDAlert_ChB.Value = UserFormStopwatch1.bCDAlert
        CDTxtAlert_Tb.Value = UserFormStopwatch1.sCDTxtAlert
        CDStart_ChB.Value = UserFormStopwatch1.bCDStart
        vEnableEvents = False
        CDSpeak_ChB.Value = UserFormStopwatch1.bCDSpeak
        vEnableEvents = True
        CDSpeak_Tb.Value = UserFormStopwatch1.lCDSpeak
        CDRestart_ChB.Value = UserFormStopwatch1.bCDRestart
        CDRecntdown_ChB.Value = UserFormStopwatch1.bCDReCntdown
    End If

    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")
    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
    Email_Lb.Left = Width / Twips - Email_Lb.Width - (Width / Twips - InsideWidth) - 4    'Email_Lb.Left = Width / Twips - Email_Lb.Width - 8

    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel. Depois da op|fffd||fffd|o bUnanchExcelWin sempre no form que chamou OnTop se
    SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, UserFormStopwatch1.Form_hWnd: If UserFormStopwatch1.bAlwaysOnTop Then SetWindowPos Form_hWnd1, HWND_TOPMOST, 0, 0, 0, 0, flags     'If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente

    'Ativar window |fffd| necess|fffd|rio porque, n|fffd|o sei qual a raz|fffd|o, o form fica por atras do Stopwath ou do Excel em COM ao cpturar countDown
    SetForegroundWindow Form_hWnd1    ' Como tenho o handle melhor que AppActivate.
End Sub

Private Sub UserForm_Initialize()
    CDHour_Lb.Caption = IIf(IsPortg, "Horas", "Hours")
    CDMin_Lb.Caption = IIf(IsPortg, "Minutos", "Minutes")
    CDSec_Lb.Caption = IIf(IsPortg, "Segundos", "Seconds")
    CDSecFract_Lb.Caption = IIf(IsPortg, "Fra|fffd||fffd|o", "Fraction")
    CDtoDTime_OpB.Caption = IIf(IsPortg, "Contar para uma data/hora futura em:   (aaaa-mm-dd hh:mm:ss)", "Countdown to a future date/time at:   (yyyy-mm-dd hh:mm:ss)"): GoToday_Lb.Caption = IIf(IsPortg, "H", "T"): GoNow_Lb.Caption = IIf(IsPortg, "A", "N"): GoToday_Lb.ControlTipText = IIf(IsPortg, "Insere Hoje, somente data.", "Insert Today date only."): GoNow_Lb.ControlTipText = IIf(IsPortg, "Insere Agora, somente hora.", "Insert Now time only."): GoToday_Lb.MouseIcon = HomePage_Lb.MouseIcon: GoNow_Lb.MouseIcon = HomePage_Lb.MouseIcon: DTPickerEmbedTbHlp_Lb.MouseIcon = HomePage_Lb.MouseIcon
    CDStartFrom_OpB.Caption = IIf(IsPortg, "Iniciar de:", "Start from:")
    LbStartStop.Caption = IIf(IsPortg, "Iniciar", "Start")
    LbCancel.Caption = IIf(IsPortg, "Cancelar", "Cancel")
    CDEvents_Fr.Caption = IIf(IsPortg, "Eventos ao expirar:", "Events when expiring:")
    LbBeepTimes.Caption = IIf(IsPortg, "vezes", "times")
    CDQuit_ChB.Caption = IIf(IsPortg, "Fechar Cron|fffd|metro", "Close Stopwatch")
    CDWav_ChB.Caption = IIf(IsPortg, "Tocar:", "Play:")
    CDRun_ChB.Caption = IIf(IsPortg, "Rodar:", "Run:")
    CDAlert_ChB.Caption = IIf(IsPortg, "Alertar:", "Alert:")
    CDRecntdown_ChB.Caption = IIf(IsPortg, "Reiniciar a contagem regressiva em loop infinito", "Restart the countdown in endless loop")    'New option
    LbSaveSetting.Caption = IIf(IsPortg, "Salva Config.", "Save Setting")
    LbDefaultSetting.Caption = IIf(IsPortg, "Padr|fffd|o", "Default")
    CDStart_ChB.Caption = IIf(IsPortg, "Rodar Cron|fffd|metro do zero pressionando bot|fffd|es Reset e Iniciar", "Run Stopwatch from zero pressing Reset and Start buttons")
    CDStart_ChB.ControlTipText = IIf(IsPortg, "Dica! Em m|fffd|ltiplas inst|fffd|ncias, atar bot|fffd|es Reset e Iniciar para iniciar v|fffd|rios simultaneamente do zero ao expirar a contagem regressiva.", "Tip! In multiple instances, attach Reset and Start buttons to start several at once from zero when countdown expires.")
    CDRestart_ChB.Caption = IIf(IsPortg, "Rodar Cron|fffd|metro do tempo atual pressionando bot|fffd|o Reiniciar", "Run Stopwatch from current time pressing Restart button")    'New option
    CDRestart_ChB.ControlTipText = IIf(IsPortg, "Dica! Em m|fffd|ltiplas inst|fffd|ncias, atar bot|fffd|es Iniciar e Reiniciar para iniciar ou reiniciar v|fffd|rios simultaneamente ao expirar a contagem regressiva.", " Tip! In multiple instances, attach Start and Restart buttons to start or restart several at once when countdown expires.")
    CDSpeak_ChB.Caption = IIf(IsPortg, "Falar |fffd|ltimos", "Speak last")
    LbSpeakSec.Caption = IIf(IsPortg, "segundos", "seconds")
End Sub

Private Sub SpinButton1_SpinDown(): EvSpin CDHour_Tb, -1: End Sub
Private Sub SpinButton2_SpinDown(): EvSpin CDMin_Tb, -1: End Sub
Private Sub SpinButton3_SpinDown(): EvSpin CDSec_Tb, -1: End Sub
Private Sub SpinButton4_SpinDown(): EvSpin CDSecFract_Tb, -1: End Sub
Private Sub SpinButton5_SpinDown(): EvSpin CDBeep_Tb, -1: End Sub
Private Sub SpinButton6_SpinDown(): EvSpin CDSpeak_Tb, -1: End Sub
Private Sub SpinButton1_SpinUp(): EvSpin CDHour_Tb, 1: End Sub
Private Sub SpinButton2_SpinUp(): EvSpin CDMin_Tb, 1: End Sub
Private Sub SpinButton3_SpinUp(): EvSpin CDSec_Tb, 1: End Sub
Private Sub SpinButton4_SpinUp(): EvSpin CDSecFract_Tb, 1: End Sub
Private Sub SpinButton5_SpinUp(): EvSpin CDBeep_Tb, 1: End Sub
Private Sub SpinButton6_SpinUp(): EvSpin CDSpeak_Tb, 1: End Sub
Private Sub EvSpin(vCtrl As Object, Inc As Long)    'As Control pode d|fffd| erro em COM add-in
    If Not IsNumeric(vCtrl.Value) Then vCtrl.Value = 0
    If vCtrl.Name = "CDSecFract_Tb" And vCtrl.Value > 0 And (Left(vCtrl.Value, 1) = "0" Or Len(vCtrl.Value) > 1) Then
        'S|fffd| incrementa decimal de 1 a 9 ou teria que ter controle para cent e mil ent|fffd|o ativa o textbox para digitar qualquer fra|fffd||fffd|o inclusive iniciada por 0
        SpinButton4.Visible = False
        CDSecFract_Tb.SetFocus
    Else
        vCtrl.Value = vCtrl.Value + Inc
    End If
    If vCtrl.Value <= 0 Then vCtrl.Value = 0    'Evitar negativo s|fffd| para n|fffd|o complicar, pois matematicamente n|fffd|o tem proplema
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub


'Textboxes with embed DateTime Picker. Traduzi do VB dos toEXEs. Alterado no VBA: os argumentos dos eventos aqui requerem ByVal, o tipo do KeyCode e LostFocus n|fffd|o existe aqui, mas exit serviu.
Private Sub CDtoDTime_Tb_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): DTPickerEmbed_Tb_MouseDown Button, Shift, X, Y, CDtoDTime_Tb: End Sub
Private Sub CDtoDTime_Tb_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): DTPickerEmbed_Tb_MouseUp Button, Shift, X, Y, CDtoDTime_Tb: End Sub
Private Sub CDtoDTime_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): DTPickerEmbed_Tb_LostFocus CDtoDTime_Tb: End Sub
Private Sub CDtoDTime_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): DTPickerEmbed_Tb_KeyDown KeyCode, Shift, CDtoDTime_Tb: End Sub

Private Sub DTPickerEmbed_Tb_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single, DTPickerEmbed_Tb As Control)
    If DTPickerEmbed_Tb.MousePointer = 0 Then DTPickerEmbed_Tb.MousePointer = 1: Exit Sub    'Seguran|fffd|a, no primeiro click sai, apenas altera cursor do mouse restaurando em lost focus ou altera com tecla.
    lInc = IIf(Y < DTPickerEmbed_Tb.Height / 2 - 50 * 0, 1, -1)    'Alterado no VBA n|fffd|o requer ajuste de 50.
    DTPickerEmbedTextBox DTPickerEmbed_Tb
End Sub
Private Sub DTPickerEmbed_Tb_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single, DTPickerEmbed_Tb As Control)
    If DTPickerEmbed_Tb.SelLength > 0 Then DTPickerEmbed_Tb.SelLength = 0: DTPickerEmbed_Tb.SelStart = lSt    'Colap sele|fffd||fffd|o de duploclick, restarando |fffd|ltima pos.
End Sub
Private Sub DTPickerEmbed_Tb_LostFocus(DTPickerEmbed_Tb As Control)
    DTPickerEmbed_Tb.MousePointer = 0
End Sub

Private Sub DTPickerEmbed_Tb_KeyDown(KeyCode As MSForms.ReturnInteger, Shift As Integer, DTPickerEmbed_Tb As Control)
    If KeyCode = 37 Then lSt = DTPickerEmbed_Tb.SelStart - 1: If lSt < 1 Then lSt = 1
    If KeyCode = 39 Then lSt = DTPickerEmbed_Tb.SelStart + 1
    If KeyCode = 38 Or KeyCode = 40 Then
        DTPickerEmbed_Tb.MousePointer = 0
        lInc = IIf(KeyCode = 38, 1, -1)
        DTPickerEmbedTextBox DTPickerEmbed_Tb
        KeyCode = 0    'If KeyCode = 38 Then If DTPickerEmbed_Tb.SelStart < Len(DTPickerEmbed_Tb.Text) Then DTPickerEmbed_Tb.SelStart = lSt + 1 Else VBA.SendKeys "{RIGHT}"  'Alterado no VBA que n|fffd|o requer estas duas linhas apena zerar, pois as setas up e down sai do controle.
        '               If KeyCode = 40 And lSt > 0 Then DTPickerEmbed_Tb.SelStart = lSt - 1
    End If
    If Shift = 2 And (KeyCode = 84 Or KeyCode = 72) Then GoToday_Lb_Click    'DTPickerEmbed_Tb.Text = Format(Date, "yyyy-mm-dd hh:nn:ss")    'Go Today (T ou H)
    If Shift = 2 And (KeyCode = 78 Or KeyCode = 65) Then GoNow_Lb_Click    'DTPickerEmbed_Tb.Text = Format(Now, "yyyy-mm-dd hh:nn:ss")
End Sub
Private Sub DTPickerEmbedTextBox(DTPickerEmbed_Tb As Control)
    Dim dDate As Date
    lSt = DTPickerEmbed_Tb.SelStart
    dDate = DateValue(DTPickerEmbed_Tb.Text) + TimeValue(DTPickerEmbed_Tb.Text)
    If lSt <> 6 And lSt <> 7 Then lEOMonth = 0             'Se n|fffd|o |fffd| casa de m|fffd|s, mata restaura de EOMonth
    Select Case lSt
    Case 1, 2, 3, 4                                    'yyyy
        lInc = 10 ^ (4 - lSt) * lInc
        If Year(dDate) + lInc <= Year(Now) - 10 Or Year(dDate) + lInc >= Year(Now) + 40 Then Exit Sub
        dDate = DateSerial(Year(dDate) + lInc, Month(dDate), Day(dDate)) + TimeSerial(Hour(dDate), Minute(dDate), Second(dDate))
    Case 6, 7                                          'mm
        If lSt = 6 Then lInc = 10 * lInc
        If Month(dDate) + lInc >= 1 And Month(dDate) + lInc <= 12 And Day(dDate) >= 28 Then    'Para n|fffd|o travar incrementando m|fffd|s, melhor ajustar dia para final do m|fffd|s, mas guarda existente para restaurar enquanto continuar alterndo m|fffd|s.
            If lEOMonth = 0 Then lRstEOMonth = Day(dDate)
            If Not IsDate(Format(Year(dDate), "0000") & "-" & Format(Month(dDate) + lInc, "00") & "-" & Format(lRstEOMonth, "00")) Then
                lEOMonth = Day(DateSerial(Year(dDate), Month(dDate) + lInc + 1, 0))
                dDate = DateSerial(Year(dDate), Month(dDate), lEOMonth) + TimeSerial(Hour(dDate), Minute(dDate), Second(dDate))
            Else
                dDate = DateSerial(Year(dDate), Month(dDate) + lInc, lRstEOMonth) + TimeSerial(Hour(dDate), Minute(dDate), Second(dDate))
                GoTo UpdtTb                            'J|fffd| testadao e EOMonth restaurado ent|fffd|o ir direto para o update do texbox
            End If
        End If
        If Not IsDate(Format(Year(dDate), "0000") & "-" & Format(Month(dDate) + lInc, "00") & "-" & Format(Day(dDate), "00")) _
           Or Month(dDate) + lInc < 1 Or Month(dDate) + lInc > 12 Then Exit Sub
        dDate = DateSerial(Year(dDate), Month(dDate) + lInc, Day(dDate)) + TimeSerial(Hour(dDate), Minute(dDate), Second(dDate))

    Case 9, 10                                         'dd
        If lSt = 9 Then lInc = 10 * lInc
        If Not IsDate(Format(Year(dDate), "0000") & "-" & Format(Month(dDate), "00") & "-" & Format(Day(dDate) + lInc, "00")) _
           Or Day(dDate) + lInc < 0 Or Day(dDate) + lInc > 31 Then Exit Sub
        dDate = DateSerial(Year(dDate), Month(dDate), Day(dDate) + lInc) + TimeSerial(Hour(dDate), Minute(dDate), Second(dDate))

    Case 12, 13                                        'hh
        If lSt = 12 Then lInc = 10 * lInc
        If Not IsDate(Format(Hour(dDate) + lInc, "00") & ":" & Format(Minute(dDate), "00") & ":" & Format(Second(dDate), "00")) _
           Or Hour(dDate) + lInc < 0 Or Hour(dDate) + lInc > 23 Then Exit Sub
        dDate = DateSerial(Year(dDate), Month(dDate), Day(dDate)) + TimeSerial(Hour(dDate) + lInc, Minute(dDate), Second(dDate))

    Case 15, 16                                        'nn
        If lSt = 15 Then lInc = 10 * lInc
        If Not IsDate(Format(Hour(dDate), "00") & ":" & Format(Minute(dDate) + lInc, "00") & ":" & Format(Second(dDate), "00")) _
           Or Minute(dDate) + lInc < 0 Or Minute(dDate) + lInc > 59 Then Exit Sub
        dDate = DateSerial(Year(dDate), Month(dDate), Day(dDate)) + TimeSerial(Hour(dDate), Minute(dDate) + lInc, Second(dDate))

    Case 18, 19                                        'ss
        If lSt = 18 Then lInc = 10 * lInc
        If Not IsDate(Format(Hour(dDate), "00") & ":" & Format(Minute(dDate), "00") & ":" & Format(Second(dDate) + lInc, "00")) _
           Or Second(dDate) + lInc < 0 Or Second(dDate) + lInc > 59 Then Exit Sub
        dDate = DateSerial(Year(dDate), Month(dDate), Day(dDate)) + TimeSerial(Hour(dDate), Minute(dDate), Second(dDate) + lInc)
    End Select
UpdtTb:
    '                                          1234567890123456789
    DTPickerEmbed_Tb.Text = Format(dDate, "yyyy-mm-dd hh:nn:ss")
    DTPickerEmbed_Tb.SelStart = lSt
End Sub

Private Sub DTPickerEmbedTbHlp_Lb_Click()    'Index As Integer)
    Msg2 = IIf(IsPortg, "Ajuda Pegador de Data/Hora Embutido", "Embedded Date/Time Picker Help")
    MyMsgBox IIf(IsPortg, "Todas as caixas de texto de data/tempo aqui tem pegador de data/hora incorporado. Para alterar um n|fffd|mero diretamente no formato mantendo data e tempo v|fffd|lidos:" & vbCrLf & _
                          "- Posicione o cursor em frente ao n|fffd|mero usando o mouse ou as teclas de seta direita e esquerda;" & vbCrLf & _
                          "- Para incrementar ou decrementar, use as teclas de seta superior e inferior ou clique com o mouse na parte superior e inferior do cursor." & vbCrLf & vbCrLf & _
                          "- Ctrl + H - Insere Hoje, somente data." & vbCrLf & _
                          "- Ctrl + A - Insere Agora, somente hora.", _
                 "All textboxes of date/time here have embedded date/time picker. To change a number directly in the format maintaining valid date and time:" & vbCrLf & _
                 "- Position the cursor in front of the number using the mouse or the right and left arrow key" & vbCrLf & _
                 "- To increment or decrement, use up and down arrow key or click with the mouse on the top and bottom of cursor." & vbCrLf & vbCrLf & _
                 "- Ctrl + T - Insert Today date only." & vbCrLf & _
                 "- Ctrl + N - Insert Now time only."), _
             1, Msg2, vbModal, Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
    On Error Resume Next
    '    If Index = 0 Then LimitExecDateFrom_Tb.SetFocus
End Sub

Private Sub CDtoDTime_Tb_DblClick(ByVal Cancel As MSForms.ReturnBoolean)    '|fffd|timo no VBA devido o Cancel n|fffd|o existente no VB. N|fffd|o deixa nem a sele|fffd||fffd|o acontecer.
    Cancel = True
End Sub

Private Sub DTPickerEmbedTbEnlarge(DTPickerEmbed_Tb, bEnlarge As Boolean)
    If bEnlarge Then
        CDtoDTime_Tb.Font.Size = 16: CDtoDTime_Tb.Font.Weight = 1000: CDtoDTime_Tb.BackColor = &H8000&: CDtoDTime_Tb.ForeColor = &HFFFF00
    Else
        CDtoDTime_Tb.Font.Size = CDHour_Tb.Font.Size: CDtoDTime_Tb.Font.Weight = CDHour_Tb.Font.Weight: CDtoDTime_Tb.BackColor = CDHour_Tb.BackColor: CDtoDTime_Tb.ForeColor = CDHour_Tb.ForeColor
    End If
    DTPickerEmbedTbHlp_Lb.Left = DTPickerEmbed_Tb.Left + DTPickerEmbed_Tb.Width
    GoToday_Lb.Left = DTPickerEmbedTbHlp_Lb.Left: GoToday_Lb.Top = DTPickerEmbed_Tb.Top + DTPickerEmbed_Tb.Height - GoToday_Lb.Height - 2: GoToday_Lb.Visible = bEnlarge
    GoNow_Lb.Left = DTPickerEmbedTbHlp_Lb.Left + 8.25: GoNow_Lb.Top = GoToday_Lb.Top: GoNow_Lb.Visible = bEnlarge
End Sub

Private Sub GoToday_Lb_Click()
    CDtoDTime_Tb.Text = Format(Date + TimeValue(Right(CDtoDTime_Tb.Text, 8)), "yyyy-mm-dd hh:nn:ss")    'Go Today(T)
End Sub
Private Sub GoNow_Lb_Click()
    CDtoDTime_Tb.Text = Format(DateValue(Left(CDtoDTime_Tb.Text, 10)) + Time, "yyyy-mm-dd hh:nn:ss")   'Go Now (N)
End Sub

Attribute VB_Name = "UserFormHotKey"
Attribute VB_Base = "0{0930328C-E039-4976-BD4C-024EDA142FC9}{45E5FAD0-A557-452C-B9AE-FA3EEE066165}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim EmailSubj As String
Dim HomePageUrl As String
Public UserFormStopwatch1 As UserFormStopwatch
Dim Form_hWnd1 As Long

Private Sub Cancel_Bt_Click()
    Unload Me
End Sub

Private Sub Clear_Bt_Click()
    HotKeyIni = ""
    Unload Me
End Sub

Private Sub Ok_Bt_Click()
    If Len(Key_Tb.Value) = 0 Then
        HotKeyIni = ""
        Unload Me
    End If
    If Len(Key_Tb.Value) = 1 Then
        HotKeyIni = IIf(Alt_ChB.Value, "%", "") _
                  & IIf(Shift_ChB.Value, "+", "") _
                  & IIf(Ctrl_ChB.Value, "^", "") & Left(Key_Tb.Value, 1)
        Unload Me
    End If
    If Len(Key_Tb.Value) > 1 Then MyMsgBox IIf(IsPortg, "Insira uma letra ou um n|fffd|mero.", "Insert one letter or one number."), 1, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
End Sub

Private Sub UserForm_Activate()
'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel. Depois da op|fffd||fffd|o bUnanchExcelWin sempre no form que chamou OnTop se
    SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, UserFormStopwatch1.Form_hWnd: If UserFormStopwatch1.bAlwaysOnTop Then SetWindowPos Form_hWnd1, HWND_TOPMOST, 0, 0, 0, 0, flags    'If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, UserFormStopwatch1.Form_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
    Key_Tb.SetFocus
End Sub

Private Sub UserForm_Initialize()
    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")
    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
    Email_Lb.Left = Width / Twips - Email_Lb.Width - (Width / Twips - InsideWidth) - 4    'Email_Lb.Left = Width / Twips - Email_Lb.Width - 8

    Caption = IIf(IsPortg, "Tecla de Atalho", "Hot Key")
    Key_Tb.Value = Right(HotKeyIni, 1)
    Alt_ChB.Value = InStr(1, HotKeyIni, "%") > 0
    Shift_ChB.Value = InStr(1, HotKeyIni, "+") > 0
    Ctrl_ChB.Value = InStr(1, HotKeyIni, "^") > 0 Or Key_Tb.Value = ""
    'Key_Tb.SetFocus 'Se usado em COM add-in, o evento Activate n|fffd|o dispara, talvez um bug. Tranferi para o activate
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub












Attribute VB_Name = "UserFormSkin"
Attribute VB_Base = "0{5AB631B2-EB6E-4935-B3F8-7D0F474CBE90}{40F98328-3EF7-4BDF-982E-3DD00C204CE1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim EmailSubj As String
Dim HomePageUrl As String
Public UserFormStopwatch1 As UserFormStopwatch
Dim Form_hWnd1 As Long
Dim vEnableEvents As Boolean
Dim lClickOnDisplay As Long    '0 a 4 dft 0
Dim bEnableBackgrond As Boolean
Dim lColorBackground As Long
Dim sPictFile As String
Dim lPictAlignment As Long    '0 a 4 dft 2
Dim lPictSizeMode As Long    '0 a 3 dft 0 sem 2
Dim bPictTiling As Boolean
Dim bTranspDisplay As Boolean    'dft true
Dim bTranspCtrlPanel As Boolean
Dim bTranspSnapshotLb As Boolean
Dim bTranspPaper As Boolean
Dim bHideTitleBar As Boolean
Dim bAutoHideCtrlPanel As Boolean
Dim bAnchActCelStart As Boolean
Dim bAnchCelAdjWidth As Boolean
Dim bAnchCelAdjHeight As Boolean
Dim bUnanchExcelWin As Boolean
Dim bAlwaysOnTop As Boolean

Private Sub ClickOnDisplay_Cb_Change()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub EnableBackground_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
    FormEnableDisCtrls
End Sub

Private Sub HideTitleBar_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
    FormEnableDisCtrls
End Sub

Private Sub AutoHideCtrlPanel_ChB_Click()
    UserFormStopwatch1.bUserNoteUpd = False    'Para atualizar form size no pr|fffd|ximo loop.
    If vEnableEvents Then SkinSettingUpt
    FormEnableDisCtrls
End Sub

Private Sub AnchActCelStart_ChB_Click()
    If vEnableEvents And AnchActCelStart_ChB.Value Then
        Msg1 = "": On Error Resume Next: Msg1 = UserFormStopwatch1.rngActCelStart.AddressLocal: On Error GoTo 0    'Verifica se cel inicial existe antes de alterar cfg
        If Msg1 = "" Then MyMsgBox IIf(IsPortg, "Esta inst|fffd|ncia n|fffd|o pode ser ancorada agora porque n|fffd|o havia c|fffd|lula ativa quando iniciou ou foi deletada.", "This instance can not be anchored now because there wasn't active cell when started or was deleted."), 1, sAddInCaptByApp & IIf(IsPortg, " - Falha!", " - Fail!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop: Exit Sub
    End If

    UserFormStopwatch1.bUserNoteUpd = False    'Para atualizar form size no pr|fffd|ximo loop.
    If vEnableEvents Then SkinSettingUpt
    FormEnableDisCtrls
End Sub
Private Sub AnchCelAdjWidth_ChB_Click()
    AnchActCelStart_ChB_Click
End Sub
Private Sub AnchCelAdjHeight_ChB_Click()
    AnchActCelStart_ChB_Click
End Sub

Private Sub UnanchExcelWin_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub AlwaysOnTop_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub PictFile_Tb_Change()
    If vEnableEvents Then SkinSettingUpt
    FormEnableDisCtrls
End Sub

Private Sub PictFileOpen_Lb_Click()
    Dim vFileName
    Static ChDirOne As Boolean
    If ChDirOne = False And (PictFile_Tb.Value = "" Or Dir(PictFile_Tb.Value) = "") Then
        If Mid(ThisDLLPath, 2, 1) = ":" Then ChDrive ThisDLLPath
        ChDir ThisDLLPath
        ChDirOne = True
    Else
        If PictFile_Tb.Value <> "" And Dir(PictFile_Tb.Value) <> "" Then
            vFileName = Left(PictFile_Tb.Value, InStrRev(PictFile_Tb.Value, sPathSep))
            If Mid(vFileName, 2, 1) = ":" Then ChDrive vFileName
            ChDir vFileName
        End If
    End If

    Dim sFileFilter As String                              'xxxxx Deve ser ecoado, pois s|fffd| estava func. no Excel
    bUseHook = True
    hWndForm = Form_hWnd1
    sFileFilter = IIf(IsPortg, "Figuras", "Pictures") & " (*.emf;*.wmf;*.jpg;*.jpeg;*.jfif;*.jpe;*.png;*.bmp;*.dib;*.rle;*.gif;*.bmz;*.gfa;*.emz;*.ico)" & vbNullChar & "*.emf;*.wmf;*.jpg;*.jpeg;*.jfif;*.jpe;*.png;*.bmp;*.dib;*.rle;*.gif;*.bmz;*.gfa;*.emz;*.ico" & vbNullChar & vbNullChar
    On Error GoTo ErrHandler
    vFileName = GetOpenFilenameAPI(sFileFilter, 1, sAddInCaptByApp & " - " & IIf(IsPortg, "Inserir Figura de Fundo", "Insert Background Picture"), False)
    If LenB(vFileName) = 0 Then Exit Sub
    PictFile_Tb.Value = vFileName
    On Error Resume Next
    UserFormStopwatch1.Picture = LoadPicture(vFileName)
    If Err.Number <> 0 Then
        If Err.Number <> 0 Then MsgBox Err.Description
        PictFile_Tb.Value = ""
    End If
ErrHandler:
End Sub

Private Sub PictAlignment_Cb_Change()
    If vEnableEvents Then SkinSettingUpt
End Sub
Private Sub PictSizeMode_Cb_Change()
    If vEnableEvents Then SkinSettingUpt
End Sub
Private Sub PictTiling_Cb_Change()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub ColorBackground1_Lb_Click()
    ColorBackground_Tb.BackColor = PickColor(ColorBackground_Tb.BackColor, Form_hWnd1)
    UserFormStopwatch1.BackColor = ColorBackground_Tb.BackColor
    If vEnableEvents Then SkinSettingUpt
    FormEnableDisCtrls
End Sub
Private Sub ColorBackgroundDft_ChB_Click()
    ColorBackgroundDft_ChB.Value = False
    ColorBackground_Tb.BackColor = &H8000000F
    SkinSettingUpt
    FormEnableDisCtrls
End Sub

Private Sub TranspCtrlPanel_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub TranspDisplay_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub TranspPaper_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub TranspSnapshotLb_ChB_Click()
    If vEnableEvents Then SkinSettingUpt
End Sub

Private Sub UserForm_Activate()
    If ClickOnDisplay_Cb.ListCount > 0 Then Exit Sub    'Rodar uma vez s|fffd|

    With UserFormStopwatch1    'Quarda valores para restaurar se cancelar
        lClickOnDisplay = .lClickOnDisplay
        bEnableBackgrond = .bEnableBackgrond
        lColorBackground = .lColorBackground
        sPictFile = .sPictFile
        lPictAlignment = .lPictAlignment
        lPictSizeMode = .lPictSizeMode
        bPictTiling = .bPictTiling
        bTranspDisplay = .bTranspDisplay
        bTranspCtrlPanel = .bTranspCtrlPanel
        bTranspSnapshotLb = .bTranspSnapshotLb
        bTranspPaper = .bTranspPaper
        bHideTitleBar = .bHideTitleBar
        bAutoHideCtrlPanel = .bAutoHideCtrlPanel
        bAnchActCelStart = .bAnchActCelStart
        bAnchCelAdjWidth = .bAnchCelAdjWidth
        bAnchCelAdjHeight = .bAnchCelAdjHeight
        bUnanchExcelWin = .bUnanchExcelWin
        bAlwaysOnTop = .bAlwaysOnTop
    End With

    Caption = IIf(IsPortg, "Configura|fffd||fffd|es de Face - ", "Skin Settings - ") & UserFormStopwatch1.Caption
    Cancel_Bt.Caption = IIf(IsPortg, "Cancelar", "Cancel")
    Default_Bt.Caption = IIf(IsPortg, "Padr|fffd|o", "Default"): Default_Bt.ControlTipText = IIf(IsPortg, "Restaurar op|fffd||fffd|es padr|fffd|o neste formul|fffd|rio apenas.", "Restore default options on this form only.")

    vEnableEvents = False
    ClickOnDisplay_Lb.Caption = IIf(IsPortg, "Clicando no visor aciona:", "Clicking on display act:")
    With ClickOnDisplay_Cb
        If IsPortg Then
            .AddItem ("Nenhum Bot|fffd|o")
            .AddItem ("Bot|fffd|o Iniciar/Parar")
            .AddItem ("Bot|fffd|o PararIns")
            .AddItem ("Bot|fffd|o Dividir/Instant|fffd|neo")
            .AddItem ("Bot|fffd|o Zerar")
        Else
            .AddItem ("None Button")
            .AddItem ("Start/Stop Button")
            .AddItem ("StopIns Button")
            .AddItem ("Split/Snapshot Button")
            .AddItem ("Reset Button")
        End If
        .ListIndex = lClickOnDisplay
    End With

    EnableBackground_ChB.Caption = IIf(IsPortg, "Habilitar plano de fundo", "Enable background")
    EnableBackground_ChB.Value = bEnableBackgrond
    EnableBackground_ChB_Click

    ColorBackground_Lb.Caption = IIf(IsPortg, "C|fffd|r: ", "Color: ")
    ColorBackgroundDft_ChB.Caption = IIf(IsPortg, "Restaurar c|fffd|r padr|fffd|o", "Restore default color")
    ColorBackground_Tb.BackColor = lColorBackground

    Pict_Fr.Caption = IIf(IsPortg, "Figura: ", "Picture: ")
    PictFile_Lb.Caption = IIf(IsPortg, "Arquivo:", "File:")
    PictFile_Tb.Text = sPictFile

    PictAlignment_Lb.Caption = IIf(IsPortg, "Alinhamento:", "Alignment:")
    With PictAlignment_Cb
        If IsPortg Then
            .AddItem ("Superior esquerda")
            .AddItem ("Superior direita")
            .AddItem ("Centro")
            .AddItem ("Inferior esquerda")
            .AddItem ("Inferior direita")
        Else
            .AddItem ("Top left")
            .AddItem ("Top right")
            .AddItem ("Center")
            .AddItem ("Bottom left")
            .AddItem ("Bottom right")
        End If
        .ListIndex = lPictAlignment
    End With

    PictSizeMode_Lb.Caption = IIf(IsPortg, "Modos de ajuste do tamanho:", "Adjust size mode:")
    With PictSizeMode_Cb
        If IsPortg Then
            .AddItem ("Cortar, se maior")
            .AddItem ("Esticar para encaixar, se menor")
            .AddItem ("Zoom sem cortar ou esticar")
        Else
            .AddItem ("Clip, if larger")
            .AddItem ("Stretch to fit, if smaller")
            .AddItem ("Zoom without clip or stretch")
        End If
        .ListIndex = lPictSizeMode
    End With

    PictTiling_Lb.Caption = IIf(IsPortg, "Atelhar:", "Tiling:")
    With PictTiling_Cb
        If IsPortg Then
            .AddItem ("Falso")
            .AddItem ("Verdadeiro")
        Else
            .AddItem ("False")
            .AddItem ("True")
        End If
        .ListIndex = IIf(bPictTiling, 1, 0)
    End With

    Transp_Fr.Caption = IIf(IsPortg, "Transpar|fffd|ncia dos objetos: ", "Object Transparency: ")
    TranspDisplay_ChB.Caption = IIf(IsPortg, "Visor", "Display")
    TranspCtrlPanel_ChB.Caption = IIf(IsPortg, "Painel de bot|fffd|es", "Panel of buttons")
    TranspSnapshotLb_ChB.Caption = IIf(IsPortg, "Instant|fffd|neos de r|fffd|tulos", "Label snapshots")
    TranspPaper_ChB.Caption = IIf(IsPortg, "Fita de papel", "Paper ribbon")
    HideTitleBar_ChB.Caption = IIf(IsPortg, "Ocultar barra de t|fffd|tulo", "Hide title bar")
    AutoHideCtrlPanel_ChB.Caption = IIf(IsPortg, "Auto-ocultar painel de bot|fffd|es", "Autohide panel of buttons")
    AnchActCelStart_ChB.Caption = IIf(IsPortg, "Ancorar na c|fffd|lula ativa quando iniciou", "Anchor in active cell when started")
    AnchCelAdjHeight_ChB.Caption = IIf(IsPortg, "Ajustar altura e", "Adjust height and")
    AnchCelAdjWidth_ChB.Caption = IIf(IsPortg, "largura |fffd| c|fffd|lula ancorada", "width to anchored cell"): AnchCelAdjWidth_ChB.Left = AnchCelAdjHeight_ChB.Left + AnchCelAdjHeight_ChB.Width - 4.5
    UnanchExcelWin_ChB.Caption = IIf(IsPortg, "Desancorado da Janela do Excel", "Unanchored from Excel Window")
    AlwaysOnTop_ChB.Caption = IIf(IsPortg, "Sempre na Frente", "Always On Top")

    TranspDisplay_ChB.Value = bTranspDisplay
    TranspCtrlPanel_ChB.Value = bTranspCtrlPanel
    TranspSnapshotLb_ChB.Value = bTranspSnapshotLb
    TranspPaper_ChB.Value = bTranspPaper

    HideTitleBar_ChB.Value = bHideTitleBar
    AutoHideCtrlPanel_ChB.Value = bAutoHideCtrlPanel
    AnchActCelStart_ChB.Value = bAnchActCelStart
    AnchCelAdjWidth_ChB.Value = bAnchCelAdjWidth
    AnchCelAdjHeight_ChB.Value = bAnchCelAdjHeight
    UnanchExcelWin_ChB.Value = bUnanchExcelWin
    AlwaysOnTop_ChB.Value = bAlwaysOnTop
    vEnableEvents = True

    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")
    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
    Email_Lb.Left = Width / Twips - Email_Lb.Width - (Width / Twips - InsideWidth) - 4    'Email_Lb.Left = Width / Twips - Email_Lb.Width - 8

    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel. Depois da op|fffd||fffd|o bUnanchExcelWin sempre no form que chamou OnTop se
    SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, UserFormStopwatch1.Form_hWnd: If UserFormStopwatch1.bAlwaysOnTop Then SetWindowPos Form_hWnd1, HWND_TOPMOST, 0, 0, 0, 0, flags    'If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, UserFormStopwatch1.Form_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
End Sub

Private Sub Ok_Bt_Click()
'Consolidar variav e salvar
    SkinSettingUpt
    UserFormStopwatch1.WriteINISetting1
    Set UserFormStopwatch1.UserFormSkin1 = Nothing
    Unload Me
End Sub

Private Sub Cancel_Bt_Click()
    With UserFormStopwatch1    'Restaurando
        .lClickOnDisplay = lClickOnDisplay
        .bEnableBackgrond = bEnableBackgrond
        .lColorBackground = lColorBackground
        .sPictFile = sPictFile
        .lPictAlignment = lPictAlignment
        .lPictSizeMode = lPictSizeMode
        .bPictTiling = bPictTiling
        .bTranspDisplay = bTranspDisplay
        .bTranspCtrlPanel = bTranspCtrlPanel
        .bTranspSnapshotLb = bTranspSnapshotLb
        .bTranspPaper = bTranspPaper
        .bHideTitleBar = bHideTitleBar
        .bAutoHideCtrlPanel = bAutoHideCtrlPanel
        .bAnchActCelStart = bAnchActCelStart
        .bAnchCelAdjWidth = bAnchCelAdjWidth
        .bAnchCelAdjHeight = bAnchCelAdjHeight
        .bUnanchExcelWin = bUnanchExcelWin
        .bAlwaysOnTop = bAlwaysOnTop
        .SkinSettingUpt
        .bUserNoteUpd = False    'Para atualizar form size no pr|fffd|ximo loop.
    End With
    Set UserFormStopwatch1.UserFormSkin1 = Nothing
    Unload Me
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then
        'Cancel = True
        Cancel_Bt_Click
    End If
End Sub

Private Sub SkinSettingUpt()
    With UserFormStopwatch1
        .lClickOnDisplay = ClickOnDisplay_Cb.ListIndex
        .bEnableBackgrond = EnableBackground_ChB.Value
        .lColorBackground = ColorBackground_Tb.BackColor
        .sPictFile = PictFile_Tb.Text
        .lPictAlignment = PictAlignment_Cb.ListIndex
        .lPictSizeMode = PictSizeMode_Cb.ListIndex
        .bPictTiling = PictTiling_Cb.ListIndex = 1
        .bTranspDisplay = TranspDisplay_ChB.Value
        .bTranspCtrlPanel = TranspCtrlPanel_ChB.Value
        .bTranspSnapshotLb = TranspSnapshotLb_ChB.Value
        .bTranspPaper = TranspPaper_ChB.Value
        .bHideTitleBar = HideTitleBar_ChB.Value
        .bAutoHideCtrlPanel = AutoHideCtrlPanel_ChB.Value
        .bAnchActCelStart = AnchActCelStart_ChB.Value
        .bAnchCelAdjWidth = AnchCelAdjWidth_ChB.Value
        .bAnchCelAdjHeight = AnchCelAdjHeight_ChB.Value
        .bUnanchExcelWin = UnanchExcelWin_ChB.Value
        .bAlwaysOnTop = AlwaysOnTop_ChB.Value
        .SkinSettingUpt
    End With
End Sub

Private Sub FormEnableDisCtrls()
'Enable/disable controles
    ColorBackground_Lb.Enabled = EnableBackground_ChB.Value
    ColorBackground_Tb.Enabled = EnableBackground_ChB.Value
    ColorBackground1_Lb.Enabled = EnableBackground_ChB.Value
    ColorBackgroundDft_ChB.Enabled = EnableBackground_ChB.Value And ColorBackground_Tb.BackColor <> &H8000000F
    Dim lCtrl
    For Each lCtrl In Pict_Fr.Controls
        lCtrl.Enabled = EnableBackground_ChB.Value
    Next
    PictAlignment_Cb.Enabled = EnableBackground_ChB.Value And PictFile_Tb.Text <> ""
    PictSizeMode_Cb.Enabled = PictAlignment_Cb.Enabled
    PictTiling_Cb.Enabled = PictAlignment_Cb.Enabled

    'Embora a transp. possa ficar independente do background, preferi n|fffd|o, mas basta comentar as linhas abaixo
    'e rever bEnableBackgrond And ... em SkinSettingUpt
    TranspDisplay_ChB.Enabled = EnableBackground_ChB.Value
    TranspCtrlPanel_ChB.Enabled = EnableBackground_ChB.Value
    TranspSnapshotLb_ChB.Enabled = EnableBackground_ChB.Value
    TranspPaper_ChB.Enabled = EnableBackground_ChB.Value

    AnchCelAdjWidth_ChB.Enabled = AnchActCelStart_ChB.Value And AutoHideCtrlPanel_ChB.Value And HideTitleBar_ChB.Value
    AnchCelAdjHeight_ChB.Enabled = AnchActCelStart_ChB.Value And AutoHideCtrlPanel_ChB.Value And HideTitleBar_ChB.Value
End Sub

Private Sub Default_Bt_Click()
    vEnableEvents = False

    ClickOnDisplay_Cb.ListIndex = 0
    EnableBackground_ChB.Value = False
    ColorBackground_Tb.BackColor = -2147483633
    PictFile_Tb.Text = ""
    PictAlignment_Cb.ListIndex = 2
    PictSizeMode_Cb.ListIndex = 0
    PictTiling_Cb.ListIndex = 0
    TranspDisplay_ChB.Value = False
    TranspCtrlPanel_ChB.Value = False
    TranspSnapshotLb_ChB.Value = False
    TranspPaper_ChB.Value = False
    HideTitleBar_ChB.Value = True
    AutoHideCtrlPanel_ChB.Value = False
    AnchActCelStart_ChB.Value = False
    AnchCelAdjWidth_ChB.Value = False
    AnchCelAdjHeight_ChB.Value = False
    UnanchExcelWin_ChB.Value = False
    AlwaysOnTop_ChB.Value = False

    vEnableEvents = True
    SkinSettingUpt
    FormEnableDisCtrls

End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Attribute VB_Name = "UserFormSound"
Attribute VB_Base = "0{27BEA362-2D52-4797-95D1-9C8087478C2E}{DD16011B-5D30-404A-80AF-19F495E28589}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim EmailSubj As String
Dim HomePageUrl As String
Public UserFormStopwatch1 As UserFormStopwatch
Dim Form_hWnd1 As Long
Public lRetIdx As Long

Private Sub AtEventWAV_Lb_Click()
    Dim vFileName
    Static ChDirOne As Boolean
    If ChDirOne = False And (AtEventWAV_Tb.Value = "" Or Dir(AtEventWAV_Tb.Value) = "") Then
        If Mid(ThisDLLPath, 2, 1) = ":" Then ChDrive ThisDLLPath
        ChDir ThisDLLPath
        ChDirOne = True
    Else
        If AtEventWAV_Tb.Value <> "" And Dir(AtEventWAV_Tb.Value) <> "" Then
            vFileName = Left(AtEventWAV_Tb.Value, InStrRev(AtEventWAV_Tb.Value, appHostApp.PathSeparator))
            If Mid(vFileName, 2, 1) = ":" Then ChDrive vFileName
            ChDir vFileName
        End If
    End If
    If IsPortg Then
        vFileName = appHostApp.GetOpenFilename("Sons (*.wav),*.wav,Todos (*.*),*.*", , "Selecionar WAV")
    Else
        vFileName = appHostApp.GetOpenFilename("Sounds (*.wav),*.wav,All Files (*.*),*.*", , "Select WAV")
    End If
    SetForegroundWindow Form_hWnd1    'Necess|fffd|rio depois da op|fffd||fffd|o bUnanchExcelWin.
    If vFileName = False Then Exit Sub
    AtEventWAV_Tb.Value = vFileName
    AtEvent_ChB.Value = True
End Sub

Private Sub UserForm_Activate()
    If Form_hWnd1 <> 0 Then Exit Sub    'Para rodar uma |fffd|nica vez. Necess|fffd|rio depois da op|fffd||fffd|o bUnanchExcelWin.
    With UserFormStopwatch1
        Select Case lRetIdx
        Case 1
            Caption = IIf(IsPortg, "Ao Iniciar", "At Start")
            AtEvent_ChB.Value = .bSndAtStart
            AtEventWAV_Tb.Value = .sWavSndAtStart
        Case 2
            Caption = IIf(IsPortg, "Ao Parar", "At Stop")
            AtEvent_ChB.Value = .bSndAtStop
            AtEventWAV_Tb.Value = .sWavSndAtStop
        Case 3
            Caption = IIf(IsPortg, "Ao Reiniciar", "At Restart")
            AtEvent_ChB.Value = .bSndAtRestart
            AtEventWAV_Tb.Value = .sWavSndAtRestart
        Case 4
            Caption = IIf(IsPortg, "Ao PararIns", "At StopIns")
            AtEvent_ChB.Value = .bSndAtStopIns
            AtEventWAV_Tb.Value = .sWavSndAtStopIns
        Case 5
            Caption = IIf(IsPortg, "Ao Instant|fffd|neo", "At Snapshot")
            AtEvent_ChB.Value = .bSndAtSnapshot
            AtEventWAV_Tb.Value = .sWavSndAtSnapshot
        Case 6
            Caption = IIf(IsPortg, "Ao Zerar", "At Reset")
            AtEvent_ChB.Value = .bSndAtReset
            AtEventWAV_Tb.Value = .sWavSndAtReset
        Case Is > 10
            Caption = IIf(IsPortg, "Ao Instant|fffd|neo", "At Snapshot") & lRetIdx - 10
            AtEvent_ChB.Value = .arrbSndAtSnpshtLbGet(lRetIdx - 10)
            AtEventWAV_Tb.Value = .arrsWavSndAtSnpshtLbGet(lRetIdx - 10)
        End Select
        .WriteINISetting1
    End With
    Caption = Caption & IIf(IsPortg, " - Habilitar/Desabilitar Som e Definir Arquivo WAV a Tocar", " - Enable/Disable Sound and Set WAV File to Play")
    Cancel_Bt.Caption = IIf(IsPortg, "Cancelar", "Cancel")
    Play_Bt.Caption = IIf(IsPortg, "Toque Teste", "Play Test")
    Play_Lb.Caption = IIf(IsPortg, "Arquivo:", "WAV File:")
    Top = UserFormStopwatch1.Top + 10 * Twips
    Left = UserFormStopwatch1.Left + 10 * Twips

    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")
    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
    Email_Lb.Left = Width / Twips - Email_Lb.Width - (Width / Twips - InsideWidth) - 4    'Email_Lb.Left = Width / Twips - Email_Lb.Width - 8

    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel. Depois da op|fffd||fffd|o bUnanchExcelWin sempre no form que chamou OnTop se
    SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, UserFormStopwatch1.Form_hWnd: If UserFormStopwatch1.bAlwaysOnTop Then SetWindowPos Form_hWnd1, HWND_TOPMOST, 0, 0, 0, 0, flags    'If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, UserFormStopwatch1.Form_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
End Sub


Private Sub Ok_Bt_Click()
    With UserFormStopwatch1
        Select Case lRetIdx
        Case 1
            .bSndAtStart = AtEvent_ChB.Value
            .sWavSndAtStart = AtEventWAV_Tb.Value
        Case 2
            .bSndAtStop = AtEvent_ChB.Value
            .sWavSndAtStop = AtEventWAV_Tb.Value
        Case 3
            .bSndAtRestart = AtEvent_ChB.Value
            .sWavSndAtRestart = AtEventWAV_Tb.Value
        Case 4
            .bSndAtStopIns = AtEvent_ChB.Value
            .sWavSndAtStopIns = AtEventWAV_Tb.Value
        Case 5
            .bSndAtSnapshot = AtEvent_ChB.Value
            .sWavSndAtSnapshot = AtEventWAV_Tb.Value
        Case 6
            .bSndAtReset = AtEvent_ChB.Value
            .sWavSndAtReset = AtEventWAV_Tb.Value
        Case Is > 10
            .arrbSndAtSnpshtLbLet(lRetIdx - 10) = AtEvent_ChB.Value
            .arrsWavSndAtSnpshtLbLet(lRetIdx - 10) = AtEventWAV_Tb.Value
        End Select
        .WriteINISetting1
    End With
    Cancel_Bt_Click
End Sub

Private Sub Cancel_Bt_Click()
    Set UserFormStopwatch1.UserFormSound1 = Nothing
    Unload Me
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then
        'Cancel = True
        Cancel_Bt_Click
    End If
End Sub

Private Sub Play_Bt_Click()
    If Dir(AtEventWAV_Tb.Value) = "" Then
        Msg1 = IIf(IsPortg, "O arquivo '" & AtEventWAV_Tb.Value & "' n|fffd|o foi encontrado!", _
                   "The file '" & AtEventWAV_Tb.Value & "' wasn't found!")
        Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Falha!", " - Fail!")
        MyMsgBox Msg1, 1, Msg2, , Left / Twips - 95, Top / Twips - 15, Form_hWnd1, , UserFormStopwatch1.bAlwaysOnTop
    Else
        Call sndPlaySound32(AtEventWAV_Tb.Value, &H0 + &H2)
    End If
End Sub

Private Sub AtEventWAV_Tb_Change()
    Play_Bt.Enabled = Len(AtEventWAV_Tb.Value) > 0
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Attribute VB_Name = "UserFormStopwatch"
Attribute VB_Base = "0{7C5FCA19-DE08-4FB3-8763-9CF9E0C6447D}{B6809F7B-D769-4234-9D3E-983F78DA1BA9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim Xini, LeftIni As Single
Dim Yini, TopIni As Single
Dim sIgnClickIfDrag As String
Dim vEnableEvents As Boolean
Dim TeclaEnter As Boolean
Dim DadosTransf As DataObject
Dim FitaPapel() As String
Dim PosPapel As Long
Dim IgnoreTbVisorFnd_KeyUp As Boolean
Public Form_hWnd As Long
Public App_hWnd1 As Long                                   'Guardar App_hWnd para restaurar, pois ele pode ser alterado por inst|fffd|ncia em outra janela no PowerPoint, Word e no Excel 2013 quando fiz o updadte alterando cada linha e t|fffd|o somente onde aparece App_hWnd1.
Dim rngUserNoteLast As Range
Dim bNotExitFromTb As Boolean    'Para n|fffd|o sair de um textbox ao digitar uma hotkey no mesmo

Dim OrigFormWidth As Double
Dim OrigFormHeight As Double
Dim dFormBorderWeight As Double
Dim dFormTitleHeight As Double
Dim lastFormHeight As Double
Dim lastFormWidth As Double

'Private WithEvents Timer1 As CTimer
Public lBotPress As Long
Public dbElapsed As Double    'aka sgElapsed as Single mas havia perda ao capturar com mais de duas decimais
Public dbStart As Double: Public lTickCountMultFix As Long: Public lTickCountDownFix As Long: Public dTimeDownFix As Date: Dim lStartTickCount As Long

Dim vModal As Long
Dim bPopupFormatSel As Boolean
Dim bPopupSel As Boolean
Dim HotKey As String
Dim lShortMenuPos As Long
Dim lToolbarPos As Long
Dim bResetAtPopup As Boolean
Dim bStartAtPopup As Boolean
Dim bSplitAtPopup As Boolean
Dim bSplitInBkGrAtPopup As Boolean
Dim bPaperRibbon As Boolean   'Exibindo Papel
Dim bPopupAtLastPos As Boolean
Dim dLastPosTop As Double
Dim dLastPosLeft As Double

Dim lMode As Long
Dim lNumDecim As Long
Dim lDispSize As Double
Dim lCtrlPanelSize As Long
Public lStopInsMode As Long, lInsOvrCnts As Long, lInsAlsoDTime As Long, lOtherButtsMode As Long, lCellAsButTriggSlc As Long, lEchoDisplayInCell As Long: Dim bEchoDisplayInCellAndHide As Boolean: Dim sEchoLastDisplay As String 'StopIns button modes, Cell as button trigger selecting cells options, echo options.
Public lResetMode As Long   'Reset button modes
Public bInsActCelStart As Boolean    'Insere na c|fffd|lula que estava ativa ao iniciar
Public rngActCelStart As Range
Public ActShAtPopup As Worksheet    'Planilha ativa ao iniciar

Dim bUserNoteLast As Boolean
Dim lSnapshotNumb As Long
Dim arrBackColor(10) As Long    'Background colors
Dim arrForeColor(10) As Long    'Foreground colors
Dim arrSnpshtLb(10) As String    'Snapshot labels

Public UserFormCntDown1 As UserFormCntDown
Public bCntDown As Boolean
Public dbElapsedCurr As Double    'Estoca para reiniciar depois do countdown
Public dbCDElapsed As Double    'Estoca e calculado para um recountdown.
Public lCDHour As Long
Public lCDMin As Long
Public lCDSec As Long
Public lCDSecFract As String    'Como text para validar qualquer fra|fffd||fffd|o de segundo iniciada com 0
Public bCDtoDTime As Boolean
Public dbCDtoDTime As Double
Public bCDBeep As Boolean
Public lCDBeep As Long
Public bCDQuit As Boolean
Public bCDWav As Boolean
Public sCDFileWav As String
Public bCDRun As Boolean
Public sCDFileRun As String
Public bCDAlert As Boolean
Public sCDTxtAlert As String
Public bCDStart As Boolean
Public bCDSpeak As Boolean
Public lCDSpeak As Long
Public bCDRestart As Boolean
Public bCDReCntdown As Boolean


Public bMultStartAttach As Boolean
Public bMultStopAttach As Boolean
Public bMultRestartAttach As Boolean
Public bMultResetAttach As Boolean
Public bMultStopInsAttach As Boolean
Public bMultStartStopsAttach As Boolean
Public bMultRestartStopsAttach As Boolean
Public bMultStartStopInssAttach As Boolean
Public bMultRestartStopInssAttach As Boolean

Public UserFormSound1 As UserFormSound
Public bSndDisableAll As Boolean
Public bSndAtStart As Boolean
Public bSndAtStop As Boolean
Public bSndAtRestart As Boolean
Public bSndAtStopIns As Boolean
Public bSndAtSnapshot As Boolean
Public bSndAtReset As Boolean
Dim arrbSndAtSnpshtLb(10) As Boolean    'Snapshot labels
Public sWavSndAtStart As String
Public sWavSndAtStop As String
Public sWavSndAtRestart As String
Public sWavSndAtStopIns As String
Public sWavSndAtSnapshot As String
Public sWavSndAtReset As String
Dim arrsWavSndAtSnpshtLb(10) As String    'Snapshot labels

Public UserFormSkin1 As UserFormSkin
Public lClickOnDisplay As Long    '0 a 4 dft 0
Public bEnableBackgrond As Boolean
Public lColorBackground As Long
Public sPictFile As String
Public lPictAlignment As Long    '0 a 4 dft 2
Public lPictSizeMode As Long    '0 a 3 dft 0 sem 2
Public bPictTiling As Boolean
Public bTranspDisplay As Boolean    'dft true
Public bTranspCtrlPanel As Boolean
Public bTranspSnapshotLb As Boolean
Public bTranspPaper As Boolean
Public bHideTitleBar As Boolean
Public bAutoHideCtrlPanel As Boolean: Dim bAutoHideCtrlPanelOn As Boolean    'Este |fffd|ltimo funciona como uma chave que desliga com CtrlPanelShow_Lb e autoliga quando mouse estiver sobre o form ou se aproximando.
Public bAnchActCelStart As Boolean
Public bAnchCelAdjWidth As Boolean: Dim bAnchCelAdjWidthOffTmp    'Este |fffd|ltimo desliga o primeiro s|fffd| na inst|fffd|ncia evitando ecoar para outras sendo criadas.
Public bAnchCelAdjHeight As Boolean
Public bUnanchExcelWin As Boolean
Public bAlwaysOnTop As Boolean

Public bSplit As Boolean
Public wbSplit As Workbook
Public shSplit As Worksheet
Public sSplitStartCellRef As String    'ref
Public bActSplitShAtSplit As Boolean    'Mantem a planilha de split ativada ao dividir
Public bUserNoteUpd As Boolean    'Al|fffd|m de UserNote, tamb|fffd|m |fffd| usado como flag para provocar necessidade de update em FormAdjust.
Public lActSnapshotTb As Long

Public bCallBYfStopwatch As Boolean
Public bFromAutoPopCell As Boolean
Public lWaitAndRetValue As Long    '0 - N|fffd|o ret. valor, unassincrono, modeless, old bReleasedModeless; 1 - Ret. valor em modeless; 2 - Ret. valor em modal
Public sCountInstAdd As String

'Esses property s|fffd|o necess|fffd|rios porque arrays n|fffd|o podem ser p|fffd|blico em classs module
Property Get arrbSndAtSnpshtLbGet(lRetIdx As Long) As Boolean
    arrbSndAtSnpshtLbGet = arrbSndAtSnpshtLb(lRetIdx)
End Property
Property Let arrbSndAtSnpshtLbLet(lRetIdx As Long, bRet As Boolean)
    arrbSndAtSnpshtLb(lRetIdx) = bRet
End Property
Property Get arrsWavSndAtSnpshtLbGet(lRetIdx As Long) As String
    arrsWavSndAtSnpshtLbGet = arrsWavSndAtSnpshtLb(lRetIdx)
End Property
Property Let arrsWavSndAtSnpshtLbLet(lRetIdx As Long, sRet As String)
    arrsWavSndAtSnpshtLb(lRetIdx) = sRet
End Property

Private Sub LbCntDown_Click()
    If Not UserFormCntDown1 Is Nothing Then Exit Sub
    Set UserFormCntDown1 = New UserFormCntDown
    Set UserFormCntDown1.UserFormStopwatch1 = Me
    UserFormCntDown1.Caption = IIf(IsPortg, "Contagem Regressiva", "Countdown") & IIf(sCountInstAdd = "1", "", sCountInstAdd) & IIf(IsPortg, " para Excel", " for Excel")
    UserFormCntDown1.Show vModal
End Sub

Private Sub Menu_Lb_Click()
    If sIgnClickIfDrag = Menu_Lb.Name Then   'Ignorar click se houver arrasto do form por este controle
        sIgnClickIfDrag = ""
        Exit Sub
    End If

    App_hWnd = App_hWnd1
    'BannerCount_Lb.Visible = False: BannerCountR_Lb.Visible = False
    If Not bUsarOnTimeAPI And vModal = 1 Then
        'Sem ontime o menu n|fffd|o funciona em modal ent|fffd|o exib logo about
        PopMenuOpt = 20
        Menu_Lb_ClickCont
        Exit Sub
    End If

    WriteINISetting1    'Alinha cfgini com a inst|fffd|ncia do menu acionado
    'CopyToClipboard True: PasteFromClipboard True  'Get info to copy and paste command
    Dim bAppMinimized As Boolean
    PopMenuOpt = 0
    Select Case appHostApp.Name
    Case "Microsoft Excel", "Microsoft PowerPoint", "Microsoft Access"
        PopMenu bFromAutoPopCell, Form_hWnd, bAppMinimized
    Case "Microsoft Word"
        Dim bNormSvd As Boolean
        bNormSvd = appHostApp.NormalTemplate.Saved
        PopMenu bFromAutoPopCell, Form_hWnd, bAppMinimized
        appHostApp.NormalTemplate.Saved = bNormSvd
    End Select
    If bUsarOnTimeAPI Then
        If PopMenuOpt <> 0 Then OnTimeAPI 0.1, "Menu_Lb_ClickCont"    '|fffd| necess|fffd|rio porque algumas a|fffd||fffd|es fecham, mas como o menu est|fffd| travado acaba o Word ficando oculto ao fechar.
    Else
        If CollectionInst.Count < 100 Then MyWait 0.1    'Mensagens de alerta via menu v|fffd|o custando a aparecer at|fffd| deixam de aparecem a partir de 150 inst|fffd|ncias. 100 |fffd| a razo|fffd|vel.
        Menu_Lb_ClickCont
        If bAppMinimized Then ShowWindow App_hWnd, SW_SHOWMINIMIZED
    End If
End Sub

Public Sub Menu_Lb_ClickCont()
    Select Case PopMenuOpt
    Case 0
        Exit Sub
    Case 1   'Modal
        If dHostAppVer > 8 Then
            If vModal = 1 Then vModal = 0 Else vModal = 1
            vModalChange = True
            Hide
            WriteINISetting1
        Else
            MyMsgBox IIf(IsPortg, "Excel 97 n|fffd|o suporta Cron|fffd|metro n|fffd|o modal!", "Excel 97 doesn't suport modeless Stopwatch!"), 1, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop
        End If

    Case 2   'Reset at Popup
        bResetAtPopup = Not bResetAtPopup
        WriteINISetting1
    Case 3   'Start at Popup
        bStartAtPopup = Not bStartAtPopup
        WriteINISetting1
    Case 4   'Split at Popup
        bSplitAtPopup = Not bSplitAtPopup
        If bSplitAtPopup And bSplitInBkGrAtPopup Then bSplitInBkGrAtPopup = False
        WriteINISetting1
    Case 5   'Split at Popup
        bSplitInBkGrAtPopup = Not bSplitInBkGrAtPopup
        If bSplitAtPopup And bSplitInBkGrAtPopup Then bSplitAtPopup = False
        WriteINISetting1
    Case 51   'Popup at last position
        bPopupAtLastPos = Not bPopupAtLastPos
        WriteINISetting1
    Case 6   'Stop, Insert, and Close 'LbStopIns button behaviour
        lStopInsMode = 1
        LbStopInsUpt
        WriteINISetting1
    Case 61   'Stop, Insert, and Reset
        lStopInsMode = 2
        LbStopInsUpt
        WriteINISetting1
    Case 62   'Stop, Insert, Reset, and Start
        lStopInsMode = 3
        LbStopInsUpt
        WriteINISetting1
    Case 7   'Stop and Insert
        lStopInsMode = 4
        LbStopInsUpt
        WriteINISetting1
    Case 8   'Insert
        lStopInsMode = 5
        LbStopInsUpt
        WriteINISetting1
    Case 9   'Disable
        lStopInsMode = 6
        LbStopInsUpt
        WriteINISetting1

    Case 900
        bInsActCelStart = Not bInsActCelStart
        WriteINISetting1

    Case 9001   'Overwrite
        lInsOvrCnts = 1
        WriteINISetting1
    Case 9002   'Not insert
        lInsOvrCnts = 2
        WriteINISetting1
    Case 9003   'Next empty down
        lInsOvrCnts = 3
        WriteINISetting1
    Case 9004
        lInsOvrCnts = 4
        WriteINISetting1
    Case 9005
        lInsOvrCnts = 5
        WriteINISetting1
    Case 9006
        lInsOvrCnts = 6
        WriteINISetting1

    Case 90001   'Not insert
        lInsAlsoDTime = 1
        WriteINISetting1
    Case 90002   'Insert as comm
        lInsAlsoDTime = 2
        WriteINISetting1
    Case 90003
        lInsAlsoDTime = 3
        WriteINISetting1
    Case 90004
        lInsAlsoDTime = 4
        WriteINISetting1
    Case 90005
        lInsAlsoDTime = 5
        WriteINISetting1
    Case 90006
        lInsAlsoDTime = 6
        WriteINISetting1

    Case 91   'Reset 'LbReset button behaviour
        lResetMode = 1
        LbSetUpt
        WriteINISetting1
    Case 92   'Reset and Start
        lResetMode = 2
        LbSetUpt
        WriteINISetting1
    Case 93   'Insert, Reset, and Start
        lResetMode = 3
        LbSetUpt
        WriteINISetting1
    Case 94   'Disable
        lResetMode = 4
        LbSetUpt
        WriteINISetting1


    Case 941
        If (lOtherButtsMode And 1) = 1 Then lOtherButtsMode = lOtherButtsMode And (Not 1) Else lOtherButtsMode = lOtherButtsMode Or 1  'Bitwise bit flag 1 ...
        LbOtherButtsUpt
        WriteINISetting1
    Case 942
        If (lOtherButtsMode And 2) = 2 Then lOtherButtsMode = lOtherButtsMode And (Not 2) Else lOtherButtsMode = lOtherButtsMode Or 2  'Bitwise bit flag 2 ...
        LbOtherButtsUpt
        WriteINISetting1
    Case 943
        If (lOtherButtsMode And 4) = 4 Then lOtherButtsMode = lOtherButtsMode And (Not 4) Else lOtherButtsMode = lOtherButtsMode Or 4
        LbOtherButtsUpt
        WriteINISetting1
    Case 944
        If (lOtherButtsMode And 8) = 8 Then lOtherButtsMode = lOtherButtsMode And (Not 8) Else lOtherButtsMode = lOtherButtsMode Or 8
        LbOtherButtsUpt
        WriteINISetting1
    Case 945
        If (lOtherButtsMode And 16) = 16 Then lOtherButtsMode = lOtherButtsMode And (Not 16) Else lOtherButtsMode = lOtherButtsMode Or 16
        LbOtherButtsUpt
        WriteINISetting1
    Case 946
        If (lOtherButtsMode And 32) = 32 Then lOtherButtsMode = lOtherButtsMode And (Not 32) Else lOtherButtsMode = lOtherButtsMode Or 32
        LbOtherButtsUpt
        WriteINISetting1
    Case 947
        If Not (lOtherButtsMode And 64) = 64 Then If MyMsgBox(IIf(IsPortg, "Se voc|fffd| desabilitar o bot|fffd|o Exibir Painel de Bot|fffd|es(ep) juntamente com a op|fffd||fffd|o Auto-ocultar painel de bot|fffd|es, o menu s|fffd| ser|fffd| acess|fffd|vel clicando o visor com o bot|fffd|o direito do mouse. Ok?", "If you disable Show Panel of Buttons (sp) button together with Autohide panel of buttons option, the menu will only be accessible right-clicking the display. OK?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2 Then Exit Sub
        If (lOtherButtsMode And 64) = 64 Then lOtherButtsMode = lOtherButtsMode And (Not 64) Else lOtherButtsMode = lOtherButtsMode Or 64
        LbOtherButtsUpt
        WriteINISetting1
    Case 948
        If lOtherButtsMode > 0 Then lOtherButtsMode = 0 Else lOtherButtsMode = (1 Or 2 Or 4 Or 8 Or 16 Or 32)
        LbOtherButtsUpt
        WriteINISetting1


    Case 9401   'Trigger selecting cells.
        If (lCellAsButTriggSlc And 1) = 1 Then    'Sobre Bitwise Operators In VB ver ref. no XLtoEXE, mas resumindo: Os bits em um Long s|fffd|o pot|fffd|ncias de 2 (1 2 4 8...). Operando entre Longs, o Or |fffd| uni|fffd|o retornando soma, o And |fffd| interse|fffd||fffd|o retornando pot|fffd|ncias comuns. O Not is a unary operator que inverte bit a bit e junto com And subtrai se existir, por exemplo: 7 And (Not 2) = 5, pois 7 |fffd| 1+2+4, tirando o 2 fica 5.
            lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 1)
        Else
            lCellAsButTriggSlc = lCellAsButTriggSlc Or 1   'Bitwise bit flag 1
            'lStopInsMode = 5: LbStopInsUpt: bInsActCelStart = False    'Ao habilitar |fffd| aconselh|fffd|vel configurar s|fffd| para inserir e na c|fffd|lula ativa que |fffd| a cfg mais prov|fffd|vel.
            lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 64) And (Not 128) And (Not 256) And (Not 512) And (Not 1024)
            lCellAsButTriggSlc = lCellAsButTriggSlc Or 1024
            lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 2048) And (Not 4096)
            lCellAsButTriggSlc = lCellAsButTriggSlc Or 2048

        End If
        WriteINISetting1
    Case 9402
        If (lCellAsButTriggSlc And 2) = 2 Then lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 2) Else lCellAsButTriggSlc = lCellAsButTriggSlc Or 2  'Bitwise bit flag 2 ...
        WriteINISetting1
    Case 9403
        If (lCellAsButTriggSlc And 4) = 4 Then lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 4) Else lCellAsButTriggSlc = lCellAsButTriggSlc Or 4
        WriteINISetting1
    Case 9404
        If (lCellAsButTriggSlc And 8) = 8 Then lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 8) Else lCellAsButTriggSlc = lCellAsButTriggSlc Or 8
        WriteINISetting1
    Case 9405
        If (lCellAsButTriggSlc And 16) = 16 Then lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 16) Else lCellAsButTriggSlc = lCellAsButTriggSlc Or 16
        WriteINISetting1
    Case 9406
        If (lCellAsButTriggSlc And 32) = 32 Then lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 32) Else lCellAsButTriggSlc = lCellAsButTriggSlc Or 32
        WriteINISetting1
    Case 9407
        lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 64) And (Not 128) And (Not 256) And (Not 512) And (Not 1024)
        lCellAsButTriggSlc = lCellAsButTriggSlc Or 64
        WriteINISetting1
    Case 9408
        lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 64) And (Not 128) And (Not 256) And (Not 512) And (Not 1024)
        lCellAsButTriggSlc = lCellAsButTriggSlc Or 128
        WriteINISetting1
    Case 9409
        lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 64) And (Not 128) And (Not 256) And (Not 512) And (Not 1024)
        lCellAsButTriggSlc = lCellAsButTriggSlc Or 256
        WriteINISetting1
    Case 9410
        lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 64) And (Not 128) And (Not 256) And (Not 512) And (Not 1024)
        lCellAsButTriggSlc = lCellAsButTriggSlc Or 512
        WriteINISetting1
    Case 9411
        lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 64) And (Not 128) And (Not 256) And (Not 512) And (Not 1024)
        lCellAsButTriggSlc = lCellAsButTriggSlc Or 1024
        WriteINISetting1
    Case 94012
        lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 2048) And (Not 4096)
        lCellAsButTriggSlc = lCellAsButTriggSlc Or 2048
        WriteINISetting1
    Case 94013
        lCellAsButTriggSlc = lCellAsButTriggSlc And (Not 2048) And (Not 4096)
        lCellAsButTriggSlc = lCellAsButTriggSlc Or 4096
        WriteINISetting1

    Case 94001   'Echo in Active Cell When Started.
        If (lEchoDisplayInCell And 1) = 1 Then    'Sobre Bitwise Operators In VB ver ref. no XLtoEXE, mas resumindo: Os bits em um Long s|fffd|o pot|fffd|ncias de 2 (1 2 4 8...). Operando entre Longs, o Or |fffd| uni|fffd|o retornando soma, o And |fffd| interse|fffd||fffd|o retornando pot|fffd|ncias comuns. O Not is a unary operator que inverte bit a bit e junto com And subtrai se existir, por exemplo: 7 And (Not 2) = 5, pois 7 |fffd| 1+2+4, tirando o 2 fica 5.
            lEchoDisplayInCell = lEchoDisplayInCell And (Not 1)
        Else
            lEchoDisplayInCell = lEchoDisplayInCell Or 1   'Bitwise bit flag 1
        End If
        WriteINISetting1
    Case 94002
        If (lEchoDisplayInCell And 2) = 2 Then lEchoDisplayInCell = lEchoDisplayInCell And (Not 2) Else lEchoDisplayInCell = lEchoDisplayInCell Or 2  'Bitwise bit flag 2 ...
        WriteINISetting1
    Case 94003
        If (lEchoDisplayInCell And 4) = 4 Then lEchoDisplayInCell = lEchoDisplayInCell And (Not 4) Else lEchoDisplayInCell = lEchoDisplayInCell Or 4
        WriteINISetting1


    Case 10   'To Popup when selection
        bPopupSel = Not bPopupSel
        '        If bPopupSel Then
        '            Set EventApp.App = Application
        '        Else
        '            Set EventApp.App = Nothing
        '        End If
        WriteINISetting1
    Case 11   'Define Poupup Cell
        Dim n As Name
        Dim Rng As Range
        Dim sName As String
        Dim i As Long
        If appHostApp.ActiveWindow.ActiveSheet.ProtectContents Then
            MyMsgBox IIf(IsPortg, "Imposs|fffd|vel definir nomes de c|fffd|lulas em uma planilha protegida!", "It's impossible to define cell names on protected sheet!"), 1, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop
        Else
            For Each n In appHostApp.ActiveWorkbook.Names
                If Left(LCase(n.Name), Len("PopupStopwatch")) = LCase("PopupStopwatch") Then
                    On Error Resume Next
                    Set Rng = appHostApp.Intersect(appHostApp.Selection, n.RefersToRange)
                    If Err.Number = 0 And Not Rng Is Nothing Then
                        sName = n.Name
                        Set Rng = n.RefersToRange
                        Exit For
                    End If
                End If
            Next
            If Rng Is Nothing Then Set Rng = appHostApp.Selection
            On Error GoTo 0
            If sName <> "" Then
                Dim ActSel As Range
                Set ActSel = appHostApp.Selection
                Rng.Select
                If MyMsgBox(IIf(IsPortg, "Remover a defini|fffd||fffd|o de popup de c|fffd|lulas em " & Rng.Address & "?", "Remove popup definition of cells on " & Rng.Address & "?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
                    n.Delete
                End If
                ActSel.Select
                Set ActSel = Nothing
            Else
                If MyMsgBox(IIf(IsPortg, "Definir as c|fffd|lulas em " & Rng.Address & " para Popup ao selecionar?", "Define cells on " & Rng.Address & " to Popup when selecting?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
                    Do While sName = ""
                        i = i + 1
                        sName = "PopupStopwatch" & i
                        For Each n In appHostApp.ActiveWorkbook.Names
                            If n.Name = "PopupStopwatch" & i Then sName = ""
                        Next
                    Loop
                    Rng.Name = sName
                End If
            End If
        End If
        Set Rng = Nothing

    Case 12   'Format defines Popup
        bPopupFormatSel = Not bPopupFormatSel
        WriteINISetting1

    Case 130   'Sem Short Menu
        If lShortMenuPos <> 0 Then
            lShortMenuPos = 0: WriteINISetting1
            ShortMenuPos 0
            If dbElapsed = 0 Then Cancel_Bt_Click
        End If
    Case 13   'Menu Sup
        If lShortMenuPos <> 1 Then
            lShortMenuPos = 1: WriteINISetting1
            ShortMenuPos 2, lShortMenuPos = 2   'False
            If dbElapsed = 0 Then Cancel_Bt_Click
        End If
    Case 14   'Menu Inf
        If lShortMenuPos <> 2 Then
            lShortMenuPos = 2: WriteINISetting1
            ShortMenuPos 2, lShortMenuPos = 2    'True
            If dbElapsed = 0 Then Cancel_Bt_Click
        End If

    Case 54   'Toolbar bot
        If lToolbarPos <> 0 Then
            lToolbarPos = 0: WriteINISetting1
            ToolbarPos 0
            If dbElapsed = 0 Then Cancel_Bt_Click
        End If
    Case 55   'Left
        If lToolbarPos <> 1 Then
            lToolbarPos = 1: WriteINISetting1
            ToolbarPos 2, lToolbarPos = 2   'False
            If dbElapsed = 0 Then Cancel_Bt_Click
        End If
    Case 65   'Right
        If lToolbarPos <> 2 Then
            lToolbarPos = 2: WriteINISetting1
            ToolbarPos 2, lToolbarPos = 2    'True
            If dbElapsed = 0 Then Cancel_Bt_Click
        End If

    Case 15   'HotKey
        HotKeyIni = HotKey
        Set UserFormHotKey.UserFormStopwatch1 = Me
        UserFormHotKey.Show 1        'vModal

        If HotKeyIni <> HotKey Then
            If HotKey <> "" Then fHotKey HotKey, False, False
            HotKey = HotKeyIni
            If HotKey <> "" Then If Not fHotKey(HotKey, True, False) Then HotKey = ""    'appHostApp.OnKey HotKey, appHostApp.ThisWorkbook.Name & "!Calculator"
            VBA.Interaction.AppActivate GetAppWinCaption
            WriteINISetting1
            ShortMenuPos 0: ToolbarPos 0  'Exclui
            ShortMenuPos IIf(lShortMenuPos <> 0, 1, 0), lShortMenuPos = 2: ToolbarPos IIf(lToolbarPos <> 0, 1, 0), lToolbarPos = 2    'Recria
            If dbElapsed = 0 Then Cancel_Bt_Click
        End If

    Case 151   'Attach mult
        bMultStartAttach = Not bMultStartAttach
        bUserNoteUpd = False
        FormAdjust
        WriteINISetting1
    Case 1511   'Attach mult
        bMultStartStopsAttach = Not bMultStartStopsAttach: bMultRestartStopsAttach = bMultStartStopsAttach: If bMultStartStopsAttach Then bMultStopAttach = False  'N|fffd|o vejo utilidades em ser diferente, assim sempre que alterar igual, se quiser fazer diferente tem que come|fffd|ar ou terminar por bMultRestartStopsAttach
        bUserNoteUpd = False
        FormAdjust
        WriteINISetting1
    Case 1512   'Attach mult
        bMultStartStopInssAttach = Not bMultStartStopInssAttach: bMultRestartStopInssAttach = bMultStartStopInssAttach: If bMultStartStopInssAttach Then bMultStopAttach = False  'N|fffd|o vejo utilidades em ser diferente, assim sempre que alterar igual, se quiser fazer diferente tem que come|fffd|ar ou terminar por bMultRestartStopInssAttach
        bUserNoteUpd = False
        FormAdjust
        WriteINISetting1
    Case 152   'Attach mult
        bMultRestartAttach = Not bMultRestartAttach
        bUserNoteUpd = False
        FormAdjust
        WriteINISetting1
    Case 1521   'Attach mult
        bMultRestartStopsAttach = Not bMultRestartStopsAttach
        bUserNoteUpd = False
        FormAdjust
        WriteINISetting1
    Case 1522   'Attach mult
        bMultRestartStopInssAttach = Not bMultRestartStopInssAttach
        bUserNoteUpd = False
        FormAdjust
        WriteINISetting1
    Case 153   'Attach mult
        bMultStopAttach = Not bMultStopAttach
        bUserNoteUpd = False
        FormAdjust
        WriteINISetting1
    Case 154   'Attach mult
        bMultStopInsAttach = Not bMultStopInsAttach
        Call LbStopInsUpt: LbSetUpt
        WriteINISetting1
    Case 155   'Attach mult
        bMultResetAttach = Not bMultResetAttach
        LbSet.Caption = Replace(LbSet.Caption, "*", "") & IIf(bMultResetAttach, "*", "")
        WriteINISetting1
    Case 156   'Attach mult
        If Not bMultDisable Then If MyMsgBox(IIf(IsPortg, "N|fffd|o ser|fffd| mais permitido rodar simultaneamente m|fffd|ltiplas inst|fffd|ncias. OK?", _
                                             "Will not be allowed to run simultaneously multiple instances. OK?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2 Then Exit Sub
        bMultDisable = Not bMultDisable
        WriteINISetting1

    Case 157
        OpenSaveSettingByUsr True
    Case 158
        OpenSaveSettingByUsr False
    Case 159
        OpenDefaultSetting1

    Case 161   'Sounds at
        SetSounds 1
    Case 162
        SetSounds 2
    Case 163
        SetSounds 3
    Case 164
        SetSounds 4
    Case 165
        SetSounds 5
    Case 166
        SetSounds 6
    Case 167
        bSndDisableAll = Not bSndDisableAll
        WriteINISetting1

    Case 16
        SkinSettingForm

    Case 17   'Fechar
        Cancel_Bt_Click
    Case 18   'Fechar Tudo
        Cancel_Bt_ClickMult False
    Case 19   'Sair
        If bIsCOMAddin Then
            If MyMsgBox(IIf(IsPortg, "Sair, removendo o comando do menu. OK?", "Exit, removing menu command. OK?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2 Then Exit Sub
            ShortMenuPos 0: ToolbarPos 0    'Remove menu
            Cancel_Bt_Click
            VBA.Interaction.AppActivate GetAppWinCaption
        Else
            If MyMsgBox(IIf(IsPortg, "Sair, descarregando AddIn. OK?", "Exit, unloading AddIn. OK?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2 Then Exit Sub
            Select Case appHostApp.Name
            Case "Microsoft Excel"
                appHostApp.OnTime Now, appHostApp.ThisWorkbook.Name & "!XlaExit"
                Cancel_Bt_Click
            Case "Microsoft Word"
                Cancel_Bt_Click
                Dim d    'Pode ser document ou add-in
                For Each d In appHostApp.Documents
                    If d.Name = "WordCalculator.dot" Then
                        d.Close False
                        Exit Sub
                    End If
                Next
                For Each d In appHostApp.AddIns
                    If d.Name = "WordCalculator.dot" Then
                        d.Installed = False
                        Exit Sub
                    End If
                Next
            Case "Microsoft PowerPoint"
                Cancel_Bt_Click
                For Each d In appHostApp.AddIns
                    If d.Name = "PowerPointCalculator" Then
                        d.Loaded = msoFalse
                        Exit Sub
                    End If
                Next
            Case "Microsoft Access"
                Stop
            End Select
        End If

    Case 20   'About
        If IsPortg Then
            Msg1 = "Copyright|fffd| 2003-" & Right(Year(VerDate), 2) & " by Fco Orlando Magalh|fffd|es Filho." & vbCrLf & _
                   "Todos os direitos reservados." & vbCrLf & _
                   "Licensa de Uso: Gr|fffd|tis (Freeware)" & vbCrLf & _
                   "Tipo: " & IIf(bIsCOMAddin, "COM add-in programado em VBA (dll)", "Excel Add-in programado em VBA (xla)") & vbCrLf & _
                   "Vers|fffd|o: " & fGetVersion & " (" & VBA.Format(VerDate, "yyyy.mm.dd") & ")" & vbCrLf & vbCrLf & _
                   "Visitar o site para ver as novidades sobre este e outros utilit|fffd|rios. Ok?"
        Else
            Msg1 = "Copyright|fffd| 2003-" & Right(Year(VerDate), 2) & " by Fco Orlando Magalh|fffd|es Filho." & vbCrLf & _
                   "All rights reserved." & vbCrLf & _
                   "Use License: Freeware" & vbCrLf & _
                   "Type: " & IIf(bIsCOMAddin, "COM add-in", "Add-in") & " programmed in VBA" & vbCrLf & _
                   "Version: " & fGetVersion & " (" & VBA.Format(VerDate, "yyyy.mm.dd") & ")" & vbCrLf & vbCrLf & _
                   "Visit the site to see the news about this and others utilities. Ok?"
        End If
        If MyMsgBox(Msg1, 2, IIf(IsPortg, "Sobre o 'Popup' ", "About Popup ") & sAddInCaptByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
            On Error Resume Next
            Select Case appHostApp.Name
            Case "Microsoft Excel"
                appHostApp.ActiveWorkbook.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True  'DifAppMet
            Case "Microsoft Word"
                appHostApp.ActiveDocument.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True
            Case "Microsoft PowerPoint"
                appHostApp.ActivePresentation.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True
            Case "Microsoft Access"
                appHostApp.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True
            End Select
            If Err.Number <> 0 Then MsgBox Err.Description
        End If

    Case 21    'How uninstall or temporrally disconnect
        Msg2 = MyReplace(appHostApp.Name, "Microsoft ", "")    'Nome do aplicativo
        If IsPortg Then
            Msg1 = "atrav|fffd|s do comando ''Suplementos COM...'' (Obs.: Normalmente esse comando n|fffd|o est|fffd| em nenhuma barra e antes voc|fffd| precisa adicion|fffd|-lo usando o comando Personalizar... no menu Ferramentas.)"
            Msg1 = "Este aplicativo |fffd| um COM add-in com uma |fffd|nica DLL, a " & Msg2 & "Stopwatch.dll, que pode ser desinstalado ou desconectado temporariamente por voc|fffd| mesmo usando o gerenciador de COM add-in do " & Msg2 & " ou desinstalado total e automaticamente usando o mesmo arquivo execut|fffd|vel que voc|fffd| baixou para instalar." & vbCrLf & vbCrLf & _
                   "Para DESINSTALAR OU DESCONECTAR TEMPORARIAMENTE por voc|fffd| mesmo, abra o gerenciador " & IIf(dHostAppVer < 11 + 1, Msg1, "assim: Bot|fffd|o Office > Op|fffd||fffd|es do " & Msg2 & " > Guia Suplementos > Selecione Suplementos COM no Combobox Gerenciar: > Bot|fffd|o Ir....") & vbCrLf & vbCrLf & _
                   "Para DESINSTALAR TOTAL E AUTOMATICAMENTE, execute o mesmo arquivo que voc|fffd| baixou para instalar e use o bot|fffd|o Desinstalar. Caso voc|fffd| n|fffd|o o tenha mais em seu computador, voc|fffd| pode baix|fffd|-lo novamente agora a partir de sua homepage na web. Ok?"
        Else
            Msg1 = "thru the ''COM Add-in...'' command (Note: Normally this commend is not in any bar and before you need to add it using the Customize... command on Tools menu.)"
            Msg1 = "This application is a COM add-in with a single DLL, the " & Msg2 & "Stopwatch.dll, which can be uninstalled or temporarily disconnected by yourself using the " & Msg2 & " COM add-in manager or uninstalled completely and automatically using the same executable file that you downloaded to install." & vbCrLf & vbCrLf & _
                   "To UNINSTALL or TEMPORARILY DISCONNECT by yourself, open the manager " & IIf(dHostAppVer < 11 + 1, Msg1, "like this: Office Button > " & Msg2 & " Options > Add-Ins Tab > Select COM Add-ins in Manage: Combobox control > Go... Button.") & vbCrLf & vbCrLf & _
                   "To UNINSTALL COMPLETELY AND AUTOMATICALLY, execute the same file that you downloaded to install and use Uninstall button. If you do not have it anymore on your computer, you can download it again NOW from its web homepage. Ok?"
        End If
        If MyMsgBox(Msg1, 2, sAddInCaptByApp & IIf(IsPortg, " - Como Desinstalar ou Desconectar ", " - How Uninstall or Disconnect "), , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
            On Error Resume Next
            Select Case appHostApp.Name
            Case "Microsoft Excel"
                appHostApp.ActiveWorkbook.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=DesinstAjuda", "More.asp?IdC=UninstHelp"), , True  'DifAppMet
            Case "Microsoft Word"
                appHostApp.ActiveDocument.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=DesinstAjuda", "More.asp?IdC=UninstHelp"), , True
            Case "Microsoft PowerPoint"
                appHostApp.ActivePresentation.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=DesinstAjuda", "More.asp?IdC=UninstHelp"), , True
            Case "Microsoft Access"
                appHostApp.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=DesinstAjuda", "More.asp?IdC=UninstHelp"), , True
            End Select
            If Err.Number <> 0 Then MsgBox Err.Description
        End If
    End Select
End Sub

Private Sub LabelLedImp_Click()
    Dim LinFin As Long
    Dim LinIni As Long
    Dim LinPag As Long
    Dim ColPag As Long
    Dim Col As Long
    Dim Pag As Long
    Dim i As Long
    Dim j As Long
    Dim Lin As Long
    Dim c As Range
    Dim Lar1 As Double
    LinFin = UBound(FitaPapel)
    LinIni = Val(InputBox(IIf(IsPortg, "H|fffd| ", "There are ") & LinFin & IIf(IsPortg, " linhas na fita. Imprimir as |fffd|ltimas:", " rows in the ribbon. Print the last ones:"), IIf(IsPortg, "Imprimir Papel", "Print Paper"), LinFin))
    If LinIni < 1 Then Exit Sub
    If LinIni > LinFin Then LinIni = LinFin
    LinIni = LinFin - LinIni + 1
    appHostApp.ScreenUpdating = False
    appHostApp.Workbooks.Add
    LinPag = 45
    ColPag = 4
    Col = 1
    Pag = 1
    For i = LinIni To LinFin
        Lin = i - (Col - 1) * LinPag - (Pag - 1) * LinPag * ColPag + LinPag * (Pag - 1) - LinIni + 1
        appHostApp.Cells(Lin, Col).Value = FitaPapel(i)
        j = Col
        If i Mod LinPag = 0 Then Col = Col + 1
        If i Mod ColPag * LinPag = 0 Then
            appHostApp.ActiveWindow.SelectedSheets.HPageBreaks.Add Before:=appHostApp.Cells(Lin + 1, j)
            Col = 1
            Pag = Pag + 1
        End If
    Next

    appHostApp.Range(appHostApp.Range("A1"), appHostApp.Range("A1").SpecialCells(xlCellTypeLastCell)).Select
    appHostApp.Selection.Font.Size = 12
    appHostApp.Selection.Columns.AutoFit
    appHostApp.Selection.Font.Size = 10
    i = appHostApp.Selection.Columns.Width
    If i < 450 Then
        For Each c In appHostApp.Selection.Columns
            If c.Column = 1 Then Lar1 = c.Width
            If c.Column > 1 Then c.ColumnWidth = c.ColumnWidth * (450 - Lar1) / (i - Lar1)
        Next
    Else
        appHostApp.ActiveWindow.ActiveSheet.PageSetup.Zoom = Int((450 - Lar1) / (i - Lar1) * 100)
    End If
    appHostApp.Selection.HorizontalAlignment = xlRight
    Err.Clear
    On Error Resume Next
    appHostApp.ActiveWindow.SelectedSheets.PrintOut Copies:=1
    If Err.Number <> 0 Then MyMsgBox IIf(IsPortg, "Erro", "Error") & " # " & Str(Err.Number) & IIf(IsPortg, " foi gerado por ", " was generated by ") _
                                   & Err.Source & Chr(13) & Err.Description, 1, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop

    On Error GoTo 0
    appHostApp.ActiveWorkbook.Close False
    appHostApp.ScreenUpdating = True
End Sub

Private Sub LbColar_Click()
    Dim lPartInt, lPartFrc
    Dim i
    DadosTransf.GetFromClipboard
    On Error Resume Next    'Antecipei, pois se vazio d|fffd| erro em GetText(1). Bug percebido na vers|fffd|o 4.0.
    i = MyClean(VBA.Trim(DadosTransf.GetText(1)))
    If Err.Number <> 0 Then i = 0

    If InStr(1, i, sDecimalSep) = 0 Then
        lPartInt = i
        lPartFrc = 0
    Else
        lPartInt = Left(i, InStr(1, i, ",") - 1)
        lPartFrc = Mid(i, InStr(1, i, ",") + 1, 3)
        If Not IsNumeric(lPartFrc) Then lPartFrc = 0
    End If

    lPartInt = TimeValue(lPartInt)
    If Err.Number <> 0 Then lPartInt = 0
    If lPartInt = 0 And lPartFrc = 0 Then
        MyMsgBox IIf(IsPortg, "A |fffd|rea de Tranfer|fffd|ncia do Windows n|fffd|o cont|fffd|m um valor v|fffd|lido!", "The Windows Clipboard hasn't valid value!"), 1, sAddInCaptByApp & IIf(IsPortg, " - Valor Inv|fffd|lido", " - Invalid Value"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop
    Else
        If lBotPress = 1 Then If MyMsgBox(IIf(IsPortg, "Parar a contagem atual para continuar a existente na |fffd|rea de Tranfer|fffd|ncia do Windows. Ok?", "Stop the current count to continue the existing in the Windows Clipboard. OK?"), 2, sAddInCaptByApp & IIf(IsPortg, " - Colar " & i, " - Paste " & i), , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2 Then TbVisorFnd.SetFocus: Exit Sub
        lBotPress = 2
        dbElapsed = Hour(lPartInt) * 3600 + Minute(lPartInt) * 60 + Second(lPartInt) + lPartFrc / 10 ^ Len(lPartFrc)    'lPartFrc / 100
        dbStart = GetTickCount() / 1000 - dbElapsed
    End If
    TbVisorFnd.SetFocus
End Sub

Private Sub LbCopiar_Click()
    If dbElapsed = 0 Then Exit Sub
    Dim lPartInt, lPartFrc
    Dim lHh As Long, lMm As Long, lSs As Long
    lPartInt = Int(dbElapsed)
    lPartFrc = dbElapsed - lPartInt
    lHh = Int(lPartInt / 60 / 60)
    lMm = Int((lPartInt - 60 * 60 * lHh) / 60)
    lSs = lPartInt - 60 * 60 * lHh - 60 * lMm
    lPartInt = lHh & ":" & VBA.Format(lMm, "00") & ":" & VBA.Format(lSs, "00")
    lPartFrc = IIf(lPartFrc < 0.01, "", sDecimalSep & Left(VBA.Format(10 ^ 3 * lPartFrc, String(3, "0")), 3))
    DadosTransf.SetText lPartInt & lPartFrc
    DadosTransf.PutInClipboard
    TbVisorFnd.SetFocus
End Sub

Private Sub ScrollBarSize_Change()
    lDispSize = ScrollBarSize.Value
    If vEnableEvents = False Then Exit Sub
    WriteINISetting1
End Sub
Private Sub ScrollBarSize_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    IgnoreTbVisorFnd_KeyUp = False
    TbVisorFnd.SetFocus
    ScrollBarMode.SetFocus
    TbVisorFnd.SetFocus
End Sub

Private Sub ScrollBarCtrlPanel_Change()
    lCtrlPanelSize = ScrollBarCtrlPanel.Value
    If vEnableEvents = False Then Exit Sub
    WriteINISetting1
End Sub
Private Sub ScrollBarCtrlPanel_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    IgnoreTbVisorFnd_KeyUp = False
    TbVisorFnd.SetFocus
    ScrollBarMode.SetFocus
    TbVisorFnd.SetFocus
End Sub


Private Sub ScrollBarPapel_Change()
    Dim i As Long
    Dim lCtrl As Long
    i = ScrollBarPapel.Value
    If i < 9 Then
        ScrollBarPapel.Value = 9
        i = 9
        Beep
    End If
    If i > UBound(FitaPapel()) Then
        ScrollBarPapel.Value = UBound(FitaPapel())
        i = UBound(FitaPapel())
        Beep
    End If

    For lCtrl = 1 To 9
        Controls("LabelPapel" & lCtrl).Caption = FitaPapel(i - lCtrl + 1)    'LabelPapel1.Caption = FitaPapel(i): LabelPapel2.Caption = FitaPapel(i - 1):...
    Next
End Sub
Private Sub ScrollBarPapel_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    IgnoreTbVisorFnd_KeyUp = False
    TbVisorFnd.SetFocus
    ScrollBarMode.SetFocus
    TbVisorFnd.SetFocus
End Sub

Private Sub TbVisorFrontTransp_Click()
    If sIgnClickIfDrag = TbVisorFrontTransp.Name Then   'Ignorar click se houver arrasto do form por este controle
        sIgnClickIfDrag = ""
        Exit Sub
    End If

    Select Case lClickOnDisplay
    Case 1
        xLbStartStop_Click
    Case 2
        xLbStopIns_Click lStopInsMode
    Case 3
        If LbSplit.Visible Then xLbSplit_Click 0
    Case 4
        xLbSet_Click lResetMode
    End Select
End Sub
Private Sub TbVisorFrontTransp_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    TbVisorFrontTransp_Click
End Sub

Private Sub UserForm_Initialize()
    AlinhReadINISetting

    If IsPortg Then
        LbSet.Caption = "Zerar"
        LbSplit.Caption = "Dividir"
        LbCntDown.Caption = "CntRegr"

        ScrollBarPapel.ControlTipText = "Rolar papel"
        LabelLedImp.Caption = "Impr."
        LabelLedPapel.Caption = "Papel"
        LabelDecimal.ControlTipText = "Casas decimais"
        LabelMode.ControlTipText = "Modo do Visor"
        ScrollBarPapel.ControlTipText = "Rolar Papel"
        ScrollBarDecimal.ControlTipText = "Altera Casas Decimais"
        ScrollBarMode.ControlTipText = "Altera Modos do Visor"
        LbColar.ControlTipText = "Colar da |fffd|rea de Transfer|fffd|ncia do Windows (Ctrl+V)"
        LbCopiar.ControlTipText = "Copiar para |fffd|rea de Transfer|fffd|ncia do Windows (Ctrl+C)"
        LbSet.ControlTipText = "Zerar contagem de tempo"
        LbStartStop.ControlTipText = "Iniciar, Parar ou Reiniciar"
        LbSplit.ControlTipText = "Divide tempo em uma planilha de instant|fffd|neos"
        LbCntDown.ControlTipText = "Contagem Regressiva"
        LabelMode.Caption = Choose(lMode, "d  hh : mm : ss", "h : mm : ss", "m : ss", "Segundos", "Minutos", "Horas", "Dias", "Semanas", "Meses", "Anos")
        UserNoteLast_Chb.ControlTipText = "Alterna entre inserir a nota no pr|fffd|ximo ou no |fffd|ltimo evento ocorrido"
        ActSplitSheet_ChB.Caption = "AtPln"
        ActSplitSheet_ChB.ControlTipText = "Ativa a planilha de divis|fffd|o ou a inicial"
        SnapshotLabels_Lb.Caption = "R|fffd|tulos/Cores de Instant|fffd|neos"
        ScrollBarSnapshotNumb.ControlTipText = "Exibi/Oculta instant|fffd|neos de r|fffd|tulo/cor de 0 a 10"
        Close_Lb.ControlTipText = "Fechar" & IIf(CollectionInst.Count > 0, " (Baixar Shift para fechar todos)", "")
        CtrlPanelShow_Lb.Caption = "ep": CtrlPanelShow_Lb.ControlTipText = "Exibir painel de bot|fffd|es"
    Else
        ScrollBarPapel.ControlTipText = "Scroll paper"
        LabelLedImp.Caption = "Print"
        LabelLedPapel.Caption = "Paper"
        LabelDecimal.ControlTipText = "Decimal places"
        LabelMode.ControlTipText = "Display Mode"
        ScrollBarPapel.ControlTipText = "Scroll Paper"
        ScrollBarDecimal.ControlTipText = "Change Decimal Places"
        ScrollBarMode.ControlTipText = "Change Display Modes"
        LbColar.ControlTipText = "Paste from Windows Clipboard (Ctrl+V)"
        LbCopiar.ControlTipText = "Copy to Windows Clipboard (Ctrl+C)"
        LbSet.ControlTipText = "Reset time count"
        LbStartStop.ControlTipText = "Start, Stop or Restart"
        LbSplit.ControlTipText = "Split time in a snapshot sheet"
        LbCntDown.ControlTipText = "Countdown"
        LabelMode.Caption = Choose(lMode, "d  hh : mm : ss", "h : mm : ss", "m : ss", "Seconds", "Minutes", "Hours", "Days", "Weeks", "Months", "Years")
        UserNoteLast_Chb.ControlTipText = "Toggle between insert the note in the next or in the last event happened"
        ActSplitSheet_ChB.Caption = "ActSh"
        ActSplitSheet_ChB.ControlTipText = "Acivate the split sheet or the initial one"
        SnapshotLabels_Lb.Caption = "Snapshot Labels/Colors"
        ScrollBarSnapshotNumb.ControlTipText = "Show/Hide label/color snapshots from 0 to 10"
        Close_Lb.ControlTipText = "Close" & IIf(CollectionInst.Count > 0, " (Shift down to close all)", "")
        CtrlPanelShow_Lb.Caption = "sp": CtrlPanelShow_Lb.ControlTipText = "Show panel of buttons"
    End If

    Menu_Lb.MouseIcon = FormMyMsgBox.HomePage_Lb.MouseIcon
    LabelLedPapel.MouseIcon = Menu_Lb.MouseIcon
    LabelLedImp.MouseIcon = Menu_Lb.MouseIcon
    CtrlPanelShow_Lb.MouseIcon = Menu_Lb.MouseIcon: CtrlPanelShow_Lb.BackStyle = fmBackStyleTransparent
    TbVisorFrontTransp.BackStyle = fmBackStyleTransparent    'Essa frente transparente |fffd| para evitar ativar o cursor dentro textbox de n|fffd|mero, o right clique que no textbox aparece duas vezes, arrastar ou qualquer a|fffd||fffd|o com mouse
    Call LbStopInsUpt: LbSetUpt
    UserNote_Lb.Caption = IIf(IsPortg, "Nota Usu|fffd|rio:", "User Note:")

    'Hide controles de spliting. Usernote e Snapshots Labels
    Dim oCtrl As Object
    For Each oCtrl In Controls
        If InStr(1, oCtrl.Name, "PickC") > 0 Then oCtrl.MouseIcon = Menu_Lb.MouseIcon    'LbDispPickCback.MouseIcon = Menu_Lb.MouseIcon
        If oCtrl.Top >= UserNote_Tb.Top Then oCtrl.Visible = False
    Next

    UpdtCtrlColors
    Dim lCtrl As Long
    For lCtrl = 1 To 10
        Controls("LbSnapshot" & lCtrl).Caption = IIf(IsPortg, "Instt|fffd|neo ", "Snapshot ") & lCtrl
        Controls("LbSnapshot" & lCtrl).ControlTipText = IIf(IsPortg, "Snapshot de r|fffd|tulo/cor ", "Snapshot label/color ") & lCtrl
        Controls("Snapshot" & lCtrl & "_Tb").ControlTipText = IIf(IsPortg, "R|fffd|tulo/Cor do snapshot ", "Snapshot label/color ") & lCtrl

        If lCtrl < 10 Then Controls("LabelPapel" & lCtrl).ControlTipText = IIf(IsPortg, "Papel", "Paper")
    Next

    LbDispPickCback.ControlTipText = IIf(IsPortg, "Alterar cor de fundo do visor", "Change display background color")
    LbDispPickCfore.ControlTipText = IIf(IsPortg, "Alterar cor de frente do visor", "Change display foreground color")
    LbDispPickCrestore.ControlTipText = IIf(IsPortg, "Restaura as cores padr|fffd|o do visor e tamanhos", "Restore display default colors and sizes")
    LbSnpshtPickCback1.ControlTipText = IIf(IsPortg, "Alterar cor de fundo", "Change background color")
    LbSnpshtPickCfore1.ControlTipText = IIf(IsPortg, "Alterar cor de frente", "Change foreground color")
    LbSnpshtPickCrestore.ControlTipText = IIf(IsPortg, "Restaura as cores padr|fffd|o", "Restore default colors")
    LbSnpshtSound.ControlTipText = IIf(IsPortg, "Som", "Sound")

    vEnableEvents = True
    Leds
    Set DadosTransf = New DataObject

    On Error Resume Next: lCtrl = 0: lCtrl = UBound(FitaPapel()): On Error GoTo 0    'Teste se fita j|fffd| existe. Melhorar depois
    If lCtrl = 0 Then
        ReDim FitaPapel(9)
        FitaPapel(2) = IIf(IsPortg, "Fita de Papel", "Paper Ribbon")
        FitaPapel(3) = IIf(IsPortg, "Cron|fffd|metro", "Stopwatch")
        FitaPapel(4) = "Orlando Magalh|fffd|es Filho"
        FitaPapel(5) = "http://cpap.com.br/orlando/"
        FitaPapel(7) = IIf(IsPortg, "Licenciado:", "Licensed:")
        FitaPapel(8) = IIf(IsPortg, "Sim. Uso dom|fffd|stico", "Yes. Home use")
    Else
        ScrollBarPapel.Value = UBound(FitaPapel())
    End If

    vEnableEvents = False
    ScrollBarDecimal.Value = ScrollBarDecimal.Max - lNumDecim
    LabelDecimal.Caption = IIf(lNumDecim = 5, "F", lNumDecim)
    ScrollBarMode.Value = lMode
    ScrollBarSize.Value = lDispSize
    ScrollBarCtrlPanel.Value = lCtrlPanelSize
    ScrollBarSnapshotNumb.Value = lSnapshotNumb
    UserNoteLast_Chb.Value = bUserNoteLast: UserNote_Tb.Text = arrSnpshtLb(0)

    'TbVisor.Value = CStr(CronometroElapsedIni)
    vEnableEvents = True
    If bPaperRibbon = False Then LabelLedPapel_Click


    'API format form here because it changes form size accord with Windows and Office version
    If App_hWnd = 0 Or appHostApp.Name = "Microsoft Word" Or appHostApp.Name = "Microsoft PowerPoint" Or (appHostApp.Name = "Microsoft Excel" And dHostAppVer >= 11 + 1 + 2 + 1) Then GetApp_hWnd    'In Word and PowerPoint each doc window has different handle e o Excel 15 tamb|fffd|m.
    App_hWnd1 = App_hWnd

    Caption = Caption & Now    'T|fffd|tulo |fffd|nico para um handle preciso
    Form_hWnd = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd = 0 Then Form_hWnd = FindWindowA(vbNullString, Caption)

    'Basear o form na janela do aplicativo. Comentei, pois agora vai ser feito em SkinSettingUpt depos das op|fffd||fffd|es bUnanchExcelWin e bAlwaysOnTop
    'If (bIsCOMAddin And Not bUnanchExcelWin) Or (Not bIsCOMAddin And bUnanchExcelWin) Then SetWindowLongA Form_hWnd, GWL_HWNDPARENT, IIf(bUnanchExcelWin, 0&, App_hWnd1)
    'If bAlwaysOnTop Then SetWindowPos Form_hWnd, HWND_TOPMOST, 0, 0, 0, 0, FLAGS

    'Sizeble form in both COM and Add-in and also detect borders and title bar sizes     'Fixar form to avoid resize
    vEnableEvents = False
    OrigFormWidth = InsideWidth    'Para detectar a varia|fffd||fffd|o das bordas ao formatar form via API
    OrigFormHeight = InsideHeight
    formSizeble Form_hWnd, False

    If Width > 2 * 273 Then Twips = 20 Else Twips = 1           'Em ComAddin as dimens|fffd|es do formul|fffd|rio |fffd| em twip, mas as posi|fffd||fffd|es dos controles continuma em pontos
    Width = Width - (InsideWidth - OrigFormWidth) * Twips
    Height = Height - (InsideHeight - OrigFormHeight) * Twips

    OrigFormHeight = InsideHeight    'Para detectar a altura do t|fffd|tulo ao formatar form via API
    formSizeble Form_hWnd, True
    dFormTitleHeight = InsideHeight - OrigFormHeight
    dFormBorderWeight = (Width / Twips - InsideWidth) / 2    'Weight of each border

    formSizeble Form_hWnd, bHideTitleBar    'If bIsCOMAddin Then FixForm Form_hWnd
    vEnableEvents = True

    'Form position. Posicionar onde o form j|fffd| est|fffd| definido com papel exibido ou n|fffd|o
    If Not bIsCOMAddin Then StartUpPosition = 0
    CronometroPosLeft = CronometroPosLeft - 60
    If CronometroPosLeft > ScreenRx - Width / Twips Then CronometroPosLeft = ScreenRx - Width / Twips  'M|fffd|x permitido
    CronometroPosTop = CronometroPosTop - 50 + IIf(bPaperRibbonIni, -95, 0) + IIf(bHideTitleBarIni, dFormTitleHeight, 0)    'Sobe form para mouse ficar no meio
    If CronometroPosTop > ScreenRy - 85 Then CronometroPosTop = ScreenRy - 85      '25 segur. para evitar Start Menu fixo
    If CronometroPosTop < 0 Then CronometroPosTop = 0

    If bPopupAtLastPos Then        '|fffd|tima pos salva
        If dLastPosTop < -15 Then dLastPosTop = -15
        If dLastPosTop > ScreenRy - 85 Then dLastPosTop = ScreenRy - 85
        Top = dLastPosTop * Twips

        If dLastPosLeft < -80 Then dLastPosLeft = -80
        If dLastPosLeft > ScreenRx - 70 Then dLastPosLeft = ScreenRx - 70
        Left = dLastPosLeft * Twips
    Else        'Pr|fffd|ximo ao cursor do mous. Posi|fffd||fffd|o antiga e padr|fffd|o
        Top = CronometroPosTop * Twips
        Left = CronometroPosLeft * Twips
    End If

    Width = 210 * Twips: Height = 160 * Twips    'Esses valores |fffd| para evitar ver a caixa sendo ajeitada
    SkinSettingUpt    'TitleBar n|fffd|o pode ser ocultado desta vez. Fazer no Activate
    lastFormWidth = Width: lastFormHeight = Height    'Consolida size do form at|fffd| aqui para evitar que seja tida como altera|fffd||fffd|o externa pelas bordas
    'TbVisorFnd.SetFocus 'Se usado em COM add-in, o evento Activate n|fffd|o dispara, talvez um bug. Tranferi para o activate
End Sub

Private Sub LbStopInsUpt()
    LbStopIns.BackColor = Choose(lStopInsMode, &HFF&, &H404080, &H4040&, &H80FF&, &HFFFFFF, BackColor)                         'red, brown, olive, orange, blank. Code color got in VBA form property
    LbStopIns.ForeColor = Choose(lStopInsMode, &HFFFFFF, &HFFFFFF, &HFFFFFF, &HFFFFFF, &H0&, ForeColor)
    If IsPortg Then
        LbStopIns.Caption = LbStopInsCapt()
        LbStopIns.ControlTipText = Choose(lStopInsMode, "P|fffd|ra, insere na c|fffd|lula e fecha.", "P|fffd|ra, insere na c|fffd|lula e zera.", "P|fffd|ra, insere na c|fffd|lula, zera e inicia.", "P|fffd|ra e insere na c|fffd|lula somente.", "Insere na c|fffd|lula sem parar (Instant|fffd|neo)", "") & " Dica! Use o menu para alterar entre Parar/Inserir/Fechar/Zerar."
    Else
        LbStopIns.Caption = LbStopInsCapt()
        LbStopIns.ControlTipText = Choose(lStopInsMode, "Stop, insert in the cell, and close.", "Stop, insert in the cell, and reset", "Stop, insert in the cell, reset, and start.", "Stop and insert in the cell only.", "Insert in the cell without stop (Snapshot)", "") & " Tip! Use the menu to change between Stop/Insert/Close/Reset."
    End If
    If Not bMultDisable And bMultStopInsAttach Then LbStopIns.Caption = LbStopIns.Caption & "*"

    LbStopIns.Enabled = lStopInsMode < 6
End Sub
Private Function LbStopInsCapt(Optional lStopInsMode1 As Long) As String    'Separei para obter s|fffd| caption quando a|fffd||fffd|o vem pelo bot|fffd|o Reset
    If lStopInsMode1 = 0 Then lStopInsMode1 = lStopInsMode
    If IsPortg Then
        LbStopInsCapt = Choose(lStopInsMode1, "ParInsFec", "ParInsZer", "ParInZeIn", "PararIns", "Inserir", "PararIns")
    Else
        LbStopInsCapt = Choose(lStopInsMode1, "StpInsCls", "StpInsRst", "StpInRsSt", "StopIns", "Insert", "StopIns")
    End If
End Function

Private Sub LbSetUpt()
    LbSet.BackColor = Choose(lResetMode, &HE0E0E0, &HC000&, &HFFFFFF, BackColor)      'gray, green, blank
    LbSet.ForeColor = Choose(lResetMode, &H0&, &HFFFFFF, &H0&, ForeColor)
    LbSet.Enabled = True
    If IsPortg Then
        LbSet.Caption = Choose(lResetMode, "Zerar", "ZerarI", "ZerarII", "Zerar")
        LbSet.ControlTipText = Choose(lResetMode, "Zerar.", "Zerar e Iniciar.", "Inserir na c|fffd|lula ativa, Zerar e Iniciar.", "") & " Dica! Use o menu para alterar entre Inserir/Zerar/Iniciar."
    Else
        LbSet.Caption = Choose(lResetMode, "Reset", "ResetS", "ResetIS", "Reset")
        LbSet.ControlTipText = Choose(lResetMode, "Reset.", "Reset and Start.", "Insert in the active cell, Reset, and Start.", "") & " Tip! Use the menu to change between Insert/Reset/Start."
    End If
    If Not bMultDisable And bMultResetAttach Then LbSet.Caption = LbSet.Caption & "*"

    LbSet.Enabled = lResetMode < 4
End Sub

Private Sub LbOtherButtsUpt()
    If (lBotPress = 1 And (lOtherButtsMode And 1) = 1) _
       Or (lBotPress = 2 And (lOtherButtsMode And 2) = 2) Then
        LbStartStop.Visible = False: LbStartStop.SpecialEffect = fmSpecialEffectEtched    'Se Enabled, o Excel perde o foco, mas Visible parece at|fffd| mais adequado no autohide.
    Else
        LbStartStop.Visible = True
    End If
    LbCntDown.Enabled = Not (lOtherButtsMode And 4) = 4    'Desabilitar |fffd| mais adquadno do que ocultar ficando buraco.
    LbSplit.Enabled = Not (lOtherButtsMode And 8) = 8
    LbColar.Enabled = Not (lOtherButtsMode And 16) = 16
    LbCopiar.Enabled = Not (lOtherButtsMode And 32) = 32
    CtrlPanelShow_Lb.Visible = Not (lOtherButtsMode And 64) = 64    'Como s|fffd| em autohide, ocultar |fffd| mais adequado que desabilitar.
End Sub

Private Sub UserForm_Activate()
    Static bOnlyOneTime As Boolean
    If bOnlyOneTime Then Exit Sub
    bOnlyOneTime = True

    If lBotPress = 0 Or lBotPress = 2 Then  'S|fffd| alerta para update ao iniciar e se resetado e parado
        LoopAPI    'Faz o primeiro loop para exibi o form ajeitado pro tr|fffd|s de um poss|fffd|vel alert de update.
        bUserNoteUpd = False: LoopAPI: If bHideTitleBar Then bUserNoteUpd = False: LoopAPI    'Faz dois loops novamente, pois um s|fffd| n|fffd|o |fffd| suficiente para deixar ajeitada, principalmente se barra de tit tiver sido oculta no primeiro. Usa bUserNoteUpd para provocar necessidade de update em FormAdjust.
        AlertAboutNewVer
    End If
    If LoopAPIid = 0 Then StartLoopAPI  'Start the API loop if not yet by other instance

    'Necess|fffd|rio, devido bug Setfocus em textbox do Excel2k. Isto foi resolvido com SendKeys tamb|fffd|m
    If Val(appHostApp.Version) = 9 Then
        On Error Resume Next    'N|fffd|o sei se precisa s|fffd| em debug
        ScrollBarDecimal.SetFocus
        TbVisorFnd.SetFocus
        On Error GoTo 0
    End If

    If bCntDown Then    'If start in countdown update cntdown form and show or just start
        If bCDtoDTime = False Then    'Se for countdown para um date/time j|fffd| definido |fffd| melhor preservar o tempo fixo existente.
            lCDHour = Int(dbElapsed / 60 / 60)
            lCDMin = Int((dbElapsed - lCDHour * 60 * 60) / 60)
            lCDSec = Int((dbElapsed - lCDHour * 60 * 60 - lCDMin * 60))
            If Round(dbElapsed - Int(dbElapsed), 3) = 0 Then lCDSecFract = 0 Else lCDSecFract = Mid(CStr(Round(dbElapsed - Int(dbElapsed), 3)), 3)
        End If

        If sCDTxtAlert = "" Then
            lCDBeep = 10
            sCDFileWav = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "MediaPath") & "\TADA.WAV"    '"C:\WINDOWS\MEDIA\TADA.WAV"
            sCDFileRun = "Notepad.exe"
            sCDTxtAlert = IIf(IsPortg, "A Contagem Regressiva Expirou!", "The Coutdown Expire!")
            lCDSpeak = 10
        End If
        If lBotPress = 2 Then LbCntDown_Click
    End If
    TbVisorFnd.SetFocus
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then
        Cancel = True
        Cancel_Bt_ClickQ    'Cancel_Bt_Click
    End If
End Sub

Private Sub TbVisorFnd_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'Se estiver popuping em c|fffd|lulas marcadas as teclas de dire|fffd||fffd|o ficam cancelando para n|fffd|o atrapalhar a navega|fffd||fffd|o na planilha
    If (KeyCode >= 37 And KeyCode <= 40) Or KeyCode = 33 Or KeyCode = 34 Or KeyCode = 9 Then
        If bArrKeysCancel Then
            Cancel_Bt_Click
            Exit Sub
        End If
    End If

    IgnoreTbVisorFnd_KeyUp = True
    If KeyCode = 82 Then xLbSet_Click lResetMode   'R and era Backspace 8
    If (KeyCode >= 37 And KeyCode <= 40) Or KeyCode = 33 Or KeyCode = 34 Or KeyCode = 9 Or KeyCode = 117 Then NavShThruVisor KeyCode, Shift   'xLbStopIns_Click lStopInsMode 'Comentei porque n|fffd|o parece |fffd|til sair com ArrayKeys sem estar navegando na planilha com popup em c|fffd|l.
    If KeyCode = 73 Then xLbStopIns_Click lStopInsMode  'I antes era O 79
    If KeyCode = 13 Or (KeyCode = 187 And Shift = 0) Or KeyCode = 32 Then If bSplit And lBotPress = 1 Then xLbSplit_Click Else xLbStartStop_Click    '=
    TeclaEnter = KeyCode = 13
    If KeyCode = 67 Then LbCopiar_Click    'C
    If KeyCode = 86 Then LbColar_Click    'V
    TbVisorFnd.SetFocus
End Sub

Private Sub UserForm_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Xini = X    'When a button is down, store initial mouse position
    Yini = Y
    If Button = 2 Then Menu_Lb_Click    'Show menu when right mouse button down
End Sub

Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
'Se o mouse se mover sobre o calend|fffd|rios as teclas de dire|fffd||fffd|o n|fffd|o mais cancela
    If Abs(TbVisorFnd.Top - TbVisor.Top) > 10 Or (((lOtherButtsMode And 1) = 1 Or (lOtherButtsMode And 2) = 2) And X > LbStartStop.Left And X < LbStartStop.Left + LbStartStop.Width And Y > LbStartStop.Top And Y < LbStartStop.Top + LbStartStop.Height) Then Exit Sub     'Ignora MouseMove com o form ainda n|fffd|o organizado no inicio e sobre LbStartStop quando pode ser ocultado ao ser clicado provocando deslocamento do form.
    bArrKeysCancel = False

    If Button = 1 Then    'Move form if left mouse button is down
        Left = Left + (X - Xini)
        Top = Top + (Y - Yini)
        If Abs(Left - LeftIni) > 4 Or Abs(Top - TopIni) > 4 Then sIgnClickIfDrag = Me.Name
        SizeFormRestLast
    End If
End Sub

Private Sub TbVisorFnd_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'Se uma tecla for acionada com outro controle em foco o seu keydown foca TbVisorFnd e ativa este evento que tranfere para keydown
    If bArrKeysCancel Or IgnoreTbVisorFnd_KeyUp Then Exit Sub
    TbVisorFnd_KeyDown KeyCode, Shift
End Sub

Private Sub TbVisorFnd_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Cancel = TeclaEnter
    TeclaEnter = False
End Sub

Sub PrintPapel(ByVal dbElapsed1 As Double, ByVal sTime As Date, sEvent As String, sLabel, sDisplay)
    sEvent = Replace(sEvent, "*", ""): sEvent = Replace(sEvent, "|fffd|", ""): sEvent = Replace(sEvent, "|fffd|", "")
    If bSplit Then SplitLog dbElapsed1, sTime, sEvent, CStr(sLabel)
    If sEvent <> IIf(IsPortg, "Cancelar", "Cancel") Then sLastDisplay = sDisplay: dbLastElapsed = dbElapsed1

    If Not bPaperRibbon Then Exit Sub
    Dim i As Long
    i = UBound(FitaPapel())

    ReDim Preserve FitaPapel(i + 1)
    Dim lLenEvMax As Long    'Nome de evento com maior tamanho
    If Not bSplit Then
        lLenEvMax = Len(IIf(IsPortg, "ParInsFec", "StpInsCls"))
    Else
        lLenEvMax = Len(IIf(IsPortg, "Instt|fffd|neo", "Snapshot")) + IIf(lSnapshotNumb = 0, 0, Len(CStr(lSnapshotNumb)))
    End If
    FitaPapel(i + 1) = VBA.Format(sTime, "hh:mm:ss" & IIf(appHostApp.International(xl24HourClock), "", " AM/PM")) & _
                       " " & IIf(bCntDown, IIf(IsPortg, "Regressivo", "Countdown"), IIf(IsPortg, "Cron|fffd|metro", "Stopwatch")) & _
                       " " & lMode & lNumDecim & _
                       " " & Left(Replace(sEvent, " ", "") & String(20, Chr(160)), lLenEvMax) & _
                       " " & sDisplay
    ScrollBarPapel.Value = i + 1

    If TbVisor.Top > 20 And Not bSndDisableAll Then Call sndPlaySound32(WavFile, &H0)
    If TbVisor.Top > 20 And Not bSndDisableAll Then Call sndPlaySound32(WavFile, &H1)
    FitaPapelIni() = FitaPapel()    'Qualquer evento ecoa para o Ini para ficar o padr|fffd|o
End Sub
Private Sub LabelPapel1_Click()
    EvLabelPapel_Click (LabelPapel1.Caption)
End Sub
Private Sub LabelPapel2_Click()
    EvLabelPapel_Click (LabelPapel2.Caption)
End Sub
Private Sub LabelPapel3_Click()
    EvLabelPapel_Click (LabelPapel3.Caption)
End Sub
Private Sub LabelPapel4_Click()
    EvLabelPapel_Click (LabelPapel4.Caption)
End Sub
Private Sub LabelPapel5_Click()
    EvLabelPapel_Click (LabelPapel5.Caption)
End Sub
Private Sub LabelPapel6_Click()
    EvLabelPapel_Click (LabelPapel6.Caption)
End Sub
Private Sub LabelPapel7_Click()
    EvLabelPapel_Click (LabelPapel7.Caption)
End Sub
Private Sub LabelPapel8_Click()
    EvLabelPapel_Click (LabelPapel8.Caption)
End Sub
Private Sub LabelPapel9_Click()
    EvLabelPapel_Click (LabelPapel9.Caption)
End Sub

Private Sub EvLabelPapel_Click(i1 As String)
    Dim lPartInt, lPartFrc
    Dim i
    On Error Resume Next
    i = Split(i1, " "): i = i(4)
    If InStr(1, i, sDecimalSep) = 0 Then
        lPartInt = i
        lPartFrc = 0
    Else
        lPartInt = Left(i, InStr(1, i, ",") - 1)
        lPartFrc = Mid(i, InStr(1, i, ",") + 1, 255)
        If Not IsNumeric(lPartFrc) Then lPartFrc = 0
    End If
    'Get display mode
    i = Split(i1, " "): i = Left(i(2), 1)
    Select Case i
    Case 0
        lPartInt = Split(lPartInt, ":")
        lPartInt = lPartInt(0) * 3600 + lPartInt(1) * 60 + lPartInt(2) * 1
    Case 1
        lPartInt = Split(lPartInt, ":")
        lPartInt = lPartInt(0) * 60 + lPartInt(1) * 1
    Case 2
        lPartInt = lPartInt * 1
    Case 3
        lPartInt = lPartInt * 60
    Case 4
        lPartInt = lPartInt * 3600
    End Select
    If Err.Number <> 0 Then lPartInt = 0
    If lPartInt = 0 And lPartFrc = 0 Then
        MyMsgBox IIf(IsPortg, "Esta linha do papel n|fffd|o cont|fffd|m uma configura|fffd||fffd|o v|fffd|lida!", "This paper line hasn't a valid configuration!"), 1, sAddInCaptByApp & IIf(IsPortg, " - Valor Inv|fffd|lido", " - Invalid Value"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop
    Else
        lBotPress = 2
        dbElapsed = lPartInt + lPartFrc / 10 ^ Len(lPartFrc) * Choose(i + 1, 1, 1, 1, 60, 3600)    'lPartFrc / 100
        dbStart = GetTickCount() / 1000 - dbElapsed
        ScrollBarMode = i
        ScrollBarDecimal = Len(lPartFrc)
    End If
    TbVisorFnd.SetFocus
    ScrollBarPapel.SetFocus
    TbVisorFnd.SetFocus
End Sub

Private Sub LabelLedPapel_Click()
    Dim i As Double
    Dim oCtrl As Object
    i = IIf(TbVisor.Top < 20, 95, -95)
    For Each oCtrl In Controls
        oCtrl.Top = oCtrl.Top + i
    Next
    If i > 0 Then
        Top = Top - i
        Height = Height + i * Twips
    Else
        Height = Height + i * Twips
        Top = Top - i
    End If
    lastFormWidth = Width: lastFormHeight = Height    'Consolida novo size do form para evitar que seja tida como altera|fffd||fffd|o externa pelas bordas em FormAdjust
    bPaperRibbon = TbVisor.Top > 20
    Leds
    ScrollBarPapel.Value = UBound(FitaPapel())
    WriteINISetting1
End Sub

Sub Leds()
    LabelLedPapel.ControlTipText = IIf(TbVisor.Top > 20, IIf(IsPortg, "Ocultar papel", "Hide paper"), IIf(IsPortg, "Exibir papel", "Show paper"))
    LabelLedImp.ControlTipText = IIf(TbVisor.Top > 20, IIf(IsPortg, "Imprimir papel", "Print paper"), "")
    LabelLedImp.Enabled = TbVisor.Top > 20
    LabelLedImp.MousePointer = IIf(TbVisor.Top > 20, fmMousePointerCustom, fmMousePointerDefault)
End Sub

Private Sub LbColar_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbColar.SpecialEffect = fmSpecialEffectSunken: End Sub
Private Sub LbColar_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbColar.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbCopiar_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbCopiar.SpecialEffect = fmSpecialEffectSunken: End Sub
Private Sub LbCopiar_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbCopiar.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbStopIns_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbStopIns.SpecialEffect = fmSpecialEffectSunken: xLbStopIns_Click lStopInsMode: End Sub
Private Sub LbStopIns_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbStopIns.SpecialEffect = fmSpecialEffectEtched: End Sub

Private Sub LbSet_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSet.SpecialEffect = fmSpecialEffectSunken: xLbSet_Click lResetMode: End Sub
Private Sub LbSet_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSet.SpecialEffect = fmSpecialEffectEtched: End Sub

Private Sub LbStartStop_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbStartStop.SpecialEffect = fmSpecialEffectSunken: xLbStartStop_Click: End Sub
Private Sub LbStartStop_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbStartStop.SpecialEffect = fmSpecialEffectEtched: End Sub

Private Sub LbCntDown_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbCntDown.SpecialEffect = fmSpecialEffectSunken: End Sub
Private Sub LbCntDown_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbCntDown.SpecialEffect = fmSpecialEffectEtched: End Sub


'===============================================================
Sub xLbSet_Click(lResetMode1 As Long, Optional CalledFromMult As Boolean = False, Optional lTickCountMultFix1 As Long, Optional dTime As Date)
'Se o bot|fffd|o estiver attached em multiple, procura outra instancia na mesma situa|fffd||fffd|o e acionar
    If bMultResetAttach And Not CalledFromMult And CollectionInst.Count > 1 And Not bCntDown Then xLbSet_ClickMult lResetMode1: Exit Sub    'If Not bCntDown And CollectionInst.Count > 1 And bMultResetAttach Then LbSet_ClickMult: Exit Sub

    If lResetMode = 4 Then Exit Sub
    If bSndAtReset And Not bSndDisableAll Then Call sndPlaySound32(sWavSndAtReset, &H1)
    If lResetMode1 = 3 Then xLbStopIns_Click 3, CalledFromMult, lTickCountMultFix1, dTime  'Insere antes de Reset.
    lBotPress = 0    'Flag to reset in the loop
    bCntDown = False
    If Not UserFormCntDown1 Is Nothing Then Unload UserFormCntDown1: Set UserFormCntDown1 = Nothing
    If CalledFromMult Then lTickCountMultFix = lTickCountMultFix1: LoopAPI: lTickCountMultFix = 0    'Em loop de mult, reLoopAPI em cada form para sincronizar todos no mesmo TickCount fixado.
    PrintPapel dbElapsed, IIf(CalledFromMult, dTime, Now), LbSet.Caption, "", TbVisor.Value & TbVisorFrc.Value
    'If lResetMode1 = 2 Or lResetMode1 = 3 Then MyWait 0.1: xLbStartStop_Click    'Restart, o MyWait |fffd| para o loop antes realizar o flag do reset
    If lResetMode1 = 2 Or lResetMode1 = 3 Then
        If CalledFromMult Then lTickCountMultFix = lTickCountMultFix1     'Em loop de mult, reLoopAPI em cada form para sincronizar todos no mesmo TickCount fixado.
        LoopAPI    'Restart, para o loop antes realizar o flag do reset antes de reiniciar
        lTickCountMultFix = 0
        xLbStartStop_Click CalledFromMult, lTickCountMultFix1, dTime
    End If
End Sub

Public Sub xLbStartStop_Click(Optional CalledFromMult As Boolean = False, Optional lTickCountMultFix1 As Long, Optional dTime As Date)
'Se o bot|fffd|o estiver attached em multiple, procura outra instancia na mesma situa|fffd||fffd|o e acionar
    If Not CalledFromMult And CollectionInst.Count > 1 And Not bCntDown Then
        If (bMultStartAttach And lBotPress = 0) Or _
           (bMultStopAttach And lBotPress = 1) Or _
           (bMultRestartAttach And lBotPress = 2) Then xLbStartStop_ClickMult lBotPress: Exit Sub

        If (bMultStartStopsAttach And lBotPress = 0) Or _
           (bMultRestartStopsAttach And lBotPress = 2) Or _
           (bMultStartStopInssAttach And lBotPress = 0) Or _
           (bMultRestartStopInssAttach And lBotPress = 2) Then xLbStartStop_ClickMult lBotPress, sCountInstAdd: Exit Sub
    End If

    If lBotPress = 0 Or lBotPress = 2 Then
        If bCntDown Then
            dbStart = GetTickCount() / 1000 + dbElapsed
        Else
            dbStart = IIf(CalledFromMult, lTickCountMultFix1, GetTickCount()) / 1000 - dbElapsed
        End If
        If lBotPress = 0 And bSndAtStart And Not bSndDisableAll Then Call sndPlaySound32(sWavSndAtStart, &H1)
        If lBotPress = 2 And bSndAtRestart And Not bSndDisableAll Then Call sndPlaySound32(sWavSndAtRestart, &H1)
        lBotPress = 1
    Else
        If bSndAtStop And Not bSndDisableAll Then Call sndPlaySound32(sWavSndAtStop, &H1)
        lBotPress = 2
    End If
    PrintPapel dbElapsed, IIf(CalledFromMult, dTime, Now), LTrim(LbStartStop.Caption), "", TbVisor.Value & TbVisorFrc.Value
    If lBotPress = 1 And bSplit And lSnapshotNumb > 0 Then On Error Resume Next: If ActiveControl.Name Like "Snapshot*_Tb" Then TbVisorFnd.SetFocus    'Ao iniciar ou reiniciar em split remove foco em Snapshot*_Tb, pois gera erro na se|fffd||fffd|o 'Snapshot1_Tb width de ShowUserNotesCtrls. Foi impl. na vers|fffd|o 4.0 que n|fffd|o permite editar snapshot label rodando.
End Sub

Public Sub xLbStopIns_Click(lStopInsMode1 As Long, Optional CalledFromMult As Boolean = False, Optional lTickCountMultFix1 As Long, Optional dTime As Date, Optional bInsActCelStart1 As Boolean)
'Se o bot|fffd|o estiver attached em multiple, procura outra instancia na mesma situa|fffd||fffd|o e acionar
    If bMultStopInsAttach And Not CalledFromMult And CollectionInst.Count > 1 Then xLbStopIns_ClickMult lStopInsMode1: Exit Sub

    If lStopInsMode1 = 6 Then Exit Sub Else dTime = IIf(CalledFromMult, dTime, Now): bInsActCelStart1 = IIf(CalledFromMult, bInsActCelStart1, bInsActCelStart)
    If bSndAtStopIns And Not bSndDisableAll Then Call sndPlaySound32(sWavSndAtStopIns, &H1)
    If CalledFromMult Then lTickCountMultFix = lTickCountMultFix1: LoopAPI: lTickCountMultFix = 0    'Em loop de mult, reLoopAPI em cada form para sincronizar todos no mesmo TickCount fixado.
    PrintPapel dbElapsed, dTime, LbStopInsCapt(lStopInsMode1), "", TbVisor.Value & TbVisorFrc.Value
    Dim dbElapsed1 As Double: dbElapsed1 = dbElapsed    'Na vers|fffd|o 4.0 precisa guardar para inserir devido ao reset.
    Select Case lStopInsMode1
    Case 1    'StpInsCls - Stop, insere and close (Old mode and default)
        lBotPress = 3
        If lWaitAndRetValue > 0 Then Exit Sub    'Retorna o valor pelo c|fffd|digo que deve estar em espera
    Case 2, 3   'StopInsRst - Stop, insert current dbElapsed here stored in em dbElapsed1 and reset without close...
        xLbSet_Click 1, CalledFromMult, lTickCountMultFix1, dTime: LoopAPI
        If lStopInsMode1 = 3 Then xLbStartStop_Click CalledFromMult, lTickCountMultFix1, dTime    '... and start
    Case 4    'StopIns - Stop and insert current dbElapsed1 here without close
        If Not (lBotPress = 0 Or lBotPress = 2) Then xLbStartStop_Click CalledFromMult, lTickCountMultFix1, dTime   'Se j|fffd| tiver parado s|fffd| insere
    Case 5    'Insert - Insert current dbElapsed1 here without stop
    End Select
    On Error Resume Next
    Dim rngOldSplit As Range    'Para evitar que um StopIns or ResetI destrua algum log de split, ser|fffd| verificado antes de inserir
    If bInsActCelStart1 And Not rngActCelStart Is Nothing Then Set rngOldSplit = rngActCelStart Else Set rngOldSplit = appHostApp.ActiveWindow.ActiveCell
    If bSplit And (lStopInsMode1 >= 2 And lStopInsMode1 <= 5) Then If shSplit.Name = rngOldSplit.Parent.Name And wbSplit.Name = rngOldSplit.Parent.Parent.Name Then If LookForOldSplit(rngOldSplit) Then Exit Sub

    Dim ActCelToIns As Range, bIsEmpty As Boolean, i As Long
    If bInsActCelStart1 And Not rngActCelStart Is Nothing Then Set ActCelToIns = rngActCelStart Else Set ActCelToIns = appHostApp.ActiveWindow.ActiveCell
    bIsEmpty = (Len(ActCelToIns.Value) = 0)

    Msg2 = IIf(IsPortg, "O tempo ", "The time ") & TbVisor.Value & TbVisorFrc.Value & IIf(IsPortg, " n|fffd|o foi inserido.", " wasn't inserted.")
    If lInsOvrCnts >= 3 And bIsEmpty And (ActCelToIns.Parent.ProtectContents And ActCelToIns.Locked) Then bIsEmpty = False    'Se for procurar permiss|fffd|vel e estiver vazia, mas protegida, considera n|fffd|o vazia.
    If bIsEmpty Or lInsOvrCnts = 1 Or bFromAutoPopCell Then    'Overwrite in silence
        bIsEmpty = True
    ElseIf lInsOvrCnts = 2 Then    'Ask to overwrite.
        Msg1 = IIf(IsPortg, " conte|fffd|do na c|fffd|lula e voc|fffd| configurou para n|fffd|o subscrever!", " contents in cell and you set to not overwrite!")
        Err.Raise vbObjectError + 1, Msg1, Msg2
    ElseIf lInsOvrCnts >= 3 Then   'Arrows
        Msg1 = IIf(IsPortg, " por procurar c|fffd|lula al|fffd|m do limite da planilha!", " looking for cell beyond the sheet limit!")
        Do
            i = i + IIf(lInsOvrCnts = 3 Or lInsOvrCnts = 4, 1, -1)
            If (lInsOvrCnts = 3 And ActCelToIns.Row + i > 65536) _
               Or (lInsOvrCnts = 4 And ActCelToIns.Column + i > 256) _
               Or (lInsOvrCnts = 5 And ActCelToIns.Row + i = 0) _
               Or (lInsOvrCnts = 6 And ActCelToIns.Column + i = 0) _
               Then Err.Raise vbObjectError + 2, Msg1, Msg2: bIsEmpty = False: Exit Do
            If lInsOvrCnts = 3 Or lInsOvrCnts = 5 Then    'Procura na coluna down, up.
                If Len(ActCelToIns.Offset(i, 0).Value) = 0 And (Not ActCelToIns.Parent.ProtectContents _
                                                                Or (ActCelToIns.Parent.ProtectContents And Not ActCelToIns.Offset(i, 0).Locked)) Then
                    Set ActCelToIns = ActCelToIns.Offset(i, 0): bIsEmpty = True: Exit Do
                End If
            End If
            If lInsOvrCnts = 4 Or lInsOvrCnts = 6 Then    'Procura na linha left, right.
                If Len(ActCelToIns.Offset(0, i).Value) = 0 And (Not ActCelToIns.Parent.ProtectContents _
                                                                Or (ActCelToIns.Parent.ProtectContents And Not ActCelToIns.Offset(0, i).Locked)) Then
                    Set ActCelToIns = ActCelToIns.Offset(0, i): bIsEmpty = True: Exit Do
                End If
            End If
        Loop
    End If

    If bIsEmpty Then Err.Clear: ActCelToIns.Value = CDbl(dbElapsed1 / 24 / 60 / 60)
    If Err.Number <> 0 Then
        MyMsgBox IIf(IsPortg, "Erro", "Error") & " # " & Str(Err.Number) & IIf(IsPortg, " foi gerado por ", " was generated by ") & Err.Source & Chr(13) & Err.Description, 1, sAddInCaptByApp, , Left + 3, Top + 21 + 3, Form_hWnd, 0, bAlwaysOnTop
    Else
        'Se c|fffd|lula sem formato e estava vazia, formata agora silenciosamente como tempo seguindo padr|fffd|o do Excel de formatar automaticamente.
        If ActCelToIns.NumberFormat = "General" And bIsEmpty Then ActCelToIns.NumberFormat = Choose(lMode, "d  hh:mm:ss", "[h]:mm:ss", "[m]:ss", "[ss]", "#,##0", "#,##0", "#,##0", "#,##0", "#,##0", "#,##0") & IIf(lNumDecim = 0, "", "." & String(lNumDecim, "0"))

        'Ap|fffd|s inserir com sucesso, insere tamb|fffd|m data e hora do evento.
        If lInsAlsoDTime = 2 Then
            If lInsOvrCnts >= 3 And Not ActCelToIns.Comment Is Nothing Then Exit Sub    'Se tiver inserindo pr|fffd|xima vazia |fffd| melhor preservar coment|fffd|rio existente.
            If ActCelToIns.Comment Is Nothing Then ActCelToIns.AddComment CStr(dTime) Else ActCelToIns.Comment.Text CStr(dTime)
        ElseIf lInsAlsoDTime > 2 Then
            Set ActCelToIns = ActCelToIns.Offset(Choose(lInsAlsoDTime - 2, 0, 0, 1, -1), Choose(lInsAlsoDTime - 2, 1, -1, 0, 0))
            bIsEmpty = (Len(ActCelToIns.Value) = 0)
            If lInsOvrCnts >= 3 And Not bIsEmpty Then Exit Sub    'Se tiver inserindo pr|fffd|xima vazia |fffd| melhor preservar pr|fffd|ximas n|fffd|o vazias.
            ActCelToIns.Value = CDbl(dTime)
            If ActCelToIns.NumberFormat = "General" And bIsEmpty And Err.Number = 0 Then ActCelToIns.NumberFormat = "hh:mm:ss" & IIf(appHostApp.International(xl24HourClock), "", " AM/PM")
        End If
    End If
End Sub

Private Sub LbSplit_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSplit.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 0: End Sub
Private Sub LbSplit_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSplit.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot1.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 1: End Sub
Private Sub LbSnapshot1_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot1.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot2_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot2.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 2: End Sub
Private Sub LbSnapshot2_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot2.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot3_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot3.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 3: End Sub
Private Sub LbSnapshot3_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot3.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot4_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot4.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 4: End Sub
Private Sub LbSnapshot4_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot4.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot5_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot5.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 5: End Sub
Private Sub LbSnapshot5_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot5.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot6_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot6.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 6: End Sub
Private Sub LbSnapshot6_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot6.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot7_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot7.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 7: End Sub
Private Sub LbSnapshot7_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot7.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot8_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot8.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 8: End Sub
Private Sub LbSnapshot8_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot8.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot9_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot9.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 9: End Sub
Private Sub LbSnapshot9_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot9.SpecialEffect = fmSpecialEffectEtched: End Sub
Private Sub LbSnapshot10_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot10.SpecialEffect = fmSpecialEffectSunken: xLbSplit_Click 10: End Sub
Private Sub LbSnapshot10_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): LbSnapshot10.SpecialEffect = fmSpecialEffectEtched: End Sub
Public Sub xLbSplit_Click(Optional Lb As Long)
    If bSplit = False Then
        If Not shSplit Is Nothing And bActSplitShAtSplit Then shSplit.Activate
        ShowUserNotesCtrls
        lastFormWidth = Width: lastFormHeight = Height    'Consolida novo size do form para evitar que seja tida como altera|fffd||fffd|o externa pelas bordas em FormAdjust
    End If
    If bSplit And lBotPress <> 1 Then Exit Sub    'Se j|fffd| split e parada, desabilita sem desvanecer bot|fffd|o j|fffd| Snapshot. Sua a|fffd||fffd|o e log n|fffd|o parece |fffd|til, inclusive gera lap 0 no exemplo 2 de motocross. Isso foi impl. na vers|fffd|o 4.0
    bSplit = True
    LbSplit.Caption = IIf(IsPortg, "Instt|fffd|neo", "Snapshot"): LbSetUpt    'LbSetUpt aqui para atualizar pois nunca insere em Split
    LbSplit.BackColor = &HFFFFFF
    Dim sEvent As String
    Dim sLabel As String

    If Lb = 0 Then
        sEvent = LbSplit.Caption
        sLabel = ""
        If bSndAtSnapshot And Not bSndDisableAll And Not dbElapsed = 0 Then Call sndPlaySound32(sWavSndAtSnapshot, &H1)    'Se ainda zero, n|fffd|o h|fffd| registro de snapshoe apenas insere cabe|fffd|alho
    Else
        sEvent = IIf(IsPortg, "Instt|fffd|neo ", "Snapshot ") & Lb    'Controls("LbSnapshot" & Lb).Caption
        sLabel = Controls("Snapshot" & Lb & "_Tb").Text
        If Len(sLabel) = 0 Then sLabel = CStr(Lb) & IIf(sCountInstAdd = "1", "", IIf(IsPortg, " em Cron|fffd|metro", " in Stopwatch") & sCountInstAdd)
        If arrbSndAtSnpshtLb(Lb) And Not bSndDisableAll And Not dbElapsed = 0 Then Call sndPlaySound32(arrsWavSndAtSnpshtLb(Lb), &H1)
    End If

    If Visible Then PrintPapel dbElapsed, Now, sEvent, sLabel, TbVisor.Value & TbVisorFrc.Value    'Regist snapshot no split de popup, form oculta, |fffd| desnecess|fffd|rio, pois |fffd| igual ao reg. do popup logo a frente
    bUserNoteUpd = False
    'TbVisorFnd.SetFocus
End Sub

Private Sub LbDispPickCback_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xPickColor_Click LbDispPickCback, True, 0: End Sub
Private Sub LbSnpshtPickCback1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xPickColor_Click LbSnpshtPickCback1, True, lActSnapshotTb: End Sub
Private Sub LbDispPickCfore_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xPickColor_Click LbDispPickCfore, False, 0: End Sub
Private Sub LbSnpshtPickCfore1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xPickColor_Click LbSnpshtPickCfore1, False, lActSnapshotTb: End Sub
Private Sub xPickColor_Click(CtrlBt As Object, bBackground As Boolean, Lb As Long)   'As Control d|fffd| erro em COM add-in
    Dim CtrlTb As Object
    If Lb = 0 Then
        Set CtrlTb = TbVisor
    Else
        Set CtrlTb = Controls("Snapshot" & Lb & "_Tb")
        arrSnpshtLb(Lb) = CtrlTb.Text    'Preservar o digitado ainda n|fffd|o consolidado no exit
    End If

    'On Error Resume Next 'Algumas vezes d|fffd| erro, talvez fosse pelo negativo ao definir cores padr|fffd|o do sistema (Removi padr|fffd|o em tudo)
    CtrlBt.SpecialEffect = fmSpecialEffectSunken: MyWait 0.3
    If bBackground Then
        arrBackColor(Lb) = PickColor(CtrlTb.BackColor, Form_hWnd)
        If arrBackColor(Lb) <> CtrlTb.BackColor Then
            arrForeColor(Lb) = Not (arrBackColor(Lb) Xor &HFF000000)              'Tenta o inverso autom|fffd|ticamente, o usu|fffd|rio altera se quiser
            WriteINISetting1
        End If
    Else
        arrForeColor(Lb) = PickColor(CtrlTb.ForeColor, Form_hWnd)
        If arrForeColor(Lb) <> CtrlTb.ForeColor Then
            WriteINISetting1
        End If
    End If
    UpdtCtrlColors
    CtrlBt.SpecialEffect = fmSpecialEffectFlat
End Sub

Private Sub LbDispPickCrestore_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xColorRestore_Click LbDispPickCrestore, 0: End Sub
Private Sub LbSnpshtPickCrestore_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xColorRestore_Click LbSnpshtPickCrestore, lActSnapshotTb: End Sub
Private Sub xColorRestore_Click(CtrlBt As Object, Lb As Long)
    CtrlBt.SpecialEffect = fmSpecialEffectSunken: MyWait 0.3

    If Lb = 0 Then
        If MyMsgBox(IIf(IsPortg, "Restaurar as cores padr|fffd|o do visor?", "Restore display default colors?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
            arrBackColor(0) = &H8000&
            arrForeColor(0) = &HFFFF00
            UpdtCtrlColors
            WriteINISetting1
        End If
        If MyMsgBox(IIf(IsPortg, "Restaurar os tamanhos padr|fffd|o do visor e do painel de bot|fffd|es?", "Restore display and panel of buttons default sizes?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
            lDispSize = 26
            lCtrlPanelSize = 10
            'Update controles with new setting
            vEnableEvents = False
            ScrollBarCtrlPanel.Value = lCtrlPanelSize
            ScrollBarSize.Value = lDispSize
            vEnableEvents = True
            WriteINISetting1
        End If

        If MyMsgBox(IIf(IsPortg, "Restaurar as configura|fffd||fffd|es padr|fffd|o de face?", "Restore skin default settings?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
            lClickOnDisplay = 0
            bEnableBackgrond = False
            bHideTitleBar = True
            bAutoHideCtrlPanel = False
            SkinSettingUpt
            WriteINISetting1
        End If
    Else
        If MyMsgBox(IIf(IsPortg, "Restaurar as cores padr|fffd|o do r|fffd|tulo de snapshot " & Lb & "?", "Restore label default colors of snapshot " & Lb & "?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
            arrBackColor(Lb) = &HFFFFFF
            arrForeColor(Lb) = &H0&
            UpdtCtrlColors
            WriteINISetting1
        End If
    End If
    CtrlBt.SpecialEffect = fmSpecialEffectFlat
End Sub

Private Sub LbSnpshtSound_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLbSnpshtSound_Click LbSnpshtSound, lActSnapshotTb: End Sub
Private Sub xLbSnpshtSound_Click(CtrlBt As Object, Lb As Long)
    CtrlBt.SpecialEffect = fmSpecialEffectSunken: MyWait 0.3
    If bSndDisableAll Then
        Msg1 = IIf(IsPortg, "Todos os sons est|fffd|o desabilitados! Use o Menu para habilitar.", _
                   "All sounds are disable! Use the Menu to enable.")
        Msg2 = IIf(IsPortg, "Som Ao Instant|fffd|neo", "Sound At Snapshot") & Lb
        MyMsgBox Msg1, 1, Msg2, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop
    Else
        SetSounds Lb + 10
    End If
    CtrlBt.SpecialEffect = fmSpecialEffectFlat
End Sub

Private Sub UpdtCtrlColors()
    TbVisor.BackColor = arrBackColor(0)
    TbVisorFrc.BackColor = arrBackColor(0)
    TbVisorFnd.BackColor = arrBackColor(0)
    LabelMode.BackColor = arrBackColor(0)
    LabelDecimal.BackColor = arrBackColor(0)

    TbVisor.ForeColor = arrForeColor(0)
    TbVisorFrc.ForeColor = arrForeColor(0)
    TbVisorFnd.ForeColor = arrForeColor(0)
    LabelMode.ForeColor = arrForeColor(0)
    LabelDecimal.ForeColor = arrForeColor(0)

    Dim lCtrl As Long
    For lCtrl = 1 To 10
        Controls("Snapshot" & lCtrl & "_Tb").Text = arrSnpshtLb(lCtrl)    'Snapshot1_Tb.Text = arrSnpshtLb(1) 'Aproveita o loop
        Controls("Snapshot" & lCtrl & "_Tb").BackColor = arrBackColor(lCtrl)    'Snapshot1_Tb.BackColor = arrBackColor(1)
        Controls("Snapshot" & lCtrl & "_Tb").ForeColor = arrForeColor(lCtrl)    'Snapshot1_Tb.ForeColor = arrForeColor(1)
        Controls("LbSnapshot" & lCtrl).BackColor = arrBackColor(lCtrl)     'LbSnapshot1.BackColor = arrBackColor(1)
        Controls("LbSnapshot" & lCtrl).ForeColor = arrForeColor(lCtrl)    'LbSnapshot1.ForeColor = arrForeColor(1)
        If bCallBYfStopwatch Then If Len(Controls("Snapshot" & lCtrl & "_Tb").Text) > 0 Then Controls("Snapshot" & lCtrl & "_Tb").Locked = True    'Se veio label por fStopwatch como exemplo 3 de motogross, |fffd| melhor travar, pois s|fffd|o chave de procura.
    Next
End Sub

Public Sub Cancel_Bt_Click()
    lBotPress = 4
    PrintPapel dbElapsed, Now, IIf(IsPortg, "Cancelar", "Cancel"), "", TbVisor.Value & TbVisorFrc.Value
End Sub
Private Sub Cancel_Bt_ClickQ()    'Melhora a chamada de Cancel_Bt_Click para questionar se fecha todas.
    If CollectionInst.Count > 1 And ShiftDown Then
        Cancel_Bt_ClickMult True
    ElseIf CollectionInst.Count > 1 And bCallBYfStopwatch And bMultStartAttach And Not bMultStopAttach And Not bMultRestartAttach Then     'Se iniciado by code and atado somente no Start, fecha tudo sem questionar.
        Cancel_Bt_ClickMult True
    ElseIf CollectionInst.Count > 2 And (bMultStartAttach Or bMultStopAttach Or bMultRestartAttach Or bMultResetAttach Or bMultStopInsAttach Or bMultStartStopsAttach Or bMultRestartStopsAttach Or bMultStartStopInssAttach Or bMultRestartStopInssAttach) Then
        MyMsgBox IIf(IsPortg, "Fechar todas as " & CollectionInst.Count & " inst|fffd|ncias abertas?  (Dica! Tecla Shift baixa, fecha todas sem questionar.", _
                     "Close all " & CollectionInst.Count & " open instances?  (Tip! Shift key down, close all without question.)"), 3, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop
        If BotAcionado = 1 Then Cancel_Bt_ClickMult True Else If BotAcionado = 2 Then Cancel_Bt_Click
    Else
        Cancel_Bt_Click
    End If
End Sub

Private Sub Close_Lb_Click()
    If sIgnClickIfDrag = Close_Lb.Name Then   'Ignorar click se houver arrasto do form por este controle
        sIgnClickIfDrag = ""
        Exit Sub
    End If

    Cancel_Bt_ClickQ    'Cancel_Bt_Click
End Sub

Private Sub TbVisorFrontTransp_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, TbVisorFrontTransp: End Sub
Private Sub LabelMode_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, LabelMode: End Sub
Private Sub LabelDecimal_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, LabelDecimal: End Sub
Private Sub UserNote_Lb_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, UserNote_Lb: End Sub
Private Sub SnapshotLabels_Lb_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, SnapshotLabels_Lb: End Sub
Private Sub CtrlPanelShow_Lb_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, CtrlPanelShow_Lb: End Sub
Private Sub Menu_Lb_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, Menu_Lb: End Sub
Private Sub Close_Lb_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseDown Button, Shift, X, Y, Close_Lb: End Sub
Private Sub xLb_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single, Ctrl As Object)     'As Control d|fffd| erro em COM add-in)
    Xini = X    'When a button is down, store initial mouse position
    Yini = Y
    LeftIni = Left    'When a button is down, store initial form position
    TopIni = Top
    If Button = 2 Then    'When right mouse button down
        If Ctrl.Name = "TbVisorFrontTransp" And lClickOnDisplay <> 0 Then
            TbVisorFrontTransp_Click  'Age como Click ignoran right click menu
        ElseIf Ctrl.Name = "IrAgora_Lb" Then
        Else
            Menu_Lb_Click    'Show menu when right mouse button down
        End If
    End If
End Sub

Private Sub TbVisorFrontTransp_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, TbVisorFrontTransp: End Sub
Private Sub LabelMode_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, LabelMode: End Sub
Private Sub LabelDecimal_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, LabelDecimal: End Sub
Private Sub UserNote_Lb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, UserNote_Lb: End Sub
Private Sub SnapshotLabels_Lb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, SnapshotLabels_Lb: End Sub
Private Sub CtrlPanelShow_Lb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, CtrlPanelShow_Lb: End Sub
Private Sub Menu_Lb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, Menu_Lb: End Sub
Private Sub Close_Lb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single): xLb_MouseMove Button, Shift, X, Y, Close_Lb: End Sub
Private Sub xLb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single, Ctrl As Object)    'As Control d|fffd| erro em COM add-in
    If Abs(TbVisorFnd.Top - TbVisor.Top) > 10 Or (((lOtherButtsMode And 1) = 1 Or (lOtherButtsMode And 2) = 2) And X > LbStartStop.Left And X < LbStartStop.Left + LbStartStop.Width And Y > LbStartStop.Top And Y < LbStartStop.Top + LbStartStop.Height) Then Exit Sub     'Ignora MouseMove com o form ainda n|fffd|o organizado no inicio e sobre LbStartStop quando pode ser ocultado ao ser clicado provocando deslocamento do form.
    If Button = 1 Then   'Move form if left mouse button is down
        Left = Left + (X - Xini)
        Top = Top + (Y - Yini)
        If Abs(Left - LeftIni) > 4 Or Abs(Top - TopIni) > 4 Then sIgnClickIfDrag = Ctrl.Name
        SizeFormRestLast
    End If
End Sub

Private Sub ScrollBarDecimal_Change()
    lNumDecim = ScrollBarDecimal.Max - ScrollBarDecimal.Value    'Subtrai do Max para inverter seta
    LabelDecimal.Caption = IIf(lNumDecim = 5, "F", lNumDecim)
    If vEnableEvents = False Then Exit Sub
    WriteINISetting1
    TbVisorFnd.SetFocus
    ScrollBarDecimal.SetFocus
    TbVisorFnd.SetFocus
End Sub

Private Sub ScrollBarMode_Change()
    lMode = ScrollBarMode.Value
    If IsPortg Then
        LabelMode.Caption = Choose(lMode, "d  hh : mm : ss", "h : mm : ss", "m : ss", "Segundos", "Minutos", "Horas", "Dias", "Semanas", "Meses", "Anos")
    Else
        LabelMode.Caption = Choose(lMode, "d  hh : mm : ss", "h : mm : ss", "m : ss", "Seconds", "Minutes", "Hours", "Days", "Weeks", "Months", "Years")
    End If
    If vEnableEvents = False Then Exit Sub
    WriteINISetting1
    TbVisorFnd.SetFocus
    ScrollBarMode.SetFocus
    TbVisorFnd.SetFocus
End Sub

Private Sub ScrollBarSnapshotNumb_Change()
    lSnapshotNumb = ScrollBarSnapshotNumb.Value
    If vEnableEvents = False Then Exit Sub
    WriteINISetting1
    TbVisorFnd.SetFocus
    ScrollBarSnapshotNumb.SetFocus
    TbVisorFnd.SetFocus
End Sub

Private Sub ActSplitSheet_ChB_Click()
    If vEnableEvents = False Then Exit Sub
    On Error Resume Next
    If ActSplitSheet_ChB.Value = False Then
        ActShAtPopup.Activate
    Else
        shSplit.Activate
        If Err.Number = 0 Then    'Para evitar que inclus|fffd|o acidental destrua dados. Vai para o fim do log ou c|fffd|lula em branco
            Dim rngOldSplit As Range: Set rngOldSplit = appHostApp.ActiveWindow.ActiveCell
            If LookForOldSplit(rngOldSplit) Then rngOldSplit.Offset(2, 7 - 2).Select
            Do While appHostApp.ActiveWindow.ActiveCell.Value <> Empty Or appHostApp.ActiveWindow.ActiveCell.Offset(-1, 0).Value <> Empty
                appHostApp.ActiveWindow.ActiveCell.Offset(1, 0).Select
            Loop
        End If
    End If
End Sub

Sub SplitLog(ByVal dbElapsed1 As Double, ByVal sTime As Date, sEvent As String, sLabel As String)
    Dim w As Window
    Dim i As Long
    Dim NewSplit As Range

    'Verificar se est|fffd| sobre um split anterior para continuar. Se tiver contanto |fffd| melhor n|fffd|o interferir com alerta e split em padr|fffd|o.
    If sSplitStartCellRef = "" And lBotPress <> 1 Then   'Desde que n|fffd|o trabalhe com CurrentRegion sSplitStartCellRef pode ser a |fffd|ltima linha encontrada possibilitando altera|fffd||fffd|o do cabe|fffd|alho e split no meio de outros dados de um relat|fffd|rio.
        Dim bIsOldSplit As Boolean, rngOldSplit As Range, OldSplitElapsedIni As Variant, bNegatSign As Boolean
        Set rngOldSplit = appHostApp.ActiveWindow.ActiveCell
        bIsOldSplit = LookForOldSplit(rngOldSplit)
        If bIsOldSplit Then OldSplitElapsedIni = rngOldSplit.Offset(0, -1).Value
        If bIsOldSplit Then bIsOldSplit = IsTimeExtend(OldSplitElapsedIni, OldSplitElapsedIni, bNegatSign)
        If bIsOldSplit Then
            Set shSplit = appHostApp.ActiveWindow.ActiveSheet: Set wbSplit = appHostApp.ActiveWorkbook   'J|fffd| define provisoriamente, pois a API pode chamar o LoopAPI durante o MyMsgbox com bSplit j|fffd| True.
            LbSplit.SpecialEffect = fmSpecialEffectEtched
            bIsOldSplit = MyMsgBox(IIf(IsPortg, "A c|fffd|lula ativa est|fffd| sobre o registro de uma divis|fffd|o anterior, reiniciar este registro. OK?", "The active cell is on the log of a earlier split, restart this log. OK?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1
            If bIsOldSplit Then
                sSplitStartCellRef = rngOldSplit.Offset(-i, -2).Address(False, False)
                lBotPress = 2: dbElapsed = OldSplitElapsedIni: LoopAPI: bCntDown = bNegatSign   'Poe em modo restart com o |fffd|ltimo time captado.
                Exit Sub
            Else
                Set shSplit = Nothing: Set wbSplit = Nothing
            End If
        End If
    End If

    'Verificar se est|fffd| sobre um split anterior vazio para compartilhar com outras inst|fffd|ncia j|fffd| rodando. |fffd|til para mais de 10 snapshot labels em um mesmo log.
    If sSplitStartCellRef = "" And lBotPress <> 1 Then
        Set rngOldSplit = appHostApp.ActiveWindow.ActiveCell
        bIsOldSplit = LookForBlankSplit(rngOldSplit)
        If bIsOldSplit Then
            Set shSplit = appHostApp.ActiveWindow.ActiveSheet: Set wbSplit = appHostApp.ActiveWorkbook   'J|fffd| define provisoriamente, pois a API pode chamar o LoopAPI durante o MyMsgbox com bSplit j|fffd| True.
            LbSplit.SpecialEffect = fmSpecialEffectEtched
            bIsOldSplit = MyMsgBox(IIf(IsPortg, "A c|fffd|lula ativa est|fffd| sobre o registro de uma divis|fffd|o em branco criada por outra inst|fffd|ncia, compartilhar este registro. OK?", "The active cell is on the log of a blank split created by another instance, share this log. OK?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1
            If bIsOldSplit And Not bMultStartAttach Then bIsOldSplit = MyMsgBox(IIf(IsPortg, "Para que duas ou mais inst|fffd|ncias compartilhem um mesmo registro de divis|fffd|o de tempo, |fffd| importante que seus bot|fffd|es Iniciar, Parar e Reiniciar estejam atados. Pelo menos o bot|fffd|o Iniciar |fffd| obrigat|fffd|rio!", "In order for two or more instances share the same split log, it is important that their buttons Start, Stop and Restart are attached. At least the Start button is required!"), 1, sAddInCaptByApp & IIf(IsPortg, " - Requer Bot|fffd|es Atados!", " - Require Attached Buttons!"), , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2: lBotPress = 4: Exit Sub    'Nestas condi|fffd||fffd|es talvez o menos inconveniente seja fechar a inst|fffd|ncia.
            If bIsOldSplit Then
                sSplitStartCellRef = rngOldSplit.Address(False, False)
                'lBotPress = 0: dbElapsed = 0: LoopAPI: bCntDown = False 'Seria por similaridade ao anterior, mas parece n|fffd|o ser necess|fffd|rio.
                Exit Sub
            Else
                Set shSplit = Nothing: Set wbSplit = Nothing
            End If
        End If
    End If

    'Verificar se h|fffd| room suficiente em branco para pelo menos 25 linhas e questionar se divide na planilha ativa.
    If sSplitStartCellRef = "" And lBotPress <> 1 Then
        If appHostApp.WorksheetFunction.CountBlank(appHostApp.ActiveWindow.ActiveCell.Resize(25, 7 + 1).Cells) = 25 * (7 + 1) Then
            Set shSplit = appHostApp.ActiveWindow.ActiveSheet: Set wbSplit = appHostApp.ActiveWorkbook   'J|fffd| define provisoriamente, pois a API pode chamar o LoopAPI durante o MyMsgbox com bSplit j|fffd| True.
            LbSplit.SpecialEffect = fmSpecialEffectEtched
            If MyMsgBox(IIf(IsPortg, "A c|fffd|lula ativa est|fffd| sobre um intervalo com c|fffd|lulas em branco suficientes para registrar uma divis|fffd|o, registrar a partir da c|fffd|lula ativa. OK?", "The active cell is on a range with sufficient blank cells to a split, log from the active cell. OK?"), 2, sAddInCaptByApp, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 1 Then
                sSplitStartCellRef = appHostApp.ActiveWindow.ActiveCell.Address(False, False)
            Else
                Set shSplit = Nothing: Set wbSplit = Nothing
            End If
        End If
    End If

    If shSplit Is Nothing Then
        For Each w In appHostApp.Windows    'Procura workbook j|fffd| criado hoje
            If w.Caption = IIf(IsPortg, "Cron|fffd|metro", "Stopwatch") & " Log - " & VBA.Format(Now, "yy-mm-dd") Then
                Set wbSplit = w.Parent
                If Not appHostApp.ActiveWindow.ActiveSheet Is Nothing Then Set ActShAtPopup = appHostApp.ActiveWindow.ActiveSheet
                Set shSplit = wbSplit.Sheets.Add(appHostApp.Sheets(1))  'Criar uma nova planilha a cada execu|fffd||fffd|o
                shSplit.Name = VBA.Format(Now, "hh.mm.ss")
                If bActSplitShAtSplit Then shSplit.Activate Else On Error Resume Next: ActShAtPopup.Activate: On Error GoTo 0
                Exit For
            End If
        Next
        If wbSplit Is Nothing Then
            i = appHostApp.SheetsInNewWorkbook
            appHostApp.SheetsInNewWorkbook = 1
            Set wbSplit = appHostApp.Workbooks.Add   '(1)
            appHostApp.SheetsInNewWorkbook = i
            Set shSplit = wbSplit.Sheets(1)
            shSplit.Name = VBA.Format(Now, "hh.mm.ss")
            wbSplit.Windows(1).Caption = IIf(IsPortg, "Cron|fffd|metro", "Stopwatch") & " Log - " & VBA.Format(Now, "yy-mm-dd")
            If bActSplitShAtSplit Then shSplit.Activate Else On Error Resume Next: ActShAtPopup.Activate: On Error GoTo 0
        End If
    End If

    If sSplitStartCellRef = "" Then sSplitStartCellRef = "A1"

    If IsEmpty(shSplit.Range(sSplitStartCellRef)) Then
        Set NewSplit = shSplit.Range(sSplitStartCellRef)
        With NewSplit
            .Offset(0, 0).Value = "Item"
            .Offset(0, 1).Value = IIf(IsPortg, "Tempo", "Time")
            .Offset(0, 2).Value = IIf(IsPortg, "Intervalo", "Gap")
            .Offset(0, 3).Value = IIf(IsPortg, "NoRel|fffd|gio", "AtClock")
            .Offset(0, 4).Value = IIf(IsPortg, "Modo", "Mode")
            .Offset(0, 5).Value = IIf(IsPortg, "Evento", "Event")
            .Offset(0, 6).Value = IIf(IsPortg, "R|fffd|tulo", "Label")
            .Offset(0, 7).Value = IIf(IsPortg, "Notas Usu|fffd|rio", "User Notes")
            Set rngUserNoteLast = .Offset(0, 7)
            With .CurrentRegion
                .Interior.ColorIndex = 15
                .Font.Italic = True
                .Font.Bold = True
                .Columns.AutoFit
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
                .WrapText = True
            End With
            If sSplitStartCellRef <> "A1" Then .Offset(1, 0).Value = IIf(IsPortg, "Nova divis|fffd|o iniciar|fffd| aqui.", "New split will start here.")    'FlagInicial
        End With
        If dbElapsed1 = 0 Then Exit Sub    'Se ainda zero, basta inserir cabe|fffd|alho
    End If

    If sSplitStartCellRef = "A1" Then    'Planilha de split nova padr|fffd|o ent|fffd|o trabalhar com CurrentRegion (Vers|fffd|es antigas)
        Set NewSplit = shSplit.Range(sSplitStartCellRef).CurrentRegion
        Set NewSplit = shSplit.Range(sSplitStartCellRef).Offset(NewSplit.Rows.Count)
    ElseIf shSplit.Range(sSplitStartCellRef).Offset(1, 0).Value = IIf(IsPortg, "Nova divis|fffd|o iniciar|fffd| aqui.", "New split will start here.") Then    'Split novo iniciando em qualquer c|fffd|lula da planilha ativa, ent|fffd|o, depois de sobrescrever o FlagInicial, vai trabalhar como OldSplit procurando a c|fffd|l do |fffd|ltimo split
        Set NewSplit = shSplit.Range(sSplitStartCellRef).Offset(1, 0)
    Else    'Planilha ou range de split antigo, ent|fffd|o trabalhar procurando a c|fffd|l do |fffd|ltimo
        Set rngOldSplit = shSplit.Range(sSplitStartCellRef)
        If Not LookForOldSplit(rngOldSplit) Then Exit Sub
        Set NewSplit = rngOldSplit.Offset(1, -2)
    End If
    dbElapsed1 = IIf(lMode < 5, dbElapsed1 / 24 / 60 / 60, Choose(lMode - 4, dbElapsed1 / 60, dbElapsed1 / 60 / 60, dbElapsed1 / 60 / 60 / 24, dbElapsed1 / 60 / 60 / 24 / 7, dbElapsed1 / 60 / 60 / 24 / 30.5, dbElapsed1 / 60 / 60 / 24 / 365.25))
    With NewSplit
        '.Offset(0, 0).Value = NewSplit.Row - 1
        .Offset(0, 0).FormulaR1C1 = "=IF(ISNUMBER(OFFSET(RC,-1,0)),OFFSET(RC,-1,0),0)+1"
        .Offset(0, 1).Value = dbElapsed1
        '.Offset(0, 2).Value = ABS(dbElapsed1 - IIf(IsNumeric(.Offset(-1, 1).Value), .Offset(-1, 1).Value, 0))
        .Offset(0, 2).FormulaR1C1 = "=ABS(OFFSET(RC,0,-1)-IF(AND(ISNUMBER(OFFSET(RC,-1,-1)),OFFSET(RC,-1,3)<>""" & fGetIntCode(LbSet.Caption) & LbSet.Caption & """),OFFSET(RC,-1,-1),0))"
        .Offset(0, 3).Value = sTime
        .Offset(0, 4).Value = fGetIntCode(bCntDown) & IIf(bCntDown, IIf(IsPortg, "Regressivo", "Countdown"), IIf(IsPortg, "Cron|fffd|metro", "Stopwatch"))
        .Offset(0, 5).Value = fGetIntCode(sEvent) & IIf(Len(sLabel) > 0, IIf(IsPortg, "Instt|fffd|neo", "Snapshot"), sEvent)
        If Len(sLabel) > 0 Then .Offset(0, 6).Value = sLabel

        vEnableEvents = False
        If UserNoteLast_Chb.Value Then
            UserNote_Tb.Text = ""
        Else
            .Offset(0, 7).Value = UserNote_Tb.Text
        End If
        Set rngUserNoteLast = .Offset(0, 7)
        vEnableEvents = True

        '                                         Choose(lMode, "d  hh : mm : ss","h : mm : ss", "m : ss", "Seg", "Min", "Horas","Dias","Semanas","Meses","Anos")
        .Offset(0, 1).Resize(1, 2).NumberFormat = Choose(lMode, "d  hh:mm:ss", "[h]:mm:ss", "[m]:ss", "[ss]", "#,##0", "#,##0", "#,##0", "#,##0", "#,##0", "#,##0") _
                                                & IIf(lNumDecim = 0, "", "." & String(lNumDecim, "0"))
        .Offset(0, 3).NumberFormat = "hh:mm:ss" & IIf(appHostApp.International(xl24HourClock), "", " AM/PM")

        If sEvent <> "Snapshot" Then .Resize(1, 7 + 1).Interior.ColorIndex = _
        -4 * ((sEvent = IIf(IsPortg, "Iniciar", "Start")) Or (sEvent = IIf(IsPortg, "Reiniciar", "Restart"))) _
                                                                             - 45 * ((sEvent = IIf(IsPortg, "Parar", "Stop")) Or (sEvent = IIf(IsPortg, "Expirar", "Expire")) Or (sEvent = IIf(IsPortg, "Cancelar", "Cancel"))) _
                                                                             - 15 * ((sEvent = IIf(IsPortg, "Zerar", "Reset")) Or (sEvent = IIf(IsPortg, "ZerarI", "ResetS")) Or (sEvent = IIf(IsPortg, "ZerarII", "ResetIS"))) _
                                                                             - 45 * ((sEvent = IIf(IsPortg, "ParInsFec", "StpInsCls") Or (sEvent = IIf(IsPortg, "ParInsZer", "StpInsRst")) Or (sEvent = IIf(IsPortg, "ParInZeIn", "StpInRsSt")) Or (sEvent = IIf(IsPortg, "PararIns", "StopIns"))))  'Cor de acordo com os eventos, exceto os Snapshot que ficam de acordo com a cor definida no bot|fffd|o pelo usr transferidas a seguir xxxx. Todos StopIns que para preferi fazer igual ao Stop 45 e n|fffd|o vermelho 3.

        If Len(sLabel) > 0 Then    'Transf Snapshot label colors
            Dim lEvent As Long
            lEvent = Replace(sEvent, IIf(IsPortg, "Instt|fffd|neo", "Snapshot"), "")
            If lEvent = 0 Then lEvent = 1
            .Offset(0, 6).Resize(1, 2).Interior.Color = arrBackColor(lEvent)
            .Offset(0, 6).Resize(1, 2).Font.Color = arrForeColor(lEvent)
        End If

        If sSplitStartCellRef = "A1" Then    'Planilha de split nova padr|fffd|o ent|fffd|o trabalhar com CurrentRegion
            .CurrentRegion.Columns.AutoFit
        Else    'Planilha ou range de split antigo, ent|fffd|o trabalhar s|fffd| linha nova e a ref s|fffd| aumentando
            For i = 0 To 7
                Dim dblWidth As Double
                dblWidth = .Offset(-1, i).ColumnWidth
                .Offset(-1, i).Resize(2, 1).Columns.AutoFit
                If .Offset(-1, i).ColumnWidth < dblWidth Then .Offset(-1, i).ColumnWidth = dblWidth
            Next
        End If

        'Ajustando a visualiza|fffd||fffd|o
        If appHostApp.ActiveWorkbook.Name = wbSplit.Name And appHostApp.ActiveWindow.ActiveSheet.Name = shSplit.Name Then
            If Not appHostApp.Intersect(appHostApp.ActiveWindow.ActivePane.VisibleRange, .CurrentRegion) Is Nothing Then
                Do While appHostApp.ActiveWindow.ActivePane.VisibleRange.Row + appHostApp.ActiveWindow.ActivePane.VisibleRange.Rows.Count _
                   - (.Row + 1 - (appHostApp.ActiveWindow.ActivePane.VisibleRange.Rows.Count > 1)) < 0
                    appHostApp.ActiveWindow.ActivePane.SmallScroll Down:=1
                Loop
            End If
            Dim bDisEnableEvents As Boolean: bDisEnableEvents = (lCellAsButTriggSlc And 1) = 1 And appHostApp.EnableEvents: If bDisEnableEvents Then appHostApp.EnableEvents = False    'Se usando c|fffd|lula como bot|fffd|o e split sheet ativa, desabilita eventos antes selec c|fffd|l para n|fffd|o entrar em loop.
            .Offset(2, 7).Activate: If bDisEnableEvents Then appHostApp.EnableEvents = True            'Para evitar que inclus|fffd|o acidental destrua dados.
        End If
    End With
End Sub

Private Function LookForOldSplit(rngOldSplit As Range) As Boolean    'Procura por registro anterior iniciado e assim retomar.
    Const sFlagFormula As String = "=ABS(OFFSET(RC,0,-1)-IF(AND(ISNUMBER(OFFSET(RC,-1,-1)),OFFSET(RC,-1,3)<>"    '""Reset""),OFFSET(RC,-1,-1),0))"
    Dim R As Long, c As Long
    For R = 1 To -2 Step -1
        If rngOldSplit.Row + R > 0 And rngOldSplit.Row + R < rngOldSplit.EntireColumn.Rows.Count Then
            For c = 2 To -7 - 1 Step -1
                If rngOldSplit.Column + c > 0 And rngOldSplit.Column + c < rngOldSplit.EntireRow.Columns.Count Then
                    If Left(rngOldSplit.Offset(R, c).FormulaR1C1, 72) = sFlagFormula Then LookForOldSplit = True: Exit For
                End If
            Next c
        End If
        If LookForOldSplit Then Set rngOldSplit = rngOldSplit.Offset(R, c): Exit For
    Next R
    If Not LookForOldSplit Then Exit Function

    If Not (rngOldSplit.Offset(1, 0) = Empty And Not rngOldSplit.Offset(1, 0).HasFormula) Then    'Se n|fffd|o est|fffd| no final
        Set rngOldSplit = rngOldSplit.End(xlDown)
        If Left(rngOldSplit.FormulaR1C1, 72) <> sFlagFormula Then LookForOldSplit = False    'N|fffd|o |fffd| coluna de split
    End If

    If LookForOldSplit Then    'Verif. se pr|fffd|xima linha est|fffd| branco e se a celula ao lado
        If Not (rngOldSplit.Offset(1, 0) = Empty And Not rngOldSplit.Offset(1, 0).HasFormula) Then LookForOldSplit = False
        If Not (rngOldSplit.Offset(1, -1) = Empty And Not rngOldSplit.Offset(1, -1).HasFormula) Then LookForOldSplit = False
        If Not (rngOldSplit.Offset(1, -2) = Empty And Not rngOldSplit.Offset(1, -2).HasFormula) Then LookForOldSplit = False
    End If
    If LookForOldSplit And appHostApp.ActiveWindow.ActiveCell.Value = Empty And sSplitStartCellRef = "" Then rngOldSplit.Offset(0, -1).Select  'Selecionando c|fffd|lula n|fffd|o vazia do log encontrado, evita questionar para criar novo em cima dele, se cancelar para n|fffd|o us|fffd|-lo.
End Function

Private Function LookForBlankSplit(rngOldSplit As Range) As Boolean    'Procura por registro anterior em branco, s|fffd| com cabe|fffd|alho. |fffd|til para mais de uma inst|fffd|ncia usar o mesmo registro e assim suportar mais de dez labels.
    Dim R As Long, c As Long
    For R = 1 To -25 Step -1
        If rngOldSplit.Row + R > 0 And rngOldSplit.Row + R < rngOldSplit.EntireColumn.Rows.Count Then
            For c = 2 To -7 - 1 Step -1
                If rngOldSplit.Column + c > 0 And rngOldSplit.Column + c < rngOldSplit.EntireRow.Columns.Count Then
                    With rngOldSplit.Offset(R, c)
                        If .Offset(0, 0).Value = "Item" _
                           And .Offset(0, 1).Value = IIf(IsPortg, "Tempo", "Time") _
                           And .Offset(0, 2).Value = IIf(IsPortg, "Intervalo", "Gap") _
                           And .Offset(0, 3).Value = IIf(IsPortg, "NoRel|fffd|gio", "AtClock") _
                           And .Offset(0, 4).Value = IIf(IsPortg, "Modo", "Mode") _
                           And .Offset(0, 5).Value = IIf(IsPortg, "Evento", "Event") _
                           And .Offset(0, 6).Value = IIf(IsPortg, "R|fffd|tulo", "Label") _
                           And .Offset(0, 7).Value = IIf(IsPortg, "Notas Usu|fffd|rio", "User Notes") _
                           And appHostApp.WorksheetFunction.CountBlank(.Offset(1, 1).Resize(25, 7 + 1 - 1).Cells) = 25 * (7 + 1 - 1) Then LookForBlankSplit = True: Exit For   'Contando brancos, ignora primeira coluna devido observa|fffd||fffd|o inicial.
                    End With
                End If
            Next c
        End If
        If LookForBlankSplit Then Set rngOldSplit = rngOldSplit.Offset(R, c): Exit For
    Next R
    If LookForBlankSplit And appHostApp.ActiveWindow.ActiveCell.Value = Empty And sSplitStartCellRef = "" Then rngOldSplit.Offset(0, 0).Select     'Selecionando c|fffd|lula n|fffd|o vazia do log encontrado, evita questionar para criar novo em cima dele, se cancelar para n|fffd|o us|fffd|-lo.
End Function

Private Sub UserNote_Tb_Change()
    If vEnableEvents = False Then Exit Sub
    If rngUserNoteLast Is Nothing Then Exit Sub
    If UserNoteLast_Chb.Value And rngUserNoteLast.Row > 1 Then rngUserNoteLast.Value = UserNote_Tb.Text
End Sub

Private Sub UserNoteLast_Chb_Click()
    If vEnableEvents = False Then Exit Sub
    If UserNoteLast_Chb.Value And Not rngUserNoteLast Is Nothing Then UserNote_Tb.Text = rngUserNoteLast.Value
    UserNote_Tb.SetFocus

    If IsPortg Then
        UserNote_Tb.ControlTipText = "Nota de usu|fffd|rio " & IIf(UserNoteLast_Chb.Value = False, "para o pr|fffd|ximo evento a ocorrer", "no |fffd|ltimo evento")
    Else
        UserNote_Tb.ControlTipText = "User note " & IIf(UserNoteLast_Chb.Value = False, "for the next event to happen", "in the last event")
    End If
    bUserNoteUpd = False
    bUserNoteLast = UserNoteLast_Chb.Value
    WriteINISetting1
End Sub


Private Sub UserNote_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit UserNote_Tb, arrSnpshtLb(0), Cancel: End Sub
Private Sub Snapshot1_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot1_Tb, arrSnpshtLb(1), Cancel: End Sub
Private Sub Snapshot2_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot2_Tb, arrSnpshtLb(2), Cancel: End Sub
Private Sub Snapshot3_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot3_Tb, arrSnpshtLb(3), Cancel: End Sub
Private Sub Snapshot4_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot4_Tb, arrSnpshtLb(4), Cancel: End Sub
Private Sub Snapshot5_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot5_Tb, arrSnpshtLb(5), Cancel: End Sub
Private Sub Snapshot6_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot6_Tb, arrSnpshtLb(6), Cancel: End Sub
Private Sub Snapshot7_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot7_Tb, arrSnpshtLb(7), Cancel: End Sub
Private Sub Snapshot8_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot8_Tb, arrSnpshtLb(8), Cancel: End Sub
Private Sub Snapshot9_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot9_Tb, arrSnpshtLb(9), Cancel: End Sub
Private Sub Snapshot10_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean): xSnapshot_Tb_Exit Snapshot10_Tb, arrSnpshtLb(10), Cancel: End Sub
Private Sub xSnapshot_Tb_Exit(CtrlTb As Object, sSnpshtLb As String, ByVal Cancel As MSForms.ReturnBoolean)
    Cancel = Not bNotExitFromTb
    'Para em labels maiores que a caixa realinhar a esquerda ao sair da edi|fffd||fffd|o
    CtrlTb.SelStart = 0
    CtrlTb.SelLength = 1
    If CtrlTb.Text <> sSnpshtLb Then
        sSnpshtLb = CtrlTb.Text
        WriteINISetting1
    End If
    bNotExitFromTb = True
End Sub


Private Sub UserNote_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, UserNote_Tb, 0: End Sub
Private Sub Snapshot1_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot1_Tb, 1: End Sub
Private Sub Snapshot2_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot2_Tb, 2: End Sub
Private Sub Snapshot3_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot3_Tb, 3: End Sub
Private Sub Snapshot4_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot4_Tb, 4: End Sub
Private Sub Snapshot5_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot5_Tb, 5: End Sub
Private Sub Snapshot6_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot6_Tb, 6: End Sub
Private Sub Snapshot7_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot7_Tb, 7: End Sub
Private Sub Snapshot8_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot8_Tb, 8: End Sub
Private Sub Snapshot9_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot9_Tb, 9: End Sub
Private Sub Snapshot10_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer): xSnapshot_Tb_KeyDown KeyCode, Shift, Snapshot10_Tb, 10: End Sub
Private Sub xSnapshot_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer, CtrlTb As Object, Lb As Long)
    bNotExitFromTb = True
    If KeyCode = 32 And (CtrlTb.Text = "" Or Right(CtrlTb.Text, 1) = " ") Then KeyCode = 13
    If KeyCode = 13 Or (KeyCode = 187 And Shift = 0) Then
        If bSplit And lBotPress = 1 Then xLbSplit_Click Lb Else xLbStartStop_Click    '=
        'CtrlTb.SetFocus  'Para n|fffd|o sair do Tb mas falha, tive que usar bNotExitFromTb s|fffd| para contornar
        bNotExitFromTb = False
    End If
End Sub

Public Sub LoopAPI()
'    lastFormWidth = Width: lastFormHeight = Height    'Consolida size do form at|fffd| aque para evitar que seja tida como altera|fffd||fffd|o externa pelas bordas
'    Do While True

    Select Case lBotPress
    Case 0    'Waiting Start from 0
        dbElapsed = 0
    Case 1    'Start or restart and running
        If bCntDown Then
            Dim lTickCountDownFix1 As Long    'Fixar GetTickCount e Time para sincronizar eventos imediatos no mesmo tick e tempo. Passar via arg. para fazer os ajustes.
            Dim dTimeDownFix1 As Date
            lTickCountDownFix1 = IIf(lTickCountDownFix = 0, GetTickCount(), lTickCountDownFix)
            dTimeDownFix1 = IIf(lTickCountDownFix = 0, Now, dTimeDownFix)
            dbElapsed = dbStart - lTickCountDownFix1 / 1000

            'Speak coutdown
            If bCDSpeak Then
                Static lSecLast As Long
                If Int(dbElapsed) >= -1 And Int(dbElapsed) < lCDSpeak And Int(dbElapsed) <> lSecLast Then appHostApp.Speech.Speak Int(dbElapsed) + 1 & "!"  'Fala o pr|fffd|ximo, pois demora para fala e s|fffd| em seguida vai atualizar o visor
                lSecLast = Int(dbElapsed)
            End If

            If dbElapsed = 0 Then CountDownExpire lTickCountDownFix1, dTimeDownFix1
            If dbElapsed < 0 Then    'Ent|fffd|o o tickcount era um pouco antes que n|fffd|o passou aqui, ent|fffd|o corrige para ficar exato.
                dTimeDownFix1 = dTimeDownFix1 - TimeSerial(0, 0, (lTickCountDownFix1 - dbStart * 1000) / 1000)
                lTickCountDownFix1 = dbStart * 1000
                CountDownExpire lTickCountDownFix1, dTimeDownFix1
            End If
        Else
            dbElapsed = IIf(lTickCountMultFix = 0, GetTickCount(), lTickCountMultFix) / 1000 - dbStart
        End If
        If lStartTickCount = 0 Then lStartTickCount = GetTickCount()    'Guarda tick inicial para eventual refer|fffd|ncia.
    Case 2    'Stop and waiting to restart
        'dbElapsed = dbElapsed
    Case 3    'Stop and exit with insert
        CronometroElapsedAtu = dbElapsed
        '        Timer1.Enabled = False
        OkInsert = True
        PreparingToClose
        If lWaitAndRetValue = 0 Then Unload Me Else Hide
        Exit Sub        'Exit Do
    Case 4    'Stop and exit without insert (Cancel)
        '        Timer1.Enabled = False
        OkInsert = False
        PreparingToClose
        If lWaitAndRetValue = 0 Then Unload Me Else Hide
        Exit Sub        'Exit Do
    End Select

    WriteTbVisor dbElapsed
    'MyWait 0      'DoEvents and Sleep to release CPU usage. Com o loop sendo feito pelo OTimeObj n|fffd|o |fffd| mais necess|fffd|rio

    FormAdjust

    'Get information from UI app for a sensitive Caption
    Dim sCaption As String, bActCelIsNoth As Boolean
    Select Case appHostApp.Name
    Case "Microsoft Excel"
        On Error Resume Next    'Preteste necess|fffd|rio porque rngActCelStart pode ter sido deletada ou a planinha fechada ou ainda shSplit exclu|fffd|da
        If bSplit Then
            sCaption = shSplit.Name & wbSplit.Name
            If Err.Number <> 0 Then bSplit = False
        End If
        If (bInsActCelStart Or bFromAutoPopCell) And Not rngActCelStart Is Nothing Then
            sCaption = rngActCelStart.AddressLocal
            If Err.Number <> 0 Then Set rngActCelStart = Nothing: bInsActCelStart = False: bFromAutoPopCell = False
        End If
        Err.Clear: bActCelIsNoth = appHostApp.ActiveWindow.ActiveCell Is Nothing: bActCelIsNoth = Err.Number <> 0    'Pretestar tamb|fffd|m se existe c|fffd|lula ativa, pois todas as planilhar podem ter sido fechadas.
        On Error GoTo 0

        sCaption = IIf(bCntDown, IIf(IsPortg, "Contagem Regressiva", "Countdown"), IIf(IsPortg, "Cron|fffd|metro", "Stopwatch")) & IIf(sCountInstAdd = "1", "", sCountInstAdd)

        If bSplit Then
            sCaption = sCaption & " - " & shSplit.Name & " - " & wbSplit.Name
        ElseIf (bInsActCelStart Or bFromAutoPopCell) And lStopInsMode < 6 And Not rngActCelStart Is Nothing And Not bActCelIsNoth Then
            sCaption = sCaption & IIf(IsPortg, " em ", " in ") & Replace(rngActCelStart.AddressLocal, "$", "")
            If rngActCelStart.Parent.Name & " - " & rngActCelStart.Parent.Parent.Name = _
               appHostApp.ActiveWindow.ActiveSheet.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Parent.Name Then
                sCaption = sCaption & " - " & IIf(IsPortg, "Planilha Ativa", "Active Sheet")
            Else
                sCaption = sCaption & " - " & rngActCelStart.Parent.Name & " - " & rngActCelStart.Parent.Parent.Name
            End If
        End If

        bEchoDisplayInCellAndHide = (lEchoDisplayInCell And 1) = 1 And lBotPress = 1 And Not rngActCelStart Is Nothing     'Se ecoando, s|fffd| deve acontecer se j|fffd| Start e enquanto a cel existir.
        If bEchoDisplayInCellAndHide Then    'A vari|fffd|vel |fffd| usada como flag temp que evolui do echo at|fffd| o autohide.
            bEchoDisplayInCellAndHide = IIf((lEchoDisplayInCell And 2) = 2, CellHasTimeFormat(rngActCelStart.NumberFormat), True)   'S|fffd| ecoa em c|fffd|lula formatada e ao ecoar verifica erro para n|fffd|o auto-ocultar em AnchToActCelStart().
            On Error Resume Next
            If bEchoDisplayInCellAndHide And sEchoLastDisplay <> TbVisor.Value & TbVisorFrc.Value Then sEchoLastDisplay = TbVisor.Value & TbVisorFrc.Value: If rngActCelStart.HasFormula Or (rngActCelStart.Locked And appHostApp.ActiveWindow.ActiveSheet.ProtectContents) Then rngActCelStart.Calculate Else rngActCelStart.Value = CDbl(dbElapsed / 24 / 60 / 60)   'S|fffd| ecoar quando houver altera|fffd||fffd|o no visor, assim a precis|fffd|o do visor regula os rec|fffd|lculos da planilha. E se houver formula ou c|fffd|lula protegida apenas recalcular evita o erro e a c|fffd|lula e outras s|fffd|o recalculadas sem destruir f|fffd|rmula e sem inserir valor na c|fffd|lula protegida (Ver comm em outro .Calculate).
            If bEchoDisplayInCellAndHide Then bEchoDisplayInCellAndHide = (Err.Number = 0) And (lEchoDisplayInCell And 4) = 4 And Not bSplit
            On Error GoTo 0
        End If
        If Not bEchoDisplayInCellAndHide And Top < -Height And Not bAnchActCelStart Then Top = (lTop + 1 + 13 * 0) * Twips    'S|fffd| para reexibir se oculta devido autohide e a configura|fffd||fffd|o seja alterada ainda rodando.

    Case "Microsoft Word", "Microsoft PowerPoint", "Microsoft Access"
    End Select
    If Caption <> sCaption Then
        SetWindowText Form_hWnd, sCaption    'A vantagem do API em rela|fffd||fffd|o ao Caption = sCaption |fffd| que o form n|fffd|o perde as configura|fffd||fffd|es como sizeble e barra oculta alterando tamanho, posi|fffd||fffd|o e provocando flex.
        TbVisorFrontTransp.ControlTipText = IIf(bHideTitleBar Or Len(sCaption) * 5.4 > InsideWidth, sCaption, "")
    End If

    If bAnchActCelStart Or bEchoDisplayInCellAndHide Or ((lEchoDisplayInCell And 1) = 1 And GetTickCount() < IIf(lStartTickCount = 0, GetTickCount(), lStartTickCount) + 1000) Then AnchToActCelStart            'Ancorar na c|fffd|lula ativa ao iniciar se: (1)Configurado; (2)Ecoando com autohide, for|fffd|ar ancoragem para quando reexibir aproximando da c|fffd|lula expor a interface j|fffd| embaixo do mouse para uma a|fffd||fffd|o imediata e (3)Ecoando com ou sem autohide, for|fffd|ar ancoragem no in|fffd|cio para posicionar juntos no in|fffd|cio.

    'Loop
    '    If Timer1.Interval <> 50 + 2 * CollectionInst.Count Then Timer1.Interval = 50 + 2 * CollectionInst.Count        'Aumenta interv recall (loop) a cada new instance, se n|fffd|o o menu fica lento ou trava (fui at|fffd| 70 sem problema)
End Sub

Public Function WriteTbVisor(ByVal dbElapsed1 As Double) As String    'Destaquei do LoopAPI pois as vezes |fffd| necess|fffd|rio apenas a escrta no visor em um certo tickcount e no LoopAPI mesmo com tickcount fix pode ocorrer um nova chamada da API quase simult|fffd|nea durante o ajuste dos varios controles.
    Dim lPartInt, lPartFrc
    Dim lDd As Long, lHh As Long, lMm As Long, lSs As Long

    lPartInt = Int(Round(dbElapsed1, lNumDecim))    'Tal como o arredondar no format de planilha, primeiro arredonda na decimal prevista para s|fffd| depois tirar o inteiro.
    lPartFrc = dbElapsed1 - lPartInt
    Select Case lMode
    Case 1    '"d  hh:mm:ss
        lDd = Int(lPartInt / 24 / 60 / 60)
        lHh = Int((lPartInt - CLng(24) * 60 * 60 * lDd) / 60 / 60)
        lMm = Int((lPartInt - CLng(24) * 60 * 60 * lDd - 60 * 60 * lHh) / 60)
        lSs = lPartInt - CLng(24) * 60 * 60 * lDd - 60 * 60 * lHh - 60 * lMm
        lPartInt = lDd & " " & VBA.Format(lHh, "00") & ":" & VBA.Format(lMm, "00") & ":" & VBA.Format(lSs, "00")
    Case 2    'h:mm:ss
        lHh = Int(lPartInt / 60 / 60)
        lMm = Int((lPartInt - 60 * 60 * lHh) / 60)
        lSs = lPartInt - 60 * 60 * lHh - 60 * lMm
        lPartInt = lHh & ":" & VBA.Format(lMm, "00") & ":" & VBA.Format(lSs, "00")
    Case 3    'm:ss
        lMm = Int(lPartInt / 60)
        lSs = lPartInt - 60 * lMm
        lPartInt = lMm & ":" & VBA.Format(lSs, "00")
    Case 4    'segundos
        lPartInt = VBA.Format(lPartInt, "#,##0")

    Case 5    'minutos
        lPartInt = Int(Round(dbElapsed1 / 60, lNumDecim))
        lPartFrc = dbElapsed1 / 60 - lPartInt
        lPartInt = VBA.Format(lPartInt, "#,##0")
    Case 6    'horas
        lPartInt = Int(Round(dbElapsed1 / 60 / 60, lNumDecim))
        lPartFrc = dbElapsed1 / 60 / 60 - lPartInt
        lPartInt = VBA.Format(lPartInt, "#,##0")
    Case 7    'Dias
        lPartInt = Int(Round(dbElapsed1 / 60 / 60 / 24, lNumDecim))
        lPartFrc = dbElapsed1 / 60 / 60 / 24 - lPartInt
        lPartInt = VBA.Format(lPartInt, "#,##0")
    Case 8    'Semanas
        lPartInt = Int(Round(dbElapsed1 / 60 / 60 / 24 / 7, lNumDecim))
        lPartFrc = dbElapsed1 / 60 / 60 / 24 / 7 - lPartInt
        lPartInt = VBA.Format(lPartInt, "#,##0")
    Case 9    'Meses
        lPartInt = Int(Round(dbElapsed1 / 60 / 60 / 24 / 30.5, lNumDecim))
        lPartFrc = dbElapsed1 / 60 / 60 / 24 / 30.5 - lPartInt
        lPartInt = VBA.Format(lPartInt, "#,##0")
    Case 10    'Anos
        lPartInt = Int(Round(dbElapsed1 / 60 / 60 / 24 / 365.25, lNumDecim))
        lPartFrc = dbElapsed1 / 60 / 60 / 24 / 365.25 - lPartInt
        lPartInt = VBA.Format(lPartInt, "#,##0")
    End Select
    If lPartFrc < 0 Then lPartFrc = 0    'Devido ao arredondamento pode avan|fffd|ar negativando a fra|fffd||fffd|o, ent|fffd|o zera.
    lPartFrc = IIf(lNumDecim = 0, "", IIf(Round(lPartFrc, lNumDecim) = 0, sDecimalSep, "") & Mid(Round(lPartFrc, lNumDecim) & String(lNumDecim, "0"), 2, lNumDecim + 1))

    TbVisor.Value = lPartInt
    TbVisorFrc.Value = lPartFrc
    WriteTbVisor = lPartInt & lPartFrc
End Function

Private Sub FormAdjust()
    Static lastVisorWidth As Double    'Aka lastTbVisor
    Static lastlBotPress As Long
    Static lastlCtrlPanelSize As Long
    Static lastlDispSize As Long
    Static lastlMode As Long
    Static lastlSnapshotNumb As Long
    Static lastlActSnapshotTb As Long
    Dim lCtrl As Long
    If bSplit Then
        'Se split e esperando Start em zero, parece ser interessante desabilitar os bot|fffd|es de snapshot. Comentei na vers|fffd|o 4.0, pois em xLbSplit_Click fiz com que, se parado, click em snapshot n|fffd|o tem a|fffd||fffd|o. Sem desvanecer at|fffd| melhora esteticamente.
        '        If (lBotPress = 0 And dbElapsed = 0 And LbSnapshot1.Enabled) _
                 '           Or (dbElapsed <> 0 And Not LbSnapshot1.Enabled) Then
        '            LbSnapshot1.Enabled = Not LbSnapshot1.Enabled
        '            For lCtrl = 1 To 10
        '                Controls("LbSnapshot" & lCtrl).Enabled = LbSnapshot1.Enabled
        '            Next
        '            'LbSplit.Enabled = LbSnapshot1.Enabled 'O Excel perde o foco, parece bug, mesmo assim n|fffd|o |fffd| necess|fffd|rio agora que decidi ocult|fffd|-lo ao exibir snap label
        '        End If

        'Se split e contando, estender cada bot|fffd|o snapshot sobre sua caixa de texto e ocult|fffd|-la, usando s|fffd| o caption desta, se houver. Aumenta |fffd|rea de click e fica menos confuso. Editar label rodando n|fffd|o |fffd| |fffd|til e pode gerar erro. Novo na vers|fffd|o 4.0.
        For lCtrl = 1 To lSnapshotNumb
            If lBotPress = 1 Then
                If Controls("Snapshot" & lCtrl & "_Tb").Text <> "" Then Controls("LbSnapshot" & lCtrl).Caption = Controls("Snapshot" & lCtrl & "_Tb").Text
                Controls("LbSnapshot" & lCtrl).Width = Width / Twips - LbSnapshot1.Left - (Width / Twips - InsideWidth) - 1.5
                Controls("Snapshot" & lCtrl & "_Tb").Visible = False
            Else
                Controls("LbSnapshot" & lCtrl).Caption = IIf(IsPortg, "Instt|fffd|neo ", "Snapshot ") & lCtrl
                Controls("Snapshot" & lCtrl & "_Tb").Visible = True
            End If
        Next

        'Se split, verifica se sel em e ActSplitSheet_ChB condiz ou houve ativa|fffd||fffd|o externa.
        vEnableEvents = False
        On Error Resume Next    'Contornar poss|fffd|veis exclus|fffd|o de shSplit or ausencia de ActiveSheet
        If ActSplitSheet_ChB.Value Then
            If shSplit.Name <> appHostApp.ActiveWindow.ActiveSheet.Name Or shSplit.Parent.Name <> appHostApp.ActiveWindow.ActiveSheet.Parent.Name Then If Err.Number = 0 Then ActSplitSheet_ChB.Value = False
        Else
            If shSplit.Name = appHostApp.ActiveWindow.ActiveSheet.Name And shSplit.Parent.Name = appHostApp.ActiveWindow.ActiveSheet.Parent.Name Then If Err.Number = 0 Then ActSplitSheet_ChB.Value = True
        End If
        On Error GoTo 0
        vEnableEvents = True
    End If

    'Alterando pelas bordas com o mouse pode at|fffd| zerar momentameante o que pode zerar controles, ent|fffd|o limitar. Deixar no m|fffd|nimo que o pr|fffd|prio VBA suporta, 25.25x92.25, e agora com API, 10x10
    If Height < 10 * Twips Then HeightAPI = 10 * Twips: Exit Sub
    If Width < 10 * Twips Then WidthAPI = 10 * Twips: Exit Sub

    'Adjusting to anchored cell. Antes verifica se cel inicial ainda existe. A priori, pela utilidade e dificuldade de ajustar, vou requerer, al|fffd|m da ancoragem, bAutoHideCtrlPanelOn e bHideTitleBar.
    If bAnchActCelStart And bAutoHideCtrlPanelOn And bHideTitleBar And Not rngActCelStart Is Nothing And (bAnchCelAdjWidth Or bAnchCelAdjHeight) Then On Error Resume Next: lCtrl = 0: lCtrl = Len(rngActCelStart.AddressLocal): On Error GoTo 0: If lCtrl = 0 Then Set rngActCelStart = Nothing
    If bAnchActCelStart And bAutoHideCtrlPanelOn And bHideTitleBar And Not rngActCelStart Is Nothing And lastVisorWidth <> 0 Then    '|fffd|ltima condi|fffd||fffd|o salta no primeiro ajuste ao iniciar.
        If bAnchCelAdjWidth And (Width < (rngActCelStart.Width - 7) * Twips Or Width > (rngActCelStart.Width + 1) * Twips) And Not bAnchCelAdjWidthOffTmp Then
            If Width < rngActCelStart.Width * Twips And bAnchCelAdjHeight And (Abs(Height - rngActCelStart.Height * Twips) <= 7 * Twips Or rngActCelStart.Height < 12) Then
                'Se n|fffd|o tiver encaixado na largura, mas menor e encaixado na altura deixa como est|fffd|
            Else
                If Width < rngActCelStart.Width Then
                    WidthAPI = rngActCelStart.Width * Twips + 16    'Como |fffd| feito por intera|fffd||fffd|o com toler|fffd|ncia, se vier diminuido pode ficar diferente de se vier aumentando entao se acontecer menor fa|fffd|o maior para sempre convergir diminuindo.
                ElseIf Width > rngActCelStart.Width And Width < rngActCelStart.Width + 7 Then
                    WidthAPI = Width - 1    'Se estiver bem pr|fffd|ximo e maior um ajuste ponto a ponto vai ficar mais preciso.
                Else
                    WidthAPI = rngActCelStart.Width * Twips + 2    'Tenta um pouco maior para que ajuste fino seja feito ponto a ponto.
                End If
            End If
        ElseIf bAnchCelAdjHeight And (Height < (rngActCelStart.Height - 7) * Twips Or Height > (rngActCelStart.Height + 1) * Twips) Then
            If Height < rngActCelStart.Height * Twips And bAnchCelAdjWidth And Abs(Width - rngActCelStart.Width * Twips) <= 7 * Twips Then
                'Se n|fffd|o tiver encaixado na altura, mas menor e encaixado na largura deixa como est|fffd|
            Else
                If Height < rngActCelStart.Height Then
                    HeightAPI = rngActCelStart.Height * Twips + 16
                ElseIf Height > rngActCelStart.Height And Height < rngActCelStart.Height + 7 Then
                    HeightAPI = Height - 1
                Else
                    HeightAPI = rngActCelStart.Height * Twips + 2
                End If
                If bAnchCelAdjWidth Then bAnchCelAdjWidthOffTmp = True: FormAdjust: FormAdjust: FormAdjust: bAnchCelAdjWidthOffTmp = False    'Como bAnchCelAdjWidth tem a prefer, se n|fffd|o ajustar altura na primeira tentativa entra em loop ent|fffd|o faz mais 3 tentativas de ajuste com bAnchCelAdjWidth false, mas para n|fffd|o ecoar configura|fffd||fffd|o em inst|fffd|ncia sendo criado, vou usar bAnchCelAdjWidthOffTmp.
            End If
        End If
    End If

    'Agora que os bot|fffd|es podem ser aumentados, vamos for|fffd|ar um ajuste fino para que a altura do formul|fffd|rio n|fffd|o deixe o bot|fffd|o split muito prejudicado. Ignorar quando no inicio ou ainda n|fffd|o ajustado grosso. Se bAutoHideCtrlPanelOn, o bot|fffd|o LbStartStop deve limitar a altura para exibir total e LbDispPickCrestore a largura para ocultar total, mas, so t|fffd|tulo estiver oculto, n|fffd|o parece ser necess. limitar.
    If bAutoHideCtrlPanelOn Then
        If bHideTitleBar Then
            'N|fffd|o parece necess. limitar, pois o ajuste sempre oculta todos os controles e pode ser configurado o click no visor ou usar teclado se LbStartStop ficar sempre oculto.
        Else
            If TbVisor.Left = 0 Then If LbStartStop.Top + LbStartStop.Height > TbVisor.Top + TbVisor.Height Then lDispSize = lDispSize * (LbStartStop.Top + LbStartStop.Height) / (TbVisor.Top + TbVisor.Height)
            If TbVisor.Left = 0 Then If LbDispPickCrestore.Left + LbDispPickCrestore.Width > TbVisorFnd.Left + TbVisorFnd.Width Then lDispSize = lDispSize * (LbDispPickCrestore.Left + LbDispPickCrestore.Width) / (TbVisorFnd.Left + TbVisorFnd.Width)
        End If
    Else
        If Not Abs(TbVisorFnd.Top - TbVisor.Top) > 10 And TbVisor.Left > 0 Then If LbSplit.Top + LbSplit.Height / IIf(bSplit, 1.1, 2) > TbVisor.Top + TbVisor.Height Then lDispSize = lDispSize * (LbSplit.Top + LbSplit.Height / IIf(bSplit, 1.1, 2)) / (TbVisor.Top + TbVisor.Height)
    End If

    'Antes verifica se houve altera|fffd||fffd|o no tamanho do form externamente pelas bordas. Se houve, alterar
    'lDispSize na mesma propor|fffd||fffd|o dando prefer|fffd|ncia a altera|fffd||fffd|o na largura
    If Not IsMouseDown(vbLeftButton) Then    'Enquanto o mouse estiver press, n|fffd|o ajustar
        If Width <> lastFormWidth Then
            lDispSize = lDispSize + lDispSize * (Width - lastFormWidth) / lastFormWidth
        Else
            If Height <> lastFormHeight Then
                lDispSize = lDispSize + lDispSize * (Height - lastFormHeight) / lastFormHeight
            End If
        End If
        If lastlDispSize <> lDispSize Then SetWindowText Form_hWnd, Caption & " "    'Flag alterando para ser verificado
    End If

    'Antes verifica se houve altera|fffd||fffd|o no snapshot_tb ativo para alterar a posi|fffd||fffd|o dos icones de edi|fffd||fffd|o de cores
    If Left(ActiveControl.Name, 8) = "Snapshot" And Right(ActiveControl.Name, 3) = "_Tb" Then lActSnapshotTb = Mid(ActiveControl.Name, 9, Len(ActiveControl.Name) - 11) Else lActSnapshotTb = 0

    'Autohide button panel.
    If bAutoHideCtrlPanel And Not bSplit And Not bPaperRibbon Then
        LbStartStop.ZOrder 1: LbSet.ZOrder 1: LbStopIns.ZOrder 1: CtrlPanelShow_Lb.ZOrder 1: Close_Lb.ZOrder 1
        Dim Point As POINTAPI, Result
        Result = GetCursorPos(Point)
        If Result <> 0 Then
            Point.Y = Point.Y * 0.75 * Twips - IIf(bHideTitleBar, 0, dFormTitleHeight): Point.X = Point.X * 0.75 * Twips
            If bAutoHideCtrlPanelOn Then    'Se ligado, exibir bot|fffd|es conform aproxima|fffd||fffd|o do mouse.
                Dim bDispClicbSmal: bDispClicbSmal = lClickOnDisplay > 0 And Height < 40 And lBotPress <> 0 And lBotPress <> 2    'Apenas para n|fffd|o exibir bot|fffd|es no visor se click neste tiver fun|fffd||fffd|o definida, for pequeno e estiver contando
                If Point.Y > Top And Point.Y < Top + Height And Point.X > Left And Point.X < Left + Width Then CtrlPanelShow_Lb.ZOrder 0: Close_Lb.ZOrder 0: If Not bDispClicbSmal Then LbStartStop.ZOrder 0
                If Point.Y > Top + LbSet.Top * Twips And Point.Y < Top + LbCntDown.Top * Twips And Point.X > Left And Point.X < Left + LbStartStop.Left * Twips And LbSet.Enabled Then If Not bDispClicbSmal Then LbSet.ZOrder 0
                If Point.Y > Top And Point.Y < Top + LbStartStop.Top * Twips And Point.X > Left + LbStartStop.Left * Twips And Point.X < Left + (LbStopIns.Left + LbStopIns.Width + 3) * Twips And LbStopIns.Enabled Then If Not bDispClicbSmal Then LbStopIns.ZOrder 0
            Else    'Se optado mas desligado, verifica se est|fffd| sobre o form ou se aproximando e liga  e flag para ajustar Form a seguir
                bAutoHideCtrlPanelOn = Not (Point.Y > Top - 25 And Point.Y < Top + Height + 25 And Point.X > Left - 25 And Point.X < Left + Width + 25)
                If bAutoHideCtrlPanelOn Then bUserNoteUpd = False
            End If
        Else
            If bAutoHideCtrlPanelOn Then LbStartStop.ZOrder 0: CtrlPanelShow_Lb.ZOrder 0: Close_Lb.ZOrder 0    'Se get cursor falhar e tiver oculta exibe pelo menos este tr|fffd|s.
        End If
    Else
        bAutoHideCtrlPanelOn = False    'Desliga se n|fffd|o atender todas as condi|fffd||fffd|es para autoocultar.
    End If
    If Not bAutoHideCtrlPanelOn Then Close_Lb.ZOrder 0

    'Se n|fffd|o houve nenhuma altera|fffd||fffd|o em rela|fffd||fffd|o a |fffd|ltima vez aqui, sai
    If lastVisorWidth = TbVisor.Width + TbVisorFrc.Width _
       And lastlBotPress = lBotPress _
       And lastlCtrlPanelSize = lCtrlPanelSize _
       And lastlDispSize = lDispSize _
       And lastlMode = lMode _
       And lastlSnapshotNumb = lSnapshotNumb _
       And lastlActSnapshotTb = lActSnapshotTb _
       And bUserNoteUpd Then Exit Sub

    'Se houve alguma altera|fffd||fffd|o pelas bordas, arredondar para o pr|fffd|ximo int em tend|fffd|ncia e criticar limites
    lDispSize = IIf(lastlDispSize > lDispSize, Int(lDispSize), Int(lDispSize) - (lDispSize - Int(lDispSize) > 0))    'Floor Ceiling using Int
    If lDispSize < 2 Then lDispSize = 2 Else If lDispSize > 500 Then lDispSize = 500
    ScrollBarSize.Value = lDispSize

    TbVisor.Font.Size = lDispSize
    TbVisorFrc.Font.Size = Int(lDispSize * 0.85)
    If lNumDecim > 3 And lMode < 5 Then ScrollBarDecimal.Value = ScrollBarDecimal.Max - 3
    Select Case lBotPress
    Case 0
        LbStartStop.Caption = IIf(IsPortg, "Iniciar", "Start")
        LbStartStop.BackColor = &HC000&    'Verde
        If Not bMultDisable And bMultStartAttach Then LbStartStop.Caption = LbStartStop.Caption & "*"
        If Not bMultDisable And bMultStartStopsAttach Then LbStartStop.Caption = LbStartStop.Caption & "|fffd|"
        If Not bMultDisable And bMultStartStopInssAttach Then LbStartStop.Caption = LbStartStop.Caption & "|fffd|"
    Case 1
        LbStartStop.Caption = IIf(IsPortg, "Parar", "Stop")
        LbStartStop.BackColor = &H8080FF    'Vermelho alaranjado
        If Not bMultDisable And bMultStopAttach Then LbStartStop.Caption = LbStartStop.Caption & "*"
        'If Not bMultDisable And (bMultStartStopsAttach Or bMultRestartStopsAttach) Then LbStartStop.Caption = LbStartStop.Caption & "|fffd|" 'Comentei, pois n|fffd|o parece coerente distingui o Stop. Ele sofre acionamento e n|fffd|o aciona.
        'If Not bMultDisable And (bMultStartStopInssAttach Or bMultRestartStopInssAttach) Then LbStartStop.Caption = LbStartStop.Caption & "|fffd|" 'Comentei, pois n|fffd|o parece coerente distingui o Stop. Ele sofre acionamento e n|fffd|o aciona.
    Case 2
        If bCntDown And LbStartStop.Caption = IIf(IsPortg, "Iniciar", "Start") Then
            'N|fffd|o altera, pois indica que uma contagem regressiva ainda vai iniciar por uma chamada de fStopwatch
        Else
            LbStartStop.Caption = IIf(IsPortg, " Reiniciar", " Restart")
            LbStartStop.BackColor = &HC000&    'Verde
            If Not bMultDisable And bMultRestartAttach Then LbStartStop.Caption = LbStartStop.Caption & "*"
            If Not bMultDisable And bMultRestartStopsAttach Then LbStartStop.Caption = LbStartStop.Caption & "|fffd|"
            If Not bMultDisable And bMultRestartStopInssAttach Then LbStartStop.Caption = LbStartStop.Caption & "|fffd|"
        End If
    End Select


    'Autosize and arrange bot|fffd|es
    LbStopIns.AutoSize = True
    LbStartStop.AutoSize = True
    LbSplit.AutoSize = True
    LbSet.AutoSize = True
    LbCntDown.AutoSize = True
    LabelMode.AutoSize = True
    LabelDecimal.AutoSize = True


    LbStopIns.Font.Size = Int(lCtrlPanelSize * 0.8)    ' - 2
    LbStartStop.Font.Size = lCtrlPanelSize
    LbSplit.Font.Size = Int(lCtrlPanelSize * 0.8)    ' - 2
    LbSet.Font.Size = lCtrlPanelSize
    LbCntDown.Font.Size = Int(lCtrlPanelSize * 0.8)    ' - 2
    LabelLedPapel.Font.Size = IIf(lCtrlPanelSize >= 10, 7, Int(lCtrlPanelSize * 0.7))
    LabelLedImp.Font.Size = LabelLedPapel.Font.Size

    LabelMode.Font.Size = IIf(lCtrlPanelSize >= 10, 8, Int(lCtrlPanelSize * 0.8))
    LabelDecimal.Font.Size = LabelMode.Font.Size

    If LbStopIns.Width >= LbStartStop.Width And LbStopIns.Width >= LbSplit.Width Then
        LbStopIns.Width = LbStopIns.Width + 4
        LbStartStop.Width = LbStopIns.Width
        LbSplit.Width = LbStopIns.Width
    ElseIf LbStartStop.Width >= LbStopIns.Width And LbStartStop.Width >= LbSplit.Width Then
        LbStopIns.Width = LbStopIns.Width + 4
        LbStopIns.Width = LbStartStop.Width
        LbSplit.Width = LbStartStop.Width
    ElseIf LbSplit.Width >= LbStartStop.Width And LbSplit.Width >= LbStopIns.Width Then
        LbSplit.Width = LbSplit.Width + 4
        LbStopIns.Width = LbSplit.Width
        LbStartStop.Width = LbSplit.Width
    End If

    If LbSet.Width >= LbCntDown.Width Then
        LbSet.Width = LbSet.Width + 4
        LbCntDown.Width = LbSet.Width
        LbCopiar.Width = LbSet.Width / 2 - 1.5
    Else
        LbCntDown.Width = LbCntDown.Width + 4
        LbSet.Width = LbCntDown.Width
        LbCopiar.Width = LbCntDown.Width / 2 - 1.5
    End If
    LbColar.Width = LbCopiar.Width
    LabelLedImp.Left = LabelLedPapel.Left + LabelLedPapel.Width + 2

    LbStartStop.Left = LbSet.Left + LbSet.Width + 0.5
    LbStopIns.Left = LbStartStop.Left
    LbSplit.Left = LbStartStop.Left
    LbCopiar.Left = LbSet.Left: LbColar.Left = LbCopiar.Left + LbCopiar.Width + 2
    LbCntDown.Left = LbSet.Left

    LbCopiar.Height = LbStopIns.Height
    LbColar.Height = LbStopIns.Height
    LbSet.Height = LbStartStop.Height
    LbCntDown.Height = LbStopIns.Height
    LbSplit.Height = LbStopIns.Height

    LbCopiar.Top = IIf(bAutoHideCtrlPanelOn, 0, Menu_Lb.Top + Menu_Lb.Height)
    LbColar.Top = LbCopiar.Top
    LbStopIns.Top = LbCopiar.Top

    LbSet.Top = LbCopiar.Top + LbCopiar.Height + 0.5
    LbStartStop.Top = LbSet.Top

    LbCntDown.Top = LbSet.Top + LbSet.Height + 0.5
    LbSplit.Top = LbCntDown.Top

    LbStopIns.AutoSize = False
    LbStartStop.AutoSize = False
    LbSplit.AutoSize = False

    LbSet.AutoSize = False
    LbCntDown.AutoSize = False

    LabelMode.AutoSize = False
    LabelDecimal.AutoSize = False

    'Se bAutoHideCtrlPanelOn n|fffd|o altera nada, apenas ancorar visor na posi|fffd||fffd|o 0 do form em vez de no bot|fffd|o split. Acima ainda eleva painel com bot|fffd|o Copiar no top. Por seguran|fffd|a, para os bot|fffd|es ficarem por baixo, ratifica a ordem que |fffd| o padr|fffd|o em tempo de design.
    TbVisorFnd.ZOrder 0: TbVisorFrc.ZOrder 0: TbVisor.ZOrder 0: TbVisorFrontTransp.ZOrder 0
    CtrlPanelShow_Lb.Left = IIf(bAutoHideCtrlPanelOn, LbCopiar.Left + 2, -80): CtrlPanelShow_Lb.Top = LbSet.Top - CtrlPanelShow_Lb.Height - 2
    CtrlPanelShow_Lb.Font.Size = 8    'lCtrlPanelSize

    'Ancorando controles do visor a esquerda do bot|fffd|o split
    If bAutoHideCtrlPanelOn Then TbVisor.Left = 0 Else TbVisor.Left = LbSplit.Left + LbSplit.Width + 3

    LabelMode.Left = TbVisor.Left + 1
    '   LabelMode.Top = ScrollBarMode.Top - (LabelMode.Height - ScrollBarMode.Height) / 2 + 1    '1 ajuste visual
    LabelMode.Top = ScrollBarCtrlPanel.Top
    ScrollBarMode.Top = LabelMode.Top
    LabelDecimal.Top = LabelMode.Top
    ScrollBarDecimal.Top = LabelMode.Top
    LbDispPickCback.Top = LabelMode.Top
    LbDispPickCfore.Top = LabelMode.Top
    LbDispPickCrestore.Top = LabelMode.Top

    ScrollBarMode.Height = LabelMode.Height * 0.9
    ScrollBarDecimal.Height = LabelMode.Height * 0.9
    LbDispPickCback.Height = LabelMode.Height
    LbDispPickCfore.Height = LabelMode.Height
    LbDispPickCrestore.Height = LabelMode.Height

    ScrollBarMode.Left = LabelMode.Left + LabelMode.Width - 1

    LabelDecimal.Left = ScrollBarMode.Left + ScrollBarMode.Width + 3
    ScrollBarDecimal.Left = LabelDecimal.Left + LabelDecimal.Width - 1
    LbDispPickCback.Left = ScrollBarDecimal.Left + ScrollBarDecimal.Width + 3
    LbDispPickCfore.Left = LbDispPickCback.Left + LbDispPickCback.Width + 2
    LbDispPickCrestore.Left = LbDispPickCfore.Left + LbDispPickCfore.Width + 2

    If bAutoHideCtrlPanelOn Then TbVisor.Top = 0 Else TbVisor.Top = ScrollBarMode.Top + ScrollBarMode.Height + 4.5

    'Ajustando tudo ao visor que j|fffd| foi definido automaticamente pelo tamanho da fonte
    lastVisorWidth = TbVisor.Width + TbVisorFrc.Width
    WidthAPI = (TbVisor.Left + lastVisorWidth) * Twips + (Width - InsideWidth * Twips) - 3 * Twips    'WidthAPI = (TbVisor.Left + lastVisorWidth) * Twips + (Width - InsideWidth * Twips) / 2 - IIf(Twips > 1, 1, 0) * Twips   'Em COM quando Twips>1 precisa ser 1pt menor
    HeightAPI = (TbVisor.Top + TbVisor.Height) * Twips + (Height - InsideHeight * Twips) + IIf(bHideTitleBar, 1.5, 2.5) * Twips    ' O entre parentese reflete alt. da barra de t|fffd|tulo e bordas que varia conforme a config. na Apar|fffd|ncia do Windows

    'If Width < (LabelDecimal.Left + LabelDecimal.Width + 5) * Twips Then 'Se pequeno, para n|fffd|o ocultar o cursor aumentar form e fundo somente. Eliminei comentando
    '  Width = (LabelDecimal.Left + LabelDecimal.Width + 5) * Twips
    '  TbVisorFnd.Width = Width / Twips - TbVisor.Left - (Width / Twips - InsideWidth) + 2
    'Else
    TbVisorFnd.Width = lastVisorWidth
    'End If

    TbVisorFnd.Top = TbVisor.Top - 3
    TbVisorFnd.Left = TbVisor.Left - 3
    TbVisorFnd.Height = InsideHeight - TbVisor.Top + 2.8    'IIf(lBotPress = 0, 3.5, 2.8) Ao fazer um segundo loop no Activate, estes ajustes diferentes com lBotPress deixaram de ser necess|fffd|rios.

    TbVisorFrontTransp.Top = TbVisorFnd.Top
    TbVisorFrontTransp.Left = TbVisorFnd.Left
    TbVisorFrontTransp.Height = TbVisorFnd.Height
    TbVisorFrontTransp.Width = TbVisorFnd.Width

    TbVisorFrc.Top = TbVisor.Top + TbVisor.Height - TbVisorFrc.Height - 1    'IIf(lBotPress = 0, 0, 1)
    TbVisorFrc.Left = TbVisor.Left + TbVisor.Width - 6

    For lCtrl = 1 To 9
        Controls("LabelPapel" & lCtrl).Width = InsideWidth - 2.5     '.LabelPapel1.Width =
    Next
    LabelSerrilha.Width = InsideWidth - 2.5
    LabelSerrilha.Caption = String(107 / 17 * (InsideWidth - 2.5), "^")
    Cancel_Bt.Left = -100: Close_Lb.Top = Menu_Lb.Top + 2.5: If bHideTitleBar Then Close_Lb.Left = InsideWidth - Close_Lb.Width + 1 Else Close_Lb.Left = -80

    'Se spliting, aumenta formul para exibir os controles de obs de usu|fffd|rio
    If bSplit Then ShowUserNotesCtrls
    If lOtherButtsMode > 0 Then LbOtherButtsUpt    'Aqui para ser chamado s|fffd| com altera|fffd||fffd|o de lBotPress e se houver config para desabitar.

    lastlBotPress = lBotPress
    lastlCtrlPanelSize = lCtrlPanelSize
    lastlDispSize = lDispSize
    lastlMode = lMode
    lastlSnapshotNumb = lSnapshotNumb
    lastlActSnapshotTb = lActSnapshotTb
    bUserNoteUpd = True
    lastFormWidth = Width
    lastFormHeight = Height

    ScrollBarCtrlPanel.ControlTipText = IIf(IsPortg, "Amplificar painel de bot|fffd|es (", "Amplify panel of buttons (") & lCtrlPanelSize & ") - " & IIf(IsPortg, "Padr|fffd|o 10", "Default 10")
    ScrollBarSize.ControlTipText = IIf(IsPortg, "Amplificar Visor (", "Amplify Display (") & lastlDispSize & ") - " & IIf(IsPortg, "Padr|fffd|o 26", "Default 26")
End Sub

Public Sub ShowUserNotesCtrls()
'Ajusta o form para exibir os controles de notas do user e snapshot labels
    If lSnapshotNumb > 0 Then
        Controls("LbSnapshot" & lSnapshotNumb).AutoSize = True    'Autodimensionar primeiro o poss|fffd|vel maior controle e no loop igualar similares.
        Controls("Snapshot" & lSnapshotNumb & "_Tb").AutoSize = True    'Idem
        Controls("LbSnapshot" & lSnapshotNumb).Font.Size = Int(lCtrlPanelSize * 0.9)     ' - 2
        Controls("Snapshot" & lSnapshotNumb & "_Tb").Font.Size = Int(lCtrlPanelSize * 0.8)    ' - 2
        Controls("LbSnapshot" & lSnapshotNumb).AutoSize = False
        Controls("Snapshot" & lSnapshotNumb & "_Tb").AutoSize = False
    End If

    Dim lCtrl As Long
    For lCtrl = 1 To 10
        If lSnapshotNumb > 0 Then
            Controls("LbSnapshot" & lCtrl).Font.Size = Int(lCtrlPanelSize * 0.8)    ' - 2
            Controls("Snapshot" & lCtrl & "_Tb").Font.Size = Int(lCtrlPanelSize * 0.8)    ' - 2
            Controls("LbSnapshot" & lCtrl).Width = Controls("LbSnapshot" & lSnapshotNumb).Width
            Controls("LbSnapshot" & lCtrl).Height = Controls("LbSnapshot" & lSnapshotNumb).Height
            Controls("Snapshot" & lCtrl & "_Tb").Height = Controls("Snapshot" & lSnapshotNumb & "_Tb").Height
        End If

        Controls("Snapshot" & lCtrl & "_Tb").Visible = lSnapshotNumb > lCtrl - 1    '.Snapshot1_Tb.Visible = lSnapshotNumb > 0: LbSnapshot1.Visible = lSnapshotNumb > 0
        Controls("LbSnapshot" & lCtrl).Visible = lSnapshotNumb > lCtrl - 1
    Next

    Height = Height + (UserNote_Tb.Height + 1 + ScrollBarSnapshotNumb.Height + 1 + lSnapshotNumb * (Snapshot1_Tb.Height + 1) + 2) * Twips
    UserNote_Lb.Visible = True
    UserNote_Tb.Visible = True
    UserNoteLast_Chb.Visible = True
    ActSplitSheet_ChB.Visible = True
    ScrollBarSnapshotNumb.Visible = IIf(bCallBYfStopwatch, lSnapshotNumb > 0 + 100, True)  'Oculta se chamado por fStopwatch sem snapshop label. Resolvi ocutar sempre com +100.
    SnapshotLabels_Lb.Visible = ScrollBarSnapshotNumb.Visible

    LbSplit.Visible = lSnapshotNumb = 0    'Embora n|fffd|o seja necess|fffd|rio, achei melhor ocultar e aumentar o bot|fffd|o stop. Se quiser exibir basta comentar esta linha
    '.LbStartStop.Height = LbCntDown.Top - LbSet.Top + LbCntDown.Height 'Fico feio

    UserNote_Tb.Top = TbVisorFnd.Top + TbVisorFnd.Height + 0.1
    UserNote_Lb.Top = UserNote_Tb.Top + 3.4
    UserNote_Lb.Left = 2
    UserNote_Tb.Left = 2 + UserNote_Lb.Width + 0.1
    UserNote_Tb.Width = Width / Twips - UserNote_Lb.Width - (Width / Twips - InsideWidth) - 15    'UserNote_Tb.Width = Width / Twips - UserNote_Lb.Width - 21
    UserNoteLast_Chb.Top = UserNote_Tb.Top
    UserNoteLast_Chb.Left = UserNote_Tb.Left + UserNote_Tb.Width + 1

    ScrollBarSnapshotNumb.Top = UserNote_Tb.Top + 17
    SnapshotLabels_Lb.Top = ScrollBarSnapshotNumb.Top + 1
    ActSplitSheet_ChB.Top = SnapshotLabels_Lb.Top

    LbSnapshot1.Left = LbSet.Left
    ScrollBarSnapshotNumb.Left = LbSnapshot1.Left + LbSnapshot1.Width - ScrollBarSnapshotNumb.Width
    SnapshotLabels_Lb.Left = ScrollBarSnapshotNumb.Left + ScrollBarSnapshotNumb.Width + 2
    ActSplitSheet_ChB.Left = LbSnapshot1.Left

    If lSnapshotNumb > 0 Then
        For lCtrl = 1 To 10
            'Snapshot1_Tb position
            If lCtrl = 1 Then
                Controls("Snapshot" & lCtrl & "_Tb").Top = ScrollBarSnapshotNumb.Top + ScrollBarSnapshotNumb.Height + 1
            Else
                Controls("Snapshot" & lCtrl & "_Tb").Top = Controls("Snapshot" & lCtrl - 1 & "_Tb").Top + Snapshot1_Tb.Height + 1
            End If
            Controls("Snapshot" & lCtrl & "_Tb").Left = SnapshotLabels_Lb.Left

            'LbSnapshot1 position
            Controls("LbSnapshot" & lCtrl).Top = Controls("Snapshot" & lCtrl & "_Tb").Top + 1.5
            If lCtrl = 1 Then
                Controls("LbSnapshot" & lCtrl).Left = Snapshot1_Tb.Left - LbSnapshot1.Width - 0.5
            Else
                Controls("LbSnapshot" & lCtrl).Left = Controls("LbSnapshot" & lCtrl - 1).Left
            End If

            'Snapshot1_Tb width
            If lCtrl = 1 Then
                Controls("Snapshot" & lCtrl & "_Tb").Width = Width / Twips - Snapshot1_Tb.Left - LbSnapshot1.Left - (Width / Twips - InsideWidth) - 1    'Controls("Snapshot" & lCtrl & "_Tb").Width = Width / Twips - Snapshot1_Tb.Left - LbSnapshot1.Left - 7
            Else
                Controls("Snapshot" & lCtrl & "_Tb").Width = Snapshot1_Tb.Width
            End If
        Next
    End If

    LbSnpshtPickCback1.Visible = lActSnapshotTb > 0
    LbSnpshtPickCfore1.Visible = lActSnapshotTb > 0
    LbSnpshtPickCrestore.Visible = lActSnapshotTb > 0
    LbSnpshtSound.Visible = lActSnapshotTb > 0
    If lActSnapshotTb > 0 Then    'Reduz o textbox ativo e exibi icones de edi|fffd||fffd|o
        Controls("Snapshot" & lActSnapshotTb & "_Tb").Width = Snapshot1_Tb.Width - LbSnpshtPickCback1.Width - LbSnpshtPickCfore1.Width - LbSnpshtPickCrestore.Width - LbSnpshtPickCrestore.Width - 5
        LbSnpshtPickCback1.Top = Snapshot1_Tb.Top + 2.9 + (lActSnapshotTb - 1) * (Snapshot1_Tb.Height + 1)
        LbSnpshtPickCback1.Left = Snapshot1_Tb.Left + Controls("Snapshot" & lActSnapshotTb & "_Tb").Width + 1.5

        LbSnpshtPickCfore1.Top = LbSnpshtPickCback1.Top
        LbSnpshtPickCfore1.Left = LbSnpshtPickCback1.Left + LbSnpshtPickCback1.Width + 1.5

        LbSnpshtPickCrestore.Top = LbSnpshtPickCback1.Top
        LbSnpshtPickCrestore.Left = LbSnpshtPickCfore1.Left + LbSnpshtPickCfore1.Width + 1.5

        LbSnpshtSound.Top = LbSnpshtPickCback1.Top
        LbSnpshtSound.Left = LbSnpshtPickCrestore.Left + LbSnpshtPickCrestore.Width + 1.5 + 1
    End If

    'Se ins. note in last, colorir UserNote_Tb de acordo com a cel.
    If rngUserNoteLast Is Nothing Or Not bUserNoteLast Then
        UserNote_Tb.BackColor = &H80FFFF     '&H80000005
        UserNote_Lb.ForeColor = &H80000008
    Else
        UserNote_Tb.BackColor = rngUserNoteLast.Offset(Abs(Not UserNoteLast_Chb.Value), 0).Interior.Color    '&H80000005
        UserNote_Tb.ForeColor = rngUserNoteLast.Offset(Abs(Not UserNoteLast_Chb.Value), 0).Font.Color    '&H80000005
    End If

End Sub

Private Sub AnchToActCelStart()
    Static dLastAnchrd As Date    'Para periodizar rec|fffd|lculos, assim fica mais leve.
    Dim sUpVisibleCells As String: Static sLastUpVisibleCells As String    'Para, se rolar ou posicionar janelas ou alterar |fffd|rea visivel, ignorar periodicidade.

    If appHostApp.WindowState = xlMinimized Then Exit Sub    'Ignorar se minimizado. No Excel 15 nao parece influir em xla, mas vou deixar e criticar a janela da celula ancora logo depois de critica-la

    If rngActCelStart Is Nothing Then    'Sai se cel inicial n|fffd|o existir
        If Top < 0 Then Top = 0    'Exibir se estiver ocultada
        Exit Sub
    Else    ' Verifica se cel inicial ainda existe
        On Error Resume Next: sUpVisibleCells = rngActCelStart.AddressLocal: On Error GoTo 0
        If sUpVisibleCells = "" Then Set rngActCelStart = Nothing: Exit Sub
    End If

    If rngActCelStart.Width = 0 Or rngActCelStart.Height = 0 Then Top = -(Height + 20 * Twips): SizeFormRestLast: Exit Sub

    If dHostAppVer >= 11 + 1 + 2 + 1 Then If rngActCelStart.Parent.Parent.Windows(1).WindowState = xlMinimized Then Exit Sub    'Ignorar se janela minimizada.

    If rngActCelStart.Parent.Name & " - " & rngActCelStart.Parent.Parent.Name <> appHostApp.ActiveWindow.ActiveSheet.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Parent.Name Then
        If dHostAppVer >= 11 + 1 + 2 + 1 Then Exit Sub    'No Excel 15 SDI, se wb nao ativo e portanto janela nao ativa, mas em exib entao ignorar.
        Top = -(Height + 20 * Twips): SizeFormRestLast: Exit Sub
    End If

    If appHostApp.ActiveWindow.FreezePanes = False Then
        Dim rngIntersect As Range: On Error Resume Next: Set rngIntersect = appHostApp.Intersect(appHostApp.ActiveWindow.ActivePane.VisibleRange, rngActCelStart): On Error GoTo 0
        If rngIntersect Is Nothing Then Top = -(Height + 20 * Twips): SizeFormRestLast: Exit Sub
    End If

    sUpVisibleCells = appHostApp.ActiveWindow.ActivePane.VisibleRange.Address & appHostApp.Top & appHostApp.Left & appHostApp.ActiveWindow.Top & appHostApp.ActiveWindow.Left & appHostApp.ActiveWindow.ActiveSheet.Name & " - " & appHostApp.ActiveWorkbook.Name
    If Abs(Now - dLastAnchrd) < TimeSerial(0, 0, 5) And sLastUpVisibleCells = sUpVisibleCells Then sLastUpVisibleCells = "": Exit Sub
    If Not IsMouseDown(vbLeftButton) Then     'Enquanto o mouse estiver press, n|fffd|o ajustar, gera em erro em ExecuteExcel4Macro("GET.DOCUME. S|fffd| bot|fffd|o esquerdo.
        Dim ret: On Error Resume Next: ret = appHostApp.ExecuteExcel4Macro("GET.DOCUMENT(12)")   'Al|fffd|m do mouse, tambem gera erro mouse wheel ativado e form do excel em exibi|fffd||fffd|o, ent|fffd|o, antes testa logo
        If Err.Number = 0 Then
            If dHostAppVer >= 11 + 1 + 2 + 1 Then If rngActCelStart.Parent.Name & " - " & rngActCelStart.Parent.Parent.Name <> appHostApp.ActiveWindow.ActiveSheet.Name & " - " & appHostApp.ActiveWindow.ActiveSheet.Parent.Name Then Exit Sub
            If fGetScrPosMeth Then
                GetScreenCellPos rngActCelStart    'appHostApp.ActiveWindow.ActiveCell
                If Abs(Top - lTop * Twips) > 1.5 * Twips Or Abs(Left - lLeft * Twips) > 1.5 * Twips Or bEchoDisplayInCellAndHide Then 'S|fffd| verifica se deslocar 1.5 ou se tiver ocultando com o mouse away.
                    If bEchoDisplayInCellAndHide Then    'Se ecoando com autohide, hide aqui e sai antes de ancorar para evitar flick.
                        Dim Point As POINTAPI, Result
                        Result = GetCursorPos(Point): Point.Y = Point.Y * 0.75 * Twips: Point.X = Point.X * 0.75 * Twips
                        If Not (Point.Y > lTop * Twips And Point.Y < lTop * Twips + Height And Point.X > lLeft * Twips And Point.X < lLeft * Twips + Width) Then Top = -(Height + 20 * Twips): SizeFormRestLast: Exit Sub
                    End If

                    Top = (lTop + 1 + 13 * 0) * Twips: Left = (lLeft + 20 * 0) * Twips: SizeFormRestLast
                    If bUnanchExcelWin And Not bAlwaysOnTop Then SetForegroundWindow Form_hWnd
                End If
                dLastAnchrd = Now: sLastUpVisibleCells = sUpVisibleCells
            End If
        Else
            dLastAnchrd = Now
        End If
        On Error GoTo 0
    Else
        dLastAnchrd = Now
    End If
End Sub

Private Sub PreparingToClose()
    If Not UserFormCntDown1 Is Nothing Then Unload UserFormCntDown1: Set UserFormCntDown1 = Nothing
    If Not UserFormSound1 Is Nothing Then Unload UserFormSound1: Set UserFormSound1 = Nothing
    If Not UserFormSkin1 Is Nothing Then Unload UserFormSkin1: Set UserFormSkin1 = Nothing

    If bPopupAtLastPos And (Top <> dLastPosTop Or Left <> dLastPosLeft) Then
        dLastPosTop = Top / Twips
        dLastPosLeft = Left / Twips
        WriteINISetting1
    End If

    bSplit = False

    CollectionInst.Remove sCountInstAdd
    If CollectionInst.Count = 0 Then KillLoopAPI: lCountInstAdd = 0    'Se n|fffd|o restou cronometro rodando finaliza o loop de api e zera contagem de instancias

    'Ativa Excel ao sair, pois ao exib. outro form em cima do Stopwatch, o Excel perde foco
    If bIsCOMAddin Then SetForegroundWindow App_hWnd1            ' Como tenho o handle melhor que AppActivate.
End Sub

Private Sub CountDownExpire(lTickCountDownFix1 As Long, dTimeDownFix1 As Date)
    PrintPapel 0, dTimeDownFix1, IIf(IsPortg, "Expirar", "Expire"), "", WriteTbVisor(0)   'Simula dbElapsed = 0 no visor/papel, pois eventualmente pode ter passado mil|fffd|simos
    lBotPress = 0: bCntDown = False: dbElapsed = 0: LoopAPI  'xLbSet_Click 1

    If bCDWav Then
        Call sndPlaySound32(sCDFileWav, &H1)
    End If
    If bCDRun Then
        Shell sCDFileRun, vbNormalFocus
    End If
    If bCDAlert Then
        MyMsgBox sCDTxtAlert, 1, sAddInCaptByApp, , Left / Twips + 3, Top / Twips + 21 + 3, IIf(bCDQuit, App_hWnd1, Form_hWnd), 0, bAlwaysOnTop    'Se for fechar n|fffd|o ancorar no userform, se n|fffd|o fecha tamb|fffd|m.
    End If

    If bCDBeep Then    'Deixar por |fffd|ltimo, pois n|fffd|o |fffd| assincron.
        Dim i
        For i = 1 To lCDBeep
            Call Beep: MyWait 0.08
        Next
    End If

    If bCDReCntdown Then    'Start the countdown again in endless loop
        lBotPress = 1
        bCntDown = True
        PrintPapel dbCDElapsed, dTimeDownFix1, LbStartStop.Caption, "", WriteTbVisor(dbCDElapsed)
        dTimeDownFix = dTimeDownFix1: lTickCountDownFix = lTickCountDownFix1: dbStart = lTickCountDownFix1 / 1000 + dbCDElapsed: LoopAPI: lTickCountDownFix = 0  'LoopAPI agora para sincronizar o TickCount fixado.
    End If

    If bCDStart Then    'Press Stopwatch Reset and Start buttons (All run from zero).
        If bMultResetAttach And CollectionInst.Count > 1 Then
            xLbSet_ClickMult lResetMode
        Else
            xLbSet_Click lResetMode
        End If

        If bMultStartAttach And CollectionInst.Count > 1 Then
            xLbStartStop_ClickMult lBotPress, , lTickCountDownFix1, dTimeDownFix1
        Else
            dbStart = lTickCountDownFix1 / 1000 - dbElapsed
            lBotPress = 1
            PrintPapel dbElapsed, dTimeDownFix1, LTrim(LbStartStop.Caption), "", TbVisor.Value & TbVisorFrc.Value
        End If
    End If

    If bCDRestart Then    'Press Stopwatch Start/Restart buttons (All from current, any including zero)
        If bMultStartAttach And CollectionInst.Count > 1 Then    'Simula que |fffd| uma inst|fffd|ncia em modo Start (padr|fffd|o inicial aqui) para chamar as outras.
            xLbStartStop_ClickMult lBotPress, , lTickCountDownFix1, dTimeDownFix1
        End If
        If bMultRestartAttach And CollectionInst.Count > 1 Then     'Simula que |fffd| uma inst|fffd|ncia em modo Restart para chamar as outras.
            lBotPress = 2: dbElapsed = 0.001: LoopAPI
            xLbStartStop_ClickMult lBotPress, , lTickCountDownFix1, dTimeDownFix1
            lBotPress = 0: dbElapsed = 0: LoopAPI    'Depois da simula|fffd||fffd|o restaura padr|fffd|o inicial aqui para ent|fffd|o acionar o stopwatch aqui normalmente como uno sobrepondo as simula|fffd||fffd|es.
        End If

        If dbElapsedCurr > 0 Then lBotPress = 2: dbElapsed = dbElapsedCurr: LoopAPI    'Restaura tempo e deixa em modo de reiniciar
        dbStart = lTickCountDownFix1 / 1000 - dbElapsed
        lBotPress = 1
        PrintPapel dbElapsed, dTimeDownFix1, LTrim(LbStartStop.Caption), "", TbVisor.Value & TbVisorFrc.Value
    End If

    If bCDQuit Then
        Cancel_Bt_Click    'xLbStopIns_Click 1    'Sai inserindo para diferenciar de cancelar. N|fffd|o sei porque sair inserindo, alterei na vers|fffd|o 4.0
    End If
    WriteINISetting1    'Salvar |fffd|ltima conf. de Count pelo menos nos Ini
End Sub

Private Sub AlinhReadINISetting()
    vModal = vModalIni
    bPopupFormatSel = bPopupFormatSelIni
    bPopupSel = bPopupSelIni
    HotKey = HotKeyIni
    lShortMenuPos = lShortMenuPosIni
    bResetAtPopup = bResetAtPopupIni
    bStartAtPopup = bStartAtPopupIni
    bSplitAtPopup = bSplitAtPopupIni
    bSplitInBkGrAtPopup = bSplitInBkGrAtPopupIni
    bPaperRibbon = bPaperRibbonIni
    bPopupAtLastPos = bPopupAtLastPosIni
    dLastPosTop = dLastPosTopIni
    dLastPosLeft = dLastPosLeftIni

    lMode = lModeIni
    lNumDecim = lNumDecimIni
    lCtrlPanelSize = lCtrlPanelSizeIni
    lDispSize = lDispSizeIni
    lStopInsMode = lStopInsModeIni
    bInsActCelStart = bInsActCelStartIni Or bFromAutoPopCell
    bUserNoteLast = bUserNoteLastIni
    lSnapshotNumb = lSnapshotNumbIni
    Dim lCtrl As Long
    For lCtrl = 0 To 10
        arrSnpshtLb(lCtrl) = arrSnpshtLbIni(lCtrl)
        arrBackColor(lCtrl) = arrBackColorIni(lCtrl)
        arrForeColor(lCtrl) = arrForeColorIni(lCtrl)
        arrbSndAtSnpshtLb(lCtrl) = arrbSndAtSnpshtLbIni(lCtrl)
        arrsWavSndAtSnpshtLb(lCtrl) = arrsWavSndAtSnpshtLbIni(lCtrl)
    Next

    lCDHour = lCDHourIni
    lCDMin = lCDMinIni
    lCDSec = lCDSecIni
    lCDSecFract = lCDSecFractIni
    bCDtoDTime = bCDtoDTimeIni
    dbCDtoDTime = dbCDtoDTimeIni
    bCDBeep = bCDBeepIni
    lCDBeep = lCDBeepIni
    bCDQuit = bCDQuitIni
    bCDWav = bCDWavIni
    sCDFileWav = sCDFileWavIni
    bCDRun = bCDRunIni
    sCDFileRun = sCDFileRunIni
    bCDAlert = bCDAlertIni
    sCDTxtAlert = sCDTxtAlertIni
    bCDStart = bCDStartIni
    bCDSpeak = bCDSpeakIni
    lCDSpeak = lCDSpeakIni
    bCDRestart = bCDRestartIni
    bCDReCntdown = bCDReCntdownIni

    Set rngActCelStart = rngActCelStartIni
    Set ActShAtPopup = ActShAtPopupIni

    bMultStartAttach = bMultStartAttachIni
    bMultStopAttach = bMultStopAttachIni
    bMultRestartAttach = bMultRestartAttachIni
    bMultStopInsAttach = bMultStopInsAttachIni
    bMultResetAttach = bMultResetAttachIni

    bSndDisableAll = bSndDisableAllIni
    bSndAtStart = bSndAtStartIni
    bSndAtStop = bSndAtStopIni
    bSndAtRestart = bSndAtRestartIni
    bSndAtStopIns = bSndAtStopInsIni
    bSndAtSnapshot = bSndAtSnapshotIni
    bSndAtReset = bSndAtResetIni
    sWavSndAtStart = sWavSndAtStartIni
    sWavSndAtStop = sWavSndAtStopIni
    sWavSndAtRestart = sWavSndAtRestartIni
    sWavSndAtStopIns = sWavSndAtStopInsIni
    sWavSndAtSnapshot = sWavSndAtSnapshotIni
    sWavSndAtReset = sWavSndAtResetIni

    lClickOnDisplay = lClickOnDisplayIni
    bEnableBackgrond = bEnableBackgrondIni
    lColorBackground = lColorBackgroundIni
    sPictFile = sPictFileIni
    lPictAlignment = lPictAlignmentIni
    lPictSizeMode = lPictSizeModeIni
    bPictTiling = bPictTilingIni
    bTranspDisplay = bTranspDisplayIni
    bTranspCtrlPanel = bTranspCtrlPanelIni
    bTranspSnapshotLb = bTranspSnapshotLbIni
    bTranspPaper = bTranspPaperIni
    bHideTitleBar = bHideTitleBarIni

    FitaPapel() = FitaPapelIni()

    lResetMode = lResetModeIni
    bMultStartStopsAttach = bMultStartStopsAttachIni
    bMultRestartStopsAttach = bMultRestartStopsAttachIni
    bAutoHideCtrlPanel = bAutoHideCtrlPanelIni
    bAnchActCelStart = bAnchActCelStartIni
    bAnchCelAdjWidth = bAnchCelAdjWidthIni
    bAnchCelAdjHeight = bAnchCelAdjHeightIni
    bUnanchExcelWin = bUnanchExcelWinIni
    bAlwaysOnTop = bAlwaysOnTopIni
    lToolbarPos = lToolbarPosIni
    bMultStartStopInssAttach = bMultStartStopInssAttachIni
    bMultRestartStopInssAttach = bMultRestartStopInssAttachIni
    lInsOvrCnts = lInsOvrCntsIni
    lInsAlsoDTime = lInsAlsoDTimeIni

    lOtherButtsMode = lOtherButtsModeIni
    lCellAsButTriggSlc = lCellAsButTriggSlcIni
    lEchoDisplayInCell = lEchoDisplayInCellIni

    bCallBYfStopwatch = bCallBYfStopwatchIni
    If bFromAutoPopCellIni Then bFromAutoPopCell = bFromAutoPopCellIni: bFromAutoPopCellIni = False    'Se autopop, s|fffd| capt uma vez o ini e falsea, pois n|fffd|o h|fffd| outro ponto onde falsear e tanto autopop como menu vem pelo mesmo sub. Se precisar em mod stand vai atrav|fffd|s de argumento como no PopMenu
End Sub

Private Sub UpdtCtrlNewAlinhReadINISetting()
'Update controles with new setting
    vEnableEvents = False
    ScrollBarCtrlPanel.Value = lCtrlPanelSize
    ScrollBarSize.Value = lDispSize
    ScrollBarMode.Value = lMode
    ScrollBarDecimal.Value = ScrollBarDecimal.Max - lNumDecim    'Subtrai do Max para inverter seta
    UserNoteLast_Chb.Value = bUserNoteLast
    ScrollBarSnapshotNumb.Value = lSnapshotNumb
    vEnableEvents = True
    Call LbStopInsUpt: LbSetUpt: LbOtherButtsUpt
    UpdtCtrlColors
    SkinSettingUpt
    bUserNoteUpd = False
End Sub

Public Sub WriteINISetting1()
    AlinhWriteINISetting    'Realinha as vari|fffd|veis INI antes de salvar ou alterar cfg pelo menu
    If Not bCallBYfStopwatch Then WriteINISetting        'Se chamado pela fun|fffd||fffd|o fStopwatch alinha para altera|fffd||fffd|es via menu mas n|fffd|o salva preservando cfgIni
End Sub

Private Sub AlinhWriteINISetting()
    vModalIni = vModal
    bPopupFormatSelIni = bPopupFormatSel
    bPopupSelIni = bPopupSel
    HotKeyIni = HotKey
    lShortMenuPosIni = lShortMenuPos
    bResetAtPopupIni = bResetAtPopup
    bStartAtPopupIni = bStartAtPopup
    bSplitAtPopupIni = bSplitAtPopup
    bSplitInBkGrAtPopupIni = bSplitInBkGrAtPopup
    bPaperRibbonIni = bPaperRibbon
    bPopupAtLastPosIni = bPopupAtLastPos
    dLastPosTopIni = dLastPosTop
    dLastPosLeftIni = dLastPosLeft

    lModeIni = lMode
    lNumDecimIni = lNumDecim
    lCtrlPanelSizeIni = lCtrlPanelSize
    lDispSizeIni = lDispSize
    lStopInsModeIni = lStopInsMode
    bInsActCelStartIni = bInsActCelStart
    bUserNoteLastIni = bUserNoteLast
    lSnapshotNumbIni = lSnapshotNumb
    Dim lCtrl As Long
    For lCtrl = 0 To 10
        arrSnpshtLbIni(lCtrl) = arrSnpshtLb(lCtrl)
        arrBackColorIni(lCtrl) = arrBackColor(lCtrl)
        arrForeColorIni(lCtrl) = arrForeColor(lCtrl)
        arrbSndAtSnpshtLbIni(lCtrl) = arrbSndAtSnpshtLb(lCtrl)
        arrsWavSndAtSnpshtLbIni(lCtrl) = arrsWavSndAtSnpshtLb(lCtrl)
    Next

    lCDHourIni = lCDHour
    lCDMinIni = lCDMin
    lCDSecIni = lCDSec
    lCDSecFractIni = lCDSecFract
    bCDtoDTimeIni = bCDtoDTime
    dbCDtoDTimeIni = dbCDtoDTime
    bCDBeepIni = bCDBeep
    lCDBeepIni = lCDBeep
    bCDQuitIni = bCDQuit
    bCDWavIni = bCDWav
    sCDFileWavIni = sCDFileWav
    bCDRunIni = bCDRun
    sCDFileRunIni = sCDFileRun
    bCDAlertIni = bCDAlert
    sCDTxtAlertIni = sCDTxtAlert
    bCDStartIni = bCDStart
    bCDSpeakIni = bCDSpeak
    lCDSpeakIni = lCDSpeak
    bCDRestartIni = bCDRestart
    bCDReCntdownIni = bCDReCntdown

    Set rngActCelStartIni = rngActCelStart
    Set ActShAtPopupIni = ActShAtPopup

    bMultStartAttachIni = bMultStartAttach
    bMultStopAttachIni = bMultStopAttach
    bMultRestartAttachIni = bMultRestartAttach
    bMultStopInsAttachIni = bMultStopInsAttach
    bMultResetAttachIni = bMultResetAttach

    bSndDisableAllIni = bSndDisableAll
    bSndAtStartIni = bSndAtStart
    bSndAtStopIni = bSndAtStop
    bSndAtRestartIni = bSndAtRestart
    bSndAtStopInsIni = bSndAtStopIns
    bSndAtSnapshotIni = bSndAtSnapshot
    bSndAtResetIni = bSndAtReset
    sWavSndAtStartIni = sWavSndAtStart
    sWavSndAtStopIni = sWavSndAtStop
    sWavSndAtRestartIni = sWavSndAtRestart
    sWavSndAtStopInsIni = sWavSndAtStopIns
    sWavSndAtSnapshotIni = sWavSndAtSnapshot
    sWavSndAtResetIni = sWavSndAtReset

    lClickOnDisplayIni = lClickOnDisplay
    bEnableBackgrondIni = bEnableBackgrond
    lColorBackgroundIni = lColorBackground
    sPictFileIni = sPictFile
    lPictAlignmentIni = lPictAlignment
    lPictSizeModeIni = lPictSizeMode
    bPictTilingIni = bPictTiling
    bTranspDisplayIni = bTranspDisplay
    bTranspCtrlPanelIni = bTranspCtrlPanel
    bTranspSnapshotLbIni = bTranspSnapshotLb
    bTranspPaperIni = bTranspPaper
    bHideTitleBarIni = bHideTitleBar

    FitaPapelIni() = FitaPapel()

    lResetModeIni = lResetMode
    bMultStartStopsAttachIni = bMultStartStopsAttach
    bMultRestartStopsAttachIni = bMultRestartStopsAttach
    bAutoHideCtrlPanelIni = bAutoHideCtrlPanel
    bAnchActCelStartIni = bAnchActCelStart
    bAnchCelAdjWidthIni = bAnchCelAdjWidth
    bAnchCelAdjHeightIni = bAnchCelAdjHeight
    bUnanchExcelWinIni = bUnanchExcelWin
    bAlwaysOnTopIni = bAlwaysOnTop
    lToolbarPosIni = lToolbarPos
    bMultStartStopInssAttachIni = bMultStartStopInssAttach
    bMultRestartStopInssAttachIni = bMultRestartStopInssAttach
    lInsOvrCntsIni = lInsOvrCnts
    lInsAlsoDTimeIni = lInsAlsoDTime

    lOtherButtsModeIni = lOtherButtsMode
    lCellAsButTriggSlcIni = lCellAsButTriggSlc
    lEchoDisplayInCellIni = lEchoDisplayInCell

    bCallBYfStopwatchIni = bCallBYfStopwatch
End Sub

Sub OpenSaveSettingByUsr(Optional bOpen As Boolean = False)
    Dim vFileName    'as String need be variable
    Dim sDllPath As String
    Static ChDirOne As Boolean
    If ChDirOne = False And (sOpenSettingFile = "" Or VBA.FileSystem.Dir(sOpenSettingFile) = "") Then
        On Error Resume Next
        If Mid(ThisDLLPath, 2, 1) = ":" Then ChDrive ThisDLLPath
        ChDir ThisDLLPath
        On Error GoTo 0
        ChDirOne = True
    Else
        If sOpenSettingFile <> "" And VBA.FileSystem.Dir(sOpenSettingFile) <> "" Then
            vFileName = Left(sOpenSettingFile, InStrRev(sOpenSettingFile, appHostApp.PathSeparator))
            If Mid(vFileName, 2, 1) = ":" Then ChDrive vFileName
            ChDir vFileName
        End If
    End If

    If bOpen Then    'Open
        If IsPortg Then
            vFileName = appHostApp.GetOpenFilename("Arquivos (*.ini),*.ini", , "Abrir Arquivo de Configura|fffd||fffd|o", "Abrir")
        Else
            vFileName = appHostApp.GetOpenFilename("Files (*.ini),*.ini", , "Open Setting File", "Open")
        End If
        If vFileName = False Then Exit Sub
        AlinhWriteINISetting    'Realinha as vari|fffd|veis INI antes de abrir, porque se falhar na leitura volta restaurando
        ReadINISetting CStr(vFileName)
        AlinhReadINISetting    'Realinha as vari|fffd|veis INI aqui depois de abrir
        UpdtCtrlNewAlinhReadINISetting
    Else    'Save
ReTry:
        If IsPortg Then
            vFileName = appHostApp.GetSaveAsFilename("ExcelStopwatch_Novo1.ini", "Arquivos (*.ini),*.ini", , "Salvar Configura|fffd||fffd|o Como", "Salvar")
        Else
            vFileName = appHostApp.GetSaveAsFilename("ExcelStopwatch_New1.ini", "Files (*.ini),*.ini", , "Save Setting As", "Save")
        End If
        If vFileName = False Then Exit Sub

        If Dir(vFileName) <> "" Then
            Msg1 = IIf(IsPortg, "O arquivo '" & vFileName & "' j|fffd| existe! Sobrescrever?", _
                       "The file '" & vFileName & "' already exists! Overwrite?")
            Msg2 = sAddInCaptByApp & IIf(IsPortg, " - Sobrescrever!", " - Overwrite!")
            If MyMsgBox(Msg1, 2, Msg2, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2 Then GoTo ReTry
            If LCase(vFileName) = LCase(sINIfile) Then GoTo ReTry    'N|fffd|o aceitar subscrever padr|fffd|o
        End If
        AlinhWriteINISetting    'Realinha as vari|fffd|veis INI antes de salvar
        WriteINISetting CStr(vFileName)
    End If
End Sub

Sub OpenDefaultSetting1()
    Msg1 = IIf(IsPortg, "Toda a configura|fffd||fffd|o padr|fffd|o original ser|fffd| restaurada. OK?", "All the original default setting will be restored. OK?")
    Msg2 = IIf(IsPortg, "Restaurar Configura|fffd||fffd|o Padr|fffd|o", "Restore Default Setting")
    If MyMsgBox(Msg1, 2, Msg2, , Left / Twips - 95, Top / Twips - 15, Form_hWnd, , bAlwaysOnTop) = 2 Then Exit Sub

    OpenDefaultSetting
    If HotKey <> "" Then fHotKey HotKey, False, False
    AlinhReadINISetting    'Realinha as vari|fffd|veis INI depois de abrir para salvar em seguida
    UpdtCtrlNewAlinhReadINISetting
    WriteINISetting1
    ShortMenuPos 0: ToolbarPos 0      'Exclui
    ShortMenuPos IIf(lShortMenuPosIni <> 0, 1, 0), lShortMenuPosIni = 2: ToolbarPos IIf(lToolbarPosIni <> 0, 1, 0), lToolbarPosIni = 2    'Recria
    If TbVisor.Top > 20 Then LabelLedPapel_Click    'Oculta papel
    SetWindowLongA Form_hWnd, GWL_HWNDPARENT, App_hWnd    'Ancora na janela do Excel padr|fffd|o. Necess|fffd|rio depois da op|fffd||fffd|o bUnanchExcelWin.
    SetWindowPos Form_hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, flags
End Sub

Private Sub SetSounds(lRetIdx As Long)
    If Not UserFormSound1 Is Nothing Then Exit Sub
    Set UserFormSound1 = New UserFormSound
    Set UserFormSound1.UserFormStopwatch1 = Me
    UserFormSound1.lRetIdx = lRetIdx
    UserFormSound1.Show vModal
End Sub

Private Sub SkinSettingForm()
    If Not UserFormSkin1 Is Nothing Then Exit Sub
    Set UserFormSkin1 = New UserFormSkin
    Set UserFormSkin1.UserFormStopwatch1 = Me
    '    UserFormSkin1.lRetIdx = lRetIdx
    UserFormSkin1.Show vModal
End Sub

Public Sub SkinSettingUpt()
    If bEnableBackgrond Then
        BackColor = lColorBackground
        On Error Resume Next
        If sPictFile <> "" Then
            If Dir(sPictFile) <> "" Then
                Picture = LoadPicture(sPictFile)
                If Err.Number <> 0 Then Picture = LoadPicture("")
            Else
                Picture = LoadPicture("")
            End If
        Else
            Picture = LoadPicture("")
        End If
        On Error GoTo 0
        PictureAlignment = lPictAlignment   '0 a 4 dft 2
        PictureSizeMode = IIf(lPictSizeMode = 2, 3, lPictSizeMode)    '0 a 3 dft 0 sem 2
        PictureTiling = bPictTiling
    Else
        BackColor = &H8000000F
        Picture = LoadPicture("")
    End If

    On Error Resume Next
    Dim lCtrl
    For Each lCtrl In Controls    'Faz antes tudo opaco ou transp...
        lCtrl.BackStyle = IIf(bEnableBackgrond And bTranspCtrlPanel, 0, 1)
    Next
    On Error GoTo 0

    TbVisor.BackStyle = IIf(bEnableBackgrond And bTranspDisplay, 0, 1)  'dft true
    TbVisorFnd.BackStyle = IIf(bEnableBackgrond And bTranspDisplay, 0, 1)
    TbVisorFrc.BackStyle = IIf(bEnableBackgrond And bTranspDisplay, 0, 1)
    TbVisorFrontTransp.BackStyle = 0    'fmBackStyleTransparent
    LabelMode.BackStyle = IIf(bEnableBackgrond And bTranspDisplay, 0, 1)
    LabelDecimal.BackStyle = IIf(bEnableBackgrond And bTranspDisplay, 0, 1)

    For lCtrl = 1 To 10
        Controls("Snapshot" & lCtrl & "_Tb").BackStyle = IIf(bEnableBackgrond And bTranspSnapshotLb, 0, 1)
        If lCtrl < 10 Then Controls("LabelPapel" & lCtrl).BackStyle = IIf(bEnableBackgrond And bTranspPaper, 0, 1)
    Next

    'bHideTitleBar
    If bHideTitleBar Then
        If Height / Twips - InsideHeight > dFormTitleHeight Then
            formSizeble Form_hWnd, bHideTitleBar
            bUserNoteUpd = False    'Para atualizar form size no pr|fffd|ximo loop.
            'Top = Top + dFormTitleHeight * Twips 'Simula barra como algo acima. Comentei, pois n|fffd|o parece t|fffd|o interessante
            SetWindowText Form_hWnd, Caption & " "    'Flag alterando para ser verificado
        End If
    Else
        If Height / Twips - InsideHeight < dFormTitleHeight Then
            formSizeble Form_hWnd, bHideTitleBar
            bUserNoteUpd = False
            'Top = Top - dFormTitleHeight * Twips
            SetWindowText Form_hWnd, Caption & " "
        End If
    End If
    SetWindowLongA Form_hWnd, GWL_HWNDPARENT, IIf(bUnanchExcelWin, 0&, App_hWnd1)   'Ancora ou desancora
    SetWindowPos Form_hWnd, IIf(bAlwaysOnTop, HWND_TOPMOST, HWND_NOTOPMOST), 0, 0, 0, 0, flags

    bAutoHideCtrlPanelOn = bAutoHideCtrlPanel    'Como n|fffd|o vai ser op|fffd||fffd|o padr|fffd|o |fffd| melhor iniciar logo oculto se optado
End Sub

Sub NavShThruVisor(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Dim lRowOffset As Long
    Dim lColOffset As Long
    If appHostApp.ActiveWindow.ActiveCell Is Nothing Then Exit Sub Else On Error GoTo ErrorHandler    'O controle de erro |fffd| s|fffd| por preven|fffd||fffd|o, pois todos os erros foram verificados

    If KeyCode >= 37 And KeyCode <= 40 And Shift <> 2 Then
        If KeyCode = 37 Then lColOffset = -1
        If KeyCode = 38 Then lRowOffset = -1
        If KeyCode = 39 Then lColOffset = 1
        If KeyCode = 40 Then lRowOffset = 1
        If appHostApp.ActiveWindow.ActiveCell.Row + lRowOffset <= 0 Then lRowOffset = -appHostApp.ActiveWindow.ActiveCell.Row + 1
        If appHostApp.ActiveWindow.ActiveCell.Row + lRowOffset >= appHostApp.ActiveWindow.ActiveCell.EntireColumn.Rows.Count Then lRowOffset = appHostApp.ActiveWindow.ActiveCell.EntireColumn.Rows.Count - appHostApp.ActiveWindow.ActiveCell.Row
        If appHostApp.ActiveWindow.ActiveCell.Column + lColOffset <= 0 Then lColOffset = -appHostApp.ActiveWindow.ActiveCell.Column + 1
        If appHostApp.ActiveWindow.ActiveCell.Column + lColOffset >= appHostApp.ActiveWindow.ActiveCell.EntireRow.Columns.Count Then lColOffset = appHostApp.ActiveWindow.ActiveCell.EntireRow.Columns.Count - appHostApp.ActiveWindow.ActiveCell.Column
        appHostApp.ActiveWindow.ActiveCell.Offset(lRowOffset, lColOffset).Select
    End If

    If KeyCode >= 37 And KeyCode <= 40 And Shift = 2 Then
        If KeyCode = 37 Then lColOffset = xlToLeft
        If KeyCode = 38 Then lRowOffset = xlUp
        If KeyCode = 39 Then lColOffset = xlToRight
        If KeyCode = 40 Then lRowOffset = xlDown
        appHostApp.ActiveWindow.ActiveCell.End(lRowOffset + lColOffset).Select
    End If

    If (KeyCode = 33 Or KeyCode = 34) And Shift = 0 Then
        lRowOffset = appHostApp.ActiveWindow.ActiveCell.Row - appHostApp.ActiveWindow.ActivePane.VisibleRange.Row
        If KeyCode = 33 Then appHostApp.ActiveWindow.LargeScroll , 1 Else appHostApp.ActiveWindow.LargeScroll 1
        If lRowOffset > appHostApp.ActiveWindow.ActivePane.VisibleRange.Rows.Count Then lRowOffset = appHostApp.ActiveWindow.ActivePane.VisibleRange.Rows.Count - 1
        If appHostApp.ActiveWindow.ActivePane.VisibleRange.Row + lRowOffset > appHostApp.ActiveWindow.ActiveCell.EntireColumn.Rows.Count Then lRowOffset = appHostApp.ActiveWindow.ActiveCell.EntireColumn.Rows.Count - appHostApp.ActiveWindow.ActivePane.VisibleRange.Row
        lColOffset = appHostApp.ActiveWindow.ActivePane.VisibleRange.Row    'Estoca para, se select alterar, restaurar posi|fffd||fffd|o com SmallScroll.
        appHostApp.ActiveWindow.ActiveSheet.Cells(appHostApp.ActiveWindow.ActivePane.VisibleRange.Row + lRowOffset, appHostApp.ActiveWindow.ActiveCell.Column).Select
        If lColOffset <> appHostApp.ActiveWindow.ActivePane.VisibleRange.Row Then appHostApp.ActiveWindow.SmallScroll , appHostApp.ActiveWindow.ActivePane.VisibleRange.Row - lColOffset
    End If

    If KeyCode = 33 And Shift = 2 Then appHostApp.ActiveWindow.ActiveSheet.Previous.Select
    If KeyCode = 34 And Shift = 2 Then appHostApp.ActiveWindow.ActiveSheet.Next.Select

    If KeyCode = 33 And Shift = 4 Then appHostApp.ActiveWindow.LargeScroll ToRight:=-1
    If KeyCode = 34 And Shift = 4 Then appHostApp.ActiveWindow.LargeScroll ToRight:=1

    If KeyCode = 117 And Shift = 3 Then appHostApp.ActiveWindow.ActivatePrevious
    If KeyCode = 117 And Shift = 2 Then appHostApp.ActiveWindow.ActivateNext

    If KeyCode = 9 Then If Shift = 1 Then appHostApp.ActiveWindow.ActiveCell.Previous.Activate Else appHostApp.ActiveWindow.ActiveCell.Next.Activate
ErrorHandler:
End Sub

Private Sub TbVisorFrc_Enter()    'Necessario para  NavShThruVisor com TAB key
    TbVisorFnd.SetFocus
End Sub

Private Sub CtrlPanelShow_Lb_Click()    'Private Sub CtrlPanelShow_Lb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If sIgnClickIfDrag = CtrlPanelShow_Lb.Name Then   'Ignorar click se houver arrasto do form por este controle
        sIgnClickIfDrag = ""
        Exit Sub
    End If

    If bAutoHideCtrlPanelOn Then bAutoHideCtrlPanelOn = False: bUserNoteUpd = False
End Sub

'Let properties para substituir Width and Heigh and make possible small size than VBA via API
Property Let WidthAPI(sngWidth As Single)
    If sngWidth >= 92.25 * Twips And Height > 25.25 * Twips Then Width = sngWidth Else SizeFormAPI sngWidth, True                'If working with size supported by VBA, use its property.
End Property
Property Let HeightAPI(sngHeight As Single)
    If sngHeight >= 25.25 * Twips And Width > 92.25 * Twips Then Height = sngHeight Else SizeFormAPI sngHeight, False                 'If working with size supported by VBA, use its property.
End Property
Private Sub SizeFormAPI(sngDim As Single, bByWidth As Boolean)
    Dim R As RECT
    GetWindowRect Form_hWnd, R
    If bByWidth Then
        R.Right = R.Left + (R.Right - R.Left) * sngDim / Width    'Alterando na propor|fffd||fffd|o dispensa convers|fffd|o de point e pixel
    Else
        R.Bottom = R.Top + (R.Bottom - R.Top) * sngDim / Height     'Alterando na propor|fffd||fffd|o dispensa convers|fffd|o de point e pixel
    End If
    AdjustWindowRectEx R, 0&, False, 0&    'Com 0& altera tamanho mantendo cfg de caption e style
    If 2 = 2 Then    'Optei por move, mas ambas s|fffd|o eficientes e ficam para testes eventuais.
        MoveWindow Form_hWnd, R.Left, R.Top, R.Right - R.Left, R.Bottom - R.Top, True
    Else
        Dim hDWP As Long: hDWP = BeginDeferWindowPos(1)
        DeferWindowPos hDWP, Form_hWnd, HWND_TOP, R.Left, R.Top, R.Right - R.Left, R.Bottom - R.Top, SWP_SHOWWINDOW
        EndDeferWindowPos hDWP
    End If
End Sub

Private Sub SizeFormRestLast()    'Ao alterar Top ou Left do form como no arrastar com mouse, altera dim se menores do que suportado pelo VBA.
    Do While Width <> lastFormWidth Or Height <> lastFormHeight
        If Height <> lastFormHeight Then HeightAPI = lastFormHeight
        If Width <> lastFormWidth Then WidthAPI = lastFormWidth
    Loop
End Sub

Private Sub GetFormBordAPI()
    Dim R As RECT, Rc As RECT, bw, th
    GetWindowRect Form_hWnd, R
    GetClientRect Form_hWnd, Rc
    bw = ((R.Right - R.Left) - (Rc.Right - Rc.Left)) / 2    'Border witdh
    'th = ((R.Bottom - R.Top) - (Rc.Bottom - Rc.Top)) - 2 * bw    'Title height
    th = ((R.Bottom - R.Top) - (Rc.Bottom - Rc.Top)) - 1.714 * bw    'Title height 'N|fffd|o sei mas n|fffd|o |fffd| 2, mas menos

    Msg1 = dFormTitleHeight
    bw = bw * 72 / ScreenResol(0)   'Convert Pixel to Point
    th = th * 72 / ScreenResol(1)    'Convert Pixel to Point   Teria que ser 27 e n|fffd|o 26
End Sub


' InQuest injected base64 decoded content
' -Jzl
' )"{,
' j'v&
' j'v&
' -Jzl
' -Jzl
' ~`ZrD

INQUEST-PP=macro
