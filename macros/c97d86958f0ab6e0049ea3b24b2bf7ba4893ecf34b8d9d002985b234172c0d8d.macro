Attribute VB_Name = "AAA_ExportCode"
Option Explicit


Private Sub CreateXLAXLAM()
  ThisWorkbook.IsAddin = True
  ThisWorkbook.SaveAs ThisWorkbook.path & "\ExcelProtect.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.Saved = True
End Sub


Private Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.names.Count > 0 Then
      For i = 1 To ThisWorkbook.names.Count
          If ThisWorkbook.names(i).Visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub



Public Sub ExportMyModules()
  Dim cm
  Dim counter As Long
  MkFullDir ThisWorkbook.path & "\vba"
  MyKill ThisWorkbook.path & "\vba\*.bas"
  MyKill ThisWorkbook.path & "\vba\*.cls"
  MyKill ThisWorkbook.path & "\vba\*.frx"
  MyKill ThisWorkbook.path & "\vba\*.frm"
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, ThisWorkbook.path & "\vba"
      End If
    End If
  Next

End Sub


Private Function ExportVBComponent(ByRef VBComp, _
                FolderName As String, _
                Optional fileName As String, _
                Optional OverwriteExisting As Boolean = True) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This function exports the code module of a VBComponent to a text
    ' file. If FileName is missing, the code will be exported to
    ' a file with the same name as the VBComponent followed by the
    ' appropriate extension.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim Extension As String
    Dim fname As String
    Extension = GetFileExtension(VBComp:=VBComp)
    If Trim(fileName) = vbNullString Then
        fname = VBComp.name & Extension
    Else
        fname = fileName
        If InStr(1, fname, ".", vbBinaryCompare) = 0 Then
            fname = fname & Extension
        End If
    End If
    
    If StrComp(Right(FolderName, 1), "\", vbBinaryCompare) = 0 Then
        fname = FolderName & fname
    Else
        fname = FolderName & "\" & fname
    End If
    
    If Dir(fname, vbNormal + vbHidden + vbSystem) <> vbNullString Then
        If OverwriteExisting = True Then
            Kill fname
        Else
            ExportVBComponent = False
            Exit Function
        End If
    End If
    
    VBComp.Export fileName:=fname
    ExportVBComponent = True
    
    End Function
    
Private Function GetFileExtension(ByRef VBComp) As String
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This returns the appropriate file extension based on the Type of
' the VBComponent.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case VBComp.Type
        Case 2 ' vbext_ct_ClassModule
            GetFileExtension = ".cls"
        Case 100 ' vbext_ct_Document
            GetFileExtension = ".cls"
        Case 3 ' vbext_ct_MSForm
            GetFileExtension = ".frm"
        Case 1 ' vbext_ct_StdModule
            GetFileExtension = ".bas"
        Case Else
            GetFileExtension = ".bas"
    End Select
    
End Function




Attribute VB_Name = "AboutDlg"
Attribute VB_Base = "0{59BC412D-BF86-4B17-8703-5A42526AFAA8}{967734F5-5415-4877-8DFF-CF0FA1BD89F4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Private Sub CommandButton1_Click()
    Me.Hide
End Sub

Private Sub Label3_Click()
  On Error Resume Next
  Call Shell("explorer.exe http://www.stromwerken.de", 1)
End Sub


Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection

Private Function GetNextLine(ByRef S As String) As String

    Dim rs As String
    Do
        rs = GetLine(S)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(S)) <= 0 Then
            GetNextLine = ""
            S = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    If m_Lines Is Nothing Then
      Set m_Lines = New Collection
      Set m_Sec = New Collection
    End If
    If Len(txt) = 0 Then Exit Sub
    Dim S As String
    Do
        S = GetNextLine(txt)
        If Len(S) <= 0 Then Exit Do
        If UCase(Left(S, 9)) = "MERGECFG " Then
          GetCfgUniversal Mid(S, 10)
        Else
          If Len(Trim(S)) > 0 Then
            m_Lines.Add S
          End If
          m_Sec.Add S
        End If
    Loop
End Sub

Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function

Private Function GetEncodingString(encoding As Long) As String
    Select Case encoding
    Case CP_ACP: GetEncodingString = "ANSI"
    Case CP_UTF8: GetEncodingString = "UTF8"
    Case CP_UTF16_LE: GetEncodingString = "UTF16 LE"
    Case CP_UTF16_BE: GetEncodingString = "UTF16 BE"
    Case CP_UTF32_LE: GetEncodingString = "UTF32 LE"
    Case CP_UTF32_BE: GetEncodingString = "UTF32 BE"
    Case Else: GetEncodingString = "Codepage " & CStr(encoding)
    End Select
End Function

Private Function GetCfgUniversal(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    'Dim ff As Long
    'ff = FreeFile
    'Call OpenForInput(fname, ff, encoding)
    Dim encoding As Long
    Dim fileContents As String
    Dim bom As Boolean
    fileContents = GetContents(fname, encoding, -1, bom)
    'DebugPrint tinfo, fname & " opened with encoding: " & GetEncodingString(encoding) & IIf(bom, " BOM", " no BOM")
    
    Call GetCFGString(fileContents)
    GetCfgUniversal = True
    
    Exit Function

couldntOpenFile:
  GetCfgUniversal = False
End Function

Function GetCfg(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  Call GetCfgUniversal(fname)
  
  GetCfg = True
  Exit Function
couldntOpenFile:
  GetCfg = False
End Function

Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
End Function

Function GetValue(S As String) As String
  Dim i As Long
  If m_Sec Is Nothing Then Exit Function
  For i = 1 To m_Sec.Count
    If Left(m_Sec(i), Len(S) + 1) = S & "=" Then
      GetValue = Trim(Mid(m_Sec(i), Len(S) + 2))
      Exit Function
    ElseIf Left(m_Sec(i), Len(S) + 1) = S & " " Then
        Dim pos As Long
        pos = InStr(m_Sec(i), "=")
        If pos > 0 Then
            GetValue = Trim(Mid(m_Sec(i), pos + 1))
            Exit Function
        End If
    End If
  Next i
  GetValue = ""
End Function

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim i As Long
  Dim found As Boolean
  found = False
  If Not m_Lines Is Nothing Then
    For i = 1 To m_Lines.Count
      If m_Lines(i) = "[" & sec & "]" Then
        i = i + 1
        Do While i <= m_Lines.Count
          If Left(m_Lines(i), 1) <> "[" Then
            c.Add m_Lines(i)
            found = True
            i = i + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i > m_Lines.Count Then Exit For
    Next i
  End If
  GetSectionValues = found
End Function



Attribute VB_Name = "DBStuff"
Option Explicit

Public G_DBUser As String
Public G_DBUserPasswort As String

Function GetConnection(Optional ByVal waitendless As Boolean = False) As Object

    Dim conn
    Set conn = CreateObject("ADODB.Connection")
    If G_Cursorlocation <> 2 And G_Cursorlocation <> 3 Then
      G_Cursorlocation = 3
    End If
    conn.CursorLocation = G_Cursorlocation
    On Error Resume Next

    Set GetConnection = Nothing
    Dim cnt As Long
    cnt = 0
checkAgain:
    
    conn.Open G_DBConnectionString, G_DBUser, G_DBUserPasswort
    
    If Err.Number <> 0 Then
        Debug.Print Err.Description
        Err.Clear
        Sleep 50
        cnt = cnt + 1
        If Not waitendless Then
            If cnt >= 100 Then
                conn = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If
    End If

    Set GetConnection = conn

End Function


Sub GetDBUser()
    
    G_DBUser = "IDVTTECHUSER"
    G_DBUserPasswort = "12SD3Ax$!d7%fd/"
    
    Dim cfg As CfgReader
    Set cfg = New CfgReader
    
    If FileExists(ThisWorkbook.path & "\DB.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\DB.cfg") = True Or _
        FileExists(ThisWorkbook.path & "\..\..\IDV-Suite-Plugins\cfg\DB.cfg") = True Or _
        FileExists(ThisWorkbook.path & "\DB.cfg") = True Then
        
        If FileExists(ThisWorkbook.path & "\DB.cfg") = True Then
          cfg.GetCfg (ThisWorkbook.path & "\DB.cfg")
        ElseIf FileExists(ThisWorkbook.path & "\..\cfg\DB.cfg") = True Then
          cfg.GetCfg (ThisWorkbook.path & "\..\cfg\DB.cfg")
        ElseIf FileExists(ThisWorkbook.path & "\..\..\IDV-Suite-Plugins\cfg\DB.cfg") = True Then
          cfg.GetCfg (ThisWorkbook.path & "\..\..\IDV-Suite-Plugins\cfg\DB.cfg")
        ElseIf FileExists(ThisWorkbook.path & "\DB.cfg") = True Then
          cfg.GetCfg (ThisWorkbook.path & "\DB.cfg")
        End If

        Dim S As String
        If cfg.GetSection("DB") = True Then
            S = cfg.GetValue("USER")
            If S <> "" Then
                G_DBUser = Crypt(S, "uIq2%7/=}pJIi39x?", False)
            End If
            S = cfg.GetValue("PASSWORD")
            If S <> "" Then
                G_DBUserPasswort = Crypt(S, "uIq2%7/=}pJIi39x?", False)
            End If
        End If

    End If
End Sub


Function Crypt(Inp As String, Key As String, Mode As Boolean) As String
    Dim z As String
    Dim i As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For i = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If Mode Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, i, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If i > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, i * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
        Next i
     
        Crypt = z
End Function


Function GetSafeFieldPlus(ByRef rs As Object, ByVal fieldName As String, Optional defaultVal As Variant) As Variant
  On Error Resume Next
  If Not IsNull(rs.Fields(fieldName).value) Then
    GetSafeFieldPlus = rs.Fields(fieldName).value
  Else
    If Not IsMissing(defaultVal) Then
      GetSafeFieldPlus = defaultVal
    End If
  End If
End Function




Attribute VB_Name = "DatenElement"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







Public name As String
Public Hauptgruppe As String
Public Gruppe As String
Public typ As String
Public Zeile As Long
Public Tabelle As String

Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True







Attribute VB_Name = "Ergebnis"
Attribute VB_Base = "0{608F18ED-F9A0-49FF-BF60-11E9AFEB6F3D}{3F402E75-2F80-4524-AFCF-214634686C68}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Private Sub cmdOK_Click()
  Me.Hide
End Sub


Attribute VB_Name = "ExeFile"
Option Explicit

Const pw As Long = &H165C
Const STARTMID As Long = &H1698
Const ENDMID As Long = &H16A0
Const REST As Long = &H16C0
Const ENDE As Long = &H10000

Global Const MAX_FILENAMELEN As Long = 30
Const MAX_PASSWLEN As Long = 16

Sub LoadExe()
  Dim r As Long
  r = 0
  LoadExePart 0, pw, r
  LoadExePart STARTMID, ENDMID, r
  LoadExePart REST, ENDE, r
End Sub

Sub LoadExePart(st As Long, ed As Long, ByRef i As Long)
   Dim j As Integer, xlen As Long
   Dim arr(1 To 256) As Byte
   
   Dim cnt As Long
   
   cnt = st
   
   Dim logFF As Long
   logFF = FreeFile
   Open "d:\development\vb\excelloader\excelloader.exe" For Binary Access Read As #logFF
   Seek #logFF, cnt + 1
   xlen = (ed - st) Mod 256 ' LOF(1) Mod 256 ' der Rest am Ende
   Do While Not EOF(1)
      i = i + 1
      Get #logFF, , arr
      For j = 1 To 256
         ThisWorkbook.Sheets("Protect").Cells(i, j).value = arr(j)
         cnt = cnt + 1
         If cnt >= ed Then Exit For
      Next
      If cnt >= ed Then Exit Do
   Loop
   If xlen <> 0 Then Range(Cells(i, xlen + 1), Cells(i, 256)).Clear
   Close #logFF
   
   i = i + 2

End Sub

Function SaveExe(ByVal xlsfname As String, ByVal pw As String) As Boolean
  Dim r As Long
  r = 1
  Dim fname As String
  fname = GetFileNameAndPath(xlsfname) & ".exe"
  
  If Dir(fname) <> "" Then
    'If MsgBox("Die Datei '" & fname & "' existiert bereits. Soll sie |fffd|berschrieben werden? (Bei nein wird der komplette Vorgang abgebrochen!)", vbYesNo) = vbYes Then
    If MsgBox(FMT1("MDEXEFILE_1", fname), vbYesNo) = vbYes Then
      Kill fname
    Else
      SaveExe = False
      Exit Function
    End If
  End If
  Dim fn As Integer
  fn = FreeFile
  Open fname For Binary Access Write As fn
  SaveExePart r, fn
  SaveExeTxt GetFileNameAndExtension(xlsfname), MAX_FILENAMELEN, fn
  SaveExePart r, fn
  SaveExeTxt pw, MAX_PASSWLEN, fn
  SaveExePart r, fn
  Close fn
  SaveExe = True
End Function

Sub SaveExeTxt(t As String, l As Long, fn As Integer)
  t = DoThisAndThat(t)
  Dim cnt As Long
  Dim arr() As Byte
  ReDim arr(1 To 2)
  Dim i As Long
  arr(2) = 0
  For i = 1 To Len(t)
    arr(1) = Asc(Mid(t, i, 1))
    Put fn, , arr
  Next i
  
  arr(1) = 0
  Do While i <= l
    Put fn, , arr
    i = i + 1
  Loop
  
End Sub

Sub SaveExePart(ByRef i As Long, fn As Integer)
  Dim j As Long
  Dim v As Long
  j = 1
  Dim arr() As Byte
  Dim cnt As Long
  ReDim arr(1 To 256)
  cnt = 1
  Do While Not IsEmpty(ThisWorkbook.Sheets("Protect").Cells(i, j))
    arr(cnt) = ThisWorkbook.Sheets("Protect").Cells(i, j)
    cnt = cnt + 1
    If cnt = 257 Then
      Put fn, , arr
      cnt = 1
    End If
    j = j + 1
    If j > 256 Then
      j = 1
      i = i + 1
    End If
  Loop
  If cnt > 0 Then
    ReDim Preserve arr(1 To cnt - 1)
    Put fn, , arr
  End If
  i = i + 3
End Sub


Function DoThisAndThat(S As String)
    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(S)
        If Mid(S, i, 1) = vbLf Then
            s2 = s2 + "@"
        ElseIf Mid(S, i, 1) = " " Then
            s2 = s2 + "^"
        ElseIf Mid(S, i, 1) >= "0" And Mid(S, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("9") + Asc("0") - Asc(Mid(S, i, 1)))
        ElseIf Mid(S, i, 1) >= "a" And Mid(S, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(S, i, 1)))
        ElseIf Mid(S, i, 1) >= "A" And Mid(S, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(S, i, 1)))
        Else
            s2 = s2 + Mid(S, i, 1)
        End If
    Next i
    DoThisAndThat = s2
End Function

Attribute VB_Name = "Globals"
Option Explicit

'Public Const MyVersion As String = "Version 2.4 FP6"
Public Const MyVersionNumber As String = "2.5"
Public Const MyInternalVersion As Long = 9
Public Const ProgNameShort As String = "EP"
Public Const ProgNameLong As String = "ExcelProtect"

Public G_Cursorlocation As Long
Public G_DBConnectionString As String

Attribute VB_Name = "Hauptmen|fffd|"
Attribute VB_Base = "0{25BC0F92-811C-4863-95D8-35266869B0C1}{4695C49C-A23C-4E36-885E-FA7D98BC2720}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Public Function OpenMen|fffd|()
  Dim eintrag As DatenElement
  Vers = MyVersion
  Cop = "|fffd|2002-" & year(Now) & " Norman Neubert"
  Projekt.Clear
  
  For Each eintrag In DE
    Select Case eintrag.typ
      Case "Hgr"
        Projekt.AddItem "----------------- " & eintrag.name & " -----------------"
      Case "Grp"
        Projekt.AddItem eintrag.name
      Case "E"
        Projekt.AddItem "          " & eintrag.name ' & " (HGR: " & eintrag.Hauptgruppe & " - GR: " & eintrag.Gruppe & ")"
      Case "Tab"
        Projekt.AddItem "ED: " & eintrag.name
    End Select
  Next eintrag
  
  Hauptmen|fffd|.Show
  Exit Function
OpenError:
  'MsgBox "Die Datendatei '" & ThisWorkbook.path & "\ExcelProtectData.xls' konnte nicht ge|fffd|ffnet werden! (" & Err.Description & ")", vbCritical
  MsgBox FMT2("MAIN_9", ThisWorkbook.path, Err.Description), vbCritical
End Function

Private Sub AktualisierungenSuchen_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="NoAutoUpdate", _
     Setting:=0

'  CheckVersion 0, ProgNameShort, ProgNameShort & "\SWUpdate" & ProgNameShort & ".txt", MyInternalVersion, True

End Sub

Private Sub butBeenden_Click()
    Me.Hide
End Sub

Private Sub HelpButton_Click()
  OpenFileWithApp ThisWorkbook.path & "\ExcelProtect.pdf"
End Sub

Private Sub Label3_Click()
  On Error Resume Next
  Call Shell("explorer.exe http://www.stromwerken.de", 1)
End Sub

Private Sub Sch|fffd|tzen_Click()

  If Projekt.ListIndex < 0 Then Exit Sub
  Me.Hide
  ProtectProject Projekt.ListIndex
DebugPrint "5"
  If MenuEPAllowed = False Then
'    ThisWorkbook.Close False
    ThisWorkbook.Saved = True
    Application.Quit
  End If
End Sub


Private Sub ShowAboutDlg_Click()
    AboutDlg.Label1 = dothat(trs)
    AboutDlg.Show
End Sub

Attribute VB_Name = "Helpers"
Option Explicit

Const NoError = 0       'The Function call was successful

#If VBA7 Then
Declare PtrSafe Function GetLogicalDrives& Lib "kernel32" ()
Private Declare PtrSafe Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

'Declare PtrSafe Function GetLogicalDrives& Lib "kernel32" ()
Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

#Else
Declare Function GetLogicalDrives& Lib "kernel32" ()
Private Declare Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

#End If

Function GetMachineName() As String
  'Returns the computername
  Dim lngLen As Long, lngX As Long
  Dim strCompName As String
  
  lngLen = 16
  strCompName = String$(lngLen, 0)
  lngX = apiGetComputerName(strCompName, lngLen)
  If lngX <> 0 Then
      GetMachineName = Left$(strCompName, lngLen)
  Else
      GetMachineName = ""
  End If
End Function


Function GetUserName() As String

   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else

      ' An error occurred.
'         MsgBox "Unable to get the name."
      lpUserName = "Unbekannt"
   End If

   ' Display the name of the person logged on to the machine.
'      MsgBox "The person logged on this machine is: " & lpUserName

    GetUserName = lpUserName

End Function

Function Mk_Dir(bez1$) As Boolean
'Die Funktion erzeugt einen kompletten Unterverzeichnisbaum : z.B.  c:\test\backup\access\nr1
On Error Resume Next
Dim verz$, Bez$
  Mk_Dir = True
  
  If Len(bez1) < 3 And Mid(bez1, 2, 1) = ":" Then Exit Function
  
  Bez = bez1
  verz = Left(Bez, 3)
  Bez = Right(Bez, Len(Bez) - 3)
  If Right(Bez, 1) <> "\" Then Bez = Bez & "\"
  verz = verz & Mid(Bez, 1, InStr(Bez, "\") - 1)
  Bez = Right(Bez, Len(Bez) - InStr(Bez, "\"))
  While Right(verz, 1) <> "\"
    Err.Number = 0
    MkDir verz
'    If Err.Number <> 0 Then
'        MsgBox "Das Verzeichnis '" & verz & "' konnte nicht angelegt werden! (" & Err.Description & ") Setup wird abgebrochen!", vbCritical
'        Mk_Dir = False
'        Exit Function
'    End If
    If Bez <> "" Then
        verz = verz & "\" + Mid(Bez, 1, InStr(Bez, "\") - 1)
    Else
        verz = verz & "\"
    End If
    Bez = Right(Bez, Len(Bez) - InStr(Bez, "\"))
  Wend

  Err.Number = 0
  MyFileDateTime bez1
  If Err.Number <> 0 Then
'      MsgBox "Das Verzeichnis '" & bez1 & "' konnte nicht angelegt werden! (" & Err.Description & ") Setup wird abgebrochen!", vbCritical
      Mk_Dir = False
  End If

End Function

Function GetFilePath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFilePath = Left(path, Len(path) - 1)
End Function

Function GetFileNameAndPath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndPath = path & File
End Function

Function GetFileNameAndExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndExtension = File & "." & ext
End Function

Sub fileSplit(ByVal S$, ByRef path$, ByRef File$, ByRef ext$)
    ' die Prozedur zerlegt den Dateinamen S in Path, Name, Extension
    Dim i%
    For i = Len(S) To 1 Step -1
        If Mid(S, i, 1) = "\" Or Mid(S, i, 1) = "/" Then   ' keine Extension vorhanden
            ext = ""
            Exit For
        End If
        If Mid(S, i, 1) = "." Then
            ext = Right(S, Len(S) - i)
            S = Left(S, i - 1)
            Exit For
        End If
    Next i
    i = Len(S)
    If InStr(S, "\") <> 0 Then
        While Mid(S, i, 1) <> "\"
            i = i - 1
        Wend
    ElseIf InStr(S, "/") <> 0 Then
        While Mid(S, i, 1) <> "/"
            i = i - 1
        Wend
    End If
    path = Left(S, i)
    File = Right(S, Len(S) - i)

End Sub

Function Encode(S As String)
    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(S)
        If Mid(S, i, 2) = "\n" Then
          s2 = s2 + "@"
          i = i + 1
        Else
          If Mid(S, i, 1) = vbLf Then
              s2 = s2 + "@"
          ElseIf Mid(S, i, 1) = " " Then
              s2 = s2 + "^"
          ElseIf Mid(S, i, 1) >= "0" And Mid(S, i, 1) <= "9" Then
            s2 = s2 + Chr(Asc("9") + Asc("0") - Asc(Mid(S, i, 1)))
          ElseIf Mid(S, i, 1) >= "a" And Mid(S, i, 1) <= "z" Then
            s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(S, i, 1)))
          ElseIf Mid(S, i, 1) >= "A" And Mid(S, i, 1) <= "Z" Then
            s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(S, i, 1)))
          Else
              s2 = s2 + Mid(S, i, 1)
          End If
        End If
    Next i
    Encode = s2
End Function

Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore As Boolean
  
  inIgnore = False
  
  For txtPos = 1 To Len(txt)
    If Len(ignoreIn) > 0 Then
      If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
        If Not inIgnore Then
          inIgnore = True
        Else
          inIgnore = False
        End If
      End If
    End If
    
    If Not inIgnore Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tVal As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tVal = Mid(txt, txtPos - 1, 1)
            If (tVal >= "a" And tVal <= "z") Or _
               (tVal >= "A" And tVal <= "Z") Or _
               (tVal >= "0" And tVal <= "9") Or _
               tVal = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tVal = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tVal >= "a" And tVal <= "z") Or _
               (tVal >= "A" And tVal <= "Z") Or _
               (tVal >= "0" And tVal <= "9") Or _
               tVal = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function



Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub

Function ConvGermanDateKey(d As String) As String
    Dim sp() As String
    sp = Split(d, ".")
    If UBound(sp) - LBound(sp) + 1 = 3 Then
        ConvGermanDateKey = DateSerial(CInt(sp(2)), CInt(sp(1)), CInt(sp(0)))
    Else
        ConvGermanDateKey = d
    End If
End Function

Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim endPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              endPos = InStr(pos2 + 1, d, " ")
              If endPos <= 0 Then endPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, endPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function

Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While Mid(codeValRet, i, 1) = " " Or Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Function GetNumber(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  
  Do While ((Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
    (Mid(codeValRet, i + 1, 1) = ".")) And i < Len(codeValRet)
    i = i + 1
  Loop
  If i > 0 Then
    token = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
    OverreadBlanks codeValRet
  End If
  
  GetNumber = token
End Function

Private Function GetLine(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  Dim i As Long
  i = 0
  Do While i < Len(codeValRet) - 1 And Mid(codeValRet, i + 1, 1) <> vbCr And Mid(codeValRet, i + 1, 1) <> vbLf
    i = i + 1
  Loop
  If i > 0 Then
    GetLine = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
  End If
End Function

Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Function GetString(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  End If
  
  GetString = token
End Function



Sub OpenFileWithApp(fname As String)
  If FileExists(fname) Then
    Dim s2 As String, s3 As String, n As Long
    
    s2 = AnwendungFuerDatei(fname)
    If "" <> s2 Then
       s3 = Chr(34) & ShortFileName(s2) & Chr(34) & " " & Chr(34) & ShortFileName(fname) & Chr(34)
       n = Shell(s3, vbNormalFocus)
    Else
       'MsgBox "Anwendungprogramm f|fffd|r " & fname & " nicht gefunden/installiert!"
       MsgBox FMT1("HELPERS_1", fname)
    End If
  Else
    'MsgBox "Datei '" & fname & "' nicht vorhanden.", vbCritical
    MsgBox FMT1("HELPERS_2", fname), vbCritical
  End If
End Sub


Public Function AnwendungFuerDatei(ByVal a_Datei As String) As String
  'Datei: Pfad + Dateinamen einer existierenden Datei
  Dim Pfad As String * 255
  
  Call FindExecutable(a_Datei, vbNullString, Pfad)
  
  If "" <> Trim(Pfad) Then
     Pfad = Trim(Left(Pfad, InStr(Pfad, vbNullChar) - 1))
  End If
  AnwendungFuerDatei = Trim(Pfad)
End Function

Public Function ShortFileName(ByVal long_name As String) As String
    If UCase(Left(long_name, 5)) = "HTTP:" Or UCase(Left(long_name, 6)) = "HTTPS:" Then
      ShortFileName = long_name
      Exit Function
    End If
    
    'Returns the short filename associated w
    '     ith sLongFilename
    Dim lRet As Long
    Dim sShortFilename As String
    'First attempt using 1024 character buff
    '     er.
    sShortFilename = String$(1024, " ")
    lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    
    'If buffer is too small lRet contains bu
    '     ffer size needed.


    If lRet > Len(sShortFilename) Then
        'Increase buffer size...
        sShortFilename = String$(lRet + 1, " ")
        'and try again.
        lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    End If
    
    'lRet contains the number of characters
    '     returned.


    If lRet > 0 Then
        ShortFileName = Left$(sShortFilename, lRet)
    End If
    
    If Trim(ShortFileName) = "" Then
      ShortFileName = long_name
    End If
    
End Function

Sub MyKill(fname As String)
  On Error Resume Next
  Kill fname
End Sub

Function WBGetValueLong(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal vname As String) As Long

    WBGetValueLong = -100
    Dim nameItem As Excel.name
    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If nameItem.Visible = False Then
            If nameItem.name = vname Then
                WBGetValueLong = Val(Mid(nameItem.RefersTo, 2))
                Exit Function
            End If
        End If
    Next nameItem

End Function


Function FileExists(ByVal Dateiname$) As Boolean
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:
  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    FileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    FileExists = res
  End If
    Exit Function
fehler:
    FileExists = False
    If Len(Dateiname) > 260 Then
        FileExists = MyFileExistsLongName(Dateiname)
    End If
End Function

Function MyFileExistsLongName(ByVal fname As String) As Boolean
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Set fs = CreateObject("Scripting.FileSystemObject")
    MyFileExistsLongName = fs.FileExists(fname)
    Exit Function
nogo:
    MyFileExistsLongName = False
End Function

Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .Send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim S As String
        S = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        S = Left(S, Len(S) - 4)
        modDate = CDate(S)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print Err.Description
    Set Request = Nothing
End Function

Function MyFileLen(fname As String) As Long
  On Error GoTo nogo:
  MyFileLen = 0
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileLen = sz
    End If
  Else
    MyFileLen = FileLen(fname)
  End If
  Exit Function
nogo:
End Function

Function MyFileDateTime(ByVal fname As String) As Date
  MyFileDateTime = 0
  On Error GoTo nogo
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileDateTime = modDate
    End If
  Else
    MyFileDateTime = FileDateTime(fname)
  End If
  Exit Function
nogo:
  If Len(fname) > 260 Then
     MyFileDateTime = MyFileDateTimeLongName(fname)
  Else
'    DebugPrint tdebug, "MyFileDateTime failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
  End If
End Function

Function MyFileDateTimeLongName(fname As String) As Date
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Dim f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(fname)
    
    MyFileDateTimeLongName = f.DateLastModified
    Exit Function
nogo:
'    DebugPrint tdebug, "MyFileDateTimeLongName failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
    MyFileDateTimeLongName = 0
End Function
Function StrRemove(srcstring As String, removechars As String) As String
  Dim res As String
  Dim x As Long
  Dim l As Long
  l = Len(removechars)
  
  res = srcstring
  If l > 0 Then
    For x = 1 To l
      res = Replace(res, Mid(removechars, x, 1), "")
    Next x
  End If
  StrRemove = res
End Function



Function GetTempPath() As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    GetTempPath = Trim(Left(pathbuffer, l))
  End If
End Function

Attribute VB_Name = "Keystuff"
Option Explicit


Public G_Lizenzen As Long
Public G_FullDemoBis As Date

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String

Public G_EPPro As Boolean
Public G_MyLicencseVersion As Long
Public G_Wartung As Boolean
Public G_WartungBis As Date

Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Then
    Open G_cfgKeypfad & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(ThisWorkbook.path & "\..\swres.swk") Then
    Open ThisWorkbook.path & "\..\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(ThisWorkbook.path & "\swres.swk") Then
    Open ThisWorkbook.path & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  End If
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC3 - LZW
  ElseIf l = 2 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    Dim lval As Long
    Dim arr() As Long
    ReDim arr(l)
    
    For charc = 1 To l
      Get #ff, pos + 4 + charc * 4, lval
      arr(charc - 1) = lval
    Next charc
    Close ff
    
    Dim LZW As New LZW
    res = LZW.DecompressArray(l, arr)
    Set LZW = Nothing
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function

Sub GetData()
  On Error GoTo noData
  
  G_Lizenzen = -3
  G_EPPro = False
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Or FileExists(ThisWorkbook.path & "\..\swres.swk") Then
    Dim ff As Long
    ff = FreeFile
    Dim S As String
    
    S = GetSWResItem(1000, ff)
    If InStr(S, "EP,") > 0 Or InStr(S, "EPPRO,") > 0 Then
    
      If InStr(S, "EPPRO,") > 0 Then
        G_EPPro = True
      End If
    
      G_Lizenznehmer = GetSWResItem(2000, ff)
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = Val(GetSWResItem(4800, ff))
      G_Lizenzen = Val(GetSWResItem(4900, ff))
      
      
'      s = GetSWResItem(5000, ff)
      S = ConvGermanDateKey(GetSWResItem(5000, ff))
      If Len(S) > 0 Then
        If IsDate(S) Then
          If CDate(S) > #1/1/1900# Then
            G_FullDemoBis = CDate(S)
          End If
        End If
      End If
      G_Wartung = IIf(UCase(GetSWResItem(5100, ff)) = "JA", True, False)
      
      If G_Wartung Then
        ' s = GetSWResItem(5200, ff)
        S = ConvGermanDateKey(GetSWResItem(5200, ff))
        If Len(S) > 0 Then
          If IsDate(S) Then
            G_WartungBis = CDate(S)
          End If
        End If
      End If
      
      FullVersion = True
      
      If G_Lizenzen = -1 Then
        'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trs = FMT2("MDKEYSTUFF_1", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo " & G_Lizenznehmer & " - Einsatz nur zu Testzwecken!"
        trsShrt = FMT1("MDKEYSTUFF_2", G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("MDKEYSTUFF_3", CStr(G_FullDemoBis), G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo bis zum " & G_FullDemoBis & " - " & G_Lizenznehmer
        trsShrt = FMT2("MDKEYSTUFF_4", CStr(G_FullDemoBis), G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("MDKEYSTUFF_5", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Demoversion " & G_Lizenznehmer
        trsShrt = FMT1("MDKEYSTUFF_6", G_Lizenznehmer)
      ElseIf G_Lizenzen = -2 Then
        'trs = "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("MDKEYSTUFF_7", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Gesamthauslizenz " & G_Lizenznehmer
        trsShrt = FMT1("MDKEYSTUFF_8", G_Lizenznehmer)
      ElseIf G_Lizenzen = 1 Then
        'trs = G_Lizenzen & " Lizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("MDKEYSTUFF_9", CStr(G_Lizenzen), G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenz " & G_Lizenznehmer
        trsShrt = FMT2("MDKEYSTUFF_10", CStr(G_Lizenzen), G_Lizenznehmer)
      Else
        'trs = G_Lizenzen & " Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("MDKEYSTUFF_11", CStr(G_Lizenzen), G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenzen " & G_Lizenznehmer
        trsShrt = FMT2("MDKEYSTUFF_12", CStr(G_Lizenzen), G_Lizenznehmer)
      End If
      
      If G_Wartung Then
        'trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", ""), "")
        trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, FMT2("MDKEYSTUFF_13", CStr(G_WartungBis), IIf(Now > G_WartungBis, " " & FMT0("MDKEYSTUFF_14"), "")), "")
      End If
      
    End If
  Else
    GetDataOld
  End If
  
  
noData:
  Exit Sub
End Sub

Attribute VB_Name = "LZW"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'Private Data Members
Private flgFirstTime As Boolean
Private arr() As String
Private m_CharacterBytesCount As Integer


'Properties
Public Property Get CharacterBytesCount() As Integer
    CharacterBytesCount = m_CharacterBytesCount
End Property

Public Property Let CharacterBytesCount(ByVal vNewValue As Integer)
    m_CharacterBytesCount = vNewValue
End Property

'Private Methods
Private Function Add(ByVal Entry As String) As Long

   If flgFirstTime Then
        flgFirstTime = False
    Else
        ReDim Preserve arr(UBound(arr) + 1)
    End If
    
    arr(UBound(arr)) = Entry
    'Arr(UBound(Arr)).Code = ubund(
    
    Add = UBound(arr)
    
End Function

Private Function IsExists(ByVal Entry As String) As Boolean
    Dim i As Long
    Dim flg As Boolean
    flg = False
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            flg = True
            Exit For
        End If
    Next i
    
    IsExists = flg
    
End Function

Private Function IsIndexExists(ByVal index As Long) As Boolean
    
    Dim flg As Boolean
    flg = False
    
    If index <= UBound(arr) Then
        flg = True
    Else
        flg = False
    End If
    
    IsIndexExists = flg
    
End Function

Private Function GetValue(ByVal index As Long) As String
    If IsIndexExists(index) Then
        GetValue = arr(index)
    Else
        GetValue = ""
    End If
End Function

Private Function GetIndexOf(ByVal Entry As String) As Long
    
    Dim i As Long
    Dim ReturnCode As Long
    ReturnCode = -1
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            ReturnCode = i
            Exit For
        End If
    Next i
    
    GetIndexOf = ReturnCode
    
End Function

Private Sub Class_Initialize()
    ReDim arr(0) As String
    flgFirstTime = True
    m_CharacterBytesCount = 2
End Sub

Private Function mrtLeft(ByVal InputString As String, ByVal length As Long) As String
    If Len(InputString) >= length Then
        mrtLeft = Left(InputString, length)
    Else
        mrtLeft = InputString
    End If
End Function

Private Sub InitializeDictionary()
    Dim i As Long
    For i = 0 To (2 ^ (m_CharacterBytesCount * 8)) - 1
        Add (ChrW(i))
    Next
End Sub

Private Function length() As Long
    length = UBound(arr)
End Function

'Public methods
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function Compress(ByVal UncompressedData As String, ByRef valam As Long, ByRef arr() As Long) As String

    Dim w As String
    Dim c As String
    Dim wc As String
    'Dim dic As New Dictionary
    Dim Output As String
    Dim code As Long
    
    Dim i As Long
    InitializeDictionary
    valam = 0
    
    ReDim arr(1024)
    Dim curarrsize As Long
    curarrsize = 1024
     
    w = ""
    For i = 1 To Len(UncompressedData)
        
        c = Mid(UncompressedData, i, 1)
        wc = w + c
        If IsExists(wc) Then
            w = wc
        Else
            code = Add(wc)
            code = GetIndexOf(w)
            Output = Output & IIf(Output = "", "", ",") & code
            arr(valam) = code
            valam = valam + 1
            If valam > curarrsize Then
              curarrsize = curarrsize + 1024
              ReDim Preserve arr(curarrsize)
            End If
            w = c
        End If
        
        '?
    
    Next i
    
    Output = Output & IIf(Output = "", "", ",") & GetIndexOf(w)
    arr(valam) = GetIndexOf(w)
    valam = valam + 1
    
    Compress = Output

End Function


Public Function DecompressArray(valam As Long, arr() As Long) As String
  Dim compresseddata As String
  Dim i As Long
  For i = 0 To valam - 1
    compresseddata = compresseddata & IIf(compresseddata = "", "", ",") & arr(i)
  Next i
  DecompressArray = Decompress(compresseddata)
End Function

Public Function Decompress(ByVal compresseddata As String) As String
    
    If compresseddata = "" Then Exit Function
    
    'Dim dic As New Dictionary
    
    InitializeDictionary

    Dim Output As String
    Dim Entry As String

    Dim K As String
    Dim w As String
    Dim i As Long
    
    Dim arrCompressedData() As String
    ListSplit arrCompressedData, compresseddata, "," '  arrCompressedData = Split(compresseddata, ",")
    
    K = arrCompressedData(0)
    Output = Output & GetValue(K)
    w = K
    
    For i = 1 To UBound(arrCompressedData)
    
        K = arrCompressedData(i)
        
        If IsIndexExists(K) Then
        
            Entry = GetValue(K)
            
        ElseIf IsIndexExists(K) = False And K = length + 1 Then
            
            Entry = GetValue(w) + mrtLeft(GetValue(w), 1)
            
        Else
        
            'MsgBox "Bad compressed."
            Dim errMsg As String
            errMsg = "Bad compressed."
            MsgBox errMsg
            
        End If
        
        Output = Output + Entry
        
        Add (GetValue(w) + mrtLeft(Entry, 1))
        
        w = GetIndexOf(Entry)
        
    Next
    
    Decompress = Output
    
End Function


 Function ListSplit(ArrayReturn() As String, ByVal StringToSplit As String, _
 SplitAt As String) As Integer
   Dim intInstr As Integer
   Dim intCount As Integer
   Dim strTemp As String

   intCount = -1
   intInstr = InStr(StringToSplit, SplitAt)
   Do While intInstr > 0
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = Left(StringToSplit, intInstr - 1)
     StringToSplit = Mid(StringToSplit, intInstr + 1)
     intInstr = InStr(StringToSplit, SplitAt)
   Loop
   If Len(StringToSplit) > 0 Then
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = StringToSplit
   End If
   ListSplit = intCount
 End Function






Attribute VB_Name = "PChecks"
Option Explicit

Sub PlausiCheck(wert As Werte, ByRef infotxt As String, y As Long)
  
  ' ------------------------------------------------------------
  ' Plausis f|fffd|r EXE FILE
  ' ------------------------------------------------------------
  'If UCase(wert.ExeFileLoad) = "JA" Then
  If IsYes(wert.ExeFileLoad) Then
    ' ------------------------------------------------------------
    ' EXE FILES nur mit Ausgabe XLS
    ' ------------------------------------------------------------
    If UCase(Right(wert.Outp, 3)) <> "XLS" Then
      'infotxt = infotxt & "Fehler (31): [ExeFileLoad] kann nur bei XLS Dateien genutzt werden!" & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_1") & vbCrLf
      Errors = Errors + 1
    End If
    ' ------------------------------------------------------------
    ' EXE FILE nur mit RND Lese-Passwort
    ' ------------------------------------------------------------
    If UCase(wert.Lesepasswort) <> "RND" Then
      'infotxt = infotxt & "Hinweis (4): Bei [ExeFileLoad] wird das Lesepasswort zuf|fffd|llig vergeben! Das von Ihnen eingetragene Passwort wird ignoriert." & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_2") & vbCrLf
      Warnings = Warnings + 1
      wert.Lesepasswort = "RND"
    End If
  End If

  ' ------------------------------------------------------------
  ' Wiederholungsbereich nur mit Blattschutzpasswort RND
  ' ------------------------------------------------------------
  'If UCase(wert.Blattschutzpasswort) <> "RND" And UCase(wert.Wiederholungsbereich) = "JA" Then
  If UCase(wert.Blattschutzpasswort) <> "RND" And IsYes(wert.Wiederholungsbereich) Then
    'infotxt = infotxt & "Hinweis (5): Bei Nutzung des Wiederholungsbereichs wird das Blattschutzpasswort zuf|fffd|llig vergeben! Das von Ihnen eingetragene Passwort wird ignoriert." & vbCrLf
    infotxt = infotxt & FMT0("MDPChecks_3") & vbCrLf
    Warnings = Warnings + 1
    wert.Blattschutzpasswort = "RND"
  End If

  ' ------------------------------------------------------------
  ' Wenn der Wiederholungsbereich genutzt wird, dann muss
  ' der Aufbau gesch|fffd|tzt sein.
  ' ------------------------------------------------------------
  'If UCase(wert.Wiederholungsbereich) = "JA" And (UCase(wert.AufbauSch|fffd|tzen) <> "JA" Or UCase(wert.Arbeitsmappenschutzpasswort) <> "RND") Then
  If IsYes(wert.Wiederholungsbereich) And (Not IsYes(wert.AufbauSch|fffd|tzen) Or UCase(wert.Arbeitsmappenschutzpasswort) <> "RND") Then
    'infotxt = infotxt & "Hinweis (6): Bei der Nutzung des Wiederholungsbereichs wird die Arbeitsmappe mit einem zuf|fffd|lligen Passwort (RND) gesch|fffd|tzt. Gleichzeitig wird Arbeitsmappenaufbau automatisch gesichert." & vbCrLf
    infotxt = infotxt & FMT0("MDPChecks_4") & vbCrLf
    Warnings = Warnings + 1
    wert.Arbeitsmappenschutzpasswort = ""
    wert.AufbauSch|fffd|tzen = "Nein"
  End If

  ' ------------------------------------------------------------
  ' ButtonProtect geht nur, wenn Ausgabedatei XLS ist
  ' ------------------------------------------------------------
  'If UCase(wert.ButtonProtect) = "JA" And UCase(Right(wert.Outp, 3)) <> "XLS" Then
  If IsYes(wert.ButtonProtect) And UCase(Right(wert.Outp, 3)) <> "XLS" Then
    'infotxt = infotxt & "Fehler (16): [ButtonProtect] kann nur bei XLS Dateien genutzt werden!" & vbCrLf
    infotxt = infotxt & FMT0("MDPChecks_5") & vbCrLf
    Errors = Errors + 1
  End If

  ' ------------------------------------------------------------
  ' Wenn ButtonProtect oder SimpleProtect...
  ' ------------------------------------------------------------
  'If UCase(wert.ButtonProtect) = "JA" Or UCase(wert.SimpleProtect) = "JA" Then
  If IsYes(wert.ButtonProtect) Or IsYes(wert.SimpleProtect) Then
    ' ------------------------------------------------------------
    ' Nur von Excel97 bis Excel2002
    ' ------------------------------------------------------------
    'If UCase(wert.ButtonProtect) = "JA" And Left(Application.Version, 3) <> "8.0" And Left(Application.Version, 3) <> "9.0" And Left(Application.Version, 4) <> "10.0" And Left(Application.Version, 4) <> "11.0" Then
    If IsYes(wert.ButtonProtect) And Left(Application.Version, 3) <> "8.0" And Left(Application.Version, 3) <> "9.0" And Left(Application.Version, 4) <> "10.0" And Left(Application.Version, 4) <> "11.0" Then
      'infotxt = infotxt & "Fehler (15): Die von Ihnen eingesetzte Excel-Version erlaubt keine Nutzung von [ButtonProtect]" & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_6") & vbCrLf
      Errors = Errors + 1
    End If
    
    'If UCase(wert.SimpleProtect) = "JA" And Left(Application.Version, 3) <> "8.0" And Left(Application.Version, 3) <> "9.0" And Left(Application.Version, 4) <> "10.0" And Left(Application.Version, 4) <> "11.0" And Left(Application.Version, 4) <> "12.0" And Left(Application.Version, 4) <> "14.0" Then
    If IsYes(wert.SimpleProtect) And Left(Application.Version, 3) <> "8.0" And Left(Application.Version, 3) <> "9.0" And Left(Application.Version, 4) <> "10.0" And Left(Application.Version, 4) <> "11.0" And Left(Application.Version, 4) <> "12.0" And Left(Application.Version, 4) <> "14.0" Then
      'infotxt = infotxt & "Fehler (15a): Die von Ihnen eingesetzte Excel-Version erlaubt keine Nutzung von [Protect]" & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_7") & vbCrLf
      Errors = Errors + 1
    End If
    
    ' ------------------------------------------------------------
    ' Zugriff auf VBA muss an sein
    ' ------------------------------------------------------------
    If CheckVBAAccessAllowed = False Then
      'infotxt = infotxt & "Fehler (18): Der Zugriff auf Visual-Basic ist in Excel nicht erlaubt. Wenn Sie [ButtonProtect] oder [Protect]  nutzen m|fffd|chten, m|fffd|ssen Sie in Excel |fffd|ber Extras\Makro\Sicherheit Reiter 'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic vertrauen' anschalten." & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_8") & vbCrLf
      Errors = Errors + 1
    End If
    ' ------------------------------------------------------------
    ' Codeschutzpasswort auf RND!
    ' ------------------------------------------------------------
    If wert.Codeschutzpasswort <> "RND" Then
      wert.Codeschutzpasswort = "RND"
      'infotxt = infotxt & "Hinweis (7): Bei [ButtonProtect] oder [Protect] wird das Codeschutzpasswort zuf|fffd|llig vergeben. Das von Ihnen eingetragene Passwort wird ignioriert!" & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_9") & vbCrLf
      Warnings = Warnings + 1
    End If
    
    If Errors > 0 Then
      Exit Sub
    End If
  ' ------------------------------------------------------------
  ' ButtonSpeichern nur mit VBA!
  ' ------------------------------------------------------------
  'ElseIf UCase(wert.ButtonSpeichern) = "JA" Then
  ElseIf IsYes(wert.ButtonSpeichern) Then
    If CheckVBAAccessAllowed = False Then
      'infotxt = infotxt & "Fehler (33): Der Zugriff auf Visual-Basic ist in Excel nicht erlaubt. Wenn Sie [ButtonSpeichern] nutzen m|fffd|chten, dann m|fffd|ssen Sie in Excel |fffd|ber Extras\Makro\Sicherheit Reiter 'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic vertrauen' anschalten." & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_10") & vbCrLf
      Errors = Errors + 1
      Exit Sub
    End If
  ' ------------------------------------------------------------
  ' DruckenVorSchlie|fffd|en nur mit VBA!
  ' ------------------------------------------------------------
  'ElseIf UCase(wert.DruckenVorSchlie|fffd|en) = "JA" Then
  ElseIf IsYes(wert.DruckenVorSchlie|fffd|en) Then
    If CheckVBAAccessAllowed = False Then
      'infotxt = infotxt & "Fehler (33): Der Zugriff auf Visual-Basic ist in Excel nicht erlaubt. Wenn Sie [DruckenVorSchlie|fffd|en] nutzen m|fffd|chten, dann m|fffd|ssen Sie in Excel |fffd|ber Extras\Makro\Sicherheit Reiter 'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic vertrauen' anschalten." & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_11") & vbCrLf
      Errors = Errors + 1
      Exit Sub
    End If
  ' ------------------------------------------------------------
  ' ButtonDruckn nur mit VBA!
  ' ------------------------------------------------------------
  'ElseIf UCase(wert.ButtonDrucken) = "JA" Then
  ElseIf IsYes(wert.ButtonDrucken) Then
    If CheckVBAAccessAllowed = False Then
      'infotxt = infotxt & "Fehler (34): Der Zugriff auf Visual-Basic ist in Excel nicht erlaubt. Wenn Sie [ButtonDrucken] nutzen m|fffd|chten, dann m|fffd|ssen Sie in Excel |fffd|ber Extras\Makro\Sicherheit Reiter 'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic vertrauen' anschalten." & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_12") & vbCrLf
      Errors = Errors + 1
      Exit Sub
    End If
  ' ------------------------------------------------------------
  ' Selektionsschutz nur mit VBA!
  ' ------------------------------------------------------------
  'ElseIf UCase(wert.Selektionsschutz) = "JA" Then
  ElseIf IsYes(wert.Selektionsschutz) Then
    If CheckVBAAccessAllowed = False Then
      'infotxt = infotxt & "Fehler (35): Der Zugriff auf Visual-Basic ist in Excel nicht erlaubt. Wenn Sie den Selektionsschutz nutzen m|fffd|chten, dann m|fffd|ssen Sie in Excel |fffd|ber Extras\Makro\Sicherheit Reiter 'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic vertrauen' anschalten." & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_13") & vbCrLf
      Errors = Errors + 1
      Exit Sub
    End If
  ' ------------------------------------------------------------
  ' Wiederholungsbereich nur mit VBA!
  ' ------------------------------------------------------------
  'ElseIf UCase(wert.Wiederholungsbereich) = "JA" Then
  ElseIf IsYes(wert.Wiederholungsbereich) Then
    If CheckVBAAccessAllowed = False Then
      'infotxt = infotxt & "Fehler (36): Der Zugriff auf Visual-Basic ist in Excel nicht erlaubt. Wenn Sie den Wiederholungsbereich nutzen m|fffd|chten, dann m|fffd|ssen Sie in Excel |fffd|ber Extras\Makro\Sicherheit Reiter 'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic vertrauen' anschalten." & vbCrLf
      infotxt = infotxt & FMT0("MDPChecks_14") & vbCrLf
      Errors = Errors + 1
      Exit Sub
    End If
  End If

End Sub



Attribute VB_Name = "SWFuncs"
Option Explicit


Public Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function


Function MySpc(l As Long) As String
  If l > 0 Then
    Dim i As Long
    For i = 1 To l
      MySpc = MySpc + " "
    Next i
  End If
End Function

Function MakeFileName(n As String)
  Dim newn As String
  Dim i As Long
  If Len(i) > 0 Then
    For i = 1 To Len(n)
      Select Case Mid(n, i, 1)
        Case ":"
          newn = newn & "-"
        Case "\", "/", "*", "?", Chr(34), "<", ">", "|"
          newn = newn & "_"
        Case Else
          newn = newn + Mid(n, i, 1)
      End Select
    Next i
  End If
  MakeFileName = newn
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function

Function FileUpToDate(dst As String, src As String)
  FileUpToDate = True
'  If Not FileExists(dst) Then
'    FileUpToDate = False
'    Exit Function
'  ElseIf MyFileDateTime(dst) < MyFileDateTime(src) Then
  On Error GoTo dstFileMissing
  
  If MyFileDateTime(dst) < MyFileDateTime(src) Then
    FileUpToDate = False
    Exit Function
  End If
  
  Exit Function
dstFileMissing:
  FileUpToDate = False
  
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function

Attribute VB_Name = "SendKeyExt"
Option Explicit

#If Win64 Then
Declare PtrSafe Function OemKeyScan Lib "user32" (ByVal wOemChar As Long) As Long
Declare PtrSafe Function CharToOem Lib "user32" Alias "CharToOemA" (ByVal lpszSrc As String, ByVal lpszDst As String) As Long
Declare PtrSafe Function VkKeyScan Lib "user32" Alias "VkKeyScanA" (ByVal cChar As Byte) As Integer
Declare PtrSafe Function MapVirtualKey Lib "user32" Alias "MapVirtualKeyA" (ByVal wCode As Long, ByVal wMapType As Long) As Long
Declare PtrSafe Sub keybd_event Lib "user32" (ByVal bVk As Byte, ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As LongPtr)
#Else
Private Declare Function OemKeyScan Lib "user32" (ByVal wOemChar As Integer) As Long
Private Declare Function CharToOem Lib "user32" Alias "CharToOemA" (ByVal lpszSrc As String, ByVal lpszDst As String) As Long
Private Declare Function VkKeyScan Lib "user32" Alias "VkKeyScanA" (ByVal cChar As Byte) As Integer
Private Declare Function MapVirtualKey Lib "user32" Alias "MapVirtualKeyA" (ByVal wCode As Long, ByVal wMapType As Long) As Long
Private Declare Sub keybd_event Lib "user32" (ByVal bVk As Byte, ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As Long)
#End If

Private Const KEYEVENTF_KEYDOWN      As Long = &H0
Private Const KEYEVENTF_KEYUP        As Long = &H2

Type VKType
    VKCode As Integer
    scanCode As Integer
    Control As Boolean
    Shift As Boolean
    Alt As Boolean
End Type

'---------------------------------------------------------------------
' Routine: VbSendKeys()
'
' Author:  Bryan Wolf, 1999
'
' Purpose: Imitate VB's internal SendKeys statement, but add the
'          ability to send keypresses to a DOS application.  You
'          can use SendKeys, to paste ASCII characters to a DOS
'          window from the clipboard, but you can't send function
'          keys.  This module solves that problem and makes sending
'          any keys to any Application, DOS or Windows, easy.
'
' Arguments: Keystrokes.  Note that this does not implement the
'            SendKeys's 'wait' argument.  If you need to wait,
'            try using a timing loop.
'
'            The syntax for specifying keystrokes is the
'            same as that of SendKeys - Please refer to VB's
'            documentation for an in-depth description.  Support
'            for the following codes has been added, in addition
'            to the standard set of codes suppored by SendKeys:
'
'            KEY                  CODE
'            break                {CANCEL}
'            escape               {ESCAPE}
'            left mouse button    {LBUTTON}
'            right mouse button   {RBUTTON}
'            middle mouse button  {MBUTTON}
'            clear                {CLEAR}
'            shift                {SHIFT}
'            control              {CONTROL}
'            alt                  {MENU} or {ALT}
'            pause                {PAUSE}
'            space                {SPACE}
'            select               {SELECT}
'            execute              {EXECUTE}
'            snapshot             {SNAPSHOT}
'            number pad 0         {NUMPAD0}
'            number pad 1         {NUMPAD1}
'            number pad 2         {NUMPAD2}
'            number pad 3         {NUMPAD3}
'            number pad 4         {NUMPAD4}
'            number pad 5         {NUMPAD5}
'            number pad 6         {NUMPAD6}
'            number pad 7         {NUMPAD7}
'            number pad 8         {NUMPAD8}
'            number pad 9         {NUMPAD9}
'            number pad multiply  {MULTIPLY}
'            number pad add       {ADD}
'            number pad separator {SEPARATOR}
'            number pad subtract  {SUBTRACT}
'            number pad decimal   {DECIMAL}
'            number pad divide    {DIVIDE}
'
' Sample Calls:
'   VbSendKeys "Dir~"   ' View a directory of in DOS
'
' NOTE: there is a minor difference with SendKeys syntax. You can
'       group multiple characters under the same shift key using
'       curly brackets, while VB's SendKeys uses regular brackets.
'       For example, to keep the SHIFT key pressed while you type
'       A, B, and C keys, you must run the following statement
'           VBSendKeys "+{abc}"
'       while the syntax of the built-in VB function is
'           SendKeys "+(abc)"
'---------------------------------------------------------------------

Sub VbSendKeys(ByVal sKeystrokes As String)
    Dim iKeyStrokesLen As Integer
    Dim lRepetitions As Long
    Dim bShiftKey As Boolean
    Dim bControlKey As Boolean
    Dim bAltKey As Boolean
    Dim lResult As Long
    Dim sKey As String
    Dim iAsciiKey As Integer
    Dim iVirtualKey As Integer
    Dim i As Long
    Dim j As Long
  
    Static bInitialized As Boolean
    Static AsciiKeys(0 To 255) As VKType
    Static VirtualKeys(0 To 255) As VKType
  
    On Error GoTo 0

    If Not bInitialized Then
        Dim iKey As Integer
        Dim OEMChar As String
        Dim keyScan As Integer
        
        ' Initialize AsciiKeys()
        For iKey = LBound(AsciiKeys) To UBound(AsciiKeys)
            keyScan = VkKeyScan(iKey)
            AsciiKeys(iKey).VKCode = keyScan And &HFF   ' low-byte of key scan
                                                        ' code
            AsciiKeys(iKey).Shift = (keyScan And &H100)
            AsciiKeys(iKey).Control = (keyScan And &H200)
            AsciiKeys(iKey).Alt = (keyScan And &H400)
            ' Get the ScanCode
            OEMChar = "  " ' 2 Char
            CharToOem Chr(iKey), OEMChar
            AsciiKeys(iKey).scanCode = OemKeyScan(Asc(OEMChar)) And &HFF
        Next iKey
        
        ' Initialize VirtualKeys()
        For iKey = LBound(VirtualKeys) To UBound(VirtualKeys)
            VirtualKeys(iKey).VKCode = iKey
            VirtualKeys(iKey).scanCode = MapVirtualKey(iKey, 0)
            ' no use in initializing remaining elements
        Next iKey
        bInitialized = True     ' don't run this code twice
    End If    ' End of initialization routine
  
    ' Parse the string in the same way that SendKeys() would
    Do While Len(sKeystrokes)
        lRepetitions = 1 ' Default number of repetitions for each character
        bShiftKey = False
        bControlKey = False
        bAltKey = False
        
        ' Pull off Control, Alt or Shift specifiers
        sKey = Left$(sKeystrokes, 1)
        sKeystrokes = Mid$(sKeystrokes, 2)
        
        Do While InStr(" ^%+", sKey) > 1 ' The space in " ^%+" is necessary
            If sKey = "+" Then
                bShiftKey = True
            ElseIf sKey = "^" Then
                bControlKey = True
            ElseIf sKey = "%" Then
                bAltKey = True
            End If
            sKey = Left$(sKeystrokes, 1)
            sKeystrokes = Mid$(sKeystrokes, 2)
        Loop
        
        ' Look for "{}"
        If sKey = "{" Then
            ' Look for the  "}"
            i = InStr(sKeystrokes, "}")
            If i > 0 Then
                sKey = Left$(sKeystrokes, i - 1) ' extract the content between
                                                 ' the {}
                sKeystrokes = Mid$(sKeystrokes, i + 1) ' Remove the }
            End If
        
            ' Look for repetitions
            i = Len(sKey)
            Do While Mid$(sKey, i, 1) >= "0" And Mid$(sKey, i, _
                1) <= "9" And i >= 3
                i = i - 1
            Loop
        
            If i < Len(sKey) Then ' If any digits were found...
                If i >= 2 Then ' If there is something preceding it...
                    If Mid$(sKey, i, 1) = " " Then  ' If a space precedes the
                                                    ' digits...
                        On Error Resume Next ' On overflow, ignore the value
                        lRepetitions = CLng(Mid$(sKey, i + 1))
                        On Error GoTo 0
                        sKey = Left$(sKey, i - 1)
                    End If
                End If
            End If
        End If
        
        ' Look for special words
        Select Case UCase$(sKey)
            Case "LBUTTON" ' New
                iVirtualKey = vbKeyLButton
            Case "RBUTTON" ' New
                iVirtualKey = vbKeyRButton
            Case "BREAK", "CANCEL"
                iVirtualKey = vbKeyCancel
            Case "MBUTTON" ' New
                iVirtualKey = vbKeyMButton
            Case "BACKSPACE", "BS", "BKSP"
                iVirtualKey = vbKeyBack
            Case "TAB"
                iVirtualKey = vbKeyTab
            Case "CLEAR" ' New
                iVirtualKey = vbKeyClear
            Case "ENTER", "~"
                iVirtualKey = vbKeyReturn
            Case "SHIFT" ' New
                iVirtualKey = vbKeyShift
            Case "CONTROL" ' New
                iVirtualKey = vbKeyControl
            Case "MENU", "ALT" ' New
                iVirtualKey = vbKeyMenu
            Case "PAUSE" ' New
                iVirtualKey = vbKeyPause
            Case "CAPSLOCK"
                iVirtualKey = vbKeyCapital
            Case "ESCAPE", "ESC"
                iVirtualKey = vbKeyEscape
            Case "SPACE" ' New
                iVirtualKey = vbKeySpace
            Case "PGUP"
                iVirtualKey = vbKeyPageUp
            Case "PGDN"
                iVirtualKey = vbKeyPageDown
            Case "END"
                iVirtualKey = vbKeyEnd
            Case "HOME" ' New
                iVirtualKey = vbKeyHome
            Case "LEFT"
                iVirtualKey = vbKeyLeft
            Case "UP"
                iVirtualKey = vbKeyUp
            Case "RIGHT"
                iVirtualKey = vbKeyRight
            Case "DOWN"
                iVirtualKey = vbKeyDown
            Case "SELECT" ' New
                iVirtualKey = vbKeySelect
            Case "PRTSC"
                iVirtualKey = vbKeyPrint
            Case "EXECUTE" ' New
                iVirtualKey = vbKeyExecute
            Case "SNAPSHOT" ' New
                iVirtualKey = vbKeySnapshot
            Case "INSERT", "INS"
                iVirtualKey = vbKeyInsert
            Case "DELETE", "DEL"
                iVirtualKey = vbKeyDelete
            Case "HELP"
                iVirtualKey = vbKeyHelp
            Case "NUMLOCK"
                iVirtualKey = vbKeyNumlock
'            Case "SCROLLLOCK"
'                iVirtualKey = vbKeyScrollLock
            Case "NUMPAD0" ' New
                iVirtualKey = vbKeyNumpad0
            Case "NUMPAD1" ' New
                iVirtualKey = vbKeyNumpad1
            Case "NUMPAD2" ' New
                iVirtualKey = vbKeyNumpad2
            Case "NUMPAD3" ' New
                iVirtualKey = vbKeyNumpad3
            Case "NUMPAD4" ' New
                iVirtualKey = vbKeyNumpad4
            Case "NUMPAD5" ' New
                iVirtualKey = vbKeyNumpad5
            Case "NUMPAD6" ' New
                iVirtualKey = vbKeyNumpad6
            Case "NUMPAD7" ' New
                iVirtualKey = vbKeyNumpad7
            Case "NUMPAD8" ' New
                iVirtualKey = vbKeyNumpad8
            Case "NUMPAD9" ' New
                iVirtualKey = vbKeyNumpad9
            Case "MULTIPLY" ' New
                iVirtualKey = vbKeyMultiply
            Case "ADD" ' New
                iVirtualKey = vbKeyAdd
            Case "SEPARATOR" ' New
                iVirtualKey = vbKeySeparator
            Case "SUBTRACT" ' New
                iVirtualKey = vbKeySubtract
            Case "DECIMAL" ' New
                iVirtualKey = vbKeyDecimal
            Case "DIVIDE" ' New
                iVirtualKey = vbKeyDivide
            Case "F1"
                iVirtualKey = vbKeyF1
            Case "F2"
                iVirtualKey = vbKeyF2
            Case "F3"
                iVirtualKey = vbKeyF3
            Case "F4"
                iVirtualKey = vbKeyF4
            Case "F5"
                iVirtualKey = vbKeyF5
            Case "F6"
                iVirtualKey = vbKeyF6
            Case "F7"
                iVirtualKey = vbKeyF7
            Case "F8"
                iVirtualKey = vbKeyF8
            Case "F9"
                iVirtualKey = vbKeyF9
            Case "F10"
                iVirtualKey = vbKeyF10
            Case "F11"
                iVirtualKey = vbKeyF11
            Case "F12"
                iVirtualKey = vbKeyF12
            Case "F13"
                iVirtualKey = vbKeyF13
            Case "F14"
                iVirtualKey = vbKeyF14
            Case "F15"
                iVirtualKey = vbKeyF15
            Case "F16"
                iVirtualKey = vbKeyF16
            Case Else
                ' Not a virtual key
                iVirtualKey = -1
        End Select
        
        ' Turn on CONTROL, ALT and SHIFT keys as needed
        If bShiftKey Then
            keybd_event VirtualKeys(vbKeyShift).VKCode, _
                VirtualKeys(vbKeyShift).scanCode, KEYEVENTF_KEYDOWN, 0
        End If
        
        If bControlKey Then
            keybd_event VirtualKeys(vbKeyControl).VKCode, _
                VirtualKeys(vbKeyControl).scanCode, KEYEVENTF_KEYDOWN, 0
        End If
        
        If bAltKey Then
            keybd_event VirtualKeys(vbKeyMenu).VKCode, _
                VirtualKeys(vbKeyMenu).scanCode, KEYEVENTF_KEYDOWN, 0
        End If
        
        ' Send the keystrokes
        For i = 1 To lRepetitions
            If iVirtualKey > -1 Then
                ' Virtual key
                keybd_event VirtualKeys(iVirtualKey).VKCode, _
                    VirtualKeys(iVirtualKey).scanCode, KEYEVENTF_KEYDOWN, 0
                keybd_event VirtualKeys(iVirtualKey).VKCode, _
                    VirtualKeys(iVirtualKey).scanCode, KEYEVENTF_KEYUP, 0
            Else
                ' ASCII Keys
                For j = 1 To Len(sKey)
                    iAsciiKey = Asc(Mid$(sKey, j, 1))
                    ' Turn on CONTROL, ALT and SHIFT keys as needed
                    If Not bShiftKey Then
                        If AsciiKeys(iAsciiKey).Shift Then
                            keybd_event VirtualKeys(vbKeyShift).VKCode, _
                                VirtualKeys(vbKeyShift).scanCode, _
                                KEYEVENTF_KEYDOWN, 0
                        End If
                    End If
        
                    If Not bControlKey Then
                        If AsciiKeys(iAsciiKey).Control Then
                            keybd_event VirtualKeys(vbKeyControl).VKCode, _
                                VirtualKeys(vbKeyControl).scanCode, _
                                KEYEVENTF_KEYDOWN, 0
                        End If
                    End If
        
                    If Not bAltKey Then
                        If AsciiKeys(iAsciiKey).Alt Then
                            keybd_event VirtualKeys(vbKeyMenu).VKCode, _
                                VirtualKeys(vbKeyMenu).scanCode, _
                                KEYEVENTF_KEYDOWN, 0
                        End If
                    End If
        
                    ' Press the key
                    keybd_event AsciiKeys(iAsciiKey).VKCode, _
                        AsciiKeys(iAsciiKey).scanCode, KEYEVENTF_KEYDOWN, 0
                    keybd_event AsciiKeys(iAsciiKey).VKCode, _
                        AsciiKeys(iAsciiKey).scanCode, KEYEVENTF_KEYUP, 0
        
                    ' Turn on CONTROL, ALT and SHIFT keys as needed
                    If Not bShiftKey Then
                        If AsciiKeys(iAsciiKey).Shift Then
                            keybd_event VirtualKeys(vbKeyShift).VKCode, _
                                VirtualKeys(vbKeyShift).scanCode, _
                                KEYEVENTF_KEYUP, 0
                        End If
                    End If
        
                    If Not bControlKey Then
                        If AsciiKeys(iAsciiKey).Control Then
                            keybd_event VirtualKeys(vbKeyControl).VKCode, _
                                VirtualKeys(vbKeyControl).scanCode, _
                                KEYEVENTF_KEYUP, 0
                        End If
                    End If
        
                    If Not bAltKey Then
                        If AsciiKeys(iAsciiKey).Alt Then
                            keybd_event VirtualKeys(vbKeyMenu).VKCode, _
                                VirtualKeys(vbKeyMenu).scanCode, _
                                KEYEVENTF_KEYUP, 0
                        End If
                    End If
                Next j ' Each ASCII key
            End If  ' ASCII keys
        Next i ' Repetitions
        
        ' Turn off CONTROL, ALT and SHIFT keys as needed
        If bShiftKey Then
            keybd_event VirtualKeys(vbKeyShift).VKCode, _
                VirtualKeys(vbKeyShift).scanCode, KEYEVENTF_KEYUP, 0
        End If
        
        If bControlKey Then
            keybd_event VirtualKeys(vbKeyControl).VKCode, _
                VirtualKeys(vbKeyControl).scanCode, KEYEVENTF_KEYUP, 0
        End If
        
        If bAltKey Then
            keybd_event VirtualKeys(vbKeyMenu).VKCode, _
                VirtualKeys(vbKeyMenu).scanCode, KEYEVENTF_KEYUP, 0
        End If
        Sleep 200
    Loop ' sKeyStrokes
End Sub


Attribute VB_Name = "Start"
Option Explicit

Public Const MenuEPAllowed As Boolean = False

Public trs As String
Public trsShrt As String
Public FullVersion As Boolean

Public FatalErrors As Long
Public Errors As Long
Public Warnings As Long

Public Const ttdyrs As Boolean = True
Const StartListY As Long = 22
Const StartGlobalsY As Long = 4

Const TXT_WASSERZEICHEN As String = "<! WASSERZEICHEN "
Const TXT_WASSERZEICHENZG As String = "<! WASSERZEICHENZELLGR|fffd|SSE "


Public cfgStrings As Collection
Public xFreierBereich As Long

Global DE As Collection
Global StartedByCfg As Boolean

Public theOXLWBookRes As Excel.Workbook
Public ParameterIndex As Collection

Public TheCurrentFile As String
Public UserAbort As Boolean

Public Absicherungsdatum As String

Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgKeypfad As String
Public G_cfgBinpfad As String
Public G_cfgAlleTabellenblaetterSchuetzen As Boolean

Public G_LogEnabled As Boolean

Const pwstr As String = "abcdefghijklmnopqrstufwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&/()=+#-.,;:_'*{[]}\~<>|"

Public G_Command As String
Public G_CommandParam As String

Public ExcelDataFile As String

#If VBA7 Then
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
      dwMilliseconds As Long)
      
    Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
#Else
    Public Declare Sub Sleep Lib "kernel32" (ByVal _
      dwMilliseconds As Long)
      
    Declare Function GetCurrentProcessId Lib "kernel32" () As Long
#End If


Public Const MYadOpenDynamic As Long = 2
Public Const MYadLockPessimistic As Long = 2
Public Const MYadLockOptimistic As Long = 3
Public Const MYadLockReadOnly As Long = 1


Private LocTextCol As Collection
Private LocParamsCol As Collection
Private LocParamsBoolCol As Collection

Public Function MyVersion() As String
  MyVersion = FMT1("MDStart_1", MyVersionNumber)
End Function

Private Sub InitLocalization()
  ' de auf en abbilden
  
  Set LocTextCol = New Collection
  LocTextCol.Add "Note", "Hinweis"
  
  Set LocParamsCol = New Collection
  LocParamsCol.Add "File", "Dateiname"
  LocParamsCol.Add "SaveFile", "Speicherdateiname"
  LocParamsCol.Add "File open password", "Lesepasswort"
  LocParamsCol.Add "File save password", "Schreibpasswort"
  LocParamsCol.Add "Sheet password", "Blattschutzpasswort"
  LocParamsCol.Add "Protect objects", "ObjekteSch|fffd|tzen"
  LocParamsCol.Add "Protect content", "InhalteSch|fffd|tzen"
  LocParamsCol.Add "Protect scenarios", "SzenariosSch|fffd|tzen"
  LocParamsCol.Add "Workbook password", "Arbeitsmappenschutzpasswort"
  LocParamsCol.Add "Protect workbook structure", "Arbeitsmappenaufbausch|fffd|tzen"
  LocParamsCol.Add "Protect windows", "FensterSch|fffd|tzen"
  LocParamsCol.Add "Share password", "Freigabeschutzpasswort"
  LocParamsCol.Add "Code password", "Codeschutzpasswort"
  LocParamsCol.Add "Protect all formula cells", "Alle Formelzellen sch|fffd|tzen"
  LocParamsCol.Add "Protect non-formula cells", "Alle Nicht-Formelzellen entsperren"
  LocParamsCol.Add "Protect selection", "Selektionsschutz"
  LocParamsCol.Add "Rows to repeat at top", "Wiederholungsbereich"
  LocParamsCol.Add "Watermark", "Wasserzeichen"
  LocParamsCol.Add "Name-File-Date", "Name-Datei-Datum"
  LocParamsCol.Add "Note text", "Hinweistext"
  LocParamsCol.Add "Protect", "Protect"

  
  Set LocParamsBoolCol = New Collection
  LocParamsBoolCol.Add "[ReplaceCode]", "[CodeErsatz]"
  LocParamsBoolCol.Add "[Tab]", "[Tab]"
  LocParamsBoolCol.Add "[BSFormatCells]", "[BSZellenFormatieren]"
  LocParamsBoolCol.Add "[BSFormatColumns]", "[BSSpaltenFormatieren]"
  LocParamsBoolCol.Add "[BSFormatRows]", "[BSZeilenFormatieren]"
  LocParamsBoolCol.Add "[BSInsertColumns]", "[BSSpaltenEinf|fffd|gen]"
  LocParamsBoolCol.Add "[BSInsertRows]", "[BSZeilenEinf|fffd|gen]"
  LocParamsBoolCol.Add "[BSInsertHyperlink]", "[BSHyperlinksEinf|fffd|gen]"
  LocParamsBoolCol.Add "[BSDeleteColumns]", "[BSSpaltenL|fffd|schen]"
  LocParamsBoolCol.Add "[BSDeleteRows]", "[BSZeilenL|fffd|schen]"
  LocParamsBoolCol.Add "[BSSort]", "[BSSortieren]"
  LocParamsBoolCol.Add "[BSUseAutoFilter]", "[BSAutofilterVerwenden]"
  LocParamsBoolCol.Add "[BSUsePivotTableReports]", "[BSPivotTableBerichteVerwenden]"
  LocParamsBoolCol.Add "[ExeFileLoad]", "[ExeFileLoad]"
  LocParamsBoolCol.Add "[ButtonProtect]", "[ButtonProtect]"
  LocParamsBoolCol.Add "[Protect]", "[Protect]"
  LocParamsBoolCol.Add "[SaveButton]", "[ButtonSpeichern]"
  LocParamsBoolCol.Add "[PrintBeforeClose]", "[DruckenVorSchlie|fffd|en]"
  LocParamsBoolCol.Add "[PrintButton]", "[ButtonDrucken]"
  LocParamsBoolCol.Add "[ProtectSelection]", "[Selektionsschutz]"
  LocParamsBoolCol.Add "[RepeatedRange]", "[Wiederholungsbereich]"
  LocParamsBoolCol.Add "[ReplaceCells]", "[ZellErsatz]"
End Sub

Sub Auto_Open()
    G_cfgTemppfad = ThisWorkbook.path
    G_cfgLogpfad = ThisWorkbook.path
    G_cfgKeypfad = ThisWorkbook.path
    G_cfgBinpfad = ThisWorkbook.path
    InitApp
    GetData
    
    InitLocalization
    
    G_Command = ""
    Dim commandString As String
    commandString = GetSetting( _
        appname:="Stromwerken", _
        Section:="EP", _
        Key:="COMMAND", _
        Default:="")
        
    If commandString <> "" Then
        SaveSetting _
               appname:="Stromwerken", _
               Section:="EP", _
               Key:="COMMAND", _
               Setting:=""
        If Left(commandString, 7) = "ETPROT " Then
          G_Command = "ETPROT"
          G_CommandParam = Mid(commandString, 7)
        End If
    End If
    
    
    If FullVersion = False Then ThisWorkbook.Close False
    
'    If Left(Application.Version, 3) <> "8.0" And Left(Application.Version, 3) <> "9.0" And Left(Application.Version, 4) <> "10.0" And Left(Application.Version, 4) <> "11.0" And Left(Application.Version, 4) <> "12.0" And Left(Application.Version, 4) <> "14.0" Then
'        'If MsgBox("Dieses Programm l|fffd|uft nur unter Excel97 - 2010! Soll das Programm beendet werden? (Benutzung auf eigene Gefahr! Der VBA-Codeschutzpasswort wird nicht durchgef|fffd|hrt! [ButtonProtect] ist nicht verf|fffd|gbar)", vbYesNo) = vbYes Then
'        If MsgBox(FMT0("MDStart_2"), vbYesNo) = vbYes Then
'            ThisWorkbook.Close
'        End If
'    End If
    
    If Not FileExists(G_cfgTemppfad & "\ExcelProtectDataSuite" & GetUserName & ".xls") Then
      ExcelDataFile = ThisWorkbook.path & "\ExcelProtectData.xls"
      
      If Not MenuEPAllowed Then
        Dim wb As Workbook
        Dim firstQuestion As Boolean
        firstQuestion = True
        For Each wb In Workbooks
          If Not wb Is ThisWorkbook Then
            If Not wb.Saved Then
              If firstQuestion Then
                'If MsgBox("ACHTUNG: Sie haben ungespeicherte Excel-Dateien ge|fffd|ffnet! ExcelProtect muss zur Absicherung von Dateien alle anderen Dateien schlie|fffd|en, Ver|fffd|nderungen gehen dabei unwiederruflich verloren. Sind Sie wirklich sicher, dass Sie ver|fffd|nderte Dateien schlie|fffd|en und mit ExcelProtect fortfahren wollen? Stromwerken haftet nicht f|fffd|r eventuelle Datenverluste! Bein NEIN wird ExcelProtect beendet und die ver|fffd|nderte Dateien bleiben ge|fffd|ffnet.", vbQuestion + vbYesNo) = vbNo Then
                If MsgBox(FMT0("MDStart_3"), vbQuestion + vbYesNo) = vbNo Then
                  ThisWorkbook.Close
                Else
                  firstQuestion = False
                End If
              End If
            End If
            wb.Close False
          End If
        Next wb
      End If
      
checkFinished:
      
'      CheckVersion 0, ProgNameShort, ProgNameShort & "\SWUpdate" & ProgNameShort & ".txt", MyInternalVersion
    End If
    
    Dim i As Long
    Dim item As DatenElement
    If FileExists(G_cfgTemppfad & "\ExcelProtectDataSuite" & GetUserName & ".xls") = True Then
        StartedByCfg = True
        ExcelDataFile = G_cfgTemppfad & "\ExcelProtectDataSuite" & GetUserName & ".xls"
        ReadEPConfig
        ProtectProject 0 ' i
        Kill ExcelDataFile
        Application.Quit
    ElseIf G_Command = "ETPROT" Then
        ExcelDataFile = G_cfgTemppfad & "\ExcelProtectDataSuite" & GetUserName & ".xls"
        Dim templateNumber As String
        templateNumber = GetNumber(G_CommandParam)
        If Not FileExists(G_cfgBinpfad & "\ExcelProtectData" & templateNumber & ".xls") Then
          'MsgBox "Die notwendige Schablone " & G_cfgBinpfad & "\ExcelProtectData" & templateNumber & ".xls existiert nicht! Bitte wenden Sie sich an Ihre Administration.", vbCritical
          MsgBox FMT2("MDStart_4", G_cfgBinpfad, CStr(templateNumber)), vbCritical
          Application.Quit
        End If
        FileCopy G_cfgBinpfad & "\ExcelProtectData" & templateNumber & ".xls", ExcelDataFile
        ReadEPConfig
        ProtectProject 0 ' i
        Kill ExcelDataFile
        Application.Quit
        
    ElseIf FileExists(ThisWorkbook.path & "\ExcelProtectRunOnce.txt") Then
      Dim cfgHG As String
      Dim cfgGP As String
      Dim cfgTAG As String
    
      StartedByCfg = True
      Dim logFF As Long
      logFF = FreeFile
      Open ThisWorkbook.path & "\ExcelProtectRunOnce.txt" For Input As #logFF
      Input #logFF, cfgHG
      Input #logFF, cfgGP
      Input #logFF, cfgTAG
      
      Dim str As String
      Set cfgStrings = New Collection
      While Not EOF(1)
        Input #logFF, str
        cfgStrings.Add str
      Wend
              
      Close #logFF
    
      ReadEPConfig
      
      i = 0
      For Each item In DE
        If item.Hauptgruppe = cfgHG And _
           item.Gruppe = cfgGP And _
           item.name = cfgTAG Then
           ProtectProject i
           Exit For
        End If
        i = i + 1
      Next item
      Kill (ThisWorkbook.path & "\ExcelProtectRunOnce.txt")
      Application.Quit
    Else
      
      
'      Dim found As Boolean
      Dim c
      For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
        If c.Caption = "ExcelProtect" Then
          Application.CommandBars("Worksheet Menu Bar").Controls("ExcelProtect").Delete
          Exit For
        End If
      Next c
      
      If MenuEPAllowed Then
        Dim cbb As CommandBarPopup
        Dim scbb As CommandBarButton
        
        Set cbb = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup)
       
        'cbb.Caption = "ExcelProtect"
        cbb.Caption = FMT0("MDStart_5")
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Start"
        scbb.Caption = FMT0("MDStart_6")
        scbb.OnAction = "ExcelProtectShowMainMenu"
        'scbb.TooltipText = "Startet Excel-Protect"
        scbb.TooltipText = FMT0("MDStart_7")
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Aus Men|fffd| entfernen"
        scbb.Caption = FMT0("MDStart_8")
        scbb.OnAction = "ExcelProtectRemoveMenu"
        'scbb.TooltipText = "Entfernt ExcelProtect aus der Men|fffd|leiste."
        scbb.TooltipText = FMT0("MDStart_9")
      End If
      
      If UCase(ThisWorkbook.name) = "EXCELPROTECT.XLS" Or UCase(ThisWorkbook.name) = "EXCELPROTECT.XLA" Then
          ExcelProtectShowMainMenu
      End If
    End If
End Sub

Sub Auto_Close()
    On Error Resume Next
End Sub

Sub InitApp()
  Dim cfg As New CfgReader
  Dim S As String
  
  G_cfgKeypfad = ThisWorkbook.path
  G_cfgLogpfad = ThisWorkbook.path
  G_cfgTemppfad = ThisWorkbook.path
  G_cfgBinpfad = ThisWorkbook.path
  
  Dim overrideLanguage As String
  Dim showStartupMsg As Boolean
  showStartupMsg = False
  
  Set cfg = New CfgReader
  If FileExists(ThisWorkbook.path & "\EP.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Then

      If FileExists(ThisWorkbook.path & "\EP.cfg") = True Then
        cfg.GetCfg (ThisWorkbook.path & "\EP.cfg")
      ElseIf FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCfg (ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg")
      End If
      
      Call InitTranslation(ThisWorkbook.path, "EP", cfg)
      
      If cfg.GetSection("EP") = True Then
          S = cfg.GetValue("HELLOWORLD")
          'If UCase(s) = "JA" Then
          If IsYes(S) Then
            'MsgBox "Hinweis: Der Excel-Sheet-Checker wurde gestartet. Sie k|fffd|nnen diesen Hinweis in der Datei EP.cfg deaktivieren. Stellen Sie dort bitte den Parameter HELLOWORLD auf Nein", vbInformation
            'MsgBox FMT0("MDStart_10"), vbInformation
            showStartupMsg = True
          End If
          S = cfg.GetValue("LOG")
          'If UCase(s) = "JA" Then
          If IsYes(S) Then
            G_LogEnabled = True
          End If
          S = cfg.GetValue("ALLEBLAETTERSCHUETZEN")
          'If UCase(s) = "JA" Then
          If IsYes(S) Then
            G_cfgAlleTabellenblaetterSchuetzen = True
          End If
      End If
      If cfg.GetSection("GLOBALS") = True Then
          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          G_cfgBinpfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("BINPFAD"))
          
          S = cfg.GetValue("CURSORLOCATION")
          If UCase(S) = "SERVER" Then
            G_Cursorlocation = 2 ' ADODB.adUseServer
          Else
            G_Cursorlocation = 3 ' ADODB.adUseClient
          End If
          
          overrideLanguage = cfg.GetValue("LANGUAGE")
      End If
      
      If cfg.GetSection("DBCONNECT") = True Then
        G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING")
      End If
  
  Else
    Call InitTranslation(ThisWorkbook.path, "EP", cfg)
  End If
  
  
  If showStartupMsg Then
    MsgBox FMT0("MDStart_10"), vbInformation
  End If

  ClearLog
  LogPrint "EP Start"

End Sub

Sub LogPrint(ByVal str As String, Optional ByVal dur As Double = 0)
  If G_LogEnabled Then
    If G_cfgLogpfad = "" Then
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\EP-Log-" & GetUserName & ".txt"
    Else
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\EP-Log-" & GetUserName & ".txt"
    End If
  End If
End Sub

Public Function AddTextToFile(ByVal strData As String, _
     ByVal FullPath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    Dim fn As Long
    fn = FreeFile
    Dim S As String

GoAgain:

    On Error GoTo CatchEx

    Open FullPath For Append As fn
    Print #fn, strData
    Close fn

    AddTextToFile = True
    Exit Function

CatchEx:
    Sleep 100
    GoTo GoAgain
End Function

Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim S As String
  If cfgpath = "" Then S = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Then
    S = cfgpath
  Else
    S = ThisWorkbook.path & "\" & cfgpath
  End If
  
  If Not PathExists(S) Then
    MkFullDir S
    If Not PathExists(S) Then
      'MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical
      MsgBox FMT1("MDStart_11", S), vbCritical
    End If
  End If
  
  GetRelativePath = S
End Function


Sub ClearLog()
  On Error Resume Next
  If G_cfgLogpfad = "" Then
    Kill ThisWorkbook.path & "\EP-Log" & GetUserName & ".txt"
  Else
    Kill G_cfgTemppfad & "\EP-Log" & GetUserName & ".txt"
  End If
End Sub

Function CheckVBAWritable(ByRef wb As Workbook) As Boolean
  CheckVBAWritable = False

' Debug.Print Application.VBE.ActiveVBProject.Protection
  On Error GoTo noVBA
  If wb.VBProject.Protection = 0 Then
    CheckVBAWritable = True
  End If
  Exit Function
noVBA:
End Function


Function CheckVBAAccessAllowed() As Boolean
  CheckVBAAccessAllowed = True

' Debug.Print Application.VBE.ActiveVBProject.Protection
  On Error GoTo noVBA
  If ThisWorkbook.VBProject.Protection = 0 Then
  End If
  Exit Function
noVBA:
  CheckVBAAccessAllowed = False
End Function

Public Sub ExcelProtectShowMainMenu()
    If Not CheckVBAAccessAllowed Then
        'MsgBox "Sie benutzen eine Excel-Version (ab Excel2000), die den Zugriff auf VBA-Code nur beschr|fffd|nkt zul|fffd|sst. Um den vollen Funktionsumfag von ExcelProtect nutzen zu k|fffd|nnen, m|fffd|ssen Sie unter Extras/Makro/Sicherheit im Reiter " & _
        '  "'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic Projekt vertrauen' anschalten. Danach ist erst die volle Analyse m|fffd|glich! Bitte schalten Sie die Funktion bei Bedarf danach wieder aus!", vbCritical
        MsgBox FMT0("MDStart_12"), vbCritical
    End If

    StartedByCfg = False
    ReadEPConfig
    GetData
    If Len(trs) Then Hauptmen|fffd|.Label4 = trs
    Hauptmen|fffd|.OpenMen|fffd|
End Sub

Sub ExcelProtectRemoveMenu()
    On Error Resume Next
    'If MsgBox("Sind Sie sicher, dass Sie ExcelProtect aus Ihrer Men|fffd|leiste entfernen m|fffd|chten?", vbYesNo) = vbYes Then
    If MsgBox(FMT0("MDStart_13"), vbYesNo) = vbYes Then
        Application.CommandBars("Worksheet Menu Bar").Controls("ExcelProtect").Delete
        ThisWorkbook.Close
    End If
End Sub

Function dothat(trs As String) As String
    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(trs)
        If Mid(trs, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(trs, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(trs, i, 1) >= "0" And Mid(trs, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(trs, i, 1)))
        ElseIf Mid(trs, i, 1) >= "a" And Mid(trs, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(trs, i, 1)))
        ElseIf Mid(trs, i, 1) >= "A" And Mid(trs, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(trs, i, 1)))
        Else
            s2 = s2 + Mid(trs, i, 1)
        End If
    Next i
    
    dothat = s2
End Function

Public Sub ReadEPConfig()


  Set DE = New Collection
  Dim eintrag As DatenElement
  
  Dim oXLWbook                  As Excel.Workbook
  
  ' |fffd|ffnen der Datei
  On Error GoTo OpenError
  
  Set oXLWbook = Workbooks.Open(ExcelDataFile, False, True)
  Dim item
  
  Dim hgr As String
  Dim gr As String
  xFreierBereich = GetCollumn("Datenliste", 1, "Freier Bereich")
  
  hgr = "Alle"
  gr = "Alle"
  For Each item In oXLWbook.Sheets
      If item.Cells(2, 2).value = "Datenliste" And xFreierBereich >= 0 Then
        Dim y As Long
        y = 5
        While Not IsEmpty(item.Cells(y, 3)) Or Not IsEmpty(item.Cells(y + 1, 3)) Or _
          Not IsEmpty(item.Cells(y + 2, 3)) Or Not IsEmpty(item.Cells(y + 3, 3)) Or _
          Not IsEmpty(item.Cells(y + 3, xFreierBereich))
          If Not IsEmpty(item.Cells(y, 1)) Then
            hgr = item.Cells(y, 1)
            Set eintrag = New DatenElement
            eintrag.name = item.Cells(y, 1)
            eintrag.Hauptgruppe = hgr
            eintrag.Zeile = y
            eintrag.Tabelle = item.name
            eintrag.typ = "Hgr"
            DE.Add eintrag
          End If
          If Not IsEmpty(item.Cells(y, 2)) Then
            gr = item.Cells(y, 2)
            Set eintrag = New DatenElement
            eintrag.name = item.Cells(y, 2)
            eintrag.Hauptgruppe = hgr
            eintrag.Gruppe = gr
            eintrag.Zeile = y
            eintrag.Tabelle = item.name
            eintrag.typ = "Grp"
            DE.Add eintrag
          End If
          If Not IsEmpty(item.Cells(y, 3)) Then
            Set eintrag = New DatenElement
            eintrag.name = item.Cells(y, 3)
            eintrag.Hauptgruppe = hgr
            eintrag.Gruppe = gr
            eintrag.Zeile = y
            eintrag.Tabelle = item.name
            eintrag.typ = "E"
            DE.Add eintrag
          End If
          y = y + 1
        Wend
      ElseIf item.name <> "Globals" Then
        Set eintrag = New DatenElement
        eintrag.name = item.name
        eintrag.Tabelle = item.name
        eintrag.Hauptgruppe = "---"
        eintrag.Gruppe = "---"
        eintrag.Zeile = -1
        eintrag.typ = "Tab"
        DE.Add eintrag
      End If
  Next item
  oXLWbook.Close
  Set oXLWbook = Nothing
  
  Exit Sub
OpenError:
  'MsgBox "Die Datendatei '" & ExcelDataFile & "' konnte nicht ge|fffd|ffnet werden! (" & Err.Description & ")", vbCritical
  MsgBox FMT2("MDStart_14", ExcelDataFile, Err.Description), vbCritical

End Sub


Sub ProtectProject(projektIndex As Long)

    Dim deitem As DatenElement
  Dim y As Long
  Dim infotxt As String
  
  If projektIndex < 0 Then Exit Sub

  Dim oXLWbook                  As Excel.Workbook
  
  FatalErrors = 0
  Errors = 0
  Warnings = 0
  
  ' |fffd|ffnen der Datei
  On Error GoTo OpenError
  
  Set oXLWbook = Workbooks.Open(ExcelDataFile)

  On Error GoTo 0
  Absicherungsdatum = CStr(Now)
  
  UserAbort = False
  
  If Not StartedByCfg Then
    'MsgBox "Bitte wechseln Sie w|fffd|hrend der Absicherung Ihrer Datei nicht das Programm (z.B. |fffd|ber ALT-TAB oder |fffd|ber die Taskleiste)! Dies kann zu unvorhersehbaren Fehlern f|fffd|hren! Bitte warten Sie auch bei l|fffd|ngerer Inaktivit|fffd|t ab, der Absicherungsvorgang kann einige Zeit in Anspruch nehmen! ExcelProtect informiert Sie, sobald die Absicherung beendet ist oder Fehler auftreten!" & vbCrLf & vbCrLf & _
    '"Bei der Absicherung mit ExcelProtect wird die Datei unter einem neuen Namen (!) abgespeichert. Die Originaldatei wird hierbei NICHT ver|fffd|ndert und ist auch nicht |fffd|berschreibbar. Der Hintergrund hierf|fffd|r ist, dass Sie an der Original-Datei auch weiter arbeiten k|fffd|nnen m|fffd|ssen - wenn das Original aber gesch|fffd|tzt w|fffd|re, ginge dies nicht mehr. Um die gesch|fffd|tzte Datei zu testen m|fffd|ssen Sie diese nach der Absicherung |fffd|ffnen.", vbInformation
    MsgBox FMT0("MDStart_15"), vbInformation
  End If
  
  If DE(projektIndex + 1).typ = "Tab" Then
    If oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(2, 2).value = "Datei" Then
        Application.EnableEvents = False
        infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
        'infotxt = infotxt & "Schutz des ExcelProtectData-Eintrags '" & oXLWbook.Worksheets(DE(projektIndex + 1).name).name & "' (Datei)" & vbCrLf
        infotxt = infotxt & FMT1("MDStart_16", oXLWbook.Worksheets(DE(projektIndex + 1).name).name) & vbCrLf
        'infotxt = infotxt & CStr(Now) & " - User: " & Environ("USERNAME") & vbCrLf
        infotxt = infotxt & FMT2("MDStart_17", CStr(Now), Environ("USERNAME")) & vbCrLf
        infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
        ProtectFile oXLWbook.Worksheets(DE(projektIndex + 1).name), infotxt
        Application.EnableEvents = True
    ElseIf oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(2, 2).value = "Liste" Then
      y = 0
      infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
      'infotxt = infotxt & "Schutz des ExcelProtectData-Eintrags '" & oXLWbook.Worksheets(DE(projektIndex + 1).name).name & "' (Liste)" & vbCrLf
      infotxt = infotxt & FMT1("MDStart_18", oXLWbook.Worksheets(DE(projektIndex + 1).name).name) & vbCrLf
      'infotxt = infotxt & CStr(Now) & " - User: " & Environ("USERNAME") & vbCrLf
      infotxt = infotxt & FMT2("MDStart_17", CStr(Now), Environ("USERNAME")) & vbCrLf
      infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
      Do While Not IsEmpty(oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1))
        Dim item
        Dim found As Boolean
        found = False
        For Each item In oXLWbook.Worksheets
          If item.name = oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1) Then
              found = True
              Exit For
          End If
        Next item
        If Not found Then
          'infotxt = infotxt & "Fehler(): In der Datei 'ExcelProtectData.xls' gibt es keine Tabelle mit dem Namen '" & oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1) & "'!" & vbCrLf
          infotxt = infotxt & FMT1("MDStart_19", oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1)) & vbCrLf
        Else
          If oXLWbook.Worksheets("" & oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1) & "").Cells(2, 1) <> "Datei" Then
            'infotxt = infotxt & "Hinweis (2): Die Tabelle '" & oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1) & "' ist eine List! Es k|fffd|nnen keine Listen in Listen bearbeitet werden!" & vbCrLf
            infotxt = infotxt & FMT1("MDStart_20", CStr(oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1))) & vbCrLf
            Warnings = Warnings + 1
          Else
            Application.EnableEvents = False
            infotxt = infotxt & "----" & vbCrLf
            'infotxt = infotxt & "Eintrag '" & oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1) & "' (Datei)" & vbCrLf
            infotxt = infotxt & FMT1("MDStart_21", CStr(oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1))) & vbCrLf
            infotxt = infotxt & "----" & vbCrLf
            ProtectFile oXLWbook.Worksheets("" & oXLWbook.Worksheets(DE(projektIndex + 1).name).Cells(3 + y, 1) & ""), infotxt
            Application.EnableEvents = True
          End If
        End If
        y = y + 1
      Loop
    End If
  ' ---------------------------------------------------------
  ' Einzeldatei
  ' ---------------------------------------------------------
  ElseIf DE(projektIndex + 1).typ = "E" Then
    Application.EnableEvents = False
    infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
    'infotxt = infotxt & "Schutz des ExcelProtectData-Eintrags '" & oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle).name & "' - " & DE(projektIndex + 1).name & " (Einzeldatei, Zeile " & DE(projektIndex + 1).Zeile & ")" & vbCrLf
    infotxt = infotxt & FMT3("MDStart_22", oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle).name, DE(projektIndex + 1).name, DE(projektIndex + 1).Zeile) & vbCrLf
    'infotxt = infotxt & CStr(Now) & " - User: " & Environ("USERNAME") & vbCrLf
    infotxt = infotxt & FMT2("MDStart_17", CStr(Now), Environ("USERNAME")) & vbCrLf
    infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
    ProtectFile oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle), infotxt, DE(projektIndex + 1)
    Application.EnableEvents = True
  
  ' ---------------------------------------------------------
  ' Gruppe
  ' ---------------------------------------------------------
  ElseIf DE(projektIndex + 1).typ = "Grp" Then
    infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
    'infotxt = infotxt & "Schutz der Gruppe '" & oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle).name & "' - " & DE(projektIndex + 1).name & " (Zeile " & DE(projektIndex + 1).Zeile & ")" & vbCrLf
    infotxt = infotxt & FMT3("MDStart_23", oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle).name, DE(projektIndex + 1).name, DE(projektIndex + 1).Zeile) & vbCrLf
    'infotxt = infotxt & CStr(Now) & " - User: " & Environ("USERNAME") & vbCrLf
    infotxt = infotxt & FMT2("MDStart_17", CStr(Now), Environ("USERNAME")) & vbCrLf
    infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
    For Each deitem In DE
      If deitem.Gruppe = DE(projektIndex + 1).Gruppe And deitem.typ = "E" And deitem.Tabelle = DE(projektIndex + 1).Tabelle Then
        Application.EnableEvents = False
        infotxt = infotxt & "----" & vbCrLf
        'infotxt = infotxt & "Eintrag '" & deitem.name & "' (Zeile " & deitem.Zeile & ")" & vbCrLf
        infotxt = infotxt & FMT2("MDStart_24", deitem.name, deitem.Zeile) & vbCrLf
        infotxt = infotxt & "----" & vbCrLf
        ProtectFile oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle), infotxt, deitem
        Application.EnableEvents = True
        If FatalErrors > 0 Then Exit For
        If Errors > 0 Then Exit For
        If UserAbort Then Exit For
      End If
    Next deitem
  
  ' ---------------------------------------------------------
  ' Hauptgruppe
  ' ---------------------------------------------------------
  ElseIf DE(projektIndex + 1).typ = "Hgr" Then
    infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
    'infotxt = infotxt & "Schutz der Hauptgruppe '" & oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle).name & "' - " & DE(projektIndex + 1).name & " (Zeile " & DE(projektIndex + 1).Zeile & ")" & vbCrLf
    infotxt = infotxt & FMT3("MDStart_25", oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle).name, DE(projektIndex + 1).name, DE(projektIndex + 1).Zeile) & vbCrLf
    'infotxt = infotxt & CStr(Now) & " - User: " & Environ("USERNAME") & vbCrLf
    infotxt = infotxt & FMT2("MDStart_17", CStr(Now), Environ("USERNAME")) & vbCrLf
    infotxt = infotxt & "------------------------------------------------------------------------------------------------" & vbCrLf
    For Each deitem In DE
      If deitem.Hauptgruppe = DE(projektIndex + 1).Hauptgruppe And deitem.typ = "E" And deitem.Tabelle = DE(projektIndex + 1).Tabelle Then
        Application.EnableEvents = False
        infotxt = infotxt & "----" & vbCrLf
        'infotxt = infotxt & "Eintrag '" & deitem.name & "' (Zeile " & deitem.Zeile & ")" & vbCrLf
        infotxt = infotxt & FMT2("MDStart_24", deitem.name, deitem.Zeile) & vbCrLf
        infotxt = infotxt & "----" & vbCrLf
        ProtectFile oXLWbook.Worksheets(DE(projektIndex + 1).Tabelle), infotxt, deitem
        Application.EnableEvents = True
        If FatalErrors > 0 Then Exit For
        If Errors > 0 Then Exit For
        If UserAbort Then Exit For
      End If
    Next deitem
  End If
  
  If Not theOXLWBookRes Is Nothing Then
    theOXLWBookRes.Close False
    Set theOXLWBookRes = Nothing
  End If
  
  Dim infotxt2 As String
  infotxt = infotxt & "***********************************************************" & vbCrLf
  'infotxt = infotxt & "*** Ergebnis " & CStr(Now) & ":" & vbCrLf
  infotxt = infotxt & FMT1("MDStart_26", CStr(Now)) & vbCrLf
  If FatalErrors = 0 And Errors = 0 And UserAbort = False Then
    'infotxt2 = infotxt2 & "*** ABSICHERUNG ERFOLGREICH!" & vbCrLf
    infotxt2 = infotxt2 & FMT0("MDStart_27") & vbCrLf
    If Warnings > 0 Then
      'infotxt2 = infotxt2 & "*** Es gab Hinweise, bitte beachten Sie diese!" & vbCrLf
      infotxt2 = infotxt2 & FMT0("MDStart_28") & vbCrLf
    End If
    SaveSetting appname:="Stromwerken", _
                Section:="IDV-Suite", _
                Key:="EPErgebnis", Setting:=1
  ElseIf FatalErrors > 0 Or Errors > 0 Then
    'infotxt2 = infotxt2 & "*** FEHLER W|fffd|HREND DER ABSICHERUNG!" & vbCrLf
    infotxt2 = infotxt2 & FMT0("MDStart_29") & vbCrLf
    infotxt2 = infotxt2 & FMT0("MDStart_30") & vbCrLf
    SaveSetting appname:="Stromwerken", _
                Section:="IDV-Suite", _
                Key:="EPErgebnis", Setting:=2
  ElseIf UserAbort = True Then
    'infotxt2 = infotxt2 & "*** ABSICHERUNG ABGEBROCHEN!" & vbCrLf
    infotxt2 = infotxt2 & FMT0("MDStart_31") & vbCrLf
    SaveSetting appname:="Stromwerken", _
                Section:="IDV-Suite", _
                Key:="EPErgebnis", Setting:=3
  End If
  'infotxt2 = infotxt2 & "*** " & FatalErrors & " Schwer wiegende(r) Fehler, " & Errors & " Fehler, " & Warnings & " Hinweis(e)" & vbCrLf
  infotxt2 = infotxt2 & FMT3("MDStart_32", CStr(FatalErrors), CStr(Errors), CStr(Warnings)) & vbCrLf
  infotxt = infotxt & infotxt2
  infotxt = infotxt & "***********************************************************" & vbCrLf
  If FatalErrors = 0 And Errors = 0 And UserAbort = False Then
    'infotxt = infotxt & "Bitte testen Sie die abgesicherten Programme vor der |fffd|bernahme in Produktion, damit keine unerw|fffd|nschten Nebeneffekte eintreten! Sie sollten insbesondere bei der Nutzung von [ButtonProtect] und [Protect] auf Funktionalit|fffd|tstests achten!" & vbCrLf
    infotxt = infotxt & FMT0("MDStart_33") & vbCrLf
  End If
  
  Dim logFF As Long
  logFF = FreeFile
  
  Open G_cfgLogpfad & "\EPLastLog-" & GetUserName & ".txt" For Output As #logFF
  Print #logFF, infotxt
  Close #logFF
  
  'infotxt = infotxt & vbCrLf & "Die angezeigten Informationen k|fffd|nnen in der Datei '" & G_cfgLogpfad & "\EPLastLog-" & GetUserName & ".txt' nachgelesen werden."
  infotxt = infotxt & vbCrLf & FMT2("MDStart_34", G_cfgLogpfad, GetUserName)
  
  If G_Command <> "ETPROT" Then
    Open G_cfgLogpfad & "\EPLog.txt" For Append As #logFF
    'Print #logFF, infotxt & "Alle Absicherungen werden in der Datei '" & ThisWorkbook.path & "\EPLog.txt' protokolliert."
    Print #logFF, infotxt & FMT1("MDStart_35", ThisWorkbook.path)
    Close #logFF
  End If
  
  
'  DebugPrint "1"
  If Not StartedByCfg Then
'    If G_Command = "ETPROT" Then
      Ergebnis.ErgebnisText = infotxt
      '    Ergebnis.ErgebnisText.SelStart = Len(infotxt)
      Ergebnis.Show
'    Else
'      MsgBox infotxt2 & vbCrLf & "Details der Absicherung k|fffd|nnen Sie der Datei '" & G_cfgLogpfad & "\EPLastLog-" & GetUserName & ".txt im Programmordner entnehmen." & vbCrLf & vbCrLf & "Bitte testen Sie die abgesicherten Programme vor der |fffd|bernahme in Produktion, damit keine unerw|fffd|nschten Nebeneffekte eintreten!", vbInformation + vbApplicationModal
'    End If
  End If
  
  oXLWbook.Close False
  Set oXLWbook = Nothing
  
  
  Exit Sub

OpenError:
  'MsgBox "Die Datendatei '" & ExcelDataFile & "' konnte nicht ge|fffd|ffnet werden!", vbCritical
  MsgBox FMT1("MDStart_36", ExcelDataFile), vbCritical

End Sub

Sub DebugPrint(infotext As String)
  Dim logFF As Long
  logFF = FreeFile
  Open G_cfgLogpfad & "\EPLog.txt" For Append As #logFF
  Print #logFF, infotext
  Close #logFF
End Sub

Sub ProtectFile(oXLWSheet As Worksheet, ByRef infotxt As String, Optional ByRef dat As DatenElement)
  Dim found As Boolean
  Dim y As Long
  Dim tStr
'  Dim oldCalc
  Dim hasGlobals As Boolean
  Dim ws As Worksheet
  Dim item
  
  Dim additionalErrorInfo As String
  
  Dim lockCells As Boolean
  Dim unlockNonFormulaCells As Boolean
  Dim migritem
  Dim newMigr As TextMigr
  Dim tPos As Long
 
  Dim lockedCells As Long
  lockedCells = 0
  
  Dim fehlendeWasserzeichen As Long
  fehlendeWasserzeichen = 0
  
  Dim tableMigr As Collection
  Dim codeMigr As Collection
  Dim tabs As Collection
  
  Set codeMigr = New Collection
  Set tableMigr = New Collection
  Set tabs = New Collection
  
  Dim wert As Werte
  Set wert = New Werte
  
'  GetParameterIndexes oXLWSheet

  TheCurrentFile = ""
  
  If Not GetWerte(oXLWSheet, wert, dat, tableMigr, codeMigr, tabs, infotxt) Then
    'infotxt = infotxt & "Fehler (7): Die Werte konnten nicht erfolgreich eingelesen werden!" & vbCrLf
    infotxt = infotxt & FMT0("MDStart_37") & vbCrLf
    Errors = Errors + 1
    Exit Sub
  End If
  
  GetResFile infotxt, wert.Inp
  
  Dim oXLWbook As Excel.Workbook

'  On Error Resume Next
  On Error GoTo myErrorHandler
  
  Set oXLWbook = GetWorkbook(wert.Inp)
  TheCurrentFile = wert.Inp
  If oXLWbook Is Nothing Then
    'infotxt = infotxt & "Fehler (2): Die Datei konnte nicht ge|fffd|ffnet werden!" & vbCrLf
    infotxt = infotxt & FMT0("MDStart_38") & vbCrLf
    Errors = Errors + 1
    Exit Sub
  End If
  oXLWbook.Activate
  
  hasGlobals = False
  For Each ws In oXLWSheet.Parent.Sheets
    If ws.name = "Globals" Then
      hasGlobals = True
      Exit For
    End If
  Next ws
  
  lockCells = False
  'If UCase(wert.Formelzellensch|fffd|tzen) = "JA" Then
  If IsYes(wert.Formelzellensch|fffd|tzen) Then
    lockCells = True
  End If
  
  'If UCase(wert.NichtFormelzellenEntsch|fffd|tzen) = "JA" Then
  If IsYes(wert.NichtFormelzellenEntsch|fffd|tzen) Then
    unlockNonFormulaCells = True
  End If
  
  
  
  ' ------------------------------------------------------------
  ' Globaler Code Ersatz
  ' ------------------------------------------------------------
  
  If hasGlobals Then
    y = StartGlobalsY
    While Not IsEmpty(oXLWSheet.Parent.Sheets("Globals").Cells(y, 3)) Or Not IsEmpty(oXLWSheet.Parent.Sheets("Globals").Cells(y + 1, 3))
        If Not IsEmpty(oXLWSheet.Parent.Sheets("Globals").Cells(y, 3)) Then
          If Left(oXLWSheet.Parent.Sheets("Globals").Cells(y, 3), 1) <> "#" Then
            Set newMigr = New TextMigr
            newMigr.TxtFrom = oXLWSheet.Parent.Sheets("Globals").Cells(y, 3)
            newMigr.TxtTo = oXLWSheet.Parent.Sheets("Globals").Cells(y, 4)
            If codeMigr.Count > 0 Then
                For tPos = 1 To codeMigr.Count
                    If Len(newMigr.TxtFrom) >= Len(codeMigr(tPos).TxtFrom) Then
                        Exit For
                    End If
                Next tPos
            End If
            If tPos = 0 Or tPos >= codeMigr.Count Then
                codeMigr.Add newMigr
            Else
                ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
                codeMigr.Add newMigr, , tPos
            End If
          End If
        End If
        y = y + 1
    Wend
  End If
  
  ' ------------------------------------------------------------
  ' cfgStrings einlesen
  ' ------------------------------------------------------------
  If Not cfgStrings Is Nothing Then
    If cfgStrings.Count > 0 Then
      For Each item In cfgStrings
        Dim tType As String
        Set newMigr = New TextMigr
        If Left(item, 3) = "CR:" Or Left(item, 3) = "TR:" Then
          tType = Left(item, 3)
          tStr = Mid(item, 4)
          Dim istgleich As Long
          istgleich = InStr(tStr, "=")
          If istgleich <> 0 Then
            newMigr.TxtFrom = Left(tStr, istgleich - 1)
            newMigr.TxtTo = Mid(tStr, istgleich + 1)
          Else
            tType = ""
          End If
        Else
          tType = ""
        End If
        
        ' CODE REPLACE
        If tType = "CR:" Then
          If codeMigr.Count > 0 Then
              For tPos = 1 To codeMigr.Count
                  If Len(newMigr.TxtFrom) >= Len(codeMigr(tPos).TxtFrom) Then
                      Exit For
                  End If
              Next tPos
          End If
          If tPos = 0 Or tPos >= codeMigr.Count Then
              codeMigr.Add newMigr
          Else
              ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
              codeMigr.Add newMigr, , tPos
          End If
          
        ' TABLE REPLACE
        ElseIf tType = "TR:" Then
          If tableMigr.Count > 0 Then
              For tPos = 1 To tableMigr.Count
                  If Len(newMigr.TxtFrom) >= Len(tableMigr(tPos).TxtFrom) Then
                      Exit For
                  End If
              Next tPos
          End If
          If tPos = 0 Or tPos >= tableMigr.Count Then
              tableMigr.Add newMigr
          Else
              ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
              tableMigr.Add newMigr, , tPos
          End If
        End If
      Next item
    End If
  End If
  
  'oXLWBook.VBAProject.
  '("Start").Visible = xlVeryHidden
  
  ' Code Replace
  If codeMigr.Count > 0 Then
    If Not CheckVBAWritable(oXLWbook) Then
    Else
      For Each item In oXLWbook.VBProject.VBComponents
          With item
              Dim S As String
              Dim lcount As Long
              For lcount = 1 To item.CodeModule.CountOfLines
                  Dim fPos As Long
                  For Each migritem In codeMigr
                    fPos = InStr(item.CodeModule.Lines(lcount, 1), migritem.TxtFrom)
                    If fPos > 0 Then
                        If fPos - 1 > 0 Then
                            S = Left(item.CodeModule.Lines(lcount, 1), fPos - 1)
                        Else
                            S = ""
                        End If
                        S = S + migritem.TxtTo
                        S = S + Mid(item.CodeModule.Lines(lcount, 1), fPos + Len(migritem.TxtFrom))
                        item.CodeModule.replaceLine lcount, S
                    End If
                  Next migritem
              Next lcount
          End With
      Next item
    End If
  End If
  
  Set codeMigr = Nothing
  
  ' ------------------------------------------------------------
  ' Plausiabfragen START
  ' ------------------------------------------------------------
      
      ' ------------------------------------------------------------
      ' Arbeitsmappenfreigabe und Protect?
      ' ------------------------------------------------------------
      'If Len(wert.Freigabeschutzpasswort) > 0 And (UCase(wert.ButtonProtect) = "JA" Or UCase(wert.SimpleProtect) = "JA") Then
      If Len(wert.Freigabeschutzpasswort) > 0 And (IsYes(wert.ButtonProtect) Or IsYes(wert.SimpleProtect)) Then
        'infotxt = infotxt & "Hinweis (3): Bei [ButtonProtect] oder [Protect] ist die Nutzung des 'Freigabeschutzpassworts' nicht erlaubt! Das Passwort wird ignoriert; es wird keine Freigabe vorgenommen!" & vbCrLf
        infotxt = infotxt & FMT0("MDStart_39") & vbCrLf
        Warnings = Warnings + 1
        wert.Freigabeschutzpasswort = ""
      End If
      
      ' ------------------------------------------------------------
      ' Irgendwelche unsichtbaren Tabellen bei Protect oder ButtonProtect?
      ' ------------------------------------------------------------
      'If UCase(wert.ButtonProtect) = "JA" Or UCase(wert.SimpleProtect) = "JA" Then
      If IsYes(wert.ButtonProtect) Or IsYes(wert.SimpleProtect) Then
        For Each ws In oXLWbook.Worksheets
          If ws.Visible <> xlSheetVisible Then
            'infotxt = infotxt & "Fehler (37): Wenn Sie [ButtonProtect] oder [Protect] nutzen, darf es in Ihrer Datei keine asgebkendeten / versteckten Tabellen geben. Bitte entfernen Sie diese!" & vbCrLf
            infotxt = infotxt & FMT0("MDStart_40") & vbCrLf
            Errors = Errors + 1
          End If
        Next ws
      End If
      
      
      ' ------------------------------------------------------------
      ' Bei ButtonProtect und Protect darf es keine Tabelle mit Hinweis geben
      ' ------------------------------------------------------------
      'If UCase(wert.ButtonProtect) = "JA" Or UCase(wert.SimpleProtect) = "JA" Then
      If IsYes(wert.ButtonProtect) Or IsYes(wert.SimpleProtect) Then
        For Each ws In oXLWbook.Worksheets
          'If UCase(ws.name) = "HINWEIS" Then
          If CmpLocText(UCase(ws.name), "HINWEIS") Then
            'infotxt = infotxt & "Fehler (38) Wenn Sie [ButtonProtect] oder [Protect] nutzen darf es in Ihrer Datei keine Tabelle mit dem Namen 'Hinweis' geben. Bitte entfernen Sie diese Tabelle oder nennen Sie um!" & vbCrLf
            infotxt = infotxt & FMT0("MDStart_41") & vbCrLf
            Errors = Errors + 1
            Exit For
          End If
        Next ws
      End If
      
      ' ------------------------------------------------------------
      ' Wiederholungsbereich?
      ' Falls dieser genutzt werden soll, dann muss ButtonProtect oder Protect an sein!
      ' ------------------------------------------------------------
      'If UCase(wert.Wiederholungsbereich) = "JA" And UCase(wert.ButtonProtect) <> "JA" And UCase(wert.SimpleProtect) <> "JA" Then
      If IsYes(wert.Wiederholungsbereich) And Not IsYes(wert.ButtonProtect) And Not IsYes(wert.SimpleProtect) Then
        'infotxt = infotxt & "Fehler (39): Wenn [Wiederholungsbereich] genutzt wird, dann muss auch [ButtonProtect] oder [Protect] genutzt werden!" & vbCrLf
        infotxt = infotxt & FMT0("MDStart_42") & vbCrLf
        Errors = Errors + 1
      End If
      
      ' ------------------------------------------------------------
      ' Selektionsschutz?
      ' Falls dieser genutzt werden soll, dann muss ButtonProtect oder Protect an sein!
      ' ------------------------------------------------------------
      'If UCase(wert.Selektionsschutz) = "JA" And UCase(wert.ButtonProtect) <> "JA" And UCase(wert.SimpleProtect) <> "JA" Then
      If IsYes(wert.Selektionsschutz) And Not IsYes(wert.ButtonProtect) And Not IsYes(wert.SimpleProtect) Then
        'infotxt = infotxt & "Fehler (40): Wenn [Selektionsschutz] genutzt wird, dann muss auch [ButtonProtect] oder [Protect] genutzt werden!" & vbCrLf
        infotxt = infotxt & FMT0("MDStart_43") & vbCrLf
        Errors = Errors + 1
      End If
      
      ' ------------------------------------------------------------
      ' DruckenVorSchlie|fffd|en?
      ' Falls dieser genutzt werden soll, dann muss ButtonProtect oder Protect an sein!
      ' ------------------------------------------------------------
      'If UCase(wert.DruckenVorSchlie|fffd|en) = "JA" And UCase(wert.ButtonProtect) <> "JA" And UCase(wert.SimpleProtect) <> "JA" Then
      If IsYes(wert.DruckenVorSchlie|fffd|en) And Not IsYes(wert.ButtonProtect) And Not IsYes(wert.SimpleProtect) Then
        'infotxt = infotxt & "Fehler (54): Wenn [DruckenVorSchlie|fffd|en] genutzt wird, dann muss auch [ButtonProtect] oder [Protect] genutzt werden!" & vbCrLf
        infotxt = infotxt & FMT0("MDStart_44") & vbCrLf
        Errors = Errors + 1
      End If
      
      ' ------------------------------------------------------------
      ' Button Protect und Protect gleichzeitig genutzt?
      ' ------------------------------------------------------------
      'If UCase(wert.ButtonProtect) = "JA" And UCase(wert.SimpleProtect) = "JA" Then
      If IsYes(wert.ButtonProtect) And IsYes(wert.SimpleProtect) Then
        'infotxt = infotxt & "Fehler (41): Sie k|fffd|nnen nicht [ButtonProtect] und gleichzeitig [Protect] nutzen!" & vbCrLf
        infotxt = infotxt & FMT0("MDStart_45") & vbCrLf
        Errors = Errors + 1
      End If
      
      ' ------------------------------------------------------------
      ' SimpleProtect mit buttons genutzt?
      ' ------------------------------------------------------------
      'If UCase(wert.SimpleProtect) = "JA" And (UCase(wert.ButtonSpeichern) = "JA" Or UCase(wert.ButtonDrucken) = "JA") Then
      If IsYes(wert.SimpleProtect) And (IsYes(wert.ButtonSpeichern) Or IsYes(wert.ButtonDrucken)) Then
        'infotxt = infotxt & "Fehler (42): [Protect] kann nicht zusammen mit [ButtonSpeichern] oder [ButtonDrucken] genutzt werden!" & vbCrLf
        infotxt = infotxt & FMT0("MDStart_46") & vbCrLf
        Errors = Errors + 1
      End If
  
  ' ------------------------------------------------------------
  ' Plausiabfragen ENDE
  ' ------------------------------------------------------------
  If Errors > 0 Then
    oXLWbook.Close False
    Set oXLWbook = Nothing
    Exit Sub
  End If
  
  
  
  
  
  ' ------------------------------------------------------------
  ' Als erstes mal Code zu, sp|fffd|ter geht's nicht mehr
  ' ------------------------------------------------------------
  If Not FileExists(ThisWorkbook.path & "\VBAProt.exe") Then
    If Not CheckVBAWritable(oXLWbook) Then
      'infotxt = infotxt & "Hinweis (9): Der VBA-Code-Schutz honnte nicht angebracht werden, da kein Zugriff auf VBA besteht oder der VBA-Code der Datei bereits gesch|fffd|tzt ist." & vbCrLf
      infotxt = infotxt & FMT0("MDStart_47") & vbCrLf
      Warnings = Warnings + 1
    Else
      CodeProtect wert, oXLWbook
    End If
  End If
  
  ' ------------------------------------------------------------
  ' ButtonProtect?
  ' ------------------------------------------------------------
  'If UCase(wert.ButtonProtect) = "JA" Or UCase(wert.ButtonSpeichern) = "JA" Or UCase(wert.ButtonDrucken) = "JA" Then
  If IsYes(wert.ButtonProtect) Or IsYes(wert.ButtonSpeichern) Or IsYes(wert.ButtonDrucken) Then
    If Not ButtonProtect(oXLWbook, infotxt, wert.Inp) Then
      'infotxt = infotxt & "Fehler (8): 'ButtonProtect' konnte nicht auf die Datei ausgef|fffd|hrt werden!" & vbCrLf
      infotxt = infotxt & FMT0("MDStart_48") & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
  End If
  
  ' ------------------------------------------------------------
  ' SimpleProtect?
  ' ------------------------------------------------------------
  'If UCase(wert.SimpleProtect) = "JA" Then
  If IsYes(wert.SimpleProtect) Then
    If Not SimpleProtect(oXLWbook, infotxt, wert.Inp) Then
      'infotxt = infotxt & "Fehler (43): 'SimpleProtect' konnte nicht auf die Datei ausgef|fffd|hrt werden!" & vbCrLf
      infotxt = infotxt & FMT0("MDStart_49") & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
  End If
  
  ' ------------------------------------------------------------
  ' ButtonSpeichern?
  ' ------------------------------------------------------------
  'If UCase(wert.ButtonSpeichern) = "JA" Then
  If IsYes(wert.ButtonSpeichern) Then
    If Not CodeSet(oXLWbook, "'#BUTTON Speichern#", "'#BUTTON#", infotxt, wert.Inp) Then
      'infotxt = infotxt & "Fehler (9): 'ButtonSpeichern' konnte nicht auf die Datei ausgef|fffd|hrt werden!" & vbCrLf
      infotxt = infotxt & FMT0("MDStart_50") & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
  End If
  
  ' ------------------------------------------------------------
  ' ButtonDrucken?
  ' ------------------------------------------------------------
  'If UCase(wert.ButtonDrucken) = "JA" Then
  If IsYes(wert.ButtonDrucken) Then
    If Not CodeSet(oXLWbook, "'#BUTTON Drucken#", "'#BUTTON#", infotxt, wert.Inp) Then
      'infotxt = infotxt & "Fehler (10): 'ButtonDrucken' konnte nicht auf die Datei ausgef|fffd|hrt werden!" & vbCrLf
      infotxt = infotxt & FMT0("MDStart_51") & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
  End If
  
  
  ' ------------------------------------------------------------
  ' Selektionsschutz? (Auf globaler Ebene!)
  ' ------------------------------------------------------------
  'If UCase(wert.Selektionsschutz) = "JA" Then
  If IsYes(wert.Selektionsschutz) Then
    If Not CodeSet(oXLWbook, "'#DISABLE SELECT#", "'#CELL_SELECTION#", infotxt, wert.Inp) Then
      'infotxt = infotxt & "Fehler (44): 'Selektionsschutz' konnte nicht auf die Datei ausgef|fffd|hrt werden!" & vbCrLf
      infotxt = infotxt & FMT0("MDStart_52") & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
'    If ws.Name <> "Hinweis" Or (UCase(wert.ButtonProtect) <> "JA" And UCase(wert.SimpleProtect) <> "JA") Then
'      AddAllWorksheetsEnableSelection oXLWBook, infotxt, wert.Inp
'    End If
  End If
  
  
  ' ------------------------------------------------------------
  ' DruckenVorSpeichern?
  ' ------------------------------------------------------------
  'If UCase(wert.DruckenVorSchlie|fffd|en) = "JA" Then
  If IsYes(wert.DruckenVorSchlie|fffd|en) Then
    If Not CodeSet(oXLWbook, "'#PRINT_BEFORE_SAVE#", "'#INSERT_PRINT_BEFORE_SAVE#", infotxt, wert.Inp) Then
      'infotxt = infotxt & "Fehler (56): 'DruckenVorSchlie|fffd|en' konnte nicht auf die Datei ausgef|fffd|hrt werden!" & vbCrLf
      infotxt = infotxt & FMT0("MDStart_53") & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
  End If
  
  ' --------------------------------------------------------
  ' Ersteller Pfad Datum rein?
  ' --------------------------------------------------------
  'If UCase(wert.ErstellerPfadDatum) = "JA" Then
  If IsYes(wert.ErstellerPfadDatum) Then
    ErstellerPfadDatumErzeugen oXLWbook, infotxt, wert.Inp
  End If
  
  oXLWbook.Activate
 
  ' ---------------------------------------------------------------
 
  
  Dim fileName As String
  Dim lesepw As String
  Dim arbeitsmappenpw As String
  Dim schreibpw As String
  Dim sharingpw As String
  Dim Blattschutzpasswort As String
  
  fileName = wert.Outp
  
  ' Lesepasswort
  lesepw = Left(wert.Lesepasswort, 15)
  
  Dim sc As Long
  Dim pwchr As Long
  
  If Len(lesepw) > 0 Then
    lesepw = CheckPassword(lesepw, 15)
  End If
  
'  lesepw = "a"
  
  ' ------------------------------------------------------------
  ' ExeFileLoad?
  ' ------------------------------------------------------------
  'If UCase(wert.ExeFileLoad) = "JA" Then
  If IsYes(wert.ExeFileLoad) Then
    If Len(GetFileNameAndExtension(fileName)) < MAX_FILENAMELEN Then
      If Not SaveExe(fileName, lesepw) Then
        oXLWbook.Close False
        Set oXLWbook = Nothing
        Exit Sub
      End If
    Else
      'infotxt = infotxt & "Fehler (45): [ExeFileLoad] kann nicht genutzt werden, da der Dateiname '" & GetFileNameAndExtension(Filename) & "' die erlaubte L|fffd|nge von " & MAX_FILENAMELEN & " |fffd|berschreitet!" & vbCrLf
      infotxt = infotxt & FMT2("MDStart_54", GetFileNameAndExtension(fileName), MAX_FILENAMELEN) & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
  End If
  
  
  ' Schreibpasswort
  schreibpw = wert.Schreibpasswort
  
  ' Sharingpasswort
  sharingpw = wert.Freigabeschutzpasswort
  
  ' Arbeitsmappenpasswort
  arbeitsmappenpw = wert.Arbeitsmappenschutzpasswort
  
  ' Blattschutzpasswort
  Blattschutzpasswort = wert.Blattschutzpasswort
  
  Dim FormenSch|fffd|tzen As Boolean
  Dim InhalteSch|fffd|tzen As Boolean
  Dim SzenariosSch|fffd|tzen As Boolean
'  Dim SelektionsschutzF|fffd|rZellen As Long
  
  ' Formulare
  FormenSch|fffd|tzen = False
  'If UCase(wert.ObjekteSch|fffd|tzen) = "JA" Then
  If IsYes(wert.ObjekteSch|fffd|tzen) Then
      FormenSch|fffd|tzen = True
  End If
  
  ' Inhalte
  InhalteSch|fffd|tzen = False
  'If UCase(wert.InhalteSch|fffd|tzen) = "JA" Then
  If IsYes(wert.InhalteSch|fffd|tzen) Then
      InhalteSch|fffd|tzen = True
  End If
  
  ' Szenarios
  SzenariosSch|fffd|tzen = False
  'If UCase(wert.SzenariosSch|fffd|tzen) = "JA" Then
  If IsYes(wert.SzenariosSch|fffd|tzen) Then
      SzenariosSch|fffd|tzen = True
  End If
  
  ' Jetzt holen wir uns mal die Pfade und setzen diese in eine Collection, und zwar der L|fffd|nge nach!
  
  
  
  
'    ActiveSheet.Pictures.Insert("D:\NormanNeubert.jpg").Select
'    Selection.ShapeRange.IncrementLeft -139.5
'    Selection.ShapeRange.IncrementTop -84#
'    With Selection
'        .Placement = xlMove
'        .PrintObject = True
'    End With
  
  
  
  ' ------------------------------------------------------------
  ' Globaler Zellersatz
  ' ------------------------------------------------------------
  If hasGlobals Then
    y = 0
    Do While Not IsEmpty(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 1)) Or Not IsEmpty(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y + 1, 1))
      If Not IsEmpty(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 1)) Then
        If Left(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 1), 1) <> "#" Then
          Set newMigr = New TextMigr
          If Left(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 1), 1) <> Chr(34) Then
              'infotxt = infotxt & "Fehler (3): Sie haben in Zeile " & StartGlobalsY + y & ", Spalte A der globalen Suchen-Und-Ersetzen-Tabelle 'Globals' kein f|fffd|hrendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
              infotxt = infotxt & FMT1("MDStart_55", StartGlobalsY + y) & vbCrLf
              Errors = Errors + 1
              oXLWbook.Close False
              Set oXLWbook = Nothing
              Exit Sub
          End If
          If Right(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 1), 1) <> Chr(34) Then
              'infotxt = infotxt & "Fehler (4): Sie haben in Zeile " & StartGlobalsY + y & ", Spalte A der globalen Suchen-Und-Ersetzen-Tabelle 'Globals' kein endendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
              infotxt = infotxt & FMT1("MDStart_56", StartGlobalsY + y) & vbCrLf
              Errors = Errors + 1
              oXLWbook.Close False
              Set oXLWbook = Nothing
              Exit Sub
          End If
          If Left(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 2), 1) <> Chr(34) Then
              'infotxt = infotxt & "Fehler (5): Sie haben in Zeile " & StartGlobalsY + y & ", Spalte B der globalen Suchen-Und-Ersetzen-Tabelle 'Globals' kein f|fffd|hrendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
              infotxt = infotxt & FMT1("MDStart_57", StartGlobalsY + y) & vbCrLf
              Errors = Errors + 1
              oXLWbook.Close False
              Set oXLWbook = Nothing
              Exit Sub
          End If
          If Right(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 2), 1) <> Chr(34) Then
              'infotxt = infotxt & "Fehler (6): Sie haben in Zeile " & StartGlobalsY + y & ", Spalte B der globalen Suchen-Und-Ersetzen-Tabelle 'Globals' kein endendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
              infotxt = infotxt & FMT1("MDStart_58", StartGlobalsY + y) & vbCrLf
              Errors = Errors + 1
              oXLWbook.Close False
              Set oXLWbook = Nothing
              Exit Sub
          End If
          newMigr.TxtFrom = Mid(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 1), 2, Len(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 1)) - 2)
          If Len(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 2)) - 2 > 0 Then
            newMigr.TxtTo = Mid(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 2), 2, Len(oXLWSheet.Parent.Sheets("Globals").Cells(StartGlobalsY + y, 2)) - 2)
          Else
            newMigr.TxtTo = ""
          End If
          If tableMigr.Count > 0 Then
              For tPos = 1 To tableMigr.Count
                  If Len(newMigr.TxtFrom) > Len(tableMigr(tPos).TxtFrom) Then
                      Exit For
                  End If
              Next tPos
          End If
          If tPos = 0 Or tPos >= tableMigr.Count Then
              tableMigr.Add newMigr
          Else
              ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
              tableMigr.Add newMigr, , tPos
          End If
        End If
      End If
      y = y + 1
    Loop
  End If
    
  
'  oldCalc = oXLWbook.Application.Calculation
  oXLWbook.Application.Calculation = xlCalculationManual
  
  Err.Clear
  Dim cellsNotLockable As Long
  cellsNotLockable = 0
  
  ' Und dann alles einschalten
  For Each ws In oXLWbook.Worksheets
  
    If WorksheetProtected(ws) = True Then
      infotxt = infotxt & FMT1("MDStart_96", ws.name) & vbCrLf
      Warnings = Warnings + 1
    Else
          
          
            ' Wenn es die Hinweistabelle ist und ein Protect Schutz da war, dann braucht die Tabelle nicht
            ' weiter gesch|fffd|tzt zu werden. Ansonsten handelt es sich um eine Tabelle des Programms, die
            ' ggf. zu sch|fffd|tzen ist.
          
            'If ws.name <> "Hinweis" Or (UCase(wert.ButtonProtect) <> "JA" And UCase(wert.SimpleProtect) <> "JA") Then
            'If (ws.name <> "Hinweis" And ws.name <> "Note") Or (Not IsYes(wert.ButtonProtect) And Not IsYes(wert.SimpleProtect)) Then
            If (Not CmpLocText(ws.name, "Hinweis")) Or (Not IsYes(wert.ButtonProtect) And Not IsYes(wert.SimpleProtect)) Then
        
                Dim fname As String
                Dim newpic As Object
                Dim c
        
                ' ------------------------------------------------------------
                ' Normale Zellen "entsch|fffd|tzen"
                ' ------------------------------------------------------------
                If unlockNonFormulaCells Then
                    UnlockCells ws, infotxt
        '            For Each c In ws.UsedRange
        '                If Not c.HasFormula Then
        '                  UnlockCell c, infotxt
        '                End If
        '            Next c
                End If
                
        
                found = False
                Dim tabItem As TabSchutz
                For Each tabItem In tabs
                    If ws.name = tabItem.name Then
                        found = True
                        Exit For
                    End If
                Next tabItem
        
                ' ------------------------------------------------------------
                ' Wiederholungsbereich?
                ' ------------------------------------------------------------
                If Not found Then
                  'If UCase(wert.Wiederholungsbereich) = "JA" Then
                  If IsYes(wert.Wiederholungsbereich) Then
                    AddWiederholungsbereich oXLWbook, ws, wert, infotxt, wert.Inp, wert.Outp
                  End If
                End If
              
                Err.Clear
        
        
        
        '        ws.EnableSelection = SelektionsschutzF|fffd|rZellen
                
                ' ------------------------------------------------------------
                ' Wasserzeichen einbinden?
                ' ------------------------------------------------------------
                For Each c In ws.UsedRange
                  If Left(CStr(c.value), Len(TXT_WASSERZEICHEN)) = TXT_WASSERZEICHEN Then
                    fname = Mid(c.value, Len(TXT_WASSERZEICHEN))
                    If FileExists(Trim(fname)) Then
                      Application.ScreenUpdating = False
                      Set newpic = ws.Pictures.Insert(Trim(fname))
                      With newpic
                           .Top = c.Top + 1
                           .Left = c.Left + 1
                           .Placement = xlMove
                      End With
                      c.value = "WZ"
                      Application.ScreenUpdating = True
                      If c.MergeCells = True Then
                        'additionalErrorInfo = "c.MergeArea.Locked = true (Sperrung) nicht m|fffd|glich in Tabelle '" & c.Parent.name & "', Zelle " & c.Address
                        additionalErrorInfo = FMT2("MDStart_59", c.Parent.name, c.Address)
                        c.MergeArea.Locked = True
                        additionalErrorInfo = ""
                      Else
                        'additionalErrorInfo = "c.Locked = true (Sperrung) nicht m|fffd|glich in Tabelle '" & c.Parent.name & "', Zelle " & c.Address
                        additionalErrorInfo = FMT2("MDStart_60", c.Parent.name, c.Address)
                        c.Locked = True
                        additionalErrorInfo = ""
                      End If
                    Else
                      'infotxt = infotxt & "Fehler (46): Das Wasserzeichen '" & Trim(fname) & "' wurde nicht gefunden!" & vbCrLf
                      infotxt = infotxt & FMT1("MDStart_61", Trim(fname)) & vbCrLf
                      Errors = Errors + 1
                      fehlendeWasserzeichen = fehlendeWasserzeichen + 1
                    End If
                  End If
                  
                  additionalErrorInfo = "Error im Wasserzeichen in Tablle '" & c.Parent.name & "', Zelle " & c.Address
                  If Left(CStr(c.value), Len(TXT_WASSERZEICHENZG)) = TXT_WASSERZEICHENZG Then
                    fname = Mid(c.value, Len(TXT_WASSERZEICHENZG))
                    If FileExists(Trim(fname)) Then
                      Application.ScreenUpdating = False
                      Set newpic = ws.Pictures.Insert(Trim(fname))
                      With newpic
                           .Top = c.Top + 1
                           .Left = c.Left + 1
                           .Width = c.Width - 1
                           .Height = c.Height - 1
                           .Placement = xlMoveAndSize
                      End With
                      c.value = "WZ"
                      Application.ScreenUpdating = True
                      If c.MergeCells = True Then
                        'additionalErrorInfo = "c.MergeArea.Locked = true (Sperrung) nicht m|fffd|glich in Tabelle '" & c.Parent.name & "', Zelle " & c.Address
                        additionalErrorInfo = FMT2("MDStart_59", c.Parent.name, c.Address)
                        c.MergeArea.Locked = True
                        additionalErrorInfo = ""
                      Else
                        'additionalErrorInfo = "c.Locked = true (Sperrung) nicht m|fffd|glich in Tabelle '" & c.Parent.name & "', Zelle " & c.Address
                        additionalErrorInfo = FMT2("MDStart_60", c.Parent.name, c.Address)
                        c.Locked = True
                        additionalErrorInfo = ""
                      End If
                    Else
                      'infotxt = infotxt & "Fehler (47): Das Wasserzeichen '" & Trim(fname) & "' wurde nicht gefunden!" & vbCrLf
                      infotxt = infotxt & FMT1("MDStart_61", Trim(fname)) & vbCrLf
                      Errors = Errors + 1
                      fehlendeWasserzeichen = fehlendeWasserzeichen + 1
                    End If
                  End If
                  additionalErrorInfo = ""
                Next c
                        
                ' ------------------------------------------------------------
                ' Formelabsicherung
                ' ------------------------------------------------------------
        '        Err.Clear
                Dim formulaAmount As Long
                formulaAmount = 0
                If lockCells Then
                      For Each c In ws.UsedRange
                          If c.HasFormula Then
                              formulaAmount = formulaAmount + 1
                              If Not c.Locked Then
                                  If c.MergeCells = True Then
                                    'additionalErrorInfo = "c.MergeArea.Locked = true (Sperrung) nicht m|fffd|glich in Tabelle '" & c.Parent.name & "', Zelle " & c.Address
                                    additionalErrorInfo = FMT2("MDStart_59", c.Parent.name, c.Address)
                                    If Not FormulaAnalyzable(c) Then
                                      c.MergeArea.Locked = True
                                    ElseIf Not IsSimpleFormula(c.Formula) Then
                                      c.MergeArea.Locked = True
                                    End If
                                    additionalErrorInfo = ""
                                  Else
                                    'additionalErrorInfo = "c.Locked = true (Sperrung) nicht m|fffd|glich in Tabelle '" & c.Parent.name & "', Zelle " & c.Address
                                    additionalErrorInfo = FMT2("MDStart_60", c.Parent.name, c.Address)
                                    If Not FormulaAnalyzable(c) Then
                                      c.Locked = True
                                    ElseIf Not IsSimpleFormula(c.Formula) Then
                                      c.Locked = True
                                    End If
                                    additionalErrorInfo = ""
                                  End If
                                  If Err.Number > 0 Then
                                    'infotxt = infotxt & "Fehler (48): Die Zelle " & c.Address & " der Tabelle '" & c.Worksheet.name & "' konnte nicht gesch|fffd|tzt werden! Wahrscheinlich enth|fffd|lt die Tabelle einen Blattschutz oder |fffd|hnliches!" & vbCrLf & "Excel Fehlertext: " & vbCrLf & Err.Description & vbCrLf
                                    infotxt = infotxt & FMT3("MDStart_62", c.Address, c.Worksheet.name, Err.Description) & vbCrLf
                                    Errors = Errors + 1
                                    oXLWbook.Close False
                                    Exit Sub
          '                          cellsNotLockable = cellsNotLockable + 1
          '                          Err.Clear
                                  End If
                                  lockedCells = lockedCells + 1
                              End If
                          End If
                      Next c
                End If
        
                ' Dann gehen wir mal durch alle Zellen durch und ersetzen die Texte!
                If tableMigr.Count > 0 Then
                    Dim txtPos As Long
                    For Each c In ws.UsedRange
                    
                    
                        ' ------------------------------------------------------------
                        ' F|fffd|r alle Suchen und Ersetzen Texte
                        ' ------------------------------------------------------------
                        For Each migritem In tableMigr
                            txtPos = 1
                            While txtPos > 0
                                If c.HasFormula Then
                                    txtPos = InStr(txtPos, c.Formula, migritem.TxtFrom)
                                    If txtPos > 0 Then
                                        If txtPos - 1 > 0 Then
                                            tStr = Left(c.Formula, txtPos - 1)
                                        Else
                                            tStr = ""
                                        End If
                                        tStr = tStr + migritem.TxtTo
                                        tStr = tStr + Mid(c.Formula, txtPos + Len(migritem.TxtFrom))
                                        c.Formula = tStr
                                        txtPos = 1
                                    End If
                                Else
                                    txtPos = InStr(txtPos, c.value, migritem.TxtFrom)
                                    If txtPos > 0 Then
                                        If txtPos - 1 > 0 Then
                                          tStr = Left(CStr(c.value), txtPos - 1)
                                        Else
                                          tStr = ""
                                        End If
                                        tStr = tStr + migritem.TxtTo
                                        tStr = tStr + Mid(c.value, txtPos + Len(migritem.TxtFrom))
                                        c.value = tStr
                                        txtPos = 1
                                    End If
                                End If
                            Wend
                        Next migritem
                        For Each migritem In tableMigr
                            txtPos = 1
                            While txtPos > 0
                                If c.HasFormula Then
                                    txtPos = InStr(txtPos, c.Formula, migritem.TxtFrom)
                                    If txtPos > 0 Then
                                        If txtPos > 1 Then
                                            tStr = Left(c.Formula, txtPos - 1)
                                        Else
                                            tStr = ""
                                        End If
                                        tStr = tStr + migritem.TxtTo
                                        tStr = tStr + Mid(c.Formula, txtPos + Len(migritem.TxtFrom))
                                        c.Formula = tStr
                                        txtPos = 1
                                    End If
                                Else
                                    txtPos = InStr(txtPos, c.value, migritem.TxtFrom)
                                    If txtPos > 0 Then
                                        If txtPos > 1 Then
                                          tStr = Left(CStr(c.value), txtPos - 1)
                                        Else
                                          tStr = ""
                                        End If
                                        tStr = tStr + migritem.TxtTo
                                        tStr = tStr + Mid(c.value, txtPos + Len(migritem.TxtFrom))
                                        c.value = tStr
                                        txtPos = 1
                                    End If
                                End If
                            Wend
                        Next migritem
                    Next c
                End If
        
        
                ' Wenn wir wissen, dass es ein TabItem gibt...
                If found Then
                  For Each tabItem In tabs
                    If ws.name = tabItem.name Then
                        
                        Dim tFormenSch|fffd|tzen As Boolean
                        Dim tInhalteSch|fffd|tzen As Boolean
                        Dim tSzenariosSch|fffd|tzen As Boolean
                                        
                        ' Formulare
                        tFormenSch|fffd|tzen = False
                        'If UCase(tabItem.ObjekteSch|fffd|tzen) = "JA" Then
                        If IsYes(tabItem.ObjekteSch|fffd|tzen) Then
                            tFormenSch|fffd|tzen = True
                        End If
                        
                        ' Inhalte
                        tInhalteSch|fffd|tzen = False
                        'If UCase(tabItem.InhalteSch|fffd|tzen) = "JA" Then
                        If IsYes(tabItem.InhalteSch|fffd|tzen) Then
                            tInhalteSch|fffd|tzen = True
                        End If
                        
                        ' Szenarios
                        tSzenariosSch|fffd|tzen = False
                        If IsYes(tabItem.SzenariosSch|fffd|tzen) Then
                            tSzenariosSch|fffd|tzen = True
                        End If
                        
                        
                        ' ------------ SELEKTIONSSCHUTZ ------------------------------
                        'If UCase(tabItem.Selektionsschutz) = "JA" Or UCase(tabItem.Wasserzeichen) = "JA" Or UCase(wert.Wasserzeichen) = "JA" Then
                        If IsYes(tabItem.Selektionsschutz) Or IsYes(tabItem.Wasserzeichen) Or IsYes(wert.Wasserzeichen) Then
        '                  If Not CodeSet(oXLWBook, "'#DISABLE SELECT#", "'#CELL_SELECTION#", infotxt, wert.Inp) Then
        '                    infotxt = infotxt & "Fehler (): 'Selektionsschutz' konnte nicht auf die Datei ausgef|fffd|hrt werden!" & vbCrLf
        '                    oXLWBook.Close False
        '                    Set oXLWBook = Nothing
        '                    Exit Sub
        '                  End If
                          'If ws.name <> "Hinweis" Or (UCase(wert.ButtonProtect) <> "JA" And UCase(wert.SimpleProtect) <> "JA") Then
                          If (Not CmpLocText(ws.name, "Hinweis")) Or (Not IsYes(wert.ButtonProtect) And Not IsYes(wert.SimpleProtect)) Then
                            ' Nur wenn nicht schon f|fffd|r alle Tabellen ein Selektionsschutz gesetzt wurde!
                            'If UCase(wert.Selektionsschutz) <> "JA" Then
                            If Not IsYes(wert.Selektionsschutz) Then
                              AddWorksheetEnableSelection ws, oXLWbook, infotxt, wert.Inp
                            End If
                          End If
                        End If
                        
                        ' ------------ WIEDERHOLUNGSBEREICH ------------------------------
                        'If UCase(tabItem.Wiederholungsbereich) = "JA" Then
                        If IsYes(tabItem.Wiederholungsbereich) Then
                          AddWiederholungsbereich oXLWbook, ws, tabItem, infotxt, wert.Inp, wert.Outp
                        End If
                        
                        ' ------------ BLATTSCHUTZ ------------------------------
                        If Len(tabItem.Passwort) > 0 Then
                              If tabItem.Passwort = "*" Then
                                Err.Clear
                                ws.Protect , _
                                    DrawingObjects:=tFormenSch|fffd|tzen, _
                                    Contents:=tInhalteSch|fffd|tzen, _
                                    Scenarios:=tSzenariosSch|fffd|tzen
                                If Err.Number > 0 Then
                                  'infotxt = infotxt & "Fehler (49): Die Tabelle '" & ws.name & "' konnte nicht gesch|fffd|tzt werden! Wahrscheinlich ist sie bereits gesch|fffd|tzt. Excel Fehlertext: " & vbCrLf & Err.Description & vbCrLf
                                  infotxt = infotxt & FMT2("MDStart_63", ws.name, Err.Description) & vbCrLf
                                  Errors = Errors + 1
                                  oXLWbook.Close False
                                  Set oXLWbook = Nothing
                                  Exit Sub
                                End If
                              Else
                                Err.Clear
                                ws.Protect CheckPassword(tabItem.Passwort, 15), _
                                    DrawingObjects:=tFormenSch|fffd|tzen, _
                                    Contents:=tInhalteSch|fffd|tzen, _
                                    Scenarios:=tSzenariosSch|fffd|tzen
                                If Err.Number > 0 Then
                                  'infotxt = infotxt & "Fehler (50): Die Tabelle '" & ws.name & "' konnte nicht gesch|fffd|tzt werden! Wahrscheinlich ist sie bereits gesch|fffd|tzt. Excel Fehlertext: " & vbCrLf & Err.Description & vbCrLf
                                  infotxt = infotxt & FMT2("MDStart_64", ws.name, Err.Description) & vbCrLf
                                  Errors = Errors + 1
                                  oXLWbook.Close False
                                  Set oXLWbook = Nothing
                                  Exit Sub
                                End If
                              End If
                        End If
                        
                        Exit For
                    End If
                  Next tabItem
                End If
                
                
                
                ' ------------------------------------------------------------
                ' Wenn es keine individuellen Parameter gibt....
                ' ------------------------------------------------------------
                If Not found Then
                  ' ------------------------------------------------------------
                  ' Selektionsschutz?
                  ' ------------------------------------------------------------
                  If IsYes(wert.Selektionsschutz) Then
                    'If ws.name <> "Hinweis" Or (UCase(wert.ButtonProtect) <> "JA" And UCase(wert.SimpleProtect) <> "JA") Then
                    If (Not CmpLocText(ws.name, "Hinweis")) Or (Not IsYes(wert.ButtonProtect) And Not IsYes(wert.SimpleProtect)) Then
                      AddWorksheetEnableSelection ws, oXLWbook, infotxt, wert.Inp
                    End If
                  End If
                  ' ------------------------------------------------------------
                  ' Blattschutz
                  ' ------------------------------------------------------------
                  If Len(Blattschutzpasswort) > 0 Then
                      Err.Clear
                      
              If lockCells = False Or (lockCells = True And formulaAmount > 0) Or G_cfgAlleTabellenblaetterSchuetzen = True Then
                        If Left(Application.Version, 4) < "11.0" Then
                          ws.Protect Blattschutzpasswort, _
                              DrawingObjects:=FormenSch|fffd|tzen, _
                              Contents:=InhalteSch|fffd|tzen, _
                              Scenarios:=SzenariosSch|fffd|tzen
                        Else
                          ProtWSVersion11 ws, Blattschutzpasswort, wert
                        End If
                      End If
                        
                  End If
                  If Err.Number > 0 Then
                    'infotxt = infotxt & "Fehler (51): Die Tabelle '" & ws.name & "' konnte nicht gesch|fffd|tzt werden! Wahrscheinlich ist sie bereits gesch|fffd|tzt. Excel Fehlertext: " & vbCrLf & Err.Description & vbCrLf
                    infotxt = infotxt & FMT2("MDStart_65", ws.name, Err.Description) & vbCrLf
                    Errors = Errors + 1
                    oXLWbook.Close False
                    Set oXLWbook = Nothing
                    Exit Sub
                  End If
                End If
            End If
    End If
  Next ws
  
  
  oXLWbook.Activate
  
  ' -------------------------------------------------------------------------------
'  oXLWbook.Application.Calculation = oldCalc
  
  ' Und Migrationstexte freigeben
  Set tableMigr = Nothing
  Set tabs = Nothing
  ' -------------------------------------------------------------------------------
  ' Noch die Sachen f|fffd|r die gesharte Datei
  ' ------------------------------------------------------------
  Dim PositionDerTabellenbl|fffd|tterSch|fffd|tzen As Boolean
  Dim FensterSch|fffd|tzen As Boolean
  
  'PositionDerTabellenbl|fffd|tterSch|fffd|tzen
  PositionDerTabellenbl|fffd|tterSch|fffd|tzen = False
  'If UCase(wert.AufbauSch|fffd|tzen) = "JA" Then
  If IsYes(wert.AufbauSch|fffd|tzen) Then
      PositionDerTabellenbl|fffd|tterSch|fffd|tzen = True
  End If

  ' ------------------------------------------------------------
  'Fenster sch|fffd|tzen
  ' ------------------------------------------------------------
  FensterSch|fffd|tzen = False
  'If UCase(wert.FensterSch|fffd|tzen) = "JA" Then
  If IsYes(wert.FensterSch|fffd|tzen) Then
      FensterSch|fffd|tzen = True
  End If
  
  'If Len(sharingpw) = 0 And Len(arbeitsmappenpw) > 0 And UCase(wert.SimpleProtect) <> "JA" Then
  If Len(sharingpw) = 0 And Len(arbeitsmappenpw) > 0 And IsYes(wert.SimpleProtect) = False Then
    Err.Clear
    oXLWbook.Protect arbeitsmappenpw, PositionDerTabellenbl|fffd|tterSch|fffd|tzen, FensterSch|fffd|tzen
    If Err.Number > 0 Then
      'infotxt = infotxt & "Fehler (52): Die Arbeitsmappe konnte nicht gesch|fffd|tzt werden! Wahrscheinlich ist sie bereits gesch|fffd|tzt. Excel Fehlertext: " & vbCrLf & Err.Description & vbCrLf
      infotxt = infotxt & FMT1("MDStart_66", Err.Description) & vbCrLf
      Errors = Errors + 1
      oXLWbook.Close False
      Set oXLWbook = Nothing
      Exit Sub
    End If
  End If
  
  If cellsNotLockable > 0 Then
    'infotxt = infotxt & "Fehler (53): Die Formel-Zellen der Ausgabedatei sollten gesch|fffd|tzt werden. Dies war bei " & cellsNotLockable & " Zelle(n) nicht m|fffd|glich! Wahrscheinlich sind eine oder mehrere Tabellen gesch|fffd|tzt oder die Arbeitsmappe wurde freigegeben. Beides ist nicht zul|fffd|ssig! Bitte entfernen Sie den Schutz / die Freigabe und versuchen es erneut!" & vbCrLf
    infotxt = infotxt & FMT1("MDStart_67", cellsNotLockable) & vbCrLf
    Errors = Errors + 1
    oXLWbook.Close False
    Set oXLWbook = Nothing
    Exit Sub
  End If
  
'  If fehlendeWasserzeichen > 0 Then
'    infotxt = infotxt & "Fehler (): " & fehlendeWasserzeichen & " Wasserzeichen wurden nicht gefunden! Bitte pr|fffd|fen Sie, ob die Dateien an der gew|fffd|nschten Stelle liegen!" & vbCrLf
'    Errors = Errors + 1
'  End If
  
  If Errors > 0 Then
    oXLWbook.Close False
    Set oXLWbook = Nothing
    Exit Sub
  End If
  
  ' ------------------------------------------------------------
  ' Pfad anlegen
  ' ------------------------------------------------------------
  If Not Mk_Dir(GetFilePath(wert.Outp)) Then
    'infotxt = infotxt & "Fehler (1): ['" & wert.Inp & "']: Absicherung abgebrochen, da das Verzeichnis nicht angelegt werden konnte!" & vbCrLf
    infotxt = infotxt & FMT1("MDStart_68", wert.Inp) & vbCrLf
    Errors = Errors + 1
    oXLWbook.Close False
    Set oXLWbook = Nothing
    Exit Sub
  End If
  ' ------------------------------------------------------------
  ' Als Addin speichern?
  ' ------------------------------------------------------------
  If UCase(Right(wert.Outp, 3)) = "XLA" Then
      oXLWbook.IsAddin = True
  End If
  
  If Len(sharingpw) > 0 And oXLWbook.IsAddin = False Then
    If StartedByCfg Then
      If FileExists(fileName) Then
        Kill fileName
      End If
      oXLWbook.ProtectSharing fileName, lesepw, schreibpw, , , sharingpw
    Else
      If FileExists(fileName) Then
        'If MsgBox("Es existiert bereits eine Datei mit dem Dateinamen '" & Filename & "'. Soll die Datei |fffd|berschrieben werden?", vbYesNo) = vbYes Then
        If MsgBox(FMT1("MDStart_69", fileName), vbYesNo) = vbYes Then
          Kill fileName
          oXLWbook.ProtectSharing fileName, lesepw, schreibpw, , , sharingpw
        End If
      Else
      ' Und Schutz rein!
        oXLWbook.ProtectSharing fileName, lesepw, schreibpw, , , sharingpw
      End If
    End If
    If Not oXLWbook.Saved Then
      UserAbort = True
    End If
  Else
    If StartedByCfg And FileExists(fileName) Then Kill fileName
    
    Application.EnableEvents = False
'    oXLWbook.Application.Calculation = oldCalc
    oXLWbook.Application.Calculation = xlCalculationAutomatic
    
    On Error Resume Next
'    If oXLWbook.IsAddin = True Then
'        oXLWbook.SaveAs Filename, , lesepw, schreibpw
'    Else
'        oXLWbook.SaveAs Filename, , lesepw, schreibpw
'    End If
    
    oXLWbook.SaveAs fileName, , lesepw, schreibpw, , , , , , , , True
    
    If Not oXLWbook.Saved Then
      UserAbort = True
    Else
      Dim trackerID As Long
      trackerID = WBGetValueLong(oXLWbook, "_IDVTrackerID")
      If trackerID > 0 Then
        Application.EnableEvents = True
        Application.DisplayAlerts = False
        SaveSetting _
               appname:="Stromwerken", _
               Section:="ExcelTracker", _
               Key:="EPSaveAs", _
               Setting:="True"
        oXLWbook.SaveAs fileName, , lesepw, schreibpw, , , , , , , , True
        Application.EnableEvents = False
        
        If trackerID <> WBGetValueLong(oXLWbook, "_IDVTrackerID") Then
          oXLWbook.SaveAs fileName, , lesepw, schreibpw, , , , , , , , True
          Dim conn As Object
          Set conn = GetConnection()
          If conn Is Nothing Then Exit Sub
          If lesepw <> "" Then
            StorePasswordFuerDatei 1, conn, WBGetValueLong(oXLWbook, "_IDVTrackerID"), lesepw
          End If
          conn.Close
          Set conn = Nothing
        End If
        Application.DisplayAlerts = True
        

        
      End If
    End If
    
    Application.EnableEvents = True
'    Application.Calculation = xlCalculationAutomatic
  
  End If
  
  Application.EnableEvents = False
  oXLWbook.Close False
  Application.EnableEvents = True
  Set oXLWbook = Nothing
  DoEvents
    
' xlVeryHidden

  Set migritem = Nothing
  Set item = Nothing
  
  If Not UserAbort Then
    Dim tpw As String
    tpw = GetCodePassword(wert)
    If tpw <> "" Then
      If FileExists(ThisWorkbook.path & "\VBAProt.exe") Then
        Shell ThisWorkbook.path & "\VBAProt.exe" & " " & Chr(34) & fileName & Chr(34) & " " & tpw
      End If
    End If
  End If
  
  Set wert = Nothing
  Exit Sub
  
myErrorHandler:

  Dim errNr As Long
  Dim errStr As String
  
  errNr = Err.Number
  errStr = Err.Description

  'infotxt = infotxt & "Fehler (55): **** Schwer wiegender Fehler beim Schutz der Datei! ****" & vbCrLf
  infotxt = infotxt & FMT0("MDStart_70") & vbCrLf
  FatalErrors = FatalErrors + 1
  If Len(additionalErrorInfo) > 0 Then
    'infotxt = infotxt & "Zusatzinfo: " & additionalErrorInfo & vbCrLf
    infotxt = infotxt & FMT0("MDStart_71") & additionalErrorInfo & vbCrLf
  End If
  'infotxt = infotxt & "Excel-Fehler-Hinweis:" & vbCrLf & "(" & Err.Number & ") " & Err.Description & vbCrLf
  infotxt = infotxt & FMT2("MDStart_72", errNr, errStr) & vbCrLf
'  If Left(Err.Description, Len("Die Locked-Eigenschaft des Range-Objektes")) = "Die Locked-Eigenschaft des Range-Objektes" Then
'  End If
  Resume Next
End Sub

Function GetCodePassword(wert) As String
  If Len(wert.Codeschutzpasswort) > 0 Then
    Dim tpassword As String
    Dim sz As Variant
    Dim ssubc As Long
    Dim cspw As String
    Dim sc As Long
    Dim found As Boolean
    
    cspw = CheckPassword(wert.Codeschutzpasswort, 16)
    
'    cspw = "&Y3BC-b#:/eN`.J>|fffd|f<IX#f5"
    sz = Array("+", "^", "%", "~", "(", ")", "[", "]", "{", "}")
    For sc = 1 To Len(cspw)
        found = False
        For ssubc = 0 To 9
            ' Wenn eins der Sonderzeichen vorhanden ist m|fffd|ssen wir dies umsetzen
            If Mid(cspw, sc, 1) = sz(ssubc) Then
                found = True
                Exit For
            End If
        Next ssubc
        If found Then
            tpassword = tpassword + "{" + Mid(cspw, sc, 1) + "}"
        Else
            tpassword = tpassword + Mid(cspw, sc, 1)
        End If
    Next sc
    GetCodePassword = tpassword
  End If
End Function

Sub CodeProtect(wert, ByRef wb As Excel.Workbook)
  Dim projPos As Long
  Dim projPosCnt As Long
  Dim sc As Long
  Dim found As Boolean
  If Len(wert.Codeschutzpasswort) > 0 Then
    Dim tpassword As String
    Dim sz As Variant
    Dim ssubc As Long
    Dim cspw As String
    
    cspw = CheckPassword(wert.Codeschutzpasswort, 16)
    
'    cspw = "&Y3BC-b#:/eN`.J>|fffd|f<IX#f5"
    sz = Array("+", "^", "%", "~", "(", ")", "[", "]", "{", "}")
    For sc = 1 To Len(cspw)
        found = False
        For ssubc = 0 To 9
            ' Wenn eins der Sonderzeichen vorhanden ist m|fffd|ssen wir dies umsetzen
            If Mid(cspw, sc, 1) = sz(ssubc) Then
                found = True
                Exit For
            End If
        Next ssubc
        If found Then
            tpassword = tpassword + "{" + Mid(cspw, sc, 1) + "}"
        Else
            tpassword = tpassword + Mid(cspw, sc, 1)
        End If
    Next sc
    
'    tpassword = "a"
    Application.EnableEvents = True
    If Left(Application.Version, 3) = "8.0" Then
      SendKeys "%{F11}%Xs{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    ElseIf Left(Application.Version, 3) = "9.0" Then
      SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    ElseIf Left(Application.Version, 4) = "10.0" Then
      SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    ElseIf Left(Application.Version, 4) = "11.0" Then
      SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    ElseIf Left(Application.Version, 4) = "12.0" Then
'      SendKeys "%{F11}%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
      SendKeys "%x", True
      SendKeys "k", True
      SendKeys "v", True
      SendKeys "^r", True
'      If GetFileNameAndExtension(wert.Inp) > "ExcelProtectRes.xls" Then
'        SendKeys ("{END}"), True
'      Else
'        SendKeys ("{HOME}"), True
'      End If
      
      SendKeys ("{HOME}"), True
      projPos = GetAddinPos(wb.VBProject.name, GetFileNameAndExtension(wb.VBProject.fileName))
      If projPos > 0 Then
        For projPosCnt = 1 To projPos
          VbSendKeys "{SUBTRACT}"
          SendKeys "{DOWN}", True
        Next projPosCnt
      Else
        SendKeys ("{ENTER}"), True
      End If
      SendKeys "%x", True
      SendKeys "i{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}", True
      SendKeys "%q", True
    ElseIf Left(Application.Version, 4) = "14.0" Then
'      SendKeys "%{F11}%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
      SendKeys "%x", True
      SendKeys "k", True
      SendKeys "v", True
      SendKeys "^r", True
'      If GetFileNameAndExtension(wert.Inp) > "ExcelProtectRes.xls" Then
'        SendKeys ("{END}"), True
'      Else
' SendKeys("{HOME}"), True
'      End If
      SendKeys ("{HOME}"), True
      projPos = GetAddinPos(wb.VBProject.name, GetFileNameAndExtension(wb.VBProject.fileName))
      If projPos > 0 Then
        For projPosCnt = 1 To projPos
          VbSendKeys "{SUBTRACT}"
          SendKeys "{DOWN}", True
        Next projPosCnt
      Else
        SendKeys ("{ENTER}"), True
      End If
'      SendKeys ("{ENTER}"), True
      SendKeys "%x", True
      SendKeys "i{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}", True
      SendKeys "%q", True
    Else
        'MsgBox "Bei dieser Version von Excel kann keine Absicherung des VBA-Codes vorgenommen werden!", vbInformation
        MsgBox FMT0("MDStart_73"), vbInformation
    End If
    
    Application.EnableEvents = False
  
    DoEvents
    
    
  
  End If

End Sub

Function GetWerte(ByRef oXLWSheet As Worksheet, ByRef wert As Werte, ByRef dat As DatenElement, ByRef tableMigr, ByRef codeMigr, ByRef tabs, ByRef infotxt As String) As Boolean

  GetWerte = False
  Dim y As Long
  Dim x As Long
  Dim tPos As Long
  If dat Is Nothing Then
  
    wert.Inp = oXLWSheet.Cells(3, 2).value
    wert.Outp = oXLWSheet.Cells(4, 2).value
    wert.Lesepasswort = oXLWSheet.Cells(6, 2).value
    wert.Schreibpasswort = oXLWSheet.Cells(7, 2).value
    wert.Blattschutzpasswort = oXLWSheet.Cells(8, 2).value
    wert.ObjekteSch|fffd|tzen = oXLWSheet.Cells(9, 2).value
    wert.InhalteSch|fffd|tzen = oXLWSheet.Cells(10, 2).value
    wert.SzenariosSch|fffd|tzen = oXLWSheet.Cells(11, 2).value
    wert.Arbeitsmappenschutzpasswort = oXLWSheet.Cells(14, 2).value
    wert.AufbauSch|fffd|tzen = oXLWSheet.Cells(15, 2).value
    wert.FensterSch|fffd|tzen = oXLWSheet.Cells(16, 2).value
    wert.Freigabeschutzpasswort = oXLWSheet.Cells(17, 2).value
    wert.Codeschutzpasswort = oXLWSheet.Cells(18, 2).value
    wert.Formelzellensch|fffd|tzen = oXLWSheet.Cells(19, 2).value
'    wert.NichtFormelzellenEntsch|fffd|tzen = oXLWSheet.Cells(20, 2).Value
    wert.ButtonProtect = "Nein"
    wert.ButtonSpeichern = "Nein"
    wert.ButtonDrucken = "Nein"
    wert.Selektionsschutz = "Nein"
    wert.Wiederholungsbereich = "Nein"
    wert.DruckenVorSchlie|fffd|en = "Nein"
    
    wert.PrintStatus infotxt
    
    ' *********************************************************
    ' Tabellenpassw|fffd|rter
    ' *********************************************************
    y = 0
    Do While Not IsEmpty(oXLWSheet.Cells(StartListY + y, 1))
      Dim tabItem As TabSchutz
      Set tabItem = New TabSchutz
      tabItem.name = oXLWSheet.Cells(StartListY + y, 1)
      tabItem.Passwort = oXLWSheet.Cells(StartListY + y, 2)
      tabItem.InhalteSch|fffd|tzen = wert.InhalteSch|fffd|tzen
      tabItem.ObjekteSch|fffd|tzen = wert.ObjekteSch|fffd|tzen
      tabItem.SzenariosSch|fffd|tzen = wert.SzenariosSch|fffd|tzen
      tabItem.Selektionsschutz = "Nein"
      tabItem.Wiederholungsbereich = "Nein"
      tabItem.Wasserzeichen = ""
      tabItem.ErstellerPfadDatum = ""
      tabItem.Copyrightvermerk = ""
      tabs.Add tabItem
      y = y + 1
    Loop
    
    ' *********************************************************
    ' Textersatz bei Tabellen
    ' *********************************************************
    y = 0
    Do While Not IsEmpty(oXLWSheet.Cells(StartListY + y, 3))
      Dim newMigr As TextMigr
      Set newMigr = New TextMigr
      If Left(oXLWSheet.Cells(StartListY + y, 3), 1) <> Chr(34) Then
          'infotxt = infotxt & "Fehler (11): Sie haben in Zeile " & StartListY + y & ", Spalte C der Suchw|fffd|rter der Tabelle '" & oXLWSheet.name & "' kein f|fffd|hrendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
          infotxt = infotxt & FMT2("MDStart_74", StartListY + y, oXLWSheet.name) & vbCrLf
          Errors = Errors + 1
          Exit Function
      End If
      If Right(oXLWSheet.Cells(StartListY + y, 3), 1) <> Chr(34) Then
          'infotxt = infotxt & "Fehler (12): Sie haben in Zeile " & StartListY + y & ", Spalte C der Suchw|fffd|rter der Tabelle '" & oXLWSheet.name & "' kein endendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
          infotxt = infotxt & FMT2("MDStart_75", StartListY + y, oXLWSheet.name) & vbCrLf
          Errors = Errors + 1
          Exit Function
      End If
      If Left(oXLWSheet.Cells(StartListY + y, 4), 1) <> Chr(34) Then
          'infotxt = infotxt & "Fehler (13): Sie haben in Zeile " & StartListY + y & ", Spalte D der zu ersetzenden W|fffd|rter der Tabelle '" & oXLWSheet.name & "' kein f|fffd|hrendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
          infotxt = infotxt & FMT2("MDStart_76", StartListY + y, oXLWSheet.name) & vbCrLf
          Errors = Errors + 1
          Exit Function
      End If
      If Right(oXLWSheet.Cells(StartListY + y, 4), 1) <> Chr(34) Then
          'infotxt = infotxt & "Fehler (14): Sie haben in Zeile " & StartListY + y & ", Spalte D der zu ersetzenden W|fffd|rter der Tabelle '" & oXLWSheet.name & "' kein endendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
          infotxt = infotxt & FMT2("MDStart_77", StartListY + y, oXLWSheet.name) & vbCrLf
          Errors = Errors + 1
          Exit Function
      End If
      newMigr.TxtFrom = Mid(oXLWSheet.Cells(StartListY + y, 3), 2, Len(oXLWSheet.Cells(StartListY + y, 3)) - 2)
      If Len(oXLWSheet.Cells(StartListY + y, 4)) - 2 > 0 Then
        newMigr.TxtTo = Mid(oXLWSheet.Cells(StartListY + y, 4), 2, Len(oXLWSheet.Cells(StartListY + y, 4)) - 2)
        
        If Left(newMigr.TxtTo, 5) = "!ENC!" Then
          newMigr.TxtTo = Encode(Mid(newMigr.TxtTo, 6))
        End If
        
      Else
        newMigr.TxtTo = ""
      End If
      
      If tableMigr.Count > 0 Then
          For tPos = 1 To tableMigr.Count
              If Len(newMigr.TxtFrom) >= Len(tableMigr(tPos).TxtFrom) Then
                  Exit For
              End If
          Next tPos
      End If
      If tPos = 0 Or tPos >= tableMigr.Count Then
          tableMigr.Add newMigr
      Else
          ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
          tableMigr.Add newMigr, , tPos
      End If
      y = y + 1
    Loop
    
    ' *********************************************************
    ' Textersatz bei Code
    ' *********************************************************
    y = 0
    While Not IsEmpty(oXLWSheet.Cells(StartListY + y, 5))
        Set newMigr = New TextMigr
        newMigr.TxtFrom = oXLWSheet.Cells(StartListY + y, 5)
        newMigr.TxtTo = oXLWSheet.Cells(StartListY + y, 6)
        If codeMigr.Count > 0 Then
            For tPos = 1 To codeMigr.Count
                If Len(newMigr.TxtFrom) >= Len(codeMigr(tPos).TxtFrom) Then
                    Exit For
                End If
            Next tPos
        End If
        If tPos = 0 Or tPos >= codeMigr.Count Then
            codeMigr.Add newMigr
        Else
            ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
            codeMigr.Add newMigr, , tPos
        End If
        y = y + 1
    Wend
  Else
    If dat.typ = "E" Then
    
      If GetParameterIndex(oXLWSheet, "Dateiname") < 0 And GetParameterIndex(oXLWSheet, "File") < 0 Then
        'infotxt = infotxt & "Fehler (17) Es gibt keine Spalte mit der Bezeichnung 'Dateiname' in der Tabelle '" & oXLWSheet.name & "'!" & vbCrLf
        infotxt = infotxt & FMT1("MDStart_78", oXLWSheet.name) & vbCrLf
        Errors = Errors + 1
      End If
      If GetParameterIndex(oXLWSheet, "Speicherdateiname") < 0 Then
        'infotxt = infotxt & "Fehler (20) Es gibt keine Spalte mit der Bezeichnung 'Speicherdateiname' in der Tabelle '" & oXLWSheet.name & "'!" & vbCrLf
        infotxt = infotxt & FMT1("MDStart_79", oXLWSheet.name) & vbCrLf
        Errors = Errors + 1
      End If
      
      If Errors > 0 Then Exit Function
      
      If G_Command = "ETPROT" Then
        wert.Inp = GetString(G_CommandParam)
        wert.Outp = GetString(G_CommandParam)
      Else
        wert.Inp = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Dateiname")).value
        wert.Outp = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Speicherdateiname")).value
      End If
      If GetParameterIndex(oXLWSheet, "Lesepasswort") > 0 Then wert.Lesepasswort = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Lesepasswort")).value
      If GetParameterIndex(oXLWSheet, "Schreibpasswort") > 0 Then wert.Schreibpasswort = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Schreibpasswort")).value
      If GetParameterIndex(oXLWSheet, "Blattschutzpasswort") > 0 Then wert.Blattschutzpasswort = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Blattschutzpasswort")).value
      If GetParameterIndex(oXLWSheet, "ObjekteSch|fffd|tzen") > 0 Then wert.ObjekteSch|fffd|tzen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "ObjekteSch|fffd|tzen")).value
      If GetParameterIndex(oXLWSheet, "InhalteSch|fffd|tzen") > 0 Then wert.InhalteSch|fffd|tzen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "InhalteSch|fffd|tzen")).value
      If GetParameterIndex(oXLWSheet, "SzenariosSch|fffd|tzen") > 0 Then wert.SzenariosSch|fffd|tzen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "SzenariosSch|fffd|tzen")).value
      If GetParameterIndex(oXLWSheet, "Arbeitsmappenschutzpasswort") > 0 Then wert.Arbeitsmappenschutzpasswort = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Arbeitsmappenschutzpasswort")).value
      If GetParameterIndex(oXLWSheet, "Arbeitsmappenaufbausch|fffd|tzen") > 0 Then wert.AufbauSch|fffd|tzen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Arbeitsmappenaufbausch|fffd|tzen")).value
      If GetParameterIndex(oXLWSheet, "FensterSch|fffd|tzen") > 0 Then wert.FensterSch|fffd|tzen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "FensterSch|fffd|tzen")).value
      If GetParameterIndex(oXLWSheet, "Freigabeschutzpasswort") > 0 Then wert.Freigabeschutzpasswort = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Freigabeschutzpasswort")).value
      If GetParameterIndex(oXLWSheet, "Codeschutzpasswort") > 0 Then wert.Codeschutzpasswort = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Codeschutzpasswort")).value
      If GetParameterIndex(oXLWSheet, "Alle Formelzellen sch|fffd|tzen") > 0 Then wert.Formelzellensch|fffd|tzen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Alle Formelzellen sch|fffd|tzen")).value
      If GetParameterIndex(oXLWSheet, "Alle Nicht-Formelzellen entsperren") > 0 Then wert.NichtFormelzellenEntsch|fffd|tzen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Alle Nicht-Formelzellen entsperren")).value
      
      If GetParameterIndex(oXLWSheet, "Selektionsschutz") > 0 Then wert.Selektionsschutz = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Selektionsschutz")).value
      If GetParameterIndex(oXLWSheet, "Wiederholungsbereich") > 0 Then wert.Wiederholungsbereich = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Wiederholungsbereich")).value
      If GetParameterIndex(oXLWSheet, "Wasserzeichen") > 0 Then wert.Wasserzeichen = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Wasserzeichen")).value
      If GetParameterIndex(oXLWSheet, "Name-Datei-Datum") > 0 Then wert.ErstellerPfadDatum = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Name-Datei-Datum")).value
      If GetParameterIndex(oXLWSheet, "Hinweistext") > 0 Then wert.Copyrightvermerk = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Hinweistext")).value
      If GetParameterIndex(oXLWSheet, "Protect") > 0 Then wert.SimpleProtect = oXLWSheet.Cells(dat.Zeile, GetParameterIndex(oXLWSheet, "Protect")).value
      
      wert.ButtonProtect = "Nein"
      wert.ButtonSpeichern = "Nein"
      wert.ButtonDrucken = "Nein"
      wert.DruckenVorSchlie|fffd|en = "Nein"
      
'      xFreierBereich = GetCollumn("Datenliste", 1, "Freier Bereich")
      If xFreierBereich > 0 Then
        y = dat.Zeile
        x = xFreierBereich
        Do While Not IsEmpty(oXLWSheet.Cells(y, x))
          ' ****************************************************************************
          'If oXLWSheet.Cells(y, x) = "[CodeErsatz]" Then
          If GetParameterBool(oXLWSheet.Cells(y, x), "[CodeErsatz]") Then
            Set newMigr = New TextMigr
            newMigr.TxtFrom = oXLWSheet.Cells(y, x + 1)
            newMigr.TxtTo = oXLWSheet.Cells(y, x + 2)
            
            If Left(newMigr.TxtTo, 5) = "!ENC!" Then
              newMigr.TxtTo = Encode(Mid(newMigr.TxtTo, 6))
            End If
            
            If codeMigr.Count >= 0 Then
                For tPos = 1 To codeMigr.Count
                    If Len(newMigr.TxtFrom) > Len(codeMigr(tPos).TxtFrom) Then
                        Exit For
                    End If
                Next tPos
            End If
            If tPos = 0 Or tPos >= codeMigr.Count Then
                codeMigr.Add newMigr
            Else
                ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
                codeMigr.Add newMigr, , tPos
            End If
            x = x + 2
          'ElseIf oXLWSheet.Cells(y, x) = "[Tab]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[Tab]") Then
            Set tabItem = New TabSchutz
            tabItem.name = oXLWSheet.Cells(y, x + 1)
            tabItem.Passwort = oXLWSheet.Cells(y, x + 2).value
            tabItem.InhalteSch|fffd|tzen = oXLWSheet.Cells(y, x + 3)
            tabItem.ObjekteSch|fffd|tzen = oXLWSheet.Cells(y, x + 4)
            tabItem.SzenariosSch|fffd|tzen = oXLWSheet.Cells(y, x + 5)
            x = x + 5
            If Not IsEmpty(oXLWSheet.Cells(y, x + 1)) Then
              If Left(oXLWSheet.Cells(y, x + 1), 1) <> "[" Then
                x = x + 1
                tabItem.Selektionsschutz = oXLWSheet.Cells(y, x)
                tabItem.Wiederholungsbereich = oXLWSheet.Cells(y, x + 1)
                'If UCase(tabItem.Wiederholungsbereich) = "JA" Then
                If IsYes(tabItem.Wiederholungsbereich) Then
                  tabItem.Selektionsschutz = "JA"
                End If
                tabItem.Wasserzeichen = oXLWSheet.Cells(y, x + 2)
                tabItem.ErstellerPfadDatum = oXLWSheet.Cells(y, x + 3)
                tabItem.Copyrightvermerk = oXLWSheet.Cells(y, x + 4)
                x = x + 4
              Else
                tabItem.Selektionsschutz = "Nein"
                tabItem.Wiederholungsbereich = "Nein"
                tabItem.Wasserzeichen = ""
                tabItem.ErstellerPfadDatum = ""
                tabItem.Copyrightvermerk = ""
              End If
            End If
            'If UCase(tabItem.Passwort) <> "RND" And UCase(tabItem.Wiederholungsbereich) = "JA" Then
            If UCase(tabItem.Passwort) <> "RND" And IsYes(tabItem.Wiederholungsbereich) Then
              'infotxt = infotxt & "Fehler (21): Wenn Sie den Wiederholungsbereich nutzen m|fffd|chten (Tabelle '" & oXLWSheet.name & "'), dann m|fffd|ssen Sie im Feld f|fffd|r das Blattschutzpasswort RND eintragen!" & vbCrLf
              infotxt = infotxt & FMT1("MDStart_80", oXLWSheet.name) & vbCrLf
              Errors = Errors + 1
            End If
          
            tabs.Add tabItem
          'ElseIf oXLWSheet.Cells(y, x) = "[BSZellenFormatieren]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSZellenFormatieren]") Then
            wert.BSZellenFormatieren = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSSpaltenFormatieren]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSSpaltenFormatieren]") Then
            wert.BSSpaltenFormatieren = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSZeilenFormatieren]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSZeilenFormatieren]") Then
            wert.BSZeilenFormatieren = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSSpaltenEinf|fffd|gen]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSSpaltenEinf|fffd|gen]") Then
            wert.BSSpaltenEinf|fffd|gen = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSZeilenEinf|fffd|gen]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSZeilenEinf|fffd|gen]") Then
            wert.BSZeilenEinf|fffd|gen = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSHyperlinksEinf|fffd|gen]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSHyperlinksEinf|fffd|gen]") Then
            wert.BSHyperlinksEinf|fffd|gen = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSSpaltenL|fffd|schen]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSSpaltenL|fffd|schen]") Then
            wert.BSSpaltenL|fffd|schen = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSZeilenL|fffd|schen]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSZeilenL|fffd|schen]") Then
            wert.BSZeilenL|fffd|schen = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSSortieren]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSSortieren]") Then
            wert.BSSortieren = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSAutofilterVerwenden]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSAutofilterVerwenden]") Then
            wert.BSAutofilterVerwenden = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[BSPivotTableBerichteVerwenden]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[BSPivotTableBerichteVerwenden]") Then
            wert.BSPivotTableBerichteVerwenden = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[ExeFileLoad]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[ExeFileLoad]") Then
            wert.ExeFileLoad = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[ButtonProtect]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[ButtonProtect]") Then
              wert.ButtonProtect = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[Protect]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[Protect]") Then
              wert.SimpleProtect = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[ButtonSpeichern]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[ButtonSpeichern]") Then
            wert.ButtonSpeichern = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[DruckenVorSchlie|fffd|en]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[DruckenVorSchlie|fffd|en]") Then
            wert.DruckenVorSchlie|fffd|en = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[ButtonDrucken]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[ButtonDrucken]") Then
            wert.ButtonDrucken = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[Selektionsschutz]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[Selektionsschutz]") Then
            wert.Selektionsschutz = "Ja"
          'ElseIf oXLWSheet.Cells(y, x) = "[Wiederholungsbereich]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[Wiederholungsbereich]") Then
            wert.Wiederholungsbereich = "Ja"
            wert.Wasserzeichen = oXLWSheet.Cells(y, x + 1)
            wert.ErstellerPfadDatum = oXLWSheet.Cells(y, x + 2)
            wert.Copyrightvermerk = oXLWSheet.Cells(y, x + 3)
            x = x + 3
          'ElseIf oXLWSheet.Cells(y, x) = "[ZellErsatz]" Then
          ElseIf GetParameterBool(oXLWSheet.Cells(y, x), "[ZellErsatz]") Then
            Set newMigr = New TextMigr
            If Left(oXLWSheet.Cells(y, x + 1), 1) <> Chr(34) Then
              'infotxt = infotxt & "Fehler (22): Sie haben in Zeile " & y & ", Spalte " & GetSpalte(x + 1) & " der Suchw|fffd|rter der Tabelle '" & oXLWSheet.name & "' kein f|fffd|hrendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
              infotxt = infotxt & FMT3("MDStart_81", y, GetSpalte(x + 1), oXLWSheet.name) & vbCrLf
              Errors = Errors + 1
            End If
            If Right(oXLWSheet.Cells(y, x + 1), 1) <> Chr(34) Then
              'infotxt = infotxt & "Fehler (23): Sie haben in Zeile " & y & ", Spalte " & GetSpalte(x + 1) & " der Suchw|fffd|rter der Tabelle '" & oXLWSheet.name & "' kein endendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
              infotxt = infotxt & FMT3("MDStart_82", y, GetSpalte(x + 1), oXLWSheet.name) & vbCrLf
              Errors = Errors + 1
            End If
            If Left(oXLWSheet.Cells(y, x + 2), 1) <> Chr(34) Then
              'infotxt = infotxt & "Fehler (24): Sie haben in Zeile " & y & ", Spalte " & GetSpalte(x + 3) & " der zu ersetzenden W|fffd|rter der Tabelle '" & oXLWSheet.name & "' kein f|fffd|hrendes Hochkomma angegeben. Bitte erg|fffd|nzen Sie dies!" & vbCrLf
              infotxt = infotxt & FMT3("MDStart_83", y, GetSpalte(x + 3), oXLWSheet.name) & vbCrLf
              Errors = Errors + 1
            End If
            If Right(oXLWSheet.Cells(y, x + 2), 1) <> Chr(34) Then
              infotxt = infotxt & FMT3("MDStart_84", y, GetSpalte(x + 3), oXLWSheet.name) & vbCrLf
              Errors = Errors + 1
            End If
            If Errors > 0 Then
              Exit Function
            End If
            
            newMigr.TxtFrom = Mid(oXLWSheet.Cells(y, x + 1), 2, Len(oXLWSheet.Cells(y, x + 1)) - 2)
            If Len(oXLWSheet.Cells(y, x + 2)) - 2 > 0 Then
              newMigr.TxtTo = Mid(oXLWSheet.Cells(y, x + 2), 2, Len(oXLWSheet.Cells(y, x + 2)) - 2)
              If Left(newMigr.TxtTo, 5) = "!ENC!" Then
                newMigr.TxtTo = Encode(Mid(newMigr.TxtTo, 6))
              End If
            Else
              newMigr.TxtTo = ""
            End If
            
            If tableMigr.Count > 0 Then
                For tPos = 1 To tableMigr.Count
                    If Len(newMigr.TxtFrom) >= Len(tableMigr(tPos).TxtFrom) Then
                        Exit For
                    End If
                Next tPos
            End If
            If tPos = 0 Or tPos >= tableMigr.Count Then
                tableMigr.Add newMigr
            Else
                ' Nur wenn es diese OE noch nicht gibt wird sie auch eingef|fffd|gt
                tableMigr.Add newMigr, , tPos
            End If
            x = x + 2
          End If
          
          x = x + 1
          If IsEmpty(oXLWSheet.Cells(y, x)) And IsEmpty(oXLWSheet.Cells(y + 1, 3)) Then
            x = xFreierBereich
            y = y + 1
          End If
        Loop
      End If
    
      wert.PrintStatus infotxt
    
      PlausiCheck wert, infotxt, dat.Zeile
      If Errors > 0 Then
        Exit Function
      End If
    
    End If
  End If
  
  If Mid(wert.Inp, 2, 1) <> ":" And Mid(wert.Inp, 2, 1) <> "\" And Mid(wert.Inp, 2, 1) <> "/" And InStr(wert.Inp, "://") <= 0 Then
    wert.Inp = ThisWorkbook.path & "\" & wert.Inp
  End If
  
  If Mid(wert.Outp, 2, 1) <> ":" And Mid(wert.Outp, 2, 1) <> "\" And Mid(wert.Outp, 2, 1) <> "/" And InStr(wert.Outp, "://") <= 0 Then
    wert.Outp = ThisWorkbook.path & "\" & wert.Outp
  End If
  
  If UCase(Right(wert.Inp, 4)) <> ".XLS" And UCase(Right(wert.Inp, 5)) <> ".XLSX" And UCase(Right(wert.Inp, 5)) <> ".XLSM" And UCase(Right(wert.Inp, 5)) <> ".XLSB" Then
    'infotxt = infotxt & "Fehler (28) ['" & wert.Inp & "'] ist keine XLS- oder XLSX-Datei! Excel-Protect liest ausschlie|fffd|lich XLS/XLSX/XLSM/XLSB-Dateien ein!" & vbCrLf
    infotxt = infotxt & FMT1("MDStart_85", wert.Inp) & vbCrLf
    Errors = Errors + 1
    Exit Function
  End If

  
  
  GetWerte = True
End Function

Function GetSpalte(spalte As Long) As String
  If spalte > 26 Then
    GetSpalte = Chr((spalte - 1) \ 26 + 64) & Chr((spalte - 1) Mod 26 + 65)
  Else
    GetSpalte = Chr(spalte + 64)
  End If
End Function

Function GetCollumn(tabname As String, y As Long, txt As String) As Long
  GetCollumn = -1
  On Error GoTo failedGetCollumn
  Dim i As Long
  For i = 1 To 255
    If Worksheets(tabname).Cells(y, i).value = txt Then
      GetCollumn = i
      Exit Function
    End If
  Next i
failedGetCollumn:
End Function

Function FindModuleWithText(oXLWbook As Excel.Workbook, txt As String) As Variant
  Dim VBComp
  Dim dstmdl
  For Each VBComp In oXLWbook.VBProject.VBComponents
    Set dstmdl = VBComp.CodeModule
    
    Dim srch As String
    Dim loc As Long
    loc = dstmdl.CountOfLines
    If loc > 0 Then
      Dim i As Long
      For i = 1 To loc
        If InStr(UCase(dstmdl.Lines(i, 1)), UCase(txt)) > 0 Then
          FindModuleWithText = dstmdl
          Exit Function
        End If
      Next i
    End If
  Next VBComp
  Set FindModuleWithText = Nothing
End Function

Function ButtonProtect(oXLWbook As Excel.Workbook, ByRef infotxt As String, inpFilename As String) As Boolean

  ButtonProtect = False
  
  If Not CheckVBAWritable(oXLWbook) Then
    Exit Function
  End If

  
'  On Error Resume Next
  
  Dim dstmdl
    
  If 1 = 2 Then
    Set dstmdl = FindModuleWithText(oXLWbook, "auto_open()")
  
    If dstmdl Is Nothing Then
      Set dstmdl = oXLWbook.VBProject.VBComponents.Add(1).CodeModule
    End If
    
    CodeSetTotalFunction dstmdl, "Sub auto_open()", "'#INSERT_WORKBOOK_OPEN#", _
      "'#INSERT_WORKBOOK_OPEN_PART#", infotxt, inpFilename
  
  Else
  
    Set dstmdl = GetCodemodule(oXLWbook, "ThisWorkbook")
    
    If dstmdl Is Nothing Then
      Set dstmdl = GetCodemodule(oXLWbook, "DieseArbeitsmappe")
      If dstmdl Is Nothing Then
        'infotxt = infotxt & "Fehler (29) ['" & inpFilename & "']: Die Datei hat kein Modul mit dem Namen 'DieseArbeitsmappe'. Eventuell benutzen Sie eine ausl|fffd|ndische Version von Excel. Absicherungen mit ausl|fffd|ndischen Versionen sind nicht m|fffd|glich!" & vbCrLf
        infotxt = infotxt & FMT1("MDStart_86", inpFilename) & vbCrLf
        Errors = Errors + 1
        Exit Function
      End If
    End If
  
    CodeSetTotalFunction dstmdl, "Sub Workbook_Open()", "'#INSERT_WORKBOOK_OPEN#", _
      "'#INSERT_WORKBOOK_OPEN_PART#", infotxt, inpFilename
    
  End If
  
  
  Dim codeStr As String
  Dim newMod
  ' Jetzt muss noch das neue Modul dazu
  Set newMod = oXLWbook.VBProject.VBComponents.Add(1)
  codeStr = GetCode(theOXLWBookRes, "'#MODULE Extension#")
  If newMod.CodeModule.CountOfLines > 0 Then
    newMod.CodeModule.deletelines 1, newMod.CodeModule.CountOfLines
  End If
  newMod.CodeModule.InsertLines newMod.CodeModule.CountOfLines + 1, codeStr
'  Application.ActiveWorkbook.Activate
  
  SendKeys "%{TAB}", True
  DoEvents
  
  Application.Wait Now + TimeValue("0:00:1")
  DoEvents



  ' Jetzt wird das Programm noch so modifiziert, dass alle Tabellen unsichtbar sind und eine neue Tabelle mit
  ' dem entsprechenden Text eingef|fffd|gt wird.
  ' Jetzt die neue Tabelle rein
  'theOXLWBookRes.Sheets("Hinweis").Activate
  'theOXLWBookRes.Sheets("Hinweis").Copy Before:=oXLWbook.Sheets(1)
  Dim noteSheet As String
  noteSheet = GetNoteSheetName()
  theOXLWBookRes.Sheets(noteSheet).Activate
  theOXLWBookRes.Sheets(noteSheet).Copy Before:=oXLWbook.Sheets(1)
  
  Dim itemCnt As Long
  For itemCnt = 2 To oXLWbook.Worksheets.Count
      oXLWbook.Worksheets(itemCnt).Visible = xlVeryHidden
  Next itemCnt
  
  Set newMod = Nothing
  Set dstmdl = Nothing

  WBSetValueLong oXLWbook, "_ExcelProtectP_" & Format(Now, "yyyymmddhhmmss"), 1

  ButtonProtect = True
End Function

Private Function GetNoteSheetName() As String
  On Error GoTo nogo
  If WorksheetExists(theOXLWBookRes, "Hinweis") Then
    GetNoteSheetName = "Hinweis"
  Else
    Dim name As String
    name = LocTextCol("Hinweis")
    If WorksheetExists(theOXLWBookRes, name) Then
      GetNoteSheetName = name
    End If
  End If
  Exit Function
nogo:
  
End Function

Private Function WorksheetExists(ByRef wb As Workbook, ByVal name As String) As Boolean
  On Error Resume Next
  WorksheetExists = (wb.Sheets(name).name <> "")
  On Error GoTo 0
End Function

Function GetResFile(ByRef infotxt As String, inpFilename As String) As Boolean

  GetResFile = False
  If Not FileExists(ThisWorkbook.path & "\ExcelProtectRes.xls") Then
    'infotxt = infotxt & "Fehler (26) ['" & inpFilename & "']: Die Datei '" & ThisWorkbook.path & "\ExcelProtectRes.xls' wurde nicht gefunden!" & vbCrLf
    infotxt = infotxt & FMT2("MDStart_87", inpFilename, ThisWorkbook.path) & vbCrLf
    Errors = Errors + 1
    Exit Function
  End If
  
  On Error Resume Next
  
  Set theOXLWBookRes = Workbooks.Open(ThisWorkbook.path & "\ExcelProtectRes.xls", False, True, , "13d4a!Psw(7dd)=")
  
  If theOXLWBookRes Is Nothing Then
    'infotxt = infotxt & "Fehler (27) ['" & inpFilename & "']: Die Datei '" & ThisWorkbook.path & "\ExcelProtectRes.xls' konnte nicht ge|fffd|ffnet werden." & vbCrLf
    infotxt = infotxt & FMT2("MDStart_88", inpFilename, ThisWorkbook.path) & vbCrLf
    Errors = Errors + 1
    Exit Function
  End If
  GetResFile = True

End Function


Sub WBSetValueLong(ByRef wb As Excel.Workbook, ByVal vname As String, ByVal v As Long)
    Dim nameItem As Excel.name

    For Each nameItem In wb.names
        If nameItem.Visible = False Then
            If nameItem.name = vname Then
                nameItem.RefersTo = "=" & v
                Exit Sub
            End If
        End If
    Next nameItem

    On Error GoTo nogo
    wb.names.Add vname, CStr(v), False
    Exit Sub

nogo:

    'MsgBox "Error: " & Err.Number & " - " & Err.Description & " - " & Err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
    MsgBox FMT3("MDStart_89", Err.Number, Err.Description, Err.Source), vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion

End Sub


Function SimpleProtect(oXLWbook As Excel.Workbook, ByRef infotxt As String, inpFilename As String) As Boolean

  SimpleProtect = False
  
'  On Error Resume Next
  
  Dim dstmdl
  
  If 1 = 2 Then
    Set dstmdl = FindModuleWithText(oXLWbook, "auto_open()")
    If dstmdl Is Nothing Then
      Set dstmdl = oXLWbook.VBProject.VBComponents.Add(1).CodeModule
    End If
    
    CodeSetTotalFunction dstmdl, "Sub auto_open()", "'#INSERT_WORKBOOK_SIMPLE_OPEN#", _
      "'#INSERT_WORKBOOK_SIMPLE_OPEN_PART#", infotxt, inpFilename
  Else
  
    Set dstmdl = GetCodemodule(oXLWbook, "ThisWorkbook")
    
    If dstmdl Is Nothing Then
      Set dstmdl = GetCodemodule(oXLWbook, "DieseArbeitsmappe")
      If dstmdl Is Nothing Then
        'infotxt = infotxt & "Fehler (30) ['" & inpFilename & "']: Die Datei hat kein Modul mit dem Namen 'DieseArbeitsmappe'. Eventuell benutzen Sie eine ausl|fffd|ndische Version von Excel. Absicherungen mit ausl|fffd|ndischen Versionen sind nicht m|fffd|glich!" & vbCrLf
        infotxt = infotxt & FMT1("MDStart_90", inpFilename) & vbCrLf
        Errors = Errors + 1
        Exit Function
      End If
    End If
  
    CodeSetTotalFunction dstmdl, "Sub Workbook_Open()", "'#INSERT_WORKBOOK_SIMPLE_OPEN#", _
      "'#INSERT_WORKBOOK_SIMPLE_OPEN_PART#", infotxt, inpFilename
  End If
  
  Set dstmdl = Nothing
  
  Set dstmdl = GetCodemodule(oXLWbook, "ThisWorkbook")
  
  If dstmdl Is Nothing Then
    Set dstmdl = GetCodemodule(oXLWbook, "DieseArbeitsmappe")
  End If
  
  CodeSetTotalFunction dstmdl, "Sub Workbook_BeforeClose(", "'#INSERT_WORKBOOK_SIMPLE_CLOSE#", _
    "'#INSERT_WORKBOOK_SIMPLE_CLOSE_PART#", infotxt, inpFilename
  
  CodeSetTotalFunction dstmdl, "Sub Workbook_BeforeSave(", "'#INSERT_WORKBOOK_SIMPLE_BEFORE_SAVE#", _
    "'#INSERT_WORKBOOK_SIMPLE_BEFORE_SAVE_PART#", infotxt, inpFilename
  
  Dim newMod
  Dim codeStr As String
  ' Jetzt muss noch das neue Modul dazu
  Set newMod = oXLWbook.VBProject.VBComponents.Add(1)
  codeStr = GetCode(theOXLWBookRes, "'#MODULE Extension#")
  If newMod.CodeModule.CountOfLines > 0 Then
    newMod.CodeModule.deletelines 1, newMod.CodeModule.CountOfLines
  End If
  newMod.CodeModule.InsertLines newMod.CodeModule.CountOfLines + 1, codeStr
'  Application.ActiveWorkbook.Activate
  
  SendKeys "%{TAB}", True
  DoEvents
  
  Application.Wait Now + TimeValue("0:00:1")
  DoEvents



  ' Jetzt wird das Programm noch so modifiziert, dass alle Tabellen unsichtbar sind und eine neue Tabelle mit
  ' dem entsprechenden Text eingef|fffd|gt wird.
  ' Jetzt die neue Tabelle rein
  theOXLWBookRes.Sheets("Hinweis").Activate
  theOXLWBookRes.Sheets("Hinweis").Copy Before:=oXLWbook.Sheets(1)
  Dim itemCnt As Long
  For itemCnt = 2 To oXLWbook.Worksheets.Count
      oXLWbook.Worksheets(itemCnt).Visible = xlVeryHidden
  Next itemCnt
  
  Set newMod = Nothing
  Set dstmdl = Nothing
  
  WBSetValueLong oXLWbook, "_ExcelProtectP_" & Format(Now, "yyyymmddhhmmss"), 1

  SimpleProtect = True
End Function


Function ErstellerPfadDatumErzeugen(oXLWbook As Excel.Workbook, ByRef infotxt As String, inpFilename As String) As Boolean

'  On Error Resume Next

  If Not CheckVBAWritable(oXLWbook) Then
    ErstellerPfadDatumErzeugen = False
    'infotxt = infotxt & "Fehler () ['" & inpFilename & "']: 'ErstellerPfadDatum' konnte nicht erzeugt werden, da kein Zugriff auf VBA besteht oder der VBA-Code der Datei bereits gesch|fffd|tzt ist." & vbCrLf
    infotxt = infotxt & FMT1("MDStart_91", inpFilename) & vbCrLf
    Errors = Errors + 1
    Exit Function
  End If
  
  Dim dstmdl
  Set dstmdl = GetCodemodule(oXLWbook, "ThisWorkbook")
  
  If dstmdl Is Nothing Then
    Set dstmdl = GetCodemodule(oXLWbook, "DieseArbeitsmappe")
  End If
  
  CodeSetTotalFunction dstmdl, "Sub Workbook_BeforePrint(", "'#INSERT_WORKBOOK_BEFOREPRINT#", _
    "'#INSERT_WORKBOOK_BEFOREPRINT_PART#", infotxt, inpFilename
  
  Set dstmdl = Nothing

  ErstellerPfadDatumErzeugen = True
End Function



Function GetCode(oXLWbook As Excel.Workbook, findStr As String) As String
  Dim element
  Dim mdl
  For Each element In oXLWbook.VBProject.VBComponents
    Set mdl = element.CodeModule
    
    Dim loc As Long
    loc = mdl.CountOfLines
    If loc > 0 Then
      Dim startLine As Long
      Dim endLine As Long
      startLine = -1
      endLine = -1
      Dim i As Long
      For i = 1 To loc
        If InStr(mdl.Lines(i, 1), findStr) > 0 Then
          startLine = i + 1
          Exit For
        End If
      Next i
      
      If startLine >= 0 Then
        For i = startLine To loc
          If InStr(mdl.Lines(i, 1), findStr) > 0 Then
            endLine = i
              If endLine - startLine > 0 Then
                GetCode = mdl.Lines(startLine, endLine - startLine)
              End If
            Exit Function
          End If
        Next i
      End If
    End If
  Next element
End Function

Function CodeSet(oXLWbook As Excel.Workbook, sourceCodeTag As String, destCodeTag As String, ByRef infotxt As String, ByRef inpFilename As String) As Boolean

  CodeSet = False
  
'  On Error Resume Next

  If Not CheckVBAWritable(oXLWbook) Then
    'infotxt = infotxt & "Fehler () ['" & inpFilename & "']: CodeSet ('" & sourceCodeTag & "' --> '" & destCodeTag & "') war nicht m|fffd|glich, da kein Zugriff auf VBA besteht oder der VBA-Code der Datei bereits gesch|fffd|tzt ist!" & vbCrLf
    infotxt = infotxt & FMT3("MDStart_92", inpFilename, sourceCodeTag, destCodeTag) & vbCrLf
    Errors = Errors + 1
    CodeSet = False
    Exit Function
  End If

  Dim dstmdl
  Dim vbc
  For Each vbc In oXLWbook.VBProject.VBComponents
    Set dstmdl = vbc.CodeModule
    If Not dstmdl Is Nothing Then
      Dim srch As String
      Dim loc As Long
      loc = dstmdl.CountOfLines
      If loc > 0 Then
        Dim i As Long
        For i = 1 To loc
          If InStr(UCase(dstmdl.Lines(i, 1)), destCodeTag) > 0 Then
            ' OK, dann wollen wir mal den Code holen lassen
            Dim codeStr As String
            codeStr = GetCode(theOXLWBookRes, sourceCodeTag)
            dstmdl.InsertLines i + 1, codeStr
            loc = dstmdl.CountOfLines
'            Exit For
          End If
                  
        Next i
      End If
    End If
  Next vbc
  
  CodeSet = True
End Function

Sub AddAllWorksheetsEnableSelection(oXLWbook As Excel.Workbook, ByRef infotxt As String, inpFilename As String)

  Dim ws As Worksheet
  For Each ws In oXLWbook.Worksheets
    AddWorksheetEnableSelection ws, oXLWbook, infotxt, inpFilename
  Next ws
  
End Sub

Function AddWorksheetEnableSelection(ws As Worksheet, oXLWbook As Excel.Workbook, ByRef infotxt As String, inpFilename As String) As Boolean

  If Not CheckVBAWritable(oXLWbook) Then
    'infotxt = infotxt & "Fehler () ['" & inpFilename & "']: Der Selektionsschutz konnte in Tabelle '" & ws.name & "' nicht gesetzt werden, da kein Zugriff auf VBA m|fffd|glich ist oder der VBA-Code der Datei bereits gesch|fffd|tzt ist!" & vbCrLf
    infotxt = infotxt & FMT2("MDStart_93", inpFilename, ws.name) & vbCrLf
    Errors = Errors + 1
    AddWorksheetEnableSelection = False
    Exit Function
  End If
  
  Dim dstmdl
  Set dstmdl = GetCodemodule(oXLWbook, ws.CodeName)
  
  CodeSetTotalFunction dstmdl, "Sub Worksheet_Activate()", "'#INSERT_WORKSHEET_ACTIVATE#", _
    "'#INSERT_WORKSHEET_ACTIVATE_PART#", infotxt, inpFilename
    
  Set dstmdl = Nothing
  AddWorksheetEnableSelection = True
  
End Function



Sub CodeSetTotalFunction(dstmdl, destCodeTag As String, sourceCodeTag As String, _
  sourceCodeTagPart As String, ByRef infotxt As String, ByRef inpFilename As String)
  
  If dstmdl Is Nothing Then Exit Sub
  
  Dim found As Boolean
  found = False
  
  Dim srch As String
  Dim loc As Long
  loc = dstmdl.CountOfLines
  If loc > 0 Then
    Dim i As Long
    For i = 1 To loc
      If InStr(UCase(dstmdl.Lines(i, 1)), UCase(destCodeTag)) > 0 Then
        found = True
        
        ' OK, dann wollen wir mal den Code holen lassen
        Dim codeStr As String
        codeStr = GetCode(theOXLWBookRes, sourceCodeTagPart)
        dstmdl.InsertLines i + 1, codeStr
        Exit For
      End If
              
    Next i
  End If
  
  If Not found Then
    codeStr = GetCode(theOXLWBookRes, sourceCodeTag)
    dstmdl.InsertLines dstmdl.CountOfLines + 1, codeStr
  End If

End Sub

Function GetParameterIndex(ByRef oXLWSheet As Worksheet, paramName As String)
  GetParameterIndex = -1
  Dim i As Long
  For i = 1 To 255
    If MakeUnique(oXLWSheet.Cells(4, i).value) = MakeUnique(paramName) Then
      GetParameterIndex = i
      Exit Function
    End If
  Next i
  
  If Not LocParamsCol Is Nothing Then
    ' Und nochmal fuer Englisch
    On Error GoTo nogo
    Dim name As String
    name = LocParamsCol(paramName)
    For i = 1 To 255
      If MakeUnique(oXLWSheet.Cells(4, i).value) = MakeUnique(name) Then
        GetParameterIndex = i
        Exit Function
      End If
    Next i
  End If
nogo:
  Debug.Print "ParamName: " & paramName & " missing!"
End Function
  
Function MakeUnique(S As String) As String
  Dim news As String
  Dim i As Long
  For i = 1 To Len(S)
    If (Mid(S, i, 1) >= "a" And Mid(S, i, 1) <= "z") Or _
       (Mid(S, i, 1) >= "A" And Mid(S, i, 1) <= "Z") Then
       news = news + Mid(S, i, 1)
    End If
  Next i
  MakeUnique = UCase(news)
End Function

Function GetParameterBool(cell As Object, paramName As String) As Boolean
  GetParameterBool = False
  If cell Is Nothing Then
    Exit Function
  End If
  If cell = paramName Then
    GetParameterBool = True
    Exit Function
  ElseIf Not LocParamsBoolCol Is Nothing Then
    ' Auch mit Englisch probieren
    On Error GoTo nogo
    Dim name As String
    name = LocParamsBoolCol(paramName)
    If cell = name Then
      GetParameterBool = True
      Exit Function
    End If
nogo:
  End If
End Function

Function CmpLocText(txt As String, cmp As String) As Boolean
  On Error GoTo nogo
  If txt = cmp Then
    CmpLocText = True
    Exit Function
  Else
    Dim locCmp As String
    locCmp = LocTextCol(cmp)
    If txt = locCmp Then
      CmpLocText = True
      Exit Function
    End If
  End If
nogo:
  CmpLocText = False
End Function

Sub AddWiederholungsbereich(wb As Excel.Workbook, ws As Worksheet, wert, ByRef infotxt As String, inpFilename As String, outFilename As String)
  If Len(wert.Copyrightvermerk) > 0 Then
    ws.Rows("1:3").Insert Shift:=xlDown
    ws.PageSetup.PrintTitleRows = "$1:$3"
  Else
    ws.Rows("1:2").Insert Shift:=xlDown
    ws.PageSetup.PrintTitleRows = "$1:$2"
  End If

'  ws.Range("A1:A2").MergeCells = True
'          With ws.Range("A1:A2")
'              .HorizontalAlignment = xlGeneral
'              .VerticalAlignment = xlBottom
'              .WrapText = False
'              .Orientation = 0
'              .ShrinkToFit = False
'              .MergeCells = True
'          End With
  
  ' --------------------------------------------------------
  ' Soll ein Wasserzeichen in den Wiederholungsbereich rein?
  ' --------------------------------------------------------
  Dim fname As String
  Dim newpic As Object
  Dim c
  
  
  Dim EPDSpalte As Long
  EPDSpalte = 1
  'If UCase(wert.Wasserzeichen) = "JA" Then
  If IsYes(wert.Wasserzeichen) Then
    fname = ThisWorkbook.path & "\Wasserzeichen.jpg"
    If FileExists(fname) Then
      Application.ScreenUpdating = False
      Set newpic = ws.Pictures.Insert(Trim(fname))
      
      newpic.Top = ws.Cells(1, 1).Top + 1
      newpic.Left = ws.Cells(1, 1).Left + 1
      
      Dim oldVal As Double
'      oldVal = ws.Columns(1).ColumnWidth
'      ws.Columns(1).ColumnWidth = 0
'      Do Until newpic.Width <= ws.Columns(1).Width
'          ws.Columns(1).ColumnWidth = ws.Columns(1).ColumnWidth + 0.1
'      Loop
'      If ws.Columns(1).ColumnWidth < oldVal Then
'        ws.Columns(1).ColumnWidth = oldVal
'      End If

      EPDSpalte = newpic.BottomRightCell.Column + 1

      oldVal = ws.Rows(1).RowHeight
      ws.Rows(1).RowHeight = 0
      Do Until newpic.Height <= ws.Rows(1).Height
          ws.Rows(1).RowHeight = ws.Rows(1).RowHeight + 0.5
      Loop
      If ws.Rows(1).RowHeight < oldVal Then
        ws.Rows(1).RowHeight = oldVal
      End If
      
      
      newpic.Placement = xlMoveAndSize
      
      Application.ScreenUpdating = True
      If ws.Cells(1, 1).MergeCells = True Then
        ws.Cells(1, 1).MergeArea.Locked = True
      Else
        ws.Cells(1, 1).Locked = True
      End If
      
    End If
  End If
  
  ' --------------------------------------------------------
  ' Ersteller Pfad Datum rein?
  ' --------------------------------------------------------
  'If UCase(wert.ErstellerPfadDatum) = "JA" Then
  If IsYes(wert.ErstellerPfadDatum) Then
    With ws.Cells(1, EPDSpalte)
      .Formula = "=SW_xlErstellerPfadDatum()"
      .Font.name = "Arial"
      .Font.Size = 5
      .VerticalAlignment = xlTop
      .HorizontalAlignment = xlHAlignLeft
    End With
  End If

  ' --------------------------------------------------------
  ' Copyright rein?
  ' --------------------------------------------------------
  If Len(wert.Copyrightvermerk) > 0 Then
    Dim ts As String
    ts = wert.Copyrightvermerk
    ts = MyReplace(ts, "#datum#", Absicherungsdatum)
    ts = MyReplace(ts, "#user#", Environ("USERNAME"))
    ts = MyReplace(ts, "#datei#", outFilename)
    ws.Cells(2, 1) = ts
    With ws.Cells(2, 1)
      .Font.name = "Arial"
      .Font.Size = 6
      .VerticalAlignment = xlTop
      .HorizontalAlignment = xlHAlignLeft
    End With
  End If
End Sub

Function CheckPassword(S As String, pwlen As Long) As String
  Dim pwchr As Long
  Dim news As String
  If UCase(S) = "RND" Then
    Dim sc As Long
    For sc = 1 To 15
      pwchr = CLng((Len(pwstr) * Rnd) + 1)
      news = news + Mid(pwstr, pwchr, 1)
    Next sc
    CheckPassword = news
  Else
    CheckPassword = S
  End If
End Function

Sub GetDataOld()
  On Error GoTo noData
  FullVersion = False
  Dim app As Excel.Application
  Dim wb As Excel.Workbook
  Set app = New Excel.Application
  Set wb = app.Workbooks.Open(ThisWorkbook.path & "\" & dothat("HDIvh.coz"), False, True, , "k$a5iUTe4hf2!/{", , True, , , False, False, , False)
    If wb.Sheets(1).Cells(1, 1) = "1fdd34/lkMTzdfZZQ12()//|fffd|245mNGNndflRltdaf''++.,LpiUGF" Then
      If wb.Sheets(1).Cells(3, 1) = "" Then
        Exit Sub
      End If
      trs = wb.Sheets(1).Cells(3, 1)
'      MyCopyright = wb.Sheets(1).Cells(3, 2)
      FullVersion = True
    End If
  wb.Close
  Set wb = Nothing
  app.Quit
  Set app = Nothing
  Exit Sub
noData:
  Exit Sub
End Sub

Function GetCodemodule(oXLWbook As Excel.Workbook, n As String) As Variant
  On Error Resume Next
  Set GetCodemodule = Nothing
  Set GetCodemodule = oXLWbook.VBProject.VBComponents(n).CodeModule
End Function

Function GetWorkbook(fname As String) As Workbook
  On Error Resume Next
  Set GetWorkbook = Nothing
  Set GetWorkbook = Workbooks.Open(fname)
End Function

Sub UnlockCells(ws, ByRef infotxt As String)
On Error GoTo noUnlock
  ws.Cells.Locked = False
  Exit Sub
noUnlock:
  'infotxt = infotxt & "Hinweis (1): Die Zellen der Tabelle '" & ws.name & "' konnte nicht entsperrt werden." & vbCrLf
  infotxt = infotxt & FMT1("MDStart_94", ws.name) & vbCrLf
  Warnings = Warnings + 1
End Sub

Sub UnlockCell(c, ByRef infotxt As String)
On Error GoTo noUnlock
  If c.MergeCells = True Then
    If c.MergeArea.Locked = True Then
      c.MergeArea.Locked = False
    End If
  Else
    If c.Locked = True Then
      c.Locked = False
    End If
  End If
  Exit Sub
noUnlock:
  'infotxt = infotxt & "Hinweis (8): Die Zelle " & c.Address & " der Tabelle '" & c.Parent.name & "' konnte nicht entsperrt werden." & vbCrLf
  infotxt = infotxt & FMT2("MDStart_95", c.Address, c.Parent.name) & vbCrLf
  Warnings = Warnings + 1
End Sub



Sub TestAddins()

  Debug.Print GetAddinPos("VBAProject", "BAddin.xlam")

End Sub

Function GetAddinPos(ByVal addinname As String, ByVal addinfilename As String) As Long

    GetAddinPos = -1
    Dim c As Collection
    Set c = New Collection
    Dim i As Long

    Dim v
    For Each v In Application.VBE.VBProjects
    
      Dim S As String
      S = v.name & "|" & GetFileNameAndExtension(v.fileName)
      If c.Count > 0 Then
        Dim found As Boolean
        found = False
        For i = 1 To c.Count
          If UCase(c(i)) > UCase(S) Then
            found = True
            c.Add S, S, i
            Exit For
          End If
        Next i
        If Not found Then
          c.Add S, S
        End If
      Else
        c.Add S, S
      End If
    Next v
    
    If c.Count > 0 Then
      For i = 1 To c.Count
        Debug.Print c(i)
      Next i
    End If
    
    If c.Count > 0 Then
      For i = 1 To c.Count
        If UCase(c(i)) = UCase(addinname & "|" & addinfilename) Then
          GetAddinPos = i - 1
        End If
      Next i
    End If
    
End Function

Public Function CryptPasswort(ByVal S As String) As String
    CryptPasswort = Crypt(S, "T0)7/hJy+\1TrcpI?", True)
End Function

Public Function DecryptPasswort(ByVal S As String) As String
    DecryptPasswort = Crypt(S, "T0)7/hJy+\1TrcpI?", False)
End Function

Public Function CreateRandomPasswort() As String
    CreateRandomPasswort = GetStandardPassword() ' Format$(Now, "dd.mm.yyyy")
End Function

Public Function GetStandardPassword() As String
    GetStandardPassword = "NDR9)oio0(rrl5/mfk677&"
End Function

Public Function StorePasswordFuerDatei(ByVal typ As Long, ByRef conn As Object, ByVal idvDateiID As String, ByVal pw) As Boolean

    Dim rs As Object
    ' wenn es noch kein Passwort gibt, dann erstellen wir ein neues
On Error GoTo fehler
    Set rs = CreateObject("ADODB.Recordset")
    
    rs.Open "SELECT * from idvDateienPW WHERE idvDateiID = " & idvDateiID & " and PWTyp = " & typ, conn, MYadOpenDynamic, MYadLockOptimistic
    If rs Is Nothing Then
        StorePasswordFuerDatei = False
        Exit Function
    End If
    
    If rs.EOF = True Then
        rs.AddNew
        rs.Fields("idvDateiID").value = idvDateiID
        rs.Fields("LogonID").value = Left(GetUserName(), 20)
        rs.Fields("Datum").value = Now
    End If
    pw = CryptPasswort(pw)
    rs.Fields("Passwort").value = pw
    rs.Fields("PWTyp").value = typ
    rs.Update
    
    Set rs = Nothing
    StorePasswordFuerDatei = True
    Exit Function
    
fehler:
    StorePasswordFuerDatei = False
End Function



Function Crypt(Inp As String, Key As String, Mode As Boolean) As String
    Dim z As String
    Dim i As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For i = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If Mode Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, i, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If i > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, i * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
        Next i
     
        Crypt = z
End Function

Function IsSimpleFormula(ByVal f As String) As Boolean
    
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(f, "N(" & Chr(34))
    If pos > 0 Then
    
' .NET START
      If pos > 1 Then
        If UCase(Mid(f, pos - 1, 1)) >= "A" And UCase(Mid(f, pos - 1, 1)) <= "Z" Then
          Exit Do
        End If
      End If
' .NET END
      pos2 = InStr(pos + 3, f, Chr(34))
      If pos2 <= 0 Then Exit Do
      If Mid(f, pos2 + 1, 1) = ")" Then
        f = Left(f, pos - 1) & Mid(f, pos2 + 2)
      Else
        Exit Do
      End If
    Else
      Exit Do
    End If
  Loop
  If Trim(StrRemove(f, "0123456789+-*/^(). " & vbCrLf & vbTab)) = "=" Then IsSimpleFormula = True
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.Formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function

Function WorksheetProtected(ByRef ws As Worksheet) As Boolean
  If ws.ProtectContents = True Then
    WorksheetProtected = True
  End If
End Function

Attribute VB_Name = "TabSchutz"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public name As String
Public Passwort As String
Public ObjekteSch|fffd|tzen As String
Public InhalteSch|fffd|tzen As String
Public SzenariosSch|fffd|tzen As String

Public Selektionsschutz As String
Public Wiederholungsbereich As String
Public Wasserzeichen As String
Public ErstellerPfadDatum As String
Public Copyrightvermerk As String


Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "CommandButton1, 1, 0, MSForms, CommandButton"
Private Sub CommandButton1_Click()
  Auto_Open
End Sub
Attribute VB_Name = "TextMigr"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False








Public TxtFrom As String
Public TxtTo As String

Attribute VB_Name = "Translation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit



' ------------------------------------------------------------------
Private Const NoError = 0       'The Function call was successful

Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SISO639LANGNAME = &H59
Private Const LOCALE_SISO3166CTRYNAME = &H5A

#If VBA7 Then
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
          
    ' Caution:  If the user default locale is a custom locale, an application cannot accurately tag data
    ' with the value or exchange it. In this case, the application should use GetUserDefaultLocaleName
    ' (available starting with Windows Vista) in preference to GetUserDefaultLCID.
    Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    ' List of Language Identifier Constants and Strings:
    ' https://msdn.microsoft.com/library/dd318693.aspx
    Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

    ' Available since Vista
    'GetUserDefaultUILanguage
    
#Else
    Private Declare Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
    
    Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
    
#End If

' ------------------------------------------------------------------


' 0 = fallback language
Private mStringTables(2) As Collection
Private mLangIDs(2) As String
Private mCurrentUser As String

Public Property Get CurrentUser() As String
    CurrentUser = mCurrentUser
End Property


Private Sub Class_Initialize()
    mCurrentUser = GetTranslationUserName
End Sub

Public Function StartupInit(installRoot As String, app As String, Optional overrideLang As String = "") As Boolean
    On Error GoTo nogo
    ' User Language ermitteln (xy-uv)
    Dim lang As String
    If overrideLang <> "" Then
        lang = overrideLang
    Else
        'lang = GetUserLanguage
        ' Direkt das nehmen was Windows reportet
        lang = GetWindowsLanguageString
    End If
    
    Dim path As String
    Dim paths(1) As String
    Dim userPaths(1) As String
    
    Dim tries As Long
    For tries = 0 To 1
    
      paths(0) = installRoot & "\Translate\" & app & "_" & lang & ".txt"
      userPaths(0) = installRoot & "\Translate\" & app & "_" & lang & "_indiv.txt"
      
      paths(1) = installRoot & "\..\Translate\" & app & "_" & lang & ".txt"
      userPaths(1) = installRoot & "\..\Translate\" & app & "_" & lang & "_indiv.txt"
      
      Dim i As Long
      For i = 0 To UBound(paths)
          If Init(0, paths(i), lang) = True Then
              ' Und auch versuchen die user strings zu laden (falls es die gibt)
              Init 1, userPaths(i), lang
              StartupInit = True
              Exit Function
          End If
      Next i
      
      ' Nix gefunden -> Fallback language setzen
      lang = GetFallbackLanguage(lang)
    
    Next tries
    
nogo:
    StartupInit = False
End Function

Public Function Init(index As Long, path As String, langId As String) As Boolean
    Init = False
    If index >= UBound(mLangIDs) Then
        Exit Function
    End If
    
    mLangIDs(index) = UCase(langId)
    Dim c As Collection
    Set c = LoadStringTable(path)
    If c Is Nothing Then
        Exit Function
    End If
    Set mStringTables(index) = c
    Init = True
End Function

Public Sub Clear()
    Set mStringTables(0) = New Collection
    Set mStringTables(1) = New Collection
End Sub

Public Function GetLocalizedFile(path As String) As String
    Dim lang As String
    If UBound(mLangIDs) > 0 Then
        If mLangIDs(0) <> "" Then
            lang = mLangIDs(0)
        End If
    End If
    If lang = "" Then
        lang = GetWindowsLanguageString
    End If
    
    GetLocalizedFile = LocalizedFileExists(path, lang)
End Function

' Splitted path\filename.ext aus path
' Und sucht dann nach
' path\filename_lang.ext
' Wenn nix gefunden, wird lang mit einem fallback replaced.
' en-gb fuer alles was en-xy ist
' de-de fuer alles andere
' Oder halt den original path wenn es auch de-de nicht gibt.
' Der gefundene pfad wird returned oder "" wenn es gar nix gibt.
Public Function LocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    LocalizedFileExists = path
    Dim newPath As String
    
    If lang <> "" Then
        ' Direkt nach der uebergebenen Sprache in lang suchen
        newPath = InternalLocalizedFileExists(path, lang)
        If newPath <> "" Then
            LocalizedFileExists = newPath
            Exit Function
        End If
        
        ' Nix gefunden -> fallback Sprache nehmen
        If Len(lang) > 2 Then
            ' Wenn es was Englisches ist, dann nach en-gb suchen
            If UCase(lang) <> "EN-GB" And InStr(UCase(lang), "EN") > 0 Then
                newPath = InternalLocalizedFileExists(path, "en-gb")
                If newPath <> "" Then
                    LocalizedFileExists = newPath
                    Exit Function
                End If
            End If
        End If
        
        ' Bis hier hin nix gefunden -> nach "de-de" suchen
        If UCase(lang) <> "DE-DE" Then
            newPath = InternalLocalizedFileExists(path, "de-de")
            If newPath <> "" Then
                LocalizedFileExists = newPath
                Exit Function
            End If
        End If
    End If
    
nogo:
    If Not FileExists(LocalizedFileExists) Then
        LocalizedFileExists = ""
    End If
End Function

Private Function InternalLocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    Dim newPath As String
    Dim p As String
    Dim fileName As String
    Dim ext As String
    fileSplit path, p, fileName, ext

    newPath = FmtInternal("%1%2_%3.%4", p, fileName, lang, ext)
    If newPath <> "" And FileExists(newPath) Then
        InternalLocalizedFileExists = newPath
        Exit Function
    End If
nogo:
End Function


Public Sub AddString(tableIdx As Long, id As String, S As String)
    mStringTables(tableIdx).Add S, id
End Sub

Public Function StringExists(id As String) As Boolean
    If id = "" Then
        StringExists = True
        Exit Function
    End If
    On Error GoTo nogo
    Dim S As String
    S = mStringTables(0).item(UCase(id))
    StringExists = True
    Exit Function
nogo:
    StringExists = False
End Function

Public Function GetString(id As String) As String
    On Error GoTo nogo
    If id = "" Then
        Exit Function
    End If
    
    If mStringTables(1) Is Nothing Then
        GetString = GetFallbackString(id)
        Exit Function
    End If
    GetString = mStringTables(1).item(UCase(id))
    Exit Function
nogo:
    GetString = GetFallbackString(id)
End Function

Public Function GetFallbackString(id As String) As String
    On Error GoTo nogo
    If mStringTables(0) Is Nothing Then
        GetFallbackString = id & ": ***MISSING***"
        Exit Function
    End If
    
    GetFallbackString = mStringTables(0).item(UCase(id))
    Exit Function
nogo:
    GetFallbackString = id & ": ***MISSING***"
End Function

Public Function FormatString(FMT As String, _
                             Optional arg1 As String = vbNullChar, _
                             Optional arg2 As String = vbNullChar, _
                             Optional arg3 As String = vbNullChar, _
                             Optional arg4 As String = vbNullChar, _
                             Optional arg5 As String = vbNullChar, _
                             Optional arg6 As String = vbNullChar, _
                             Optional arg7 As String = vbNullChar, _
                             Optional arg8 As String = vbNullChar, _
                             Optional arg9 As String = vbNullChar _
                             ) As String
                             
    On Error GoTo nogo
    
    Dim argarray(8) As String
    If IsTestUser Then
        argarray(0) = arg1
        argarray(1) = arg2
        argarray(2) = arg3
        argarray(3) = arg4
        argarray(4) = arg5
        argarray(5) = arg6
        argarray(6) = arg7
        argarray(7) = arg8
        argarray(8) = arg9
        
        Dim i As Long
        ' Erstmal checken ob wir fuer jeden Placeholder einen Parameter uebergeben bekommen haben
        ' Hier koennte man auch IsMissing nehmen - aber dann muessen alle args vom Type Variant sein.
        For i = 1 To 9
            If InStr(FMT, "%" & i) > 0 Then
                If argarray(i - 1) = vbNullChar Then
                    MsgBox FMT & vbCrLf & vbCrLf & "ERROR in FormatString: No arg for %" & i, vbCritical
                    Exit Function
                End If
            End If
        Next i
    Else
        argarray(0) = IIf(arg1 = vbNullChar, "", arg1)
        argarray(1) = IIf(arg2 = vbNullChar, "", arg2)
        argarray(2) = IIf(arg3 = vbNullChar, "", arg3)
        argarray(3) = IIf(arg4 = vbNullChar, "", arg4)
        argarray(4) = IIf(arg5 = vbNullChar, "", arg5)
        argarray(5) = IIf(arg6 = vbNullChar, "", arg6)
        argarray(6) = IIf(arg7 = vbNullChar, "", arg7)
        argarray(7) = IIf(arg8 = vbNullChar, "", arg8)
        argarray(8) = IIf(arg9 = vbNullChar, "", arg9)
    End If
    
    Dim r As String
    r = FMT
    
    r = Replace(r, "%%", "%")
    r = Replace(r, "\n", vbCrLf)
    r = Replace(r, "\t", vbTab)
    
    For i = 1 To 9
        r = Replace(r, "%" & i, argarray(i - 1))
    Next i
    
    FormatString = r
    Exit Function

nogo:
    FormatString = "ERROR " & FMT
End Function

#If TEST_BUILD = 1 Then
#Else
#End If

'Public Function FormatString(fmt As String, _
'                             Optional arg1 As String, _
'                             Optional arg2 As String, _
'                             Optional arg3 As String, _
'                             Optional arg4 As String, _
'                             Optional arg5 As String, _
'                             Optional arg6 As String, _
'                             Optional arg7 As String, _
'                             Optional arg8 As String, _
'                             Optional arg9 As String _
'                             ) As String
'    On Error GoTo nogo
'
'    Dim argarray(8) As String
'    argarray(0) = arg1
'    argarray(1) = arg2
'    argarray(2) = arg3
'    argarray(3) = arg4
'    argarray(4) = arg5
'    argarray(5) = arg6
'    argarray(6) = arg7
'    argarray(7) = arg8
'    argarray(8) = arg9
'    Dim i As Long
'    Dim r As String
'    r = fmt
'    For i = 1 To 9
'        r = Replace(r, "%" & i, argarray(i - 1))
'    Next i
'    r = Replace(r, "%%", "%")
'    r = Replace(r, "\n", vbCrLf)
'    r = Replace(r, "\t", vbTab)
'
'    FormatString = r
'    Exit Function
'
'nogo:
'    FormatString = "ERROR " & fmt
'End Function

Public Sub TranslateControl(ctl As Object)
    On Error GoTo nogo
    Dim tag As String
    tag = ctl.tag
    If tag <> "" Then
        Dim tags() As String
        tags = Split(tag, ",")
    
        ' Caption
        Dim S As String
        S = FMT0(tags(0))
        If S <> "" Then
            If TypeOf ctl Is MSForms.TextBox Then
                ctl.Text = S
            'ElseIf TypeOf ctl Is MSForms.UserForm Then
            Else
                ctl.Caption = S
            End If
        End If
        
        ' ControlTipText
        If UBound(tags) > 0 Then
            S = FMT0(tags(1))
            If S <> "" Then
                If TypeOf ctl Is MSForms.MultiPage Then
                    ' MultiPage hat keinen tooltip
                Else
                    ctl.ControlTipText = S
                End If
            End If
        End If
    End If

    Exit Sub
nogo:
End Sub

Public Sub TranslateForm(frm As Object)
    TranslateControl frm
    
    
    Dim ctl As Object
    For Each ctl In frm.Controls
        
        'If ctl.ControlType = acTextBox Then
        If TypeOf ctl Is MSForms.MultiPage Then
            TranslateControl ctl
            Dim page As Object
            For Each page In ctl.Pages
                TranslateControl page
            Next page
        ElseIf TypeOf ctl Is MSForms.Frame Then
            TranslateForm ctl
        Else
            TranslateControl ctl
        'ElseIf ctl.ControlType = acSubform Then
        '    TranslateForm frm(ctl.name).Form
        End If
    Next ctl
    
End Sub

' Die Sprache die der user in Windows eingestellt hat
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetUserLanguage() As String
    Dim lcid As Long
    lcid = GetUserDefaultLCID()
    GetUserLanguage = MapLCIDToInternalLanguage(lcid)
End Function

' Die Sprache des installierten Ms Office
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetMsOfficeLanguage() As String
    Dim lcid As Long
    lcid = Application.LanguageSettings.LanguageID(msoLanguageIDUI)
    GetMsOfficeLanguage = MapLCIDToInternalLanguage(lcid)
End Function



' -------------------------------------------------------------------
'
' -------------------------------------------------------------------

Function LoadStringTable(path As String) As Collection
    On Error GoTo nogo
    Set LoadStringTable = Nothing
    
    Const ForReading = 1
    Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0
    
    Dim fs, f, ts
    Set ts = Nothing
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(path, ForReading, False, TristateTrue)
    
    'Dim sheet As Worksheet
    'Set sheet = ThisWorkbook.Sheets("Test")
    'Dim y As Long
    'y = 1
    
    Dim c As New Collection
    Dim S As String
    Do While ts.AtEndOfStream <> True
        ' This really is a Unicode string, although the debugger and MsgBox show ??
        S = ts.ReadLine
        'sheet.Cells(y, 1) = s
        'y = y + 1
        
        If ExtractString(S, c) Then
        End If
    Loop
    Set LoadStringTable = c
nogo:
    If Not ts Is Nothing Then
        ts.Close
        Set ts = Nothing
    End If
    If Not fs Is Nothing Then
        Set fs = Nothing
    End If
End Function

Function ExtractString(line As String, c As Collection) As Boolean
    On Error GoTo nogo
    
    ExtractString = False
    If line = "" Then
        Exit Function
    End If
    If Left(line, 1) = "'" Then
        Exit Function
    End If
    
    Dim pos As Long
    pos = InStr(line, " ")
    If pos <= 0 Then
        Exit Function
    End If
    
    Dim id As String
    Dim value As String
    id = Left(line, pos - 1)
    value = Mid(line, pos + 1, Len(line) - pos)
    If Not CollectionStringExists(c, id) Then
        c.Add value, id
    End If
    
    ExtractString = True
    Exit Function
nogo:
    MsgBox Err.Description
End Function

Private Function IsTestUser() As Boolean
    If mCurrentUser = "dirk" Or _
        mCurrentUser = "dwinter" Or _
        mCurrentUser = "norman" Or _
        mCurrentUser = "nneubert" Or _
        mCurrentUser = "rolf" Or _
        mCurrentUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Private Function GetTranslationUserName() As String
   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      lpUserName = "Unbekannt"
   End If

    GetTranslationUserName = lpUserName
End Function

Private Function CollectionStringExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim S As String
  S = c(name)
  CollectionStringExists = True
  Exit Function
  
notReadable:
  CollectionStringExists = False
End Function

Private Function LCIDToLanguageCode(lcid As Long) As String

    ' Locale IDs
    ' https://msdn.microsoft.com/en-us/goglobal/bb964664
    'Arabic (Saudi Arabia)                1025
    'Arabic (Iraq)                        2049
    'Arabic (Egypt)                       3073
    'Arabic (Libya)                       4097
    'Arabic (Algeria)                     5121
    'Arabic (Morocco)                     6145
    'Arabic (Tunisia)                     7169
    'Arabic (Oman)                        8193
    'Arabic (Yemen)                       9217
    'Arabic (Syria)                      10241
    'Arabic (Jordan)                     11265
    'Arabic (Lebanon)                    12289
    'Arabic (Kuwait)                     13313
    'Arabic (U.A.E.)                     14337
    'Arabic (Bahrain)                    15361
    'Arabic (Qatar)                      16385
    'Bulgarian                            1026
    'Catalan                              1027
    'Chinese (Taiwan)                     1028
    'Chinese (PRC)                        2052
    'Chinese (Hong Kong SAR               3076
    'Chinese (Singapore)                  4100
    'Czech                                1029
    'Danish                               1030
    'German (Germany)                     1031
    'German (Swiss)                       2055
    'German (Austrian)                    3079
    'German (Luxembourg)                  4103
    'German (Liechtenstein)               5127
    'Greek                                1032
    'English (United States)              1033
    'English (United Kingdom)             2057
    'English (Australian)                 3081
    'English (Canadian)                   4105
    'English (New Zealand)                5129
    'English (Ireland)                    6153
    'English (South Africa)               7177
    'English (Jamaica)                    8201
    'English (Caribbean)                  9225
    'English (Belize)                    10249
    'English (Trinidad)                  11273
    'Spanish (Traditional Sort)           1034
    'Spanish (Mexican)                    2058
    'Spanish (Modern Sort)                3082
    'Spanish (Guatemala)                  4106
    'Spanish (Costa Rica)                 5130
    'Spanish (Panama)                     6154
    'Spanish (Dominican Republic)         7178
    'Spanish (Venezuela)                  8202
    'Spanish (Colombia)                   9226
    'Spanish (Peru)                      10250
    'Spanish (Argentina)                 11274
    'Spanish (Ecuador)                   12298
    'Spanish (Chile)                     13322
    'Spanish (Uruguay)                   14346
    'Spanish (Paraguay)                  15370
    'Spanish (Bolivia)                   16394
    'Spanish (El Salvador)               17418
    'Spanish (Honduras)                  18442
    'Spanish (Nicaragua)                 19466
    'Spanish (Puerto Rico)               20490
    'Finnish                              1035
    'French (Standard)                    1036
    'French (Belgian)                     2060
    'French (Canadian)                    3084
    'French (Swiss)                       4108
    'French (Luxembourg)                  5132
    'Hebrew                               1037
    'Hungarian                            1038
    'Icelandic                            1039
    'Italian (Standard)                   1040
    'Italian (Swiss)                      2064
    'Japanese                             1041
    'Korean                               1042
    'Korean (Johab)                       2066
    'Dutch (Standard)                     1043
    'Dutch (Belgian)                      2067
    'Norwegian (Bokmal)                   1044
    'Norwegian (Nynorsk)                  2068
    'Polish                               1045
    'Portuguese (Brazil)                  1046
    'Portuguese (Portugal)                2070
    'Romanian                             1048
    'Russian                              1049
    'Croatian                             1050
    'Serbian (Latin)                      2074
    'Serbian (Cyrillic)                   3098
    'Slovak                               1051
    'Albanian                             1052
    'Swedish                              1053
    'Swedish (Finland)                    2077
    'Thai                                 1054
    'Turkish                              1055
    'Indonesian                           1057
    'Ukrainian                            1058
    'Belarusian                           1059
    'Slovenian                            1060
    'Estonian                             1061
    'Latvian                              1062
    'Lithuanian                           1063
    'Farsi                                1065
    'Vietnamese                           1066
    'Basque                               1069
    'Afrikaans                            1078
    'Faeroese                             1080

    'Dim langs As Variant
    'langs = [{1031, "de-de"; 2055, "de-ch"}]
    'langs = Array( _
    '        1031, "de-de" _
    '    )
    
    ' Default ist Englisch
    LCIDToLanguageCode = "en-gb"

    ' https://msdn.microsoft.com/en-us/library/ee825488(v=cs.20).aspx
    Select Case lcid
    Case 1031
        'German (Germany)
        LCIDToLanguageCode = "de-de"
    Case 2055
        'German (Swiss)
        LCIDToLanguageCode = "de-ch"
    Case 3079
        'German (Austrian)
        LCIDToLanguageCode = "de-at"
    Case 4103
        'German (Luxembourg)
        LCIDToLanguageCode = "de-lu"
    Case 5127
        'German (Liechtenstein)
        LCIDToLanguageCode = "de-li"
        
    Case 1033
        'English (United States)
        LCIDToLanguageCode = "en-us"
    Case 2057
        'English (United Kingdom)
        LCIDToLanguageCode = "en-gb"
    Case 3081
        'English (Australian)
        LCIDToLanguageCode = "en-au"
    Case 4105
        'English (Canadian)
        LCIDToLanguageCode = "en-ca"
    Case 5129
        'English (New Zealand)
        LCIDToLanguageCode = "en-nz"
    Case 6153
        'English (Ireland)
        LCIDToLanguageCode = "en-ie"
    Case 7177
        'English (South Africa)
        LCIDToLanguageCode = "en-za"
    Case 8201
        'English (Jamaica)
        LCIDToLanguageCode = "en-jm"
    Case 9225
        'English (Caribbean)
        LCIDToLanguageCode = "en-cb"
    Case 10249
        'English (Belize)
        LCIDToLanguageCode = "en-bz"
    Case 11273
        'English (Trinidad and Tobago)
        LCIDToLanguageCode = "en-tt"
    End Select
End Function

Private Function MapLCIDToInternalLanguage(lcid As Long) As String
    Dim langCulture As String
    langCulture = LCIDToLanguageCode(lcid)
    
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(langCulture, 2) = "de" Then
        MapLCIDToInternalLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        MapLCIDToInternalLanguage = LANG_EN_GB
    End If
    
End Function

Public Function GetWindowsLanguageString() As String
    On Error GoTo nogo
    
    Dim ret As Long
    Dim loc As String
    Dim windowsLang As String
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = loc & "-"
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = windowsLang & loc
    
    GetWindowsLanguageString = LCase(windowsLang)
    Exit Function
nogo:
    GetWindowsLanguageString = "en-gb"
End Function

Private Function GetFallbackLanguage(lang As String) As String
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(lang, 2) = "de" Then
        GetFallbackLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        GetFallbackLanguage = LANG_EN_GB
    End If
End Function



Attribute VB_Name = "TranslationHelpers"
Option Explicit

' Fallbacksprachen
' Regeln:
 '  File APP_en-xy.txt nicht da -> APP_en-gb.txt benutzen
 '  File APP_de-xy.txt nicht da -> APP_de-de.txt benutzen
 '  File APP_xy-uv.txt nicht da -> APP_en-gb.txt benutzen
Public Const LANG_EN_GB As String = "en-gb"
Public Const LANG_DE_DE As String = "de-de"

Public gTranslation As New Translation

Public Function InitTranslation(path As String, langFile As String, cfg As CfgReader) As Boolean
    InitTranslation = False
    Dim overrideLanguage As String
    If Not cfg Is Nothing Then
        If cfg.GetSection("GLOBALS") = True Then
            overrideLanguage = cfg.GetValue("LANGUAGE")
        End If
    End If
    If Not gTranslation.StartupInit(path, langFile, overrideLanguage) Then
        ' Sprachdateien wurden nicht geladen
        MsgBox FmtInternal("Missing language files ('%1_en-gb.txt')!" & vbCrLf & vbCrLf & "Die Sprachdateien wurden nicht gefunden ('%1_de-de.txt')!", langFile), vbCritical
        Exit Function
    End If
    InitTranslation = True
End Function

Public Function FMT0(f As String) As String
    FMT0 = FmtInternal(TR(f))
End Function

Public Function FMT1(f As String, _
                     ByVal arg1 As String) As String
    FMT1 = FmtInternal(TR(f), arg1)
End Function

Public Function FMT2(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String) As String
    FMT2 = FmtInternal(TR(f), arg1, arg2)
End Function

Public Function FMT3(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String) As String
    FMT3 = FmtInternal(TR(f), arg1, arg2, arg3)
End Function

Public Function FMT4(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String) As String
    FMT4 = FmtInternal(TR(f), arg1, arg2, arg3, arg4)
End Function

Public Function FMT5(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String) As String
    FMT5 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5)
End Function

Public Function GetTranslationString(id As String, fallback As String) As String
    If gTranslation.StringExists(id) Then
        GetTranslationString = gTranslation.GetString(id)
        Exit Function
    End If
    GetTranslationString = fallback
End Function

Public Function TR(id As String) As String
'    If gTranslation Is Nothing Then
'        TR = "gTranslation Not Initialized"
'        Exit Function
'    End If
    TR = gTranslation.GetString(id)
End Function

Public Function FmtInternal(f As String, _
                    Optional arg1 As String = vbNullChar, _
                    Optional arg2 As String = vbNullChar, _
                    Optional arg3 As String = vbNullChar, _
                    Optional arg4 As String = vbNullChar, _
                    Optional arg5 As String = vbNullChar, _
                    Optional arg6 As String = vbNullChar, _
                    Optional arg7 As String = vbNullChar, _
                    Optional arg8 As String = vbNullChar, _
                    Optional arg9 As String = vbNullChar _
                    ) As String
    FmtInternal = gTranslation.FormatString(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
End Function

Public Function IsYes(S As String) As Boolean
  If UCase(S) = "JA" Or UCase(S) = "YES" Then
    IsYes = True
  End If
End Function

Public Function IsNo(S As String) As Boolean
  If UCase(S) = "NEIN" Or UCase(S) = "NO" Then
    IsNo = True
  End If
End Function

Public Function IsTrue(S As String) As Boolean
    If UCase(S) = "WAHR" Or UCase(S) = "TRUE" Then
        IsTrue = True
    End If
End Function

Public Function IsFalse(S As String) As Boolean
    If UCase(S) = "FALSCH" Or UCase(S) = "FALSE" Then
        IsFalse = True
    End If
End Function

Private Function MyWorksheetExists(ByRef wb, wsname As String) As Boolean
    On Error GoTo nogo
    Dim ws
    Set ws = wb.Worksheets(wsname)
    Set ws = Nothing
    MyWorksheetExists = True
    Exit Function
nogo:
End Function

Public Function TranslationSheetExists(ByRef wb As Workbook, names As Variant) As String
    On Error GoTo nogo
    Dim name As String
    If IsArray(names) Then
        Dim n As Variant
        For Each n In names
            name = CStr(n)
            If MyWorksheetExists(wb, name) Then
                TranslationSheetExists = name
                Exit Function
            End If
        Next n
        If UBound(names) >= 0 Then
            TranslationSheetExists = CStr(names(0))
            Exit Function
        End If
    Else
        name = CStr(names)
        If MyWorksheetExists(wb, name) Then
            TranslationSheetExists = name
            Exit Function
        End If
    End If
nogo:
    
End Function

' Das gleiche wie Cells.Find - aber probiert mehrere Strings zu finden (fuer mehrere Sprachen)
Public Function TranslationFindCells(ws As Worksheet, What As Variant, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean) As Range
  Set TranslationFindCells = Nothing
  Dim S As Variant
  For Each S In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(S), LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase)
    If Not r Is Nothing Then
      Set TranslationFindCells = r
      Exit Function
    End If
  Next S
End Function

' This works because Debug.Print is omitted in the compiled code
Public Function InIDE() As Boolean
  On Error Resume Next
  Debug.Print 0 / 0
  InIDE = Err.Number <> 0
End Function



Attribute VB_Name = "UNC"
Option Explicit
    

' Fuer CacheMappedDrives()
'Dim mMappedDrives As Collection
Dim mMappedDrives(0 To 25) As String
Dim mUsedDriveLetters(0 To 25) As String
Dim mNumUsedDrives As Integer
    

#If VBA7 And Win64 Then
' Done
Private Declare PtrSafe Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#Else
Private Declare Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#End If

Public Function GetUNCPath(ByVal sLocalPath As String) As String
    '// -----------------------------------------------------------------
    '// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
    '// -----------------------------------------------------------------
    '// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..)
    '// -----------------------------------------------------------------
    '// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
    '//            | bei Fehler = sLocalPath
    '// -----------------------------------------------------------------
    Const NO_ERROR As Long = 0
    Dim sUNCPath As String
    Dim sResult As String
    Dim sDrive As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
    '// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = Left$(sLocalPath, 2)
    sUNCPath = Space$(260)
    If WNetGetConnectionA(sDrive, sUNCPath, Len(sUNCPath)) = NO_ERROR Then
        sResult = Left$(sUNCPath, InStr(sUNCPath, vbNullChar) - 1)
        If Len(sResult) > 0 Then
            GetUNCPath = sResult & Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Sub CacheMappedDrives()
    mNumUsedDrives = 0
    Dim i As Integer
    For i = 65 To 90
        Dim strUNCPath As String
        strUNCPath = ""
        If GetUNCPathShort(Chr(i) & ":", strUNCPath) = 0 Then
            mMappedDrives(mNumUsedDrives) = UCase(strUNCPath)
            mUsedDriveLetters(mNumUsedDrives) = Chr(i)
            mNumUsedDrives = mNumUsedDrives + 1
        Else
        
        End If
    Next i
End Sub

' Wir nehmen an uncPath ist all upper case
Public Function GetCachedMappedDrive(uncPath As String) As String
    GetCachedMappedDrive = uncPath
    Dim i As Integer
    For i = 0 To mNumUsedDrives - 1
        If mMappedDrives(i) = Left$(uncPath, Len(mMappedDrives(i))) Then
            GetCachedMappedDrive = mUsedDriveLetters(i) & ":" & Mid$(uncPath, Len(mMappedDrives(i)) + 1)
            Exit For
        End If
    Next i
End Function

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim S As String

    S = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(S) Then
                S = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = S
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnectionA(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        If InStr(strRemoteName, Chr(0)) > 0 Then
          strUNCPath = Left(strRemoteName, InStr(strRemoteName, Chr(0)) - 1)
        Else
          strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        End If
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function



Attribute VB_Name = "UnicodeFile"
Option Explicit

#If VBA7 And Win64 Then
' Done
  Private Declare PtrSafe Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As LongPtr, _
      ByVal cbMultiByte As LongPtr, _
      ByVal lpWideCharStr As LongPtr, _
      ByVal cchWideChar As Long _
  ) As Long

  Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
      ByVal codePage As Long, ByVal dwFlags As Long, _
      ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr, _
      ByVal lpMultiByteStr As LongPtr, ByVal cchMultiByte As LongPtr, _
      ByVal lpDefaultChar As LongPtr, ByVal lpUsedDefaultChar As LongPtr) As Long
        
#Else
  Private Declare Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long _
  ) As Long
  
  Private Declare Function WideCharToMultiByte Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpDefaultChar As Long, _
      ByVal lpUsedDefaultChar As Long _
  ) As Long
#End If

Public Const CP_ACP        As Long = 0          ' Default ANSI code page.
Public Const CP_UTF8       As Long = 65001      ' UTF8.
Public Const CP_UTF16_LE   As Long = 1200       ' UTF16 - little endian.
Public Const CP_UTF16_BE   As Long = 1201       ' UTF16 - big endian.
Public Const CP_UTF32_LE   As Long = 12000      ' UTF32 - little endian.
Public Const CP_UTF32_BE   As Long = 12001      ' UTF32 - big endian.

' Purpose:  Heuristic to determine whether bytes in a file are UTF-8.
Private Function FileBytesAreUTF8(ByVal the_iFileNo As Integer) As Boolean

    Const knSampleByteSize          As Long = 2048
    Dim nLof                        As Long
    Dim nByteCount                  As Long
    Dim nByteIndex                  As Long
    Dim nCharExtraByteCount         As Long
    Dim bytValue                    As Byte

    ' We look at the first <knSampleByteSize> bytes of the file. However, if the file is smaller, we will have to
    ' use the smaller size.
    nLof = LOF(the_iFileNo)
    If nLof < knSampleByteSize Then
        nByteCount = nLof
    Else
        nByteCount = knSampleByteSize
    End If

    ' Go to the start of the file.
    Seek #the_iFileNo, 1

    For nByteIndex = 1 To nByteCount

        Get #the_iFileNo, , bytValue

        ' If the character we are processing has bytes beyond 1, then we are onto the next character.
        If nCharExtraByteCount = 0 Then
            '
            ' The UTF-8 specification says that the first byte of a character has masking bits which indicate how many bytes follow.
            '
            ' See: http://en.wikipedia.org/wiki/UTF-8#Description
            '
            ' Bytes in
            ' sequence   Byte 1   Byte 2   Byte 3   Byte 4
            ' 1          0xxxxxxx
            ' 2          110xxxxx 10xxxxxx
            ' 3          1110xxxx 10xxxxxx 10xxxxxx
            ' 4          11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            '
            If (bytValue And &H80) = &H0 Then
                nCharExtraByteCount = 0
            ElseIf (bytValue And &HE0) = &HC0 Then
                nCharExtraByteCount = 1
            ElseIf (bytValue And &HF0) = &HE0 Then
                nCharExtraByteCount = 2
            ElseIf (bytValue And &HF8) = &HF0 Then
                nCharExtraByteCount = 3
            Else
                ' If none of these masks were matched, then this can't be a UTF-8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        Else
            ' All following bytes must be masked as in the table above.
            If (bytValue And &HC0) = &H80 Then
                nCharExtraByteCount = nCharExtraByteCount - 1
                If nCharExtraByteCount = 0 Then
                    FileBytesAreUTF8 = True
                End If
            Else
                ' Not a UTF8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        End If

    Next nByteIndex

End Function

' Purpose:  Take a string whose bytes are in the byte array <the_abytCPString>, with code page <the_nCodePage>, convert to a VB string.
Private Function FromCPString(ByRef the_abytCPString() As Byte, ByVal the_nCodePage As Long) As String

    Dim sOutput                     As String
    Dim nValueLen                   As Long
    Dim nOutputCharLen              As Long

    ' If the code page says this is already compatible with the VB string, then just copy it into the string. No messing.
    If the_nCodePage = CP_UTF16_LE Then
        FromCPString = the_abytCPString()
    Else

        ' Cache the input length.
        nValueLen = UBound(the_abytCPString) - LBound(the_abytCPString) + 1

        ' See how big the output buffer will be.
        nOutputCharLen = MultiByteToWideChar(the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, 0&, 0&)

        ' Resize output byte array to the size of the UTF-8 string.
        sOutput = Space$(nOutputCharLen)

        ' Make this API call again, this time giving a pointer to the output byte array.
        MultiByteToWideChar the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, StrPtr(sOutput), nOutputCharLen

        ' Return the array.
        FromCPString = sOutput

    End If

End Function

Public Function GetContents(ByVal the_sTextFile As String, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean) As String

    Dim iFileNo                     As Integer
    Dim abytFileContents()          As Byte
    Dim nDataSize                   As Long

    iFileNo = FreeFile

    OpenForInput the_sTextFile, iFileNo, out_nCodePage, the_nDesiredCodePage, out_bContainedBOM

    ' We want to read the entire contents of the file (not including any BOM value).
    ' After calling OpenForInput(), the file pointer should be positioned after any BOM.
    ' So size file contents buffer to <file size> - <current position> + 1.
    nDataSize = LOF(iFileNo) - Seek(iFileNo) + 1
    ReDim abytFileContents(1 To nDataSize)
    Get #iFileNo, , abytFileContents()

    Close iFileNo

    ' Now we must convert this to UTF-8. But we have to first convert to the Windows NT standard UTF-16 LE.
    GetContents = FromCPString(abytFileContents(), out_nCodePage)

End Function


' Diese Funktion ist langsam!!!!!!!!!!!!!

' Purpose:  Reads up to the end of the current line of the file, repositions to the beginning of the next line, if any, and
'           outputs all characters found.
' Inputs:   the_nFileNo     The number of the file.
' Outputs:  out_sLine       The line from the current position in the file.
' Return:   True if there is more data.
Public Function LineInputUTF8(ByVal the_nFileNo As Integer, ByRef out_sLine As String) As Boolean

    Dim bytValue            As Byte
    Dim abytLine()          As Byte
    Dim nStartOfLinePos     As Long
    Dim nEndOfLinePos       As Long
    Dim nStartOfNextLine    As Long
    Dim nLineLen            As Long

    ' Save the current file position as the beginning of the line, and cache this value.
    nStartOfLinePos = Seek(the_nFileNo)

    ' Retrieves the first byte from the current position.
    Get #the_nFileNo, , bytValue

    ' Loop until the end of file is encountered.
    Do Until EOF(the_nFileNo)

        ' Check whether this byte represents a carriage return or line feed character (indicating new line).
        If bytValue = 13 Or bytValue = 10 Then
            ' By this point, the current position is *after* the CR or LF character, so to get the position of the
            ' last byte in the line, we must go back two bytes.
            nEndOfLinePos = Seek(the_nFileNo) - 2

            ' If this is a carriage return, then we must check the next character.
            If bytValue = 13 Then
                Get #the_nFileNo, , bytValue
                ' Is this a line feed?
                If bytValue = 10 Then
                ' Yes. Assume that CR-LF counts as a single NewLine. So the start of the next line should skip over the line feed.
                    nStartOfNextLine = nEndOfLinePos + 3
                Else
                ' No. The start of the next line is the current position.
                    nStartOfNextLine = nEndOfLinePos + 2
                End If
            ElseIf bytValue = 10 Then
            ' If this is a line feed, then the start of the next line is the current position.
                nStartOfNextLine = nEndOfLinePos + 2
            End If

            ' Since we have processed all the bytes in the line, exit the loop.
            Exit Do
        End If

        ' Get the next byte.
        Get #the_nFileNo, , bytValue
    Loop

    ' Check to see if there was an end of line.
    If nEndOfLinePos = 0 Then
    ' No, this is the end of the file - so use all the remaining characters.
        nLineLen = Seek(the_nFileNo) - nStartOfLinePos - 1
    Else
    ' Yes - so use all the characters up to the end of line position.
        nLineLen = nEndOfLinePos - nStartOfLinePos + 1
    End If

    ' Is this line empty?
    If nLineLen = 0 Then
    ' Yes - just return an empty string.
        out_sLine = vbNullString
    Else
    ' No - pull all the bytes from the beginning to the end of the line into a byte array, and then convert that from UTF-8 to a VB string.
        ReDim abytLine(1 To nLineLen)
        Get #the_nFileNo, nStartOfLinePos, abytLine()
        out_sLine = FromCPString(abytLine(), CP_UTF8)
    End If

    ' If there is a line afterwards, then move to the beginning of the line, and return True.
    If nStartOfNextLine > 0 Then
        Seek #the_nFileNo, nStartOfNextLine
        LineInputUTF8 = True
    End If

End Function

' Purpose:  Analogue of 'Open "fileName" For Input As #fileNo' - but also return what type of text this is via a Code Page value.
' Inputs:   the_sFileName
'           the_iFileNo
'           (the_nDesiredCodePage)  The code page that you want to use with this file.
'                                   If this value is set to the default, -1, this indicates that the code page will be ascertained from the file.
' Outputs:  out_nCodePage           There are only six valid values that are returned if <the_nDesiredCodePage> was set to -1.
'               CP_ACP        ANSI code page
'               CP_UTF8       UTF-8
'               CP_UTF16LE    UTF-16 Little Endian (VB and NT default string encoding)
'               CP_UTF16BE    UTF-16 Big Endian
'               CP_UTF32LE    UTF-32 Little Endian
'               CP_UTF32BE    UTF-32 Big Endian
'           (out_bContainedBOM)     If this was set to True, then the file started with a BOM (Byte Order Marker).
Public Sub OpenForInput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean)

    ' Note if we want to take account of every case, we should read in the first four bytes, and check for UTF-32 low and high endian BOMs, check
    ' the first three bytes for the UTF-8 BOM, and finally check the first two bytes for UTF-16 low and hight endian BOMs.
    Dim abytBOM(1 To 4)             As Byte
    Dim nCodePage                   As Long

    ' By default, there is no BOM.
    out_bContainedBOM = False

    Open the_sFilename For Binary Access Read As #the_iFileNo

    ' We are interested in -1 (ascertain code page), and then various UTF encodings.
    Select Case the_nDesiredCodePage
    Case -1, CP_UTF8, CP_UTF16_BE, CP_UTF16_LE, CP_UTF32_BE, CP_UTF32_LE

        ' Default code page.
        nCodePage = CP_ACP

        ' Pull in the first four bytes to determine the BOM (byte order marker).
        Get #the_iFileNo, , abytBOM()

        ' The following are the BOMs for text files:
        '
        ' FF FE         UTF-16, little endian
        ' FE FF         UTF-16, big endian
        ' EF BB BF      UTF-8
        ' FF FE 00 00   UTF-32, little endian
        ' 00 00 FE FF   UTF-32, big-endian
        '
        ' Work out the code page from this information.

        Select Case abytBOM(1)
        Case &HFF
            If abytBOM(2) = &HFE Then
                If abytBOM(3) = 0 And abytBOM(4) = 0 Then
                    nCodePage = CP_UTF32_LE
                Else
                    nCodePage = CP_UTF16_LE
                End If
            End If
        Case &HFE
            If abytBOM(2) = &HFF Then
                nCodePage = CP_UTF16_BE
            End If
        Case &HEF
            If abytBOM(2) = &HBB And abytBOM(3) = &HBF Then
                nCodePage = CP_UTF8
            End If
        Case &H0
            If abytBOM(2) = &H0 And abytBOM(3) = &HFE And abytBOM(4) = &HFF Then
                nCodePage = CP_UTF32_BE
            End If
        End Select

        ' Did we match any BOMs?
        If nCodePage = CP_ACP Then
        ' No - we are still defaulting to the ANSI code page.
            ' Special check for UTF-8. The BOM is not specified in the standard for UTF-8, but according to Wikipedia (which is always right :-) ),
            ' only Microsoft includes this marker at the beginning of files.
            If FileBytesAreUTF8(the_iFileNo) Then
                out_nCodePage = CP_UTF8
            Else
                out_nCodePage = CP_ACP
            End If
        Else
        ' Yes - we have worked out the code page from the BOM.
            ' If no code page was suggested, we now return the code page we found.
            If the_nDesiredCodePage = -1 Then
                out_nCodePage = nCodePage
            End If

            ' Inform the caller that a BOM was found.
            out_bContainedBOM = True
        End If

        ' Reset the file pointer to the beginning of the file data.
        If out_bContainedBOM Then
            ' Note that if the code page found was one of the two UTF-32 values, then we are already in the correct position.
            ' Otherwise, we have to move to just after the end of the BOM.
            Select Case nCodePage
            Case CP_UTF16_BE, CP_UTF16_LE
                Seek #the_iFileNo, 3
            Case CP_UTF8
                Seek #the_iFileNo, 4
            End Select
        Else
            ' There is no BOM, so simply go the beginning of the file.
            Seek #the_iFileNo, 1
        End If

    Case Else
        out_nCodePage = the_nDesiredCodePage
    End Select

End Sub

' Purpose:  Analogue of 'Open "fileName" For Append As #fileNo'
Public Sub OpenForAppend(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Open the file and move to the end of the file.
    Open the_sFilename For Binary Access Write As #the_iFileNo
    Seek the_iFileNo, LOF(the_iFileNo) + 1

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of 'Open "fileName" For Output As #fileNo'
Public Sub OpenForOutput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Ensure we overwrite the file by deleting it ...
    On Error Resume Next
    Kill the_sFilename
    On Error GoTo 0

    ' ... before creating it.
    Open the_sFilename For Binary Access Write As #the_iFileNo

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of the 'Print #fileNo, value' statement. But only one value allowed.
'           Setting <the_bAppendNewLine> = False is analagous to 'Print #fileNo, value;'.
Public Sub Print_(ByVal the_iFileNo As Integer, ByRef the_sValue As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bAppendNewLine As Boolean = True)

    Const kbytNull                  As Byte = 0
    Const kbytCarriageReturn        As Byte = 13
    Const kbytNewLine               As Byte = 10

    Put #the_iFileNo, , ToCPString(the_sValue, the_nCodePage)

    If the_bAppendNewLine Then
        Select Case the_nCodePage
        Case CP_UTF16_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF16_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
        Case CP_UTF32_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF32_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
        Case Else
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNewLine
        End Select
    End If

End Sub

Public Sub PutContents(ByRef the_sFilename As String, ByRef the_sFileContents As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional the_bPrefixWithBOM As Boolean)

    Dim iFileNo                     As Integer

    iFileNo = FreeFile
    OpenForOutput the_sFilename, iFileNo, the_nCodePage, the_bPrefixWithBOM
    Print_ iFileNo, the_sFileContents, the_nCodePage, False
    Close iFileNo

End Sub

' Purpose:  Converts a VB string (UTF-16) to UTF8 - as a binary array.
Private Function ToCPString(ByRef the_sValue As String, ByVal the_nCodePage As Long) As Byte()

    Dim abytOutput()                As Byte
    Dim nValueLen                   As Long
    Dim nOutputByteLen              As Long

    If the_nCodePage = CP_UTF16_LE Then
        ToCPString = the_sValue
    Else

        ' Cache the input length.
        nValueLen = Len(the_sValue)

        ' See how big the output buffer will be.
        nOutputByteLen = WideCharToMultiByte(the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, 0&, 0&, 0&, 0&)

        If nOutputByteLen > 0 Then
            ' Resize output byte array to the size of the UTF-8 string.
            ReDim abytOutput(1 To nOutputByteLen)

            ' Make this API call again, this time giving a pointer to the output byte array.
            WideCharToMultiByte the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, VarPtr(abytOutput(1)), nOutputByteLen, 0&, 0&
        End If

        ' Return the array.
        ToCPString = abytOutput()

    End If

End Function

Private Sub WriteBOM(ByVal the_iFileNo As Integer, ByVal the_nCodePage As Long)

    ' FF FE         UTF-16, little endian
    ' FE FF         UTF-16, big endian
    ' EF BB BF      UTF-8
    ' FF FE 00 00   UTF-32, little endian
    ' 00 00 FE FF   UTF-32, big-endian

    Select Case the_nCodePage
    Case CP_UTF8
        Put #the_iFileNo, , CByte(&HEF)
        Put #the_iFileNo, , CByte(&HBB)
        Put #the_iFileNo, , CByte(&HBF)
    Case CP_UTF16_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
    Case CP_UTF16_BE
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    Case CP_UTF32_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
    Case CP_UTF32_BE
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    End Select

End Sub







Attribute VB_Name = "Version11"
Option Explicit

Sub ProtWSVersion11(ByRef ws As Worksheet, Blattschutzpasswort As String, ByRef wert As Werte)

'  ws.Protect Blattschutzpasswort, _
'    IIf(UCase(wert.ObjekteSch|fffd|tzen) = "JA", True, False), _
'    IIf(UCase(wert.InhalteSch|fffd|tzen) = "JA", True, False), _
'    IIf(UCase(wert.SzenariosSch|fffd|tzen) = "JA", True, False), _
'    False, _
'    IIf(UCase(wert.BSZellenFormatieren) = "JA", True, False), _
'    IIf(UCase(wert.BSSpaltenFormatieren) = "JA", True, False), _
'    IIf(UCase(wert.BSZeilenFormatieren) = "JA", True, False), _
'    IIf(UCase(wert.BSSpaltenEinf|fffd|gen) = "JA", True, False), _
'    IIf(UCase(wert.BSZeilenEinf|fffd|gen) = "JA", True, False), _
'    IIf(UCase(wert.BSHyperlinksEinf|fffd|gen) = "JA", True, False), _
'    IIf(UCase(wert.BSSpaltenL|fffd|schen) = "JA", True, False), _
'    IIf(UCase(wert.BSZeilenL|fffd|schen) = "JA", True, False), _
'    IIf(UCase(wert.BSSortieren) = "JA", True, False), _
'    IIf(UCase(wert.BSAutofilterVerwenden) = "JA", True, False), _
'    IIf(UCase(wert.BSPivotTableBerichteVerwenden) = "JA", True, False)
    
  ws.Protect Blattschutzpasswort, _
    IIf(IsYes(wert.ObjekteSch|fffd|tzen), True, False), _
    IIf(IsYes(wert.InhalteSch|fffd|tzen), True, False), _
    IIf(IsYes(wert.SzenariosSch|fffd|tzen), True, False), _
    False, _
    IIf(IsYes(wert.BSZellenFormatieren), True, False), _
    IIf(IsYes(wert.BSSpaltenFormatieren), True, False), _
    IIf(IsYes(wert.BSZeilenFormatieren), True, False), _
    IIf(IsYes(wert.BSSpaltenEinf|fffd|gen), True, False), _
    IIf(IsYes(wert.BSZeilenEinf|fffd|gen), True, False), _
    IIf(IsYes(wert.BSHyperlinksEinf|fffd|gen), True, False), _
    IIf(IsYes(wert.BSSpaltenL|fffd|schen), True, False), _
    IIf(IsYes(wert.BSZeilenL|fffd|schen), True, False), _
    IIf(IsYes(wert.BSSortieren), True, False), _
    IIf(IsYes(wert.BSAutofilterVerwenden), True, False), _
    IIf(IsYes(wert.BSPivotTableBerichteVerwenden), True, False)


End Sub

Attribute VB_Name = "Werte"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Inp As String
Public Outp As String
Public Lesepasswort As String
Public Schreibpasswort As String
Public Blattschutzpasswort As String
Public ObjekteSch|fffd|tzen As String
Public InhalteSch|fffd|tzen As String
Public SzenariosSch|fffd|tzen As String
Public Arbeitsmappenschutzpasswort As String
Public AufbauSch|fffd|tzen As String
Public FensterSch|fffd|tzen As String
Public Freigabeschutzpasswort As String
Public Codeschutzpasswort As String
Public Formelzellensch|fffd|tzen As String
Public NichtFormelzellenEntsch|fffd|tzen As String
Public ButtonProtect As String
Public ButtonSpeichern As String
Public ButtonDrucken As String
Public SimpleProtect As String
Public Selektionsschutz As String
Public ExeFileLoad As String
Public DruckenVorSchlie|fffd|en As String


Public BSZellenFormatieren As String
Public BSSpaltenFormatieren As String
Public BSZeilenFormatieren As String
Public BSSpaltenEinf|fffd|gen As String
Public BSZeilenEinf|fffd|gen As String
Public BSHyperlinksEinf|fffd|gen As String
Public BSSpaltenL|fffd|schen As String
Public BSZeilenL|fffd|schen As String
Public BSSortieren As String
Public BSAutofilterVerwenden As String
Public BSPivotTableBerichteVerwenden As String


Public Wiederholungsbereich As String
Public Wasserzeichen As String
Public ErstellerPfadDatum As String
Public Copyrightvermerk As String

Sub PrintStatus(ByRef t As String)
  't = t + "--- Werte Start ---" & vbCrLf
'  t = t + FMT0("CWerte_1") & vbCrLf
  
  't = t + "Eingabedatei: '" & Inp & "'" & vbCrLf
  t = t + FMT1("CWerte_2", Inp) & vbCrLf
  't = t + "Ausgabedatei: '" & Outp & "'" & vbCrLf
  t = t + FMT1("CWerte_3", Outp) & vbCrLf & vbCrLf
  't = t + "Lesepasswort: '" & IIf(Lesepasswort <> "", "****", "") & "'" & vbCrLf
  t = t + FMT1("CWerte_4", IIf(Lesepasswort <> "", "****", "")) & "      "
  't = t + "Schreibpasswort: '" & IIf(Schreibpasswort <> "", "****", "") & "'" & vbCrLf
  t = t + FMT1("CWerte_5", IIf(Schreibpasswort <> "", "****", "")) & vbCrLf
  't = t + "Blattschutzpasswort: '" & IIf(Blattschutzpasswort <> "", "****", "") & "'" & vbCrLf
  t = t + FMT1("CWerte_6", IIf(Blattschutzpasswort <> "", "****", "")) & vbCrLf
  't = t + "ObjekteSch|fffd|tzen: '" & ObjekteSch|fffd|tzen & "'" & vbCrLf
  t = t + "  " & FMT1("CWerte_7", ObjekteSch|fffd|tzen) & "      "
  't = t + "InhalteSch|fffd|tzen: '" & InhalteSch|fffd|tzen & "'" & vbCrLf
  t = t + FMT1("CWerte_8", InhalteSch|fffd|tzen) & "      "
  't = t + "SzenariosSch|fffd|tzen: '" & SzenariosSch|fffd|tzen & "'" & vbCrLf
  t = t + FMT1("CWerte_9", SzenariosSch|fffd|tzen) & vbCrLf
  
  't = t + "Formelzellensch|fffd|tzen: '" & Formelzellensch|fffd|tzen & "'" & vbCrLf
  t = t + "  " & FMT1("CWerte_15", Formelzellensch|fffd|tzen) & "      "
  't = t + "NichtFormelzellenEntsch|fffd|tzen: '" & NichtFormelzellenEntsch|fffd|tzen & "'" & vbCrLf
  t = t + FMT1("CWerte_16", NichtFormelzellenEntsch|fffd|tzen) & vbCrLf
  
  't = t + "Blattschutz:" & vbCrLf
'  t = t + FMT0("CWerte_28") & vbCrLf
  't = t + "  Zellen formatieren: '" & BSZellenFormatieren & "'" & vbCrLf
  t = t + FMT1("CWerte_29", BSZellenFormatieren) & "   "
  't = t + "  Spalten formatieren: '" & BSSpaltenFormatieren & "'" & vbCrLf
  t = t + FMT1("CWerte_30", BSSpaltenFormatieren) & "   "
  't = t + "  Zeilen formatieren: '" & BSZeilenFormatieren & "'" & vbCrLf
  t = t + FMT1("CWerte_31", BSZeilenFormatieren) & vbCrLf
  't = t + "  Spalten einf|fffd|gen: '" & BSSpaltenEinf|fffd|gen & "'" & vbCrLf
  t = t + FMT1("CWerte_32", BSSpaltenEinf|fffd|gen) & "   "
  't = t + "  Zeilen einf|fffd|gen: '" & BSZeilenEinf|fffd|gen & "'" & vbCrLf
  t = t + FMT1("CWerte_33", BSZeilenEinf|fffd|gen) & "   "
  't = t + "  Hyperlinks einf|fffd|gen: '" & BSHyperlinksEinf|fffd|gen & "'" & vbCrLf
  t = t + FMT1("CWerte_34", BSHyperlinksEinf|fffd|gen) & vbCrLf
  't = t + "  Spalten l|fffd|schen: '" & BSSpaltenL|fffd|schen & "'" & vbCrLf
  t = t + FMT1("CWerte_35", BSSpaltenL|fffd|schen) & "   "
  't = t + "  Zeilen l|fffd|schen: '" & BSZeilenL|fffd|schen & "'" & vbCrLf
  t = t + FMT1("CWerte_36", BSZeilenL|fffd|schen) & "   "
  't = t + "  Sortieren: '" & BSSortieren & "'" & vbCrLf
  t = t + FMT1("CWerte_37", BSSortieren) & vbCrLf
  't = t + "  Autofilter verwenden: '" & BSAutofilterVerwenden & "'" & vbCrLf
  t = t + FMT1("CWerte_38", BSAutofilterVerwenden) & "   "
  't = t + "  Pivottabellenberichte verwenden: '" & BSPivotTableBerichteVerwenden & "'" & vbCrLf
  t = t + FMT1("CWerte_39", BSPivotTableBerichteVerwenden) & vbCrLf
  
  
  
  't = t + "Arbeitsmappenschutzpasswort: '" & IIf(Arbeitsmappenschutzpasswort <> "", "****", "") & "'" & vbCrLf
  t = t + FMT1("CWerte_10", IIf(Arbeitsmappenschutzpasswort <> "", "****", "")) & "      "
  't = t + "AufbauSch|fffd|tzen: '" & AufbauSch|fffd|tzen & "'" & vbCrLf
  t = t + "  " & FMT1("CWerte_11", AufbauSch|fffd|tzen) & "      "
  't = t + "FensterSch|fffd|tzen: '" & FensterSch|fffd|tzen & "'" & vbCrLf
  t = t + FMT1("CWerte_12", FensterSch|fffd|tzen) & vbCrLf
  't = t + "Freigabeschutzpasswort: '" & IIf(Freigabeschutzpasswort <> "", "****", "") & "'" & vbCrLf
  t = t + FMT1("CWerte_13", IIf(Freigabeschutzpasswort <> "", "****", "")) & vbCrLf
  't = t + "Codeschutzpasswort: '" & IIf(Codeschutzpasswort <> "", "****", "") & "'" & vbCrLf
  t = t + FMT1("CWerte_14", IIf(Codeschutzpasswort <> "", "****", "")) & vbCrLf & vbCrLf
  't = t + "ButtonProtect: '" & ButtonProtect & "'" & vbCrLf
  t = t + FMT1("CWerte_17", ButtonProtect) & "      "
  't = t + "ButtonSpeichern: '" & ButtonSpeichern & "'" & vbCrLf
  t = t + FMT1("CWerte_18", ButtonSpeichern) & "      "
  't = t + "ButtonDrucken: '" & ButtonDrucken & "'" & vbCrLf
  t = t + FMT1("CWerte_19", ButtonDrucken) & vbCrLf
  't = t + "SimpleProtect: '" & SimpleProtect & "'" & vbCrLf
  t = t + FMT1("CWerte_20", SimpleProtect) & "      "
  't = t + "Selektionsschutz: '" & Selektionsschutz & "'" & vbCrLf
  t = t + FMT1("CWerte_21", Selektionsschutz) & "      "
  't = t + "ExeFileLoad: '" & ExeFileLoad & "'" & vbCrLf
  t = t + FMT1("CWerte_22", ExeFileLoad) & vbCrLf
  't = t + "Wiederholungsbereich: '" & Wiederholungsbereich & "'" & vbCrLf
  t = t + FMT1("CWerte_23", Wiederholungsbereich) & "      "
  't = t + "Wasserzeichen: '" & Wasserzeichen & "'" & vbCrLf
  t = t + FMT1("CWerte_24", Wasserzeichen) & "      "
  't = t + "ErstellerPfadDatum: '" & ErstellerPfadDatum & "'" & vbCrLf
  t = t + FMT1("CWerte_25", ErstellerPfadDatum) & "      "
  't = t + "Copyrightvermerk: '" & Copyrightvermerk & "'" & vbCrLf
  t = t + FMT1("CWerte_26", Copyrightvermerk) & vbCrLf
  't = t + "DruckenVorSchlie|fffd|en: '" & DruckenVorSchlie|fffd|en & "'" & vbCrLf
  t = t + FMT1("CWerte_27", DruckenVorSchlie|fffd|en) & vbCrLf & vbCrLf
  
  't = t + "--- Werte Ende ---" & vbCrLf
'  t = t + FMT0("CWerte_40") & vbCrLf

End Sub

' InQuest injected base64 decoded content
' KnjX
' szY^
' -zY^

INQUEST-PP=macro
