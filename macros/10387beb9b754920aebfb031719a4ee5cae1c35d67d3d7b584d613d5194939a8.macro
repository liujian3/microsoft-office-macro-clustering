Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "basAdmin"
Option Explicit

Private Const Const_DST_ADMINISTRATOR_USERNAME As String = "User" ' ACZ "anton.coetzee"
Private Const Const_BANNER_WIDTH As Integer = 120

Sub ExportMacroProjectContents()
    Dim strexportfolder As String, strtextfile As String
    Dim fso As FileSystemObject, fil As File, tstream As TextStream
On Error GoTo Err_ExportMacroProjectContents
 
    ' create export folder if it does not exist, else delete existing files
    Set fso = New FileSystemObject
    strexportfolder = fso.BuildPath(Application.MacroContainer.Path, "export")
    If Not fso.FolderExists(strexportfolder) Then
        fso.CreateFolder (strexportfolder)
    Else
        For Each fil In fso.GetFolder(strexportfolder).Files
            fil.Delete (True)
        Next fil
    End If
 
    ' export the form and code components
    Call ExportComponents(strexportfolder)
    
    ' create the file that will contain the other exported text
    strtextfile = fso.BuildPath(strexportfolder, fso.GetBaseName(Application.MacroContainer.Name) & ".txt")
    Set tstream = fso.CreateTextFile(strtextfile)
    
    ' Export the Ribbon XML customisation
    tstream.WriteLine String(Const_BANNER_WIDTH, "/")
    tstream.WriteLine "Custom UI XML:"
    tstream.WriteLine GetCustomUIXML
        
    ' Also dump the document bookmark and traceability configuration
    tstream.WriteLine String(Const_BANNER_WIDTH, "/")
    tstream.Write Dst.BookmarkConfig.ConfigAsText
    tstream.WriteLine String(Const_BANNER_WIDTH, "/")
    tstream.Write Dst.TrcConfig.ConfigAsText
  
Exit_ExportMacroProjectContents:
    If Not tstream Is Nothing Then tstream.Close
    Exit Sub
    
Err_ExportMacroProjectContents:
    MsgBox Err.Number & " " & Err.Description & " in ExportMacroProjectContents()"
    Resume Exit_ExportMacroProjectContents

End Sub

Sub ExportComponents(ByVal strexportfolder As String)
    Dim vbaproject As VBProject, vbcomp As VBComponent, strsuffix As String
    Dim fso As FileSystemObject
On Error GoTo Err_ExportComponents
 
    Set fso = New FileSystemObject
    
    ' Get the VBA project and loop through all the components (modules, forms, etc) in the VBA project and extract the info
    Set vbaproject = Application.ActiveDocument.VBProject
    For Each vbcomp In vbaproject.VBComponents
        strsuffix = vbNullString
        Select Case vbcomp.Type
            Case vbext_ct_MSForm
                strsuffix = ".frm"
                
            Case vbext_ct_StdModule
                strsuffix = ".bas"
                
            Case vbext_ct_ClassModule, vbext_ct_Document
                strsuffix = ".cls"
            
            Case Else
                MsgBox "Don't know how to export components of type '" & vbcomp.Type & "'", vbExclamation
        End Select
        
        If strsuffix <> vbNullString Then
            vbcomp.Export fso.BuildPath(strexportfolder, vbcomp.Name) & strsuffix
        End If
    Next
    
Exit_ExportComponents:
    Exit Sub
    
Err_ExportComponents:
    MsgBox Err.Number & " " & Err.Description & " in ExportComponents()"
    Resume Exit_ExportComponents
End Sub

Private Function GetCustomUIXML() As String
    Dim fso As FileSystemObject, fil As File, strunzipfolder As String, strsourcefile As String, strcopyfile As String, strtemp As String
    Dim shl As Shell
    Dim xmldoc As MSXML2.DOMDocument60
    
    Set fso = New FileSystemObject
    
    ' copy the sourcefile as it can't be unzipped if it's open
    strsourcefile = fso.BuildPath(Application.MacroContainer.Path, Application.MacroContainer.Name)
    strcopyfile = fso.BuildPath(Application.MacroContainer.Path, "temp.zip")
    fso.CopyFile strsourcefile, strcopyfile
    
    ' create the folder location where the files will be unzipped to
    strunzipfolder = fso.BuildPath(Application.MacroContainer.Path, "Unzipped")
    If fso.FolderExists(strunzipfolder) Then
        fso.DeleteFolder strunzipfolder
    End If
    fso.CreateFolder strunzipfolder

    ' copy the .dotm file as seperate files into the unzip folder - this "unzips" them
    Set shl = New Shell
    shl.NameSpace(strunzipfolder).CopyHere shl.NameSpace(strcopyfile).Items
    
    'ACZ see http://www.databasejournal.com/features/msaccess/article.php/3835766/Working-with-Compressed-zipped-folders-in-MS-Access.htm
    ' can browse ZIP file and only extract the part we need
    
    ' extract the customUI XML content
    Set xmldoc = New MSXML2.DOMDocument60
    GetCustomUIXML = "Error loading 'customUI' XML"
    strtemp = fso.BuildPath(strunzipfolder, "customUI")
    For Each fil In fso.GetFolder(strtemp).Files
        If fil.Name Like "customUI*.xml" Then
            If xmldoc.Load(fil.Path) Then
                GetCustomUIXML = xmldoc.XML
                Exit For
            End If
        End If
    Next fil

    ' clean up the temporary data
    fso.DeleteFile strcopyfile
    fso.DeleteFolder strunzipfolder
    
End Function

Function IsDstAdministrator() As Boolean
    IsDstAdministrator = (Environ("USERNAME") Like Const_DST_ADMINISTRATOR_USERNAME)
End Function
Attribute VB_Name = "basArrDicUtilities"
Option Explicit

Private Const Const_DST_SPLIT_TOKEN = "-={DST_SPLIT_TOKEN}=-"

'==================================================================================================================================
' Source: http://www.cpearson.com/excel/CollectionsAndDictionaries.htm
'==================================================================================================================================

Sub ArrayToDictionary(ByRef varsrcarray As Variant, ByRef dicdest As Scripting.Dictionary, Optional ByVal blappend As Boolean = False, Optional ByVal varvalue As Variant)
    Dim idx As Integer, strkey As String
    
    If Not blappend Then dicdest.RemoveAll
    SortArray varsrcarray, 0, UBound(varsrcarray)
    For idx = 0 To UBound(varsrcarray)
        strkey = Trim(varsrcarray(idx))
        If strkey <> vbNullString And Not dicdest.Exists(strkey) Then dicdest.Add strkey, IIf(IsMissing(varvalue), strkey, varvalue)
    Next idx

End Sub
    
Function DictionaryToArray(ByRef dicsrc As Scripting.Dictionary) As Variant
    Dim idx As Integer, vardestarray As Variant
    
    If dicsrc.Count > 0 Then
        ReDim vardestarray(0 To dicsrc.Count - 1)
        For idx = 0 To dicsrc.Count - 1
            vardestarray(idx) = Trim(dicsrc.Keys(idx))
        Next idx
    Else
        ReDim vardestarray(0)
    End If
    DictionaryToArray = vardestarray
    
End Function
    
Sub SortArray(ByRef arr As Variant, ByVal lnglow As Long, ByVal lnghigh As Long, Optional ByVal CompareMode As VbCompareMethod = vbTextCompare)
  Dim arrpivot As Variant, arrtempswap As Variant
  Dim lngtemplow As Long, lngtemphigh  As Long

    lngtemplow = lnglow
    lngtemphigh = lnghigh

    If lnghigh < 0 Then
        Exit Sub
    End If
    arrpivot = Trim(arr((lnglow + lnghigh) \ 2))

    While (lngtemplow <= lngtemphigh)
    
       While StrComp(Trim(arr(lngtemplow)), arrpivot, CompareMode) = -1 And lngtemplow < lnghigh
          lngtemplow = lngtemplow + 1
       Wend
    
       While StrComp(arrpivot, Trim(arr(lngtemphigh)), CompareMode) = -1 And lngtemphigh > lnglow
          lngtemphigh = lngtemphigh - 1
       Wend
    
       If lngtemplow <= lngtemphigh Then
          arrtempswap = arr(lngtemplow)
          arr(lngtemplow) = arr(lngtemphigh)
          arr(lngtemphigh) = arrtempswap
          lngtemplow = lngtemplow + 1
          lngtemphigh = lngtemphigh - 1
       End If
    Wend

    If lnglow < lngtemphigh Then SortArray arr, lnglow, lngtemphigh
    If lngtemplow < lnghigh Then SortArray arr, lngtemplow, lnghigh

End Sub

Function SortDictionary(ByRef dic As Scripting.Dictionary, Optional ByVal CompareMode As VbCompareMethod = vbTextCompare) As Scripting.Dictionary
    Dim idx As Integer
    Dim arrdic As Variant
    Dim dictemp As Scripting.Dictionary
    Dim strkey As String
    
    If dic Is Nothing Then
        Exit Function
    ElseIf dic.Count = 0 Or dic.Count = 1 Then
        Set SortDictionary = dic
        Exit Function
    End If

    Set dictemp = New Scripting.Dictionary

    ' redim the array to the number of elements in the dictionary and load the array with the keys
    arrdic = DictionaryToArray(dic)
    
    ' sort the key names and rebuild a new dictionary
    SortArray arrdic, LBound(arrdic), UBound(arrdic), CompareMode
    For idx = 0 To dic.Count - 1
        strkey = arrdic(idx)
        dictemp.Add strkey, dic.Item(strkey)
    Next idx
    
    ' point to the new dictionary
    Set SortDictionary = dictemp
    
End Function

Public Function SortDictionaryByValues(ByRef dic As Scripting.Dictionary, Optional ByVal CompareMode As VbCompareMethod = vbTextCompare) As Scripting.Dictionary
    Dim idx As Long
    Dim strkey As String
    Dim varitem As Variant
    Dim arrdic() As Variant
    Dim arrtypes() As VbVarType
    Dim arrsplit As Variant
    Dim dictemp As Scripting.Dictionary
    
    If dic Is Nothing Then
        Exit Function
    ElseIf dic.Count = 0 Or dic.Count = 1 Then
        Set SortDictionaryByValues = dic
        Exit Function
    End If
    
    Set dictemp = New Scripting.Dictionary
    
    ' set array sizes to input size
    ReDim arrdic(0 To dic.Count - 1) ' stores string of item, split token and key
    ReDim arrtypes(0 To dic.Count - 1) ' stores type of each item

    For idx = 0 To dic.Count - 1
        ' function won't work with objects, arrays or user-defined types
        If IsObject(dic.Items(idx)) = True Or IsArray(dic.Items(idx)) = True Or vartype(dic.Items(idx)) = vbUserDefinedType Then
            MsgBox "The SortDictionaryByVaues() function only works with simple built-in data types - contact the DST owner!", vbExclamation
            Exit Function
        End If
        arrdic(idx) = dic.Items(idx) & Const_DST_SPLIT_TOKEN & dic.Keys(idx)
        arrtypes(idx) = vartype(dic.Items(idx))
    Next idx
    
    ' sort the array - this effectively sorts it on the dictionary values
    SortArray arrdic, LBound(arrdic), UBound(arrdic), CompareMode
    
    ' split each entry in the array on the split token to give a value and key
    For idx = LBound(arrdic) To UBound(arrdic)
        arrsplit = Split(arrdic(idx), Const_DST_SPLIT_TOKEN)
        strkey = arrsplit(UBound(arrsplit))
        varitem = arrsplit(LBound(arrsplit))
        Select Case arrtypes(idx)
            Case vbBoolean
                varitem = CBool(varitem)
            Case vbByte
                varitem = CByte(varitem)
            Case vbCurrency
                varitem = CCur(varitem)
            Case vbDate
                varitem = CDate(varitem)
            Case vbDecimal
                varitem = CDec(varitem)
            Case vbDouble
                varitem = CDbl(varitem)
            Case vbInteger
                varitem = CInt(varitem)
            Case vbLong
                varitem = CLng(varitem)
            Case vbSingle
                varitem = CSng(varitem)
            Case vbString
                varitem = CStr(varitem)
            Case Else
                varitem = varitem
        End Select
        dictemp.Add strkey, varitem
    Next idx
    
    Set SortDictionaryByValues = dictemp
End Function

Function PadSortDictionary(ByRef dicsrc As Scripting.Dictionary, ByVal blsort As Boolean, ByVal blpadnames As Boolean) As Scripting.Dictionary
    Dim dictemp As Scripting.Dictionary, dicpadsort As Scripting.Dictionary
    Dim intlongestname As Integer, idx As Integer, strkey As String
On Error GoTo Err_PadSortDictionary

    ' sort dictionary if requested
    If blsort Then
        Set dictemp = SortDictionary(dicsrc)
    Else
        Set dictemp = dicsrc
    End If
    
    ' get longest key names if padding is required
    If blpadnames Then
        ' determine length of longest key name
        For idx = 0 To dictemp.Count - 1
            strkey = dictemp.Keys(idx)
            If Len(strkey) > intlongestname Then
                intlongestname = Len(strkey)
            End If
        Next idx
    End If
    
    ' update final storage and pad names if required
    Set dicpadsort = New Scripting.Dictionary
    For idx = 0 To dictemp.Count - 1
        strkey = dictemp.Keys(idx)
        If blpadnames Then strkey = strkey & String(intlongestname - Len(strkey), " ") ' pad key names if required
        dicpadsort.Add strkey, dictemp.Items(idx)
    Next idx
    
    Set PadSortDictionary = dicpadsort
    
Exit_PadSortDictionary:
    Exit Function

Err_PadSortDictionary:
    MsgBox Err.Description & " in PadSortDictionary() of basArrDicUtilities"
    Resume Exit_PadSortDictionary
End Function

Function CompareDictionaries(ByRef dica As Scripting.Dictionary, ByRef dicb As Scripting.Dictionary) As Boolean
    '==================================================================================================================================
    ' Description: Compares the keys of the given dictionaries for equality
    '==================================================================================================================================
    Dim varitem As Variant
    If dica.Count = dicb.Count Then
        CompareDictionaries = True
        For Each varitem In dica
            If Not dicb.Exists(varitem) Then
                CompareDictionaries = False
                Exit For
            End If
        Next varitem
    Else
        CompareDictionaries = False
    End If
End Function

Function IsArrayAllocated(ByRef arr As Variant) As Boolean
    Dim lng As Long
    On Error Resume Next

    ' if Arr is not an array, return FALSE and get out.
    If IsArray(arr) = False Then
        IsArrayAllocated = False
        Exit Function
    End If

    ' Attempt to get the UBound of the array. If the array has not been allocated,
    ' an error will occur. Test Err.Number to see if an error occurred.
    lng = UBound(arr, 1)
    If (Err.Number = 0) Then
    ' Under some circumstances, if an array is not allocated, Err.Number will be 0. To acccomodate this case, we test
    ' whether LBound <= Ubound. If this is True, the array is allocated. Otherwise, the array is not allocated.
        If LBound(arr) <= UBound(arr) Then
            ' no error. array has been allocated.
            IsArrayAllocated = True
        Else
            IsArrayAllocated = False
        End If
    Else
        ' unallocated array
        IsArrayAllocated = False
    End If

End Function

Function GetDictionaryAsText(ByRef dic As Scripting.Dictionary, Optional ByVal blsort As Boolean = False, Optional ByVal blpadnames As Boolean = False, _
                             Optional ByVal strpad As String = "") As String
    Dim dicsorted As Scripting.Dictionary, idx As Long, strtext As String, strvalue As String
On Error GoTo Err_GetDictionaryAsText

    Set dicsorted = PadSortDictionary(dic, blsort, blpadnames)
    For idx = 0 To dicsorted.Count - 1
        Select Case TypeName(dicsorted.Items(idx))
            Case "cAbbreviation"
                strvalue = dicsorted.Items(idx).Definition
            Case Else
                strvalue = dicsorted.Items(idx) ' assumes values are printable
        End Select
        strtext = AddStatusText(strtext, strpad & dicsorted.Keys(idx) & ": " & strvalue)
    Next idx
    GetDictionaryAsText = strtext

Exit_GetDictionaryAsText:
    Exit Function

Err_GetDictionaryAsText:
    If Err.Number = 438 Then
        strvalue = "ERROR! Could not read dictionary value"
        Resume Next
    Else
        MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure GetDictionaryAsText, line " & Erl & "."
        Resume Exit_GetDictionaryAsText
    End If
End Function
Attribute VB_Name = "basBookmarks"
Option Explicit

' Maximum bookmark name length
Public Const Const_MAX_BOOKMARK_LENGTH As Integer = 39

' Unknown document type
Public Const Const_TEXT_UNKNOWN As String = "UNKNOWN"

' Portion of bookmark prefix for associated descriptions
Public Const Const_DESC_PREFIX As String = "desc"

' Character set for bookmark names
Public Const Const_BOOKMARK_CHARSET As String = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"

' Default configuratin file for the rename bookmark script
Public Const Const_REN_BM_CONFIG_FILE = "ren_bm.cfg"

Public Const Const_EXTERNAL_BOOKMARK_ID_TEXT As String = "[EXTERNAL]"

Function GetDataDicBookmarkTypeFromLayout(ByRef rng As Range, Optional ByRef strmessage As Variant) As String
    Dim strbooktype As String, strdescbooktype As String, strstatus As String, docinfo As cDocInfo
    
    strbooktype = vbNullString

    Set docinfo = Dst.Document(rng.Document.Fullname)
    
    ' check if selection is in a data dictionary section, this is usually in a table
    ' with columns 1 and 2 the Name and Description fields
    If IsRangeInTable(rng) = True Then
        With rng.Tables(1)
            If .Columns.Count >= 3 And .Columns.Count <= 7 Then
                If .Cell(1, 1).Range.Text Like "*Name*" And _
                   .Cell(1, 2).Range.Text Like "*Description*" Then
                    ' determine the bookmark type prefix
                    strbooktype = docinfo.Properties.TypeAbbr
                    If strbooktype = "DFS" Then
                        strbooktype = "dfs"
                    ElseIf strbooktype = "FRS" Then
                        strbooktype = "sys"
                    Else
                        strbooktype = "srs"
                    End If
                        
                    ' determine 'lit' or 'var' part of prefix
                    If .Columns.Count = 3 Then
                        ' this is a data dictionary 'lit' bookmark
                        strbooktype = strbooktype & "lit"
                    ElseIf .Columns.Count = 7 Then
                        ' this is a data dictionary 'var' bookmark
                        strbooktype = strbooktype & "var"
                        
                        ' check whether an associated description exists and whether the column is selected
                        strdescbooktype = Dst.BookmarkConfig.DescBookmarkFromName(strbooktype & "_") ' create a dummy bookmark name
                        If strdescbooktype <> vbNullString And rng.Cells(1).ColumnIndex = 2 Then
                            strbooktype = strdescbooktype
                        End If
                    Else
                        ' unknown table format, so assume not in a data dictionary area
                        strbooktype = vbNullString
                        strstatus = "Unknown Data Dictionary table format."
                    End If
                Else
                    strstatus = "Table header row should contain the text 'Name' and 'Description' in the first two columns."
                End If
            Else
                strstatus = "Data Dictionary tables must have between three and seven columns."
            End If
        End With
    Else
        strstatus = "Insertion point not in a table."
    End If
    
    ' return additional info if required
    If Not IsMissing(strmessage) Then
        strmessage = strstatus
    End If
    
    GetDataDicBookmarkTypeFromLayout = strbooktype
            
End Function

Function AddBookmark(ByRef rng As Range, ByVal strbookname As String, _
                     Optional ByVal blrename As Boolean = False, Optional ByVal blsuppressiotables As Boolean = False, Optional ByRef strmessage As Variant) As Boolean
    Dim strdatadicbooktype As String, strbooktype As String, strstatus As String
    Dim blnotify As Boolean
On Error GoTo Err_AddBookmark
    
    ' get the bookmark type
    strbooktype = Dst.BookmarkConfig.PrefixFromName(strbookname)
    
    ' check if the current selection is in a valid data dictionary area
    strdatadicbooktype = GetDataDicBookmarkTypeFromLayout(rng)
    If strdatadicbooktype <> vbNullString Then
        ' apply bookmark to the text in the entire cell
        Set rng = rng.Cells(1).Range
        rng.End = rng.End - 1
        rng.Text = Trim(rng.Text)
        
        ' check if this is a literal bookmark and add the '<< >>' symbols around the text
        If Dst.BookmarkConfig.IsLiteralPrefix(strbooktype) Then
            If Left(rng.Text, 1) <> Chr(171) Then
                ' strip out '<<' if user added these manually
                If Left(rng.Text, 2) = "<<" Then
                    rng.Text = Right(rng.Text, Len(rng.Text) - 2)
                End If
                rng.InsertBefore Chr(171)
            Else
                blnotify = True
            End If
            
            If Right(rng.Text, 1) <> Chr(187) Then
                ' strip out '>>' if user added these manually
                If Right(rng.Text, 2) = ">>" Then
                    rng.Text = Left(rng.Text, Len(rng.Text) - 2)
                End If
                rng.InsertAfter Chr(187)
            Else
                blnotify = True
            End If
            ' notify user if delimiters were added manually
            If blnotify And Not blrename Then MsgBox "Note that DST will automatically insert the literal delimiters << and >> around the text when the bookmark is applied for you.", vbInformation, "Literal Delimiters"
        End If
    End If
        
    strstatus = ApplyBookmark(rng, strbookname)
    If strstatus = vbNullString Then
        If blsuppressiotables Then Call AddBookmarksInputOutput(rng, strbookname, strbooktype)
        
        ' get the potential associated description bookmark name
        strbookname = Dst.BookmarkConfig.DescBookmarkFromName(strbookname)
        ' NOTE: When renaming a bookmark, the bookmarking of the associated description is controlled from the calling function.
        If strbookname <> vbNullString And blrename = False And strdatadicbooktype <> vbNullString Then
            ' for data dictionary bookmark types, apply the description bookmark to the text in the 2nd cell
            Set rng = rng.Rows(1).Cells(2).Range
            rng.End = rng.End - 1
            ' make sure any existing bookmark is deleted
            Call DeleteBookmark(rng, True)
            strstatus = ApplyBookmark(rng, strbookname)
        End If
    End If
    
Exit_AddBookmark:
    If strstatus = vbNullString Then
        AddBookmark = True
    Else
        AddBookmark = False
        If IsMissing(strmessage) Then
            MsgBox strstatus, vbExclamation, "Bookmark Error"
        Else
            strmessage = strstatus
        End If
    End If
    Exit Function
    
Err_AddBookmark:
    strstatus = Err.Number & " " & Err.Description & " in AddBookmark()"
    Resume Exit_AddBookmark

End Function

Function DeleteBookmark(ByRef rng As Range, Optional ByVal blquiet As Boolean = False) As Boolean
' Deletes the bookmark at the given range
    Dim docinfo As cDocInfo, bmark As Bookmark
    
    ' initialise the current selection
    If rng.Bookmarks.Count > 0 Then
        Set docinfo = Dst.Document(rng.Document.Fullname)
        Set bmark = rng.Bookmarks(1)
        If Not blquiet And docinfo.Bookmarks.IsExternal(bmark.Name) Then
            If MsgBox("The bookmark '" & bmark.Name & "' is an external bookmark - are you sure you want to delete it?", vbQuestion + vbYesNo, "Bookmark Deletion") = vbYes Then
                DeleteBookmark = True
            End If
        Else
            DeleteBookmark = True
        End If
        If DeleteBookmark Then docinfo.Bookmarks.Delete bmark.Name ' always use cDocInfo object to add/remove bookmarks
    Else
        If Not blquiet Then MsgBox "There is no bookmark in the selection.", vbExclamation, "Bookmark not deleted"
    End If

End Function

Function RenameBookmark(ByRef objdoc As Document, ByVal stroldbookmark As String, ByVal strnewbookmark As String, _
                        ByRef strmessage As String, Optional ByRef frm As Object) As Boolean
    Dim rng As Range, strfilename As String, fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    ' select the old bookmark before it's deleted
    ' point the range object somewhere
    Set rng = objdoc.Bookmarks(stroldbookmark).Range
    
    ' validate new bookmark name first
    strmessage = ValidateBookmarkName(rng, strnewbookmark, True, True)
    If strmessage = vbNullString Then
        ' delete the old bookmark
        If DeleteBookmark(rng, True) Then
            ' if text must match bookmark name, clear range so the add bookmark function can modify the text
            If Dst.BookmarkConfig.Prefix(Dst.BookmarkConfig.PrefixFromName(strnewbookmark)).TextMatch = enumTextMatchFull Then
                rng.Text = vbNullString
            End If
            
            ' apply the new bookmark
            If AddBookmark(rng, strnewbookmark, True, , strmessage) Then
                RenameBookmark = True
                
                ' update references to the old bookmark so they reference the new bookmark
                Call RenameRefs(objdoc, stroldbookmark, strnewbookmark)
                
                ' generate the config file for the bookmark rename perl script
                If Not frm Is Nothing Then
                    If frm.chkAddToRenBmConfigFile Then
                        ' use default
                        strfilename = Application.MacroContainer.Path & "\" & Const_REN_BM_CONFIG_FILE
                        If frm.txtRenBmConfigFile = vbNullString Then
                            frm.txtRenBmConfigFile = strfilename
                        Else
                            If Not fso.FolderExists(fso.GetParentFolderName(frm.txtRenBmConfigFile)) Then
                                frm.txtRenBmConfigFile = strfilename
                                MsgBox "The folder '" & fso.GetParentFolderName(frm.txtRenBmConfigFile) & "' could not be found, using default location.", vbExclamation
                            End If
                        End If
                        If Not WriteRenameBmConfigFile(frm.txtRenBmConfigFile, stroldbookmark, strnewbookmark) Then
                            MsgBox "An error occurred trying to write to the configuration file '" & frm.txtRenBmConfigFile & "'.", vbExclamation
                        End If
                    End If
                End If
            End If
        End If
    End If
    
End Function

Function AddBookmarkAuto(ByRef rng As Range, ByVal strautoaddbooktype As String) As String
' Automatically bookmarks the word under the cursor if it's a known type, else the bookmark management form is opened
    Dim strbookname As String, strbookmarkprefix As String, strdocid As String
    
    ' set range to word surrounding current cursor position
    Call SetBookmarkTextRange(rng)
    strbookname = rng.Text
            
    ' first check if text already includes a valid prefix and if so, use it
    strbookmarkprefix = Dst.BookmarkConfig.PrefixFromName(strbookname)
    If strbookmarkprefix <> vbNullString Then
        strautoaddbooktype = strbookmarkprefix
    End If
    
    If strautoaddbooktype <> vbNullString Then
        ' strip off possible prefix and DOCID or just DOCID prefix first
        strdocid = Dst.Document(rng.Document.Fullname).Properties.DocID & "_"
        strbookmarkprefix = strautoaddbooktype & "_"
        If InStr(1, strbookname, strbookmarkprefix, vbTextCompare) = 1 Then ' in case prefix starts with uppercase
            strbookname = Replace(strbookname, strbookmarkprefix, vbNullString, 1, 1, vbTextCompare)
        End If
        If InStr(1, strbookname, strdocid) = 1 Then
            strbookname = Replace(strbookname, strdocid, vbNullString, 1, 1)
        End If
        
        ' now add prefix and DOCID
        strbookname = strbookmarkprefix & strdocid & strbookname
        
        ' update the bookmark text
        rng.Text = strbookname
        rng.Select
    
        If Dst.BookmarkConfig.Prefix(strautoaddbooktype).TextMatch <> enumTextMatchFull Then
            MsgBox "Bookmarks with prefixes '" & strautoaddbooktype & "' are not defined for auto-bookmarking, use the DST Bookmark Management Form to insert bookmarks.", vbExclamation, "Auto Bookmark Not Available"
            Call OpenUserForm("frmBookmarkMgmt", rng.Document)
        Else
            ' validate the bookmark name and apply it if OK
            If AddBookmark(rng, strbookname) Then
                AddBookmarkAuto = strbookname
            End If
        End If
    Else
        MsgBox "Don't know which bookmark prefix applies, use the DST Bookmark Management Form to insert bookmarks.", vbExclamation, "Bookmark Prefix Unknown"
        Call OpenUserForm("frmBookmarkMgmt", rng.Document)
    End If
        
End Function

Function AddBookmarkAutoAll(ByRef objdoc As Document, ByRef frmtext As Object, ByVal strautoaddbooktype As String) As Boolean
' Automatically bookmarks all the items of the specified type
    Dim strbookname As String, blOK As Boolean, rngdoc As Range, slct As SelectionType, strmessage As String
    Dim lngcount As Long, bladdbookmark As Boolean
    
    blOK = True
    lngcount = 0
    
    ' check if the bookmark type exists
    If Dst.BookmarkConfig.Prefixes.Exists(strautoaddbooktype) Then
        ' check if the bookmark name must match the text
        If Dst.BookmarkConfig.Prefix(strautoaddbooktype).TextMatch = enumTextMatchFull Then
            ' search through the given document for items beginning with the given bookmark type
            Set rngdoc = objdoc.content ' only work in main text story
            With rngdoc.Find
                .ClearFormatting
                .Text = strautoaddbooktype & "_" ' so we exclude bookmark types that start with the same string
                .Forward = True
                .Wrap = wdFindStop
                .MatchCase = True
                .MatchPrefix = True
            End With
            
            AddBookmarkAutoAll = True
            frmtext.UpdateProgressText "Searching for unbookmarked text starting with bookmark prefix '" & strautoaddbooktype & "'..."
            
            ' find the items to be bookmarked
            Do While (rngdoc.Find.Execute)
                ' point to entire word
                Call SetBookmarkTextRange(rngdoc)
                strbookname = rngdoc.Text
                
                ' ignore the table of contents sections
                If InTocSection(rngdoc) = False Then
                    ' if the selection is not already bookmarked, continue
                    If rngdoc.Bookmarks.Count = 0 Then
                        bladdbookmark = False
                        ' if the selection is not a reference or if it is but it does not refer to an existing
                        ' bookmark, then apply the bookmark
                        If RangeHasFields(rngdoc, slct) = 0 Then
                            bladdbookmark = True
                        ElseIf GetFieldResult(rngdoc) <> vbNullString Then
                            If GetFieldResult(rngdoc) <> strbookname Then
                                bladdbookmark = True
                            End If
                        End If
                        
                        If bladdbookmark Then
                            ' bookmark the item
                            blOK = AddBookmark(rngdoc, strbookname, , , strmessage)
                            If blOK = True Then
                                frmtext.UpdateProgressText "  - Added bookmark '" & strbookname & "'"
                                lngcount = lngcount + 1
                            Else
                                frmtext.LogResult "ERROR - " & strmessage
                                AddBookmarkAutoAll = False
                            End If
                        End If
                    End If
                End If
                
                ' prepare for next item
                rngdoc.Collapse wdCollapseEnd
            Loop
            
            ' set the return status and unload the bookmark management form if it was open to force a reload of its data
            If lngcount > 0 Then
                Call UnloadUserForm(, "frmBookmarkMgmt", objdoc.Fullname)
                frmtext.UpdateProgressText lngcount & " bookmark(s) added." & vbCrLf
            ElseIf AddBookmarkAutoAll Then
                frmtext.UpdateProgressText "INFO - No unbookmarked text matching '" & strautoaddbooktype & "' found."
            End If
        Else
            frmtext.LogResult "ERROR - Unable to automatically bookmark items with the prefix '" & strautoaddbooktype & "' as the bookmark name does not have to match the bookmarked text."
        End If
    Else
        frmtext.LogResult "ERROR - The bookmark prefix '" & strautoaddbooktype & "' is unknown."
    End If
    
End Function

Private Sub AddBookmarksInputOutput(ByRef rng As Range, ByVal strbookname As String, ByVal strbooktype As String)
    Dim strbooksuffix As String, strbookprefixin As String, strbookprefixout As String, striobookname As String
    Dim rngio As Range, blinsertparagraph As Boolean, docinfo As cDocInfo
    
    ' when adding process bookmarks, automatically add the companion input and output bookmarks if they don't exist
    If strbooktype = "sysp" Or strbooktype = "srsp" Then
        Set docinfo = Dst.Document(rng.Document.Fullname)
        
        strbookprefixin = Replace(strbooktype, "p", "i", 1, 1) & "_"
        strbookprefixout = Replace(strbooktype, "p", "o", 1, 1) & "_"
        strbooksuffix = Dst.BookmarkConfig.SuffixFromName(strbookname)
        
        ' add input bookmark in previous paragraph and change to hidden text
        striobookname = strbookprefixin & strbooksuffix
        If Not docinfo.Bookmarks.All.Exists(striobookname) Then
            Set rngio = rng.Previous(wdParagraph)
            blinsertparagraph = True
            If rngio.Bookmarks.Count = 1 Then
                If rngio.Bookmarks(1).Name Like strbookprefixout & "*" Then
                    ' previous paragraph already has output bookmark, so add on same line
                    blinsertparagraph = False
                    rngio.MoveEnd wdCharacter, -1
                    rngio.Collapse wdCollapseEnd
                    rngio.InsertAfter " "
                    rngio.Collapse wdCollapseEnd
                End If
            End If
            
            If blinsertparagraph Then
                rngio.MoveEnd wdCharacter, -1
                rngio.InsertParagraphAfter
                rngio.Collapse wdCollapseEnd
            End If
            rngio.Text = "SuppressInputTable"
            docinfo.Bookmarks.Add striobookname, rngio ' always use cDocInfo object to add/remove bookmarks
            rngio.Font.Hidden = True
        End If
        
        ' add output bookmark at end of section and change to hidden text
        striobookname = strbookprefixout & strbooksuffix
        If Not docinfo.Bookmarks.All.Exists(striobookname) Then
            Set rngio = GetHeadingRangeExtendedFromRange(rng)
            Set rngio = rngio.Paragraphs(rngio.Paragraphs.Count).Range
            blinsertparagraph = True
            If rngio.Bookmarks.Count = 1 Then
                If rngio.Bookmarks(1).Name Like strbookprefixin & "*" Then
                    ' last paragraph already has input bookmark, so add on same line
                    Set rngio = rngio.Previous(wdParagraph) ' in fact we're going to insert a paragraph above the line, add the bookmark and
                    blinsertparagraph = False               ' then delete the paragraph marker again because we cannot insert anything if a
                End If                                      ' line already starts with a bookmark
            End If
            
            rngio.MoveEnd wdCharacter, -1
            rngio.InsertParagraphAfter
            rngio.Collapse wdCollapseEnd
            rngio.InsertAfter "SuppressOutputTable"
            docinfo.Bookmarks.Add striobookname, rngio ' always use cDocInfo object to add/remove bookmarks
            rngio.Font.Hidden = True
            If Not blinsertparagraph Then
                rngio.InsertAfter " "
                rngio.Collapse wdCollapseEnd
                rngio.Characters(1).Delete ' delete paragraph marker - thus joing lines again
            End If
        End If
    End If

End Sub

Private Function ApplyBookmark(ByRef rng As Range, ByVal strbookname As String) As String
    Dim strstyle As String, strbooktype As String, strstatus As String
On Error GoTo Err_ApplyBookmark
    
    ' check if the bookmark name is valid
    strstatus = ValidateBookmarkName(rng, strbookname)

    ' get the proposed bookmark type
    strbooktype = Dst.BookmarkConfig.PrefixFromName(strbookname)
    
    If strstatus = vbNullString Then
        Dst.Document(rng.Document.Fullname).Bookmarks.Add strbookname, rng ' always use cDocInfo object to add/remove bookmarks
        
        ' check if style to be applied exists
        strstyle = Dst.BookmarkConfig.Prefix(strbooktype).BookmarkStyle
        If StyleExists(rng.Document, strstyle, strstatus) = True Then
            rng.Style = strstyle
            
            ' restore the default style and insert a space
            rng.Collapse wdCollapseEnd
            rng.InsertAfter " "
            rng.Style = wdStyleDefaultParagraphFont
        End If
        
        rng.Collapse wdCollapseEnd
        rng.Select
    End If

Exit_ApplyBookmark:
    ApplyBookmark = strstatus
    Exit Function
    
Err_ApplyBookmark:
    strstatus = Err.Number & " " & Err.Description & " in ApplyBookmark()"
    Resume Exit_ApplyBookmark

End Function

Function ValidateBookmarkName(ByRef rng As Range, ByVal strbookname As String, _
                              Optional ByVal blautoinsert As Boolean = True, Optional ByVal blrename As Boolean = False) As String
    Dim strmessage As String, strmatch As String
On Error GoTo Err_ValidateBookmarkName
    
    '=========================================================================================================
    ' check if bookmark name is specified
    '=========================================================================================================
    If strbookname = vbNullString Then
        strmessage = "No bookmark name specified."
    End If
        
    '=========================================================================================================
    ' check if selection not already bookmarked, or if called as pre-validation for bookmark rename, continue
    '=========================================================================================================
    If strmessage = vbNullString Then
        If rng.Bookmarks.Count = 0 Or blrename Then
            ' do nothing
        Else
            strmessage = "Insertion point is already bookmarked with '" & rng.Bookmarks(1).Name & "'."
        End If
    End If
    
    '=========================================================================================================
    ' check if bookmark to be applied does not exist already, or if called as pre-validation for bookmark rename, continue
    '=========================================================================================================
    If strmessage = vbNullString Then
        If Not rng.Document.Bookmarks.Exists(strbookname) Or blrename Then
            ' do nothing
        Else
            strmessage = "Bookmark '" & strbookname & "' already exists."
        End If
    End If
    
    '=========================================================================================================
    ' perform bookmark name and text checks
    '=========================================================================================================
    If strmessage = vbNullString Then
        strmessage = CheckBookmarkName(strbookname, rng, strmatch, blrename)
        If strmessage = vbNullString And strmatch <> vbNullString Then
            If rng.Start = rng.End Then
                ' cursor in whitespace, so auto-insert text to match the match string if required
                If blautoinsert Then rng.Text = strmatch
            End If
        End If
    End If
    
    ValidateBookmarkName = strmessage

Exit_ValidateBookmarkName:
    Exit Function
    
Err_ValidateBookmarkName:
    ValidateBookmarkName = Err.Number & " " & Err.Description & " in ValidateBookmarkName()"
    Resume Exit_ValidateBookmarkName

End Function

Function CheckBookmarkName(ByVal strbookname As String, ByRef rng As Range, Optional ByRef strmatch As String, Optional ByVal blrename As Boolean = False) As String
    Dim strmessage As String, intlen As Integer, intmaxlen As Integer
    Dim strbooktype As String, strdoctype As String, strdocid As String, strcsci As String, bldatadic As Boolean
    Dim strsuffix As String, strtemp As String, strdocname As String
    Dim strdatadicbooktype As String, bldatadicbooktype As Boolean, docinfo As cDocInfo
On Error GoTo Err_CheckBookmarkName
    
    ' get some local data
    Set docinfo = Dst.Document(rng.Document.Fullname)
    strbooktype = Dst.BookmarkConfig.PrefixFromName(strbookname)
    strsuffix = Dst.BookmarkConfig.SuffixFromName(strbookname)
    strdocname = docinfo.Properties.Fullname
    strdoctype = docinfo.Properties.TypeAbbr
    strdocid = docinfo.Properties.DocID & "_"
    strcsci = docinfo.Properties.CSCI
    bldatadic = docinfo.Properties.IsDataDictionary
    
    '=========================================================================================================
    ' check for valid bookmark characters
    '=========================================================================================================
    If strmessage = vbNullString Then
        If CheckBookmarkCharacters(strbookname) = True Then
            ' do nothing
        Else
            strmessage = "Invalid characters in bookmark name '" & strbookname & "'."
        End If
    End If
    
    '=========================================================================================================
    ' check if bookmark prefix exists and for description bookmarks, that the parent bookmark is bookmarked
    '=========================================================================================================
    If strmessage = vbNullString Then
        If Dst.BookmarkConfig.Prefixes.Exists(strbooktype) Then
            ' check if this is perhaps a description type bookmark
            strtemp = Dst.BookmarkConfig.DescParentBookmarkFromName(strbookname)
            If strtemp <> vbNullString Then
                ' check that parent is bookmarked
                If Not rng.Document.Bookmarks.Exists(strtemp) Then
                    strmessage = "Parent bookmark '" & strtemp & "' does not exist."
                End If
            Else
                ' do nothing
            End If
        Else
            If InStr(1, strbookname, "_") Then
                strmessage = "Unknown prefix in bookmark name '" & strbookname & "'."
            Else
                strmessage = "Could not determine bookmark prefix as bookmark '" & strbookname & "' has no underscore."
            End If
        End If
    End If
    
    '=========================================================================================================
    ' check if bookmark prefix is allowed for the current document type
    '=========================================================================================================
    If strmessage = vbNullString Then
        If Dst.BookmarkConfig.PrefixesForDocType(docinfo.Properties.TypeAbbr).Exists(strbooktype) Then
            ' do nothing
        Else
            strmessage = "Bookmarks with prefix '" & strbooktype & "' are not allowed in documents of type '" & strdoctype & "'."
        End If
    End If
    
    '=========================================================================================================
    ' check length
    '=========================================================================================================
    If strmessage = vbNullString Then
        intlen = Len(strbookname)
        intmaxlen = Dst.BookmarkConfig.Prefix(strbooktype).MaxLength
        If intlen <= intmaxlen Then
            ' do nothing
        Else
            strmessage = "Bookmark name is " & intlen & " characters long - bookmarks of type '" & strbooktype & "' are limited to " & intmaxlen & " characters in length."
        End If
    End If
    
    '=========================================================================================================
    ' checks for data dictionary bookmark types
    '=========================================================================================================
    If strmessage = vbNullString Then
        strdatadicbooktype = GetDataDicBookmarkTypeFromLayout(rng, strmessage)
        bldatadicbooktype = Dst.BookmarkConfig.Prefix(strbooktype).IsDataDicType
        If bldatadic = True Then
            ' document is a data dictionary
            If strdatadicbooktype <> vbNullString Then
                ' cursor is in a valid data dictionary area
                If bldatadicbooktype And strbooktype = strdatadicbooktype Then
                    ' do nothing - valid case
                Else
                    ' non data dictionary bookmark type
                    strmessage = "Bookmark type '" & strbooktype & "' is not valid, expected data dictionary bookmark type '" & strdatadicbooktype & "'."
                End If
            Else
                ' cursor not in a valid data dictionary area
                If Not bldatadicbooktype Then
                    ' do nothing - valid case, clear message test in case
                    strmessage = vbNullString
                Else
                    ' data dictionary bookmark, but not in a valid area
                    strmessage = "Data dictionary bookmark type '" & strbooktype & "' not in valid data dictionary area: " & strmessage
                End If
            End If
        Else
            If bldatadicbooktype Then
                ' data dictionary bookmark, but not a data dictionary
                strmessage = "Data dictionary bookmark type '" & strbooktype & "' only allowed in data dictionaries."
            Else
                ' do nothing - valid case, clear message test in case
                strmessage = vbNullString
            End If
        End If
    End If
    
    '=========================================================================================================
    ' check suffix
    '=========================================================================================================
    If strmessage = vbNullString Then
        If strsuffix <> vbNullString Then
            Select Case Dst.BookmarkConfig.Prefix(strbooktype).SuffixStart
                Case enumSuffixStartDocID
                    If InStr(1, strsuffix, strdocid) = 1 Or strsuffix & "_" = strdocid Then
                        ' do nothing
                    Else
                        strmessage = "Suffixes for bookmarks of type '" & strbooktype & "' must start with the document ID (" & strdocid & ") at position " & rng.Start & "."
                    End If
                
                Case Else
                    ' do nothing
            End Select
        ElseIf strbookname <> "SQM" Then ' SQM is only bookmark that does not need a suffix
            strmessage = "Can't determine bookmark suffix for text '" & strbookname & "' at position " & rng.Start & " (bookmark type is '" & strbooktype & "')."
        End If
    End If
    
    '=========================================================================================================
    ' check if bookmarked text (or suffix computed above) matches bookmark name, as applicable
    '=========================================================================================================
    If strmessage = vbNullString Then
        If Dst.BookmarkConfig.Prefix(strbooktype).TextMatch <> enumTextMatchNone Then
            ' determine text to be matched
            Select Case Dst.BookmarkConfig.Prefix(strbooktype).TextMatch
                Case enumTextMatchFull
                    strmatch = strbookname
                    
                Case enumTextMatchSuffix
                    strmatch = strsuffix
                    
                Case Else
                    strmatch = vbNullString ' should never happen
            End Select
            
            ' perform match
            If StrComp(strmatch, rng.Text, vbTextCompare) <> 0 And rng.Start < rng.End And Not blrename Then
                strmessage = "Bookmark " & IIf(strmatch = strsuffix, "suffix ", vbNullString) & "'" & strmatch & "' does not match text '" & rng.Text & "'."
            End If
        End If
    End If
    
    '=========================================================================================================
    ' check that bookmark is not applied to a table of contents
    '=========================================================================================================
    If strmessage = vbNullString Then
        If InTocSection(rng) Then
            strmessage = "Bookmark '" & strbookname & "' cannot be applied to the Table of Contents section of a document."
        End If
    End If
    
    '=========================================================================================================
    ' check if there are any extra validations that need to be performed
    '=========================================================================================================
    If strmessage = vbNullString Then
        strmessage = ExtraBookmarkValidations(strbookname, strbooktype, strsuffix, rng.Text)
    End If
    
    CheckBookmarkName = strmessage

Exit_CheckBookmarkName:
    Exit Function
    
Err_CheckBookmarkName:
    CheckBookmarkName = Err.Number & " " & Err.Description & " in CheckBookmarkName()"
    Resume Exit_CheckBookmarkName

End Function

Private Function ExtraBookmarkValidations(ByVal strbookname As String, ByVal strbooktype As String, _
                                          ByVal strsuffix As String, ByVal strbooktext As String) As String
    Dim strmessage As String
On Error GoTo Err_ExtraBookmarkValidations
    
    Select Case strbooktype
        Case "package", "packagedesc"
            If RegularExpressionSearch(strsuffix, "[a-z]+") Then
                strmessage = "Bookmark type " & strbooktype & ": suffix '" & strsuffix & "' may not contain lowercase letters."
            End If
            
        Case "subpackage", "subpackagedesc"
            If Not RegularExpressionSearch(strsuffix, "^([A-Z]+\d+$)") Then
                strmessage = "Bookmark type " & strbooktype & ": suffix '" & strsuffix & "' must be one or more uppercase letters followed by one or more digits."
            End If
        
        Case "subsubpackage", "subsubpackagedesc"
            If Not RegularExpressionSearch(strsuffix, "^([A-Z]+\d+[A-Z]+$)") Then
                strmessage = "Bookmark type " & strbooktype & ": suffix '" & strsuffix & "' must be one or more uppercase letters followed by one or more digits followed by one or more uppercase letters."
            End If
        
        Case "module", "moduledesc"
            If RegularExpressionSearch(strsuffix, "[A-Z]+") Then
                strmessage = "Bookmark type " & strbooktype & ": suffix '" & strsuffix & "' may not contain uppercase letters."
            End If
            
        Case "code"
            If RegularExpressionSearch(strbooktext, "\W+") Then
                strmessage = "Bookmark type " & strbooktype & ": text '" & strbooktext & "' must be a valid 'C' identifier."
            End If
        
        Case Else
            ' do nothing
        
    End Select
    
    ExtraBookmarkValidations = strmessage

Exit_ExtraBookmarkValidations:
    Exit Function
    
Err_ExtraBookmarkValidations:
    ExtraBookmarkValidations = Err.Number & " " & Err.Description & " in ExtraBookmarkValidations()"
    Resume Exit_ExtraBookmarkValidations

End Function

Sub SetBookmarkTextRange(ByRef rng As Range)
    
    ' first strip of leading and trailing spaces
    rng.MoveStartWhile " ", wdForward
    rng.MoveEndWhile " ", wdBackward
    
    ' select word surrounding current cursor position
    rng.MoveStartWhile Const_BOOKMARK_CHARSET, wdBackward
    rng.MoveEndWhile Const_BOOKMARK_CHARSET, wdForward

End Sub

Function SetRangeToWordAroundCursor(ByRef objdoc As Document, Optional ByVal blselectword As Boolean = True) As Range
    Dim rng As Range, slct As Word.Selection
    
    ' point to the current selection
    Set slct = objdoc.ActiveWindow.Selection
    
    ' set the range to include the word under the cursor - init it to point at the selection's story range and note
    ' that we don't want to touch/change the Selection object
    Set rng = objdoc.StoryRanges(slct.StoryType)
    rng.SetRange slct.Start, slct.End
    If blselectword Then Call SetBookmarkTextRange(rng)
    
    Set SetRangeToWordAroundCursor = rng

End Function

Function CheckBookmarkCharacters(ByVal strbookname As String) As Boolean
    If Len(strbookname) > 0 Then
        ' should only contain [a-zA-Z_0-9]
        CheckBookmarkCharacters = Not RegularExpressionSearch(strbookname, "\W+")
    End If
End Function

Function WriteRenameBmConfigFile(ByVal strfilename As String, ByVal stroldname As String, ByVal strnewname As String) As Boolean
    Dim fso As FileSystemObject, ts As TextStream
On Error GoTo Err_WriteRenameBmConfigFile
    
    ' append to the file if it already exists
    Set fso = New FileSystemObject
    If fso.FileExists(strfilename) Then
        Set ts = fso.OpenTextFile(strfilename, ForAppending)
    Else
        Set ts = fso.CreateTextFile(strfilename)
        ts.WriteLine "# This file's location is '" & strfilename & "'" & vbCrLf
    End If
    
    ' write the data to the file
    ts.WriteLine "# Content added on " & Now()
    ts.WriteLine stroldname & "=" & strnewname
    
    WriteRenameBmConfigFile = True
    
Exit_WriteRenameBmConfigFile:
    If Not ts Is Nothing Then ts.Close
    Exit Function
    
Err_WriteRenameBmConfigFile:
    MsgBox Err.Description & " in WriteRenameBmConfigFile()"
    Resume Exit_WriteRenameBmConfigFile

End Function

Function FindBookmarkListIndex(ByVal strtext As String, _
                               ByRef lstbox As ListBox, _
                               Optional ByVal blmatchwhole As Boolean = False, _
                               Optional ByVal blmatchstart As Boolean = True, _
                               Optional ByVal intcomparemethod As VbCompareMethod = vbBinaryCompare) As Integer
    Dim idx As Integer, intpos As Integer
    
    ' Search through the list of bookmarks and select the first bookmark in the list box that matches the given text
    FindBookmarkListIndex = -1 ' deselect the list
    If strtext <> vbNullString Then
        For idx = 0 To lstbox.ListCount - 1
            If blmatchwhole = True Then
                If StrComp(lstbox.List(idx), strtext) = 0 Then
                    FindBookmarkListIndex = idx
                    Exit For
                End If
            Else
                intpos = InStr(1, lstbox.List(idx), strtext, intcomparemethod)
                If intpos = 1 And blmatchstart = True Then
                    FindBookmarkListIndex = idx
                    Exit For
                ElseIf intpos > 0 And blmatchstart = False Then
                    FindBookmarkListIndex = idx
                    Exit For
                End If
            End If
        Next idx
    End If
    
End Function
Attribute VB_Name = "basChecksums"

Function ProcessTableChecksum(ByRef objdoc As Document, ByVal strbkmark As String, Optional ByVal blupdate As Boolean = True, _
                              Optional ByVal colstart As Integer = 0, Optional ByVal numcols As Integer = 0) As String
    Dim tbl As Table, strchecksum As String, strchecksumstored As String, strmessage As String, docinfo As cDocInfo
On Error GoTo Err_ProcessTableChecksum

    Set docinfo = Dst.Document(objdoc.Fullname)
    If colstart = 0 Or numcols = 0 Then
        strchecksum = GetTableChecksum(objdoc, strbkmark, strmessage)
    Else
        strchecksum = GetTableColumnsChecksum(objdoc, strbkmark, colstart, numcols, strmessage)
    End If
    If strchecksum <> vbNullString Then
        If blupdate Then
            docinfo.Variables.TableChecksum(strbkmark) = strchecksum
        Else
            strchecksumstored = docinfo.Variables.TableChecksum(strbkmark)
            If strchecksumstored <> vbNullString Then
                If strchecksumstored <> strchecksum Then
                    strmessage = "Checksum for table '" & strbkmark & "' does not match - table was probably modified by hand."
                End If
            Else
                strmessage = "Could not find document variable checksum entry for " & strbkmark & "."
            End If
        End If
    End If
    
    ProcessTableChecksum = strmessage
    
Exit_ProcessTableChecksum:
    Exit Function

Err_ProcessTableChecksum:
    MsgBox Err.Description & " in ProcessTableChecksum() of basChecksums"
    Resume Exit_ProcessTableChecksum
End Function

Function GetTableChecksum(ByRef objdoc As Document, ByVal strbkmark As String, Optional ByRef strmessage As String) As String
    Dim tbl As Table

    Set tbl = GetTable(objdoc, strbkmark, strmessage)
    If Not tbl Is Nothing Then
        GetTableChecksum = StringCRC32(tbl.Range.Text)
    End If
    
End Function

Function GetTableColumnsChecksum(ByRef objdoc As Document, ByVal strbkmark As String, ByVal colstart As Integer, ByVal numcols As Integer, Optional ByRef strmessage As String) As String
    Dim tbl As Table, strtext As String, cel As Cell, idx As Integer
    
    Set tbl = GetTable(objdoc, strbkmark, strmessage)
    If Not tbl Is Nothing Then
        numcols = numcols - 1
        If tbl.Columns.Count < colstart + numcols Then
            MsgBox "Table " & strbkmark & " only has " & tbl.Columns.Count & " columns and you're trying to work with " & colstart + numcols & " columns.", vbExclamation
        Else
            For idx = colstart To colstart + numcols
                For Each cel In tbl.Columns(idx).Cells
                    strtext = strtext & GetCellText(cel)
                Next cel
            Next idx
            GetTableColumnsChecksum = StringCRC32(strtext)
        End If
    End If
End Function
Attribute VB_Name = "basClassUtils"
Option Explicit

' The command-line length limit for cmd.exe is 8191 characters - use 7500 characters as a target
Public Const Const_CMDEXE_COMMAND_LINE_LEN = 7500

Function GetSubTypeDocs(ByVal stranydocname As String, ByVal strdoctype As String, ByVal strdocsubtype As String) As Scripting.Dictionary
    Dim doclst As cDocList, doc As cDocInfo, dicdocs As New Scripting.Dictionary, idx As Integer
    Set doclst = Dst.Document(stranydocname).DocList
    If Not doclst Is Nothing Then
        For idx = 0 To doclst.AllDocuments.Count - 1
            Set doc = doclst.AllDocuments.Items(idx)
            If doc.Properties.TypeAbbr = strdoctype And doc.Properties.SubTypesAsDictionary.Exists(strdocsubtype) Then
                dicdocs.Add doc.Properties.Fullname, doc.Properties.Fullname
            End If
        Next idx
        Set GetSubTypeDocs = dicdocs
    End If
End Function

Function GetAutoBookmarkList() As Scripting.Dictionary
    Set GetAutoBookmarkList = Dst.BookmarkConfig.PrefixesAuto(Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr)
End Function

Function GetHlTestAttributeNode(ByRef xmldoc As MSXML2.DOMDocument60, ByVal strnode As String, ByVal strattrname As String) As IXMLDOMNode
    Dim nodrpts As MSXML2.IXMLDOMNodeList, nod As MSXML2.IXMLDOMNode
    
    ' Find the requested reporting section - assume the namespace is in the first attribute and the reporting in the second.
    Set nodrpts = xmldoc.SelectNodes("//ns:" & strnode)
    For Each nod In nodrpts
        If nod.Attributes.Length > 1 Then
            If InStr(1, nod.Attributes(1).Text, strattrname) Then
                Set GetHlTestAttributeNode = nod
                Exit For
            End If
        End If
    Next nod
        
End Function

Function GetSingleNode(ByRef nodparent As MSXML2.IXMLDOMNode, ByVal strnodepath As String) As IXMLDOMNode
    Dim nodlist As MSXML2.IXMLDOMNodeList, nod As MSXML2.IXMLDOMNode
    Dim arrpaths As Variant, blrecurse As Boolean
    
    ' This function allows using XPath notation to extracts nodes without requiring any knowledge about namespaces
    ' It caters for a fully qualified path, e.g. "nodeparent/nodechild/nodegrandchild...", or a recursive option specified
    ' as "//nodegrandchild".
    blrecurse = (InStr(1, strnodepath, "//") = 1)
    If Not blrecurse Then
        arrpaths = Split(strnodepath, "/")
        If UBound(arrpaths) > 0 Then
            strnodepath = Right(strnodepath, Len(strnodepath) - Len(arrpaths(0)) - 1)
        End If
    Else
        arrpaths = Array(Right(strnodepath, Len(strnodepath) - Len("//"))) ' strip away recursiveness
    End If
    
    Set nodlist = nodparent.ChildNodes
    For Each nod In nodlist
        If GetSingleNode Is Nothing Then
            If nod.Basename = arrpaths(0) Then
                If UBound(arrpaths) = 0 Then
                    Set GetSingleNode = nod
                    Exit For
                Else
                    If nod.HasChildNodes Then
                        Set GetSingleNode = GetSingleNode(nod, strnodepath)
                    End If
                End If
            Else
                If blrecurse And nod.HasChildNodes Then
                    Set GetSingleNode = GetSingleNode(nod, strnodepath)
                End If
            End If
        Else
            Exit For
        End If
    Next nod
        
End Function
    
Function GetSingleNodeText(ByRef nodparent As IXMLDOMNode, ByVal strnodepath As String, Optional ByVal straltnodepath As String = vbNullString) As String
    Dim nod As IXMLDOMNode
    
    Set nod = GetSingleNode(nodparent, strnodepath)
    If Not nod Is Nothing Then
        GetSingleNodeText = nod.Text
    ElseIf straltnodepath <> vbNullString Then
        ' try the alternate nodepath if supplied
        Set nod = GetSingleNode(nodparent, straltnodepath)
        If Not nod Is Nothing Then
            GetSingleNodeText = nod.Text
        End If
    End If
    
End Function

Function BuildPercentageString(ByVal varvalue As Variant) As String
    Dim percentage As Single, strfractionalpart As String
    
    BuildPercentageString = "-"
    strfractionalpart = ".0%"
        
    varvalue = Replace(varvalue, "%", vbNullString) ' strip off percentage string
    If varvalue <> vbNullString Then
        If IsNumeric(varvalue) Then
            percentage = varvalue
            If percentage >= 0 Then
                BuildPercentageString = Format(percentage / 100#, "0" & strfractionalpart)
                If BuildPercentageString Like "*" & strfractionalpart Then
                    BuildPercentageString = Replace(BuildPercentageString, strfractionalpart, vbNullString) & "%"
                End If
            End If
        Else
            MsgBox "Unable to convert '" & varvalue & "' to a percentage string.", vbExclamation
        End If
    End If
    
End Function


Attribute VB_Name = "basCrc32"
' Source based on sample code from http://www.di-mgt.com.au/crypto.html#CRC
Option Explicit

Private CRC32Table(256) As Long
Private BlTableInitialised As Boolean

Public Function StringCRC32(ByRef strtext As String) As String
    ' Initialise the CRC32 table
    ' Set lngcrc = 0xFFFFFFFF
    ' For each byte in string do:
    '   calculate lngcrc = (lngcrc >> 8) ^ Table[(lngcrc & 0xFF) ^ byte]
    ' Return lngcrc ^ 0xFFFFFFFF
    Dim lngcrc As Long, idx As Long, lngA As Long
    Dim bytT As Byte, bytC As Byte
    
    Call InitialiseCRC32Table
    
    lngcrc = &HFFFFFFFF
    For idx = 1 To Len(strtext)
        bytC = Asc(Mid(strtext, idx, 1))
        bytT = (lngcrc And &HFF) Xor bytC
        lngA = ShiftRightBy8(lngcrc)
        lngcrc = lngA Xor CRC32Table(bytT)
    Next
    
    StringCRC32 = Hex(lngcrc Xor &HFFFFFFFF)
    StringCRC32 = "0x" & String(8 - Len(StringCRC32), "0") & StringCRC32 ' add prefix and pad with leading zeros

End Function

Public Function FileCRC32(ByVal strfilename As String, Optional ByVal binarymode As Boolean = False) As String
    Dim fso As Scripting.FileSystemObject, stream As TextStream
    Dim intfilenum As Integer, strbinarybuffer As String
    
    Set fso = New FileSystemObject
    
    If fso.FileExists(strfilename) Then
        If Not binarymode Then
            Set stream = fso.OpenTextFile(strfilename)
            FileCRC32 = StringCRC32(stream.ReadAll)
            stream.Close
        Else
            intfilenum = FreeFile
            Open strfilename For Binary Access Read As #intfilenum
    
            ' pad buffer with number of bytes in file and then get the content of the file
            strbinarybuffer = String$(LOF(intfilenum), " ")
            Get #intfilenum, , strbinarybuffer
            Close #intfilenum
            FileCRC32 = StringCRC32(strbinarybuffer)
        End If
    Else
        MsgBox "File '" & strfilename & "' does not exist - cannot compute file checksum.", vbExclamation, "File Checksum"
    End If
    
End Function

Private Function ShiftRightBy8(lnginput As Long) As Long
    ' Shift 32-bit long value to right by 8 bits
    ' Avoiding problem with sign bit
    Dim lngresult As Long
    
    lngresult = (lnginput And &H7FFFFFFF) \ 256
    If (lnginput And &H80000000) <> 0 Then
        lngresult = lngresult Or &H800000
    End If
    ShiftRightBy8 = lngresult
    
End Function

Private Sub InitialiseCRC32Table()
    'Creates a CRC32 Table
    Dim lngpolynomial As Long, lngcrc As Long
    Dim i As Long, j As Long

    If Not BlTableInitialised Then
        lngpolynomial = &HEDB88320
        For i = 0 To 255
            lngcrc = i
            For j = 8 To 1 Step -1
                If (lngcrc And 1) Then
                    lngcrc = ((lngcrc And &HFFFFFFFE) \ 2&) And &H7FFFFFFF
                    lngcrc = lngcrc Xor lngpolynomial
                Else
                    lngcrc = ((lngcrc And &HFFFFFFFE) \ 2&) And &H7FFFFFFF
                End If
            Next j
            CRC32Table(i) = lngcrc
        Next i
        
        BlTableInitialised = True
    End If
    
End Sub
Attribute VB_Name = "basDocumentAbbrev"
Option Explicit

' NOTE: The 'defined' and 'old' abbreviation-related dictionaries contain cAbbreviation objects
'       The 'undefined' and 'ignored' dictionaries contain abbreviation strings

Public DicAbbrevUndefined As Scripting.Dictionary

Function UpdateAbbreviationsList(ByRef objdoc As Document, ByRef frm As Object, ByVal blselect As Boolean) As Boolean
    Dim strstatus As String, tbl As Table
    Dim dicold As Scripting.Dictionary, dicdefined As Scripting.Dictionary, dicignored As Scripting.Dictionary
On Error GoTo Err_UpdateAbbreviationsList
        
    UpdateAbbreviationsList = True
        
    frm.UpdateProgressText "Searching for abbreviations in " & objdoc.content.Words.Count & " words..."
    
    If Not DicAbbrevUndefined Is Nothing Then Set DicAbbrevUndefined = Nothing
    Set DicAbbrevUndefined = New Scripting.Dictionary
    
    strstatus = ValidateAbbreviationTable(objdoc, tbl)
    If strstatus = vbNullString Then
        ' save the existing abbreviations defined in the table for later use
        Set dicold = ParseAbbreviationsTable(tbl)
                                
        ' get list of ignored abbreviations
        Set dicignored = Dst.Document(objdoc.Fullname).Variables.OfType(enumDocVariableTypeAbbrIgnored)
        
        ' find abbreviations of the form 'Dummy Abbreviation Defintion (DAD)'
        Set dicdefined = New Scripting.Dictionary
        If Not FindAbbreviations(objdoc, "[\(][A-Za-z]{2,}[\)]", dicdefined, DicAbbrevUndefined, dicold, dicignored, True, frm) Then UpdateAbbreviationsList = False
    
        ' find undefined abbreviations - must be called after calling for defined abbreviations
        frm.UpdateProgressText "Checking for missing abbreviation definitions..."
        If Not FindAbbreviations(objdoc, "<[A-Z]{2,}>", dicdefined, DicAbbrevUndefined, dicold, dicignored, False, frm) Then UpdateAbbreviationsList = False
        
        ' report ignored and undefined lists
        Call ReportAbbreviationStatus(objdoc, dicdefined, DicAbbrevUndefined, dicignored, frm)
        
        ' update abbreviations table and go to it
        frm.UpdateProgressText "Updating abbreviations list with " & dicdefined.Count & " entries..."
        Call UpdateAbbreviationsTable(tbl, dicdefined, dicold, frm)
        
        ' only select table if requested
        If blselect Then
            tbl.Cell(1, 1).Select
            Selection.Collapse wdCollapseStart
        End If
    Else
        frm.UpdateProgressText strstatus
        UpdateAbbreviationsList = False
    End If
    
Exit_UpdateAbbreviationsList:
    Exit Function

Err_UpdateAbbreviationsList:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure UpdateAbbreviationsList.", vbExclamation
    Resume Next

End Function

' Validates the given document's abbreviations table
'  * Checks that the table heading exists
'  * Checks that a table is found below the heading
'  * Checks that the table is uniform and has 2 columns
Function ValidateAbbreviationTable(ByRef objdoc As Document, Optional ByRef tbl As Table) As String
    Dim docinfo As cDocInfo, strmessage As String
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    Set tbl = GetTableBeneathText(objdoc, Const_DOC_LIST_OF_ABBREVIATIONS, strmessage)
    If Not tbl Is Nothing Then
        If tbl.Uniform = True Then
            If tbl.Columns.Count <> 2 Then
                ValidateAbbreviationTable = "The " & Const_DOC_LIST_OF_ABBREVIATIONS & " should have 2 columns."
            End If
        Else
            ValidateAbbreviationTable = "The " & Const_DOC_LIST_OF_ABBREVIATIONS & " is not uniform - use the Format Table function in the Formatting Tools group to re-format the table."
        End If
    Else
        If AbbreviationTableIsRequired(objdoc) Then
            ValidateAbbreviationTable = strmessage
        Else
            ValidateAbbreviationTable = "Documents of type '" & docinfo.Properties.TypeAbbr & "' do not require an Abbreviations list."
        End If
    End If
End Function

' Returns whether an abbreviations table is required in the document
Function AbbreviationTableIsRequired(ByRef objdoc As Document) As Boolean
    With Dst.Document(objdoc.Fullname).Properties
        AbbreviationTableIsRequired = (.TypeAbbr <> "NDA" And .TypeAbbr <> Const_TEXT_UNKNOWN)
    End With
End Function

Function GetAbbreviationsData(ByRef objdoc As Document) As String
    Dim tbl As Table, strtext As String, dic As Scripting.Dictionary
    strtext = "Abbreviation Data Dump:"
    strtext = AddStatusText(vbCrLf & strtext, String(Len(strtext), "="))
    
    ' defined abbreviations
    If ValidateAbbreviationTable(objdoc, tbl) = vbNullString Then
        Set dic = ParseAbbreviationsTable(tbl)
        strtext = AddStatusText(strtext, "Abbreviations List: (" & dic.Count & " entries)" & vbCrLf & GetDictionaryAsText(dic, True, True, "  "))  ' this gets the current abbreviations
    Else
        strtext = AddStatusText(strtext, "ERROR: Could not find Abbreviations table")
    End If
    
    ' ignored abbreviations
    Set dic = Dst.Document(objdoc.Fullname).Variables.OfType(enumDocVariableTypeAbbrIgnored)
    strtext = AddStatusText(strtext, vbCrLf & "Ignored List: (" & dic.Count & " entries)" & vbCrLf & GetDictionaryAsText(dic, True, True, "  "))
    
    ' undefined abbreviations
    Set dic = DicAbbrevUndefined
    strtext = AddStatusText(strtext, vbCrLf & "Undefined List: (" & dic.Count & " entries)" & vbCrLf & GetDictionaryAsText(DicAbbrevUndefined, True, True, "  "))
    GetAbbreviationsData = strtext
End Function

Private Function ParseAbbreviationsTable(ByRef tbl As Table) As Scripting.Dictionary
    Dim rw As Row, dic  As Scripting.Dictionary, strabbr As String, abbr As cAbbreviation
    Set dic = New Scripting.Dictionary
    For Each rw In tbl.Rows
        strabbr = GetCellText(rw.Cells(1))
        If strabbr <> vbNullString Then
            If Not dic.Exists(strabbr) Then
                Set abbr = New cAbbreviation
                abbr.Definition = GetCellText(rw.Cells(2))
                abbr.Position = rw.Range.Start
                dic.Add strabbr, abbr
            End If
        End If
    Next rw
    Set ParseAbbreviationsTable = dic
End Function

Private Function FindAbbreviations(ByRef objdoc As Document, ByVal strsearchpattern, _
                                   ByRef dicdefined As Scripting.Dictionary, ByRef dicundefined As Scripting.Dictionary, _
                                   ByRef dicold As Scripting.Dictionary, ByRef dicignored As Scripting.Dictionary, _
                                   ByVal bladd As Boolean, ByRef frm As Object) As Boolean
    Dim rng As Range
    
    FindAbbreviations = True
    
    ' only work in themain text story of the document, from section 1 onwards
    Set rng = GetHeadingNumberAsRange(objdoc, "1.")
    If rng Is Nothing Then
        Set rng = objdoc.content ' just use entire document if section 1 not found
    Else
        rng.End = objdoc.content.End
    End If
                            
    ' find abbreviations in the given range
    With rng.Find
        .ClearFormatting
        .Text = strsearchpattern
        .Forward = True
        .Wrap = wdFindStop
        .IgnorePunct = True
        .MatchWildcards = True
        Do While (.Execute)
            frm.UpdateProgressMeter rng.Start, objdoc.content.End
            If Not rng.CharacterStyle = "DSTSnippetOrPath" Then
                If bladd Then
                    If Not AddAbbreviation(rng, dicdefined, dicignored, dicold, frm) Then FindAbbreviations = False
                Else
                    If Not UpdateAbbreviationsNotInList(rng, dicdefined, dicundefined, dicold, dicignored, frm) Then FindAbbreviations = False
                End If
            End If
            rng.Collapse wdCollapseEnd ' to prepare for next item
        Loop
    End With
    frm.UpdateProgressMeter (-1)
End Function

Private Function AddAbbreviation(ByRef rng As Range, ByRef dicdefined As Scripting.Dictionary, ByRef dicignored As Scripting.Dictionary, _
                                 ByRef dicold As Scripting.Dictionary, ByRef frm As Object) As Boolean
    Dim strabbr As String, strword As String, strdefinition As String, strabbrrebuild As String, strprefix As String
    Dim wrd As Range, idx As Integer, abbr As cAbbreviation, blplural As Boolean
    
    AddAbbreviation = True
    
    strabbr = Mid(rng.Text, 2, Len(rng.Text) - 2) ' strip off two brackets if the search is 'add'
    If Right(strabbr, 1) = "s" Then
        strabbr = Left(strabbr, Len(strabbr) - 1) ' strip off plural 's'
        blplural = True
    End If
    If strabbr = UCase(strabbr) Then ' abbreviations must be uppercase
        If Not dicdefined.Exists(strabbr) Then
            ' extract "abbreviation's length" capatalised words to the left as the abbreviation's definition
            Set wrd = rng
            For idx = 1 To Len(strabbr)
                Do
                    Set wrd = wrd.Previous(wdWord)
                    strword = Trim(Replace(wrd.Text, Chr(13), ""))
                    If blplural Then
                        strword = Replace(strword, "'", "", Len(strword) - 1, 1) ' strip out possible apostrophe at end
                        strword = Left(strword, Len(strword) - 1)
                        blplural = False
                    End If
                    strdefinition = " " & strword & strdefinition ' remove whitespace and possible paragraph marker
                    
                    
                    If strabbr Like "*" & strword & "*" Then
                        ' word is subset of abbreviation, e.g. Mechanical CAD (MCAD), so use entire word as prefix and advance the for loop with as many words
                        strprefix = strword ' note this statement also forces the loop exit condition below
                        idx = idx + Len(strword) - 1
                    Else
                        strprefix = Left(strword, 1)
                    End If
                    ' loop while
                    '      prefix is a lower case character, e.g. Visual Basic for Applications (VBA) and
                    '      uppercase of prefix does not match character in same position in abbreviation, e.g. Guarantee of Payment (GOP) and
                    '      prefix is not a subset of the abbreviation
                    '      single characters or empty words
                Loop While (strprefix Like "[a-z]" And _
                            UCase(strprefix) <> Mid(strabbr, Len(strabbr) - idx + 1, 1) And _
                            strprefix <> strword) Or _
                           Len(strword) = 1 Or strword = vbNullString
    
                ' rebuild abbreviation from word prefixes of definition for comparison below
                strabbrrebuild = UCase(strprefix) & strabbrrebuild
            Next idx
            
            ' check if abbreviation correlates to its definition - use existing abbreviation if it does not
            If strabbr = strabbrrebuild Then
                Set abbr = New cAbbreviation
                abbr.Definition = Trim(strdefinition)
                abbr.Position = rng.Start
            Else
                If dicold.Exists(strabbr) Then ' test for existence in isolation to avoid adding entries to dictionary when accesing a value (bug in VBA)
                    If IsAbbreviationDefinitionValid(dicold(strabbr)) Then
                        Set abbr = dicold(strabbr)
                    Else
                        AddAbbreviation = dicignored.Exists(strabbr) ' no error if abbreviation is ignored
                    End If
                Else
                    AddAbbreviation = dicignored.Exists(strabbr) ' no error if abbreviation is ignored
                End If
                
                If Not AddAbbreviation Then
                    frm.UpdateProgressText "  ERROR: '" & strdefinition & "' does not correlate with '" & strabbr & "'. Manually update the entry in the Abbreviations list"
                    Set abbr = New cAbbreviation
                    abbr.Definition = Const_DOC_ERROR_STRING & " Could not extract abbreviation definition - extracted '" & strdefinition & "'" & vbCrLf & _
                                      Const_INSTR_START & "Edit this entry to define the correct abbreviation" & Const_INSTR_END
                    abbr.Position = 0 ' this puts it before section 1 of the document body
                End If
            End If
            
            If Not abbr Is Nothing Then dicdefined.Add strabbr, abbr
        Else
            AddAbbreviation = False
            frm.UpdateProgressText "  ERROR: Found another definition for abbreviation '" & strabbr & "' in sentence '" & rng.Sentences(1).Text & vbCrLf
        End If
    End If
End Function

Private Function UpdateAbbreviationsNotInList(ByRef rng As Range, ByRef dicdefined As Scripting.Dictionary, ByRef dicundefined As Scripting.Dictionary, _
                                              ByRef dicold As Scripting.Dictionary, ByRef dicignored As Scripting.Dictionary, ByRef frm As Object) As Boolean
    Dim strabbr As String, blundefined As Boolean, abbr As cAbbreviation
    
    UpdateAbbreviationsNotInList = True
    
    ' ignore abbreviation if it has adjacent characters '-' or '_'
    strabbr = rng.Text
    If Not rng.Previous(wdWord).Text Like "*[-_]" And Not rng.Next(wdWord).Text Like "[-_]*" Then
        If dicdefined.Exists(strabbr) Then
            If IsAbbreviationDefinitionValid(dicdefined(strabbr)) Then
                Set abbr = dicdefined(strabbr)
                If rng.Start < dicdefined(strabbr).Position Then
                    Set abbr = Nothing
                    frm.UpdateProgressText "  ERROR: Abbreviation used before being defined near position " & rng.Start & ": " & strabbr
                    UpdateAbbreviationsNotInList = False
                End If
            End If
        End If
        
        ' try old list if not valid
        If abbr Is Nothing Then
            If dicold.Exists(strabbr) Then ' test for existence in isolation to avoid adding entries to dictionary when accesing a value (bug in VBA)
                Set abbr = dicold(strabbr)
                If IsAbbreviationDefinitionValid(abbr) Then
                    dicdefined.Add strabbr, abbr ' re-use old abbreviation in case user chooses not to introduce it
                    frm.UpdateProgressText "  INFO: Abbreviation '" & strabbr & "' has not been defined - using previous definition."
                Else
                    blundefined = True
                End If
            Else
                blundefined = True
            End If
            
            ' add undefined abbreviation to the list if not ignored
            If blundefined And Not dicignored.Exists(strabbr) Then
                If Not dicundefined.Exists(strabbr) Then
                    dicundefined.Add strabbr, 1
                Else
                    dicundefined(strabbr) = dicundefined(strabbr) + 1 ' increment instances
                End If
            End If
        End If
    End If
End Function

Private Function IsAbbreviationDefinitionValid(ByRef abbr As cAbbreviation) As Boolean
    IsAbbreviationDefinitionValid = Not abbr.Definition Like Const_DOC_ERROR_STRING & "*" And abbr.Definition <> vbNullString
End Function

Private Sub UpdateAbbreviationsTable(ByRef tbl As Table, ByRef dicdefined As Scripting.Dictionary, ByRef dicold As Scripting.Dictionary, _
                                     ByRef frm As Object)
    Dim rw As Row, idx As Integer, dicabbr As Scripting.Dictionary, varitem As Variant
            
    ' prepare table with one row more than required
    idx = dicdefined.Count + 1
    With tbl
        Do
            If .Rows.Count > idx Then
                .Rows(1).Delete
            ElseIf .Rows.Count < idx Then
                .Rows.Add
            End If
        Loop Until .Rows.Count = idx
        
        ' clear last row
        With .Rows.Last.Cells(1)
            .Range.Text = ""
            .Next.Range.Text = ""
        End With
            
        ' populate table
        Set dicabbr = SortDictionary(dicdefined)
        For idx = 0 To dicabbr.Count - 1
            With .Rows(idx + 1).Cells(1)
                .Range.Text = dicabbr.Keys(idx)
                .Next.Range.Text = dicabbr.Items(idx).Definition
            End With
        Next idx
    End With
    
    ' report abbreviations that were removed
    For Each varitem In dicold
        If Not dicdefined.Exists(varitem) Then
            frm.UpdateProgressText "  INFO: Removed unused abbreviation from list: " & varitem
        End If
    Next varitem
        
End Sub

Private Sub ReportAbbreviationStatus(ByRef objdoc As Document, ByRef dicdefined As Scripting.Dictionary, ByRef dicundefined As Scripting.Dictionary, _
                                     ByRef dicignored As Scripting.Dictionary, ByRef frm As Object)
    Dim varitem As Variant, docvars As cDocVars
    
    ' remove entries from ignore list that have now been defined
    Set docvars = Dst.Document(objdoc.Fullname).Variables
    For Each varitem In dicignored
        If dicdefined.Exists(varitem) Then
            docvars.VariableDelete varitem, enumDocVariableTypeAbbrIgnored
        End If
    Next varitem
    
    ' report those that are ignored and undefined
    If docvars.OfType(enumDocVariableTypeAbbrIgnored).Count Then frm.UpdateProgressText "  INFO: Ignoring the " & docvars.OfType(enumDocVariableTypeAbbrIgnored).Count & " abbreviations defined in the ignore list."
    If dicundefined.Count Then frm.UpdateProgressText "  WARNING: The document has " & dicundefined.Count & " undefined abbreviations - define them or ignore them."
    
End Sub
Attribute VB_Name = "basDocumentAmendRec"
Option Explicit

' Updates the amendment record in the given document object with the given parameters
Function UpdateAmendmentRecord(ByRef objdoc As Document, ByVal strissue As String, _
                               ByRef strmessage As String, Optional ByRef rw As Row) As Boolean
    Dim lngindex As Long, lngblankindex As Long, strtemp As String
    Dim tbl As Table
On Error GoTo Err_UpdateAmendmentRecord
    
    If AmendmentRecordIsRequired(objdoc) Then
        strmessage = ValidateAmendmentRecordTable(objdoc, tbl)
        If strmessage = vbNullString Then
            ' find cell in 1st column with issue number, else find index of first blank cell
            For lngindex = 1 To tbl.Rows.Count
                Set rw = tbl.Rows(lngindex)
                strtemp = GetCellText(rw.Cells(1))
                If strtemp = strissue Then
                    Exit For
                ElseIf strtemp = vbNullString And lngblankindex = 0 Then
                    lngblankindex = lngindex
                End If
            Next lngindex
                    
            ' check if row with issue number was found
            If lngindex <= tbl.Rows.Count Then
                Set rw = tbl.Rows(lngindex)
            ' check if blank cell was found
            ElseIf lngblankindex > 0 Then
                Set rw = tbl.Rows(lngblankindex)
            ' at end of table
            Else
                Set rw = tbl.Rows.Add
            End If
            
            ' fill in issue and date
            rw.Cells(1).Range.Text = strissue
            rw.Cells(2).Range.Text = Format(Date, "dd mmm yyyy")
        
            UpdateAmendmentRecord = True
        End If
    Else
        UpdateAmendmentRecord = True
    End If
    
Exit_UpdateAmendmentRecord:
    Exit Function

Err_UpdateAmendmentRecord:
    strmessage = Err.Description & " in UpdateAmendmentRecord()"
    Resume Exit_UpdateAmendmentRecord

End Function

' Verifies the given document's amendment record against the given parameters
'  * Validates the amendment record table structure
'  * Checks that the issue number entry and property correspond
'  * Checks that the date entry and date property correspond
Function VerifyAmendmentRecord(ByRef objdoc As Document) As String
    Dim strmessage As String, tbl As Table, rw As Row
    Dim strtemp As String, strissue As String, strdate As String, docinfo As cDocInfo
On Error GoTo Err_VerifyAmendmentRecord

    If AmendmentRecordIsRequired(objdoc) Then
        strmessage = ValidateAmendmentRecordTable(objdoc, tbl)
        If strmessage = vbNullString Then
            ' find the last entry in the table
            For Each rw In tbl.Rows
                If GetCellText(rw.Cells(1)) = vbNullString Then
                    Set rw = rw.Previous
                    Exit For
                Else
                    If rw.IsLast Then
                        Exit For
                    End If
                End If
            Next rw
            strtemp = GetCellText(rw.Cells(1))
            
            ' get the issue number property and check it
            Set docinfo = Dst.Document(objdoc.Fullname)
            strissue = docinfo.Properties.Issue
            If strissue <> vbNullString Then
                If strissue <> strtemp Then
                    strmessage = "Found issue '" & strtemp & "' in row " & rw.Index & " of the " & _
                        Const_DOC_AMENDMENT_RECORD & ", but the custom document property '" & docinfo.Properties.PropertyNameIssue & "' is set to " & strissue
                End If
            Else
                strmessage = "Custom document property '" & docinfo.Properties.PropertyNameIssue & "' not set."
            End If
                    
            ' get the date property and verify it
            strdate = docinfo.Properties.DocDate
            strtemp = GetCellText(rw.Cells(2))
            If strdate <> vbNullString Then
                strdate = Format(strdate, "dd mmm yyyy")
                If strtemp <> strdate Then
                    strtemp = "Found date '" & strtemp & "' in row " & rw.Index & " of the " & Const_DOC_AMENDMENT_RECORD & _
                              ", but the custom document property '" & docinfo.Properties.PropertyNameDate & "' is set to " & strdate
                Else
                    strtemp = vbNullString
                End If
            Else
                strtemp = "Custom document property '" & docinfo.Properties.PropertyNameDate & "' not set."
            End If
            If strtemp <> vbNullString Then
                strmessage = strmessage & IIf(strmessage <> vbNullString, vbCrLf, vbNullString) & strtemp
            End If
        End If
    End If
    
    VerifyAmendmentRecord = strmessage

Exit_VerifyAmendmentRecord:
    Exit Function

Err_VerifyAmendmentRecord:
    MsgBox Err.Description & " in VerifyAmendmentRecord()"
    Resume Exit_VerifyAmendmentRecord

End Function

' Validates the given document's amendment record table
'  * Checks that the table heading exists
'  * Checks that a table is found below the heading
'  * Checks that the table is uniform and has at least 4 columns
Function ValidateAmendmentRecordTable(ByRef objdoc As Document, Optional ByRef tbl As Table, Optional ByVal blignoreuniformity As Boolean = False) As String
    Dim docinfo As cDocInfo, strmessage As String
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    If AmendmentRecordIsRequired(objdoc) Then
        ' Find the Amendment Record table
        Set tbl = GetTableBeneathText(objdoc, Const_DOC_AMENDMENT_RECORD, strmessage)
        If Not tbl Is Nothing Then
            If tbl.Uniform = True Then
                If tbl.Columns.Count < 4 Then
                    ValidateAmendmentRecordTable = "The " & Const_DOC_AMENDMENT_RECORD & " should have at least 4 columns."
                End If
            ElseIf Not blignoreuniformity Then
                ValidateAmendmentRecordTable = "The " & Const_DOC_AMENDMENT_RECORD & " is not uniform - use the Format Table function in the Formatting Tools group to re-format the table."
            End If
        Else
            ValidateAmendmentRecordTable = strmessage
        End If
    Else
        ValidateAmendmentRecordTable = "Documents of type '" & docinfo.Properties.TypeAbbr & "' do not require an Amendment Record."
    End If
End Function

' Returns whether an amendment record table is required in the document
Function AmendmentRecordIsRequired(ByRef objdoc As Document) As Boolean
    Dim docinfo As cDocInfo
    Set docinfo = Dst.Document(objdoc.Fullname)
    AmendmentRecordIsRequired = (docinfo.Properties.TypeAbbr <> "NDA" And docinfo.Properties.TypeAbbr <> "WRKP")
End Function
Attribute VB_Name = "basDocumentChecks"
Option Explicit

' MS Word reference error prefix
Public Const Const_DOC_ERROR_STRING As String = "Error!"

Function CheckDocumentStatusQuick(ByRef objdoc As Document) As String
    Dim strmessage As String, strtemp As String, strdate As String, tbl As Table
    
    '=============================================================================
    ' check amendment record table
    '=============================================================================
    strtemp = VerifyAmendmentRecord(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check document title properties
    '=============================================================================
    strtemp = CheckDocTitle(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check document issue property
    '=============================================================================
    strtemp = CheckIssueProperty(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check document date property
    '=============================================================================
    strtemp = CheckDateProperty(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check location property
    '=============================================================================
    strtemp = CheckLocationProperty(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
        
    '=============================================================================
    ' check when document check was last run
    '=============================================================================
    strtemp = CheckDocumentLastRun(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
        
    '=============================================================================
    ' check external references table
    '=============================================================================
    strtemp = CheckDocExtRefsDate(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check test description bookmarks
    '=============================================================================
    strtemp = CheckTestDescriptionBookmarks(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check test report table checksums
    '=============================================================================
    strtemp = CheckTestReportTableChecksums(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check test report result file checksums
    '=============================================================================
    strtemp = CheckTestReportResultFileChecksums(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check document revisions
    '=============================================================================
    strtemp = CheckRevisionsStatus(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check tracked changes status
    '=============================================================================
    strtemp = CheckTrackChangesStatus(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check inline shapes (pictures)
    '=============================================================================
    strtemp = CheckInlineShapes(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If
    
    '=============================================================================
    ' check for attached template
    '=============================================================================
    strtemp = CheckAttachedTemplateStatus(objdoc)
    If strtemp <> vbNullString Then
        strmessage = strmessage & strtemp & vbCrLf
    End If

    ' return the status
    CheckDocumentStatusQuick = strmessage
    
End Function

Function CheckDocumentStatusComplete(ByRef objdoc As Document, ByRef frmtext As Object) As Boolean
    Dim strmessage As String, tbl As Table, doclst As cDocList
    
    Call SaveAndTurnOffGrammarSettings
    
    '=============================================================================
    ' check document title
    '=============================================================================
    frmtext.UpdateProgressText "Checking document title..."
    frmtext.LogResult CheckDocTitle(objdoc)
    
    '=============================================================================
    ' check amendment record
    '=============================================================================
    frmtext.UpdateProgressText "Checking amendment record table..."
    frmtext.LogResult VerifyAmendmentRecord(objdoc)
    
    '=============================================================================
    ' check issue property
    '=============================================================================
    frmtext.UpdateProgressText "Checking issue property..."
    frmtext.LogResult CheckIssueProperty(objdoc)
    
    '=============================================================================
    ' check date property
    '=============================================================================
    frmtext.UpdateProgressText "Checking date property..."
    frmtext.LogResult CheckDateProperty(objdoc)
    
    '=============================================================================
    ' check location property
    '=============================================================================
    frmtext.UpdateProgressText "Checking location property..."
    frmtext.LogResult CheckLocationProperty(objdoc)
    
    '=============================================================================
    ' check traceability tables
    '=============================================================================
    frmtext.UpdateProgressText "Checking traceability tables..."
    frmtext.LogResult ValidateDocTraceabilityTables(objdoc, , , , True, , True)
    
    '=============================================================================
    ' check when document check was last run
    '=============================================================================
    frmtext.UpdateProgressText "Checking document checked date..."
    frmtext.LogResult CheckDocumentLastRun(objdoc)
        
    '=============================================================================
    ' check external references table
    '=============================================================================
    frmtext.UpdateProgressText "Checking external references table..."
    frmtext.LogResult CheckDocExtRefsDate(objdoc)
    
    '=============================================================================
    ' check bookmark names
    '=============================================================================
    frmtext.UpdateProgressText "Checking bookmark names..."
    frmtext.LogResult CheckBookmarkNames(objdoc)
    
    '=============================================================================
    ' check for missing auto bookmarks
    '=============================================================================
    frmtext.LogResult CheckMissingAutoBookmarks(objdoc, frmtext)
    
    '=============================================================================
    ' check test description bookmarks
    '=============================================================================
    frmtext.UpdateProgressText "Checking test description bookmarks..."
    frmtext.LogResult CheckTestDescriptionBookmarks(objdoc, True)
    
    '=============================================================================
    ' check test report table checksums
    '=============================================================================
    frmtext.UpdateProgressText "Checking test report table checksums..."
    frmtext.LogResult CheckTestReportTableChecksums(objdoc)
        
    '=============================================================================
    ' check test report result file checksums
    '=============================================================================
    frmtext.UpdateProgressText "Checking test report result file checksums..."
    frmtext.LogResult CheckTestReportResultFileChecksums(objdoc)
    
    '=============================================================================
    ' check document revisions
    '=============================================================================
    frmtext.UpdateProgressText "Checking revisions status..."
    frmtext.LogResult CheckRevisionsStatus(objdoc)
    
    '=============================================================================
    ' check tracked changes status
    '=============================================================================
    frmtext.UpdateProgressText "Checking tracked changes status..."
    frmtext.LogResult CheckTrackChangesStatus(objdoc)
    
    '=============================================================================
    ' check for attached template
    '=============================================================================
    frmtext.UpdateProgressText "Checking attached template status..."
    frmtext.LogResult CheckAttachedTemplateStatus(objdoc)
    
    '=============================================================================
    ' check for styles template date
    '=============================================================================
    frmtext.UpdateProgressText "Checking master template date..."
    frmtext.LogResult CheckMasterTemplateDate(objdoc)

    '=============================================================================
    ' check inline shapes (pictures)
    '=============================================================================
    frmtext.UpdateProgressText "Checking inline shapes..."
    frmtext.LogResult CheckInlineShapes(objdoc)
    
    '=============================================================================
    ' check for unlocked include text and picture fields
    '=============================================================================
    frmtext.UpdateProgressText "Checking fields..."
    frmtext.LogResult CheckIncludeFields(objdoc, frmtext)
    
    '=============================================================================
    ' check for Error! text
    '=============================================================================
    frmtext.UpdateProgressText "Searching for '" & Const_DOC_ERROR_STRING & "' text..."
    If FindTextInRange(objdoc.Range, Const_DOC_ERROR_STRING) = True Then
        frmtext.LogResult "Found '" & Const_DOC_ERROR_STRING & "' in the main body of the document."
    End If
    
    '=============================================================================
    ' check for instruction text
    '=============================================================================
    frmtext.UpdateProgressText "Searching for '" & Const_INSTR_START & " or " & Const_INSTR_END & "' text..."
    If FindTextInRange(objdoc.Range, Const_INSTR_START) = True Then
        frmtext.LogResult "Found '" & Const_INSTR_START & "' in the main body of the document."
    End If
    If FindTextInRange(objdoc.Range, Const_INSTR_END) = True Then
        frmtext.LogResult "Found '" & Const_INSTR_END & "' in the main body of the document."
    End If
    
    '=============================================================================
    ' append status
    '=============================================================================
    frmtext.UpdateProgressText "Document Status ", False
    If frmtext.GetResult = vbNullString Then
        frmtext.UpdateProgressText "OK"
        CheckDocumentStatusComplete = True
    Else
        frmtext.UpdateProgressText "NOK"
        CheckDocumentStatusComplete = False
    End If
            
    Call RestoreGrammarSettings
    
End Function

Function CheckDocument(ByRef objdoc As Document, ByRef frmtext As Object) As Boolean

    CheckDocument = True
    
    frmtext.UpdateProgressText vbCrLf & "Updating Abbreviations:"
    If Not UpdateAbbreviationsList(objdoc, frmtext, False) Then CheckDocument = False
    
    frmtext.UpdateProgressText vbCrLf & "Fixing Orphaned List Paragraphs:"
    If Not RevertOrphanedListParagraphs(objdoc, frmtext) Then CheckDocument = False
    
    frmtext.UpdateProgressText "Updating External References:"
    If Not UpdateExternalReferencesTable(objdoc, frmtext) Then CheckDocument = False
    
    frmtext.UpdateProgressText vbCrLf & "Updating All Fields:"
    If Not UpdateAllFields(objdoc, frmtext, False) Then CheckDocument = False
    
    frmtext.UpdateProgressText vbCrLf & "Checking Document Status:"
    Dst.Document(objdoc.Fullname).Variables.CheckDocDate = Format(Now, Const_FORMAT_DATETIME) ' set before running function below, because it check the date!
    If Not CheckDocumentStatusComplete(objdoc, frmtext) Then CheckDocument = False
                          
End Function
            
Function CheckDateProperty(ByRef objdoc As Document) As String
    Dim strmessage As String, strdate As String, strtemp As String, docinfo As cDocInfo
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    strdate = docinfo.Properties.DocDate
    If strdate <> vbNullString Then
        strtemp = Format(strdate, "dd mmmm yyyy")
        If strdate <> strtemp Then
            strmessage = "Custom property '" & docinfo.Properties.PropertyNameDate & "' should be formatted as " & strtemp
        End If
    End If

    CheckDateProperty = strmessage
    
End Function

Function CheckLocationProperty(ByRef objdoc As Document) As String
    Dim strmessage As String, strlocation As String, docinfo As cDocInfo
        
    Set docinfo = Dst.Document(objdoc.Fullname)
    strlocation = docinfo.Properties.Location
    If strlocation <> vbNullString Then
        strlocation = Replace(strlocation, "$CVSROOT", vbNullString) ' strip this out so we can compare paths
        strlocation = Replace(strlocation, "/", "\") ' so it's the same as property below
        If Not objdoc.Fullname Like "*" & strlocation Then
            strmessage = "Custom property '" & docinfo.Properties.PropertyNameLocation & "' is not a substring of the document path '" & objdoc.Fullname & "'"
        End If
    Else
        strmessage = vbNullString ' this property is optional, so don't complain if it does not exist
    End If

    CheckLocationProperty = strmessage
    
End Function

Function CheckIssueProperty(ByRef objdoc As Document) As String
    Dim docinfo As cDocInfo, strmessage As String, strissue As String, strdraftpart As String
        
    ' check whether issue property exists
    Set docinfo = Dst.Document(objdoc.Fullname)
    strissue = docinfo.Properties.Issue
    If strissue <> vbNullString Then
        Call GetRefIssueComponents(strissue, strissue, strdraftpart)
        If Not RegularExpressionSearch(strissue, "^[0-9]+$") Then
            strmessage = "Custom document property '" & docinfo.Properties.PropertyNameIssue & "' prefix '" & strissue & "' must be numeric."
        End If
        If strdraftpart <> vbNullString And Not RegularExpressionSearch(strdraftpart, "^[A-Z]+$") Then
            strmessage = AddStatusText(strmessage, "Custom document property '" & docinfo.Properties.PropertyNameIssue & "' suffix '" & strdraftpart & "' may only contain uppercase letters.")
        End If
    End If

    CheckIssueProperty = strmessage
    
End Function

Function CheckBookmarkNames(ByRef objdoc As Document) As String
    Dim strmessage As String, bkmark As Bookmark, docinfo As cDocInfo

    Set docinfo = Dst.Document(objdoc.Fullname)
    For Each bkmark In objdoc.Bookmarks
        If Not docinfo.Bookmarks.IsExternal(bkmark.Name) Then
            strmessage = CheckBookmarkName(bkmark.Name, bkmark.Range)
            If strmessage <> vbNullString Then
                CheckBookmarkNames = CheckBookmarkNames & IIf(CheckBookmarkNames <> vbNullString, vbCrLf, vbNullString) & bkmark.Name & ": " & strmessage
            End If
        End If
    Next bkmark
    
End Function

Function CheckTestDescriptionBookmarks(ByRef objdoc As Document, Optional ByVal blcomplete As Boolean = False) As String
    Dim strmessage As String, strdoctype As String, bkm As cDocBookmark, docinfo As cDocInfo
        
    Set docinfo = Dst.Document(objdoc.Fullname)
    strdoctype = docinfo.Properties.TypeAbbr
    If strdoctype = "STD" Then
        ' first check that the section is delimited
        If Not docinfo.Bookmarks.Internal.Exists(Const_DOCTESTDESC_START) Or _
           Not docinfo.Bookmarks.Internal.Exists(Const_DOCTESTDESC_END) Then
            strmessage = "The bookmarks called '" & Const_DOCTESTDESC_START & "' and '" & Const_DOCTESTDESC_END & _
                         "' used to delimit the Test Description section could not be found."
        ' now check that the sequence is correct
        ElseIf docinfo.Bookmarks.Internal(Const_DOCTESTDESC_START).Position >= _
               docinfo.Bookmarks.Internal(Const_DOCTESTDESC_END).Position Then
            strmessage = "The bookmark '" & Const_DOCTESTDESC_END & "' must appear after '" & Const_DOCTESTDESC_START & _
                         "' to correctly delimit the Test Description section."
        End If
        
        If blcomplete Then
            ' if any testabstractions exist, the summary table bookmark must exist
            For Each bkm In docinfo.Bookmarks.Internal
                If Dst.BookmarkConfig.PrefixFromName(bkm.Name) = Const_TESTABSTR_PREFIX Then
                    If Not docinfo.Bookmarks.Internal.Exists(Const_DOCTESTABSTRACTIONS_SUMMARY) Then
                        strmessage = "The bookmark called '" & Const_DOCTESTABSTRACTIONS_SUMMARY & "' could not be found - run the 'Update Summary Table' function to create the Test Abstractions Summary table."
                    End If
                    Exit For
                End If
            Next bkm
        End If
    End If

    CheckTestDescriptionBookmarks = strmessage
    
End Function

Function CheckDocTitle(ByRef objdoc As Document, Optional ByVal blfixdoctitles As Boolean = False, Optional ByVal blprompt As Boolean = True) As String
    Dim strmessage As String, rng As Range, docinfo As cDocInfo, blusetitlebookmark As Boolean
    Dim strtitlecover As String, strtitlebkmarkname As String, strtitlebkmarktext As String, strtitledocprop As String
        
    Set docinfo = Dst.Document(objdoc.Fullname)
    If docinfo.Properties.TypeAbbr <> "NDA" Then ' skip for NDAs
        blusetitlebookmark = (docinfo.Properties.TypeAbbr <> Const_TEXT_UNKNOWN And docinfo.Properties.TypeAbbr <> "WRKP")
        
        ' ================================================================================================
        ' determine the cover page title only if it exists
        ' ================================================================================================
        Set rng = objdoc.Range
        If rng.Tables.Count > 0 Then
            Set rng = rng.Tables(1).Range
            If rng.Rows.Count > 2 Then
                Set rng = rng.Rows(3).Range
                If rng.Cells.Count > 1 Then
                    strtitlecover = GetCellText(rng.Cells(2))
                    strtitlecover = Replace(strtitlecover, vbCr, " ") ' remove CRs
                    strtitlecover = Replace(strtitlecover, vbLf, " ") ' remove LFs
                    strtitlecover = Trim(RegularExpressionReplace(strtitlecover, "\s+", " ")) ' trim whitespace
                End If
            End If
        End If
        If strtitlecover <> vbNullString Then
            ' ================================================================================================
            ' determine the title from the document title bookmark
            ' ================================================================================================
            strtitlebkmarkname = GetDocumentTitleBookmark(objdoc, strtitlebkmarktext)
            
            ' ================================================================================================
            ' determine the title from the document property
            ' ================================================================================================
            strtitledocprop = docinfo.Properties.BuiltIn(wdPropertyTitle)
            
            ' ================================================================================================
            ' compare all three document titles
            ' ================================================================================================
            If strtitlecover <> strtitledocprop Or (blusetitlebookmark And strtitlecover <> strtitlebkmarktext) Then
                CheckDocTitle = "Document titles don't match:" & vbCrLf & _
                   "Cover Page     - " & """" & strtitlecover & """" & vbCrLf & _
                   "Title Property - " & """" & strtitledocprop & """" & _
                   IIf(blusetitlebookmark, vbCrLf & _
                   "Title Bookmark - " & """" & strtitlebkmarktext & """" & " (based on bookmark '" & strtitlebkmarkname & "')", vbNullString)
                
                If Not blfixdoctitles Then
                    If strtitledocprop = vbNullString Then
                        CheckDocTitle = AddStatusText(CheckDocTitle, "The built-in document property 'Title' must be specified.")
                    End If
                    If blusetitlebookmark And strtitlebkmarktext = vbNullString Then
                        CheckDocTitle = AddStatusText(CheckDocTitle, "The document title bookmark '" & strtitlebkmarkname & "' not found on the Approvals page.")
                    End If
                Else
                    ' prompt user before starting
                    Dim blset As Boolean
                    If blprompt Then
                        If MsgBox("Set built-in document property 'Title' to '" & strtitlecover & "'" & IIf(blusetitlebookmark, " and create/update bookmark '" & strtitlebkmarkname & "' on the Approvals Page as well?", vbNullString), vbYesNo + vbQuestion) = vbYes Then
                            blset = True
                        End If
                    Else
                        blset = True
                    End If
                    If blset Then
                        ' set 'Title' document property
                        docinfo.Properties.Title = strtitlecover
                        
                        ' set the document title bookmark
                        If blusetitlebookmark Then Call SetDocumentTitleBookmark(objdoc, strtitlebkmarkname, strtitlecover)
                        
                        Call UpdateDocumentPropertyRefs(objdoc, docinfo.Properties.BuiltInName(wdPropertyTitle))
                    End If
                End If
            Else
                If blfixdoctitles Then MsgBox "The built-in document property 'Title' and the title on the Cover Page" & IIf(blusetitlebookmark, " and the text of the title bookmark on the Approvals Page", vbNullString) & " match.", vbInformation
            End If
            
            ' ================================================================================================
            ' check that the title property is not referenced directly
            ' ================================================================================================
            If IsFieldReferencedInDoc(objdoc, "Title", wdFieldTitle) Then
                If Not blfixdoctitles Then
                    CheckDocTitle = AddStatusText(CheckDocTitle, "The built-in document property 'Title' property may only be referenced using the 'DOCPROPERTY' syntax.")
                Else
                    Call RenameRefs(objdoc, "Title", "Title", wdFieldTitle)
                End If
            End If
        Else
            CheckDocTitle = "The document title must be specified in the correct place on the Cover Page."
        End If
        
        ' add some instruction text
        If CheckDocTitle <> vbNullString Then
            CheckDocTitle = CheckDocTitle & vbCrLf & "Use the 'Sync Titles' function on the DST Admin tab to fix this."
        End If
    End If
    
End Function

Function GetDocumentTitleBookmark(ByRef objdoc As Document, ByRef strtitle As String) As String
    Dim fso As New FileSystemObject
    strtitle = vbNullString
    GetDocumentTitleBookmark = UCase(fso.GetBaseName(objdoc.Name))
    If objdoc.Bookmarks.Exists(GetDocumentTitleBookmark) Then
        strtitle = objdoc.Bookmarks(GetDocumentTitleBookmark).Range.Text
    End If
End Function

Sub SetDocumentTitleBookmark(ByRef objdoc As Document, ByVal strtitlebkmname As String, ByVal strtitle As String)
    Dim tbl As Table, rng As Range, fld As Field, cel As Cell, strdocnumberbkmname As String, docinfo As cDocInfo, slct As SelectionType
    
    ' delete existing bookmarks
    Set docinfo = Dst.Document(objdoc.Fullname)
    strdocnumberbkmname = strtitlebkmname & "_DocNumber"
    
    ' insert new bookmark on the Approval Page - assume it's in the 2nd table
    Set tbl = objdoc.Tables(2)
    Set cel = tbl.Cell(1, 1)
    If GetCellText(cel) Like "*TITLE*" Then
        Set rng = cel.Next.Next.Range
        rng.MoveEnd wdCharacter, -1 ' exclude end-of-cell marker
        If RangeHasFields(rng, slct) Then
            Set fld = rng.Fields(1)
            fld.Update
            Set rng = fld.Result
            docinfo.Bookmarks.Delete strtitlebkmname
            If AddBookmark(rng, strtitlebkmname) Then
                ' insert the document number bookmark as well - delete it first
                Set cel = tbl.Cell(2, 1)
                If GetCellText(cel) Like "*DOCUMENT NUMBER*" Then
                    Set rng = cel.Next.Next.Range
                    rng.MoveEnd wdCharacter, -1 ' exclude end-of-cell marker
                    docinfo.Bookmarks.Delete strdocnumberbkmname
                    Call AddBookmark(rng, strdocnumberbkmname)
                Else
                    MsgBox "DST expects the 2nd table to have the text 'DOCUMENT NUMBER' in the 1st column of the 2nd row - unable to set the document number bookmark '" & strdocnumberbkmname & "'.", vbExclamation
                End If
            End If
        Else
            MsgBox "DST expects the 2nd table to have a field in the 3rd column of the 1st row - unable to set the document title bookmark '" & strdocnumberbkmname & "'.", vbExclamation
        End If
    Else
        MsgBox "DST expects the 2nd table to have the text 'TITLE' in the 1st column of the 1st row - unable to set the document title bookmark '" & strtitlebkmname & "'.", vbExclamation
    End If
    
End Sub

Function CheckDocumentLastRun(ByRef objdoc As Document) As String
    
    CheckDocumentLastRun = CheckDateAgainstSaveDate(objdoc, "CheckDocDate", "Check Document", _
                                                    "It is recommended to run the function after editing a docment to ensure its status is maintained.")
            
End Function
            
Function CheckDocExtRefsDate(ByRef objdoc As Document) As String
    Dim strmessage As String, tbl As Table
    
    If ValidateDocExtRefsTable(objdoc, tbl, strmessage) Then
        CheckDocExtRefsDate = CheckDateAgainstSaveDate(objdoc, "ExtRefsDate", "Update External References", _
                                                       "The external references may be out-of-date.")
    Else
        CheckDocExtRefsDate = strmessage
    End If
            
End Function

Private Function CheckDateAgainstSaveDate(ByRef objdoc As Document, ByVal strdateproperty As String, ByVal strfunction As String, ByVal strmessage As String) As String
    Dim strrefdate As String, strdocsavedate As String, lngseconds As Long, lngminutes As Long, docinfo As cDocInfo
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    ' only do check if the document was edited and saved in this session
    If docinfo.DocSavedInSession Then
        strrefdate = CallByName(docinfo.Variables, strdateproperty, VbGet)
        If strrefdate <> vbNullString Then
            ' check whether given date is within a five minutes from document save date
            strdocsavedate = Format(docinfo.Properties.BuiltIn(wdPropertyTimeLastSaved), Const_FORMAT_DATETIME)
            lngseconds = DateDiff("s", strrefdate, strdocsavedate)
            If lngseconds > 60 * 5 Then
                lngminutes = lngseconds / 60
                CheckDateAgainstSaveDate = "The document was edited and saved " & lngminutes & " minutes after the '" & strfunction & "' function was last run. " & strmessage
            End If
        Else
            CheckDateAgainstSaveDate = "Document variable '" & docinfo.Variables.GetVariableName(strdateproperty) & "' does not exist. Run the '" & strfunction & "' function."
        End If
    End If
            
End Function

Function InDocExtRefsTable(ByRef rng As Range) As Boolean
' Indicates whether the given range falls within the External References table
    Dim tbl As Table
    
    If ValidateDocExtRefsTable(rng.Document, tbl, , True) = True Then
        InDocExtRefsTable = rng.InRange(tbl.Range)
    End If
    
End Function

Function CheckRevisionsStatus(ByRef objdoc As Document) As String
    
    If objdoc.Revisions.Count > 0 Then
        CheckRevisionsStatus = "This document has " & objdoc.Revisions.Count & " tracked changes - these changes should be accepted."
    End If

End Function

Function CheckTrackChangesStatus(ByRef objdoc As Document) As String
    
    If objdoc.TrackRevisions = True Then
        CheckTrackChangesStatus = "This document has 'Track Changes' turned on - it should be turned off."
    End If
    
End Function

Function CheckMasterTemplateDate(ByRef objdoc As Document) As String
    
    CheckMasterTemplateDate = ManageMasterTemplateDate(objdoc)
    
End Function

Function CheckIncludeFields(ByRef objdoc As Document, ByRef frm As Object) As String
    Dim stryrng As Range, fld As Word.Field, strmessage As String, idx As Long, lngnumfields As Long
    
    ' find all INCLUDETEXT and INCLUDEPICTURE fields and check that they're locked
    For Each stryrng In objdoc.StoryRanges
        Do
            idx = 0
            lngnumfields = stryrng.Fields.Count
            For Each fld In stryrng.Fields
                idx = idx + 1
                frm.UpdateProgressMeter idx, lngnumfields
                If fld.Type = wdFieldIncludeText Or fld.Type = wdFieldIncludePicture Then
                    If Not fld.Locked Then
                        strmessage = strmessage & "Field with code '" & fld.Code.Text & "' at position " & fld.Code.Start & " should be locked." & vbCrLf
                    End If
                    
                    If fld.Type = wdFieldIncludePicture Then
                        If UseInlineShapes(stryrng.Document) Then
                            ' only binary format documents should use INCLUDEPICTURE fields
                            strmessage = strmessage & "Picture at position " & fld.Code.Start & " uses an INCLUDEPICTURE field, XML-based documents must use Inline Shapes - re-insert the picture with the 'Insert Picture' function." & vbCrLf
                        End If
                        If fld.LinkFormat.SavePictureWithDocument = False Then
                            strmessage = strmessage & "Picture at position " & fld.Code.Start & " should be set to 'Save Picture With Document'." & vbCrLf
                        End If
                    End If
                ElseIf fld.Type = wdFieldRef Then
                    If GetBookmarkNameFromFieldCode(fld.Code) Like "_Ref*" Then
                        If fld.Result.Text = "0" Then
                            strmessage = strmessage & "The field result at position " & fld.Code.Start & " is 0 - reference is invalid." & vbCrLf
                        End If
                    End If
                End If
            Next fld
            Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
        Loop Until stryrng Is Nothing
    Next stryrng
    frm.UpdateProgressMeter (-1)
    
    CheckIncludeFields = strmessage
        
End Function

Function CheckMissingAutoBookmarks(ByRef objdoc As Document, ByRef frm As Object) As String
    Dim rngstart As Range, tblend As Table, rngsearch As Range, varprefix As Variant, strmessage As String
    Dim docinfo As cDocInfo, prefixcount As Long, rngword As Range, wordcount As Long, lngincrements As Long
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    If docinfo.Properties.TypeAbbr <> "STD" Or Not docinfo.Properties.SubTypesAsDictionary.Exists("notests") Then
        ' start search from section 2 to either the traceability or external references table
        Set rngsearch = objdoc.Range
        Set rngstart = GetHeadingNumberAsRange(objdoc, "2.")
        Set tblend = GetTable(objdoc, Const_DOCTBL_TRCSUMMARY)
        If tblend Is Nothing Then Set tblend = GetTable(objdoc, Const_DOCTBL_EXTREFERENCES)
        If Not rngstart Is Nothing And Not tblend Is Nothing Then
            ' cycle through the search area for each auto prefix for this document type
            For Each varprefix In Dst.BookmarkConfig.PrefixesAuto(docinfo.Properties.TypeAbbr)
                prefixcount = prefixcount + 1
                
                ' reset the search area and find all occurences of the prefix text
                rngsearch.SetRange rngstart.Start, tblend.Range.Start
                frm.UpdateProgressText "Checking for missing '" & varprefix & "' bookmarks in " & rngsearch.Words.Count & " words (prefix " & prefixcount & " of " & Dst.BookmarkConfig.PrefixesAuto(docinfo.Properties.TypeAbbr).Count & ")..."
                wordcount = 1
                lngincrements = rngsearch.Words.Count / 10 ' this should give us increments of 10%
                If lngincrements = 0 Then lngincrements = 1
                For Each rngword In rngsearch.Words
                    If wordcount Mod lngincrements = 0 Then frm.UpdateProgressMeter wordcount, rngsearch.Words.Count ' adjust 1000 based on number of words
                    If rngword = varprefix Then
                        If rngword.Next(wdWord) = "_" Then
                            Call SetBookmarkTextRange(rngword)
                            ' skip ranges inside hyperlinks
                            If rngword.Hyperlinks.Count = 0 Then
                                If rngword.Bookmarks.Count = 0 And rngword.Fields.Count = 0 Then
                                    strmessage = strmessage & IIf(strmessage <> vbNullString, vbCrLf, vbNullString) & "The text '" & rngword.Text & "' at position " & rngword.Start & " is not bookmarked and it's not a cross-reference."
                                End If
                                If rngword.Bookmarks.Count > 1 Then
                                    strmessage = strmessage & IIf(strmessage <> vbNullString, vbCrLf, vbNullString) & "The text '" & rngword.Text & "' at position " & rngword.Start & " has multiple bookmarks."
                                End If
                            End If
                        End If
                    End If
                    wordcount = wordcount + 1
                Next rngword
            Next varprefix
            frm.UpdateProgressMeter (-1)
        Else
            strmessage = "Unable to delimit the search area for missing bookmarks. Make sure that the document has a section 2 " & _
                         "and either a " & Const_DOCTBL_TRCSUMMARY & " table or a " & Const_DOCTBL_EXTREFERENCES & " table."
        End If
    End If
    CheckMissingAutoBookmarks = strmessage
    
End Function

Sub ProposeTrackedChangesOff(ByRef objdoc As Document)
    Dim strmessage As String
    
    strmessage = CheckRevisionsStatus(objdoc)
    If strmessage <> vbNullString Then
        If MsgBox(strmessage & vbCrLf & vbCrLf & "Would you like to accept these changes now?", vbQuestion + vbYesNo, "Document Revisions") = vbYes Then
            objdoc.Revisions.AcceptAll
        End If
    End If
    
    strmessage = CheckTrackChangesStatus(objdoc)
    If strmessage <> vbNullString Then
        If MsgBox(strmessage & vbCrLf & vbCrLf & "Would you like to turn it off now?", vbQuestion + vbYesNo, "Track Changes") = vbYes Then
            objdoc.TrackRevisions = False
        End If
    End If
    
End Sub

Function FindTextInRange(ByRef rng As Range, ByVal strtext As String, Optional ByVal optwrap As WdFindWrap = wdFindContinue, _
                         Optional ByVal blprefix As Boolean = False, Optional ByVal blselect As Boolean = False) As Boolean
On Error GoTo Err_FindTextInRange

    Call ScreenUpdatePause
    
    With rng.Find
        .ClearFormatting
        .Forward = True
        .MatchWholeWord = False
        .MatchSoundsLike = False
        .MatchWildcards = False
        .MatchCase = True
        .MatchPrefix = blprefix
        .Wrap = optwrap
        FindTextInRange = .Execute(strtext)
    End With
    
    If FindTextInRange = True And blselect = True Then
        rng.Select
    End If

Exit_FindTextInRange:
    Call ScreenUpdateRestore
    Exit Function

Err_FindTextInRange:
    MsgBox Err.Description & " in FindTextInRange()"
    Resume Exit_FindTextInRange

End Function

Function InTocSection(ByRef rng As Range) As Boolean
    Dim toc As TableOfContents, tof As TableOfFigures
    
    For Each toc In rng.Document.TablesOfContents
        If rng.InRange(toc.Range) Then
            InTocSection = True
            Exit For
        End If
    Next toc

    If InTocSection = False Then
        For Each tof In rng.Document.TablesOfFigures
            If rng.InRange(tof.Range) Then
                InTocSection = True
                Exit For
            End If
        Next tof
    End If
    
End Function

Attribute VB_Name = "basDocumentHeadings"
Option Explicit

Function IsRangeHeading(ByRef rng As Range) As Boolean
    '==================================================================================================================================
    ' Purpose: Checks if the given range is a heading (must be outline numbered and must be formatted with a valid heading style)
    '==================================================================================================================================
    If rng.ListFormat.ListType = wdListOutlineNumbering Then
        If Not rng.Style Is Nothing Then
            If (rng.Style Like "Heading *" Or rng.Style Like "Appendix *") Then
                IsRangeHeading = True
            End If
        End If
    End If
End Function

Function GetHeadingsAsText(ByRef objdoc As Document) As String
    '==================================================================================================================================
    ' Purpose: Returns the current document headings and bookmark names if they are bookmarked
    '==================================================================================================================================
    Dim rng As Range, par As Paragraph, idx As Integer, strbookmark As String
    
    For idx = 1 To objdoc.ListParagraphs.Count
        Set rng = objdoc.ListParagraphs(idx).Range
        If IsRangeHeading(rng) Then ' only look at headings
            ' exclude the paragraph marker
            rng.MoveEnd wdCharacter, -1
            If rng.Bookmarks.Count > 0 Then
                strbookmark = rng.Bookmarks(1).Name
            Else
                strbookmark = vbNullString
            End If
            GetHeadingsAsText = GetHeadingsAsText & rng.Text & "," & strbookmark & vbCrLf
        End If
    Next idx
    
End Function

Function GetParentHeadingAsRange(ByRef rng As Range) As Range
    '==================================================================================================================================
    ' Purpose: Finds the first heading above the given range that is a level higher than the given level - returns the heading as a range
    '==================================================================================================================================
    Dim rngfind As Range, idx As Long, rngchild As Range, rngparent As Range
    
    ' get the heading that preceeds the range
    Set rngchild = GetHeadingAsRange(rng)
    
    ' search upwards from the child heading for the first higher-level heading
    Set rngfind = rngchild.Document.Range
    rngfind.SetRange 1, rngchild.Start
    For idx = rngfind.ListParagraphs.Count To 1 Step -1
        Set rngparent = rngfind.ListParagraphs(idx).Range
        If IsRangeHeading(rngparent) And rngparent.ListFormat.ListLevelNumber < rngchild.ListFormat.ListLevelNumber Then
            Set GetParentHeadingAsRange = rngparent
            Exit For
        End If
    Next idx
                                             
End Function

Function GetHeadingNumberAsRange(ByRef objdoc As Document, ByVal strheadingnumber As String) As Range
    '==================================================================================================================================
    ' Purpose: Returns a range object that represents the given heading number
    '==================================================================================================================================
    Dim rng As Range, idx As Long
    
    ' find the given heading text
    For idx = 1 To objdoc.ListParagraphs.Count
        Set rng = objdoc.ListParagraphs(idx).Range
        If IsRangeHeading(rng) Then ' only interested in headings
            If rng.ListFormat.ListString = strheadingnumber Then
                Set GetHeadingNumberAsRange = rng
                Exit For
            End If
        End If
    Next idx

End Function

Function GetHeadingAsRange(ByRef rng As Range) As Range
    '==================================================================================================================================
    ' Purpose: Returns the heading that preceeds the given range as a range
    '==================================================================================================================================
    Dim rngabove As Range, idx As Long, rngpar As Range
    
    If IsRangeHeading(rng) Then
        Set GetHeadingAsRange = rng.ListParagraphs(1).Range
    Else
        ' search upwards for the first heading
        Set rngabove = rng.Document.Range
        rngabove.SetRange 1, rng.Start ' set search range to range above given range
        For idx = rngabove.ListParagraphs.Count To 1 Step -1
            Set rngpar = rngabove.ListParagraphs(idx).Range
            If IsRangeHeading(rngpar) Then
                Set GetHeadingAsRange = rngpar
                Exit For
            End If
        Next idx
    End If
    
End Function

Function GetHeadingText(ByRef rng As Range) As String
    '==================================================================================================================================
    ' Purpose: Returns the heading text that preceeds the given range
    '==================================================================================================================================
    Dim rnghdg As Range
    
    Set rnghdg = GetHeadingAsRange(rng)
    If Not rnghdg Is Nothing Then
        GetHeadingText = Left(rnghdg.Text, Len(rnghdg.Text) - 1) ' don't take paragraph marker
        GetHeadingText = ConvertSpecialCharacters(GetHeadingText)
    Else
        GetHeadingText = Const_TEXT_UNKNOWN
    End If

End Function

Function GetHeadingNumber(ByRef rng As Range, Optional ByVal blstriptrailingdot As Boolean = True) As String
    '==================================================================================================================================
    ' Purpose: Returns the heading number that preceeds the given range
    '==================================================================================================================================
    Dim rnghdg As Range
    
    Set rnghdg = GetHeadingAsRange(rng)
    If Not rnghdg Is Nothing Then
        GetHeadingNumber = rnghdg.ListFormat.ListString
        If blstriptrailingdot And GetHeadingNumber Like "*." Then
            ' strip away trailing dot
            GetHeadingNumber = Left(GetHeadingNumber, Len(GetHeadingNumber) - 1)
        End If
    Else
        GetHeadingNumber = Const_TEXT_UNKNOWN
    End If

End Function

Function GetHeadingNumberAndText(ByRef rng As Range) As String
    '==================================================================================================================================
    ' Purpose: Returns the heading number and text that preceeds the given range
    '==================================================================================================================================
    Dim rnghdg As Range
    
    Set rnghdg = GetHeadingAsRange(rng)
    If Not rnghdg Is Nothing Then
        GetHeadingNumberAndText = GetHeadingNumber(rnghdg, False) & " " & GetHeadingText(rnghdg)
    Else
        GetHeadingNumberAndText = Const_TEXT_UNKNOWN
    End If

End Function

Function GetHeadingLevel(ByRef rng As Range) As String
    '==================================================================================================================================
    ' Purpose: Returns the heading level that preceeds the given range
    '==================================================================================================================================
    Dim rnghdg As Range
    
    Set rnghdg = GetHeadingAsRange(rng)
    If Not rnghdg Is Nothing Then
        GetHeadingLevel = rnghdg.ListFormat.ListLevelNumber
    Else
        GetHeadingLevel = 0
    End If

End Function

Function GetHeadingRangeExtendedFromText(ByRef rng As Range, ByVal strheadingtext As String, Optional ByVal strheadingnumber As String = vbNullString, _
                                         Optional ByRef varmessage As Variant) As Range
    '==================================================================================================================================
    ' Purpose: Returns a range object that represents the full range enclosed by the given heading
    '==================================================================================================================================
    Dim rngtemp As Range, rnghdg As Range, intlevel As Integer, idx As Long, strmessage As String
    
    ' find the first occurrence of the given heading text and number if specified
    For idx = 1 To rng.ListParagraphs.Count
        Set rngtemp = rng.ListParagraphs(idx).Range
        If IsRangeHeading(rngtemp) Then  ' only interested in headings
            If (GetHeadingText(rngtemp) = strheadingtext) And _
               (GetHeadingNumber(rngtemp) = strheadingnumber Or strheadingnumber = vbNullString) Then
                ' start the range and store the list level
                Set rnghdg = rngtemp
                intlevel = rnghdg.ListFormat.ListLevelNumber
                Exit For
            End If
        End If
    Next idx
                    
    ' now get the range to the end of the heading that was found from the subsequent list paragraphs
    If Not rnghdg Is Nothing Then
        ' if heading was found in last section, include to the end of the given range
        If idx = rng.ListParagraphs.Count Then
            rnghdg.End = rng.End
        Else
            For idx = idx + 1 To rng.ListParagraphs.Count
                Set rngtemp = rng.ListParagraphs(idx).Range
                ' if heading is at the same level or higher than the one found
                If IsRangeHeading(rngtemp) And rngtemp.ListFormat.ListLevelNumber <= intlevel Then
                    ' extend the range to this heading and exit loop
                    rnghdg.End = rngtemp.Start
                    Exit For
                End If
            Next idx
                
            ' if heading number not specified, check for duplicate headings in remainder of headings
            If strheadingnumber = vbNullString Then
                For idx = idx To rng.ListParagraphs.Count
                    If GetHeadingText(rngtemp) = strheadingtext Then
                        ' clear return reference and exit loop
                        strmessage = "Heading text '" & strheadingtext & "' found in multiple headings"
                        If IsMissing(varmessage) Then
                            MsgBox strmessage, vbExclamation, "DST Heading Range"
                        Else
                            varmessage = strmessage
                        End If
                        Set rnghdg = Nothing
                        Exit For
                    End If
                Next idx
            End If
        End If
    End If

    Set GetHeadingRangeExtendedFromText = rnghdg
    
End Function

Function GetHeadingRangeExtendedFromRange(ByRef rng As Range) As Range
    '==================================================================================================================================
    ' Purpose: Returns a range object that represents the full range enclosed by the heading above the given range
    '==================================================================================================================================
    Dim rnghdg As Range
    
    ' find the heading above the current range, stop when we hit the first page
    Set rnghdg = rng
    Do While rnghdg.Information(wdActiveEndPageNumber) > 1
        If rnghdg.ListParagraphs.Count = 1 And IsRangeHeading(rnghdg) Then
            Set rnghdg = rnghdg.ListParagraphs(1).Range
            Set GetHeadingRangeExtendedFromRange = GetHeadingRangeExtendedFromText(rnghdg.Document.Range, GetHeadingText(rnghdg), GetHeadingNumber(rnghdg))
            Exit Do
        End If
        Set rnghdg = rnghdg.Previous(wdParagraph)
    Loop
End Function

Function GetSubHeadingsInRange(ByRef rng As Range) As Scripting.Dictionary
    '==================================================================================================================================
    ' Description: Returns a dictionary of references to range objects that are sub-headings within the given range
    '==================================================================================================================================
    Dim dicsubhdgs As Scripting.Dictionary, rngsub As Range, intlevel As Integer, idx As Integer
    Set dicsubhdgs = New Scripting.Dictionary
    intlevel = GetHeadingListLevelNumber(rng)
    For idx = 1 To rng.ListParagraphs.Count
        Set rngsub = rng.ListParagraphs(idx).Range
        If IsRangeHeading(rngsub) And rngsub.ListFormat.ListLevelNumber > intlevel Then  ' only interested in headings
            dicsubhdgs.Add rngsub.ListFormat.ListString, rngsub
        End If
    Next idx
    Set GetSubHeadingsInRange = dicsubhdgs
End Function

Function GetHeadingStyleIndex(ByVal strheading As String) As Long
    '==================================================================================================================================
    ' Purpose: Returns the numerical value of the heading level based on the heading string
    '==================================================================================================================================
    Dim vartemp As Variant
    
    ' remove trailing '.'
    If Right(strheading, 1) = "." Then
        strheading = Left(strheading, Len(strheading) - 1)
    End If
    
    ' split the components into an array
    vartemp = Split(strheading, ".")
    
    ' Heading1 has a numerical style value of -2, Heading2 is -3, etc.
    GetHeadingStyleIndex = -2 - UBound(vartemp)
    
End Function

Function InsertHeadingSameLevel(ByRef rng As Range, ByVal strheadingtext As String) As Range
    Set InsertHeadingSameLevel = InsertHeading(rng, strheadingtext, GetHeadingListLevelNumber(rng))
End Function

Function InsertHeadingSubHeading(ByRef rng As Range, ByVal strheadingtext As String) As Range
    Set InsertHeadingSubHeading = InsertHeading(rng, strheadingtext, GetHeadingListLevelNumber(rng) + 1)
End Function

Function InsertHeading(ByRef rng As Range, ByVal strheadingtext As String, ByVal intlevel As Integer) As Range
    '==================================================================================================================================
    ' Purpose: Inserts the given level heading and adds an empty paragraph below it - returns the range of this empty paragraph
    '==================================================================================================================================
    rng.Collapse wdCollapseStart
    rng.Text = strheadingtext
    rng.Style = wdStyleHeading1 - intlevel + 1 ' Heading1 has a numerical style value of -2, Heading2 is -3, etc.
    rng.InsertParagraphAfter
    rng.Collapse wdCollapseEnd
    Set InsertHeading = rng
End Function

Function GetHeadingListLevelNumber(ByRef rng As Range) As Integer
    GetHeadingListLevelNumber = GetHeadingAsRange(rng).ListFormat.ListLevelNumber
End Function

Function InsertCrossReferenceToHeading(ByRef rng As Range, ByVal strheadingtext As String) As Boolean
    '==================================================================================================================================
    ' Purpose: Inserts a cross-reference to the heading number for the given heading text at the given range.
    '==================================================================================================================================
    Dim idx As Long
    idx = GetHeadingCrossReferenceItemIndex(rng.Document, strheadingtext)
    If idx > 0 Then
        rng.InsertCrossReference wdRefTypeHeading, wdNumberNoContext, idx, True
        InsertCrossReferenceToHeading = True
    End If
End Function

Function GetHeadingCrossReferenceItemIndex(ByRef objdoc As Document, strheadingtext As String) As Long
    '==================================================================================================================================
    ' Purpose: Returns the index of the given heading as returned by the GetCrossReferenceItems method so to used with the
    '          InsertCrossReference method.
    '==================================================================================================================================
    Dim varitems As Variant, idx As Long
    varitems = objdoc.GetCrossReferenceItems(wdRefTypeHeading)
    For idx = 1 To UBound(varitems)
        If varitems(idx) Like "*" & strheadingtext Then ' need wildcard because sub-headings are padded with whitespace
            GetHeadingCrossReferenceItemIndex = idx
            Exit For
        End If
    Next idx
End Function

Function IsInAppendixRange(ByRef rng As Range)
    Dim rnghdg As Range
    Set rnghdg = GetHeadingAsRange(rng)
    If Not rnghdg Is Nothing Then
        IsInAppendixRange = (rnghdg.Style Like "*Appendix *")
    End If
End Function
Attribute VB_Name = "basDocumentPrepare"
Option Explicit

' Draft issue number string
Private Const Conststr_DRAFT As String = " Draft "

Function PrepareForEdit(ByRef objdoc As Document, ByRef frm As Object) As Boolean
    Dim strissue As String, lngpropindex As Long, bldraft As Boolean
    Dim struser As String, strmessage As String, intpos As Integer, rw As Row, rng As Range
    
    frm.UpdateProgressText "Preparing '" & objdoc.Name & "' for edit ..."
    
    ' get the next issue number and prepare the document
    If MsgBox("Would you like to up-issue the document to the next draft issue?" & vbCrLf & "(Clicking 'No' will create the next formal issue)", vbQuestion + vbYesNo, "Document Issue Number") = vbYes Then
        bldraft = True
    End If
    strissue = Dst.Document(objdoc.Fullname).Properties.Issue
    If strissue <> vbNullString Then
        strissue = GetNextIssueNumber(strissue, bldraft)
    Else
        strissue = "Unknown"
        frm.UpdateProgressText "   INFO: Could not determine the next document issue number - update it manually."
    End If
    
    ' prepare the document
    strmessage = PrepareDocument(objdoc, strissue, rw, frm)
    
    ' set the insertion point to 3rd column
    If Not rw Is Nothing Then
        Set rng = rw.Cells(3).Range
        rng.Start = rng.End - 1
        rng.End = rng.Start
        rng.Select
    End If

    ' provide status feedback
    If strmessage = vbNullString Then
        frm.UpdateProgressText "Document successfully prepared for edit" & IIf(Not rw Is Nothing, " - remember to fill in the Change Reference and Change Summary columns at the insertion point", ".")
        PrepareForEdit = True
    End If

End Function

'======================================================================================================================
' Updates the relevant document properties and amendment record - also updates all fields.
' NOTE: This function is also called from SDLC, so take care when changing the API
'======================================================================================================================
Private Function PrepareDocument(ByRef objdoc As Document, ByVal strissue As String, _
                                 Optional ByRef rw As Row, Optional ByRef frm As Object) As String
    Dim docinfo As cDocInfo
    Dim strdate As String, strmessage As String, strstatus As String, blshowprogress As Boolean
    
    ' check if we need to show progress
    blshowprogress = Not frm Is Nothing
    
    If Not objdoc.ReadOnly Then
        Set docinfo = Dst.Document(objdoc.Fullname)
        
        ' update issue property
        If blshowprogress Then frm.UpdateProgressText "Updating the " & docinfo.Properties.PropertyNameIssue & " property to '" & strissue & "' ..."
        docinfo.Properties.Issue = strissue
        
        ' update date property
        strdate = Format(Date, "dd mmmm yyyy")
        If blshowprogress Then frm.UpdateProgressText "Updating the " & docinfo.Properties.PropertyNameDate & " property to '" & strdate & "' ..."
        docinfo.Properties.DocDate = strdate
        
        ' update the Amendment Record
        If blshowprogress Then frm.UpdateProgressText "Updating the Amendment Record ..."
        If Not UpdateAmendmentRecord(objdoc, strissue, strstatus, rw) Then
            strstatus = "   ERROR: " & strstatus & vbCrLf
            If blshowprogress Then frm.UpdateProgressText strstatus, False
            strmessage = strmessage & "   ERROR: " & strstatus
        End If
        
        ' update all fields
        If Not UpdateAllFields(objdoc, frm) Then
            strstatus = "   ERROR: One of more fields could not be updated." & vbCrLf
            If blshowprogress Then frm.UpdateProgressText strstatus, False
            strmessage = strmessage & strstatus
        End If
    Else
        strstatus = "   ERROR: Unable to edit - the document is read-only." & vbCrLf
        If blshowprogress Then frm.UpdateProgressText strstatus, False
        strmessage = strmessage & strstatus
    End If
    
    PrepareDocument = strmessage
    
End Function

Function GetNextIssueNumber(ByVal strrefissue As String, ByVal bldraft As Boolean) As String
    Dim strnextrefissue As String
    Dim strissuepart As String, lngissuenumber As Long
    Dim strdraftpart As String, strdraftprefix As String, strdraftnumber As String
On Error GoTo Err_GetNextIssueNumber
    
    GetNextIssueNumber = vbNullString
    
    ' get the issue components
    Call GetRefIssueComponents(strrefissue, strissuepart, strdraftpart)
    
    ' Determine the latest issue number and draft number
    If strdraftpart <> vbNullString Then ' Latest issue is a draft issue
        ' get the issue number left of the draft part
        lngissuenumber = Val(strissuepart)
        
        ' get the draft number from the end
        strdraftnumber = Right(strdraftpart, 1)
        
        ' get the draft prefix
        strdraftprefix = Left(strdraftpart, Len(strdraftpart) - Len(strdraftnumber))
    Else
        lngissuenumber = Val(strissuepart)
        strdraftnumber = vbNullString
    End If
            
    If strdraftnumber <> vbNullString Then  ' Latest issue is a draft issue
        If bldraft = True Then
            ' increment draft number
            strdraftnumber = Chr(Asc(strdraftnumber) + 1)
            strnextrefissue = strissuepart & Conststr_DRAFT & strdraftprefix & strdraftnumber
        Else
            ' formal issue number is the current issue number
            strnextrefissue = Format(str(lngissuenumber), String(Len(strissuepart), "0"))
        End If
    Else ' Latest issue is a formal issue
        lngissuenumber = lngissuenumber + 1
        strnextrefissue = Format(str(lngissuenumber), String(Len(strissuepart), "0"))
        If bldraft = True Then
            ' append first draft
            strnextrefissue = strnextrefissue & Conststr_DRAFT & "A"
        End If
    End If
    
    GetNextIssueNumber = strnextrefissue
    
Exit_GetNextIssueNumber:
    Exit Function

Err_GetNextIssueNumber:
    MsgBox Err.Description & " in GetNextIssueNumber()"
    Resume Exit_GetNextIssueNumber

End Function

Sub GetRefIssueComponents(ByVal strrefissue As String, ByRef strissuepart As String, ByRef strdraftpart As String)
    Dim intpos As Integer
On Error GoTo Err_GetRefIssueComponents
    
    ' set defaults
    strissuepart = Trim(strrefissue)
    strdraftpart = vbNullString
    
    ' break the issue number into its components if the draft exists
    intpos = InStr(1, strrefissue, Conststr_DRAFT)
    If intpos > 0 Then
        strissuepart = Trim(Left(strrefissue, intpos))
        strdraftpart = Trim(Right(strrefissue, Len(strrefissue) - Len(Conststr_DRAFT) - intpos + 1))
    End If

Exit_GetRefIssueComponents:
    Exit Sub

Err_GetRefIssueComponents:
    MsgBox Err.Description & " in GetRefIssueComponents()"
    Resume Exit_GetRefIssueComponents

End Sub
Attribute VB_Name = "basDocuments"
Option Explicit

Public Const Const_DOC_AMENDMENT_RECORD As String = "AMENDMENTS"
Public Const Const_DOC_LIST_OF_ABBREVIATIONS As String = "ABBREVIATIONS"
Public Const Const_DOC_LIST_OF_DEFINITIONS As String = "DEFINITIONS"
Public Const Const_DOC_DOCUMENT_CONVENTIONS As String = "DOCUMENT CONVENTIONS"

Function IsDocumentOpen(ByVal strfullname As String, Optional ByRef objdoc As Document, _
                        Optional ByVal blopen As Boolean = True, Optional ByVal blvisible As Boolean = False) As Boolean
' Checks whether the given document is open, opens it, if requested, and returns a reference to it, if requested
    Dim objdocopen As Document, fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    IsDocumentOpen = False
    For Each objdocopen In Documents
        If LCase(objdocopen.Fullname) = LCase(strfullname) Then
            IsDocumentOpen = True
            If Not IsMissing(objdoc) Then
                Set objdoc = objdocopen
            End If
            If blopen And blvisible Then
                objdocopen.ActiveWindow.Visible = True
                objdocopen.ActiveWindow.Activate
            End If
            Exit For
        End If
    Next objdocopen
    
    If blopen And Not IsDocumentOpen Then
        If fso.FileExists(strfullname) Then
            Set objdocopen = Documents.Open(strfullname, AddToRecentFiles:=False, Revert:=False, Visible:=blvisible)
            If Not objdocopen Is Nothing Then
                If Not IsMissing(objdoc) Then
                    Set objdoc = objdocopen
                End If
            End If
        End If
    End If
    
End Function

Function CreateNewDocument(ByVal strtemplatename As String, ByVal strsubtemplatename As String, Optional ByVal strdocname As String = vbNullString) As Document
    Dim objdoc As Document, objdocsub As Document, rng As Range, rngsub As Range, docinfo As cDocInfo, varnameparts As Variant
    Dim dlgfileopen As FileDialog, fso As FileSystemObject, strcurdir As String, strmessage As String, strsubject As String
On Error GoTo Err_CreateNewDocument
    
    Set fso = New FileSystemObject
    
    ' default the save to folder to the current document's folder
    strcurdir = ActiveDocument.Path
    
    If strtemplatename <> vbNullString Then
        Set objdoc = Documents.Add(strtemplatename)
        
        ' check if a new document was created and then save it
        If Not objdoc Is Nothing Then
            Set docinfo = Dst.Document(objdoc.Fullname)
            objdoc.AttachedTemplate = vbNullString ' detach from template
            docinfo.Variables.MasterTemplateUsed = strtemplatename
            Call ManageMasterTemplateDate(objdoc, True)
            ' use supplied name if defined
            If strdocname <> vbNullString Then
                objdoc.SaveAs strdocname
            Else
                ' build new name from parts
                varnameparts = GetPartsFromTemplateFilename(strsubtemplatename)
                If varnameparts(2) = vbNullString Then
                    strdocname = varnameparts(1) ' use category as the type
                Else
                    strdocname = varnameparts(2)
                End If
                strdocname = fso.BuildPath(strcurdir, strdocname & "_new")
                Set dlgfileopen = Application.FileDialog(msoFileDialogSaveAs)
                With dlgfileopen
                    .Title = "Save New Document As"
                    .InitialFileName = strdocname
                    If .Show = -1 Then
                        strdocname = .SelectedItems(1)
                        objdoc.SaveAs strdocname, wdFormatDocumentDefault ' save in the default format
                    Else
                        ' the user pressed Cancel
                        objdoc.Close False
                        Set objdoc = Nothing
                    End If
                End With
            End If
            
            If Not objdoc Is Nothing Then
                ' set document type property based on subject field
                If strsubtemplatename <> vbNullString Then
                    ' set document type property using template's Subject property
                    strsubject = Dst.Document(strsubtemplatename).Properties.BuiltIn(wdPropertySubject)
                    If strsubject <> vbNullString Then
                        docinfo.Properties.TypeText = strsubject
                        Call UpdateDocumentPropertyRefs(objdoc, docinfo.Properties.PropertyNameType)
                        strsubject = vbNullString
                    Else
                        strsubject = "Unable to retrieve built-in 'Subject' property from template '" & strsubtemplatename & "'."
                    End If
                    If strsubject <> vbNullString Then
                        MsgBox strsubject, vbExclamation
                    End If
                    
                    ' insert sub-template content if sub-template name has been supplied
                    If strsubtemplatename <> strtemplatename Then
                        If fso.GetBaseName(strsubtemplatename) Like "*trcr" Then
                            ' delete existing TRC section because we're about to insert a new one
                            Set rng = GetHeadingRangeExtendedFromText(objdoc.Range, "TRACEABILITY RELATIONSHIPS")
                            If Not rng Is Nothing Then rng.Delete
                        End If
                        Set objdocsub = Documents.Add(strsubtemplatename, True)
                        Set rngsub = objdocsub.Range
                        Set rng = GetHeadingNumberAsRange(objdoc, "3.") ' insert after Introduction section
                        rng.SetRange rng.Start, rng.Start
                        rng.FormattedText = rngsub.FormattedText
                        objdocsub.Close False
                    End If
                    
                    ' update Amendments page
                    If Not UpdateAmendmentRecord(objdoc, "1 Draft A", strmessage) Then
                        MsgBox "Unable to update Amendments page.", vbExclamation
                    End If
                End If
                                
                ' set date property if it exists
                If docinfo.Properties.DocDate <> vbNullString Then
                    docinfo.Properties.DocDate = Format(Date, "dd MMMM yyyy")
                    Call UpdateDocumentPropertyRefs(objdoc, docinfo.Properties.PropertyNameDate)
                End If
                
                objdoc.Save
                Set CreateNewDocument = objdoc
            End If
        End If
    End If
    
Exit_CreateNewDocument:
    Set dlgfileopen = Nothing
    Set fso = Nothing
    Exit Function
    
Err_CreateNewDocument:
    MsgBox Err.Description & " in CreateNewDocument()"
    Resume Exit_CreateNewDocument
End Function

Function MakeDocumentBackup(ByRef objdoc As Document, ByRef frmtext As Object) As Boolean
    Dim fso As FileSystemObject, strfullname As String, strdestination As String
    Dim strfolder As String, strbase As String, strext As String, strdate As String
On Error GoTo Err_MakeDocumentBackup

    Set fso = New FileSystemObject
    
    strfullname = objdoc.Fullname
    strfolder = fso.GetParentFolderName(strfullname)
    strbase = fso.GetBaseName(strfullname)
    strext = fso.GetExtensionName(strfullname)
    strdate = Format(Now(), "yyyy-mm-dd.hh-nn-ss")
    If StrComp(strfolder, Application.StartupPath, vbTextCompare) = 0 Then
        strext = strext & "." & strdate ' hide real extension so Word does not load multiple DST projects at start-up
    Else
        strext = strdate & "." & strext
    End If
    strdestination = strbase & "." & strext
    strdestination = fso.BuildPath(strfolder, strdestination)
    fso.CopyFile strfullname, strdestination
    frmtext.UpdateProgressText "Back-up copy '" & strdestination & "' created."
    MakeDocumentBackup = True
    
Exit_MakeDocumentBackup:
    Exit Function
    
Err_MakeDocumentBackup:
    frmtext.UpdateProgressText Err.Description & " in MakeDocumentBackup()"
    Resume Exit_MakeDocumentBackup
End Function

Function ExportDocumentPdf(ByRef objdoc As Document, ByRef frmtext As Object) As Boolean
    Dim fso As FileSystemObject, blexport As Boolean
    Dim strfullname As String, strdestination As String, strfolder As String, strbase As String
On Error GoTo Err_ExportDocumentPdf

    Set fso = New FileSystemObject
    
    strfullname = objdoc.Fullname
    strfolder = fso.GetParentFolderName(strfullname)
    strbase = fso.GetBaseName(strfullname)
    strdestination = strbase & ".pdf"
    strdestination = fso.BuildPath(strfolder, strdestination)
    blexport = True
    If fso.FileExists(strdestination) Then
        If MsgBox("'" & strdestination & "' already exists, overwrite?", vbYesNo) = vbNo Then
            frmtext.UpdateProgressText "Export aborted."
            blexport = False
        End If
    End If
    
    If blexport Then
        objdoc.ExportAsFixedFormat strdestination, wdExportFormatPDF, True, wdExportOptimizeForPrint, _
                                   wdExportAllDocument, , , , True, , wdExportCreateHeadingBookmarks
        frmtext.UpdateProgressText "Exported PDF to '" & strdestination & "'."
        ExportDocumentPdf = True
    End If
    
Exit_ExportDocumentPdf:
    Exit Function
    
Err_ExportDocumentPdf:
    frmtext.UpdateProgressText Err.Description & " in ExportDocumentPdf()"
    Resume Exit_ExportDocumentPdf
End Function

Function TransferDocumentToNewTemplate(ByRef objdoc As Document, ByVal strcaption As String) As Boolean
    Dim objdocnew As Document, strdocname As String, strolddocname As String, strtemp As String, strmessage As String
    Dim frmnew As Object, tblref As Table, tblnew As Table
    Dim rng As Range, rngnew As Range
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    TransferDocumentToNewTemplate = True
    
    '====================================================================================================================
    ' save document, close it, rename it and re-open it
    '====================================================================================================================
    strdocname = objdoc.Fullname
    strolddocname = fso.BuildPath(objdoc.Path, fso.GetBaseName(objdoc.Name) & ".old." & fso.GetExtensionName(objdoc.Name))
    If fso.FileExists(strolddocname) Then fso.DeleteFile strolddocname
    objdoc.Close wdSaveChanges
    fso.MoveFile strdocname, strolddocname
    Set objdoc = Documents.Open(strolddocname)
        
    '====================================================================================================================
    ' create a new blank document under new name
    '====================================================================================================================
    'ACZ do via new document template selection form
    'Set objdocnew = CreateNewDocument(GetMasterTemplateName, strdocname, True)
    If Not objdocnew Is Nothing Then
        Set frmnew = OpenUserForm("frmTextBox", objdocnew)
        frmnew.Caption = strcaption
        frmnew.UpdateProgressText "Saved old document as '" & fso.GetFileName(strolddocname) & "'..."
        frmnew.UpdateProgressText "Created new document..."
    Else
        Exit Function
    End If
    
    '====================================================================================================================
    ' find Help Text ranges, clear text and change style to Body Text
    '====================================================================================================================
    frmnew.UpdateProgressText "Removing help text..."
    Call ChangeStyle(objdocnew, "HelpText", "Body Text", "Table Text", True)
    Call ChangeStyle(objdocnew, "HelpTextBullet", "Body Text", "Table Text", True)
    
    '====================================================================================================================
    ' copy document references table from new template to below Amandment Record temporarily so we have a table template to work with later
    '====================================================================================================================
    frmnew.UpdateProgressText "Copying template reference table..."
    Set tblref = GetTableBeneathText(objdocnew, "Specifications and Reference Documents", strmessage)
    If Not tblref Is Nothing Then
        Set tblnew = GetTableBeneathText(objdocnew, Const_DOC_AMENDMENT_RECORD, strmessage)
        If Not tblnew Is Nothing Then
            Set rngnew = tblnew.Range
            rngnew.Move wdCharacter
            rngnew.InsertParagraph
            rngnew.Collapse wdCollapseEnd
            rngnew.FormattedText = tblref.Range.FormattedText
            Set tblref = rngnew.Tables(1)
        Else
            TransferDocumentToNewTemplate = False
            frmnew.UpdateProgressText "  ERROR: " & strmessage
        End If
    Else
        TransferDocumentToNewTemplate = False
        frmnew.UpdateProgressText "  ERROR: " & strmessage
    End If
    
    '====================================================================================================================
    ' remove landscape section
    '====================================================================================================================
    frmnew.UpdateProgressText "Removing landscape page..."
    Set rngnew = GetHeadingRangeExtendedFromText(objdocnew.Range, "Landscape Pages")
    Call RemoveLandscapeSection(rngnew)
    
    '====================================================================================================================
    ' update document properties and the title
    '====================================================================================================================
    frmnew.UpdateProgressText "Updating document properties..."
    Call TransferTemplateCustomPropertiesRequired(objdoc, objdocnew)
    Call TransferTemplateCustomPropertiesOptional(objdoc, objdocnew)
    
    '====================================================================================================================
    ' transfer Amendment Record - delete Paragraph column if required
    '====================================================================================================================
    frmnew.UpdateProgressText "Transferring the " & Const_DOC_AMENDMENT_RECORD & " table..."
    If Not TransferAmendmentRecord(objdoc, objdocnew, frmnew) Then
        TransferDocumentToNewTemplate = False
    End If
    
    '====================================================================================================================
    ' transfer List of Abbreviations
    '====================================================================================================================
    frmnew.UpdateProgressText "Transferring " & Const_DOC_LIST_OF_ABBREVIATIONS & " table..."
    If Not TransferTableContent(objdoc, objdocnew, frmnew, Const_DOC_LIST_OF_ABBREVIATIONS) Then
        TransferDocumentToNewTemplate = False
    End If
    
    '====================================================================================================================
    ' transfer List of Definitions
    '====================================================================================================================
    frmnew.UpdateProgressText "Transferring " & Const_DOC_LIST_OF_DEFINITIONS & " table..."
    If Not TransferTableContent(objdoc, objdocnew, frmnew, Const_DOC_LIST_OF_DEFINITIONS) Then
        TransferDocumentToNewTemplate = False
    End If
    
    '====================================================================================================================
    ' transfer Document Conventions
    '====================================================================================================================
    frmnew.UpdateProgressText "Transferring the " & Const_DOC_DOCUMENT_CONVENTIONS & " table..."
    If Not TransferTableContent(objdoc, objdocnew, frmnew, Const_DOC_DOCUMENT_CONVENTIONS) Then
        TransferDocumentToNewTemplate = False
    End If
    
    '====================================================================================================================
    ' transfer content from section 1 onwards
    '====================================================================================================================
    frmnew.UpdateProgressText "Transferring document content..."
    Set rng = GetHeadingNumberAsRange(objdoc, "1.")
    rng.SetRange rng.Start, objdoc.Range.End
    Set rngnew = GetHeadingNumberAsRange(objdocnew, "1.")
    rngnew.SetRange rngnew.Start, objdocnew.Range.End
    rngnew.Delete
    rngnew.FormattedText = rng.FormattedText
        
    '====================================================================================================================
    ' transfer programme pictures - cover and header
    '====================================================================================================================
    frmnew.UpdateProgressText "Transferring pictures..."
    Call TransferPictures(objdoc, objdocnew, frmnew)
    
    '====================================================================================================================
    ' transferring document references - assume they're all in section 2
    '====================================================================================================================
    Set rngnew = GetHeadingRangeExtendedFromText(objdocnew.Range, GetHeadingText(GetHeadingNumberAsRange(objdocnew, "2.")))
    For Each tblnew In rngnew.Tables
        frmnew.UpdateProgressText "Transferring references in section " & GetHeadingNumber(tblnew.Range) & "..."
        Call TransferDocumentReferences(frmnew, tblref, tblnew)
    Next tblnew
    
    '====================================================================================================================
    ' delete template reference table and the blank line in between
    '====================================================================================================================
    Set rngnew = tblref.Range
    rngnew.MoveStart wdParagraph, -1
    rngnew.Delete
    
    '====================================================================================================================
    ' update fields and fix document title
    '====================================================================================================================
    Call UpdateAllFields(objdocnew, frmnew, False)
    Call CheckDocTitle(objdocnew, True, False)
    objdocnew.Save
    
    '====================================================================================================================
    ' additional instructions
    '====================================================================================================================
    frmnew.UpdateProgressText vbCrLf & "NOTE 1:" & vbCrLf & "The document title was generated from the template - review and update the title on the Cover Page if required."
    frmnew.UpdateProgressText "NOTE 2:" & vbCrLf & "The Approval Page was generated from the template - review it and remove the table sections that do not apply."
    frmnew.UpdateProgressText "NOTE 3:" & vbCrLf & "Review the document structure against the associated type-specific template to ensure that all structural requirements are met."
    frmnew.UpdateProgressText "NOTE 4:" & vbCrLf & "Run the 'Check Document' function, review the errors and compare the document with '" & objdoc.Name & "' to ensure that the tranfer to the new template was correct."
    frmnew.ShowStatus TransferDocumentToNewTemplate
    
End Function

Private Sub TransferTemplateCustomPropertiesRequired(ByRef objdoc As Document, ByRef objdocnew As Document)
    Dim propsnew As cDocProps, props As cDocProps
    
    Set propsnew = Dst.Document(objdocnew.Fullname).Properties
    Set props = Dst.Document(objdoc.Fullname).Properties
    
    propsnew.Number = props.Number
    propsnew.Issue = props.Issue
    propsnew.DocDate = props.DocDate
    propsnew.TypeText = props.TypeText
    propsnew.Classification = props.Classification
    propsnew.Programme = props.Programme
    propsnew.Project = props.Project
    
End Sub

Private Sub TransferTemplateCustomPropertiesOptional(ByRef objdoc As Document, ByRef objdocnew As Document)
    Dim props As cDocProps, propsnew As cDocProps
    
    Set propsnew = Dst.Document(objdocnew.Fullname).Properties
    Set props = Dst.Document(objdoc.Fullname).Properties
    
    If props.Location <> vbNullString Then propsnew.Location = props.Location
    If props.CSCI <> vbNullString Then propsnew.CSCI = props.CSCI
    If props.Appendix <> vbNullString Then propsnew.Appendix = props.Appendix
    
End Sub

Private Function TransferAmendmentRecord(ByRef objdoc As Document, ByRef objdocnew As Document, frmnew As Object) As Boolean
    Dim tbl As Table, tblnew As Table, rw As Row, cel As Cell
    Dim strmessage As String, idxoffset As Integer
    
    TransferAmendmentRecord = True
    
    Set tbl = GetTableBeneathText(objdoc, Const_DOC_AMENDMENT_RECORD, strmessage)
    If Not tbl Is Nothing Then
        Set tblnew = GetTableBeneathText(objdocnew, Const_DOC_AMENDMENT_RECORD, strmessage)
        If Not tblnew Is Nothing Then
            ' add extra rows to the new table if required
            While tblnew.Rows.Count < tbl.Rows.Count
                tblnew.Rows.Add
            Wend
            ' template has five columns, so remove extra column if source table only has 4
            If tbl.Columns.Count = 4 Then
                tblnew.Columns(2).Delete
                Call FormatTable(tblnew)
            End If
            For Each rw In tbl.Rows
                If rw.Index > 1 Then ' skip header row
                    idxoffset = 0
                    For Each cel In rw.Cells
                        If rw.Cells.Count = 6 And cel.ColumnIndex = 3 Then
                            ' skip pages column
                            idxoffset = -1
                        Else
                            tblnew.Cell(rw.Index, cel.ColumnIndex + idxoffset).Range.Text = GetCellText(cel)
                        End If
                    Next cel
                End If
            Next rw
        Else
            TransferAmendmentRecord = False
            frmnew.UpdateProgressText "  ERROR: " & strmessage
        End If
    Else
        TransferAmendmentRecord = False
        frmnew.UpdateProgressText "  ERROR: " & strmessage
    End If
    
End Function

Private Function TransferTableContent(ByRef objdoc As Document, ByRef objdocnew As Document, ByRef frmnew As Object, ByVal strtextabovetable As String) As Boolean
    Dim tbl As Table, tblnew As Table, rw As Row, cel As Cell, rng As Range
    Dim strmessage As String
    
    TransferTableContent = True
    
    Set tbl = GetTableBeneathText(objdoc, strtextabovetable, strmessage)
    If Not tbl Is Nothing Then
        Set tblnew = GetTableBeneathText(objdocnew, strtextabovetable, strmessage)
        If Not tblnew Is Nothing Then
            ' add extra rows to the new table if required
            While tblnew.Rows.Count < tbl.Rows.Count
                tblnew.Rows.Add
            Wend
            For Each rw In tbl.Rows
                For Each cel In rw.Cells
                    Set rng = cel.Range
                    rng.MoveEnd wdCharacter, -1 ' exclude end-of-cell marker
                    tblnew.Cell(rw.Index, cel.ColumnIndex).Range.FormattedText = rng.FormattedText
                Next cel
            Next rw
        Else
            TransferTableContent = False
            frmnew.UpdateProgressText "  WARNING: " & strmessage
        End If
    Else
        TransferTableContent = False
        frmnew.UpdateProgressText "  WARNING: " & strmessage
    End If
    
End Function

Private Sub TransferPictures(ByRef objdoc As Document, ByRef objdocnew As Document, ByRef frmnew As Object)
    Dim rng As Range, rngnew As Range, sect As section
    
    ' transfer programme pictures - cover and header
    If objdoc.Tables(1).Columns.Count > 1 Then
        Set rng = objdoc.Tables(1).Cell(2, 2).Range ' old cover picture
        rng.MoveEnd wdCharacter, -1 ' exclude end-of-cell marker
        If rng.InlineShapes.Count > 0 Then
            Set rngnew = objdocnew.Tables(1).Cell(2, 2).Range
            rngnew.InlineShapes(1).Delete
            rngnew.FormattedText = rng.FormattedText
        Else
            frmnew.UpdateProgressText "  WARNING: No Programme-specific picture found in old document - Cover Page picture not updated..."
        End If
    Else
        frmnew.UpdateProgressText "  WARNING: No Programme-specific picture found in old document - Cover Page picture not updated..."
    End If
    Set rng = objdoc.Sections(1).Headers(wdHeaderFooterPrimary).Range
    If rng.Tables.Count > 0 Then
        Set rng = rng.Tables(1).Range
        If rng.Cells.Count > 2 Then
            Set rng = rng.Cells(3).Range ' old header picture
            rng.MoveEnd wdCharacter, -1 ' exclude end-of-cell marker
            If rng.InlineShapes.Count > 0 Then
                For Each sect In objdocnew.Sections
                    Set rngnew = sect.Headers(wdHeaderFooterPrimary).Range.Tables(1).Cell(1, 3).Range
                    rngnew.InlineShapes(1).Delete
                    rngnew.FormattedText = rng.FormattedText
                Next sect
            Else
                frmnew.UpdateProgressText "  WARNING: No Programme-specific picture found in old document - header pictures not updated..."
            End If
        Else
            frmnew.UpdateProgressText "  WARNING: Table in old document header has less than three cells - header pictures not updated..."
        End If
    Else
        frmnew.UpdateProgressText "  WARNING: No table found in old document header - header pictures not updated..."
    End If
    
End Sub

Private Sub TransferDocumentReferences(ByRef frmnew As Object, ByRef tbltemplate As Table, ByRef tbl As Table)
    Dim tblnew As Table, rng As Range, rw As Row, cel As Cell
    Dim strmessage As String, strrefbookmark As String, strtitlebookmark As String
    
    ' transfer content if table does not have two columns
    If tbl.Columns.Count > 2 Then
        ' insert the template table
        Set rng = tbl.Range
        rng.MoveStart wdCharacter, -1
        rng.InsertParagraphBefore
        rng.Collapse wdCollapseStart
        rng.Move wdCharacter
        rng.FormattedText = tbltemplate.Range.FormattedText
        Set tblnew = rng.Tables(1)
        
        ' adjust number of rows so they're equal
        While tblnew.Rows.Count < tbl.Rows.Count
            tblnew.Rows.Add
        Wend
        While tblnew.Rows.Count > tbl.Rows.Count
            tblnew.Rows(tblnew.Rows.Count).Delete
        Wend
        
        For Each rw In tbl.Rows
            strrefbookmark = vbNullString
            strtitlebookmark = vbNullString
            For Each cel In rw.Cells
                Select Case cel.ColumnIndex
                    Case 1
                        If cel.Range.Bookmarks.Count > 0 Then
                            strrefbookmark = cel.Range.Bookmarks(1).Name
                        End If
                        
                    Case 2
                        Set rng = cel.Range
                        rng.MoveEnd wdCharacter, -1 ' exclude end-of-cell marker
                        If rng.Characters.Count > 1 Then ' if the cell is not empty
                            tblnew.Cell(rw.Index, 2).Range.FormattedText = rng.FormattedText
                        End If
                        ' assume document numbers are never bookmarked
                        
                    Case 3
                        Set rng = cel.Range
                        rng.MoveEnd wdCharacter, -1 ' exclude end-of-cell marker
                        ' use data if the cell is not empty, else delete the row
                        If rng.Characters.Count > 1 Then
                            tblnew.Cell(rw.Index, 1).Range.FormattedText = rng.FormattedText
                            If rng.Bookmarks.Count > 0 Then
                                strtitlebookmark = rng.Bookmarks(1).Name
                            End If
                        Else
                            tblnew.Rows(tblnew.Rows.Count).Delete ' always delete last row
                            Exit For
                        End If
                End Select
            Next cel
            
            ' fix references to bookmarks
            If strrefbookmark <> vbNullString Then Call ReplaceBookmarkReference(tbl.Range.Document, strrefbookmark, tblnew.Cell(rw.Index, 1).Range.ListFormat.ListString, wdNumberNoContext)
            If strtitlebookmark <> vbNullString Then Call ReplaceBookmarkReference(tbl.Range.Document, strtitlebookmark, tblnew.Cell(rw.Index, 1).Range.ListFormat.ListString, wdContentText)
            
        Next rw
        
        ' delete old table and the blank line in between
        Set rng = tbl.Range
        rng.MoveStart wdParagraph, -1
        rng.Delete
    End If
    
End Sub
    
Private Sub ReplaceBookmarkReference(ByRef objdoc As Document, ByVal strbookmark As String, ByVal strrefnumber As String, refkind As WdReferenceKind)
    Dim stryrng As Range, rng As Range, fld As Word.Field, varxrefs As Variant, idx As Integer
    
    strrefnumber = Replace(strrefnumber, "[", "[[]") ' this is so the Like operator below works
    varxrefs = ActiveDocument.GetCrossReferenceItems(wdRefTypeNumberedItem)
    For idx = 1 To UBound(varxrefs)
        If varxrefs(idx) Like strrefnumber & "*" Then
            ' search for the bookmark name in all reference fields
            For Each stryrng In objdoc.StoryRanges
                Do
                    For Each fld In stryrng.Fields
                        If fld.Type = wdFieldRef Then
                            If RegularExpressionSearch(fld.Code.Text, strbookmark, True) Then
                                Set rng = fld.Result
                                fld.Delete
                                rng.InsertCrossReference wdRefTypeNumberedItem, refkind, idx, True
                            End If
                        End If
                    Next fld
                    Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
                Loop Until stryrng Is Nothing
            Next stryrng
            Exit For
        End If
    Next idx
    
End Sub
Attribute VB_Name = "basEquations"
Option Explicit

Sub InsertEquation(ByRef rng As Range)
    Dim tbl As Table, rngref As Range, blinappendix As Boolean, objmath As OMath
On Error GoTo Err_InsertEquation

    Call ScreenUpdatePause
    
    ' insert blank paragraph if there's already a table above insertion point
    If rng.Previous(wdParagraph).Tables.Count <> 0 Then
        rng.InsertParagraphBefore
        rng.Collapse wdCollapseEnd
    End If
    
    Set tbl = rng.Tables.Add(rng, 1, 2, wdWord9TableBehavior, wdAutoFitFixed)
    With tbl
        With .Cell(1, 2)
            .Range.Columns(1).SetWidth CentimetersToPoints(3), wdAdjustNone
            .Range.ParagraphFormat.Alignment = wdAlignParagraphRight
            .VerticalAlignment = wdCellAlignVerticalCenter
            Set rngref = .Range
            blinappendix = IsInAppendixRange(rngref)
            rngref.Collapse wdCollapseStart
            rngref.Fields.Add rngref, wdFieldSequence, "Equation \s " & IIf(blinappendix, "7", "1"), False ' 1st level appendix style (Appendix 1) starts at level 7
            rngref.InsertBefore "-"
            rngref.Collapse wdCollapseStart
            rngref.Fields.Add rngref, wdFieldStyleRef, """" & IIf(blinappendix, "Appendix 1", "Heading 1") & """" & " \s", False
        End With
        
        With .Cell(1, 1)
            .Range.Columns(1).SetWidth CentimetersToPoints(Const_TABLE_WIDTH - 5), wdAdjustNone
            .VerticalAlignment = wdCellAlignVerticalCenter
            Set rngref = .Range
            rngref.Font.Size = 12
            If Not IsMathTypeInstalled Then
                rngref.Text = "y = x^2+1"
                rngref.OMaths.Add rngref
                Set objmath = rngref.OMaths(1)
                objmath.Justification = wdOMathJcCenter
                objmath.Range.Select
                DSTRibbon.ActivateTabMso "TabEquationToolsDesign"
            Else
                rngref.ParagraphFormat.Alignment = wdAlignParagraphCenter
                rngref.Text = Const_INSTR_START & " Delete this text then insert an 'inline' equation using the MathType tab on the Ribbon " & Const_INSTR_END
                .Select
            End If
        End With
    
        .Borders.Enable = False
        .AllowAutoFit = False
        .Rows.LeftIndent = .Range.Document.Styles("Body Text").ParagraphFormat.LeftIndent
    End With
    
Exit_InsertEquation:
    Call ScreenUpdateRestore
    Exit Sub
    
Err_InsertEquation:
    MsgBox Err.Description & " in InsertEquation()"
    Resume Exit_InsertEquation
End Sub

Private Function IsMathTypeInstalled() As Boolean
    Dim adn As AddIn
    
    For Each adn In AddIns
        If adn.Name Like "*MathType*" And adn.Installed Then
            IsMathTypeInstalled = True
            Exit For
        End If
    Next adn
End Function
Attribute VB_Name = "basFields"
Option Explicit

Public Const Const_PICTURE_LEFT_INDENT As Single = 0#

Function UpdateLockedField(ByRef objdoc As Document, ByRef slct As SelectionType, Optional ByRef strmessage As Variant) As Boolean
    Dim bllocked As Boolean, fld As Field
    Dim strfilename As String, strdummy As String, strstatus As String, fso As FileSystemObject
    Dim blupdatefield As Boolean
    
    Set fso = New FileSystemObject
    
    If slct.FieldIndex > 0 Then
        ' Change to the current directory
        Application.ChangeFileOpenDirectory objdoc.Path
        
        ' get a reference to the field object
        Set fld = objdoc.StoryRanges(slct.Story).Fields(slct.FieldIndex)
        
        ' for include fields, determine the referenced filename and resolve the relative address
        If fld.Type = wdFieldIncludePicture Or fld.Type = wdFieldIncludeText Then
            Call GetRefInfoFromIncludeFieldCode(fld, strfilename, strdummy)
            If strfilename <> vbNullString Then
                ' check that the file exists before updating the field
                strfilename = fso.GetAbsolutePathName(fso.BuildPath(objdoc.Path, strfilename))
                If fso.FileExists(strfilename) Then
                    blupdatefield = True
                Else
                    strstatus = "The field references a file that does not exist (" & strfilename & ")."
                End If
            Else
                strstatus = "Could not determine referenced filename from field code '" & fld.Code & "'."
            End If
        Else
            ' always update other fields
            blupdatefield = True
        End If
    Else
        strstatus = "No field selected."
    End If
    
    If strstatus = vbNullString Then
        UpdateLockedField = True
        If blupdatefield Then
            ' unlock, update and lock the field
            bllocked = fld.Locked ' save the locked status
            fld.Locked = False
            fld.Update
            fld.Locked = bllocked ' restore locked status
        End If
    Else
        If IsMissing(strmessage) Then
            MsgBox strstatus & vbCrLf & vbCrLf & "Field not updated.", vbExclamation, "DST - Update Locked Field"
        Else
            strmessage = strstatus
        End If
    End If
    
End Function

Function UpdateAllFields(ByRef objdoc As Document, Optional ByRef frm As Object, _
                         Optional ByVal blprompt As Boolean = True, Optional ByVal stropenargs As String = vbNullString) As Boolean
    Dim blOK As Boolean, toc As TableOfContents, tof As TableOfFigures
    Dim stryrng As Range, lngnumfields As Long, blshowprogress As Boolean
    Dim arrstorydesc() As Variant, lngnumrngs As Integer, idx As Long, lngjunk As Long
    
    Call SaveAndTurnOffGrammarSettings
    
    ' create an array of descriptions for the WdStoryType enumeration
    arrstorydesc = Array("Main text", "Footnotes", "Endnotes", "Comments", "Text frame", _
                         "Even pages header", "Primary header", "Even pages footer", "Primary footer", _
                         "First page header", "First page footer", "Footnote separator", "Footnote continuation separator", _
                         "Footnote continuation notice", "Endnote separator", "Endnote continuation separator", _
                         "Endnote continuation notice")
    
    ' check if we need to show progress
    blshowprogress = Not frm Is Nothing
    
    ' update all stories in the document
    lngnumrngs = objdoc.StoryRanges.Count
    If blshowprogress Then
        If stropenargs = "DocInfo" Then
            frm.UpdateProgressText "Document information updated, so fields that reference these need to be updated - remember to save the document afterwards."
            frm.UpdateProgressText "Updating " & lngnumrngs & " story ranges:"
        End If
    End If
    blOK = True

    ' fix the skipped blank Header/Footer problem as provided by Peter Hewett
    lngjunk = objdoc.Sections(1).Headers(1).Range.StoryType
    For Each stryrng In objdoc.StoryRanges
        idx = idx + 1
        ' indicate which story type is being updated
        If blshowprogress Then
            frm.UpdateProgressText "      " & arrstorydesc(stryrng.StoryType - 1) & " story.......", False
            frm.UpdateProgressMeter idx, lngnumrngs
        End If
                
        lngnumfields = 0
        If Not UpdateStoryRangeFields(stryrng, lngnumfields, blprompt, frm) Then blOK = False
            
        ' show number of fields updated
        If blshowprogress Then frm.UpdateProgressText lngnumfields & " fields updated"
    Next stryrng
    
    ' now update the TOC tables
    If blshowprogress Then
        frm.UpdateProgressText "Updating Table Of Contents.......", False
        frm.UpdateProgressMeter 0, 2
    End If
    
    For Each toc In objdoc.TablesOfContents
        toc.Update
    Next toc
    
    If blshowprogress Then
        frm.UpdateProgressText objdoc.TablesOfContents.Count & " tables updated"
        frm.UpdateProgressText "Updating Figure and Table lists.......", False
        frm.UpdateProgressMeter 1, 2
    End If
    
    For Each tof In objdoc.TablesOfFigures
        tof.Update
    Next tof
    
    If blshowprogress Then frm.UpdateProgressText objdoc.TablesOfFigures.Count & " lists updated"
    
    ' complete the process
    If blshowprogress Then
        frm.UpdateProgressText vbNullString
        frm.UpdateProgressMeter (-1)
    End If
    If blOK = True Then
        ' search for error text
        If FindTextInRange(objdoc.Range, Const_DOC_ERROR_STRING) = False Then
            If blshowprogress Then frm.UpdateProgressText "Done - Fields updated successfully."
        Else
            blOK = False
            If blshowprogress Then frm.UpdateProgressText "WARNING: Found '" & Const_DOC_ERROR_STRING & "' in the main body of the document."
        End If
    Else
        If blshowprogress Then frm.UpdateProgressText "ERROR: Field updates"
    End If
    
    UpdateAllFields = blOK
    
    Call RestoreGrammarSettings

End Function

Private Function UpdateStoryRangeFields(ByRef stryrng As Range, ByRef lngnumfields As Long, ByVal blprompt As Boolean, Optional ByRef frm As Object) As Boolean
    UpdateStoryRangeFields = True
    Do
        If Not UpdateFields(stryrng.Document, stryrng.Fields, lngnumfields, blprompt, frm) Then UpdateStoryRangeFields = False
        Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
    Loop Until stryrng Is Nothing
End Function

Private Function UpdateFields(ByRef objdoc As Document, ByRef flds As Fields, ByRef lngnumfields As Long, ByVal blprompt As Boolean, Optional ByRef frm As Object) As Boolean
    Dim idx As Long, lngalerts As Long, fld As Field
    
    UpdateFields = True
    lngnumfields = lngnumfields + flds.Count
    If flds.Count > 0 Then
        For Each fld In flds
            If fld.Type = wdFieldSet Then
                If Not frm Is Nothing Then frm.UpdateProgressText "ERROR: Prohibited use of the field code type 'SET' at position " & fld.Result.Start & " (field code is '" & fld.Code & "')."
                UpdateFields = False
            End If
        Next fld
        
        ' save current alerts setting and turn it off temporarily
        lngalerts = objdoc.Application.DisplayAlerts
        objdoc.Application.DisplayAlerts = wdAlertsNone
        ' update fields
        idx = flds.Update
        objdoc.Application.DisplayAlerts = lngalerts ' restore original alerts setting
        If idx <> 0 Then
            UpdateFields = False
            If blprompt Then
                If MsgBox("At least one field could not be updated. Go to field?", vbQuestion + vbYesNo, "DST - Field Update Error") = vbYes Then
                    'using idx to go to field with error does not always work, so rather search for the problematic field manually
                    flds.Parent.Find.Execute Const_DOC_ERROR_STRING, Wrap:=wdFindContinue
                    flds.Parent.Select
                End If
            End If
        End If
    End If
    
End Function

Sub UpdateDocumentPropertyRefs(ByRef objdoc As Document, ByVal strproperty As String)
    Dim stryrng As Range, fld As Word.Field
On Error GoTo Err_UpdateDocumentPropertyRefs
    
    Call SaveAndTurnOffGrammarSettings
    
    ' search for the old bookmark name in all fields of the requested type
    For Each stryrng In objdoc.StoryRanges
        Do
            For Each fld In stryrng.Fields
                If fld.Type = wdFieldDocProperty Then
                    If RegularExpressionSearch(fld.Code.Text, strproperty, True) Then fld.Update
                End If
            Next fld
            Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
        Loop Until stryrng Is Nothing
    Next stryrng
        
Exit_UpdateDocumentPropertyRefs:
    Call RestoreGrammarSettings
    Exit Sub
    
Err_UpdateDocumentPropertyRefs:
    MsgBox Err.Description & " in UpdateDocumentPropertyRefs()", vbExclamation
    Resume Exit_UpdateDocumentPropertyRefs
End Sub

Sub RenameRefs(ByRef objdoc As Document, ByVal stroldname As String, ByVal strnewname As String, Optional ByVal fldtype As WdFieldType = wdFieldRef)
    Dim stryrng As Range, fld As Word.Field, hlnk As Hyperlink, strrenameto As String
    
    Call SaveAndTurnOffGrammarSettings
    
    If fldtype = wdFieldTitle Then
        ' direct references to the Title field will be changed to the document property format for consistency
        strrenameto = "DOCPROPERTY " & strnewname
    Else
        strrenameto = strnewname
    End If
    
    ' search for the old bookmark name in all fields of the requested type
    For Each stryrng In objdoc.StoryRanges
        Do
            For Each fld In stryrng.Fields
                If fld.Type = fldtype Then
                    If RegularExpressionSearch(fld.Code.Text, stroldname, True) Then
                        fld.Code.Text = RegularExpressionReplace(fld.Code.Text, "(\s|" & """" & ")" & stroldname & "\1", "$1" & strrenameto & "$1")
                        fld.Update
                    End If
                End If
            Next fld
        
            ' search for the old bookmark name in all hyperlinks as well
            For Each hlnk In stryrng.Hyperlinks
                If hlnk.SubAddress = stroldname Then
                    ' change the hyperlink to use the new bookmark name
                    hlnk.SubAddress = Replace(hlnk.SubAddress, stroldname, strnewname)
                    Call FormatXRefHyperlink(hlnk)
                End If
            Next hlnk
            Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
        Loop Until stryrng Is Nothing
    Next stryrng
        
    Call RestoreGrammarSettings
    
End Sub

Function IsFieldReferenced(ByRef rng As Range, ByVal strfieldname As String, _
                           ByVal fldtype As WdFieldType) As Boolean
    Dim fld As Word.Field, strtype As String, strpattern As String
    
    Call SaveAndTurnOffGrammarSettings
    
    ' first determine the field type string
    Select Case fldtype
        Case wdFieldDocProperty
            strtype = "DOCPROPERTY"
            
        Case wdFieldHyperlink
            strtype = "HYPERLINK"
            
        Case wdFieldIncludePicture
            strtype = "INCLUDEPICTURE"
            
        Case wdFieldIncludeText
            strtype = "INCLUDETEXT"
           
        Case wdFieldRef
            strtype = "REF"
            
        Case wdFieldTitle
            strtype = vbNullString
            
        Case Else
            MsgBox "Field type " & fldtype & " not catered for. Contact the DST Owner.", vbCritical
            Exit Function
    End Select
    
    ' determine the regexp search pattern
    If strtype <> vbNullString Then
        strpattern = "(" & strtype & ")\W+"
    End If
    strpattern = "^\W*" & strpattern & "(" & strfieldname & ")\W+"
    
    ' search for the old bookmark name in all fields starting with " REF <bookmark_name> "
    For Each fld In rng.Fields
        If fld.Type = fldtype Then
            If Not InDocExtRefsTable(fld.Result) Then
                If RegularExpressionSearch(fld.Code.Text, strpattern, True) Then
                    IsFieldReferenced = True
                    Exit Function
                End If
            End If
        End If
    Next fld

    Call RestoreGrammarSettings
    
End Function

Function IsFieldReferencedInDoc(ByRef objdoc As Document, ByVal strfieldname As String, ByVal fldtype As WdFieldType) As Boolean
    Dim stryrng As Range
    
    For Each stryrng In objdoc.StoryRanges
        Do
            If IsFieldReferenced(stryrng, strfieldname, fldtype) Then
                IsFieldReferencedInDoc = True
                Exit Function
            End If
            Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
        Loop Until stryrng Is Nothing
    Next stryrng

End Function

Sub FormatXRefHyperlink(ByRef hlnk As Hyperlink)

    hlnk.TextToDisplay = Replace(hlnk.Address, "/", "\") & IIf(hlnk.SubAddress <> vbNullString, " - " & hlnk.SubAddress, vbNullString)
    hlnk.Range.Fields(1).ShowCodes = False

End Sub

Function GetBookmarkNameFromField(ByRef fld As Field) As String
    Dim strdummy As String, strbkname As String
    
    GetBookmarkNameFromField = vbNullString
    
    If fld.Type = wdFieldRef Then
        GetBookmarkNameFromField = GetBookmarkNameFromFieldCode(fld.Code)
    ElseIf fld.Type = wdFieldSet Then
        MsgBox "The use of the 'SET' field code is prohibited at position " & fld.Result.Start & " (field code is '" & fld.Code & "')", vbCritical, "Field Code Error"
    ElseIf fld.Type = wdFieldIncludeText Then
        Call GetRefInfoFromIncludeFieldCode(fld, strdummy, strbkname)
        GetBookmarkNameFromField = strbkname
    End If
    
End Function

Function GetBookmarkNameFromFieldCode(ByVal strfieldcode As String, Optional ByVal strfieldtype As String = "REF") As String
    Dim strsearch As String
    Dim intfs As Integer, intfe As String
    
    strsearch = strfieldtype & " "
    intfs = InStr(1, strfieldcode, strsearch) + Len(strsearch)
    intfe = InStr(intfs + 1, strfieldcode, "\")
    If intfe = 0 Then
        ' in case there are no backslashes, search for a trailing space
        intfe = InStr(intfs + 1, strfieldcode, " ")
        If intfe = 0 Then
            ' this means the field has no options and there is no white space seperating the field code and the closing brace
            intfe = Len(strfieldcode) + 1
        End If
    End If
    GetBookmarkNameFromFieldCode = Trim(Mid(strfieldcode, intfs, intfe - intfs))
    
End Function

Sub GetRefInfoFromIncludeFieldCode(ByRef fld As Field, ByRef strfilename As String, ByRef strbookname As String)
' Gets the filename and bookmark name components from an INCLUDETEXT or INCLUDEPICTURE field
    Dim strfieldcode As String, strpattern As String, colmatches As MatchCollection
    
    ' extract the filename and bookmark from the field code - quotes around filename parameter are optional
    strpattern = "^\s*INCLUDE(TEXT|PICTURE)\s+" & """" & "?(.+?)" & """" & "?\s+(\w*)"
    
    strfieldcode = fld.Code
    If RegularExpressionSearch(strfieldcode, strpattern, , colmatches) Then
        strfilename = colmatches(0).SubMatches(1)
        strbookname = colmatches(0).SubMatches(2)
    Else
        MsgBox "Could not determine filename and possible bookmark directive in field code '" & strfieldcode & "'.", vbExclamation, "DST include-type Reference"
    End If
    
End Sub

Sub AddOpenReferenceShortcut()
On Error GoTo Err_AddOpenReferenceShortcut

    With CommandBars("Fields")
        ' remove all customisations and restore the built-in toolbar to its original state
        .Reset
        
        With .Controls.Add(msoControlButton, , , .FindControl(id:=215).Index + 1)
            .Caption = "Open &Reference"
            .TooltipText = "Opens the reference in a new instance of Word."
            .Style = msoButtonIconAndCaption
            .FaceId = 681
            .OnAction = "OpenReferenceInWord"
        End With
    End With
    
    ' trick the attached template (normal.dotm) to be in a saved state to avoid being prompted
    ' to save the Normal.dotm template when closing the last Word instance
    Application.CustomizationContext.Saved = True

Exit_AddOpenReferenceShortcut:
    Exit Sub
    
Err_AddOpenReferenceShortcut:
    MsgBox Err.Description & " in AddOpenReferenceShortcut()"
    Resume Exit_AddOpenReferenceShortcut
End Sub

Sub OpenReferenceInWord()
    Dim objdoc As Document, rng As Range, strdocname As String, strbookmarkname As String
    Dim strstatus As String, blcontinue As Boolean, hlnk As Hyperlink, slct As SelectionType
    
    ' point to the insertion point
    Set rng = ActiveDocument.ActiveWindow.Selection.Range
    
    ' determine where the insertion point is
    If InDocExtRefsTable(rng) Then
        ' cursor is in the External References section, get info based on hyperlink directly
        If ValidateXRefHyperlinkRow(rng.Rows(1), hlnk, strdocname, strbookmarkname, strstatus) = True Then
            blcontinue = True
        Else
            MsgBox strstatus, vbExclamation, "DST - Hyperlink Error"
        End If
    Else
        ' check if cursor is on a field
        If RangeHasFields(rng, slct) > 0 Then
            ' get bookmark name from field
            strbookmarkname = GetBookmarkNameFromField(rng.Document.StoryRanges(slct.Story).Fields(slct.FieldIndex))
            If strbookmarkname <> vbNullString Then
                blcontinue = True
            End If
        End If
    End If
    
    If blcontinue Then
        ' check whether bookmark is external
        If Dst.Document(ActiveDocument.Fullname).Bookmarks.IsExternal(strbookmarkname) Then
            ' get info from associated hyperlink
            If ValidateXRefHyperlinkRow(ActiveDocument.Bookmarks(strbookmarkname).Range.Rows(1), _
                                        hlnk, strdocname, strbookmarkname, strstatus) = True Then
                ' open the document and select the bookmark
                Set objdoc = Application.Documents.Open(strdocname)
                objdoc.Activate
            Else
                MsgBox strstatus, vbExclamation, "DST - Hyperlink Error"
                blcontinue = False
            End If
        Else
            ' open the current document in a new window if it's not already open in a window
            If ActiveDocument.Windows.Count = 1 Then
                ActiveDocument.ActiveWindow.NewWindow
            End If
            ActiveDocument.Windows(2).Activate
        End If
        
        ' now select the bookmark
        If blcontinue = True Then
            If ActiveDocument.Bookmarks.Exists(strbookmarkname) = True Then
                Set rng = ActiveDocument.Bookmarks(strbookmarkname).Range
                rng.Select
            Else
                MsgBox "The bookmark " & strbookmarkname & " does not exist in '" & ActiveDocument.Name & "'.", vbExclamation, "DST - Bookmark not Found"
            End If
        End If
    Else
        MsgBox "No navigable field found beneath the insertion point.", vbExclamation, "DST - Invalid Reference"
    End If
    
End Sub

Function RangeHasFields(ByRef rngslct As Range, ByRef slct As SelectionType) As Long
' Code based on sampe code in http://www.wordarticles.com/Issues/IndexUpdate/CodeExample.htm
    Dim lngnumfieldsbefore As Long, lngnumfieldsafter As Long, lngnumfieldstotal As Long
    Dim rng As Range, rngwrk As Range, rngtemp As Range
On Error GoTo Err_RangeHasFields

    ' NOTE: DO NOT use the rng.Information method to determine any of the range attributes such as
    '       in table or at end of row. This method causes Word to crash if it gets called from multiple
    '       threads such as the Word's Ribbon management and DST functionality.
    '       Use the IsRangeInTable() function instead and use the Cells count property to determine
    '       whether the range is at the end of row marker.
    
    ' init return data
    RangeHasFields = 0
    slct.NumFields = 0
    slct.NumBookmarks = 0
    slct.FieldIndex = 0
    slct.Story = 0
    
    ' set the local range to use
    ' NOTE - ranges in (split)special panes (e.g. the revisions or comments pane), do not have story types, so trap this error
    Set rng = rngslct.Document.StoryRanges(rngslct.StoryType)
    rng.SetRange rngslct.Start, rngslct.End
    
    ' set the number of bookmarks in case it's required
    slct.NumBookmarks = rng.Bookmarks.Count
    
    If Not IsRangeInTable(rng) Then
        ' first try the Fields collection
        If rng.Fields.Count > 0 Then
            RangeHasFields = rng.Fields.Count
        Else
            ' now try a different method - in case range is in field, but not whole field is in range
            Set rngwrk = rng.Document.StoryRanges(rng.StoryType)
        End If
    Else
        ' in tables, work only with the current cell
        If rng.Cells.Count > 0 Then
            Set rngwrk = rng.Cells(1).Range
            rngwrk.SetRange rngwrk.Start, rngwrk.End - 1 ' exclude end of cell marker
        Else
            ' this implies where in the end of row marker of a table row
            Set rngwrk = rng ' don't try and find fields here!
        End If
    End If
    
    ' proceed if the working range has been set
    If Not rngwrk Is Nothing Then
        lngnumfieldstotal = rngwrk.Fields.Count
        Set rngtemp = rng.Document.StoryRanges(rng.StoryType) ' to ensure it's part of the same story
        With rngtemp
            .SetRange rngwrk.Start, rng.Start - (Len(rng.Text) = 0)
            lngnumfieldsbefore = .Fields.Count
            .SetRange rng.End, rngwrk.End
            lngnumfieldsafter = .Fields.Count
        End With
        RangeHasFields = Abs(lngnumfieldsafter + lngnumfieldsbefore - lngnumfieldstotal)
    End If
    
    ' adjust the range so it includes the field
    If RangeHasFields > 0 Then
        rng.TextRetrievalMode.IncludeFieldCodes = True ' this allows the field code to be included in the search below
        While rng.Fields.Count = 0
            rng.MoveEndUntil Chr(&H15) ' } field code terminator
            rng.MoveEnd wdCharacter, 1
        Wend
        
        ' return the actual numbers of fields and the index of the first field if requested
        RangeHasFields = rng.Fields.Count
        slct.NumFields = rng.Fields.Count
        If rng.Fields.Count > 0 Then
            slct.FieldIndex = rng.Fields(1).Index
        End If
        slct.Story = rng.StoryType
    End If
    
Exit_RangeHasFields:
    Exit Function

Err_RangeHasFields:
    If Err.Number = -2147467259 Then
        ' do nothing, simply exit as the story type property does not exist - return data set to defaults already
    Else
        MsgBox Err.Description & " in RangeHasFields() of basFields"
    End If
    Resume Exit_RangeHasFields

End Function

Function GetFieldResult(ByRef rng As Range) As String
    
    ' first try the Fields collection
    If rng.Fields.Count > 0 Then
        GetFieldResult = rng.Fields(1).Result
    End If

End Function

Sub InsertTBDField()
    
    With Selection
        .InsertAfter "TBD "
        .Collapse Direction:=wdCollapseEnd
        ActiveDocument.Fields.Add .Range, wdFieldSequence, "TBD", False
        .InsertAfter ": "
        .Collapse wdCollapseEnd
    End With

End Sub

Sub InsertPicture(ByRef rng As Range)
    Dim dlgfileopen As FileDialog, fld As Field, rngxref As Range
    Dim strstartpath As String, strpicturefilerel As String, strcaption As String, strmessage As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    ' open file browse dialogue to select pictures - default to document's associated subfolder
    Set dlgfileopen = Application.FileDialog(msoFileDialogFilePicker)
    With dlgfileopen
        .Title = "Select a picture to insert"
        .Filters.Clear
        .Filters.Add "PNG files", "*.png", 1
        .Filters.Add "More pictures", "*.png; *.bmp; *.gif; *.jpg; *.wmf"
        .Filters.Add "All files", "*.*"

        strstartpath = fso.BuildPath(ActiveDocument.Path, fso.GetBaseName(ActiveDocument.Name))
        If Not fso.FolderExists(strstartpath) Then strstartpath = ActiveDocument.Path
        .InitialFileName = strstartpath
        
        .AllowMultiSelect = False
        If .Show = -1 Then
            ' use current range to insert a reference to the figure after it was created
            Set rngxref = rng.Document.Range
            rngxref.SetRange rng.Start, rng.End
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
            rng.ParagraphFormat.LeftIndent = CentimetersToPoints(Const_PICTURE_LEFT_INDENT)
            
            ' insert picture using relative path to selected picture
            strpicturefilerel = GetRelativePath(ActiveDocument.Path, .SelectedItems.Item(1))
            If Not UseInlineShapes(rng.Document) Then
                ' binary format documents must use INCLUDEPICTURE fields
                Set fld = rng.Fields.Add(rng, wdFieldIncludePicture, strpicturefilerel, True)
                fld.Locked = True
                Set rng = fld.Result
            Else
                ' newer formats must use InLineShapes
                Set rng = InsertInlineShape(rng, .SelectedItems.Item(1))
            End If
            rng.ParagraphFormat.Alignment = wdAlignParagraphCenter
            
            ' insert figure caption
            With Application.CaptionLabels(wdCaptionFigure)
                .NumberStyle = wdCaptionNumberStyleArabic
                .IncludeChapterNumber = True
                .ChapterStyleLevel = IIf(IsInAppendixRange(rng), 7, 1) ' 1st level appendix (Appendix A) starts at level 7
                .Separator = wdSeparatorEnDash ' do not use hyphen as a separator, doing Range.Text on caption strips out the hyphen
            End With
            strcaption = Const_INSTR_START & " Insert title here " & Const_INSTR_END
            rng.InsertCaption wdCaptionFigure, ": " & strcaption, vbNullString, wdCaptionPositionBelow, False
            
            ' insert a cross-reference to the figure caption and select the caption text
            Set rng = rng.Next(wdParagraph) ' to select inserted caption
            rng.MoveEnd wdCharacter, -1 ' to exclude the paragraph marker
            Call InsertXRefToCaption(wdCaptionFigure, rng.Text, rngxref)
            rng.SetRange rng.End - Len(strcaption), rng.End
            rng.Select
            
            ' apply caption style
            If StyleExists(rng.Document, "DSTCaptionFigure", strmessage) Then
                rng.Style = "DSTCaptionFigure"
            Else
                MsgBox strmessage, vbExclamation
            End If
        Else
            ' The user pressed Cancel
        End If
    End With
    
    Set dlgfileopen = Nothing

End Sub

Function IsHyperlinkInRange(ByRef rng As Range, ByVal strhyperlinkaddress As String) As Boolean
    Dim hlnk As Hyperlink, strtemp As String
    
    For Each hlnk In rng.Hyperlinks
        ' change all address path seperators to single / before comparing
        strtemp = hlnk.Address
        strtemp = Replace(strtemp, "\\", "\")
        strtemp = Replace(strtemp, "\", "/")
        strhyperlinkaddress = Replace(strhyperlinkaddress, "\\", "\")
        strhyperlinkaddress = Replace(strhyperlinkaddress, "\", "/")
        If strtemp = strhyperlinkaddress Then
            IsHyperlinkInRange = True
            Exit For
        End If
    Next hlnk
    
End Function
Attribute VB_Name = "basInit"
Option Explicit

' Dictionary of documents with associated information, bookmarks and allowed prefixes
Public Dst As cDst

Sub AutoExec()
On Error GoTo Err_AutoExec

    Call UnloadUserForm
    
    ' init an object pointing to the Word Application so that events can be triggered
    Set oAppClass.oApp = Word.Application
    
    ' add special shortcut for open references
    Call AddOpenReferenceShortcut
    
    ' initialise the main DST object
    Set Dst = Nothing
    Set Dst = New cDst
    
Exit_AutoExec:
    Exit Sub

Err_AutoExec:
    MsgBox Err.Description & " in AutoExec() of basStartUp"
    Resume Exit_AutoExec
        
End Sub

Sub FullDSTReset()
    Call InitialiseDSTDocuments(True)
End Sub

Sub InitialiseDSTDocuments(ByVal blfullreset As Boolean)

    If blfullreset Then
        Call AutoExec
    ElseIf Dst Is Nothing Then
        ' something went wrong, so do a full reset
        MsgBox "An unexpected error occurred, DST will attempt to reset itself. Good luck.", vbExclamation
        Call AutoExec
    End If

    ' re-compute the ribbon
    If BlDSTDebugMode Then Debug.Print "Calling ReComputeRibbon from InitialiseDSTDocuments..."
    Call ReComputeRibbon(blfullreset)

End Sub

Sub SetWordOptions()
    Dim vw As View, obj As Object
On Error Resume Next ' Word sometimes complains about a property not being available for reading when a document is opened through OLE (e.g. from SDLC), so ignore all errors in this module

    ' set some default Word options
    ActiveDocument.ActiveWindow.DocumentMap = True
    Set vw = ActiveDocument.ActiveWindow.View
    vw.ShowBookmarks = True
    vw.ShowHiddenText = True
    vw.FieldShading = wdFieldShadingAlways
    vw.TableGridlines = True
    
    ' turn off reading view for E-mail attachments etc. and don't update links when opening a document
    Application.Options.AllowReadingMode = False
    Application.Options.UpdateLinksAtOpen = False
    
    ' always turn off hidden bookmarks
    ActiveDocument.Bookmarks.ShowHidden = False
    
    ' add the user's project folder as a trusted location
    Set obj = CreateObject("WScript.Shell")
    Call AddTrustedLocation(obj.SpecialFolders("MyDocuments") & "\Projects")
    
End Sub
Attribute VB_Name = "basInlineShapes"
Option Explicit

Function UseInlineShapes(ByRef objdoc As Document) As Boolean

    ' old binary Word documents should not use inline shapes
    UseInlineShapes = (objdoc.SaveFormat <> wdFormatDocument)
    
End Function

Function InsertInlineShape(ByRef rng As Range, ByVal strfilename As String) As Range
    Dim ishape As InlineShape
    
    Set ishape = rng.InlineShapes.AddPicture(strfilename, False, True)
    ishape.LockAspectRatio = msoTrue
    
    ' Use title and alternative text fields to store source picture file info
    ' NOTE: Using the inline shape's LinkFormat object and SourceFullName property for this is problematic when
    '       updatng fields - inline shapes cannot be locked, so if it is linked and the linked picture file
    '       does not exist, it breaks the picture
    ishape.Title = GetRelativePath(rng.Document.Path, strfilename)
    ishape.AlternativeText = FileCRC32(strfilename, True)
    Set InsertInlineShape = ishape.Range

End Function
                
Sub UpdateInlineShape(ByRef ishape As InlineShape)
    Dim fso As FileSystemObject, strfilename As String, rng As Range
    
    If ishape.Title <> vbNullString Then
        Set fso = New FileSystemObject
        strfilename = fso.BuildPath(ishape.Range.Document.Path, ishape.Title)
        If fso.FileExists(strfilename) Then
            ' delete and re-insert the picture
            Set rng = ishape.Range
            ishape.Delete
            Call InsertInlineShape(rng, strfilename)
        Else
            MsgBox "Could not find picture file '" & strfilename & "'.", vbExclamation
        End If
    Else
        MsgBox "Picture has no source file specified - re-insert the picture using the 'Insert Picture' function.", vbExclamation
    End If
    
End Sub

Function CheckInlineShapes(ByRef objdoc As Document) As String
    Dim rng As Range, ishape As InlineShape, strmessage As String
    Dim fso As FileSystemObject, strfilename As String
    
    ' only process shapes in main document story of documents that should be using inline shapes
    If UseInlineShapes(objdoc) Then
        Set fso = New FileSystemObject
        For Each ishape In objdoc.InlineShapes
            If Not IsInlineShapeEquation(ishape) Then ' MathType equations are also inline shapes
                If Not IsInlineShape(ishape) Then
                    If ishape.Range.Information(wdActiveEndPageNumber) > 1 Then  ' only pictures on Cover Page do not have to be linked
                        strmessage = strmessage & "Picture at position " & ishape.Range.Start & " is not associated with a picture file on disk - re-insert the picture using the 'Insert Picture' function." & vbCrLf
                    End If
                Else
                    If Not ishape.LinkFormat Is Nothing Then
                        strmessage = strmessage & "Picture at position " & ishape.Range.Start & " is linked - re-insert the picture using the 'Insert Picture' function." & vbCrLf
                    End If
                    
                    ' check if picture is up-to-date, but only if picture file exists
                    strfilename = fso.BuildPath(objdoc.Path, ishape.Title)
                    If fso.FileExists(strfilename) Then
                        If ishape.AlternativeText <> FileCRC32(strfilename, True) Then
                            strmessage = strmessage & "Picture at position " & ishape.Range.Start & " is not up-to-date - use the 'Update Picture' function to update it" & vbCrLf
                        End If
                    End If
                End If
            End If
        Next ishape
    End If
    
    CheckInlineShapes = strmessage
        
End Function

Function IsInlineShape(ByRef ishape As InlineShape) As Boolean
On Error GoTo Err_InlineShape

    ' check if inline has a title property and that it is not empty
    If ishape.Title <> vbNullString Then IsInlineShape = True
    
Exit_InlineShape:
    Exit Function
    
Err_InlineShape:
    If Err.Number = 445 Then ' Object doesn't support this action - occurs when inline shape has not Title property
        Resume Exit_InlineShape
    End If
    
End Function

Function IsInlineShapeEquation(ByRef ishape As InlineShape) As Boolean
    If Not ishape.OLEFormat Is Nothing Then
        IsInlineShapeEquation = (ishape.OLEFormat.ClassType Like "*Equation*")
    End If
End Function
Attribute VB_Name = "basJustifications"
Option Explicit

Public Const Const_JST_BMRK_PREFIX_TRCFROM_EXCEPTION As String = "jtf_"
Public Const Const_JST_BMRK_PREFIX_TRCTO_EXCEPTION As String = "jtt_"
Public Const Const_JST_BMRK_PREFIX_UNINSTR As String = "jimodule_"
Public Const Const_JST_BMRK_PREFIX_INCOMPLETECOV As String = "jcfunc_"
Public Const Const_JST_BMRK_PREFIX_FAILURE As String = "jf"
Public Const Const_JST_BMRK_PREFIX_NOTEXECUTED As String = "jn"
Public Const Const_DEFAULT_JST_TEXT = Const_INSTR_START & " Add justification text here " & Const_INSTR_END

Function InsertJustificationsTable(ByRef rng As Range, ByRef jstnew As Scripting.Dictionary, ByRef jstcur As Scripting.Dictionary, _
                                   ByVal strcaption As String, ByVal strtable As String, ByVal strheadingcol1 As String, _
                                   ByRef frm As Object) As String
    Dim tbl As Table, numrows As Integer, offset As Integer, idx As Integer, strtext As String
On Error GoTo Err_InsertJustificationsTable
    
    frm.UpdateProgressText "Inserting new " & strtable & " table..."
    frm.UpdateProgressMeter (-1)
    If jstnew.Count > 0 Then
        numrows = jstnew.Count + 1
        frm.UpdateProgressText "  [-] Updating " & jstnew.Count & " exceptions in table..."
    Else
        numrows = 2
    End If
    Set tbl = CreateTableTemplate(rng, numrows, 2, strcaption, strtable, True)
    If Not tbl Is Nothing Then
        With tbl
            ' adjust the column widths and center 2nd column
            .Columns(1).SetWidth CentimetersToPoints(7.5), wdAdjustNone
            .Columns(2).SetWidth CentimetersToPoints(Const_TABLE_WIDTH) - tbl.Columns(1).Width, wdAdjustNone
                
            .Cell(1, 1).Range.Text = strheadingcol1
            .Cell(1, 2).Range.Text = "Justification"
            
            Call InsertNotApplicable(.Cell(2, 1).Range)
            
            offset = 2
            For idx = 0 To jstnew.Count - 1
                frm.UpdateProgressMeter idx, jstnew.Count
                Call UpdateJustificationRow(.Rows(offset + idx), jstnew.Keys(idx), jstnew.Items(idx), jstcur)
            Next idx
            
            ' collapse range to end of table
            Set rng = .Range
            rng.Collapse wdCollapseEnd
        End With
        
        ' warn user if there are unresolved justifications
        strtext = NotifyUnresolvedJustifications(tbl)
        If strtext <> vbNullString Then frm.UpdateProgressText strtext
    Else
        InsertJustificationsTable = "Unable to create '" & strcaption & "' table"
    End If

Exit_InsertJustificationsTable:
    frm.UpdateProgressMeter (-1)
    Exit Function

Err_InsertJustificationsTable:
    InsertJustificationsTable = Err.Description & " in InsertJustificationsTable()"
    Resume Exit_InsertJustificationsTable
    
End Function

Sub UpdateJustificationRow(ByRef rw As Row, ByVal strjstbkmark As String, ByVal strjsttext As String, ByRef jstcur As Scripting.Dictionary)
    Dim rngbkm As Range, jst As Scripting.Dictionary, idx As Integer, rngjst As Range
    Dim strjustification As String, varhlnk As Variant, varaddress As Variant, strstyle As String, strlinenum As String
On Error GoTo Err_UpdateJustificationRow
    
    ' insert justification bookmark in first cell and apply the relevant style
    Set rngbkm = rw.Cells(1).Range
    If rngbkm.CharacterStyle.NameLocal <> "Default Paragraph Font" Then ' occurs when adding rows to existing table
        rngbkm.Select
        Selection.ClearCharacterAllFormatting
    End If
    rngbkm.Style = "Table Text Small"
    rngbkm.Text = strjsttext
    rngbkm.Collapse wdCollapseStart
    Call SetBookmarkTextRange(rngbkm) ' make sure we only bookmark valid bookmark text
    Dst.Document(rngbkm.Document.Fullname).Bookmarks.Add strjstbkmark, rngbkm
    strstyle = Dst.BookmarkConfig.PrefixFromName(strjstbkmark)
    strstyle = Dst.BookmarkConfig.Prefix(strstyle).BookmarkStyle
    If strstyle <> vbNullString Then rngbkm.Style = strstyle
    
    ' insert the justification text in the 2nd cell
    Set rngbkm = rw.Cells(2).Range
    With rngbkm
        .ParagraphFormat.Alignment = wdAlignParagraphJustify
        .SetRange .End - 1, .End - 1 ' move to just before the end-of-cell marker
        If jstcur.Exists(strjstbkmark) Then
            ' first check to see if the stored justification is a Range object
            Set rngjst = Nothing
            On Error Resume Next
            Set rngjst = jstcur(strjstbkmark)
            On Error GoTo Err_UpdateJustificationRow ' restore default error handling
            If Not rngjst Is Nothing Then
                If rngjst.FormattedText <> vbNullString Then
                    rngjst.Copy
                    .Paste
                    '.FormattedText = rngjst.FormattedText
                Else
                    .Text = Const_DEFAULT_JST_TEXT
                    .Font.ColorIndex = wdRed
                End If
            Else
                Set jst = jstcur(strjstbkmark)
                If Not IsJustification(jst) Then
                    .Text = Const_DOC_ERROR_STRING & " No justifications provided in the COVT"
                Else
                    For idx = 0 To jst.Count - 1
                        strlinenum = jst.Keys(idx)
                        strjustification = jst.Items(idx)
                        
                        ' process line number if required
                        If strlinenum <> "0" Then
                            .Text = "Line #" & strlinenum & ": "
                            .Collapse wdCollapseEnd
                        End If
                        
                        If strjustification Like "http://*" Then
                            ' for hyperlinks, split into hyperlink and display text, then split hyperlink into address and subaddress
                            varhlnk = Split(strjustification, ",", 2)
                            varaddress = Split(varhlnk(0), "#", 2)
                            .Text = varhlnk(1)
                            .Hyperlinks.Add rngbkm, varaddress(0), varaddress(1)
                        Else
                            If strjustification <> vbNullString Then
                                ' normal in-line justification
                                .Text = strjustification
                            Else
                                .Text = Const_DEFAULT_JST_TEXT
                                .Font.ColorIndex = wdRed
                            End If
                        End If
                        
                        ' add newline if more justifications to come
                        If Not idx = jst.Count - 1 Then
                            .SetRange .Cells(1).Range.End - 1, .Cells(1).Range.End - 1  ' move to just before the end-of-cell marker
                            .Text = vbCrLf
                            .Collapse wdCollapseEnd
                        End If
                    Next idx
                End If
            End If
        Else
            .Text = Const_DEFAULT_JST_TEXT
            .Font.ColorIndex = wdRed
        End If
    End With

Exit_UpdateJustificationRow:
    Exit Sub

Err_UpdateJustificationRow:
    MsgBox Err.Description & " in UpdateJustificationRow()", vbExclamation
    Resume Next
    
End Sub

Function NotifyUnresolvedJustifications(ByRef tbl As Table) As String
    If FindTextInRange(tbl.Range, Const_DEFAULT_JST_TEXT) Then NotifyUnresolvedJustifications = "WARNING: There are still unresolved justifications in the justifications table"
End Function

Sub StoreJustificationBookmarks(ByRef rng As Range, ByVal strprefix As String, ByRef storage As Scripting.Dictionary)
    Dim bkmark As Bookmark, rngjst As Range
    
    ' store existing justification bookmarks and ranges enclosed in the given section
    For Each bkmark In rng.Bookmarks
        If InStr(1, bkmark.Name, strprefix) = 1 Then
            Set rngjst = bkmark.Range.Next(wdCell)
            rngjst.End = rngjst.End - 1 ' exclude end-of-cell marker from range
            storage.Add bkmark.Name, rngjst
        End If
    Next bkmark

End Sub

Function JSTTypeText(ByVal strtypetext As String, Optional ByVal blextract As Boolean = False) As String
    '==================================================================================================================================
    ' Description: Builds a formatted justification type string from the given string, or extracts the type string from the given string
    '==================================================================================================================================
    If blextract Then
        JSTTypeText = Split(strtypetext, "(", 2)(1) ' get the portion after the first opening bracket
        JSTTypeText = Split(JSTTypeText, ")", 2)(0) ' get the portion before the first closing bracket
    Else
        JSTTypeText = " (" & strtypetext & ")"
    End If
End Function

Function IsJustificationResolved(ByRef cel As Cell) As Boolean
    Dim strtext As String
    strtext = GetCellText(cel)
    If strtext <> vbNullString And InStr(1, strtext, Const_DEFAULT_JST_TEXT) <> 1 Then
        IsJustificationResolved = True
    End If
End Function

Private Function IsJustification(ByRef jst As Scripting.Dictionary) As Boolean

    If jst.Count = 0 Then
       IsJustification = False
    ElseIf jst.Count = 1 And jst.Items(0) = vbNullString Then
        IsJustification = False
    Else
        IsJustification = True
    End If
    
End Function
Attribute VB_Name = "basLandscape"
Option Explicit

Function IsRangeLandscape(ByRef rng As Range) As Boolean
    If Not rng.Information(wdInCommentPane) And _
       Not rng.Information(wdInFootnote) Then
        If rng.PageSetup.Orientation = wdOrientLandscape Then
            IsRangeLandscape = True
        End If
    End If
End Function

Sub InsertLandscapeSection(ByRef rng As Range)
    Dim idx As Integer, strmessage As String
    
    If IsRangeLandscape(rng) Then
        MsgBox "Page is already landscape oriented.", vbExclamation
    Else
        Call ScreenUpdatePause
    
        ' insert two section breaks and decouple from previous header/footer
    
        ' NOTE: Using the Range object's InsertBreak method does not always make the inserted page immediately available, unless a
        '       breakpoint is set. Rather use the Sections' Add method
        rng.Sections.Add rng, wdSectionNewPage
        Set rng = rng.Next(wdSection) ' point to the new section
        rng.PageSetup.DifferentFirstPageHeaderFooter = False
        rng.Sections(1).Headers(wdHeaderFooterPrimary).LinkToPrevious = False
        rng.Sections(1).Footers(wdHeaderFooterPrimary).LinkToPrevious = False
        
        rng.Collapse wdCollapseStart
        rng.Sections.Add rng, wdSectionNewPage
        Set rng = rng.Next(wdSection) ' point to the new section
        rng.Sections(1).Headers(wdHeaderFooterPrimary).LinkToPrevious = False
        rng.Sections(1).Footers(wdHeaderFooterPrimary).LinkToPrevious = False
        rng.Paragraphs(1).Range.Delete ' delete the user's blank paragraph
        
        ' change new page to landscape
        Set rng = rng.Previous(wdParagraph)
        rng.PageSetup.Orientation = wdOrientLandscape
        
        ' re-adjust landscape page header
        Set rng = rng.Sections(1).Headers(wdHeaderFooterPrimary).Range
        With rng
            If .Tables.Count > 0 Then
                With .Tables(1)
                    If .Columns.Count = 3 Then
                        .Columns(3).SetWidth (CentimetersToPoints(Const_LANDSCAPE_PAGE_WIDTH) - .Columns(2).Width - .Columns(1).Width), wdAdjustNone
                        .Rows(1).Cells.DistributeWidth
                    Else
                        strmessage = "Non-standard header format - expected three columns, but found " & .Columns.Count
                    End If
                End With
            Else
                strmessage = "Non-standard header format - no table found"
            End If
        End With
        
        ' re-adjust landscape page footer
        If rng.Sections(1).Footers(wdHeaderFooterPrimary).Range.Paragraphs.Count = 2 Then
            Set rng = rng.Sections(1).Footers(wdHeaderFooterPrimary).Range.Paragraphs(1).Range
            With rng
                For idx = 1 To 2
                    .ParagraphFormat.TabStops.ClearAll
                    .ParagraphFormat.TabStops.Add CentimetersToPoints(0.5 * Const_LANDSCAPE_PAGE_WIDTH), wdAlignTabCenter
                    .ParagraphFormat.TabStops.Add CentimetersToPoints(Const_LANDSCAPE_PAGE_WIDTH), wdAlignTabRight
                    .Move wdParagraph, 1
                Next idx
            End With
        Else
            strmessage = "Non-standard footer - expected two paragraphs, but found " & rng.Sections(1).Footers(wdHeaderFooterPrimary).Range.Paragraphs.Count
        End If
        
        If strmessage <> vbNullString Then
            MsgBox strmessage, vbExclamation, "Header/Footer Error"
        End If
    
        Call ScreenUpdateRestore
        
        rng.Sections(1).Range.Select
    End If
    
End Sub

Sub RemoveLandscapeSection(ByRef rng As Range)
    Dim rngnext As Range
    
    If Not IsRangeLandscape(rng) Then
        MsgBox "Page is not landscape oriented.", vbExclamation
    Else
        Set rngnext = rng.Next(wdSection)
        
        ' clear the landscape section - this also deletes the 2nd section break
        rng.Sections(1).Range.Delete
        
        ' set the "Different First Page" option and unlink the header/footer of section after
        With rngnext
            .PageSetup.DifferentFirstPageHeaderFooter = True
            .Sections(1).Headers(wdHeaderFooterPrimary).LinkToPrevious = True
            .Sections(1).Footers(wdHeaderFooterPrimary).LinkToPrevious = True
        End With
        
        ' delete the section break before the current section
        rng.Move wdParagraph, -1
        rng.Delete
    End If
End Sub
Attribute VB_Name = "basPopupMenu"
Option Explicit

Sub DstInfoFormTextBoxPopupProcess()
    Dim ctlcmdbar As CommandBarControl, cmd As Integer, docinfo As cDocInfo
    Dim strvariable As String, strvalue As String

    If Not IsDstAdministrator Then
        MsgBox "The pop-up menu is reserved for use by the DST owner only"
        Exit Sub
    End If
    
    Set ctlcmdbar = CommandBars.ActionControl
    If ctlcmdbar Is Nothing Then Exit Sub

    Set docinfo = Dst.Document(ActiveDocument.Fullname)
    strvariable = ctlcmdbar.Parameter
    Select Case ctlcmdbar.Index
        Case 2
            strvalue = InputBox("Enter new value for " & strvariable & ":", "Edit", docinfo.Variables.VariableGet(strvariable))
            If strvalue <> vbNullString Then
                docinfo.Variables.VariableEdit strvariable, strvalue
            End If
        Case 3
             docinfo.Variables.VariableDelete strvariable
        Case 4
            strvalue = InputBox("Enter new '" & strvariable & "' variable using syntax below:", "Add", "name=value")
            If strvalue <> vbNullString And strvalue Like "*=*" Then
                strvariable = strvariable & Split(strvalue, "=")(0)
                strvalue = Split(strvalue, "=")(1)
                docinfo.Variables.VariableEdit Trim(strvariable), Trim(strvalue)
            End If
    End Select
    
End Sub
Attribute VB_Name = "basRandD"
Option Explicit

Sub FixBookmarks()
    Call RenameBookmarks("gref_DST", "stndrd_DST_DOCS")
    Call RenameBookmarks("gref_TECHDOCS", "gref_DST_DOCS_Type")
End Sub

Sub ConvertAppendixStyles()
    Dim fso As New FileSystemObject, par As Paragraph, fld As Field
    
    ' change Appendix 1-3 ranges to Heading 7-9
    For Each par In ActiveDocument.Paragraphs
        If par.Style = "Appendix 1" Then par.Style = "Heading 7"
        If par.Style = "Appendix 2" Then par.Style = "Heading 8"
        If par.Style = "Appendix 3" Then par.Style = "Heading 9"
    Next par
    
    ' delete Appendix 1-3 styles
    ActiveDocument.Styles("Appendix 1").Delete
    ActiveDocument.Styles("Appendix 2").Delete
    ActiveDocument.Styles("Appendix 3").Delete
    
    ' re-import styles from master
    Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionImportStyles, , fso.BuildPath(GetTemplatePathLocalDefault(), Const_MASTERTEMPLATE_NAME), vbModal)
    
    ' Fix TOC field
    For Each fld In ActiveDocument.Fields
        If fld.Type = wdFieldTOC Then
            fld.Code.Text = "TOC \o " & """" & "2-5" & """" & " \t " & """" & "Heading 1,1,Appendix 1,1,Appendix 2,2,Appendix 3,3" & """"
            Exit For
        End If
    Next fld
    
End Sub

Sub CreateDummySRSBookmarks()
    Dim idx As Integer, rng As Range, numentries As Integer
    
    ' insert requirements at cursor point
    Set rng = Selection.Range
    numentries = 199
    For idx = 0 To numentries
        If idx Mod 20 = 0 Then
            rng.Text = "Heading Text " & idx
            rng.Style = "Heading 2"
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
            DoEvents
        End If
        If idx Mod 10 = 0 Then
            rng.Text = "Heading Text " & idx
            rng.Style = "Heading 3"
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
        End If
        If idx Mod 5 = 0 Then
            rng.Text = "Heading Text " & idx
            rng.Style = "Heading 4"
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
        End If
        
        rng.Text = "Test_" & idx
        Call AddBookmarkAuto(rng, "reqsw")
        rng.InsertParagraphAfter
        rng.Collapse wdCollapseEnd
        rng.Text = "Requirement text for " & idx
        rng.InsertParagraphAfter
        rng.Collapse wdCollapseEnd
    Next idx
    
End Sub

Sub CreateDummySDDBookmarks()
    Dim idx As Integer, numentries As Integer, rng As Range, strrefbookname As String
    
    ' insert requirements at cursor point
    Set rng = Selection.Range
    numentries = 199
    For idx = 0 To numentries
        If idx Mod 20 = 0 Then
            rng.Text = "Heading Text " & idx
            rng.Style = "Heading 2"
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
            DoEvents
        End If
        If idx Mod 10 = 0 Then
            rng.Text = "Heading Text " & idx
            rng.Style = "Heading 3"
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
        End If
        If idx Mod 5 = 0 Then
            rng.Text = "Heading Text " & idx
            rng.Style = "Heading 4"
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
        End If
        
        rng.Text = "Test_" & idx
        strrefbookname = AddBookmarkAuto(rng, "reqsdd")
        strrefbookname = Replace(strrefbookname, "reqsdd", "reqsw", 1, 1)
        Call InsertXref(rng, strrefbookname, strrefbookname, ActiveDocument.Path & "\srs_demo_big.doc", True)
        strrefbookname = Replace(strrefbookname, idx, numentries - idx, 1, 1)
        Call InsertXref(rng, strrefbookname, strrefbookname, ActiveDocument.Path & "\srs_demo_big.doc", True)
        rng.InsertParagraphAfter
        rng.Collapse wdCollapseEnd
        rng.Text = "Low-level requirement text for " & idx
        rng.InsertParagraphAfter
        rng.Collapse wdCollapseEnd
    Next idx
    
End Sub

Function FixViperDocument(ByRef frm As Object, ByVal strdocname As String) As Boolean
    Dim objdoc As Document, bldocwasopen As Boolean, docinfo As cDocInfo
    Dim strdocnumber As String, strappendix As String, strmessage As String, strpattern As String
    Dim tbl As Table, rw As Row, rwcrnt As Row, rwins As Row, rng As Range, rng2 As Range, fld As Field
    
    If Application.Username Like "Anton*" Or _
       Application.Username Like "Brett*" Or _
       Application.Username Like "Tahnia*" Or _
       Application.Username Like "Johan*" Or _
       Application.Username Like "Rui*" Then
        FixViperDocument = True
        bldocwasopen = IsDocumentOpen(strdocname, objdoc)
        
        frm.UpdateProgressText "Processing " & objdoc.Name
        frm.UpdateProgressText "   - Importing styles"
        Call ImportStyles(objdoc, frm, Dst.Document(objdoc.Fullname).Variables.MasterTemplateUsed)
    
        ' Search/replace Paramout
        frm.UpdateProgressText "   - Fixing Paramout"
        Call DocumentSearchReplace(objdoc, "Paramout", "Paramount", True)
        
        ' Search/replace Advanced Technologies and Engineering (Pty.) Ltd.
        Call DocumentSearchReplace(objdoc, "Advanced Technologies*Engineering*Pty*Ltd", "Paramount Advanced Technologies", False, True)
        
        ' DocumentNumber property to include Document Appendix property value where required
        ' (update DST's Document Status function to check that if DocumentAppendix property exists, that it is included in the DocumentNumber property
        Set docinfo = Dst.Document(objdoc.Fullname)
        strdocnumber = docinfo.Properties.Number
        strappendix = docinfo.Properties.Appendix
        If strappendix <> vbNullString Then
            If Not strdocnumber Like "* App " & strappendix Then
                strdocnumber = strdocnumber & " App " & strappendix
                docinfo.Properties.Number = strdocnumber
                frm.UpdateProgressText "   - Updated property " & docinfo.Properties.PropertyNameNumber & " to " & strdocnumber
                
                ' fix all occurrences of [DocumentNumber] followed by ' App [DocumentAppenddix]'
                strpattern = "^\W*(DOCPROPERTY)\W+(" & docinfo.Properties.PropertyNameNumber & ")\W+"
                For Each rng In ActiveDocument.StoryRanges
                    For Each fld In rng.Fields
                        If fld.Type = wdFieldDocProperty Then
                            If RegularExpressionSearch(fld.Code.Text, strpattern, True) Then
                                Set rng2 = fld.Result
                                If rng2.Next(wdWord, 1).Text = "App " And rng2.Next(wdWord, 2).Text Like strappendix & "*" Then
                                    rng2.Next(wdWord, 2).Delete
                                    rng2.Next(wdWord, 1).Delete
                                    rng2.Next(wdCharacter, 1).Delete
                                    frm.UpdateProgressText "   - Removed 'App " & strappendix & "' text at position " & rng2.End
                                End If
                            End If
                        End If
                    Next fld
                Next rng
            End If
        End If
        
        ' Move PAT entry to correct place in Abbreviations table
        For Each tbl In objdoc.Tables
            If tbl.Columns.Count = 2 Then
                Set rng = objdoc.Range
                rng.SetRange tbl.Range.Previous(wdParagraph, 2).Start, tbl.Range.Start
                If rng.Text Like "*LIST*ABBREVIATIONS*" Then
                    For Each rw In tbl.Rows
                        If GetCellText(rw.Cells(1)) = "PAT" Then
                            Set rwcrnt = rw
                            Exit For
                        End If
                    Next rw
                    
                    If Not rwcrnt Is Nothing Then
                        Set rwins = Nothing
                        For Each rw In tbl.Rows
                            If rw.Index <> rwcrnt.Index Then
                                If rw.Index < tbl.Rows.Count Then
                                    If StrComp(GetCellText(rw.Cells(1)), "PAT", vbTextCompare) = -1 And _
                                       StrComp(GetCellText(rw.Next.Cells(1)), "PAT", vbTextCompare) = 1 Then
                                        Set rwins = tbl.Rows.Add(rw.Next)
                                        Exit For
                                    End If
                                Else
                                    If GetCellText(rw.Cells(1)) <> vbNullString And StrComp(GetCellText(rw.Cells(1)), "PAT", vbTextCompare) = -1 Then
                                        Set rwins = tbl.Rows.Add
                                    End If
                                End If
                            End If
                        Next rw
                        If Not rwins Is Nothing Then
                            rwins.Cells(1).Range.Text = GetCellText(rwcrnt.Cells(1))
                            rwins.Cells(2).Range.Text = GetCellText(rwcrnt.Cells(2))
                            rwcrnt.Delete
                            frm.UpdateProgressText "   - Moved PAT abbreviation to row below " & GetCellText(rwins.Previous.Cells(1))
                        End If
                    Else
                        frm.UpdateProgressText "INFO: PAT Abbreviation not found"
                    End If
                    Exit For
                End If
            End If
        Next tbl

        frm.UpdateProgressText vbCrLf & "Updating all fields:"
        If Not UpdateAllFields(objdoc, frm, False) Then FixViperDocument = False
        
        objdoc.Save
        If Not bldocwasopen Then
            objdoc.Close wdDoNotSaveChanges
        End If
    Else
        frm.UpdateProgressText "The button says 'Do Not Press' - you are not authorised to use this function!"
    End If
    
End Function

Function ChangeDanubeToViper(ByRef objdoc As Document, ByRef frm As Object) As Boolean
    Dim strmessage As String, strvalue As String, strname As String
    Dim rng As Range, tbl As Table, fld As Field, hlnk As Hyperlink, sect As section, ishape As InlineShape
    Dim numcols As Integer, bkm As Bookmark, docinfo As cDocInfo
On Error GoTo Err_ChangeDanubeToViper

    ChangeDanubeToViper = True
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Import latest styles
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Importing styles..."
    Call ImportStyles(objdoc, frm, Dst.Document(objdoc.Fullname).Variables.MasterTemplateUsed)
        
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Make sure all document property references use an uppercased field code
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Fixing DOCPROPERTY references..."
    For Each rng In objdoc.StoryRanges
        For Each fld In rng.Fields
            If RegularExpressionSearch(fld.Code.Text, " DOCPROPERTY ", True) Then
                fld.Code.Text = Replace(fld.Code.Text, " DOCPROPERTY ", " DOCPROPERTY ", 1, 1, vbTextCompare)
                fld.Update
            End If
        Next fld
    Next rng
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Modify document properties
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Updating document properties..."
    Set docinfo = Dst.Document(objdoc.Fullname)
    docinfo.Properties.Programme = "Viper"
    docinfo.Properties.DocDate = Format(Date, "dd mmmm yyyy")
    docinfo.Properties.Number = Replace(docinfo.Properties.Number, "DAN", "VPR", 1, 1, vbTextCompare)
    docinfo.Properties.Issue = "1 Draft A"
    
    
    ' set Title property
    Set rng = objdoc.Tables(1).Range.Rows(4).Range
    rng.Fields.Update
    strname = GetCellText(rng.Cells(2))
    strname = Replace(strname, vbCr, " ") ' remove CRs
    strname = Replace(strname, vbLf, " ") ' remove LFs
    strname = Trim(RegularExpressionReplace(strname, "\s+", " ")) ' trim whitespace
    docinfo.Properties.Title = strname
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Modify pictures on Cover Page and in all section Headers, update footers
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Modifying cover page, headers and footers..."
    If objdoc.Sections(1).Headers(wdHeaderFooterFirstPage).Shapes.Count > 0 Then objdoc.Sections(1).Headers(wdHeaderFooterFirstPage).Shapes(1).Delete ' delete old ATE frame
    ' format table and insert PAT logo
    Set tbl = objdoc.Tables(1)
    tbl.Rows(1).Height = CentimetersToPoints(3.5)
    tbl.Rows(2).Height = CentimetersToPoints(6.5)
    tbl.Rows(3).Height = CentimetersToPoints(1)
    tbl.Rows(4).Height = CentimetersToPoints(3.7)
    Set rng = tbl.Cell(1, 2).Range
    Set ishape = rng.InlineShapes.AddPicture("C:\Users\anton.coetzee\Documents\Templates\PATCover.gif", False, True)
    With ishape
        With .PictureFormat
            .CropLeft = CentimetersToPoints(4.28)
            .CropRight = CentimetersToPoints(2.28)
            .CropTop = CentimetersToPoints(5.12)
            .CropBottom = CentimetersToPoints(5.12)
        End With
        .Height = CentimetersToPoints(3.7)
        .Width = CentimetersToPoints(11.5)
    End With
    ' programme logo
    Set rng = tbl.Cell(2, 2).Range
    If rng.InlineShapes.Count > 0 Then rng.InlineShapes(1).Delete
    Set ishape = rng.InlineShapes.AddPicture("C:\Users\anton.coetzee\Documents\Templates\ViperLogo.jpg", False, True)
    With ishape
        .Height = CentimetersToPoints(6.5)
        .Width = CentimetersToPoints(10#)
    End With
    ' update cover footer table
    Set tbl = objdoc.Sections(1).Footers(wdHeaderFooterFirstPage).Range.Tables(1)
    tbl.Rows(1).Cells(2).Range.Text = "DOCUMENT No."
    Set rng = tbl.Rows(1).Cells(4).Range
    rng.Text = vbNullString
    rng.Collapse wdCollapseStart
    Set fld = objdoc.Fields.Add(rng, wdFieldDocProperty, docinfo.Properties.PropertyNameType, True)
    rng.InsertBefore "/"
    rng.Collapse wdCollapseStart
    Set fld = rng.Fields.Add(rng, wdFieldDocProperty, docinfo.Properties.PropertyNameNumber, True)
    tbl.Rows(2).Cells(2).Range.Text = "ISSUE"
    Set rng = tbl.Rows(2).Cells(4).Range
    rng.Text = vbNullString
    rng.Collapse wdCollapseStart
    Set fld = rng.Fields.Add(rng, wdFieldDocProperty, docinfo.Properties.PropertyNameIssue, True)
    tbl.Rows(3).Cells(2).Range.Text = "DATE"
    Set rng = tbl.Rows(3).Cells(4).Range
    rng.Text = vbNullString
    rng.Collapse wdCollapseStart
    Set fld = rng.Fields.Add(rng, wdFieldDocProperty, docinfo.Properties.PropertyNameDate, True)
    tbl.Rows(4).Cells(2).Range.Text = "CLASSIFICATION"
    Set rng = tbl.Rows(4).Cells(4).Range
    rng.Text = vbNullString
    rng.Collapse wdCollapseStart
    Set fld = rng.Fields.Add(rng, wdFieldDocProperty, docinfo.Properties.PropertyNameClassification, True)
    ' remove RESTRICTED field below table in footer
    Set rng = tbl.Range.Next(wdParagraph)
    If rng.Fields.Count > 0 Then
        Set fld = rng.Fields(1)
        If fld.Result = "RESTRICTED" Then fld.Delete
    End If
    ' set rest of headers and footers
    For Each sect In objdoc.Sections
        Set rng = sect.Headers(wdHeaderFooterPrimary).Range.Tables(1).Cell(1, 1).Range
        If rng.InlineShapes.Count > 0 Then rng.InlineShapes(1).Delete
        rng.InlineShapes.AddPicture "C:\Users\anton.coetzee\Documents\Templates\PATHeader.gif", False, True
        Set rng = sect.Headers(wdHeaderFooterPrimary).Range.Tables(1).Cell(1, 2).Range
        If rng.Fields.Count > 0 Then
            Set fld = rng.Fields(1)
            fld.Delete
            rng.Text = vbNullString
            rng.Collapse wdCollapseStart
            Set fld = rng.Fields.Add(rng, wdFieldDocProperty, "Title", True)
            rng.Cells(1).VerticalAlignment = wdCellAlignVerticalCenter
            rng.Cells(1).Range.Font.Size = 8
        End If
        
        Set rng = sect.Headers(wdHeaderFooterPrimary).Range.Tables(1).Cell(1, 3).Range
        If rng.InlineShapes.Count > 0 Then rng.InlineShapes(1).Delete
        Set ishape = rng.InlineShapes.AddPicture("C:\Users\anton.coetzee\Documents\Templates\ViperLogo.jpg", False, True)
        With ishape
            .Height = CentimetersToPoints(1.5)
            .Width = CentimetersToPoints(2.3)
        End With
        
        Set rng = sect.Footers(wdHeaderFooterPrimary).Range.Paragraphs(1).Range
        rng.Font.Size = 6.5
        rng.End = rng.End - 1
        rng.Text = "This document is strictly confidential and cannot be used, reproduced or transmitted without the prior written authorisation of Paramount"
    Next sect
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Update Amendment Record
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Updating Amendment Record..."
    strmessage = ValidateAmendmentRecordTable(objdoc, tbl, True)
    If strmessage = vbNullString Then
        Set rng = tbl.Range
        rng.Collapse wdCollapseStart
        numcols = tbl.Rows(1).Cells.Count
        tbl.Delete
        Set tbl = Nothing
        Set tbl = CreateTableTemplate(rng, 51, numcols)
        If Not tbl Is Nothing Then
            Call FormatTable(tbl)
            With tbl.Rows(1)
                .Cells(1).Range.Text = "CHANGE REF."
                If numcols = 5 Then .Cells(2).Range.Text = "PARAGRAPH"
                .Cells(numcols).Range.Text = "AUTHOR"
                .Cells(numcols - 1).Range.Text = "DATE"
                .Cells(numcols - 2).Range.Text = "ISSUE"
            End With
            With tbl.Rows(2)
                .Cells(1).Range.Text = "VPR-EPR-0001"
                If numcols = 5 Then .Cells(2).Range.Text = "All"
                .Cells(numcols).Range.Text = "A. Coetzee"
                .Cells(numcols - 1).Range.Text = Format(Date, "dd mmm yyyy")
                .Cells(numcols - 2).Range.Text = "01 Draft A1"
            End With
        Else
            frm.UpdateProgressText "ERROR: Could not create new Amendment Record Table"
            ChangeDanubeToViper = False
        End If
    Else
        frm.UpdateProgressText "ERROR: " & strmessage
        ChangeDanubeToViper = False
    End If

    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Rename *DAN_MC* bookmarks (don't think Danube, DANUBE, danube are used anywhere)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Renaming bookmarks..."
    For Each bkm In objdoc.Bookmarks
        strname = bkm.Name
        If strname Like "*DAN_MC*" Then
            strvalue = Replace(strname, "DAN_MC", "VPR_MC")
            If Not RenameBookmark(objdoc, strname, strvalue, strmessage) Then
                frm.UpdateProgressText "ERROR: " & strmessage
                ChangeDanubeToViper = False
            End If
        End If
    Next bkm
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Update all picture fields - lock them
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Updating pictures..."
    For Each fld In objdoc.Fields
        If fld.Type = wdFieldIncludePicture Then
            fld.Select
            If CurrentSelection.NumFields > 0 Then
                If Not UpdateLockedField(objdoc, CurrentSelection, strmessage) Then
                    frm.UpdateProgressText "    " & strmessage
                End If
                fld.Locked = True ' make sure it is locked
            Else
                frm.UpdateProgressText "ERROR: zero fields at position " & fld.Result.Start
                ChangeDanubeToViper = False
            End If
        End If
    Next fld
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Fix hyperlinks such as SDF
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Fixing hyperlinks..."
    For Each hlnk In objdoc.Hyperlinks
        Dim blecho As Boolean
        blecho = False
        If InStr(1, hlnk.Address, "Danube") Then
            blecho = True
            hlnk.Address = Replace(hlnk.Address, "Danube", "Viper")
        ElseIf InStr(1, hlnk.Address, "danube") Then
            blecho = True
            hlnk.Address = Replace(hlnk.Address, "danube", "viper")
        End If
        
        If InStr(1, hlnk.Address, "http://wiki.esd.ate-aerospace/foswiki/bin/view/", vbTextCompare) Then
            hlnk.Address = Replace(hlnk.Address, "http://wiki.esd.ate-aerospace/foswiki/bin/view/", "http://wiki.esd.ate-group.com/", 1, 1, vbTextCompare)
        End If
        
        If blecho Then frm.UpdateProgressText "    " & hlnk.Address
    Next hlnk

    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Update All Fields and check the Document Status
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText vbCrLf & "Updating all fields:"
    If Not UpdateAllFields(objdoc, frm, False) Then ChangeDanubeToViper = False
    
    frm.UpdateProgressText vbCrLf & "Checking document status:"
    If Not CheckDocumentStatusComplete(objdoc, frm) Then ChangeDanubeToViper = False

    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Check title bookmark against Title property
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    strvalue = UCase(Left(objdoc.Name, InStr(1, objdoc.Name, ".") - 1))
    If objdoc.Bookmarks.Exists(strvalue) Then
        Set bkm = objdoc.Bookmarks(strvalue)
        strname = docinfo.Properties.BuiltIn(wdPropertyTitle)
        If bkm.Range.Text <> strname Then
            frm.UpdateProgressText "ERROR: Document title and corresponding title bookmark text do not match: '" & strname & "' vs. '" & bkm.Range.Text & "'"
            ChangeDanubeToViper = False
        End If
    Else
        frm.UpdateProgressText "ERROR: Could not find title bookmark '" & strvalue & "'"
        ChangeDanubeToViper = False
    End If
           
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Search/Replace for remaining
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    frm.UpdateProgressText "Renaming remaining text..."
    Call DocumentSearchReplace(objdoc, "Danube", "Viper")
    Call DocumentSearchReplace(objdoc, "danube", "viper")
    Call DocumentSearchReplace(objdoc, "DAN", "VPR")
    Call DocumentSearchReplace(objdoc, "ATE (PTY) LTD", "Paramout Advanced Technologies", True)
    Call DocumentSearchReplace(objdoc, "ATE", "PAT", True)
    Call DocumentSearchReplace(objdoc, "Advanced Technologies and Engineering Co. (Pty) Ltd", "Paramout Advanced Technologies", True)
    
    ' go to top of document
    objdoc.Paragraphs(1).Range.Select
    
Exit_ChangeDanubeToViper:
    Exit Function
    
Err_ChangeDanubeToViper:
    MsgBox Err.Description, vbCritical
    ChangeDanubeToViper = False
    Resume Exit_ChangeDanubeToViper
        
End Function

Sub PrintTestSets()
    Dim idx As Integer, idx2 As Integer
    Dim tset As cHeadingGroup, tcase As cHeading, numtestcases As Integer
    Dim rng As Range, intlevel As Integer, rngnew As Range, tbl As Table
    Dim strtemp As String, objatr As Document, objatp As Document
    
    ' NOTE: this function assumes the ATP and ATR are open and that a section called "Tests Executed" exists in the ATR and that it is empty
    Set objatr = Application.Documents("atr_efst.doc")
    Set rng = GetHeadingRangeExtendedFromText(objatr.Range, "Tests Executed")
    If Not rng Is Nothing Then
        ' add paragraphs in case section is empty
        If rng.Paragraphs.Count = 1 Then
            rng.Paragraphs.Add
            rng.Paragraphs.Add
            rng.SetRange rng.Start, rng.Paragraphs(2).Range.End ' we need blank line after last table, so don't include 3rd paragraph in range
        End If
        
        ' get heading level and adjust range to exclude heading (from 2nd paragraph)
        intlevel = rng.Paragraphs(1).Range.ListFormat.ListLevelNumber
        rng.Start = rng.Paragraphs(2).Range.Start
        
        Set rngnew = objatr.Range
        rngnew.SetRange rng.Start, rng.Start
            
        Set objatp = Application.Documents("atp_efst.doc")
        objatp.Activate
        Call BuildTestSpecificationList
        
        For idx = 0 To TestSets.Count - 1
            Set tset = TestSets.Items(idx)
            
            Debug.Print "Adding table for " & tset.Group.Bookmark
            If InsertXref(rngnew, tset.Group.Bookmark, tset.Group.Bookmark, objatp.Fullname, False, True, strtemp) Then
                rngnew.Style = wdStyleHeading1 - intlevel
                rngnew.InsertParagraphAfter
                rngnew.Collapse wdCollapseEnd
                
                For idx2 = 0 To tset.SubItems.Count - 1
                    Set tcase = tset.SubItems.Items(idx2)
                    Debug.Print "   " & tcase.Number & " " & tcase.Bookmark
                    numtestcases = numtestcases + 1
                Next idx2

                strtemp = InsertATRResultTable(rngnew, tset, objatp.Fullname)
                If strtemp <> vbNullString Then
                    Debug.Print strtemp
                End If
            Else
                Debug.Print strtemp
            End If
            
            objatp.Activate
            Call BuildTestSpecificationList ' need to call this repeatedly because TestSet dictionary gets wacked everytime for some unknown reason
        Next idx
    Else
        Debug.Print "Could not find section called 'Tests Executed' in " & objatr.Fullname
    End If
    
    ' update summary table as well
    Set tbl = GetTable(objatr, Const_DOCHLTEST_SUMMARY, strtemp)
    If strtemp <> vbNullString Then
        Debug.Print strtemp
    Else
        tbl.Cell(2, 2).Range.Text = numtestcases
        tbl.Cell(3, 2).Range.Text = "0"
        tbl.Cell(4, 2).Range.Text = "0"
    End If
    
End Sub

Private Function InsertATRResultTable(ByRef rng As Range, ByRef tset As cHeadingGroup, ByVal stratppath As String) As String
    Dim tbl As Table, tcase As cHeading, rngcel As Range
    Dim numrows As Integer, idx As Integer, strmessage As String, strtemp As String
    
    numrows = tset.SubItems.Count + 1
    Set tbl = CreateTableTemplate(rng, numrows, 3, , , True)
    If Not tbl Is Nothing Then
        With tbl
            ' adjust the column widths
            .Columns(1).SetWidth CentimetersToPoints(6), wdAdjustNone
            .Columns(2).SetWidth CentimetersToPoints(8), wdAdjustNone
            .Columns(3).SetWidth CentimetersToPoints(Const_TABLE_WIDTH) - tbl.Columns(1).Width - tbl.Columns(2).Width, wdAdjustNone
            For idx = 1 To numrows
                .Cell(idx, 3).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
            Next idx
                
            ' header
            Set rngcel = .Cell(1, 1).Range
            rngcel.Text = "Test Case Identifier"
            .Cell(1, 2).Range.Text = "Comments"
            .Cell(1, 3).Range.Text = "Result"
            
            ' test cases
            For idx = 2 To numrows
                Set tcase = tset.SubItems.Items(idx - 2)
                Set rngcel = .Cell(idx, 1).Range
                If Not InsertXref(rngcel, tcase.Bookmark, tcase.Bookmark, stratppath, False, True, strtemp) Then
                    strmessage = strmessage & strtemp & vbCrLf
                End If
                .Cell(idx, 3).Range.Text = Const_TESTRESULT_PASSED
            Next idx
            
            ' collapse range to end of table
            Set rng = .Range
            rng.Collapse wdCollapseEnd
        End With
    Else
        strmessage = "Unable to create test results table for '" & tset.Group.Bookmark & "'"
    End If
    
    If strmessage <> vbNullString Then
        InsertATRResultTable = strmessage
    End If
    
End Function

Sub GetReferences()
    Dim ref As Reference
    
    For Each ref In Application.VBE.ActiveVBProject.References
        Debug.Print ref.Name & " " & ref.FullPath & " " & ref.GUID & " " & ref.Major & "." & ref.Minor
    Next ref
End Sub

Sub BarOpen()
  Dim xBar As CommandBar
  Dim xBarPop As CommandBarPopup
  Dim bCreatedNew As Boolean
  Dim N As Integer, m As Integer
  Dim k As Integer
  Dim APP_NAME As String
  Dim ICON_SET As Integer
  
  APP_NAME = "FaceIDs (Browser)"
  ICON_SET = 30

  On Error Resume Next
  ' Try to get a reference to the 'FaceID Browser' toolbar if it exists and delete it:
  Set xBar = CommandBars(APP_NAME)
  On Error GoTo 0
  If Not xBar Is Nothing Then
    xBar.Delete
    Set xBar = Nothing
  End If

  Set xBar = CommandBars.Add(Name:=APP_NAME, Temporary:=True) ', Position:=msoBarLeft
  With xBar
    .Visible = True
    '.Width = 80
    For k = 0 To 4 ' 5 dropdowns, each for about 1000 FaceIDs
      Set xBarPop = .Controls.Add(Type:=msoControlPopup) ', Before:=1
      With xBarPop
        .BeginGroup = True
        If k = 0 Then
          .Caption = "Face IDs " & 1 + 1000 * k & " ... "
        Else
          .Caption = 1 + 1000 * k & " ... "
        End If
        N = 1
        Do
          With .Controls.Add(Type:=msoControlPopup) '34 items * 30 items = 1020 faceIDs
            .Caption = 1000 * k + N & " ... " & 1000 * k + N + ICON_SET - 1
            For m = 0 To ICON_SET - 1
              With .Controls.Add(Type:=msoControlButton) '
                .Caption = "ID=" & 1000 * k + N + m
                .FaceId = 1000 * k + N + m
              End With
            Next m
          End With
          N = N + ICON_SET
        Loop While N < 1000 ' or 1020, some overlapp
      End With
    Next k
  End With 'xBar
End Sub

Sub FixeFASTATPReferences()
    Dim intfilenum As Integer, strline As String, varspec As Variant, rng As Range
    
    intfilenum = FreeFile
    Open "C:\projects\dmttest\efast\doc\rename.dat" For Input As #intfilenum
    
    Set rng = ActiveDocument.Range
    With rng.Find
        .ClearFormatting
        .Forward = True
        .MatchWholeWord = True
        .MatchSoundsLike = False
        .MatchWildcards = False
        .MatchCase = True
        .MatchPrefix = False
        .Wrap = wdFindStop
    End With
    
    Do While Not EOF(intfilenum)
        Line Input #intfilenum, strline
        varspec = Split(strline, "=")
        If UBound(varspec) > 0 Then
            Set rng = ActiveDocument.Range
            While rng.Find.Execute(varspec(0))
                If Not InsertXref(rng, Trim(varspec(1)), Trim(varspec(1)), "C:\projects\dmttest\efast\doc\urs_efst.doc", True, True) Then
                    Debug.Print varspec(0) & "=" & varspec(1)
                End If
            Wend
        End If
    Loop
    Close #intfilenum
    
End Sub

Sub AddeFASTATPBookmarks()
    Dim rng As Range, strtestcase As String
    
    Set rng = ActiveDocument.Range
    With rng.Find
        .ClearFormatting
        .Forward = True
        .MatchWholeWord = True
        .MatchSoundsLike = False
        .MatchWildcards = False
        .MatchCase = True
        .MatchPrefix = False
        .Wrap = wdFindStop
    End With
    
    While rng.Find.Execute("TST_")
        Call SetBookmarkTextRange(rng)
        strtestcase = Replace(rng.Text, "TST_", "tchln_EFST_")
        rng.Text = strtestcase
        If Not AddBookmark(rng, strtestcase) Then
            Debug.Print rng.Text & "=" & strtestcase
            Set rng = ActiveDocument.Range
        End If
    Wend
    
End Sub

Sub FixTSMBookmarkText()
    Dim strbkname As String, bkmark As Bookmark
On Error GoTo Err_FixTSMBookmarkText

    ' loop through all fields in the document and apply the TRC style
    For Each bkmark In ActiveDocument.StoryRanges(wdMainTextStory).Bookmarks
        strbkname = bkmark.Name
        If strbkname Like "tsm_*" And Not bkmark.Range.Text Like "tsm_*" Then
            bkmark.Range.InsertBefore "tsm_"
        End If
    Next bkmark
    
Exit_FixTSMBookmarkText:
    Exit Sub
    
Err_FixTSMBookmarkText:
    MsgBox Err.Description
    Resume Exit_FixTSMBookmarkText
End Sub

Sub RenameBookmarks(ByVal stroldprefix As String, ByVal strnewprefix As String)
    Dim stroldbookmark As String, strnewbookmark As String, bkmark As Bookmark, strmessage As String
    
    If Dst.BookmarkConfig.Prefixes.Exists(Dst.BookmarkConfig.PrefixFromName(strnewprefix)) Then
        For Each bkmark In ActiveDocument.Bookmarks
            stroldbookmark = bkmark.Name
            If stroldbookmark Like stroldprefix & "_*" Then
                strmessage = vbNullString
                strnewbookmark = Replace(stroldbookmark, stroldprefix & "_", strnewprefix & "_")
                
                If RenameBookmark(ActiveDocument, stroldbookmark, strnewbookmark, strmessage) <> True Then
                    MsgBox strmessage, "Bookmark Rename Error", vbExclamation
                End If
            End If
        Next bkmark
    Else
        MsgBox "Unknown bookmark prefix '" & strnewprefix & "'", vbExclamation
    End If
    
End Sub
                
Sub RenameSDSBookmarks()
    Dim stroldbookmark As String, strnewbookmark As String, bkmark As Bookmark, rng As Range, tbl As Table
    
    If ValidateDocExtRefsTable(ActiveDocument, tbl) Then
        For Each bkmark In tbl.Range.Bookmarks
            stroldbookmark = bkmark.Name
            Set rng = bkmark.Range
            If stroldbookmark Like "reqsds_*" And Not stroldbookmark Like "reqsds_SAWS_*" Then
                If DeleteBookmark(rng, True) = True Then
                    strnewbookmark = Replace(stroldbookmark, "reqsds_", "reqsds_SAWS_")
                    rng.Bookmarks.Add strnewbookmark
                    Call RenameRefs(ActiveDocument, stroldbookmark, strnewbookmark)
                End If
            End If
        Next bkmark
    End If
                
End Sub
                
Sub RenameSAWSBookmarks()
    Dim stroldbookmark As String, strnewbookmark As String, bkmark As Bookmark, rng As Range, tbl As Table
    
    If ValidateDocExtRefsTable(ActiveDocument, tbl) Then
        For Each bkmark In tbl.Range.Bookmarks
            stroldbookmark = bkmark.Name
            Set rng = bkmark.Range
            If stroldbookmark Like "reqsaws_*" Then
                If DeleteBookmark(rng, True) = True Then
                    strnewbookmark = Replace(stroldbookmark, "reqsaws_", "reqsds_")
                    rng.Bookmarks.Add strnewbookmark
                    Call RenameRefs(ActiveDocument, stroldbookmark, strnewbookmark)
                End If
            End If
        Next bkmark
    End If
                
End Sub
                
Sub ApplyBkmStyleToRefs()
    Dim strbkname As String, bkmark As Bookmark
On Error GoTo Err_ApplyBkmStyleToRefs

    ' loop through all fields in the document and apply the TRC style
    For Each bkmark In ActiveDocument.StoryRanges(wdMainTextStory).Bookmarks
        strbkname = bkmark.Name
        If strbkname Like "tcstp_*" Or strbkname Like "tsstp_*" Then
            bkmark.Range.Style = "DSTTpBkm"
        End If
    Next bkmark
    
Exit_ApplyBkmStyleToRefs:
    Exit Sub
    
Err_ApplyBkmStyleToRefs:
    MsgBox Err.Description
    Resume Exit_ApplyBkmStyleToRefs
End Sub

                
Sub ApplyTrcStyleToRefs()
    Dim strbkname As String, fld As Field
On Error GoTo Err_ApplyTrcStyleToRefs

    ' loop through all fields in the document and apply the TRC style
    For Each fld In ActiveDocument.StoryRanges(wdMainTextStory).Fields
        strbkname = GetBookmarkNameFromField(fld)
        If strbkname Like "sreqsrs_*" Then
            fld.Result.Style = "DSTTrcRef"
        End If
    Next fld
    
Exit_ApplyTrcStyleToRefs:
    Exit Sub
    
Err_ApplyTrcStyleToRefs:
    MsgBox Err.Description
    Resume Exit_ApplyTrcStyleToRefs
End Sub

Sub GetWordVersion()
    Dim objword As Word.Application
    
    Set objword = CreateObject("Word.Application")
    Debug.Print objword.Version
    objword.Quit

End Sub

Sub FixTestTableStyles()
    Dim tbl As Table
    
    ' !!!!!!!!!!!! Import Styles
    
    Set tbl = ActiveDocument.ActiveWindow.Selection.Tables(1)
    If tbl.Range.ListParagraphs.Count > 0 Then
        If MsgBox("Table has list paragraphs. Continue?", vbYesNo) = vbYes Then
           MsgBox "Remember to re-apply the list paragraphs afterwards!"
        Else
            Exit Sub
        End If
    End If
    If tbl.Range.Style Is Nothing Then
        tbl.Range.Style = "Table Text Small"
    Else
        If tbl.Range.Style <> "Table Text Small" Then
            tbl.Range.Style = "Table Text Small"
        End If
    End If
        
    Call BuildTestSpecificationList ' function below needs this
    Call FormatTestTable(tbl.Range)
    tbl.Range.Fields.Update
    
End Sub

Sub ReformatTestAbstractionTable()
    Dim tbl As Table, rw As Row, tblfrmt As cTblTestFormat, rwfrmt As cTblRowFormat, secfrmt As cTblSectionFormat, strmessage As String
    
    Set tbl = ActiveDocument.ActiveWindow.Selection.Tables(1)
    Set tblfrmt = New cTblTestFormat
    
    Set rw = tbl.Rows(2)
    If rw.Cells.Count = 3 Then rw.Cells(3).Split 1, 2
    Set rw = tbl.Rows.Add(rw)
    rw.Cells(2).Merge rw.Cells(rw.Cells.Count)
    Call SetTestTableFormat(GetHeadingAsRange(rw.Range).Bookmarks(1).Name, tblfrmt)
    Set secfrmt = tblfrmt.TableFormat.Item(Const_TABLE_ASSUMPTIONS_TEXT)
    Set rwfrmt = secfrmt.HeadingRow
    rwfrmt.Format rw, 1, secfrmt.SectionHeader, True
    
    Set rw = tbl.Rows(3)
    Set rw = tbl.Rows.Add(rw)
    rw.Cells(2).Merge rw.Cells(rw.Cells.Count)
    Set secfrmt = tblfrmt.TableFormat.Item(Const_TABLE_SIDE_EFFECTS_TEXT)
    Set rwfrmt = secfrmt.HeadingRow
    rwfrmt.Format rw, 1, secfrmt.SectionHeader, True
    
    Set rw = tbl.Rows(4)
    Set rw = tbl.Rows.Add(rw)
    Set secfrmt = tblfrmt.TableFormat.Item(Const_TABLE_INPUTS_TEXT)
    Set rwfrmt = secfrmt.HeadingRow
    rwfrmt.Format rw, 1, secfrmt.SectionHeader, True
    Set rw = rw.Next
    rw.Cells(1).Range.Text = vbNullString
    
    Set rw = tblfrmt.GetSectionStartRow(tbl, Const_TABLE_PROCEDURE_TEXT)
    rw.Cells(3).Range.Text = Const_TABLE_STEP_RESULT_TEXT
    
    Set rw = tblfrmt.GetSectionStartRow(tbl, Const_TABLE_IMP_REF_TEXT)
    Set rw = rw.Previous
    If GetCellText(rw.Cells(1)) = Const_TABLE_RESULTS_TEXT Then rw.Delete
    
    strmessage = tblfrmt.Format(tbl)
    If strmessage <> vbNullString Then
        MsgBox strmessage
    End If
End Sub

Sub ReformatTestCaseTable()
    Dim tbl As Table, rw As Row, tblfrmt As cTblTestFormat, strmessage As String, rngsrc As Range, rngdest As Range, strtext As String
    
    Set tbl = ActiveDocument.ActiveWindow.Selection.Tables(1)
    Set tblfrmt = New cTblTestFormat
    
    Set rw = tbl.Rows(1)
    Call SetTestTableFormat(GetHeadingAsRange(rw.Range).Bookmarks(1).Name, tblfrmt)
    
    While Not rw.IsLast
        If GetCellText(rw.Cells(1)) = Const_TABLE_RESULTS_TEXT Then
            Set rngdest = rw.Previous.Cells(4).Range
            Set rngsrc = rw.Cells(3).Range
            rngdest.End = rngdest.End - 1
            rngsrc.End = rngsrc.End - 1
            strtext = GetCellText(rw.Cells(3))
            If strtext <> "None." And strtext <> "None" And strtext <> "All checks in the procedure must pass." Then rngdest.FormattedText = rngsrc.FormattedText
            rw.Delete
            Set rw = tbl.Rows(tbl.Rows.Count) ' exit loop
        Else
            Set rw = rw.Next
        End If
    Wend
    
    strmessage = tblfrmt.Format(tbl)
    If strmessage <> vbNullString Then
        MsgBox strmessage
    End If
    
End Sub

Sub ApplyStyleToTestRequirementRefsInTable()
    Dim tbl As Table, rw As Row, rng As Range, fld As Field, strbkname As String

    ' loop through all tables and check if test case table - Purpose text and 2 columns
    If Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr = "STD" Then
        Set tbl = Selection.Tables(1)
        For Each fld In tbl.Range.Fields
            strbkname = GetBookmarkNameFromField(fld)
            If strbkname Like "*reqdfs_*" Then
                fld.Result.Style = "DSTTrcRef"
            End If
        Next fld
    Else
        MsgBox "This function only works on STDs", vbExclamation
    End If
    
End Sub

Sub duration()
    Dim sum As New cTestSummary, idx As Integer
    Dim dte1 As Date, dte2 As Date
    Dim days As Single, hours As String, minutes As String, seconds As String
    
    dte1 = "15:00:00"
    For idx = 0 To 4
        dte2 = dte2 + dte1
    Next idx
    'dte2 = "17:01:26"
    days = Int(dte2)
    hours = Format(dte2, "h")
    minutes = Format(dte2, "n")
    seconds = Format(dte2, "s")
    Debug.Print "Duration: " & days & " day(s) " & Format(TimeSerial(hours, minutes, seconds), "HH:mm:ss")
    Debug.Print "Duration: " & days & " day(s) " & Format(dte2, "HH:mm:ss")
    
End Sub

Sub FixSTDRequirementRows()
    Dim tbl As Table, rw As Row, rng As Range, cel As Cell
    Dim strtext As String, blinreqrows As Boolean, lngwidth As Long
On Error GoTo Err_FixSTDRequirementRow

    ' loop through all tables and check if test case table - Purpose text and 2 columns
    For Each tbl In ActiveDocument.Tables
        Set rw = tbl.Rows(1)
        If rw.Cells.Count = 2 And GetCellText(rw.Cells(1)) = Const_TABLE_PURPOSE_TEXT Then
            blinreqrows = False
            For Each rw In tbl.Rows
                strtext = GetCellText(rw.Cells(1))
                If strtext <> vbNullString Then blinreqrows = False
                
                If strtext = Const_TABLE_REQUIREMENTS_TEXT Then
                    blinreqrows = True
                End If
                
                If blinreqrows = True Then
                    If rw.Cells.Count = 5 Then
                        rw.Cells(3).Range.Text = vbNullString
                        rw.Cells(3).Merge rw.Cells(4)
                        lngwidth = rw.Cells(3).Width + rw.Cells(4).Width
                        rw.Cells(3).Width = CentimetersToPoints(7.51)
                        rw.Cells(4).Width = lngwidth - rw.Cells(3).Width
                        rw.Cells(4).Range.Font.Size = 8
                    End If
                End If
            Next rw
        End If
Continue_Next_Table:
    Next tbl

Exit_FixSTDRequirementRow:
    Exit Sub
    
Err_FixSTDRequirementRow:
    If Err.Number = 5991 Then
        Resume Continue_Next_Table
    Else
        MsgBox Err.Description
    End If
End Sub

Sub ApplyStyleToTestRequirementRefs()
    Dim tbl As Table, rw As Row, rng As Range, cel As Cell
    Dim strtext As String, blinreqrows As Boolean, lngwidth As Long
On Error GoTo Err_ApplyStyleToTestRequirementRefs

    ' loop through all tables and check if test case table - Purpose text and 2 columns
    If Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr = "STD" Then
        For Each tbl In ActiveDocument.Tables
            Set rw = tbl.Rows(1)
            If rw.Cells.Count = 2 And GetCellText(rw.Cells(1)) = Const_TABLE_PURPOSE_TEXT Then
                blinreqrows = False
                For Each rw In tbl.Rows
                    strtext = GetCellText(rw.Cells(1))
                    If strtext <> vbNullString Then blinreqrows = False
                    
                    If strtext = Const_TABLE_REQUIREMENTS_TEXT Then
                        blinreqrows = True
                    End If
                    
                    If blinreqrows = True Then
                        rw.Cells(rw.Cells.Count - 1).Range.Style = "DSTTrcRef"
                    End If
                Next rw
            End If
Continue_Next_Table:
        Next tbl
    Else
        MsgBox "This function only works on STDs", vbExclamation
    End If
    
Exit_ApplyStyleToTestRequirementRefs:
    Exit Sub
    
Err_ApplyStyleToTestRequirementRefs:
    If Err.Number = 5991 Then
        Resume Continue_Next_Table
    Else
        MsgBox Err.Description
    End If
End Sub

Sub HyperlinksFix()
    Dim hlnk As Hyperlink, rng As Range, tbl As Table, straddress As String, strsubaddress As String, hlnktemp As Hyperlink
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    If ValidateDocExtRefsTable(ActiveDocument, tbl) Then
        For Each hlnk In tbl.Range.Hyperlinks
            Set rng = hlnk.Range
            straddress = hlnk.Address
            straddress = fso.GetFileName(straddress)
            strsubaddress = hlnk.SubAddress
            hlnk.Delete
            Set hlnktemp = rng.Hyperlinks.Add(rng, straddress, strsubaddress)
            Call FormatXRefHyperlink(hlnktemp)
        Next hlnk
    End If
    
End Sub

Sub HyperlinksRenameAddress(ByVal stroldaddress As String, ByVal strnewaddress As String)
    Dim hlnk As Hyperlink, rng As Range, tbl As Table, straddress As String, strsubaddress As String, hlnktemp As Hyperlink
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    If ValidateDocExtRefsTable(ActiveDocument, tbl) Then
        For Each hlnk In tbl.Range.Hyperlinks
            Set rng = hlnk.Range
            straddress = hlnk.Address
            If straddress Like "*" & stroldaddress & "*" Then
                straddress = Replace(straddress, stroldaddress, strnewaddress)
            End If
            straddress = fso.GetFileName(straddress)
            strsubaddress = hlnk.SubAddress
            hlnk.Delete
            Set hlnktemp = rng.Hyperlinks.Add(rng, straddress, strsubaddress)
            Call FormatXRefHyperlink(hlnktemp)
        Next hlnk
    End If
    
End Sub

Sub Oryx_STD_Fix_Bookmarks()
    Dim rng As Range, strbookmark As String, idx As Integer
    Dim intfilenum As Integer, strline As String, varvalues As Variant, strmessage As String, cel As Cell
    
    '==================================================================================================================================
    ' Purpose: Reads input from a test names CSV file and updates the current headings and bookmarks accordingly. Also clears
    '          the test implementation reference cell.
    ' File format: 1st column = test set/case heading
    '              2nd column = current bookmark name
    '              3rd column = new bookmark name
    '==================================================================================================================================
    
    intfilenum = FreeFile
    Open "C:\Users\Anton.Coetzee\Documents\Oryx\std_a6_interfaces.csv" For Input As #intfilenum
    
    Do While Not EOF(intfilenum)
        Line Input #intfilenum, strline
        strline = Trim(strline)
        If strline <> vbNullString Then ' skip blank lines
            varvalues = Split(strline, ",")
            ' search for heading in current document
            For idx = 1 To ActiveDocument.ListParagraphs.Count
                Set rng = ActiveDocument.ListParagraphs(idx).Range
                If rng.ListFormat.ListType = wdListOutlineNumbering Then ' only look at headings
                    ' exclude the paragraph marker
                    rng.MoveEnd wdCharacter, -1
                    If varvalues(0) = Trim(rng.Text) Then ' is this the heading we're looking for
                        If rng.Bookmarks.Count = 1 Then
                            If Not RenameBookmark(ActiveDocument, varvalues(1), varvalues(2), strmessage) Then
                                MsgBox strmessage, vbCritical
                            End If
                        Else
                            rng.Text = varvalues(2)
                            If Not AddBookmark(rng, varvalues(2), True, , strmessage) Then
                                MsgBox strmessage, vbCritical
                            End If
                        End If
                        
                        ' assume the table starts directly below the heading and delete the implementation reference cell content
                        Set rng = rng.Paragraphs(1).Range.Next
                        For Each cel In rng.Tables(1).Range.Cells
                            If StrComp(GetCellText(cel), Const_TABLE_IMP_REF_TEXT, vbTextCompare) = 0 Then
                                cel.Next.Range.Text = vbNullString ' delete content
                                Exit For
                            End If
                        Next cel
                    Exit For
                    End If
                End If
            Next idx
        End If
    Loop

    Close #intfilenum
    
End Sub

Sub Oryx_STD_Clear_Implementation_Hyperlinks()
    Dim tbl As Table, cel As Cell
    
    '==================================================================================================================================
    ' Purpose: Clears the test implementation reference cells in the active document.
    '==================================================================================================================================
    For Each tbl In ActiveDocument.Tables
        For Each cel In tbl.Range.Cells
            If StrComp(GetCellText(cel), Const_TABLE_IMP_REF_TEXT, vbTextCompare) = 0 Then
                cel.Next.Range.Text = vbNullString ' delete content
                Exit For
            End If
        Next cel
    Next tbl
    
End Sub

Sub Oryx_STD_Fix_Scripts_Rename()
    Dim fso As FileSystemObject, strstartfolder As String
    Dim intfilenum As Integer, strline As String, varvalues As Variant, strtemp As String, strmessage As String
    Dim fil As File, fold As Folder, strext As String
    
    '==================================================================================================================================
    ' Purpose: Reads input from a script names CSV file and updates the test scripts, test group and C# project file in a given folder.
    ' File format: 1st column = current script name
    '              2nd column = new script name
    '==================================================================================================================================
    
    Set fso = New FileSystemObject
    
    ' read in test names file
    intfilenum = FreeFile
    Open "C:\Users\Anton.Coetzee\Documents\Oryx\std_a2_modes.scripts.csv" For Input As #intfilenum
    strstartfolder = "C:\projects\oryx\cms\rmu\test\fast\scripts\std_rmu_a2_modes"
    
    Do While Not EOF(intfilenum)
        Line Input #intfilenum, strline
        strline = Trim(strline)
        If strline <> vbNullString Then ' skip blank lines
            varvalues = Split(strline, ",")
            ' search through all files beneath the given location
            Set fold = fso.GetFolder(strstartfolder)
            For Each fil In fold.Files
                strmessage = vbNullString
                strext = fso.GetExtensionName(fil.Name)
                Select Case strext
                    Case "csproj", "cs", "tgp", "xml"
                        ' 1st pass on file references
                        If Not FileSearchReplace(fil.Path, varvalues(0), varvalues(1), strtemp) Then
                            strmessage = " (1st pass): " & strtemp
                        End If
                        
                        ' 2nd pass to cover methods
                        If strext = "cs" Or strext = "xml" Then
                            If Not FileSearchReplace(fil.Path, fso.GetBaseName(varvalues(0)), fso.GetBaseName(varvalues(1)), strtemp) Then
                                strmessage = " (2nd pass): " & strtemp
                            End If
                        End If
                    Case Else
                        ' do nothing
                End Select
                
                If strmessage <> vbNullString Then
                    Debug.Print "Renaming " & varvalues(0) & " to " & varvalues(1) & " in " & fil.Name & " failed " & strmessage
                End If
            Next fil
        End If
    Loop

    Close #intfilenum
    
End Sub

Sub FixFIMBrackets()
    Dim idx As Integer, bkm As Bookmark, rng As Range, strbkname As String
    
    For idx = 1 To ActiveDocument.Bookmarks.Count
        Set bkm = ActiveDocument.Bookmarks(idx)
        If Dst.BookmarkConfig.PrefixFromName(bkm.Name) = "dfslit" Then
            strbkname = bkm.Name
            Set rng = bkm.Range
            If Left(rng, 2) = "<<" Then
                rng.Text = Chr(171) & Right(rng, Len(rng) - 2)
            End If
            If Right(rng.Text, 2) = ">>" Then
                rng.Text = Left(rng, Len(rng) - 2) & Chr(187)
            End If
            Set bkm = ActiveDocument.Bookmarks.Add(strbkname, rng)
        End If
    Next idx
    
End Sub

'==========================================================================================================
' Loops through all paragraphs in the active document and tries to detect a Table or Figure caption. If a
' valid caption is found, the paragraph style is changed to the appropriate DST style
'==========================================================================================================
Sub ApplyTableFigureCaptions()
    Dim par As Paragraph, rng1 As Range, rng2 As Range, strstyle As String
    
    For Each par In ActiveDocument.Paragraphs
        If par.Range.Words.Count > 4 Then
            Set rng1 = par.Range.Words(1)
            Set rng2 = par.Range.Words(2)
            If Trim(rng1) = "Table" Then
                strstyle = "DSTCaptionTable"
            ElseIf Trim(rng1) = "Figure" Then
                strstyle = "DSTCaptionFigure"
            Else
                strstyle = vbNullString
            End If
            
            If strstyle <> vbNullString Then
                ' check if the first two words resemble a table/figure caption
                If rng1.Fields.Count = 0 And rng1.Font.Bold And IsNumeric(Trim(rng2)) Then
                    par.Style = strstyle
                End If
            End If
        End If
    Next par
    
End Sub

'==========================================================================================================
' Loops through all hyperlinks in the selected table and changes the hyperlink address to the file's name
'==========================================================================================================
Sub ConvertHyperlinksToBaseName()
    Dim hlnk As Hyperlink, fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    For Each hlnk In Selection.Tables(1).Range.Hyperlinks
        hlnk.Address = fso.GetFileName(hlnk.Address)
    Next hlnk
    
End Sub

Private Sub GetFIMBookmarks(ByRef varfims As Variant, ByRef dicfims As Scripting.Dictionary, ByRef frm As Object)
    Dim dicbookmarks As Scripting.Dictionary, vartemp As Variant, bkm As cDocBookmark, strtype As String
    Dim blopen As Boolean, objdoc As Document, docinfo As cDocInfo, fso As FileSystemObject
        
    Set fso = New FileSystemObject
    Set dicbookmarks = New Scripting.Dictionary
    For Each vartemp In varfims
        ' open document
        blopen = IsDocumentOpen(vartemp, objdoc)
        If Not objdoc Is Nothing Then
            frm.UpdateProgressText "Extracting bookmarks from '" & fso.GetFileName(vartemp) & "' ..."
            Set docinfo = Dst.Document(objdoc.Fullname)
            ' extract SRS/DFS literals, variables and variable descriptions - skip external bookmarks
            For Each bkm In docinfo.Bookmarks.Internal
                strtype = Dst.BookmarkConfig.PrefixFromName(bkm.Name)
                Select Case strtype
                    Case "srslit", "dfslit", "srsvar", "dfsvar", "srsvardesc", "dfsvardesc"
                        ' add FIM variables to list
                        dicbookmarks.Add bkm.Name, bkm.Name
                    
                    Case Else
                        ' skip rest
                End Select
            Next bkm
            
            ' close document
            If Not blopen Then objdoc.Close wdDoNotSaveChanges
            
            ' add list to dictionary
            dicfims.Add vartemp, dicbookmarks
        Else
            frm.UpdateProgressText "   ERROR: Could not open '" & vartemp & "'."
        End If
    Next vartemp
    
End Sub

Private Sub GetBookmarksInRange(ByRef vardocs As Variant, ByRef dicdocbkmarks As Scripting.Dictionary, ByVal strheading As String, Optional ByRef frm As Object)
    Dim dicbookmarks As Scripting.Dictionary, vartemp As Variant, bkmark As Bookmark, strtype As String
    Dim blopen As Boolean, objdoc As Document, rng As Range, docinfo As cDocInfo, fso As FileSystemObject
        
    Set fso = New FileSystemObject
    
    Set dicbookmarks = New Scripting.Dictionary
    For Each vartemp In vardocs
        ' open document
        blopen = IsDocumentOpen(vartemp, objdoc)
        If Not objdoc Is Nothing Then
            If Not frm Is Nothing Then frm.UpdateProgressText "Extracting bookmarks from '" & fso.GetFileName(vartemp) & "' ..."
            Set docinfo = Dst.Document(objdoc.Fullname)
            Set rng = GetHeadingRangeExtendedFromText(objdoc.Range, strheading)
            If Not rng Is Nothing Then
                For Each bkmark In rng.Bookmarks
                    If Not docinfo.Bookmarks.IsExternal(bkmark.Name) Then
                        strtype = Dst.BookmarkConfig.PrefixFromName(bkmark.Name)
                        Select Case strtype
                            Case "tabstr"
                                dicbookmarks.Add bkmark.Name, bkmark.Name
                            
                            Case Else
                                ' skip rest
                        End Select
                    End If
                Next bkmark
            End If
            
            ' close document
            If Not blopen Then objdoc.Close wdDoNotSaveChanges
            
            ' add list to dictionary
            If dicbookmarks.Count > 0 Then dicdocbkmarks.Add vartemp, dicbookmarks
        Else
            If Not frm Is Nothing Then frm.UpdateProgressText "   ERROR: Could not open '" & vartemp & "'."
        End If
    Next vartemp
        
End Sub

Private Sub FixDocReferences(ByRef vardocs As Variant, ByRef dicotherdocs As Scripting.Dictionary, ByRef frm As Object)
    Dim blopen As Boolean, objdoc As Document, rng As Range, fld As Field
    Dim vartemp As Variant, fso As FileSystemObject, strbookmark As String, strdocname As String, strmessage As String
    Dim idx As Integer
    
    Set fso = New FileSystemObject
    
    For Each vartemp In vardocs
        ' open document
        blopen = IsDocumentOpen(vartemp, objdoc)
        If Not objdoc Is Nothing Then
            frm.UpdateProgressText "Adding external references to '" & fso.GetFileName(vartemp) & "' ..."
            ' loop through all fields and find REF type fields
            For Each rng In objdoc.StoryRanges
                For Each fld In rng.Fields
                    If fld.Type = wdFieldRef Then
                        ' add new external reference if field is broken
                        If InStr(1, fld.Result, Const_DOC_ERROR_STRING & " Reference source not found.") = 1 Then
                            ' make sure bold formatting due to error is removed from field
                            fld.Result.Font.Bold = False
                            
                            ' get the referenced bookmark
                            strbookmark = GetBookmarkNameFromFieldCode(fld.Code)
                            
                            ' figure out which document now contains this bookmark
                            strdocname = vbNullString
                            For idx = 0 To dicotherdocs.Count - 1
                                If dicotherdocs(dicotherdocs.Keys(idx)).Exists(strbookmark) Then
                                    strdocname = dicotherdocs.Keys(idx)
                                    Exit For
                                End If
                            Next idx
                            
                            If strdocname <> vbNullString Then
                                If Not objdoc.Bookmarks.Exists(strbookmark) Then
                                    If AddToExternalReferences(objdoc, strbookmark, "Run 'Update External References' function", strdocname, strmessage) Then
                                        frm.UpdateProgressText "   INFO: Added '" & strbookmark & "'"
                                    Else
                                        frm.UpdateProgressText "   ERROR: " & strmessage
                                    End If
                                End If
                            Else
                                frm.UpdateProgressText "   ERROR: Bookmark '" & strbookmark & "' not found in any of the documents."
                            End If
                        End If
                    End If
                Next fld
            Next rng
            
            ' close document
            If Not blopen Then objdoc.Close wdSaveChanges
        Else
            frm.UpdateProgressText "   ERROR: Could not open '" & vartemp & "'."
        End If
    Next vartemp
    
End Sub

Sub MovedBookmarksFixHyperLinks(ByRef objdoc As Document, ByRef frm As Object, ByRef dicdestdocs As Scripting.Dictionary)
    Dim hlnk As Hyperlink, idx As Integer, strnewaddress As String
    
    frm.UpdateProgressText "Checking for hyperlinks to update in '" & objdoc.Name & "' ..."
    
    For Each hlnk In objdoc.Hyperlinks
        ' if sub-address is specified, check if bookmark now exists in one of the new FIMs
        If hlnk.SubAddress <> vbNullString Then
            For idx = 0 To dicdestdocs.Count - 1
                If dicdestdocs(dicdestdocs.Keys(idx)).Exists(hlnk.SubAddress) Then
                    strnewaddress = GetRelativePath(objdoc.Path, dicdestdocs.Keys(idx))
                    If strnewaddress <> hlnk.Address Then
                        hlnk.Address = strnewaddress
                        frm.UpdateProgressText "   INFO: Updated address for '" & hlnk.SubAddress & "' to '" & hlnk.Address & "'"
                    End If
                    Exit For
                End If
            Next idx
        End If
    Next hlnk
    
End Sub

Sub GetBookmarklistInRange()
    Dim vardocs As Variant, dicdocbkmarks As Scripting.Dictionary, dicbkmarks As Scripting.Dictionary, idx As Integer, idx2 As Integer, strbookname As String

    Set dicdocbkmarks = New Scripting.Dictionary
    vardocs = Array(ActiveDocument.Fullname)
    Call GetBookmarksInRange(vardocs, dicdocbkmarks, """" & "BNR Parameters Default Setup" & """")
    For idx = 0 To dicdocbkmarks.Count - 1
        Set dicbkmarks = dicdocbkmarks.Items(idx)
        For idx2 = 0 To dicbkmarks.Count - 1
            Debug.Print dicbkmarks.Items(idx2)
        Next idx2
    Next idx

End Sub
Attribute VB_Name = "basRibbon"
Option Explicit

Public DSTRibbon As IRibbonUI

Public BlDSTDebugMode As Boolean
Public BlDSTDebugTiming As Boolean

Public Const Const_URL_HELP_FILE_ROOT As String = "http://eng-confluence/DstHelp"

Public Type SelectionType
    Story As WdStoryType
    NumBookmarks As Long
    BookMarkName As String
    NumFields As Long
    FieldIndex As Long
End Type
Public CurrentSelection As SelectionType

' Stores the state of the Small/Normal font size and paragraph spacing settings
Private BlTableFontSmall As Boolean
Private BlTableParSpacingZero As Boolean

#If VBA7 Then
    Declare PtrSafe Function GetKeyState Lib "USER32" (ByVal vKey As Long) As Integer
#Else
    Declare Function GetKeyState Lib "USER32" (ByVal vKey As Long) As Integer
#End If

Sub Onload(Ribbon As IRibbonUI)

    ' Create a ribbon instance for use in this project
    Set DSTRibbon = Ribbon
    
    ' Store pointer to ribbon in case we lose the reference to it, e.g. when there's an unhandled error
    Call SaveDSTRibbonPointer
       
End Sub

Sub ReComputeRibbon(ByVal blfullreset As Boolean)
On Error GoTo Err_ReComputeRibbon
    
    If BlDSTDebugMode Then Debug.Print "Ribbon re-computed at " & Now()

    ' re-compute the current selection info
    CurrentSelection.NumBookmarks = ActiveDocument.ActiveWindow.Selection.Bookmarks.Count
    If CurrentSelection.NumBookmarks > 0 Then CurrentSelection.BookMarkName = ActiveDocument.ActiveWindow.Selection.Bookmarks(1).Name
    ' NOTE: field info will be re-computed only when the the selection changes to avoid Word instability
    CurrentSelection.NumFields = 0
    CurrentSelection.FieldIndex = 0
    CurrentSelection.Story = 0
    
    ' re-compute the ribbon for a full reset
    If blfullreset Then
        ' reset local data
        BlTableFontSmall = False
        BlTableParSpacingZero = False
        Call InvalidateRibbon
    End If
    
    Call ScreenUpdateOn
    
Exit_ReComputeRibbon:
    Exit Sub

Err_ReComputeRibbon:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure ReComputeRibbon, line " & Erl & "."
    Resume Exit_ReComputeRibbon
End Sub

Private Sub InvalidateRibbon(Optional id As String = vbNullString)
On Error GoTo Err_InvalidateRibbon

    ' check if we need to restore the ribbon, e.g. an unhandled error will cause references to be set to 0
    If DSTRibbon Is Nothing Then
        Call RestoreDSTRibbonObject
    End If
    
    ' Invalidate will force the UI to reload and thereby ask for current states
    If id <> vbNullString Then
        DSTRibbon.InvalidateControl id ' Note: This does not work reliably
    Else
        DSTRibbon.Invalidate
    End If

Exit_InvalidateRibbon:
    Exit Sub

Err_InvalidateRibbon:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure InvalidateRibbon, line " & Erl & "." & _
           "Due to a design flaw in the architecture of the MS ribbon UI you have to close all instances " & _
           "of Word to restore the DST Ribbon behaviour." & vbNewLine & vbNewLine, vbExclamation + vbOKOnly
    Resume Exit_InvalidateRibbon
End Sub

Sub SelectionHasChanged(ByRef objdoc As Document)
    Dim slct As Selection
    
    If BlDSTDebugMode Then Debug.Print "SelectionHasChanged processing started at " & Timer()
    
    ' update the info for the current selection
    Set slct = ActiveDocument.ActiveWindow.Selection
    CurrentSelection.NumBookmarks = slct.Bookmarks.Count
    If CurrentSelection.NumBookmarks > 0 Then CurrentSelection.BookMarkName = slct.Bookmarks(1).Name
    
    If BlDSTDebugMode Then Debug.Print "SelectionHasChanged processing starting fields at " & Timer()
     
    ' only do this check when not selecting text - display performance and quality is degraded when doing the check whilst selecting text using the keyboard
    If Not GetKeyState(vbKeyShift) < 0 Then
        Call RevertOrphanedMultiLevelListStyle(slct.Range)
    End If
    
    Call RangeHasFields(slct.Range, CurrentSelection)
        
    If BlDSTDebugMode Then Debug.Print "SelectionHasChanged processing invalidating ribbon at " & Timer()
    
    ' re-compute these controls as they depend on the current selection
    InvalidateRibbon "BtnDelBkmark"
    InvalidateRibbon "TglBtnKeepWithNext"
    InvalidateRibbon "TglBtnPageBreakBefore"
    InvalidateRibbon "BtnTable"
    InvalidateRibbon "BtnFormatTestTable"
    InvalidateRibbon "TglBtnShowFieldCode"
    InvalidateRibbon "TglBtnLockField"
    InvalidateRibbon "BtnDecreaseListIndent"
    InvalidateRibbon "BtnIncreaseListIndent"
    InvalidateRibbon "BtnUpdateLockedField"
    InvalidateRibbon "BtnOpenReference"
    InvalidateRibbon "BtnManagePicture"
    InvalidateRibbon "BtnInsertEquation"
    InvalidateRibbon "BtnInsertNote"
    InvalidateRibbon "BtnUpdateTrc"
    InvalidateRibbon "BtnUpdateTrcSummaryMetrics"
    InvalidateRibbon "EBGotoPosition"
    InvalidateRibbon "GlryAutoAdd"
    InvalidateRibbon "GlryAutoAddAll"
    InvalidateRibbon "BtnManageLandscape"
    
    If BlDSTDebugMode Then Debug.Print "SelectionHasChanged processing finished at " & Timer()
    
End Sub

Sub GetVisible(control As IRibbonControl, ByRef returnedVal)
    
    If Not ProtectedViewActive() And Application.Documents.Count > 0 Then ' only show DST tabs if there are open documents
        If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
            Select Case control.id
                Case Is = "TabDST", "TabDSTAdmin"
                    If ActiveDocument.Fullname <> vbNullString Then ' some windows e.g. compare revisions don't have document names
                        If control.id = "TabDSTAdmin" Then
                            returnedVal = IsDstAdministrator
                        Else
                            returnedVal = True
                        End If
                    End If
                    
                Case Else
                    returnedVal = True
                    
            End Select
        End If
    End If
    
End Sub

'Callback for Button onAction
Sub BtnMacro(ByVal control As IRibbonControl)
    
    Call ScreenUpdateOn
    
    Select Case control.id
        Case Is = "BtnDSTVersion"
            'ACZ ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpMacros"
            ActiveDocument.FollowHyperlink Application.StartupPath & "\docs\usrm_dst.docx"
        
        Case Is = "BtnResetDST"
            Call FullDSTReset
                       
        Case Is = "BtnDocStatus"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionDocStatus)
            InvalidateRibbon control.id ' recompute the button
            
        Case Is = "BtnDocCheck"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionCheckDocument)
        
        Case Is = "BtnDocInfo"
            Call OpenUserForm("frmDocInfo", ActiveDocument)
        
        Case Is = "BtnDocCreateNew"
            Call OpenUserForm("frmDocNew", ActiveDocument)
            
        Case Is = "BtnDocMakeBackup"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionMakeBackup)
            
        Case Is = "BtnExportToPdf"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionExportPdf)
            
        Case Is = "BtnSyncDocumentTitles"
            Call CheckDocTitle(ActiveDocument, True)
        
        Case Is = "BtnUpdateAbbreviations"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionUpdateAbbreviations)
        
        Case Is = "BtnRemoveHelpText"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionRemoveHelpText)
            
        Case Is = "BtnInsertNumberedList"
            InsertMultiLevelList ActiveDocument.ActiveWindow.Selection.Range, Const_DOC_NUMBERED_LIST_STYLE
            
        Case Is = "BtnInsertBulletedList"
            InsertMultiLevelList ActiveDocument.ActiveWindow.Selection.Range, Const_DOC_BULLET_LIST_STYLE
                      
        Case Is = "BtnDecreaseListIndent"
            AdjustListIndent ActiveDocument.ActiveWindow.Selection.Range, -1
            InvalidateRibbon "BtnDecreaseListIndent"
            InvalidateRibbon "BtnIncreaseListIndent"
            
        Case Is = "BtnIncreaseListIndent"
            AdjustListIndent ActiveDocument.ActiveWindow.Selection.Range, 1
            InvalidateRibbon "BtnDecreaseListIndent"
            InvalidateRibbon "BtnIncreaseListIndent"
        
        Case Is = "BtnFixListParagraphs"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionFixListParagraphs)
            
        Case Is = "BtnDocPrepareEdit"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionPrepareEdit)
            
        Case Is = "BtnShowDocument"
            Call ForceDocumentVisible(ActiveDocument)
        
        Case Is = "BtnShowStylesUsage"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionDocStylesUsage)
        
        Case Is = "BtnImportStyles"
            Call OpenUserForm("frmDocNew", ActiveDocument, , , "Styles")
            
        Case Is = "BtnOpenStylesPane"
            Application.TaskPanes(wdTaskPaneFormatting).Visible = True
            
        Case Is = "BtnAddBkmarkManual"
            Call OpenUserForm("frmBookmarkMgmt", ActiveDocument)
            
        Case Is = "BtnDelBkmark"
            If DeleteBookmark(ActiveDocument.ActiveWindow.Selection.Range) = True Then
                ' unload bookmark management form if it was open to force a reload of its data
                Call UnloadUserForm(, "frmBookmarkMgmt", ActiveDocument.Fullname)
                ' re-compute the button label
                InvalidateRibbon control.id
            End If
            
        Case Is = "BtnInsertBkmRef"
            Call OpenUserForm("frmBkmRefsMgmt", ActiveDocument)
            
        Case Is = "BtnInsertDocRef"
            Call OpenUserForm("frmDocRefsMgmt", ActiveDocument)
            
        Case Is = "BtnOpenReference"
            Call OpenReferenceInWord
            
        Case Is = "BtnUpdateFields"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionUpdateAllFields)
            
        Case Is = "BtnUpdateLockedField"
            If CurrentSelection.NumFields > 0 Then
                Call UpdateLockedField(ActiveDocument, CurrentSelection)
            End If
            
        Case Is = "BtnUpdateExtRefs"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionUpdateExtReferences)
            
        Case Is = "BtnUpdateTrc"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionUpdateTrc)

        Case Is = "BtnUpdateTrcSummaryMetrics"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionUpdateTrcSummaryMetrics)
        
        Case Is = "BtnDocList"
            Call OpenUserForm("frmDocList", ActiveDocument)
                    
        Case Is = "BtnTable"
            If IsRangeInTable(ActiveDocument.ActiveWindow.Selection.Range) Then
                Call FormatExistingTable(ActiveDocument, BlTableFontSmall, BlTableParSpacingZero)
            Else
                Call CreateTableTemplate(ActiveDocument.ActiveWindow.Selection.Range, , , Const_INSTR_START & " Insert caption here " & Const_INSTR_END, , BlTableFontSmall, BlTableParSpacingZero, True)
            End If
            
        Case Is = "BtnManageLandscape"
            If IsRangeLandscape(ActiveDocument.ActiveWindow.Selection.Range) Then
                Call RemoveLandscapeSection(ActiveDocument.ActiveWindow.Selection.Range)
            Else
                Call InsertLandscapeSection(ActiveDocument.ActiveWindow.Selection.Range)
            End If
            
        Case Is = "BtnSTDTools"
            Call OpenUserForm("frmSTDMgmt", ActiveDocument)
            
        Case Is = "BtnFormatTestTable"
            Call FormatTestTable(ActiveDocument.ActiveWindow.Selection.Range)
            
        Case Is = "BtnSTRTools"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionUpdateSTRResults)
            
        Case Is = "BtnInsertTBD"
            Call InsertTBDField
            
        Case Is = "BtnInsertEquation"
            Call InsertEquation(ActiveDocument.ActiveWindow.Selection.Range)
            
        Case Is = "BtnInsertNote"
            Call InsertNote(ActiveDocument.ActiveWindow.Selection.Range)
                        
        Case Is = "BtnFormatSnippetOrPath"
            ActiveDocument.ActiveWindow.Selection.Range.Style = "DSTSnippetOrPath"
                        
        Case Is = "BtnManagePicture"
            With ActiveDocument.ActiveWindow.Selection.Range
                If .InlineShapes.Count = 0 Then
                    Call InsertPicture(ActiveDocument.ActiveWindow.Selection.Range)
                ElseIf IsInlineShape(.InlineShapes(1)) Then
                    Call UpdateInlineShape(.InlineShapes(1))
                End If
            End With
            
        Case Is = "BtnFormatParagraph3Pt"
            ActiveDocument.ActiveWindow.Selection.ParagraphFormat.SpaceBefore = 3
            ActiveDocument.ActiveWindow.Selection.ParagraphFormat.SpaceAfter = 3
            
        Case Is = "BtnTransferToNewTemplate"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionTransferToNewTemplate)
            
        Case Is = "BtnGenText"
            Call ExportMacroProjectContents
            
        Case Is = "ShowVBEditor"
            ShowVisualBasicEditor = True
            
        Case Is = "BtnParagraphFormatting"
            Dialogs(wdDialogFormatParagraph).Show
            
        Case Else
        
    End Select

End Sub

Sub galleryOnAction(control As IRibbonControl, selectedID As String, selectedIndex As Integer)
  
    Call ScreenUpdateOn
    
    Select Case control.id
        Case "GlryAutoAddAll"
            Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionAutoAddBookmarksAll, , GetAutoBookmarkList.Items(selectedIndex))
            
        Case "GlryAutoAdd"
            If AddBookmarkAuto(ActiveDocument.ActiveWindow.Selection.Range, GetAutoBookmarkList.Items(selectedIndex)) <> vbNullString Then
                ' unload bookmark management form if it was open to force a reload of its data
                Call UnloadUserForm(, "frmBookmarkMgmt", ActiveDocument.Fullname)
            End If
        Case Else
        
    End Select
    
End Sub

'Callback for Toggle onAction
Sub ToggleonAction(control As IRibbonControl, pressed As Boolean)
        
    Call ScreenUpdateOn
    
    Select Case control.id
        Case Is = "TglBtnFontSize"
            BlTableFontSmall = pressed
            
        Case Is = "TglBtnParSpacing"
            BlTableParSpacingZero = pressed
            
        Case Is = "TglBtnShowFieldCode"
            If CurrentSelection.NumFields = 1 Then
                ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).Select ' need to select the field else fields in last cells of rows don't work so well
                ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).ShowCodes = Not ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).ShowCodes
            End If
            
        Case Is = "TglBtnLockField"
            If CurrentSelection.NumFields = 1 Then
                ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).Locked = pressed
            End If
            ' re-compute the Update Locked Field button
            InvalidateRibbon "BtnUpdateLockedField"
        
        Case Is = "TglBtnKeepWithNext"
            ActiveDocument.ActiveWindow.Selection.ParagraphFormat.KeepWithNext = pressed
        
        Case Is = "TglBtnPageBreakBefore"
            ActiveDocument.ActiveWindow.Selection.ParagraphFormat.PageBreakBefore = pressed
        
        Case Is = "TglBtnDebugMode"
            BlDSTDebugMode = pressed
        
        Case Is = "TglBtnDebugTiming"
            BlDSTDebugTiming = pressed
        
        Case Else
            ' do nothing
        
    End Select
    
    'Force the ribbon to redefine the control with correct image and label
    InvalidateRibbon control.id
    
End Sub

'Callback for Enabling controls
Sub GetEnabled(control As IRibbonControl, ByRef enabled)
    Dim strdoctype As String
    
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        strdoctype = Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr
        
        Select Case control.id
            Case "BtnSyncDocumentTitles"
                enabled = (strdoctype <> "NDA")
                
            Case "BtnDocPrepareEdit"
                enabled = (strdoctype <> "NDA")
            
            Case "GlryAutoAdd"
                If CurrentSelection.NumBookmarks = 0 And CurrentSelection.NumFields = 0 And GetAutoBookmarkList.Count > 0 Then enabled = True
            
            Case "GlryAutoAddAll"
                enabled = (GetAutoBookmarkList.Count > 0)
                
            Case Is = "BtnDelBkmark"
                If CurrentSelection.NumBookmarks > 0 Then enabled = True
            
            Case Is = "BtnDecreaseListIndent"
                enabled = IsMultiLevelList(ActiveDocument.ActiveWindow.Selection.Range) And ActiveDocument.ActiveWindow.Selection.Range.ListFormat.ListLevelNumber > 1
            
            Case Is = "BtnIncreaseListIndent"
                enabled = IsMultiLevelList(ActiveDocument.ActiveWindow.Selection.Range) And ActiveDocument.ActiveWindow.Selection.Range.ListFormat.ListLevelNumber < 9
        
            Case Is = "TglBtnShowFieldCode"
                enabled = (CurrentSelection.NumFields = 1)
            
            Case Is = "TglBtnLockField"
                enabled = (CurrentSelection.NumFields = 1)
                
            Case Is = "BtnUpdateLockedField"
                If CurrentSelection.NumFields = 1 Then
                    enabled = ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).Locked
                End If
                
            Case Is = "BtnOpenReference"
                enabled = (CurrentSelection.NumFields = 1)
                
            Case Is = "BtnInsertEquation"
                With ActiveDocument.ActiveWindow.Selection
                    enabled = IsBlankLine(.Range) And Not IsRangeInTable(.Range)
                End With
            
            Case Is = "BtnInsertNote"
                With ActiveDocument.ActiveWindow.Selection
                    enabled = IsBlankLine(.Range)
                End With
            
            Case Is = "BtnUpdateTrc"
                enabled = (ValidateDocTraceabilityTables(ActiveDocument) = vbNullString)
                
            Case Is = "BtnUpdateTrcSummaryMetrics"
                enabled = (ValidateDocTraceabilityTables(ActiveDocument) = vbNullString)
            
            Case Is = "BtnSTDTools"
                enabled = (strdoctype = "STD")
            
            Case Is = "BtnFormatTestTable"
                If strdoctype = "STD" Then
                    enabled = IsTestTable(ActiveDocument.ActiveWindow.Selection.Range)
                End If
                
            Case Is = "BtnSTRTools"
                enabled = (strdoctype = "STR")
                
            Case Is = "BtnGenText"
                enabled = (Application.MacroContainer.Path = ActiveDocument.Path)
            
            Case Is = "BtnManagePicture"
                With ActiveDocument.ActiveWindow.Selection
                    If .Range.InlineShapes.Count = 0 Then
                        enabled = IsBlankLine(.Range)
                    Else
                        enabled = True
                    End If
                    enabled = enabled And Not IsRangeInTable(.Range)
                End With
                
            Case Is = "BtnTable"
                With ActiveDocument.ActiveWindow.Selection
                    enabled = IsRangeInTable(.Range) Or IsBlankLine(.Range)
                End With
                
            Case Is = "BtnManageLandscape"
                With ActiveDocument.ActiveWindow.Selection
                    If Not .Information(wdInCommentPane) And Not .Information(wdInFootnote) Then
                        enabled = (IsBlankLine(.Range) And Not IsRangeInTable(.Range)) Or IsRangeLandscape(.Range)
                    End If
                End With
                
            Case Is = "BtnDSTAdmin"
                enabled = IsDstAdministrator
                
            Case Else
            
        End Select
    End If
    
End Sub

'Callback for getImage
Sub GetImage(control As IRibbonControl, ByRef returnedVal)
    
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        Select Case control.id
            Case Is = "TglBtnLockField"
                returnedVal = "FileLinksToFiles"
                If CurrentSelection.NumFields = 1 Then
                    If ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).Locked Then
                        returnedVal = "TableUnlinkExternalData"
                    End If
                End If
                
            Case Is = "BtnDocStatus"
                returnedVal = "AcceptInvitation"
                If CheckDocumentStatusQuick(ActiveDocument) <> vbNullString Then
                    returnedVal = "Risks"
                End If
        
            Case Is = "BtnManagePicture"
                With ActiveDocument.ActiveWindow.Selection.Range
                    If .InlineShapes.Count = 0 Then
                        returnedVal = "PicturePositionGallery"
                    Else
                        returnedVal = "PictureReset"
                    End If
                End With
        
            Case Is = "BtnManageLandscape"
                If Not IsRangeLandscape(ActiveDocument.ActiveWindow.Selection.Range) Then
                    returnedVal = "PageOrientationGallery"
                Else
                    returnedVal = "ReviewDeleteComment"
                End If
                
            Case Is = "TglBtnFontSize"
                If BlTableFontSmall Then
                    returnedVal = "FontSizeDecrease"
                Else
                    returnedVal = "FontSizeIncrease"
                End If
            
            Case Is = "TglBtnParSpacing"
                If BlTableParSpacingZero Then
                    returnedVal = "ParagraphSpacingDecrease"
                Else
                    returnedVal = "ParagraphSpacingIncrease"
                End If
            
            Case Is = "BtnTable"
                returnedVal = "CreateTableInDesignView"
                If Not IsRangeInTable(ActiveDocument.ActiveWindow.Selection.Range) Then
                    returnedVal = "TableDrawTable"
                End If
            
            Case Else
            
        End Select
    End If
    
End Sub

'Callback for ComboBox onChange
Sub CBMacro(control As IRibbonControl, Text As String)
    
    Call ScreenUpdateOn
    
    Select Case control.id
        Case Else
    
    End Select
  
End Sub

'Callback for ListBox onDropdown
Sub DDMacro(ByVal control As IRibbonControl, ByVal id As String, ByVal Index As Integer)
    
    Call ScreenUpdateOn
    
    Select Case control.id
        Case Else
    
    End Select

End Sub

'Callback for EditBox onChange
Sub EBMacro(ByVal control As IRibbonControl, ByVal strtext As String)
    Dim lngpos As String
    
    lngpos = Val(Trim(strtext))
    
    Select Case control.id
        Case Is = "EBGotoPosition"
            If IsNumeric(strtext) Then
                If lngpos >= ActiveDocument.Range.Start And lngpos < ActiveDocument.Range.End Then
                    ActiveDocument.Range(lngpos, lngpos).Select
                Else
                    MsgBox "Valid positions for this document are between 0 and " & ActiveDocument.Range.End - 1 & ".", vbExclamation, "Invalid Position"
                End If
            Else
                MsgBox "'" & strtext & "' is not a number.", vbExclamation, "Invalid Position"
            End If
            InvalidateRibbon control.id ' recalculate box so the change event is always triggered
            
        Case Else
        
    End Select

End Sub

'Callback for getText
Sub GetText(ByVal control As IRibbonControl, ByRef returnedVal)

    returnedVal = vbNullString
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        Select Case control.id
            Case Is = "EBGotoPosition"
                returnedVal = ActiveDocument.ActiveWindow.Selection.Start
            
            Case Else
        End Select
    End If
    
End Sub

'Callback for getItemCount
Sub GetItemCount(ByVal control As IRibbonControl, ByRef cnt)
    Dim varitem As Variant
    
    cnt = 0
    Select Case control.id
        Case "GlryAutoAdd", "GlryAutoAddAll"
            cnt = GetAutoBookmarkList.Count
            
        Case Else
    End Select

End Sub

'Callback for getLabel
Sub GetLabel(control As IRibbonControl, ByRef Label)
    Dim strfilename As String, strpropname As String
    
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        Select Case control.id
            Case Is = "BtnDSTVersion"
                ' assume DST macro-enabled template file is loaded - else this ribbon would not exist
                strfilename = Application.MacroContainer.Path & "\" & Application.MacroContainer.Name
                strpropname = Dst.Document(ActiveDocument.Fullname).Properties.PropertyNameVersion
                Label = "Help v" & Application.Templates(strfilename).CustomDocumentProperties(strpropname).Value
                
            Case Is = "BtnDocStatus"
                If CheckDocumentStatusQuick(ActiveDocument) = vbNullString Then
                    Label = "Doc Status"
                Else
                    Label = "Doc Error"
                End If
                
            Case Is = "BtnManagePicture"
                With ActiveDocument.ActiveWindow.Selection.Range
                    If .InlineShapes.Count = 0 Then
                        Label = "Insert Picture"
                    Else
                        Label = "Update Picture"
                    End If
                End With
        
            Case Is = "BtnManageLandscape"
                If Not IsRangeLandscape(ActiveDocument.ActiveWindow.Selection.Range) Then
                    Label = "Insert Landscape"
                Else
                    Label = "Remove Landscape"
                End If
        
            Case Is = "BtnUpdateLockedField"
                If CurrentSelection.NumFields = 1 Then
                    If ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).Locked Then
                        Label = "Update Locked Field"
                    Else
                        Label = "<Field not Locked>"
                    End If
                ElseIf CurrentSelection.NumFields > 1 Then
                    Label = "<Multiple Fields>"
                Else
                    Label = "<No Field>"
                End If
                
            Case Is = "BtnTable"
                If IsRangeInTable(ActiveDocument.ActiveWindow.Selection.Range) Then
                    Label = "Format Table"
                Else
                    Label = "Insert Table"
                End If
            
            Case Else
            
        End Select
    End If
End Sub

'Callback for getItemLabel
Sub GetItemLabel(ByVal control As IRibbonControl, ByVal Index As Integer, ByRef Label)
    
    Label = vbNullString
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        Select Case control.id
            Case "GlryAutoAdd", "GlryAutoAddAll"
                Label = GetAutoBookmarkList.Items(Index)
            
            Case Else
        End Select
    End If
End Sub

'Callback for getScreenTip
Sub GetScreenTip(ByVal control As IRibbonControl, ByRef returnedVal)

    returnedVal = vbNullString
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        Select Case control.id
            Case Is = "BtnManagePicture"
                With ActiveDocument.ActiveWindow.Selection.Range
                    If .InlineShapes.Count = 0 Then
                        returnedVal = "Insert New Picture"
                    Else
                        returnedVal = "Update Linked Picture"
                    End If
                End With
            
            Case Is = "BtnTable"
                With ActiveDocument.ActiveWindow.Selection
                    If IsRangeInTable(.Range) Then
                        returnedVal = "Format Existing Table"
                    Else
                        returnedVal = "Insert New Table"
                    End If
                End With
            
            Case Is = "BtnManageLandscape"
                If Not IsRangeLandscape(ActiveDocument.ActiveWindow.Selection.Range) Then
                    returnedVal = "Insert New Landscape Section"
                Else
                    returnedVal = "Remove Landscape Section"
                End If
                    
            Case Else
                returnedVal = "[NOT SET]"
        End Select
    End If
End Sub

'Callback for getSuperTip
Sub GetSuperTip(ByVal control As IRibbonControl, ByRef returnedVal)

    returnedVal = vbNullString
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        Select Case control.id
            Case Is = "BtnManagePicture"
                With ActiveDocument.ActiveWindow.Selection.Range
                    If .InlineShapes.Count = 0 Then
                        returnedVal = "Inserts a reference to a picture file and appends a figure caption. Note that the insertion point must be on a blank line."
                    Else
                        returnedVal = "Updates the linked picture at the insertion point."
                    End If
                End With
                
            Case Is = "BtnTable"
                With ActiveDocument.ActiveWindow.Selection
                    If IsRangeInTable(.Range) Then
                        returnedVal = "Formats the table at the insertion point and applies the appropriate styles and formatting based on the font size and paragraph spacing settings above."
                    Else
                        returnedVal = "Inserts a new table and applies the appropriate styles and formatting based on the font size and paragraph spacing settings above. Note that the insertion point must be on a blank line."
                    End If
                End With
            
            Case Is = "BtnManageLandscape"
                If Not IsRangeLandscape(ActiveDocument.ActiveWindow.Selection.Range) Then
                    returnedVal = "Inserts a new section formatted as a landscape page after the insertion point and re-formats its header and footer. Note that the insertion point must be on a blank line."
                Else
                    returnedVal = "Removes the landscaped section at the insertion point. Note that this function removes the entire section - including the content."
                End If
                
            Case Else
                returnedVal = "[NOT SET]"
        End Select
    End If
End Sub

'Callback for getSelectedIndex
Sub GetSelectedIndex(ByVal control As IRibbonControl, ByRef Index)
    
    'This procedure is used to ensure the first item in the dropdown is displayed.
    Select Case control.id
        Case Is = "DDBkmarkPrefix"
            Index = 0
            ' set initial value for bookmark prefix by simulating the dropdown event
            Call DDMacro(control, vbNullString, Index)
            
        Case Else
            Index = 0
            
    End Select

End Sub

'Callback for togglebutton getLabel
Sub getToggleLabel(control As IRibbonControl, ByRef returnedVal)
    
    If ActiveDocument.ProtectionType <> wdAllowOnlyFormFields Then
        Select Case control.id
            Case Is = "TglBtnFontSize"
                If BlTableFontSmall Then
                    returnedVal = "Small"
                Else
                    returnedVal = "Normal"
                End If
                
            Case Is = "TglBtnParSpacing"
                If BlTableParSpacingZero Then
                    returnedVal = "0 pt"
                Else
                    returnedVal = "3 pt"
                End If
                
            Case Is = "TglBtnShowFieldCode"
                If CurrentSelection.NumFields = 1 Then
                    If ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).ShowCodes Then
                        returnedVal = "Show Field Result"
                    Else
                        returnedVal = "Show Field Code"
                    End If
                ElseIf CurrentSelection.NumFields > 1 Then
                    returnedVal = "<Multiple Fields>"
                Else
                    returnedVal = "<No Field>"
                End If
                        
            Case Is = "TglBtnLockField"
                If CurrentSelection.NumFields = 1 Then
                    If ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).Locked = True Then
                        returnedVal = "Unlock Field"
                    Else
                        returnedVal = "Lock Field"
                    End If
                ElseIf CurrentSelection.NumFields > 1 Then
                    returnedVal = "<Multiple Fields>"
                Else
                    returnedVal = "<No Field>"
                End If
                
            Case Is = "TglBtnKeepWithNext"
                returnedVal = "Keep with next"
                
            Case Is = "TglBtnPageBreakBefore"
                returnedVal = "Page break before"
            
            Case Is = "TglBtnDebugMode"
                returnedVal = "Debug Mode " & IIf(BlDSTDebugMode, "On", "Off")
            
            Case Is = "TglBtnDebugTiming"
                returnedVal = "Debug Timing " & IIf(BlDSTDebugTiming, "On", "Off")
            
            Case Else
                returnedVal = "Label Error!"
                
        End Select
    End If
End Sub

'Callback for togglebutton getPressed
Sub TogglePressed(control As IRibbonControl, ByRef toggleState)
'toggleState is used to set the toggle state (i.e., true or false) and determine how the
'toggle appears on the ribbon (i.e., flush or sunken).
        
    Select Case control.id
        Case Is = "TglBtnFontSize"
            toggleState = BlTableFontSmall
            
        Case Is = "TglBtnParSpacing"
            toggleState = BlTableParSpacingZero
            
        Case Is = "TglBtnShowFieldCode"
            If CurrentSelection.NumFields = 1 Then
                toggleState = ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).ShowCodes
            End If
        
        Case Is = "TglBtnLockField"
            If CurrentSelection.NumFields = 1 Then
                toggleState = ActiveDocument.StoryRanges(CurrentSelection.Story).Fields(CurrentSelection.FieldIndex).Locked
            End If
            
        Case Is = "TglBtnKeepWithNext"
            toggleState = ActiveDocument.ActiveWindow.Selection.ParagraphFormat.KeepWithNext
        
        Case Is = "TglBtnPageBreakBefore"
            toggleState = ActiveDocument.ActiveWindow.Selection.ParagraphFormat.PageBreakBefore

        Case Is = "TglBtnDebugMode"
            toggleState = BlDSTDebugMode
        
        Case Is = "TglBtnDebugTiming"
            toggleState = BlDSTDebugTiming
                
        Case Else
            toggleState = False
            
    End Select
End Sub

Sub GetContent(control As IRibbonControl, ByRef content)
    
    Select Case control.id
        Case Else
            'For future use
    End Select
    
End Sub

Private Function BuildAutoBookmarkAddMenu() As String
    Dim strXML As String, i As Long, varitem As Variant
    
    'ACZ retain this function as an example if ever a dynamic menu is required
    strXML = Const_CUSTOMUI_NAMESPACE
    
    For Each varitem In Dst.BookmarkConfig.PrefixesForDocType(Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr)
        If Dst.BookmarkConfig.Prefix(varitem).TextMatch = enumTextMatchFull Then
            strXML = strXML & RibbonXMLStringBuilder(strctrltype:="button", _
                                                     strID:="AutoAddItem" & i, _
                                                     strlabel:=CStr(varitem), _
                                                     straction:="AutoAddMenuOnAction", _
                                                     strtag:=CStr(varitem), _
                                                     strtip:="Auto Add '" & varitem & "' Bookmark", _
                                                     strsupertip:="Click to automatically bookmark the word at insert point with the '" & varitem & "' prefix")
            i = i + 1
        End If
    Next varitem
        
    strXML = strXML & vbNewLine & "</menu>"
    strXML = Replace(strXML, "&", "&amp;&amp;") 'Added to prevent error entries with "&"
    
    BuildAutoBookmarkAddMenu = strXML

End Function
Attribute VB_Name = "basRibbonPointer"
Option Explicit

Private Const Const_RIBBON_POINTER As String = "ribbon_pointer"

' The DSTRibbon reference sometimes gets lost when an unhandled error occurs. This module provides functionality to store a retrieve
' the pointer to the ribbon interface so the DST ribbon reference can be restored if an error occurs. A file is used to store the
' pointer value as it is the only "memory" guaranteed to be unchanged if an error occurs
' Ref: https://colinlegg.wordpress.com/2013/09/07/a-custom-tab-ribbonx-template-which-handles-state-loss
#If VBA7 Then
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, source As Any, ByVal Length As Long)
#Else
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, source As Any, ByVal Length As Long)
#End If

Sub SaveDSTRibbonPointer()
    Dim fso As FileSystemObject, tstream As TextStream, strfile As String
    #If VBA7 And Win64 Then
        Dim lngpointer As LongPtr
    #Else
        Dim lngpointer As Long
    #End If
On Error GoTo Err_SaveDSTRibbonPointer
    
    lngpointer = ObjPtr(DSTRibbon)
    strfile = GetTempFolderName() & "\" & Const_RIBBON_POINTER
    Set fso = New FileSystemObject
    Set tstream = fso.CreateTextFile(strfile)
    tstream.WriteLine Trim(CStr(lngpointer))
    tstream.WriteLine "DO NOT DELETE THIS FILE - THE VALUE ABOVE IS USED AS A POINTER TO RESTORE THE DST RIBBON UI"
    tstream.Close
    
Exit_SaveDSTRibbonPointer:
    Exit Sub
    
Err_SaveDSTRibbonPointer:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in SaveDSTRibbonPointer() of basRibbonPointer - unable to store the DST ribbon pointer - contact the DST owner", vbCritical, "Critical Error"
    Beep
    Stop
End Sub
 
Sub RestoreDSTRibbonObject()
    Dim fso As FileSystemObject, tstream As TextStream, strfile As String
    Dim objribbon As Object, strvalue As String, strmessage As String
    #If VBA7 And Win64 Then
        Dim lngpointer As LongPtr
    #Else
        Dim lngpointer As Long
    #End If
On Error GoTo Err_RestoreDSTRibbonObject
    
    Set fso = New FileSystemObject
    strfile = GetTempFolderName() & "\" & Const_RIBBON_POINTER
    If fso.FileExists(strfile) Then
        Set tstream = fso.OpenTextFile(strfile)
        strvalue = tstream.ReadLine
        tstream.Close
        If IsNumeric(strvalue) Then
            #If VBA7 Then
                lngpointer = CLngPtr(strvalue)
            #Else
                lngpointer = CLng(strvalue)
            #End If
            If lngpointer <> 0 Then
                CopyMemory objribbon, lngpointer, LenB(lngpointer)
                Set DSTRibbon = objribbon
                CopyMemory objribbon, 0&, LenB(lngpointer)
            Else
                strmessage = "Pointer is 0"
            End If
        Else
            strmessage = "Invalid pointer location '" & strvalue & "'"
        End If
    Else
        strmessage = "Could not locate file used to store the ribbon pointer"
    End If
    
Exit_RestoreDSTRibbonObject:
    If strmessage <> vbNullString Then
        MsgBox strmessage & " - unable to restore the ribbon functionality - contact the DST owner if the problem persists", vbCritical, "Critical Error"
    End If
    Exit Sub

Err_RestoreDSTRibbonObject:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in RestoreDSTRibbonObject() of basRibbonPointer - unable to restore the ribbon functionality - contact the DST owner if the problem persists", vbCritical, "Critical Error"
    Beep
    Stop
End Sub
Attribute VB_Name = "basRibbonXML"
Option Explicit

Public Const Const_CUSTOMUI_NAMESPACE = "<menu xmlns=""http://schemas.microsoft.com/office/2006/01/customui"">" & vbNewLine

Function RibbonXMLStringBuilder(ByRef strctrltype As String, Optional strID As String, Optional strIDmso As String, _
                                Optional strIDq As String, Optional strIAmso As String, Optional strIBmso As String, _
                                Optional strIAq As String, Optional strIBq As String, Optional strsize As String, _
                                Optional strgetsize As String, Optional strkeytip As String, Optional strgetkeytip As String, _
                                Optional strvisible As String, Optional strgetvisible As String, Optional strlabel As String, _
                                Optional strgetlabel As String, Optional strshowlabel As String, Optional strgetshowlabel As String, _
                                Optional strimagemso As String, Optional strimage As String, Optional strgetimage As String, _
                                Optional strshowimage As String, Optional strgetshowimage As String, Optional straction As String, _
                                Optional strcontent As String, Optional strtag As String, Optional strtip As String, _
                                Optional strgettip As String, Optional strsupertip As String, Optional strgetsupertip As String, _
                                Optional stronchange As String, Optional strenabled As String, Optional strgetenabled As String, _
                                Optional strgetpressed As String, Optional strgettext As String, Optional strgetitemcount As String, _
                                Optional strgetitemID As String, Optional strgetitemimage As String, _
                                Optional strgetitemlabel As String, Optional strgetitemtip As String, _
                                Optional strgetitemsupertip As String, Optional strgetselitemID As String, _
                                Optional strgetselitemindex As String, Optional strgetitemheight As String, _
                                Optional strgetitemwidth As String, Optional strtitle As String, Optional strgettitle As String, _
                                Optional strdescr As String, Optional strgetdescr As String) As String
    Dim strXML As String, s As String
    Dim arrattributes() As String, arrattributevalues() As String
    Dim idx As Long
    
    'Build control type and ID attribute
    Select Case True
        Case Len(strID) > 0
            strXML = "<" & strctrltype & " id=" & Chr(34) + strID + Chr(34)
        Case Len(strIDq) > 0
            strXML = "<" & strctrltype & " idQ=" & Chr(34) + strIDq + Chr(34)
        Case Len(strIDmso) > 0
            strXML = "<" & strctrltype & " idMso=" & Chr(34) + strID + Chr(34)
    End Select
    
    'Build additional attributes as passed
    s = ","
    arrattributes = Split("insertAfterMso=,insertBeforeMso=,insertAfterQ=,insertBeforeQ=,size=,getSize=,keytip=,getKeytip=,label=,getLabel=," _
                          & "showLabel=,getShowLabel=,visible=,getVisible=,imageMso=,image=,getImage=,showImage=,getShowImage=,onAction=," _
                          & "getContent=,tag=,screentip=,getScreentip=,supertip=,getSupertip,onChange=,enabled=,getEnabeled=,getPressed=," _
                          & "getText=,getItemCount=,getItemID=,getItemImage=,getItemLabel=,getItemTip=,getItemSupertip=,getSelectedItemID=," _
                          & "getSelectedItemIndex,getItemHeight=,getItemWidth=,title=,getTitle=,description=,getDescription", ",")
    arrattributevalues = Split(strIAmso + s + strIBmso + s + strIAq + s + strIBq + s + strsize + s + strgetsize + s + strkeytip + s + strgetkeytip + s + strlabel + s _
                               + strgetlabel + s + strshowlabel + s + strgetshowlabel + s + strvisible + s + strgetvisible + s + strimagemso + s _
                               + strimage + s + strgetimage + s + strshowimage + s + strgetshowimage + s + straction + s + strcontent + s + strtag + s _
                               + strtip + s + strgettip + s + strsupertip + s + strgetsupertip + s + stronchange + s + strenabled + s + strgetenabled + s _
                               + strgetpressed + s + strgettext + s + strgetitemcount + s + strgetitemID + s + strgetitemimage + s + strgetitemlabel + s _
                               + strgetitemtip + s + strgetitemsupertip + s + strgetselitemID + s + strgetselitemindex + s + strgetitemheight + s _
                               + strgetitemwidth + s + strtitle + s + strgettitle + s + strdescr + s + strgetdescr, ",")
    For idx = 0 To UBound(arrattributevalues)
          If Len(arrattributevalues(idx)) > 0 Then strXML = strXML & vbNewLine + vbTab + arrattributes(idx) + Chr(34) + arrattributevalues(idx) + Chr(34)
    Next idx
    RibbonXMLStringBuilder = strXML & "/>" & vbNewLine

End Function
Attribute VB_Name = "basSearch"
Option Explicit

Function RegularExpressionSearch(ByVal strsearch As String, ByVal strpattern As String, _
                                 Optional ByVal blignorecase As Boolean = False, Optional ByRef colmatches As MatchCollection) As Boolean
    Dim objregexp As regexp

    ' create a regular expression object
    Set objregexp = New regexp
    
    ' set the pattern by using the Pattern property
    objregexp.Pattern = strpattern
    objregexp.IgnoreCase = blignorecase
    objregexp.Global = True
    objregexp.MultiLine = True
    
    ' test whether the bookmark name can be compared
    If objregexp.Test(strsearch) = True Then
        RegularExpressionSearch = True
    
        ' return all matches if requested
        If Not IsMissing(colmatches) Then
            Set colmatches = objregexp.Execute(strsearch)
        End If
    End If
    
End Function

Function RegularExpressionReplace(ByVal strsearch As String, ByVal strpattern As String, ByVal strreplace, Optional ByVal blignorecase As Boolean = True) As String
    Dim objregexp As regexp

    ' create a regular expression object
    Set objregexp = New regexp
    
    ' set the pattern by using the Pattern property
    objregexp.Pattern = strpattern
    objregexp.IgnoreCase = blignorecase
    objregexp.Global = True
    objregexp.MultiLine = True
    
    ' do the replace
    RegularExpressionReplace = objregexp.Replace(strsearch, strreplace)
    
End Function

Function FileSearchReplace(ByVal strfilename As String, ByVal strsearch As String, ByVal strreplace As String, Optional ByRef strmessage As Variant) As Boolean
    Dim fso As FileSystemObject, fstr As TextStream, strstatus As String
    Dim strfilecontents As String, strnewfilecontents As String
On Error GoTo Err_FileSearchReplace

    Set fso = New FileSystemObject
    
    ' check if file exists first
    If fso.FileExists(strfilename) Then
        ' read the source text file
        Set fstr = fso.OpenTextFile(strfilename, ForReading)
        strfilecontents = fstr.ReadAll
    
        ' replace all occurrences as-is
        strnewfilecontents = Replace(strfilecontents, strsearch, strreplace)
        
        ' compare old and new
        If strnewfilecontents <> strfilecontents Then
            ' write string back to file if different
            Set fstr = fso.OpenTextFile(strfilename, ForWriting)
            fstr.Write strnewfilecontents
            fstr.Close
        End If
        
        FileSearchReplace = True
    Else
        strstatus = "The file '" & strfilename & "' does not exist."
    End If
    
Exit_FileSearchReplace:
    ' inform the user if required
    If strstatus <> vbNullString Then
        If IsMissing(strmessage) Then
            MsgBox strstatus, vbExclamation, "File Search/Replace"
        Else
            strmessage = strstatus
        End If
    End If
    Exit Function

Err_FileSearchReplace:
    strstatus = Err.Description & " in FileSearchReplace() of basUtilities"
    Resume Exit_FileSearchReplace
    
End Function

Function FileSearchReplaceLine(ByVal strfilename As String, ByVal strsearch As String, ByVal varreplace As Variant, _
                               Optional blinsert As Boolean = True, Optional ByVal strremove As String = vbNullString) As Boolean
    Dim fso As FileSystemObject, fstr As TextStream
    Dim strleadingspace As String, idx As Integer, strreplace As String, colmatches As MatchCollection, strtemp As String
    Dim strline As String, strnewline As String, strfilecontents As String, strnewfilecontents As String
On Error GoTo Err_FileSearchReplaceLine

    Set fso = New FileSystemObject
    
    ' check if file exists first
    If fso.FileExists(strfilename) Then
        ' read the source text file
        Set fstr = fso.OpenTextFile(strfilename, ForReading)
        strfilecontents = fstr.ReadAll
        fstr.Close
        
        ' insert new line above existing (to retain it) and replace text in new line
        Set fstr = fso.OpenTextFile(strfilename, ForReading)
        While Not fstr.AtEndOfStream
            strline = fstr.ReadLine
            If InStr(1, strline, strsearch) Then
                ' make sure we have an array
                If Not IsArray(varreplace) Then
                    varreplace = Array(varreplace)
                End If
                
                ' get the leading whitespace
                If RegularExpressionSearch(strline, "(^\s+).*", , colmatches) = True Then
                    strleadingspace = colmatches(0).SubMatches(0)
                End If
                
                ' now add the leading whitespace from the 2nd entry onwards in the array
                strreplace = vbNullString
                For idx = 0 To UBound(varreplace)
                    strtemp = Replace(varreplace(idx), vbCrLf, vbCrLf & strleadingspace)
                    If idx = 0 Then
                        strreplace = strtemp
                    Else
                        strreplace = strreplace & vbCrLf & strleadingspace & strtemp
                    End If
                Next idx
                
                ' replace the text
                strnewline = Replace(strline, strsearch, strreplace)
                
                ' remove some text from the new line if requested
                If strremove <> vbNullString Then
                    strnewline = Replace(strnewline, strremove, vbNullString)
                End If
                
                ' append the original line if requested
                If blinsert Then
                    strnewline = strnewline & vbCrLf & strline
                End If
            
            Else
                strnewline = strline
            End If
            
            ' append line to file content string
            strnewfilecontents = strnewfilecontents & strnewline & vbCrLf
        Wend
        fstr.Close
        
        ' compare old and new
        If strnewfilecontents <> strfilecontents Then
            ' write string back to file if different
            Set fstr = fso.OpenTextFile(strfilename, ForWriting)
            fstr.Write strnewfilecontents
            fstr.Close
        Else
            MsgBox "File '" & strfilename & "' was not modified - modified contents was the same as the original.", vbInformation, "File Search and Replace"
        End If
        FileSearchReplaceLine = True
    Else
        MsgBox "The file '" & strfilename & "' does not exist.", vbExclamation, "File Search and Replace"
    End If
    
Exit_FileSearchReplaceLine:
    Exit Function

Err_FileSearchReplaceLine:
    MsgBox Err.Description & " in FileSearchReplaceLine() of basUtilities"
    Resume Exit_FileSearchReplaceLine
    
End Function

' Splits a given string into words (note that '-' characters are assumed to be part of the word
Function SplitIntoWords(ByVal strtext As String, ByRef colmatches As MatchCollection) As Boolean
    
    If RegularExpressionSearch(strtext, "([\w-]+)\b", , colmatches) Then
        SplitIntoWords = True
    End If

End Function

Sub DocumentSearchReplace(ByRef objdoc As Document, ByVal strsearch As String, ByVal strreplace As String, Optional ByVal blwholeword As Boolean = False, Optional ByVal blwildcards As Boolean = False)
    Dim stryrng As Range
    
    Call ScreenUpdatePause
    
    For Each stryrng In objdoc.StoryRanges
        Do
            With stryrng.Find
                .ClearFormatting
                .Text = strsearch
                .MatchAllWordForms = False
                .MatchCase = True
                .MatchWholeWord = blwholeword
                .MatchWildcards = blwildcards
                .Replacement.ClearFormatting
                .Replacement.Text = strreplace
                .Execute Replace:=wdReplaceAll
            End With
            Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
        Loop Until stryrng Is Nothing
    Next stryrng
    
    Call ScreenUpdateRestore
    
End Sub

Sub FindFilePatterns(ByVal strstartfolder As String, ByVal strpatternfolder As String, ByVal strpatternfile As String, ByRef dicfiles As Scripting.Dictionary)
    Dim fso As New FileSystemObject, regexo As New regexp
    
    ' change wildcard patterns to regex
    strpatternfolder = Replace(strpatternfolder, "\", "\\")
    strpatternfolder = Replace(strpatternfolder, ".", "\.")
    strpatternfolder = Replace(strpatternfolder, "*", ".*")
    strpatternfile = Replace(strpatternfile, ".", "\.")
    strpatternfile = Replace(strpatternfile, "*", ".*")
    
    regexo.Pattern = strpatternfolder & strpatternfile
    regexo.IgnoreCase = True
    Call RecursiveFileSearch(strstartfolder, regexo, dicfiles, fso)
 
End Sub
 
Sub RecursiveFileSearch(ByVal strstartfolder As String, ByRef regexo As regexp, ByRef dicfiles As Scripting.Dictionary, ByRef fso As FileSystemObject)
    Dim fold As Folder, fil As File, subfold As Folder
 
    ' get the folder object associated with the start directory
    Set fold = fso.GetFolder(strstartfolder)
 
    ' loop through the files current folder - ignore temporary files, e.g. Word documents
    For Each fil In fold.Files
        If regexo.Test(fil.Path) And Left(fil.Name, 2) <> "~$" Then
            dicfiles.Add fil.Path, fil.Path
        End If
    Next
 
    ' loop through the each of the sub folders recursively
    For Each subfold In fold.SubFolders
        RecursiveFileSearch subfold, regexo, dicfiles, fso
    Next
 
End Sub
Attribute VB_Name = "basStyles"
Option Explicit
            
Public Const Const_DOC_NUMBERED_LIST_STYLE As String = "DSTNumberedList"
Public Const Const_DOC_BULLET_LIST_STYLE As String = "DSTBulletedList"

Function ImportStyles(ByRef objdoc As Document, ByRef frm As Object, ByVal strtemplate As String) As Boolean
    Dim strdate As String, fso As FileSystemObject
            
    ' check if it exists
    If strtemplate <> vbNullString Then
        Set fso = New FileSystemObject
        If fso.FileExists(strtemplate) Then
            ' associate document with master template
            Dst.Document(objdoc.Fullname).Variables.MasterTemplateUsed = strtemplate
            
            ' import styles and update document styles date variable
            objdoc.CopyStylesFromTemplate strtemplate
            strdate = ManageMasterTemplateDate(objdoc, True)
            frm.UpdateProgressText "Successfully imported master template from '" & strtemplate & "'."
            ImportStyles = True
        Else
            frm.UpdateProgressText "Master template '" & strtemplate & "' does not exist."
        End If
    Else
        frm.UpdateProgressText "No master template to import from was specified."
    End If

End Function

Sub ApplyStyleToField(ByVal strstylename As String, ByVal strbkmarkprefix As String, Optional ByRef rng As Range)
    Dim fld As Field, strbkname As String

    If rng Is Nothing Then
        Set rng = ActiveDocument.Range
    End If
    
    For Each fld In rng.Fields
        strbkname = GetBookmarkNameFromField(fld)
        If strbkname Like strbkmarkprefix & "_*" Then
            If fld.Result.Style <> strstylename Then
                fld.Result.Style = strstylename
            End If
        End If
    Next fld
    
End Sub

Function StyleExists(ByRef objdoc As Document, ByVal strstyle As String, Optional ByRef strmessage As Variant) As Boolean
    Dim strdescription As String, strstatus As String
On Error GoTo Err_StyleExists

    If strstyle <> vbNullString Then
        ' check if style exists - note the error that the collection member does not exist is caught below
        strdescription = Const_TEXT_UNKNOWN
        strdescription = objdoc.Styles(strstyle).Description
        If strdescription = Const_TEXT_UNKNOWN Then
            strstatus = "The style '" & strstyle & "' does not exist. Use the 'Import DST Styles' function to copy the styles from the Master Template."
        End If
    End If
    
Exit_StyleExists:
    If strstatus = vbNullString Then
        If strstyle <> vbNullString Then
            StyleExists = True
        Else
            StyleExists = False
        End If
    Else
        StyleExists = False
        If IsMissing(strmessage) Then
            MsgBox strstatus, vbExclamation, "DST Style Error"
        Else
            strmessage = strstatus
        End If
    End If
    Exit Function
    
Err_StyleExists:
    If Err.Number = 5941 And strdescription = Const_TEXT_UNKNOWN Then
        Resume Next
    Else
        strstatus = Err.Number & " " & Err.Description & " in StyleExists()"
        Resume Exit_StyleExists
    End If
    
End Function

Function ChangeStyle(ByRef objdoc As Document, ByVal strstylefind As String, ByVal strstylereplacebody As String, ByVal strstylereplacetable As String, _
                     Optional ByVal blcleartext As Boolean = False) As String
    Dim rng As Range, lngpars As Long
    
    ' find ranges with the given style, change style to Body Text
    Set rng = objdoc.content ' only work in main text story
    With rng.Find
        .ClearFormatting
        .Forward = True
        .Wrap = wdFindStop
        .Style = strstylefind
        Do While (.Execute)
            If IsRangeInTable(rng) Then
                rng.Style = strstylereplacetable
            Else
                rng.Style = strstylereplacebody
            End If
            If blcleartext Then rng.Text = vbNullString
            lngpars = lngpars + 1
        Loop
    End With

    ChangeStyle = "Removed " & lngpars & " paragraphs formatted with the '" & strstylefind & "' style."
    
End Function

Function ListDocStyles(ByRef objdoc As Document, ByRef frmtext As Object) As Boolean
    Dim tmpl As Document
    Dim strmessage As String, strtemp As String
    Dim strname As String, strmaster As String, strused As String, strbuiltin As String
    Dim strx As String
    Dim blclosedoc As Boolean
    Dim stl As Style, strstatus As String
    Dim strfilename As String, intnamelen As Integer
    
    ' loop through each style in the given document and determine its origin (i.e., master template or local) and also
    ' indicate its usage status
    strfilename = Dst.Document(objdoc.Fullname).Variables.MasterTemplateUsed
    If strfilename <> vbNullString Then
        blclosedoc = Not IsDocumentOpen(strfilename, tmpl)
        
        ' if template not already open, open it as a document
        If tmpl Is Nothing Then Set tmpl = Application.Templates(strfilename).OpenAsDocument
        
        frmtext.UpdateProgressText "Master Template:"
        frmtext.UpdateProgressText "================"
        frmtext.UpdateProgressText tmpl.AttachedTemplate.Fullname & vbCrLf
        
        strx = Space(5) & "x" & Space(4)
        
        strtemp = "NAME" & Space(17)
        intnamelen = Len(strtemp)
        strtemp = "| " & strtemp & "|  MASTER  |   USED   | BUILT-IN | BASED ON"
        strtemp = strtemp & Space(intnamelen - Len("BASED ON")) & " |"
        frmtext.UpdateProgressText String(Len(strtemp), "=")
        frmtext.UpdateProgressText strtemp
        frmtext.UpdateProgressText String(Len(strtemp), "=")
        For Each stl In objdoc.Styles
            ' pad/limit lentgh of style name
            strname = stl.NameLocal
            If intnamelen > Len(strname) Then
                strname = strname & Space(intnamelen - Len(strname))
            Else
                strname = Left(strname, intnamelen)
            End If
            strmessage = "| " & strname
            
            ' determine the origin of the style
            strmaster = Space(Len(strx))
            If StyleExists(tmpl, stl.NameLocal, strstatus) Then strmaster = strx
            
            ' determine the style's actual usage status
            strused = Space(Len(strx))
            If stl.InUse = True Then
                With objdoc.content.Find
                    .ClearFormatting
                    .Text = vbNullString
                    .Style = stl
                    .Execute Format:=True
                    If .Found = True Then
                        strused = strx
                    End If
                End With
            End If
                        
            ' determine built-in status
            strbuiltin = Space(Len(strx))
            If stl.BuiltIn Then strbuiltin = strx
            
            ' show all user-defined styles and only built-in styles that are used
            If strused = strx Or strbuiltin <> strx Then
                strmessage = strmessage & "|" & strmaster & "|" & strused & "|" & strbuiltin & "|"
                strname = Space(intnamelen)
                If stl.BaseStyle <> vbNullString Then
                    ' pad/limit lentgh of style name
                    strname = stl.BaseStyle
                    If intnamelen > Len(strname) Then
                        strname = strname & Space(intnamelen - Len(strname))
                    Else
                        strname = Left(strname, intnamelen)
                    End If
                End If
                strmessage = strmessage & " " & strname & " |"
                frmtext.UpdateProgressText strmessage
                frmtext.UpdateProgressText String(Len(strmessage), "-")
            End If
        Next stl
            
        If blclosedoc Then tmpl.Close wdDoNotSaveChanges
    End If
    
    ListDocStyles = True
    
End Function

Sub InsertNote(ByRef rng As Range)
    With rng
        .Text = "Note:" & vbTab
        .Style = "DSTNote"
        .End = .End - 1
        .Font.Bold = True
        If IsRangeInTable(rng) Then
            With .ParagraphFormat
                .LeftIndent = -1 * .FirstLineIndent
                .TabStops(1).Position = .LeftIndent
            End With
        End If
        .SetRange .End + 1, .End + 1
        .Select
    End With
End Sub

Sub InsertMultiLevelList(ByRef rng As Range, ByVal strlisttemplate As String)
    '==================================================================================================================================
    ' Purpose: Insert a new multi-level list at the given range and appends a blank 'Body Text' paragraph afterwards
    '==================================================================================================================================
    Dim strdefaultstyle As String, blinsertblank As Boolean
    
    With rng
        ' NOTE: use the Selection object to ensure numbering starts at 1
        Selection.Style = .Document.Styles(strlisttemplate)
        If IsRangeInTable(rng) Then
            strdefaultstyle = rng.Rows(1).Cells(1).Range.ParagraphFormat.Style ' use first cell in row as default style for tables
            .ParagraphFormat.LeftIndent = CentimetersToPoints(0.7) ' there's no indentation for tables
            .Paragraphs(1).Range.Font.Size = .Document.Styles(strdefaultstyle).Font.Size ' use existing font size
            blinsertblank = (.Paragraphs(1).Range.Text Like "*" & Chr(13) & Chr(7)) ' insert blank line if at end of cell (EOC)
        Else
            strdefaultstyle = "Body Text"
            blinsertblank = (.Next(wdParagraph).Style <> strdefaultstyle) ' preserve other formats
        End If
        
        If blinsertblank Then
            .InsertParagraphAfter
            .Collapse wdCollapseEnd
            .ParagraphFormat.Style = strdefaultstyle
        End If
    End With
End Sub

Function IsMultiLevelList(ByRef rng As Range) As Boolean
    '==================================================================================================================================
    ' Purpose: Checks whether the given range is a multi-level list
    '==================================================================================================================================
    IsMultiLevelList = (rng.ListFormat.ListType = wdListOutlineNumbering)
End Function

Function IsMultiLevelListStyle(ByRef rng As Range) As Boolean
    '==================================================================================================================================
    ' Purpose: Checks whether given range is styled with one of the multi-level list styles
    '==================================================================================================================================
On Error GoTo Err_IsMultiLevelListStyle
    With rng
        If Not .Style Is Nothing Then
            If .Style Like Const_DOC_NUMBERED_LIST_STYLE & "*" Or .Style Like Const_DOC_BULLET_LIST_STYLE & "*" Then
                IsMultiLevelListStyle = True
            End If
        End If
    End With

Exit_IsMultiLevelListStyle:
    Exit Function

Err_IsMultiLevelListStyle:
    ' Testing for 'rng.Style Is Nothing' causes selection to be unhighlighted, but still selected
    If Err.Number = -2147467259 Then
        ' ignore the "Method 'Style' of object 'Range' failed" error, happens when inserting a  new table for example.
        ' NOTE: In this case we assume there is no numbered style
    Else
        MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure IsMultiLevelListStyle, line " & Erl & "."
    End If
    Resume Exit_IsMultiLevelListStyle
End Function

Function IsOrphanedListParagraph(ByRef rng As Range) As Boolean
    '==================================================================================================================================
    ' Purpose: Checks whether given range is an orphaned list paragraph
    '==================================================================================================================================
    If IsMultiLevelListStyle(rng) Then
        IsOrphanedListParagraph = (rng.ListFormat.ListType = wdListNoNumbering)
    End If
End Function

Function RevertOrphanedMultiLevelListStyle(ByRef rng As Range) As String
    '==================================================================================================================================
    ' Purpose: Defaults paragraph style in case a multi-level list was orphaned
    '==================================================================================================================================
    If IsOrphanedListParagraph(rng) Then
        rng.Style = "Body Text"
        RevertOrphanedMultiLevelListStyle = rng.Style
    End If
End Function

Function RevertOrphanedListParagraphs(ByRef objdoc As Document, Optional ByRef frm As Object) As Boolean
    Dim idx As Integer, strstyle As String, rng As Range, blfound As Boolean
    
    frm.UpdateProgressText "Checking " & objdoc.ListParagraphs.Count & " list paragraphs..."
    For idx = 1 To objdoc.ListParagraphs.Count
        With objdoc.ListParagraphs(idx)
            If IsMultiLevelListStyle(.Range) Then
                Set rng = .Range.Next(wdParagraph)
                strstyle = RevertOrphanedMultiLevelListStyle(rng)
                If strstyle <> vbNullString Then
                    frm.UpdateProgressText "   WARNING: Changed style to '" & strstyle & "' at position " & rng.Start
                    blfound = True
                End If
            End If
        End With
    Next idx
        
    If Not blfound Then frm.UpdateProgressText "   INFO: No orphaned list paragraphs found." & vbCrLf
    
    RevertOrphanedListParagraphs = True
    
End Function

Sub AdjustListIndent(ByRef rng As Range, ByVal intdirection As Integer)
    With rng
        If intdirection > 0 Then
            .ListFormat.ListIndent
        Else
            .ListFormat.ListOutdent
        End If
        
        ' content in tables are aligned at zero, so re-adjust indents accordingly
        If IsRangeInTable(rng) Then
            .ParagraphFormat.LeftIndent = -1 * .ListParagraphs(1).Range.ListFormat.ListLevelNumber * .ParagraphFormat.FirstLineIndent
        End If
    End With
End Sub
                        
Function IsBlankLine(ByRef rng As Range) As Boolean
    IsBlankLine = (rng.Paragraphs(1).Range.Words.Count = 1)
End Function

Function RemoveHelptext(ByRef objdoc As Document, ByRef frmtext As Object) As Boolean
    Dim rng As Range, rnglscape As Range, strheading As String
    
    strheading = "TEMPLATE USAGE OVERVIEW"
    Set rng = GetHeadingRangeExtendedFromText(objdoc.Range, strheading)
    If Not rng Is Nothing Then
        ' first remove landscape page
        Set rnglscape = GetHeadingRangeExtendedFromText(objdoc.Range, "Landscape Pages")
        If Not rnglscape Is Nothing Then
            If rnglscape.PageSetup.Orientation = wdOrientLandscape Then
                Call RemoveLandscapeSection(rnglscape)
            End If
        End If
        rng.Delete
        frmtext.UpdateProgressText "Removed section titled '" & strheading & "'"
        strheading = "APPENDIX 1 SAMPLE"
        Set rng = GetHeadingRangeExtendedFromText(objdoc.Range, strheading)
        If Not rng Is Nothing Then
            rng.Delete
            frmtext.UpdateProgressText "Removed section titled '" & strheading & "'"
        End If
    End If
    frmtext.UpdateProgressText ChangeStyle(objdoc, "Help Text", "Body Text", "Table Text", True)
    frmtext.UpdateProgressText ChangeStyle(objdoc, "Help Text Bullet", "Body Text", "Table Text", True)
    
    RemoveHelptext = True
End Function
Attribute VB_Name = "basTRC"
Option Explicit

Public Const Const_DOCTBL_TRCPREFIX As String = "DocTblTrc"

Public Const Const_DOCTBL_TRCSUMMARY_OVERALL As String = Const_DOCTBL_TRCPREFIX & "SummaryOverall"
Public Const Const_DOCTBL_TRCSUMMARY_BYDOC As String = Const_DOCTBL_TRCPREFIX & "SummaryByDoc"

Public Const Const_DOCTBL_TRCSUMMARY As String = Const_DOCTBL_TRCPREFIX & "Summary"
Public Const Const_DOCTBL_TRCRELATIONSHIPS As String = Const_DOCTBL_TRCPREFIX & "Relationships"
Public Const Const_DOCTBL_TRCRELATIONSHIPS_PREFIX As String = Const_DOCTBL_TRCRELATIONSHIPS & "_"
Public Const Const_DOCTBL_TRCRELATIONSHIPS_USED_PREFIX As String = Const_DOCTBL_TRCRELATIONSHIPS & "Used_"

Public Const Const_DOCTBL_TRCFROMJSTS As String = Const_DOCTBL_TRCPREFIX & "FromJSTs"
Public Const Const_DOCTBL_TRCTOJSTS As String = Const_DOCTBL_TRCPREFIX & "ToJSTs"

Public Const Const_TRCSUMMARY_BYDOC_TRCTYPE_COL As Integer = 3
Public Const Const_TRCSUMMARY_BYDOC_NUMCOLS As Integer = 5 ' number of columns to the right of the trace type column (inclusive)

Public Const Const_TRCREL_TRACEBKM_COLUMN As Integer = 2
Public Const Const_TRCREL_TRACEFROM_COLUMN As Integer = 4

Function UpdateDocTraceabilityTables(ByRef objdoc As Document, ByRef frm As Object) As Boolean
    '==================================================================================================================================
    ' Description: Entry point for the 'Update Traceability' function
    '==================================================================================================================================
    Dim strstatus As String
    
    If Dst.Document(objdoc.Fullname).Properties.TypeAbbr = "TRCR" Then
        strstatus = UpdateTRCTablesTRCRDoc(objdoc, frm)
    Else
        strstatus = UpdateTRCTablesSourceDoc(objdoc, frm)
    End If
    
    If strstatus = vbNullString And frm.GetResult = vbNullString Then UpdateDocTraceabilityTables = True
    frm.UpdateProgressText strstatus
        
End Function

Function ValidateDocTraceabilityTables(ByRef objdoc As Document, _
                                       Optional ByRef tblsum As Table, Optional ByRef tbltrc As Table, Optional ByRef tbljst As Table, _
                                       Optional ByVal blcheckchecksums As Boolean = False, Optional ByRef varstatusjsts As Variant, _
                                       Optional ByVal blcheckmissing As Boolean = False) As String
    '==================================================================================================================================
    ' Description: Entry point for TRC table validation function. If the checksum option was specified, the status is returned in the
    '              [varstatusjsts] parameter if it was specified, else it is returned as part of the instruction text. Refer to
    '              sub-functions below for a more detailed description of the validation rules.
    '==================================================================================================================================
    Dim strstatus As String, strstatusjsts As String
    
    If Dst.Document(objdoc.Fullname).Properties.TypeAbbr = "TRCR" Then
        strstatus = ValidateTablesTRCRDoc(objdoc, tblsum, tbltrc, tbljst, blcheckchecksums, strstatusjsts)
    Else
        strstatus = ValidateTablesSourdeDoc(objdoc, tblsum, tbltrc, tbljst, blcheckchecksums, strstatusjsts, blcheckmissing)
    End If
    
    ' add some instruction text
    If strstatus <> vbNullString Then
        strstatus = AddStatusText(strstatus, strstatusjsts)
        strstatus = AddStatusText(strstatus, "Run the 'Update Traceability' function to fix this.")
    ElseIf IsMissing(varstatusjsts) And strstatusjsts <> vbNullString Then
        strstatus = AddStatusText(strstatusjsts, "Run the 'Update Metrics' function to fix this.")
    ElseIf Not IsMissing(varstatusjsts) Then
        varstatusjsts = strstatusjsts
    End If
    
    ValidateDocTraceabilityTables = strstatus
End Function

Private Function ValidateTablesTRCRDoc(ByRef objdoc As Document, _
                                       Optional ByRef tblsum As Table, Optional ByRef tblbydoc As Table, Optional ByRef tbljst As Table, _
                                       Optional ByVal blcheckchecksums As Boolean = False, Optional ByRef strstatusjsts As String) As String
    '==================================================================================================================================
    ' Description: Validates the TRC tables for a TRC report (TRCR document):
    '              [-] Checks that the overall summary, summary by document and justification tables exist
    '              [-] Checks that the summary by document table has the correct columns defined (in case user edited this)
    '              [-] If requested, validates the checksums of these tables as well as each of the source document relationship tables.
    '                  NOTE: The status of the justifications table checksum is returned in the optional parameter.
    '==================================================================================================================================
    Dim strstatus As String, strtemp As String
    
    ' check that TRC tables exist
    Set tblsum = GetTable(objdoc, Const_DOCTBL_TRCSUMMARY_OVERALL, strstatus)
    Set tblbydoc = GetTable(objdoc, Const_DOCTBL_TRCSUMMARY_BYDOC, strtemp)
    strstatus = AddStatusText(strstatus, strtemp)
    Set tbljst = GetTable(objdoc, Const_DOCTBL_TRCTOJSTS, strtemp)
    strstatus = AddStatusText(strstatus, strtemp)
    
    ' check that all the tables exist
    If tblsum Is Nothing Or tblbydoc Is Nothing Or tbljst Is Nothing Then
        ValidateTablesTRCRDoc = strstatus
        Exit Function ' no point in continuing if tables don't exist
    Else
        ' NOTE: from here on assume that all three tables exist
        ' check that summary by document table has the right shape
        With tblbydoc
            If .Columns.Count <> 7 Then
                strstatus = "The '" & Const_DOCTBL_TRCSUMMARY_BYDOC & "' table does not have 7 columns"
            ElseIf GetCellText(.Cell(1, 1)) <> "Document" Or _
                   GetCellText(.Cell(1, 2)) <> "Section" Or _
                   GetCellText(.Cell(1, 3)) <> "Relationship" Or _
                   GetCellText(.Cell(1, 4)) <> "Total Items" Or _
                   GetCellText(.Cell(1, 5)) <> "Traced" Or _
                   GetCellText(.Cell(1, 6)) <> "Justified" Or _
                   GetCellText(.Cell(1, 7)) <> "Unresolved" Then
                strstatus = "The '" & Const_DOCTBL_TRCSUMMARY_BYDOC & "' table does not have column headings 'Document, Section, Relationship, Total Items, Traced, Justified, Unresolved'"
            End If
        End With
    End If
    
    ' check that checksum of TRC tables are unmodified
    If strstatus = vbNullString And blcheckchecksums Then
        strstatus = GetTRCTableChecksumStatus(objdoc, True, strstatusjsts)
    End If
    
    ValidateTablesTRCRDoc = strstatus
    
End Function

Private Function ValidateTablesSourdeDoc(ByRef objdoc As Document, _
                                         Optional ByRef tblsum As Table, Optional ByRef tbltrc As Table, Optional ByRef tbljst As Table, _
                                         Optional ByVal blcheckchecksums As Boolean = False, Optional ByRef strstatusjsts As String, _
                                         Optional ByVal blcheckmissing As Boolean = False) As String
    '==================================================================================================================================
    ' Description: Validates the TRC tables for a source document:
    '              [-] Checks that the summary, relationship and justification tables exist if the document has traceable bookmark types.
    '              [-] If requested, validates the checksums of these tables.
    '                  NOTE: The status of the justifications table checksum is returned in the optional parameter.
    '              [-] If requested, checks that each traceable bookmark is listed in the relationship table and that the table does
    '                  not list untraceable bookmarks.
    '==================================================================================================================================
    Dim strstatus As String, strtemp As String, docinfo As cDocInfo, dictrcprefixes As Scripting.Dictionary
    Dim varprefix As Variant, varbkm As Variant, idx As Integer, dicbkm As Scripting.Dictionary, cel As Cell
    
    ' check that TRC tables exist if document has any bookmarks that are defined in TRC types
    Set tblsum = GetTable(objdoc, Const_DOCTBL_TRCSUMMARY, strstatus)
    Set tbltrc = GetTable(objdoc, Const_DOCTBL_TRCRELATIONSHIPS, strtemp)
    strstatus = AddStatusText(strstatus, strtemp)
    Set tbljst = GetTable(objdoc, Const_DOCTBL_TRCFROMJSTS, strtemp)
    strstatus = AddStatusText(strstatus, strtemp)
    Set docinfo = Dst.Document(objdoc.Fullname)
    Set dictrcprefixes = Dst.TrcConfig.PrefixTracesDocType(docinfo.Properties.TypeAbbr)
    If dictrcprefixes.Count = 0 Then
        If Not tblsum Is Nothing Or Not tbltrc Is Nothing Or Not tbljst Is Nothing Then
            strstatus = "Documents of type '" & docinfo.Properties.TypeAbbr & "' do not have any traceability bookmark prefixes defined - " & _
                        "the sections containing the following bookmarks should be removed:" & vbCrLf & _
                        Const_DOCTBL_TRCSUMMARY & " and/or " & Const_DOCTBL_TRCRELATIONSHIPS & " and/or " & Const_DOCTBL_TRCFROMJSTS
        Else
            strstatus = vbNullString
        End If
    Else
        ' check that all the tables exist
        If tblsum Is Nothing Or tbltrc Is Nothing Or tbljst Is Nothing Then
            ValidateTablesSourdeDoc = strstatus
            Exit Function ' no point in continuing if tables don't exist
        End If
        ' NOTE: from here on assume that all three tables exist
        If tblsum.Rows.Count < 2 Then
            strstatus = "The '" & Const_DOCTBL_TRCSUMMARY & "' table does not have any entries"
        End If
        
        ' check that checksum of TRC tables are unmodified
        If blcheckchecksums Then
            strstatus = vbNullString
            For Each varprefix In dictrcprefixes
                If docinfo.Bookmarks.PrefixIsUsed(varprefix) Then
                    strstatus = GetTRCTableChecksumStatus(objdoc, False, strstatusjsts)
                    ' exit the loop
                    Exit For
                End If
            Next varprefix
        End If
        
        ' if there were no errors, check for missing entries in the TRC table
        If strstatus = vbNullString And blcheckmissing Then
            ' get the bookmarks listed in the table - assume that bookmark text and bookmark name is the same
            Set dicbkm = New Scripting.Dictionary
            For Each cel In tbltrc.Columns(2).Cells
                If cel.RowIndex > 1 Then
                    strtemp = GetCellText(cel)
                    If strtemp <> vbNullString Then dicbkm.Add strtemp, strtemp
                End If
            Next cel
            
            ' check that each bookmark in the table is in the document's traceable bookmark list
            strtemp = vbNullString
            idx = 0
            For Each varbkm In dicbkm
                idx = idx + 1
                If Not docinfo.Bookmarks.InternalTraceable.Exists(varbkm) Then
                    strtemp = strtemp & varbkm & ", "
                End If
            Next varbkm
            If strtemp <> vbNullString Then
                strstatus = "The following bookmarks are listed in the Traceability Relationships table, but are not traceable:" & vbCrLf & _
                            Left(strtemp, Len(strtemp) - 2) & vbCrLf ' strip off trailing ,
            End If
            strtemp = vbNullString
            
            ' check that each bookmark in the document's traceable bookmark list is referenced in the table
            For Each varbkm In docinfo.Bookmarks.InternalTraceable
                If Not dicbkm.Exists(varbkm) Then
                    strtemp = strtemp & varbkm & ", "
                End If
            Next varbkm
            If strtemp <> vbNullString Then
                strstatus = strstatus & "The following traceable bookmarks are not listed in the Traceability Relationships table:" & vbCrLf & _
                            Left(strtemp, Len(strtemp) - 2) & vbCrLf ' strip off trailing ,
            End If
        End If
    End If
    
    ValidateTablesSourdeDoc = strstatus
    
End Function

Function GetTRCTableChecksumStatus(ByRef objdoc As Document, ByVal bltrcreport As Boolean, Optional ByRef strstatusjsts As String, _
                                   Optional ByVal blincludereltables As Boolean = True) As String
    '==================================================================================================================================
    ' Description: Returns the status of the TRC related table checksums for the given TRCR or source document - the checksums of the
    '              relationship tables can be optionally excluded
    '==================================================================================================================================
    Dim strstatus As String, docinfo As cDocInfo, varitem As Variant, bkm As cDocBookmark, strjsttable As String
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    If bltrcreport Then
        strjsttable = Const_DOCTBL_TRCTOJSTS
        strstatus = ProcessTableChecksum(objdoc, Const_DOCTBL_TRCSUMMARY_OVERALL, False)
        strstatus = AddStatusText(strstatus, ProcessTableChecksum(objdoc, Const_DOCTBL_TRCSUMMARY_BYDOC, False, Const_TRCSUMMARY_BYDOC_TRCTYPE_COL, Const_TRCSUMMARY_BYDOC_NUMCOLS))
        ' check status of checksums for relationship tables as well if requested
        If blincludereltables Then
            For Each varitem In docinfo.Bookmarks.Internal
                Set bkm = docinfo.Bookmarks.Bookmark(varitem)
                If bkm.Name Like Const_DOCTBL_TRCRELATIONSHIPS_PREFIX & "*" Then
                    strstatus = AddStatusText(strstatus, ProcessTableChecksum(objdoc, bkm.Name, False))
                End If
            Next varitem
        End If
    Else
        strjsttable = Const_DOCTBL_TRCFROMJSTS
        strstatus = ProcessTableChecksum(objdoc, Const_DOCTBL_TRCSUMMARY, False)
        If blincludereltables Then
            strstatus = AddStatusText(strstatus, ProcessTableChecksum(objdoc, Const_DOCTBL_TRCRELATIONSHIPS, False))
        End If
    End If
    
    ' get the justifications table status
    If ProcessTableChecksum(objdoc, strjsttable, False) <> vbNullString Then
        strstatusjsts = "The traceability metrics summary table is out-of-date because the justifications were edited."
    End If
    
    GetTRCTableChecksumStatus = strstatus
End Function

Sub InsertTRCTraceAsHyperlink(ByRef rng As Range, ByVal strsourcedocrelative As String, ByVal strbookmark As String, ByVal strtext As String)
    '==================================================================================================================================
    ' Description: Inserts a hyperlink to the given bookmark at the given range and formats it accordingly
    '==================================================================================================================================
    rng.Hyperlinks.Add rng, strsourcedocrelative, strbookmark, , strtext
    rng.Style = "Hyperlink" ' ensure correct styling is applied
    rng.Font.Size = 7
End Sub

Function GetTraceTypeText(ByRef rng As Range, Optional ByRef strleftpart As String, Optional ByRef strmidpart As String, Optional ByRef strrightpart As String) As String
    '==================================================================================================================================
    ' Description: Returns the trace type text from a formatted trace type range. The function:
    '              [-] Assumes the range content was generated by the DST
    '              [-] Ignores brackets that may be part of the range
    '              [-] Caters for trace types with arrow symbols or plain text
    '==================================================================================================================================
    Dim colmatches As MatchCollection
    If Left(rng.Text, 1) = "(" Then rng.Start = rng.Start + 1 ' strips out brackets
    If Right(rng.Text, 1) = ")" Then rng.End = rng.End - 1
    If SplitIntoWords(rng.Text, colmatches) Then
        If colmatches.Count = 2 Then ' always two matches for arrows
            strleftpart = colmatches(0)
            strrightpart = colmatches(1)
            Set rng = rng.Words(2)
            With rng.Find
                .Text = ChrW(-3856) ' code for right arrow (left arrow code is -3857)
                .Execute
                If .Found Then
                    strmidpart = Dst.TrcConfig.TraceToIdentifier
                Else
                    ' assume it's a left arrow
                    strmidpart = Dst.TrcConfig.TraceFromIdentifier
                End If
            End With
        ElseIf colmatches.Count = 3 Then ' three matches for plain text
            strleftpart = colmatches(0)
            strmidpart = colmatches(1)
            strrightpart = colmatches(2)
        End If
        GetTraceTypeText = Trim(strleftpart & " " & strmidpart & " " & strrightpart)
    End If
End Function

Sub UpdateTRCTraceTypeWithArrowSymbol(ByRef tbl As Table, ByVal idxcol As Integer, ByVal bldirectionfrom As Boolean)
    '==================================================================================================================================
    ' Description: Converts plain trace type text so it uses an arrow symbol based on the given direction specified. This function
    '              uses the Range.Find object's replace method because inserting a symbol for each individual cell is very inefficient.
    '              Furthermore, only the given table column is processed using the Selection object. To improve performance even more,
    '              the appropriate symbol to insert is placed on the Clipboard so the Range.Find object can replace it directly from
    '              their.
    '==================================================================================================================================
    Dim rng As Range, lngsymbol As Long
    
    ' determine which arrow symbol to use
    If bldirectionfrom Then
        lngsymbol = 239 ' left arrow corresponds with 'from'
    Else
        lngsymbol = 240 ' right arrow corresponds with 'to'
    End If
        
    ' temporarily insert the symbol at the end of the document so we can get it on the clipboard
    Set rng = tbl.Range.Document.content
    rng.Collapse wdCollapseEnd
    rng.InsertSymbol lngsymbol, "Wingdings", True
    rng.End = rng.End + 1
    rng.Copy ' put it on the clipboard
    rng.Delete ' remove it again
    
    tbl.Columns(idxcol).Select ' only select the column of interest
    With Selection.Range.Find
        .ClearFormatting
        .Text = " " & IIf(bldirectionfrom, Dst.TrcConfig.TraceFromIdentifier, Dst.TrcConfig.TraceToIdentifier) & " "
        .MatchWholeWord = True
        .MatchCase = True
        With .Replacement
            .ClearFormatting
            .Text = " ^c " ' this takes the content from the clipboard
        End With
        .Execute Replace:=wdReplaceAll
    End With
End Sub
Attribute VB_Name = "basTRCJustifications"
Option Explicit

Sub ManageTRCJustificationsTable(ByRef tbljst As Table, ByVal strtable As String, ByRef jsttrcnew As Scripting.Dictionary, _
                                 ByRef jsttrccur As Scripting.Dictionary, ByVal blreplacetable As Boolean, ByRef jstrefscur As Scripting.Dictionary, _
                                 frm As Object)
    '==================================================================================================================================
    ' Description: Manages the insertion of a new justifications table or the partial update of an existing table. The justification
    '              table to update or replace is specified by the [tbljst] parameter. For partila updates, this function removes those
    '              justification rows that are no longer referenced.
    '==================================================================================================================================
    Dim rng As Range, tblnew As Table, rw As Row, strmessage As String, strtext As String
    Dim varjstbkmark As Variant
    
    ' insert new table if required
    If blreplacetable Then
        ' move to start of caption of existing JST table and insert new table
        Set rng = tbljst.Range
        rng.MoveStart wdParagraph, -1
        rng.SetRange rng.Start, rng.Start
        rng.InsertParagraphAfter ' to allow new table to be created
        rng.Collapse wdCollapseStart
        rng.Style = "Body Text"
        strmessage = InsertJustificationsTable(rng, jsttrcnew, jsttrccur, "Justifications for Traceability Exceptions", strtable, "Item Not Traced", frm)
        If strmessage = vbNullString Then Set tblnew = GetTable(rng.Document, strtable)
        
        ' delete existing justifications table and the empty paragraph above it
        Set rng = tbljst.Range
        rng.MoveStart wdParagraph, -2
        rng.Delete
    Else
        ' this is a partial update, so point to the existing table
        frm.UpdateProgressText "Adding new justifications to the " & strtable & " table..."
        Set tblnew = GetTable(tbljst.Range.Document, strtable)
        
        ' add new justifications to the table
        For Each varjstbkmark In jsttrcnew
            If Not jsttrccur.Exists(varjstbkmark) Then ' if it does not exist yet
                Set rw = tblnew.Rows.Add
                Call UpdateJustificationRow(rw, varjstbkmark, jsttrcnew(varjstbkmark), jsttrccur)
            End If
        Next varjstbkmark
        
        ' remove justification bookmarks that are no longer referenced (used)
        For Each varjstbkmark In jstrefscur
            If Not jsttrcnew.Exists(varjstbkmark) Then
                If tblnew.Range.Bookmarks.Exists(varjstbkmark) Then
                    tblnew.Range.Bookmarks(varjstbkmark).Range.Rows(1).Delete
                End If
            End If
        Next varjstbkmark
    
        ' warn user if there are unresolved justifications
        strtext = NotifyUnresolvedJustifications(tblnew)
        If strtext <> vbNullString Then frm.UpdateProgressText strtext
    End If
    
    If strmessage = vbNullString Then
        ' point to the (new) justifications table
        Set tbljst = tblnew
    
        ' update the trace type text
        Call UpdateTRCTraceTypeWithArrowSymbol(tbljst, 1, IIf(strtable = Const_DOCTBL_TRCFROMJSTS, True, False))
        
        ' update table checksum
        Call ProcessTableChecksum(tbljst.Range.Document, strtable, True)
    Else
        frm.LogResult strmessage
    End If
End Sub

Function GetTRCJustificationBookmark(ByVal strjstprefix As String, ByVal strtracetype As String, ByVal strbookmark As String) As String
    '==================================================================================================================================
    ' Description: Generates a unique justification bookmark name for the given bookmark to ensure that the name does not exceed the 39
    '              character length limit. This is achieved by calculating a CRC checksum of the bookmark name and prepending the
    '              justification bookmark prefix and the trace type.
    '==================================================================================================================================
    GetTRCJustificationBookmark = strjstprefix & Replace(strtracetype, " ", "_") & "_" & StringCRC32(strbookmark)
End Function
Attribute VB_Name = "basTRCReport"
Option Explicit

Function UpdateTRCTablesTRCRDoc(ByRef objdoc As Document, ByRef frm As Object) As String
    '==================================================================================================================================
    ' Description: This is the main function for updating the TRC information in a TRCR document.
    '              [-] The function first validates the traceability tables of the TRCR document followed by the validation of the
    '                  traceability information in each source document specified by the TRC document list. The source documents must
    '                  all be up-to-date as far as the traceability status is concerned.
    '              [-] If the validation passed, the function determines the list of source documents to process. Using these documents
    '                  the function:
    '                  * Transfers the 'trace from' information directly from each source document into the TRCR document - this
    '                    includes the relationship table and the related summary table entries
    '                  * Stores the existing justifications for later use
    '                  * Adds the inverse relationships information for each source document to the TRCR document
    '                  * Adds new justification information to the justifications table and removes justifications no longer referenced
    '                  * Updates the inverse summary information in the relevant summary by document table for each source document
    '                  * Inserts a new overall summary table
    '                  * Cleans up sub-sections and related document variables in case entries were removed from the TRC document list.
    '              [-] The function will only process source documents that have changed. Some logic is applied to add additional
    '                  documents to this list to ensure that the 'trace to' information is complete.
    '              [-] If any of the intermediate steps in this process fail, the processing is discontinued.
    '==================================================================================================================================
    Dim tblsum As Table, tblbydoc As Table, tbljst As Table, strstatus As String
    Dim processlist As Scripting.Dictionary, dictraceto As Scripting.Dictionary
    Dim doctrcrinfo As cDocInfo, vardoc As Variant, docsrcinfo As cDocInfo
    Dim jsttrccur As Scripting.Dictionary, jsttrcnew As Scripting.Dictionary, jstrefscur As Scripting.Dictionary
    
    frm.UpdateProgressText "Validating the traceability related tables..."
    strstatus = ValidateDocTraceabilityTables(objdoc, tblsum, tblbydoc, tbljst) ' checksums are checked later
    If Not tblsum Is Nothing And Not tblbydoc Is Nothing And Not tbljst Is Nothing Then
        strstatus = vbNullString
        
        ' check that each source document's TRC info is up-to-date
        frm.UpdateProgressText "Checking that that traceability information in the source documents are up-to-date..."
        Set doctrcrinfo = Dst.Document(objdoc.Fullname)
        
        ' inform user which documents in document list will not be processed
        For Each vardoc In doctrcrinfo.DocList.TrcDocumentsNotValid
            Set docsrcinfo = Dst.Document(vardoc)
            frm.UpdateProgressText "WARNING: Skipping invalid document '" & vardoc & "' - use the 'Document List' function to add valid or remove invalid entries"
        Next vardoc
    
        For Each vardoc In doctrcrinfo.DocList.TrcDocuments
            Set docsrcinfo = Dst.Document(vardoc)
            frm.UpdateProgressText "  [-] Validating tables for '" & docsrcinfo.Properties.Shortname & "'..."
            If ValidateDocTraceabilityTables(docsrcinfo.Document, , , , True, , True) <> vbNullString Then
                frm.LogResult "Run the 'Update Traceability' function for '" & docsrcinfo.Properties.Fullname & "' first."
            End If
        Next vardoc
        
        If frm.GetResult = vbNullString Then
            ' initialise the dictionary for the pivot/trace to info as well as the dictionary of 'trace to' justification references
            Set dictraceto = New Scripting.Dictionary
            Set jstrefscur = New Scripting.Dictionary
                
            ' get the list of documents to generate TRC information for
            Set processlist = GetTRCProcessList(doctrcrinfo, tblbydoc, dictraceto, jstrefscur, frm)
            
            ' process the generate list
            If processlist.Count = 0 Then
                frm.UpdateProgressText "INFO: Tables in source traceability documents are unchanged - no changes made to this TRCR document"
            Else
                frm.UpdateProgressText vbCrLf & "NOTE: This could take a while to complete - DO NOT use the Clipboard and don't try and edit documents during the process" & vbCrLf
                ' insert the 'trace from' relationship tables
                For Each vardoc In processlist
                    Set docsrcinfo = Dst.Document(vardoc)
                    If frm.GetResult = vbNullString Then
                        frm.UpdateProgressText "Transferring TRC info from '" & docsrcinfo.Properties.Shortname & "'..."
                        Call TransferTRCInfoFromSource(doctrcrinfo, docsrcinfo, dictraceto, tblbydoc, frm)
                    End If
                Next vardoc
            
                ' process the inverse relationships and store the justifications
                If frm.GetResult = vbNullString Then
                    ' store the existing justifications for traceability exceptions
                    frm.UpdateProgressText "Storing existing justifications..."
                    Set jsttrcnew = New Scripting.Dictionary
                    Set jsttrccur = New Scripting.Dictionary
                    Call StoreJustificationBookmarks(tbljst.Range, Const_JST_BMRK_PREFIX_TRCTO_EXCEPTION, jsttrccur)
                
                    ' update each relationship table with the additional 'trace to' information
                    For Each vardoc In processlist
                        Set docsrcinfo = Dst.Document(vardoc)
                        If frm.GetResult = vbNullString Then
                            frm.UpdateProgressText "Processing inverse TRC relationships for '" & docsrcinfo.Properties.Shortname & "'..."
                            Call ProcessInverseTRCRelationships(doctrcrinfo, docsrcinfo, dictraceto(vardoc), jsttrcnew, tblbydoc, frm)
                            If frm.GetResult = vbNullString Then
                                ' update checksum for each source document relationship table and checksum of table used
                                Call ProcessTableChecksum(objdoc, Const_DOCTBL_TRCRELATIONSHIPS_PREFIX & docsrcinfo.Properties.Basename)
                                doctrcrinfo.Variables.TableChecksum(Const_DOCTBL_TRCRELATIONSHIPS_USED_PREFIX & docsrcinfo.Properties.Basename) = _
                                            docsrcinfo.Variables.TableChecksum(Const_DOCTBL_TRCRELATIONSHIPS)
                               End If
                        End If
                    Next vardoc
                End If
                
                If frm.GetResult = vbNullString Then
                    ' insert new JST table and transfer existing justifications
                    Call ManageTRCJustificationsTable(tbljst, Const_DOCTBL_TRCTOJSTS, jsttrcnew, jsttrccur, (processlist.Count = doctrcrinfo.DocList.TrcDocuments.Count), jstrefscur, frm)
                End If
                    
                ' update the summary tables
                frm.UpdateProgressText "Processing inverse TRC summaries..."
                For Each vardoc In processlist
                    Set docsrcinfo = Dst.Document(vardoc)
                    If frm.GetResult = vbNullString Then
                        frm.UpdateProgressText "  [-] Adding rows for '" & docsrcinfo.Properties.Shortname & "'..."
                        Call ProcessTRCRInverseSummaries(doctrcrinfo, docsrcinfo, dictraceto(vardoc), tblbydoc, tbljst, frm)
                    End If
                Next vardoc
                
                ' ACZ
                ' build a summary process list for documents not in above process rel list - do this earlier, but use it here
                '   [-] check if source summary table is changed - store source summary table as used checksum to compare
                ' for entries in list:
                '   [-] build a new input cTrcDocTraces object from summary table in source document
                '   [-] call ProcessTRCRInverseSummaries
                '   [-] update used checksum document variable:
                '       doctrcrinfo.Variables.TableChecksum(Const_DOCTBL_TRCSUMMARY_USED_PREFIX & docsrcinfo.Properties.Basename) = _
                '                            docsrcinfo.Variables.TableChecksum(Const_DOCTBL_TRCSUMMARY)
                ' update RemoveOrphanedSourceEntries() for new docvar entry
                ' ACZ
                    
                ' update summary by document table arrows, checksum and overall summary table
                If frm.GetResult = vbNullString Then
                    Call UpdateTRCTraceTypeWithArrowSymbol(tblbydoc, Const_TRCSUMMARY_BYDOC_TRCTYPE_COL, False) ' only 'to' because 'from' rows already done in source
                    Call ProcessTableChecksum(objdoc, Const_DOCTBL_TRCSUMMARY_BYDOC, True, Const_TRCSUMMARY_BYDOC_TRCTYPE_COL, Const_TRCSUMMARY_BYDOC_NUMCOLS)
                    frm.UpdateProgressText "Updating overall TRC summary table..."
                    Call InsertTRCROverallSummaryTable(doctrcrinfo, tblsum, tblbydoc, frm)
                End If
                
                ' do clean-up
                If frm.GetResult = vbNullString Then
                    frm.UpdateProgressText "Removing orphaned entries..."
                    Call RemoveOrphanedSourceEntries(doctrcrinfo, frm)
                End If
                
                If strstatus = vbNullString And frm.GetResult = vbNullString Then frm.UpdateProgressText "Traceability tables were updated successfully."
            End If
        End If
    End If
    
    UpdateTRCTablesTRCRDoc = strstatus
    
End Function

Private Function GetTRCProcessList(ByRef doctrcrinfo As cDocInfo, ByRef tblbydoc As Table, ByRef dictraceto As Scripting.Dictionary, _
                                   ByRef jstrefscur As Scripting.Dictionary, ByRef frm As Object) As Scripting.Dictionary
    '==================================================================================================================================
    ' Description: Returns a list of documents to process for TRC information.
    '              [-] The function takes into account whether local tables were modified by hand and whether tables in source
    '                  documents changed.
    '              [-] The function also adds those documents to the list that are listed in 'trace from' relationships to ensure that
    '                  all the inverse TRC information is included.
    '              [-] If any local relationship table is deemed modified by hand, all the TRC information must be regenerated to
    '                  maintain integrity.
    '              [-] If all TRC documents are in the process list, the functions cleans out all the subsections and related document
    '                  variables to ensure that no "orphaned" TRC information remains behind.
    '              [-] The function returns:
    '                  * The current 'trace to' information for each document not in the process list
    '                  * The list of 'trace to' justifications referenced in each source document relationship table.
    '==================================================================================================================================
    Dim processlist As Scripting.Dictionary, docsrcinfo As cDocInfo, vardoc As Variant, strfilename As String
    Dim blprocessall As Boolean
    
    Set processlist = New Scripting.Dictionary
    
    ' determine if any tables were modified by hand
    frm.UpdateProgressText "Building list of documents to process..."
    If GetTRCTableChecksumStatus(doctrcrinfo.Document, True, , False) <> vbNullString Then
        ' update all documents in TRC list
        frm.UpdateProgressText "  [-] One or more summary tables were modified by hand"
        blprocessall = True
    Else
        ' only add changed TRC documents to the process list
        For Each vardoc In doctrcrinfo.DocList.TrcDocuments
            Set docsrcinfo = Dst.Document(vardoc)
            ' check that local relationship table was not modified by hand - if so, exit immediately
            If ProcessTableChecksum(doctrcrinfo.Document, Const_DOCTBL_TRCRELATIONSHIPS_PREFIX & docsrcinfo.Properties.Basename, False) <> vbNullString Then
                frm.UpdateProgressText "  [-] Local relationship table for '" & docsrcinfo.Properties.Shortname & "' modified by hand, so 'trace to' information cannot be derived"
                blprocessall = True
                Exit For
            ' add document to the list if the source document's relationship table checksum differs to the one used to generate the corresponding table
            ElseIf docsrcinfo.Variables.TableChecksum(Const_DOCTBL_TRCRELATIONSHIPS) <> _
               doctrcrinfo.Variables.TableChecksum(Const_DOCTBL_TRCRELATIONSHIPS_USED_PREFIX & docsrcinfo.Properties.Basename) Then
                strfilename = docsrcinfo.Properties.Fullname
                processlist.Add strfilename, strfilename
                frm.UpdateProgressText "  [-] Adding '" & docsrcinfo.Properties.Shortname & "' because source document was updated"
            End If
        Next vardoc
        
        If processlist.Count > 0 And Not blprocessall Then
            ' process the source document relationship tables in the local document for each entry in the process list to add
            ' additional documents to the list - this also updates the current list of 'trace to' justification references
            Call UpdateListsFromRelationshipTables(doctrcrinfo, processlist, dictraceto, jstrefscur, frm)
        End If
    End If

    ' check if the list includes all the documents anyway
    If CompareDictionaries(processlist, doctrcrinfo.DocList.TrcDocuments) Then
        frm.UpdateProgressText "  [-] The generate list includes all the entries in the TRC Document List"
        blprocessall = True
    End If

    ' check if we need to do a complete re-generation - note we retain the order as per the summary table
    If blprocessall Then
        frm.UpdateProgressText "  [-] Re-generating TRC info for all documents in the list..."
        ' add all the TRC documents to the list - remove items that may have been added above
        dictraceto.RemoveAll ' we don't need this if all documents are in the list
        processlist.RemoveAll
        For Each vardoc In doctrcrinfo.DocList.TrcDocuments
            processlist.Add vardoc, vardoc
        Next vardoc
        
        ' remove entire range below summary table
        Call RemoveRangeBelowTable(tblbydoc)
        
        ' remove all table checksums related to the source documents
        doctrcrinfo.Variables.DeleteAllOfType enumDocVariableTypeTableChecksum, Const_DOCTBL_TRCRELATIONSHIPS_PREFIX
        doctrcrinfo.Variables.DeleteAllOfType enumDocVariableTypeTableChecksum, Const_DOCTBL_TRCRELATIONSHIPS_USED_PREFIX
    End If

    Set GetTRCProcessList = SortDictionary(processlist)
End Function

Private Sub UpdateListsFromRelationshipTables(ByRef doctrcrinfo As cDocInfo, ByRef processlist As Scripting.Dictionary, _
                                              ByRef dictraceto As Scripting.Dictionary, ByRef jstrefscur As Scripting.Dictionary, ByRef frm As Object)
    '==================================================================================================================================
    ' Description: Takes the given process list and determines which additional documents need to be added to the list based on the
    '              logic described below, but only if they are in the document list.
    '              [-] For each source document in the process list, parses the source document's relationship table and adds the
    '                  referenced 'trace from' documents to the process list.
    '              [-] For each source document in the process list, parses the local relationship table and:
    '                  * For 'trace to' justitications, adds the bookmark reference to the given justification reference dictionary
    '                  * For 'trace from' relationships, adds the referenced document to the process list - this ensures that documents
    '                    with traces that might have been removed are also processed
    '                  * For 'trace to' relationships, adds the traces to the given 'trace to' dictionary
    '                    NOTE: Only 'trace to' relationships from documents that are not in the process list are added to the 'trace to'
    '                          dictionary - this ensures that the 'trace to' information is retained, because the source document
    '                          related to these traces is not in the generate list.
    '==================================================================================================================================
    Dim tbl As Table, celbkm As Cell, celref As Cell, celend As Cell, hlnk As Hyperlink, strtracetype As String
    Dim strfilename As String, strprefix As String, strtracefilename As String, docsrcinfo As cDocInfo
    Dim trcdoc As cTrcDocTraces, trc As cTrace, bkm As cDocBookmark, trcitem As cTracedItem
    Dim vardoc As Variant, vartrc As Variant, vartrcitem As Variant, docsprocessed As Scripting.Dictionary
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    Set docsprocessed = New Scripting.Dictionary
    
    For Each vardoc In processlist
        Set docsrcinfo = Dst.Document(vardoc)
        docsprocessed.Add docsrcinfo.Properties.Fullname, vbNullString ' to keep track of which entries were processed in this function
                
        ' process relationship table in source document
        Set tbl = GetTable(docsrcinfo.Document, Const_DOCTBL_TRCRELATIONSHIPS) ' assume table exists because TRC validation passed
        For Each celref In tbl.Columns(Const_TRCREL_TRACEFROM_COLUMN).Cells
            ' get absolute path of address referred to by 'trace from' hyperlink
            If celref.Range.Hyperlinks.Count = 1 Then
                strfilename = fso.GetAbsolutePathName(fso.BuildPath(docsrcinfo.Properties.Path, celref.Range.Hyperlinks(1).Address))
                If Not processlist.Exists(strfilename) And doctrcrinfo.DocList.TrcDocuments.Exists(strfilename) Then
                    processlist.Add strfilename, strfilename
                    frm.UpdateProgressText "  [-] Adding '" & fso.GetFileName(strfilename) & "' because it's referenced from '" & docsrcinfo.Properties.Shortname & "'"
                End If
            End If
        Next celref
        
        ' process local relationship table in TRCR document
        Set tbl = GetTable(doctrcrinfo.Document, Const_DOCTBL_TRCRELATIONSHIPS_PREFIX & docsrcinfo.Properties.Basename) ' assume table exists
        For Each celbkm In tbl.Columns(Const_TRCREL_TRACEBKM_COLUMN).Cells
            If celbkm.RowIndex > 1 Then ' skip header row
                ' entry in 2nd cell is now the 'to' trace
                Set hlnk = celbkm.Range.Hyperlinks(1)
                Set bkm = New cDocBookmark
                bkm.Name = hlnk.SubAddress
                bkm.Prefix = Dst.BookmarkConfig.PrefixFromName(bkm.Name)
                bkm.SourceDocument = hlnk.Address
                Set trc = New cTrace
                Set trc.Item = bkm
                strfilename = fso.GetAbsolutePathName(fso.BuildPath(doctrcrinfo.Properties.Path, bkm.SourceDocument))
                
                ' entries in 4th cell are now the item sources, so add entry in 2nd cell as 'trace to' relationship
                Set celref = celbkm
                Set celend = GetSubSectionLastCell(celbkm)
                Do
                    Set celref = celref.Next.Next
                    Set hlnk = celref.Range.Hyperlinks(1)
                    If hlnk.SubAddress Like Const_JST_BMRK_PREFIX_TRCTO_EXCEPTION & "*" Then
                        jstrefscur.Add hlnk.SubAddress, vbNullString ' no need to test existence, JTSs have one-to-one relationships
                    ElseIf Not hlnk.SubAddress Like Const_JST_BMRK_PREFIX_TRCFROM_EXCEPTION & "*" Then ' skip 'trace from' justifications
                        strprefix = Dst.BookmarkConfig.PrefixFromName(hlnk.SubAddress)
                        strtracefilename = fso.GetAbsolutePathName(fso.BuildPath(doctrcrinfo.Properties.Path, hlnk.Address))
                        If Dst.TrcConfig.PrefixTrace(trc.Item.Prefix).FromPrefixes.Exists(strprefix) Then
                            ' it's a 'trace from' relationship - this ensures that documents with traces that might have been removed are processed
                            If Not processlist.Exists(strtracefilename) And doctrcrinfo.DocList.TrcDocuments.Exists(strtracefilename) Then
                                processlist.Add strtracefilename, strtracefilename
                                frm.UpdateProgressText "  [-] Adding '" & fso.GetFileName(strtracefilename) & "' because it used to be referenced from '" & docsrcinfo.Properties.Shortname & "'"
                            End If
                        Else
                            ' assume it's a 'trace to' relationship
                            Set trcitem = New cTracedItem
                            trcitem.Bookmark = hlnk.SubAddress
                            trcitem.SourceDocument = hlnk.Address
                            trcitem.TraceType = Dst.TrcConfig.TraceTypeText(trc.Item.Prefix, False, strprefix)
                            trc.Add trcitem
                        End If
                    End If
                Loop Until celref.RowIndex = celend.RowIndex ' while reference is related to bookmark
                
                ' if there are 'to' traces, add them to the dictionary
                If trc.TracedItems.Count > 0 Then
                    If Not dictraceto.Exists(strfilename) Then
                        Set trcdoc = New cTrcDocTraces
                        trcdoc.Init docsrcinfo, Dst.TrcConfig, False
                        dictraceto.Add strfilename, trcdoc
                    End If
                    Set trcdoc = dictraceto(strfilename)
                    trcdoc.Add trc
                End If
            End If
        Next celbkm
    Next vardoc
    
    ' remove entries from the 'trace to' dictionary if the traced document is in the generate list
    For Each vardoc In dictraceto
        Set trcdoc = dictraceto(vardoc)
        For Each vartrc In trcdoc.Traces
            Set trc = trcdoc.Trace(vartrc)
            For Each vartrcitem In trc.TracedItems
                Set trcitem = trc.TracedItem(vartrcitem)
                strfilename = fso.GetAbsolutePathName(fso.BuildPath(doctrcrinfo.Properties.Path, trcitem.SourceDocument))
                If processlist.Exists(strfilename) Then
                    ' remove entry
                    trc.TracedItems.Remove vartrcitem
                End If
            Next vartrcitem
        Next vartrc
        ' if there are no traces left, remove entry from dictionary
        If trcdoc.TotalTraceCount = 0 Then
            dictraceto.Remove vardoc
        Else
            frm.UpdateProgressText "  [-] Stored existing 'trace to' relationships for '" & fso.GetFileName(vardoc) & "'"
        End If
    Next vardoc

    ' check that all 'trace to' justifications were added, because some documents may have been added to the list during processing above
    For Each vardoc In processlist
        Set docsrcinfo = Dst.Document(vardoc)
        If Not docsprocessed.Exists(docsrcinfo.Properties.Fullname) Then
            Set tbl = GetTable(doctrcrinfo.Document, Const_DOCTBL_TRCRELATIONSHIPS_PREFIX & docsrcinfo.Properties.Basename)
            If Not tbl Is Nothing Then ' table might not exist yet
                For Each celref In tbl.Columns(Const_TRCREL_TRACEFROM_COLUMN).Cells
                    If celref.RowIndex > 1 Then ' skip first row
                        Set hlnk = celref.Range.Hyperlinks(1)
                        If hlnk.SubAddress Like Const_JST_BMRK_PREFIX_TRCTO_EXCEPTION & "*" Then
                            jstrefscur.Add hlnk.SubAddress, vbNullString
                        End If
                    End If
                Next celref
            End If
        End If
    Next vardoc

    Set processlist = SortDictionary(processlist)
End Sub
                
Private Sub TransferTRCInfoFromSource(ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, ByRef dictraceto As Scripting.Dictionary, _
                                      ByRef tblbydoc As Table, ByRef frm As Object)
    '==================================================================================================================================
    ' Description: Transfers the 'trace from' information from the source document to the TRCR document:
    '              [-] Prepares the relevant summary by document entry
    '              [-] Prepares the relevant sub-section
    '              [-] Transfers the relationship table from the source document as-is
    '              [-] Updates the hyperlink addresses so they are relative to the TRCR document
    '              [-] Transfers the summary table rows from the source document to the summary by document table
    '              [-] Builds the inverse TRC relationships and adds them to the 'trace to' dictionary
    '==================================================================================================================================
    Dim celsum As Cell, rngrel As Range, tblrel As Table, strmessage As String
    
    ' get entry in summary by document table for source document and prepare it
    frm.UpdateProgressText "  [-] Preparing summary table row..."
    Set celsum = PrepareTRCRSummaryByDocTableRow(doctrcrinfo, docsrcinfo, tblbydoc)
    
    ' get sub-section for source document's relationship table and prepare it
    frm.UpdateProgressText "  [-] Preparing relationship section..."
    strmessage = PrepareRelationshipSection(doctrcrinfo, docsrcinfo, tblbydoc, rngrel)
    If strmessage = vbNullString Then
        ' copy relationship table and caption from source document
        frm.UpdateProgressText "  [-] Transferring relationship table..."
        strmessage = TransferRelationshipTable(rngrel, doctrcrinfo, docsrcinfo, tblrel)
    End If
    
    If strmessage = vbNullString Then
        ' update all hyperlink addresses in table to be relative to TRCR document
        frm.UpdateProgressText "  [-] Updating hyperlinks in relationship table..."
        Call UpdateHyperlinkAddresses(tblrel, doctrcrinfo, docsrcinfo)
        
        ' copy metrics summary values from source document to summary by document table - adding rows as necessary, also add section references
        frm.UpdateProgressText "  [-] Transferring summary table rows..."
        strmessage = TransferTRCRSummaryTableRows(celsum, docsrcinfo, rngrel)
    End If
    
    If strmessage = vbNullString Then
        ' build the inverse relationships from the 'trace from' entries and add them to the dictionary
        frm.UpdateProgressText "  [-] Building inverse relationships from relationship table..."
        strmessage = BuildInverseRelationshipsFromTable(tblrel, doctrcrinfo, docsrcinfo, dictraceto)
    End If
    
    If strmessage <> vbNullString Then frm.LogResult docsrcinfo.Properties.Shortname & ": " & strmessage
End Sub

Private Sub ProcessInverseTRCRelationships(ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, ByRef trcdoc As cTrcDocTraces, _
                                           ByRef jsttrcnew As Scripting.Dictionary, ByRef tblbydoc As Table, ByRef frm As Object)
    '==================================================================================================================================
    ' Description: Inserts the 'trace to' rows in the given relationship table and returns the new justifications that need to be added
    '              to the justifications table later
    '==================================================================================================================================
    Dim tbl As Table, hlnk As Hyperlink, strmessage As String
    Dim strbookmark As String, trc As cTrace, varitem As Variant, trcitem As cTracedItem, dictracetotypes As Scripting.Dictionary
    Dim trcpref As cTrcPrefixConfig, varprefix As Variant, strjstbookmark As String, strtracetype As String
    Dim celhdg As Cell, celbkm As Cell, celref As Cell, cel As Cell, celprev As Cell
    
    ' locate relationship table (assume it exists) and cycle through each trace item - note the table and the document traces object should be in sync
    frm.UpdateProgressText "  [-] Adding inverse trace rows..."
    Set tbl = GetTable(doctrcrinfo.Document, Const_DOCTBL_TRCRELATIONSHIPS_PREFIX & docsrcinfo.Properties.Basename)
    For Each celbkm In tbl.Columns(Const_TRCREL_TRACEBKM_COLUMN).Cells
        If celbkm.RowIndex > 1 Then ' skip header row
            frm.UpdateProgressMeter celbkm.RowIndex, tbl.Rows.Count
            Set hlnk = celbkm.Range.Hyperlinks(1)
            strbookmark = hlnk.SubAddress
            If trcdoc.Traces.Exists(strbookmark) Then
                Set trc = trcdoc.Trace(strbookmark) ' this points to the 'trace to' info for the bookmark
                
                ' build a list of all 'trace to' types for the item - as items are traced below, the trace type entries are removed from this dictionary
                Set trcpref = Dst.TrcConfig.PrefixTrace(trc.Item.Prefix)
                Set dictracetotypes = New Scripting.Dictionary
                For Each varprefix In trcpref.ToPrefixes
                    strtracetype = Dst.TrcConfig.TraceTypeText(trcpref.Prefix, False, varprefix)
                    If Not dictracetotypes.Exists(strtracetype) Then dictracetotypes.Add strtracetype, vbNullString
                Next varprefix
                
                ' process each of the traced items
                Set celref = GetSubSectionLastCell(celbkm) ' returns the last cell in the range of references
                For Each varitem In trc.TracedItems
                    Set trcitem = trc.TracedItem(varitem)
                    strtracetype = trcitem.TraceType
                    
                    ' insert new TRC row
                    Set celref = InsertTraceRowBelow(celref, strtracetype, trcitem.SourceDocument, trcitem.Bookmark, trcitem.Bookmark)
                    
                    ' remove trace type entry for valid traces
                    If dictracetotypes.Exists(strtracetype) Then dictracetotypes.Remove strtracetype
                Next varitem
                            
                ' the trace types remaining in the dictionary need to be justified
                For Each varitem In dictracetotypes
                    strtracetype = varitem
                    
                    ' determine JST bookmark name - use checksums to ensure names don't go beyond length limit
                    strjstbookmark = GetTRCJustificationBookmark(Const_JST_BMRK_PREFIX_TRCTO_EXCEPTION, strtracetype, strbookmark)
                    
                    ' add the justified trace to the object
                    Set trcitem = New cTracedItem
                    trcitem.Bookmark = strjstbookmark
                    trcitem.SourceDocument = doctrcrinfo.Properties.Shortname
                    trcitem.TraceType = strtracetype
                    trc.Add trcitem
                    
                    ' insert justification row - JST bookmark is stored in this TRCR document, so shortname is already relative path)
                    Set celref = InsertTraceRowBelow(celref, strtracetype, trcitem.SourceDocument, trcitem.Bookmark, "Trace Exception")
                    
                    ' add bookmark of item that needs justification to new dictionary - note that the text is the original bookmark name
                    jsttrcnew.Add strjstbookmark, strbookmark & JSTTypeText(strtracetype)
                Next varitem
                                
                ' restore line style as it was set to none above
                Call MergeCells(celbkm, celref.Previous.Previous)
            Else
                strmessage = AddStatusText(strmessage, "Could not find 'trace to' entry in dictionary for bookmark " & strbookmark)
            End If
        End If
    Next celbkm
    
    ' (re)merge heading number cells
    frm.UpdateProgressText "  [-] Merging heading number cells..."
    For Each cel In tbl.Columns(1).Cells
        If cel.RowIndex > 1 Then
            If GetCellText(cel) <> vbNullString Then
                ' new heading number, so merge up to previous cell (if set and if there are merged cells)
                Call MergeCells(celhdg, celprev)
                Set celhdg = cel ' new heading cell
            End If
            Set celprev = cel ' previous cell
        End If
    Next cel
    Call MergeCells(celhdg, celprev)
    
    ' update trace type arrows - only 'to' because 'from' already done in source
    frm.UpdateProgressText "  [-] Updating trace type with arrows..."
    Call UpdateTRCTraceTypeWithArrowSymbol(tbl, Const_TRCREL_TRACEFROM_COLUMN - 1, False)
    
    frm.UpdateProgressMeter (-1)
    
    If strmessage <> vbNullString Then frm.LogResult docsrcinfo.Properties.Shortname & ": " & strmessage

End Sub

Private Function PrepareRelationshipSection(ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, ByRef tblbydoc As Table, _
                                            ByRef rngrel As Range) As String
    '==================================================================================================================================
    ' Description: Searches for the relevant sub-section within the section below the given summary table. If it does not exist, adds a
    '              new sub-section at the end of the section. The function ensures that the sub-section consists of only an empty
    '              paragraph and updates the range argument to point to this paragraph.
    '==================================================================================================================================
    Dim rng As Range, rngbelow As Range, tbl As Table, idx As Integer, intlevel As Integer, strmessage As String
    
    ' point to the range below the summary by document table and get the level index of the table's section
    Set rngbelow = GetRangeBelowTable(tblbydoc)
    intlevel = GetHeadingListLevelNumber(tblbydoc.Range)
    
    ' find insertion point for source document sub-section and clear it out - add new sub-section at end of range if it does not exist
    Set rng = GetHeadingRangeExtendedFromText(rngbelow, docsrcinfo.Properties.Shortname, , strmessage)
    If strmessage = vbNullString Then
        If rng Is Nothing Then
            Set rng = rngbelow
            ' if there's nothing below given table or if section ends with a table, take special care so we don't shift existing headings down
            If rng.Start = rng.End Or rng.Paragraphs.Last.Range.Tables.Count > 0 Then
                If rng.Start = rng.End Then
                    Set tbl = tblbydoc ' nothing below table, so insert below summary by document table
                Else
                    Set tbl = rng.Paragraphs.Last.Range.Tables(1) ' insert below table last table
                End If
                Set rng = InsertParagraphAfterTable(tbl)
            Else
                rng.End = rng.End - 1
                rng.InsertParagraphAfter
                rng.Collapse wdCollapseEnd
            End If
            Set rng = InsertHeading(rng, docsrcinfo.Properties.Shortname, intlevel + 1)
        Else
            rng.Start = rng.Paragraphs(2).Range.Start ' exclude heading
            Set rng = ClearRange(rng)
        End If
        
        Set rngrel = rng ' this should now point to the first paragraph below the heading
    End If
    
    PrepareRelationshipSection = strmessage

End Function

Private Function TransferRelationshipTable(ByRef rng As Range, ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, ByRef tbl As Table) As String
    Dim rngtrcr As Range, rngsrc As Range, strmessage As String, strtable As String, strtemp As String
    '==================================================================================================================================
    ' Description: Copies the relationship table and its caption from the source document and renames the table bookmark accordingly.
    '              Updates the given table argument to point to this table.
    '==================================================================================================================================
    ' point to table and its caption in source document
    Set rngsrc = GetTable(docsrcinfo.Document, Const_DOCTBL_TRCRELATIONSHIPS).Range
    rngsrc.Start = rngsrc.Previous(wdParagraph).Start
    ' point a new range object to the given range so we don't mess with its position
    Set rngtrcr = doctrcrinfo.Document.Range
    rngtrcr.SetRange rng.Start, rng.End
    ' copy table
    rngsrc.Copy
    rngtrcr.Paste
    ' delete empty paragraph below table
    rngtrcr.Collapse wdCollapseEnd
    rngtrcr.Delete
    ' rename the caption bookmark
    strtable = Const_DOCTBL_TRCRELATIONSHIPS_PREFIX & docsrcinfo.Properties.Basename
    If RenameBookmark(doctrcrinfo.Document, Const_DOCTBL_TRCRELATIONSHIPS, strtable, strmessage) Then
        Set tbl = GetTable(doctrcrinfo.Document, strtable, strtemp) ' return new table
        Set rngtrcr = tbl.Cell(1, Const_TRCREL_TRACEFROM_COLUMN).Range
        rngtrcr.Text = GetCellText(rngtrcr.Cells(1)) & "/To" ' modify header because it now includes 'to' traces
        strmessage = AddStatusText(strmessage, strtemp)
    End If
    
    TransferRelationshipTable = strmessage
    
End Function

Private Sub UpdateHyperlinkAddresses(ByRef tbl As Table, ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo)
    '==================================================================================================================================
    ' Description: Updates all hyperlink addresses in the given table to be relative to TRCR document instead of the source document.
    '==================================================================================================================================
    Dim hlnk As Hyperlink, fso As FileSystemObject, straddress As String
    Set fso = New FileSystemObject
    For Each hlnk In tbl.Range.Hyperlinks
        straddress = fso.GetAbsolutePathName(fso.BuildPath(docsrcinfo.Properties.Path, hlnk.Address)) ' full path to address
        hlnk.Address = GetRelativePath(doctrcrinfo.Properties.Path, straddress) ' get it relative to TRCR document
    Next hlnk
End Sub

Private Function BuildInverseRelationshipsFromTable(ByRef tblrel As Table, ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, _
                                                    ByRef dictraceto As Scripting.Dictionary) As String
    '==================================================================================================================================
    ' Description: Parses the given relationship table and builds the inverse relationships by using the 'from' entries and creating a
    '              the 'to' trace information for each item - these are then added to the 'trace to' dictionary.
    '              NOTE 1: Assume the table being parsed is generated, so little error checking is required.
    '              NOTE 2: The summary information is calculated later once all the traces have been added for all documents.
    '==================================================================================================================================
    Dim celbkm As Cell, celref As Cell, celend As Cell, hlnk As Hyperlink, strmessage As String
    Dim trcdoc As cTrcDocTraces, trc As cTrace, trcitem As cTracedItem
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    For Each celbkm In tblrel.Columns(Const_TRCREL_TRACEBKM_COLUMN).Cells
        If celbkm.RowIndex > 1 Then ' skip header row
            ' entry in 2nd cell is now the 'to' trace
            Set hlnk = celbkm.Range.Hyperlinks(1)
            Set trcitem = New cTracedItem
            trcitem.Bookmark = hlnk.SubAddress
            trcitem.SourceDocument = hlnk.Address
            ' trace type is set further on below
            
            ' make sure item is listed in 'trace to' dictionary so we can detect missing traces later
            Call InitTraceToFromHyperlink(hlnk, doctrcrinfo, dictraceto)
            
            ' entries in 4th cell are now the item sources, so add entry in 2nd cell as 'trace to' relationship
            Set celref = celbkm
            Set celend = GetSubSectionLastCell(celbkm)
            Do
                Set celref = celref.Next.Next
                Set hlnk = celref.Range.Hyperlinks(1)
                If Not hlnk.SubAddress Like Const_JST_BMRK_PREFIX_TRCFROM_EXCEPTION & "*" Then ' skip justifications
                    Set trcdoc = InitTraceToFromHyperlink(hlnk, doctrcrinfo, dictraceto)
                    Set trc = trcdoc.Traces(hlnk.SubAddress)
                    trcitem.TraceType = Dst.TrcConfig.TraceTypeText(trc.Item.Prefix, False, Dst.BookmarkConfig.PrefixFromName(trcitem.Bookmark))
                    trc.Add trcitem
                End If
            Loop Until celref.RowIndex = celend.RowIndex ' while reference is related to bookmark
        End If
    Next celbkm

    BuildInverseRelationshipsFromTable = strmessage
    
End Function

Private Function InitTraceToFromHyperlink(ByRef hlnk As Hyperlink, ByRef doctrcrinfo As cDocInfo, ByRef dictraceto As Scripting.Dictionary) As cTrcDocTraces
    '==================================================================================================================================
    ' Description: Adds the data from the given hyperlink to the 'trace to' dictionary as an empty cTrace object - the 'trace from'
    '              information is added elsewhere. The new document traces object is returned.
    '==================================================================================================================================
    Dim bkm As cDocBookmark, strdocument As String, trcdoc As cTrcDocTraces, trc As cTrace, fso As FileSystemObject
    Set fso = New FileSystemObject
    Set bkm = New cDocBookmark ' we only need the bookmark, prefix and document filename
    bkm.Name = hlnk.SubAddress
    bkm.SourceDocument = hlnk.Address
    bkm.Prefix = Dst.BookmarkConfig.PrefixFromName(bkm.Name)
    strdocument = fso.GetAbsolutePathName(fso.BuildPath(doctrcrinfo.Properties.Path, bkm.SourceDocument))
    If Not dictraceto.Exists(strdocument) Then
        Set trcdoc = New cTrcDocTraces
        trcdoc.Init Dst.Document(strdocument), Dst.TrcConfig, False
        dictraceto.Add strdocument, trcdoc
    End If
    Set trcdoc = dictraceto(strdocument)
    If Not trcdoc.Traces.Exists(bkm.Name) Then
        Set trc = New cTrace
        Set trc.Item = bkm
        trcdoc.Add trc
    End If
    Set InitTraceToFromHyperlink = trcdoc
End Function

Private Function InsertTraceRowBelow(ByRef cel As Cell, ByVal strtracetype As String, _
                                     ByVal strlinkaddress As String, ByVal strlinksubaddress As String, ByVal strlinktext As String) As Cell
    '==================================================================================================================================
    ' Description: Inserts a new trace row below the given cell - updates the trace type as well as the traced hyperlink. The last cell
    '              in the row is returned
    '==================================================================================================================================
    cel.Select ' have to use the selection object to insert a new row when table has merged cells
    Selection.InsertRowsBelow
    Set cel = cel.Range.Next(wdCell, 3).Cells(1) ' select reference cell in new row (4th cell), so advance by three
    If cel.ColumnIndex = Const_TRCREL_TRACEFROM_COLUMN - 1 Then Set cel = cel.Next ' this occurs when row is added just above the start of a new heading number sub-section
    cel.Previous.Range.Text = strtracetype
    Call InsertTRCTraceAsHyperlink(cel.Range, strlinkaddress, strlinksubaddress, strlinktext)
    Set InsertTraceRowBelow = cel
End Function

Private Sub RemoveRangeBelowTable(ByRef tbl As Table)
    '==================================================================================================================================
    ' Description: Clears out all content and sub-sections below given table up to the next heading
    '==================================================================================================================================
    Dim rng As Range
    Set rng = GetRangeBelowTable(tbl)
    If rng.End > rng.Start Then Call ClearRange(rng, False)
End Sub

Private Function GetRangeBelowTable(ByRef tbl As Table) As Range
    '==================================================================================================================================
    ' Description: Returns the range below given table up to the next same-level heading
    '==================================================================================================================================
    Dim rng As Range
    Set rng = GetHeadingRangeExtendedFromRange(tbl.Range) ' range of section enclosing by the table
    rng.Start = tbl.Range.Next(wdParagraph).Start ' move start to paragraph after table
    Set GetRangeBelowTable = rng
End Function

Private Function ClearRange(rng As Range, Optional ByVal blleaveblankpar As Boolean = True) As Range
    '==================================================================================================================================
    ' Description: Clears the given range and leaves an empty paragraph if required
    '==================================================================================================================================
    Dim tbl As Table, bltableatend As Boolean
    
    ' special processing is required if there is a table at the end of the range
    bltableatend = (rng.Paragraphs.Last.Range.Tables.Count > 0)
    
    ' always remove tables first because if range ends with table, it cannot be edited
    For Each tbl In rng.Tables
        tbl.Delete
    Next tbl
    
    ' insert a blank paragraph before we clear the content if there was a table at the end of the range
    If bltableatend And blleaveblankpar Then
        rng.InsertParagraphBefore
        rng.Style = "Body Text"
        rng.Start = rng.Start + 1 ' leave new paragraph
        rng.Text = vbNullString
        Set rng = rng.Previous(wdParagraph)
        If rng.Bookmarks.Count > 0 Then rng.Bookmarks(1).Delete
        rng.Collapse wdCollapseStart
    Else
        If blleaveblankpar Then rng.End = rng.End - 1
        rng.Text = vbNullString
    End If
            
    Set ClearRange = rng ' this should now point to the start of the cleared range

End Function

Private Sub RemoveOrphanedSourceEntries(ByRef doctrcrinfo As cDocInfo, ByRef frm As Object)
    '==================================================================================================================================
    ' Description: Removes document sub-sections and table checksum entries that are not related to any entries in the TRC dcoument list
    '==================================================================================================================================
    Dim strstatus As String
    strstatus = RemoveOrphanedSubSections(doctrcrinfo)
    strstatus = AddStatusText(strstatus, RemoveOrphanedDocVar(doctrcrinfo, Const_DOCTBL_TRCRELATIONSHIPS_PREFIX))
    strstatus = AddStatusText(strstatus, RemoveOrphanedDocVar(doctrcrinfo, Const_DOCTBL_TRCRELATIONSHIPS_USED_PREFIX))
    If strstatus <> vbNullString Then
        frm.UpdateProgressText strstatus
    End If
End Sub

Private Function RemoveOrphanedSubSections(ByRef doctrcrinfo As cDocInfo) As String
    '==================================================================================================================================
    ' Description: Removes document sub-sections that are not related to any entries in the TRC dcoument list
    '==================================================================================================================================
    Dim dichdgs As Scripting.Dictionary, varhdg As Variant, rnghdg As Range
    Dim docsrcinfo As cDocInfo, vardoc As Variant, strstatus As String, blfound As Boolean
    
    ' remove orphaned sub-sections
    Set dichdgs = GetSubHeadingsInRange(GetRangeBelowTable(GetTable(doctrcrinfo.Document, Const_DOCTBL_TRCSUMMARY_BYDOC))) ' assume table exists
    For Each varhdg In dichdgs
        blfound = False
        Set rnghdg = dichdgs(varhdg)
        rnghdg.End = rnghdg.End - 1 ' exclude paragraph marker
        For Each vardoc In doctrcrinfo.DocList.TrcDocuments
            Set docsrcinfo = Dst.Document(vardoc)
            If rnghdg.Text = docsrcinfo.Properties.Shortname Then
                blfound = True
                Exit For
            End If
        Next vardoc
        
        If Not blfound Then
            strstatus = AddStatusText(strstatus, "  [-] Removed sub-section " & varhdg & " " & rnghdg.Text)
            GetHeadingRangeExtendedFromRange(rnghdg).Delete
        End If
    Next varhdg
    RemoveOrphanedSubSections = strstatus
End Function

Private Function RemoveOrphanedDocVar(ByRef doctrcrinfo As cDocInfo, ByVal strprefix As String) As String
    '==================================================================================================================================
    ' Description: Cycles through each table checksum variable that starts with the given prefix and removes it if it is not related to
    '              a corresponding TRC document list entry
    '==================================================================================================================================
    Dim varitem As Variant, dicvars As Scripting.Dictionary, strsource As String, vardoc As Variant, docsrcinfo As cDocInfo, strstatus As String, blfound As Boolean
    Set dicvars = doctrcrinfo.Variables.OfType(enumDocVariableTypeTableChecksum)
    For Each varitem In dicvars
        blfound = False
        If varitem Like strprefix & "*" Then
            strsource = Replace(varitem, strprefix, vbNullString)
            For Each vardoc In doctrcrinfo.DocList.TrcDocuments
                Set docsrcinfo = Dst.Document(vardoc)
                If strsource = docsrcinfo.Properties.Basename Then
                    blfound = True
                    Exit For
                End If
            Next vardoc
            
            If Not blfound Then
                strstatus = AddStatusText(strstatus, "  [-] Removed checksum variable '" & varitem & "'")
                doctrcrinfo.Variables.VariableDelete varitem
            End If
        End If
    Next varitem
    RemoveOrphanedDocVar = strstatus
End Function
Attribute VB_Name = "basTRCSource"
Option Explicit

Function UpdateTRCTablesSourceDoc(ByRef objdoc As Document, ByRef frm As Object) As String
    '==================================================================================================================================
    ' Description: This is the main function for updating the TRC information in a source document.
    '              [-] The function first validates the traceability tables of the document.
    '              [-] If the validation passed, the function:
    '                  * Rebuilds the bookmarks object
    '                  * Stores the existing justifications for later use
    '                  * Deletes the summary and relationship tables
    '                  * Builds new relationships from the traceable bookmarks and references
    '                  * Inserts a new relationship table using the information above
    '                  * Inserts a new justifications table
    '                  * Inserts a new summary table
    '              [-] If any of the intermediate steps in this process fail, the processing is discontinued.
    '==================================================================================================================================
    Dim tblsum As Table, tbltrc As Table, tbljst As Table, docinfo As cDocInfo, strtable As String
    Dim trcdoc As cTrcDocTraces
    Dim jsttrccur As Scripting.Dictionary, jsttrcnew As Scripting.Dictionary
    Dim rngtblsum As Range, rngtbltrc As Range, strstatus As String
    
    frm.UpdateProgressText "Validating the traceability related tables..."
    strstatus = ValidateDocTraceabilityTables(objdoc, tblsum, tbltrc, tbljst) ' we're going to update, so don't check checksums
    If Not tblsum Is Nothing And Not tbltrc Is Nothing And Not tbljst Is Nothing Then
        ' update bookmarks dictionary before we start
        Set docinfo = Dst.Document(objdoc.Fullname)
        frm.UpdateProgressText "Rebuilding bookmarks index..."
        docinfo.Bookmarks.RebuildBookmarks
        
        ' store the existing justifications for traceabilioty exceptions
        frm.UpdateProgressText "Storing existing justifications..."
        Set jsttrccur = New Scripting.Dictionary
        Call StoreJustificationBookmarks(tbljst.Range, Const_JST_BMRK_PREFIX_TRCFROM_EXCEPTION, jsttrccur)
    
        ' delete summary and relationships tables - justifications table is deleted later
        frm.UpdateProgressText "Deleting summary and relationships tables..."
        Set rngtblsum = DeleteTable(objdoc, Const_DOCTBL_TRCSUMMARY)
        strtable = Const_DOCTBL_TRCRELATIONSHIPS
        Set rngtbltrc = DeleteTable(objdoc, strtable)
        If Not rngtbltrc Is Nothing Then
            ' build TRC relationships from document content
            Set trcdoc = BuildRelationships(objdoc, Const_DOCTBL_TRCFROMJSTS, frm)
            strtable = Const_DOCTBL_TRCRELATIONSHIPS
            frm.UpdateProgressText "Inserting new " & strtable & " table..."
            Set jsttrcnew = New Scripting.Dictionary
            strstatus = InsertRelationshipsTable(objdoc, rngtbltrc, strtable, jsttrcnew, trcdoc, frm)
            If strstatus = vbNullString Then
                ' update the table checksum
                Call ProcessTableChecksum(objdoc, strtable)
                                                
                ' insert new JST table and transfer existing justifications
                Call ManageTRCJustificationsTable(tbljst, Const_DOCTBL_TRCFROMJSTS, jsttrcnew, jsttrccur, True, Nothing, frm)
                
                ' insert the summary table last because we need the data in the other tables to compute the metrics
                If frm.GetResult = vbNullString Then
                    strtable = Const_DOCTBL_TRCSUMMARY
                    frm.UpdateProgressText "Inserting new " & strtable & " table..."
                    trcdoc.CalculateSummary tbljst ' trigger calculation of the metrics summary
                    strstatus = InsertTRCSummaryTable(docinfo, rngtblsum, strtable, trcdoc)
                End If
                
                If strstatus = vbNullString And frm.GetResult = vbNullString Then frm.UpdateProgressText "Traceability tables were updated successfully."
            End If
        Else
            strstatus = "Unable to delete the " & strtable & " table."
        End If
    End If
    
    UpdateTRCTablesSourceDoc = strstatus
    
End Function

Private Function BuildRelationships(ByRef objdoc As Document, ByVal strcontentendmarker As String, ByRef frm As Object) As cTrcDocTraces
    '==================================================================================================================================
    ' Description: Processes the traceability relationships in the given document and returns a cTrcDocTraces object giving the 'from'
    '              traceability relationships. The summary info is updated later after processing the justifications.
    '==================================================================================================================================
    Dim docinfo As cDocInfo, idx As Integer
    Dim trcdoc As cTrcDocTraces, trc As cTrace, trcitem As cTracedItem, trcpref As cTrcPrefixConfig
    Dim dicbkm As Scripting.Dictionary, bkm As cDocBookmark, strrefbookmark As String, strrefprefix As String
    Dim rngbkm As Range, fld As Field
    Dim strtracetype As String, strjstbookmark As String
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    Set trcdoc = New cTrcDocTraces
    trcdoc.Init docinfo, Dst.TrcConfig, True
    
    Set dicbkm = docinfo.Bookmarks.InternalTraceable
    frm.UpdateProgressText "Building relationships for " & dicbkm.Count & " traceable items..."
    For idx = 0 To dicbkm.Count - 1
        frm.UpdateProgressMeter idx, dicbkm.Count
        Set bkm = dicbkm.Items(idx)
        Set trc = New cTrace
        Set trc.Item = bkm
        
        ' get references in this bookmark's range (till next bookmark)
        If idx < dicbkm.Count - 1 Then
            Set rngbkm = objdoc.Range(bkm.Position, dicbkm.Items(idx + 1).Position - 1)
        Else
            Set rngbkm = objdoc.Range(bkm.Position, docinfo.Bookmarks.Bookmark(strcontentendmarker).Position - 1) ' range for last bookmark is up to the bookmark 'end' marker
        End If
        
        ' check if reference is defined as a valid 'trace from' prefix for this bookmark prefix and that it is correctly styled
        For Each fld In rngbkm.Fields
            strrefbookmark = GetBookmarkNameFromField(fld)
            strrefprefix = Dst.BookmarkConfig.PrefixFromName(strrefbookmark)
            If strrefprefix <> vbNullString Then
                If docinfo.Parent.TrcConfig.PrefixTrace(bkm.Prefix).FromPrefixes.Exists(strrefprefix) And _
                    fld.Result.Style = docinfo.Parent.BookmarkConfig.Prefix(strrefprefix).ReferenceStyle Then
                    
                    ' add trace from item info
                    strtracetype = Dst.TrcConfig.TraceTypeText(bkm.Prefix, True, strrefprefix)
                    Set trcitem = New cTracedItem
                    trcitem.Bookmark = strrefbookmark
                    trcitem.TraceType = strtracetype
                    trcitem.SourceDocument = docinfo.Bookmarks.Bookmark(strrefbookmark).SourceDocument
                    trc.Add trcitem
                End If
            End If
        Next fld
        
        ' if there no traces, add justifications
        If trc.TracedItems.Count = 0 Then
            ' default trace type to the first 'trace from' type for the current bookmark
            Set trcpref = Dst.TrcConfig.PrefixTrace(trc.Item.Prefix)
            strtracetype = Dst.TrcConfig.TraceTypeText(trc.Item.Prefix, True, trcpref.FromPrefixes.Keys(0))
            
            ' determine bookmark name - use checksums to ensure names don't go beyond length limit
            strjstbookmark = GetTRCJustificationBookmark(Const_JST_BMRK_PREFIX_TRCFROM_EXCEPTION, strtracetype, trc.Item.Name)
            
            ' add JST as a trace item
            Set trcitem = New cTracedItem
            trcitem.Bookmark = strjstbookmark
            trcitem.TraceType = strtracetype
            trcitem.SourceDocument = trc.Item.SourceDocument
            trc.Add trcitem
        End If
        trcdoc.Add trc
    Next idx
    frm.UpdateProgressMeter (-1)
    
    Set BuildRelationships = trcdoc
    
End Function

Private Function InsertRelationshipsTable(ByRef objdoc As Document, ByRef rngtbl As Range, ByVal strtable As String, _
                                          ByRef jsttrcnew As Scripting.Dictionary, ByRef trcdoc As cTrcDocTraces, ByRef frm As Object) As String
    '==================================================================================================================================
    ' Description: Inserts a new relationships table using the given cTrcDocTraces object.
    '==================================================================================================================================
    Dim tbltrc As Table, strcaption As String, docinfo As cDocInfo
    Dim numrows As Integer
    Dim celhdg As Cell, celbkm As Cell, celref As Cell, rngref As Range
    Dim bkm As cDocBookmark, trc As cTrace, trcitem As cTracedItem
    Dim varbookmark As Variant, vartrcitem As Variant
    Dim strpreviousheading As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(objdoc.Fullname)
    
    ' insert the relationships table with enough rows for each traceable bookmark
    strcaption = "Traceability Relationships"
    numrows = IIf(trcdoc.TotalTraceCount > 0, 1 + trcdoc.TotalTraceCount, 2)
    Set tbltrc = CreateTableTemplate(rngtbl, numrows, 4, strcaption, strtable, True, True)
    If Not tbltrc Is Nothing Then
        With tbltrc
            ' set table header
            .Columns(1).SetWidth CentimetersToPoints(2.3), wdAdjustNone
            .Cell(1, 1).Range.Text = "Section"
            .Columns(2).SetWidth CentimetersToPoints(6.4), wdAdjustNone
            .Cell(1, 2).Range.Text = "Item"
            .Columns(3).SetWidth CentimetersToPoints(1.9), wdAdjustNone
            .Columns(3).Select
            Selection.ParagraphFormat.Alignment = wdAlignParagraphCenter
            .Cell(1, 3).Range.Text = "Type"
            .Columns(Const_TRCREL_TRACEFROM_COLUMN).SetWidth CentimetersToPoints(6.4), wdAdjustNone
            .Cell(1, Const_TRCREL_TRACEFROM_COLUMN).Range.Text = "Traces From"
            Call InsertNotApplicable(.Cell(2, 2).Range)
            
            ' add the traceable bookmarks to the table
            frm.UpdateProgressText "  [-] Adding " & numrows - 1 & " entries to the table..."
            Set celhdg = .Cell(1, 1)
            Set celref = .Cell(1, 4)
            Set celbkm = celref
            For Each varbookmark In trcdoc.Traces
                frm.UpdateProgressMeter celref.RowIndex, numrows
                Set trc = trcdoc.Trace(varbookmark)
                Set bkm = trc.Item
                ' check if cell merge is required
                If bkm.Heading <> strpreviousheading Then
                    Call MergeCells(celhdg, .Cell(celref.RowIndex, 1))
                    Set celhdg = celref.Next ' advance cell to heading location in next row
                    celhdg.Range.Text = bkm.Heading
                    strpreviousheading = bkm.Heading
                End If
                Set celbkm = celbkm.Next.Next ' assume cell is reference cell, so advance cell to bookmark location in next row
                Call InsertTRCTraceAsHyperlink(celbkm.Range, bkm.SourceDocument, bkm.Name, bkm.Name)
                For Each vartrcitem In trc.TracedItems
                    Set celref = celref.Range.Next(wdCell, 4).Cells(1) ' advance cell to reference location in next row
                    Set trcitem = trc.TracedItem(vartrcitem)
                    celref.Previous.Range.Text = trcitem.TraceType
                    Set rngref = celref.Range
                    If Not trcitem.Bookmark Like Const_JST_BMRK_PREFIX_TRCFROM_EXCEPTION & "*" Then
                        Call InsertTRCTraceAsHyperlink(rngref, trcitem.SourceDocument, trcitem.Bookmark, trcitem.Bookmark)
                    Else
                        Call InsertTRCTraceAsHyperlink(rngref, trcitem.SourceDocument, trcitem.Bookmark, "Trace Exception")
                        ' add bookmark of item that needs justification to new dictionary - append the JST type
                        jsttrcnew.Add trcitem.Bookmark, trc.Item.Name & JSTTypeText(trcitem.TraceType)
                    End If
                Next vartrcitem
                Call MergeCells(celbkm, celref.Previous.Previous)
                Set celbkm = celref ' point back to reference cell so next loop's advance works correctly
            Next varbookmark
            Call MergeCells(celhdg, .Cell(celref.RowIndex, 1))
            frm.UpdateProgressMeter (-1)
        End With
        
        frm.UpdateProgressText "  [-] Updating trace type with arrows..."
        Call UpdateTRCTraceTypeWithArrowSymbol(tbltrc, Const_TRCREL_TRACEFROM_COLUMN - 1, True)
    Else
        InsertRelationshipsTable = "Unable to create the '" & strcaption & "' table"
    End If
    
End Function
Attribute VB_Name = "basTRCSummary"
Option Explicit

Function UpdateTRCSummaryTableMetrics(ByRef objdoc As Document, ByRef frm As Object) As Boolean
    '==================================================================================================================================
    ' Description: This is the main entry point for the 'Update Metrics' function.
    '              [-] This function updates the [Justified] and [Unresolved] columns in the relevant summary tables if the
    '                  justifications table was edited since the last update of the traceability tables
    '              [-] For TRCR documents, all justifications must be resolved before this function updates anything
    '              [-] For source documents, this function parses the justifications tbale and determines the values for these columns
    '                  based on the trace types
    '==================================================================================================================================
    Dim tblsum As Table, tblbydoc As Table, tbljst As Table, strstatus As String, strstatusjsts As String, bltrcr As Boolean

    frm.UpdateProgressText "Updating the summary justification metrics columns..."
    
    ' check if the document traceability status is up-to-date - note we obtain the status of the justification table checksum seperately
    strstatus = ValidateDocTraceabilityTables(objdoc, tblsum, tblbydoc, tbljst, True, strstatusjsts, True)
    If strstatus = vbNullString And Not (tblsum Is Nothing Or tblbydoc Is Nothing Or tbljst Is Nothing) Then
        If strstatusjsts <> vbNullString Then
            If Dst.Document(objdoc.Fullname).Properties.TypeAbbr = "TRCR" Then
                strstatus = NotifyUnresolvedJustifications(tbljst)
                If strstatus = vbNullString Then
                    Call UpdateTRCRSummaryJstColumns(tblsum, tblbydoc)
                Else
                    strstatus = strstatus & ". Resolve all remaining justifications in this table and then re-run this function."
                End If
            Else
                Call UpdateSourceSummaryJstColumns(tbljst, tblsum)
                Set tblbydoc = Nothing ' this is actually the relationship table for a source document - we don't use it
            End If
            
            ' update checksum of JST table used and summary table(s)
            If strstatus = vbNullString Then
                Call ProcessTableChecksum(objdoc, GetTableName(tbljst))
                Call ProcessTableChecksum(objdoc, GetTableName(tblsum))
                Call ProcessTableChecksum(objdoc, GetTableName(tblbydoc))
                frm.UpdateProgressText "The Traceability Metrics Summary was updated successfully."
            End If
        Else
            frm.UpdateProgressText "INFO: The justifications table is unchanged - the Traceability Metrics Summary was not updated"
        End If
    End If
    frm.UpdateProgressText strstatus
    
    If strstatus = vbNullString And frm.GetResult = vbNullString Then
        UpdateTRCSummaryTableMetrics = True
    End If
        
End Function

Function InsertTRCSummaryTable(ByRef docinfo As cDocInfo, ByRef rngtbl As Range, ByVal strtable As String, ByRef trcdoc As cTrcDocTraces) As String
    '==================================================================================================================================
    ' Description: Inserts a new summary table in the given document and populates it with the given summary values for each trace type
    '==================================================================================================================================
    Dim tblsum As Table, strcaption As String, rw As Row, rng As Range
    Dim trcsum As cTrcSummary, idx As Integer, strtext As String
    
    strcaption = "Traceability Metrics Summary"
    
    ' create the summary table
    Set tblsum = CreateTableTemplate(rngtbl, trcdoc.Summaries.Count + 1, 5, strcaption, strtable)
    If Not tblsum Is Nothing Then
        With tblsum
            .Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
            .Cell(1, 1).Range.Text = "Type"
            .Cell(1, 2).Range.Text = "Total Items"
            .Cell(1, 3).Range.Text = "Traced"
            .Cell(1, 4).Range.Text = "Justified"
            .Cell(1, 5).Range.Text = "Unresolved"
            For idx = 0 To trcdoc.Summaries.Count - 1
                Set trcsum = trcdoc.Summaries.Items(idx)
                .Cell(idx + 2, 1).Range.Text = trcsum.TrcType
                .Cell(idx + 2, 2).Range.Text = IIf(trcsum.Total > 0, trcsum.Total, "-")
                .Cell(idx + 2, 3).Range.Text = IIf(trcsum.Traced > 0, trcsum.Traced, "-")
                Call UpdateSummaryJstColumns(.Cell(idx + 2, 4), trcsum)
            Next idx
        End With
        
        ' update trace type arrows (both directions)
        If strtable = Const_DOCTBL_TRCSUMMARY Then
            Call UpdateTRCTraceTypeWithArrowSymbol(tblsum, 1, True) ' only 'from' arrows in source summary table
        Else
            Call UpdateTRCTraceTypeWithArrowSymbol(tblsum, 1, True)
            Call UpdateTRCTraceTypeWithArrowSymbol(tblsum, 1, False)
        End If
        
        ' update table checksum
        Call ProcessTableChecksum(docinfo.Document, strtable)
    Else
        InsertTRCSummaryTable = "Unable to create the '" & strcaption & "' table"
    End If
    
End Function

Sub InsertTRCROverallSummaryTable(ByRef doctrcrinfo As cDocInfo, ByRef tblsum As Table, ByRef tblbydoc As Table, ByRef frm As Object)
    '==================================================================================================================================
    ' Description: Inserts the overall summary table in the TRCR document and populates it with the accumulated summary values
    '==================================================================================================================================
    Dim rng As Range, celtype As Cell, celval As Cell
    Dim strmessage As String, strtable As String
    Dim trcdoc As cTrcDocTraces, trcsum As cTrcSummary, strtracetype As String
    Dim dicsummaries As Scripting.Dictionary, dictyperank As Scripting.Dictionary, varitem As Variant
        
    ' populate summary data manually from summary by document table
    Set dicsummaries = New Scripting.Dictionary
    For Each celtype In tblbydoc.Columns(Const_TRCSUMMARY_BYDOC_TRCTYPE_COL).Cells
        If celtype.RowIndex > 1 Then
            ' determine trace type and accumulate values
            strtracetype = GetTraceTypeText(celtype.Range)
            If Not dicsummaries.Exists(strtracetype) Then
                Set trcsum = New cTrcSummary
                trcsum.TrcType = strtracetype
                dicsummaries.Add strtracetype, trcsum
            End If
            Set trcsum = dicsummaries(strtracetype)
            Set celval = celtype.Next
            trcsum.Total = trcsum.Total + GetCellValue(celval)
            Set celval = celval.Next
            trcsum.Traced = trcsum.Traced + GetCellValue(celval)
            Set celval = celval.Next
            trcsum.Justified = trcsum.Justified + GetCellValue(celval)
            Set celval = celval.Next
            trcsum.Unresolved = trcsum.Unresolved + GetCellValue(celval)
        End If
    Next celtype
    
    ' create a new dictionary for type and rank, based on the trace type entries above and sort this dictionary on its values
    Set dictyperank = New Scripting.Dictionary
    For Each varitem In dicsummaries
        dictyperank.Add varitem, doctrcrinfo.Parent.TrcConfig.TraceTypeRank(varitem)
    Next varitem
    Set dictyperank = SortDictionaryByValues(dictyperank)
    
    ' use the type rank dictionary to ensure the document traces object is sorted according to the level ranking
    Set trcdoc = New cTrcDocTraces
    For Each varitem In dictyperank
        trcdoc.Summaries.Add varitem, dicsummaries(varitem)
    Next varitem
    
    ' delete existing summary table
    strtable = GetTableName(tblsum)
    Set rng = DeleteTable(tblsum.Range.Document, strtable)
    
    ' insert new summary table
    strmessage = InsertTRCSummaryTable(doctrcrinfo, rng, strtable, trcdoc)
    
    If strmessage <> vbNullString Then frm.LogResult strmessage

End Sub

Sub ProcessTRCRInverseSummaries(ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, ByRef trcdoc As cTrcDocTraces, _
                                ByRef tblbydoc As Table, ByRef tbljst As Table, ByRef frm As Object)
    '==================================================================================================================================
    ' Description: Adds the relevant inverse summary table row entries to the given symmary by document table in a TRCR document
    '==================================================================================================================================
    Dim celstart As Cell, celsum As Cell, celend As Cell, varsum As Variant, trcsum As cTrcSummary, strmessage As String
    Dim cel As Cell, idx As Integer

    ' point to last row in the summary table sub-section
    Set celstart = GetTRCRSummaryByDocTableCell(doctrcrinfo, docsrcinfo, tblbydoc) ' assume row will exist by now
    Set celend = GetSubSectionLastCell(celstart)
    
    ' trigger summary calculation
    trcdoc.CalculateSummary tbljst
    For Each varsum In trcdoc.Summaries
        Set trcsum = trcdoc.Summary(varsum)
        ' find corresponding trace type/relationship cell
        Set celsum = Nothing
        For idx = celstart.RowIndex To celend.RowIndex
            Set cel = tblbydoc.Columns(Const_TRCSUMMARY_BYDOC_TRCTYPE_COL).Cells(idx)
            If GetTraceTypeText(cel.Range) = trcsum.TrcType Then
                Set celsum = cel
                Exit For ' cell found, exit loop
            End If
        Next idx
        ' add row at end of sub-section if entry not found
        If celsum Is Nothing Then
            Set celsum = celend
            celsum.Select ' have to use the selection object to insert a new row when table has merged cells
            Selection.InsertRowsBelow
            Set celsum = celsum.Next.Next.Next ' select 'Relationship' column in new row, so advance by three - assuming currently at end of row
            celsum.Range.Text = trcsum.TrcType
            Set celend = tblbydoc.Cell(celsum.RowIndex, tblbydoc.Columns.Count) ' update end cell as new row was added
        End If
        Set celsum = celsum.Next
        celsum.Range.Text = trcsum.Total
        Set celsum = celsum.Next
        celsum.Range.Text = IIf(trcsum.Traced > 0, trcsum.Traced, "-")
        Set celsum = celsum.Next
        Call UpdateSummaryJstColumns(celsum, trcsum)
        Set celsum = celsum.Next ' advance to last cell
    Next varsum
    
    ' merge cells in first two columns - assume celsum points to last cell in row
    Call MergeCells(celstart, tblbydoc.Cell(celsum.RowIndex, 1))
    Call MergeCells(celstart.Next, tblbydoc.Cell(celsum.RowIndex, 2))

    If strmessage <> vbNullString Then frm.LogResult docsrcinfo.Properties.Shortname & ": " & strmessage
End Sub

Function PrepareTRCRSummaryByDocTableRow(ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, ByRef tblbydoc As Table) As Cell
    '==================================================================================================================================
    ' Description: Returns the first cell in the summary by document table for the given source document and removes the sub-section
    '              rows below - assumes the source document is listed in the table
    '==================================================================================================================================
    Dim cel As Cell
    Set cel = GetTRCRSummaryByDocTableCell(doctrcrinfo, docsrcinfo, tblbydoc)
    Call DeleteTabeSubRows(cel)
    Call SetTRCRSummaryTableRowDashes(cel)
    cel.Range.Hyperlinks(1).SubAddress = Const_DOCTBL_TRCSUMMARY ' make sure hyperlink points to source document summary table
    Set PrepareTRCRSummaryByDocTableRow = cel
End Function

Function TransferTRCRSummaryTableRows(ByRef celstart As Cell, ByRef docsrcinfo As cDocInfo, ByRef rngrel As Range) As String
    '==================================================================================================================================
    ' Description: Copies the metrics summary values from the source document to the summary by document table row pointed to by the
    '              given cell argument. The function adds rows to the summary table as necessary and also updates the sub-section
    '              reference using the range given by the range argument.
    '==================================================================================================================================
    Dim tblsrc As Table, rwsrc As Row, rng As Range, idx As Integer
    Dim celsum As Cell, tblsum As Table, strheadingtext As String, strmessage As String
    Set celsum = celstart ' start at given cell in summary table
    Set tblsrc = GetTable(docsrcinfo.Document, Const_DOCTBL_TRCSUMMARY, strmessage)
    For Each rwsrc In tblsrc.Rows
        If rwsrc.Index > 1 Then ' skip header row
            If rwsrc.Index = 2 Then
                ' main row, so add section reference in 2nd column
                strheadingtext = GetHeadingNumberAndText(rngrel)
                Set celsum = celsum.Next
                Set rng = celsum.Range
                rng.Text = vbNullString
                rng.Collapse wdCollapseStart
                If Not InsertCrossReferenceToHeading(rng, strheadingtext) Then
                    strmessage = AddStatusText(strmessage, "Could not insert cross-reference to heading '" & strheadingtext & "' in summary table")
                End If
            Else
                celsum.Select ' have to use the selection object to insert a new row when table has merged cells
                Selection.InsertRowsBelow
                Set celsum = celsum.Next.Next ' select 'Section' column in new row, so advance by two - assuming currently at end of row
            End If
            ' copy formatted content from source table
            For idx = 1 To Const_TRCSUMMARY_BYDOC_NUMCOLS
                Set rng = rwsrc.Cells(idx).Range
                rng.End = rng.End - 1 ' exclude end-of-cell marker
                Set celsum = celsum.Next
                With celsum.Range
                    .Text = vbNullString
                    .Collapse wdCollapseStart
                    .FormattedText = rng.FormattedText
                End With
            Next idx
        End If
    Next rwsrc
    
    ' merge cells in first two columns - assume celsum points to last cell in row
    Set tblsum = celsum.Range.Tables(1)
    Call MergeCells(celstart, tblsum.Cell(celsum.RowIndex, 1))
    Call MergeCells(celstart.Next, tblsum.Cell(celsum.RowIndex, 2))
    
    TransferTRCRSummaryTableRows = strmessage
End Function
    
Private Function GetTRCRSummaryByDocTableCell(ByRef doctrcrinfo As cDocInfo, ByRef docsrcinfo As cDocInfo, ByRef tblbydoc As Table) As Cell
    '==================================================================================================================================
    ' Description: Returns the first cell in the summary by document table for the given source document
    '==================================================================================================================================
    Dim cel As Cell, fso As FileSystemObject
    Set fso = New FileSystemObject
    For Each cel In tblbydoc.Columns(1).Cells
        ' find row in table where the hyperlink address corresponds to the source document path
        If cel.Range.Hyperlinks.Count = 1 Then
            If fso.GetAbsolutePathName(fso.BuildPath(doctrcrinfo.Properties.Path, cel.Range.Hyperlinks(1).Address)) = docsrcinfo.Properties.Fullname Then
                Set GetTRCRSummaryByDocTableCell = cel
                Exit For ' cell found, so exit loop
            End If
        End If
    Next cel
End Function

Sub SetTRCRSummaryTableRowDashes(ByRef cel As Cell)
    '==================================================================================================================================
    ' Description: Initialises the rest of the given summary table row cells with dashes
    '==================================================================================================================================
    Dim celset As Cell, idx As Integer
    Set celset = cel
    For idx = Const_TRCSUMMARY_BYDOC_TRCTYPE_COL - 1 To Const_TRCSUMMARY_BYDOC_TRCTYPE_COL - 1 + Const_TRCSUMMARY_BYDOC_NUMCOLS
        Set celset = celset.Next
        celset.Range.Text = "-"
    Next idx
End Sub

Private Sub UpdateTRCRSummaryJstColumns(ByRef tblsum As Table, ByRef tblbydoc As Table)
    '==================================================================================================================================
    ' Description: Updates the [Justified] and [Unresolved] values in the given summary tables of a TRCR document - the function assumes
    '              all justifications have been resolved and that the [Justified] columns are alwayd 2nd last
    '==================================================================================================================================
    Dim trcsum As cTrcSummary, cel As Cell
    Set trcsum = New cTrcSummary ' assume justifications have all been resolved, so init to zeros
    For Each cel In tblsum.Columns(tblsum.Columns.Count - 1).Cells
        If cel.RowIndex > 1 Then Call UpdateSummaryJstColumns(cel, trcsum)
    Next cel
    
    For Each cel In tblbydoc.Columns(tblbydoc.Columns.Count - 1).Cells
        If cel.RowIndex > 1 Then Call UpdateSummaryJstColumns(cel, trcsum)
    Next cel
End Sub

Private Sub UpdateSourceSummaryJstColumns(ByRef tbljst As Table, ByRef tblsum As Table)
    '==================================================================================================================================
    ' Description: Parses the given justifications table and updates the [Justified] and [Unresolved] values in the given summary table
    '              of a source document
    '==================================================================================================================================
    Dim trcdoc As cTrcDocTraces, trcsum As cTrcSummary, rw As Row, cel As Cell, rng As Range, strtracetype As String
    
    Set trcdoc = New cTrcDocTraces
    
    ' compute the metrics for each of the trace types that have been justified
    For Each rw In tbljst.Rows
        If rw.Index > 1 Then
            Set rng = rw.Cells(1).Range
            ' point to the trace type portion
            rng.MoveStartUntil "("
            rng.End = rng.Start
            rng.MoveEndUntil ")"
            strtracetype = GetTraceTypeText(rng)
            
            ' use the summary objects to accumulate the values
            If Not trcdoc.Summaries.Exists(strtracetype) Then
                Set trcsum = New cTrcSummary
                trcsum.TrcType = strtracetype
                trcdoc.Summaries.Add strtracetype, trcsum
            End If
            Set trcsum = trcdoc.Summaries(strtracetype)
                        
            If IsJustificationResolved(rw.Cells(2)) Then
                trcsum.Justified = trcsum.Justified + 1
            Else
                trcsum.Unresolved = trcsum.Unresolved + 1
            End If
        End If
    Next rw
    
    ' update the Justified and Unresolved summary table columns
    For Each cel In tblsum.Columns(1).Cells
        If cel.RowIndex > 1 Then
            ' get the trace type and summary info
            strtracetype = GetTraceTypeText(cel.Range)
            If trcdoc.Summaries.Exists(strtracetype) Then
                Set trcsum = trcdoc.Summary(strtracetype)
            Else
                Set trcsum = New cTrcSummary ' no JSTs, so init to zeros
            End If
            Call UpdateSummaryJstColumns(cel.Range.Next(wdCell, 3).Cells(1), trcsum) ' assume JST is the 4th column
        End If
    Next cel
End Sub

Private Sub UpdateSummaryJstColumns(ByRef cel As Cell, ByRef trcsum As cTrcSummary)
    '==================================================================================================================================
    ' Description: Updates the [Justified] and [Unresolved] columns from the given cell using the given summary object. This function
    '              assumes the given cell reference is the [Justified] column and the [Unresolved] column is the next column.
    '==================================================================================================================================
    cel.Range.Text = IIf(trcsum.Justified, trcsum.Justified, "-")
    With cel.Next.Range
        If trcsum.Unresolved Then
            .Text = trcsum.Unresolved
            .Font.ColorIndex = wdRed
        Else
            .Text = "-"
            .Font.ColorIndex = wdBlack
        End If
    End With
End Sub
Attribute VB_Name = "basTables"
Option Explicit

Public Const Const_STYLE_TABLE_TEXT As String = "Table Text"
Public Const Const_STYLE_TABLE_TEXT_SMALL As String = "Table Text Small"

Public Const Const_TABLE_WIDTH As Single = 17
Public Const Const_TABLE_LEFT_INDENT As Single = 0#

Function GetCellText(ByRef cel As Cell) As String
    Dim strtext As String
    strtext = cel.Range
    GetCellText = Trim(Left(strtext, Len(strtext) - 2)) ' strip off end-of-cell marker
End Function

Function GetCellValue(ByRef cel As Cell) As Long
    Dim strtext As String
    strtext = GetCellText(cel)
    If IsNumeric(strtext) Then
        GetCellValue = Val(strtext)
    Else
        GetCellValue = 0
    End If
End Function

Function SetRangeToEndOfCell(ByRef cel As Cell) As Range
    Dim rng As Range
    Set rng = cel.Range
    rng.End = rng.End - 1
    rng.Collapse wdCollapseEnd
    Set SetRangeToEndOfCell = rng
End Function
                        
Function GetTable(ByRef objdoc As Document, ByVal strbookmark As String, Optional ByRef strmessage As String) As Table
    Dim rng As Range
    
    ' get table associated with the bookmark
    If objdoc.Bookmarks.Exists(strbookmark) Then
        ' get the range of the bookmark
        Set rng = objdoc.Bookmarks(strbookmark).Range.Paragraphs(1).Range
        ' check if the range is in a table, or else assume the range is the table caption, so check if there's a table directly below the caption
        If IsRangeInTable(rng) Then
            Set GetTable = rng.Tables(1)
        ElseIf IsRangeInTable(rng.Next(wdParagraph)) Then
            Set GetTable = rng.Next(wdTable).Tables(1)
        Else
            strmessage = "No table was found directly below caption bookmarked with '" & strbookmark & "' in '" & objdoc.Name & "'"
        End If
    Else
        strmessage = "Bookmark '" & strbookmark & "' not found in '" & objdoc.Name & "'"
    End If
    
End Function

Function GetTableName(ByRef tbl As Table) As String
    '==================================================================================================================================
    ' Description: Returns the bookmark name associated with the given table - assume the bookmarked caption is above table
    '==================================================================================================================================
    If Not tbl Is Nothing Then
        With tbl.Range.Previous(wdParagraph)
            If .Bookmarks.Count > 0 Then GetTableName = .Bookmarks(1).Name
        End With
    End If
End Function
        
Function GetTableBeneathText(ByRef objdoc As Document, ByVal strtext As String, Optional ByRef strmessage As String) As Table
    Dim rng As Range, blfound As Boolean
On Error GoTo Err_GetTableBeneathText

    Call ScreenUpdatePause
    
    Set rng = objdoc.Range
    With rng.Find
        .Forward = True
        .ClearFormatting
        .MatchWholeWord = False
        .MatchSoundsLike = False
        .MatchWildcards = False
        .MatchCase = False
        .Wrap = wdFindContinue
    End With
    If rng.Find.Execute(FindText:=strtext) = True Then
        blfound = True
        ' skip hits in the table of contents
        If rng.Style Like "TOC*" Then
            blfound = rng.Find.Execute(FindText:=strtext)
        End If
    End If
    Call ScreenUpdateRestore
    
    If blfound Then
        ' move down into the table
        Set rng = rng.Next(wdTable)
        If IsRangeInTable(rng) Then
            Set GetTableBeneathText = rng.Tables(1)
        Else
            strmessage = "No table found below the text '" & strtext & "' in '" & objdoc.Name & "'"
        End If
    Else
        strmessage = "Could not locate text '" & strtext & "' - no table found in '" & objdoc.Name & "'"
    End If

Exit_GetTableBeneathText:
    Exit Function

Err_GetTableBeneathText:
    If Err.Number = 9099 Then
        strmessage = "Could not execute Word's command to find the table below the text '" & strtext & "' in '" & objdoc.Name & "'. Close an re-open all Word instances if the problem persists."
    Else
        MsgBox "Error " & Err.Number & " (" & Err.Description & ") in GetTableBeneathText() of basTables"
    End If
    Resume Exit_GetTableBeneathText
End Function

Function DeleteTable(ByRef objdoc As Document, ByVal strbookmark As String) As Range
    Dim rng As Range, tbl As Table
    
    Set tbl = GetTable(objdoc, strbookmark)
    
    ' delete table and caption associated with the bookmark
    If Not tbl Is Nothing Then
        tbl.Delete
        Set rng = objdoc.Bookmarks(strbookmark).Range.Paragraphs(1).Range
        rng.Delete
        Set DeleteTable = rng
    End If
    
End Function

Function CreateTableTemplate(ByRef rng As Range, _
                             Optional ByVal numrows As Long = 5, Optional ByVal numcols As Long = 3, _
                             Optional ByVal strcaption As String = vbNullString, Optional ByVal strbookmark As String = vbNullString, _
                             Optional ByVal blsmallfont As Boolean = False, Optional ByVal blparspacezero As Boolean = False, Optional ByVal bladdcrossref As Boolean = False) As Table
    Dim tbl As Table, idx As Integer, lngwidth As Long, rngcap As Range, rngxref As Range
On Error GoTo Err_CreateTableTemplate

    Call ScreenUpdatePause
    
    ' Add a new table if not directly below an existing table
    If rng.Previous(wdParagraph).Tables.Count = 0 Then
        Set rngxref = rng.Document.Range
        rngxref.SetRange rng.Start, rng.End
            
        Set tbl = rng.Tables.Add(rng, numrows, numcols, wdWord9TableBehavior, wdAutoFitFixed)
        tbl.AllowAutoFit = False ' make sure colum widths don't adjust to contents
        
        ' Fill in default column headings and widths
        lngwidth = CentimetersToPoints(Const_TABLE_WIDTH / numcols)
        For idx = 1 To numcols
            tbl.Columns(idx).SetWidth lngwidth, wdAdjustNone
            tbl.Cell(1, idx).Range.Text = "[Heading Column " & idx & "]"
        Next idx
        
        ' Apply the formatting and styles to the new table
        Set rngcap = FormatTable(tbl, blsmallfont, blparspacezero, strcaption, strbookmark)
        
        ' Indent the table so it lines up with the paragraph text and left align the table
        tbl.Rows.LeftIndent = CentimetersToPoints(Const_TABLE_LEFT_INDENT)
        tbl.Rows.Alignment = wdAlignRowLeft
        
        If bladdcrossref Then
            ' insert cross reference to caption and select caption so user can edit it
            Call InsertXRefToCaption(wdCaptionTable, rngcap.Text, rngxref)
            rngcap.SetRange rngcap.End - Len(strcaption), rngcap.End
            rngcap.Select
        End If
        
        Set CreateTableTemplate = tbl
    Else
        MsgBox "Cannot create a table directly below an existing table.", vbExclamation, "DST Table Create"
    End If
    
Exit_CreateTableTemplate:
    Call ScreenUpdateRestore
    Exit Function
    
Err_CreateTableTemplate:
    MsgBox Err.Description & " in CreateTableTemplate()"
    Resume Exit_CreateTableTemplate
End Function

Sub FormatExistingTable(ByRef objdoc As Document, ByVal blsmalltext As Boolean, ByVal blparspacezero As Boolean)

    If objdoc.ActiveWindow.Selection.Tables(1).Rows.Count > 1 Then
        Call FormatTable(objdoc.ActiveWindow.Selection.Tables(1), blsmalltext, blparspacezero)
    Else
        MsgBox "The table must have more than one row before it can be formatted.", vbExclamation, "DST Table Format"
    End If
    
End Sub

Function FormatTable(ByRef tbl As Table, Optional ByVal blsmalltext As Boolean = False, Optional ByVal blparspacezero As Boolean = False, _
                     Optional ByVal strcaption As String = vbNullString, Optional ByVal strbookmark As String = vbNullString) As Range
    Dim blxreftable As Boolean, blamendrecord As Boolean, tblamend As Table
    Dim strstyle As String, rng As Range, blstylemessage As Boolean
On Error GoTo Err_FormatTable

    Call ScreenUpdatePause
    
    If ValidateAmendmentRecordTable(tbl.Range.Document, tblamend, True) = vbNullString Then
        blamendrecord = tbl.Range.InRange(tblamend.Range)
        If blamendrecord And Not tblamend.Uniform Then
            ' convert table to text and back to a table to make it uniform
            Set tbl = tblamend.Rows.ConvertToText(wdSeparateByTabs).ConvertToTable(wdSeparateByTabs, , , , , True)
        End If
    End If
    
    With tbl
        ' set the style
        If blsmalltext Then
            strstyle = Const_STYLE_TABLE_TEXT_SMALL
        Else
            strstyle = Const_STYLE_TABLE_TEXT
        End If
        
        ' Determine whether this is the external references table
        If InDocExtRefsTable(.Range) Then
            blxreftable = True
        End If
                
        ' Apply the table row properties and don't allow rows to break across pages
        Set rng = .Range
        If Not blxreftable Then ' don't use styles in external references table
            If StyleExists(rng.Document, strstyle) = True Then
                rng.Style = strstyle
            Else
                blstylemessage = True
            End If
        End If
        
        ' Format the header row and apply shading and style
        Call FormatRowAsHeading(.Rows(1), , blxreftable, blsmalltext)
        .Rows(1).HeadingFormat = True
    
        ' Apply the outside border formats
        With .Borders(wdBorderLeft)
            .LineStyle = wdLineStyleSingle
            .LineWidth = wdLineWidth075pt
            .Color = wdColorAutomatic
        End With
        With .Borders(wdBorderRight)
            .LineStyle = wdLineStyleSingle
            .LineWidth = wdLineWidth075pt
            .Color = wdColorAutomatic
        End With
        With .Borders(wdBorderTop)
            .LineStyle = wdLineStyleSingle
            .LineWidth = wdLineWidth075pt
            .Color = wdColorAutomatic
        End With
        With .Borders(wdBorderBottom)
            .LineStyle = wdLineStyleSingle
            .LineWidth = wdLineWidth075pt
            .Color = wdColorAutomatic
        End With
        
        ' Apply the inner border formats
        With .Borders(wdBorderHorizontal)
            .LineStyle = wdLineStyleSingle
            .LineWidth = wdLineWidth075pt
            .Color = wdColorAutomatic
        End With
        With .Borders(wdBorderVertical)
            .LineStyle = wdLineStyleSingle
            .LineWidth = wdLineWidth075pt
            .Color = wdColorAutomatic
        End With
        .Borders(wdBorderDiagonalDown).LineStyle = wdLineStyleNone
        .Borders(wdBorderDiagonalUp).LineStyle = wdLineStyleNone
        .Borders.Shadow = False
    
        ' Override the paragraph spacing after the styles have been applied
        If blparspacezero Or blamendrecord Then
            .Range.ParagraphFormat.SpaceBefore = 0
            .Range.ParagraphFormat.SpaceAfter = 0
        Else
            .Range.ParagraphFormat.SpaceBefore = 3
            .Range.ParagraphFormat.SpaceAfter = 3
        End If
    
        ' apply some specific external references table settings
        If blxreftable Then
            With .Range
                .NoProofing = True
                With .Font
                    .Size = 7
                    .Bold = False
                    .Italic = False
                End With
                With .ParagraphFormat
                    .SpaceBefore = 0
                    .SpaceAfter = 0
                    .LineSpacingRule = wdLineSpaceSingle
                End With
            End With
        End If
    End With
    
    If blamendrecord Then
        With tbl
            ' Indent the table so it lines up with the paragraph text
            .Rows.LeftIndent = CentimetersToPoints(Const_TABLE_LEFT_INDENT)
            
            ' Adjust the column widths
            If .Columns.Count = 4 Then
                .Columns(1).Width = CentimetersToPoints(2.25)
                .Columns(2).Width = CentimetersToPoints(2.75)
                .Columns(3).Width = CentimetersToPoints(3.5)
                .Columns(4).Width = CentimetersToPoints(8.5)
            ElseIf .Columns.Count = 5 Then
                .Columns(1).Width = CentimetersToPoints(3.25)
                .Columns(2).Width = CentimetersToPoints(5.5)
                .Columns(3).Width = CentimetersToPoints(2.25)
                .Columns(4).Width = CentimetersToPoints(2.75)
                .Columns(5).Width = CentimetersToPoints(3.25)
            End If
            
            ' Centre the last three columns - have to use the Selection object to get column as paragraph
            .Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
            .Columns(1).Select
            Selection.ParagraphFormat.Alignment = wdAlignParagraphLeft
            If .Columns.Count = 5 Then
                .Columns(2).Select
                Selection.ParagraphFormat.Alignment = wdAlignParagraphLeft
            End If
            Selection.Collapse
            
            ' Header row is centre-aligned and spaced
            With .Rows(1).Range.ParagraphFormat
                .Alignment = wdAlignParagraphCenter
                .SpaceBefore = 3
                .SpaceAfter = 3
            End With
        End With
    Else
        ' Point to the line above the table and insert the table caption if required
        rng.Start = tbl.Range.Start
        rng.Collapse wdCollapseStart
        Set rng = rng.Previous(wdParagraph)
        If blxreftable Then strcaption = "Bookmarks in Other Documents"
        If strcaption <> vbNullString And (Left(rng.Text, 6) <> "Table " Or rng.Style <> "DSTCaptionTable") Then
            With Application.CaptionLabels(wdCaptionTable)
                .NumberStyle = wdCaptionNumberStyleArabic
                .IncludeChapterNumber = True
                .ChapterStyleLevel = IIf(IsInAppendixRange(rng), 7, 1) ' 1st level appendix style (Appendix 1) starts at level 7
                .Separator = wdSeparatorEnDash ' do not use hyphen as a separator, doing Range.Text on caption strips out the hyphen
            End With
            
            ' insert the caption below the current range
            rng.InsertCaption wdCaptionTable, ": " & strcaption, vbNullString, wdCaptionPositionBelow, False
            
            ' point back to the caption
            Set rng = rng.Next(wdParagraph)
            rng.MoveEnd wdCharacter, -1  ' to exclude paragraph marker
            
            ' add bookmark to caption if specified
            If strbookmark <> vbNullString Then
                Dst.Document(rng.Document.Fullname).Bookmarks.Add strbookmark, rng
            End If
            Set FormatTable = rng ' return range that points to caption
        End If
        If Left(rng.Text, 6) = "Table " Then
            If StyleExists(rng.Document, "DSTCaptionTable") = True Then
                rng.Style = "DSTCaptionTable"
            Else
                blstylemessage = True
            End If
        End If
    End If
    
    If blstylemessage Then
        MsgBox "Re-format the table using the 'Format' tool once the style is available in the current document.", vbInformation, "DST Table Format"
    End If

Exit_FormatTable:
    Call ScreenUpdateRestore
    Exit Function
    
Err_FormatTable:
    MsgBox Err.Description & " in FormatTable()"
    Resume Exit_FormatTable
End Function

Sub FormatRowAsHeading(ByRef rw As Row, Optional stopatcolfromend As Integer = 0, Optional ByVal blnostyle As Boolean = False, Optional ByVal blsmalltext As Boolean = False)
    Dim rng As Range, strstyle As String, idx As Integer
    
    For idx = 1 To rw.Cells.Count - stopatcolfromend
        Set rng = rw.Cells(idx).Range
        With rng
            If Not blnostyle Then
                If blsmalltext Then
                    strstyle = Const_STYLE_TABLE_TEXT_SMALL
                Else
                    strstyle = Const_STYLE_TABLE_TEXT
                End If
                strstyle = strstyle & " Header"
                If StyleExists(.Document, strstyle) = True Then
                    .Style = strstyle
                Else
                    MsgBox "Re-format the table using the 'Format' tool once the style is available in the current document.", vbInformation, "DST Table Header Format"
                End If
            End If
            With .Shading
                .Texture = wdTexture12Pt5Percent
                .ForegroundPatternColor = wdColorAutomatic
                .BackgroundPatternColor = wdColorAutomatic
            End With
        End With
    Next idx
    
End Sub

Function IsRangeInTable(ByRef rng As Range) As Boolean
On Error GoTo Err_IsRangeInTable
' NOTE: The Range.Information(wdWithInTable) property does not reliably indicate whether the given range is in a table - for some range
'       objects it even crashes Word. This function should be used instead

    IsRangeInTable = False
    If Not rng Is Nothing Then
        If rng.Tables.Count > 0 Then
            IsRangeInTable = True
            If rng.Cells.Count > 0 Then
                ' do nothing, method above may throw an error (see below)
            End If
        End If
    End If
    
Exit_IsRangeInTable:
    Exit Function

Err_IsRangeInTable:
    If Err.Number = 5907 Then
        ' this error implies that the range has a table count and the ensueing rng.Cells.Count method throws an
        ' error stating that there is no table in the range - this occurs when the cursor is immediately below a table,
        ' so in this case, we're not in a table
        IsRangeInTable = False
    Else
        MsgBox Err.Description & " in IsRangeInTable() of basFields"
    End If
    Resume Exit_IsRangeInTable
        
End Function

Function GetSubTable(ByRef rng As Range) As Table
    Dim tbl As Table
    For Each tbl In rng.Tables(1).Tables
        If tbl.Range.InRange(rng) Then
            Set GetSubTable = tbl
        End If
    Next tbl
End Function

Function GetSubSectionLastCell(ByRef cel As Cell) As Cell
    '==================================================================================================================================
    ' Description: Returns the sub-section's last cell in the last row to the right of the given merged cell.
    '              NOTE: This function assumes there are no horizontally merged cells
    '==================================================================================================================================
    Dim tbl As Table
    Set tbl = cel.Range.Tables(1)
    Set GetSubSectionLastCell = tbl.Cell(cel.RowIndex + GetCellRowSpan(cel) - 1, tbl.Columns.Count)
End Function

Sub DeleteTabeSubRows(ByRef cel As Cell)
    '==================================================================================================================================
    ' Description: Deletes the sub-rows for the given parent cel, starting at the given column number. It is assumed that the parent
    '              cell is a vertically merged cell and that the given column number has unmerged cells.
    '==================================================================================================================================
    Dim celend As Cell
    Do
        Set celend = GetSubSectionLastCell(cel)
        If celend.RowIndex > cel.RowIndex Then
            celend.Delete wdDeleteCellsEntireRow
        Else
            Exit Do
        End If
    Loop
End Sub

Function GetCellRowSpan(ByRef cel As Cell) As Integer
    '==================================================================================================================================
    ' Description: Returns the row span of the given (merged) cell.
    '==================================================================================================================================
    cel.Select ' have to use selection object to read row number information below when table has merged cells
    GetCellRowSpan = Selection.Information(wdEndOfRangeRowNumber) - Selection.Information(wdStartOfRangeRowNumber) + 1
End Function

Sub MergeCells(ByRef celfrom As Cell, ByRef celto As Cell)
    If Not celfrom Is Nothing And Not celto Is Nothing Then
        If celfrom.RowIndex <> celto.RowIndex Then
            celfrom.Merge celto
        End If
    End If
End Sub

Sub InsertHyperlinkWithTextInCell(ByRef cel As Cell, ByVal strfromfolder As String, ByVal straddress As String, ByVal strdisplaytext As String, _
                                  Optional ByVal strsubaddress As String = vbNullString, Optional ByVal strtextbefore As String = vbNullString, Optional ByVal strtextafter As String = vbNullString)
    Dim rng As Range, hlnk As Hyperlink, strlinkadress As String
    
    If strfromfolder <> vbNullString Then
        strlinkadress = GetRelativePath(strfromfolder, straddress)
    Else
        strlinkadress = straddress
    End If
    
    Set rng = SetRangeToEndOfCell(cel)
    rng.InsertBefore strtextbefore
    Set rng = SetRangeToEndOfCell(cel)
    Set hlnk = rng.Hyperlinks.Add(rng, strlinkadress, strsubaddress, , strdisplaytext)
    hlnk.Range.Font.Size = rng.Font.Size
    Set rng = SetRangeToEndOfCell(cel)
    rng.InsertAfter strtextafter
    
End Sub

Function InsertParagraphAfterTable(ByRef tbl As Table) As Range
    Dim rw As Row, rng As Range
    '==================================================================================================================================
    ' Purpose: Inserts an empty paragraph after the given table. If a heading follows immediately after the table, the only way to add
    '          an empty paragraph without shifting the heading down is to add another row to the table and to then split the table and
    '          remove the blank table again.
    '==================================================================================================================================
    With tbl
        If .Uniform Then
            Set rw = .Rows.Add
            .Split(rw).Delete
        Else
            ' need to use Selection object to split table if it has merged cells
            .Rows.Add
            .Cell(.Rows.Count, 1).Select
            Selection.SplitTable
            Selection.Next(wdTable).Tables(1).Delete
        End If
        With .Borders(wdBorderBottom)
            .LineStyle = wdLineStyleSingle ' restore bottom border linestyle after split, in case
            .LineWidth = wdLineWidth075pt
            .Color = wdColorAutomatic
        End With
        Set rng = .Range.Next(wdParagraph)
    End With
    rng.Style = "Body Text"
    Set InsertParagraphAfterTable = rng
End Function
Attribute VB_Name = "basTemplates"
Option Explicit

Public Const Const_MASTERTEMPLATE_NAME As String = "dst-master.dotx"

Function GetTemplatePathNetworkDefault() As String
    GetTemplatePathNetworkDefault = "\\10.2.44.100\InfoPool\Templates"
End Function

Function GetTemplatePathLocalDefault() As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    GetTemplatePathLocalDefault = fso.GetAbsolutePathName(fso.BuildPath(Application.StartupPath, "templates"))
    Set fso = Nothing

End Function

Function GetPartsFromTemplateFilename(ByVal strtemplatename As String) As Variant
    Dim fso As FileSystemObject, strbasename As String, strsplitter As String, numparts As Integer, varparts As Variant
    
    ' assume parts are split by "-" character and have form dst-[<category>]-<type>
    Set fso = New FileSystemObject
    strsplitter = "-"
    
    If strtemplatename <> vbNullString Then
        strbasename = fso.GetBaseName(strtemplatename)
        numparts = 1 + UBound(Split(strbasename, strsplitter))
        If numparts < 3 Then strbasename = strbasename & String(3 - numparts, strsplitter) ' make sure we always return three parts
        varparts = Split(strbasename, "-", 3)
        GetPartsFromTemplateFilename = varparts
    End If
    Set fso = Nothing

End Function

Function CheckAttachedTemplateStatus(ByRef objdoc As Document) As String
    Dim strtemplate As String, strmessage As String

    With objdoc.Application.Dialogs(wdDialogToolsTemplates)
        strtemplate = .Template
        If strtemplate <> "Normal" And strtemplate <> vbNullString Then
            strmessage = "This document is attached to the '" & strtemplate & "' template. "
            If MsgBox(strmessage & "Would you like to detach it?", vbYesNo + vbQuestion) = vbYes Then
                .Template = vbNullString
                .Execute
            Else
                CheckAttachedTemplateStatus = strmessage & "Clear the 'Document Template' field in the Templates and Add-ins dialogue accessed from the Word Options."
            End If
        End If
    End With
    
End Function

Function ManageMasterTemplateDate(ByRef objdoc As Document, Optional ByVal blupdate As Boolean = False) As String
    Dim strtemplate As String, strtemplatedate As String, strimportdate As String
    Dim fso As FileSystemObject, fil As Scripting.File, docinfo As cDocInfo
    
    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(objdoc.Fullname)
    
    ' find the DST master template date and extract its date
    strtemplate = docinfo.Variables.MasterTemplateUsed
    If strtemplate <> vbNullString Then
        If fso.FileExists(strtemplate) Then
            Set fil = fso.GetFile(strtemplate)
            strtemplatedate = Format(fil.DateLastModified, Const_FORMAT_DATETIME)
            If blupdate Then
                docinfo.Variables.MasterTemplateDate = strtemplatedate
                ManageMasterTemplateDate = strtemplatedate
            Else
                strimportdate = Format(docinfo.Variables.MasterTemplateDate, Const_FORMAT_DATETIME)
                If strtemplatedate <> strimportdate Then
                    ManageMasterTemplateDate = "DST Master Template is now dated '" & strtemplatedate & "'. When the styles were last imported, the DST Master Template was dated '" & strimportdate & "'. Use the 'Import DST Styles' function to re-import the latest styles."
                End If
            End If
        End If
    End If
    
End Function
Attribute VB_Name = "basTestReportTableConfig"
Option Explicit

Function UpdateTestConfigTable(ByRef objdoc As Document, ByRef rpt As Object, ByVal strtable As String, ByRef srninfo As cSrns, ByRef frm As Object) As Boolean
    Dim cfg As cTestConfig, rng As Range, strmessage As String, strtemp As String, strothersubtype As String
    Dim tbl As Table, idx As Integer, numcols As Long, numcolsother As Long, numrowstoadd As Long, lngstartrowindex As Long
    Dim dicsubtypes As Scripting.Dictionary
    
    If strtable = Const_DOCTEST_CONFIGSUMMARY And rpt.ReportSubType Like "*testssum" Then
        ' do nothing
    ElseIf strtable = Const_DOCHLTEST_CONFIG And rpt.ReportSubType = "hltests" Then
        ' do nothing
    Else
        ' sub-type does not apply, so exit
        UpdateTestConfigTable = False
        frm.UpdateProgressText "ERROR: The '" & strtable & "' table does apply to '" & rpt.ReportSubType & "' reports"
        Exit Function
    End If
    
    ' first prepare the data for the given report (hl or ll)
    Set dicsubtypes = Dst.Document(objdoc.Fullname).Properties.SubTypesAsDictionary
    Set cfg = rpt.TestConfig
    If Not cfg Is Nothing Then
        frm.UpdateProgressText "Updating the " & strtable & " table for '" & rpt.ReportSubType & "'..."
        
        ' determine how many rows are required - note that the prepare summary table retains one row so the formatting is inherited when inserting new rows
        If rpt.ReportSubType Like "hltests*" Then
            numcols = 4
            numcolsother = 1
            numrowstoadd = 3 + IIf(cfg.TestConfigErrorsString <> vbNullString, 1, 0) ' fast row, test files row, LRU header row, config errors
            ' now add CSCI rows
            For idx = 0 To cfg.Lrus.Count - 1
                numrowstoadd = numrowstoadd + cfg.Lrus.Items(idx).Count
            Next idx
            If cfg.Lrus.Count > 0 Then numrowstoadd = numrowstoadd - 1 ' already added one LRU header row above
        Else
            numcols = 1
            numcolsother = 4
            numrowstoadd = 0 ' only one row is required
        End If
        
        ' prepare the relevant configuration table first
        If strtable = Const_DOCHLTEST_CONFIG Then
            Set rng = DeleteTable(objdoc, strtable)
            If Not rng Is Nothing Then
                Set tbl = CreateTableTemplate(rng, numrowstoadd + 1, numcols, "High-level Test Environment Identification", strtable, True)
                If tbl Is Nothing Then strmessage = "Unable to create the '" & strtable & "' table"
                lngstartrowindex = 1
            Else
                strmessage = "Unable to delete the '" & strtable & "' table"
            End If
        Else
            Set tbl = PrepareSummaryTable(objdoc, strtable, rpt.ReportSubType, numrowstoadd, numcols, lngstartrowindex, False, strmessage)
        End If
        
        ' now update the table content
        If Not tbl Is Nothing Then
            If rpt.ReportSubType Like "hltests*" Then
                If Not UpdateHlTestConfigTable(tbl, cfg, rpt.ReportSubType, dicsubtypes, lngstartrowindex, numrowstoadd) Then
                    strmessage = "Configuration errors were found"
                End If
                    
                ' check config against SRN
                strtemp = CheckTestFilesVersionAgainstSrnCscis(tbl, srninfo)
                If strtemp <> vbNullString Then
                    strmessage = AddStatusText(strmessage, strtemp)
                End If
            Else
                If Not UpdateLlTestConfigTable(tbl, cfg, lngstartrowindex) Then
                    strmessage = "Configuration errors were found"
                End If
            End If
        End If
        
        ' now clear the data if the other report has no data (hl or ll)
        If strtable <> Const_DOCHLTEST_CONFIG Then
            strothersubtype = GetOtherReportSubType(rpt.ReportSubType)
            If Not dicsubtypes.Exists(strothersubtype) Then
                Set tbl = PrepareSummaryTable(objdoc, strtable, strothersubtype, 0, numcolsother, lngstartrowindex, True, strmessage)
            Else
                ' do nothing - the table will be/has already been updated in the next/previous iteration
            End If
        End If
    Else
        strmessage = "Could not set reference to the configuration data"
    End If
    
    ' update error status
    UpdateTestConfigTable = ProcessStatusMessage(strmessage, frm)
    
End Function

Private Function UpdateHlTestConfigTable(ByRef tbl As Table, ByRef cfg As cTestConfig, ByVal strreportsubtype As String, _
                                         ByRef dicsubtypes As Scripting.Dictionary, ByVal lngstartrowindex As Long, ByVal numrows As Long) As Boolean
    Dim idxlru As Integer, idx As Integer, offset As Integer, cscilist As Scripting.Dictionary, srn As cSrn, cscientry As cCsci
    Dim strtemp As String, strtext As String
    
    UpdateHlTestConfigTable = True
    
    With tbl
        ' adjust the table cell widths
        For idx = lngstartrowindex To lngstartrowindex + numrows
            .Rows(idx).Cells(1).SetWidth CentimetersToPoints(2), wdAdjustNone
            .Rows(idx).Cells(2).SetWidth CentimetersToPoints(6.5), wdAdjustNone
            .Rows(idx).Cells(3).SetWidth CentimetersToPoints(5.5), wdAdjustNone
            .Rows(idx).Cells(4).SetWidth CentimetersToPoints(3), wdAdjustNone
            If idx <> lngstartrowindex Then
                With .Rows(idx).Range
                    .Font.Bold = False
                    .Font.ColorIndex = wdAuto
                    .Shading.Texture = wdTextureNone
                    .Shading.BackgroundPatternColorIndex = wdColorAutomatic
                    .Shading.ForegroundPatternColor = wdColorAutomatic
                    .ParagraphFormat.Alignment = wdAlignParagraphLeft
                End With
            End If
        Next idx
            
        offset = lngstartrowindex
        .Cell(offset, 1).Range.Text = "LRU"
        .Cell(offset, 2).Range.Text = "Version Tag"
        .Cell(offset, 3).Range.Text = "Item"
        .Cell(offset, 4).Range.Text = "Checksum"
                
        offset = offset + 1
        .Cell(offset, 1).Range.Text = "FAST"
        strtext = cfg.FastVersion
        If strtext = vbNullString Then
            UpdateHlTestConfigTable = False
            strtext = Const_DOC_ERROR_STRING & " Unknown"
            .Cell(offset, 2).Range.Font.ColorIndex = wdRed
        End If
        .Cell(offset, 2).Range.Text = strtext
        .Cell(offset, 3).Range.Text = Const_CORE_VERSION_TEXT
        .Cell(offset, 4).Range.Text = "N/A"
            
        offset = offset + 1
        .Cell(offset, 1).Borders(wdBorderTop).LineStyle = wdLineStyleNone
        strtext = cfg.TestFilesVersion
        If strtext = vbNullString Then
            UpdateHlTestConfigTable = False
            strtext = Const_DOC_ERROR_STRING & " Unknown"
            .Cell(offset, 2).Range.Font.ColorIndex = wdRed
        End If
        .Cell(offset, 2).Range.Text = strtext
        .Cell(offset, 3).Range.Text = Const_TEST_FILES_TEXT
        .Cell(offset, 4).Range.Text = "N/A"
        
        offset = offset + 1
        If cfg.Lrus.Count = 0 Then
            .Cell(offset, 1).Range.Text = "LRU"
            .Cell(offset, 2).Range.Text = "N/A"
            .Cell(offset, 3).Range.Text = "No items captured"
            .Cell(offset, 4).Range.Text = "N/A"
            offset = offset + 1 ' adjust offset
        Else
            For idxlru = 0 To cfg.Lrus.Count - 1
                If cfg.Srns.Exists(cfg.Lrus.Keys(idxlru)) Then
                    Set srn = cfg.Srns.Item(cfg.Lrus.Keys(idxlru))
                Else
                    Set srn = Nothing
                End If
                Set cscilist = cfg.Lrus.Items(idxlru)
                For idx = 0 To cscilist.Count - 1
                    Set cscientry = cscilist.Items(idx)
                    ' group same LRUs in first column
                    If idx = 0 Then
                        .Cell(offset + idx, 1).Range.Text = cfg.Lrus.Keys(idxlru)
                    Else
                        .Cell(offset + idx, 1).Range.Text = vbNullString
                        .Cell(offset + idx, 1).Borders(wdBorderTop).LineStyle = wdLineStyleNone
                    End If
                    ' use the SRN info for these cells - if available
                    If Not srn Is Nothing Then
                        If srn.Cscis.Exists(cscientry.BinName) Then
                            .Cell(offset + idx, 2).Range.Text = srn.Cscis(cscientry.BinName).VersionTag
                            .Cell(offset + idx, 4).Range.Text = srn.Cscis(cscientry.BinName).Checksum
                        Else
                            UpdateHlTestConfigTable = False
                            .Cell(offset + idx, 2).Range.Text = Const_DOC_ERROR_STRING & " Item not listed in SRN " & srn.Reference & " Issue " & srn.Issue
                            .Cell(offset + idx, 4).Range.Text = Const_DOC_ERROR_STRING & " Unknown"
                            .Rows(offset + idx).Range.Font.ColorIndex = wdRed
                        End If
                    Else
                        UpdateHlTestConfigTable = False
                        strtemp = Const_DOC_ERROR_STRING & " No SRN info available for the " & cfg.Lrus.Keys(idxlru) & " LRU"
                        .Cell(offset + idx, 2).Range.Text = strtemp
                        .Cell(offset + idx, 4).Range.Text = strtemp
                        .Rows(offset + idx).Range.Font.ColorIndex = wdRed
                    End If
                    .Cell(offset + idx, 3).Range.Text = cscientry.BinName
                Next idx
                offset = offset + idx
            Next idxlru
        End If
                                                                                                            
        strtext = cfg.TestConfigErrorsString
        If strtext <> vbNullString Then
            .Rows(offset).Cells.Merge
            If strreportsubtype = "hltests" Or (strreportsubtype = "hltestssum" And dicsubtypes.Exists("hltests")) Then
                UpdateHlTestConfigTable = False
                .Rows(offset).Range.Font.ColorIndex = wdRed
                .Cell(offset, 1).Range.Text = Const_DOC_ERROR_STRING & " " & strtext
            Else
                .Cell(offset, 1).Range.Text = "Configuration errors were found in one or more test results files. Refer to the relevant appendix STRs for the error justifications."
            End If
        End If
    End With

End Function

Private Function UpdateLlTestConfigTable(ByRef tbl As Table, ByRef cfg As cTestConfig, ByVal lngstartrowindex As Long) As Boolean
    Dim strtext As String, rng As Range
    
    UpdateLlTestConfigTable = True
    
    tbl.Rows(lngstartrowindex).Cells.Merge
    Set rng = tbl.Rows(lngstartrowindex).Cells(1).Range
    If cfg.TestConfigErrorsString <> vbNullString Then
        UpdateLlTestConfigTable = False
        rng.Font.ColorIndex = wdRed
        strtext = Const_DOC_ERROR_STRING & cfg.TestConfigErrorsString
    Else
        rng.Font.ColorIndex = wdAuto
        strtext = "The low-level test configurations are internally consistent - refer to the individual configuration identification files for details."
    End If
    rng.Text = strtext

End Function

Function CheckTestConfigTable(ByRef objdoc As Document, ByVal strtag As String) As String
    Dim doclst As cDocList, strdoctype As String, varsubtype As Variant, strmessage As String, strtemp As String
    Dim strconfigtable As String, strtestbaselinetable As String, strdataset As String, tbl As Table, rw As Row, cel As Cell
    Dim srninfo As cSrns, strchecksum As String, strversion As String, strbin As String, dicsubtypes As Scripting.Dictionary
    Dim idx As Integer, idxcsci As Integer, srn As cSrn, cscientry As cCsci, blmatchfound As Boolean, docinfo As cDocInfo
     
    Set docinfo = Dst.Document(objdoc.Fullname)
    strdoctype = docinfo.Properties.TypeAbbr
    If strdoctype = "STR" Then
        ' for each STR sub-type, check if we need to check the config table
        Set dicsubtypes = docinfo.Properties.SubTypesAsDictionary
        For Each varsubtype In dicsubtypes
            strconfigtable = GetTestConfigTableBookmark(varsubtype, objdoc)
            strtestbaselinetable = GetTestBaselineTableBookmark(varsubtype)
            strmessage = vbNullString
            If strconfigtable <> vbNullString And strtestbaselinetable <> vbNullString Then
                '======================================================================================
                ' check that the config table versions and checksums match those in the referenced SRN
                '======================================================================================
                ' get the SRN information associated with this STR
                strdataset = varsubtype
                If Not strdataset Like "*sum" Then strdataset = strdataset & "sum" ' must give SRN process a dataset
                Set doclst = docinfo.DocList
                Set srninfo = New cSrns
                strmessage = srninfo.ProcessSrns(doclst, strdataset, strtestbaselinetable)
                If strmessage = vbNullString Then
                    ' process the rows that have valid checksums in the last column
                    Set tbl = GetTable(objdoc, strconfigtable, strmessage)
                    If Not tbl Is Nothing Then
                        For Each rw In tbl.Rows
                            strtemp = vbNullString
                            Set cel = rw.Cells(rw.Cells.Count)
                            strchecksum = GetCellText(cel)
                            If InStr(1, strchecksum, "0x") = 1 Then
                                ' assume version tag is in the 2nd column and binary in 3rd column
                                strversion = GetCellText(rw.Cells(2))
                                strbin = GetCellText(rw.Cells(3))
                                
                                ' now find the SRN entry for this binary and validte it's checksum
                                blmatchfound = False
                                idx = 0
                                Do Until blmatchfound Or idx = srninfo.Srns.Count
                                    Set srn = srninfo.Srns.Items(idx)
                                    For idxcsci = 0 To srn.Cscis.Count - 1
                                        Set cscientry = srn.Cscis.Items(idxcsci)
                                        If cscientry.VersionTag = strversion And cscientry.BinName = strbin Then
                                            If cscientry.Checksum <> strchecksum Then
                                                strtemp = strbin & " checksum=" & strchecksum & ", SRN checksum=" & cscientry.Checksum
                                            End If
                                            blmatchfound = True
                                            Exit For
                                        End If
                                    Next idxcsci
                                    idx = idx + 1
                                Loop
                                
                                If Not blmatchfound Then
                                    strtemp = "No SRN info for " & strversion & ", " & strbin
                                End If
                                
                            End If
                            
                            If strtemp <> vbNullString Then
                                strmessage = strmessage & strtemp & vbCrLf
                            End If
                        Next rw
                    End If
                End If
                
                '=============================================================================
                ' also check that the specified tag is listed in the config table
                '=============================================================================
                If strtag <> vbNullString Then
                    strtemp = FindVersionTagInTable(objdoc, strconfigtable, strtag)
                    If strtemp <> vbNullString Then
                        strmessage = strmessage & strtemp & vbCrLf
                    End If
                End If
            End If
            
            If strmessage <> vbNullString Then
                CheckTestConfigTable = CheckTestConfigTable & strmessage & vbCrLf
            End If
        Next varsubtype
        
        If CheckTestConfigTable <> vbNullString Then
            CheckTestConfigTable = "Configuration errors found in the configuration table:" & vbCrLf & CheckTestConfigTable
        End If
    End If
    
End Function

Private Function FindVersionTagInTable(ByRef objdoc As Document, ByVal strtable As String, ByVal strtag As String) As String
    Dim tbl As Table, strmessage As String
    
    ' check that the test files entry's checksum matches the given SRN
    Set tbl = GetTable(objdoc, strtable, strmessage)
    If Not tbl Is Nothing Then
        If Not FindTextInRange(tbl.Range, strtag) Then
            strmessage = "The tag '" & strtag & "' is not listed in the " & strtable & " table."
        End If
    Else
        strmessage = "Could not get a table reference to the " & strtable & " table"
    End If
    
    FindVersionTagInTable = strmessage
    
End Function
    
Private Function CheckTestFilesVersionAgainstSrnCscis(ByRef tblconfig As Table, ByRef srninfo As cSrns) As String
    Dim tbl As Table, rng As Range, blbinfound As Boolean
    Dim strmessage As String, idx As Integer, idxsrn As Integer, idxcsci As Integer, cel As Cell, srn As cSrn, csc As cCsci
    Dim strbin As String, strtag As String, strchecksum As String
    
    ' check that the test files entry's checksum matches the given SRN if the SRN is in SDLC
    For idx = 2 To tblconfig.Rows.Count ' start in second row
        Set cel = tblconfig.Cell(idx, 3) ' point to binary name
        If GetCellText(cel) = Const_TEST_FILES_TEXT Then
            strtag = GetCellText(cel.Previous)
            If Not strtag Like Const_DOC_ERROR_STRING & "*" And strtag <> "N/A" Then
                Set srn = srninfo.Srns.Items(0) ' assume first entry is for the software under test
                If srn.InSdlc Then
                    For idxcsci = 0 To srn.Cscis.Count - 1
                        Set csc = srn.Cscis.Items(idxcsci)
                        If strtag = csc.VersionTag Then
                            Exit For ' match found, so exit
                        End If
                    Next idxcsci
                    
                    If idxcsci >= srn.Cscis.Count Then
                        cel.Previous.Range.Text = Const_DOC_ERROR_STRING & " " & strtag & " - version tag not listed on first SRN"
                        cel.Previous.Range.Font.ColorIndex = wdRed
                        strmessage = "Configuration errors were found against the first SRN"
                    End If
                Else
                    cel.Previous.Range.Text = strtag & vbCrLf & "(version tag was verified manually against SRN)"
                End If
            Else
                strmessage = "Could not obtain the " & Const_TEST_FILES_TEXT & " version tag from the result files"
            End If
            Exit For ' found test files entry, so exit
        End If
    Next idx

    CheckTestFilesVersionAgainstSrnCscis = strmessage
    
End Function
Attribute VB_Name = "basTestReportTableCoverage"
Option Explicit

Function UpdateStructuralCoverageTable(ByRef objdoc As Document, ByRef rpt As cCoverageReport, ByVal strtable As String, ByRef frm As Object) As Boolean
    Dim rng As Range, rngtbljst As Range, strtitle As String, strmessage As String, strjsttable As String
    Dim jstcovnew As Scripting.Dictionary, jstcovcur As Scripting.Dictionary, jstcovstr As Scripting.Dictionary
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
       
    ' storage for the incomplete coverage justifications
    Set jstcovnew = New Scripting.Dictionary
    Set jstcovcur = New Scripting.Dictionary
    
    ' table only applies to coverage analysis reports
    If strtable = Const_DOCHLSTRUCTCOV And rpt.ReportSubType = "hlstructcov" Then
        strtitle = "High-level Structural Coverage"
    ElseIf strtable = Const_DOCLLSTRUCTCOV And rpt.ReportSubType = "llstructcov" Then
        strtitle = "Low-level Structural Coverage"
    Else
        ' sub-type does not apply, so exit
        frm.UpdateProgressText "ERROR: The '" & strtable & "' table does apply to '" & rpt.ReportSubType & "' reports"
        Exit Function
    End If
    
    ' store the existing justifications for incomplete coverage listed in the STR
    strjsttable = Const_DOCSTRUCTCOV_JSTS
    Set jstcovstr = New Scripting.Dictionary
    Call StoreJustificationBookmarks(GetTable(objdoc, strjsttable).Range, Const_JST_BMRK_PREFIX_INCOMPLETECOV, jstcovstr)

    ' create the coverage analysis table
    frm.UpdateProgressText "Updating the " & strtable & " table..."
    If Not UpdateCoverageAnalysisTable(objdoc, strtable, strtitle, rpt, jstcovcur, jstcovnew, jstcovstr, strmessage, frm) Then
        strmessage = AddStatusText(strmessage, "Unable to update the " & strtitle & " analysis table")
    End If
    
    ' point to existing justifications table and create a temporary reference to it so it can be deleted afterwards
    Set rngtbljst = GetTable(objdoc, strjsttable).Range
    rngtbljst.MoveStart wdParagraph, -1 ' include table caption
    Set rng = objdoc.Range
    rng.SetRange rngtbljst.Start, rngtbljst.Start
    rng.Move wdCharacter, -1
    rng.InsertParagraphAfter ' to allow new table to be created
    rng.Collapse wdCollapseEnd
    If Not rng Is Nothing Then
        strmessage = AddStatusText(strmessage, _
                     InsertJustificationsTable(rng, jstcovnew, jstcovcur, "Justifications for Incomplete Coverage", strjsttable, "Justification Identifier", frm))
    Else
        strmessage = AddStatusText(strmessage, "Unable to delete the incomplete coverage justifications table")
    End If
        
    ' delete existing justifications table and the empty paragraph above it
    rngtbljst.Delete
    rng.Delete
        
    ' update error status
    UpdateStructuralCoverageTable = ProcessStatusMessage(strmessage, frm)
    
End Function

Sub UpdateCoverageSummaryRow(ByRef objdoc As Document, ByRef rw As Row, ByRef rptcov As cCoverageReport, ByRef strmessage As String)
    Dim rptmetric As cCoverageMetric, fso As FileSystemObject, rnghlnk As Range, cel As Cell, strcoveragefilerelpath As String
    
    Set fso = New FileSystemObject
    
    With rw
        Set cel = .Cells(1)
        cel.Range.Text = "Overall for this CSCI"
        cel.Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                                
        ' add hyperlink to test results file
        Set cel = cel.Next
        Set rnghlnk = cel.Range
        rnghlnk.ParagraphFormat.Alignment = wdAlignParagraphLeft
        rnghlnk.Text = fso.GetFileName(rptcov.CoverageResultsFile)
        strcoveragefilerelpath = GetRelativePath(objdoc.Path, rptcov.CoverageResultsFile)
        rnghlnk.Hyperlinks.Add rnghlnk, strcoveragefilerelpath
        rnghlnk.Collapse wdCollapseEnd
        
        rnghlnk.SetRange rnghlnk.End - 2, rnghlnk.End - 2 ' move to just before the end-of-cell marker
        If Not rptcov.ConfigStatus.BaselineIntegrity Then
            rnghlnk.InsertParagraphAfter
            rnghlnk.Collapse wdCollapseEnd
            rnghlnk.Style = wdStyleDefaultParagraphFont
            strmessage = AddStatusText(strmessage, "Coverage baseline error - see red-coloured text in document")
            rnghlnk.Text = Const_DOC_ERROR_STRING & " The coverage results were not obtained on a consistent source code baseline. "
            rnghlnk.Font.ColorIndex = wdRed
        End If
        If rptcov.ConfigStatus.ConstraintViolations > 0 Then
            rnghlnk.InsertParagraphAfter
            rnghlnk.Collapse wdCollapseEnd
            rnghlnk.Style = wdStyleDefaultParagraphFont
            strmessage = AddStatusText(strmessage, "Coverage constraint error - see red-coloured text in document")
            rnghlnk.Text = Const_DOC_ERROR_STRING & " There are " & rptcov.ConfigStatus.ConstraintViolations & " coverage constraint violations in the source code."
            rnghlnk.Font.ColorIndex = wdRed
        End If
    
        ' set coverage percentages
        Set rptmetric = rptcov.CoverageMetrics
        Set cel = cel.Next
        cel.Range.Text = rptmetric.StatementPercentage
        cel.Range.Font.Bold = True
        Set cel = cel.Next
        cel.Range.Text = rptmetric.DecisionPercentage
        cel.Range.Font.Bold = True
        Set cel = cel.Next
        cel.Range.Text = rptmetric.McdcPercentage
        cel.Range.Font.Bold = True
    End With
    
End Sub

Private Function UpdateCoverageAnalysisTable(ByRef objdoc As Document, ByRef strtable As String, ByVal strtitle As String, ByRef rpt As cCoverageReport, _
                                             ByRef jstcovcur As Scripting.Dictionary, ByRef jstcovnew As Scripting.Dictionary, ByRef jstcovstr As Scripting.Dictionary, _
                                             ByRef strmessage As String, ByRef frm As Object) As Boolean
    Dim tbl As Table, rw As Row, rwfunc As Row, rng As Range, rnghlnk As Range, rngjst As Range, cel As Cell
    Dim covmod As cCoverageModule, covmetric As cCoverageMetric, covmetricfunc As cCoverageMetric, citem As cConfigItem
    Dim strmodule As String, strmodulebasename As String, strfunction As String, strbkmark As String, strcvslocation As String
    Dim idx As Integer, idxfunc As Integer, idxjst As Integer, fso As FileSystemObject, intmaxlength As Integer, docinfo As cDocInfo
        
    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(objdoc.Fullname)
       
    ' delete table
    Set rng = DeleteTable(objdoc, strtable)
    
    ' generate new table
    If Not rng Is Nothing Then
        ' insert a blank line before the next table if there isn't one - the fact that the range has a bookmark means the range is already at the next table caption, so a blank line is required
        If rng.Bookmarks.Count > 0 Then
            rng.Move wdParagraph, -1
            Set rng = rng.Paragraphs(1).Range
            rng.End = rng.End - 1
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
        End If
        Set tbl = CreateTableTemplate(rng, 3, 5, strtitle, strtable, True) ' note that additional rows are added below as required
        If Not tbl Is Nothing Then
            With tbl
                .Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                
                ' adjust the column widths
                .Columns(1).SetWidth CentimetersToPoints(7), wdAdjustNone
                .Columns(2).SetWidth CentimetersToPoints(3.7), wdAdjustNone
                .Columns(3).SetWidth CentimetersToPoints(2.1), wdAdjustNone
                .Columns(4).SetWidth CentimetersToPoints(2.1), wdAdjustNone
                .Columns(5).SetWidth CentimetersToPoints(2.1), wdAdjustNone
                    
                ' header row
                With .Rows(1)
                    .Cells(1).Range.Text = "Identifier"
                    .Cells(2).Range.Text = "Result"
                    .Cells(3).Range.Text = "Statement"
                    .Cells(4).Range.Text = "Decision"
                    .Cells(5).Range.Text = "MCDC"
                End With
                
                ' 2nd row
                Call UpdateCoverageSummaryRow(objdoc, .Rows(2), rpt, strmessage)
                
                ' 3rd row
                .Rows(1).Range.Copy
                Set rng = .Rows(3).Range
                With rng
                    .Collapse wdCollapseStart
                    .Paste
                    With .Rows(1)
                        .Range.Text = vbNullString
                        .HeadingFormat = False
                        .Cells(1).Range.Text = "By Module"
                        .Cells(1).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                        .Cells(1).Borders(wdBorderRight).LineStyle = wdLineStyleNone
                        .Cells(2).Range.Text = vbNullString
                        .Cells(2).Borders(wdBorderRight).LineStyle = wdLineStyleNone
                        .Cells(3).Range.Text = vbNullString
                        .Cells(3).Borders(wdBorderRight).LineStyle = wdLineStyleNone
                        .Cells(4).Range.Text = vbNullString
                        .Cells(4).Borders(wdBorderRight).LineStyle = wdLineStyleNone
                        .Cells(5).Range.Text = vbNullString
                    End With
                End With
                
                ' module rows
                intmaxlength = Const_MAX_BOOKMARK_LENGTH - Len("_f12") ' max JST bookmark length

                For idx = 0 To rpt.InstrumentedModules.Count - 1
                    Set covmod = rpt.InstrumentedModules.Items(idx)
                    Set covmetric = covmod.Coverage
                    Set rw = .Rows.Add(.Rows(.Rows.Count))
                    With rw
                        ' insert hyperlink to module
                        rw.Range.Font.Size = 8
                        strmodule = covmod.Name
                        frm.UpdateProgressText "   " & fso.GetFileName(strmodule)
                        frm.UpdateProgressMeter idx, rpt.InstrumentedModules.Count
                        strmodulebasename = fso.GetBaseName(strmodule)
                        Set rng = .Cells(1).Range
                        rng.ParagraphFormat.Alignment = wdAlignParagraphLeft
                        rng.Text = strmodulebasename
                        rng.Hyperlinks.Add rng, strmodule
                        
                        ' insert hyperlink to revision
                        Set cel = .Cells(1)
                        Set rng = SetRangeToEndOfCell(cel)
                        If rpt.ConfigStatus.ConfigItems.Exists(strmodule) Then
                            Set citem = rpt.ConfigStatus.ConfigItems.Item(strmodule)
                            strcvslocation = docinfo.Properties.Location
                            strcvslocation = Replace(strcvslocation, "$CVSROOT", vbNullString)
                            strcvslocation = fso.GetParentFolderName(strcvslocation)
                            strcvslocation = fso.BuildPath(strcvslocation, strmodule)
                            Call InsertHyperlinkWithTextInCell(cel, vbNullString, "http://cvs.esd.ate-group.com/viewvc/esd" & strcvslocation & "?revision=" & citem.Revision & "&view=markup", citem.Revision, , " (revision ", ")")
                        Else
                            rng.Text = Const_DOC_ERROR_STRING & " Revision unknown"
                            rng.Font.ColorIndex = wdRed
                        End If
                        
                        ' insert result
                        .Cells(2).Range.Text = covmetric.Result
                        For idxfunc = 0 To covmod.Functions.Count - 1
                            Set covmetricfunc = covmod.Functions.Items(idxfunc)
                            strfunction = covmod.Functions.Keys(idxfunc)
                            If covmetricfunc.Result <> Const_TESTRESULT_PASSED Then
                                Set rwfunc = tbl.Rows.Add(tbl.Rows(tbl.Rows.Count))
                                With rwfunc
                                    rwfunc.Range.Font.Size = 6
                                    .Borders(wdBorderTop).LineStyle = wdLineStyleNone
                                    .Cells(1).LeftPadding = CentimetersToPoints(1.25)
                                    .Cells(1).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                                    .Cells(1).Range.Text = strfunction
                                    Set rnghlnk = .Cells(2).Range
                                    ' limit bookmark name length
                                    strbkmark = Const_JST_BMRK_PREFIX_INCOMPLETECOV & strmodulebasename
                                    If Len(strbkmark) > intmaxlength Then strbkmark = Left(strbkmark, intmaxlength)
                                    strbkmark = strbkmark & "_f" & idxfunc + 1
                                    rnghlnk.Text = covmetricfunc.Result
                                    rnghlnk.Hyperlinks.Add rnghlnk, , strbkmark
                                    .Cells(3).Range.Text = covmetricfunc.StatementPercentage
                                    .Cells(4).Range.Text = covmetricfunc.DecisionPercentage
                                    .Cells(5).Range.Text = covmetricfunc.McdcPercentage
                                    
                                    ' if there is no predefined justification (e.g. from the COVT) and one already exists in the STR, use it instead
                                    If covmetricfunc.Justifications.Items(0) = Const_DEFAULT_JST_TEXT And jstcovstr.Exists(strbkmark) Then
                                        Set rngjst = jstcovstr(strbkmark)
                                        jstcovcur.Add strbkmark, rngjst
                                    Else
                                        jstcovcur.Add strbkmark, covmetricfunc.Justifications
                                    End If
                                    
                                    ' add justification bookmark and identifier text as new JSTs
                                    jstcovnew.Add strbkmark, strmodulebasename & "." & strfunction
                                     
                                End With
                            End If
                        Next idxfunc
                        
                        ' insert module metrics
                        .Cells(3).Range.Text = covmetric.StatementPercentage
                        .Cells(4).Range.Text = covmetric.DecisionPercentage
                        .Cells(5).Range.Text = covmetric.McdcPercentage
                                                
                    End With
                Next idx
                
                .Rows(.Rows.Count).Delete ' delete empty row (was added for convenience)
                
                UpdateCoverageAnalysisTable = True
            End With
        End If
    End If
        
    frm.UpdateProgressMeter (-1)
    
End Function
Attribute VB_Name = "basTestReportTableResults"
Option Explicit

Function UpdateTestSummaryTable(ByRef rng As Range, ByRef rpt As cTestReport, ByVal strtable As String, ByRef frm As Object) As Boolean
    Dim tsum As cTestSummary, strtesttype As String, strmessage As String, tbl As Table, strconfigerror As String, numrows As Integer
    
    ' get reference to summary
    If strtable = Const_DOCHLTEST_SUMMARY And rpt.ReportSubType = "hltests" Then
        strtesttype = "High-level Requirements"
    ElseIf strtable = Const_DOCLLTEST_SUMMARY And rpt.ReportSubType = "lltests" Then
        strtesttype = "Low-level"
    Else
        frm.UpdateProgressText "ERROR: The '" & strtable & "' table does not apply to '" & rpt.ReportSubType & "' reports"
        Exit Function
    End If
    
    Set tsum = rpt.TestSummary
    If Not tsum Is Nothing Then
        frm.UpdateProgressText "Updating the " & strtable & " table..."
    
        ' delete table
        Call DeleteTable(rng.Document, strtable)
        
        ' generate new table
        If Not rng Is Nothing Then
            If rpt.ReportSubType = "lltests" Then strconfigerror = rpt.TestConfig.TestConfigErrorsString ' LL tests do not have a config table
            numrows = 5 + IIf(strconfigerror <> vbNullString, 1, 0)
            Set tbl = CreateTableTemplate(rng, numrows, 2, strtesttype & " Test Summary", strtable)
            If Not tbl Is Nothing Then
                With tbl
                    ' adjust the column widths and center table
                    .Rows.Alignment = wdAlignRowCenter
                    .Columns(1).SetWidth CentimetersToPoints(5), wdAdjustNone
                    .Columns(2).SetWidth CentimetersToPoints(5), wdAdjustNone
                    
                    ' centre 2nd column - have to use the Selection object to get column as paragraph
                    .Columns(2).Select
                    Selection.ParagraphFormat.Alignment = wdAlignParagraphCenter
                        
                    .Cell(1, 1).Range.Text = "Testing Attribute"
                    .Cell(1, 2).Range.Text = "Value"
                    
                    .Cell(2, 1).Range.Text = "Test Cases Executed"
                    .Cell(2, 2).Range.Text = tsum.TestCasesExecuted
                
                    .Cell(3, 1).Range.Text = "Test Cases Failed"
                    .Cell(3, 2).Range.Text = tsum.TestCasesFailed
                
                    .Cell(4, 1).Range.Text = "Test Cases Not Executed"
                    .Cell(4, 2).Range.Text = tsum.TestCasesNotExecuted
                
                    .Cell(5, 1).Range.Text = "Test Duration"
                    .Cell(5, 2).Range.Text = tsum.TestDurationString
                    
                    If strconfigerror <> vbNullString Then
                        .Rows(numrows).Cells.Merge
                        With .Cell(numrows, 1).Range
                            .Text = Const_DOC_ERROR_STRING & strconfigerror
                            .Font.ColorIndex = wdRed
                            .ParagraphFormat.Alignment = wdAlignParagraphLeft
                        End With
                        strmessage = "Configuration errors were found"
                    End If
                    
                    ' point range to after the new table
                    Set rng = tbl.Range
                    rng.Collapse wdCollapseEnd
                    
                End With
            Else
                strmessage = "Unable to create summary table"
            End If
        Else
            strmessage = "Unable to delete summary table"
        End If
    Else
        strmessage = "Could not set reference to summary data"
    End If
    
    ' update error status
    Dim blstatus As Boolean
    blstatus = ProcessStatusMessage(strmessage, frm)
    UpdateTestSummaryTable = blstatus
    
End Function

Function UpdateTestResultsTables(ByRef objdoc As Document, ByRef rpt As cTestReport, ByVal dteteststart As Date, ByRef frm As Object) As Boolean
    Dim trslts As Scripting.Dictionary, rslt As cTestResult
    Dim jstfailcur As Scripting.Dictionary, jstfailnew As Scripting.Dictionary
    Dim jstnotexcur As Scripting.Dictionary, jstnotexnew As Scripting.Dictionary
    Dim diccomments As Scripting.Dictionary
    Dim strtesttype As String, strheadingtext As String, rng As Range, rngnew As Range, rngtbl As Range, strmessage As String, strtemp As String, numrows As Long
    Dim idx As Integer, offset As Long, intlevel As Integer, tbl As Table, strnotestswarning As String
    Dim strtable As String, strsummarytable As String, strnotexectable As String, strfailjsttable As String, strnotexecjsttable As String, strcommentstable As String
    
    ' get reference to results and tests not executed
    If rpt.ReportSubType = "hltests" Then
        strtesttype = "High-level Requirements"
        strsummarytable = Const_DOCHLTEST_SUMMARY
        strnotexectable = Const_DOCHLTEST_NOTEXECUTED
        strnotexecjsttable = Const_DOCHLTEST_NOTEXECUTEDJSTS
        strcommentstable = Const_DOCHLTEST_COMMENTS
        strfailjsttable = Const_DOCHLTEST_FAILUREJSTS
        strnotestswarning = "WARNING: No test results found  - possible because no tests were executed after the SRN date of " & dteteststart
    ElseIf rpt.ReportSubType = "lltests" Then
        strtesttype = "Low-level"
        strsummarytable = Const_DOCLLTEST_SUMMARY
        strnotexectable = Const_DOCLLTEST_NOTEXECUTED
        strnotexecjsttable = Const_DOCLLTEST_NOTEXECUTEDJSTS
        strfailjsttable = Const_DOCLLTEST_FAILUREJSTS
        strnotestswarning = "WARNING: No test result files found"
    Else
        ' sub-type does not apply, so exit
        frm.UpdateProgressText "ERROR: The test results tables do not apply to '" & rpt.ReportSubType & "' reports"
        Exit Function
    End If
        
    strheadingtext = strtesttype & " Test Results"
    
    Set trslts = rpt.TestResults
    If Not trslts Is Nothing Then
        ' set some local storage
        Set jstfailcur = New Scripting.Dictionary
        Set jstnotexcur = New Scripting.Dictionary
        Set jstfailnew = New Scripting.Dictionary
        Set jstnotexnew = New Scripting.Dictionary
        Set diccomments = New Scripting.Dictionary

        ' find the results section
        Set rng = GetHeadingRangeExtendedFromText(objdoc.Range, strheadingtext)
        If Not rng Is Nothing Then
            ' add paragraphs in case section is empty
            If rng.Paragraphs.Count = 1 Then
                rng.Paragraphs.Add
                rng.Paragraphs.Add
                rng.SetRange rng.Start, rng.Paragraphs(2).Range.End ' we need blank line after last table, so don't include 3rd paragraph in range
            End If
            
            ' get heading level and adjust range to exclude heading (from 2nd paragraph)
            intlevel = GetHeadingListLevelNumber(rng)
            rng.Start = rng.Paragraphs(2).Range.Start
            
            ' store existing justification bookmarks and ranges enclosed in results section
            Call StoreJustificationBookmarks(rng, Const_JST_BMRK_PREFIX_FAILURE, jstfailcur)
            Call StoreJustificationBookmarks(rng, Const_JST_BMRK_PREFIX_NOTEXECUTED, jstnotexcur)
            
            Set rngnew = objdoc.Range
            rngnew.SetRange rng.Start, rng.Start
                
            ' first update the test result summary table
            If UpdateTestSummaryTable(rngnew, rpt, strsummarytable, frm) Then
                ' generate tests executed tables
                Call InsertHeading(rngnew, "Tests Executed", intlevel)
                numrows = trslts.Count
                If numrows > 0 Then
                    For idx = 0 To numrows - 1
                        frm.UpdateProgressMeter idx, numrows
                        Set rslt = trslts.Items(idx)
                        strtable = "Doc" & Left(rslt.TestSpec, Const_MAX_BOOKMARK_LENGTH - Len("Doc")) ' limit total bookmark name length to max for bookmarks
                        frm.UpdateProgressText "Updating the " & strtable & " table..."
                        If InsertXref(rngnew, rslt.TestSpec, rslt.TestSpec, rpt.StdAssociated, False, True, strtemp) Then ' don't care about returned result text
                            rngnew.Style = wdStyleHeading1 - intlevel - 1
                            rngnew.InsertParagraphAfter
                            rngnew.Collapse wdCollapseEnd
                            strtemp = InsertTestResultTable(rngnew, rslt, strtable, rpt.ReportSubType, jstfailnew, jstnotexnew, diccomments)
                            If strtemp <> vbNullString Then
                                strmessage = strmessage & strtemp & vbCrLf
                            End If
                        Else
                            strmessage = strmessage & strtemp & vbCrLf
                        End If
                    Next idx
                    frm.UpdateProgressMeter (-1)
                Else
                    frm.UpdateProgressText strnotestswarning
                    Call InsertNotApplicable(rngnew, True)
                End If
                
                ' generate tests not executed table
                Call InsertHeading(rngnew, "Tests Not Executed", intlevel)
                strtemp = InsertTestsNotExecutedTable(rngnew, strtesttype & " Tests Not Executed", strnotexectable, rpt, jstnotexnew)
                If strtemp <> vbNullString Then
                    strmessage = strmessage & strtemp & vbCrLf
                End If
                
                ' generate test failure justifications table if required
                Call InsertHeading(rngnew, "Justifications for Test Failures", intlevel)
                strtemp = InsertJustificationsTable(rngnew, jstfailnew, jstfailcur, "Justifications for " & strtesttype & " Test Failures", strfailjsttable, "Test Case Identifier", frm)
                If strtemp <> vbNullString Then
                    strmessage = strmessage & strtemp & vbCrLf
                End If
                
                ' generate tests not executed justifications table
                frm.UpdateProgressText "Updating the " & strnotexecjsttable & " table..."
                Call InsertHeading(rngnew, "Justifications for Tests Not Executed", intlevel)
                strtemp = InsertJustificationsTable(rngnew, jstnotexnew, jstnotexcur, "Justifications for " & strtesttype & " Tests Not Executed", strnotexecjsttable, "Test Set/Case Identifier", frm)
                If strtemp <> vbNullString Then
                    strmessage = strmessage & strtemp & vbCrLf
                End If
                
                ' generate tests not executed justifications table
                If strcommentstable <> vbNullString Then
                    frm.UpdateProgressText "Updating the " & strcommentstable & " table..."
                    Call InsertHeading(rngnew, "Tests Comments", intlevel)
                    strtemp = InsertTestCommentsTable(rngnew, strtesttype & " Test Comments", strcommentstable, diccomments, frm)
                    If strtemp <> vbNullString Then
                        strmessage = strmessage & strtemp & vbCrLf
                    End If
                End If
                
                ' now clear old section content, adjust original range start position
                rng.Start = rngnew.Start ' rngnew at this point is at the end of the justifications table
                ' if there's no blank line after the table, the rng.Delete below fails, so delete the table seperately
                Set rngtbl = rng.Paragraphs(rng.Paragraphs.Count).Range
                If IsRangeInTable(rngtbl) Then
                    Set tbl = rngtbl.Tables(1)
                    rng.End = tbl.Range.Start ' adjust range to exclude table
                    tbl.Delete
                End If
                rng.Delete
            End If
        Else
            strmessage = "Could not locate section titled '" & strheadingtext & "'"
        End If
    Else
        strmessage = "Could not set reference to test results data"
    End If
        
    ' update error status
    UpdateTestResultsTables = ProcessStatusMessage(strmessage, frm)
    
End Function

Private Function InsertTestResultTable(ByRef rng As Range, ByRef rslt As cTestResult, ByVal strtable As String, ByVal strreportsubtype As String, _
                                       ByRef jstfailnew As Scripting.Dictionary, ByRef jstnotexnew As Scripting.Dictionary, _
                                       ByRef diccomments As Scripting.Dictionary) As String
    Dim tbl As Table, tcase As cTestCase, rngcel As Range, strjstbkmark As String, citem As cConfigItem
    Dim numrows As Integer, offset As Integer, idx As Integer, strmessage As String, strfile As String, strstatustext As String
    Dim fso As FileSystemObject, docinfo As cDocInfo
    
    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(rng.Document.Fullname)
    
    numrows = rslt.TestCases.Count + 3
    Set tbl = CreateTableTemplate(rng, numrows, 3, , , True)
    If Not tbl Is Nothing Then
        With tbl
            ' adjust the column widths and center 2nd column
            .Columns(1).SetWidth CentimetersToPoints(7.5), wdAdjustNone
            .Columns(2).SetWidth CentimetersToPoints(2.2), wdAdjustNone
            .Columns(3).SetWidth CentimetersToPoints(Const_TABLE_WIDTH) - tbl.Columns(1).Width - tbl.Columns(2).Width, wdAdjustNone
            For idx = 1 To numrows
                .Cell(idx, 2).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
            Next idx
                
            ' primary header
            Set rngcel = .Cell(1, 1).Range
            rngcel.Text = "Test Set Identifier"
            rngcel.Collapse wdCollapseStart
            docinfo.Bookmarks.Add strtable, rngcel  ' insert table identifying bookmark
            .Cell(1, 2).Range.Text = "Duration"
            If strreportsubtype = "hltests" Then
                .Cell(1, 3).Range.Text = "Hyperlink to Result File"
            Else
                .Cell(1, 3).Range.Text = "Hyperlinks to Result and Configuration Files"
            End If
            
            ' secondary header
            Call FormatRowAsHeading(.Rows(3), 1, , True)
            .Cell(3, 1).Range.Text = "Test Case Identifier"
            .Cell(3, 2).Range.Text = "Result"
            .Cell(3, 2).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
            .Cell(3, 3).Borders(wdBorderBottom).LineStyle = wdLineStyleNone
            
            ' test set info
            Set rngcel = .Cell(2, 1).Range
            rngcel.Text = rslt.TestSet
            rngcel.Hyperlinks.Add rngcel, GetRelativePath(docinfo.Properties.Path, rslt.TestScript)
            .Cell(2, 2).Range.Text = rslt.TestSummary.TestDurationString
            .Cell(2, 3).Borders(wdBorderBottom).LineStyle = wdLineStyleNone
            Set rngcel = .Cell(2, 3).Range
            rngcel.Text = fso.GetFileName(rslt.TestResultFile)
            strfile = GetRelativePath(docinfo.Properties.Path, rslt.TestResultFile)
            rngcel.Hyperlinks.Add rngcel, strfile
            Call UpdateTestResultFileChecksum(docinfo.Document, rslt.TestResultFile) ' update the test result file checksum
            If strreportsubtype = "lltests" Then
                Set rngcel = .Cell(3, 3).Range
                strfile = rslt.TestCtrFile
                If fso.FileExists(strfile) Then
                    Call UpdateTestResultFileChecksum(docinfo.Document, strfile) ' update CTR file checksum
                    rngcel.Text = fso.GetFileName(strfile)
                    strfile = GetRelativePath(docinfo.Properties.Path, strfile)
                    rngcel.Hyperlinks.Add rngcel, strfile
                Else
                    rngcel.Text = Const_DOC_ERROR_STRING & " CTR file '" & strfile & "' does not exist"
                    rngcel.Font.ColorIndex = wdRed
                End If
                                            
                Set rngcel = .Cell(4, 3).Range
                strfile = rslt.TestConfigFile
                If fso.FileExists(strfile) Then
                    Call UpdateTestResultFileChecksum(docinfo.Document, strfile) ' update configuration file checksum
                    rngcel.Text = fso.GetFileName(strfile)
                    strfile = GetRelativePath(docinfo.Document.Path, strfile)
                    rngcel.Hyperlinks.Add rngcel, strfile
                    
                    ' list any unknown items
                    strstatustext = vbNullString
                    For idx = 0 To rslt.TestConfig.TestConfigStatus.UnknownItems.Count - 1
                        Set citem = rslt.TestConfig.TestConfigStatus.UnknownItems.Items(idx)
                        strfile = fso.GetFileName(citem.File)
                        If citem.Status <> citem.UpToDateString Then
                            strstatustext = strstatustext & vbCrLf & "Status for '" & strfile & "': " & citem.Status
                        Else
                            strstatustext = strstatustext & vbCrLf & "Revision for '" & strfile & "': Unknown"
                        End If
                    Next idx
                    If strstatustext <> vbNullString Then
                        rngcel.InsertParagraphAfter
                        rngcel.InsertAfter Const_DOC_ERROR_STRING & " " & strstatustext
                        rngcel.Font.ColorIndex = wdRed
                    End If
                Else
                    rngcel.Text = Const_DOC_ERROR_STRING & " Configuration file '" & strfile & "' does not exist"
                    rngcel.Font.ColorIndex = wdRed
                End If
            End If
            
            ' test cases
            offset = 4
            For idx = 0 To rslt.TestCases.Count - 1
                Set tcase = rslt.TestCases.Items(idx)
                Set rngcel = .Cell(offset + idx, 1).Range
                Dim strscript As String
                strscript = GetRelativePath(docinfo.Document.Path, tcase.TestScript)
                rngcel.Text = tcase.TestCase
                rngcel.Hyperlinks.Add rngcel, strscript
                
                ' capture test comments for later use
                If tcase.Comments <> vbNullString Then
                    diccomments.Add strscript, tcase.Comments
                End If
                
                strjstbkmark = Left(tcase.TestCase, Const_MAX_BOOKMARK_LENGTH - 2) ' allow enough space in name for the justification prefix to be added
                With .Cell(offset + idx, 2)
                    Set rngcel = .Range
                    rngcel.Text = tcase.Result
                    If tcase.Result = Const_TESTRESULT_PASSED Then
                        ' do nothing
                    ElseIf tcase.Result = Const_TESTRESULT_FAILED Then
                        ' add failure to list and insert hyperlink to failure justification bookmark
                        strjstbkmark = Const_JST_BMRK_PREFIX_FAILURE & strjstbkmark
                        If Not jstfailnew.Exists(strjstbkmark) Then
                            jstfailnew.Add strjstbkmark, tcase.TestCase
                            rngcel.Hyperlinks.Add rngcel, , strjstbkmark
                        Else
                            rngcel.Next.Font.ColorIndex = wdRed
                            rngcel.Next.Text = Const_DOC_ERROR_STRING & " Bookmark '" & strjstbkmark & "' already exists."
                            strmessage = "JST bookmark creation error"
                        End If
                    ElseIf tcase.Result = Const_TESTRESULT_NOTEXECUTED Then
                        ' add not tested to list and insert hyperlink to not tested justification bookmark
                        strjstbkmark = Const_JST_BMRK_PREFIX_NOTEXECUTED & strjstbkmark
                        If Not jstnotexnew.Exists(strjstbkmark) Then
                            jstnotexnew.Add strjstbkmark, tcase.TestCase
                            rngcel.Hyperlinks.Add rngcel, , strjstbkmark
                        Else
                            rngcel.Next.Font.ColorIndex = wdRed
                            rngcel.Next.Text = Const_DOC_ERROR_STRING & " Bookmark '" & strjstbkmark & "' already exists."
                            strmessage = "JST bookmark creation error"
                        End If
                    Else
                        rngcel.Text = Const_DOC_ERROR_STRING & " Result unknown" ' override and show discrepancy
                        rngcel.Font.ColorIndex = wdRed
                        strmessage = "Unknown results found"
                    End If
                End With
                .Cell(offset + idx, 3).Borders(wdBorderTop).LineStyle = wdLineStyleNone
            Next idx
            
            ' add table checksum to document variables collection
            docinfo.Variables.TableChecksum(strtable) = StringCRC32(.Range.Text)
            
            ' collapse range to end of table
            Set rng = .Range
            rng.Collapse wdCollapseEnd
        End With
    Else
        strmessage = "Unable to create test results table for '" & rslt.TestScript & "'"
    End If
    
    If strmessage <> vbNullString Then
        InsertTestResultTable = strmessage
    End If
    
End Function

Private Function InsertTestsNotExecutedTable(ByRef rng As Range, ByRef strcaption As String, ByRef strtable As String, _
                                             ByRef rpt As cTestReport, ByRef jstnotexnew As Scripting.Dictionary) As String
    Dim tbl As Table, rnghlnk As Range, strtestspec As String, strmessage As String, strtemp As String, strbkmark As String
    Dim numrows As Integer, offset As Integer, idx As Integer
    
    numrows = IIf(rpt.TestSetsNotExecuted.Count > 0, rpt.TestSetsNotExecuted.Count + 1, 2)
    Set tbl = CreateTableTemplate(rng, numrows, 2, strcaption, strtable, True)
    If Not tbl Is Nothing Then
        With tbl
            ' centre table, adjust the column widths and center 2nd column
            .Rows.Alignment = wdAlignRowCenter
            .Columns(1).SetWidth CentimetersToPoints(7.5), wdAdjustNone
            .Columns(2).SetWidth CentimetersToPoints(2.2), wdAdjustNone
                
            .Cell(1, 1).Range.Text = "Test Set Identifier"
            .Cell(1, 2).Range.Text = "Result"
            
            Call InsertNotApplicable(.Cell(2, 1).Range)
            
            offset = 2
            For idx = 0 To rpt.TestSetsNotExecuted.Count - 1
                ' insert cross reference to test spec in STD
                Set rnghlnk = .Cell(offset + idx, 1).Range
                strtestspec = rpt.TestSetsNotExecuted.Keys(idx)
                If Not InsertXref(rnghlnk, strtestspec, strtestspec, rpt.StdAssociated, False, True, strtemp) Then
                    rnghlnk.Text = rnghlnk & Const_DOC_ERROR_STRING & " Could not insert cross-reference to test specification - " & strtemp
                    rnghlnk.Font.ColorIndex = wdRed
                    strmessage = "Errors inserting cross-reference were encountered"
                End If
                
                ' add not tested to list and insert hyperlink to not tested justification, center 2nd column
                strbkmark = Left(strtestspec, Const_MAX_BOOKMARK_LENGTH - 2) ' allow enough space in name for the justification prefix to be added
                strbkmark = Const_JST_BMRK_PREFIX_NOTEXECUTED & strbkmark
                jstnotexnew.Add strbkmark, strtestspec
                Set rnghlnk = .Cell(offset + idx, 2).Range
                rnghlnk.Text = Const_TESTRESULT_NOTEXECUTED
                rnghlnk.Hyperlinks.Add rnghlnk, , strbkmark
                rnghlnk.ParagraphFormat.Alignment = wdAlignParagraphCenter
            Next idx
            
            ' collapse range to end of table
            Set rng = .Range
            rng.Collapse wdCollapseEnd
        End With
    Else
        strmessage = "Unable to create tests not executed table"
    End If
    
    If strmessage <> vbNullString Then
        InsertTestsNotExecutedTable = strmessage
    End If
    
End Function

Private Function InsertTestCommentsTable(ByRef rng As Range, ByRef strcaption As String, ByRef strtable As String, _
                                         ByRef diccomments As Scripting.Dictionary, ByRef frm As Object) As String
    Dim tbl As Table, rngcel As Range, strmessage As String, strscript As String
    Dim numrows As Integer, offset As Integer, idx As Integer
    Dim fso As FileSystemObject
On Error GoTo Err_InsertTestCommentsTable

    numrows = IIf(diccomments.Count > 0, diccomments.Count + 1, 2)
    Set tbl = CreateTableTemplate(rng, numrows, 3, strcaption, strtable, True)
    If Not tbl Is Nothing Then
        Set fso = New FileSystemObject
        With tbl
            ' centre table, adjust the column widths and center 2nd column
            .Columns(1).SetWidth CentimetersToPoints(6.25), wdAdjustNone
            .Columns(2).SetWidth CentimetersToPoints(8), wdAdjustNone
            .Columns(3).SetWidth CentimetersToPoints(Const_TABLE_WIDTH) - .Columns(1).Width - .Columns(2).Width, wdAdjustNone
                
            .Cell(1, 1).Range.Text = "Test Case Identifier"
            .Cell(1, 2).Range.Text = "Comment"
            .Cell(1, 3).Range.Text = "EPR Reference"
            
            Call InsertNotApplicable(.Cell(2, 1).Range)
            
            offset = 2
            For idx = 0 To diccomments.Count - 1
                frm.UpdateProgressMeter idx, diccomments.Count
                ' insert hyperlink to test script
                strscript = diccomments.Keys(idx)
                Set rngcel = .Cell(offset + idx, 1).Range
                rngcel.Text = fso.GetBaseName(strscript)
                rngcel.Hyperlinks.Add rngcel, strscript
                
                .Cell(offset + idx, 2).Range.Text = diccomments.Items(idx)
                
                Set rngcel = .Cell(offset + idx, 3).Range
                rngcel.Text = Const_DOC_ERROR_STRING & " [Insert EPR reference here]"
                rngcel.Font.ColorIndex = wdRed
            Next idx
            
            ' collapse range to end of table
            Set rng = .Range
            rng.Collapse wdCollapseEnd
        End With
    Else
        strmessage = "Unable to create test comments table"
    End If
    
    If strmessage <> vbNullString Then
        InsertTestCommentsTable = strmessage
    End If
    
Exit_InsertTestCommentsTable:
    frm.UpdateProgressMeter (-1)
    Exit Function

Err_InsertTestCommentsTable:
    InsertTestCommentsTable = Err.Description & " in InsertTestCommentsTable()"
    Resume Exit_InsertTestCommentsTable
        
End Function
Attribute VB_Name = "basTestReportTableSummaries"
Option Explicit

Function UpdateSummariesTable(ByRef objdoc As Document, ByRef rpt As cTestReportSum, ByVal strtable As String, ByRef frm As Object) As Boolean
    Dim strmessage As String, strothersubtype As String, diccovdocs As Scripting.Dictionary, dicsubtypes As Scripting.Dictionary
    Dim tbl As Table, lngstartrowindex As Long, numrowstoadd As Integer, numcols As Integer
    
    ' determine which table to update and how many rows are required - note that the prepare function retains one row so the
    ' formatting is inherited when inserting new rows
    If strtable = Const_DOCTEST_SUMMARY And rpt.ReportSubType Like "*testssum" Then
        numrowstoadd = rpt.TestReports.Count - 1
        numcols = 6
    ElseIf strtable = Const_DOCSTRUCTCOV_SUMMARY And rpt.ReportSubType Like "*structcovsum" Then
        strothersubtype = Replace(rpt.ReportSubType, "sum", vbNullString)
        Set diccovdocs = GetSubTypeDocs(objdoc.Fullname, "STR", strothersubtype)
        numrowstoadd = diccovdocs.Count ' coverage report has an extra row compared to test reports
        numcols = 5
    Else
        ' sub-type does not apply, so exit
        UpdateSummariesTable = False
        frm.UpdateProgressText "ERROR: The '" & strtable & "' table does apply to '" & rpt.ReportSubType & "' reports"
        Exit Function
    End If
    
    ' first prepare the data for the given report (hl or ll)
    frm.UpdateProgressText "Updating the " & strtable & " table for '" & rpt.ReportSubType & "'..."
    Set tbl = PrepareSummaryTable(objdoc, strtable, rpt.ReportSubType, numrowstoadd, numcols, lngstartrowindex, False, strmessage)
    If Not tbl Is Nothing Then
        If strtable = Const_DOCTEST_SUMMARY Then
            Call UpdateTestSummariesTable(tbl, lngstartrowindex, rpt, strmessage)
        Else
            Call UpdateCoverageSummariesTable(tbl, lngstartrowindex, rpt, diccovdocs, strmessage)
        End If
    End If
    
    ' now clear the data if the other report has no data (hl or ll)
    strothersubtype = GetOtherReportSubType(rpt.ReportSubType)
    Set dicsubtypes = Dst.Document(objdoc.Fullname).Properties.SubTypesAsDictionary
    If Not dicsubtypes.Exists(strothersubtype) Then
        Set tbl = PrepareSummaryTable(objdoc, strtable, strothersubtype, 0, numcols, lngstartrowindex, True, strmessage)
    Else
        ' do nothing - the table will be/has already been updated in the next/previous iteration
    End If
    
    ' update error status
    UpdateSummariesTable = ProcessStatusMessage(strmessage, frm)
    
End Function

Function PrepareSummaryTable(ByRef objdoc As Document, ByVal strsumtblbookmark As String, ByVal strsubtype As String, _
                             ByVal numrowstoadd As Integer, ByVal numcols As Integer, ByRef lngstartrowindex As Long, ByVal blisothertable As Boolean, _
                             ByRef strmessage As String) As Table
    Dim strtesttype As String, strhltesttype As String, strlltesttype As String
    Dim tbl As Table, rng As Range, rw As Row, rws As Rows, cel As Cell
    Dim lngendrowindex As Long, idx As Integer, idxhl As Integer, idxll As Integer, numrows As Integer
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    strhltesttype = "High-level Requirements Tests"
    strlltesttype = "Low-level Requirements Tests"
    
    ' determine header row text
    If strsubtype Like "hl*sum" Then
        strtesttype = strhltesttype
    ElseIf strsubtype Like "ll*sum" Then
        strtesttype = strlltesttype
    Else
        ' sub-type does not apply, so exit
        strmessage = "The '" & strsumtblbookmark & "' table does apply to '" & strsubtype & "' reports"
        Exit Function
    End If
    
    ' get a reference to the summary table and validate it
    Set tbl = GetTable(objdoc, strsumtblbookmark, strmessage)
    If Not tbl Is Nothing Then
        With tbl
            ' find header rows
            idxhl = 0
            idxll = 0
            For Each rw In .Rows
                Set cel = rw.Cells(1)
                If GetCellText(cel) = strhltesttype Then
                    idxhl = rw.Index
                ElseIf GetCellText(cel) = strlltesttype Then
                    idxll = rw.Index
                End If
            Next rw
            If idxhl = 0 Then
                strmessage = "Could not find header row titled '" & strhltesttype & "' in the " & strsumtblbookmark & "table"
            ElseIf idxll = 0 Then
                strmessage = "Could not find header row titled '" & strlltesttype & "' in the " & strsumtblbookmark & "table"
            Else
                ' determine relevant section start and end rows - assume low-level tests are listed after high-level tests
                lngstartrowindex = IIf(strtesttype = strhltesttype, idxhl, idxll) + 1
                lngendrowindex = IIf(strtesttype = strhltesttype, idxll - 1, .Rows.Count)
                If strsumtblbookmark Like "*Config*" And strtesttype = strhltesttype And blisothertable Then lngstartrowindex = lngstartrowindex + 1 ' hltests config table has an extra sub-header row
                
                If .Rows(lngstartrowindex).Cells.Count <> numcols Then
                    strmessage = "The " & strsumtblbookmark & " table does not have " & numcols & " columns in row " & lngstartrowindex
                Else
                    ' delete all but one row in relevant section
                    If lngstartrowindex <> lngendrowindex Then
                        Set rng = .Rows(lngstartrowindex + 1).Range
                        rng.End = .Rows(lngendrowindex).Range.End
                        Set rws = rng.Rows
                        rws.Delete
                    End If
                    
                    ' clear the section header row if required
                    If Not strsumtblbookmark Like "*Config*" Then
                        For idx = 2 To numcols
                            .Cell(lngstartrowindex - 1, idx).Range.Text = vbNullString
                        Next idx
                    End If
                    
                    ' set the default row values for the other table
                    If blisothertable Then
                        .Rows(lngstartrowindex).Range.Font.ColorIndex = wdAuto
                        .Cell(lngstartrowindex, 1).Range.Text = "N/A"
                        For idx = 2 To numcols
                            .Cell(lngstartrowindex, idx).Range.Text = "-"
                        Next idx
                    Else
                        ' insert the given number of rows
                        For idx = 1 To numrowstoadd
                            .Rows.Add .Rows(lngstartrowindex + idx - 1)
                        Next idx
                    End If
                    
                    Set PrepareSummaryTable = tbl
                End If
            End If
        End With
    End If
    
End Function

Private Sub UpdateTestSummariesTable(ByRef tbl As Table, ByRef lngsectionstart As Long, ByRef rptsum As cTestReportSum, ByRef strmessage As String)
    Dim tsum As cTestSummary, rpt As cTestReport, docinfo As cDocInfo
    Dim strreport As String, strtable As String
    Dim fso As FileSystemObject, idx As Long, rnghlnk As Range
    
    Set fso = New FileSystemObject
    
    With tbl
        For idx = 0 To rptsum.TestReports.Count - 1
            Set rpt = rptsum.TestReports.Items(idx)
            Set tsum = rpt.TestSummary
            
            strreport = rptsum.TestReports.Keys(idx)
            Set docinfo = Dst.Document(strreport)
            
            ' add hyperlink to STD
            Set rnghlnk = .Cell(idx + lngsectionstart, 1).Range
            If Not docinfo.Properties.IsOrphaned Then
                rnghlnk.Text = fso.GetFileName(rpt.StdAssociated)
                rnghlnk.Hyperlinks.Add rnghlnk, GetRelativePath(tbl.Range.Document.Path, rpt.StdAssociated)
            Else
                rnghlnk.Text = "N/A"
            End If
                                    
            ' add hyperlink to test report
            Set rnghlnk = .Cell(idx + lngsectionstart, 2).Range
            If rpt.ReportSubType = "hltests" Then
                strtable = Const_DOCHLTEST_SUMMARY
            Else
                strtable = Const_DOCLLTEST_SUMMARY
            End If
            rnghlnk.Text = fso.GetFileName(strreport)
            rnghlnk.Hyperlinks.Add rnghlnk, GetRelativePath(tbl.Range.Document.Path, strreport), strtable
             
            ' add summary result data
            .Cell(idx + lngsectionstart, 3).Range.Text = tsum.TestDurationString
            .Cell(idx + lngsectionstart, 4).Range.Text = tsum.TestCasesExecuted
            .Cell(idx + lngsectionstart, 5).Range.Text = tsum.TestCasesFailed
            .Cell(idx + lngsectionstart, 6).Range.Text = tsum.TestCasesNotExecuted
        Next idx
        
        ' now update the report-level summary result data
        .Cell(lngsectionstart - 1, 3).Range.Text = rptsum.TestSummary.TestDurationString
        .Cell(lngsectionstart - 1, 4).Range.Text = rptsum.TestSummary.TestCasesExecuted
        .Cell(lngsectionstart - 1, 5).Range.Text = rptsum.TestSummary.TestCasesFailed
        .Cell(lngsectionstart - 1, 6).Range.Text = rptsum.TestSummary.TestCasesNotExecuted
    End With
    
End Sub

Private Sub UpdateCoverageSummariesTable(ByRef tbl As Table, ByRef lngsectionstart As Long, _
                                         ByRef rptsum As cTestReportSum, ByRef diccovdocs As Scripting.Dictionary, ByRef strmessage As String)
    Dim objdoc As Document, strtabletoreference As String, docinfo As cDocInfo
    Dim idx As Long, rnghlnk As Range, strreport As String, strstd As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    Set objdoc = tbl.Range.Document
    
    ' determine which result table to reference
    If rptsum.ReportSubType = "hlstructcovsum" Then
        strtabletoreference = Const_DOCHLSTRUCTCOV
    ElseIf rptsum.ReportSubType = "llstructcovsum" Then
        strtabletoreference = Const_DOCLLSTRUCTCOV
    Else
        ' should never happen - already checked by caller
    End If
    
    ' update the coverage results file checksum
    Call UpdateTestResultFileChecksum(objdoc, rptsum.CoverageReport.CoverageResultsFile)
    
    ' add the revision info to the document variables
    Call UpdateConfigItemVariables(objdoc, rptsum.CoverageReport.ConfigStatus)
    
    With tbl
        Call UpdateCoverageSummaryRow(objdoc, .Rows(lngsectionstart), rptsum.CoverageReport, strmessage)
        
        For idx = 0 To diccovdocs.Count - 1
            With .Rows(idx + 1 + lngsectionstart)
                .Range.Font.Bold = False
                
                strreport = diccovdocs.Keys(idx)
                strstd = GetSTDFileNameFromSTR(strreport)
                Set docinfo = Dst.Document(strreport)
                
                ' add hyperlink to STD
                Set rnghlnk = .Cells(1).Range
                If Not docinfo.Properties.IsOrphaned Then
                    rnghlnk.Text = fso.GetFileName(strstd)
                    rnghlnk.Hyperlinks.Add rnghlnk, GetRelativePath(objdoc.Path, strstd)
                Else
                    rnghlnk.Text = "N/A"
                End If
                
                ' add hyperlink to coverage report
                Set rnghlnk = .Cells(2).Range
                rnghlnk.Text = fso.GetFileName(strreport)
                rnghlnk.Hyperlinks.Add rnghlnk, GetRelativePath(objdoc.Path, strreport), strtabletoreference
                                 
                ' add summary result data - inherit overall result if only one STR
                If diccovdocs.Count = 1 Then
                    .Cells(3).Range.Text = rptsum.CoverageReport.CoverageMetrics.StatementPercentage
                    .Cells(4).Range.Text = rptsum.CoverageReport.CoverageMetrics.DecisionPercentage
                    .Cells(5).Range.Text = rptsum.CoverageReport.CoverageMetrics.McdcPercentage
                Else
                    ' can't express values per STR at the moment, so mark as N/A for now
                    .Cells(3).Range.Text = "N/A"
                    .Cells(4).Range.Text = "N/A"
                    .Cells(5).Range.Text = "N/A"
                End If
            End With
        Next idx
    End With
    
End Sub

Function UpdateInstrumentationSummaryTable(ByRef objdoc As Document, rpt As cTestReportSum, ByVal strtable As String, ByRef frm As Object) As Boolean
    Dim tbl As Table, rw As Row, rng As Range, rnghlnk As Range
    Dim instrsum As cInstrumentSum, strreport As String
    Dim idx As Integer, strmodule As String, strmessage As String
    Dim fso As FileSystemObject
    Dim confstat As cConfigStatus, citem As cConfigItem, dicuninstr As Scripting.Dictionary, jst As Scripting.Dictionary
    
    Set fso = New FileSystemObject
    
    strreport = objdoc.Fullname
       
    ' table only applies to coverage summary reports
    If rpt.ReportSubType = "hlstructcovsum" Or rpt.ReportSubType = "llstructcovsum" Then
        ' do nothing yet
    Else
        ' sub-type does not apply, so exit
        frm.UpdateProgressText "ERROR: The instrumentation summary table does apply to '" & rpt.ReportSubType & "' reports"
        Exit Function
    End If
    
    ' process the coverage result files to build the instrumentation summary
    Set instrsum = New cInstrumentSum
    instrsum.ProcessResults strreport, frm
    
    ' write some debug info
    Call WriteDebugFile(instrsum.DebugString, "instrsum")
    
    ' delete and generate new table
    frm.UpdateProgressText "Updating the " & strtable & " table..."
    Set rng = DeleteTable(objdoc, strtable)
    If Not rng Is Nothing Then
        ' insert a blank line before the next table if there isn't one - the fact that the range has a bookmark means the range is already at the next table caption, so a blank line is required
        If rng.Bookmarks.Count > 0 Then
            rng.Move wdParagraph, -1
            Set rng = rng.Paragraphs(1).Range
            rng.End = rng.End - 1
            rng.InsertParagraphAfter
            rng.Collapse wdCollapseEnd
        End If
        Set tbl = CreateTableTemplate(rng, 3, 3, "Instrumentation Summary", strtable, True) ' note that additional rows are added below as required
        If Not tbl Is Nothing Then
            With tbl
                ' adjust the column widths
                .Columns(1).SetWidth CentimetersToPoints(10.2), wdAdjustNone
                .Columns(2).SetWidth CentimetersToPoints(3.5), wdAdjustNone
                .Columns(3).SetWidth CentimetersToPoints(3.5), wdAdjustNone
                    
                ' header row
                .Cell(1, 1).Range.Text = "Identifier"
                .Cell(1, 2).Range.Text = "Value"
                .Cell(1, 2).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                .Cell(1, 3).Range.Text = "%"
                .Cell(1, 3).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                
                ' 2nd row
                .Rows(1).Range.Copy
                Set rng = .Rows(2).Range
                With rng
                    .Collapse wdCollapseStart
                    .Paste
                    .Rows(1).HeadingFormat = False
                    .Cells(1).Range.Text = "Instrumented Modules"
                    .Cells(1).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                End With
                
                ' 3rd row
                Set rw = .Rows(3)
                With rw
                    .Borders(wdBorderTop).LineStyle = wdLineStyleNone
                    .Cells(1).Range.Text = "High-level Test Instrumentation"
                    .Cells(1).LeftPadding = CentimetersToPoints(1.25)
                    .Cells(2).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                    .Cells(3).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                End With
                
                ' 4th row
                .Rows(3).Range.Copy
                Set rng = .Rows(4).Range
                With rng
                    .Collapse wdCollapseStart
                    .Paste
                    .Borders(wdBorderTop).LineStyle = wdLineStyleNone
                    .Cells(1).Range.Text = "Low-level Test Instrumentation"
                End With
                
                ' 5th row
                .Rows(2).Range.Copy
                Set rng = .Rows(5).Range
                With rng
                    .Collapse wdCollapseStart
                    .Paste
                    .Cells(1).Range.Text = "Un-instrumented Modules"
                End With
                
                ' 6th row
                .Rows(3).Range.Copy
                Set rng = .Rows(6).Range
                With rng
                    .Collapse wdCollapseStart
                    .Paste
                    .Borders(wdBorderTop).LineStyle = wdLineStyleNone
                    .Cells(3).Range.Text = "-"
                End With
                
                ' last row
                .Rows(2).Range.Copy
                Set rng = .Rows(.Rows.Count).Range
                With rng
                    .Collapse wdCollapseStart
                    .Paste
                    .Cells(1).Range.Text = "Total Modules"
                    .Borders(wdBorderBottom).LineStyle = wdLineStyleSingle
                End With
                .Rows(.Rows.Count).Delete ' delete empty row (was added for convenience)
            
                ' process high-level coverage data
                If instrsum.InstrumentedTotalHighLevel > 0 Then
                    Call InsertHyperlinkWithTextInCell(.Rows(3).Cells(1), objdoc.Path, instrsum.CoverageFileHighLevel, fso.GetFileName(instrsum.CoverageFileHighLevel), , " (", ")")
                End If
                
                ' process low-level coverage data
                If instrsum.InstrumentedTotalLowLevel > 0 Then
                    Call InsertHyperlinkWithTextInCell(.Rows(4).Cells(1), objdoc.Path, instrsum.CoverageFileLowLevel, fso.GetFileName(instrsum.CoverageFileLowLevel), , " (", ")")
                End If
                
                ' update metric values in table
                .Rows(2).Cells(2).Range.Text = instrsum.InstrumentedTotal
                .Rows(2).Cells(3).Range.Text = instrsum.InstrumentedTotalPercentage
                .Rows(3).Cells(2).Range.Text = instrsum.InstrumentedTotalHighLevel
                .Rows(3).Cells(3).Range.Text = instrsum.InstrumentedTotalHighLevelPercentage
                .Rows(4).Cells(2).Range.Text = instrsum.InstrumentedTotalLowLevel
                .Rows(4).Cells(3).Range.Text = instrsum.InstrumentedTotalLowLevelPercentage
                .Rows(5).Cells(2).Range.Text = instrsum.UnInstrumentedTotal
                .Rows(5).Cells(3).Range.Text = instrsum.UnInstrumentedTotalPercentage
                .Rows(.Rows.Count).Cells(2).Range.Text = instrsum.ModulesTotal
                .Rows(.Rows.Count).Cells(3).Range.Text = "100%"
                
                ' insert un-instrumented module rows and create justifications table
                Call InsertUninstrumentedRowsAndJstTable(tbl, instrsum.UnInstrumentedModules, frm, strmessage)
                
                ' add un-instrumented modules to config item variables for use during SCR checks
                Set confstat = New cConfigStatus
                Set dicuninstr = instrsum.UnInstrumentedModules
                For idx = 0 To dicuninstr.Count - 1
                    Set citem = New cConfigItem
                    citem.File = dicuninstr.Keys(idx)
                    Set jst = dicuninstr.Items(idx)
                    citem.Revision = IIf(jst.Items(0) <> vbNullString, "JST", " ") ' cannot add blank entries, hence the whitespace
                    confstat.ConfigItems.Add citem.File, citem
                Next idx
                Call UpdateConfigItemVariables(objdoc, confstat)
                               
            End With
        Else
            strmessage = AddStatusText(strmessage, "Unable to create the instrumentation summary table")
        End If
    Else
        strmessage = AddStatusText(strmessage, "Unable to delete the instrumentation summary table")
    End If
        
    ' update error status
    UpdateInstrumentationSummaryTable = ProcessStatusMessage(strmessage, frm)
    
End Function

Private Sub InsertUninstrumentedRowsAndJstTable(ByRef tbl As Table, ByRef dicuninstr As Scripting.Dictionary, ByRef frm As Object, ByRef strmessage As String)
    Dim rw As Row, rng As Range, idx As Integer, rngtbljst As Range, rngjst As Range
    Dim jstuninstrnew As Scripting.Dictionary, jstuninstrcur As Scripting.Dictionary, jstuninstrstr As Scripting.Dictionary
    Dim strmodule As String, strmodulebasename As String, strbkmark As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
       
    ' create dictionaries for current and new justifications
    Set jstuninstrcur = New Scripting.Dictionary
    Set jstuninstrnew = New Scripting.Dictionary
    Set jstuninstrstr = New Scripting.Dictionary
    
    ' store the existing justifications for un-instrumented modules listed in the STR
    Call StoreJustificationBookmarks(GetTable(tbl.Range.Document, Const_DOCSTRUCTCOV_UNINSTRJSTS).Range, Const_JST_BMRK_PREFIX_UNINSTR, jstuninstrstr)
    
    With tbl
        ' add entries for each un-instrumented module listed in the local list
        Set rng = tbl.Range
        If Not dicuninstr Is Nothing And dicuninstr.Count > 0 Then
            For idx = 0 To dicuninstr.Count - 1
                frm.UpdateProgressMeter idx, dicuninstr.Count
                ' insert above 2nd last row
                Set rw = .Rows.Add(.Rows(.Rows.Count - 1))
                With rw
                    .Borders(wdBorderTop).LineStyle = wdLineStyleNone
                    
                    strmodule = dicuninstr.Keys(idx)
                    strmodulebasename = fso.GetBaseName(strmodule)
                    strbkmark = Const_JST_BMRK_PREFIX_UNINSTR & strmodulebasename
                    If Len(strbkmark) > Const_MAX_BOOKMARK_LENGTH Then strbkmark = Left(strbkmark, Const_MAX_BOOKMARK_LENGTH) ' limit bookmark name length
                    Set rng = .Cells(1).Range
                    rng.Text = strmodulebasename
                    rng.Hyperlinks.Add rng, strmodule
                    Set rng = .Cells(2).Range
                    rng.Text = "Justification"
                    rng.Hyperlinks.Add rng, , strbkmark
                    .Cells(3).Range.Text = "-"
                    
                    ' if there is no predefined justification (e.g. from the COVT) and one already exists in the STR, use it instead
                    If dicuninstr(strmodule).Item(0) = Const_DEFAULT_JST_TEXT And jstuninstrstr.Exists(strbkmark) Then
                        Set rngjst = jstuninstrstr(strbkmark)
                        jstuninstrcur.Add strbkmark, rngjst
                    Else
                        jstuninstrcur.Add strbkmark, dicuninstr(strmodule)
                    End If
                    
                    ' add justification bookmark and text to new JSTs
                    jstuninstrnew.Add strbkmark, strmodulebasename
                End With
            Next idx
            .Rows(.Rows.Count - 1).Delete ' delete empty row (was added for convenience)
        Else
            .Rows(.Rows.Count - 1).Cells(1).Range.Text = "N/A"
            .Rows(.Rows.Count - 1).Cells(2).Range.Text = "-"
        End If
    End With

    ' point to existing justifications table
    Set rngtbljst = GetTable(tbl.Range.Document, Const_DOCSTRUCTCOV_UNINSTRJSTS).Range
    rngtbljst.MoveStart wdParagraph, -1 ' include table caption
    rng.SetRange rngtbljst.Start, rngtbljst.Start
    rng.Move wdParagraph, -1
    rng.InsertParagraphAfter ' to allow new table to be created
    rng.Collapse wdCollapseEnd
    If Not rng Is Nothing Then
        ' create the justifications table
        strmessage = AddStatusText(strmessage, _
                     InsertJustificationsTable(rng, jstuninstrnew, jstuninstrcur, "Justifications for Un-instrumented Modules", Const_DOCSTRUCTCOV_UNINSTRJSTS, "Module Name", frm))
    End If
    
    ' delete existing justifications table and the empty paragraph above it
    rngtbljst.Delete
    rng.Delete
    
End Sub

Private Sub UpdateConfigItemVariables(ByRef objdoc As Document, ByRef config As cConfigStatus)
    Dim idx As Integer, citem As cConfigItem, vars As cDocVars
    
    Set vars = Dst.Document(objdoc.Fullname).Variables
    
    For idx = 0 To config.ConfigItems.Count - 1
        Set citem = config.ConfigItems.Items(idx)
        vars.ConfigItem(citem.File) = citem.Revision
    Next idx
    
End Sub
Attribute VB_Name = "basTestReports"
Option Explicit

Public Const Const_TESTRESULT_PASSED As String = "Passed"
Public Const Const_TESTRESULT_FAILED As String = "Failed"
Public Const Const_TESTRESULT_NOTEXECUTED As String = "Not Executed"

Public Const Const_CORE_VERSION_TEXT As String = "Core Version"
Public Const Const_TEST_FILES_TEXT As String = "Test Files"

Public Const Const_TEST_FOLDER_PATH_REL2DOC As String = "..\test"

Public Const Const_DOCTEST_SUMMARY As String = "DocTestSummary"
Public Const Const_DOCTEST_CONFIGSUMMARY As String = "DocTestConfigSummary"

Public Const Const_DOCHLTEST_BASELINE As String = "DocHLTestBaseline"
Public Const Const_DOCHLTEST_CONFIG As String = "DocHLTestConfig"
Public Const Const_DOCHLTEST_SUMMARY As String = "DocHLTestSummary"
Public Const Const_DOCHLTEST_RESULT As String = "Doctshl_"
Public Const Const_DOCHLTEST_NOTEXECUTED As String = "DocHLTestsNotExecuted"
Public Const Const_DOCHLTEST_FAILUREJSTS As String = "DocHLTestFailureJSTs"
Public Const Const_DOCHLTEST_NOTEXECUTEDJSTS As String = "DocHLTestsNotExecutedJSTs"
Public Const Const_DOCHLTEST_COMMENTS As String = "DocHLTestsComments"

Public Const Const_DOCLLTEST_SUMMARY As String = "DocLLTestSummary"
Public Const Const_DOCLLTEST_RESULT As String = "Doctsm_"
Public Const Const_DOCLLTEST_NOTEXECUTED As String = "DocLLTestsNotExecuted"
Public Const Const_DOCLLTEST_FAILUREJSTS As String = "DocLLTestFailureJSTs"
Public Const Const_DOCLLTEST_NOTEXECUTEDJSTS As String = "DocLLTestsNotExecutedJSTs"

Public Const Const_DOCSTRUCTCOV_SUMMARY As String = "DocStructCovSummary"
Public Const Const_DOCSTRUCTCOV_INSTRSUMMARY As String = "DocStructCovInstrSummary"
Public Const Const_DOCSTRUCTCOV_UNINSTRJSTS As String = "DocStructCovUnInstrJSTs"
Public Const Const_DOCSTRUCTCOV_HLTESTSUMMARY As String = "DocStructCovHLTestSummary" ' (provisional)
Public Const Const_DOCSTRUCTCOV_JSTS As String = "DocStructCovJSTs"

Public Const Const_DOCHLSTRUCTCOV_BASELINE As String = "DocHLStructCovBaseline" ' (provisional)
Public Const Const_DOCHLSTRUCTCOV As String = "DocHLStructCov"

Public Const Const_DOCLLSTRUCTCOV As String = "DocLLStructCov"

Private BlInstrumetationSummaryTableUpdated As Boolean

Function UpdateSoftwareTestReport(ByRef objdoc As Document, ByRef frm As Object) As Boolean
    Dim strreport As String, blissummaryreport As Boolean, strsummarysubtype As String, dicsubtypes As Scripting.Dictionary
    Dim varsubtype As Variant, doclst As cDocList, strstatus As String, strmessage As String, strdoctype As String
    Dim srninfo As cSrns, strbaselinetable As String, docinfo As cDocInfo
    Dim dteteststart As Date, srn As cSrn, idx As Integer
    Dim rpt As Object, bldocvarsdeleted As Boolean
On Error GoTo Err_UpdateSoftwareTestReport

    UpdateSoftwareTestReport = True
    BlInstrumetationSummaryTableUpdated = False
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    strreport = docinfo.Properties.Fullname
    strdoctype = docinfo.Properties.TypeAbbr
    If strdoctype = "STR" Then
        
        ' validate the doclist
        Set doclst = docinfo.DocList
        strstatus = doclst.Validate
        If strstatus = vbNullString Then
            ' process the subtypes defined for the given STR
            Set dicsubtypes = docinfo.Properties.SubTypesAsDictionary
            For Each varsubtype In dicsubtypes
                If varsubtype Like "*tests*" Or varsubtype Like "*structcov*" Then
                    frm.UpdateProgressText "Processing the '" & varsubtype & "' data set for " & docinfo.Properties.Shortname & "..."
                    
                    ' set some sub-type related variables
                    strsummarysubtype = Replace(varsubtype, "sum", vbNullString) & "sum"
                    blissummaryreport = (strsummarysubtype = varsubtype)
                    strbaselinetable = GetTestBaselineTableBookmark(varsubtype)
                    
                    ' process SRNs if required - only once
                    If strbaselinetable <> vbNullString And srninfo Is Nothing And varsubtype Like "hltests*" Then
                        strmessage = "Fetching the data for SRN(s) referenced in '" & strbaselinetable & "' from SDLC..."
                        frm.UpdateProgressText strmessage
                        Set srninfo = New cSrns
                        strstatus = srninfo.ProcessSrns(doclst, strsummarysubtype, strbaselinetable)
                        
                        ' inform user of errors and abort further processing
                        If strstatus <> vbNullString Then
                            frm.UpdateProgressText strstatus
                            Exit Function
                        Else
                            ' get the most recent test start date if SRNs exist
                            If Not srninfo Is Nothing Then
                                For idx = 0 To srninfo.Srns.Count - 1
                                    Set srn = srninfo.Srns.Items(idx)
                                    If srn.InSdlc And srn.StartDate > dteteststart Then
                                        dteteststart = srn.StartDate
                                    End If
                                Next idx
                                
                                ' inform user which SRN and date information will be used to check configurations
                                frm.UpdateProgressText "Configuration to be checked against the following SRNs:"
                                For idx = 0 To srninfo.Srns.Count - 1
                                    Set srn = srninfo.Srns.Items(idx)
                                    frm.UpdateProgressText srn.DebugString("  ", True)
                                Next idx
                                If dteteststart > 0 Then frm.UpdateProgressText "Results obtained after SRN Date " & dteteststart & " will be used"
                            End If
                        End If
                    End If
                    
                    ' now process the relevant report data
                    If blissummaryreport Then
                        Set rpt = New cTestReportSum
                    ElseIf varsubtype Like "*tests*" Then
                        Set rpt = New cTestReport
                    Else
                        Set rpt = New cCoverageReport
                    End If
                    If rpt.ProcessResults(strreport, varsubtype, dteteststart, srninfo, frm) Then
                        ' write some debug data to a file
                        Call WriteDebugFile(rpt.DebugString, varsubtype)
                        
                        ' before updating the actual STR content, clear the document variables collection (if not already)
                        If Not bldocvarsdeleted Then
                            docinfo.Variables.DeleteAllOfType enumDocVariableTypeFileChecksum
                            docinfo.Variables.DeleteAllOfType enumDocVariableTypeTableChecksum
                            docinfo.Variables.DeleteAllOfType enumDocVariableTypeConfigItem
                            bldocvarsdeleted = True
                        End If
                        
                        ' check for multiple test results in summary reports
                        If blissummaryreport Then
                            If Not CheckTestResultFiles(rpt, strstatus) Then
                                frm.UpdateProgressText "ERROR: The same test results were found in multiple log files:" & vbCrLf & strstatus
                                UpdateSoftwareTestReport = False
                            End If
                        End If
                        
                        ' update the tables for the STR sub-type
                        If Not UpdateSoftwareTestReportTables(objdoc, rpt, srninfo, dteteststart, frm) Then
                            UpdateSoftwareTestReport = False
                        End If
                        
                        ' reset for next iteration
                        Set rpt = Nothing
                    Else
                        UpdateSoftwareTestReport = False
                    End If
                End If
            Next varsubtype
            
            ' update the relevant table checksums if the STR content was updated
            If bldocvarsdeleted Then
                strstatus = CheckTestReportTableChecksums(objdoc, True)
                If strstatus <> vbNullString Then
                    frm.UpdateProgressText strstatus
                    UpdateSoftwareTestReport = False
                End If
            Else
                frm.UpdateProgressText "No test or coverage data found for this STR."
                UpdateSoftwareTestReport = False
            End If
            
        Else
            frm.UpdateProgressText "The following document errors need to be corrected first:" & vbCrLf & strstatus
        End If
    Else
        MsgBox "The current document is not an STR!", vbCritical
        UpdateSoftwareTestReport = False
    End If
        
    ' complete processing
    frm.UpdateProgressText "Done."
    
Exit_UpdateSoftwareTestReport:
    Exit Function
    
Err_UpdateSoftwareTestReport:
    MsgBox Err.Description & " in UpdateSoftwareTestReport()"
    Resume Exit_UpdateSoftwareTestReport
End Function

Private Function UpdateSoftwareTestReportTables(ByRef objdoc As Document, ByRef rpt As Object, ByRef srninfo As cSrns, ByVal dteteststart As Date, ByRef frm As Object) As Boolean
    Dim dictbls As Scripting.Dictionary, vartable As Variant
On Error GoTo Err_UpdateSoftwareTestReport

    Set dictbls = GetTestReportTableList(rpt.ReportSubType, objdoc)
    
    ' first update the known tables
    UpdateSoftwareTestReportTables = True
    For Each vartable In dictbls
        Select Case vartable
            Case Const_DOCHLTEST_BASELINE, Const_DOCHLSTRUCTCOV_BASELINE ' (provisonal)
                ' these tables are updated manually by the users
            
            Case Const_DOCTEST_SUMMARY, _
                 Const_DOCSTRUCTCOV_SUMMARY
                If Not UpdateSummariesTable(objdoc, rpt, vartable, frm) Then
                    UpdateSoftwareTestReportTables = False
                End If
                
            Case Const_DOCSTRUCTCOV_INSTRSUMMARY
                If Not BlInstrumetationSummaryTableUpdated Then
                    If Not UpdateInstrumentationSummaryTable(objdoc, rpt, vartable, frm) Then
                        UpdateSoftwareTestReportTables = False
                    End If
                    BlInstrumetationSummaryTableUpdated = True ' this table updates both high and low-level summary data
                End If
                
            Case Const_DOCSTRUCTCOV_UNINSTRJSTS
                ' this table is updated as part of the instrumentation summary table update above
            
            Case Const_DOCTEST_CONFIGSUMMARY, _
                 Const_DOCHLTEST_CONFIG
                If Not UpdateTestConfigTable(objdoc, rpt, vartable, srninfo, frm) Then
                    UpdateSoftwareTestReportTables = False
                End If
            
            Case Const_DOCHLTEST_SUMMARY, Const_DOCHLTEST_NOTEXECUTED, Const_DOCHLTEST_FAILUREJSTS, Const_DOCHLTEST_NOTEXECUTEDJSTS, Const_DOCHLTEST_COMMENTS, _
                 Const_DOCLLTEST_SUMMARY, Const_DOCLLTEST_NOTEXECUTED, Const_DOCLLTEST_FAILUREJSTS, Const_DOCLLTEST_NOTEXECUTEDJSTS
                ' these tables are updated as part of the test result tables update below
            
            Case Const_DOCHLSTRUCTCOV, _
                 Const_DOCLLSTRUCTCOV
                If Not UpdateStructuralCoverageTable(objdoc, rpt, vartable, frm) Then
                    UpdateSoftwareTestReportTables = False
                End If
                
            Case Const_DOCSTRUCTCOV_JSTS
                ' this table is updated as part of the structural coverage analysis table update above
            
            Case Const_DOCSTRUCTCOV_HLTESTSUMMARY ' (provisional)
            
            
            Case Else
                frm.UpdateProgressText "ERROR: No update process defined for table '" & vartable & "' in '" & rpt.ReportSubType & "' reports"
                UpdateSoftwareTestReportTables = False
        End Select
    Next vartable

    ' now update the test result tables if required
    If rpt.ReportSubType = "hltests" Or rpt.ReportSubType = "lltests" Then
        If Not UpdateTestResultsTables(objdoc, rpt, dteteststart, frm) Then
            UpdateSoftwareTestReportTables = False
        End If
    End If

Exit_UpdateSoftwareTestReportTables:
    Exit Function
    
Err_UpdateSoftwareTestReport:
    MsgBox Err.Description & " in UpdateSoftwareTestReportTables()"
    UpdateSoftwareTestReportTables = False
    Resume Exit_UpdateSoftwareTestReportTables
End Function

Sub InsertNotApplicable(ByRef rng As Range, Optional ByVal blinsertparagraph As Boolean = False)

    rng.Text = "Not applicable."
    If blinsertparagraph Then
        rng.InsertParagraphAfter
        rng.Collapse wdCollapseEnd
    End If
    
End Sub
                
Function ProcessStatusMessage(ByRef strmessage As String, ByRef frm As Object) As Boolean

    ' update error status
    If strmessage = vbNullString Then
        ProcessStatusMessage = True
    Else
        frm.UpdateProgressText "   ERROR: " & Replace(strmessage, vbCrLf, vbCrLf & String(10, " "))
        ProcessStatusMessage = False
    End If
    
End Function

Sub UpdateTestResultFileChecksum(ByRef objdoc As Document, strresultfile As String)
    Dim strrelpath As String
        
    strrelpath = GetRelativePath(objdoc.Path, strresultfile)
    Dst.Document(objdoc.Fullname).Variables.FileChecksum(strrelpath) = FileCRC32(strresultfile)  ' add log file checksum to document variables collection

End Sub

Function CheckTestReportTableChecksums(ByRef objdoc As Document, Optional ByVal blupdate As Boolean = False) As String
    Dim strmessage As String, strdoctype As String, strtemp As String
    Dim dictbls As Scripting.Dictionary, docinfo As cDocInfo
    Dim varsubtype As Variant, vartable As Variant, bkm As cDocBookmark
    
    Set docinfo = Dst.Document(objdoc.Fullname)
    strdoctype = docinfo.Properties.Fullname
    If strdoctype = "STR" Then
        ' for each STR sub-type, check if table bookmark exists and compute its checksum
        For Each varsubtype In docinfo.Properties.SubTypesAsDictionary
            Set dictbls = GetTestReportTableList(varsubtype, objdoc)
            For Each vartable In dictbls
                ' only process if it has a checksum
                If dictbls(vartable) Then
                    strtemp = ProcessTableChecksum(objdoc, vartable, blupdate)
                    If strtemp <> vbNullString Then
                        strmessage = strmessage & IIf(strmessage <> vbNullString, vbCrLf, vbNullString) & strtemp
                    End If
                End If
            Next vartable
        Next varsubtype
    
        ' now check for variant table bookmarks types and compute their checksums
        For Each bkm In docinfo.Bookmarks.Internal
            If bkm.Name Like Const_DOCHLTEST_RESULT & "*" Or bkm.Name Like Const_DOCLLTEST_RESULT & "*" Then
                strtemp = ProcessTableChecksum(objdoc, bkm.Name, blupdate)
                If strtemp <> vbNullString Then
                    strmessage = strmessage & IIf(strmessage <> vbNullString, vbCrLf, vbNullString) & strtemp
                End If
            End If
        Next bkm
    End If
    
    CheckTestReportTableChecksums = strmessage
    
End Function

Function CheckTestReportResultFileChecksums(ByRef objdoc As Document, Optional ByRef dicrsltfiles As Scripting.Dictionary) As String
    Dim strmessage As String, strdoctype As String, strtemp As String, strresultfile As String
    Dim varname As Variant, strfilechecksum As String, dicvaritems As Scripting.Dictionary
    Dim fso As FileSystemObject, docinfo As cDocInfo
On Error GoTo Err_CheckTestReportResultFileChecksums

    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(objdoc.Fullname)
    
    strdoctype = docinfo.Properties.TypeAbbr
    If strdoctype = "STR" Then
        ' check result file checksum entries in the document variables
        Set dicvaritems = docinfo.Variables.OfType(enumDocVariableTypeFileChecksum)
        For Each varname In dicvaritems
            strtemp = vbNullString
            If dicrsltfiles Is Nothing Then
                ' no dictionary supplied, so use default result files paths
                strresultfile = fso.GetAbsolutePathName(fso.BuildPath(objdoc.Path, varname))
            Else
                ' dictionary supplied (probably via SDLC), so use paths provided - assume absolute paths are given
                strresultfile = dicrsltfiles(varname)
            End If
            strfilechecksum = FileCRC32(strresultfile)
            
            If strfilechecksum <> dicvaritems(varname) Then
                strtemp = "Checksum error: '" & varname & "' the test result file is different to the one used to update the STR - update the STR again or make sure that the correct revisions of the results files are " & _
                           IIf(dicrsltfiles Is Nothing, "on your local machine", "tagged")
            End If
            
            If strtemp <> vbNullString Then strmessage = strmessage & IIf(strmessage <> vbNullString, vbCrLf, vbNullString) & strtemp
        Next varname
    End If
    
    CheckTestReportResultFileChecksums = strmessage
    
Exit_CheckTestReportResultFileChecksums:
    Exit Function

Err_CheckTestReportResultFileChecksums:
    MsgBox Err.Description & " in CheckTestReportResultFileChecksums() of basTestReports"
    Resume Exit_CheckTestReportResultFileChecksums
End Function

Private Function CheckTestResultFiles(ByRef rptsum As cTestReportSum, ByRef strmessage As String) As Boolean
    Dim rpt As cTestReport, rslt As cTestResult, tcase As cTestCase
    Dim idxrpt As Integer, idxrslt As Integer, idxtcase As Integer
    
    For idxrpt = 0 To rptsum.TestReports.Count - 1
        Set rpt = rptsum.TestReports.Items(idxrpt)
        For idxrslt = 0 To rpt.TestResults.Count - 1
            Set rslt = rpt.TestResults.Items(idxrslt)
            For idxtcase = 0 To rslt.TestCases.Count - 1
                Set tcase = rslt.TestCases.Items(idxtcase)
                Call FindTestCaseResult(rptsum, tcase.TestCase, rslt, strmessage)
            Next idxtcase
        Next idxrslt
    Next idxrpt
    
    If strmessage = vbNullString Then
        CheckTestResultFiles = True
    End If
    
End Function

Private Sub FindTestCaseResult(ByRef rptsum As cTestReportSum, ByVal strtestcase As String, ByRef tcasecontainer As cTestResult, ByRef strmessage As String)
    Dim rpt As cTestReport, rslt As cTestResult, tcase As cTestCase
    Dim idxrpt As Integer, idxrslt As Integer, idxtcase As Integer
    
    For idxrpt = 0 To rptsum.TestReports.Count - 1
        Set rpt = rptsum.TestReports.Items(idxrpt)
        For idxrslt = 0 To rpt.TestResults.Count - 1
            Set rslt = rpt.TestResults.Items(idxrslt)
            For idxtcase = 0 To rslt.TestCases.Count - 1
                Set tcase = rslt.TestCases.Items(idxtcase)
                If tcase.TestCase = strtestcase Then
                    If rslt.TestResultFile <> tcasecontainer.TestResultFile Then
                        strmessage = strmessage & "Test result for '" & strtestcase & "' listed in both '" & rslt.TestResultFile & "' and '" & tcasecontainer.TestResultFile & "'" & vbCrLf
                    End If
                End If
            Next idxtcase
        Next idxrslt
    Next idxrpt
    
End Sub

Function GetSTDFileNameFromSTR(ByVal strreport As String) As String
    Dim strstdname As String, strdocfolder As String, fso As FileSystemObject

    ' determine the STD name based on the STR name
    Set fso = New FileSystemObject
    strdocfolder = fso.GetParentFolderName(strreport)
    strstdname = fso.GetFileName(strreport)
    strstdname = Replace(strstdname, "str_", "std_", 1, 1)
    strstdname = Replace(strstdname, "atr_", "atp_", 1, 1) ' in case ATP document is used as an STD
    strstdname = fso.BuildPath(strdocfolder, strstdname)
    GetSTDFileNameFromSTR = strstdname

End Function

Function GetSTRFileNameFromSTD(ByVal strstd As String) As String
    Dim strreport As String, strdocfolder As String, fso As FileSystemObject

    ' determine the STD name based on the STR name
    Set fso = New FileSystemObject
    strdocfolder = fso.GetParentFolderName(strstd)
    strreport = fso.GetFileName(strstd)
    strreport = Replace(strreport, "std_", "str_", 1, 1)
    strreport = Replace(strreport, "atp_", "atr_", 1, 1)
    strreport = fso.BuildPath(strdocfolder, strreport)
    GetSTRFileNameFromSTD = strreport

End Function

Private Function GetTestReportTableList(ByVal strsubtype As String, ByRef objdoc As Document) As Scripting.Dictionary
' Builds a dictionary that contains the list of table bookmark names for the given STR sub-type and whether a checksum applies to each table
    Dim dictables As New Scripting.Dictionary, dicsubtypes As New Scripting.Dictionary
            
    Set dicsubtypes = Dst.Document(objdoc.Fullname).Properties.SubTypesAsDictionary
    
    Select Case strsubtype
        Case "hltestssum"
            dictables.Add Const_DOCHLTEST_BASELINE, False
            dictables.Add Const_DOCTEST_CONFIGSUMMARY, True
            dictables.Add Const_DOCTEST_SUMMARY, True
            
        Case "hltests"
            If Not dicsubtypes.Exists("hltestssum") Then dictables.Add Const_DOCHLTEST_CONFIG, True
            dictables.Add Const_DOCHLTEST_SUMMARY, True
            dictables.Add Const_DOCHLTEST_NOTEXECUTED, True
            dictables.Add Const_DOCHLTEST_FAILUREJSTS, False
            dictables.Add Const_DOCHLTEST_NOTEXECUTEDJSTS, False
            dictables.Add Const_DOCHLTEST_COMMENTS, False
    
        Case "lltestssum"
            dictables.Add Const_DOCTEST_CONFIGSUMMARY, True
            dictables.Add Const_DOCTEST_SUMMARY, True
    
        Case "lltests"
            dictables.Add Const_DOCLLTEST_SUMMARY, True
            dictables.Add Const_DOCLLTEST_NOTEXECUTED, True
            dictables.Add Const_DOCLLTEST_FAILUREJSTS, False
            dictables.Add Const_DOCLLTEST_NOTEXECUTEDJSTS, False
    
        Case "hlstructcovsum"
            dictables.Add Const_DOCSTRUCTCOV_SUMMARY, True
            dictables.Add Const_DOCSTRUCTCOV_INSTRSUMMARY, True
            dictables.Add Const_DOCSTRUCTCOV_UNINSTRJSTS, False
            ' dictables.Add Const_DOCHLSTRUCTCOV_BASELINE, False (provision)
            ' dictables.Add Const_DOCSTRUCTCOV_HLTESTSUMMARY, true (provision)
    
        Case "hlstructcov"
            dictables.Add Const_DOCHLSTRUCTCOV, True
            dictables.Add Const_DOCSTRUCTCOV_JSTS, False
    
        Case "llstructcovsum"
            dictables.Add Const_DOCSTRUCTCOV_SUMMARY, True
            dictables.Add Const_DOCSTRUCTCOV_INSTRSUMMARY, True
            dictables.Add Const_DOCSTRUCTCOV_UNINSTRJSTS, False
    
        Case "llstructcov"
            dictables.Add Const_DOCLLSTRUCTCOV, True
            dictables.Add Const_DOCSTRUCTCOV_JSTS, False
            
        Case "sa", "notests"
            ' no tables apply to static analysis and container STRs
            
        Case Else
            MsgBox "No test report table list defined for the '" & strsubtype & "' sub-type", vbCritical
            
    End Select
    
    Set GetTestReportTableList = dictables
    
End Function

Function GetTestBaselineTableBookmark(ByVal strsubtype As String) As String
    
    If strsubtype Like "hltests*" Then
        GetTestBaselineTableBookmark = Const_DOCHLTEST_BASELINE
    End If
    
End Function

Function GetTestConfigTableBookmark(ByVal strsubtype As String, ByRef objdoc As Document) As String
    Dim vartable As Variant
    
    For Each vartable In GetTestReportTableList(strsubtype, objdoc)
        If vartable Like "*TestConfig*" Then ' assume bookmark names always look like this
            GetTestConfigTableBookmark = vartable
            Exit For
        End If
    Next vartable
    
End Function

Function GetOtherReportSubType(ByVal strreportsubtype As String) As String
    GetOtherReportSubType = Replace(strreportsubtype, IIf(strreportsubtype Like "hl*", "hl", "ll"), IIf(strreportsubtype Like "hl*", "ll", "hl"), 1, 1)
End Function

Function GetResultFileList(ByRef objdoc As Document) As Scripting.Dictionary
    Set GetResultFileList = Dst.Document(objdoc.Fullname).Variables.OfType(enumDocVariableTypeFileChecksum)
End Function
Attribute VB_Name = "basTestTableFormats"
Option Explicit

' Table format text strings
Public Const Const_TABLE_PURPOSE_TEXT As String = "Purpose:"
Public Const Const_TABLE_ASSUMPTIONS_TEXT As String = "Assumptions:"
Public Const Const_TABLE_SIDE_EFFECTS_TEXT As String = "Side Effects:"
Public Const Const_TABLE_INPUTS_TEXT As String = "Inputs:"
Public Const Const_TABLE_COVERAGE_LIMITATIONS_TEXT As String = "Test Coverage Limitations:"
Public Const Const_TABLE_ADD_HARDWARE_REQ_TEXT As String = "Additional Hardware Requirements:"
Public Const Const_TABLE_INPUT_DATA_REQ_TEXT As String = "Test Set Input Data Requirements:"
Public Const Const_TABLE_OUTPUT_DATA_REQ_TEXT As String = "Test Set Output Data Requirements:"
Public Const Const_TABLE_CONDITIONS_TEXT As String = "Initial Conditions:"
Public Const Const_TABLE_PROCEDURE_TEXT As String = "Procedure:"
Public Const Const_TABLE_STEP_RESULT_TEXT As String = "Expected Results:"
Public Const Const_TABLE_RESULTS_TEXT As String = "Results:"
Public Const Const_TABLE_REQUIREMENTS_TEXT As String = "Requirements:"
Public Const Const_TABLE_IMP_REF_TEXT As String = "Implementation Reference:"
Public Const Const_TABLE_SPEC_REF_TEXT As String = "Specification Reference:"
Public Const Const_TABLE_PREPARATIONS_TEXT As String = "Preparations:"
Public Const Const_TABLE_LINKS_TEXT As String = "Links:"
Public Const Const_TABLE_COMMENTS_TEXT As String = "Comments:"
Public Const Const_INSTR_START As String = "[####"
Public Const Const_INSTR_END As String = "####]"
Public Const Const_TABLE_INSTR_ABSTR_SUMMARY_REMINDER As String = "Remember to run the 'Update Summary Table' macro to rebuild the '" & Const_DOCTESTABSTRACTIONS_SUMMARY & "' table"
Public Const Const_TABLE_INSTR_ABSTR_PURPOSE_TEXT As String = Const_INSTR_START & " " & Const_TABLE_INSTR_ABSTR_SUMMARY_REMINDER & " " & Const_INSTR_END
Public Const Const_TABLE_INSTR_PURPOSE_TEXT As String = ""
Public Const Const_TABLE_INSTR_NONE_TEXT As String = Const_INSTR_START & " Type " & """" & "None." & """" & " if not applicable, don't delete the entire block " & Const_INSTR_END
Public Const Const_TABLE_INSTR_NOT_APPLICABLE_TEXT As String = Const_INSTR_START & " Type " & """" & "Not Applicable." & """" & " if not applicable, don't delete the entire block " & Const_INSTR_END
Public Const Const_TABLE_INSTR_HLNK_CSHARP_TEXT As String = Const_INSTR_START & " DST will insert a hyperlink to the C# test script here when the user generates the C# test files " & Const_INSTR_END
Public Const Const_TABLE_INSTR_HLNK_CSHARP_MAN_TEXT As String = Const_INSTR_START & " Insert a hyperlink to the C# test script here " & Const_INSTR_END
Public Const Const_TABLE_INSTR_HLNK_MODTEST_TEXT As String = Const_INSTR_START & " DST can be used to populate this hyperlink field " & Const_INSTR_END
Public Const Const_TABLE_INSTR_TEST_IMP_TEXT As String = Const_INSTR_START & " DST will insert a reference to the test implementation bookmark when the user generates the test implementation template - delete this row if the implementation is not documented in the STD " & Const_INSTR_END
Public Const Const_TABLE_INSTR_TEST_SPEC_TEXT As String = Const_DOC_ERROR_STRING & " Could not insert the cross-reference to the test specification. Use DST to manually insert the reference to the associated test specification"
Public Const Const_TABLE_INSTR_REFS_TEXT As String = Const_INSTR_START & " Use the Insert X Ref function of the DST to insert references to test sets, test cases and test configurations " & Const_INSTR_END
Public Const Const_TABLE_INSTR_REQS_TEXT As String = Const_INSTR_START & " Use the Insert X Ref function of the DST to insert references to requirements for traceability " & Const_INSTR_END
Public Const Const_TABLE_INSTR_INSP1_TEXT As String = "Note that this is an Inspection Test Case"
Public Const Const_TABLE_INSTR_INSP2_TEXT As String = Const_INSTR_START & " Delete if not applicable " & Const_INSTR_END
Public Const Const_TABLE_INSTR_HYPERLINK_TEXT As String = Const_INSTR_START & " Insert hyperlink here and use the Test Mgmt function of the DST to insert the hyperlink content below this line " & Const_INSTR_END

' Test table column widths for portrait
Public Const Const_STD_TABLE_WIDTH As Single = 17.5
Public Const Const_CELL_DELTA_LS_WIDTH As Single = 7
Public Const Const_CELL_NUM_WIDTH As Single = 0.75
Public Const Const_CELL_PURPOSE_LABEL_WIDTH As Single = 2.5
Public Const Const_CELL_PURPOSE_WIDTH As Single = 15.75
Public Const Const_CELL_INPUT_NAME_WIDTH As Single = 3.45
Public Const Const_CELL_INPUT_NAME_HEAD_WIDTH As Single = Const_CELL_NUM_WIDTH + Const_CELL_INPUT_NAME_WIDTH
Public Const Const_CELL_PREPS_WIDTH As Single = 15
Public Const Const_CELL_PROC_STEP_WIDTH As Single = 7.5
Public Const Const_CELL_PROC_STEP_HEAD_WIDTH As Single = Const_CELL_NUM_WIDTH + Const_CELL_PROC_STEP_WIDTH
Public Const Const_CELL_REQ_REF_WIDTH As Single = Const_CELL_PROC_STEP_WIDTH
Public Const Const_CELL_REQ_OLD_TEXT_WIDTH As Single = 6
Public Const Const_CELL_REQ_OLD_REF_WIDTH As Single = 5.25

Public Const Const_CELL_LINK_WIDTH As Single = 12.3
Public Const Const_CELL_LINK_SCALE_HEAD_WIDTH As Single = 1.5
Public Const Const_CELL_LINK_SCALE_WIDTH As Single = 1.2

Sub SetTestTableFormat(ByVal strtestname As String, ByRef tblfrmt As cTblTestFormat)
    Dim strbooktype As String
    
    strbooktype = Dst.BookmarkConfig.PrefixFromName(strtestname)
    Select Case strbooktype
        Case "tabstr"
            Call SetTestAbstractionTableFormat(tblfrmt)
            
        Case "tshl"
            Call SetTestSetSpecTableFormat(tblfrmt)
        
        Case "tsm"
            Call SetTestSetSpecModuleTableFormat(tblfrmt)
        
        Case "tchln", "tchlr"
            Call SetTestCaseSpecTableFormat(tblfrmt)
        
        Case "tshlia", "tshlim"
            Call SetTestSetImpTableFormat(tblfrmt)
        
        Case "tchlnia", "tchlnim", "tchlria", "tchlrim"
            Call SetTestCaseImpTableFormat(tblfrmt)
        
        Case "tsatp"
            Call SetTestSetSatpTableFormat(tblfrmt)
        
        Case "tcatp"
            Call SetTestCaseSatpTableFormat(tblfrmt)
        
        Case Else
            ' assume test name is valid
    End Select
    
End Sub

Sub SetTestAbstractionTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an STD Test Abstraction table
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    '================================================================================================================
    ' Purpose row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PURPOSE_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_ABSTR_PURPOSE_TEXT
        sectfrmt.TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Assumptions row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_ASSUMPTIONS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
    '================================================================================================================
    ' Side Effects row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_SIDE_EFFECTS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
    '================================================================================================================
    ' Inputs rows
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_INPUTS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = "Name:"
        celfrmt.Width = Const_CELL_INPUT_NAME_HEAD_WIDTH
        sectfrmt.HeadingRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = "Description:"
        sectfrmt.HeadingRow.CellsFormat.Add 3, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        sectfrmt.SubRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.Width = Const_CELL_INPUT_NAME_WIDTH
        sectfrmt.SubRow.CellsFormat.Add 3, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 4, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt

    '================================================================================================================
    ' Procedure rows
    '================================================================================================================
    Call SetProcedureSectionFormat(tblfrmt)
    
    '================================================================================================================
    ' Implementation Reference row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_IMP_REF_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.StyleOverride = "Hyperlink"
        sectfrmt.HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_HLNK_CSHARP_MAN_TEXT
        sectfrmt.TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Comments row
    '================================================================================================================
    Call SetCaseCommentsSectionFormat(tblfrmt)
    
End Sub

Sub SetTestSetSpecTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an STD Test Set Specification table
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    '================================================================================================================
    ' Purpose row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PURPOSE_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format subrow
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_PURPOSE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Test Coverage Limitations row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_COVERAGE_LIMITATIONS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
    '================================================================================================================
    ' Additional Hardware Requirements row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_ADD_HARDWARE_REQ_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
    '================================================================================================================
    ' Test Set Input Data Requirements row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_INPUT_DATA_REQ_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt

    '================================================================================================================
    ' Test Set Output Data Requirements row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_OUTPUT_DATA_REQ_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
    '================================================================================================================
    ' Implementation Reference row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_IMP_REF_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        celfrmt.StyleOverride = "Hyperlink"
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_HLNK_CSHARP_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_TEST_IMP_TEXT
        sectfrmt.TemplateText.Add 3, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Comments row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_COMMENTS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub

Sub SetTestSetSpecModuleTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an STD Test Set Specification table for module tests
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    '================================================================================================================
    ' Purpose row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PURPOSE_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format subrow
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_PURPOSE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Implementation Reference row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_IMP_REF_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        celfrmt.StyleOverride = "Hyperlink"
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_HLNK_MODTEST_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Comments row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_COMMENTS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub

Sub SetTestCaseSpecTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an STD Test Case Specification table
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    '================================================================================================================
    ' Purpose row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PURPOSE_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, vbNullString ' no template text for heading row
        .TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Initial Conditions rows
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_CONDITIONS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .HeadingRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 3, celfrmt ' empty cell
        ' format sub row
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .SubRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 3, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_NONE_TEXT
        .TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_REFS_TEXT
        .TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt

    '================================================================================================================
    ' Procedure rows
    '================================================================================================================
    Call SetProcedureSectionFormat(tblfrmt)
    
    '================================================================================================================
    ' Results rows
    '================================================================================================================
    If IsOldFormatStd() Then Call SetResultsSectionFormat(tblfrmt)
        
    '================================================================================================================
    ' Requirements rows
    '================================================================================================================
    Call SetRequirementsSectionFormat(tblfrmt, True)
    
    '================================================================================================================
    ' Implementation Reference row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_IMP_REF_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.StyleOverride = "Hyperlink"
        .HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        ' format sub row
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_HLNK_CSHARP_TEXT
        .TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_TEST_IMP_TEXT
        .TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Comments row
    '================================================================================================================
    Call SetCaseCommentsSectionFormat(tblfrmt)
    
End Sub

Sub SetTestSetImpTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an STD Test Set Implementation table
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    '================================================================================================================
    ' Specification row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_SPEC_REF_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format subrow
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_TEST_SPEC_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Preparations rows
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PREPARATIONS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_NOT_APPLICABLE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_REFS_TEXT
        sectfrmt.TemplateText.Add 3, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
    '================================================================================================================
    ' Comments row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_COMMENTS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        sectfrmt.TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub

Sub SetTestCaseImpTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an STD Test Case Implementation table
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    '================================================================================================================
    ' Specification reference row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_SPEC_REF_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_TEST_SPEC_TEXT
        .TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Preparations rows
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PREPARATIONS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .HeadingRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 3, celfrmt ' empty cell
        ' format sub row
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .SubRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 3, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_NONE_TEXT
        .TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_REFS_TEXT
        .TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt

    '================================================================================================================
    ' Procedure rows
    '================================================================================================================
    Call SetProcedureSectionFormat(tblfrmt)
    
    '================================================================================================================
    ' Results rows
    '================================================================================================================
    If IsOldFormatStd() Then Call SetResultsSectionFormat(tblfrmt)
    
    '================================================================================================================
    ' Comments row
    '================================================================================================================
    Call SetCaseCommentsSectionFormat(tblfrmt)
    
End Sub

Sub FormatTestTable(ByRef rng As Range)
    Dim tbl As Table, strtestname As String, tblformat As cTblTestFormat, strmessage As String
On Error GoTo Err_FormatTestTable

    Call ScreenUpdatePause
    
    If IsTestTable(rng, strtestname) Then
        ' (re)apply requirement, literal and variable reference styles
        Set tbl = rng.Tables(1)
        Call ApplyStyleToField(Dst.BookmarkConfig.Prefix("reqsw").ReferenceStyle, "reqsw", tbl.Range)
        Call ApplyStyleToField(Dst.BookmarkConfig.Prefix("sreqsw").ReferenceStyle, "sreqsw", tbl.Range)
        Call ApplyStyleToField(Dst.BookmarkConfig.Prefix("reqsdd").ReferenceStyle, "reqsdd", tbl.Range)
        Call ApplyStyleToField(Dst.BookmarkConfig.Prefix("srslit").ReferenceStyle, "srslit", tbl.Range)
        Call ApplyStyleToField(Dst.BookmarkConfig.Prefix("srsvar").ReferenceStyle, "srsvar", tbl.Range)
        
        ' format the rest of the table
        Set tblformat = New cTblTestFormat
        Call SetTestTableFormat(strtestname, tblformat)
        strmessage = tblformat.Format(tbl)
        If strmessage <> vbNullString Then
            MsgBox strmessage, vbCritical, "Test Format Error"
        End If
    End If
    
Exit_FormatTestTable:
    Call ScreenUpdateRestore
    Exit Sub
    
Err_FormatTestTable:
    MsgBox Err.Description & " in FormatTestTable()"
    Resume Exit_FormatTestTable
    
End Sub

Private Sub SetProcedureSectionFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the test procedure format
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary

    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PROCEDURE_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = "Steps:"
        celfrmt.Width = Const_CELL_PROC_STEP_HEAD_WIDTH
        .HeadingRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = Const_TABLE_STEP_RESULT_TEXT
        If IsOldFormatStd() Then celfrmt.Label = Replace(celfrmt.Label, "Expected", "Intermediate")
        .HeadingRow.CellsFormat.Add 3, celfrmt
        ' format sub row
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .SubRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.Width = Const_CELL_PROC_STEP_WIDTH
        .SubRow.CellsFormat.Add 3, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 4, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 1, vbNullString ' no template text for heading row
        .TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_NONE_TEXT
        .TemplateText.Add 2, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_REFS_TEXT
        .TemplateText.Add 3, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub

Private Sub SetRequirementsSectionFormat(ByRef tblfrmt As cTblTestFormat, ByVal blnewformat As Boolean)
    ' Creates the test results format
    Dim sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_REQUIREMENTS_TEXT
    With sectfrmt
        ' format heading row
        Call SetRequirementsRowFormat(.HeadingRow, True, blnewformat)
        
        ' format sub row
        Call SetRequirementsRowFormat(.SubRow, False, blnewformat)
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_NONE_TEXT
        .TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_REFS_TEXT
        .TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub

Sub SetRequirementsRowFormat(ByRef rowfrmt As cTblRowFormat, ByVal blheadingrow As Boolean, ByVal blnewformat As Boolean)
    Dim celfrmt As cTblCellFormat
    
    With rowfrmt
        Set celfrmt = New cTblCellFormat
        If blheadingrow Then celfrmt.Label = Const_TABLE_REQUIREMENTS_TEXT
        .CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .CellsFormat.Add 2, celfrmt
        If blnewformat Then
            Set celfrmt = New cTblCellFormat
            celfrmt.Width = Const_CELL_REQ_REF_WIDTH
            celfrmt.StyleOverride = "DSTTrcRef"
            .CellsFormat.Add 3, celfrmt ' empty cell
            Set celfrmt = New cTblCellFormat
            .CellsFormat.Add 4, celfrmt ' empty cell
        Else
            Set celfrmt = New cTblCellFormat
            celfrmt.Width = Const_CELL_REQ_OLD_TEXT_WIDTH
            celfrmt.StyleOverride = Const_STYLE_TABLE_TEXT_SMALL ' just to make sure
            .CellsFormat.Add 3, celfrmt ' empty cell
            Set celfrmt = New cTblCellFormat
            celfrmt.Width = Const_CELL_REQ_OLD_REF_WIDTH
            celfrmt.StyleOverride = "DSTTrcRef"
            .CellsFormat.Add 4, celfrmt ' empty cell
            Set celfrmt = New cTblCellFormat
            .CellsFormat.Add 5, celfrmt ' empty cell
        End If
    End With
    
End Sub

Private Sub SetResultsSectionFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the test results format
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_RESULTS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .HeadingRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 3, celfrmt ' empty cell
        ' format sub row
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .SubRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 3, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_NONE_TEXT
        sectfrmt.TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub

Private Sub SetCaseCommentsSectionFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the test case comments format
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary

    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_COMMENTS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, Const_TABLE_INSTR_NONE_TEXT
        .TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub

Function GetTableWidth(ByRef rng As Range) As Single
    Dim sngllandscapedelta As Single
    
    ' determine table width based on page orientation
    sngllandscapedelta = IIf(rng.PageSetup.Orientation = wdOrientLandscape, CentimetersToPoints(Const_CELL_DELTA_LS_WIDTH), 0)
    GetTableWidth = CentimetersToPoints(Const_STD_TABLE_WIDTH) + sngllandscapedelta
    
End Function

Function IsOldFormatStd() As Boolean
    Dim tset As cHeadingGroup, tcase As cHeading, tbl As Table, cel As Cell, strstepresulttext As String
    
    ' build list in case STD Tools form hasn't been loaded yet
    If TestSets Is Nothing Then
        Call BuildTestSpecificationList
    End If
    
    ' determine the text of the step result heading of the first test case - search for intermediate text
    strstepresulttext = Replace(Const_TABLE_STEP_RESULT_TEXT, "Expected", "Intermediate")
    If TestSets.Count > 0 Then
        Set tset = TestSets.Items(0)
        If tset.SubItems.Count > 0 Then
            Set tcase = tset.SubItems.Items(0)
            Set tbl = GetTable(ActiveDocument, tcase.Bookmark)
            For Each cel In tbl.Range.Cells
                If GetCellText(cel) = strstepresulttext Then
                    IsOldFormatStd = True
                    Exit For
                End If
            Next cel
        End If
    End If
    
End Function

Function GetTestTablePurposeSection(ByRef rng As Range) As Range
    Set GetTestTablePurposeSection = GetTestTableSection(rng, Const_TABLE_PURPOSE_TEXT)
End Function

Function GetTestTablePreparationsSection(ByRef rng As Range) As Range
    Set GetTestTablePreparationsSection = GetTestTableSection(rng, Const_TABLE_PREPARATIONS_TEXT)
End Function

Function GetTestTableProceduresSection(ByRef rng As Range) As Range
    Set GetTestTableProceduresSection = GetTestTableSection(rng, Const_TABLE_PROCEDURE_TEXT)
End Function

Function GetTestTableConditionsSection(ByRef rng As Range) As Range
    Set GetTestTableConditionsSection = GetTestTableSection(rng, Const_TABLE_CONDITIONS_TEXT)
End Function

Function GetTestTableResultsSection(ByRef rng As Range) As Range
    Set GetTestTableResultsSection = GetTestTableSection(rng, Const_TABLE_RESULTS_TEXT)
End Function

Function GetTestTableRequirementsSection(ByRef rng As Range) As Range
    Set GetTestTableRequirementsSection = GetTestTableSection(rng, Const_TABLE_REQUIREMENTS_TEXT)
End Function

Function GetTestTableCommentsSection(ByRef rng As Range) As Range
    Set GetTestTableCommentsSection = GetTestTableSection(rng, Const_TABLE_COMMENTS_TEXT)
End Function

Function GetTestTableSection(ByRef rng As Range, ByVal strsectionheader As String) As Range
    Dim tbl As Table, strtestname As String, tblformat As cTblTestFormat
    Dim rwstart As Row, rwend As Row, rngreqs As Range, strsectionheadernext As String
    
    If IsTestTable(rng, strtestname) Then
        Set tbl = rng.Tables(1)
        Set tblformat = New cTblTestFormat
        Call SetTestTableFormat(strtestname, tblformat)
        Set rwstart = tblformat.GetSectionStartRow(tbl, strsectionheader)
        Set rwend = tblformat.GetSectionEndRow(tbl, strsectionheader, strsectionheadernext)
        If Not rwstart Is Nothing And Not rwend Is Nothing Then
            Set rngreqs = tbl.Range
            rngreqs.SetRange rwstart.Range.Start, rwend.Range.End
            Set GetTestTableSection = rngreqs
        ElseIf rwstart Is Nothing Then
            MsgBox "Could not locate table section starting with header '" & strsectionheader & "'", vbCritical
        ElseIf rwend Is Nothing Then
            MsgBox "Could not locate table section starting with header '" & strsectionheader & "' and ending with '" & strsectionheadernext & "'", vbCritical
        End If
    End If
    
End Function

Sub SetTestSetSatpTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an SATP Test Set table
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat
    
    '================================================================================================================
    ' Purpose row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PURPOSE_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        sectfrmt.HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        sectfrmt.SubRow.CellsFormat.Add 2, celfrmt ' empty cell
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt

End Sub

Sub SetTestCaseSatpTableFormat(ByRef tblfrmt As cTblTestFormat)
    ' Creates the format of an SATP Test Case table
    Dim celfrmt As cTblCellFormat, sectfrmt As cTblSectionFormat, dicrowtext As Scripting.Dictionary
    
    '================================================================================================================
    ' Purpose row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PURPOSE_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, vbNullString ' no template text for heading row
        .TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
            
    '================================================================================================================
    ' Initial Conditions rows
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_PREPARATIONS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .HeadingRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 3, celfrmt ' empty cell
        ' format sub row
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 1, celfrmt ' empty cell
        Set celfrmt = New cTblCellFormat
        celfrmt.IsNumber = True
        .SubRow.CellsFormat.Add 2, celfrmt
        Set celfrmt = New cTblCellFormat
        .SubRow.CellsFormat.Add 3, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_NONE_TEXT
        .TemplateText.Add 1, dicrowtext
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 3, Const_TABLE_INSTR_REFS_TEXT
        .TemplateText.Add 2, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
    '================================================================================================================
    ' Procedure rows
    '================================================================================================================
    Call SetProcedureSectionFormat(tblfrmt)
    
    '================================================================================================================
    ' Results row
    '================================================================================================================
    Call SetResultsSectionFormat(tblfrmt)
    
    '================================================================================================================
    ' Requirements rows
    '================================================================================================================
    Call SetRequirementsSectionFormat(tblfrmt, False)
    
    '================================================================================================================
    ' Links row
    '================================================================================================================
    Set sectfrmt = New cTblSectionFormat
    sectfrmt.SectionHeader = Const_TABLE_LINKS_TEXT
    With sectfrmt
        ' format heading row
        Set celfrmt = New cTblCellFormat
        celfrmt.Label = sectfrmt.SectionHeader
        .HeadingRow.CellsFormat.Add 1, celfrmt
        Set celfrmt = New cTblCellFormat
        .HeadingRow.CellsFormat.Add 2, celfrmt ' empty cell
        
        ' template text
        Set dicrowtext = New Scripting.Dictionary
        dicrowtext.Add 2, "None"
        .TemplateText.Add 1, dicrowtext
    End With
    tblfrmt.TableFormat.Add sectfrmt.SectionHeader, sectfrmt
    
End Sub
Attribute VB_Name = "basTests"
Option Explicit

' Test type strings
Public Const Const_TESTABSTRACTION As String = "Abstraction"
Public Const Const_TESTSPECIFICATION As String = "Specification"
Public Const Const_TESTIMPLEMENTATION As String = "Implementation"

' Test set and case bookmark name prefixes
Public Const Const_TESTABSTR_PREFIX As String = "tabstr"
Public Const Const_TESTSET_HL_PREFIX As String = "tshl"
Public Const Const_TESTCASE_HLN_PREFIX As String = "tchln"
Public Const Const_TESTCASE_HLR_PREFIX As String = "tchlr"
Public Const Const_TESTSET_LL_PREFIX As String = "tsm"

' Bookmarks that delimit the start and end of the test description sections in STDs
Public Const Const_DOCTESTABSTRACTIONS_SUMMARY As String = "DocTestAbstractionsSummary"
Public Const Const_DOCTESTDESC_START As String = "DocTestDescriptionsStart"
Public Const Const_DOCTESTDESC_END As String = "DocTestDescriptionsEnd"

' Makefile macro names for test locations
Public Const Const_TEST_SCRIPT_ROOT As String = "ATE_GBP_CSHARP_TEST_SCRIPT_ROOT_PATH"
Public Const Const_TEST_SCRIPT_TEMPLATE_PATH As String = "ATE_GBP_CSHARP_TEST_SCRIPT_TEMPLATE_PATH"
Public Const Const_TEST_SCRIPT_GEN_STD_ROOT As String = "ATE_GBP_CSHARP_TEST_SCRIPT_GENERATE_IN_STD_ROOT"

' Table column indexes
Private Const Const_TABLE_PURPOSE_SPECIAL_TEXT_INDEX As Integer = 3
Private Const Const_TABLE_CONDITIONS_TEXT_INDEX As Integer = 3
Private Const Const_TABLE_STEPS_TEXT_INDEX As Integer = 3
Private Const Const_TABLE_RESULTS_TEXT_INDEX As Integer = 4

Public TestAbstractions As Scripting.Dictionary
Public TestSets As Scripting.Dictionary

Sub BuildTestAbstractionList()
    ' Builds the test abstraction list for the current document.
    Dim bkmark As Bookmark, rng As Range, tgrp As cHeadingGroup, tgrpcur As cHeadingGroup, tabstr As cHeading
    Dim rnggrp As Range
    
    ' Reinitisialise the list of test abstractions
    Set TestAbstractions = Nothing
    Set TestAbstractions = New Scripting.Dictionary
    
    ' initialise a range object that includes only the test description area
    Set rng = ActiveDocument.Range
    rng.SetRange ActiveDocument.Bookmarks(Const_DOCTESTDESC_START).Start, _
                 ActiveDocument.Bookmarks(Const_DOCTESTDESC_END).Start
    
    ' loop through all the bookmarks in the range
    For Each bkmark In rng.Bookmarks
        ' first build temporary list of all abstractions
        If InStr(1, bkmark.Name, Const_TESTABSTR_PREFIX & "_") = 1 Then ' append underscore here so we only find test abstractions
            ' point to the parent heading range
            Set rnggrp = GetParentHeadingAsRange(bkmark.Range)
            If tgrp Is Nothing Then
                ' no groups yet, so add one
                Set tgrp = New cHeadingGroup
                tgrp.Group.ProcessRange rnggrp
                TestAbstractions.Add tgrp.Group.Number, tgrp
            Else
                ' check if current group differs from last one
                Set tgrpcur = New cHeadingGroup
                tgrpcur.Group.ProcessRange rnggrp
                If tgrpcur.Group.Text <> tgrp.Group.Text Or _
                   tgrpcur.Group.Number <> tgrp.Group.Number Then
                    ' lower-level sub-item exists without preceeding group header, group will already exist, so don't add it again
                    If Not TestAbstractions.Exists(tgrpcur.Group.Number) Then
                        TestAbstractions.Add tgrpcur.Group.Number, tgrpcur
                    End If
                End If
            End If
            
            ' point to latest group in dictionary and add abstraction
            Set tgrp = TestAbstractions.Items(TestAbstractions.Count - 1)
            Set tabstr = New cHeading
            tabstr.ProcessRange bkmark.Range
            tgrp.SubItems.Add tabstr.Bookmark, tabstr
        End If
    Next bkmark
        
End Sub

Sub BuildTestSpecificationList()
    ' Builds the test set and case specification list for the current document. Also checks that correct bookmarks have been applied
    Dim bkmark As Bookmark, rngtests As Range, tset As cHeadingGroup, tcase As cHeading

    ' Reinitisialise the list of test sets
    Set TestSets = Nothing
    Set TestSets = New Scripting.Dictionary
        
    ' initialise a range object that includes only the test description area
    Set rngtests = ActiveDocument.Range
    rngtests.SetRange ActiveDocument.Bookmarks(Const_DOCTESTDESC_START).Start, _
                      ActiveDocument.Bookmarks(Const_DOCTESTDESC_END).Start
    
    ' loop through all the bookmarks in the range
    For Each bkmark In rngtests.Bookmarks
        ' for each test/case found, populate the heading information in the dictionary
        If InStr(1, bkmark.Name, Const_TESTSET_HL_PREFIX & "_") = 1 Or _
           InStr(1, bkmark.Name, Const_TESTCASE_HLN_PREFIX & "_") = 1 Or _
           InStr(1, bkmark.Name, Const_TESTCASE_HLR_PREFIX & "_") = 1 Then ' append underscore here so we only find test specifications
            
            ' if this is a test set
            If InStr(1, bkmark.Name, Const_TESTSET_HL_PREFIX) = 1 Then
                ' add new test set to dictionary
                Set tset = New cHeadingGroup
                If tset.Group.ProcessRange(bkmark.Range) Then
                    TestSets.Add tset.Group.Bookmark, tset
                End If
            Else
                ' add new test case to test set
                If Not tset Is Nothing Then
                    Set tcase = New cHeading
                    If tcase.ProcessRange(bkmark.Range) Then
                        tset.SubItems.Add tcase.Bookmark, tcase
                    End If
                Else
                    MsgBox "No Test Set found before Test Case '" & bkmark.Name & "'.", vbCritical, "Orphaned Test Case"
                End If
            End If
        End If
    Next bkmark

End Sub

Function GetTestType(ByVal strtestname As String) As String
    Dim strbooktype As String
    
    strbooktype = Dst.BookmarkConfig.PrefixFromName(strtestname)
    Select Case strbooktype
        Case "tabstr"
            GetTestType = Const_TESTABSTRACTION
            
        Case "tshl", "tchln", "tchlr"
            GetTestType = Const_TESTSPECIFICATION
        
        Case "tshlia", "tshlim", "tchlnia", "tchlnim", "tchlria", "tchlrim"
            GetTestType = Const_TESTIMPLEMENTATION
        
        Case Else
            ' assume test name is valid
    End Select
    
End Function

Function GetTestSetCase(ByVal strtestname As String) As String
    Dim strbooktype As String
    
    strbooktype = Dst.BookmarkConfig.PrefixFromName(strtestname)
    Select Case strbooktype
        Case "tshl", "tshlia", "tshlim", "tsatp"
            GetTestSetCase = "Set"
            
        Case "tchln", "tchlr", "tchlnia", "tchlnim", "tchlria", "tchlrim", "tcatp"
            GetTestSetCase = "Case"
        
        Case Else
            ' do nothing, does not apply
    End Select
    
End Function

Function IsTestTable(ByRef rng As Range, Optional ByRef strtestname As String) As Boolean
    ' Returns the corresponding test set (group heading) above the insertion point
    Dim hdgrng As Range, strbookmarktype As String, strdoctype As String
    
    strdoctype = Dst.Document(rng.Document.Fullname).Properties.TypeAbbr
    If strdoctype = "STD" Then
        If CheckTestDescriptionBookmarks(rng.Document) = vbNullString Then
            ' check that range is within the test description area
            If rng.Start <= rng.Document.Bookmarks(Const_DOCTESTDESC_START).Start Or _
               rng.Start >= rng.Document.Bookmarks(Const_DOCTESTDESC_END).Start Then
                Exit Function
            End If
        Else
            Exit Function
        End If
    Else
        Exit Function
    End If
    
    ' check that range is in a table
    If Not IsRangeInTable(rng) Then
        Exit Function
    End If
    
    ' check if the paragraph above the table is a valid test heading
    Set hdgrng = GetHeadingAsRange(rng)
    If Not hdgrng Is Nothing Then
        If hdgrng.Bookmarks.Count = 1 Then
            strtestname = hdgrng.Bookmarks(1).Name
            strbookmarktype = Dst.BookmarkConfig.PrefixFromName(strtestname)
            Select Case strbookmarktype
                Case "tabstr", "tshl", "tchln", "tchlr", "tshlia", "tshlim", "tchlnia", "tchlnim", "tchlria", "tchlrim", "tsatp", "tcatp"
                    IsTestTable = True
            End Select
        End If
    End If
    
End Function

Function GetTestSpecificationName(ByVal strtestimpname As String) As String
    Dim strspecname As String
    
    ' remove possible 'ia' and 'im' parts
    strspecname = Replace(strtestimpname, "tshlia_", "tshl_", 1, 1)
    strspecname = Replace(strspecname, "tshlim_", "tshl_", 1, 1)
    GetTestSpecificationName = strspecname
    
End Function

Function GetTestImplementationName(ByVal strtestname As String, ByVal blautomatedtest As Boolean) As String
    ' Builds the test implementation name for the given test specification name
    Dim strprefix As String, strsuffix As String
    
    If strtestname <> vbNullString Then
        strprefix = Dst.BookmarkConfig.PrefixFromName(strtestname)
        strsuffix = Dst.BookmarkConfig.SuffixFromName(strtestname)
        GetTestImplementationName = strprefix & "i" & IIf(blautomatedtest, "a", "m") & "_" & strsuffix
    End If
    
End Function

Function GetTestPurpose(ByRef objdoc As Document, ByVal strtestspecname As String) As String
    Dim rng As Range, rngpurp As Range
    
    ' point to the bookmark and find the table below it
    Set rng = objdoc.Bookmarks(strtestspecname).Range
    rng.Collapse wdCollapseEnd
    If IsRangeInTable(rng) Then
        ' already in table, so assume purpose is in third cell
        If rng.Rows(1).Cells.Count < Const_TABLE_PURPOSE_SPECIAL_TEXT_INDEX Then
            GetTestPurpose = "Row " & rng.Rows(1).Index & " in table for '" & strtestspecname & "' in '" & objdoc.Fullname & "' has less than " & Const_TABLE_PURPOSE_SPECIAL_TEXT_INDEX & " columns. Could not extract Test Purpose."
        Else
            GetTestPurpose = ConvertSpecialCharacters(GetCellText(rng.Rows(1).Cells(Const_TABLE_PURPOSE_SPECIAL_TEXT_INDEX)))
        End If
    Else
        GetTestPurpose = "No Test Purpose defined for '" & strtestspecname & "' in '" & objdoc.Fullname & "'."
        ' move into table (hopefully)
        rng.Move wdParagraph
        If Not IsRangeInTable(rng) Then
            GetTestPurpose = "Bookmark '" & strtestspecname & "' in '" & objdoc.Fullname & "' is not above a table. Could not extract Test Purpose."
        Else
            Set rngpurp = GetTestTablePurposeSection(rng)
            If Not rngpurp Is Nothing Then
                GetTestPurpose = ConvertSpecialCharacters(GetCellText(rngpurp.Cells(2)))
            End If
        End If
    End If
    
End Function

Function GetTestCaseConditions(ByRef objdoc As Document, ByVal strtestspecname As String, Optional ByVal strstepprefix As String = vbNullString) As Variant
    Dim rng As Range, rngcond As Range, cel As Cell, rw As Row, varcond As Variant, idx As Integer

    ' initialise the default return
    ReDim varcond(0)
    varcond(0) = strstepprefix & "No initial conditions defined for '" & strtestspecname & "' in '" & objdoc.Fullname & "'."

    ' point to the bookmark and find the table below it
    Set rng = objdoc.Bookmarks(strtestspecname).Range
    rng.Collapse wdCollapseEnd
    ' move into table (hopefully)
    rng.Move wdParagraph
    If Not IsRangeInTable(rng) Then
        varcond(0) = strstepprefix & "Bookmark '" & strtestspecname & "' in '" & objdoc.Fullname & "' is not above a table. Could not extract Initial Conditions."
    Else
        ' find the initial conditions heading and build the text
        Set rngcond = GetTestTableConditionsSection(rng)
        If Not rngcond Is Nothing Then
            Set rw = rngcond.Rows(1)
            If rw.Cells.Count < Const_TABLE_CONDITIONS_TEXT_INDEX Then
                varcond(0) = strstepprefix & "Row " & rw.Index & " in table for '" & strtestspecname & "' in '" & objdoc.Fullname & "' has less than " & Const_TABLE_CONDITIONS_TEXT_INDEX & " columns. Could not extract Initial Conditions."
            Else
                ' retrieve the first condition
                varcond(0) = ConvertSpecialCharacters(strstepprefix & GetCellText(rw.Cells(Const_TABLE_CONDITIONS_TEXT_INDEX)))
                ' point to the row below the heading
                Set rw = rw.Next
                While GetCellText(rw.Cells(1)) = vbNullString And Not rw Is Nothing
                    ' now retrieve the other conditions
                    idx = idx + 1
                    ReDim Preserve varcond(idx)
                    If rw.Cells.Count < Const_TABLE_CONDITIONS_TEXT_INDEX Then
                        varcond(idx) = strstepprefix & "Row " & rw.Index & " in table for '" & strtestspecname & "' in '" & objdoc.Fullname & "' has less than " & Const_TABLE_CONDITIONS_TEXT_INDEX & " columns. Could not extract Initial Conditions."
                    Else
                        varcond(idx) = ConvertSpecialCharacters(strstepprefix & vbCrLf & GetCellText(rw.Cells(Const_TABLE_CONDITIONS_TEXT_INDEX)))
                    End If
                    Set rw = rw.Next
                Wend
            End If
        End If
    End If
    
    GetTestCaseConditions = varcond
    
End Function

Function GetTestCaseSteps(ByRef objdoc As Document, ByVal strtestspecname As String, ByVal bloldformat As Boolean, Optional ByVal strstepprefix As String = vbNullString) As Variant
    Dim rng As Range, rngproc As Range, cel As Cell, rw As Row, varsteps As Variant, idx As Integer, strtext As String

    ' initialise the default return
    ReDim varsteps(0)
    varsteps(0) = strstepprefix & "No steps and results defined for '" & strtestspecname & "' in '" & objdoc.Fullname & "'."
    
    ' point to the bookmark and find the table below it
    Set rng = objdoc.Bookmarks(strtestspecname).Range
    rng.Collapse wdCollapseEnd
    ' move into table (hopefully)
    rng.Move wdParagraph
    If Not IsRangeInTable(rng) Then
        varsteps(0) = strstepprefix & "Bookmark '" & strtestspecname & "' in '" & objdoc.Fullname & "' is not above a table. Could not extract Test Steps and Results."
    Else
        ' find the procedure heading and build the step and results text
        Set rngproc = GetTestTableProceduresSection(rng)
        If Not rngproc Is Nothing Then
            ' point to the row below the heading
            Set rw = rngproc.Rows(2)
            While GetCellText(rw.Cells(1)) = vbNullString And Not rw Is Nothing
                ' retrieve the step text
                ReDim Preserve varsteps(idx)
                If rw.Cells.Count < Const_TABLE_STEPS_TEXT_INDEX Then
                    varsteps(idx) = strstepprefix & "Row " & rw.Index & " in table for '" & strtestspecname & "' in '" & objdoc.Fullname & "' has less than " & Const_TABLE_STEPS_TEXT_INDEX & " columns. Could not extract Test Steps."
                Else
                    strtext = "/* " & String(132, "-") & vbCrLf & " * Test Step: */" & vbCrLf
                    varsteps(idx) = strtext & ConvertSpecialCharacters(strstepprefix & GetCellText(rw.Cells(Const_TABLE_STEPS_TEXT_INDEX))) & vbCrLf
                End If
                
                ' retrieve the result text
                idx = idx + 1
                If rw.Cells.Count < Const_TABLE_RESULTS_TEXT_INDEX Then
                    ReDim Preserve varsteps(idx)
                    varsteps(idx) = strstepprefix & "Row " & rw.Index & " in table for '" & strtestspecname & "' in '" & objdoc.Fullname & "' has less than " & Const_TABLE_RESULTS_TEXT_INDEX & " columns. Could not extract Test Results."
                    idx = idx + 1
                Else
                    strtext = GetCellText(rw.Cells(Const_TABLE_RESULTS_TEXT_INDEX))
                    If strtext <> vbNullString Then
                        ReDim Preserve varsteps(idx)
                        varsteps(idx) = "/* " & String(132, "-") & vbCrLf & " * " & IIf(Not bloldformat, Const_TABLE_STEP_RESULT_TEXT, Replace(Const_TABLE_STEP_RESULT_TEXT, "Expected", "Intermediate")) & " */" & vbCrLf & ConvertSpecialCharacters(strstepprefix & strtext) & vbCrLf
                        idx = idx + 1
                    End If
                End If
                Set rw = rw.Next
            Wend
        End If
    End If
        
    GetTestCaseSteps = varsteps
    
End Function

Function UpdateTestScriptHyperlink(ByRef objdoc As Document, ByVal strtestfullname As String, ByVal strtestspecname As String) As Boolean
    Dim rng As Range, rnghlnk As Range, hlnk As Hyperlink, cel As Cell
    Dim fso As FileSystemObject, strhyperlinkaddress As String

    Set fso = New FileSystemObject
        
    ' set the hyperlink's address
    strhyperlinkaddress = GetRelativePath(objdoc.Path, strtestfullname)
    
    ' point to the bookmark and find the table below it
    Set rng = objdoc.Bookmarks(strtestspecname).Range
    rng.Collapse wdCollapseEnd
    If IsRangeInTable(rng) Then
        ' already in table, so insert at end of cell if the hyperlink does not exist in the range yet
        If Not IsHyperlinkInRange(rng.Cells(1).Range, strhyperlinkaddress) Then
            Set rnghlnk = rng
            rnghlnk.InsertAfter vbCrLf
            rnghlnk.Collapse wdCollapseEnd
        Else
            UpdateTestScriptHyperlink = True
        End If
    Else
        ' move into table (hopefully)
        rng.Move wdParagraph
        If Not IsRangeInTable(rng) Then
            ' add link in a new line, regardless of what's around it
            Set rnghlnk = rng
            rnghlnk.InsertAfter vbCrLf
            rnghlnk.Collapse wdCollapseEnd
        Else
            ' find the purpose heading and return the cell text adjacent to it, assume hyperlink goes into this cell
            For Each cel In rng.Tables(1).Range.Cells
                If StrComp(GetCellText(cel), Const_TABLE_IMP_REF_TEXT, vbTextCompare) = 0 Then
                    ' point to next cell and check whether it already has a hyperlink
                    If Not IsHyperlinkInRange(cel.Next.Range, strhyperlinkaddress) Then
                        Set rnghlnk = cel.Next.Range
                    Else
                        UpdateTestScriptHyperlink = True
                    End If
                    Exit For
                End If
            Next cel
        End If
    End If
    
    ' insert hyperlink if required
    If Not rnghlnk Is Nothing Then
        Set hlnk = rnghlnk.Hyperlinks.Add(rnghlnk, strhyperlinkaddress, , , fso.GetFileName(strtestfullname))
        hlnk.Range.Font.Size = rng.Font.Size  ' make sure
        UpdateTestScriptHyperlink = True
    End If
    
End Function

Function AddMissingTestScriptHyperlinks(ByRef objdoc As Document, ByRef frmtext As Object) As Boolean
    Dim fso As FileSystemObject, idx As Integer, idx2 As Integer
    Dim strdocname As String, strbasename As String, strscriptroot As String, strtestimpname As String
    Dim strparentfolder As String, strsubfolder As String
    Dim bldefaultlocation As Boolean, tset As cHeadingGroup, tcase As cHeading
    
    Set fso = New FileSystemObject
    
    ' set some local data
    strdocname = ActiveDocument.Fullname
    strbasename = fso.GetBaseName(strdocname)
    strscriptroot = vbNullString ' ACZ TestScriptRoot still TBD
    If strscriptroot = vbNullString Then
        frmtext.UpdateProgressText "No test script root specified - ensure that the '" & Const_TEST_SCRIPT_ROOT & "' macro is " & _
                                   "defined in the relevant makefile associated with the current document."
    Else
        strparentfolder = fso.GetAbsolutePathName(fso.BuildPath(strscriptroot, strbasename))
        bldefaultlocation = True ' 'ACZ Not GenerateTestScriptInSTDRoot is still TBD
        AddMissingTestScriptHyperlinks = True
        
        For idx = 0 To TestSets.Count - 1
            ' indicate some progress
            frmtext.UpdateProgressMeter idx + 1, TestSets.Count
            
            Set tset = TestSets.Items(idx)
            
            ' determine destination folder
            If bldefaultlocation Then
                strsubfolder = fso.GetAbsolutePathName(fso.BuildPath(strparentfolder, tset.Group.Bookmark))
            Else
                strsubfolder = strparentfolder
            End If
            
            ' insert the test set hyperlink
            strtestimpname = fso.GetAbsolutePathName(fso.BuildPath(strsubfolder, GetTestImplementationName(tset.Group.Bookmark, True)) & ".cs") ' automated test
            If Not fso.FileExists(strtestimpname) Then
                strtestimpname = fso.GetAbsolutePathName(fso.BuildPath(strsubfolder, GetTestImplementationName(tset.Group.Bookmark, False)) & ".cs") ' try manual test
                If Not fso.FileExists(strtestimpname) Then
                    strtestimpname = vbNullString
                    frmtext.UpdateProgressText "No test script found for '" & tset.Group.Bookmark & "'"
                    AddMissingTestScriptHyperlinks = False
                End If
            End If
            If strtestimpname <> vbNullString Then
                If UpdateTestScriptHyperlink(ActiveDocument, strtestimpname, tset.Group.Bookmark) = False Then
                    frmtext.UpdateProgressText "Error inserting hyperlink to script for '" & tset.Group.Bookmark & "'"
                    AddMissingTestScriptHyperlinks = False
                End If
            End If
            
            ' insert the test case hyperlinks
            For idx2 = 0 To tset.SubItems.Count - 1
                Set tcase = tset.SubItems.Items(idx2)
                strtestimpname = fso.GetAbsolutePathName(fso.BuildPath(strsubfolder, GetTestImplementationName(tcase.Bookmark, True)) & ".cs") ' automated test
                If Not fso.FileExists(strtestimpname) Then
                    strtestimpname = fso.GetAbsolutePathName(fso.BuildPath(strsubfolder, GetTestImplementationName(tcase.Bookmark, False)) & ".cs") ' try manual test
                    If Not fso.FileExists(strtestimpname) Then
                        strtestimpname = vbNullString
                        frmtext.UpdateProgressText "No test script found for '" & tcase.Bookmark & "'"
                        AddMissingTestScriptHyperlinks = False
                    End If
                End If
                If strtestimpname <> vbNullString Then
                    If UpdateTestScriptHyperlink(ActiveDocument, strtestimpname, tcase.Bookmark) = False Then
                        frmtext.UpdateProgressText "Error inserting hyperlink to script for '" & tcase.Bookmark & "'"
                        AddMissingTestScriptHyperlinks = False
                    End If
                End If
            Next idx2
        Next idx
    End If
    
    frmtext.UpdateProgressText "Done."
    
End Function
Attribute VB_Name = "basTimer"
Option Explicit

Public Const Constbl_TIMING_ENABLED As Boolean = False

Public Enum TimersEnum
    Enum_BOOKMARKSCAN1 = 0
    Enum_BOOKMARKSCAN2
    Enum_NUM_TIMERS
End Enum

Private Timer_Array(Enum_NUM_TIMERS, 1) As Single

Sub TimeProcessStart(ByVal processID As TimersEnum)

    If Constbl_TIMING_ENABLED = True Then
        Timer_Array(processID, 0) = Timer
    End If
    
End Sub

Sub TimeProcessEnd(ByVal processID As TimersEnum)

    If Constbl_TIMING_ENABLED = True Then
        Timer_Array(processID, 1) = Timer
    End If

End Sub

Sub TimeProcessShowReport()
    Dim cnt As Integer, strprocess As String, strmessage As String
On Error GoTo Err_TimeProcessShowReport
    
    For cnt = 0 To Enum_NUM_TIMERS - 1
        Select Case cnt
            Case Enum_BOOKMARKSCAN1
                strprocess = "BOOKMARKSCAN1"
            
            Case Enum_BOOKMARKSCAN2
                strprocess = "BOOKMARKSCAN2"
            
            Case Else
                strprocess = "Unknown process ID (" & cnt & ")"
    
        End Select
        
        strmessage = strmessage & strprocess & Space(45 - Len(strprocess)) & ": " & Timer_Array(cnt, 1) - Timer_Array(cnt, 0) & vbCrLf
        
        ' reset timers
        Timer_Array(cnt, 0) = 0
        Timer_Array(cnt, 1) = 0
        
    Next cnt
    
    MsgBox strmessage
    
Exit_TimeProcessShowReport:
    Exit Sub
    
Err_TimeProcessShowReport:
    MsgBox Err.Description & " in TimeProcessShowReport()"
    Resume Exit_TimeProcessShowReport

End Sub
Attribute VB_Name = "basUserForms"
Option Explicit

Function OpenUserForm(ByVal strformname As String, ByRef objdoc As Document, _
                      Optional ByVal enmfunction As EnumExecuteFunction = enumExecuteFunctionNone, _
                      Optional ByVal blshow As Boolean = True, _
                      Optional ByVal stropenargs As String = vbNullString, Optional ByVal showmode As FormShowConstants = vbModeless) As Object
    Dim frm As Object, strdocname As String
    
    strdocname = objdoc.Fullname
    
    ' if requested form for given document not yet loaded, load a new instance of it
    Set frm = GetUserFormObject(strformname, strdocname)
    If frm Is Nothing Then
        Set frm = UserForms.Add(strformname)
        frm.Tag = strdocname
    End If
    
    ' the TextBox form has some additional features, so set the function that should execute
    If strformname = "frmTextBox" Then
        frm.FunctionToExecute = enmfunction
        Set frm.TargetDocument = objdoc
    End If
    If strformname = "frmTextBox" Or strformname = "frmDocNew" Then
        frm.OpenArgs = stropenargs
    End If
    
    Set OpenUserForm = frm

    ' show the form
    If blshow Then frm.Show showmode
    ' NOTE: if opening form modal, remember to place code in Form's activiate event, processing will wait till
    '       form is hidden or unloaded in activate event or by user action
                
End Function

Function GetUserFormObject(ByVal strformname As String, ByVal strdocname As String) As Object
    Dim frm As Object
    
    ' cycle through all userforms and find requested form
    For Each frm In UserForms
        If frm.Name = strformname And frm.Tag = strdocname Then
            Set GetUserFormObject = frm
            Exit For
        End If
    Next frm

End Function

Sub UnloadUserForm(Optional ByRef objfrm As Object, Optional ByVal strformname As String = vbNullString, Optional ByVal strdocname As String = vbNullString)
    Dim frm As Object
    
    If objfrm Is Nothing Then
        For Each frm In UserForms
            If (frm.Name = strformname Or strformname = vbNullString) And _
               (frm.Tag = strdocname Or strdocname = vbNullString) Then
                Unload frm
            End If
        Next frm
    Else
        Unload objfrm
    End If
End Sub
Attribute VB_Name = "basUtilities"
Option Explicit

Public Const Const_LANDSCAPE_PAGE_WIDTH As Single = 25.75

Public Const Const_FORMAT_DATETIME As String = "dd MMMM yyyy HH:nn:ss"

Private Const Const_MAX_NUM_TRUSTED_LOCATIONS As Integer = 999

Public Const Const_TRACE_FILENAME As String = "trace"

' Declare an object of the cThisApplication class so we can use it to trigger events
Public oAppClass As New cThisApplication

Private BlGrammarAsYouType As Boolean
Private BlGrammarWithSpelling As Boolean
Private BlScreenUpdating As Boolean

Function AddStatusText(ByVal strstatus As String, ByVal strtext As String) As String
    If strtext <> vbNullString And strstatus <> vbNullString Then
        strtext = vbCrLf & strtext
    End If
    AddStatusText = strstatus & strtext
End Function

Sub SaveAndTurnOffGrammarSettings()
    ' NOTE: When looping on document fields, the grammar checker starts winding its disk access at about 10Mbit/s continuously. This slows downs the
    '       document checks significantly. Hence we need to disable the grammar checks before we start and restore the state afterwards.
    BlGrammarAsYouType = Application.Options.CheckGrammarAsYouType
    Application.Options.CheckGrammarAsYouType = False
    BlGrammarWithSpelling = Application.Options.CheckGrammarWithSpelling
    Application.Options.CheckGrammarWithSpelling = False
End Sub

Sub RestoreGrammarSettings()
    'ACZ - the Word 2016 grammar lexer is problematic, so don't restore the "check grammar as you type option" below
    'Application.Options.CheckGrammarAsYouType = BlGrammarAsYouType
    Application.Options.CheckGrammarWithSpelling = BlGrammarWithSpelling
End Sub

Sub SelectTextBox(ByRef txtbox As TextBox)
    txtbox.SetFocus
    txtbox.SelStart = 0
    txtbox.SelLength = Len(txtbox.Text)
End Sub

Sub ScreenUpdateOff()
    Application.ScreenUpdating = False ' turning screen updates off when not required improves efficiency
    BlScreenUpdating = False
End Sub

Sub ScreenUpdatePause()
    BlScreenUpdating = Application.ScreenUpdating
    Application.ScreenUpdating = False
End Sub

Sub ScreenUpdateRestore()
    Application.ScreenUpdating = BlScreenUpdating ' restore value saved when paused
End Sub

Sub ScreenUpdateOn()
    Application.ScreenUpdating = True ' turn back on regardless
    BlScreenUpdating = True
End Sub

Function GetRelativePath(ByVal strfromfolder As String, ByVal strtofile As String) As String
    Dim strsearch As String, strtofolder As String, strto As String, strremainfrom As String, strremainto As String
    Dim intpos As Integer, intposfound As Integer
    Dim fso As FileSystemObject, strsource As String
                
    Set fso = New FileSystemObject
    
    strfromfolder = fso.GetAbsolutePathName(strfromfolder)
    strsource = fso.GetFileName(strtofile)
    strtofolder = fso.GetAbsolutePathName(fso.GetParentFolderName(strtofile))
    
    ' make sure paths all look the same and set working copies
    strfromfolder = Replace(strfromfolder, "\", "/")
    strfromfolder = Replace(strfromfolder, "//", "/")
    strtofolder = Replace(strtofolder, "\", "/")
    strtofolder = Replace(strtofolder, "//", "/")
    strto = strtofolder
    
    ' Find position of strto in strfrom and determine remainder of to
    intposfound = InStr(1, strfromfolder & "/", strto & "/", vbTextCompare)
    While (intposfound = 0)
        strto = fso.GetParentFolderName(strto)
        If Right(strto, 1) = "/" Then strto = Left(strto, Len(strto) - 1) ' drop traling slash (when we're down to the drive letter)
        intposfound = InStr(1, strfromfolder & "/", strto & "/", vbTextCompare)
    Wend
    If strto <> strtofolder Then
        strremainto = Right(strtofolder, Len(strtofolder) - (Len(strto) + 1)) ' + 1 is so we exclude the slash
    End If
    
    ' Now determine the remainder of from
    strremainfrom = Right(strfromfolder, Len(strfromfolder) - Len(strto))
    
    ' For each "/" in strremainfrom, add a "../" string to the relative path
    intpos = InStr(1, strremainfrom, "/", vbTextCompare)
    While (intpos > 0)
        GetRelativePath = GetRelativePath & "../"
        intpos = InStr(intpos + 1, strremainfrom, "/", vbTextCompare)
    Wend
    
    ' Append a last "../" and also append the remainder of strto
    If strremainto <> vbNullString Then
        If strremainfrom = vbNullString Then
            GetRelativePath = strremainto
        Else
            GetRelativePath = GetRelativePath & strremainto
        End If
        GetRelativePath = GetRelativePath & "/"
    End If
    GetRelativePath = GetRelativePath & strsource
        
End Function

Function GetApplicationObject(ByVal strappstring As String, Optional ByRef blappalreadyopen As Boolean, Optional ByVal blnewinstance As Boolean = False) As Object
On Error GoTo Err_GetApplicationObject
    
    ' attempt getting a reference to an existing application instance
    If blnewinstance = True Then
        Set GetApplicationObject = GetObject(vbNullString, strappstring)
    Else
        Set GetApplicationObject = GetObject(, strappstring)
    End If
    
    ' if we got here, it means an instance of the application was already running, so we wouldn't have gone through the error processing
    blappalreadyopen = True
        
Exit_GetApplicationObject:
    Exit Function

Err_GetApplicationObject:
    If Err.Number = 429 Then
        ' Clear Err object in case this error occurred as application was not running
        Err.Clear
        Set GetApplicationObject = GetObject(vbNullString, strappstring)
    Else
        MsgBox Err.Description & " in GetApplicationObject()"
    End If
    
    ' indicate that a new instance of the application was created
    blappalreadyopen = False
    Resume Exit_GetApplicationObject
    
End Function

Function GetDocTypeFromFilename(ByVal strdocname As String) As String
    Dim strbasename As String
    If IsValidDocumentFilename(strdocname, strbasename) Then
        GetDocTypeFromFilename = UCase(Split(strbasename, "_", 2)(0))
    End If
End Function

Function IsValidDocumentFilename(ByVal strdocname As String, Optional ByRef strbasename As String) As Boolean
    '==================================================================================================================================
    ' Description: Validates document filenames as follows:
    '              [-] Only a single dot is allowed to indicate the extension
    '              [-] Must have at least one underscore in the basename so the type can be derived
    '              [-] Extension must be .doc or .docx
    '              The basename portion is returned through an optional parameter
    '==================================================================================================================================
    Dim fso As FileSystemObject, strext As String
    Set fso = New FileSystemObject
    If strdocname <> vbNullString Then
        strbasename = fso.GetBaseName(strdocname)
        strext = fso.GetExtensionName(strdocname)
        If UBound(Split(strbasename, ".")) = 0 And UBound(Split(strbasename, "_")) > 0 And _
           (strext = "docx" Or strext = "doc") Then  '
            IsValidDocumentFilename = True
        End If
    End If
End Function

Function ConvertSpecialCharacters(ByVal strtext As String) As String
    
    ' replace some characters with equivalents
    strtext = Replace(strtext, Chr(&HA), " ")    ' replace LF
    strtext = Replace(strtext, Chr(&HD), " ")    ' replace CR
    strtext = Replace(strtext, Chr(&H80), "EUR") ' replace euro sign
    strtext = Replace(strtext, Chr(&H84), """")  ' replace low "
    strtext = Replace(strtext, Chr(&H88), "^")   ' replace modifier ^
    strtext = Replace(strtext, Chr(&H8B), "<")   ' replace < quotation
    strtext = Replace(strtext, Chr(&H91), "'")   ' replace left '
    strtext = Replace(strtext, Chr(&H92), "'")   ' replace right '
    strtext = Replace(strtext, Chr(&H93), """")  ' replace left "
    strtext = Replace(strtext, Chr(&H94), """")  ' replace right "
    strtext = Replace(strtext, Chr(&H95), ".")   ' replace bullet
    strtext = Replace(strtext, Chr(&H96), "-")   ' replace en dash
    strtext = Replace(strtext, Chr(&H97), "-")   ' replace em dash
    strtext = Replace(strtext, Chr(&H98), "~")   ' replace small ~
    strtext = Replace(strtext, Chr(&H9B), ">")   ' replace > quotation
    strtext = Replace(strtext, Chr(&HA3), "GBP") ' replace pound sign
    strtext = Replace(strtext, Chr(&HA5), "YEN") ' replace yen sign
    strtext = Replace(strtext, Chr(&HA6), "|")   ' replace broken pipe
    strtext = Replace(strtext, Chr(&HA7), "section ") ' replace section mark
    strtext = Replace(strtext, Chr(&HAB), "<<")  ' replace <<
    strtext = Replace(strtext, Chr(&HBB), ">>")  ' replace >>
    strtext = Replace(strtext, Chr(&HB0), "degrees ") ' replace degree symbol
    strtext = Replace(strtext, Chr(&HB1), "+/-") ' replace plus-minus symbol
    strtext = Replace(strtext, Chr(&HB2), "**2") ' replace squared symbol
    strtext = Replace(strtext, Chr(&HB3), "**3") ' replace cubed symbol
    strtext = Replace(strtext, Chr(&HB4), "'")   ' replace accute accent
    strtext = Replace(strtext, Chr(&HB5), "micro") ' replace micro symbol
    strtext = Replace(strtext, Chr(&HB6), "paragraph ") ' replace paragraph symbol
    strtext = Replace(strtext, Chr(&HB7), ".")   ' replace middle dot
    strtext = Replace(strtext, Chr(&HBC), "1/4") ' replace quarter symbol
    strtext = Replace(strtext, Chr(&HBD), "1/2") ' replace half symbol
    strtext = Replace(strtext, Chr(&HBE), "3/4") ' replace three-quarter symbol
    strtext = Replace(strtext, Chr(&HF7), "/")   ' replace divide symbol
    
    ' remove the rest of the non-printable characters with
    strtext = RegularExpressionReplace(strtext, "[^\x20-\x7E]", vbNullString)
    
    ConvertSpecialCharacters = strtext
    
End Function

' Checks that each word found in the input string matches an entry in the given input array
Function CheckEntriesInList(ByVal strentries As String, strlist As String, ByVal varlist As Variant) As String
    Dim mtch As Match, colmatches As MatchCollection, idx As Integer
    Dim blfound As Boolean
    
    If SplitIntoWords(strentries, colmatches) Then
        ' check that a list has been supplied
        If IsArrayAllocated(varlist) Then
            For Each mtch In colmatches
                blfound = False
                For idx = 0 To UBound(varlist, 2)
                    If mtch.Value = varlist(0, idx) Then
                        blfound = True
                        Exit For
                    End If
                Next idx
                If Not blfound Then
                    CheckEntriesInList = CheckEntriesInList & mtch.Value & " "
                End If
            Next mtch
            If CheckEntriesInList <> vbNullString Then
                CheckEntriesInList = "The following entries do not match the " & strlist & ": " & Replace(CheckEntriesInList, " ", ", ")
            End If
        Else
            If colmatches.Count > 0 Then
                CheckEntriesInList = "Entries found but the " & strlist & " is empty." & vbCrLf
            End If
        End If
    End If
    
End Function

Function Delay(ByVal seconds As Single) As Single
    Dim snglstart As Single, snglend As Single
    
    snglstart = Timer()
    snglend = snglstart + seconds
    
    While Timer() < snglend
        DoEvents
        ' do nothing
    Wend
    Delay = Timer() - snglstart
    
End Function

Function ProtectedViewActive() As Boolean
    Dim pwindow As ProtectedViewWindow

    For Each pwindow In ProtectedViewWindows
        If pwindow.Active Then
            ProtectedViewActive = True
            Exit For
        End If
    Next pwindow

End Function

Function WriteDebugFile(ByRef strdebugtext As String, ByVal strfilebasename As String, Optional ByVal blappend As Boolean = False) As String
    Dim fso As FileSystemObject, ts As TextStream, strfilepath As String
    
    Set fso = New FileSystemObject
    
    ' write the debug data to a file
    strfilepath = GetDebugFileName(strfilebasename)
    If blappend Then
        Set ts = fso.OpenTextFile(strfilepath, ForAppending, True, TristateTrue)
    Else
        Set ts = fso.CreateTextFile(strfilepath, True, True)
    End If
    ts.WriteLine vbCrLf & String(180, ">")
    ts.WriteLine "Trace time: " & Format(Now(), Const_FORMAT_DATETIME)
    ts.WriteLine String(180, ">")
    ts.Write strdebugtext
    ts.Close
    
    WriteDebugFile = strfilepath
    
End Function

Function OpenDebugFile(ByVal strfilebasename As String) As Boolean
    Dim strfilepath As String, fso As FileSystemObject, cmd As cConsoleCommand
    
    Set fso = New FileSystemObject
    strfilepath = GetDebugFileName(strfilebasename)
    If fso.FileExists(strfilepath) Then
        Set cmd = New cConsoleCommand
        cmd.AddCommand "start " & strfilepath
        If Not cmd.Execute(CommandTypeRunComSpec) Then
            MsgBox "Could not open '" & strfilepath & "'.", vbExclamation
        End If
    Else
        MsgBox "File '" & strfilepath & "' does not exist.", vbExclamation
        OpenDebugFile = False
    End If
    
End Function

Private Function GetDebugFileName(ByVal strfilebasename As String) As String
    Dim fso As FileSystemObject
    Set fso = New FileSystemObject
    GetDebugFileName = fso.BuildPath(GetTempFolderName(), strfilebasename & ".txt")
End Function

Function GetTempFolderName() As String
    Dim fso As FileSystemObject
    
    ' create temp folder if it does not exist yet
    Set fso = New FileSystemObject
    GetTempFolderName = Application.MacroContainer.Path & "\temp"
    If Not fso.FolderExists(GetTempFolderName) Then fso.CreateFolder GetTempFolderName

End Function

Function AddTrustedLocation(ByVal strlocation As String, Optional ByVal blallownetworklocations As Boolean = False) As Boolean
'WARNING:  THIS CODE MODIFIES THE REGISTRY for MS Access Trusted Locations, return True if the registry was modified
    Dim idx As Integer, wsh As WshShell, strregkey As String, strregpath As String, idxuse As Integer
    Dim strerrprocess As String
On Error GoTo Err_AddTrustedLocation

    Set wsh = CreateObject("wscript.shell")

    ' make sure given location has a trailing '\'
    strlocation = Replace(strlocation, "/", "\")
    If Right(strlocation, 1) <> "\" Then strlocation = strlocation & "\"
    
    ' Specify the registry trusted locations path for the version of Access used
    strregkey = "HKEY_CURRENT_USER\Software\Microsoft\Office\" & Format(Application.Version, "##,##0.0") & "\Word\Security\Trusted Locations"

    ' first make sure network locations are trusted if requested
    strerrprocess = "WriteAllowNetworkLocations"
    If blallownetworklocations Then
        wsh.RegWrite strregkey & "\AllowNetworkLocations", 1, "REG_DWORD"
        AddTrustedLocation = True
    End If
    
    ' now find the trusted locations references
    strerrprocess = "ReadPath"
    idxuse = -1
    strregkey = strregkey & "\Location"
    For idx = 0 To Const_MAX_NUM_TRUSTED_LOCATIONS
        strregpath = vbNullString ' NOTE: read below will fail on index that does not exist - the error is handler will be used to ensure this available location/index is then used
        strregpath = wsh.RegRead(strregkey & idx & "\Path")
        
        ' if path already exists, make sure sub-folders are allowed
        If StrComp(strregpath, strlocation, vbTextCompare) = 0 Then
            If wsh.RegRead(strregkey & idx & "\AllowSubFolders") <> 1 Then idxuse = idx
            Exit For
        End If
    Next idx

    If idxuse >= 0 Then
        strerrprocess = "WritePath"
        ' Write Trusted Location regstry key to unused location in registry
        strregkey = strregkey & idxuse & "\"
        wsh.RegWrite strregkey & "AllowSubfolders", 1, "REG_DWORD"
        wsh.RegWrite strregkey & "Date", Now(), "REG_SZ"
        wsh.RegWrite strregkey & "Description", "Added by DST", "REG_SZ"
        wsh.RegWrite strregkey & "Path", strlocation, "REG_SZ"
        AddTrustedLocation = True
    Else
        If idx = Const_MAX_NUM_TRUSTED_LOCATIONS + 1 Then
            MsgBox "Could not find a spare Trusted Location key - tried " & Const_MAX_NUM_TRUSTED_LOCATIONS + 1 & " different locations.", vbCritical
        End If
    End If

Exit_AddTrustedLocation:
    Set wsh = Nothing
    Exit Function

Err_AddTrustedLocation:
    If Err.Number = &H80070002 And strerrprocess = "ReadPath" Then ' automation error
        If idxuse = -1 Then idxuse = idx
        Resume Next
    Else
        MsgBox Err.Description & " in function AddTrustedLocation()"
    End If
    
End Function

Function Shift(ByVal lngvalue As Long, ByVal numbits As Long) As Long
    Shift = lngvalue * (2 ^ numbits)
End Function

Sub ForceDocumentVisible(ByRef objdoc As Document)
    objdoc.ActiveWindow.Visible = False
    objdoc.ActiveWindow.Visible = True
    Dst.Document(objdoc.Fullname).DocVisible = True
End Sub

Function GetExtendedFileProperties(ByVal strpath As String) As Scripting.Dictionary
    '==================================================================================================================================
    ' Description: Gets the extended properties of the file system objects in the given path. The given path can be a file or a folder
    '              path. The function returns a dictionary of dictionaries, indexed first by the object (file or folder) name then by
    '              the property name.
    '==================================================================================================================================
    Dim arrpropnames(35) As String ' only interested in the first few extended properties available
    Dim varpath As Variant, blfileonly As Boolean
    Dim objShell As Object, objFolder As Shell32.Folder, fso As FileSystemObject
    Dim idx As Integer, varitem As Variant, dicfiles As Scripting.Dictionary, dicprops As Scripting.Dictionary
    
    Set objShell = CreateObject("Shell.Application")
    Set fso = New FileSystemObject
    Set dicfiles = New Scripting.Dictionary
        
    ' determine if given path is a file or folder
    If fso.FolderExists(strpath) Then
        varpath = strpath
    ElseIf fso.FileExists(strpath) Then
        blfileonly = True
        varpath = fso.GetParentFolderName(strpath)
    Else
        MsgBox "'" & strpath & "' does not exist", vbExclamation
        Exit Function
    End If
    
    ' get property names
    Set objFolder = objShell.NameSpace(varpath)
    For idx = 0 To UBound(arrpropnames)
        arrpropnames(idx) = objFolder.GetDetailsOf(objFolder.Items, idx)
    Next
    ' NOTE: use varitem.Path below - this includes the filename extension regardless the setting in Windows Explorer's folder options
    For Each varitem In objFolder.Items
        If Not blfileonly Or fso.GetFileName(varitem.Path) = fso.GetFileName(strpath) Then ' if file was requested, only return this file's properties
            Set dicprops = New Scripting.Dictionary
            For idx = 0 To UBound(arrpropnames)
                dicprops.Add arrpropnames(idx), objFolder.GetDetailsOf(varitem, idx)
            Next idx
            dicfiles.Add varitem.Path, dicprops
        End If
    Next varitem
    Set GetExtendedFileProperties = dicfiles
End Function
Attribute VB_Name = "basXReferences"
Option Explicit

' Bookmark name that identifies external references table
Public Const Const_DOCTBL_EXTREFERENCES As String = "DocTblExternalReferences"

Public Const Const_TEST_REF_LABEL_SUFFIX As String = " Ref.:"

Function ValidateDocExtRefsTable(ByRef objdoc As Document, Optional ByRef tbl As Table, _
                                 Optional ByRef strmessage As Variant, Optional ByVal blignorechecksum As Boolean = False) As Boolean
    Dim strstatus As String, rng As Range, tblextref As Table
    
    Set tblextref = GetTable(objdoc, Const_DOCTBL_EXTREFERENCES, strstatus)
    If strstatus = vbNullString Then
        strstatus = ProcessTableChecksum(objdoc, Const_DOCTBL_EXTREFERENCES, False)
        If Not blignorechecksum And strstatus <> vbNullString Then
            strstatus = strstatus & " Run the 'Update External References' function to fix this."
        ElseIf Not tblextref.Uniform Then
            strstatus = "The External References table in '" & objdoc.Fullname & "' is not uniform. To make the table uniform, convert the table to text and then convert the text back to a table."
        ElseIf tblextref.Columns.Count <> 2 Then
            strstatus = "The External References table in '" & objdoc.Fullname & "' does not have two columns."
        Else
            ' clear status text in case we ignored the checksum test
            strstatus = vbNullString
            ' set range to portion of document after external references table
            Set rng = objdoc.Range(tblextref.Range.End, objdoc.StoryRanges(wdMainTextStory).End)
            ' search for any text after the table
            rng.TextRetrievalMode.IncludeHiddenText = False
            If RegularExpressionSearch(rng.Text, "(\S+|\w+)") Then ' non-whitespace characters
                strstatus = "The External References table in '" & objdoc.Fullname & "' is not at the end of the document."
            End If
        End If
    End If
    
    If strstatus = vbNullString Then
        ValidateDocExtRefsTable = True
        If Not IsMissing(tbl) Then
            Set tbl = tblextref
        End If
    Else
        ValidateDocExtRefsTable = False
        If IsMissing(strmessage) Then
            MsgBox strstatus, vbExclamation, "External References Table"
        Else
            strmessage = strstatus
        End If
    End If
    
End Function

Function InsertXref(ByRef rng As Range, ByVal strbookname As String, ByVal strbooktext As String, ByVal strdocname As String, _
                    ByVal blapplystyle As Boolean, Optional ByVal blrefonly As Boolean = False, _
                    Optional ByRef strmessage As Variant) As Boolean
' Inserts a cross-reference at the given range and formats it if required
    Dim fld As Field, strstatus As String, blstatus As Boolean, blintable As Boolean
    Dim strbookmarktype As String, strstyle As String, strstyleoverride As String, strdoctype As String
On Error GoTo Err_InsertXRef
                
    ' determine the bookmark type
    strbookmarktype = Dst.BookmarkConfig.PrefixFromName(strbookname)
    strdoctype = Dst.Document(rng.Document.Fullname).Properties.TypeAbbr
    blintable = IsRangeInTable(rng)
    
    ' Add the cross-reference to the external references table if it's another document
    If strdocname = vbNullString Or strdocname = rng.Document.Fullname Then
        blstatus = True
    Else
        blstatus = AddToExternalReferences(rng.Document, strbookname, strbooktext, strdocname, strstatus)
        If blstatus Then
            If Not blrefonly Then
                ' Insert special reference format based on type if in table
                Select Case strbookmarktype
                    Case "tshl", "tchln", "tchlr", "tsm", "tcm"
                        If blintable Then
                            ' Test related references
                            blstatus = InsertTestRefRow(rng, strbookname, strbookmarktype, strstatus)
                        End If
                        
                    Case "sbc"
                        If blintable Then
                            blstatus = InsertTestRefRow(rng, strbookname, strbookmarktype, strstatus)
                        End If
                        
                    Case "reqsw", "sreqsw", "reqsdd"
                        ' Requirement reference
                        If blintable Then
                            blstatus = InsertReqRefRow(rng, strbookname, strbookmarktype, strdocname, blapplystyle, strstatus)
                            If blapplystyle Then
                                strstyleoverride = "DSTTrcRef" ' always force this style for traces to requirements
                            End If
                        Else
                            If strdoctype = "STD" Then
                                blapplystyle = False ' style only applied within requirements section of a test table
                            End If
                        End If
                        
                    Case Else
                        ' do nothing - only insert the reference
                End Select
            End If
        End If
    End If
    
    ' now insert the reference
    If blstatus = True Then
        ' insert trailing space now
        rng.Text = " "
        rng.Collapse wdCollapseStart
        
        ' add the new field, select it and point the range object at it
        Set fld = rng.Fields.Add(rng, wdFieldRef, strbookname & " \! \h \* CHARFORMAT ", True)
        Set rng = fld.Result
        
        ' format the field if required
        If strbookmarktype <> vbNullString And blapplystyle = True Then
            ' apply the relevant style after checking that it exists
            If strstyleoverride <> vbNullString Then
                strstyle = strstyleoverride
            Else
                strstyle = Dst.BookmarkConfig.Prefix(strbookmarktype).ReferenceStyle
            End If
            If StyleExists(rng.Document, strstyle, strstatus) = True Then
                rng.Style = strstyle
            End If
        End If
        
        ' move selection to trailing space
        rng.Collapse wdCollapseEnd
        rng.MoveWhile " ", wdForward
        rng.Select
    End If
                
Exit_InsertXRef:
    If strstatus = vbNullString Then
        InsertXref = True
    Else
        InsertXref = False
        If IsMissing(strmessage) Then
            MsgBox strstatus, vbExclamation, "Cross-Reference Insert Error"
        Else
            strmessage = strstatus
        End If
    End If
    Exit Function
    
Err_InsertXRef:
    strstatus = Err.Number & " " & Err.Description & " in InsertXRef()"
    Resume Exit_InsertXRef

End Function

Sub InsertXRefAsBookmark(ByRef rng As Range, ByVal strbookmarkname As String, ByVal strbookmarktext As String)
    
    ' insert reference as text and add local bookmark
    rng = strbookmarktext
    If AddBookmark(rng, strbookmarkname) = True Then
        ' unload bookmark management form if it was open to force a reload of its data
        Call UnloadUserForm(, "frmBookmarkMgmt", rng.Document.Fullname)
    End If
    
End Sub

Function AddToExternalReferences(ByRef objdoc As Document, _
                                 ByVal strbookmarkname As String, ByVal strbooktext As String, _
                                 ByVal strfulldocname As String, ByRef strstatus As String) As Boolean
' If the bookmark does not exist, add it to the external references table
    Dim rng As Range, rw As Row, tbl As Table, docinfo As cDocInfo
    Dim strreldocname As String, hlnk As Hyperlink, fso As FileSystemObject
On Error GoTo Err_AddToExternalReferences
        
    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(objdoc.Fullname)
    
    If strbooktext <> vbNullString Then
        ' check if external references table exists
        If ValidateDocExtRefsTable(objdoc, tbl, strstatus) Then
            ' if the bookmark does not exist yet, add it
            If Not docinfo.Bookmarks.All.Exists(strbookmarkname) Then
                Set rw = tbl.Rows.Add
                
                ' first add the hyperlink to the second column
                Set rng = rw.Cells(2).Range
                ' get the path to the given document relative to the active document folder
                strreldocname = GetRelativePath(objdoc.Path, strfulldocname)
                Set hlnk = rng.Hyperlinks.Add(rng, strreldocname, strbookmarkname)
                Call FormatXRefHyperlink(hlnk)
                hlnk.Range.Font.Size = 7
                hlnk.Range.NoProofing = True
                
                ' now select the first column and add the bookmark
                Set rng = rw.Cells(1).Range
                rng.Text = strbooktext
                rng.End = rng.End - 1 ' don't include end of cell marker text in bookmark
                docinfo.Bookmarks.Add strbookmarkname, rng
                
                ' update the table checksum
                Call ProcessTableChecksum(objdoc, Const_DOCTBL_EXTREFERENCES)
            ElseIf docinfo.Bookmarks.IsExternal(strbookmarkname) Then
                ' bookmark is external, so check if it's an external bookmark from a different document
                If strfulldocname <> docinfo.Properties.Fullname And _
                   strfulldocname <> fso.GetAbsolutePathName(fso.BuildPath(docinfo.Properties.Path, docinfo.Bookmarks.External(strbookmarkname).SourceDocument)) Then
                    strstatus = "Bookmark '" & strbookmarkname & "' has already been referenced from a different document (" & hlnk.Address & "). Cross-reference not added."
                End If
            Else
                ' local bookmark
                If strfulldocname <> docinfo.Properties.Fullname Then
                    strstatus = "Bookmark '" & strbookmarkname & "' already exists as a local bookmark. Cross-reference not added."
                End If
            End If
        End If
    Else
        strstatus = "Bookmark '" & strbookmarkname & "' does not enclose any text. Cross-reference not added."
    End If
    
Exit_AddToExternalReferences:
    If strstatus = vbNullString Then
        AddToExternalReferences = True
    Else
        AddToExternalReferences = False
    End If
    Exit Function

Err_AddToExternalReferences:
    strstatus = Err.Description & " in AddToExternalReferences() of basXReferences"
    Resume Exit_AddToExternalReferences
    
End Function

Private Function InsertTestRefRow(ByRef rng As Range, ByVal strbookmarkname As String, ByVal strbookmarktype As String, _
                                  ByRef strstatus As String) As Boolean
    ' Inserts a new row below the current row
    Dim rownew As Row, sgltblwidth As Single
On Error GoTo Err_InsertTestRefRow
    
    ' Insert a new table row below the current row, then set the font colour to automatic and non-bold and non-italic
    Set rownew = rng.Rows.Add
    With rownew
        .Range.Style = Const_STYLE_TABLE_TEXT_SMALL
        ' merge the row cells and get the table width
        .Cells.Merge
        sgltblwidth = .Cells.Width
        
        ' Test Configuration references have one more cell than other reference types
        If strbookmarktype = "sbc_" Then
            .Cells(1).Split 1, 5
        Else
            .Cells(1).Split 1, 4
        End If
        
        ' set the cell widths and info for fixed cells
        .Cells(1).Width = CentimetersToPoints(Const_CELL_PURPOSE_LABEL_WIDTH)
        .Cells(2).Width = CentimetersToPoints(Const_CELL_NUM_WIDTH)
        .Cells(3).Width = CentimetersToPoints(3.75)
        .Cells(3).Range.Font.Italic = True
        .Cells(3).Range.Text = GetXReferenceHeading(strbookmarktype)
        If strbookmarktype = "sbc_" Then
            ' bookmark name cell
            .Cells(4).Width = CentimetersToPoints(5.75)
            .Cells(4).Range.Text = strbookmarkname
            ' cross-reference cell
            .Cells(5).Width = sgltblwidth - (.Cells(1).Width + .Cells(2).Width + .Cells(3).Width + .Cells(4).Width)
            Set rng = .Cells(5).Range
        Else
            ' cross-reference cell
            .Cells(4).Width = sgltblwidth - (.Cells(1).Width + .Cells(2).Width + .Cells(3).Width)
            Set rng = .Cells(4).Range
        End If
    End With
    
    ' return insertion point for cross-reference
    rng.Collapse wdCollapseStart

Exit_InsertTestRefRow:
    If strstatus = vbNullString Then
        InsertTestRefRow = True
    Else
        InsertTestRefRow = False
    End If
    Exit Function

Err_InsertTestRefRow:
    strstatus = Err.Description & " in InsertTestRefRow() of basXReferences"
    Resume Exit_InsertTestRefRow
    
End Function

Private Function InsertReqRefRow(ByRef rng As Range, ByVal strbookmarkname As String, ByVal strbookmarktype As String, _
                                 ByVal strdocname As String, ByRef blreqrow As Boolean, ByRef strstatus As String) As Boolean
    ' Inserts a requirement reference row if the insertion point is in a table
    ' If the row already has a reference in it, a new row is added below the insertion point
    Dim rngtemp As Range, rngreqs As Range, rownew As Row, rowtmp As Row, strnum As String, intnum As Integer, intrefidx As Integer
    Dim blinserted As Boolean, blnewformat As Boolean, sgltablewidth As Single, fso As FileSystemObject
    Dim rowfrmt As cTblRowFormat, docinfo As cDocInfo
On Error GoTo Err_InsertReqRefRow
    
    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(rng.Document.Fullname)
    
    ' flag that says we're not in a requirements traceability row in a table
    blreqrow = False
    
    ' Set the range object
    Set rngtemp = rng.Rows(1).Range
    
    ' check if this a reqsw requirement type
    blnewformat = (strbookmarktype = "reqsw" Or strbookmarktype = "sreqsw" Or strbookmarktype = "reqsdd")
        
    ' Determine whether this is a requirements traceability row
    Set rngreqs = GetTestTableRequirementsSection(rng)
    If Not rngreqs Is Nothing Then
        If rngtemp.Cells(1).Range.InRange(rngreqs) Then
            If Not IsFieldReferenced(rngreqs, strbookmarkname, wdFieldRef) Then
                blreqrow = True
                ' if this is a template or empty row, use it, else insert a new row
                If GetCellText(rngtemp.Cells(3)) = Const_TABLE_INSTR_NONE_TEXT Or _
                   GetCellText(rngtemp.Cells(3)) = Const_TABLE_INSTR_REQS_TEXT Or _
                   (GetCellText(rngtemp.Cells(3)) = vbNullString And _
                    GetCellText(rngtemp.Cells(4)) = vbNullString) Then
                    Set rownew = rngtemp.Rows(1)
                    blinserted = False
                Else
                    Set rownew = rngtemp.Rows.Add
                    rownew.Range.Select
                    Selection.ClearFormatting
                    rownew.Range.Style = Const_STYLE_TABLE_TEXT_SMALL
                    blinserted = True
                End If
                    
                ' get the current row's requirement number
                strnum = GetCellText(rngtemp.Cells(2))
                If IsNumeric(strnum) Then
                    intnum = Val(strnum)
                    If blinserted = True Then
                        intnum = intnum + 1
                    End If
                Else
                    intnum = 1
                End If
                    
                ' reformat row
                Set rowfrmt = New cTblRowFormat
                Call SetRequirementsRowFormat(rowfrmt, IIf(intnum = 1, True, False), blnewformat)
                strstatus = rowfrmt.Format(rownew, intnum - 1, Const_TABLE_REQUIREMENTS_TEXT, True)
                If strstatus = vbNullString Then
                    ' renumber existing sequence numbers
                    Set rowtmp = rownew
                    Do While GetCellText(rowtmp.Cells(1)) = vbNullString ' for all requirement reference rows
                        strnum = GetCellText(rowtmp.Cells(2))
                        If IsNumeric(strnum) Or strnum = vbNullString Then
                            rowtmp.Cells(2).Range.Text = intnum
                            intnum = intnum + 1
                        End If
                        If rowtmp.IsLast Then Exit Do
                        Set rowtmp = rowtmp.Next
                    Loop
                    
                    ' determine the cell index where the cross-reference should go
                    If blnewformat Then
                        intrefidx = 3
                    Else
                        intrefidx = 4
                        rownew.Cells(intrefidx - 1).Range.Text = strbookmarkname
                    End If
                                        
                    ' insert the document name
                    If docinfo.Bookmarks.IsExternal(strbookmarkname) Then
                        strdocname = docinfo.Bookmarks.External(strbookmarkname).SourceDocument
                    End If
                    rownew.Cells(intrefidx + 1).Range.Text = fso.GetFileName(strdocname)
                    
                    ' Clear cell and return insertion point where the cross-reference should be inserted
                    rownew.Cells(intrefidx).Range.Text = vbNullString
                    Set rng = rownew.Cells(intrefidx).Range
                    rng.Collapse wdCollapseStart
                End If
            Else
                strstatus = "Requirement '" & strbookmarkname & "' has already been referenced in this test."
            End If
        End If
    Else
        blreqrow = True ' so style is applied in all other cases
    End If

Exit_InsertReqRefRow:
    If strstatus = vbNullString Then
        InsertReqRefRow = True
    Else
        InsertReqRefRow = False
    End If
    Exit Function

Err_InsertReqRefRow:
    strstatus = Err.Description & " in InsertReqRefRow() of basXReferences"
    Resume Exit_InsertReqRefRow
    
End Function

Private Function GetXReferenceHeading(ByVal strbooktype As String) As String

    Select Case strbooktype
        Case "tsatp", "tshl", "tsi", "tsm"
            GetXReferenceHeading = "Test Set" & Const_TEST_REF_LABEL_SUFFIX

        Case "tcatp", "tchln", "tchlr", "tchl", "tci", "tcm"
            GetXReferenceHeading = "Test Case" & Const_TEST_REF_LABEL_SUFFIX
        
        Case "sbc"
            GetXReferenceHeading = "Test Configuration" & Const_TEST_REF_LABEL_SUFFIX

        Case Else
            GetXReferenceHeading = "No heading defined for bookmark type '" & strbooktype & "'"
        
    End Select
    
End Function
    
Function UpdateExternalReferencesTable(ByRef objdoc As Document, ByRef frm As Object) As Boolean
' Updates/Inserts the hyperlinks in the External References table. The macro also updates the fields.
    Dim strstatus As String, strxrefdocname As String, strbookmarkname As String
    Dim tbl As Table, rngtbl As Range, rrow As Row, rngbkm As Range, hlnk As Hyperlink
    Dim blOK As Boolean, fso As FileSystemObject, docinfo As cDocInfo
    Dim lngnumrows As Long, blrowdeleted As Boolean, lngdeleted As Long, idx As Long
On Error GoTo Err_UpdateExternalReferencesTable
    
    Set fso = New FileSystemObject
    Set docinfo = Dst.Document(objdoc.Fullname)
    
    Call SaveAndTurnOffGrammarSettings
    
    '======================================================================================
    ' check that the document is not attached to a template
    '======================================================================================
    strstatus = CheckAttachedTemplateStatus(objdoc)
    If strstatus <> vbNullString Then
        frm.UpdateProgressText strstatus
        Exit Function
    End If
    
    '======================================================================================
    ' validate the external references table (note that we ignore the checksum in this case)
    '======================================================================================
    If Not ValidateDocExtRefsTable(objdoc, tbl, strstatus, True) Then
        frm.UpdateProgressText strstatus
        Exit Function
    End If
    
    '======================================================================================
    ' check and prompt the user if change tracking is on
    '======================================================================================
    Call ProposeTrackedChangesOff(objdoc)
    
        
    '======================================================================================
    ' loop through each row of the Xrefs table
    '======================================================================================
    System.Cursor = wdCursorWait
    UpdateExternalReferencesTable = True
    ' adjust table range so external references table identifying bookmark is excluded - start at 2nd row
    Set rngtbl = tbl.Range
    rngtbl.Start = rngtbl.Rows(2).Range.Start
    lngnumrows = rngtbl.Rows.Count
    frm.UpdateProgressText "Updating bookmarks and hyperlinks in " & lngnumrows & " rows..."
    ' NOTE: The range object below is set to the first cell in the range and once inside the loop, the Range.Next method
    ' is used for best performance (using the rrow.Cells method inside the loop is extremely inefficient)
    Set rngbkm = rngtbl.Cells(1).Range
    For Each rrow In rngtbl.Rows
        blOK = False
        blrowdeleted = False
        
        ' indicate progress
        idx = idx + 1
        frm.UpdateProgressMeter idx, lngnumrows
      
        strstatus = vbNullString
        If ValidateXRefHyperlinkRow(rrow, hlnk, strxrefdocname, strbookmarkname, strstatus, True, blrowdeleted) = True Then
            ' update status message in form if required
            If strstatus <> vbNullString Then
                frm.UpdateProgressText strstatus
            End If
            
            ' point to the bookmark range and check whether the hyperlink's bookmark exists
            If Not Dst.Document(strxrefdocname).Bookmarks.All.Exists(strbookmarkname) Then
                frm.UpdateProgressText "   WARNING: Bookmark '" & strbookmarkname & "' not found in row " & rrow.Index & "..."
                rngbkm.Text = Const_DOC_ERROR_STRING & " Bookmark '" & strbookmarkname & "' not found in " & fso.GetBaseName(strxrefdocname)
            Else
                ' insert the bookmark text
                rngbkm.Text = Dst.Document(strxrefdocname).Bookmarks.Bookmark(strbookmarkname).Text
                blOK = True
            End If
            
            ' now bookmark it (exclude end of cell marker text in bookmark)
            rngbkm.End = rngbkm.End - 1
            ' NOTE: we don't use the DST's cDocBookmarks object to add the bookmark, because the checksum is updated at the end of the
            '       processing, so any changes will trigger the bookmarks object to refresh
            rngbkm.Bookmarks.Add strbookmarkname, rngbkm
            
            ' format the hyperlink
            Call FormatXRefHyperlink(hlnk)
            
        Else
            ' informational messages are OK
            If InStr(1, strstatus, "INFO:") Then
                blOK = True
            End If
            
            ' update error message in form
            frm.UpdateProgressText strstatus
        End If
        
        ' error propogation
        If Not blOK Then
            UpdateExternalReferencesTable = False
        End If
        
        ' point the range to the first cell in the next row - if a row has been deleted, keep the range where it is
        If Not blrowdeleted Then
            Set rngbkm = rngbkm.Next(wdCell, 2)
        Else
            ' reselect the first cell - deleting the row collapses the range
            Set rngbkm = rngbkm.Cells(1).Range
        End If
    Next rrow
    
    '======================================================================================
    ' remove unused references
    '======================================================================================
    lngdeleted = RemoveUnusedExternalReferences(objdoc, tbl, frm)
    frm.UpdateProgressText lngdeleted & " removed."
    
    '======================================================================================
    ' format the table and turn proofing off
    '======================================================================================
    frm.UpdateProgressText "Formatting table..."
    Call FormatTable(tbl)
    
    '======================================================================================
    ' update date and checksum if success
    '======================================================================================
    If UpdateExternalReferencesTable Then
        docinfo.Variables.ExtRefsDate = Format(Now, Const_FORMAT_DATETIME)
        Call ProcessTableChecksum(objdoc, Const_DOCTBL_EXTREFERENCES)
    End If
    
    '======================================================================================
    ' finish off processing
    '======================================================================================
    frm.UpdateProgressMeter (-1)
    
Exit_UpdateExternalReferencesTable:
    System.Cursor = wdCursorNormal
    Call RestoreGrammarSettings
    Exit Function

Err_UpdateExternalReferencesTable:
    UpdateExternalReferencesTable = False
    MsgBox Err.Description & " in UpdateExternalReferencesTable() of basXReferences"
    Resume Exit_UpdateExternalReferencesTable
    
End Function

Private Function RemoveUnusedExternalReferences(ByRef objdoc As Document, ByRef tbl As Table, ByRef frm As Object) As Long
    Dim bkmarks As Scripting.Dictionary, bkm As Bookmark, strfieldcode As String, strbookname As String
    Dim idx As Long, stryrng As Range, fld As Field, lngcount As Long, lngremoved As Long
On Error GoTo Err_RemoveUnusedExternalReferences

    frm.UpdateProgressText "Removing unused external references...", False
    Set bkmarks = New Scripting.Dictionary
    
    ' build a dictionary of references that reference bookmarks
    For Each stryrng In objdoc.StoryRanges
        Do
            ' adjust the story range such that the external reference table is excluded - assume there's nothing important beyond the external references table
            If tbl.Range.InRange(stryrng) Then
                stryrng.End = tbl.Range.Start
            End If
            
            idx = 0
            lngcount = stryrng.Fields.Count
            For Each fld In stryrng.Fields
                ' show some progress
                idx = idx + 1
                frm.UpdateProgressMeter idx, lngcount
                If fld.Type = wdFieldRef Then
                    strfieldcode = fld.Code.Text
                    If InStr(1, strfieldcode, " _Ref") = 0 Then
                        ' note that the lower case name is stored as some fields in level 1 headings could be all in uppercase
                        strbookname = LCase(GetBookmarkNameFromFieldCode(strfieldcode))
                        If Not bkmarks.Exists(strbookname) Then
                            bkmarks.Add strbookname, strbookname ' actual bookmarked text is not used here, so no need to set it
                        End If
                    End If
                End If
            Next fld
            Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
        Loop Until stryrng Is Nothing
    Next stryrng
    
    ' now loop through the external references table bookmarks and remove those that are not referenced in the document
    Set stryrng = tbl.Range
    stryrng.Start = stryrng.Rows(2).Range.Start ' start at 2nd row
    For Each bkm In stryrng.Bookmarks
        ' note that the lower case of the bookmark name is used as the dictionary entries are all in lower case
        If Not bkmarks.Exists(LCase(bkm.Name)) Then
            If tbl.Rows.Count <> 2 Then
                bkm.Range.Rows(1).Delete
            Else
                ' never delete last entry - mark it as not applicable
                Call InsertNotApplicable(tbl.Cell(2, 1).Range)
                tbl.Cell(2, 2).Range.Text = vbNullString
            End If
            lngremoved = lngremoved + 1
        End If
    Next bkm
    
    RemoveUnusedExternalReferences = lngremoved
    
Exit_RemoveUnusedExternalReferences:
    Exit Function

Err_RemoveUnusedExternalReferences:
    MsgBox Err.Description & " in RemoveUnusedExternalReferences() of basXReferences"
    Resume Exit_RemoveUnusedExternalReferences
    
End Function

Function ValidateXRefHyperlinkRow(ByRef rw As Row, ByRef hlnk As Hyperlink, _
                                  ByRef strdocname As String, ByRef strbookmarkname As String, _
                                  ByRef strmessage As String, Optional ByVal blupdate As Boolean = False, Optional ByRef blrowdeleted As Variant) As Boolean
    Dim rng As Range, fso As FileSystemObject
On Error GoTo Err_ValidateXRefHyperlink

    Set fso = New FileSystemObject
        
    Set rng = rw.Range
    If rng.Hyperlinks.Count = 0 Then
        If rng.Bookmarks.Count = 0 Then
            ' no info, so delete the row if required, except if it's the last row
            strmessage = "   INFO: No data in row " & rw.Index & "..."
            If blupdate = True And Not rw.IsLast Then
                rw.Delete
                strmessage = strmessage & "(row deleted)"
                blrowdeleted = True
            End If
        Else
            strmessage = "   WARNING: Bookmark '" & rng.Bookmarks(1).Name & "' found without hyperlink in row " & rw.Index & "..."
            If blupdate = True Then
                ' assume there's only one bookmark and assume update flag is only called from UpdateExternalReferencesTable(), so it's OK to use Range's Delete method here
                Dst.Document(rng.Document.Fullname).Bookmarks.Delete rng.Bookmarks(1).Name
                strmessage = strmessage & "(bookmark deleted)"
            End If
        End If
    Else
        Set hlnk = rng.Hyperlinks(1)
        ' warn user if there are multiple hyperlinks in a cell
        If rng.Hyperlinks.Count > 1 Then
            strmessage = "   WARNING: Multiple hyperlinks in row " & rw.Index & "..."
            If blupdate Then rng.Text = Const_DOC_ERROR_STRING & " Multiple hyperlinks found"
        Else
            ' test for absolute hyperlink address and try and correct it
            If fso.GetDriveName(hlnk.Address) <> vbNullString Then
                strmessage = "   WARNING: Hyperlink address not relative in row " & rw.Index & "..."
                If blupdate Then
                    hlnk.Address = GetRelativePath(rw.Range.Document.Path, hlnk.Address)
                    strmessage = strmessage & "(hyperlink address updated)"
                End If
            End If
            
            ' check that hyperlink has a subaddress (bookmark) and that it is a valid bookmark name
            strbookmarkname = hlnk.SubAddress
            If strbookmarkname = vbNullString Then
                strmessage = AddStatusText(strmessage, "   WARNING: Hyperlink has no subaddress in row " & rw.Index & "...")
                If blupdate Then rng.Text = Const_DOC_ERROR_STRING & " No bookmark specified in hyperlink"
            ElseIf Not CheckBookmarkCharacters(strbookmarkname) Then
                strmessage = AddStatusText(strmessage, "   WARNING: Hyperlink subaddress not found in row " & rw.Index & "...")
                If blupdate Then rng.Text = Const_DOC_ERROR_STRING & " Invalid bookmark name"
            Else
                ' check that hyperlink address exists
                strdocname = hlnk.Address
                strdocname = fso.BuildPath(rw.Range.Document.Path, strdocname) ' assume hyperlink is relative, so get full pathname
                strdocname = fso.GetAbsolutePathName(strdocname)
                If Not fso.FileExists(strdocname) Then
                    strmessage = AddStatusText(strmessage, "   WARNING: Hyperlink address not found in row " & rw.Index & "...")
                    If blupdate Then rng.Text = Const_DOC_ERROR_STRING & " File not found"
                Else
                    ' all OK, hyperlink can be used
                    ValidateXRefHyperlinkRow = True
                End If
            End If
        End If
    End If

Exit_ValidateXRefHyperlink:
    Exit Function

Err_ValidateXRefHyperlink:
    MsgBox Err.Description & " in ValidateXRefHyperlink() of basXReferences"
    Resume Exit_ValidateXRefHyperlink
                
End Function

Sub InsertXRefToCaption(ByVal reftype As Integer, ByVal strcaption As String, ByRef rng As Range)
    Dim varcrossrefs As Variant, varref As Variant, idx As Integer
    
    varcrossrefs = ActiveDocument.GetCrossReferenceItems(reftype)
    For Each varref In varcrossrefs
        idx = idx + 1
        If varref = strcaption Then
            rng.InsertParagraphBefore
            rng.Collapse
            rng.Style = "Body Text"
            rng.Text = " " & IIf(reftype = wdCaptionFigure, "illustrates", "describes") & " " & Const_INSTR_START & " describe purpose of " & IIf(reftype = wdCaptionFigure, "figure", "table") & " here " & Const_INSTR_END
            rng.Collapse
            rng.InsertCrossReference reftype, wdOnlyLabelAndNumber, idx, True
            Exit Sub
        End If
    Next varref

    ' if we got here, the given caption was not found
    rng.Text = Const_DOC_ERROR_STRING & " " & Const_INSTR_START & " Unable to find caption titled '" & strcaption & "' - cross-reference to " & IIf(reftype = wdCaptionFigure, "figure", "table") & " caption not inserted " & Const_INSTR_END
    
End Sub
Attribute VB_Name = "cAbbreviation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' Describes the details related to an abbreviation

Private mDefinition As String
Private mPosition As Long

Public Property Get Definition() As String
    Definition = mDefinition
End Property

Public Property Let Definition(strvalue As String)
    mDefinition = strvalue
End Property

Public Property Get Position() As Long
    Position = mPosition
End Property

Public Property Let Position(lngvalue As Long)
    mPosition = lngvalue
End Property
Attribute VB_Name = "cBookmarkConfig"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum EnumTextMatch
    enumTextMatchNone
    enumTextMatchSuffix
    enumTextMatchFull
End Enum

Public Enum EnumSuffixStart
    enumSuffixStartNone
    enumSuffixStartDocID
End Enum

Private mDicPrefixes As Scripting.Dictionary ' of cBookmarkPrefix objects, indexed by prefix
Private mDicDocTypePrefixes As Scripting.Dictionary ' of sub-dictionaries, indexed by document type, sub-dictionaries contain the prefix strings

' some internal control flags
Private mBlDocPrefixesAdded As Boolean
Private mBlPrefixDictionariesOrdered As Boolean

Property Get Prefixes() As Scripting.Dictionary
    Call OrderPrefixDictionaries
    Set Prefixes = mDicPrefixes
End Property

Property Get Prefix(ByVal strprefix As String) As cBookmarkPrefix
    Set Prefix = mDicPrefixes(strprefix)
End Property

Property Get DocTypes() As Scripting.Dictionary
' Returns a dictionary of prefix sub-dictionaries, indexed by document type
    Call OrderPrefixDictionaries
    Set DocTypes = mDicDocTypePrefixes
End Property

Property Get ValidDocumentType(ByVal strdoctype As String) As String
    If DocTypes.Exists(strdoctype) Then
        ValidDocumentType = strdoctype
    Else
        ValidDocumentType = Const_TEXT_UNKNOWN
    End If
End Property

Public Function PrefixesExistInRef(ByRef dicprefix As Scripting.Dictionary, ByVal strmessage As String, _
                                   Optional ByRef dicprefixref As Scripting.Dictionary) As Boolean
    '==================================================================================================================================
    ' Description: For the given list of prefixes, checks that they all exist in the reference list of prefixes. If no reference list
    '              is supplied, the current bookmark configuration is used as a reference.
    '==================================================================================================================================
    Dim varprefix As Variant
    PrefixesExistInRef = True
    If dicprefixref Is Nothing Then Set dicprefixref = mDicPrefixes
    For Each varprefix In dicprefix
        If Not dicprefixref.Exists(varprefix) Then
            MsgBox "Prefix '" & varprefix & "' does not exist in the reference configuration for '" & strmessage & "' - contact the DST owner!", vbCritical
            PrefixesExistInRef = False
        End If
    Next varprefix
End Function

Property Get PrefixesForDocType(ByVal strdoctype As String, Optional ByVal blincludedoctypes As Boolean = True) As Scripting.Dictionary
' Returns a prefix sub-dictionary for the given document type
    Dim varitem As Variant, dic As Scripting.Dictionary
    
    If blincludedoctypes Then
        If mDicDocTypePrefixes.Exists(strdoctype) Then
            Set dic = DocTypes(strdoctype)
        Else
            Set dic = New Scripting.Dictionary
        End If
    Else
        Set dic = New Scripting.Dictionary
        For Each varitem In mDicDocTypePrefixes(strdoctype)
            If Not mDicPrefixes(varitem).IsDocTypePrefix Then
                dic.Add varitem, varitem
            End If
        Next varitem
        Set PrefixesForDocType = dic
    End If
    Set PrefixesForDocType = dic
    
End Property

Property Get PrefixesAuto(ByVal strdoctype As String) As Scripting.Dictionary
    Dim varitem As Variant, dic As Scripting.Dictionary
            
    ' loop through the list of pre-defined bookmark prefixes for this document type
    Set dic = New Scripting.Dictionary
    For Each varitem In mDicDocTypePrefixes(strdoctype)
        ' bookmark names that match bookmark text can be used for auto bookmarking
        If mDicPrefixes(varitem).TextMatch = enumTextMatchFull Then
            dic.Add varitem, varitem
        End If
    Next varitem
    Set PrefixesAuto = dic
End Property

Property Get PrefixFromName(ByVal strbookname As String) As String
    Dim varitem As Variant, struscore As String
    For Each varitem In mDicPrefixes
        struscore = IIf(mDicPrefixes(varitem).HasUnderscore, "_", vbNullString)
        If InStr(1, strbookname, varitem & struscore, vbTextCompare) = 1 Then ' case-insensitive match
            PrefixFromName = varitem
            Exit For
        End If
    Next varitem
End Property

Property Get SuffixFromName(ByVal strbookname As String) As String
    Dim strprefix As String, struscore As String
    strprefix = PrefixFromName(strbookname)
    If strprefix <> vbNullString Then struscore = IIf(mDicPrefixes(strprefix).HasUnderscore, "_", vbNullString)
    SuffixFromName = Right(strbookname, Len(strbookname) - Len(strprefix & struscore))
End Property

Property Get DescBookmarkFromName(ByVal strbookname As String) As String
    Dim strprefix As String, strsuffix As String
    strprefix = PrefixFromName(strbookname)
    If strprefix <> vbNullString Then
        If mDicPrefixes(strprefix).HasDescAssoc Then
            strsuffix = SuffixFromName(strbookname)
            DescBookmarkFromName = strprefix & Const_DESC_PREFIX & IIf(strsuffix <> vbNullString, "_" & strsuffix, vbNullString)
        End If
    End If
End Property

Property Get DescParentBookmarkFromName(ByVal strbookname As String) As String
    Dim strparentprefix As String, strprefix As String
    strprefix = Dst.BookmarkConfig.PrefixFromName(strbookname)
    strparentprefix = Replace(strprefix, Const_DESC_PREFIX, vbNullString, 1, 1)
    ' if they differ, the 'desc_' part was found
    If strparentprefix <> vbNullString And strprefix <> strparentprefix Then
        If mDicPrefixes(strparentprefix).HasDescAssoc Then
            DescParentBookmarkFromName = Replace(strbookname, strprefix, strparentprefix, 1, 1)
        End If
    End If
End Property

Property Get IsLiteralPrefix(ByVal strprefix As String) As Boolean
    IsLiteralPrefix = (strprefix Like "*lit")
End Property

Sub AddPrefix(ByVal strbookprefix As String, _
              Optional ByVal bldatadic As Boolean = False, Optional ByVal bldescassoc As Boolean = False, _
              Optional ByVal enmsuffixstart As EnumSuffixStart = enumSuffixStartDocID, _
              Optional ByVal enmtextmatch As EnumTextMatch = enumTextMatchFull, _
              Optional ByVal strbmarkstyle As String = vbNullString, _
              Optional ByVal strcrossrefstyle As String = vbNullString, _
              Optional vardoctypes As Variant)
    Dim idx As Integer
    Dim strdoctype As String, strbookprefixdesc As String
    Dim dic As Scripting.Dictionary, blcontinue As Boolean
On Error GoTo Err_AddPrefix
    
    '===========================================================================================================
    ' do some validation on the configuration first - abort on any error as this should not happen
    '===========================================================================================================
    blcontinue = True
    If strbookprefix <> vbNullString Then
        If mDicPrefixes.Exists(strbookprefix) Then
            MsgBox "Prefix '" & strbookprefix & "' already exists in configuration - contact the DST owner!", vbCritical
            blcontinue = False
        End If
        
        If bldescassoc = True Then
            strbookprefixdesc = strbookprefix & Const_DESC_PREFIX
            If mDicPrefixes.Exists(strbookprefixdesc) Then
                MsgBox "Prefix '" & strbookprefixdesc & "' already exists in configuration - contact the DST owner!", vbCritical
                blcontinue = False
            End If
        End If
        
        If Not IsArrayAllocated(vardoctypes) Then
            MsgBox "No list of applicable document types supplied for '" & strbookprefix & "' - contact the DST owner!", vbCritical
            blcontinue = False
        End If
        
        If blcontinue Then
            '===========================================================================================================
            ' add given prefix properties to the dictionary
            '===========================================================================================================
            AddPrefixToDictionary strbookprefix, True, bldatadic, bldescassoc, _
                                  enmsuffixstart, enmtextmatch, False, strbmarkstyle, strcrossrefstyle
            If strbookprefixdesc <> vbNullString Then
                ' add associated description bookmark prefix, noting that no styles or text match rules are allowed for these
                AddPrefixToDictionary strbookprefixdesc, True, bldatadic, False, _
                                      enmsuffixstart, enumTextMatchNone, False, vbNullString, vbNullString
            End If
        End If
    Else
        MsgBox "No bookmark prefix supplied - contact the DST owner!.", vbCritical
        blcontinue = False
    End If
    
    If blcontinue Then
        '===========================================================================================================
        ' add each document type in the given list to the document types dictionary and also add the prefix to the
        ' list of allowed prefixes for each document type in the list
        '===========================================================================================================
        For idx = 0 To UBound(vardoctypes)
            strdoctype = vardoctypes(idx)
            If Not mDicDocTypePrefixes.Exists(strdoctype) Then
                ' create prefix dictionary
                Set dic = New Scripting.Dictionary
                dic.Add strbookprefix, strbookprefix
                ' add associated description prefix to the prefix dictionary
                If strbookprefixdesc <> vbNullString Then
                    dic.Add strbookprefixdesc, strbookprefixdesc
                End If
                ' add prefix dictionary to the document type dictionary
                mDicDocTypePrefixes.Add strdoctype, dic
            Else
                ' add prefix to document type dictionary
                mDicDocTypePrefixes(strdoctype).Add strbookprefix, strbookprefix
                ' add associated description prefix to the document type dictionary
                If strbookprefixdesc <> vbNullString Then
                    mDicDocTypePrefixes(strdoctype).Add strbookprefixdesc, strbookprefixdesc
                End If
            End If
        Next idx
    End If
    
Exit_AddPrefix:
    Exit Sub
    
Err_AddPrefix:
    MsgBox Err.Description & " in AddPrefix()"
    Resume Exit_AddPrefix
End Sub

Sub AddDocTypesNoConfig(ParamArray arrdoctypes() As Variant)
    Dim idx As Integer, vardoctypes As Variant
    Dim strdoctype As String
    Dim dic As Scripting.Dictionary
On Error GoTo Err_AddDocTypesNoConfig
    
    '===========================================================================================================
    ' do some validation on the configuration first - abort on any error as this should not happen
    '===========================================================================================================
    vardoctypes = arrdoctypes
    If Not IsArrayAllocated(vardoctypes) Then
        MsgBox "Document type list not supplied - contact the DST owner!.", vbCritical
    Else
        '===========================================================================================================
        ' add each document type in the given list to the document types dictionary and with an empty prefix dictionary
        '===========================================================================================================
        For idx = 0 To UBound(vardoctypes)
            strdoctype = vardoctypes(idx)
            If Not mDicDocTypePrefixes.Exists(strdoctype) Then
                Set dic = New Scripting.Dictionary
                mDicDocTypePrefixes.Add strdoctype, dic
            Else
                MsgBox "Document type '" & strdoctype & "' already exists - contact the DST owner!.", vbCritical
            End If
        Next idx
    End If
    
Exit_AddDocTypesNoConfig:
    Exit Sub
    
Err_AddDocTypesNoConfig:
    MsgBox Err.Description & " in AddDocTypesNoConfig()"
    Resume Exit_AddDocTypesNoConfig
End Sub

Sub AddPrefixToAllDocTypes(ByVal strbookprefix As String)
    Dim varitem As Variant
On Error GoTo Err_AddToAll
    
    ' NOTE: it is assumed that this method is invoked after all document types have been defined

    If strbookprefix <> vbNullString Then
        '===========================================================================================================
        ' do some validation on the configuration first - abort on any error as this should not happen
        '===========================================================================================================
        If mDicPrefixes.Exists(strbookprefix) Then
            MsgBox "Prefix '" & strbookprefix & "' already exists in configuration - contact the DST owner!", vbCritical
            Exit Sub
        End If
        
        '===========================================================================================================
        ' add given prefix properties to the collection - these are assumed not to have an underscore after the prefix
        '===========================================================================================================
        If strbookprefix = "gref" Then
            Call AddPrefixToDictionary(strbookprefix, True, False, False, enumSuffixStartDocID, enumTextMatchNone, False, vbNullString, vbNullString)
        Else
            Call AddPrefixToDictionary(strbookprefix, False, False, False, enumSuffixStartNone, enumTextMatchNone, False, vbNullString, vbNullString)
        End If
        
        '===========================================================================================================
        ' add prefix to each document type in the dictionary
        '===========================================================================================================
        For Each varitem In mDicDocTypePrefixes
            mDicDocTypePrefixes(varitem).Add strbookprefix, strbookprefix
        Next varitem
    Else
        MsgBox "No bookmark prefix supplied - contact the DST owner!", vbCritical
    End If
    
Exit_AddToAll:
    Exit Sub
    
Err_AddToAll:
    MsgBox Err.Description & " in AddToAll() in cColBookmarkPrefixProps"
    Resume Exit_AddToAll
End Sub

Sub AddAllDocsAsPrefixes()
    Dim vardoctype As Variant, varitem As Variant
On Error GoTo Err_AddAllDocsAsPrefixes
    
    If mBlDocPrefixesAdded Then
        MsgBox "Document type prefixes have already been added - contact the DST owner!", vbCritical
    Else
        For Each vardoctype In mDicDocTypePrefixes
            '===========================================================================================================
            ' add each document type to the bookmark prefix collection
            '===========================================================================================================
            If vardoctype <> Const_TEXT_UNKNOWN Then
                Call AddPrefixToDictionary(vardoctype, True, False, False, enumSuffixStartNone, enumTextMatchNone, True, vbNullString, vbNullString)
                
                '===========================================================================================================
                ' now add the document type as a valid bookmark prefix for each document type
                '===========================================================================================================
                For Each varitem In mDicDocTypePrefixes
                    mDicDocTypePrefixes(varitem).Add vardoctype, vardoctype
                Next varitem
            End If
        Next vardoctype
        mBlDocPrefixesAdded = True
    End If
    
Exit_AddAllDocsAsPrefixes:
    Exit Sub
    
Err_AddAllDocsAsPrefixes:
    MsgBox Err.Description & " in AddAllDocsAsPrefixes()"
    Resume Exit_AddAllDocsAsPrefixes
End Sub

Property Get ConfigAsText(Optional ByVal strdoctype As String = vbNullString) As String
    Dim dicprefixes As Scripting.Dictionary, vardoctype As Variant, varprefix As Variant, strtemp As String, strdoctypeprefixes As String
            
    If strdoctype = vbNullString Then
        strtemp = "all document types:"
        For Each vardoctype In DocTypes
            ConfigAsText = ConfigAsText & vardoctype & ":" & vbCrLf
            Set dicprefixes = PrefixesForDocType(vardoctype, False)
            For Each varprefix In dicprefixes
                ConfigAsText = ConfigAsText & "  * " & varprefix & vbCrLf
            Next varprefix
        Next vardoctype
    Else
        strtemp = "the " & strdoctype & " document type:"
        Set dicprefixes = PrefixesForDocType(strdoctype, False)
        For Each varprefix In dicprefixes
            ConfigAsText = ConfigAsText & "* " & varprefix & vbCrLf
        Next varprefix
    End If
    strtemp = "Prefixes for " & strtemp
    ConfigAsText = strtemp & vbCrLf & String(Len(strtemp), "=") & vbCrLf & ConfigAsText
    
    strtemp = "Bookmark Prefix Configuration:"
    'Prefix, Has underscore, Has associated description, Suffix must match, Bookmark text match, Data dictionary type, Bookmark style, Cross-ref Style, Prefix is document type, Max length
    ConfigAsText = ConfigAsText & vbCrLf & strtemp & vbCrLf & String(Len(strtemp), "=") & vbCrLf
    For Each varprefix In mDicPrefixes
        If strdoctype = vbNullString Or PrefixesForDocType(strdoctype).Exists(varprefix) Then
            If Not Prefix(varprefix).IsDocTypePrefix Then
                strtemp = "* " & Prefix(varprefix).Prefix & ", " & _
                     IIf(Prefix(varprefix).HasUnderscore, "Has Underscore, ", vbNullString) & _
                     IIf(Prefix(varprefix).HasDescAssoc, "Has Description, ", vbNullString) & _
                     Array(vbNullString, "Suffix Must Match DocID, ")(Prefix(varprefix).SuffixStart) & _
                     Array(vbNullString, "Text Must Match Suffix, ", "Text Must Match Name, ")(Prefix(varprefix).TextMatch) & _
                     IIf(Prefix(varprefix).IsDataDicType, "Data Dictionary, ", vbNullString) & _
                     IIf(Prefix(varprefix).BookmarkStyle <> vbNullString, Prefix(varprefix).BookmarkStyle & ", ", vbNullString) & _
                     IIf(Prefix(varprefix).ReferenceStyle <> vbNullString, Prefix(varprefix).ReferenceStyle & ", ", vbNullString) & _
                     IIf(Prefix(varprefix).IsDocTypePrefix, "Document Type Prefix, ", vbNullString) & _
                     "Max Length=" & Prefix(varprefix).MaxLength
                ConfigAsText = ConfigAsText & strtemp & vbCrLf
            Else
                strdoctypeprefixes = strdoctypeprefixes & "* " & varprefix & vbCrLf
            End If
        End If
    Next varprefix
    
    strtemp = "Document Type Prefixes:"
    ConfigAsText = ConfigAsText & vbCrLf & strtemp & vbCrLf & String(Len(strtemp), "=") & vbCrLf
    ConfigAsText = ConfigAsText & strdoctypeprefixes
    
End Property
    
Private Function AddPrefixToDictionary(ByVal strprefix As String, _
                                       ByVal blhasunderscore As Boolean, _
                                       ByVal blisdatadic As Boolean, _
                                       ByVal blhasdescassoc As Boolean, _
                                       ByVal enmsuffixstart As EnumSuffixStart, _
                                       ByVal enmtextmatch As EnumTextMatch, _
                                       ByVal blisdoctype As Boolean, _
                                       ByVal strbmarkstyle As String, _
                                       ByVal strcrossrefstyle As String) As cBookmarkPrefix
    Dim prefixobj As cBookmarkPrefix
    
    Set prefixobj = New cBookmarkPrefix
    With prefixobj
        .Prefix = strprefix
        .HasUnderscore = blhasunderscore
        .HasDescAssoc = blhasdescassoc
        .IsDataDicType = blisdatadic
        .SuffixStart = enmsuffixstart
        .TextMatch = enmtextmatch
        .IsDocTypePrefix = blisdoctype
        .BookmarkStyle = strbmarkstyle
        .ReferenceStyle = strcrossrefstyle
    End With
    mDicPrefixes.Add strprefix, prefixobj
    Set AddPrefixToDictionary = prefixobj
    
End Function

Private Sub OrderPrefixDictionaries()
    Dim vardoctype As Variant, dicdoctypes As Scripting.Dictionary, dicprefixes As Scripting.Dictionary
    
    If Not mBlPrefixDictionariesOrdered Then
        Set dicdoctypes = New Scripting.Dictionary
        For Each vardoctype In mDicDocTypePrefixes
            Set dicprefixes = SortDictionary(mDicDocTypePrefixes(vardoctype))
            dicdoctypes.Add vardoctype, dicprefixes
        Next vardoctype
        Set mDicDocTypePrefixes = dicdoctypes
        mBlPrefixDictionariesOrdered = True
    End If
End Sub

Private Sub Class_Initialize()
    Set mDicPrefixes = New Scripting.Dictionary
    Set mDicDocTypePrefixes = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mDicPrefixes = Nothing
    Set mDicDocTypePrefixes = Nothing
End Sub
Attribute VB_Name = "cBookmarkPrefix"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mPrefix As String
Private mHasDescAssociated As Boolean
Private mHasUScore As Boolean
Private mIsDataDicType As Boolean
Private mSuffixStart As EnumSuffixStart
Private mTextMatch As EnumTextMatch
Private mBookmarkStyle As String
Private mReferenceStyle As String
Private mIsDocTypePrefix As Boolean

Public Property Get Prefix() As String
    Prefix = mPrefix
End Property

Public Property Let Prefix(strvalue As String)
    mPrefix = strvalue
End Property

Public Property Get HasDescAssoc() As Boolean
    HasDescAssoc = mHasDescAssociated
End Property

Public Property Let HasDescAssoc(blvalue As Boolean)
    mHasDescAssociated = blvalue
End Property

Public Property Get HasUnderscore() As Boolean
    HasUnderscore = mHasUScore
End Property

Public Property Let HasUnderscore(blvalue As Boolean)
    mHasUScore = blvalue
End Property

Public Property Get IsDataDicType() As Boolean
    IsDataDicType = mIsDataDicType
End Property

Public Property Let IsDataDicType(blvalue As Boolean)
    mIsDataDicType = blvalue
End Property

Public Property Get SuffixStart() As EnumSuffixStart
    SuffixStart = mSuffixStart
End Property

Public Property Let SuffixStart(enmvalue As EnumSuffixStart)
    mSuffixStart = enmvalue
End Property

Public Property Get TextMatch() As EnumTextMatch
    TextMatch = mTextMatch
End Property

Public Property Let TextMatch(enmvalue As EnumTextMatch)
    mTextMatch = enmvalue
End Property

Public Property Get BookmarkStyle() As String
    BookmarkStyle = mBookmarkStyle
End Property

Public Property Let BookmarkStyle(strvalue As String)
    mBookmarkStyle = strvalue
End Property

Public Property Get ReferenceStyle() As String
    ReferenceStyle = mReferenceStyle
End Property

Public Property Let ReferenceStyle(strvalue As String)
    mReferenceStyle = strvalue
End Property

Public Property Get IsDocTypePrefix() As Boolean
    IsDocTypePrefix = mIsDocTypePrefix
End Property

Public Property Let IsDocTypePrefix(blvalue As Boolean)
    mIsDocTypePrefix = blvalue
End Property

Public Property Get MaxLength() As Integer
    Dim intlength As Integer
    
    ' set the default bookmark length
    intlength = Const_MAX_BOOKMARK_LENGTH
    
    ' if bookmark type has an associated description type, descrease its maximum length
    If mHasDescAssociated = True Then
        intlength = intlength - Len(Const_DESC_PREFIX)
    End If
    
    ' if bookmark is a test specification type bookmark, descrease its maximum length to ensure there's
    ' enough space for the "ia" or "im" parts
    If mPrefix = "tshl" Or mPrefix = "tchln" Or mPrefix = "tchlr" Then
        intlength = intlength - 2
    ElseIf mPrefix = "module" Then
        ' module names must leave enough space for function names as well
        intlength = 20 + Len(mPrefix)
    End If
    
    MaxLength = intlength
End Property
Attribute VB_Name = "cConfigItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mFile As String
Private mRevision As String
Private mStatus As String

Public Property Get File() As String
    File = mFile
End Property

Public Property Let File(ByVal strfile As String)
    mFile = strfile
End Property

Public Property Get Revision() As String
    Revision = mRevision
End Property

Public Property Let Revision(ByVal strrevision As String)
    mRevision = strrevision
End Property

Public Property Get Status() As String
    Status = mStatus
End Property

Public Property Let Status(ByVal strstatus As String)
    mStatus = strstatus
End Property

Public Property Get UpToDateString() As String
    UpToDateString = "Up-to-date"
End Property

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String
        
    strdebug = strindent & "File status: " & mFile & " " & mRevision & " (" & mStatus & ")" & vbCrLf
    
    DebugString = strdebug
    
End Function
Attribute VB_Name = "cConfigStatus"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mConfigFile As String
Private mUsername As String
Private mMachinename As String
Private mConfigDate As Date
Private mConfigItems As Scripting.Dictionary ' of type cConfigItem
Private mUnknownItems As Scripting.Dictionary ' of type cConfigItem
Private mBaselineIntegrity As Boolean
Private mConstraintViolations As Long

Property Get ConfigFile() As String
    ConfigFile = mConfigFile
End Property

Property Let ConfigFile(strconfigfile As String)
    mConfigFile = strconfigfile
End Property

Property Get Username() As String
    Username = mUsername
End Property

Property Get Machinename() As String
    Machinename = mMachinename
End Property

Property Get ConfigDate() As Date
    ConfigDate = mConfigDate
End Property

Property Let ConfigDate(dte As Date)
    mConfigDate = dte
End Property

Property Get ConfigItems() As Scripting.Dictionary
    Set ConfigItems = mConfigItems
End Property

Property Get UnknownItems() As Scripting.Dictionary
    Set UnknownItems = mUnknownItems
End Property

Public Property Get BaselineIntegrity() As Boolean
    BaselineIntegrity = mBaselineIntegrity
End Property

Public Property Let BaselineIntegrity(blintegrity As Boolean)
    mBaselineIntegrity = blintegrity
End Property

Public Property Get ConstraintViolations() As Long
    ConstraintViolations = mConstraintViolations
End Property

Public Property Let ConstraintViolations(lngviolations As Long)
    mConstraintViolations = lngviolations
End Property

Function ProcessConfigFile(ByVal strreport As String, ByVal strreportsubtype As String, ByVal strconfigfile As String) As String
    Dim strerror As String
    Dim fso As FileSystemObject

    Set fso = New FileSystemObject
    
    If strreportsubtype = "lltests" Or strreportsubtype Like "llstructcov*" Then
        If fso.FileExists(strconfigfile) Then
            mConfigFile = strconfigfile
            strerror = ParseConfigFile(strreport)
        Else
            strerror = "Configuration file '" & strconfigfile & "' not found"
        End If
    Else
        strerror = "Unable to process '" & strconfigfile & "' for '" & strreportsubtype & "'"
    End If
    
    ProcessConfigFile = strerror
        
End Function

Private Function ParseConfigFile(ByVal strreport As String) As String
    Dim xmldoc As MSXML2.DOMDocument60, nodfilelist As IXMLDOMNode, nod As IXMLDOMNode, citem As cConfigItem
    Dim strrootdir As String, strfile As String
    Dim fso As FileSystemObject
On Error GoTo Err_ParseConfigFile

    Set fso = New FileSystemObject
    
    Set xmldoc = New MSXML2.DOMDocument60
    If xmldoc.Load(mConfigFile) = True Then
        Set nodfilelist = GetSingleNode(xmldoc, "status/files")
        If Not nodfilelist Is Nothing Then
            For Each nod In nodfilelist.ChildNodes
                Set citem = New cConfigItem
                strfile = GetSingleNodeText(nod, "fullname")
                'ACZ to support old formats strfile = fso.GetAbsolutePathName(fso.BuildPath(xmldoc.SelectSingleNode("//rootdir").Text, strfile))
                strfile = fso.GetAbsolutePathName(fso.BuildPath(fso.GetParentFolderName(mConfigFile), strfile))
                strfile = GetRelativePath(fso.GetParentFolderName(strreport), strfile)
                citem.File = strfile
                citem.Revision = GetSingleNodeText(nod, "revision")
                citem.Status = GetSingleNodeText(nod, "status")
                If citem.Status = citem.UpToDateString And citem.Revision <> "Unknown" Then
                    mConfigItems.Add citem.File, citem
                Else
                    mUnknownItems.Add citem.File, citem
                End If
            Next nod
        End If
        
        Set nod = GetSingleNode(xmldoc, "status/info")
        If Not nod Is Nothing Then
            mUsername = GetSingleNodeText(nod, "user")
            mMachinename = GetSingleNodeText(nod, "computer")
            mConfigDate = GetSingleNodeText(nod, "datetime")
        End If
    Else
        ParseConfigFile = "XML Parse error in '" & mConfigFile & "': Code=" & xmldoc.parseError.ErrorCode & ", Reason=" & xmldoc.parseError.reason
    End If
    
Exit_ParseConfigFile:
    Exit Function

Err_ParseConfigFile:
    ParseConfigFile = Err.Description & " in ParseConfigFile() of cTestReport"
    Resume Exit_ParseConfigFile
End Function
  
Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim idx As Integer, strdebug As String, citem As cConfigItem
        
    strdebug = strdebug & strindent & "Config Status in " & mConfigFile & ":" & vbCrLf
    strindent = strindent & "  "
    strdebug = strdebug & strindent & "Info: " & mUsername & ", " & mMachinename & ", " & mConfigDate & vbCrLf
    strdebug = strdebug & strindent & "Items: " & vbCrLf
    For idx = 0 To mConfigItems.Count - 1
        Set citem = mConfigItems.Items(idx)
        strdebug = strdebug & citem.DebugString(strindent & "  ")
    Next idx
    strdebug = strdebug & strindent & "Unknown Items: " & vbCrLf
    strdebug = strdebug & GetUnknownItems(strindent)
    strdebug = strdebug & strindent & "Baseline Integrity: " & IIf(mBaselineIntegrity, "OK", "NOK") & vbCrLf
    strdebug = strdebug & strindent & "Constraint Violations: " & mConstraintViolations & vbCrLf
    
    DebugString = strdebug
    
End Function

Function GetUnknownItems(Optional ByVal strindent As String = vbNullString) As String
    Dim idx As Integer, stritems As String, citem As cConfigItem
        
    For idx = 0 To mUnknownItems.Count - 1
        Set citem = mUnknownItems.Items(idx)
        stritems = stritems & citem.DebugString(strindent & "  ")
    Next idx
    
    GetUnknownItems = stritems
    
End Function

Private Sub Class_Initialize()
    Set mConfigItems = New Scripting.Dictionary
    Set mUnknownItems = New Scripting.Dictionary
    mConfigDate = 0
    mBaselineIntegrity = True
End Sub

Private Sub Class_Terminate()
    Set mConfigItems = Nothing
    Set mUnknownItems = Nothing
End Sub
Attribute VB_Name = "cConsoleCommand"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Enum CommandType
    CommandTypeRunComSpec = 1
    CommandTypeRun = 2
End Enum

Private mCommandList As Scripting.Dictionary
Private mExecuteInFolder As String
Private mIgnoreReturnCode As Boolean
Private mReturnCode As Long
Private mStdOut As String
Private mStdErr As String
Private mExecutionStartTime As Date
Private mCommandsExecuted As Boolean

Public Sub AddCommand(ByVal strcommand As String)
    If strcommand <> vbNullString Then
        If Len(strcommand) <= Const_CMDEXE_COMMAND_LINE_LEN Then
            mCommandList.Add mCommandList.Count, strcommand
        Else
            MsgBox "Command starting with '" & Left(strcommand, 100) & "' is longer than the allowed " & Const_CMDEXE_COMMAND_LINE_LEN & " characters - command not added", vbCritical
        End If
    End If
End Sub

Public Sub AddCommandList(ByRef diccmds As Scripting.Dictionary)
    Dim varcmd As Variant
    
    For Each varcmd In diccmds
        mCommandList.Add varcmd, diccmds(varcmd)
    Next varcmd
End Sub

Public Property Let ExecuteIn(ByVal strexecutein As String)
    mExecuteInFolder = strexecutein
End Property

Public Property Let IgnoreReturnCode(ByVal blignore As Boolean)
    mIgnoreReturnCode = blignore
End Property

Public Property Get ReturnCode() As Long
    ReturnCode = mReturnCode
End Property

Public Property Get StdOut() As String
    StdOut = mStdOut
End Property

Public Property Get StdErr() As String
    StdErr = mStdErr
End Property

Public Function Execute(Optional ByVal cmdtype As CommandType = CommandTypeRunComSpec) As Boolean
    Dim varcommand As Variant
    Dim wsh As WshShell, fso As FileSystemObject, cmd As cConsoleCommandResult
On Error GoTo Err_Execute

    ' commands for this instance can only be executed once
    If mCommandsExecuted = True Then
        MsgBox "Commands have already been executed", vbCritical
        Execute = False
        Exit Function
    End If
    
    ' make sure we start from a known place
    Set fso = New FileSystemObject
    If Not fso.FolderExists(mExecuteInFolder) Then
        MsgBox "Cannot execute in '" & mExecuteInFolder & "' - folder does not exist", vbCritical
        Execute = False
        Exit Function
    End If
    ChDrive Left(mExecuteInFolder, 2)
    ChDir mExecuteInFolder
    
    ' make sure there are commands to execute
    If mCommandList.Count = 0 Then
        MsgBox "There are no commands to execute", vbCritical
        Execute = False
        Exit Function
    End If
    
    ' sample startime
    mExecutionStartTime = Now()
    
    ' execute each command in list
    Set wsh = CreateObject("Wscript.Shell")
    For Each varcommand In mCommandList
        Set cmd = New cConsoleCommandResult
        ' execute command
        cmd.Execute wsh, mCommandList(varcommand), cmdtype
    
        ' update global STDOUT, STDERR and return code
        mStdOut = IIf(mStdOut = vbNullString, vbNullString, mStdOut & vbCrLf) & cmd.StdOut
        mStdErr = IIf(mStdErr = vbNullString, vbNullString, mStdErr & vbCrLf) & cmd.StdErr
        If cmd.ReturnCode <> 0 Then mReturnCode = cmd.ReturnCode
    Next varcommand
    
Exit_Execute:
    ' return true if the return code is to be ignored
    If Not mIgnoreReturnCode Then
        If mReturnCode = 0 Then
            Execute = True
        End If
    Else
        Execute = True
    End If
    mCommandsExecuted = True
    Exit Function

Err_Execute:
    ' force error return if a error occurred
    mReturnCode = -1
    mStdErr = mStdErr & vbCrLf & "Error " & Err.Number & ": " & Err.Description
    mIgnoreReturnCode = False
    Resume Exit_Execute
    
End Function

Private Sub Class_Initialize()
    Set mCommandList = New Scripting.Dictionary
    mExecuteInFolder = GetTempFolderName()
End Sub

Private Sub Class_Terminate()
    Set mCommandList = Nothing
End Sub
Attribute VB_Name = "cConsoleCommandResult"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mExecutionStartTime As Date
Private mCommand As String
Private mStdOut As String
Private mStdErr As String
Private mReturnCode As Long

Public Property Get ExecutionStartTime() As Date
    ExecutionStartTime = mExecutionStartTime
End Property

Public Property Get Command() As String
    Command = mCommand
End Property

Public Property Get StdOut() As String
    StdOut = mStdOut
End Property

Public Property Get StdErr() As String
    StdErr = mStdErr
End Property

Public Property Get ReturnCode() As Long
    ReturnCode = mReturnCode
End Property

Public Sub Execute(ByRef wsh As WshShell, ByRef strcommand As String, ByVal cmdtype As CommandType)
    Dim fso As FileSystemObject
On Error GoTo Err_Execute

    Set fso = New FileSystemObject
    
    mExecutionStartTime = Now()
    
    mCommand = strcommand
    
    ' Add re-direction if trace is required
    If cmdtype = CommandTypeRunComSpec Then
        Dim strstdout As String, strstderr As String
        
        ' remove output files if they exist
        strstdout = fso.BuildPath(GetTempFolderName(), "stdout.txt")
        If fso.FileExists(strstdout) Then fso.DeleteFile strstdout
        
        strstderr = fso.BuildPath(GetTempFolderName(), "stderr.txt")
        If fso.FileExists(strstderr) Then fso.DeleteFile strstderr
        
        ' check for user-specified re-direction
        If Not mCommand Like "* >*" Then mCommand = mCommand & " > " & """" & strstdout & """"
        If Not mCommand Like "* 2>*" Then mCommand = mCommand & " 2> " & """" & strstderr & """"
        
        ' execute the command using the command interpreter with the /C option so it returns when it's done
        mCommand = wsh.ExpandEnvironmentStrings("%comspec%") & " /C " & mCommand
    End If
    
    ' run the command
    mReturnCode = wsh.Run(mCommand, WshHide, True)
            
    ' capture trace output if required
    If cmdtype = CommandTypeRunComSpec Then
        mStdOut = ReadFile(strstdout)
        mStdErr = ReadFile(strstderr)
    End If
    
Exit_Execute:
    Exit Sub
    
Err_Execute:
    mReturnCode = -1
    mStdErr = "Error " & Err.Number & ": " & Err.Description
    Resume Exit_Execute
    
End Sub

Private Function ReadFile(ByVal strinfile As String) As String
    Dim fso As FileSystemObject, ts As TextStream
    
    Set fso = New FileSystemObject
    If fso.FileExists(strinfile) Then
        Set ts = fso.OpenTextFile(strinfile)
        If Not ts.AtEndOfStream Then
            ReadFile = ts.ReadAll
        End If
        ts.Close
    End If
            
End Function
Attribute VB_Name = "cCoverageMetric"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mStatementPercentage As String
Private mDecisionPercentage As String
Private mMcdcPercentage As String
Private mJustifications As Scripting.Dictionary ' line number, justification

Property Get Result() As String
    
    Result = Const_TESTRESULT_FAILED
    
    If mStatementPercentage = BuildPercentageString(100) Then
        If mDecisionPercentage = BuildPercentageString(vbNullString) Then ' if emptry, it does not apply
            Result = Const_TESTRESULT_PASSED
        ElseIf mDecisionPercentage = BuildPercentageString(100) Then
            If mMcdcPercentage = BuildPercentageString(vbNullString) Then ' if empty, it does not apply
                Result = Const_TESTRESULT_PASSED
            ElseIf mMcdcPercentage = BuildPercentageString(100) Then
                Result = Const_TESTRESULT_PASSED
            End If
        End If
    End If
    
End Property

Property Get StatementPercentage() As Variant
    StatementPercentage = mStatementPercentage
End Property

Property Let StatementPercentage(varpercent As Variant)
    mStatementPercentage = BuildPercentageString(varpercent)
End Property

Property Get DecisionPercentage() As Variant
    DecisionPercentage = mDecisionPercentage
End Property

Property Let DecisionPercentage(varpercent As Variant)
    mDecisionPercentage = BuildPercentageString(varpercent)
End Property

Property Get McdcPercentage() As Variant
    McdcPercentage = mMcdcPercentage
End Property

Property Let McdcPercentage(varpercent As Variant)
    mMcdcPercentage = BuildPercentageString(varpercent)
End Property

Property Get Justifications() As Scripting.Dictionary
    Set Justifications = mJustifications
End Property

Function DebugString(Optional ByVal strindent As String = vbNullString, Optional ByVal blincludejsts As Boolean = False) As String
    Dim strdebug As String, idx As Integer
On Error Resume Next

    strdebug = strindent & "Result = " & Result & " (Statement: " & mStatementPercentage & ", Decision: " & mDecisionPercentage & ", MCDC: " & mMcdcPercentage & ") "
    If blincludejsts And mJustifications.Count > 0 Then
        strdebug = strdebug & vbCrLf & "Justifications: " & vbCrLf
        For idx = 0 To mJustifications.Count - 1
            strdebug = strdebug & IIf(mJustifications.Keys(idx) > 0, "Line # " & mJustifications.Keys(idx) & ": ", vbNullString) & mJustifications.Items(idx) & vbCrLf
        Next idx
    End If
    strdebug = strdebug & vbCrLf
    
    DebugString = strdebug
    
End Function

Private Sub Class_Initialize()
    mStatementPercentage = BuildPercentageString(vbNullString)
    mDecisionPercentage = BuildPercentageString(vbNullString)
    mMcdcPercentage = BuildPercentageString(vbNullString)
    Set mJustifications = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mJustifications = Nothing
End Sub
Attribute VB_Name = "cCoverageModule"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mName As String
Private mCoverage As cCoverageMetric
Private mFunctions As Scripting.Dictionary ' of class cCoverageMetric, keyed by function name

Property Get Name() As String
    Name = mName
End Property

Property Let Name(strname As String)
    mName = strname
End Property

Property Get Coverage() As cCoverageMetric
    Set Coverage = mCoverage
End Property

Property Get Functions() As Scripting.Dictionary
    Set Functions = mFunctions
End Property

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String
    Dim idx As Integer, cov As cCoverageMetric
        
    strdebug = strindent & "Module: " & mName & mCoverage.DebugString(", ")
    
    strdebug = strdebug & strindent & "  Functions:" & vbCrLf
    For idx = 0 To mFunctions.Count - 1
        Set cov = mFunctions.Items(idx)
        strdebug = strdebug & strindent & "    " & mFunctions.Keys(idx) & ":" & cov.DebugString(String(45 - Len(mFunctions.Keys(idx)), " "), True)
    Next idx
    
    DebugString = strdebug
    
End Function

Private Sub Class_Initialize()
    Set mCoverage = New cCoverageMetric
    Set mFunctions = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mCoverage = Nothing
    Set mFunctions = Nothing
End Sub
Attribute VB_Name = "cCoverageReport"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mStdAssociated As String
Private mReportSubType As String
Private mCoverageResultsFile As String
Private mCoverageMetrics As cCoverageMetric
Private mInstrumentedModules As Scripting.Dictionary ' of class cCoverageModule
Private mUnInstrumentedModules As Scripting.Dictionary ' of sub-dictionaries (line number and justification)
Private mConfigStatus As cConfigStatus

Private Const Const_TEST_COVERAGE_FOLDER_PATH_REL2DOC As String = Const_TEST_FOLDER_PATH_REL2DOC & "\coverage"
Private Const Const_COMBINED_COVERAGE_FILE_SUFFIX As String = ".combined.coverage.xml"

Property Get StdAssociated() As String
    StdAssociated = mStdAssociated
End Property

Property Get ReportSubType() As String
    ReportSubType = mReportSubType
End Property

Property Get CoverageResultsFile() As String
    CoverageResultsFile = mCoverageResultsFile
End Property

Property Get CoverageMetrics() As cCoverageMetric
    Set CoverageMetrics = mCoverageMetrics
End Property

Property Get InstrumentedModules() As Scripting.Dictionary
    Set InstrumentedModules = mInstrumentedModules
End Property

Property Get UnInstrumentedModules() As Scripting.Dictionary
    Set UnInstrumentedModules = mUnInstrumentedModules
End Property

Property Get ConfigStatus() As cConfigStatus
    Set ConfigStatus = mConfigStatus
End Property

Function ProcessResults(ByVal strreport As String, ByVal strreportsubtype As String, _
                        ByVal dtedummyref As Date, ByRef srndummyinfo As cSrns, ByRef frm As Object, Optional ByVal blsummary As Boolean = False) As Boolean
    Dim strdocfolder As String, strtestscriptroot As String, strstdfolder As String, fold As Folder, strmessage As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    mStdAssociated = GetSTDFileNameFromSTR(strreport)
    mReportSubType = strreportsubtype
    mCoverageResultsFile = GetCoverageResultFile(strreportsubtype, strreport)
    
    If mCoverageResultsFile = vbNullString Then
        ' intrumentation summary looks at multiple results files, but they might not all exist
        If Not blsummary Then
            frm.UpdateProgressText "ERROR: Could not find coverage results file for the '" & strreportsubtype & "' STR"
        End If
        Exit Function
    End If
    
    If strreportsubtype Like "hlstructcov*" Then
        strmessage = ParseHlCoverageResults(mCoverageResultsFile, strreport)
    ElseIf strreportsubtype Like "llstructcov*" Then
        strmessage = ParseLlCoverageResults(mCoverageResultsFile, strreport, blsummary)
        
        If strmessage = vbNullString Then
            ' set some configuration data for summary coverage STRs
            strdocfolder = fso.GetParentFolderName(mStdAssociated)
            mConfigStatus.ConfigFile = mCoverageResultsFile
            mConfigStatus.ConfigDate = fso.GetFile(mCoverageResultsFile).DateLastModified
            
            strtestscriptroot = fso.GetAbsolutePathName(fso.BuildPath(strdocfolder, Const_TEST_FOLDER_PATH_REL2DOC))
            If blsummary Then
                strstdfolder = strtestscriptroot
            Else
                strstdfolder = fso.BuildPath(strtestscriptroot, fso.GetBaseName(mStdAssociated))
            End If
            
            If fso.FolderExists(strstdfolder) Then
                Set fold = fso.GetFolder(strstdfolder)
                strmessage = ProcessConfigItems(strreport, strreportsubtype, fold)
            End If
        End If
    End If
    
    ProcessResults = ProcessStatusMessage(strmessage, frm)
    
End Function

Private Function ParseHlCoverageResults(ByVal strcoveragefile As String, ByVal strreport As String) As String
    Dim xmldoc As MSXML2.DOMDocument60, nodrpt As MSXML2.IXMLDOMNode, nodmod As MSXML2.IXMLDOMNode, nodfunc As MSXML2.IXMLDOMNode, nodmods As MSXML2.IXMLDOMNodeList, nodfuncs As MSXML2.IXMLDOMNodeList
    Dim covmod As cCoverageModule, covfunc As cCoverageMetric, idx As Integer, strmodule As String, jst As Scripting.Dictionary, citem As cConfigItem
    Dim fso As FileSystemObject
On Error GoTo Err_ParseHlCoverageResults

    Set fso = New FileSystemObject
    
    Set xmldoc = New MSXML2.DOMDocument60
    With xmldoc
        If .Load(strcoveragefile) = True Then
            .setProperty "SelectionNamespaces", "xmlns:ns='http://schemas.datacontract.org/2004/07/Covt.Src'"
            .setProperty "SelectionLanguage", "XPath"
            Set nodrpt = .SelectSingleNode("//ns:CoverageResults")
            If Not nodrpt Is Nothing Then
                '==================================================================================
                ' Summary coverage data
                '==================================================================================
                Call GetCoverageMetricData(nodrpt, mCoverageMetrics)
                
                '==================================================================================
                ' Config status data
                '==================================================================================
                mConfigStatus.ConfigFile = strcoveragefile
                mConfigStatus.ConfigDate = fso.GetFile(strcoveragefile).DateLastModified
                mConfigStatus.BaselineIntegrity = IIf(GetSingleNodeText(nodrpt, "BaselineIntegrity") = "Pass", True, False)
                mConfigStatus.ConstraintViolations = GetSingleNodeText(nodrpt, "ConstraintViolations")
                
                '==================================================================================
                ' Module data
                '==================================================================================
                Set nodmods = nodrpt.SelectNodes("ns:InstrumentedModules/ns:ModuleResults")
                For Each nodmod In nodmods
                    Set covmod = New cCoverageModule
                    Call GetCoverageMetricData(nodmod, covmod.Coverage)
                    strmodule = GetSingleNodeText(nodmod, "Name")
                    If strmodule <> vbNullString Then
                        strmodule = fso.GetAbsolutePathName(fso.BuildPath(fso.GetParentFolderName(strcoveragefile), strmodule))
                        strmodule = GetRelativePath(fso.GetParentFolderName(strreport), strmodule)
                        covmod.Name = strmodule
                        
                        ' update the module config status data
                        Set citem = New cConfigItem
                        citem.File = strmodule
                        citem.Revision = GetSingleNodeText(nodmod, "Revision")
                        citem.Status = citem.UpToDateString ' mark all as up-to-date, baseline integrity flag is used for high-level coverage
                        mConfigStatus.ConfigItems.Add citem.File, citem
                    End If
                    
                    '==================================================================================
                    ' Function data
                    '==================================================================================
                    Set nodfuncs = nodmod.SelectNodes("ns:Functions/ns:FunctionResults")
                    For Each nodfunc In nodfuncs
                        Set covfunc = New cCoverageMetric
                        Call GetCoverageMetricData(nodfunc, covfunc)
                        covmod.Functions.Add GetSingleNodeText(nodfunc, "Name"), covfunc
                    Next nodfunc
                    mInstrumentedModules.Add covmod.Name, covmod
                Next nodmod
                
                '==================================================================================
                ' Uninstrumented modules data
                '==================================================================================
                Set nodmods = nodrpt.SelectNodes("ns:UninstrumentedModules/ns:UninstrumentedModuleResult")
                For Each nodmod In nodmods
                    strmodule = GetSingleNodeText(nodmod, "Name")
                    strmodule = fso.GetAbsolutePathName(fso.BuildPath(fso.GetParentFolderName(strcoveragefile), strmodule))
                    strmodule = GetRelativePath(fso.GetParentFolderName(strreport), strmodule)
                    Set jst = New Scripting.Dictionary
                    jst.Add 0, GetSingleNodeText(nodmod, "Justification") ' line #0 as justification applies to entire module
                    mUnInstrumentedModules.Add strmodule, jst
                Next nodmod
                            
            End If
        Else
            ParseHlCoverageResults = "XML Parse error in '" & strcoveragefile & "': Code=" & .parseError.ErrorCode & ", Reason=" & .parseError.reason
        End If
    End With
    
Exit_ParseHlCoverageResults:
    Exit Function

Err_ParseHlCoverageResults:
    ParseHlCoverageResults = Err.Description & " in ParseHlCoverageResults() of cTestReport"
    Resume Exit_ParseHlCoverageResults
End Function

Private Function ParseLlCoverageResults(ByVal strcoveragefile As String, ByVal strreport As String, ByVal blsummary As Boolean) As String
    Dim xmldoc As MSXML2.DOMDocument60, nodmods As MSXML2.IXMLDOMNodeList, nodtests As MSXML2.IXMLDOMNodeList, nodfuncs As MSXML2.IXMLDOMNodeList
    Dim nodrpt As MSXML2.IXMLDOMNode, nod As MSXML2.IXMLDOMNode, nodmod As MSXML2.IXMLDOMNode, nodcov As MSXML2.IXMLDOMNode, nodtest As MSXML2.IXMLDOMNode, nodfunc As MSXML2.IXMLDOMNode
    Dim covmod As cCoverageModule, covfunc As cCoverageMetric, idx As Integer, strmodule As String, jstdefault As Scripting.Dictionary
    Dim blprocessmodule As Boolean, strstdfolder As String
    Dim fso As FileSystemObject
On Error GoTo Err_ParseLlCoverageResults

    Set fso = New FileSystemObject
    
    Set xmldoc = New MSXML2.DOMDocument60
    With xmldoc
        If .Load(strcoveragefile) = True Then
            Set nodrpt = .SelectSingleNode("CoverageReport/Csci")
            If Not nodrpt Is Nothing Then
                '==================================================================================
                ' Summary coverage data
                '==================================================================================
                Call GetCoverageMetricData(GetSingleNode(nodrpt, "CoverageAchieved"), mCoverageMetrics)
                
                '==================================================================================
                ' Module data
                '==================================================================================
                strstdfolder = fso.GetBaseName(mStdAssociated)
                Set nodmods = nodrpt.SelectNodes("Modules/ModuleResult")
                For Each nodmod In nodmods
                    If Not blsummary Then
                        ' only process modules instrumented under the associated STD folder
                        blprocessmodule = False
                        Set nodtests = nodmod.SelectNodes("InstrumentationList")
                        For Each nodtest In nodtests
                            If GetSingleNodeText(nodtest, "TestSet") Like "*/" & strstdfolder & "/*" Then
                                blprocessmodule = True
                                Exit For
                            End If
                        Next nodtest
                    Else
                        ' process all modules for the summaries
                        blprocessmodule = True
                    End If
                    
                    If blprocessmodule Then
                        Set nodcov = GetSingleNode(nodmod, "CoverageAchieved")
                        Set covmod = New cCoverageModule
                        Call GetCoverageMetricData(nodcov, covmod.Coverage)
                        strmodule = GetSingleNodeText(nodcov, "Name")
                        If strmodule <> vbNullString Then
                            strmodule = fso.GetAbsolutePathName(fso.BuildPath(fso.GetParentFolderName(strcoveragefile), strmodule))
                            covmod.Name = GetRelativePath(fso.GetParentFolderName(strreport), strmodule)
                        End If
                        
                        '==================================================================================
                        ' Function data
                        '==================================================================================
                        Set nodfuncs = nodmod.SelectNodes("Functions/FunctionResult/CoverageAchieved")
                        For Each nodfunc In nodfuncs
                            Set covfunc = New cCoverageMetric
                            Call GetCoverageMetricData(nodfunc, covfunc)
                            covfunc.Justifications.RemoveAll ' no justification mechanism for low-level tests, so initialise to default
                            covfunc.Justifications.Add 0, Const_DEFAULT_JST_TEXT
                            covmod.Functions.Add GetSingleNodeText(nodfunc, "Name"), covfunc
                        Next nodfunc
                        mInstrumentedModules.Add covmod.Name, covmod
                    End If
                Next nodmod
                
                '==================================================================================
                ' Uninstrumented modules data
                '==================================================================================
                Set jstdefault = New Scripting.Dictionary
                jstdefault.Add 0, Const_DEFAULT_JST_TEXT
                Set nodmods = nodrpt.SelectNodes("//UninstrumentedModules/Name")
                For Each nod In nodmods
                    strmodule = nod.Text
                    strmodule = fso.GetAbsolutePathName(fso.BuildPath(fso.GetParentFolderName(strcoveragefile), strmodule))
                    strmodule = GetRelativePath(fso.GetParentFolderName(strreport), strmodule)
                    mUnInstrumentedModules.Add strmodule, jstdefault
                Next nod
            End If
        Else
            ParseLlCoverageResults = "XML Parse error in '" & strcoveragefile & "': Code=" & .parseError.ErrorCode & ", Reason=" & .parseError.reason
        End If
    End With
    
Exit_ParseLlCoverageResults:
    Exit Function

Err_ParseLlCoverageResults:
    ParseLlCoverageResults = Err.Description & " in ParseLlCoverageResults() of cTestReport"
    Resume Exit_ParseLlCoverageResults
End Function

Private Function ProcessConfigItems(ByVal strreport As String, ByVal strreportsubtype As String, ByRef fold As Folder) As String
    Dim fso As FileSystemObject, idx As Integer, fil As File, subfold As Folder, tstresult As cTestResult, config As cConfigStatus, citem As cConfigItem
    Dim strconfigfile As String, strresultsuffix As String, strerror As String, strtemp As String
    
    Set fso = New FileSystemObject
    
    ' determine result file suffix
    Set tstresult = New cTestResult
    strresultsuffix = tstresult.TestResultFileSuffixLl
    
    ' open each config file and extract information
    For Each fil In fold.Files
        If fil.Name Like "*" & strresultsuffix Then
            tstresult.TestResultFile = fil.Path
            strconfigfile = tstresult.TestConfigFile
            Set config = New cConfigStatus
            strtemp = config.ProcessConfigFile(strreport, strreportsubtype, strconfigfile)
            If strtemp <> vbNullString Then strerror = strerror & strtemp & vbCrLf
            For idx = 0 To config.ConfigItems.Count - 1
                Set citem = config.ConfigItems.Items(idx)
                ' only add process up-to-date items
                If citem.Status = citem.UpToDateString And citem.Revision <> "Unknown" Then
                    If Not mConfigStatus.ConfigItems.Exists(citem.File) Then
                        mConfigStatus.ConfigItems.Add citem.File, citem
                    End If
                Else
                    mConfigStatus.BaselineIntegrity = False
                End If
            Next idx
        End If
    Next fil
    
    ' recursively call this function for each subfolder in the given folder
    For Each subfold In fold.SubFolders
        strtemp = ProcessConfigItems(strreport, strreportsubtype, subfold)
        If strtemp <> vbNullString Then strerror = strerror & strtemp & vbCrLf
    Next subfold
    
    ProcessConfigItems = strerror
    
End Function

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String, idx As Integer, cov As cCoverageModule, jst As Scripting.Dictionary
         
    strdebug = strdebug & strindent & mStdAssociated & " (" & mReportSubType & ")" & vbCrLf
    strdebug = strdebug & strindent & "Combined coverage results file: " & mCoverageResultsFile & vbCrLf
    strdebug = strdebug & mCoverageMetrics.DebugString(strindent)
    strdebug = strdebug & strindent & "Number of instrumented modules: " & mInstrumentedModules.Count & vbCrLf
    For idx = 0 To mInstrumentedModules.Count - 1
        Set cov = mInstrumentedModules.Items(idx)
        strdebug = strdebug & cov.DebugString(strindent & "  ")
    Next idx
    
    strdebug = strdebug & strindent & "Number of un-instrumented modules: " & mUnInstrumentedModules.Count & vbCrLf
    For idx = 0 To mUnInstrumentedModules.Count - 1
        Set jst = mUnInstrumentedModules.Items(idx) ' we know there's only one here
        strdebug = strdebug & strindent & "  " & mUnInstrumentedModules.Keys(idx) & " Justification: " & jst.Items(0) & vbCrLf
    Next idx
    strdebug = strdebug & strindent & "Config status:" & vbCrLf
    strdebug = strdebug & strindent & mConfigStatus.DebugString(strindent) & vbCrLf
    
    DebugString = strdebug
    
End Function

Private Sub GetCoverageMetricData(ByRef nodcov As MSXML2.IXMLDOMNode, ByRef cov As cCoverageMetric)
    Dim nod As MSXML2.IXMLDOMNode, nodjsts As MSXML2.IXMLDOMNodeList, strnamespace As String
    
    If nodcov.NamespaceURI <> vbNullString Then
        strnamespace = "ns:" ' assume shortcut is 'ns'
    End If
    
    With cov
        .StatementPercentage = GetCoverageMetric(nodcov, "StatementCoverage")
        .DecisionPercentage = GetCoverageMetric(nodcov, "DecisionCoverage")
        .McdcPercentage = GetCoverageMetric(nodcov, "Mcdc", "McdCoverage")
        
        Set nodjsts = nodcov.SelectNodes(strnamespace & "JustificationResults/" & strnamespace & "JustificationResult")
        For Each nod In nodjsts
            .Justifications.Add GetSingleNodeText(nod, "Line"), GetSingleNodeText(nod, "Justification")
        Next nod
    End With

End Sub

Private Function GetCoverageMetric(ByRef nodcov As IXMLDOMNode, ByVal strmetricname As String, Optional ByVal straltmetricname As String = vbNullString) As String
    GetCoverageMetric = GetSingleNodeText(nodcov, strmetricname, straltmetricname)
    If Not IsNumeric(GetCoverageMetric) Then
        GetCoverageMetric = vbNullString
    End If
End Function

Private Function GetCoverageResultFile(ByVal strreportsubtype As String, ByVal strreport As String) As String
    Dim strcoveragefile As String, fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    ' for coverage results, make sure combined coverage results file exists
    If strreportsubtype Like "*structcov*" Then
        strcoveragefile = fso.GetAbsolutePathName(fso.BuildPath(fso.GetParentFolderName(strreport), Const_TEST_COVERAGE_FOLDER_PATH_REL2DOC & "\" & _
                                                  IIf(strreportsubtype Like "hlstructcov*", "hl", "ll") & _
                                                  Const_COMBINED_COVERAGE_FILE_SUFFIX))
        If fso.FileExists(strcoveragefile) Then
            GetCoverageResultFile = strcoveragefile
        End If
    End If

End Function

Private Sub Class_Initialize()
    Set mCoverageMetrics = New cCoverageMetric
    Set mInstrumentedModules = New Scripting.Dictionary
    Set mUnInstrumentedModules = New Scripting.Dictionary
    Set mConfigStatus = New cConfigStatus
End Sub

Private Sub Class_Terminate()
    Set mCoverageMetrics = Nothing
    Set mInstrumentedModules = Nothing
    Set mUnInstrumentedModules = Nothing
    Set mConfigStatus = Nothing
End Sub


Attribute VB_Name = "cCsci"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mName As String
Private mAbbreviation As String
Private mVersionTag As String
Private mBinName As String
Private mChecksum As String

Property Get Name() As String
    Name = mName
End Property

Property Let Name(ByVal strname As String)
    mName = strname
End Property

Property Get Abbreviation() As String
    Abbreviation = mAbbreviation
End Property

Property Let Abbreviation(ByVal strabbreviation As String)
    mAbbreviation = strabbreviation
End Property

Property Get VersionTag() As String
    VersionTag = mVersionTag
End Property

Property Let VersionTag(ByVal strtag As String)
    mVersionTag = strtag
End Property

Property Get BinName() As String
    BinName = mBinName
End Property

Property Let BinName(ByVal strbinname As String)
    mBinName = strbinname
End Property

Property Get Checksum() As String
    Checksum = mChecksum
End Property

Property Let Checksum(ByVal strchecksum As String)
    mChecksum = strchecksum
End Property

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
        
    DebugString = strindent & mName & ": " & IIf(mAbbreviation <> vbNullString, "(" & mAbbreviation & ") ", vbNullString) & mBinName & "=" & mChecksum & IIf(mVersionTag <> vbNullString, " (" & mVersionTag & ")", vbNullString) & vbCrLf
    
End Function

Sub Clone(ByRef newcsci As cCsci)
    newcsci.Name = mName
    newcsci.Abbreviation = mAbbreviation
    newcsci.VersionTag = mVersionTag
    newcsci.BinName = mBinName
    newcsci.Checksum = mChecksum
End Sub
Attribute VB_Name = "cDocBookmark"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mName As String
Private mPrefix As String
Private mText As String
Private mPosition As Long
Private mHeading As String
Private mSourceDocument As String ' relative path to bookmark's source document

Public Property Get Name() As String
    Name = mName
End Property

Public Property Let Name(strvalue As String)
    mName = strvalue
End Property

Public Property Get Prefix() As String
    Prefix = mPrefix
End Property

Public Property Let Prefix(strvalue As String)
    mPrefix = strvalue
End Property

Public Property Get Text() As String
    Text = mText
End Property

Public Property Let Text(strvalue As String)
    mText = strvalue
End Property

Public Property Get Position() As Long
    Position = mPosition
End Property

Public Property Let Position(lngvalue As Long)
    mPosition = lngvalue
End Property

Public Property Get Heading() As String
    Heading = mHeading
End Property

Public Property Let Heading(strvalue As String)
    mHeading = strvalue
End Property

Public Property Get SourceDocument() As String
    SourceDocument = mSourceDocument
End Property

Public Property Let SourceDocument(strvalue As String)
    mSourceDocument = strvalue
End Property
Attribute VB_Name = "cDocBookmarks"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' NOTE: The bookmark dictionaries are not created when this class is initialised - they are (re)computed when accessed to
'       improve performance.
'       For this reason, the public APIs must ensure that these dictionaries are always populated before they're accessed
'       by calling the private RefreshBookmarks() method.
Private mParent As cDocInfo ' Reference to parent Document Info object
Private mAll As Scripting.Dictionary ' of cDocBookmark class
Private mInternal As Scripting.Dictionary ' of cDocBookmark class
Private mInternalTraceable As Scripting.Dictionary ' of cDocBookmark class
Private mExternal As Scripting.Dictionary ' of cDocBookmark class
Private mBuildTimestamp As Date
Private mBuildDuration As Long
Private mExtRefTableChecksum As String

Property Get Parent() As cDocInfo
    Set Parent = mParent
End Property

Property Set Parent(docinfo As cDocInfo)
    Set mParent = docinfo
End Property

Property Get All() As Scripting.Dictionary
    Call RefreshBookmarks
    Set All = mAll
End Property

Property Get Bookmark(ByVal strbookmark As String) As cDocBookmark
    Call RefreshBookmarks
    If mAll.Exists(strbookmark) Then Set Bookmark = mAll.Item(strbookmark)
End Property

Property Get Internal() As Scripting.Dictionary
    Call RefreshBookmarks
    Set Internal = mInternal
End Property

Property Get InternalTraceable() As Scripting.Dictionary
    Call RefreshBookmarks
    Set InternalTraceable = mInternalTraceable
End Property

Property Get External() As Scripting.Dictionary
    Call RefreshBookmarks
    Set External = mExternal
End Property

Property Get BuildTimestamp() As Date
    Call RefreshBookmarks
    BuildTimestamp = mBuildTimestamp
End Property

Property Get BuildDuration() As Long
    BuildDuration = mBuildDuration
End Property

Property Get ExtRefTableChecksum() As String
    ExtRefTableChecksum = mExtRefTableChecksum
End Property

Property Get ListBoxSortedArray(Optional ByVal blincludeexternals As Boolean = True) As Variant
    Dim bkmarklist() As String, dicsorted As Scripting.Dictionary, bkm As cDocBookmark, idx As Long
    Call RefreshBookmarks
    ' sort the dictionary first
    If blincludeexternals Then
        Set dicsorted = SortDictionary(mAll)
    Else
        Set dicsorted = SortDictionary(mInternal)
    End If
    
    ' assume list box has these columns: name, external, text, prefix, heading, position, source document
    If dicsorted.Count > 0 Then
        ReDim bkmarklist(dicsorted.Count - 1, 7)
        For idx = 0 To dicsorted.Count - 1
            Set bkm = dicsorted.Items(idx)
            bkmarklist(idx, 0) = bkm.Name
            bkmarklist(idx, 1) = IIf(IsExternal(bkm.Name), Const_EXTERNAL_BOOKMARK_ID_TEXT, vbNullString)
            bkmarklist(idx, 2) = bkm.Text
            bkmarklist(idx, 3) = bkm.Prefix
            bkmarklist(idx, 4) = bkm.Heading
            bkmarklist(idx, 5) = bkm.Position
            bkmarklist(idx, 6) = bkm.SourceDocument
        Next idx
    End If
    ListBoxSortedArray = bkmarklist
End Property

Property Get IsExternal(ByVal strbookmark As String) As Boolean
    Call RefreshBookmarks
    IsExternal = mExternal.Exists(strbookmark)
End Property

Property Get PrefixIsUsed(ByVal strprefix As String, Optional ByVal blincludeexternals As Boolean = False) As Boolean
    Dim dicbkm As Scripting.Dictionary, varbkmark As Variant
    Call RefreshBookmarks
    If blincludeexternals Then
        Set dicbkm = mAll
    Else
        Set dicbkm = mInternal
    End If
    If mParent.Parent.BookmarkConfig.Prefixes.Exists(strprefix) Then
        If mParent.Parent.BookmarkConfig.Prefix(strprefix).HasUnderscore Then
            strprefix = strprefix & "_"
        End If
    End If
    For Each varbkmark In dicbkm
        If varbkmark Like strprefix & "*" Then
            PrefixIsUsed = True
            Exit For
        End If
    Next varbkmark
End Property

Sub Add(ByVal strbookname As String, ByRef rng As Range)
' The main purpose of this method is to allow the bookmark dictionaries to be in sync with the document's bookmark
' collection, so we don't need to rebuild the dictionaries each time - this improves performance
    Dim bmark As Bookmark, tbl As Table
    If mAll Is Nothing Then Call RefreshBookmarks ' sanity check - in case bookmark is added before dictionary built for the first time
    Set bmark = rng.Document.Bookmarks.Add(strbookname, rng) ' add to document object first, note that this also moves the bookmark if it exists
    Call ValidateDocExtRefsTable(mParent.Document, tbl, , True)
    Call ProcessBookmark(bmark, tbl) ' note this will add the new bookmark at the end of the dictionary - so it won't be in sequence
    If mExternal.Exists(strbookname) Then
        ' external bookmark added, so update checksum
        mExtRefTableChecksum = GetTableChecksum(mParent.Document, Const_DOCTBL_EXTREFERENCES)
    End If
    mBuildTimestamp = Now()
End Sub

Sub Delete(ByVal strbookmark As String)
' The main purpose of this method is to allow the bookmark dictionaries to be in sync with the document's bookmark
' collection, so we don't need to rebuild the dictionaries each time - this improves performance
    If mAll Is Nothing Then Call RefreshBookmarks ' sanity check - in case bookmark is deleted before dictionary built for the first time
    If mParent.Document.Bookmarks.Exists(strbookmark) Then mParent.Document.Bookmarks(strbookmark).Delete ' delete from document object first, if it exists
    If mAll.Exists(strbookmark) Then mAll.Remove strbookmark
    If mInternal.Exists(strbookmark) Then mInternal.Remove strbookmark
    If mExternal.Exists(strbookmark) Then
        mExternal.Remove strbookmark
        ' external bookmark removed, so update checksum
        mExtRefTableChecksum = GetTableChecksum(mParent.Document, Const_DOCTBL_EXTREFERENCES)
    End If
    mBuildTimestamp = Now()
End Sub

Sub RebuildBookmarks()
    mExtRefTableChecksum = vbNullString ' this will trigger a rebuild
End Sub

Private Sub RefreshBookmarks()
    Dim blcountchange As Boolean, blchecksumchange As Boolean, bmark As Bookmark, tbl As Table, strmessage As String, lngduration As Long
On Error GoTo Err_RefreshBookmarks
        
    If Not mAll Is Nothing Then blcountchange = (mAll.Count <> mParent.Document.Bookmarks.Count)
    blchecksumchange = (mExtRefTableChecksum <> GetTableChecksum(mParent.Document, Const_DOCTBL_EXTREFERENCES))
    
    ' trigger update if objects still empty or if the bookmark count changed (e.g. user added/removed bookmark manually) or if external references were updated
    If blcountchange Or blchecksumchange Or mAll Is Nothing Or mInternal Is Nothing Or mExternal Is Nothing Then
        ' re-process the bookmarks
        lngduration = Timer()
        Call ClearBookmarkDictionaries
        Set mAll = New Scripting.Dictionary
        Set mInternal = New Scripting.Dictionary
        Set mInternalTraceable = New Scripting.Dictionary
        Set mExternal = New Scripting.Dictionary
    
        ' get the reference to the external references table
        If Not ValidateDocExtRefsTable(mParent.Document, tbl, strmessage, True) Then
            MsgBox strmessage, vbExclamation
        End If

        ' Populate the bookmarks dictionaries - sequentially ordered
        ' NOTE: Looping through the bookmark collection using the Range object gives them in sequencial order,
        '       looping through the collection using the Document object lists them in alphabetical order
        For Each bmark In mParent.Document.Range.Bookmarks
            Call ProcessBookmark(bmark, tbl)
        Next bmark
        
        ' update time updated and external references checksum
        mExtRefTableChecksum = GetTableChecksum(mParent.Document, Const_DOCTBL_EXTREFERENCES)
        mBuildTimestamp = Now()
        mBuildDuration = Timer() - lngduration
    End If
    
Exit_RefreshBookmarks:
    Exit Sub

Err_RefreshBookmarks:
    MsgBox Err.Description & " in RefreshBookmarks() of cDocBookmarks"
    Resume Exit_RefreshBookmarks
End Sub
 
Private Sub ProcessBookmark(ByRef docbkm As Bookmark, ByRef tblextref As Table)
    Dim bkm As cDocBookmark, rng As Range, blsaved As Boolean, blallcaps As Boolean, blexternal As Boolean
On Error GoTo Err_ProcessBookmark

    Set rng = docbkm.Range ' TextRetrievalMode object below wants lowest level range reference
    ' turn off allcaps so we get the real text (e.g. bookmark applied to Heading 1 text) and restore it afterwards
    ' NOTE: this somehow touches the document, so the state needs to be restored to what it was before
    blsaved = rng.Document.Saved
    blallcaps = rng.Font.AllCaps
    rng.Font.AllCaps = False
    rng.TextRetrievalMode.IncludeHiddenText = True
    
    ' check for external bookmark
    If Not tblextref Is Nothing Then blexternal = rng.InRange(tblextref.Range)
    
    ' create new bookmark object and add it to the associated dictionaries
    Set bkm = New cDocBookmark
    bkm.Name = docbkm.Name
    bkm.Prefix = mParent.Parent.BookmarkConfig.PrefixFromName(bkm.Name)
    bkm.Text = rng.Text
    bkm.Position = rng.Start
    bkm.Heading = GetHeadingNumber(rng)
    If blexternal Then
        bkm.SourceDocument = rng.Next(wdCell).Hyperlinks(1).Address ' we can safely assume that hyperlink exists because the DST would have added it
    Else
        bkm.SourceDocument = mParent.Properties.Shortname
    End If
    
    UpdateBookmark mAll, bkm
    If blexternal Then
        UpdateBookmark mExternal, bkm
    Else
        UpdateBookmark mInternal, bkm
        If mParent.Parent.TrcConfig.PrefixTracesDocType(mParent.Properties.TypeAbbr).Exists(bkm.Prefix) Then UpdateBookmark mInternalTraceable, bkm
    End If
    
Exit_ProcessBookmark:
    ' restore original settings
    rng.Font.AllCaps = blallcaps
    rng.Document.Saved = blsaved
    Exit Sub

Err_ProcessBookmark:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in ProcessBookmark() of cDocBookmarks"
    Resume Exit_ProcessBookmark
End Sub
  
Private Sub UpdateBookmark(ByRef dicbkm As Scripting.Dictionary, ByRef bkm As cDocBookmark)
    If Not dicbkm.Exists(bkm.Name) Then
        dicbkm.Add bkm.Name, bkm
    Else
        Set dicbkm(bkm.Name) = bkm ' this effectlively 'moves' the bookmark if it already exists
    End If
End Sub

Private Sub ClearBookmarkDictionaries()
    Set mAll = Nothing
    Set mInternal = Nothing
    Set mInternalTraceable = Nothing
    Set mExternal = Nothing
    mBuildTimestamp = 0
End Sub

Private Sub Class_Terminate()
    Set mParent = Nothing
    Call ClearBookmarkDictionaries
End Sub
Attribute VB_Name = "cDocInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mParent As cDst ' Reference to parent DST object
Private mDocObj As Document
Private mDocVisible As Boolean
Private mDocSavedInSession As Boolean
Private mDocProps As cDocProps
Private mDocVars As cDocVars
Private mDocBookmarks As cDocBookmarks
Private mDocList As cDocList

Property Get Parent() As cDst
    Set Parent = mParent
End Property

Property Set Parent(refparent As cDst)
    Set mParent = refparent
End Property

Property Get Document() As Document
    Set Document = mDocObj
End Property

Property Get DocVisible() As Boolean
    DocVisible = mDocVisible
End Property

Property Let DocVisible(blvisible As Boolean)
    mDocVisible = blvisible
End Property

Property Get DocSavedInSession() As Boolean
    DocSavedInSession = mDocSavedInSession
End Property

Property Let DocSavedInSession(blsaved As Boolean)
    mDocSavedInSession = blsaved
End Property

Property Get Properties() As cDocProps
    Set Properties = mDocProps
End Property

Property Get Variables() As cDocVars
    Set Variables = mDocVars
End Property

Property Get Bookmarks() As cDocBookmarks
    Set Bookmarks = mDocBookmarks
End Property

Property Get DocList() As cDocList
    Set DocList = mDocList
End Property

Sub ProcessDocument(ByRef objdoc As Document)
    ' associate this object with the given document object and also with its children objects
    Set mDocObj = objdoc
    Set mDocProps.Parent = Me
    Set mDocVars.Parent = Me
    Set mDocBookmarks.Parent = Me
    Set mDocList.Parent = Me
End Sub

Private Sub Class_Initialize()
    Set mDocProps = New cDocProps
    Set mDocVars = New cDocVars
    Set mDocBookmarks = New cDocBookmarks
    Set mDocList = New cDocList
End Sub

Private Sub Class_Terminate()
    Set mDocObj = Nothing
    Set mDocProps = Nothing
    Set mDocVars = Nothing
    Set mDocBookmarks = Nothing
    Set mDocList = Nothing
End Sub
Attribute VB_Name = "cDocList"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Type TrcDocListType
    Filename As String
    Documents As Scripting.Dictionary ' of filenames (key=value)
    Checksum As String ' of table that defines the document list
    TableRef As Table ' reference to the document list table in the Word document
    NotValid As Scripting.Dictionary ' of files listed but not valid (key=value)
    NotListed As Scripting.Dictionary ' of files found but not listed (key=value)
End Type

Private mParent As cDocInfo ' reference to parent Document Info object
Private mTrcDocList As TrcDocListType ' list of TRC related documents, based on table in TRCR document
Private mAllDocList As Scripting.Dictionary ' of filenames (key=value), based on known documents found beneath the TRCR tree structure
Private mTypeMetrics As Scripting.Dictionary ' keyed by document type, values give counts of each type in document list
Private mSubTypeMetrics As Scripting.Dictionary ' of dictionaries keyed by document type, sub-dictionaries keyed by subtype, values give counts of each subtype

Property Get Parent() As cDocInfo
    Set Parent = mParent
End Property

Property Set Parent(docinfo As cDocInfo)
    Set mParent = docinfo
End Property

Property Get TrcSourceFile() As String
    Call RefreshDocLists
    TrcSourceFile = mTrcDocList.Filename
End Property

Property Get TrcDocuments() As Scripting.Dictionary
    Call RefreshDocLists
    Set TrcDocuments = mTrcDocList.Documents
End Property

Property Get TrcDocumentsNotValid() As Scripting.Dictionary
    Set TrcDocumentsNotValid = mTrcDocList.NotValid
End Property

Property Get TrcDocumentsNotInList() As Scripting.Dictionary
    Set TrcDocumentsNotInList = mTrcDocList.NotListed
End Property

Property Get AllDocuments() As Scripting.Dictionary
    Call RefreshDocLists
    Set AllDocuments = mAllDocList
End Property

Property Get SubTypesForTypeAsDictionary(ByVal strtype As String) As Scripting.Dictionary
    If Not mSubTypeMetrics.Exists(strtype) Then strtype = Const_TEXT_UNKNOWN
    Set SubTypesForTypeAsDictionary = mSubTypeMetrics(strtype)
End Property

Property Get MetricsAsText() As String
    Dim vardoctype As Variant, numdocs As Integer
    Call CalculateDocListTypeMetrics ' make sure it's up-to-date
    For Each vardoctype In mTypeMetrics
        MetricsAsText = AddStatusText(MetricsAsText, vardoctype & ": " & mTypeMetrics(vardoctype))
        numdocs = numdocs + mTypeMetrics(vardoctype)
        If mSubTypeMetrics.Exists(vardoctype) Then
            MetricsAsText = AddStatusText(MetricsAsText, GetDictionaryAsText(mSubTypeMetrics(vardoctype), True, False, "  "))
        End If
    Next vardoctype
    MetricsAsText = AddStatusText("Total number of documents: " & numdocs, vbCrLf & MetricsAsText)
    MetricsAsText = AddStatusText(MetricsAsText, vbCrLf & "NOTE: Subtype metrics are only recalculated when validating the document list")
End Property

Function TrcDocAdd(ByVal strfilename As String) As Cell
    Dim cel As Cell, fso As New FileSystemObject
    ' add new row and select first cell in it
    With mTrcDocList.TableRef
        .Rows.Add
        Set cel = .Cell(.Rows.Count, 1)
    End With
    Call InsertHyperlinkWithTextInCell(cel, fso.GetParentFolderName(mTrcDocList.Filename), strfilename, fso.GetFileName(strfilename))
    cel.Select
    Set TrcDocAdd = cel
End Function

Sub TrcDocRemove(ByVal strfilename As String)
    Dim cel As Cell, fso As New FileSystemObject
    For Each cel In mTrcDocList.TableRef.Columns(1).Cells
        If cel.Range.Hyperlinks.Count > 0 Then
            If strfilename = fso.GetAbsolutePathName(fso.BuildPath(fso.GetParentFolderName(mTrcDocList.Filename), cel.Range.Hyperlinks(1).Address)) Then
                Call DeleteTabeSubRows(cel)
                cel.Delete wdDeleteCellsEntireRow ' delete main row as well
                Exit For
            End If
        Else
            If strfilename = BuildInvalidHyperlinkText(cel) Then
                Call DeleteTabeSubRows(cel)
                cel.Delete wdDeleteCellsEntireRow ' delete main row as well
                Exit For
            End If
        End If
    Next cel
    mTrcDocList.TableRef.Cell(1, 1).Select
End Sub

Sub RefreshDocLists(Optional ByVal blforcerefresh As Boolean = False)
    Dim strprevfile As String, strchecksum As String, strmessage As String
    Dim objdoclist As Document, blalldocslistupdated As Boolean
    
    ' store previous TRCR filename so we can detect whether it changed
    strprevfile = mTrcDocList.Filename
    
    ' make sure we have a valid document list filename
    mTrcDocList.Filename = GetDocListFilename
    If mTrcDocList.Filename <> vbNullString Then
        ' get checksum of summary table used as TRC document list source - this indirectly also checks that the table exists
        Set objdoclist = mParent.Parent.Document(mTrcDocList.Filename).Document
        strchecksum = GetTableChecksum(objdoclist, Const_DOCTBL_TRCSUMMARY_BYDOC, strmessage)
        If strmessage = vbNullString Then
            ' check if the checksum changed since it was last processed or if we have a new document list filename, or if forced
            If strchecksum <> mTrcDocList.Checksum Or strprevfile <> mTrcDocList.Filename Or blforcerefresh Then
                ' update the list of all documents found and refresh the TRC document list
                Call GetDocumentsFound(objdoclist.Path, mAllDocList)
                blalldocslistupdated = True
                Call RefreshTrcDocList(GetTable(objdoclist, Const_DOCTBL_TRCSUMMARY_BYDOC), strchecksum, mAllDocList) ' assume table exists because we got its checksum
            End If
        Else
            Call ResetTrcDocListData
            MsgBox "Unable to determine TRC document list - " & strmessage, vbExclamation
        End If
        
        ' build the complete document list only when necessary
        If Not blalldocslistupdated And (mAllDocList.Count = 0 Or blforcerefresh) Then
            Call GetDocumentsFound(objdoclist.Path, mAllDocList)
        End If
    Else
        Call ResetTrcDocListData
        mAllDocList.RemoveAll
    End If
End Sub
 
Private Function GetDocListFilename() As String
    Dim fso As FileSystemObject, fld As Folder, subfld As Folder, strstatus As String, strfilename As String
    
    ' search for TRCR in current document's folder first and only beneath a projects folder structure and within a 'doc' folder
    Set fso = New FileSystemObject
    Set fld = fso.GetFolder(mParent.Properties.Path)
    If InStr(1, fld.Path, "\projects\", vbTextCompare) > 0 Then
        strstatus = FindTRCRInDocFolder(fld, strfilename)
        If strstatus = vbNullString Then
            ' if not found, search decursively, but only until we hit the user's 'projects' folder
            While strfilename = vbNullString And LCase(fld.Name) <> "projects" And Not fld.ParentFolder.ParentFolder Is Nothing
                Set fld = fld.ParentFolder
                ' look in the parent sub-folders decursively
                For Each subfld In fld.ParentFolder.SubFolders
                    strstatus = FindTRCRInDocFolder(subfld, strfilename)
                    If strstatus <> vbNullString Or strfilename <> vbNullString Then
                        Exit For
                    End If
                Next subfld
            Wend
        End If
        
        If strstatus <> vbNullString Then
            MsgBox strstatus, vbExclamation
            strfilename = vbNullString
        End If
    End If
    GetDocListFilename = strfilename
End Function
 
Private Function FindTRCRInDocFolder(ByRef fld As Folder, ByRef strfilename As String) As String
    Dim fil As File, strstatus As String
    If fld.Name = "doc" Then
        For Each fil In fld.Files
            If GetDocTypeFromFilename(fil.Name) = "TRCR" Then
                If strfilename = vbNullString Then
                    strfilename = fil.Path
                Else
                    strstatus = "Multiple TRCR documents found in folder '" & fld.Path & "' - only one is allowed"
                    Exit For
                End If
            End If
        Next fil
    End If
    FindTRCRInDocFolder = strstatus
End Function

Private Sub RefreshTrcDocList(ByRef tbltrc As Table, ByVal strchecksum As String, ByRef dicalldocs As Scripting.Dictionary)
    Dim cel As Cell, strtrcrpath As String, strfilename As String
    Dim strdoctype As String, varitem As Variant
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    ' reset the data before we start
    Call ResetTrcDocListData
                
    ' build the TRC document list based on the given table, ignore documents that are not related to TRC,
    ' also build the list of documents not found on disk
    strtrcrpath = fso.GetParentFolderName(mTrcDocList.Filename)
    For Each cel In tbltrc.Columns(1).Cells
        If cel.RowIndex > 1 Then
            If cel.Range.Hyperlinks.Count > 0 Then
                strfilename = fso.GetAbsolutePathName(fso.BuildPath(strtrcrpath, cel.Range.Hyperlinks(1).Address))
                strdoctype = GetDocTypeFromFilename(strfilename)
                If mParent.Parent.TrcConfig.IsTRCDocType(strdoctype) Then
                    If fso.FileExists(strfilename) Then
                        mTrcDocList.Documents.Add strfilename, strfilename
                    Else
                        mTrcDocList.NotValid.Add strfilename, strfilename
                    End If
                Else
                    mTrcDocList.NotValid.Add strfilename, strfilename
                End If
            Else
                varitem = BuildInvalidHyperlinkText(cel)
                If varitem <> vbNullString Then mTrcDocList.NotValid.Add varitem, varitem
            End If
        End If
    Next cel
                                        
    ' add those documents beneath the document list file path that may have traceable items to the "not in" list, if they are
    ' not in the TRC document list already
    For Each varitem In dicalldocs
        strdoctype = GetDocTypeFromFilename(varitem)
        ' if not in the list, but it may have traceable items
        If Not mTrcDocList.Documents.Exists(varitem) And _
           mParent.Parent.TrcConfig.IsTRCDocType(strdoctype) Then
            mTrcDocList.NotListed.Add varitem, varitem
        End If
    Next varitem
    
    ' sort the dictionaries
    Set mTrcDocList.Documents = SortDictionary(mTrcDocList.Documents)
    Set mTrcDocList.NotValid = SortDictionary(mTrcDocList.NotValid)
    Set mTrcDocList.NotListed = SortDictionary(mTrcDocList.NotListed)
    
    ' set the reference to the table used and its checksum in order to monitor changes
    Set mTrcDocList.TableRef = tbltrc
    mTrcDocList.Checksum = strchecksum

End Sub
  
Private Function BuildInvalidHyperlinkText(ByRef cel As Cell) As String
    Dim strtext As String
    strtext = GetCellText(cel)
    If strtext <> vbNullString Then strtext = "Row " & cel.RowIndex & ": " & strtext
    BuildInvalidHyperlinkText = strtext
End Function

Private Sub GetDocumentsFound(ByVal strtrcrpath As String, ByRef dicdocs As Scripting.Dictionary)
    Dim dicdocsfound As Scripting.Dictionary, varitem As Variant, strfolder As String
    Dim dictrcrs As Scripting.Dictionary, vartrcr As Variant, strdoctype As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    ' find documents beneath the given TRCR path
    ' NOTE: ignore branches that have their own TRCR documents
    dicdocs.RemoveAll
    Set dicdocsfound = New Scripting.Dictionary
    Set dictrcrs = New Scripting.Dictionary
    Call FindFilePatterns(fso.GetParentFolderName(strtrcrpath), "\doc\", "*.doc*", dicdocsfound)
    ' first extract any other TRCR documents - we only need the 'branch' path
    For Each varitem In dicdocsfound
        If varitem <> mTrcDocList.Filename And GetDocTypeFromFilename(varitem) = "TRCR" Then
            strfolder = fso.GetParentFolderName(fso.GetParentFolderName(varitem))
            If Not dictrcrs.Exists(strfolder) Then
                dictrcrs.Add strfolder, vbNullString
            End If
        End If
    Next varitem
    For Each varitem In dicdocsfound
        strdoctype = GetDocTypeFromFilename(varitem)
        ' if known document type
        If mParent.Parent.BookmarkConfig.DocTypes.Exists(strdoctype) Then
            If dictrcrs.Count = 0 Then ' no other TRCRs, so just add it
                dicdocs.Add varitem, varitem
            Else
                ' check that document not under other TRCR branches
                For Each vartrcr In dictrcrs
                    If Not varitem Like vartrcr & "\*" Then
                        dicdocs.Add varitem, varitem
                    End If
                Next vartrcr
            End If
        End If
    Next varitem
    
End Sub
    
Private Sub ResetTrcDocListData()
    Set mTrcDocList.TableRef = Nothing
    mTrcDocList.Checksum = vbNullString
    mTrcDocList.Documents.RemoveAll
    mTrcDocList.NotValid.RemoveAll
    mTrcDocList.NotListed.RemoveAll
End Sub

Function Validate() As String
    Dim strstatus As String, docinfo As cDocInfo, strshortname As String
    Dim varitem As Variant, fso As FileSystemObject, dicshortnames As Scripting.Dictionary
On Error GoTo Err_Validate

    Set fso = New FileSystemObject
    
    ' force a refresh of the document list data
    Call RefreshDocLists(True)
    
    ' update metrics
    Call CalculateDocListTypeMetrics
    Call CalculateDocListSubTypeMetrics
    
    Set dicshortnames = New Scripting.Dictionary
    For Each varitem In mAllDocList
        Set docinfo = mParent.Parent.Document(varitem)
        
        ' check that shortnames are unique
        strshortname = docinfo.Properties.Shortname
        If dicshortnames.Exists(strshortname) Then
            strstatus = BuildStatusMessage(strstatus, strshortname, "File shortnames must be unique - '" & dicshortnames(strshortname) & "' already defined", vbNullString)
        Else
            dicshortnames.Add strshortname, docinfo.Properties.Fullname
        End If
        
        ' perform document type specific checks
        Select Case docinfo.Properties.TypeAbbr
            Case "STD", "STR"
                ' Each STD and STR must have at least one of subtype defined
                If docinfo.Properties.SubTypesAsDictionary.Count = 0 Then
                    strstatus = BuildStatusMessage(strstatus, strshortname, "No valid subtypes defined", "?")
                End If
                
                ' If the notests element is defined, then none of the other elements may be defined for the same document
                If docinfo.Properties.SubTypesAsDictionary.Exists("notests") Then
                    If docinfo.Properties.SubTypesAsDictionary.Count <> 1 Then
                        strstatus = BuildStatusMessage(strstatus, strshortname, "Subtype may not coexist with others", "notests")
                    End If
                End If
                                       
                If docinfo.Properties.TypeAbbr = "STR" Then
                    ' Each hltests, lltests, hlstructcov and llstructcov STR shall have a corresponding STD of the same sub-type, except if
                    ' the STR has the orphaned element defined
                    Call ValidateSTRToSTDRelationship(docinfo, strstatus)
                    
                    ' The summary element may not be defined in the same STR as the detailed element if there are multiple detailed elements
                    Call ValidateSummaryCoexistence(docinfo, "hltestssum", "hltests", strstatus)
                    Call ValidateSummaryCoexistence(docinfo, "lltestssum", "lltests", strstatus)
                    Call ValidateSummaryCoexistence(docinfo, "hlstructcovsum", "hlstructcov", strstatus)
                    Call ValidateSummaryCoexistence(docinfo, "llstructcovsum", "llstructcov", strstatus)
                End If
                                    
            Case "TRCR"
                If NumTypes("TRCR") > 1 Then
                    strstatus = BuildStatusMessage(strstatus, strshortname, "Multiple TRCR documents found in the document tree - only one is allowed", "")
                End If
                
            Case Else
                ' no other rules defined yet
        End Select
    Next varitem
    
    ' The summary element:
    '    - Must be defined if one or more associated detailed STRs are defined
    '    - May only be defined if one or more associated detailed STRs are defined
    '    - May only be defined in one STR
    '    - May only be defined in STRs (not implemented as invalid subtypes are filtered out when the doclist is processed)
    Call ValidateSummaryConsistency("STR", "hltestssum", "hltests", strstatus)
    Call ValidateSummaryConsistency("STR", "lltestssum", "lltests", strstatus)
    Call ValidateSummaryConsistency("STR", "hlstructcovsum", "hlstructcov", strstatus)
    Call ValidateSummaryConsistency("STR", "llstructcovsum", "llstructcov", strstatus)
    
    ' The hlstructcov element may only be only be defined in one STR/STD
    Call ValidateSummaryConsistency("STR", "hlstructcov", vbNullString, strstatus)
    Call ValidateSummaryConsistency("STD", "hlstructcov", vbNullString, strstatus)
    
    ' The sa element may only be defined in one STR
    Call ValidateSummaryConsistency("STR", "sa", vbNullString, strstatus)
       
    ' prepend the document list filename if there are errors
    If strstatus <> vbNullString Then
        strstatus = "Document list has validation errors:" & vbCrLf & strstatus
    End If
    
    Validate = strstatus
    
Exit_Validate:
    Exit Function

Err_Validate:
    MsgBox Err.Description & " in Validate() of cDocList"
    Resume Exit_Validate
End Function
    
Private Sub InitSubTypeMetrics()
    Dim varsubtypes As Variant, varitem As Variant, dicsubtypes As Scripting.Dictionary
    
    ' set up a dictionary of dictionaries containing metrics for each document type and its allowed subtypes
    ' NOTE: This object should always be used to validate type/subtype combinations
    ' STDs
    mSubTypeMetrics.RemoveAll
    Set dicsubtypes = New Scripting.Dictionary
    varsubtypes = Array("notests", _
                        "hltests", "lltests", _
                        "hlstructcov", "llstructcov")
    For Each varitem In varsubtypes
        dicsubtypes.Add varitem, 0
    Next varitem
    mSubTypeMetrics.Add "STD", dicsubtypes
    
    ' STRs
    Set dicsubtypes = New Scripting.Dictionary
    varsubtypes = Array("notests", "sa", _
                        "hltests", "hltestssum", "lltests", "lltestssum", _
                        "hlstructcov", "hlstructcovsum", "llstructcov", "llstructcovsum")
    For Each varitem In varsubtypes
        dicsubtypes.Add varitem, 0
    Next varitem
    mSubTypeMetrics.Add "STR", dicsubtypes
    
    ' SDDs
    Set dicsubtypes = New Scripting.Dictionary
    varsubtypes = Array("toplevel", "detailed")
    For Each varitem In varsubtypes
        dicsubtypes.Add varitem, 0
    Next varitem
    mSubTypeMetrics.Add "SDD", dicsubtypes

    ' Unknown
    Set dicsubtypes = New Scripting.Dictionary
    mSubTypeMetrics.Add Const_TEXT_UNKNOWN, dicsubtypes

End Sub

Private Sub CalculateDocListTypeMetrics()
    Dim vardoc As Variant, strtype As String
    mTypeMetrics.RemoveAll
    For Each vardoc In mAllDocList
        strtype = GetDocTypeFromFilename(vardoc)
        If strtype <> vbNullString Then
            If Not mTypeMetrics.Exists(strtype) Then mTypeMetrics.Add strtype, 0
            mTypeMetrics(strtype) = mTypeMetrics(strtype) + 1
        End If
    Next vardoc
End Sub

Private Function NumTypes(ByVal strtype As String) As Integer
    NumTypes = mTypeMetrics(strtype)
End Function
    
Private Sub CalculateDocListSubTypeMetrics()
    Dim vardoc As Variant, docinfo As cDocInfo, dicmetrics As Scripting.Dictionary
    Dim strtype As String, varsubtype As Variant
    
    ' update subtype metrics for preset configuration
    Call InitSubTypeMetrics
    For Each vardoc In mAllDocList
        Set docinfo = mParent.Parent.Document(vardoc) ' this will open the document if it is not opwn already
        strtype = docinfo.Properties.TypeAbbr
        If mSubTypeMetrics.Exists(strtype) Then
            Set dicmetrics = mSubTypeMetrics(strtype) ' this is the metrics configuration
            For Each varsubtype In docinfo.Properties.SubTypesAsDictionary
                ' increment configuration count if it exists
                If dicmetrics.Exists(varsubtype) Then
                    dicmetrics(varsubtype) = dicmetrics(varsubtype) + 1
                End If
            Next varsubtype
        End If
    Next vardoc
    
End Sub

Private Function NumSubTypes(ByVal strtype As String, ByVal strsubtype As String) As Integer
    Dim dicsubtype As Scripting.Dictionary
    Set dicsubtype = mSubTypeMetrics(strtype)
    NumSubTypes = dicsubtype(strsubtype)
End Function
    
Private Sub ValidateSummaryConsistency(ByVal strtype As String, ByVal strsummary As String, ByVal strdetail As String, ByRef strstatus As String)
    
    If NumSubTypes(strtype, strsummary) > 1 Then
        strstatus = BuildStatusMessage(strstatus, strtype, "Report defined " & NumSubTypes(strtype, strsummary) & " times - it may not be defined more than once", strsummary)
    End If
    
    If strdetail <> vbNullString Then
        If NumSubTypes(strtype, strdetail) >= 1 And NumSubTypes(strtype, strsummary) = 0 Then
            strstatus = BuildStatusMessage(strstatus, strtype, "One or more detailed reports defined - a corresponding summary report also needs to be defined", strdetail, strsummary)
        End If
        
        If NumSubTypes(strtype, strdetail) = 0 And NumSubTypes(strtype, strsummary) = 1 Then
            strstatus = BuildStatusMessage(strstatus, strtype, "Summary report defined - corresponding detailed report(s) also need to be defined", strsummary, strdetail)
        End If
    End If
    
End Sub

Private Sub ValidateSTRToSTDRelationship(ByRef docinfo As cDocInfo, ByRef strstatus As String)
    Dim varsubtypes As Variant, varitem As Variant, strstdfilename As String, fso As FileSystemObject
    
    Set fso = New FileSystemObject
            
    varsubtypes = Array("hltests", "lltests", _
                        "hlstructcov", "llstructcov")
    
    ' determine STD filename from given STR
    strstdfilename = GetSTDFileNameFromSTR(docinfo.Properties.Fullname)
                        
    For Each varitem In varsubtypes
        If docinfo.Properties.SubTypesAsDictionary.Exists(varitem) Then
            If Not docinfo.Properties.IsOrphaned Then
                If Not mAllDocList.Exists(strstdfilename) Then
                    strstatus = BuildStatusMessage(strstatus, docinfo.Properties.Shortname, "Corresponding STD not defined", fso.GetFileName(strstdfilename))
                Else
                    If Not docinfo.Properties.SubTypesAsDictionary.Exists(varitem) Then
                        strstatus = BuildStatusMessage(strstatus, docinfo.Properties.Shortname, "Corresponding STD does not have corresponding subtype defined", fso.GetFileName(strstdfilename), varitem)
                    End If
                End If
            Else
                If mAllDocList.Exists(strstdfilename) Then
                    strstatus = BuildStatusMessage(strstatus, docinfo.Properties.Shortname, "STR defined as oprhaned, but corresponding STD is defined", fso.GetFileName(strstdfilename))
                End If
            End If
        End If
    Next varitem
    
End Sub

Private Sub ValidateSummaryCoexistence(ByRef docinfo As cDocInfo, ByVal strsummary As String, ByVal strdetail As String, ByRef strstatus As String)
    If docinfo.Properties.SubTypesAsDictionary.Exists(strsummary) And _
       docinfo.Properties.SubTypesAsDictionary.Exists(strdetail) And _
       NumSubTypes(docinfo.Properties.TypeAbbr, strdetail) > 1 Then
        strstatus = BuildStatusMessage(strstatus, docinfo.Properties.Shortname, "Summary and detailed reports may not be defined in the same STR if multiple detailed reports are defined", strsummary, strdetail)
    End If
End Sub

Private Function BuildStatusMessage(ByVal strstatus As String, ByVal strdocname As String, ByVal strerror As String, ByVal strsubtype1 As String, Optional ByVal strsubtype2 As String) As String
    BuildStatusMessage = strstatus & "Entry '" & strdocname & "': " & strerror & IIf(strsubtype1 <> vbNullString, " (" & strsubtype1 & IIf(strsubtype2 <> vbNullString, ", " & strsubtype2, vbNullString) & ")", vbNullString) & vbCrLf
End Function

Private Sub Class_Initialize()
    Set mTrcDocList.Documents = New Scripting.Dictionary
    Set mTrcDocList.NotValid = New Scripting.Dictionary
    Set mTrcDocList.NotListed = New Scripting.Dictionary
    Set mAllDocList = New Scripting.Dictionary
    Call ResetTrcDocListData
    Set mTypeMetrics = New Scripting.Dictionary
    Set mSubTypeMetrics = New Scripting.Dictionary
    Call InitSubTypeMetrics
End Sub

Private Sub Class_Terminate()
    Set mTrcDocList.Documents = Nothing
    Set mTrcDocList.TableRef = Nothing
    Set mTrcDocList.NotValid = Nothing
    Set mTrcDocList.NotListed = Nothing
    Set mAllDocList = Nothing
    Set mTypeMetrics = Nothing
    Set mSubTypeMetrics = Nothing
End Sub
Attribute VB_Name = "cDocProps"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Reference to parent Document Info object
' NOTE: this class is designed not to use any local storage other than a document info object reference
Private mParent As cDocInfo
  
Property Get Parent() As cDocInfo
    Set Parent = mParent
End Property

Property Set Parent(docinfo As cDocInfo)
    Set mParent = docinfo
End Property

Property Get DateLastModified() As Date
    Dim fso As New FileSystemObject
    DateLastModified = fso.GetFile(Fullname).DateLastModified
End Property

Property Get DateCreated() As Date
    Dim fso As New FileSystemObject
    DateCreated = fso.GetFile(Fullname).DateCreated
End Property

' =====================================================================================================================
' Custom Document Property Names
' =====================================================================================================================
Property Get PropertyNameClassification() As String
    PropertyNameClassification = "DstClassification"
End Property

Property Get PropertyNameDate() As String
    PropertyNameDate = "DstDate"
End Property

Property Get PropertyNameLocation() As String
    PropertyNameLocation = "DstLocation"
End Property

Property Get PropertyNameNumber() As String
    PropertyNameNumber = "DstNumber"
End Property

Property Get PropertyNameIssue() As String
    PropertyNameIssue = "DstIssue"
End Property

Property Get PropertyNameType() As String
    PropertyNameType = "DstType"
End Property

Property Get PropertyNameSubTypes() As String
    PropertyNameSubTypes = "DstSubTypes"
End Property

Property Get PropertyNameProgramme() As String
    PropertyNameProgramme = "DstProgramme"
End Property

Property Get PropertyNameProject() As String
    PropertyNameProject = "DstProject"
End Property

Property Get PropertyNameCsci() As String
    PropertyNameCsci = "DstCsci"
End Property

Property Get PropertyNameAppendix() As String
    PropertyNameAppendix = "DstAppendix"
End Property

Property Get PropertyNameOrphaned() As String
    PropertyNameOrphaned = "DstOrphaned"
End Property

Property Get PropertyNameVersion() As String
    PropertyNameVersion = "DstVersion"
End Property

' =====================================================================================================================
' User Functions to Access Document Properties
' =====================================================================================================================
Property Get Fullname() As String
    Fullname = mParent.Document.Fullname
End Property

Property Get Shortname() As String
    Shortname = mParent.Document.Name
End Property

Property Get Basename() As String
    Dim fso As New FileSystemObject
    Basename = fso.GetBaseName(Shortname)
End Property

Property Get Path() As String
    Path = mParent.Document.Path
End Property

Property Get Extension() As String
    Dim fso As New FileSystemObject
    Extension = fso.GetExtensionName(Shortname)
End Property

Property Get DocID() As String
    On Error Resume Next
    DocID = Const_TEXT_UNKNOWN
    DocID = UCase(Split(Basename, "_", 2)(1)) ' the portion after the first underscore is the document ID
End Property

Property Get TypeAbbr(Optional ByVal strdocname As String = vbNullString) As String
    If strdocname = vbNullString Then strdocname = mParent.Document.Name
    TypeAbbr = mParent.Parent.BookmarkConfig.ValidDocumentType(GetDocTypeFromFilename(strdocname))
End Property

Property Get Classification() As String
    Classification = CustomGet(PropertyNameClassification)
End Property

Property Let Classification(strvalue As String)
    Call CustomCreate(PropertyNameClassification, strvalue)
End Property

Property Get DocDate() As String
    DocDate = CustomGet(PropertyNameDate)
End Property

Property Let DocDate(strvalue As String)
    Call CustomCreate(PropertyNameDate, strvalue)
End Property

Property Get Location() As String
    Dim idx As Integer, strproject As String
    Location = CustomGet(PropertyNameLocation)
    If Location = " " Or (Left(Location, Len(Const_INSTR_START)) = Const_INSTR_START And Right(Location, Len(Const_INSTR_END)) = Const_INSTR_END) Then
        strproject = "\projects\"
        idx = InStr(1, Fullname, strproject, vbTextCompare)
        If idx Then
            Me.Location = Right(Fullname, Len(Fullname) - (idx + Len(strproject) - 1))
        End If
    End If
End Property

Property Let Location(strvalue As String)
    Call CustomCreate(PropertyNameLocation, strvalue)
End Property

Property Get Number() As String
    Number = CustomGet(PropertyNameNumber)
End Property

Property Let Number(strvalue As String)
    Call CustomCreate(PropertyNameNumber, strvalue)
End Property

Property Get Issue() As String
    Issue = CustomGet(PropertyNameIssue)
End Property

Property Let Issue(strvalue As String)
    Call CustomCreate(PropertyNameIssue, strvalue)
End Property

Property Get TypeText() As String
    TypeText = CustomGet(PropertyNameType)
End Property

Property Let TypeText(strvalue As String)
    Call CustomCreate(PropertyNameType, strvalue)
End Property

Property Get SubTypes() As String
    Dim strsubtypes As String, strsubtypesvalidated As String
    ' strip out unknown subtypes by validating the existing value first in case user manually edited document properties
    strsubtypes = CustomGet(PropertyNameSubTypes)
    strsubtypesvalidated = ValidateSubtypes(strsubtypes)
    If strsubtypes <> strsubtypesvalidated Then Call CustomCreate(PropertyNameSubTypes, strsubtypesvalidated)
    SubTypes = CustomGet(PropertyNameSubTypes)
End Property

Property Let SubTypes(strvalue As String)
    Call CustomCreate(PropertyNameSubTypes, ValidateSubtypes(strvalue))
End Property

Property Get SubTypesAsDictionary() As Scripting.Dictionary
    Dim dicsubtypes As New Scripting.Dictionary
    ArrayToDictionary Split(SubTypes, ","), dicsubtypes
    Set SubTypesAsDictionary = dicsubtypes
End Property

Property Set SubTypesAsDictionary(dicsubtypes As Scripting.Dictionary)
    Dim varsubtype As Variant, strsubtypes As String
    For Each varsubtype In dicsubtypes
        strsubtypes = strsubtypes & "," & Trim(varsubtype)
    Next varsubtype
    If Len(strsubtypes) > 0 Then strsubtypes = Right(strsubtypes, Len(strsubtypes) - 2)
    Let SubTypes = strsubtypes
End Property

Property Get Title() As String
    Title = BuiltIn(wdPropertyTitle)
End Property

Property Let Title(strvalue As String)
    BuiltIn(wdPropertyTitle) = strvalue
End Property

Property Get Programme() As String
    Programme = CustomGet(PropertyNameProgramme)
End Property

Property Let Programme(strvalue As String)
    Call CustomCreate(PropertyNameProgramme, strvalue)
End Property

Property Get Project() As String
    Project = CustomGet(PropertyNameProject)
End Property

Property Let Project(strvalue As String)
    Call CustomCreate(PropertyNameProject, strvalue)
End Property

Property Get CSCI() As String
    CSCI = CustomGet(PropertyNameCsci)
End Property

Property Let CSCI(strvalue As String)
    Call CustomCreate(PropertyNameCsci, strvalue)
End Property

Property Get Appendix() As String
    Appendix = CustomGet(PropertyNameAppendix)
End Property

Property Let Appendix(strvalue As String)
    Call CustomCreate(PropertyNameAppendix, strvalue)
End Property

Property Get IsOrphaned() As Boolean
    If CustomGet(PropertyNameOrphaned) = "Yes" Then IsOrphaned = True
End Property

Property Let IsOrphaned(blvalue As Boolean)
    Call CustomCreate(PropertyNameOrphaned, IIf(blvalue, "Yes", vbNullString))
End Property

Property Get Version() As String
    Version = CustomGet(PropertyNameVersion)
End Property

Property Let Version(strvalue As String)
    Call CustomCreate(PropertyNameVersion, strvalue)
End Property

Property Get IsDataDictionary() As Boolean
    IsDataDictionary = (TypeAbbr = "SRS" And (Shortname Like "*_fim_*" Or Shortname Like "*_fim.*"))
End Property

Property Get BuiltInName(ByVal wdproperty As WdBuiltInProperty) As String
    BuiltInName = GetBuiltInName(wdproperty)
End Property

Property Get BuiltIn(ByVal wdproperty As WdBuiltInProperty) As String
    BuiltIn = Trim(GetBuiltInPropertiesProtected(wdproperty).Value)
End Property

Property Let BuiltIn(ByVal wdproperty As WdBuiltInProperty, ByVal strvalue As String)
    GetBuiltInPropertiesProtected(wdproperty) = strvalue
    mParent.Document.Saved = False ' force a save prompt
End Property

Property Get BuiltInAsDictionary(Optional ByVal blsort As Boolean = False, Optional ByVal blpadnames As Boolean = True) As Scripting.Dictionary
    Set BuiltInAsDictionary = FormatPropertiesAsDictionary(GetBuiltInPropertiesProtected(), blsort, blpadnames)
End Property

Property Get CustomAsDictionary(Optional ByVal blsort As Boolean = True, Optional ByVal blpadnames As Boolean = True) As Scripting.Dictionary
    Set CustomAsDictionary = FormatPropertiesAsDictionary(mParent.Document.CustomDocumentProperties, blsort, blpadnames)
End Property

' =====================================================================================================================
' Private Document Property Helper Functions
' =====================================================================================================================
Private Function CustomGet(ByVal strproperty As String) As String
    Dim prop As DocumentProperty

    For Each prop In mParent.Document.CustomDocumentProperties
        If prop.Name = strproperty Then
            CustomGet = Trim(prop.Value)
            If CustomGet = vbNullString Then CustomGet = " " ' to differentiate between property that does not exist and one that is empty
            Exit Function
        End If
    Next prop
    
End Function

Private Sub CustomCreate(ByVal strproperty As String, ByVal strvalue As String)
    If CustomGet(strproperty) = vbNullString Then
        mParent.Document.CustomDocumentProperties.Add strproperty, False, msoPropertyTypeString, strvalue
        mParent.Document.Saved = False ' force a save prompt
    Else
        Call CustomUpdate(strproperty, strvalue)
    End If
End Sub

Private Sub CustomUpdate(ByVal strproperty As String, ByVal strvalue As String)
    mParent.Document.CustomDocumentProperties(strproperty).Value = strvalue ' assume property exists
    mParent.Document.Saved = False ' force a save prompt
End Sub

Private Sub CustomDelete(ByVal strproperty As String)
    If CustomGet(strproperty) Then
        mParent.Document.CustomDocumentProperties(strproperty).Delete
        mParent.Document.Saved = False ' force a save prompt
    End If
End Sub

Private Function ValidateSubtypes(ByVal strvalue As String) As String
    Dim varsubtype As Variant, dicsubtypes As New Scripting.Dictionary
    ArrayToDictionary Split(strvalue, ","), dicsubtypes
    ' remove unknown entries
    strvalue = vbNullString
    For Each varsubtype In dicsubtypes
        If mParent.DocList.SubTypesForTypeAsDictionary(TypeAbbr).Exists(varsubtype) Then
            strvalue = strvalue & "," & Trim(varsubtype)
        End If
    Next varsubtype
    If Len(strvalue) > 0 Then strvalue = Right(strvalue, Len(strvalue) - 1)
    ValidateSubtypes = strvalue
End Function

Private Function GetBuiltInPropertiesProtected() As DocumentProperties
    Dim blsaved As Boolean
    ' NOTE: accessing the built-in document properties somehow touches the document, so the state needs to be restored to what it was before
    blsaved = mParent.Document.Saved
    Set GetBuiltInPropertiesProtected = mParent.Document.BuiltInDocumentProperties
    mParent.Document.Saved = blsaved
End Function

Private Function FormatPropertiesAsDictionary(ByRef props As DocumentProperties, ByVal blsort As Boolean, ByVal blpadnames As Boolean) As Scripting.Dictionary
    Dim dicprops As Scripting.Dictionary, prop As DocumentProperty, strvalue As String
On Error GoTo Err_FormatPropertiesAsDictionary

    Set dicprops = New Scripting.Dictionary
    For Each prop In props
        strvalue = vbNullString
        strvalue = prop.Value ' this may trigger an error
        dicprops.Add prop.Name, strvalue
    Next prop
    
    Set FormatPropertiesAsDictionary = PadSortDictionary(dicprops, blsort, blpadnames)
    
Exit_FormatPropertiesAsDictionary:
    Exit Function

Err_FormatPropertiesAsDictionary:
    If Err.Number = &H80004005 Then ' some properties fail if the value has never been set, so ignore these
        Resume Next
    Else
        MsgBox Err.Description & " in FormatPropertiesAsDictionary() of cDocProps"
        Resume Exit_FormatPropertiesAsDictionary
    End If
End Function

Private Function GetBuiltInName(ByVal wdproperty As WdBuiltInProperty) As String
    Select Case wdproperty
        Case wdPropertyTitle
            GetBuiltInName = "Title"
        
        Case wdPropertySubject
            GetBuiltInName = "Subject"
        
        Case wdPropertyAuthor
            GetBuiltInName = "Author"
            
        Case wdPropertyKeywords
            GetBuiltInName = "Keywords"
        
        Case wdPropertyComments
            GetBuiltInName = "Comments"
        
        Case wdPropertyTemplate
            GetBuiltInName = "Template"
        
        Case wdPropertyLastAuthor
            GetBuiltInName = "LastSavedBy"
        
        Case wdPropertyRevision
            GetBuiltInName = "RevisionNumber"
        
        Case wdPropertyAppName
            GetBuiltInName = "NameOfApplication"
        
        Case wdPropertyTimeLastPrinted
            GetBuiltInName = "LastPrinted"
        
        Case wdPropertyTimeCreated
            GetBuiltInName = "CreateTime"
        
        Case wdPropertyTimeLastSaved
            GetBuiltInName = "LastSavedTime"
        
        Case wdPropertyVBATotalEdit
            GetBuiltInName = "TotalEditingTime"
        
        Case wdPropertyPages
            GetBuiltInName = "Pages"
        
        Case wdPropertyWords
            GetBuiltInName = "Words"
        
        Case wdPropertyCharacters
            GetBuiltInName = "Characters"
        
        Case wdPropertySecurity
            GetBuiltInName = "Security"
        
        Case wdPropertyCategory
            GetBuiltInName = "Category"
        
        Case wdPropertyFormat
            GetBuiltInName = "Format" ' guessing
        
        Case wdPropertyManager
            GetBuiltInName = "Manager"
        
        Case wdPropertyCompany
            GetBuiltInName = "Company"
        
        Case wdPropertyBytes
            GetBuiltInName = "Bytes"
        
        Case wdPropertyLines
            GetBuiltInName = "Lines"
        
        Case wdPropertyParas
            GetBuiltInName = "Paragraphs"
        
        Case wdPropertySlides
            GetBuiltInName = "Slides" ' guessing
        
        Case wdPropertyNotes
            GetBuiltInName = "Notes" ' guessing
        
        Case wdPropertyHiddenSlides
            GetBuiltInName = "HiddenSlides" ' guessing
        
        Case wdPropertyMMClips
            GetBuiltInName = "MMClips" ' guessing
        
        Case wdPropertyHyperlinkBase
            GetBuiltInName = "HyperlinkBase"
        
        Case wdPropertyCharsWSpaces
            GetBuiltInName = "CharactersWithSpaces"
        
        Case Else
            GetBuiltInName = vbNullString
        
    End Select
End Function

' =====================================================================================================================
' Event Handlers
' =====================================================================================================================
Private Sub Class_Terminate()
    Set mParent = Nothing
End Sub
Attribute VB_Name = "cDocVars"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Reference to parent Document Info object
' NOTE: this class is designed not to use any local storage other than a document info object reference
Private mParent As cDocInfo
  
Public Enum EnumDocVariableTypes
    [_enumDocVariableTypeFirst]
    enumDocVariableTypeDst
    enumDocVariableTypeFileChecksum
    enumDocVariableTypeTableChecksum
    enumDocVariableTypeConfigItem
    enumDocVariableTypeAbbrIgnored
    [_enumDocVariableTypeLast]
End Enum

Private Const Const_DOCVARTYPE_FIXED As String = "Dst"
Private Const Const_DOCVARTYPE_FILE As String = "FILECHECKSUM::"
Private Const Const_DOCVARTYPE_TABLE As String = "TABLECHECKSUM::"
Private Const Const_DOCVARTYPE_CONFIG As String = "CONFIGITEM::"
Private Const Const_DOCVARTYPE_ABBRIGN As String = "ABBRIGNORED::"
 
Private Const Const_DOCVARNAME_CHECKDOCDATE As String = Const_DOCVARTYPE_FIXED & "CheckDocDate"
Private Const Const_DOCVARNAME_EXTREFSDATE As String = Const_DOCVARTYPE_FIXED & "ExtRefsDate"
Private Const Const_DOCVARNAME_MASTERTEMPLATEUSED As String = Const_DOCVARTYPE_FIXED & "MasterTemplateUsed"
Private Const Const_DOCVARNAME_MASTERTEMPLATEDATE As String = Const_DOCVARTYPE_FIXED & "MasterTemplateDate"

Property Get Parent() As cDocInfo
    Set Parent = mParent
End Property

Property Set Parent(docinfo As cDocInfo)
    Set mParent = docinfo
End Property

' =====================================================================================================================
' User Functions to Access Document Variables
' =====================================================================================================================
Property Get CheckDocDate() As String
    CheckDocDate = VariableGet(Const_DOCVARNAME_CHECKDOCDATE)
End Property

Property Let CheckDocDate(strvalue As String)
    Call VariableEdit(Const_DOCVARNAME_CHECKDOCDATE, strvalue)
End Property

Property Get GetVariableName(ByVal strproperty As String) As String
    Select Case strproperty
        Case "CheckDocDate"
            GetVariableName = Const_DOCVARNAME_CHECKDOCDATE
            
        Case "ExtRefsDate"
            GetVariableName = Const_DOCVARNAME_EXTREFSDATE
        
        Case "MasterTemplateUsed"
            GetVariableName = Const_DOCVARNAME_MASTERTEMPLATEUSED
        
        Case "MasterTemplateDate"
            GetVariableName = Const_DOCVARNAME_MASTERTEMPLATEDATE
        
        Case Else
            GetVariableName = "Could not determine variable name for property " & strproperty
    End Select
End Property

Property Get ExtRefsDate() As String
    ExtRefsDate = VariableGet(Const_DOCVARNAME_EXTREFSDATE)
End Property

Property Let ExtRefsDate(strvalue As String)
    Call VariableEdit(Const_DOCVARNAME_EXTREFSDATE, strvalue)
End Property

Property Get MasterTemplateUsed() As String
    MasterTemplateUsed = VariableGet(Const_DOCVARNAME_MASTERTEMPLATEUSED)
End Property

Property Let MasterTemplateUsed(strvalue As String)
    Call VariableEdit(Const_DOCVARNAME_MASTERTEMPLATEUSED, strvalue)
End Property

Property Get MasterTemplateDate() As String
    MasterTemplateDate = VariableGet(Const_DOCVARNAME_MASTERTEMPLATEDATE)
End Property

Property Let MasterTemplateDate(strvalue As String)
    Call VariableEdit(Const_DOCVARNAME_MASTERTEMPLATEDATE, strvalue)
End Property

Property Get FileChecksum(ByVal strvariable As String) As String
    FileChecksum = VariableGet(strvariable, enumDocVariableTypeFileChecksum)
End Property
       
Property Let FileChecksum(ByVal strvariable As String, ByVal strvalue As String)
    Call VariableEdit(strvariable, strvalue, enumDocVariableTypeFileChecksum)
End Property

Property Get TableChecksum(ByVal strvariable As String) As String
    TableChecksum = VariableGet(strvariable, enumDocVariableTypeTableChecksum)
End Property
       
Property Let TableChecksum(ByVal strvariable As String, ByVal strvalue As String)
    Call VariableEdit(strvariable, strvalue, enumDocVariableTypeTableChecksum)
End Property

Property Get ConfigItem(ByVal strvariable As String) As String
    ConfigItem = VariableGet(strvariable, enumDocVariableTypeConfigItem)
End Property
       
Property Let ConfigItem(ByVal strvariable As String, ByVal strvalue As String)
    Call VariableEdit(strvariable, strvalue, enumDocVariableTypeConfigItem)
End Property

Property Get AbbrIgnored(ByVal strvariable As String) As String
    AbbrIgnored = VariableGet(strvariable, enumDocVariableTypeAbbrIgnored)
End Property
       
Property Let AbbrIgnored(ByVal strvariable As String, ByVal strvalue As String)
    Call VariableEdit(strvariable, strvalue, enumDocVariableTypeAbbrIgnored)
End Property

Property Get OfType(ByVal enumvartype As EnumDocVariableTypes) As Scripting.Dictionary
    '==================================================================================================================================
    ' Description: Returns a dictionary of the document variables of the given type
    '==================================================================================================================================
    Dim dicitems As Scripting.Dictionary, varitem As Variable, strvariable As String, strvalue As String
    Set dicitems = New Scripting.Dictionary
    For Each varitem In mParent.Document.Variables
        If IsOfType(varitem.Name, enumvartype) Then
            strvariable = varitem.Name
            strvalue = VariableGet(strvariable, enumvartype) ' note this also strips out the name prefix
            dicitems.Add strvariable, strvalue
        End If
    Next varitem
    Set OfType = dicitems
End Property
                  
Property Get All() As Scripting.Dictionary
    Dim dicitems As Scripting.Dictionary, varitem As Variable, strvariable As String, strvalue As String
    Set dicitems = New Scripting.Dictionary
    For Each varitem In mParent.Document.Variables
        strvariable = varitem.Name
        strvalue = VariableGet(strvariable)
        dicitems.Add strvariable, strvalue
    Next varitem
    Set All = dicitems
End Property
                                                
Property Get IsOfType(ByVal strvariable As String, ByVal enumvartype As EnumDocVariableTypes) As Boolean
    If InStr(1, strvariable, TypeLookup(enumvartype)) = 1 Then IsOfType = True
End Property

Sub DeleteAllOfType(ByVal enumvartype As EnumDocVariableTypes, Optional ByVal strmatch As String = vbNullString)
    Dim varitem As Variable
    For Each varitem In mParent.Document.Variables
        If IsOfType(varitem.Name, enumvartype) And PrefixRemove(enumvartype, varitem.Name) Like strmatch & "*" Then
            varitem.Delete
        End If
    Next varitem
End Sub

Sub VariableEdit(ByVal strvariable As String, ByVal strvalue As String, Optional ByVal enumvartype As EnumDocVariableTypes = [_enumDocVariableTypeFirst])
    Call VariableManage(PrefixAdd(enumvartype, strvariable), strvalue)
End Sub

Sub VariableDelete(ByVal strvariable As String, Optional ByVal enumvartype As EnumDocVariableTypes = [_enumDocVariableTypeFirst])
    Call VariableManage(PrefixAdd(enumvartype, strvariable), "__DELETEDOCVAR__")
End Sub

Function VariableGet(ByRef strvariable As String, Optional ByVal enumvartype As EnumDocVariableTypes = [_enumDocVariableTypeFirst]) As String
    Dim strrealename As String
    strrealename = PrefixAdd(enumvartype, strvariable)
    strvariable = PrefixRemove(enumvartype, strrealename)
    VariableGet = VariableManage(strrealename)
End Function

Function PrefixAdd(ByVal enumvartype As EnumDocVariableTypes, ByVal strvariable As String) As String
    Dim strprefix As String
    strprefix = TypeLookup(enumvartype)
    If Not InStr(1, strvariable, strprefix) = 1 Then strvariable = strprefix & strvariable
    PrefixAdd = strvariable
End Function

' =====================================================================================================================
' Private Document Variable Helper Functions
' =====================================================================================================================
Private Function VariableManage(ByVal strvariable As String, Optional ByVal strvalue As String = vbNullString) As String
    Dim varitem As Variable
    
    ' check if variable exists
    For Each varitem In mParent.Document.Variables
        If varitem.Name = strvariable Then
            VariableManage = varitem.Value
            If VariableManage = vbNullString Then VariableManage = " " ' to differentiate between variable that does not exist and one that is empty
            Exit For
        End If
    Next varitem
    
    ' check for edit request
    If strvalue <> vbNullString Then
        If strvalue <> "__DELETEDOCVAR__" Then
            strvalue = Trim(strvalue) ' this caters for clearing value by passing in " "
            If varitem Is Nothing Then
                Set varitem = mParent.Document.Variables.Add(strvariable, strvalue)
            Else
                varitem.Value = strvalue
            End If
        Else
            If Not varitem Is Nothing Then varitem.Delete
        End If
    End If
    
End Function

Private Function PrefixRemove(ByVal enumvartype As EnumDocVariableTypes, ByVal strvariable As String) As String
    PrefixRemove = Replace(strvariable, TypeLookup(enumvartype), vbNullString, 1, 1)
End Function

Private Function TypeLookup(ByVal enumvartype As EnumDocVariableTypes) As String
    Select Case enumvartype
        Case enumDocVariableTypeDst
            TypeLookup = Const_DOCVARTYPE_FIXED
        Case enumDocVariableTypeFileChecksum
            TypeLookup = Const_DOCVARTYPE_FILE
        Case enumDocVariableTypeTableChecksum
            TypeLookup = Const_DOCVARTYPE_TABLE
        Case enumDocVariableTypeConfigItem
            TypeLookup = Const_DOCVARTYPE_CONFIG
        Case enumDocVariableTypeAbbrIgnored
            TypeLookup = Const_DOCVARTYPE_ABBRIGN
        Case [_enumDocVariableTypeFirst], [_enumDocVariableTypeLast]
            TypeLookup = vbNullString
        Case Else
            MsgBox "No entry defined for variable type " & enumvartype & " in cDocVars", vbExclamation
    End Select
End Function

' =====================================================================================================================
' Event Handlers
' =====================================================================================================================
Private Sub Class_Terminate()
    Set mParent = Nothing
End Sub
Attribute VB_Name = "cDst"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mBookmarkConfig As cBookmarkConfig
Private mTrcConfig As cTrcConfig
Private mDocuments As Scripting.Dictionary ' cDocInfo objects indexed by full document name
Private mPreviousDocument As Document

Public Property Get BookmarkConfig() As cBookmarkConfig
    Set BookmarkConfig = mBookmarkConfig
End Property

Public Property Get TrcConfig() As cTrcConfig
    Set TrcConfig = mTrcConfig
End Property

Public Property Get Documents() As Scripting.Dictionary
    Set Documents = mDocuments
End Property

Public Property Get Document(ByVal strdocname As String) As cDocInfo
    Dim docinfo As cDocInfo, objdoc As Document, blwasopen As Boolean
    blwasopen = IsDocumentOpen(strdocname, objdoc)
    If Not mDocuments.Exists(strdocname) Then
        Set docinfo = New cDocInfo
        Set docinfo.Parent = Me
        docinfo.DocVisible = blwasopen
        mDocuments.Add strdocname, docinfo
    ElseIf blwasopen Then
        If Not objdoc.ActiveWindow.Visible Then mDocuments(strdocname).DocVisible = False
    End If
    Set Document = mDocuments(strdocname)
    If Not objdoc Is Nothing Then Document.ProcessDocument objdoc
End Property

Property Get PreviousDocument() As Document
    If Not IsObjectValid(mPreviousDocument) Then Set mPreviousDocument = Nothing
    Set PreviousDocument = mPreviousDocument
End Property

Property Set PreviousDocument(objdoc As Document)
    Set mPreviousDocument = objdoc
End Property

Private Sub InitBookmarkConfig()
    ' URS
    mBookmarkConfig.AddPrefix "requsr", , , , , "DSTTrcBkm", "DSTTrcRef", Array("URS")
    
    ' SDS
    mBookmarkConfig.AddPrefix "reqdev", , , , , "DSTTrcBkm", "DSTTrcRef", Array("SDS")
    
    ' FRS, ICD, HMI, PIDS
    mBookmarkConfig.AddPrefix "reqsys", , , , , "DSTTrcBkm", "DSTTrcRef", Array("FRS", "ICD", "HMI", "PIDS")
    mBookmarkConfig.AddPrefix "sreqsys", , , , , "DSTTrcBkm", "DSTTrcRef", Array("FRS", "ICD", "HMI", "PIDS")
    
    ' FRS
    mBookmarkConfig.AddPrefix "sysc", , True, , enumTextMatchNone, , , Array("FRS")
    mBookmarkConfig.AddPrefix "sysi", , , , enumTextMatchNone, , , Array("FRS")
    mBookmarkConfig.AddPrefix "sysp", , , , enumTextMatchNone, , , Array("FRS")
    mBookmarkConfig.AddPrefix "syso", , , , enumTextMatchNone, , , Array("FRS")
    mBookmarkConfig.AddPrefix "sysvar", True, True, , enumTextMatchNone, "DSTFimBkm", "DSTVarInput", Array("FRS")
    mBookmarkConfig.AddPrefix "syslit", True, , , enumTextMatchNone, "DSTFimBkm", "DSTFimBkm", Array("FRS")
   
    ' OTP, FTP, GTP, STP, CTP
    mBookmarkConfig.AddPrefix "tsotp", , , , , , , Array("OTP")
    mBookmarkConfig.AddPrefix "tcotp", , , , , , , Array("OTP")
    mBookmarkConfig.AddPrefix "tsftp", , , , , , , Array("FTP")
    mBookmarkConfig.AddPrefix "tcftp", , , , , , , Array("FTP")
    mBookmarkConfig.AddPrefix "tsgtp", , , , , , , Array("GTP")
    mBookmarkConfig.AddPrefix "tcgtp", , , , , , , Array("GTP")
    mBookmarkConfig.AddPrefix "tsstp", , , , , , , Array("STP")
    mBookmarkConfig.AddPrefix "tcstp", , , , , , , Array("STP")
    mBookmarkConfig.AddPrefix "tsctp", , , , , , , Array("CTP")
    mBookmarkConfig.AddPrefix "tcctp", , , , , , , Array("CTP")
    
    ' SRS
    mBookmarkConfig.AddPrefix "reqsw", , , , , "DSTTrcBkm", "DSTTrcRef", Array("SRS")
    mBookmarkConfig.AddPrefix "sreqsw", , , , , "DSTTrcBkm", "DSTTrcRef", Array("SRS")
    mBookmarkConfig.AddPrefix "srsc", , True, , enumTextMatchNone, , , Array("SRS")
    mBookmarkConfig.AddPrefix "srsi", , , , enumTextMatchNone, , , Array("SRS")
    mBookmarkConfig.AddPrefix "srsp", , , , enumTextMatchNone, , , Array("SRS")
    mBookmarkConfig.AddPrefix "srso", , , , enumTextMatchNone, , , Array("SRS")
    mBookmarkConfig.AddPrefix "srsvar", True, True, , enumTextMatchNone, "DSTFimBkm", "DSTVarInput", Array("SRS")
    mBookmarkConfig.AddPrefix "srslit", True, , , enumTextMatchNone, "DSTFimBkm", "DSTFimBkm", Array("SRS")
    
    ' HRS
    mBookmarkConfig.AddPrefix "reqhw", , , , , "DSTTrcBkm", "DSTTrcRef", Array("HRS")
    mBookmarkConfig.AddPrefix "sreqhw", , , , , "DSTTrcBkm", "DSTTrcRef", Array("HRS")
    
    ' SDD
    mBookmarkConfig.AddPrefix "reqsdd", , , , , "DSTTrcBkm", "DSTTrcRef", Array("SDD")
    mBookmarkConfig.AddPrefix "module", , True, enumSuffixStartNone, enumTextMatchNone, , , Array("SDD")
    mBookmarkConfig.AddPrefix "package", , True, enumSuffixStartNone, enumTextMatchSuffix, , , Array("SDD")
    mBookmarkConfig.AddPrefix "subpackage", , True, enumSuffixStartNone, enumTextMatchSuffix, , , Array("SDD")
    mBookmarkConfig.AddPrefix "subsubpackage", , True, enumSuffixStartNone, enumTextMatchSuffix, , , Array("SDD")
    
    ' HDD
    mBookmarkConfig.AddPrefix "reqhdd", , , , , "DSTTrcBkm", "DSTTrcRef", Array("HDD")
    
    ' Code
    mBookmarkConfig.AddPrefix "swsrc", , , enumSuffixStartNone, enumTextMatchNone, , , Array("Code")
    mBookmarkConfig.AddPrefix "fwsrc", , , enumSuffixStartNone, enumTextMatchNone, , , Array("Code")
    
    ' STD
    mBookmarkConfig.AddPrefix "tabstr", , , , enumTextMatchNone, , , Array("STD")
    mBookmarkConfig.AddPrefix "tshl", , , , , , , Array("STD")
    mBookmarkConfig.AddPrefix "tchln", , , , , , , Array("STD")
    mBookmarkConfig.AddPrefix "tchlr", , , , , , , Array("STD")
    mBookmarkConfig.AddPrefix "tsm", , , enumSuffixStartNone, , , , Array("STD")
    mBookmarkConfig.AddPrefix "tcm", , , enumSuffixStartNone, , , , Array("STD")
    
    ' Tcode
    mBookmarkConfig.AddPrefix "tshlim", , , , , , , Array("Tcode")
    mBookmarkConfig.AddPrefix "tchlnim", , , , , , , Array("Tcode")
    mBookmarkConfig.AddPrefix "tchlrim", , , , , , , Array("Tcode")
    mBookmarkConfig.AddPrefix "tshlia", , , , , , , Array("Tcode")
    mBookmarkConfig.AddPrefix "tchlnia", , , , , , , Array("Tcode")
    mBookmarkConfig.AddPrefix "tchlria", , , , , , , Array("Tcode")
    mBookmarkConfig.AddPrefix "tsmi", , , enumSuffixStartNone, , , , Array("Tcode")
    mBookmarkConfig.AddPrefix "tcmi", , , enumSuffixStartNone, , , , Array("Tcode")
    
    ' STR
    mBookmarkConfig.AddPrefix "jftchlnia", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jftchlnim", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jftchlria", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jftchlrim", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jntchlnia", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jntchlnim", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jntchlria", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jntchlrim", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jntshl", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jcfunc", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jimodule", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jftcmi", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jntcmi", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    mBookmarkConfig.AddPrefix "jntsmi", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STR")
    
    ' All TRC-related
    mBookmarkConfig.AddPrefix "jtt", , , enumSuffixStartNone, enumTextMatchNone, "DSTTrcBkm", , Array("TRCR")
    mBookmarkConfig.AddPrefix "jtf", , , enumSuffixStartNone, enumTextMatchNone, "DSTTrcBkm", , Array("URS", "SDS", "FRS", "ICD", "HMI", "PIDS", "SRS", "HRS", "SDD", "HDD", "STP", "CTP", "GTP", "FTP", "OTP", "STD")
    
    ' STD
    mBookmarkConfig.AddPrefix "sbc", , , enumSuffixStartNone, enumTextMatchNone, , , Array("STD")
    
    ' STNDRD
    mBookmarkConfig.AddPrefix "stndrd", , , , enumTextMatchNone, , "DSTTrcRef", Array("STNDRD")
    
    '======================================================================================================================
    ' Add documents that have no predefined bookmark prefixes
    '======================================================================================================================
    mBookmarkConfig.AddDocTypesNoConfig "SQM", "SDP", "PSAC", "SAS", "SCI", "SRN", "VDD", "SDF", "CFS", "IRS", "NDA", "WRKP", "SPEC", "SEMP", "USRM", Const_TEXT_UNKNOWN
    
    '======================================================================================================================
    ' Add all document types as valid bookmark prefixes
    ' NOTE: the method below must be invoked here at the end as the full list of document types must have been defined
    '======================================================================================================================
    mBookmarkConfig.AddAllDocsAsPrefixes
    
    '======================================================================================================================
    ' General bookmarks
    ' NOTE: the method below must be invoked here at the end as the full list of document types must have been defined
    '======================================================================================================================
    mBookmarkConfig.AddPrefixToAllDocTypes "Doc"
    mBookmarkConfig.AddPrefixToAllDocTypes "gref"
        
End Sub

Private Sub InitTrcConfig()
    Dim vardoctype As Variant, varprefix As Variant, strlevel As String
    
    ' usr
    mTrcConfig.Add "requsr", Array(vbNullString) ' this is the highest level trace
    
    ' dev
    mTrcConfig.Add "reqdev", Array("requsr")
    
    ' sys
    mTrcConfig.Add "reqsys", Array("reqdev")
    mTrcConfig.Add "sreqsys", Array("reqdev")
    
    ' hl
    mTrcConfig.Add "reqsw", Array("reqsys", "sreqsys")
    mTrcConfig.Add "sreqsw", Array("reqsys", "sreqsys")
    mTrcConfig.Add "reqhw", Array("reqsys", "sreqsys")
    mTrcConfig.Add "sreqhw", Array("reqsys", "sreqsys")
    
    ' ll
    mTrcConfig.Add "reqsdd", Array("reqsw", "sreqsw")
    mTrcConfig.Add "reqhdd", Array("reqhw", "sreqhw")
    
    ' code
    mTrcConfig.Add "swsrc", Array("reqsdd")
    mTrcConfig.Add "fwsrc", Array("reqhdd")

    ' stest
    mTrcConfig.Add "tcstp", Array("reqdev", "reqsys", "sreqsys")
    mTrcConfig.Add "tcctp", Array("reqdev", "reqsys", "sreqsys")
    mTrcConfig.Add "tcgtp", Array("reqdev", "reqsys", "sreqsys")
    mTrcConfig.Add "tcftp", Array("reqdev", "reqsys", "sreqsys")
    mTrcConfig.Add "tcotp", Array("reqdev", "reqsys", "sreqsys")

    ' test
    mTrcConfig.Add "tchln", Array("reqsw", "sreqsw", "reqsdd")
    mTrcConfig.Add "tchlr", Array("reqsw", "sreqsw", "reqsdd")
    mTrcConfig.Add "tcm", Array("reqsw", "sreqsw", "reqsdd")
    
    ' tcode
    mTrcConfig.Add "tchlnia", Array("tchln")
    mTrcConfig.Add "tchlnim", Array("tchln")
    mTrcConfig.Add "tchlria", Array("tchlr")
    mTrcConfig.Add "tchlrim", Array("tchlr")
    mTrcConfig.Add "tcmi", Array("tcm")
    
    ' make sure all TRC prefixes used are consistent
    mBookmarkConfig.PrefixesExistInRef mTrcConfig.Levels, "Levels"
    mBookmarkConfig.PrefixesExistInRef mTrcConfig.Levels, "Levels in Prefixes", mTrcConfig.PrefixTraces
    mBookmarkConfig.PrefixesExistInRef mTrcConfig.PrefixTraces, "Prefixes in Levels", mTrcConfig.Levels

    ' make sure the documents don't contain prefixes that span multiple levels
    For Each vardoctype In mBookmarkConfig.DocTypes
        strlevel = vbNullString
        For Each varprefix In mBookmarkConfig.PrefixesForDocType(vardoctype, False)
            If mTrcConfig.Levels.Exists(varprefix) Then
                If strlevel = vbNullString Then
                    strlevel = mTrcConfig.Level(varprefix)
                ElseIf strlevel <> mTrcConfig.Level(varprefix) Then
                    MsgBox "Document type '" & vardoctype & "' already has prefix defined for the '" & strlevel & "' level, " & _
                           "the prefix '" & varprefix & "' is at a different level. A document cannot span multiple levels - contact the DST owner!", vbCritical
                End If
            End If
        Next varprefix
    Next vardoctype
    
End Sub

Private Sub Class_Initialize()
    Set mBookmarkConfig = New cBookmarkConfig
    Set mTrcConfig = New cTrcConfig
    Set mTrcConfig.Parent = Me
    Set mDocuments = New Scripting.Dictionary
    Call InitBookmarkConfig
    Call InitTrcConfig
End Sub

Private Sub Class_Terminate()
    Set mBookmarkConfig = Nothing
    Set mTrcConfig = Nothing
    Set mPreviousDocument = Nothing
End Sub
Attribute VB_Name = "cHeading"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mText As String
Private mNumber As String
Private mLevel As Integer
Private mBookmark As String
Private mStart As Long
Private mPurpose As Range

Public Function ProcessRange(ByRef rng As Range) As Boolean
    Dim tbl As Table, rngcel As Range
    Dim strbookmark As String, strmessage As String
    
    mText = GetHeadingText(rng)
    mNumber = GetHeadingNumber(rng)
    mLevel = GetHeadingLevel(rng)
    mStart = rng.Start
    If rng.Bookmarks.Count > 0 Then
        strbookmark = rng.Bookmarks(1).Name
        If rng.Bookmarks.Count = 1 Then
            mBookmark = strbookmark
            Set tbl = GetTable(rng.Document, mBookmark, strmessage)
            If Not tbl Is Nothing Then
                Set rngcel = tbl.Range.Cells(2).Range
                rngcel.End = rngcel.End - 1 ' exclude end-of-cell marker from range
                Set mPurpose = rngcel
            End If
        Else
            strmessage = "Overlapping bookmarks found in section " & mNumber & " at position " & mStart & ":" & vbCrLf & strbookmark & vbCrLf & rng.Bookmarks(2).Name
        End If
    End If
    
    If strmessage = vbNullString Then
        ProcessRange = True
    Else
        MsgBox strmessage, vbCritical, "DST Test Tables"
    End If
    
End Function

Public Property Get Text() As String
    Text = mText
End Property

Public Property Get Number() As String
    Number = mNumber
End Property

Public Property Get Level() As Integer
    Level = mLevel
End Property

Public Property Get Bookmark() As String
    Bookmark = mBookmark
End Property

Public Property Get Start() As Long
    Start = mStart
End Property

Public Property Get Purpose() As Range
    Set Purpose = mPurpose
End Property

Private Sub Class_Terminate()
    Set mPurpose = Nothing
End Sub
Attribute VB_Name = "cHeadingGroup"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mGroup As cHeading
Private mSubItems As Scripting.Dictionary

Property Get Group() As cHeading
    Set Group = mGroup
End Property

Property Get SubItems() As Scripting.Dictionary
    Set SubItems = mSubItems
End Property

Private Sub Class_Initialize()
    Set mGroup = New cHeading
    Set mSubItems = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mGroup = Nothing
    Set mSubItems = Nothing
End Sub
Attribute VB_Name = "cInstrumentSum"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mCombinedCoverageFileHl As String
Private mCombinedCoverageFileLl As String
Private mInstrumentedModules As Scripting.Dictionary
Private mInstrumentedModulesHl As Scripting.Dictionary
Private mInstrumentedModulesLl As Scripting.Dictionary
Private mUnInstrumentedModules As Scripting.Dictionary ' of sub-dictionaries (line number and justification)
Private mUnInstrumentedModulesHl As Scripting.Dictionary ' of sub-dictionaries (line number and justification)
Private mUnInstrumentedModulesLl As Scripting.Dictionary ' of sub-dictionaries (line number and justification)

Property Get CoverageFileHighLevel() As String
    CoverageFileHighLevel = mCombinedCoverageFileHl
End Property

Property Get CoverageFileLowLevel() As String
    CoverageFileLowLevel = mCombinedCoverageFileLl
End Property

Property Get ModulesTotal() As Integer
    ModulesTotal = mInstrumentedModules.Count + mUnInstrumentedModules.Count
    If ModulesTotal = 0 Then ModulesTotal = 1 ' to protect against divide by zero - other values will be zero anyway
End Property

Property Get InstrumentedTotal() As Integer
    InstrumentedTotal = mInstrumentedModules.Count
End Property

Property Get InstrumentedTotalPercentage() As String
    InstrumentedTotalPercentage = BuildPercentageString((InstrumentedTotal / ModulesTotal) * 100#)
End Property

Property Get UnInstrumentedTotal() As Integer
    UnInstrumentedTotal = mUnInstrumentedModules.Count
End Property

Property Get UnInstrumentedTotalPercentage() As String
    UnInstrumentedTotalPercentage = BuildPercentageString((UnInstrumentedTotal / ModulesTotal) * 100#)
End Property

Property Get InstrumentedTotalHighLevel() As Integer
    InstrumentedTotalHighLevel = mInstrumentedModulesHl.Count
End Property

Property Get InstrumentedTotalHighLevelPercentage() As String
    InstrumentedTotalHighLevelPercentage = BuildPercentageString((InstrumentedTotalHighLevel / ModulesTotal) * 100#)
End Property

Property Get InstrumentedTotalLowLevel() As Integer
    InstrumentedTotalLowLevel = mInstrumentedModulesLl.Count
End Property

Property Get InstrumentedTotalLowLevelPercentage() As String
    InstrumentedTotalLowLevelPercentage = BuildPercentageString((InstrumentedTotalLowLevel / ModulesTotal) * 100#)
End Property

Property Get InstrumentedModules() As Scripting.Dictionary
    Set InstrumentedModules = mInstrumentedModules
End Property

Property Get UnInstrumentedModules() As Scripting.Dictionary
    Set UnInstrumentedModules = mUnInstrumentedModules
End Property

Sub ProcessResults(ByVal strreport As String, ByRef frm As Object)
    
    ' process input files
    mCombinedCoverageFileHl = ProcessCoverageFile(strreport, "hlstructcovsum", mInstrumentedModulesHl, mUnInstrumentedModulesHl, frm)
    mCombinedCoverageFileLl = ProcessCoverageFile(strreport, "llstructcovsum", mInstrumentedModulesLl, mUnInstrumentedModulesLl, frm)
    
    ' update the overall un-instrumented modules dictionary
    Call ConsolidateUnInstrumentedModules(mUnInstrumentedModulesHl)
    Call ConsolidateUnInstrumentedModules(mUnInstrumentedModulesLl)
    
End Sub

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String, varitem As Variant, idx As Integer, jst As Scripting.Dictionary
         
    strdebug = strdebug & strindent & "Instrumented modules    : " & InstrumentedTotal & "(" & InstrumentedTotalPercentage & ")" & vbCrLf
    strdebug = strdebug & strindent & "High-level Instrumented : " & InstrumentedTotalHighLevel & "(" & InstrumentedTotalHighLevelPercentage & ")" & vbCrLf
    strdebug = strdebug & strindent & "Low-level Instrumented  : " & InstrumentedTotalLowLevel & "(" & InstrumentedTotalLowLevelPercentage & ")" & vbCrLf
    strdebug = strdebug & strindent & "Un-instrumented modules : " & UnInstrumentedTotal & "(" & UnInstrumentedTotalPercentage & ")" & vbCrLf
    strdebug = strdebug & strindent & "Total modules           : " & ModulesTotal & vbCrLf
    
    strdebug = strdebug & strindent & "Instrumented list:" & vbCrLf
    For Each varitem In mInstrumentedModules
        strdebug = strdebug & strindent & "  " & varitem & vbCrLf
    Next varitem
    
    strdebug = strdebug & strindent & "Un-Instrumented list:" & vbCrLf
    For idx = 0 To mUnInstrumentedModules.Count - 1
        Set jst = mUnInstrumentedModules.Items(idx) ' we know there's only one here
        strdebug = strdebug & strindent & "  " & mUnInstrumentedModules.Keys(idx) & " (Justification: " & jst.Items(0) & ")" & vbCrLf
    Next idx
    
    DebugString = strdebug
    
End Function

Private Function ProcessCoverageFile(ByVal strreport As String, ByVal strreportsubtype As String, _
                                     ByRef dicinstr As Scripting.Dictionary, ByRef dicuninstr As Scripting.Dictionary, ByRef frm As Object) As String
    Dim idx As Integer, cov As cCoverageReport, covmod As cCoverageModule, srndummy As cSrns
    
    Set cov = New cCoverageReport
    If cov.ProcessResults(strreport, strreportsubtype, Date, srndummy, frm, True) Then
        ' add the instrumented modules
        For idx = 0 To cov.InstrumentedModules.Count - 1
            Set covmod = cov.InstrumentedModules.Items(idx)
            dicinstr.Add covmod.Name, covmod.Name
            mInstrumentedModules.Add covmod.Name, covmod.Name  ' add to global dictionary
        Next idx
        
        ' add the un-instrumented modules
        For idx = 0 To cov.UnInstrumentedModules.Count - 1
            dicuninstr.Add cov.UnInstrumentedModules.Keys(idx), cov.UnInstrumentedModules.Items(idx)
        Next idx
        
        ProcessCoverageFile = cov.CoverageResultsFile
    End If

End Function

Private Sub ConsolidateUnInstrumentedModules(ByRef dicuninstr As Scripting.Dictionary)
    Dim idx As Integer, strmodule As String
        
    For idx = 0 To dicuninstr.Count - 1
        strmodule = dicuninstr.Keys(idx)
        If Not mInstrumentedModules.Exists(strmodule) And Not mUnInstrumentedModules.Exists(strmodule) Then
            mUnInstrumentedModules.Add strmodule, dicuninstr.Items(idx)
        End If
    Next idx

End Sub

Private Sub Class_Initialize()
    mCombinedCoverageFileHl = vbNullString
    mCombinedCoverageFileLl = vbNullString
    Set mInstrumentedModules = New Scripting.Dictionary
    Set mInstrumentedModulesHl = New Scripting.Dictionary
    Set mInstrumentedModulesLl = New Scripting.Dictionary
    Set mUnInstrumentedModules = New Scripting.Dictionary
    Set mUnInstrumentedModulesHl = New Scripting.Dictionary
    Set mUnInstrumentedModulesLl = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mInstrumentedModules = Nothing
    Set mInstrumentedModulesHl = Nothing
    Set mInstrumentedModulesLl = Nothing
    Set mUnInstrumentedModules = Nothing
    Set mUnInstrumentedModulesHl = Nothing
    Set mUnInstrumentedModulesLl = Nothing
End Sub
Attribute VB_Name = "cSrn"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mLruName As String
Private mReference As String
Private mIssue As String
Private mDate As Date
Private mInSdlc As Boolean
Private mCscis As Scripting.Dictionary ' of class cCsci

Public Property Get LruName() As String
    LruName = mLruName
End Property

Public Property Let LruName(strlru As String)
    mLruName = strlru
End Property

Public Property Get Reference() As String
    Reference = mReference
End Property

Public Property Let Reference(strref As String)
    mReference = strref
End Property

Public Property Get Issue() As String
    Issue = mIssue
End Property

Public Property Let Issue(strissue As String)
    mIssue = strissue
End Property

Public Property Get StartDate() As Date
    StartDate = mDate
End Property

Public Property Let StartDate(dtesrn As Date)
    mDate = dtesrn
End Property

Public Property Get InSdlc() As Boolean
    InSdlc = mInSdlc
End Property

Public Property Let InSdlc(blinsdlc As Boolean)
    mInSdlc = blinsdlc
End Property

Property Get Cscis() As Scripting.Dictionary
    Set Cscis = mCscis
End Property

Function DebugString(Optional ByVal strindent As String = vbNullString, Optional ByVal blshort As Boolean = False) As String
    Dim strdebug As String, idx As Integer, cscientry As cCsci
    
    If mReference <> vbNullString Then
        strdebug = IIf(mInSdlc, vbNullString, "WARNING: ") & "SRN for the " & mLruName & ": " & mReference & " Issue " & mIssue & IIf(mInSdlc, " (" & mDate & ")", " is not defined in SDLC")
        If Not blshort Then
            strdebug = strdebug & ":" & vbCrLf
            For idx = 0 To mCscis.Count - 1
                Set cscientry = mCscis.Items(idx)
                strdebug = strdebug & strindent & "  " & cscientry.DebugString(strindent)
            Next idx
        End If
    End If
    
    DebugString = strdebug
    
End Function

Private Sub Class_Initialize()
    mDate = Format(Date, "dd MMMM yyyy")
    Set mCscis = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mCscis = Nothing
End Sub
Attribute VB_Name = "cSrns"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mSrns As Scripting.Dictionary ' of class cSrn

Property Get Srns() As Scripting.Dictionary
    Set Srns = mSrns
End Property

Function ProcessSrns(ByRef doclst As cDocList, ByVal strsummarysubtype As String, ByVal strbaselinetable As String) As String
    Dim doc As cDocInfo, objdoc As Document, idx As Integer, srn As cSrn
    Dim tbl As Table, rw As Row, cel As Cell, rng As Range, strhltest As String, strmessage As String, dte As Variant, strcelltext As String
    
    ' find the summary STR in the document list and extract the SRN and test start date info from the document
    For idx = 0 To doclst.AllDocuments.Count - 1
        Set doc = doclst.AllDocuments.Items(idx)
        If doc.Properties.TypeAbbr = "STR" And doc.Properties.SubTypesAsDictionary.Exists(strsummarysubtype) Then
            ' get reference to document object and locate the table with the SRN info
            Set objdoc = doc.Document
            Set tbl = GetTable(objdoc, strbaselinetable, strmessage)
            If Not tbl Is Nothing Then
                ' find all entries that end in the SRN document code "/310"
                For Each rw In tbl.Rows
                    For Each cel In rw.Cells
                        strcelltext = GetCellText(cel)
                        If strcelltext Like "*/310" Then
                            Set srn = New cSrn
                            srn.LruName = GetCellText(cel.Previous)
                            srn.Reference = strcelltext
                            srn.Issue = GetCellText(cel.Next)
                            mSrns.Add srn.Reference, srn
                        End If
                    Next cel
                Next rw
                
                ' now get the data for these SRNs from SDLC
                If mSrns.Count > 0 Then
                    strmessage = GetSrnDataFromSdlc(objdoc)
                Else
                    strmessage = "No SRN information was found in '" & doc.Properties.Shortname & "'"
                End If
            End If
            Exit For
        End If
    Next idx

    If idx >= doclst.AllDocuments.Count Then
        strmessage = "Could not find the STR with the '" & strsummarysubtype & "' sub-type defined" ' set default return string
    End If
    
    ProcessSrns = strmessage

End Function

Function DebugString(Optional ByVal strindent As String = vbNullString, Optional ByVal blshort As Boolean = False) As String
    Dim strdebug As String, idx As Integer, srn As cSrn
    
    For idx = 0 To mSrns.Count - 1
        Set srn = mSrns.Items(idx)
        strdebug = strdebug & srn.DebugString(strindent, blshort)
    Next idx
    
    DebugString = strdebug
    
End Function

Private Function GetSrnDataFromSdlc(ByRef objdoc As Document) As String
    Dim app As Access.Application, wks As DAO.Workspace, dbspmi As DAO.Database, dbsref As DAO.Database, dbssrn As DAO.Database
    Dim rstpmi As DAO.Recordset, rstref As DAO.Recordset, rstissue As DAO.Recordset, rstsrn As DAO.Recordset
    Dim rstitems As DAO.Recordset, rstcsci As DAO.Recordset, rstversion As DAO.Recordset, strcriteria As String
    Dim strlocation As String, strprogcode As String, strmessage As String, colmatches As MatchCollection, strconnect As String
    Dim tbl As Table, rw As Row, srn As cSrn, idx As Integer
    Dim csc As cCsci, strcsciname As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    
    ' first get the programme code from the given document's Amendment Record
    strmessage = ValidateAmendmentRecordTable(objdoc, tbl)
    If strmessage = vbNullString Then
        ' find a valid EPR number in the first column of the Amendment Record and extract the programme code
        For Each rw In tbl.Rows
            If RegularExpressionSearch(GetCellText(rw.Cells(1)), "\b\s*(\w+)-EPR-.*\b", , colmatches) Then
                strprogcode = colmatches(0).SubMatches(0)
                Exit For
            End If
        Next rw
        
        ' force programme code to a known prefix so we can provide a graceful message below
        If strprogcode = vbNullString Then
            strprogcode = "LIB"
        End If
        
        ' get the server database location using the given reference CSCI
        strlocation = "L:\PMI_be.accdb"
        If fso.FileExists(strlocation) Then
            Set app = New Access.Application
            strconnect = "MS Access;PWD=advancedt"
            Set wks = app.DBEngine(0)
            Set dbspmi = wks.OpenDatabase(strlocation, False, True, strconnect)
            Set rstpmi = dbspmi.OpenRecordset("SELECT * FROM tblPMIProgrammes WHERE ProgrammeCode = '" & strprogcode & "' WITH OWNERACCESS OPTION", dbOpenSnapshot)
            If Not rstpmi.EOF Then
                ' open the required databases
                strlocation = rstpmi.Fields("ProgrammePath")
                Set dbsref = wks.OpenDatabase(strlocation & "\Refs_be.accdb", False, True, strconnect)
                Set dbssrn = wks.OpenDatabase(strlocation & "\SRN_be.accdb", False, True, strconnect)
                
                ' open some recordsets
                Set rstcsci = dbspmi.OpenRecordset("SELECT CSCIID, CSCIName, CSCIAbbr FROM tblPMICSCINames WITH OWNERACCESS OPTION", dbOpenSnapshot)
                Set rstref = dbsref.OpenRecordset("SELECT RefID, RefNumber FROM tblReferences WITH OWNERACCESS OPTION", dbOpenSnapshot)
                Set rstissue = dbsref.OpenRecordset("SELECT RefID, RefIssue, RefIssueID FROM tblRefIssues WITH OWNERACCESS OPTION", dbOpenSnapshot)
                Set rstsrn = dbssrn.OpenRecordset("SELECT SRNID, RefID, RefIssueID, SRNCreateDate FROM tblSRNMain WITH OWNERACCESS OPTION", dbOpenSnapshot)
                Set rstitems = dbssrn.OpenRecordset("SELECT SRNID, CSCIID, ItemName, CSValue FROM tblSRNItemsReleased WHERE Not CSValue Is Null WITH OWNERACCESS OPTION", dbOpenSnapshot) ' ignore items with no checksum
                                    
                ' process each of th SRNs
                For idx = 0 To mSrns.Count - 1
                    Set srn = mSrns.Items(idx)
                    
                    ' get the reference and issue IDs
                    rstref.FindFirst ("RefNumber = '" & srn.Reference & "'")
                    If Not rstref.NoMatch Then
                        srn.InSdlc = True
                        rstissue.FindFirst ("RefID = " & rstref!refID & " AND RefIssue = '" & srn.Issue & "'")
                        If Not rstissue.NoMatch Then
                            ' get the SRN ID-
                            rstsrn.FindFirst ("RefID = " & rstref!refID & " AND RefIssueID = " & rstissue!RefIssueID)
                            If Not rstsrn.NoMatch Then
                                srn.StartDate = rstsrn.Fields("SRNCreateDate")
                                
                                ' get the list of CSCIs and versions released on the SRN
                                Set rstversion = dbssrn.OpenRecordset("SELECT CSCIVersionTag, tblSRNCSCIsReleased.CSCIID FROM tblSRNCSCIVersions INNER JOIN tblSRNCSCIsReleased ON tblSRNCSCIVersions.CSCIVersionID = tblSRNCSCIsReleased.CSCIVersionToID WHERE SRNID = " & rstsrn!SRNID & " ORDER BY CSCIVersionTag WITH OWNERACCESS OPTION", dbOpenSnapshot)
                                While Not rstversion.EOF ' assume there is at least one CSCI being released!
                                    rstcsci.FindFirst ("CSCIID = " & rstversion.Fields("CSCIID"))
                                    strcsciname = rstcsci.Fields("CSCIName") ' assume it exists
                                    
                                    ' get the list of items released on the SRN for this CSCI
                                    strcriteria = "SRNID = " & rstsrn.Fields("SRNID") & " AND CSCIID = " & rstversion.Fields("CSCIID")
                                    rstitems.FindFirst (strcriteria)
                                    If Not rstitems.NoMatch Then
                                        ' add the released items to CSCI dictionary - assume dictionary reference is valid
                                        While Not rstitems.NoMatch
                                            Set csc = New cCsci
                                            csc.Name = strcsciname
                                            csc.Abbreviation = rstcsci.Fields("CSCIAbbr")
                                            csc.VersionTag = rstversion.Fields("CSCIVersionTag") ' assume it exists
                                            csc.BinName = fso.GetFileName(rstitems.Fields("ItemName"))
                                            csc.Checksum = rstitems.Fields("CSValue")
                                            srn.Cscis.Add csc.BinName, csc
                                            rstitems.FindNext (strcriteria)
                                        Wend
                                    Else
                                        ' no released items for this CSCI
                                        Set csc = New cCsci
                                        csc.Name = strcsciname
                                        csc.Abbreviation = rstcsci.Fields("CSCIAbbr")
                                        csc.VersionTag = rstversion.Fields("CSCIVersionTag") ' assume it exists
                                        csc.BinName = strcsciname ' use CSCI name as well - it should be unique
                                        csc.Checksum = "N/A"
                                        srn.Cscis.Add csc.BinName, csc
                                    End If
                                    rstversion.MoveNext
                                Wend
                            Else
                                strmessage = "Could not find SDLC SRN associated with " & srn.Reference & " Issue " & srn.Issue
                            End If
                        Else
                            strmessage = "Could not find SDLC Reference issue " & srn.Issue
                        End If
                    End If
                Next idx
            Else
                strmessage = "Could not find SDLC Programme associated with the code " & strprogcode
            End If
        Else
            strmessage = "Could not find file " & strlocation
        End If
    Else
        strmessage = "Could not determine SDLC Programme Code from Amendment Record in '" & objdoc.Name & "': " & strmessage
    End If
    
    GetSrnDataFromSdlc = strmessage
    
    ' make sure resources are released
    If Not rstpmi Is Nothing Then rstpmi.Close
    If Not rstref Is Nothing Then rstref.Close
    If Not rstissue Is Nothing Then rstissue.Close
    If Not rstsrn Is Nothing Then rstsrn.Close
    If Not rstcsci Is Nothing Then rstcsci.Close
    If Not rstversion Is Nothing Then rstversion.Close
    If Not rstitems Is Nothing Then rstitems.Close
    If Not dbspmi Is Nothing Then dbspmi.Close
    If Not dbsref Is Nothing Then dbsref.Close
    If Not dbssrn Is Nothing Then dbssrn.Close
    If Not wks Is Nothing Then wks.Close
    Set rstpmi = Nothing
    Set rstref = Nothing
    Set rstissue = Nothing
    Set rstsrn = Nothing
    Set rstcsci = Nothing
    Set rstversion = Nothing
    Set rstitems = Nothing
    Set dbspmi = Nothing
    Set dbsref = Nothing
    Set dbssrn = Nothing
    Set app = Nothing
    
End Function

Private Sub Class_Initialize()
    Set mSrns = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mSrns = Nothing
End Sub
Attribute VB_Name = "cTblCellFormat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mLabel As String
Private mIsNumber As Boolean
Private mWidth As Single
Private mStyleOverride As String

Property Get Label() As String
    Label = mLabel
End Property
 
Property Let Label(strlabel As String)
    mLabel = strlabel
End Property

Property Get IsNumber() As Boolean
    IsNumber = mIsNumber
End Property
 
Property Let IsNumber(blnumber As Boolean)
    mIsNumber = blnumber
    mWidth = CentimetersToPoints(Const_CELL_NUM_WIDTH)
End Property

Property Get Width() As Single
    Width = mWidth
End Property
 
Property Let Width(snglwidth As Single)
    If Not mIsNumber Then
        mWidth = CentimetersToPoints(snglwidth)
    End If
End Property

Property Get StyleOverride() As String
    StyleOverride = mStyleOverride
End Property

Property Let StyleOverride(strstyle As String)
    mStyleOverride = strstyle
End Property

Function Format(ByRef cel As Cell, ByRef seqnumber As Integer) As String
    Dim bloverrideformat As Boolean
    
    Format = CheckFormat(cel)
    If Format = vbNullString Then
        With cel.Range
            .Cells(1).Width = mWidth
            If mLabel <> vbNullString Then
                .Text = mLabel
                .Font.Italic = True
                .Font.Bold = True
                .Font.Underline = False
                .Cells(1).Width = mWidth
            ElseIf mIsNumber Then
                seqnumber = seqnumber + 1 ' increment sequence number
                .Text = seqnumber
                .ParagraphFormat.Alignment = wdAlignParagraphCenter
                .Cells(1).Width = CentimetersToPoints(Const_CELL_NUM_WIDTH)
            End If
        
            If mStyleOverride <> vbNullString Then
                .Style = mStyleOverride
            End If
                        
            If .Style Is Nothing Then ' some cells don't have styles
                bloverrideformat = True
            ElseIf .Style <> "DSTTrcRef" Then
                bloverrideformat = True
            Else
                bloverrideformat = False
            End If
            
            If bloverrideformat Then
                .Font.Size = .Document.Styles("Table Text Small").Font.Size
                .ParagraphFormat.SpaceBefore = .Document.Styles("Table Text Small").ParagraphFormat.SpaceBefore
                .ParagraphFormat.SpaceAfter = .Document.Styles("Table Text Small").ParagraphFormat.SpaceAfter
            End If
        End With
    End If
    
End Function

Private Sub Class_Initialize()
    mWidth = CentimetersToPoints(Const_CELL_PURPOSE_LABEL_WIDTH)
    mStyleOverride = vbNullString
End Sub

Private Function CheckFormat(ByRef cel As Cell) As String
    
    ' Label and IsNumber may not co-exist for a cell
    If mLabel <> vbNullString And mIsNumber Then
        CheckFormat = "Cannot format cell with label '" & mLabel & "' and as a number at position " & cel.Range.Start
    End If
    
End Function
Attribute VB_Name = "cTblRowFormat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mCellsFormat As Scripting.Dictionary ' of cTblCellFormat

Property Get CellsFormat() As Scripting.Dictionary
    Set CellsFormat = mCellsFormat
End Property

Function Format(ByRef rw As Row, ByRef seqnumber As Integer, ByVal strsectionheader As String, ByVal blcreatetemplate As Boolean) As String
    Dim cel As Cell, celfrmt As cTblCellFormat, idx As Integer, tblwidth As Single, cellswidth As Single, blhasnumber As Boolean
    Dim rowfrmt As cTblRowFormat
    
    '===================================================================================================================
    ' Template creation
    '===================================================================================================================
    If blcreatetemplate Then
        ' ensure we start with a single cell and then split it into the required number of cells based on the number of defined formats
        rw.Cells.Merge
        rw.Cells(1).Split 1, mCellsFormat.Count
    End If
    
    '===================================================================================================================
    ' Validation
    '===================================================================================================================
    ' check if it's a test reference row (has a cell that ends with a fixed reference label)
    If InStr(1, rw.Range.Text, Const_TEST_REF_LABEL_SUFFIX & Chr(13) & Chr(7)) Then ' ASCII code 13 and followed by 7 is the end-of-cel marker
        ' assume test reference rows are already formatted correctly
        Exit Function
    End If
    
    ' make sure the row has the correct number of cells
    Set rowfrmt = Me
    If rowfrmt.CellsFormat.Count <> rw.Cells.Count Then
        ' requirement rows may have different formats
        If strsectionheader = Const_TABLE_REQUIREMENTS_TEXT Then
            Set rowfrmt = New cTblRowFormat
            Call SetRequirementsRowFormat(rowfrmt, False, IIf(rw.Cells(4).Range.Fields.Count = 0, True, False))
        End If
        
        If rowfrmt.CellsFormat.Count <> rw.Cells.Count Then
            Format = "Row " & rw.Index & " at position " & rw.Range.Start & ": Number of cells is " & rw.Cells.Count & ", but the number of formats defined is " & mCellsFormat.Count
            Exit Function
        End If
    End If
    
    ' check that only one cell is formatted as a number
    For idx = 0 To rowfrmt.CellsFormat.Count - 1
        Set celfrmt = rowfrmt.CellsFormat.Items(idx)
        If celfrmt.IsNumber Then
            If blhasnumber Then
                Format = "Row " & rw.Index & " at position " & rw.Range.Start & ": Only one cell may be formatted as a number"
                Exit Function
            Else
                blhasnumber = True
            End If
        End If
    Next idx
    
    ' check that the cells will fit into the given table width
    tblwidth = GetTableWidth(rw.Range)
    cellswidth = 0
    For idx = 0 To rowfrmt.CellsFormat.Count - 2 ' exclude last cell - it's adjusted to fit in the remainig width
        Set celfrmt = rowfrmt.CellsFormat.Items(idx)
        cellswidth = cellswidth + celfrmt.Width ' width of formatted cells
    Next idx
    If cellswidth >= tblwidth Then
        Format = "Row " & rw.Index & " at position " & rw.Range.Start & ": Width of formatted cells (" & cellswidth & ") exceeds table width (" & tblwidth & ")"
        Exit Function
    End If
    
    '===================================================================================================================
    ' Apply format
    '===================================================================================================================
    ' format each cell
    For idx = 0 To rowfrmt.CellsFormat.Count - 1
        Set celfrmt = rowfrmt.CellsFormat.Items(idx)
        Set cel = rw.Cells(idx + 1) ' cells collection starts at 1
        celfrmt.Format cel, seqnumber
    Next idx
    
    ' adjust the last cell's width to fit into the remaining width
    cel.Width = tblwidth - cellswidth
    
End Function

Private Sub Class_Initialize()
    Set mCellsFormat = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mCellsFormat = Nothing
End Sub
Attribute VB_Name = "cTblSectionFormat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mSectionHeader As String
Private mHeadingRow As cTblRowFormat
Private mSubRow As cTblRowFormat
Private mTemplateText As Scripting.Dictionary ' of Dictionary of cell text for a row

Property Get SectionHeader() As String
    SectionHeader = mSectionHeader
End Property

Property Let SectionHeader(ByVal strheader As String)
    mSectionHeader = strheader
End Property

Property Get HeadingRow() As cTblRowFormat
    Set HeadingRow = mHeadingRow
End Property

Property Get SubRow() As cTblRowFormat
    Set SubRow = mSubRow
End Property

Property Get TemplateText() As Scripting.Dictionary
    Set TemplateText = mTemplateText
End Property

Function Format(ByRef rw As Row, ByRef frmt As cTblTestFormat, ByVal blcreatetemplate As Boolean) As String
    Dim cellfrmt As cTblCellFormat, rwsectionstart As Row, rwsectionend As Row, seqnumber As Integer, strsectionheadernext As String
    
    '===================================================================================================================
    ' Validation
    '===================================================================================================================
    ' check that first cell of heading row is formatted as a label
    Set cellfrmt = mHeadingRow.CellsFormat.Items(0)
    If cellfrmt.Label = vbNullString Then
        Format = "Row " & rw.Index & " at position " & rw.Range.Start & ": First cell of heading row is not formatted as a label"
        Exit Function
    ElseIf Not blcreatetemplate And cellfrmt.Label <> GetCellText(rw.Cells(1)) Then
        ' check that the correct section is being formatted
        Format = "Row " & rw.Index & " at position " & rw.Range.Start & ": Expected section start label '" & cellfrmt.Label & "'"
        Exit Function
    End If
    
    ' check that heading row has some template text defined
    If mTemplateText.Count = 0 Then
        Format = "Row " & rw.Index & " at position " & rw.Range.Start & ": No template text defined for heading row"
        Exit Function
    End If
        
    '===================================================================================================================
    ' Apply format
    '===================================================================================================================
    ' format heading row
    seqnumber = 0 ' start at 0, numbered cells will increment this value when the cell is formatted
    Set rwsectionstart = rw
    Format = mHeadingRow.Format(rwsectionstart, seqnumber, mSectionHeader, blcreatetemplate)
    If Format = vbNullString Then
        ' find last row for this section and format the sub rows
        If blcreatetemplate Then
            ' when creating a template, the section's last row is driven by the number of rows of template text defined for the sub rows
            Set rwsectionend = rwsectionstart.Range.Tables(1).Rows(rwsectionstart.Index + mTemplateText.Count - 1)
        Else
            ' when formatting an existing table, the last row of the section needs to be located
            Set rwsectionend = frmt.GetSectionEndRow(rw.Range.Tables(1), mSectionHeader, strsectionheadernext)
        End If
        If Not rwsectionend Is Nothing Then
            Do While rw.Index < rwsectionend.Index
                Set rw = rw.Next
                Format = mSubRow.Format(rw, seqnumber, mSectionHeader, blcreatetemplate)
                If Format <> vbNullString Then
                    ' stop formatting
                    Exit Do
                End If
            Loop
        Else
            MsgBox "Could not locate table section starting with header '" & mSectionHeader & "' and ending with '" & strsectionheadernext & "'", vbCritical
        End If
        
        ' add the template text if required
        If blcreatetemplate Then Format = WriteTemplatetext(rwsectionstart)
    End If
        
End Function

Private Function WriteTemplatetext(ByRef rw As Row) As String
    Dim idx As Integer, rowfrmt As cTblRowFormat, dicrowtext As Scripting.Dictionary
    
    ' write each row's template text
    For idx = 0 To mTemplateText.Count - 1
        If idx = 0 Then
            Set rowfrmt = mHeadingRow
        Else
            Set rowfrmt = mSubRow
        End If
        
        ' write the template text for the given row
        Set dicrowtext = mTemplateText.Items(idx)
        WriteTemplatetext = WriteTemplateTextRow(rw, rowfrmt, dicrowtext)
        If WriteTemplatetext = vbNullString Then
            Set rw = rw.Next ' assume a row exists for this text
        Else
            Exit Function
        End If
    Next idx
    
End Function

Private Function WriteTemplateTextRow(ByRef rw As Row, ByRef rowfrmt As cTblRowFormat, ByRef dicrowtext As Scripting.Dictionary) As String
    Dim varcell As Variant, cellfrmt As cTblCellFormat
    
    For Each varcell In dicrowtext
        ' check that is within row's range
        If varcell <= rw.Cells.Count Then
            If dicrowtext(varcell) <> vbNullString Then
                ' check that cell is not formatted as a label or as a number
                Set cellfrmt = rowfrmt.CellsFormat.Items(varcell - 1)
                If cellfrmt.Label = vbNullString And Not cellfrmt.IsNumber Then
                    ' add the text to the appropriate cell, blank text is used as a placeholder
                    rw.Cells(varcell).Range.Text = dicrowtext(varcell)
                Else
                    WriteTemplateTextRow = "Row " & rw.Index & " at position " & rw.Range.Start & ": template text defined for cell " & varcell & ", but cell is a label or a number"
                    Exit Function
                End If
            End If
        Else
            WriteTemplateTextRow = "Row " & rw.Index & " at position " & rw.Range.Start & ": template text defined for cell " & varcell & ", but row only has " & rw.Cells.Count & " cells"
            Exit Function
        End If
    Next varcell
    
End Function

Private Sub Class_Initialize()
    Set mHeadingRow = New cTblRowFormat
    Set mSubRow = New cTblRowFormat
    Set mTemplateText = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mHeadingRow = Nothing
    Set mSubRow = Nothing
    Set mTemplateText = Nothing
End Sub
Attribute VB_Name = "cTblTestFormat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mTableFormat As Scripting.Dictionary ' of cTblSectionFormat

Property Get TableFormat() As Scripting.Dictionary
    Set TableFormat = mTableFormat
End Property

Function Format(ByRef tbl As Table, Optional ByVal blcreatetemplate As Boolean = False) As String
    Dim idx As Integer, section As cTblSectionFormat, rw As Row, rwprev As Row, strsectionheader As String
    
    ' for existing tables, loop through each section and check that the section headings are in the correct sequence
    If Not blcreatetemplate Then
        Set rw = tbl.Rows(1)
        For idx = 0 To mTableFormat.Count - 1
            strsectionheader = mTableFormat.Keys(idx)
            Set rw = GetSectionStartRow(tbl, strsectionheader)
            If Not rw Is Nothing Then
                If Not rwprev Is Nothing Then
                    If rw.Index < rwprev.Index Then
                        Format = "Row " & rw.Index & " at position " & rw.Range.Start & ": Expected section '" & strsectionheader & "' to appear after '" & mTableFormat.Keys(idx - 1) & "'"
                        Exit Function
                    End If
                End If
                Set rwprev = rw
            Else
                Format = "Table at position " & tbl.Rows(1).Range.Start & ": Could not locate section with label '" & strsectionheader & "'"
                Exit Function
            End If
        Next idx
    End If
    
    ' loop through each section and format it
    Set rw = tbl.Rows(1)
    For idx = 0 To mTableFormat.Count - 1
        Set section = mTableFormat.Items(idx)
        Format = section.Format(rw, Me, blcreatetemplate)
        If Format = vbNullString Then
            If Not rw.IsLast Then Set rw = rw.Next ' next section's start row
        Else
            ' stop formatting
            Exit For
        End If
    Next idx
    
End Function

Function InsertTemplateTable(ByRef rng As Range) As String
    Dim idx As Integer, tbl As Table
    
    With rng
        ' create table with given number of rows
        Set tbl = .Tables.Add(rng, CountTemplateRows, 1)
        With tbl
            ' set defaults
            .AutoFormat wdTableFormatNone, True, True, True, True, False, False, False, False, False
            .Range.Style = Const_STYLE_TABLE_TEXT_SMALL
            .PreferredWidth = GetTableWidth(rng)
        End With
                
        ' format the inserted table and add the template text
        InsertTemplateTable = Format(tbl, True)
        
    End With
    
End Function

Function GetSectionStartRow(ByRef tbl As Table, ByVal strsectionheader As String) As Row
    Dim rw As Row
    
    ' make sure the section header is a known section
    If mTableFormat.Exists(strsectionheader) Then
        ' find the heading row for the given section in the given table
        Set rw = tbl.Rows(1)
        While Not rw Is Nothing
            If GetCellText(rw.Cells(1)) = strsectionheader Then
                Set GetSectionStartRow = rw
                Set rw = Nothing ' to exit loop
            Else
                Set rw = rw.Next
            End If
        Wend
    End If
    
End Function

Function GetSectionEndRow(ByRef tbl As Table, ByVal strsectionheader As String, ByRef strsectionheadernext As String) As Row
    Dim rw As Row, idx As Integer

    ' make sure the section header is a known section
    If mTableFormat.Exists(strsectionheader) Then
        ' get the next section header
        For idx = 0 To mTableFormat.Count - 2
            If mTableFormat.Keys(idx) = strsectionheader Then
                idx = idx + 1
                Exit For
            End If
        Next idx
        strsectionheadernext = mTableFormat.Keys(idx)
        
        If strsectionheadernext <> strsectionheader Then
            ' get the next section's header start row in the given table
            Set rw = GetSectionStartRow(tbl, strsectionheadernext)
            If Not rw Is Nothing Then
                Set GetSectionEndRow = rw.Previous
            End If
        Else
            ' this is the last section, so return the last row in the table
            Set GetSectionEndRow = tbl.Rows(tbl.Rows.Count)
        End If
    End If
    
End Function

Private Function CountTemplateRows() As Integer
    Dim idx As Integer, sectionfrmt As cTblSectionFormat
    
    For idx = 0 To mTableFormat.Count - 1
        Set sectionfrmt = mTableFormat.Items(idx)
        CountTemplateRows = CountTemplateRows + sectionfrmt.TemplateText.Count
    Next idx
    
End Function

Private Sub Class_Initialize()
    Set mTableFormat = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mTableFormat = Nothing
End Sub
Attribute VB_Name = "cTestCase"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mTestCase As String
Private mTestScript As String
Private mResult As String
Private mComments As String

Public Property Get TestCase() As String
    TestCase = mTestCase
End Property

Public Property Let TestCase(strtestcase As String)
    mTestCase = strtestcase
End Property

Public Property Get TestScript() As String
    TestScript = mTestScript
End Property

Public Property Let TestScript(ByVal strscript As String)
    mTestScript = strscript
End Property

Public Property Get Result() As String
    Result = mResult
End Property

Public Property Let Result(strresult As String)
    mResult = strresult
End Property

Public Property Get Comments() As String
    Comments = mComments
End Property

Public Property Let Comments(strcomments As String)
    mComments = strcomments
End Property

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    DebugString = strindent & mTestCase & " (" & mTestScript & "): " & mResult & IIf(mComments <> vbNullString, "(Comments: " & mComments & ")", vbNullString) & vbCrLf
End Function
Attribute VB_Name = "cTestConfig"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mTestConfigErrorsChecksums As Scripting.Dictionary ' used for HL tests only
Private mTestConfigErrorsSrnNotFound As Scripting.Dictionary ' used for HL tests only
Private mTestConfigErrorsOther As Scripting.Dictionary

' Data used for hltests only
Private mFastVersion As String
Private mTestFilesVersion As String
Private mLrus As Scripting.Dictionary ' consists of sub-dictionaries of type cCsci, keyed by LRU name
Private mSrns As Scripting.Dictionary ' of class cSrn, keyed by LRU name - SRN associated with LRU

' Data used for lltests only
Private mTestConfigStatus As cConfigStatus

Property Get FastVersion() As String
    FastVersion = mFastVersion
End Property

Property Let FastVersion(ByVal strtag As String)
    mFastVersion = strtag
End Property

Property Get TestFilesVersion() As String
    TestFilesVersion = mTestFilesVersion
End Property

Property Let TestFilesVersion(ByVal strtag As String)
    mTestFilesVersion = strtag
End Property

Property Get Lrus() As Scripting.Dictionary
    Set Lrus = mLrus
End Property

Property Get Srns() As Scripting.Dictionary
    Set Srns = mSrns
End Property

Property Get TestConfigStatus() As cConfigStatus
    Set TestConfigStatus = mTestConfigStatus
End Property

Property Get TestConfigErrorsString(Optional ByVal strindent As String = vbNullString) As String
    Dim idx As Integer, strerrors As String, strtemp As String
        
    ' Checksum errors
    For idx = 0 To mTestConfigErrorsChecksums.Count - 1
        strtemp = strtemp & vbCrLf & strindent & "  " & mTestConfigErrorsChecksums.Keys(idx) & " in these result files:" & vbCrLf & _
                            strindent & mTestConfigErrorsChecksums.Items(idx)
    Next idx
    If strtemp <> vbNullString Then
        strerrors = vbCrLf & strindent & "The checksums listed below don't match checksums found in the SRNs referenced in the summary STR:" & strtemp
    End If
    
    ' Unmatched SRN
    strtemp = vbNullString
    For idx = 0 To mTestConfigErrorsSrnNotFound.Count - 1
        strtemp = strtemp & vbCrLf & strindent & "  " & mTestConfigErrorsSrnNotFound.Keys(idx) & " in these result files:" & vbCrLf & _
                            strindent & mTestConfigErrorsSrnNotFound.Items(idx)
    Next idx
    If strtemp <> vbNullString Then
        strerrors = strerrors & vbCrLf & IIf(strerrors <> vbNullString, vbCrLf, vbNullString) & strindent & "The following items were not found in any of the SRNs referenced in the summary STR:" & strtemp
    End If

    ' Other config errors
    strtemp = vbNullString
    For idx = 0 To mTestConfigErrorsOther.Count - 1
        strtemp = strtemp & vbCrLf & strindent & "  " & mTestConfigErrorsOther.Keys(idx)
        If mTestConfigErrorsOther.Items(idx) <> vbNullString Then
            strtemp = strtemp & " in these results/reports:" & vbCrLf & strindent & mTestConfigErrorsOther.Items(idx)
        End If
    Next idx
    If strtemp <> vbNullString Then
        strerrors = strerrors & vbCrLf & IIf(strerrors <> vbNullString, vbCrLf, vbNullString) & strindent & "The following configuration errors were found:" & strtemp
    End If
        
    TestConfigErrorsString = strerrors

End Property

Property Get TestConfigErrorsChecksums() As Scripting.Dictionary
    Set TestConfigErrorsChecksums = mTestConfigErrorsChecksums
End Property

Property Get TestConfigErrorsSrnNotFound() As Scripting.Dictionary
    Set TestConfigErrorsSrnNotFound = mTestConfigErrorsSrnNotFound
End Property

Property Get TestConfigErrorsOther() As Scripting.Dictionary
    Set TestConfigErrorsOther = mTestConfigErrorsOther
End Property

Sub ProcessConfig(ByVal strreport As String, ByVal strreportsubtype As String, ByVal strconfigfile As String)
    Dim strerror As String
    
    ' only used for low-level tests
    strerror = mTestConfigStatus.ProcessConfigFile(strreport, strreportsubtype, strconfigfile)
    If strerror <> vbNullString Then
        If Not mTestConfigErrorsOther.Exists(strerror) Then
            mTestConfigErrorsOther.Add strerror, strreport
        End If
    End If
    
End Sub

Sub Consolidate(ByVal strsubtype As String, ByVal strreport As String, ByRef rpt As Scripting.Dictionary)
    
    If strsubtype Like "hltests*" Then
        Call ConsolidateHlConfig(rpt)
    ElseIf strsubtype Like "lltests*" Then
        Call ConsolidateLlConfig(rpt, strreport)
    End If
    
End Sub

Sub CheckHlConfigAgainstSrn(ByRef srninfo As cSrns)
    Dim idxlru As Integer, idxcsci As Integer, cscilist As Scripting.Dictionary, cscientry As cCsci, srn As cSrn, srncsci As cCsci
    Dim strlru As String, strerrorkey As String, strerror As String
    
    ' NOTE: The FAST and Test Files version are checked later in the consolidation process
    
    If Not srninfo Is Nothing Then
        ' go through each LRU in the configuration captured in the result file
        For idxlru = 0 To mLrus.Count - 1
            strlru = mLrus.Keys(idxlru)
            
            ' go through each CSCI in the LRU and check them against the SRN list
            Set cscilist = mLrus.Items(idxlru)
            For idxcsci = 0 To cscilist.Count - 1
                ' for each binary in the CSCI, find a match in one of the SRNs in the list
                Set cscientry = cscilist.Items(idxcsci)
                strerrorkey = strlru & ", " & cscientry.Name & "," & cscientry.BinName & "," & cscientry.Checksum
                If GetMatchingSrnCsci(cscientry, srninfo, srn, srncsci) = True Then
                    ' first add the SRN, if it has not been added already
                    If Not mSrns.Exists(strlru) Then mSrns.Add strlru, srn
                    
                    ' now check whether the checksum is the same as on the relevant SRN, ignore zero checksums
                    If cscientry.Checksum <> srncsci.Checksum Then
                        If Not IsChecksumZero(cscientry.Checksum) Then
                            mTestConfigErrorsChecksums.Add strerrorkey, vbNullString
                        End If
                    End If
                Else
                    mTestConfigErrorsSrnNotFound.Add strerrorkey, vbNullString
                End If
            Next idxcsci
        Next idxlru
    End If
    
End Sub

Private Sub ConsolidateHlConfig(ByRef rpt As Scripting.Dictionary)
    Dim idx As Integer, idxerr As Integer, maxlru As Integer, refconf As cTestConfig, conf As cTestConfig, chkerrs As Scripting.Dictionary
    Dim strrptfile As String, strerrorkey As String, strref As String
    Dim fso As FileSystemObject

    Set fso = New FileSystemObject
    
    ' find a reference configuration that has both the FAST and Test Files versions defined
    ' NOTE: itemcount is needed as this method is invoked from classes with different dictionary structures
    If rpt.Count > 0 Then
        For idx = 0 To rpt.Count - 1
            Set conf = rpt.Items(idx).TestConfig
            If conf.Lrus.Count >= maxlru And conf.FastVersion <> vbNullString And conf.TestFilesVersion <> vbNullString Then
                Set refconf = conf
                strref = fso.GetFileName(rpt.Keys(idx))
                maxlru = conf.Lrus.Count
            End If
        Next idx
        
        ' if a reference configuration was found, clone it and consolidate the FAST and Test Files Versions
        If Not refconf Is Nothing Then
            Call CloneHlConfig(refconf)
                
            ' go through each result/report file and validate the FAST and Test Files versions against the reference configuration
            For idx = 0 To rpt.Count - 1
                strrptfile = fso.GetFileName(rpt.Keys(idx))
                Set conf = rpt.Items(idx).TestConfig
                
                If conf.FastVersion <> vbNullString And conf.FastVersion <> refconf.FastVersion Then
                    strerrorkey = "FAST Core version " & conf.FastVersion & " differs from reference version " & refconf.FastVersion
                    If mTestConfigErrorsOther.Exists(strerrorkey) Then
                        mTestConfigErrorsOther(strerrorkey) = mTestConfigErrorsOther(strerrorkey) & vbCrLf & strrptfile
                    Else
                        mTestConfigErrorsOther.Add strerrorkey, strrptfile
                    End If
                End If
                
                If conf.TestFilesVersion <> vbNullString And conf.TestFilesVersion <> refconf.TestFilesVersion Then
                    strerrorkey = "Test Files version " & conf.TestFilesVersion & " differs from reference version " & refconf.TestFilesVersion
                    If mTestConfigErrorsOther.Exists(strerrorkey) Then
                        mTestConfigErrorsOther(strerrorkey) = mTestConfigErrorsOther(strerrorkey) & vbCrLf & strrptfile
                    Else
                        mTestConfigErrorsOther.Add strerrorkey, strrptfile
                    End If
                End If
            Next idx
            
            ' add the reference configuration name if errors were added
            If mTestConfigErrorsOther.Count > 0 Then
                mTestConfigErrorsOther.Add "These configuration errors were found with respect to the reference configuration " & strref, vbNullString
            End If
        Else
            strerrorkey = "Could not find a test configuration with valid FAST and Test Files versions"
            If Not mTestConfigErrorsOther.Exists(strerrorkey) Then
                mTestConfigErrorsOther.Add strerrorkey, vbNullString
            End If
        End If
        
        ' now roll up all the configuration errors
        For idx = 0 To rpt.Count - 1
            strrptfile = fso.GetFileName(rpt.Keys(idx))
            Set conf = rpt.Items(idx).TestConfig
            Call RollUpConfigErrors(mTestConfigErrorsChecksums, strrptfile, conf.TestConfigErrorsChecksums)
            Call RollUpConfigErrors(mTestConfigErrorsSrnNotFound, strrptfile, conf.TestConfigErrorsSrnNotFound)
            Call RollUpConfigErrors(mTestConfigErrorsOther, strrptfile, conf.TestConfigErrorsOther)
        Next idx
    End If
    
End Sub

Private Sub ConsolidateLlConfig(ByRef rpt As Scripting.Dictionary, ByVal strreport As String)
    Dim idx As Integer, idxitem As Integer, conf As cTestConfig, strerrorkey As String, citem As cConfigItem, refcitem As cConfigItem
    Dim strrptfile As String, strconffile As String
    Dim fso As FileSystemObject

    Set fso = New FileSystemObject
    
    mTestConfigStatus.ConfigFile = strreport
    
    ' go through each test config status and build an overall list of config items and their combined status
    For idx = 0 To rpt.Count - 1
        strrptfile = fso.GetFileName(rpt.Keys(idx))
        Set conf = rpt.Items(idx).TestConfig
        
        ' first add the existing configuration errors
        Call RollUpConfigErrors(mTestConfigErrorsOther, strrptfile, conf.TestConfigErrorsOther)
        
        ' add known items to overall config status
        For idxitem = 0 To conf.TestConfigStatus.ConfigItems.Count - 1
            Set citem = conf.TestConfigStatus.ConfigItems.Items(idxitem)
            ' check item revision consistency against dictionary entry - 1st item into dictionary is used as the reference revision
            If mTestConfigStatus.ConfigItems.Exists(citem.File) Then
                Set refcitem = mTestConfigStatus.ConfigItems.Item(citem.File)
                If refcitem.Revision <> citem.Revision Then
                    strerrorkey = "Revision for item '" & fso.GetFileName(citem.File) & "' is " & citem.Revision & ", where the reference revision is " & refcitem.Revision
                    strconffile = fso.GetFileName(conf.TestConfigStatus.ConfigFile)
                    If mTestConfigErrorsOther.Exists(strerrorkey) Then
                        mTestConfigErrorsOther(strerrorkey) = mTestConfigErrorsOther(strerrorkey) & vbCrLf & strconffile
                    Else
                        mTestConfigErrorsOther.Add strerrorkey, strconffile
                    End If
                End If
            Else
                Set refcitem = New cConfigItem
                refcitem.File = citem.File
                refcitem.Revision = citem.Revision
                refcitem.Status = citem.Status
                mTestConfigStatus.ConfigItems.Add refcitem.File, refcitem
            End If
        Next idxitem
        
        ' NOTE: unknown items are not consolidated, but errors are reported
        If conf.TestConfigStatus.UnknownItems.Count > 0 Then
            strconffile = "  " & fso.GetFileName(conf.TestConfigStatus.ConfigFile) & vbCrLf & conf.TestConfigStatus.GetUnknownItems("  ")
            strerrorkey = "There are unknown item(s)"
            If mTestConfigErrorsOther.Exists(strerrorkey) Then
                mTestConfigErrorsOther(strerrorkey) = mTestConfigErrorsOther(strerrorkey) & strconffile
            Else
                mTestConfigErrorsOther.Add strerrorkey, strconffile
            End If
        End If
    Next idx
    
End Sub

Private Sub CloneHlConfig(ByRef conf As cTestConfig)
    Dim idxlru As Integer, idxcsci As Integer, lru As Scripting.Dictionary, srn As cSrn, mecsci As cCsci
    Dim conflru As Scripting.Dictionary, confcsci As cCsci
    
    mFastVersion = conf.FastVersion
    mTestFilesVersion = conf.TestFilesVersion
    mLrus.RemoveAll
    For idxlru = 0 To conf.Lrus.Count - 1
        Set lru = conf.Lrus.Items(idxlru)
        Set conflru = New Scripting.Dictionary
        For idxcsci = 0 To lru.Count - 1
            Set mecsci = lru.Items(idxcsci)
            Set confcsci = New cCsci
            mecsci.Clone confcsci
            conflru.Add confcsci.BinName, confcsci ' assume binary name is unique per LRU
        Next idxcsci
        mLrus.Add conf.Lrus.Keys(idxlru), conflru
    Next idxlru
    
    mSrns.RemoveAll
    For idxlru = 0 To conf.Srns.Count - 1
        Set srn = conf.Srns.Items(idxlru)
        mSrns.Add conf.Srns.Keys(idxlru), srn
    Next idxlru
    
End Sub

Private Sub RollUpConfigErrors(ByRef dicrollerrs As Scripting.Dictionary, ByVal strrptfile As String, ByRef dicconferrs As Scripting.Dictionary)
    Dim idx As Integer, strerrorkey As String

    For idx = 0 To dicconferrs.Count - 1
        strerrorkey = dicconferrs.Keys(idx)
        If dicrollerrs.Exists(strerrorkey) Then
            dicrollerrs(strerrorkey) = IIf(dicrollerrs(strerrorkey) <> vbNullString, dicrollerrs(strerrorkey) & vbCrLf, "  ") & strrptfile
        Else
            dicrollerrs.Add strerrorkey, "  " & strrptfile
        End If
    Next idx

End Sub

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim idxlru As Integer, idx As Integer, cscilist As Scripting.Dictionary, strdebug As String, cscientry As cCsci, srn As cSrn, strsrn As String
    Dim strerrors As String
        
    strdebug = strdebug & strindent & "'hltests' config:" & vbCrLf
    strdebug = strdebug & strindent & "FAST " & Const_CORE_VERSION_TEXT & ": " & mFastVersion & vbCrLf
    strdebug = strdebug & strindent & Const_TEST_FILES_TEXT & " Version: " & mTestFilesVersion & vbCrLf
    strdebug = strdebug & strindent & "LRU Count: " & mLrus.Count & vbCrLf
    For idxlru = 0 To mLrus.Count - 1
        If mSrns.Exists(mLrus.Keys(idxlru)) Then
            Set srn = mSrns.Item(mLrus.Keys(idxlru))
            strsrn = srn.DebugString(strindent)
        Else
            strsrn = "No SRN info available for the " & mLrus.Keys(idxlru) & " LRU"
        End If
        strdebug = strdebug & strindent & mLrus.Keys(idxlru) & ": " & strsrn & vbCrLf
        Set cscilist = mLrus.Items(idxlru)
        For idx = 0 To cscilist.Count - 1
            Set cscientry = cscilist.Items(idx)
            strdebug = strdebug & strindent & cscientry.DebugString("  ")
        Next idx
    Next idxlru
    
    strdebug = strdebug & strindent & "'lltests' config:" & vbCrLf
    strdebug = strdebug & strindent & mTestConfigStatus.DebugString(strindent)
        
    ' add config errors
    strerrors = TestConfigErrorsString(strindent)
    If Replace(strerrors, " ", vbNullString) = vbNullString Then strerrors = " None"
    strdebug = strdebug & strindent & "Configuration errors:" & strerrors & vbCrLf & vbCrLf
   
    DebugString = strdebug
    
End Function

Private Function GetMatchingSrnCsci(ByRef logcsci As cCsci, ByRef srninfo As cSrns, ByRef srn As cSrn, ByRef srncsci As cCsci) As Boolean
    Dim idxsrn As Integer
        
    For idxsrn = 0 To srninfo.Srns.Count - 1
        Set srn = srninfo.Srns.Items(idxsrn)
        If srn.Cscis.Exists(logcsci.BinName) Then
            Set srncsci = srn.Cscis.Item(logcsci.BinName)
            If logcsci.Name = srncsci.Name Or logcsci.Name = srncsci.Abbreviation Then
                GetMatchingSrnCsci = True
            End If
            Exit For
        End If
    Next idxsrn
        
    ' clear return data in case there was no match
    If Not GetMatchingSrnCsci Then
        Set srn = Nothing
        Set srncsci = Nothing
    End If
    
End Function

Private Function IsChecksumZero(ByVal strchecksum As String) As Boolean
    
    strchecksum = Replace(strchecksum, "0x", vbNullString, 1, 1)
    If IsNumeric(strchecksum) Then
        If Val(strchecksum) = 0 Then
            IsChecksumZero = True
        End If
    End If
    
End Function

Private Sub Class_Initialize()
    Set mLrus = New Scripting.Dictionary
    Set mSrns = New Scripting.Dictionary
    Set mTestConfigStatus = New cConfigStatus
    Set mTestConfigErrorsChecksums = New Scripting.Dictionary
    Set mTestConfigErrorsSrnNotFound = New Scripting.Dictionary
    Set mTestConfigErrorsOther = New Scripting.Dictionary
    
End Sub

Private Sub Class_Terminate()
    Set mLrus = Nothing
    Set mSrns = Nothing
    Set mTestConfigStatus = Nothing
    Set mTestConfigErrorsChecksums = Nothing
    Set mTestConfigErrorsSrnNotFound = Nothing
    Set mTestConfigErrorsOther = Nothing
End Sub
Attribute VB_Name = "cTestReport"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mStdAssociated As String
Private mReportSubType As String
Private mTestConfig As cTestConfig
Private mTestSummary As cTestSummary
Private mTestResults As Scripting.Dictionary ' of class cTestResult
Private mTestSetsNotExecuted As Scripting.Dictionary

Property Get StdAssociated() As String
    StdAssociated = mStdAssociated
End Property

Property Get ReportSubType() As String
    ReportSubType = mReportSubType
End Property

Property Get TestConfig() As cTestConfig
    Set TestConfig = mTestConfig
End Property

Property Get TestSummary() As cTestSummary
    Set TestSummary = mTestSummary
End Property

Property Get TestResults() As Scripting.Dictionary
    Set TestResults = mTestResults
End Property

Property Get TestSetsNotExecuted() As Scripting.Dictionary
    Set TestSetsNotExecuted = mTestSetsNotExecuted
End Property

Function ProcessResults(ByVal strreport As String, ByVal strreportsubtype As String, _
                        ByVal dteref As Date, ByRef srninfo As cSrns, ByRef frm As Object) As Boolean
    Dim strdocfolder As String, strtestscriptroot As String, strstdfolder As String
    Dim fso As FileSystemObject, fold As Folder
On Error GoTo Err_ProcessResults

    Set fso = New FileSystemObject
    
    mReportSubType = strreportsubtype

    If strreport <> vbNullString Then
        mStdAssociated = GetSTDFileNameFromSTR(strreport)
        
        ' process the log files beneath the STD folder in the test script root
        strdocfolder = fso.GetParentFolderName(strreport)
        If strreportsubtype Like "hltests" Or strreportsubtype Like "lltests" Then
            strtestscriptroot = fso.GetAbsolutePathName(fso.BuildPath(strdocfolder, Const_TEST_FOLDER_PATH_REL2DOC))
        End If
        If strtestscriptroot = vbNullString Then
            frm.UpdateProgressText "ERROR: Test script root not specified - ensure that the '" & Const_TEST_SCRIPT_ROOT & "' macro is defined in a makefile"
        ElseIf Not fso.FolderExists(strtestscriptroot) Then
            frm.UpdateProgressText "ERROR: Test script root folder '" & strtestscriptroot & "' specified in the makefile does not exist"
        Else
            strstdfolder = fso.BuildPath(strtestscriptroot, fso.GetBaseName(mStdAssociated))
            If fso.FolderExists(strstdfolder) Then
                Set fold = fso.GetFolder(strstdfolder)
                Call ProcessTestLogFiles(fold, dteref, srninfo, frm)
            Else
                frm.UpdateProgressText "WARNING: STD test folder '" & strstdfolder & "' does not exist"
            End If
            
            ' consolidate the test configuration
            mTestConfig.Consolidate mReportSubType, strreport, mTestResults
            
            ' consolidate the test summary
            Call ConsolidateTestSummary
            
            ProcessResults = True
        End If
    End If
    
Exit_ProcessResults:
    Exit Function

Err_ProcessResults:
    MsgBox Err.Description & " in ProcessResults() of cTestReport"
    Resume Exit_ProcessResults
End Function

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String, strtemp As String, idx As Integer, rslt As cTestResult
        
    strdebug = strindent & mStdAssociated & " (" & mReportSubType & ")" & vbCrLf
    strtemp = mTestConfig.DebugString(strindent)
    strdebug = strdebug & strtemp ' have to do this temp else concat does not work?
    strtemp = mTestSummary.DebugString(strindent)
    strdebug = strdebug & strtemp
    
    For idx = 0 To mTestResults.Count - 1
        Set rslt = mTestResults.Items(idx)
        strdebug = strdebug & vbCrLf & rslt.DebugString(strindent & "  ")
    Next idx
    
    For idx = 0 To mTestSetsNotExecuted.Count - 1
        strdebug = strdebug & strindent & "  " & mTestSetsNotExecuted.Keys(idx) & " (" & mTestSetsNotExecuted.Items(idx) & " test cases): " & Const_TESTRESULT_NOTEXECUTED & vbCrLf
    Next idx

    DebugString = strdebug
    
End Function

Private Sub ProcessTestLogFiles(ByRef fold As Folder, ByVal dteref As Date, ByRef srninfo As cSrns, ByRef frm As Object)
    Dim fso As FileSystemObject, fil As File, subfold As Folder, idx As Integer, tstresult As cTestResult
    Dim blresultsexist As Boolean, strtestscript As String, strresultsuffix As String, strscriptsuffix As String, strpattern As String
    
    Set fso = New FileSystemObject
    
    ' determine result and script file suffixes
    Set tstresult = New cTestResult
    If mReportSubType Like "hltests" Then
        strresultsuffix = tstresult.TestResultFileSuffixHl
        strscriptsuffix = ".cs"
    Else
        strresultsuffix = tstresult.TestResultFileSuffixLl
        strscriptsuffix = ".c"
    End If
    
    ' open each log file and extract information
    For Each fil In fold.Files
        blresultsexist = False
        
        ' check whether a result file and its associated test script exist side-by-side
        If fil.Name Like "*" & strresultsuffix Then
            ' strip off the test result suffix from the log file names - note that log files may include the associated test script suffix in their names
            strpattern = "(" & strscriptsuffix & strresultsuffix & "|" & strresultsuffix & ")$"
            strpattern = Replace(strpattern, ".", "\.")
            strtestscript = RegularExpressionReplace(fil.Path, strpattern, vbNullString) & strscriptsuffix
            If fso.FileExists(strtestscript) Then
                ' check whether a similar log file has not already been processed (i.e. log file might be in a back-up folder)
                For idx = 0 To mTestResults.Count - 1
                    If fil.Name = fso.GetFileName(mTestResults.Keys(idx)) Then
                        frm.UpdateProgressText "  INFO - Skipping processing of results in '" & fil.Name & "' in folder '" & fil.ParentFolder & "' as similar results have already been extracted from '" & mTestResults.Keys(idx) & "'."
                        blresultsexist = True
                        Exit For
                    End If
                Next idx
                
                ' skip log file if results already exist
                If Not blresultsexist Then
                    If mReportSubType = "hltests" Then
                        Call ParseHlTestLogFile(fil.Path, strtestscript, strscriptsuffix, dteref, srninfo, frm)
                    Else
                        Call ParseLlTestLogFile(fil.Path, strtestscript)
                    End If
                End If
            End If
        End If
    Next fil
    
    ' recursively call this function for each subfolder in the given folder
    For Each subfold In fold.SubFolders
        Call ProcessTestLogFiles(subfold, dteref, srninfo, frm)
    Next subfold
    
End Sub

Private Sub ParseHlTestLogFile(ByVal strlogfile As String, ByVal strtestscript As String, ByVal strscriptsuffix As String, ByVal dteref As Date, ByRef srninfo As cSrns, ByRef frm As Object)
    Dim xmldoc As MSXML2.DOMDocument60, nodrpt As IXMLDOMNode, nodtcaselist As IXMLDOMNode, nodtcase As IXMLDOMNode, nod As IXMLDOMNode
    Dim nodbin As IXMLDOMNode, nodlru As IXMLDOMNode, nodlrus As IXMLDOMNodeList, nodcscis As IXMLDOMNodeList, nodbins As IXMLDOMNodeList
    Dim tstresult As cTestResult, tstcase As cTestCase, tstsum As cTestSummary, idx As Integer, strbookmark As String, strtime As String
    Dim fso As FileSystemObject, blautomated As Boolean, bltestsetfound As Boolean, strfolder As String, strtest As String, strchecksum As String
    Dim diccsci As Scripting.Dictionary, dicbkmrks As Scripting.Dictionary, csc As cCsci, strlru As String, strcsci As String, strbin As String
On Error GoTo Err_ParseHlTestLogFile

    Set fso = New FileSystemObject
    
    Set xmldoc = New MSXML2.DOMDocument60
    If xmldoc.Load(strlogfile) = True Then
        xmldoc.setProperty "SelectionNamespaces", "xmlns:ns='http://schemas.datacontract.org/2004/07/Efst'"
        xmldoc.setProperty "SelectionLanguage", "XPath"
        ' find the custom reports section
        Set nodrpt = GetHlTestAttributeNode(xmldoc, "ReportingData", "CustomTestSetReporting")
        If Not nodrpt Is Nothing Then
            ' get the working folder
            strfolder = fso.GetParentFolderName(strlogfile)
            
            '==================================================================================
            ' Test Set data
            '==================================================================================
            Set tstresult = New cTestResult
            ' only process result file if it contains new results
            strtime = GetSingleNodeText(nodrpt, "StartTime")
            If strtime <> vbNullString Then tstresult.TestSummary.TestStartDate = strtime
            If tstresult.TestSummary.TestStartDate >= dteref Then
                tstresult.TestResultFile = strlogfile
                Set nod = GetSingleNode(nodrpt, "TestSetName")
                If Not nod Is Nothing Then
                    strtest = GetItemName(nod.Text)
                    tstresult.TestSpec = GetTestSpecificationName(strtest)
                    tstresult.TestSet = fso.GetBaseName(strtestscript)
                    tstresult.TestScript = strtestscript
                    blautomated = IIf(InStr(1, strtest, "tshlia_"), True, False)
                    
                    '==================================================================================
                    ' Test Case data
                    '==================================================================================
                    Set nodtcaselist = GetSingleNode(nodrpt, "TestCaseList")
                    If Not nodtcaselist Is Nothing Then
                        For Each nodtcase In nodtcaselist.ChildNodes
                            Set nod = GetSingleNode(nodtcase, "TestCaseName")
                            If Not nod Is Nothing Then
                                Set tstcase = New cTestCase
                                tstcase.TestCase = GetItemName(nod.Text)
                                tstcase.TestScript = fso.BuildPath(strfolder, tstcase.TestCase & strscriptsuffix)
                                tstcase.Result = IIf(GetSingleNodeText(nodtcase, "TestCaseResult/TestCasePassedFailed") = "PASSED", Const_TESTRESULT_PASSED, Const_TESTRESULT_FAILED)
                                For Each nod In GetSingleNode(nodtcase, "TestCaseComments").ChildNodes
                                    tstcase.Comments = tstcase.Comments & IIf(tstcase.Comments <> vbNullString, vbCrLf, vbNullString) & nod.Text
                                Next nod
                                tstresult.TestCases.Add tstcase.TestCase, tstcase
                            End If
                        Next nodtcase
                    End If
                    
                    '==================================================================================
                    ' Test Summary data (test start time already set above)
                    '==================================================================================
                    Set tstsum = tstresult.TestSummary
                    strtime = Left(GetSingleNodeText(nodrpt, "Duration"), 8)  ' ignore fractional seconds part (date part starts at zero)
                    If strtime <> vbNullString Then tstsum.TestDuration = strtime
                    For idx = 0 To tstresult.TestCases.Count - 1
                        tstsum.TestCasesExecuted = tstsum.TestCasesExecuted + 1
                        If tstresult.TestCases.Items(idx).Result = Const_TESTRESULT_FAILED Then
                            tstsum.TestCasesFailed = tstsum.TestCasesFailed + 1
                        End If
                    Next idx
                    ' determine which test cases were not executed, but only for those test sets found in the results log - the top-level
                    ' summary will add empty test set results for those tests sets that were not executed
                    ' find the current test set specification in the sequentially ordered bookmark list for this STD
                    Set dicbkmrks = Dst.Document(mStdAssociated).Bookmarks.Internal
                    For idx = 0 To dicbkmrks.Count - 1
                        strbookmark = dicbkmrks.Keys(idx)
                        If Not bltestsetfound Then
                            If strbookmark = tstresult.TestSpec Then
                                ' test set found, so the next bookmark should be the first test case in the set
                                bltestsetfound = True
                            End If
                        Else
                            ' check if this is the next test set so we can exit
                            If InStr(1, strbookmark, "tshl_") Then
                                Exit For
                            Else
                                ' check which test cases in the set in the STD were not executed
                                If RegularExpressionSearch(strbookmark, "^tchl[n|r]_") Then
                                    strtest = GetTestImplementationName(strbookmark, blautomated)
                                    If Not tstresult.TestCases.Exists(strtest) Then
                                        ' update summary metric and add the test case to the list of results
                                        tstsum.TestCasesNotExecuted = tstsum.TestCasesNotExecuted + 1
                                        Set tstcase = New cTestCase
                                        tstcase.TestCase = strtest
                                        tstcase.TestScript = fso.BuildPath(strfolder, strtest) & strscriptsuffix
                                        tstcase.Result = Const_TESTRESULT_NOTEXECUTED
                                        tstresult.TestCases.Add tstcase.TestCase, tstcase
                                    End If
                                End If
                            End If
                        End If
                    Next idx
                
                    '==================================================================================
                    ' Test Config data - FAST
                    '==================================================================================
                    ' find the FAST validation section and use the basename in the relevant node queries
                    Set nodrpt = GetHlTestAttributeNode(xmldoc, "ReportingData", "EfastValidationResult")
                    If Not nodrpt Is Nothing And Not tstresult Is Nothing Then
                        Set nod = GetSingleNode(nodrpt, "VmiwValidationResult")
                        If Not nod Is Nothing Then
                            If GetSingleNodeText(nod, "Passed") = "true" Then
                                tstresult.TestConfig.FastVersion = GetSingleNodeText(nod, "Version")
                            End If
                        End If
                    End If
                    
                    '==================================================================================
                    ' Test Config data - Test Files
                    '==================================================================================
                    ' find the FAST validation section and use the basename in the relevant node queries
                    Set nodrpt = GetHlTestAttributeNode(xmldoc, "ReportingData", "TestFilesValidationResult")
                    If Not nodrpt Is Nothing And Not tstresult Is Nothing Then
                        Set nod = GetSingleNode(nodrpt, "CvsTagValidationResult")
                        If Not nod Is Nothing Then
                            If GetSingleNodeText(nod, "Passed") = "true" Then
                                tstresult.TestConfig.TestFilesVersion = GetSingleNodeText(nod, "Version")
                            End If
                        End If
                    End If
                                                                
                    '==================================================================================
                    ' Test Config data - CSCIs
                    ' Note: It is assumed that the binary name within an LRU is unique. Therefore the
                    '       code below (and the input test log files) does not cater for the case where
                    '       the same binary is loaded onto multiple SRUs
                    '==================================================================================
                    Set nodrpt = GetHlTestAttributeNode(xmldoc, "ReportingData", "CustomChecksumReporting")
                    If Not nodrpt Is Nothing And Not tstresult Is Nothing Then
                        Set nodlrus = GetSingleNode(nodrpt, "LruList").ChildNodes
                        For Each nodlru In nodlrus
                            strlru = UCase(GetSingleNodeText(nodlru, "LruName"))
                            Set nodcscis = GetSingleNode(nodlru, "CsciList").ChildNodes
                            Set diccsci = New Scripting.Dictionary
                            For Each nod In nodcscis
                                strcsci = GetSingleNodeText(nod, "Id")
                                Set nodbins = GetSingleNode(nod, "BinaryList").ChildNodes
                                For Each nodbin In nodbins
                                    strchecksum = GetSingleNodeText(nodbin, "Checksum")
                                    strbin = GetSingleNodeText(nodbin, "Name")
                                    If strchecksum <> "0" Then ' only process bins with checksums
                                        Set csc = New cCsci
                                        csc.Name = strcsci
                                        csc.BinName = strbin
                                        csc.Checksum = "0x" & strchecksum
                                        diccsci.Add strbin, csc
                                    End If
                                Next nodbin
                            Next nod
                            If diccsci.Count > 0 Then
                                tstresult.TestConfig.Lrus.Add strlru, diccsci ' only add LRU if it has CSCIs
                            End If
                        Next nodlru
                        
                        ' check test configuration against SRN info
                        tstresult.TestConfig.CheckHlConfigAgainstSrn srninfo
                    End If
                    
                    ' add the test set result to the dictionary
                    If Not tstresult Is Nothing Then
                        mTestResults.Add strlogfile, tstresult
                    End If
                End If
            End If
        Else
            frm.UpdateProgressText "ERROR: The log file '" & fso.GetFileName(strlogfile) & "' does not contain the 'CustomTestSetReporting' node"
        End If
    Else
        MsgBox "XML Parse error in '" & strlogfile & "': Code=" & xmldoc.parseError.ErrorCode & ", Reason=" & xmldoc.parseError.reason
    End If
    
Exit_ParseHlTestLogFile:
    Exit Sub

Err_ParseHlTestLogFile:
    MsgBox Err.Description & " in ParseHlTestLogFile() of cTestReport"
    Resume Exit_ParseHlTestLogFile
End Sub
  
Private Sub ParseLlTestLogFile(ByVal strlogfile As String, ByVal strtestscript As String)
    Dim xmldoc As MSXML2.DOMDocument60, nodrpt As IXMLDOMNode, nodtcaselist As IXMLDOMNode, nodtcase As IXMLDOMNode, nod As IXMLDOMNode
    Dim tstresult As cTestResult, tstcase As cTestCase
On Error GoTo Err_ParseLlTestLogFile

    Set xmldoc = New MSXML2.DOMDocument60
    If xmldoc.Load(strlogfile) = True Then
        ' find the custom reports section
        Set nodrpt = xmldoc.SelectSingleNode("TestResult")
        If Not nodrpt Is Nothing Then
            '==================================================================================
            ' Test Set data
            '==================================================================================
            Set tstresult = New cTestResult
            tstresult.TestResultFile = strlogfile
            tstresult.TestScript = strtestscript
            tstresult.TestSet = GetSingleNodeText(nodrpt, "TestSetName")
            tstresult.TestSpec = tstresult.TestSet
            
            '==================================================================================
            ' Test Summary data
            '==================================================================================
            tstresult.TestSummary.TestStartDate = GetSingleNodeText(nodrpt, "StartTime")
            tstresult.TestSummary.TestDuration = GetSingleNodeText(nodrpt, "Duration")
            tstresult.TestSummary.TestCasesExecuted = GetSingleNodeText(nodrpt, "TestCasesExecuted")
            tstresult.TestSummary.TestCasesFailed = GetSingleNodeText(nodrpt, "TestCasesFailed")
            tstresult.TestSummary.TestCasesNotExecuted = GetSingleNodeText(nodrpt, "TestCasesNotExecuted")
            ' NOTE: the top-level summary will check for tests sets that were not executed based on missing result files
            
            '==================================================================================
            ' Test Case data
            '==================================================================================
            Set nodtcaselist = GetSingleNode(nodrpt, "TestCaseList")
            If Not nodtcaselist Is Nothing Then
                For Each nodtcase In nodtcaselist.ChildNodes
                    Set nod = GetSingleNode(nodtcase, "TestCaseName")
                    If Not nod Is Nothing Then
                        Set tstcase = New cTestCase
                        tstcase.TestCase = nod.Text
                        tstcase.TestScript = tstresult.TestScript ' implemented in same script as test set
                        tstcase.Result = IIf(GetSingleNodeText(nodtcase, "TestCaseResult") = "passed", Const_TESTRESULT_PASSED, Const_TESTRESULT_FAILED)
                        If Not tstresult.TestCases.Exists(tstcase.TestCase) Then
                            tstresult.TestCases.Add tstcase.TestCase, tstcase
                        Else
                            MsgBox "Multiple results found for test case '" & tstcase.TestCase & "'. Ensure your test script's START_TEST labels are correct.", vbCritical
                        End If
                    End If
                Next nodtcase
            End If
            
            '==================================================================================
            ' Test Cases not Executed
            '==================================================================================
            Set nodtcaselist = GetSingleNode(nodrpt, "TestCaseNotExecutedList")
            If Not nodtcaselist Is Nothing Then
                For Each nodtcase In nodtcaselist.ChildNodes
                    Set nod = GetSingleNode(nodtcase, "TestCaseName")
                    If Not nod Is Nothing Then
                        Set tstcase = New cTestCase
                        tstcase.TestCase = nod.Text
                        tstcase.TestScript = strtestscript ' implemented in test set script
                        tstcase.Result = Const_TESTRESULT_NOTEXECUTED
                        tstresult.TestCases.Add tstcase.TestCase, tstcase
                    End If
                Next nodtcase
            End If
            
            '==================================================================================
            ' Test Configuration
            '==================================================================================
            tstresult.TestConfig.ProcessConfig GetSTRFileNameFromSTD(mStdAssociated), mReportSubType, tstresult.TestConfigFile
            
            ' add the test set result to the dictionary
            If Not tstresult Is Nothing Then
                mTestResults.Add strlogfile, tstresult
            End If
        End If
    Else
        MsgBox "XML Parse error in '" & strlogfile & "': Code=" & xmldoc.parseError.ErrorCode & ", Reason=" & xmldoc.parseError.reason
    End If
    
Exit_ParseLlTestLogFile:
    Exit Sub

Err_ParseLlTestLogFile:
    MsgBox Err.Description & " in ParseLlTestLogFile() of cTestReport"
    Resume Exit_ParseLlTestLogFile
End Sub
  
Private Sub ConsolidateTestSummary()
    Dim idx As Integer, idxrslt As Integer
    Dim strtestset As String, strbookmark As String, strspecprefix As String
    Dim dicbkmrks As Scripting.Dictionary
       
    If mReportSubType = "hltests" Then
        strspecprefix = "tshl_"
    Else
        strspecprefix = "tsm_"
    End If
    
    ' Determine which test sets in the STD were not executed at all. For each of test set not executed and add it to
    ' the list. Also update the summary TestCasesNotExecuted metric.
    
    ' NOTE: Test cases not executed as part of test sets for which results were found in the results log have already
    '       been taken into account when the log file was processed.
    
    ' First loop though each test specification in the sequentially ordered bookmark list for this STD and build a
    ' dictionary of test sets (keys) with the number of test cases of each (items)
    Set dicbkmrks = Dst.Document(mStdAssociated).Bookmarks.Internal
    For idx = 0 To dicbkmrks.Count - 1
        strbookmark = dicbkmrks.Keys(idx)
        If InStr(1, strbookmark, strspecprefix) = 1 Then
            strtestset = strbookmark
            If mReportSubType = "hltests" Then
                mTestSetsNotExecuted.Add strtestset, 0 ' add test set to list, number of test cases updated below
            Else
                mTestSetsNotExecuted.Add strtestset, 1 ' add test set to list, test cases not documented in lltests STD, so set to 1
            End If
        ElseIf mReportSubType = "hltests" Then
            ' if we need to find test cases and one is found, update the test sets not executed metric
            If RegularExpressionSearch(strbookmark, "^tchl[n|r]_") And strtestset <> vbNullString Then
                mTestSetsNotExecuted(strtestset) = mTestSetsNotExecuted(strtestset) + 1
            End If
        End If
    Next idx
    
    ' Now loop through this dictionary and remove those entries for which results exist (i.e. those that were executed)
    For idx = 0 To mTestSetsNotExecuted.Count - 1
        For idxrslt = 0 To mTestResults.Count - 1
            If idx < mTestSetsNotExecuted.Count Then ' this occurs because entries are removed without the loop max count being updated
                If mTestResults.Items(idxrslt).TestSpec = mTestSetsNotExecuted.Keys(idx) Then
                    mTestSetsNotExecuted.Remove mTestSetsNotExecuted.Keys(idx)
                    idx = -1 ' restart outer loop at 0 after 'Next' directive below
                    Exit For
                End If
            End If
        Next idxrslt
    Next idx
    
    ' Finally update the summary test cases not executed metric using the results above
    For idx = 0 To mTestSetsNotExecuted.Count - 1
        mTestSummary.TestCasesNotExecuted = mTestSummary.TestCasesNotExecuted + mTestSetsNotExecuted.Items(idx) ' the dictionary items contain the number of test cases
    Next idx
    
    ' sum metrics from each test set
    mTestSummary.Consolidate mTestResults
    
End Sub

Private Function GetItemName(ByVal strname As String) As String
    GetItemName = Right(strname, Len(strname) - InStrRev(strname, "."))
End Function

Private Sub Class_Initialize()
    Set mTestConfig = New cTestConfig
    Set mTestSummary = New cTestSummary
    Set mTestResults = New Scripting.Dictionary
    Set mTestSetsNotExecuted = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mTestConfig = Nothing
    Set mTestSummary = Nothing
    Set mTestResults = Nothing
    Set mTestSetsNotExecuted = Nothing
End Sub
Attribute VB_Name = "cTestReportSum"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mTestReportName As String
Private mReportSubType As String
Private mTestConfig As cTestConfig
Private mTestSummary As cTestSummary
Private mTestReports As Scripting.Dictionary ' of class cTestReport
Private mCoverageReport As cCoverageReport

Property Get TestReportName() As String
    TestReportName = mTestReportName
End Property

Property Get ReportSubType() As String
    ReportSubType = mReportSubType
End Property

Property Get TestConfig() As cTestConfig
    Set TestConfig = mTestConfig
End Property

Property Get TestSummary() As cTestSummary
    Set TestSummary = mTestSummary
End Property

Property Get TestReports() As Scripting.Dictionary
    Set TestReports = mTestReports
End Property

Property Get CoverageReport() As cCoverageReport
    Set CoverageReport = mCoverageReport
End Property

Function ProcessResults(ByVal strreport As String, ByVal strreportsubtype As String, ByVal dteteststart As Date, ByRef srninfo As cSrns, ByRef frm As Object) As Boolean
    Dim doclst As cDocList, docinfo As cDocInfo, doc As cDocInfo, strmessage As String, strdoctype As String
    Dim idx As Integer, varsubtype As Variant
    Dim testrpt As cTestReport, srn As cSrn, dicstrs As Scripting.Dictionary
    
    mTestReportName = strreport
    mReportSubType = strreportsubtype
    
    Set docinfo = Dst.Document(strreport)
    Set doclst = docinfo.DocList
    strdoctype = docinfo.Properties.TypeAbbr
    If strdoctype <> "STR" Then
        Exit Function
    End If
    
    ' now process the results for all STRs
    Set dicstrs = New Scripting.Dictionary
    For idx = 0 To doclst.AllDocuments.Count - 1
        Set doc = doclst.AllDocuments.Items(idx)
        If doc.Properties.TypeAbbr = strdoctype Then
            dicstrs.Add doc.Properties.Fullname, doc
        End If
    Next idx
    
    ' find all the reports related to the current report and add them to the dictionary
    For idx = 0 To dicstrs.Count - 1
        Set doc = dicstrs.Items(idx)
        frm.UpdateProgressMeter idx, dicstrs.Count
        For Each varsubtype In doc.Properties.SubTypesAsDictionary
            If mReportSubType Like varsubtype & "*" Then
                If varsubtype Like "*tests" Then
                    frm.UpdateProgressText "Processing '" & varsubtype & "' results for " & doc.Properties.Shortname & "..."
                    Set testrpt = New cTestReport
                    testrpt.ProcessResults doc.Properties.Fullname, varsubtype, dteteststart, srninfo, frm
                    mTestReports.Add doc.Properties.Fullname, testrpt
                End If
            End If
        Next varsubtype
    Next idx
    frm.UpdateProgressMeter (-1)
        
    ' process the overall coverage results
    If mReportSubType Like "*structcovsum" Then
        mCoverageReport.ProcessResults mTestReportName, mReportSubType, dteteststart, srninfo, frm, True
    Else
        ' summarise the test configurations
        mTestConfig.Consolidate mReportSubType, mTestReportName, mTestReports
        
        ' summarise the test results
        mTestSummary.Consolidate mTestReports
    End If
    
    ProcessResults = True
            
End Function

Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String, idx As Integer, srn As cSrn, tstrpt As cTestReport
        
    strdebug = strdebug & strindent & "REPORT: " & mTestReportName & vbCrLf
    strdebug = strdebug & strindent & "Sub-type: " & mReportSubType & vbCrLf
    
    If mReportSubType Like "*tests*" Then
        strdebug = strdebug & mTestConfig.DebugString(strindent)
        strdebug = strdebug & mTestSummary.DebugString(strindent)
        For idx = 0 To mTestReports.Count - 1
            strdebug = strdebug & strindent & "  " & String(100, "/") & vbCrLf
            Set tstrpt = mTestReports.Items(idx)
            strdebug = strdebug & tstrpt.DebugString(strindent & "  ")
        Next idx
    End If
        
    If mReportSubType Like "*structcov*" Then
        strdebug = strdebug & mCoverageReport.DebugString(strindent)
    End If
        
    DebugString = strdebug

End Function

Private Sub Class_Initialize()
    Set mTestConfig = New cTestConfig
    Set mTestSummary = New cTestSummary
    Set mTestReports = New Scripting.Dictionary
    Set mCoverageReport = New cCoverageReport
End Sub

Private Sub Class_Terminate()
    Set mTestConfig = Nothing
    Set mTestSummary = Nothing
    Set mTestReports = Nothing
    Set mCoverageReport = Nothing
End Sub
Attribute VB_Name = "cTestResult"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mTestSpec As String
Private mTestSet As String
Private mTestScript As String
Private mTestResultFile As String
Private mTestConfig As cTestConfig
Private mTestSummary As cTestSummary
Private mTestCases As Scripting.Dictionary

Public Property Get TestSpec() As String
    TestSpec = mTestSpec
End Property

Public Property Let TestSpec(ByVal strspec As String)
    mTestSpec = strspec
End Property

Public Property Get TestSet() As String
    TestSet = mTestSet
End Property

Public Property Let TestSet(ByVal strset As String)
    mTestSet = strset
End Property

Public Property Get TestScript() As String
    TestScript = mTestScript
End Property

Public Property Let TestScript(ByVal strscript As String)
    mTestScript = strscript
End Property

Public Property Get TestResultFile() As String
    TestResultFile = mTestResultFile
End Property

Public Property Let TestResultFile(ByVal strfile As String)
    mTestResultFile = strfile
End Property

Property Get TestConfig() As cTestConfig
    Set TestConfig = mTestConfig
End Property

Property Get TestSummary() As cTestSummary
    Set TestSummary = mTestSummary
End Property

Property Get TestCases() As Scripting.Dictionary
    Set TestCases = mTestCases
End Property

Public Property Get TestResultFileSuffixHl() As String
    TestResultFileSuffixHl = ".log.xml"
End Property

Public Property Get TestResultFileSuffixLl() As String
    TestResultFileSuffixLl = ".results.xml"
End Property

Property Get TestCtrFile() As String
    If mTestResultFile Like "*" & TestResultFileSuffixLl Then TestCtrFile = Replace(mTestResultFile, TestResultFileSuffixLl, ".ctr")
End Property

Property Get TestConfigFile() As String
    If mTestResultFile Like "*" & TestResultFileSuffixLl Then TestConfigFile = Replace(mTestResultFile, TestResultFileSuffixLl, ".config.xml")
End Property
  
Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String
    Dim idx As Integer, tcase As cTestCase
        
    strdebug = strindent & String(75, "-") & vbCrLf
    strdebug = strdebug & strindent & "Test spec: " & mTestSpec & vbCrLf
    strdebug = strdebug & strindent & "Test set: " & mTestSet & vbCrLf
    strdebug = strdebug & strindent & "Test script:" & mTestScript & vbCrLf
    strdebug = strdebug & strindent & "Log file: " & mTestResultFile & vbCrLf
    strdebug = strdebug & strindent & "CTR file: " & TestCtrFile & vbCrLf
    strdebug = strdebug & strindent & "Config file: " & TestConfigFile & vbCrLf
    strdebug = strdebug & mTestConfig.DebugString(strindent)
    strdebug = strdebug & mTestSummary.DebugString(strindent)
    
    For idx = 0 To mTestCases.Count - 1
        Set tcase = mTestCases.Items(idx)
        strdebug = strdebug & tcase.DebugString(strindent & "  ")
    Next idx
    
    DebugString = strdebug
    
End Function

Private Sub Class_Initialize()
    Set mTestConfig = New cTestConfig
    Set mTestSummary = New cTestSummary
    Set mTestCases = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mTestConfig = Nothing
    Set mTestSummary = Nothing
    Set mTestCases = Nothing
End Sub
Attribute VB_Name = "cTestSummary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mTestCasesExecuted As Integer
Private mTestCasesFailed As Integer
Private mTestCasesNotExecuted As Integer
Private mTestDuration As Date ' store test duration as Date type with time component only - for now assume each test case executes in less than 24 hours!
Private mTestStartDate As Date

Public Property Get TestCasesExecuted() As Integer
    TestCasesExecuted = mTestCasesExecuted
End Property

Public Property Let TestCasesExecuted(ByVal intnum As Integer)
    mTestCasesExecuted = intnum
End Property

Public Property Get TestCasesFailed() As Integer
    TestCasesFailed = mTestCasesFailed
End Property

Public Property Let TestCasesFailed(ByVal intnum As Integer)
    mTestCasesFailed = intnum
End Property

Public Property Get TestCasesNotExecuted() As Integer
    TestCasesNotExecuted = mTestCasesNotExecuted
End Property

Public Property Let TestCasesNotExecuted(ByVal intnum As Integer)
    mTestCasesNotExecuted = intnum
End Property

Public Property Get TestDuration() As Date
    TestDuration = mTestDuration
End Property

Public Property Get TestDurationString() As String
    Dim days As Single
    days = Int(mTestDuration)
    TestDurationString = IIf(days > 0, days & " day(s) ", vbNullString) & Format(mTestDuration, "HH:mm:ss")
End Property

Public Property Let TestDuration(ByVal duration As Date)
    mTestDuration = duration
End Property

Public Property Get TestStartDate() As Date
    TestStartDate = mTestStartDate
End Property

Public Property Let TestStartDate(ByVal dte As Date)
    mTestStartDate = dte
End Property

Sub Consolidate(ByRef dic As Scripting.Dictionary)
    Dim idx As Integer, tsum As cTestSummary
    
    ' sum metrics from each dictionary item
    For idx = 0 To dic.Count - 1
        Set tsum = dic.Items(idx).TestSummary
        mTestCasesExecuted = mTestCasesExecuted + tsum.TestCasesExecuted
        mTestCasesFailed = mTestCasesFailed + tsum.TestCasesFailed
        mTestCasesNotExecuted = mTestCasesNotExecuted + tsum.TestCasesNotExecuted
        mTestDuration = mTestDuration + tsum.TestDuration
    Next idx
    
End Sub
    
Function DebugString(Optional ByVal strindent As String = vbNullString) As String
    Dim strdebug As String, days As Single
    
    strdebug = strdebug & strindent & "Tests Executed:     " & mTestCasesExecuted & vbCrLf
    strdebug = strdebug & strindent & "Tests Failed:       " & mTestCasesFailed & vbCrLf
    strdebug = strdebug & strindent & "Tests Not Executed: " & mTestCasesNotExecuted & vbCrLf
    
    days = Int(mTestDuration)
    strdebug = strdebug & strindent & "Started: " & mTestStartDate & " Duration: " & TestDurationString & vbCrLf
        
    DebugString = strdebug
    
End Function

Private Sub Class_Initialize()
    mTestCasesExecuted = 0
    mTestCasesFailed = 0
    mTestCasesNotExecuted = 0
    mTestDuration = 0
    mTestStartDate = 0
End Sub
Attribute VB_Name = "cTextBoxEventHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' This class is used to support the right-click event on text boxes in user forms
' NOTE: Refer to the frmDocInfo form for an example of its use

Public Event RightClicked()

Public TextBoxName As String
Public TextBoxControl As TextBox

Public Sub RightClickTextBox(txt As TextBox)
    TextBoxName = txt.Name
    Set TextBoxControl = txt
    RaiseEvent RightClicked
End Sub
Attribute VB_Name = "cThisApplication"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' This class is used to enable the detection of application events

Public WithEvents oApp As Word.Application
Attribute oApp.VB_VarHelpID = -1

Private Sub oApp_WindowActivate(ByVal objdoc As Document, ByVal wind As Window)
On Error GoTo Err_oApp_WindowActivate

    If BlDSTDebugMode Then Debug.Print "WindowActivate event for " & objdoc.Name & " (" & wind.Caption & ")"
    
    If Not ProtectedViewActive() Then
        If Documents.Count > 0 Then
            ' make sure document is now visible by toggling the visible state - else the document pane remains blank if the
            ' document was already open but invisible
            ' NOTE: The Word Document object's Visible property cannot be used in this case because by the time this event occurs,
            '       property has already been set to visible
            If Not Dst.Document(objdoc.Fullname).DocVisible Then
                If BlDSTDebugMode Then Debug.Print "Toggling visibility for " & objdoc.Fullname
                ForceDocumentVisible objdoc
            End If
            
            ' change the current working directory so relative link updates work correctly
            If objdoc.Path <> vbNullString And Not objdoc.Path Like "http:*" Then Application.ChangeFileOpenDirectory objdoc.Path
        End If
        
        Call InitialiseDSTDocuments(False)
    End If

Exit_oApp_WindowActivate:
    Exit Sub

Err_oApp_WindowActivate:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure oApp_WindowActivate, line " & Erl & "."
    Resume Exit_oApp_WindowActivate
End Sub

Private Sub oApp_WindowDeactivate(ByVal objdoc As Document, ByVal Wn As Window)
On Error GoTo Err_oApp_WindowDeactivate

    If BlDSTDebugMode Then Debug.Print "WindowDeactivate event for " & objdoc.Name
    Set Dst.PreviousDocument = objdoc

Exit_oApp_WindowDeactivate:
    Exit Sub

Err_oApp_WindowDeactivate:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure oApp_WindowDeactivate, line " & Erl & "."
    Resume Exit_oApp_WindowDeactivate
End Sub

Private Sub oApp_DocumentChange()
On Error GoTo Err_oApp_DocumentChange

    If BlDSTDebugMode Then Debug.Print "DocumentChange event for " & ActiveDocument.Fullname

Exit_oApp_DocumentChange:
    Exit Sub

Err_oApp_DocumentChange:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure oApp_DocumentChange, line " & Erl & "."
    Resume Exit_oApp_DocumentChange
End Sub

Private Sub oApp_DocumentOpen(ByVal objdoc As Document)
On Error GoTo Err_oApp_DocumentOpen

    If BlDSTDebugMode Then Debug.Print "DocumentOpen event for " & objdoc.Name

    If Not ProtectedViewActive() Then
        ' set some default Word application options
        Call SetWordOptions
        
        ' make sure the indication that the document was saved at least once in the current edit session is cleared
        Dst.Document(objdoc.Fullname).DocSavedInSession = False
        
        ' clear the debug trace file if this is a new Word session
        If Documents.Count = 1 Then Call WriteDebugFile("Trace file cleared", Const_TRACE_FILENAME)
    End If

Exit_oApp_DocumentOpen:
    Exit Sub

Err_oApp_DocumentOpen:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure oApp_DocumentOpen, line " & Erl & "."
    Resume Exit_oApp_DocumentOpen
End Sub

Private Sub oApp_DocumentBeforeSave(ByVal objdoc As Document, SaveAsUI As Boolean, Cancel As Boolean)
On Error GoTo Err_oApp_DocumentBeforeSave

    If BlDSTDebugMode Then Debug.Print "DocumentBeforeSave event for " & objdoc.Name
        
    ' make sure Word does not change relative paths in hyperlinks to absolute paths when saving the document
    Application.DefaultWebOptions.UpdateLinksOnSave = False
    
    ' indicate that the document was saved at least once in the current edit session
    If objdoc.Name <> "Normal.dotm" Then
        Dst.Document(objdoc.Fullname).DocSavedInSession = True
    End If
    
    If objdoc.Path = vbNullString Then ' if this is blank it implies that the doc does not exist on disk yet
        ' force document info to be-recomputed to catch the case where a new document is saved to a different name
        If BlDSTDebugMode Then Debug.Print "Trigger recompute DocInfo for " & objdoc.Name
    End If
    

Exit_oApp_DocumentBeforeSave:
    Exit Sub

Err_oApp_DocumentBeforeSave:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure oApp_DocumentBeforeSave, line " & Erl & "."
    Resume Exit_oApp_DocumentBeforeSave
End Sub

Private Sub oApp_DocumentBeforeClose(ByVal objdoc As Document, Cancel As Boolean)
On Error GoTo Err_oApp_DocumentBeforeClose

    Dim strmessage As String, intoption As Integer, docinfo As cDocInfo, docopen As Document, blanotherdocvisible As Boolean
    
    If BlDSTDebugMode Then Debug.Print "DocumentBeforeClose event for " & objdoc.Name

    ' only do this if the document:
    '   * is visible (to avoid noise when running BMA, IOT, etc.)
    '   * is writeable
    '   * type is known to DST
    '   * is not a swdiff.bat working file
    '   * has been saved since the current edit session started or needs to be saved
    Set docinfo = Dst.Document(objdoc.Fullname)
    If objdoc.ActiveWindow.Visible And Not objdoc.ReadOnly And _
       Dst.BookmarkConfig.ValidDocumentType(docinfo.Properties.TypeAbbr) <> Const_TEXT_UNKNOWN Then
        If docinfo.DocSavedInSession = True Or objdoc.Saved = False Then
            ' prompt user to save the document first
            If Not objdoc.Saved Then
                intoption = MsgBox("Would you like to save the changes you made to " & vbCrLf & objdoc.Name & "?", vbQuestion + vbYesNoCancel, "Document not Saved")
                If intoption = vbYes Then
                    objdoc.Save
                ElseIf intoption = vbNo Then
                    ' force the saved state to avoid Word'ds save prompt
                    objdoc.Saved = True
                Else
                    ' keep document open
                    Cancel = True
                End If
            End If
            
            If Not Cancel Then
                strmessage = CheckDocumentLastRun(objdoc)
                If strmessage <> vbNullString Then
                    If MsgBox(strmessage & vbCrLf & vbCrLf & "Exit anyway?", vbYesNo + vbQuestion, "Document Check Outdated") <> vbYes Then
                        Cancel = True
                    End If
                End If
            End If
        End If
    End If
    
    If Not Cancel Then
        ' unload all forms attached to the document
        Call UnloadUserForm(, , objdoc.Fullname)
        
        ' remove document being closed from DST object
        Dst.Documents.Remove objdoc.Fullname
        
        ' scan for any visible document, except objdoc being closed
        For Each docopen In Documents
            If docopen.ActiveWindow.Visible And docopen.Fullname <> objdoc.Fullname Then
                blanotherdocvisible = True
                Exit For
            End If
        Next docopen
        
        If BlDSTDebugMode Then Debug.Print "Should now be closing " & objdoc.Name
        
        ' if this is the last visible document, then close the Word application
        If Documents.Count = 1 Or (Documents.Count > 1 And Not blanotherdocvisible) Then
            Application.Quit wdDoNotSaveChanges
        End If
    End If
    
Exit_oApp_DocumentBeforeClose:
    Exit Sub

Err_oApp_DocumentBeforeClose:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure oApp_DocumentBeforeClose, line " & Erl & "."
    Resume Exit_oApp_DocumentBeforeClose
End Sub

Private Sub oApp_WindowSelectionChange(ByVal slct As Selection)
On Error GoTo Err_oApp_WindowSelectionChange

    If BlDSTDebugMode Then Debug.Print "WindowSelectionChange event for " & slct.Document.Name
    
    ' when going to the Print dialogue, a selection change event occurs, but in this case the slct parameter is not usable, so rather use the Selection object
    Call SelectionHasChanged(Selection.Document)

Exit_oApp_WindowSelectionChange:
    Exit Sub

Err_oApp_WindowSelectionChange:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure oApp_WindowSelectionChange, line " & Erl & "."
    Resume Exit_oApp_WindowSelectionChange
End Sub
Attribute VB_Name = "cTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mTimeStart As Single

Function GetDuration(Optional ByVal blrestart As Boolean = False) As Single
    ' time since the timer was (re)started
    GetDuration = Round(Timer() - mTimeStart, 1)
    If blrestart Then Restart
End Function

Sub Restart()
    mTimeStart = Timer()
End Sub

Private Sub Class_Initialize()
    mTimeStart = Timer()
End Sub
Attribute VB_Name = "cTrace"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' For a given item (bookmark), describes the items traces

Private mItem As cDocBookmark
Private mTracedItems As Scripting.Dictionary ' of cTracedItem objects indexed by item (bookmark)

Public Property Get Item() As cDocBookmark
    Set Item = mItem
End Property

Public Property Set Item(ByRef refitem As cDocBookmark)
    Set mItem = refitem
End Property

Public Property Get TracedItems() As Scripting.Dictionary
    Set TracedItems = mTracedItems
End Property

Public Property Get TracedItem(ByVal stritem As String) As cTracedItem
    Set TracedItem = mTracedItems(stritem)
End Property

Public Sub Add(ByRef trc As cTracedItem)
    mTracedItems.Add trc.Bookmark, trc
End Sub

Private Sub Class_Initialize()
    Set mTracedItems = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mItem = Nothing
    Set mTracedItems = Nothing
End Sub
Attribute VB_Name = "cTracedItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' For a given trace, describes the details related to the trace

Private mBookmark As String
Private mTraceType As String ' always populated with the TraceTypeText method
Private mSourceDocument As String ' relative path to reference's source document

Public Property Get Bookmark() As String
    Bookmark = mBookmark
End Property

Public Property Let Bookmark(strvalue As String)
    mBookmark = strvalue
End Property

Public Property Let TraceType(strvalue As String)
    mTraceType = strvalue
End Property

Public Property Get TraceType() As String
    TraceType = mTraceType
End Property

Public Property Get SourceDocument() As String
    SourceDocument = mSourceDocument
End Property

Public Property Let SourceDocument(strvalue As String)
    mSourceDocument = strvalue
End Property
Attribute VB_Name = "cTrcConfig"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' For the DST, describes the overall TRC config by defining TRC-related bookmark prefixes and which prefixes they may
' trace from. This includes the level for each TRC-related bookmark prefix. This class also computes the inverse trace
' types, i.e. the 'trace to' relationships, using the 'trace from' information
' NOTE: Trace types are for example "sys from hl" or "hl to ll". Levels are for example sys, hl, ll, etc.

Private mParent As cDst ' reference to parent DST object
Private mPrefixTraces As Scripting.Dictionary ' of cTrcPrefixConfig objects, indexed by prefix
Private mLevels As Scripting.Dictionary ' indexed by prefix, value indicates level

Property Get Parent() As cDst
    Set Parent = mParent
End Property

Property Set Parent(refparent As cDst)
    Set mParent = refparent
End Property

Property Get PrefixTraces() As Scripting.Dictionary
    Set PrefixTraces = mPrefixTraces
End Property

Property Get PrefixTrace(ByVal strprefix As String) As cTrcPrefixConfig
    Set PrefixTrace = mPrefixTraces(strprefix)
End Property

Property Get PrefixTracesDocType(ByVal strdoctype As String) As Scripting.Dictionary
    '==================================================================================================================================
    ' Description: Returns a dictionary of cTrcPrefixConfig objects, indexed by prefix, for the prefixes associated with the given
    '              document type
    '==================================================================================================================================
    Dim dictrc As Scripting.Dictionary, varitem As Variant
    Set dictrc = New Scripting.Dictionary
    For Each varitem In mPrefixTraces
        If mParent.BookmarkConfig.PrefixesForDocType(strdoctype).Exists(varitem) Then
            dictrc.Add varitem, mPrefixTraces(varitem)
        End If
    Next varitem
    Set PrefixTracesDocType = dictrc
End Property

Property Get TraceFromIdentifier() As String
    TraceFromIdentifier = "from"
End Property

Property Get TraceToIdentifier() As String
    TraceToIdentifier = "to"
End Property

Property Get TraceTypeText(ByVal strprefix As String, ByVal bldirectionfrom As Boolean, ByVal strfromprefix As String) As String
    '==================================================================================================================================
    ' Description: Identifies the trace types according to the convention:
    '              <prefix level> <direction> <traces from/to prefix level>
    '==================================================================================================================================
    TraceTypeText = Level(strprefix) & " " & IIf(bldirectionfrom, TraceFromIdentifier, TraceToIdentifier) & " " & Level(strfromprefix)
End Property

Property Get TraceTypeRank(ByVal strtracetype As String) As Long
    '==================================================================================================================================
    ' Description: Calculates a rank (hierarchy) for the given trace type - this can be used to sort trace types accordingly.
    '              The level index is used to establish rank - lower values have higher rank
    '              - the left part (level) needs to be sorted on first - hence the left shift by 16 bits
    '              - the from identifier has a higher rank than the to identifier - hence the shift with 0
    '              - the right part (level) is used for the final sort order
    '              As an example, we want "sys from dev" to be listed before "sys to hl" and "ll from hl"
    '==================================================================================================================================
    Dim colmatches As MatchCollection
    If SplitIntoWords(strtracetype, colmatches) Then
        If colmatches.Count = 3 Then
            TraceTypeRank = Shift(LevelIndex(colmatches(0)), 16) + _
                            Shift(IIf(colmatches(1) = TraceFromIdentifier, 0, 1), 8) + _
                            LevelIndex(colmatches(2))
        End If
    End If
End Property

Property Get TraceTypesRequired(ByVal strdoctype As String, ByVal bldirectionfrom As Boolean) As Scripting.Dictionary
    '==================================================================================================================================
    ' Description: Returns a dictionary of trace types required for the given document and direction
    '==================================================================================================================================
    Dim dictypes As Scripting.Dictionary, dicprefixcfg As Scripting.Dictionary, dicprefixes As Scripting.Dictionary
    Dim trcpref As cTrcPrefixConfig, strtracetype As String, varitem As Variant, varprefix As Variant
    Set dictypes = New Scripting.Dictionary
    Set dicprefixcfg = PrefixTracesDocType(strdoctype)
    For Each varitem In dicprefixcfg
        Set trcpref = dicprefixcfg(varitem)
        Set dicprefixes = IIf(bldirectionfrom, trcpref.FromPrefixes, trcpref.ToPrefixes)
        For Each varprefix In dicprefixes
            strtracetype = TraceTypeText(trcpref.Prefix, bldirectionfrom, varprefix)
            If Not dictypes.Exists(strtracetype) Then dictypes.Add strtracetype, vbNullString
        Next varprefix
    Next varitem
    Set TraceTypesRequired = dictypes
End Property

Property Get IsTRCDocType(ByVal strdoctype As String) As Boolean
    '==================================================================================================================================
    ' Description: Checks whether the given document type is used for TRC, i.e. if it has any traceability relationships configured
    '==================================================================================================================================
    IsTRCDocType = (mParent.TrcConfig.PrefixTracesDocType(strdoctype).Count > 0)
End Property

Property Get Levels() As Scripting.Dictionary
    Set Levels = mLevels
End Property

Property Get Level(ByVal strprefix As String) As String
    Level = mLevels(strprefix)
End Property

Property Get LevelIndex(ByVal strlevel As String) As Integer
    '==================================================================================================================================
    ' Description: Returns the index (hierarchy) of the given level into the Levels dictionary
    ' NOTE: The hierarchy is determined by the sequence in which the levels are added to the Levels dictionary during the TRC
    '       configuration process.
    '==================================================================================================================================
    Dim idx As Integer
    For idx = 0 To mLevels.Count - 1
        If mLevels.Items(idx) = strlevel Then
            LevelIndex = idx
            Exit For
        End If
    Next idx
End Property

Property Get LevelIndexFromPrefix(ByVal strprefix As String) As Integer
    '==================================================================================================================================
    ' Description: Returns the index (hierarchy) of the given prefix into the Levels dictionary
    '==================================================================================================================================
    Dim idx As Integer
    For idx = 0 To mLevels.Count - 1
        If mLevels.Keys(idx) = strprefix Then
            LevelIndexFromPrefix = idx
            Exit For
        End If
    Next idx
End Property

Property Get LevelsDocType(ByVal strdoctype As String) As Scripting.Dictionary
    '==================================================================================================================================
    ' Description: Returns the levels defined for the given document type
    '==================================================================================================================================
    Dim diclvl As Scripting.Dictionary, varitem As Variant
    Set diclvl = New Scripting.Dictionary
    For Each varitem In mLevels
        If mParent.BookmarkConfig.PrefixesForDocType(strdoctype).Exists(varitem) Then
            diclvl.Add varitem, Level(varitem)
        End If
    Next varitem
    Set LevelsDocType = diclvl
End Property

Sub Add(ByVal strbookprefix As String, ByRef vartrcfromprefixes As Variant)
    '==================================================================================================================================
    ' Description: Adds the given list of prefixes that may be 'traced from' the given bookmark prefix to the trace types dictionary.
    '              Also populates the inverse trace configuration, i.e. the 'trace to' types.
    '==================================================================================================================================
    Dim fromtrc As cTrcPrefixConfig, totrc As cTrcPrefixConfig, varprefix As Variant, dicprefixes As Scripting.Dictionary
On Error GoTo Err_Add

    If mParent.BookmarkConfig.Prefixes.Exists(strbookprefix) Then
        Set fromtrc = New cTrcPrefixConfig
        fromtrc.Prefix = strbookprefix
        Call ArrayToDictionary(vartrcfromprefixes, fromtrc.FromPrefixes)
        If mParent.BookmarkConfig.PrefixesExistInRef(fromtrc.FromPrefixes, "TrcFromPrefixes") Then ' if it is a valid prefix
            mPrefixTraces.Add strbookprefix, fromtrc
        
            ' also add the 'to' trace prefixes
            For Each varprefix In fromtrc.FromPrefixes
                If Not mPrefixTraces.Exists(varprefix) Then
                    Set totrc = New cTrcPrefixConfig
                    totrc.Prefix = varprefix
                    mPrefixTraces.Add varprefix, totrc
                End If
                Set totrc = mPrefixTraces(varprefix)
                totrc.ToPrefixes.Add strbookprefix, strbookprefix
            Next varprefix
        End If
    Else
        MsgBox "Prefix '" & strbookprefix & "' does not exist in the bookmark configuration - contact the DST owner!", vbCritical
    End If
Exit_Add:
    Exit Sub

Err_Add:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in Add() of cTrcConfig"
    Resume Exit_Add
End Sub

Property Get ConfigAsText(Optional ByVal strdoctype As String = vbNullString) As String
    '==================================================================================================================================
    ' Description: Returns the TRC configuration (content of this class) as readable text
    '==================================================================================================================================
    Dim strtemp As String, varitem As Variant, varprefix As Variant, trcpref As cTrcPrefixConfig
    Dim diclvl As Scripting.Dictionary, dictrc As Scripting.Dictionary
        
    strtemp = "Traceability Levels and Indexes for each Prefix:"
    ConfigAsText = strtemp & vbCrLf & String(Len(strtemp), "=") & vbCrLf
    If strdoctype = vbNullString Then
        Set diclvl = Levels
        Set dictrc = PrefixTraces
    Else
        Set diclvl = LevelsDocType(strdoctype)
        Set dictrc = PrefixTracesDocType(strdoctype)
    End If

    For Each varitem In diclvl
        ConfigAsText = ConfigAsText & "[-] " & varitem & ": " & Level(varitem) & " (" & LevelIndexFromPrefix(varitem) & ")" & vbCrLf
    Next varitem
    
    strtemp = "Traceability Types for each Prefix:"
    ConfigAsText = ConfigAsText & vbCrLf & strtemp & vbCrLf & String(Len(strtemp), "=") & vbCrLf
    For Each varitem In dictrc
        Set trcpref = PrefixTrace(varitem)
        ConfigAsText = ConfigAsText & "[-] " & trcpref.Prefix & vbCrLf
        If trcpref.FromPrefixes.Count > 0 Then ConfigAsText = ConfigAsText & "    " & UCase(TraceFromIdentifier) & " <===" & vbCrLf
        For Each varprefix In trcpref.FromPrefixes
            ConfigAsText = ConfigAsText & "      * " & varprefix & " (" & TraceTypeText(varitem, True, varprefix) & ")" & vbCrLf
        Next varprefix
        If trcpref.ToPrefixes.Count > 0 Then ConfigAsText = ConfigAsText & "    " & UCase(TraceToIdentifier) & " ===>" & vbCrLf
        For Each varprefix In trcpref.ToPrefixes
            ConfigAsText = ConfigAsText & "      * " & varprefix & " (" & TraceTypeText(varitem, False, varprefix) & ")" & vbCrLf
        Next varprefix
    Next varitem
    
End Property

Private Sub Class_Initialize()
    Set mPrefixTraces = New Scripting.Dictionary
    Set mLevels = New Scripting.Dictionary
    ' levels are static - order determines index in hierarchy
    mLevels.Add "requsr", "usr"
    mLevels.Add "reqdev", "dev"
    mLevels.Add "reqsys", "sys"
    mLevels.Add "sreqsys", "sys"
    mLevels.Add "reqsw", "hl"
    mLevels.Add "sreqsw", "hl"
    mLevels.Add "reqhw", "hl"
    mLevels.Add "sreqhw", "hl"
    mLevels.Add "reqsdd", "ll"
    mLevels.Add "reqhdd", "ll"
    mLevels.Add "swsrc", "code"
    mLevels.Add "fwsrc", "code"
    mLevels.Add "tcstp", "stest"
    mLevels.Add "tcctp", "stest"
    mLevels.Add "tcgtp", "stest"
    mLevels.Add "tcftp", "stest"
    mLevels.Add "tcotp", "stest"
    mLevels.Add "tchln", "test"
    mLevels.Add "tchlr", "test"
    mLevels.Add "tcm", "test"
    mLevels.Add "tchlnia", "tcode"
    mLevels.Add "tchlnim", "tcode"
    mLevels.Add "tchlria", "tcode"
    mLevels.Add "tchlrim", "tcode"
    mLevels.Add "tcmi", "tcode"
End Sub

Private Sub Class_Terminate()
    Set mPrefixTraces = Nothing
    Set mLevels = Nothing
End Sub
Attribute VB_Name = "cTrcDocTraces"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' For a given document, describes the summary info for each trace type as well as the traces for each TRC-related
' bookmark in the document.

Private mSourceDocInfo As cDocInfo ' reference to the source document's info
Private mDirectionFrom As Boolean ' True for 'from' traces, False for 'to' traces
Private mTrcConfig As cTrcConfig ' reference to the TRC config to use
Private mTraces As Scripting.Dictionary ' of cTrace objects, indexed by item (bookmark)
Private mSummaries As Scripting.Dictionary ' of cTrcSummary objects, indexed by trace type

Public Sub Init(ByRef docinfo As cDocInfo, ByRef trccfg As cTrcConfig, ByVal bldirectionfrom As Boolean)
    Set mSourceDocInfo = docinfo
    Set mTrcConfig = trccfg
    mDirectionFrom = bldirectionfrom
End Sub

Public Property Get Traces() As Scripting.Dictionary
    Set Traces = mTraces
End Property

Public Property Get Trace(ByVal stritem As String) As cTrace
    Set Trace = mTraces(stritem)
End Property

Public Property Get Summaries() As Scripting.Dictionary
    Set Summaries = mSummaries
End Property

Public Property Get Summary(ByVal strtracetype As String) As cTrcSummary
    Set Summary = mSummaries(strtracetype)
End Property

Public Property Get TotalTraceCount() As Integer
    Dim varitem As Variant
    For Each varitem In mTraces
        TotalTraceCount = TotalTraceCount + Trace(varitem).TracedItems.Count
    Next varitem
End Property

Public Sub Add(ByRef trc As cTrace)
    mTraces.Add trc.Item.Name, trc
End Sub

Sub CalculateSummary(ByRef tbljst As Table)
    '==================================================================================================================================
    ' Description: Processes the traces defined in this object and calculates the metrics associated with each traceability type. The
    '              given table is used to assess the justification text.
    '==================================================================================================================================
    Dim dictrctypesrequired As Scripting.Dictionary
    Dim trc As cTrace, bkm As cDocBookmark, trcitem As cTracedItem, trcsum As cTrcSummary
    Dim varitem As Variant, vartrcitem As Variant
    Dim strtracetype As String, strjstprefix As String, strprevitem As String
    
    If Not mSourceDocInfo Is Nothing And Not mTrcConfig Is Nothing Then
        ' clear existing info in case
        mSummaries.RemoveAll
        
        ' get the list of trace types for the source document type - as item traces are detected below, the trace type entries are removed from this dictionary
        Set dictrctypesrequired = mTrcConfig.TraceTypesRequired(mSourceDocInfo.Properties.TypeAbbr, mDirectionFrom)
                    
        ' set the justification prefix
        strjstprefix = IIf(mDirectionFrom, Const_JST_BMRK_PREFIX_TRCFROM_EXCEPTION, Const_JST_BMRK_PREFIX_TRCTO_EXCEPTION)
        
        ' cycle through all the traces and accumulate trace counts
        For Each varitem In mTraces
            Set trc = mTraces(varitem)
            For Each vartrcitem In trc.TracedItems
                If varitem <> strprevitem Or Not mDirectionFrom Then ' only count 'from traces' once
                    Set trcitem = trc.TracedItem(vartrcitem)
                    strtracetype = trcitem.TraceType
                    If Not mSummaries.Exists(strtracetype) Then
                        Set trcsum = New cTrcSummary
                        trcsum.TrcType = strtracetype
                        mSummaries.Add strtracetype, trcsum
                    End If
                    Set trcsum = mSummaries(strtracetype)
                    trcsum.Total = trcsum.Total + 1
                    
                     ' determine if item is traced
                    If Not trcitem.Bookmark Like strjstprefix & "*" Then
                        trcsum.Traced = trcsum.Traced + 1
                    Else
                        ' get justification text associated with bookmark from the given table
                        If IsJustificationResolved(tbljst.Range.Bookmarks(trcitem.Bookmark).Range.Next(wdCell).Cells(1)) Then
                            trcsum.Justified = trcsum.Justified + 1
                        Else
                            trcsum.Unresolved = trcsum.Unresolved + 1
                        End If
                    End If
                    
                    ' remove trace type entry for valid traces
                    If dictrctypesrequired.Exists(strtracetype) Then dictrctypesrequired.Remove strtracetype
                End If
                strprevitem = varitem
            Next vartrcitem
        Next varitem
                    
        ' add empty entries for the remaining required trace
        For Each varitem In dictrctypesrequired
            strtracetype = varitem
            If Not mSummaries.Exists(strtracetype) Then
                Set trcsum = New cTrcSummary
                trcsum.TrcType = strtracetype
                mSummaries.Add strtracetype, trcsum
            End If
        Next varitem
    Else
        MsgBox "Source document and/or TRC configuration not defined - cannot calculate summary TRC values - contact the DST owner!", vbExclamation
    End If
End Sub

Private Sub Class_Initialize()
    Set mTraces = New Scripting.Dictionary
    Set mSummaries = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mSourceDocInfo = Nothing
    Set mTrcConfig = Nothing
    Set mTraces = Nothing
    Set mSummaries = Nothing
End Sub
Attribute VB_Name = "cTrcPrefixConfig"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'==================================================================================================================================
' Description: For given prefix, defines which TRC-related prefixes it may trace from. The TRC configuration is defined by
'              specifying valid 'from' traces, the parent class then uses this information to compute the valid 'to' (inverse)
'              traces.
'==================================================================================================================================

Private mPrefix As String
Private mFromPrefixes As Scripting.Dictionary ' of valid prefixes for 'from' (upwards) traces (value=key)
Private mToPrefixes As Scripting.Dictionary ' of valid prefixes for 'to' (downwards) traces (value=key)

Property Get Prefix() As String
    Prefix = mPrefix
End Property

Property Let Prefix(ByVal strvalue As String)
    mPrefix = strvalue
End Property

Property Get FromPrefixes() As Scripting.Dictionary
    Set FromPrefixes = mFromPrefixes
End Property

Property Get ToPrefixes() As Scripting.Dictionary
    Set ToPrefixes = mToPrefixes
End Property

Private Sub Class_Initialize()
    Set mFromPrefixes = New Scripting.Dictionary
    Set mToPrefixes = New Scripting.Dictionary
End Sub

Private Sub Class_Terminate()
    Set mFromPrefixes = Nothing
    Set mToPrefixes = Nothing
End Sub
Attribute VB_Name = "cTrcSummary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' For a given trace type, describes the summary metrics values

Private mTrcType As String
Private mTotal As Long
Private mTraced As Long
Private mJustified As Long
Private mUnresolved As Long

Property Get TrcType() As String
    TrcType = mTrcType
End Property

Property Let TrcType(ByVal strvalue As String)
    mTrcType = strvalue
End Property

Property Get Total() As Long
    Total = mTotal
End Property

Property Let Total(ByVal lngvalue As Long)
    mTotal = lngvalue
End Property

Property Get Traced() As Long
    Traced = mTraced
End Property

Property Let Traced(ByVal lngvalue As Long)
    mTraced = lngvalue
End Property

Property Get Justified() As Long
    Justified = mJustified
End Property

Property Let Justified(ByVal lngvalue As Long)
    mJustified = lngvalue
End Property

Property Get Unresolved() As Long
    Unresolved = mUnresolved
End Property

Property Let Unresolved(ByVal lngvalue As Long)
    mUnresolved = lngvalue
End Property
Attribute VB_Name = "frmAbbrevIgnore"
Attribute VB_Base = "0{467E72C8-1CD6-4319-BCBF-E55EDA523084}{27AF2741-DC3C-4691-AB24-605D864DB85D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private FormDocVars As cDocVars

Private Sub btnHelp_Click()
    ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpAbbreviationsUndefinedForm"
End Sub

Private Sub btnClose_Click()
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    ' use document variables property to validate that where working with the same objects
    Set FormDocVars = Dst.Document(ActiveDocument.Fullname).Variables ' assume document exists in dictionary
End Sub

Private Sub UserForm_Activate()
    Dim varitem As Variant
        
    ' init undefined list
    lstAbbrevUndefined.Clear
    For Each varitem In SortDictionary(DicAbbrevUndefined)
        lstAbbrevUndefined.AddItem varitem
    Next varitem
    btnAbbrevIgnoreAdd.enabled = lstAbbrevUndefined.ListCount > 0
    
    ' init ignored list
    lstAbbrevIgnored.Clear
    For Each varitem In SortDictionary(FormDocVars.OfType(enumDocVariableTypeAbbrIgnored))
        lstAbbrevIgnored.AddItem varitem
    Next varitem
    btnAbbrevIgnoreRemove.enabled = lstAbbrevIgnored.ListCount > 0

End Sub

Private Sub btnAbbrevIgnoreAdd_Click()
    Dim idx As Integer, strabbrev As String
    
    For idx = 0 To lstAbbrevUndefined.ListCount - 1
        If lstAbbrevUndefined.Selected(idx) Then
            strabbrev = lstAbbrevUndefined.List(idx, 0)
            FormDocVars.AbbrIgnored(strabbrev) = "-"
            DicAbbrevUndefined.Remove strabbrev
        End If
    Next idx
    Call UserForm_Activate
End Sub

Private Sub btnAbbrevIgnoreRemove_Click()
    Dim idx As Integer, strabbrev As String
    
    For idx = 0 To lstAbbrevIgnored.ListCount - 1
        If lstAbbrevIgnored.Selected(idx) Then
            strabbrev = lstAbbrevIgnored.List(idx, 0)
            DicAbbrevUndefined.Add strabbrev, 1
            FormDocVars.VariableDelete strabbrev, enumDocVariableTypeAbbrIgnored
        End If
    Next idx
    Call UserForm_Activate
End Sub
Attribute VB_Name = "frmBkmRefsMgmt"
Attribute VB_Base = "0{9FD97ECD-2402-4F3E-B79C-2A94A38B7F4C}{16715374-B1B3-4423-9FB1-028A2A6A5483}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

' Used to suppress events temporarily when events are triggered programmatically and not by the user
Private BlInhibitEvents As Boolean

Private Sub UserForm_Initialize()
    ' add current document to source list
    lstSourceDocs.AddItem ActiveDocument.Fullname
    BlInhibitEvents = False
End Sub

Private Sub UserForm_Activate()
    Dim rng As Range, docinfo As cDocInfo, strbookmark As String
    
    btnInsertSelection.enabled = False
    
    ' set the captions for the previous document's selection
    lblPreviousDocument.Caption = vbNullString
    lblPreviousDocumentBookmarkName.Caption = vbNullString
    txtPreviousDocumentBookmarkText.Text = vbNullString
    If Not Dst.PreviousDocument Is Nothing Then
        Set rng = Dst.PreviousDocument.Windows(1).Selection.Range
        Set docinfo = Dst.Document(Dst.PreviousDocument.Fullname)
        lblPreviousDocument.Caption = docinfo.Properties.Fullname
        If rng.Bookmarks.Count > 0 Then
            strbookmark = rng.Bookmarks(1).Name
            lblPreviousDocumentBookmarkName.Caption = strbookmark
            txtPreviousDocumentBookmarkText.Text = docinfo.Bookmarks.Bookmark(strbookmark).Text
            btnInsertSelection.enabled = True
        End If
    End If
    
    ' select first entry if nothing is selected
    If lstSourceDocs.ListIndex = -1 And lstSourceDocs.ListCount > 0 Then
        lstSourceDocs.ListIndex = 0
    Else
        ' make sure bookmark list is reloaded if required
        Call lstSourceDocs_Change
    End If
    
End Sub

Private Sub lstSourceDocs_Change()
    ' Build the list of applicable bookmarks for the new selection
    If lstSourceDocs.ListIndex <> -1 Then
        Call PopulateSourceDocList(lstSourceDocs.Column(0)) ' this also re-builds the bookmark list
    End If
End Sub

Private Sub lstBookmarkPrefixes_Change()
    ' NOTE: The .Column property is used below because the .Text is not always initialised
    '       in time - this appears to be a UserForm issue
    
    ' Search through the list of bookmarks and select the first bookmark in the list box that matches the prefix
    If lstBookmarkPrefixes.ListIndex <> -1 Then
        lstBookmarks.ListIndex = FindBookmarkListIndex(lstBookmarkPrefixes.Column(0), lstBookmarks)
    Else
        lstBookmarks.ListIndex = -1
    End If
        
    ' sync the combo box to the list box and initialise the selection
    cmbBookmarks.ListIndex = lstBookmarks.ListIndex
    If cmbBookmarks.ListIndex <> -1 Then
        cmbBookmarks.SetFocus
        cmbBookmarks.SelStart = 0
        If lstBookmarkPrefixes.ListIndex <> -1 Then
            cmbBookmarks.SelStart = Len(lstBookmarkPrefixes.Column(0))
        End If
        cmbBookmarks.SelLength = Len(cmbBookmarks.Column(0)) - cmbBookmarks.SelStart
    End If
    
    ' set the selection to the top
    If lstBookmarks.ListIndex <> -1 Then
        lstBookmarks.TopIndex = lstBookmarks.ListIndex
    End If
    
End Sub

Private Sub lstBookmarkPrefixes_DblClick(ByVal Cancel As MSForms.ReturnBoolean)

    ' Check if we've moved away from selection
    If InStr(1, lstBookmarks, lstBookmarkPrefixes) <> 1 Then
        Call lstBookmarkPrefixes_Change
    End If
    
End Sub

Private Sub chkShowDocTypePrefixes_Click()
    lstBookmarkPrefixes.List = DictionaryToArray(Dst.BookmarkConfig.PrefixesForDocType(Dst.Document(Documents(lstSourceDocs.Column(0)).Fullname).Properties.TypeAbbr, chkShowDocTypePrefixes))
End Sub

Private Sub cmbBookmarks_Change()
    ' only process event if not triggered by programmatic change of combo box
    If BlInhibitEvents = False Then
        ' sync the list box to the combo box and move the selection to the top
        lstBookmarks.ListIndex = cmbBookmarks.ListIndex
        If lstBookmarks.ListIndex <> -1 Then
            lstBookmarks.TopIndex = lstBookmarks.ListIndex
        End If
    End If
End Sub

Private Sub lstBookmarks_Change()

    ' suppress events as we're about to change the combo box below programmatically
    BlInhibitEvents = True

    ' sync the combo box with the list box
    cmbBookmarks.ListIndex = lstBookmarks.ListIndex
    
    ' restore events
    BlInhibitEvents = False
    
    ' Manage the enable status of the insert XRef button
    If lstSourceDocs.ListIndex <> -1 And lstBookmarks.ListIndex <> -1 Then
        btnInsertXRef.enabled = True
    Else
        btnInsertXRef.enabled = False
    End If
    
End Sub

Private Sub lstBookmarks_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call btnInsertXRef_Click
End Sub

Private Sub btnAddSourceDoc_Click()
    Dim varsourcedoc As Variant, strsourcedoc As String
    Dim dlgfileopen As FileDialog
    
    ' open the file picker
    Set dlgfileopen = Application.FileDialog(msoFileDialogFilePicker)
    With dlgfileopen
        .Filters.Clear
        .Filters.Add "Word Documents", "*.docx;*.doc", 1
        .Filters.Add "All files", "*.*"
        .InitialFileName = ActiveDocument.Path ' same path as the active document
        .AllowMultiSelect = True

        ' use the Show method to display the dialog and return the user's action
        If .Show = -1 Then
            ' user selected new file(s) so add them to the list
            System.Cursor = wdCursorWait
            For Each varsourcedoc In .SelectedItems
                strsourcedoc = CStr(varsourcedoc)
                If Dst.BookmarkConfig.ValidDocumentType(GetDocTypeFromFilename(strsourcedoc)) <> Const_TEXT_UNKNOWN Then
                    Call PopulateSourceDocList(strsourcedoc)
                Else
                    MsgBox "'" & strsourcedoc & "' is an unknown document type - document not added to the list.", vbExclamation
                End If
            Next varsourcedoc
        Else
            ' user pressed Cancel
        End If
    End With

    Set dlgfileopen = Nothing
    System.Cursor = wdCursorNormal
    
End Sub

Private Sub btnClearSourceDocList_Click()
    
    ' Clear all document references
    lstSourceDocs.Clear
    
    ' Clear the bookmark lists too
    lstBookmarkPrefixes.Clear
    lstBookmarks.Clear
    cmbBookmarks.Clear
    
    ' rebuild the defaults
    Call UserForm_Initialize
    Call UserForm_Activate
    
End Sub

Private Sub btnHide_Click()
    Me.hide
End Sub

Private Sub btnHelp_Click()
    ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpMacrosXRefManagementForm"
End Sub

Private Sub btnInsertXRef_Click()
    
    ' NOTE: The .Column property is used below because the .Text is not always initialised
    '       in time - this appears to be a UserForm issue
    If Me.chkInsertReferenceAsText = False Then
        Call InsertXref(Selection.Range, lstBookmarks.Column(0), Trim(lstBookmarks.Column(2)), _
                        lstSourceDocs.Column(0), chkApplyTraceToStyle)
    Else
        Call InsertXRefAsBookmark(Selection.Range, lstBookmarks.Column(0), lstBookmarks.Column(2))
        ' uncheck box after each insert as this is usually a once-off action
        Me.chkInsertReferenceAsText = False
    End If
    
End Sub

Private Sub btnInsertSelection_Click()
    
    If Me.chkInsertReferenceAsText = False Then
        Call InsertXref(Selection.Range, lblPreviousDocumentBookmarkName.Caption, txtPreviousDocumentBookmarkText.Text, _
                        lblPreviousDocument.Caption, chkApplyTraceToStyle)
    Else
        Call InsertXRefAsBookmark(Selection.Range, lblPreviousDocumentBookmarkName.Caption, txtPreviousDocumentBookmarkText.Text)
        ' uncheck box after each insert as this is usually a once-off action
        Me.chkInsertReferenceAsText = False
    End If

End Sub

Private Sub PopulateSourceDocList(ByVal strdocname As String)
    Dim idx As Integer
    
    ' search through list to determine if it's already in the list
    For idx = 0 To lstSourceDocs.ListCount - 1
        If lstSourceDocs.List(idx, 0) = strdocname Then
            Exit For
        End If
    Next idx
    
    ' add document to the list if it was not found and select it
    If idx = lstSourceDocs.ListCount Then
        lstSourceDocs.AddItem strdocname
        lstSourceDocs.ListIndex = idx ' this triggers the listbox change event which in turn calls this function again
    Else
        ' update document date in list
        lstSourceDocs.List(idx, 1) = Format(Dst.Document(strdocname).Properties.DateLastModified, Const_FORMAT_DATETIME)
               
        ' populate the bookmark list
        Call PopulateBookmarkList(strdocname)
        
    End If
        
End Sub

Private Sub PopulateBookmarkList(strdocname As String)
    Dim bkmarklist As Variant, docinfo As cDocInfo, blincludexrefs As Boolean
    
    If strdocname <> vbNullString Then
        Set docinfo = Dst.Document(strdocname)
        ' populate the bookmark prefixes first
        lstBookmarkPrefixes.List = DictionaryToArray(Dst.BookmarkConfig.PrefixesForDocType(docinfo.Properties.TypeAbbr, chkShowDocTypePrefixes))
        
        lstBookmarks.Visible = False
        cmbBookmarks.Visible = False
        lstBookmarks.Clear
        cmbBookmarks.Clear
        
        ' only include external bookmarks if we're processing the active document
        If strdocname = ActiveDocument.Fullname Then
            blincludexrefs = True
        End If
                
        bkmarklist = docinfo.Bookmarks.ListBoxSortedArray(blincludexrefs)
        If IsArrayAllocated(bkmarklist) Then
            lstBookmarks.List = bkmarklist
            cmbBookmarks.List = bkmarklist
        End If
        lstBookmarks.Visible = True
        cmbBookmarks.Visible = True
    End If
    
End Sub
Attribute VB_Name = "frmBookmarkMgmt"
Attribute VB_Base = "0{ED6AAA06-8730-4362-A080-3E901C3E02D9}{49632BAB-1D30-4CE8-96A0-BE8144A45DAD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private BlInhibitEvents As Boolean          ' Used to suppress events temporarily when events are triggered programmatically and not by the user
Private BlBackSpacePressed As Boolean       ' Used to indicate that the last key that was pressed was the backspace key
Private BlDeletePressed As Boolean          ' Used to indicate that the last key that was pressed was the delete key
Private BookmarksTimestamp As Boolean

Private Sub UserForm_Initialize()
    Dim bkm As Bookmark, bkmarklist As Variant, docinfo As cDocInfo
        
    Me.Caption = "DST Bookmark Management - " & ActiveDocument.Name
    
    ' populate the bookmark prefixes defined for this document
    Call chkShowDocTypePrefixes_Click
    
    ' remove bookmarks that start with OLE_LINK - these bookmarks are sometimes left behind by Word when doing a copy and paste
    For Each bkm In ActiveDocument.Bookmarks
        If InStr(1, bkm.Name, "OLE_LINK") = 1 Then
            bkm.Delete
        End If
    Next bkm
    
    ' populate the bookmark list
    Set docinfo = Dst.Document(ActiveDocument.Fullname)
    lstBookmarks.Visible = False ' they say this makes it run faster
    lstBookmarks.Clear
    bkmarklist = docinfo.Bookmarks.ListBoxSortedArray
    If IsArrayAllocated(bkmarklist) Then
        lstBookmarks.List = bkmarklist
    End If
    lstBookmarks.Visible = True
    lblBookmarkCount.Caption = "Count: " & lstBookmarks.ListCount
    
    ' save the timestamp so we can detect changes
    BookmarksTimestamp = docinfo.Bookmarks.BuildTimestamp
        
    Call ManageControls
    
    BlInhibitEvents = False
    BlBackSpacePressed = False
    BlDeletePressed = False
    
End Sub

Private Sub UserForm_Activate()
    Dim rng As Range, docinfo As cDocInfo
    
    ' always turn off hidden bookmarks
    ActiveDocument.Bookmarks.ShowHidden = False
                    
    ' select current word and point to the selection object
    Set rng = SetRangeToWordAroundCursor(ActiveDocument)
    
    ' check if the listboxes need to be re-initialised (in case bookmarks were updated)
    Set docinfo = Dst.Document(ActiveDocument.Fullname)
    If BookmarksTimestamp <> docinfo.Bookmarks.BuildTimestamp Then
        Call UserForm_Initialize
    End If
    
    ' select the current bookmark, else retain the previously selected entry
    If rng.Bookmarks.Count > 0 Then
        lstBookmarks.Text = rng.Bookmarks(1).Name
    End If
                    
    ' select the contents of the text box by default at start-up
    Call SelectTextBox(txtBookmarkName)

End Sub

Private Sub lstBookmarkPrefixes_Change()
    
    ' Search through the list of bookmarks and select the first bookmark in the list box that matches the prefix
    lstBookmarks.ListIndex = FindBookmarkListIndex(lstBookmarkPrefixes.Text, lstBookmarks)
    
    ' if no entry found, load textbox with prefix
    If lstBookmarks.ListIndex = -1 Then
        txtBookmarkName = lstBookmarkPrefixes.Text
    Else
        lstBookmarks.TopIndex = lstBookmarks.ListIndex
    End If
    
End Sub

Private Sub lstBookmarkPrefixes_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    ' check if we've moved away from selection
    If InStr(1, lstBookmarks, lstBookmarkPrefixes) <> 1 Then
        Call lstBookmarkPrefixes_Change
    End If
End Sub

Private Sub chkShowDocTypePrefixes_Click()
    lstBookmarkPrefixes.List = DictionaryToArray(Dst.BookmarkConfig.PrefixesForDocType(Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr, chkShowDocTypePrefixes))
End Sub

Private Sub lstBookmarks_Change()

    ' don't process event if triggered by programmatic change of text box
    If BlInhibitEvents = False Then
        ' update input text box
        If Not IsNull(lstBookmarks) Then
            ' suppress events as we're about to change this text box programmatically
            BlInhibitEvents = True
            txtBookmarkName = lstBookmarks
            Call SelectTextBox(txtBookmarkName)
        End If
    End If
    
    ' restore events
    BlInhibitEvents = False
    
    ' update the from bookmark
    lblRenameFromBookmark.Caption = lstBookmarks & " to"

End Sub

Private Sub lstBookmarks_DblClick(ByVal Cancel As MSForms.ReturnBoolean)

    txtRenameBookmark = lstBookmarks
    Call lstBookmarks_Change
    
End Sub

Private Sub txtBookmarkName_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)

    BlBackSpacePressed = False
    BlDeletePressed = False
    If KeyCode = 8 Then
        BlBackSpacePressed = True
    ElseIf KeyCode = 46 Then
        BlDeletePressed = True
    End If
    
End Sub

Private Sub txtBookmarkName_Change()
    Dim strtext As String, idx As Integer
    
    ' find a match in the list of bookmarks based on the user input
    If BlInhibitEvents = False Then ' only process event if events aren't temporarily suspended
        ' suppress events as we're about to change this text box programmatically
        BlInhibitEvents = True
        
        ' if we're at the start of the text box, clear it if required
        If (BlBackSpacePressed Or BlDeletePressed) And txtBookmarkName.SelStart = 0 Then
            txtBookmarkName.Text = vbNullString
        End If
        
        ' get a copy of the current text before we autocomplete it so we can highlight the remainder
        strtext = txtBookmarkName.Text
        
        If Not BlDeletePressed Then
            ' find the closest match in the list of bookmarks
            idx = FindBookmarkListIndex(strtext, lstBookmarks)
            If idx <> -1 Then
                lstBookmarks.ListIndex = idx
                lstBookmarks.TopIndex = idx
                ' sync the text box to the list box and highlight the remainder of the text
                txtBookmarkName = lstBookmarks
                txtBookmarkName.SelStart = Len(strtext) - IIf(BlBackSpacePressed And Len(strtext) > 0, 1, 0)
                txtBookmarkName.SelLength = Len(txtBookmarkName.Text) - txtBookmarkName.SelStart
            End If
        End If
    End If
    
    ' restore events
    BlInhibitEvents = False
    
    Call UpdateBookmarkLengthLabel(lblBookmarkLength, txtBookmarkName)
    Call ManageControls
    
End Sub

Private Sub txtRenameBookmark_Change()

    Call UpdateBookmarkLengthLabel(lblRenameBookmarkLength, txtRenameBookmark)
    Call ManageControls

End Sub

Private Sub chkAddToRenBmConfigFile_Click()

    ' set default config file
    If chkAddToRenBmConfigFile Then
        If txtRenBmConfigFile = vbNullString Then
            txtRenBmConfigFile = Application.MacroContainer.Path & "\" & Const_REN_BM_CONFIG_FILE
        End If
    End If
    
    Call ManageControls
    
End Sub

Private Sub ManageControls()
    Dim dicprefixes As Scripting.Dictionary
    
    btnAddBookmark.enabled = False
    btnRenameBookmark.enabled = False
    btnDeleteBookmark.enabled = False
    btnGotoBookmark.enabled = False
    
    ' manage the add, delete and goto button availability
    If CheckBookmarkCharacters(txtBookmarkName.Text) = True Then
        ' check if bookmark text is already in the list
        If FindBookmarkListIndex(txtBookmarkName.Text, lstBookmarks, True) <> -1 Then
            ' if the bookmark is in the list, we can delete it and go to it
            btnDeleteBookmark.enabled = True
            btnGotoBookmark.enabled = True
        Else
            ' if it's not in the list, we can add a new bookmark
            btnAddBookmark.enabled = True
        End If
    End If
    
    ' manage the rename button availability
    If CheckBookmarkCharacters(txtRenameBookmark.Text) = True Then
        ' check if bookmark text is already in the list
        If FindBookmarkListIndex(txtRenameBookmark.Text, lstBookmarks, True) = -1 Then
            ' if a bookmark is selected, it can be renamed
            If lstBookmarks.ListIndex <> -1 Then btnRenameBookmark.enabled = True
        End If
    End If
    
    btnWhereUsed.enabled = (lstBookmarks.ListIndex <> -1)
    
    chkAddToRenBmConfigFile.enabled = btnRenameBookmark.enabled
    txtRenBmConfigFile.enabled = chkAddToRenBmConfigFile
    
    Set dicprefixes = Dst.BookmarkConfig.PrefixesForDocType(Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr)
    If (txtBookmarkName.Text Like "sysp*" And dicprefixes.Exists("sysp")) Or _
       (txtBookmarkName.Text Like "srsp*" And dicprefixes.Exists("srsp")) Then
        chkSuppressIoTable.Visible = True
    Else
        chkSuppressIoTable.Visible = False
    End If
    
End Sub

Private Sub btnAddBookmark_Click()
    Call AddBookmark(SetRangeToWordAroundCursor(ActiveDocument), txtBookmarkName.Text, , chkSuppressIoTable)
    Call UserForm_Initialize
End Sub

Private Sub btnRenameBookmark_Click()
    Dim stroldbookmark As String, strnewbookmark As String, strmessage As String
    
    ' copy old an new names
    stroldbookmark = lstBookmarks.Text
    strnewbookmark = txtRenameBookmark.Text
    
    ' rename the parent bookmark
    If Not RenameBookmark(ActiveDocument, stroldbookmark, strnewbookmark, strmessage, Me) Then
        MsgBox strmessage, vbExclamation, "Bookmark Rename Error"
        Exit Sub
    Else
        ' if the new prefix has an associated description bookmark, rename it too if the old one exists
        stroldbookmark = Dst.BookmarkConfig.DescBookmarkFromName(stroldbookmark)
        strnewbookmark = Dst.BookmarkConfig.DescBookmarkFromName(strnewbookmark)
        If strnewbookmark <> vbNullString And ActiveDocument.Bookmarks.Exists(stroldbookmark) Then
            If Not RenameBookmark(ActiveDocument, stroldbookmark, strnewbookmark, strmessage, Me) Then
                MsgBox strmessage, vbExclamation, "Bookmark Rename Error"
                Exit Sub
            End If
        End If
    End If
    Call UserForm_Initialize
    
End Sub

Private Sub btnDeleteBookmark_Click()
    Dim rng As Range
    
    ' point the range object somewhere
    Set rng = ActiveDocument.Bookmarks(txtBookmarkName.Text).Range
    If DeleteBookmark(rng) = True Then
        Call UserForm_Initialize
    End If
    
End Sub

Private Sub btnGotoBookmark_Click()
    ActiveDocument.Bookmarks(txtBookmarkName.Text).Range.Select
End Sub

Private Sub btnWhereUsed_Click()
    Dim frm As Object

    Set frm = OpenUserForm("frmRefWhereUsed", ActiveDocument)
    frm.SetReferenceInfo txtBookmarkName.Text, "REF"
End Sub

Private Sub btnHide_Click()
    Me.hide
End Sub

Private Sub btnHelp_Click()
    ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpMacrosBookmarkManagementForm"
End Sub

Private Sub UpdateBookmarkLengthLabel(ByRef lbl As Label, ByRef txt As TextBox)
    Dim intmaxlen As Integer, strbooktype As String
    
    ' determine the maximum length for the given bookmark type
    strbooktype = Dst.BookmarkConfig.PrefixFromName(txt.Text)
    If strbooktype <> vbNullString Then
        intmaxlen = Dst.BookmarkConfig.Prefix(strbooktype).MaxLength
    Else
        intmaxlen = txt.MaxLength
    End If
    
    ' provide feedback if name is too long
    lbl.Caption = "Length: " & Len(txt)
    If Len(txt) >= intmaxlen Then
        lbl.ForeColor = vbRed
        lbl.Font.Bold = True
    Else
        lbl.ForeColor = vbBlack
        lbl.Font.Bold = False
    End If
    
End Sub
Attribute VB_Name = "frmDocInfo"
Attribute VB_Base = "0{E04AB6B6-D4FD-4C13-904B-6BDC04CF8CB5}{644CC3C0-8572-41F7-9849-09C428C6B34F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private WithEvents TextBoxEventHandler As cTextBoxEventHandler
Attribute TextBoxEventHandler.VB_VarHelpID = -1

Private FormDocInfo As cDocInfo

Private Sub btnHelp_Click()
    ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpMacrosDocumentInformationForm"
End Sub

Private Sub UserForm_Initialize()
    ' use document info property to validate that where working with the same objects
    Set FormDocInfo = Dst.Document(ActiveDocument.Fullname) ' assume document exists in dictionary
    Me.Caption = Me.Caption & " for " & FormDocInfo.Properties.Parent.Document.Name
    Set TextBoxEventHandler = Nothing
End Sub

Private Sub UserForm_Activate()
    Dim doclst As cDocList, dicpool As Scripting.Dictionary, varitem As Variant, idx As Integer
        
    Set doclst = FormDocInfo.DocList
    mltDocInfo.Value = 0
    
    ' Properties (derived)
    txtFullname = FormDocInfo.Properties.Fullname
    txtPath = FormDocInfo.Properties.Path
    txtShortname = FormDocInfo.Properties.Shortname
    txtBasename = FormDocInfo.Properties.Basename
    txtExtension = FormDocInfo.Properties.Extension
    txtTypeAbbr = FormDocInfo.Properties.TypeAbbr
    chkDataDictionary = FormDocInfo.Properties.IsDataDictionary
    txtDocID = FormDocInfo.Properties.DocID
    
    ' Properties (defined)
    mltProperties.Value = 0
    txtTitle = FormDocInfo.Properties.Title
    If FormDocInfo.Properties.TypeText <> vbNullString Then txtTypeText = FormDocInfo.Properties.TypeText
    If FormDocInfo.Properties.Programme <> vbNullString Then txtProgramme = FormDocInfo.Properties.Programme
    If FormDocInfo.Properties.Project <> vbNullString Then txtProject = FormDocInfo.Properties.Project
    If FormDocInfo.Properties.CSCI <> vbNullString Then txtCSCI = FormDocInfo.Properties.CSCI
    If FormDocInfo.Properties.Classification <> vbNullString Then txtClassification = FormDocInfo.Properties.Classification
    If FormDocInfo.Properties.Appendix <> vbNullString Then txtAppendix = FormDocInfo.Properties.Appendix
    If FormDocInfo.Properties.Number <> vbNullString Then txtNumber = FormDocInfo.Properties.Number
    If FormDocInfo.Properties.Issue <> vbNullString Then txtIssue = FormDocInfo.Properties.Issue
    If FormDocInfo.Properties.DocDate <> vbNullString Then txtDocDate = FormDocInfo.Properties.DocDate
    If FormDocInfo.Properties.Location <> vbNullString Then txtLocation = FormDocInfo.Properties.Location
    lstSubTypes.Clear
    For Each varitem In FormDocInfo.Properties.SubTypesAsDictionary
        lstSubTypes.AddItem varitem
    Next varitem
    Set dicpool = GetSubTypesInPoolNotUsed(doclst.SubTypesForTypeAsDictionary(FormDocInfo.Properties.TypeAbbr), FormDocInfo.Properties.SubTypesAsDictionary)
    lstSubTypesPool.Clear
    For Each varitem In SortDictionary(dicpool)
        lstSubTypesPool.AddItem varitem
    Next varitem
    If FormDocInfo.Properties.TypeAbbr = "STR" Then
        chkOrphaned.enabled = True
    Else
        If FormDocInfo.Properties.IsOrphaned Then FormDocInfo.Properties.IsOrphaned = False
        chkOrphaned.enabled = False
    End If
    chkOrphaned = FormDocInfo.Properties.IsOrphaned
    txtVersion = FormDocInfo.Properties.Version
    txtVersion.Visible = IsDstAdministrator And (FormDocInfo.Properties.Shortname = Application.MacroContainer.Name)
    lblVersion.Visible = txtVersion.Visible
    txtPropertiesBuiltIn = GetDictionaryAsText(FormDocInfo.Properties.BuiltInAsDictionary())
    txtPropertiesBuiltIn.SelStart = 0
    txtPropertiesCustom = GetDictionaryAsText(FormDocInfo.Properties.CustomAsDictionary())
    txtPropertiesCustom.SelStart = 0
    
    ' Variables
    mltVariables.Value = 0
    txtDstVariables = GetDictionaryAsText(FormDocInfo.Variables.OfType(enumDocVariableTypeDst), True, True)
    txtDstVariables.SelStart = 0
    txtAbbreviationsIgnored = GetDictionaryAsText(FormDocInfo.Variables.OfType(enumDocVariableTypeAbbrIgnored), True, True)
    txtAbbreviationsIgnored.SelStart = 0
    txtFileChecksums = GetDictionaryAsText(FormDocInfo.Variables.OfType(enumDocVariableTypeFileChecksum), True, True)
    txtFileChecksums.SelStart = 0
    txtTableChecksums = GetDictionaryAsText(FormDocInfo.Variables.OfType(enumDocVariableTypeTableChecksum), True, True)
    txtTableChecksums.SelStart = 0
    txtConfigItems = GetDictionaryAsText(FormDocInfo.Variables.OfType(enumDocVariableTypeConfigItem), True, True)
    txtConfigItems.SelStart = 0
    txtAllVariables = GetDictionaryAsText(FormDocInfo.Variables.All, True, True)
    txtAllVariables.SelStart = 0
    
    ' Other information
    txtDocDateLastModified = Format(FormDocInfo.Properties.DateLastModified, Const_FORMAT_DATETIME)
    chkDocSavedInSession = FormDocInfo.DocSavedInSession
    chkNeedsSave = Not FormDocInfo.Document.Saved
    txtPreviousDocument = vbNullString
    If Not Dst.PreviousDocument Is Nothing Then txtPreviousDocument = Dst.PreviousDocument.Name
    txtBookmarksTimestamp = Format(FormDocInfo.Bookmarks.BuildTimestamp, Const_FORMAT_DATETIME)
    txtBookmarksTimestamp = txtBookmarksTimestamp & " (" & FormDocInfo.Bookmarks.BuildDuration & " sec)"
    txtExtRefTableChecksum = FormDocInfo.Bookmarks.ExtRefTableChecksum
    txtDstDocuments = "DST Dictionary: (" & Dst.Documents.Count & ")" & vbCrLf
    For Each varitem In SortDictionary(Dst.Documents)
        txtDstDocuments = txtDstDocuments & varitem & IIf(Dst.Document(varitem).DocVisible, vbNullString, " [Not visible]") & vbCrLf
    Next varitem
    txtDstDocuments = txtDstDocuments & vbCrLf & "Word Collection: (" & Documents.Count & ")" & vbCrLf
    ' iterating through the document collection using 'For Each' does not alway give reliable results - use indexing instead
    For idx = 1 To Word.Documents.Count
        txtDstDocuments = txtDstDocuments & Word.Documents(idx).Fullname & IIf(Word.Documents(idx).Windows(1).Visible, vbNullString, " [Not visible]") & vbCrLf
    Next idx
    txtDstDocuments.SelStart = 0
    
    ' Bookmark and TRC Configuration
    Call chkBkmConfigCurrentDocOnly_Click
    Call chkTrcConfigCurrentDocOnly_Click
End Sub

Private Sub txtTypeText_AfterUpdate()
    FormDocInfo.Properties.TypeText = txtTypeText
End Sub

Private Sub txtProgramme_AfterUpdate()
    FormDocInfo.Properties.Programme = txtProgramme
End Sub

Private Sub txtProject_AfterUpdate()
    FormDocInfo.Properties.Project = txtProject
End Sub

Private Sub txtCSCI_AfterUpdate()
    FormDocInfo.Properties.CSCI = txtCSCI
End Sub

Private Sub txtClassification_AfterUpdate()
    FormDocInfo.Properties.Classification = txtClassification
End Sub

Private Sub txtNumber_AfterUpdate()
    FormDocInfo.Properties.Number = txtNumber
End Sub

Private Sub txtIssue_AfterUpdate()
    FormDocInfo.Properties.Issue = txtIssue
End Sub

Private Sub txtDocDate_AfterUpdate()
    FormDocInfo.Properties.DocDate = Format(txtDocDate, "dd MMMM yyyy")
End Sub

Private Sub txtAppendix_AfterUpdate()
    FormDocInfo.Properties.Appendix = txtAppendix
End Sub

Private Sub txtLocation_AfterUpdate()
    FormDocInfo.Properties.Location = txtLocation
End Sub

Private Sub chkOrphaned_Click()
    FormDocInfo.Properties.IsOrphaned = chkOrphaned
End Sub

Private Sub txtVersion_AfterUpdate()
    FormDocInfo.Properties.Version = txtVersion
End Sub

Private Sub btnSubTypesAdd_Click()
    Dim idx As Integer, dicsubtypes As New Scripting.Dictionary, docprops As cDocProps
    
    Set docprops = Dst.Document(ActiveDocument.Fullname).Properties
    Set dicsubtypes = docprops.SubTypesAsDictionary
    For idx = 0 To lstSubTypesPool.ListCount - 1
        If lstSubTypesPool.Selected(idx) Then
            dicsubtypes.Add lstSubTypesPool.List(idx, 0), 0
        End If
    Next idx
    Set docprops.SubTypesAsDictionary = dicsubtypes
    Call UserForm_Activate
    
End Sub

Private Sub btnSubTypesRemove_Click()
    Dim idx As Integer, dicsubtypes As New Scripting.Dictionary, docprops As cDocProps
    
    Set docprops = Dst.Document(ActiveDocument.Fullname).Properties
    For idx = 0 To lstSubTypes.ListCount - 1
        If Not lstSubTypes.Selected(idx) Then
            dicsubtypes.Add lstSubTypes.List(idx, 0), 0
        End If
    Next idx
    Set docprops.SubTypesAsDictionary = dicsubtypes
    Call UserForm_Activate
    
End Sub

Private Function GetSubTypesInPoolNotUsed(ByRef dicpool As Scripting.Dictionary, ByRef dicsubtypes As Scripting.Dictionary) As Scripting.Dictionary
    Dim varentry As Variant, dictemp As New Scripting.Dictionary
    For Each varentry In dicpool
        If Not dicsubtypes.Exists(varentry) Then
            dictemp.Add varentry, varentry
        End If
    Next varentry
    Set GetSubTypesInPoolNotUsed = dictemp
End Function

Private Sub chkBkmConfigCurrentDocOnly_Click()
    txtBkmConfiguration = Dst.BookmarkConfig.ConfigAsText(IIf(chkBkmConfigCurrentDocOnly, FormDocInfo.Properties.TypeAbbr, vbNullString))
    txtBkmConfiguration.SelStart = 0
End Sub

Private Sub chkTrcConfigCurrentDocOnly_Click()
    txtTrcConfiguration = Dst.TrcConfig.ConfigAsText(IIf(chkTrcConfigCurrentDocOnly, FormDocInfo.Properties.TypeAbbr, vbNullString))
    txtTrcConfiguration.SelStart = 0
End Sub

Private Sub btnHide_Click()
    Me.hide
    If Not FormDocInfo.Document.Saved Then
        Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionUpdateAllFields, , "DocInfo")
    End If
End Sub

Private Sub btnRefresh_Click()
    Call UserForm_Activate
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Call btnHide_Click
End Sub

Private Sub txtDstVariables_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Button = vbKeyRButton Then
        TextBoxRightMouseButtonClicked txtDstVariables
    End If
End Sub

Private Sub txtAbbreviationsIgnored_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Button = vbKeyRButton Then
        TextBoxRightMouseButtonClicked txtAbbreviationsIgnored
    End If
End Sub

Private Sub txtTableChecksums_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Button = vbKeyRButton Then
        TextBoxRightMouseButtonClicked txtTableChecksums
    End If
End Sub

Private Sub txtFileChecksums_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Button = vbKeyRButton Then
        TextBoxRightMouseButtonClicked txtFileChecksums
    End If
End Sub

Private Sub txtConfigItems_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Button = vbKeyRButton Then
        TextBoxRightMouseButtonClicked txtConfigItems
    End If
End Sub

Private Sub txtAllVariables_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Button = vbKeyRButton Then
        TextBoxRightMouseButtonClicked txtAllVariables
    End If
End Sub

Private Sub TextBoxRightMouseButtonClicked(txt As TextBox)
    ' raise the custom event in the text box event handler class, which in turn will trigger the 'RightClicked' event below
    Set TextBoxEventHandler = New cTextBoxEventHandler
    TextBoxEventHandler.RightClickTextBox txt
End Sub

Private Sub TextBoxEventHandler_RightClicked()
    Dim cmdbartxtbox As CommandBar, cmdbarbtn As CommandBarButton, idx As Integer, intpos As Integer
    Dim strselection As String, strvariable As String
    
    ' (re)create the command bar
    On Error Resume Next
    CommandBars("DstTextBoxPopup").Delete
    On Error GoTo 0
    Set cmdbartxtbox = Application.CommandBars.Add(Name:="DstTextBoxPopup", Position:=msoBarPopup, Temporary:=True)
    With cmdbartxtbox
        strselection = Trim(TextBoxEventHandler.TextBoxControl.SelText)
        intpos = InStr(1, strselection, " ")
        If intpos > 0 Then strselection = Left(strselection, intpos - 1)
        
        Select Case TextBoxEventHandler.TextBoxName
            Case "txtDstVariables"
                strvariable = FormDocInfo.Variables.PrefixAdd(enumDocVariableTypeDst, strselection)
            Case "txtAbbreviationsIgnored"
                strvariable = FormDocInfo.Variables.PrefixAdd(enumDocVariableTypeAbbrIgnored, strselection)
            Case "txtTableChecksums"
                strvariable = FormDocInfo.Variables.PrefixAdd(enumDocVariableTypeTableChecksum, strselection)
            Case "txtFileChecksums"
                strvariable = FormDocInfo.Variables.PrefixAdd(enumDocVariableTypeFileChecksum, strselection)
            Case "txtConfigItems"
                strvariable = FormDocInfo.Variables.PrefixAdd(enumDocVariableTypeConfigItem, strselection)
            Case "txtAllVariables"
                strvariable = strselection
            Case Else
                'do nothing - variable already set
        End Select
        
        For idx = 1 To 4
            Set cmdbarbtn = .Controls.Add(Type:=msoControlButton, Temporary:=True)
            With cmdbarbtn
                .Style = msoButtonCaption
                .Parameter = strvariable
                .OnAction = "DstInfoFormTextBoxPopupProcess"
                Select Case idx
                    Case 1
                        .enabled = False
                        .Caption = strvariable
                    Case 2
                        .Caption = "Edit"
                        .enabled = strselection <> vbNullString
                    Case 3
                        .Caption = "Delete"
                        .enabled = strselection <> vbNullString
                    Case 4
                        .Caption = "Add"
                        .enabled = strselection = vbNullString
                    Case Else
                        MsgBox "This should not happen - contact the DST owner!"
                End Select
            End With
        Next idx
    End With
    
    Application.CommandBars("DstTextBoxPopup").ShowPopup
    
End Sub
Attribute VB_Name = "frmDocList"
Attribute VB_Base = "0{45C4FCC7-8EB9-4B06-A9CC-05E9020FB712}{7C7F081A-FA78-4400-AD6F-2CF779561F86}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private FormDocInfo As cDocInfo ' note that this object is based on the active document

Private Sub UserForm_Initialize()
    Call RefreshFormData
End Sub
    
Private Sub RefreshFormData()
    Dim varitem As Variant, fso As FileSystemObject, dicdocs As Scripting.Dictionary, bltrcrdocopen As Boolean, objdoc As Document
    
    Set fso = New FileSystemObject
    Set FormDocInfo = Dst.Document(ActiveDocument.Fullname)
    
    txtTrcrFile = FormDocInfo.DocList.TrcSourceFile
    If txtTrcrFile <> vbNullString Then
        If IsDocumentOpen(txtTrcrFile, objdoc, False) And objdoc.ActiveWindow.Visible Then
            bltrcrdocopen = True
        End If
    End If
        
    btnOpenTrcrFile.enabled = (txtTrcrFile <> vbNullString)
    
    lstDocuments.Clear
    Set dicdocs = IIf(chkTrcDocsOnly, FormDocInfo.DocList.TrcDocuments, FormDocInfo.DocList.AllDocuments)
    For Each varitem In dicdocs
        lstDocuments.AddItem fso.GetFileName(varitem)
        lstDocuments.List(lstDocuments.ListCount - 1, 1) = varitem
    Next varitem
    lblDocuments.Caption = "Documents:" & IIf(chkTrcDocsOnly, " (total of " & lstDocuments.ListCount & ")", vbNullString)
    btnRemoveValidFromList.enabled = bltrcrdocopen And (lstDocuments.ListCount > 0)
    btnRemoveValidFromList.Visible = chkTrcDocsOnly
    
    btnValidate.enabled = (lstDocuments.ListCount > 0)
    imgDocumentStatus.Visible = (lstDocuments.ListCount > 0)
    imgDocumentCheck.Visible = (lstDocuments.ListCount > 0)
    imgUpdateTRC.Visible = (lstDocuments.ListCount > 0)
    imgExportToPDF.Visible = (lstDocuments.ListCount > 0)
    imgOpenSelected.Visible = (lstDocuments.ListCount > 0)
    
    lblDocListNotInList.Visible = chkTrcDocsOnly
    lstDocListNotInList.Visible = chkTrcDocsOnly
    lstDocListNotInList.Clear
    For Each varitem In FormDocInfo.DocList.TrcDocumentsNotInList
        lstDocListNotInList.AddItem fso.GetFileName(varitem)
        lstDocListNotInList.List(lstDocListNotInList.ListCount - 1, 1) = varitem
    Next varitem
    btnAddToList.enabled = bltrcrdocopen And (lstDocListNotInList.ListCount > 0)
    btnAddToList.Visible = chkTrcDocsOnly
    
    lblDocListNotValid.Visible = chkTrcDocsOnly
    lstDocListNotValid.Visible = chkTrcDocsOnly
    lstDocListNotValid.Clear
    For Each varitem In FormDocInfo.DocList.TrcDocumentsNotValid
        lstDocListNotValid.AddItem fso.GetFileName(varitem)
        lstDocListNotValid.List(lstDocListNotValid.ListCount - 1, 1) = varitem
    Next varitem
    btnRemoveInvalidFromList.enabled = bltrcrdocopen And (lstDocListNotValid.ListCount > 0)
    btnRemoveInvalidFromList.Visible = chkTrcDocsOnly
            
    btnValidate.Visible = Not chkTrcDocsOnly
    btnValidate.Left = 434
    lblMetrics.Visible = Not chkTrcDocsOnly
    lblMetrics.Top = 288
    txtMetrics.Visible = Not chkTrcDocsOnly
    txtMetrics.Top = 300
    txtMetrics.Height = 180
    txtMetrics.Width = 478
    txtMetrics = FormDocInfo.DocList.MetricsAsText
    txtMetrics.SelStart = 0
End Sub

Private Sub btnOpenTrcrFile_Click()
    Dim objdoc As Document, tbl As Table
    Call IsDocumentOpen(txtTrcrFile, objdoc, , True)
    If Not objdoc Is Nothing Then
        Set tbl = GetTable(objdoc, Const_DOCTBL_TRCSUMMARY_BYDOC)
        If Not tbl Is Nothing Then
            objdoc.ActiveWindow.ScrollIntoView tbl.Range, True
            tbl.Cell(2, 1).Select
        End If
    End If
End Sub

Private Sub chkTrcDocsOnly_Click()
    Call RefreshFormData
End Sub

Private Sub lstDocuments_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call IsDocumentOpen(lstDocuments.Column(1, lstDocuments.ListIndex), , , True)
End Sub

Private Sub lstDocListNotInList_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call IsDocumentOpen(lstDocListNotInList.Column(1, lstDocListNotInList.ListIndex), , , True)
End Sub

Private Sub btnValidate_Click()
    Dim strstatus As String
    strstatus = FormDocInfo.DocList.Validate
    If strstatus = vbNullString Then strstatus = "Document list validated OK"
    txtMetrics = FormDocInfo.DocList.MetricsAsText & vbCrLf & vbCrLf & strstatus
End Sub

Private Sub imgDocumentCheck_Click()
    Call ExecuteFunction(enumExecuteFunctionCheckDocument)
End Sub

Private Sub imgDocumentStatus_Click()
    Call ExecuteFunction(enumExecuteFunctionDocStatus)
End Sub

Private Sub imgExportToPDF_Click()
    Call ExecuteFunction(enumExecuteFunctionExportPdf)
End Sub

Private Sub imgUpdateTRC_Click()
    Call ExecuteFunction(enumExecuteFunctionUpdateTrc)
End Sub

Private Sub imgOpenSelected_Click()
    Dim idx As Integer
    For idx = 0 To lstDocuments.ListCount - 1
        If lstDocuments.Selected(idx) Then
            Call IsDocumentOpen(lstDocuments.Column(1, idx), , , True)
        End If
    Next idx
End Sub

Private Sub ExecuteFunction(ByVal func As EnumExecuteFunction)
    Dim idx As Integer, frm As Object, objdocactive As Document, objdoc As Document
    Dim dicdocs As Scripting.Dictionary, dicdocstoclose As Scripting.Dictionary, vardoc As Variant
    
    Set objdocactive = ActiveDocument
    If lstDocuments.ListCount > 0 Then
        ' open the feedback form and build a list of documents to process
        Set dicdocs = New Scripting.Dictionary
        Set dicdocstoclose = New Scripting.Dictionary
        For idx = 0 To lstDocuments.ListCount - 1
            If lstDocuments.Selected(idx) Then
                If Not IsDocumentOpen(lstDocuments.Column(1, idx), objdoc) Then
                    dicdocstoclose.Add objdoc.Fullname, objdoc
                End If
                dicdocs.Add objdoc.Fullname, objdoc
            End If
        Next idx
        
        If dicdocs.Count > 0 Then
            ' execute the function on the list of documents
            Set frm = OpenUserForm("frmTextBox", ActiveDocument)
            frm.ExecuteFunctionBatch func, dicdocs ' note that the function removes documents that had no problems
            
            ' close documents as required - documents with problems are made visible
            For Each vardoc In dicdocstoclose
                If dicdocs.Exists(vardoc) Then
                    dicdocs(vardoc).ActiveWindow.Visible = True
                    dicdocs(vardoc).ActiveWindow.WindowState = wdWindowStateMinimize
                Else
                    dicdocstoclose(vardoc).Close wdDoNotSaveChanges
                End If
            Next vardoc
        
            ' remove select status from list for documents that had no problems
            For idx = 0 To lstDocuments.ListCount - 1
                If lstDocuments.Selected(idx) Then
                    If Not dicdocs.Exists(lstDocuments.Column(1, idx)) Then
                        lstDocuments.Selected(idx) = False
                    End If
                End If
            Next idx

        End If
    End If
End Sub

Private Sub btnRemoveValidFromList_Click()
    Call RemoveFromList(lstDocuments)
End Sub

Private Sub btnAddToList_Click()
    Dim idx As Integer, bladded As Boolean, cel As Cell
    For idx = 0 To lstDocListNotInList.ListCount - 1
        If lstDocListNotInList.Selected(idx) Then
            Set cel = FormDocInfo.DocList.TrcDocAdd(lstDocListNotInList.List(idx, 1))
            bladded = True
            Call SetTRCRSummaryTableRowDashes(cel)
        End If
    Next idx
    If bladded Then Call RefreshFormData
End Sub

Private Sub btnRemoveInvalidFromList_Click()
    Call RemoveFromList(lstDocListNotValid)
End Sub

Private Sub RemoveFromList(ByRef ctllist As ListBox)
    Dim idx As Integer, blremoved As Boolean
    For idx = 0 To ctllist.ListCount - 1
        If ctllist.Selected(idx) Then
            FormDocInfo.DocList.TrcDocRemove ctllist.List(idx, 1)
            blremoved = True
        End If
    Next idx
    If blremoved Then Call RefreshFormData
End Sub

Private Sub btnRefresh_Click()
    Call FormDocInfo.DocList.RefreshDocLists(True)
    Call RefreshFormData
End Sub

Private Sub btnHide_Click()
    Me.hide
End Sub
Attribute VB_Name = "frmDocNew"
Attribute VB_Base = "0{568FAD66-902F-4DD6-BE0B-C24F59C795E3}{B037F9F6-3EA5-442B-81A2-79785579F522}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public OpenArgs As String

Private Const Const_DST_PATH_FOUND_SIGNATURE As String = "DSTPATHFOUND"
Private Const Const_COLUMN_TYPE_IDX As Integer = 0
Private Const Const_COLUMN_DESCRIPTION_IDX As Integer = 1
Private Const Const_COLUMN_CATEGORY_IDX As Integer = 2
Private Const Const_COLUMN_NAME_IDX As Integer = 3
Private Const Const_COLUMN_PATH_IDX As Integer = 4
Private Const Const_LISTBOX_LABELS As String = "Type,Description,Category,Template,Location" ' must match sequences above, no whitespace, comma-seperated

Private Sub UserForm_Initialize()
    
    Me.btnBrowse.Caption = ChrW(8230)
    
    Call SyncSubTemplatesColumnHeaders(Me.lstSubTemplates, Me.lstSubTemplatesHeader, Split(Const_LISTBOX_LABELS, ","))
    
    ' default location
    Me.txtTemplatePath.Text = GetTemplatePathLocalDefault()
End Sub

Private Sub UserForm_Activate()

    If Me.OpenArgs = vbNullString Then
        Me.Caption = "DST Select Document Type to Create"
        Me.btnAction.Caption = "Create"
        Me.btnAction.Accelerator = "C"
        Me.btnAction.ControlTipText = "Create a new document based on the selected template"
    Else
        Me.Caption = "DST Select Template to Import"
        Me.btnAction.Caption = "Import"
        Me.btnAction.Accelerator = "I"
        Me.btnAction.ControlTipText = "Import the styles from the selected master template"
    End If
    Call UpdateSubTemplatesList

End Sub

Private Sub optDefaultLocal_Click()
    Me.txtTemplatePath.Text = GetTemplatePathLocalDefault()
    Call UpdateSubTemplatesList
End Sub

Private Sub optDefaultNetwork_Click()
    Me.txtTemplatePath.Text = GetTemplatePathNetworkDefault()
    Call UpdateSubTemplatesList
End Sub

Private Sub optUserConfigured_Click()
    If Environ("DST_TEMPLATE_LOCATION") <> vbNullString Then
        Me.txtTemplatePath.Text = Environ("DST_TEMPLATE_LOCATION")
    Else
        Me.txtTemplatePath.Text = "[Define the 'DST_TEMPLATE_LOCATION' environment variable and point it to a valid template folder]"
    End If
    Call UpdateSubTemplatesList
End Sub

Private Sub btnBrowse_Click()
    Dim dlgfileopen As FileDialog
    
    ' open the file picker
    If Me.OpenArgs = vbNullString Then
        Set dlgfileopen = Application.FileDialog(msoFileDialogFolderPicker)
    Else
        Set dlgfileopen = Application.FileDialog(msoFileDialogFilePicker)
    End If
    With dlgfileopen
        If Me.OpenArgs = vbNullString Then
            .InitialFileName = ActiveDocument.Path & "\"
            .Title = "Select Document Template Folder"
        Else
            .Filters.Clear
            .Filters.Add "Master Template", "*.dotx", 1
            .Title = "Select Master Document Template"
            .InitialFileName = Const_MASTERTEMPLATE_NAME
        End If
        
        .InitialView = msoFileDialogViewDetails
        .ButtonName = "Select"

        ' Use the Show method to display the Folder Picker dialog box and return the user's action.
        If .Show = -1 Then
            If Me.OpenArgs = vbNullString Or .SelectedItems(1) Like "*\" & Const_MASTERTEMPLATE_NAME Then
                Me.optDefaultNetwork = False
                Me.optUserConfigured = False
                Me.txtTemplatePath.Text = Replace(.SelectedItems(1), "\" & Const_MASTERTEMPLATE_NAME, vbNullString)
                Call UpdateSubTemplatesList
            Else
                MsgBox "Only a master template may be selected", vbExclamation
            End If
        Else
            ' The user pressed Cancel
        End If
    End With

    Set dlgfileopen = Nothing

End Sub

Private Sub btnAction_Click()
    Dim strsubtemplate As String
    If Me.OpenArgs = vbNullString Then
        strsubtemplate = lstSubTemplates.List(lstSubTemplates.ListIndex, Const_COLUMN_PATH_IDX)
        If lstSubTemplates.List(lstSubTemplates.ListIndex, Const_COLUMN_CATEGORY_IDX) = "SUB" Then
            Call CreateNewDocument(lstSubTemplates.List(0, Const_COLUMN_PATH_IDX), strsubtemplate)
        Else
            Call CreateNewDocument(strsubtemplate, strsubtemplate) ' master and independent templates are used stand-alone
        End If
    Else
        Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionImportStyles, , lstSubTemplates.List(lstSubTemplates.ListIndex, Const_COLUMN_PATH_IDX), vbModal)
    End If
    Me.hide
End Sub

Private Sub lstSubTemplates_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If btnAction.enabled Then Call btnAction_Click
End Sub

Private Sub UpdateSubTemplatesList()
    Dim fso As FileSystemObject, fil As File, idx As Integer, strtype As String, strcategory As String, varparts As Variant
    Dim blmasteronly As Boolean, cmd As cConsoleCommand, dicextprops As Scripting.Dictionary
    
    Set fso = New FileSystemObject
        
    btnAction.enabled = False
    lstSubTemplates.Visible = False
    lstSubTemplates.Clear
    blmasteronly = (Me.OpenArgs = "Styles")
    
    ' test if we can access the template location in case not connected to network
    Set cmd = New cConsoleCommand
    cmd.AddCommand "if exist " & """" & fso.GetParentFolderName(Me.txtTemplatePath.Text) & """" & " echo " & Const_DST_PATH_FOUND_SIGNATURE
    cmd.ExecuteIn = Application.StartupPath
    If cmd.Execute Then
        If cmd.StdOut Like Const_DST_PATH_FOUND_SIGNATURE & "*" Then
            If fso.FileExists(fso.BuildPath(Me.txtTemplatePath.Text, Const_MASTERTEMPLATE_NAME)) Then
                ' get extended file information
                Set dicextprops = GetExtendedFileProperties(Me.txtTemplatePath.Text)
                
                ' get a list of templates in the configured template folder
                For Each fil In fso.GetFolder(Me.txtTemplatePath.Text).Files
                    idx = -1
                    ' template files are named dst-[<category>-]<type>.dotx (if the category not defined, the type is also the category)
                    varparts = GetPartsFromTemplateFilename(fil.Name)
                    strcategory = UCase(varparts(1))
                    If varparts(2) <> vbNullString Then
                        strtype = UCase(varparts(2))
                    Else
                        strtype = strcategory
                    End If
                    If fil.Name = Const_MASTERTEMPLATE_NAME Then
                        idx = 0 ' master template always listed at the top
                    ElseIf fso.GetExtensionName(fil.Name) = "dotx" And Not fil.Name Like "~*" And Not blmasteronly Then
                        idx = lstSubTemplates.ListCount
                    End If
                    
                    If idx >= 0 Then
                        lstSubTemplates.AddItem strtype, idx
                        lstSubTemplates.List(idx, Const_COLUMN_CATEGORY_IDX) = strcategory
                        lstSubTemplates.List(idx, Const_COLUMN_DESCRIPTION_IDX) = dicextprops(fil.Path)("Subject")
                        lstSubTemplates.List(idx, Const_COLUMN_NAME_IDX) = fil.Name
                        lstSubTemplates.List(idx, Const_COLUMN_PATH_IDX) = fil.Path
                    End If
                Next fil
            Else
                MsgBox "The master template '" & Const_MASTERTEMPLATE_NAME & "' was not found in the selected template location.", vbExclamation
            End If
            Set fso = Nothing
        End If
    End If

    ' Select first entry and enable insert button if there is a list
    lstSubTemplates.Visible = True
    If lstSubTemplates.ListCount > 0 Then
        lstSubTemplates.ListIndex = 0
        btnAction.enabled = True
    End If

End Sub

Private Sub btnCancel_Click()
    Me.hide
End Sub

Private Sub SyncSubTemplatesColumnHeaders(lstbody As ListBox, lstheader As ListBox, arrHeaders As Variant)
    
    ' make column count match
    lstheader.ColumnCount = lstbody.ColumnCount
    lstheader.ColumnWidths = lstbody.ColumnWidths

    ' add header elements
    lstheader.Clear
    lstheader.AddItem
    Dim i As Integer
    For i = 0 To UBound(arrHeaders)
        lstheader.List(0, i) = arrHeaders(i)
    Next i

    ' make it pretty
    lstbody.ZOrder (1)
    lstheader.ZOrder (0)
    lstheader.SpecialEffect = fmSpecialEffectBump
    lstheader.BackColor = Me.BackColor
    lstheader.Height = 12

    ' align header to body (should be done last!)
    lstheader.Width = lstbody.Width
    lstheader.Left = lstbody.Left
    lstheader.Top = lstbody.Top - (lstheader.Height + 1)
End Sub

Private Sub btnHelp_Click()
    ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpCreateDocumentForm"
End Sub
Attribute VB_Name = "frmDocRefsMgmt"
Attribute VB_Base = "0{56CE31FA-D4DF-4C8B-A08B-86E8AC647D49}{E41AB806-126F-4B45-B3DD-6134A45BD89E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_Initialize()
    
    ' Populate list of reference types
    lstReferenceType.Clear
    lstReferenceType.AddItem "Reference"
    lstReferenceType.AddItem "Heading"
    lstReferenceType.AddItem "Table"
    lstReferenceType.AddItem "Figure"
    lstReferenceType.AddItem "Equation"
    lstReferenceType.AddItem "Footnote"
    lstReferenceType.AddItem "Numbered item"
    lstReferenceType.AddItem "Property"
    
    lstReferenceType.ListIndex = 0 ' select first entry in list
    
End Sub

Private Sub UserForm_Activate()
    Dim intlistindex As Integer
    
    ' if this is a form reactivation, restore the list index because it is reset when the references list is rebuilt
    intlistindex = lstReferences.ListIndex
    Call UpdateDocReferencesList(GetListBoxValue(lstReferenceType))
    If intlistindex >= 0 Then lstReferences.ListIndex = intlistindex ' this event occurs at start-up as well, so ensure that we don't reset it if it was never set in the first place
    
End Sub

Private Sub lstReferenceType_Change()
    If lstReferenceType.ListCount > 0 Then
        Call UpdateDocReferencesList(GetListBoxValue(lstReferenceType))
        If lstReferences.ListCount = 0 Then
            btnInsertCrossRef.enabled = False
            btnWhereUsed.enabled = False
        Else
            Call lstReferences_Change
        End If
    End If
End Sub

Private Sub lstReferences_Change()
    Dim strreftype As String
    btnInsertCrossRef.enabled = True
    btnWhereUsed.enabled = False
    strreftype = GetListBoxValue(lstReferenceType)
    If strreftype = "Property" And lstReferences.ListCount > 0 Then
        ' only allow insertion of references to properties that have values
        btnInsertCrossRef.enabled = RegularExpressionReplace(lstReferences.Column(0), GetListBoxValue(lstReferences) & "\s+:\s+", vbNullString) <> vbNullString
        btnWhereUsed.enabled = True
    End If
    chkPrependSection.Visible = (strreftype = "Heading") And chkInsertNumber
End Sub

Private Sub lstReferences_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If btnInsertCrossRef.enabled Then Call btnInsertCrossRef_Click
End Sub

Private Sub UpdateDocReferencesList(ByVal strreftype As String)
' Populates the list box with the requested reference list
    Dim varxrefitems As Variant, idx As Integer
    Dim docinfo As cDocInfo, dicprops As Scripting.Dictionary, strpropname As String
        
    lstReferences.Visible = False
    lstReferences.Clear
    ' NOTE: the 2nd column of the lstReferences listbox is the bound field, so other functions can directly access the control to get the associated value.
    '       For Property reference types, this is the property name and for other types this is the ID or index value
    '       For Property reference types, 3rd column contains the property name mapping for the DOCPROPERTY field
    Select Case strreftype
        Case "Property"
            Set docinfo = Dst.Document(ActiveDocument.Fullname)
            Set dicprops = docinfo.Properties.CustomAsDictionary
            For idx = 0 To dicprops.Count - 1
                strpropname = dicprops.Keys(idx)
                lstReferences.AddItem strpropname & " : " & dicprops.Items(idx)
                lstReferences.List(lstReferences.ListCount - 1, 1) = strpropname
                lstReferences.List(lstReferences.ListCount - 1, 2) = strpropname ' custom properties name mappings are always the same
            Next idx
            
            Set dicprops = docinfo.Properties.BuiltInAsDictionary
            strpropname = String(10, "-") & " Built-in Properties " & String(10, "-")
            lstReferences.AddItem strpropname & " : " ' end with colon so it cannot be inserted
            lstReferences.List(lstReferences.ListCount - 1, 1) = strpropname
            For idx = 0 To dicprops.Count - 1
                strpropname = dicprops.Keys(idx)
                lstReferences.AddItem strpropname & " : " & dicprops.Items(idx)
                lstReferences.List(lstReferences.ListCount - 1, 1) = strpropname
                lstReferences.List(lstReferences.ListCount - 1, 2) = docinfo.Properties.BuiltInName(idx + 1) ' assume properties are listed sequentially, so (idx+1) maps to WdBuiltInProperty enumeration
            Next idx
            lstReferences.Font.Name = "Courier New"
            chkInsertNumber.enabled = False
            chkInsertNumber = False
            chkInsertText.enabled = False
            chkInsertText = True
            
        Case Else
            varxrefitems = ActiveDocument.GetCrossReferenceItems(ReferenceTypeLookup(strreftype))
            For idx = 1 To UBound(varxrefitems)
                Dim bladd As Boolean
                bladd = False
                If strreftype = "Reference" Then
                    If varxrefitems(idx) Like "[[]Ref.*]*" Then
                        lstReferences.AddItem varxrefitems(idx)
                        bladd = True
                    End If
                ElseIf strreftype = "Numbered item" Then
                    If Not varxrefitems(idx) Like "[[]Ref.*]*" And Not varxrefitems(idx) Like "Note: *" Then
                        lstReferences.AddItem varxrefitems(idx)
                        bladd = True
                    End If
                Else
                    lstReferences.AddItem varxrefitems(idx)
                    bladd = True
                End If
                ' set 2nd column only if item was added above
                If bladd Then lstReferences.List(lstReferences.ListCount - 1, 1) = idx
            Next idx
            lstReferences.Font.Name = "Tahoma"
            If strreftype <> "Equation" And strreftype <> "Footnote" Then
                chkInsertNumber.enabled = True
                chkInsertText.enabled = True
            Else
                chkInsertNumber.enabled = False
                chkInsertNumber = True
                chkInsertText.enabled = False
                chkInsertText = False
            End If
    
    End Select
    lstReferences.Visible = True
    
    ' Select first entry and enable insert button if there is a list
    If lstReferences.ListCount > 0 Then
        lstReferences.ListIndex = 0
        btnInsertCrossRef.enabled = True
    End If
    
End Sub

Private Sub btnInsertCrossRef_Click()
    Dim rng As Range, rngend As Range, fld As Field, reftypelookup As Long, strreftype As String, strreference As String
    
    Set rng = Selection.Range
    
    ' set a range end marker so we can move to it once we're done - the method used to insert a cross-reference below inserts it after the range
    Set rngend = rng.Document.Range
    rngend.SetRange rng.End, rng.End
    rngend.InsertAfter " "
    rngend.Collapse wdCollapseEnd
    
    strreftype = GetListBoxValue(lstReferenceType)
    reftypelookup = ReferenceTypeLookup(strreftype)
    strreference = GetListBoxValue(lstReferences)
    Select Case strreftype
        Case "Reference", "Numbered item"
            If chkInsertNumber Then
                rng.InsertCrossReference reftypelookup, wdNumberNoContext, strreference, True
            End If
            
            If chkInsertText Then
                rng.InsertBefore """" & IIf(chkInsertNumber, ", ", vbNullString)
                rng.Collapse wdCollapseStart
                rng.InsertCrossReference reftypelookup, wdContentText, strreference, True
                rng.InsertBefore """"
            End If
        
        Case "Heading"
            If chkInsertText Then
                rng.InsertBefore """" & IIf(chkInsertNumber, ",", vbNullString)
                rng.Collapse wdCollapseStart
                rng.InsertCrossReference reftypelookup, wdContentText, strreference, True
                rng.InsertBefore """"
            End If
            
            If chkInsertNumber Then
                rng.InsertBefore IIf(chkInsertText, " ", vbNullString)
                rng.Collapse wdCollapseStart
                If chkPrependSection Then rng.InsertAfter "section "
                rng.Collapse wdCollapseEnd
                rng.InsertCrossReference reftypelookup, wdNumberNoContext, strreference, True
            End If
            
        Case "Table", "Figure"
            If chkInsertNumber And chkInsertText Then
                rng.InsertCrossReference reftypelookup, wdEntireCaption, strreference, True
            ElseIf chkInsertText Then
                rng.InsertCrossReference reftypelookup, wdOnlyCaptionText, strreference, True
            ElseIf chkInsertNumber Then
                rng.InsertCrossReference reftypelookup, wdOnlyLabelAndNumber, strreference, True
            End If
        
        Case "Equation"
            rng.InsertCrossReference reftypelookup, wdOnlyLabelAndNumber, strreference, True
        
        Case "Footnote"
            rng.InsertCrossReference reftypelookup, wdFootnoteNumberFormatted, strreference, True
        
        Case "Property"
            Set fld = rng.Document.Fields.Add(rng, wdFieldDocProperty, lstReferences.List(lstReferences.ListIndex, 2), True) ' real property name is in 3rd column
        
    End Select
    
    ' now move to the end
    rngend.Select
    
End Sub

Private Sub chkInsertText_Click()
    If chkInsertText = chkInsertNumber And Not chkInsertText Then
        chkInsertText = True
    End If
End Sub

Private Sub chkInsertNumber_Click()
    Call chkInsertText_Click
    chkPrependSection.Visible = chkInsertNumber And GetListBoxValue(lstReferenceType) = "Heading"
End Sub

Private Sub btnWhereUsed_Click()
    Dim frm As Object
    Set frm = OpenUserForm("frmRefWhereUsed", ActiveDocument)
    frm.SetReferenceInfo Trim(GetListBoxValue(lstReferences)), "DOCPROPERTY"
End Sub

Private Sub btnHide_Click()
    Me.hide
End Sub

Private Sub btnHelp_Click()
    ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpMacrosInsertDocRefForm"
End Sub

Private Function GetListBoxValue(ByRef lst As ListBox) As String
    ' NOTE: Accessing the .Value property at start-up without user clicking on list box does not always give a valid value, even when
    '       setting .ListIndex property to 0, so use long method to get value consistently
    GetListBoxValue = lst.List(lst.ListIndex, lst.BoundColumn - 1) ' list access columns start at 0, Boundcolumn property starts at 1
End Function

Private Function ReferenceTypeLookup(ByVal strreftype As String) As Long
    Select Case strreftype
        Case "Reference", "Numbered item"
            ReferenceTypeLookup = wdRefTypeNumberedItem
        Case "Heading"
            ReferenceTypeLookup = wdRefTypeHeading
        Case "Table"
            ReferenceTypeLookup = wdCaptionTable
        Case "Figure"
            ReferenceTypeLookup = wdCaptionFigure
        Case "Equation"
            ReferenceTypeLookup = wdCaptionEquation
        Case "Footnote"
            ReferenceTypeLookup = wdRefTypeFootnote
        Case "Property"
            ReferenceTypeLookup = 0 ' not used
        Case Else
            MsgBox "No entry defined for reference type '" & strreftype & "' in frmDocRefsMgmt", vbExclamation
    End Select
End Function
Attribute VB_Name = "frmRefWhereUsed"
Attribute VB_Base = "0{BA82A07F-80B0-424A-8E17-5FE887B19C1C}{96D49918-0AD2-4453-B236-A41A87C489FF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private StrFormReference As String
Private StrFormReferenceType As String

Private Sub UserForm_Activate()
    btnGotoPrevious.Caption = ChrW(8593)
    btnGotoNext.Caption = ChrW(8595)
End Sub


Sub SetReferenceInfo(ByVal strreference As String, ByVal strreferencetype As String)
    StrFormReference = strreference
    StrFormReferenceType = strreferencetype
    Call FindReferences
End Sub

Private Sub FindReferences()
    Dim stryrng As Range, fld As Word.Field, strpattern As String, fldtype As WdFieldType
       
    lblReference.Caption = StrFormReferenceType & " " & StrFormReference
    
    Select Case StrFormReferenceType
        Case "DOCPROPERTY"
            fldtype = wdFieldDocProperty
        
        Case "REF"
            fldtype = wdFieldRef
            
        Case Else
            MsgBox "Reference type " & StrFormReferenceType & " not catered for. Contact the DST Owner.", vbCritical
            Exit Sub
    End Select
    
    ' find occurences of the given reference
    lstReferencePositions.Clear
    If StrFormReference <> vbNullString Then
        strpattern = "^\W*(" & StrFormReferenceType & ")\W+(" & StrFormReference & ")\W+"
        For Each stryrng In ActiveDocument.StoryRanges
            Do
                For Each fld In stryrng.Fields
                    If fld.Type = fldtype Then
                        If RegularExpressionSearch(fld.Code.Text, strpattern, True) Then
                            lstReferencePositions.AddItem fld.Result.Start
                            lstReferencePositions.List(lstReferencePositions.ListCount - 1, 1) = fld.Result.End
                            lstReferencePositions.List(lstReferencePositions.ListCount - 1, 2) = stryrng.StoryType
                        End If
                    End If
                Next fld
                Set stryrng = stryrng.NextStoryRange ' go to next story range in case (for example) headers are unlinked
            Loop Until stryrng Is Nothing
        Next stryrng
    End If
    
    If lstReferencePositions.ListCount > 0 Then
        lstReferencePositions.enabled = True
        lblPositions.Visible = True
        lblReferenceTotal.Caption = "Total: " & lstReferencePositions.ListCount
        Call ManageArrowButtons
    End If
    
End Sub

Private Sub btnRefresh_Click()
    Call FindReferences
End Sub

Private Sub lstReferencePositions_Change()
    Call ManageArrowButtons
    Call GotoReference
End Sub

Private Sub GotoReference()
    Dim rng As Range
        
    If Not IsNull(lstReferencePositions) Then
        Set rng = ActiveDocument.StoryRanges(lstReferencePositions.Column(2))
        rng.SetRange lstReferencePositions, lstReferencePositions.Column(1)
        rng.Select
    End If
End Sub

Private Sub btnGotoPrevious_Click()
    lstReferencePositions.ListIndex = lstReferencePositions.ListIndex - 1
End Sub

Private Sub btnGotoNext_Click()
    lstReferencePositions.ListIndex = lstReferencePositions.ListIndex + 1
End Sub

Private Sub ManageArrowButtons()
    
    btnGotoPrevious.enabled = False
    If lstReferencePositions.ListIndex > 0 Then
        btnGotoPrevious.enabled = True
    End If
    
    btnGotoNext.enabled = False
    If lstReferencePositions.ListIndex < lstReferencePositions.ListCount - 1 Then
        btnGotoNext.enabled = True
    End If
End Sub
Attribute VB_Name = "frmSTDMgmt"
Attribute VB_Base = "0{20B3EC26-8E39-4588-85BE-D9A86EB915AB}{137C8F97-75B5-41BA-A08A-2591D497772E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Const Const_TESTNAME_HELPTEXT As String = "<rest of name>"

' Huge value for position in a document used for comparison (must be larger than the largest expected document)
Private Const Const_HUGE_INSERTION_POINT As Long = 999999999#

' PowerPoint Object Libary is not referenced due to compatibility issues when running on earlier versions of Office - using late binding instead
' Constants need to be provided as the PowerPoint Object Library is not referenced
Private Const ppWindowMinimized = 2

Private Sub UserForm_Initialize()
    Dim strtemp As String
    Dim tgrp As cHeadingGroup, doclst As cDocList, dicsubtypes As Scripting.Dictionary
    
    System.Cursor = wdCursorWait
    
    ' set some lables
    lblInsertTestSet.Caption = lblInsertTestSet.Caption & " " & Const_TESTSPECIFICATION & ":"
    lblInsertTestCase.Caption = lblInsertTestCase.Caption & " " & Const_TESTSPECIFICATION & ":"
    
    ' Check that STD specific bookmarks exist
    strtemp = CheckTestDescriptionBookmarks(ActiveDocument)
    If strtemp <> vbNullString Then
        MsgBox strtemp, vbExclamation, "Bookmarks Missing"
        Unload Me
    End If
    
    ' enable buttons based on the document subtype
    Set dicsubtypes = Dst.Document(ActiveDocument.Fullname).Properties.SubTypesAsDictionary
    btnUpdateTestAbstractionSummary.enabled = dicsubtypes.Exists("hltests") And ActiveDocument.Bookmarks.Exists(Const_DOCTESTABSTRACTIONS_SUMMARY)
    txtNewTestAbstraction.enabled = btnUpdateTestAbstractionSummary.enabled
    btnInsertTestAbstraction.enabled = btnUpdateTestAbstractionSummary.enabled
    btnInsertTestSet.enabled = dicsubtypes.Exists("hltests") Or dicsubtypes.Exists("lltests")
    txtNewTestSet.enabled = btnInsertTestSet.enabled
    btnInsertTestCase.enabled = dicsubtypes.Exists("hltests")
    btnInsertTestImp.enabled = dicsubtypes.Exists("hltests")
    cmbInsertTestImp.enabled = btnInsertTestImp.enabled
    optTestImpAutomated.enabled = btnInsertTestImp.enabled
    optTestImpManual.enabled = btnInsertTestImp.enabled
    btnGenerateTestFiles.enabled = dicsubtypes.Exists("hltests")
    chkAllTests.enabled = btnGenerateTestFiles.enabled
    btnAddMissingTestScriptHyperlinks.enabled = dicsubtypes.Exists("hltests")
    
    optTestImpAutomated = True
    
    ' Manage insert hyperlink content button
    chkFetchAll = False
    Call chkFetchAll_AfterUpdate
    
    ' Build up list of test set and case headings
    Call BuildTestSpecificationList
    Call UpdateTestImplementationCombo
    
    ' Determine whether this is an older format STD (must be called after test set list has been established)
    chkOldFormatStd = IsOldFormatStd()
    
    ' set the default test set and case names
    txtNewTestSet.Text = GetCommonTestSetName(dicsubtypes.Exists("hltests")) & Const_TESTNAME_HELPTEXT
    
    ' Set current test set label
    Set doclst = Dst.Document(ActiveDocument.Fullname).DocList
    lblCurrentTestSet.Caption = vbNullString
    cmbInsertTestImp.ListIndex = -1
    If dicsubtypes.Exists("hltests") Then
        Set tgrp = GetTestSetAboveInsertionPoint(Selection.Range)
        If tgrp Is Nothing Then
            lblCurrentTestSet.Caption = "<Cursor not within in a Test Set>"
            lblCurrentTestSet.Font.Italic = True
            lblCurrentTestSet.ForeColor = vbRed
            txtNewTestCase.enabled = False
            btnInsertTestCase.enabled = False
            If cmbInsertTestImp.ListCount > 0 Then cmbInsertTestImp.ListIndex = 0 ' point to the first entry by default
        Else
            lblCurrentTestSet.Caption = tgrp.Group.Bookmark
            
            ' select current test
            On Error Resume Next ' in case heading is not bookmarked
            cmbInsertTestImp.Text = tgrp.Group.Bookmark
        End If
        txtNewTestAbstraction.Text = Const_TESTABSTR_PREFIX & "_" & doclst.Parent.Parent.Document(ActiveDocument.Fullname).Properties.DocID & "_" & Const_TESTNAME_HELPTEXT
        txtNewTestCase.Text = Replace(txtNewTestSet.Text, Const_TESTSET_HL_PREFIX, Const_TESTCASE_HLN_PREFIX, 1, 1)
    End If
    
    Call ManageImportSATPTestButtonVisibility
    
    System.Cursor = wdCursorNormal
    
End Sub

Private Sub ManageImportSATPTestButtonVisibility()
    Dim rng As Range, strsatpname As String, strstdname As String
    
    ' manage SATP import button visibility
    btnImportSATPTest.Visible = False
    If Not Dst.PreviousDocument Is Nothing Then
        If Dst.Document(Dst.PreviousDocument.Fullname).Properties.TypeAbbr = "SATP" And _
           Dst.Document(ActiveDocument.Fullname).Properties.TypeAbbr = "STD" Then
            btnImportSATPTest.Visible = True
            Set rng = Dst.PreviousDocument.Windows(1).Selection.Range
            If IsRangeInTable(rng) And IsRangeInTable(Selection.Range) Then
                Set rng = GetHeadingAsRange(rng)
                If rng.Bookmarks.Count > 0 Then
                    strsatpname = GetHeadingText(rng)
                    If strsatpname Like "t*atp_*" Then
                        Set rng = GetHeadingAsRange(Selection.Range)
                        If rng.Bookmarks.Count > 0 Then
                            strstdname = GetHeadingText(rng)
                            If strstdname Like "t*hl*_*" And GetTestSetCase(strsatpname) = GetTestSetCase(strstdname) Then
                                btnImportSATPTest.enabled = True
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End If

End Sub

Private Sub btnInsertTestAbstraction_Click()
    Dim strmessage As String, lnghdgstyleidx As Long, rng As Range, tbl As Table, rw As Row
    
    Set rng = Selection.Range
    
    ' strip whitespace
    txtNewTestAbstraction.Text = Trim(txtNewTestAbstraction.Text)
    
    ' validate the test set name
    If ValidateTestAbstractionName(rng, txtNewTestAbstraction.Text) = True Then
        ' Update the list of abstractions
        Call BuildTestAbstractionList
    
        ' Validate the insertion point
        strmessage = ValidateTestInsertionPoint(rng, txtNewTestAbstraction.Text, lnghdgstyleidx)
        If strmessage = vbNullString Then
            Me.hide
            System.Cursor = wdCursorWait
            
            ' Add the test abstraction table (also adds bookmark)
            Set rng = AddEmptyTest(rng, txtNewTestAbstraction.Text, lnghdgstyleidx)
            
            ' Add some text to the end of the summary table to remind the user to update the table
            Set tbl = GetTable(rng.Document, Const_DOCTESTABSTRACTIONS_SUMMARY)
            If Not tbl Is Nothing Then
                Set rw = tbl.Rows.Add
                rw.Cells(2).Range.Text = Const_TABLE_INSTR_ABSTR_PURPOSE_TEXT
            End If
            
            ' re-select test abstraction (in case)
            rng.Select
            
            MsgBox Const_TABLE_INSTR_ABSTR_SUMMARY_REMINDER, vbInformation, "Test " & Const_TESTABSTRACTION & " Created"
            
            System.Cursor = wdCursorNormal
            Me.Show
        Else
            MsgBox strmessage, vbExclamation, "Test " & Const_TESTABSTRACTION & " Insertion Error"
        End If
    End If
    
End Sub

Private Sub btnInsertTestSet_Click()
    ' Inserts a new test set into the document
    ' NOTE: This button is only enabled if the inputs are valid therefore no need to recheck them at this point
    Dim lnghdgstyleidx As Long, strmessage As String, rng As Range
    Dim blhltest As Boolean, dicsubtypes As Scripting.Dictionary, strprefix As String

    Set rng = Selection.Range
    Set dicsubtypes = Dst.Document(ActiveDocument.Fullname).Properties.SubTypesAsDictionary
    blhltest = dicsubtypes.Exists("hltests")
    If blhltest Then
        strprefix = Const_TESTSET_HL_PREFIX
    Else
        strprefix = Const_TESTSET_LL_PREFIX
    End If
    
    ' strip whitespace
    txtNewTestSet.Text = Trim(txtNewTestSet.Text)
    
    ' validate the test set name
    If ValidateTestSetName(rng, txtNewTestSet.Text, strprefix) = True Then
        ' Update the list of abstractions
        Call BuildTestAbstractionList
        
        ' Validate the insertion point
        strmessage = ValidateTestInsertionPoint(rng, txtNewTestSet.Text, lnghdgstyleidx)
        If strmessage = vbNullString Then
            Me.hide
            System.Cursor = wdCursorWait
            
            ' Add the test set table (also adds bookmark)
            Set rng = AddEmptyTest(rng, txtNewTestSet.Text, lnghdgstyleidx)
            
            ' Re-build the list of test set and case headings and the list of test specifications available for implementation
            Call BuildTestSpecificationList
            Call UpdateTestImplementationCombo
        
            ' re-select test set (in case)
            rng.Select
            
            Call ManageImportSATPTestButtonVisibility
            System.Cursor = wdCursorNormal
            Me.Show
        Else
            MsgBox strmessage, vbExclamation, "Test " & Const_TESTSPECIFICATION & " Insertion Error"
        End If
    End If
    
End Sub

Private Sub btnInsertTestCase_Click()
    ' Inserts a new test case into the document
    ' NOTE: This button is only enabled if a test case name is valid, therefore no need to check for this
    Dim lnghdgstyleidx As Long, strmessage As String, rng As Range

    Set rng = Selection.Range

    ' strip off whitespace
    txtNewTestCase.Text = Trim(txtNewTestCase.Text)
    
    ' validate the test case name
    If ValidateTestCaseName(rng, txtNewTestCase.Text) = True Then
        ' Update the list of abstractions
        Call BuildTestAbstractionList
        
        ' validate the insertion point
        strmessage = ValidateTestInsertionPoint(rng, txtNewTestCase.Text, lnghdgstyleidx)
        If strmessage = vbNullString Then
            Me.hide
            System.Cursor = wdCursorWait
            
            ' Add the test case table (also adds bookmark)
            Set rng = AddEmptyTest(rng, txtNewTestCase.Text, lnghdgstyleidx)
            
            ' Re-build the list of test set and case headings and the list of test specifications available for implementation
            Call BuildTestSpecificationList
            Call UpdateTestImplementationCombo
            
            ' re-select test case (in case)
            rng.Select
            
            Call ManageImportSATPTestButtonVisibility
            System.Cursor = wdCursorNormal
            Me.Show
        Else
            MsgBox strmessage, vbExclamation, "Test " & Const_TESTSPECIFICATION & " Insertion Error"
        End If
    End If
    
End Sub

Private Sub btnInsertTestImp_Click()
    ' Inserts a new test implementation into the document
    Dim strtestimpname As String, strmessage As String, lnghdgstyleidx As Long, rng As Range

    Set rng = Selection.Range
    
    ' determine the test implementation name
    strtestimpname = GetTestImplementationName(cmbInsertTestImp.Text, optTestImpAutomated)
    
    ' validate the test implementation name - derived from existing tests, so only a limited check is required
    strmessage = ValidateBookmarkName(rng, strtestimpname, False)
    If strmessage = vbNullString Then
        ' Update the list of abstractions
        Call BuildTestAbstractionList
        
        ' validate the insertion point
        strmessage = ValidateTestInsertionPoint(rng, cmbInsertTestImp.Text, lnghdgstyleidx)
        If strmessage = vbNullString Then
            Me.hide
            System.Cursor = wdCursorWait
                       
            ' Add the test (also adds bookmark)
            Call AddEmptyTest(rng, strtestimpname, lnghdgstyleidx, cmbInsertTestImp.Text)
            
            System.Cursor = wdCursorNormal
            Me.Show
        End If
    End If
    
    If strmessage <> vbNullString Then
        MsgBox strmessage, vbExclamation, "Test " & Const_TESTIMPLEMENTATION & " Insertion Error"
    End If
    
End Sub

Private Sub btnUpdateTestAbstractionSummary_Click()
    Dim tgrp As cHeadingGroup, tabstr As cHeading, rng As Range, tbl As Table
    Dim numrows As Integer, idx As Integer, idx2 As Integer, offset As Integer, strcaption As String, blgroups As Boolean
    Dim strmessage As String
On Error GoTo Err_btnUpdateTestAbstractionSummary_Click
    
    Call ScreenUpdatePause
    
    strcaption = "Test Abstraction Summary"
    
    ' Update the list of abstractions
    Call BuildTestAbstractionList
    blgroups = TestAbstractions.Count > 1
    
    ' delete table if it exists, else set the range to where it should be created
    Set rng = DeleteTable(ActiveDocument, Const_DOCTESTABSTRACTIONS_SUMMARY)
    If rng Is Nothing Then
        Set tgrp = TestAbstractions.Items(0)
        If blgroups Then
            ' insert above group heading
            Set tabstr = tgrp.Group
            Set rng = GetHeadingRangeExtendedFromText(ActiveDocument.Range, tabstr.Text, tabstr.Number)
        Else
            ' insert above first abstraction
            Set tabstr = tgrp.SubItems.Items(0)
            Set rng = ActiveDocument.Bookmarks(tabstr.Bookmark).Range
            rng.Start = rng.Start - 1
        End If
        rng.Collapse wdCollapseStart
        rng.InsertParagraphBefore
    End If
        
    ' generate new table
    numrows = 1 ' header row
    If blgroups Then numrows = numrows + TestAbstractions.Count ' add group rows if there's more than one group
    
    ' now add number of abstraction rows
    For idx = 0 To TestAbstractions.Count - 1
        Set tgrp = TestAbstractions.Items(idx)
        numrows = numrows + tgrp.SubItems.Count
    Next idx
    
    ' create the table
    Set tbl = CreateTableTemplate(rng, numrows, 2, strcaption, Const_DOCTESTABSTRACTIONS_SUMMARY, True)
    If Not tbl Is Nothing Then
        With tbl
            ' adjust the column widths
            .Columns(1).SetWidth CentimetersToPoints(6), wdAdjustNone
            .Columns(2).SetWidth CentimetersToPoints(11), wdAdjustNone
                
            .Cell(1, 1).Range.Text = "Abstractions"
            .Cell(1, 2).Range.Text = "Purpose"
            
            offset = 2
            For idx = 0 To TestAbstractions.Count - 1
                Set tgrp = TestAbstractions.Items(idx)
                If blgroups Then
                    ' insert group header text
                    .Cell(offset, 1).Range.Text = tgrp.Group.Text
                    .Cell(offset, 1).Borders(wdBorderRight).LineStyle = wdLineStyleNone
                    Call FormatRowAsHeading(.Cell(offset, 1).Row, , , True)
                    .Cell(offset, 1).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                    offset = offset + 1
                    
                End If
                
                ' insert references to test abstractions
                For idx2 = 0 To tgrp.SubItems.Count - 1
                    Set tabstr = tgrp.SubItems.Items(idx2)
                    If blgroups Then
                        .Cell(offset, 1).LeftPadding = CentimetersToPoints(0.5)
                    End If
                    Call InsertXref(.Cell(offset, 1).Range, tabstr.Bookmark, tabstr.Text, rng.Document.Fullname, False)
                    If Not tabstr.Purpose Is Nothing Then
                        .Cell(offset, 2).Range.FormattedText = tabstr.Purpose.FormattedText
                    Else
                        .Cell(offset, 2).Range.Text = Const_DOC_ERROR_STRING & " Could not extract purpose text from test table."
                    End If
                    offset = offset + 1
                Next idx2
            Next idx
                                                                                                                
        End With
    Else
        strmessage = "Unable to create the " & strcaption & " table"
    End If
    
Exit_btnUpdateTestAbstractionSummary_Click:
    Call ScreenUpdateRestore
    Exit Sub

Err_btnUpdateTestAbstractionSummary_Click:
    MsgBox Err.Description & " in btnUpdateTestAbstractionSummary_Click()"
    Resume Exit_btnUpdateTestAbstractionSummary_Click
End Sub

Private Sub chkAllTests_Click()

    Call UpdateImplementationNames
    
End Sub

Private Sub btnGenerateTestFiles_Click()
        
    If GetTestSetCase(txtTestImplementationFiles.Text) = "Set" Then
        MsgBox "Function not implemented"
    Else
        MsgBox "You must select the Test Set that contains the Test Case(s) you want to generate.", vbExclamation, "Generate Test Selection Error"
    End If
    
End Sub

Private Sub btnDocInfo_Click()

    Call OpenUserForm("frmDocInfo", ActiveDocument)
    
End Sub

Private Sub btnAddMissingTestScriptHyperlinks_Click()
    
    Me.hide ' hide form because text box form is opened non-modal
    Call OpenUserForm("frmTextBox", ActiveDocument, enumExecuteFunctionTestMgmtAddAllHyperlinks)
    
End Sub

Private Sub txtNewTestAbstraction_Enter()
    
    Call StripHelpText(txtNewTestAbstraction)
    
End Sub

Private Sub txtNewTestSet_Enter()
    
    Call StripHelpText(txtNewTestSet)
    
End Sub

Private Sub txtNewTestCase_Enter()
    
    Call StripHelpText(txtNewTestCase)
    
End Sub

Private Sub cmbInsertTestImp_Change()

    Call UpdateImplementationNames
    
End Sub

Private Sub optTestImpAutomated_Click()

    Call UpdateImplementationNames
    
End Sub

Private Sub optTestImpManual_Click()

    Call UpdateImplementationNames
    
End Sub

Private Sub StripHelpText(ByRef txtbox As TextBox)
    Dim strtemp As String
    
    ' remove help text
    strtemp = Right(txtbox.Text, Len(Const_TESTNAME_HELPTEXT))
    If strtemp = Const_TESTNAME_HELPTEXT Then
        txtbox.Text = Replace(txtbox.Text, strtemp, vbNullString)
    End If
    
End Sub

Private Sub UpdateImplementationNames()

    If cmbInsertTestImp.enabled = True Then
        txtTestImplementationSTD.Text = GetTestImplementationName(cmbInsertTestImp.Text, optTestImpAutomated)
        If Not chkAllTests And cmbInsertTestImp.ListIndex >= 0 Then
            txtTestImplementationFiles.Text = cmbInsertTestImp.Column(2) ' always show the associated test set specification name
        Else
            txtTestImplementationFiles.Text = vbNullString
        End If
    End If
    
End Sub

Private Sub chkFetchAll_AfterUpdate()
    Dim rng As Range
    
    ' Check if the current selection contains a hyperlink
    lblHyperlink.Caption = vbNullString
    btnFetchContent.enabled = False
    Set rng = Selection.Range
    rng.Expand wdParagraph
    If chkFetchAll = True Then
        btnFetchContent.enabled = True
    ElseIf rng.Hyperlinks.Count = 1 Then
        lblHyperlink.Caption = rng.Hyperlinks(1).Name
        btnFetchContent.enabled = True
    ElseIf rng.Hyperlinks.Count > 1 Then
        lblHyperlink.Caption = "Multiple hyperlinks selected"
        btnFetchContent.enabled = True
    End If
        
End Sub

Private Sub btnFetchContent_Click()
    
    ' Inserts the source from the current hyperlink
    Call InsertHyperlinkContent
    
End Sub

Private Sub btnHelp_Click()

    ActiveDocument.FollowHyperlink Const_URL_HELP_FILE_ROOT & "/DstHelpMacrosTestManagementForm"

End Sub

Private Sub btnClose_Click()
    
    Unload Me
    
End Sub

Private Sub UpdateTestImplementationCombo()
    ' Builds the possible list if test set and case implementation names
    Dim strtestname As String, strbooktype As String, idx As Integer, idx2 As Integer
    Dim tset As cHeadingGroup, tcase As cHeading
    
    ' reinitisialise the list
    cmbInsertTestImp.Visible = False ' they say this makes it run faster
    cmbInsertTestImp.Clear
    
    ' loop through the list of test headings and build the combobox
    For idx = 0 To TestSets.Count - 1
        Set tset = TestSets.Items(idx)
        strtestname = tset.Group.Bookmark
        strbooktype = Dst.BookmarkConfig.PrefixFromName(strtestname)
        cmbInsertTestImp.AddItem strtestname
        cmbInsertTestImp.List(cmbInsertTestImp.ListCount - 1, 1) = strbooktype ' add the bookmark type for later use
        cmbInsertTestImp.List(cmbInsertTestImp.ListCount - 1, 2) = strtestname ' associated test set (redundent)
        ' add its test cases to the list
        For idx2 = 0 To tset.SubItems.Count - 1
            Set tcase = tset.SubItems.Items(idx2)
            strtestname = tcase.Bookmark
            strbooktype = Dst.BookmarkConfig.PrefixFromName(strtestname)
            cmbInsertTestImp.AddItem strtestname
            cmbInsertTestImp.List(cmbInsertTestImp.ListCount - 1, 1) = strbooktype ' add the bookmark type for later use
            cmbInsertTestImp.List(cmbInsertTestImp.ListCount - 1, 2) = strtestname ' associated test set name
        Next idx2
    Next idx
    
    If cmbInsertTestImp.ListCount > 0 Then cmbInsertTestImp.ListIndex = 0
    cmbInsertTestImp.Visible = True
                                                
End Sub

Private Function GetCommonTestSetName(ByVal blhltest As Boolean) As String
    ' Builds the common test set name based on common text in existing test set headings
    Dim strcommon As String, tsidx As Integer, tset As cHeadingGroup
    
    ' Intialise return value
    GetCommonTestSetName = vbNullString
    
    ' Set default name and exit function if no test sets exist in document
    If TestSets.Count = 0 Then
        If blhltest Then
            GetCommonTestSetName = Const_TESTSET_HL_PREFIX & "_" & Dst.Document(ActiveDocument.Fullname).Properties.DocID
        Else
            GetCommonTestSetName = Const_TESTSET_LL_PREFIX & "_"
        End If
        Exit Function
    End If
    
    ' Start with the whole name of first test set but exclude any trailing numbers
    Set tset = TestSets.Items(0)
    strcommon = tset.Group.Bookmark
    Do While (IsNumeric(Right(strcommon, 1)))
        strcommon = Left(strcommon, Len(strcommon) - 1)
    Loop
    
    ' Search for common text in all test sets
    For tsidx = 0 To TestSets.Count - 1
        Set tset = TestSets.Items(tsidx)
        While InStr(1, tset.Group.Bookmark, strcommon) = 0
            ' reduce common name until match
            strcommon = Left(strcommon, Len(strcommon) - 1)
            If Len(strcommon) = 1 Then Exit Function
        Wend
    Next tsidx
    
    ' Set the return value
    GetCommonTestSetName = strcommon
    
End Function

Private Function ValidateTestAbstractionName(ByRef rng As Range, ByVal strtestabstrname As String) As Boolean
    
    ValidateTestAbstractionName = ValidateTestName(rng, strtestabstrname, Const_TESTABSTRACTION, Const_TESTABSTR_PREFIX)
    
End Function

Private Function ValidateTestSetName(ByRef rng As Range, ByVal strtestsetname As String, ByVal strprefix As String) As Boolean
    
    ValidateTestSetName = ValidateTestName(rng, strtestsetname, "Set", strprefix)

End Function

Private Function ValidateTestCaseName(ByRef rng As Range, ByVal strtestcasename As String) As Boolean
    
    ValidateTestCaseName = ValidateTestName(rng, strtestcasename, "Case", Const_TESTCASE_HLN_PREFIX, Const_TESTCASE_HLR_PREFIX)
    
End Function

Private Function ValidateTestName(ByRef rng As Range, ByVal strtestname As String, ByVal strtesttype As String, _
                                  ByVal strformat1 As String, Optional ByVal strformat2 As String = 0) As Boolean
    Dim strbookmarktype As String, strmessage As String, blerror As Boolean
      
    strmessage = ValidateBookmarkName(rng, strtestname, False)
    If strmessage = vbNullString Then
        strbookmarktype = Dst.BookmarkConfig.PrefixFromName(strtestname)
        blerror = False
        If strbookmarktype <> strformat1 Then
            If strformat2 <> vbNullString Then
                If strbookmarktype <> strformat2 Then
                    blerror = True
                End If
            Else
                blerror = True
            End If
        End If
        If blerror Then
            strmessage = "The Test " & strtesttype & " name must start with '" & strformat1 & "'" & _
                         IIf(strformat1 <> strformat2 And strformat2 <> vbNullString, " or '" & strformat2 & "'", vbNullString) & "."
        Else
            ValidateTestName = True
        End If
    End If
    
    If strmessage <> vbNullString Then
        MsgBox strmessage, vbExclamation, "Test " & strtesttype & " Name Error"
    End If
    
End Function

Private Function ValidateTestInsertionPoint(ByRef rng As Range, ByVal strtestname As String, ByRef lnghdgstyleidx As Long) As String
    Dim strtesttype As String, strtestsetcase As String
    Dim bltestabstr As Boolean, bltestset As Boolean, bltestcase As Boolean, bltestimp As Boolean
    Dim dictests As Scripting.Dictionary, tgrp As cHeadingGroup, thdg As cHeading, rnghdg As Range
    Dim strhdgtext As String, strhdgnumber As String, idx As Integer, idx2 As Integer
    
    '=============================================================================================
    ' Set Control Flags
    '=============================================================================================
    bltestabstr = False
    bltestset = False
    bltestcase = False
    bltestimp = False
    strtesttype = GetTestType(strtestname)
    strtestsetcase = GetTestSetCase(strtestname)
    If strtesttype = Const_TESTABSTRACTION Then
        bltestabstr = True
        Set dictests = TestAbstractions
    Else
        Set dictests = TestSets
    End If
    If strtesttype = Const_TESTSPECIFICATION Or strtesttype = Const_TESTIMPLEMENTATION Then
        If strtestsetcase = "Set" Then
            bltestset = True
        Else
            bltestcase = True
        End If
    End If
    If strtesttype = Const_TESTIMPLEMENTATION Then
        bltestimp = True
    End If
    
    '=============================================================================================
    ' Validation
    '=============================================================================================
    ' Check that the insertion point is collapsed
    If rng.Start <> rng.End Then
        ValidateTestInsertionPoint = "Insertion point for a Test " & strtesttype & " can't be a selection."
        Exit Function
    End If
    
    ' Check that it's not in a table
    If IsRangeInTable(rng) Or rng.IsEndOfRowMark Then
        ValidateTestInsertionPoint = "Insertion point for a Test " & strtesttype & " can't be in a table."
        Exit Function
    End If
    
    ' Check that insertion point is on a blank line
    If rng.Paragraphs(1).Range.Characters.Count > 1 Or rng.Paragraphs.Count > 1 Or rng.ListFormat.ListType = wdListOutlineNumbering Then
        ValidateTestInsertionPoint = "Insertion point for a Test " & strtesttype & " must be a blank line."
        Exit Function
    End If
    
    ' Check that insertion point is within the test description section
    If rng.Start <= ActiveDocument.Bookmarks(Const_DOCTESTDESC_START).Start Or _
       rng.Start >= ActiveDocument.Bookmarks(Const_DOCTESTDESC_END).Start Then
        ValidateTestInsertionPoint = "Insertion point for a Test " & strtesttype & " must be within the Test Description start and end markers."
        Exit Function
    End If
    
    
    If bltestimp Then
        ' For test implementations, check that insertion point of implementation appears after specification
        If rng.Start <= ActiveDocument.Bookmarks(strtestname).Start Then
            ValidateTestInsertionPoint = "Insertion point for the Test " & strtesttype & " of specification '" & strtestname & "' must be placed after the specification."
            Exit Function
        End If
    ElseIf bltestset Then
        ' For test sets, check that it's after last test abstraction
        If TestAbstractions.Count > 0 Then
            Set tgrp = TestAbstractions.Items(TestAbstractions.Count - 1)
            Set thdg = tgrp.SubItems.Items(tgrp.SubItems.Count - 1)
            If rng.Start < thdg.Start Then
                ValidateTestInsertionPoint = "Insertion point for a Test " & strtesttype & " must be after the last Test Abstraction."
                Exit Function
            End If
        End If
        
        ' For test sets, check that it's not between two test cases
        Set tgrp = GetTestSetAboveInsertionPoint(rng)
        If Not tgrp Is Nothing Then
            ' check that insertion point is after last test case, if there are test cases
            If tgrp.SubItems.Count > 0 Then
                Set thdg = tgrp.SubItems.Items(tgrp.SubItems.Count - 1)
                If rng.Start < thdg.Start Then
                    ValidateTestInsertionPoint = "Insertion point for a Test " & strtesttype & " must be after the last test case of the previous Test " & strtesttype & "."
                    Exit Function
                End If
            Else
                ' no test cases, so OK
            End If
        Else
            ' we're probably above the first test set
        End If
    ElseIf bltestabstr Then
        ' For test abstractions, check that it's before first test set
        If TestSets.Count > 0 Then
            Set tgrp = TestSets.Items(0)
            If rng.Start > tgrp.Group.Start Then
                ValidateTestInsertionPoint = "Insertion point for a Test " & strtesttype & " must be before the first Test Set specification."
                Exit Function
            End If
        End If
        
        ' For test abstractions, check that it's after the summary table
        If ActiveDocument.Bookmarks.Exists(Const_DOCTESTABSTRACTIONS_SUMMARY) Then
            If rng.Start < ActiveDocument.Bookmarks(Const_DOCTESTABSTRACTIONS_SUMMARY).Start Then
                ValidateTestInsertionPoint = "Insertion point for a Test Abstraction must be after the summary table bookmarked with " & Const_DOCTESTABSTRACTIONS_SUMMARY & "."
                Exit Function
            End If
        End If
    End If

    '=============================================================================================
    ' Heading Style Index
    '=============================================================================================
    ' get appropriate heading above insertion point
    If bltestset Then
        If TestSets.Count > 0 Then
            strhdgnumber = TestSets.Items(0).Group.Number ' test sets are all at the same level
        Else
            strhdgnumber = "1.1"
        End If
    Else
        Set rnghdg = GetHeadingAsRange(rng)
        strhdgtext = GetHeadingText(rnghdg)
        strhdgnumber = GetHeadingNumber(rnghdg)
        
        If dictests.Count = 0 Then
            ' no tests yet, so set heading one level lower
            strhdgnumber = strhdgnumber & ".1"
        Else
            ' loop through test dictionary and check if the heading is a group heading
            For idx = 0 To dictests.Count - 1
                Set tgrp = dictests.Items(idx)
                ' try group
                If tgrp.Group.Text = strhdgtext And tgrp.Group.Number = strhdgnumber Then
                    ' heading is a group, so set heading one level lower
                    strhdgnumber = strhdgnumber & ".1"
                    Exit For
                End If
                
                ' try subitems and if found, use same level as heading above insertion point
                For idx2 = 0 To tgrp.SubItems.Count - 1
                    Set thdg = tgrp.SubItems.Items(idx2)
                    If thdg.Text = strhdgtext And thdg.Number = strhdgnumber Then
                        ' need to exit both loops here, so ahve to use a goto statement!
                        GoTo End_Of_Both_Loops
                    End If
                Next idx2
            Next idx
            
End_Of_Both_Loops:
            ' if no match found, it must be a new group heading, so set heading one level lower
            If idx = dictests.Count Then
                strhdgnumber = strhdgnumber & ".1"
            End If
        End If
    End If
    
    lnghdgstyleidx = GetHeadingStyleIndex(strhdgnumber)

End Function

Private Function GetTestSetAboveInsertionPoint(ByRef rng As Range) As cHeadingGroup
    ' Returns the corresponding test set (group heading) above the insertion point
    Dim idx As Integer, lnginspoint As Long, tgrp As cHeadingGroup, tgrpnext As cHeadingGroup
    
    lnginspoint = rng.Start
    
    ' check that it's within the test description area
    If lnginspoint <= rng.Document.Bookmarks(Const_DOCTESTDESC_START).Start Or _
       lnginspoint >= rng.Document.Bookmarks(Const_DOCTESTDESC_END).Start Then
        Exit Function
    End If
    
    ' check if we're above the first test
    If TestSets.Count > 0 Then
        Set tgrp = TestSets.Items(0)
        If lnginspoint < tgrp.Group.Start Then
            Exit Function
        End If
    End If
    
    ' find the relevant test
    For idx = 0 To TestSets.Count - 1
        Set tgrp = TestSets.Items(idx)
        ' is insertion point above next test
        If idx < TestSets.Count - 1 Then
            Set tgrpnext = TestSets.Items(idx + 1)
            If lnginspoint < tgrpnext.Group.Start Then
                Set GetTestSetAboveInsertionPoint = tgrp
                Exit For
            End If
        Else
            ' must be the last test then
            Set GetTestSetAboveInsertionPoint = tgrp
        End If
    Next idx
    
End Function

Private Function AddEmptyTest(ByRef rng As Range, ByVal strtestname As String, _
                              ByVal lnghdgstyle As Long, Optional ByVal strtestref As String = vbNullString) As Range
    ' Adds an empty test for the given test type
    Dim strmessage As String, strtesttype As String
    Dim introws As Integer, intcols As Integer, rw As Row, tblfrmt As cTblTestFormat
On Error GoTo Err_AddEmptyTest

    Call ScreenUpdatePause
        
    ' Add the test and bookmark it
    With rng
        strtesttype = GetTestType(strtestname)
        
        ' Add the test heading
        .InsertParagraphAfter
        .Collapse wdCollapseEnd
        .ParagraphFormat.Style = lnghdgstyle
        If strtesttype = Const_TESTABSTRACTION Then
            .Text = Chr(&H93) & Const_INSTR_START & Replace(Replace(strtestname, "_", " "), Const_TESTABSTR_PREFIX, vbNullString, 1, 1) & " " & Const_INSTR_END & Chr(&H94)
        Else
            .Text = strtestname
        End If
        Dst.Document(rng.Document.Fullname).Bookmarks.Add strtestname, rng
        .InsertParagraphAfter
        .Collapse wdCollapseEnd
        
        ' get the table format for the given test and insert a template table
        Set tblfrmt = New cTblTestFormat
        Call SetTestTableFormat(strtestname, tblfrmt)
        strmessage = tblfrmt.InsertTemplateTable(rng)
        
        ' for test implementations, add a cross-references between the test spec and implementation
        If strmessage = vbNullString Then
            If strtesttype = Const_TESTIMPLEMENTATION Then
                ' insert cross-reference to specification
                Set rw = tblfrmt.GetSectionStartRow(.Tables(1), Const_TABLE_SPEC_REF_TEXT)
                If Not rw Is Nothing Then
                    Call InsertXref(rw.Cells(1).Next.Range, strtestref, strtestref, .Document.Fullname, False, True) ' reference the test specification
                Else
                    strmessage = "Could not find section in table starting with '" & Const_TABLE_SPEC_REF_TEXT & "' - cross-reference to '" & strtestref & "' not inserted"
                End If
                
                ' insert reference to the test implementation in the associated test specification table
                Call InsertRefToTestImplementation(strtestref, strtestname)
            End If
        End If
        
        If strmessage = vbNullString Then
            ' move the selection to the first user editable cell
            If strtesttype = Const_TESTABSTRACTION Or GetTestSetCase(strtestname) = "Case" Then
                introws = IIf(strtesttype = Const_TESTIMPLEMENTATION, 2, 1)
                intcols = IIf(strtesttype = Const_TESTIMPLEMENTATION, 3, 2)
            Else
                introws = IIf(strtesttype = Const_TESTIMPLEMENTATION, 4, 2)
                intcols = IIf(strtesttype = Const_TESTIMPLEMENTATION, 2, 1)
            End If
            
            ' select and return range to purpose column
            Set AddEmptyTest = .Tables(1).Cell(introws, intcols).Range
        Else
            Set AddEmptyTest = rng
            MsgBox strmessage, vbCritical, "Insert Test " & strtesttype & " Error"
        End If
    End With
        
    AddEmptyTest.Select
    
Exit_AddEmptyTest:
    Call ScreenUpdateRestore
    Exit Function
    
Err_AddEmptyTest:
    MsgBox Err.Description & " in AddEmptyTest()"
    Resume Exit_AddEmptyTest
End Function

Private Sub InsertRefToTestImplementation(ByVal strtestspec As String, ByVal strtestimpref As String)
    ' Insert a cross-reference to the test implementation in the test specification table
    Dim rng As Range, cel As Cell, rw As Row, rwend As Row, rngref As Range, celref As Cell, strsectionheadernext As String
    Dim strmessage As String, strcelltext As String, idx As Integer, tblfrmt As cTblTestFormat, sectionfrmt As cTblSectionFormat, rowfrmt As cTblRowFormat
    
    ' initialise the message suffix
    strmessage = " Cross-reference to implementation bookmark '" & strtestimpref & "' not inserted."
    
    ' set the range to the table below the specification bookmark - calling function ensures that bookmark exists
    Set rng = ActiveDocument.Bookmarks(strtestspec).Range
    rng.Collapse
    If IsRangeInTable(rng) Then
        ' already in table, so insert at end of cell if there are no references
        If rng.Cells(1).Range.Fields.Count = 0 Or _
           rng.Cells(1).Range.Fields.Count = rng.Cells(1).Range.Hyperlinks.Count Then ' references are all hyperlinks
            Set rngref = rng
            rngref.InsertAfter vbCrLf
            rngref.Collapse wdCollapseEnd
        End If
    Else
        ' move into table (hopefully)
        rng.Move wdParagraph
        If Not IsRangeInTable(rng) Then
            ' add reference in a new line
            Set rngref = rng
            rngref.InsertAfter vbCrLf
            rngref.Collapse wdCollapseEnd
        Else
            ' find the Implementation Reference section in the test specification
            Set tblfrmt = New cTblTestFormat
            Call SetTestTableFormat(strtestspec, tblfrmt)
            
            ' get the start and end row of this section
            Set rw = tblfrmt.GetSectionStartRow(rng.Tables(1), Const_TABLE_IMP_REF_TEXT)
            If rw Is Nothing Then
                MsgBox "The section starting with the text '" & Const_TABLE_IMP_REF_TEXT & "' could not be found in the table." & strmessage, vbExclamation
            Else
                Set rwend = tblfrmt.GetSectionEndRow(rng.Tables(1), Const_TABLE_IMP_REF_TEXT, strsectionheadernext)
                If rwend Is Nothing Then
                    MsgBox "Could not locate table section starting with header '" & Const_TABLE_IMP_REF_TEXT & "' and ending with '" & strsectionheadernext & "'." & strmessage, vbCritical
                Else
                    ' find the implementation reference cell in this section
                    For idx = rw.Index To rwend.Index
                        For Each cel In rw.Cells
                            strcelltext = GetCellText(cel)
                            If strcelltext = Const_TABLE_INSTR_TEST_IMP_TEXT Or _
                               strcelltext = "TBD" Or _
                               strcelltext = strtestimpref Then
                                ' return a reference to the destination cell and exit both loops
                                Set celref = cel
                                idx = rwend.Index
                                Exit For
                            End If
                        Next cel
                        
                        ' nothing found, so continue the search in the next row
                        Set rw = rw.Next
                    Next idx
                    
                    ' if nothing was found, add a new row at the end of this section
                    If celref Is Nothing Then
                        Set rw = rng.Tables(1).Rows.Add(rw)
                        Set sectionfrmt = tblfrmt.TableFormat.Item(Const_TABLE_IMP_REF_TEXT)
                        Set rowfrmt = sectionfrmt.SubRow
                        rowfrmt.Format rw, 1, sectionfrmt.SectionHeader, False
                        Set celref = rw.Cells(1)
                        If rw.Cells.Count > 1 Then Set celref = rw.Cells(2) ' test cases have them in the 2nd column
                    End If
                    
                    Set rngref = celref.Range
                End If
            End If
        End If
    End If
    
    If Not rngref Is Nothing Then
        ' now insert the cross-reference to the test implementation
        Call InsertXref(rngref, strtestimpref, strtestimpref, rngref.Document.Fullname, False, True)
    End If
    
End Sub

Private Sub InsertHyperlinkContent()
    Dim objPowerPoint As Object ' PowerPoint.Application (compatibility issues when running on earlier versions of Office)
    Dim objExcel As Object ' Excel.Application (compatibility issues when running on earlier versions of Office)
    Dim objBook As Object ' Excel.Workbook (compatibility issues when running on earlier versions of Office)
    Dim objSheet As Object ' Excel.Worksheet (compatibility issues when running on earlier versions of Office)
    Dim strfilename As String, strbookshortname As String, strsheetname As String, strrange As String
    Dim intbang As Integer, blnorange As Boolean
    Dim rng As Range, rwtemp As Row
    Dim slide_num As Integer, sglscale As Single
    Dim hlnks As Hyperlinks, hlnk As Hyperlink
On Error GoTo Err_InsertHyperlinkContent
    
    If chkFetchAll = True Then
        Selection.Start = ActiveDocument.Bookmarks(Const_DOCTESTDESC_START).Start
        Selection.End = ActiveDocument.Bookmarks(Const_DOCTESTDESC_END).Start - 1
    End If
    chkFetchAll = False ' always reset the box
    
    ' always expand the range in case the cursur is next to and not on top of the hyperlink
    Set rng = Selection.Range
    rng.Expand wdParagraph
    Set hlnks = rng.Hyperlinks
    
    For Each hlnk In hlnks
        System.Cursor = wdCursorWait
        
        '====================================================================================================================
        ' convert the hyperlink to a table row first and confirm that it is within a table
        '====================================================================================================================
        Call ConvertHyperlinkToTableRow(hlnk)
        If Not IsRangeInTable(hlnk.Range) Then
            MsgBox "Document structure error, hyperlink '" & hlnk.Name & "' not in table row.", vbCritical
            hlnk.Range.Select
            GoTo Exit_InsertHyperlinkContent
        End If
        
        '====================================================================================================================
        ' keep the hyperlink and the contents together
        '====================================================================================================================
        Set rng = hlnk.Range.Rows(1).Range
        rng.ParagraphFormat.KeepWithNext = True
        
        '====================================================================================================================
        ' now delete the existing hyperlink content
        '====================================================================================================================
        ' find the next hyperlink or the Comments table
        Do
            rng.Move wdParagraph ' move to the next paragraph and check the contents
            Set rng = rng.Paragraphs(1).Range
            If rng.Hyperlinks.Count > 0 Then
                If IsRangeInTable(rng) Then
                    rng.End = rng.Rows(1).Range.Start
                Else
                    rng.Move wdParagraph, -1
                End If
                Exit Do
            ElseIf IsRangeInTable(rng) Then
                If InStr(1, rng.Rows(1).Cells(1).Range.Text, Const_TABLE_COMMENTS_TEXT) > 0 Then
                    rng.Move wdParagraph, -1 ' move back one paragraph
                    Exit Do
                End If
            End If
            
            ' check that we've not gone into the next test case/set
            If rng.ListParagraphs.Count > 0 Then
                If rng.ListParagraphs(1).OutlineLevel > 0 Then
                    MsgBox "Document structure error, could not find hyperlink or Comments table after hyperlink '" & hlnk.Name & "'.", vbCritical
                    ActiveDocument.Range(hlnk.Range.Start, hlnk.Range.End).Select
                    GoTo Exit_InsertHyperlinkContent
                    Exit Do
                End If
            End If
        Loop
        rng.Start = hlnk.Range.Rows(1).Range.End
        If rng.Start < rng.End Then rng.Delete
                               
        '====================================================================================================================
        ' insert the new hyperlink content
        '====================================================================================================================
        ' we know the hyperlink is in a table row, so add a new row below it and change the row to text
        Set rwtemp = hlnk.Range.Rows.Add
        Set rng = rwtemp.Range.Rows.ConvertToText
        rng.End = rng.End - 1
        rng.Delete ' ensure the paragraph is empty
        rng.InsertParagraphAfter ' insert another paragraph to ensure that the inserted content is detached from the hyperlink table row
        rng.Collapse wdCollapseEnd
        rng.Style = wdStyleDefaultParagraphFont
        rng.ParagraphFormat.KeepWithNext = False
        
        ' determine the hyperlink filename
        strfilename = hlnk.Address
        ' if the above is not a full path (based on drive), then make it a full path
        If Right(Left(strfilename, 2), 1) <> ":" Then
            strfilename = ActiveDocument.Path & "\" & strfilename
        End If
        
        '====================================================================================================================
        ' get the scale value - assume it to be in the 5th cell of a links table row
        ' NOTE: Older entries might still have the % value in the 6th cell and if so, delete this cell and increase the width
        '       of the 5th cell.
        '====================================================================================================================
        sglscale = 0
        Set rwtemp = hlnk.Range.Rows(1)
        If rwtemp.Cells.Count = 5 Then
            If Right(strfilename, 4) <> ".xls" Then
                ' default to 75%
                If InStr(1, rwtemp.Cells(5).Range.Text, "TBD") > 0 Or _
                   Val(rwtemp.Cells(5).Range.Text) = 0 Then
                    rwtemp.Cells(5).Range.Text = "75%"
                End If
                sglscale = Val(rwtemp.Cells(5).Range.Text)
            Else
                ' scales don't apply to spreadsheets, so gobble the value
                rwtemp.Cells(5).Range.Text = vbNullString
            End If
        End If
                    
        '====================================================================================================================
        ' check for spreadsheet links
        '====================================================================================================================
        If (Right(strfilename, 4) = ".xls") Then
            ' only insert data if the sub-address is specified
            If (hlnk.SubAddress <> vbNullString) Then
                If objExcel Is Nothing Then
                    Set objExcel = GetApplicationObject("Excel.Application", , True)
                    objExcel.Visible = False
                End If
                
                strbookshortname = Right(strfilename, Len(strfilename) - Len(ActiveDocument.Path) - 1)
                On Error GoTo Err_InsertHyperlinkContent_XlsBook
                Set objBook = objExcel.Workbooks(strbookshortname)
                On Error GoTo Err_InsertHyperlinkContent
                
Continue_InsertHyperlinkContent_XlsBook:
                objBook.Activate
                intbang = InStr(1, hlnk.SubAddress, "!", vbTextCompare)
                If intbang = 0 Then
                    strsheetname = objBook.Worksheets(1).Name
                    blnorange = True
                Else
                    strsheetname = Left(hlnk.SubAddress, intbang - 1)
                    blnorange = False
                End If
                strrange = Right(hlnk.SubAddress, Len(hlnk.SubAddress) - intbang)
                Set objSheet = objBook.Worksheets(strsheetname)
                objSheet.Activate
                objSheet.Range(strrange).Select
                
                If blnorange = False Then
                    ' minimise use of Clipboard
                    objExcel.Selection.Copy
                    rng.PasteSpecial , , , , wdPasteRTF
                    If InStr(1, strrange, ":", vbTextCompare) > 0 Then
                        ' range of cells, so assume a table
                        rng.Tables(1).Rows.Height = wdRowHeightAuto
                        rng.Tables(1).Columns.AutoFit
                        rng.Tables(1).Range.Font.Size = 7
                        rng.Tables(1).Range.Paragraphs.Indent
                    Else
                        ' single cell, so assume a line
                        rng.StartOf wdParagraph, wdMove
                        rng.EndOf wdParagraph, wdExtend
                        rng.Font.Size = 7
                        rng.Paragraphs.Indent
                    End If
                Else
                    rng.Text = Const_DOC_ERROR_STRING & " NO NAMED RANGE SPECIFIED IN HYPERLINK"
                End If
            End If
        '====================================================================================================================
        ' check for presentation links
        '====================================================================================================================
        ElseIf Right(strfilename, 4) = ".ppt" Then
            If objPowerPoint Is Nothing Then
                Set objPowerPoint = GetApplicationObject("PowerPoint.Application", , True)
                objPowerPoint.Activate
                objPowerPoint.WindowState = ppWindowMinimized
            End If

            ' insert link to specific slide
            If hlnk.SubAddress = vbNullString Then
                slide_num = 1
            Else
                slide_num = hlnk.SubAddress
            End If
            Call InsertPowerPointSlide(objPowerPoint, rng, strfilename, slide_num, sglscale)
        '====================================================================================================================
        ' check for other links
        '====================================================================================================================
        Else
            Call InsertOtherItem(rng, strfilename, sglscale)
        End If
        
        ' delete the remaining empty paragraph below the hyperlink
        Set rng = hlnk.Range.Rows(1).Range
        rng.Start = rng.End
        rng.End = rng.Start + 1
        rng.Delete
        
    Next hlnk
    
Exit_InsertHyperlinkContent:
    System.Cursor = wdCursorNormal
    On Error Resume Next
    objPowerPoint.Quit
    Set objPowerPoint = Nothing
    objExcel.DisplayAlerts = False
    objExcel.Quit
    Set objSheet = Nothing
    Set objBook = Nothing
    Set objExcel = Nothing
    Exit Sub
    
Err_InsertHyperlinkContent_XlsBook:
    ' Clear Err object in case workbook was not open
    Err.Clear
    On Error GoTo Err_InsertHyperlinkContent
    objExcel.Workbooks.Open strfilename, False
    Set objBook = objExcel.Workbooks(strbookshortname)
    Resume Continue_InsertHyperlinkContent_XlsBook
    
Err_InsertHyperlinkContent:
    MsgBox Err.Description & " in InsertHyperlinkContent()", vbExclamation, "Error " & Err.Number
    Resume Exit_InsertHyperlinkContent
    
End Sub

Private Sub ConvertHyperlinkToTableRow(ByRef hlnk As Hyperlink)
    Dim rngtemp As Range, tbl As Table, tblsplit As Table, rngtbl As Range
On Error GoTo Err_ConvertHyperlinkToTableRow
    
    ' only convert it to a table if not already in a table
    If Not IsRangeInTable(hlnk.Range) Then
        ' insert a paragraph before the range to keep the new table seperate - we delete it again at the end
        hlnk.Range.Paragraphs(1).Range.InsertParagraphBefore
        Set rngtemp = hlnk.Range.Paragraphs(1).Range
        Set tbl = rngtemp.ConvertToTable(wdSeparateByTabs, 1, 5)
        Set rngtemp = tbl.Range
        If tbl.Rows.Count > 1 Then
            ' there was already a table below the hyperlink, so split it off so we don't change its formatting
            Set tblsplit = tbl.Split(2)
            Set rngtemp = tbl.Range ' reset the temporary range
        End If
        ' set defaults
        tbl.AutoFormat wdTableFormatNone, True, True, True, True, False, False, False, False, False
        With rngtemp
            .ParagraphFormat.SpaceBefore = 3
            .ParagraphFormat.SpaceAfter = 3
            .ParagraphFormat.Alignment = wdAlignParagraphLeft
            Set rngtbl = rngtemp
            Do
                ' find the first non-hyperlink table above the current
                Set rngtbl = rngtbl.Previous(wdTable, 1)
                If InStr(1, rngtbl.Rows.Last.Cells(1).Range.Text, Const_TABLE_LINKS_TEXT) Then
                    Exit Do
                End If
                If rngtbl.Rows.Count > 1 Then
                    If InStr(1, rngtbl.Rows.Last.Previous.Cells(1).Range.Text, Const_TABLE_LINKS_TEXT) Then
                        Exit Do
                    End If
                End If
            Loop
            .Rows.SetLeftIndent rngtbl.Rows(1).LeftIndent, wdAdjustNone ' use first row's indentation
            .Cells(1).Width = CentimetersToPoints(Const_CELL_PURPOSE_LABEL_WIDTH)
            With .Cells(2)
                .Width = CentimetersToPoints(Const_CELL_NUM_WIDTH)
                .Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
            End With
            With .Cells(3)
                .Width = CentimetersToPoints(Const_CELL_LINK_WIDTH)
                .Range.Font.ColorIndex = wdBlue
            End With
            With .Cells(4)
                .Width = CentimetersToPoints(Const_CELL_LINK_SCALE_HEAD_WIDTH)
                .Range.ParagraphFormat.Alignment = wdAlignParagraphRight
                .Range.Text = "Scale:"
                .Range.Font.Italic = True
                .Range.Font.Bold = True
            End With
            With .Cells(5)
                .Width = CentimetersToPoints(Const_CELL_LINK_SCALE_WIDTH)
                .Range.Text = "TBD%"
                .Range.ParagraphFormat.Alignment = wdAlignParagraphRight
            End With
        End With
        
        ' now delete the paragraphs that were added
        rngtemp.Start = tbl.Range.Start - 1 ' the paragraph above the table
        rngtemp.End = rngtemp.Start + 1 ' include the paragraph marker
        rngtemp.Delete
        If Not tblsplit Is Nothing Then
            rngtemp.Start = tblsplit.Range.Start - 1 ' the paragraph above the table
            rngtemp.End = rngtemp.Start + 1 ' include the paragraph marker
            rngtemp.Delete
        End If
    Else
        ' if we're already in a table, check for older link entries that might still have the % value in the 6th cell
        ' and if so, delete this cell and increase the width of the 5th cell.
        Set tbl = hlnk.Range.Tables(1)
        Set rngtbl = tbl.Rows(tbl.Rows.Count).Range ' using the last row of the table also caters for the case of the
                                                    ' first link that is normally attached to the test case table.
        With rngtbl
            If .Cells.Count = 6 Then
                If InStr(1, .Cells(6).Range.Text, "%") > 0 Then
                    .Cells(6).Delete
                    .Cells(3).Width = CentimetersToPoints(Const_CELL_LINK_WIDTH)
                    .Cells(5).Width = CentimetersToPoints(Const_CELL_LINK_SCALE_WIDTH)
                    .Cells(5).Range.Text = Trim(Val(rngtbl.Cells(5).Range.Text)) & "%"
                End If
            End If
        End With
    End If
    
    ' reset the hyperlink range
    Set hlnk = tbl.Range.Hyperlinks(1)
    
Exit_ConvertHyperlinkToTableRow:
    Exit Sub
    
Err_ConvertHyperlinkToTableRow:
    MsgBox Err.Description & " in ConvertHyperlinkToTableRow()", vbExclamation, "Error " & Err.Number
    Resume Exit_ConvertHyperlinkToTableRow
    
End Sub

Private Function InsertPowerPointSlide(ByRef objPowerPoint As Object, ByRef rng As Range, _
                                       ByVal ppt_filename As String, ByVal slide_number As Integer, ByVal sglscale As Single) As Boolean
    Dim prstn As Object ' PowerPoint.Presentation (compatibility issues when running on earlier versions of Office)
    Dim blalreadyopen As Boolean
    Dim outfile As String
    Dim ils As InlineShape
    Dim strpath As String
On Error GoTo Err_InsertPowerPointSlide
        
    If slide_number < 1 Then slide_number = 1
    
    strpath = Application.StartupPath
    outfile = strpath & "\Slide" & slide_number & ".wmf"
        
    blalreadyopen = False
    For Each prstn In objPowerPoint.Presentations
        If prstn.Fullname = ppt_filename Then
            blalreadyopen = True
            Exit For
        End If
    Next prstn
    
    If blalreadyopen = False Then
        Set prstn = objPowerPoint.Presentations.Open(ppt_filename, True, , True)
    End If
            
    prstn.Slides(slide_number).Export outfile, "wmf"
   
    rng.Style = wdStyleDefaultParagraphFont
    rng.ParagraphFormat.KeepWithNext = False
    Set ils = rng.InlineShapes.AddPicture(outfile, False, True)
    If sglscale > 0 Then
        ils.ScaleHeight = sglscale
        ils.ScaleWidth = sglscale
    End If
    rng.ListFormat.RemoveNumbers wdNumberParagraph
    rng.Paragraphs.Last.Alignment = wdAlignParagraphCenter
    rng.Font.Underline = wdUnderlineNone
                  
    Kill outfile
    
    InsertPowerPointSlide = True
    
Exit_InsertPowerPointSlide:
    On Error Resume Next
    Set prstn = Nothing
    Exit Function
    
Err_InsertPowerPointSlide:
    InsertPowerPointSlide = False
    MsgBox Err.Description & " in InsertPowerPointSlide()", vbExclamation, "Error " & Err.Number
    Resume Exit_InsertPowerPointSlide
    
End Function

Private Function InsertOtherItem(ByRef rng As Range, ByRef stritempath As String, ByVal sglscale As Single) As Boolean
    Dim ils As InlineShape, strextension As String
On Error GoTo Err_InsertOtherItem
        
    strextension = Right(stritempath, 3)
    Select Case strextension
        Case "bmp", "gif", "jpg", "wmf", "tif"
            Set ils = rng.InlineShapes.AddPicture(stritempath, False, True)
        Case Else
            Set ils = rng.InlineShapes.AddOLEObject(Filename:=stritempath, LinkToFile:=False, DisplayAsIcon:=True)
    End Select
    If sglscale > 0 Then
        ils.ScaleHeight = sglscale
        ils.ScaleWidth = sglscale
    End If
    rng.ListFormat.RemoveNumbers wdNumberParagraph
    rng.Paragraphs.Last.Alignment = wdAlignParagraphCenter
              
    InsertOtherItem = True
    
Exit_InsertOtherItem:
    Exit Function
    
Err_InsertOtherItem:
    InsertOtherItem = False
    MsgBox Err.Description & " in InsertOtherItem()", vbExclamation, "Error " & Err.Number
    Resume Exit_InsertOtherItem
    
End Function

Private Sub btnImportSATPTest_Click()
    Dim tblsatp As Table, tblstd As Table, rngsatp As Range, rngstd As Range, rngtemp As Range
    Dim rwsatp As Row, rwstd As Row, intlaststep As Integer
    Dim tblfrmtsatp As cTblTestFormat, tblfrmtstd As cTblTestFormat
    Dim strtestname As String, sngtblwidth As Single, cel As Cell, idx As Integer
On Error GoTo Err_btnImportSATPTest_Click

    Call ScreenUpdatePause
    
    Set tblsatp = Dst.PreviousDocument.Windows(1).Selection.Tables(1)
    Set tblstd = Selection.Tables(1)
    For Each cel In tblstd.Rows(1).Cells
        sngtblwidth = sngtblwidth + cel.Width
    Next cel
        
    '================================================================================================================
    ' get the table format for the SATP test
    '================================================================================================================
    strtestname = GetHeadingText(Dst.PreviousDocument.Windows(1).Selection.Range)
    Set tblfrmtsatp = New cTblTestFormat
    Call SetTestTableFormat(strtestname, tblfrmtsatp)
    
    '================================================================================================================
    ' get the table format for the STD test
    '================================================================================================================
    strtestname = GetHeadingText(Selection.Range)
    Set tblfrmtstd = New cTblTestFormat
    Call SetTestTableFormat(strtestname, tblfrmtstd)
        
    ' NOTE: for the table section processing that follows, assume the STD table is well formed - only the SATP table ranges are checked
        
    '================================================================================================================
    ' transfer purpose
    '================================================================================================================
    Set rngsatp = GetTestTablePurposeSection(tblsatp.Range)
    If rngsatp Is Nothing Then
        Exit Sub
    End If
    Set rngsatp = rngsatp.Cells(2).Range
    rngsatp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
    Set rngstd = GetTestTablePurposeSection(tblstd.Range)
    rngstd.Cells(2).Range.FormattedText = rngsatp.FormattedText
    
    If GetTestSetCase(strtestname) = "Set" Then
        '================================================================================================================
        ' init limitatons and test requirements and remove 2nd test implementation reference
        '================================================================================================================
        GetTestTableSection(rngstd, Const_TABLE_COVERAGE_LIMITATIONS_TEXT).Cells(3).Range.Text = "None"
        GetTestTableSection(rngstd, Const_TABLE_ADD_HARDWARE_REQ_TEXT).Cells(3).Range.Text = "None"
        GetTestTableSection(rngstd, Const_TABLE_INPUT_DATA_REQ_TEXT).Cells(3).Range.Text = "None"
        GetTestTableSection(rngstd, Const_TABLE_OUTPUT_DATA_REQ_TEXT).Cells(3).Range.Text = "None"
        GetTestTableSection(rngstd, Const_TABLE_IMP_REF_TEXT).Rows(3).Delete
    Else
        '================================================================================================================
        ' transfer preparations
        '================================================================================================================
        Set rngsatp = GetTestTablePreparationsSection(tblsatp.Range)
        If rngsatp Is Nothing Then
            Exit Sub
        End If
        Set rngstd = GetTestTableConditionsSection(tblstd.Range)
        ' make sure we have enough rows in the STD
        Set rngtemp = rngstd.Rows(2).Range
        While rngsatp.Rows.Count > rngstd.Rows.Count
            rngstd.Rows.Add rngtemp.Rows(1)
        Wend
        While rngsatp.Rows.Count < rngstd.Rows.Count
            rngstd.Rows(rngstd.Rows.Count).Delete
        Wend
        Set rwstd = rngstd.Rows(1)
        For Each rwsatp In rngsatp.Rows
            Set rngtemp = rwsatp.Cells(3).Range
            If rngtemp <> vbNullString Then rngtemp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
            If rngtemp.Text Like "*" & Const_TEST_REF_LABEL_SUFFIX Then
                Call MergeTestReference(rwsatp, rwstd)
            Else
                rwstd.Cells(3).Range.FormattedText = rngtemp.FormattedText ' prep text
                Set rngtemp = rwsatp.Cells(2).Range
                rngtemp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
                rwstd.Cells(2).Range = rngtemp.FormattedText ' prep number
            End If
            If Not rwsatp.IsLast Then Set rwstd = rwstd.Next
        Next rwsatp
        
        '================================================================================================================
        ' transfer procedures
        '================================================================================================================
        Set rngsatp = GetTestTableProceduresSection(tblsatp.Range)
        If rngsatp Is Nothing Then
            Exit Sub
        End If
        rngsatp.MoveStart wdRow ' skip section header row
        Set rngstd = GetTestTableProceduresSection(tblstd.Range)
        rngstd.MoveStart wdRow ' skip section header row
        ' make sure we have enough rows in the STD
        While rngsatp.Rows.Count > rngstd.Rows.Count
            rngstd.Rows.Add rngstd.Rows(1)
        Wend
        While rngsatp.Rows.Count < rngstd.Rows.Count
            rngstd.Rows(rngstd.Rows.Count).Delete
        Wend
        Set rwstd = rngstd.Rows(1)
        For Each rwsatp In rngsatp.Rows
            Set rngtemp = rwsatp.Cells(3).Range
            rngtemp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
            rwstd.Cells(3).Range.FormattedText = rngtemp.FormattedText ' step text
            If rngtemp.Text Like "*" & Const_TEST_REF_LABEL_SUFFIX Then
                Call MergeTestReference(rwsatp, rwstd)
            Else
                Set rngtemp = rwsatp.Cells(2).Range
                rngtemp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
                rwstd.Cells(2).Range = rngtemp.FormattedText ' step number
                intlaststep = rngtemp.Text ' store last step number
                Set rngtemp = rwsatp.Cells(4).Range
                rngtemp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
                rwstd.Cells(4).Range.FormattedText = rngtemp.FormattedText ' step result
            End If
            If Not rwsatp.IsLast Then Set rwstd = rwstd.Next
        Next rwsatp
        
        '================================================================================================================
        ' transfer results
        '================================================================================================================
        Set rngsatp = GetTestTableResultsSection(tblsatp.Range)
        If rngsatp Is Nothing Then
            Exit Sub
        End If
        Set rngstd = rwstd.Previous.Range ' we should be pointing to the last procedure row still
        ' make sure we have enough rows in the STD
        For idx = 1 To rngsatp.Rows.Count
            rngstd.Rows.Add
        Next idx
        Set rwstd = rngstd.Rows(1).Next
        For Each rwsatp In rngsatp.Rows
            Set rngtemp = rwsatp.Cells(3).Range
            rngtemp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
            rwstd.Cells(4).Range.FormattedText = rngtemp.FormattedText ' result text
            intlaststep = intlaststep + 1 ' increment step number (continued from steps above)
            rwstd.Cells(2).Range = intlaststep
            If Not rwsatp.IsLast Then Set rwstd = rwstd.Next
        Next rwsatp
        
        '================================================================================================================
        ' transfer requirements
        '================================================================================================================
        Set rngsatp = GetTestTableRequirementsSection(tblsatp.Range)
        If rngsatp Is Nothing Then
            Exit Sub
        End If
        Set rngstd = GetTestTableRequirementsSection(tblstd.Range)
        While rngstd.Rows.Count > 1
            rngstd.Rows(rngstd.Rows.Count).Delete ' leave just one row and point to it
        Wend
        
        ' make sure 3rd cell's content is cleared beforehand so formatting it later on works
        Set rwstd = rngstd.Rows(1)
        rwstd.Cells(3).Range.Text = vbNullString
        
        ' insert the requirements
        idx = 0
        For Each rwsatp In rngsatp.Rows
            If Not rwsatp.Range.Text Like "*None*" Then
                Call InsertXref(rwstd.Range, GetCellText(rwsatp.Cells(3)), GetCellText(rwsatp.Cells(4)), tblsatp.Range.Document.Path & "\" & GetCellText(rwsatp.Cells(5)), True)
                If idx > 0 Then Set rwstd = rwstd.Next  ' new requirements are inserted below 'selected' row
                idx = idx + 1
            End If
        Next rwsatp
        
        '================================================================================================================
        ' remove 2nd test implementation reference
        '================================================================================================================
        GetTestTableSection(rngstd, Const_TABLE_IMP_REF_TEXT).Rows(2).Delete
        
    End If
    
    '================================================================================================================
    ' init comments
    '================================================================================================================
    GetTestTableCommentsSection(tblstd.Range).Cells(2).Range.Text = "None"
    
Exit_btnImportSATPTest_Click:
    Call ScreenUpdateRestore
    Exit Sub
    
Err_btnImportSATPTest_Click:
    MsgBox Err.Description & " in btnImportSATPTest_Click()"
    Resume Exit_btnImportSATPTest_Click
    
End Sub

Private Sub MergeTestReference(ByRef rwsatp As Row, ByRef rwstd As Row)
    Dim rngsatp As Range, rngstd As Range
    
    Set rngsatp = rwsatp.Cells(rwsatp.Cells.Count).Range
    rngsatp.MoveEnd wdCharacter, -1 ' don't copy end-of-cell marker
    Set rwstd = rwstd.Previous ' we append references to the previous row
    Set rngstd = rwstd.Cells(3).Range ' assume we always append to the 3rd column
    rngstd.MoveEnd wdCharacter, -1 ' move back into range
    rngstd.InsertAfter " "
    rngstd.Collapse wdCollapseEnd
    rngstd.FormattedText = rngsatp.FormattedText ' copy reference in-line
    rwstd.Next.Delete ' don't need this row

End Sub
Attribute VB_Name = "frmTextBox"
Attribute VB_Base = "0{B370CCE4-390A-4DD0-A11E-44BCC8F5A9D4}{A3FBE600-70BB-4BD9-82CA-B81DB080458A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum EnumExecuteFunction
    enumExecuteFunctionNone
    enumExecuteFunctionAutoAddBookmarksAll
    enumExecuteFunctionDocStatus
    enumExecuteFunctionUpdateAbbreviations
    enumExecuteFunctionMakeBackup
    enumExecuteFunctionExportPdf
    enumExecuteFunctionImportStyles
    enumExecuteFunctionDocStylesUsage
    enumExecuteFunctionRemoveHelpText
    enumExecuteFunctionFixListParagraphs
    enumExecuteFunctionUpdateAllFields
    enumExecuteFunctionUpdateExtReferences
    enumExecuteFunctionUpdateTrc
    enumExecuteFunctionUpdateTrcSummaryMetrics
    enumExecuteFunctionCheckDocument
    enumExecuteFunctionTestMgmtAddAllHyperlinks
    enumExecuteFunctionPrepareEdit
    enumExecuteFunctionUpdateSTRResults
    enumExecuteFunctionTransferToNewTemplate
End Enum

Public FunctionToExecute As EnumExecuteFunction
Public TargetDocument As Document
Public OpenArgs As String

Private DicResultText As Scripting.Dictionary
Private IntResultNum As Integer
Private ProcessTimer As cTimer
Private DoEventsTimer As cTimer

Private Const Const_FORM_HEIGHT_NORMAL As Integer = 305
Private Const Const_FORM_HEIGHT_PROGRESSBAR As Integer = 315
Private Const Const_FORM_HEIGHT_BUTTONS As Integer = 328

Private Const Const_TEXTBOX_WIDTH_DECREMENT As Integer = 26

Private Sub UserForm_Initialize()
    
    Set ProcessTimer = New cTimer ' start timer
    Set DoEventsTimer = New cTimer
    
    Call ClearProgressText
    Me.txtTraceText.Width = Me.Width - Const_TEXTBOX_WIDTH_DECREMENT
    lblProgressBar.Top = txtTraceText.Top + txtTraceText.Height + 4
    Set DicResultText = New Scripting.Dictionary
    
End Sub
 
Private Sub UserForm_Activate()
    Dim dicdocs As Scripting.Dictionary
    Call HideButtons
    Call UpdateProgressMeter(-1)
    If Not FunctionToExecute = enumExecuteFunctionNone Then
        Set dicdocs = New Scripting.Dictionary
        dicdocs.Add TargetDocument.Fullname, TargetDocument
        Call ExecuteFunctionBatch(FunctionToExecute, dicdocs)
    End If
End Sub

Public Sub ExecuteFunctionBatch(ByVal func As EnumExecuteFunction, ByRef dicdocs As Scripting.Dictionary)
    Dim blstatus As Boolean, strstatus As String, tim As cTimer, vardoc As Variant
On Error GoTo Err_ExecuteFunctionBatch

    Set tim = New cTimer
    Call ScreenUpdateOff
    
    For Each vardoc In dicdocs
        Set TargetDocument = dicdocs(vardoc)
        IntResultNum = 0
        ProcessTimer.Restart
        If ExecuteFunction(func, TargetDocument) Then
            dicdocs.Remove vardoc
        End If
        UpdateProgressText " "
    Next vardoc
    
    ' if all documents were removed from dictionary above, status must be OK
    blstatus = (dicdocs.Count = 0)
        
    If func <> enumExecuteFunctionNone Then
        If dicdocs.Count > 0 Then
            UpdateProgressText "The function failed for following documents:"
            For Each vardoc In dicdocs
                UpdateProgressText vardoc & ":"
                UpdateProgressText GetResult(vardoc) & vbCrLf
            Next vardoc
        End If
        Call ManageStatus(blstatus)
        UpdateProgressText "'" & Me.Caption & "' completed in " & tim.GetDuration & " seconds."
        UpdateProgressText String(85, "_")
        Call WriteDebugFile(txtTraceText.Text, Const_TRACE_FILENAME, True)
    End If
    
Exit_ExecuteFunctionBatch:
    Call ScreenUpdateOn
    Exit Sub
    
Err_ExecuteFunctionBatch:
    If Err.Number = -2147418105 Then Resume Next ' automation error occurs when another form instance is opened by function TransferDocumentToNewTemplate
    MsgBox Err.Description & " in ExecuteFunctionBatch()"
    Resume Exit_ExecuteFunctionBatch
End Sub

Private Function ExecuteFunction(ByVal func As EnumExecuteFunction, ByRef objdoc As Document) As Boolean
    Dim blstatus As Boolean, strstatus As String

    ' check which function was requested
    Select Case func
        Case enumExecuteFunctionAutoAddBookmarksAll
            Call SetTraceCaption("Auto Add Bookmarks", objdoc)
            blstatus = AddBookmarkAutoAll(objdoc, Me, OpenArgs)
        
        Case enumExecuteFunctionDocStatus
            Call SetTraceCaption("Document Status", objdoc)
            blstatus = CheckDocumentStatusComplete(objdoc, Me)
        
        Case enumExecuteFunctionUpdateAbbreviations
            Call SetTraceCaption("Update Abbreviations Table", objdoc)
            Me.txtTraceText.Font.Name = "Courier New"
            blstatus = UpdateAbbreviationsList(objdoc, Me, True)
        
        Case enumExecuteFunctionMakeBackup
            Call SetTraceCaption("Document Backup", objdoc)
            blstatus = MakeDocumentBackup(objdoc, Me)
        
        Case enumExecuteFunctionExportPdf
            Call SetTraceCaption("Export PDF", objdoc)
            blstatus = ExportDocumentPdf(objdoc, Me)
                
        Case enumExecuteFunctionUpdateAllFields
            Call SetTraceCaption("Update All Fields", objdoc)
            blstatus = UpdateAllFields(objdoc, Me, , OpenArgs)
            
        Case enumExecuteFunctionUpdateExtReferences
            Call SetTraceCaption("Update External References Table", objdoc)
            blstatus = UpdateExternalReferencesTable(objdoc, Me)
        
        Case enumExecuteFunctionUpdateTrc
            Call SetTraceCaption("Update Traceability Tables", objdoc)
            blstatus = UpdateDocTraceabilityTables(objdoc, Me)

        Case enumExecuteFunctionUpdateTrcSummaryMetrics
            Call SetTraceCaption("Update Summary Traceability Table Metrics", objdoc)
            blstatus = UpdateTRCSummaryTableMetrics(objdoc, Me)

        Case enumExecuteFunctionCheckDocument
            Call SetTraceCaption("Check Document", objdoc)
            blstatus = CheckDocument(objdoc, Me)
        
        Case enumExecuteFunctionImportStyles
            Call SetTraceCaption("Import Styles", objdoc)
            blstatus = ImportStyles(objdoc, Me, OpenArgs)
        
        Case enumExecuteFunctionDocStylesUsage
            Call SetTraceCaption("Document Styles Usage", objdoc)
            Me.txtTraceText.Font.Name = "Courier New"
            blstatus = ListDocStyles(objdoc, Me)
        
        Case enumExecuteFunctionRemoveHelpText
            Call SetTraceCaption("Remove Help Text", objdoc)
            blstatus = RemoveHelptext(objdoc, Me)
            
        Case enumExecuteFunctionFixListParagraphs
            Call SetTraceCaption("Fixing Orphaned List Paragraphs", objdoc)
            blstatus = RevertOrphanedListParagraphs(objdoc, Me)
            
        Case enumExecuteFunctionTestMgmtAddAllHyperlinks
            Call SetTraceCaption("Add Test Script Hyperlinks", objdoc)
            blstatus = AddMissingTestScriptHyperlinks(objdoc, Me)
            
        Case enumExecuteFunctionPrepareEdit
            Call SetTraceCaption("Prepare for Document Edit", objdoc)
            blstatus = PrepareForEdit(objdoc, Me)
        
        Case enumExecuteFunctionUpdateSTRResults
            Call SetTraceCaption("Update Test Results", objdoc)
            blstatus = UpdateSoftwareTestReport(objdoc, Me)
        
        Case enumExecuteFunctionTransferToNewTemplate
            Call SetTraceCaption("Transfer Content to New Template", objdoc)
            blstatus = TransferDocumentToNewTemplate(objdoc, Me.Caption)
        
        Case enumExecuteFunctionNone
            blstatus = True
        
        Case Else
            Call SetTraceCaption("Unknown Function", objdoc)
            txtTraceText.Text = "Unknown function '" & FunctionToExecute & "' used to invoke the form."
        
    End Select
    
    ExecuteFunction = blstatus
    
End Function

Private Sub SetTraceCaption(ByVal strfunction As String, ByRef objdoc As Document)
    Me.Caption = strfunction
    UpdateProgressText "Executing the '" & strfunction & "' function for " & objdoc.Name & ":"
End Sub

Sub ManageStatus(ByVal blstatus As Boolean)
    Call ShowButtons
    If blstatus = False Then
        txtTraceText.ForeColor = vbRed
        Beep
    Else
        txtTraceText.ForeColor = vbBlack
    End If
End Sub

Private Sub btnClose_Click()
    Unload Me
End Sub

Private Sub btnOpenTraceFile_Click()
    Call OpenDebugFile(Const_TRACE_FILENAME)
End Sub

Private Sub btnManageAbbreviations_Click()
    Call OpenUserForm("frmAbbrevIgnore", TargetDocument, , , , vbModal)
End Sub

Private Sub btnListAbbreviations_Click()
    Call UpdateProgressText(GetAbbreviationsData(TargetDocument))
    Call WriteDebugFile(txtTraceText.Text, Const_TRACE_FILENAME, True)
End Sub

Private Sub ShowButtons()
    Me.Height = Const_FORM_HEIGHT_BUTTONS ' increase height so buttons fit
    btnClose.Visible = True
    btnOpenTraceFile.Visible = True
    btnManageAbbreviations.Visible = (FunctionToExecute = enumExecuteFunctionUpdateAbbreviations Or FunctionToExecute = enumExecuteFunctionCheckDocument)
    btnListAbbreviations.Visible = btnManageAbbreviations.Visible
End Sub

Private Sub HideButtons()
    Me.Height = Const_FORM_HEIGHT_NORMAL ' restore size
    btnClose.Visible = False
    btnOpenTraceFile.Visible = False
    btnManageAbbreviations.Visible = False
    btnListAbbreviations.Visible = False
End Sub

Sub ClearProgressText()
    Me.txtTraceText = vbNullString
End Sub

Sub UpdateProgressText(ByVal strtext As String, Optional ByVal blcrlf As Boolean = True)
    Dim strtextend As String
    If strtext <> vbNullString Then
        If BlDSTDebugTiming Then
            If ProcessTimer.GetDuration > 0 Then ' only show timing if there is any
                ' append timing of previous process to previous line of text
                strtextend = Right(txtTraceText.Text, 2)
                If strtextend = vbCrLf And txtTraceText.Text <> vbNullString Then ' if line ends in CRLF
                    If Left(Right(txtTraceText.Text, 4), 2) <> vbCrLf And Left(Right(txtTraceText.Text, 3), 1) <> " " Then  ' skip blank lines
                        txtTraceText.Text = Left(txtTraceText.Text, txtTraceText.TextLength - Len(strtextend))
                        txtTraceText.Text = txtTraceText.Text & " (" & ProcessTimer.GetDuration(True) & ")" ' note we restart the timer
                        txtTraceText.Text = txtTraceText.Text & strtextend
                    End If
                End If
            End If
        End If
        txtTraceText.SetFocus
        txtTraceText.Text = txtTraceText.Text & strtext & IIf(blcrlf, vbCrLf, vbNullString)
        txtTraceText.CurLine = txtTraceText.LineCount - 1
        DoEvents
    End If
End Sub

Sub UpdateProgressMeter(ByVal idx As Long, Optional ByVal Total As Long = 1)
    Dim sglfrac As Single, intpercent As Integer
    If idx >= 0 Then
        sglfrac = idx / Total
        intpercent = 100 * sglfrac
        If intpercent < 1 Then intpercent = 1 ' show minimum of one
        Me.Height = Const_FORM_HEIGHT_PROGRESSBAR ' increase height so bar fits
        lblProgressBar.Caption = intpercent & "%"
        lblProgressBar.Width = 20 + intpercent * ((Me.Width - 40) / 100)
    Else
        Me.Height = Const_FORM_HEIGHT_NORMAL ' restore size
        lblProgressBar.Caption = vbNullString
        lblProgressBar.Width = 0
    End If
    Me.Repaint
    If DoEventsTimer.GetDuration > 5 Then
        DoEvents ' so we show the form in case another application received the focus
        DoEventsTimer.Restart
    End If
End Sub

Sub LogResult(ByVal strtext As String)
    If strtext <> vbNullString Then
        IntResultNum = IntResultNum + 1
        If Not DicResultText.Exists(TargetDocument.Fullname) Then DicResultText.Add TargetDocument.Fullname, vbNullString
        strtext = AddStatusText(DicResultText(TargetDocument.Fullname), "   " & IntResultNum & ". " & strtext)
        DicResultText(TargetDocument.Fullname) = strtext
    End If
End Sub

Function GetResult(Optional ByVal strdocname As String = vbNullString) As String
    If strdocname = vbNullString Then strdocname = TargetDocument.Fullname
    GetResult = DicResultText(strdocname)
End Function

Private Sub UserForm_Click()
    txtTraceText.CurLine = txtTraceText.LineCount - 1
End Sub

' InQuest injected base64 decoded content
' ,"zn
' *'~(
' *'~(
' '.+-
' x(^rK.
' zjej
' bzWQy
' b'r[
' Szjej
' *^r'
' z{Qy
' z{Qy
' I4bm
' xLmE
' *Zr)
' *Zr)
' "w+y
' SD"n
' SD$R
' SD$R
' jZ N
' */"{-
' */Rr'
' z{lI
' z{lI
' *'.+-
' Z+aJ
' jT^}
' .+-O*^1
' .+-J
' ^I4S
' :-jQ
' *&n)
' t*/z
' *&n)
' t*/z
' z{^t
' z{^t
' z{^t
' *'~(
' (^rK.
' *'~(
' *'~(
' zj/yV
' zj/x
' &.+-

INQUEST-PP=macro
