Attribute VB_Name = "AutoModules"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public openAborted As Boolean
Public openMCManual As Boolean
Public thisDocDescriptor As clsDocDescriptor
Public thisDocGlossaryAdmin As clsGlossary
Public thisDocGlossaryUser As clsGlossary
Public thisDocGlossaryMerged As clsGlossary
Public thisDocProcessingParameters As clsGlossary
Public thisDocFinder As clsFindReplace
Public thisDocSourcePrefixes As clsGlossary
Public thisDocNavigator As clsNavigator
Public thisDocSaver As clsSaver
Public thisDocColorManager As clsColorManagement
Public thisDocGlossaryEncryptor As clsRC4
Public progressBar As clsProgBar
Public bdt As clsBerrickDateTime
Public Sub AutoOpen()
Set thisDocDescriptor = New clsDocDescriptor
Set thisDocGlossaryAdmin = New clsGlossary
Set thisDocGlossaryUser = New clsGlossary
Set thisDocGlossaryMerged = New clsGlossary
Set thisDocProcessingParameters = New clsGlossary
Set thisDocFinder = New clsFindReplace
Set thisDocSourcePrefixes = New clsGlossary
Set thisDocNavigator = New clsNavigator
Set thisDocSaver = New clsSaver
Set thisDocColorManager = New clsColorManagement
Set thisDocGlossaryEncryptor = New clsRC4
thisDocGlossaryEncryptor.key = c8GlossaryEncryptorKey
Set c8LicenceEncryptor = New clsRC4
c8LicenceEncryptor.key = c8LicenceEncryptorKey01
Call setFormSkins
Set progressBar = New clsProgBar
Set bdt = New clsBerrickDateTime
Call BWordDocumentVariableSet(ThisDocument, "c8Version", c8Version)
Call BWordDocumentVariableSet(ThisDocument, "c8VersionLowestCanImportInto", c8VersionLowestCanImportInto)
thisDocDescriptor.getDetails xDoc:=ThisDocument
thisDocDescriptor.doc = ThisDocument
thisDocGlossaryAdmin.loadFromString thisDocDescriptor.glossaryAdmin, glAllowDupKeys:=True, glAllowDupItems:=True, glEncryptor:=thisDocGlossaryEncryptor
thisDocGlossaryUser.loadFromString thisDocDescriptor.glossaryUser, glAllowDupKeys:=True, glAllowDupItems:=True, glEncryptor:=thisDocGlossaryEncryptor
thisDocGlossaryMerged.import glGlossary:=thisDocGlossaryAdmin, glAllowDupKeys:=True, glAllowDupItems:=True
thisDocGlossaryMerged.import glGlossary:=thisDocGlossaryUser, glAllowDupKeys:=True, glAllowDupItems:=True
thisDocSourcePrefixes.loadFromString thisDocDescriptor.sourcePrefixes
thisDocProcessingParameters.loadFromString thisDocDescriptor.glossaryProcessing, glAllowDupKeys:=True, glAllowDupItems:=True, glEncryptor:=thisDocGlossaryEncryptor
If wordVersion >= Word2003 Then Call disableReadingView
fileSavedAsFullName = ThisDocument.fullName
ThisDocument.Saved = True
If BWordSessionParameterIsSet(xOption:=c8RegistryKeyOpenedByC9) Then
openedByC9 = True
Exit Sub
End If
If wordVersion < Word2000 Then
If showMessage(c8Msg5200, button2:="OK", button3:="Cancel", defaultButton:=3) = "OK" Then
Exit Sub
Else
GoTo abortOpen
End If
End If
If autoMacsDisabled() Then Exit Sub
If C8Documents.count <= 1 Then Call EnvironmentCleanup(xAtStartup:=True)
If addinsCount > 0 Then
showMessage c8Msg8020
GoTo abortOpen
End If
If BWordDocumentVariableGet(ThisDocument, "c8DocType", xDefault:=c8MasterChronology) = c8MasterChronology Then
If showMessage(c8Msg5000, button2:="OK", button3:="Cancel", defaultButton:=2) = "OK" Then
openMCManual = True
Call trackedChangesTurnOff(ThisDocument)
ThisDocument.Saved = True
Exit Sub
Else
GoTo abortOpen
End If
End If
Call licenceGetInternal
If licenceHasBeenAccepted() Then
Else
If c8LicenceHaveValid Then
frmLicenceShort.show
Else
frmLicenceEvaluation.show
End If
If Not licenceHasBeenAccepted() Then GoTo abortOpen
End If
If thisDocDescriptor.docType = c8CompositeChronologyNew Then
Else
Call checkDescriptor(thisDocDescriptor, xShowMessage:=True, xErrorMessage:=c8Msg5400)
End If
Call EnvironmentStartup
Call RegisterEventHandler
Call ToolbarAdd
ThisDocument.ActiveWindow.View.ShowHiddenText = False
ThisDocument.ActiveWindow.View.ShowAll = False
BWordUndo_RemoveAllMarkers ThisDocument
Call initialiseFormatDefaults
If trackedChangesLurking(ThisDocument) Then Call trackedChangesOffDialog(ThisDocument, saveDoc:=True)
ThisDocument.Saved = True
Exit Sub
abortOpen:
openAborted = True
ThisDocument.Close
End Sub
Attribute VB_Name = "BerrickEncryption"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private InitDone       As Boolean
Private Map1(0 To 63)  As Byte
Private Map2(0 To 127) As Byte
Public Function Base64EncodeString(ByVal s As String) As String
Base64EncodeString = Base64Encode(ConvertStringToBytes(s))
End Function
Public Function Base64Encode(InData() As Byte)
Base64Encode = Base64Encode2(InData, UBound(InData) - LBound(InData) + 1)
End Function
Public Function Base64Encode2(InData() As Byte, ByVal InLen As Long) As String
If Not InitDone Then Init
If InLen = 0 Then Base64Encode2 = "": Exit Function
Dim ODataLen As Long: ODataLen = (InLen * 4 + 2) \ 3
Dim OLen As Long: OLen = ((InLen + 2) \ 3) * 4
Dim out() As Byte
ReDim out(0 To OLen - 1) As Byte
Dim ip0 As Long: ip0 = LBound(InData)
Dim ip As Long
Dim op As Long
Do While ip < InLen
Dim i0 As Byte: i0 = InData(ip0 + ip): ip = ip + 1
Dim i1 As Byte: If ip < InLen Then i1 = InData(ip0 + ip): ip = ip + 1 Else i1 = 0
Dim i2 As Byte: If ip < InLen Then i2 = InData(ip0 + ip): ip = ip + 1 Else i2 = 0
Dim o0 As Byte: o0 = i0 \ 4
Dim o1 As Byte: o1 = ((i0 And 3) * &H10) Or (i1 \ &H10)
Dim o2 As Byte: o2 = ((i1 And &HF) * 4) Or (i2 \ &H40)
Dim o3 As Byte: o3 = i2 And &H3F
out(op) = Map1(o0): op = op + 1
out(op) = Map1(o1): op = op + 1
out(op) = IIf(op < ODataLen, Map1(o2), Asc("=")): op = op + 1
out(op) = IIf(op < ODataLen, Map1(o3), Asc("=")): op = op + 1
Loop
Base64Encode2 = ConvertBytesToString(out)
End Function
Public Function Base64DecodeString(ByVal s As String) As String
If s = "" Then Base64DecodeString = "": Exit Function
Base64DecodeString = ConvertBytesToString(Base64Decode(s))
End Function
Public Function Base64Decode(ByVal s As String) As Byte()
If Not InitDone Then Init
Dim IBuf() As Byte: IBuf = ConvertStringToBytes(s)
Dim ILen As Long: ILen = UBound(IBuf) + 1
If ILen Mod 4 <> 0 Then Err.Raise vbObjectError, , "Length of Base64 encoded input string is not a multiple of 4."
Do While ILen > 0
If IBuf(ILen - 1) <> Asc("=") Then Exit Do
ILen = ILen - 1
Loop
Dim OLen As Long: OLen = (ILen * 3) \ 4
Dim out() As Byte
ReDim out(0 To OLen - 1) As Byte
Dim ip As Long
Dim op As Long
Do While ip < ILen
Dim i0 As Byte: i0 = IBuf(ip): ip = ip + 1
Dim i1 As Byte: i1 = IBuf(ip): ip = ip + 1
Dim i2 As Byte: If ip < ILen Then i2 = IBuf(ip): ip = ip + 1 Else i2 = Asc("A")
Dim i3 As Byte: If ip < ILen Then i3 = IBuf(ip): ip = ip + 1 Else i3 = Asc("A")
If i0 > 127 Or i1 > 127 Or i2 > 127 Or i3 > 127 Then Err.Raise vbObjectError, , "Illegal character in Base64 encoded data."
Dim b0 As Byte: b0 = Map2(i0)
Dim b1 As Byte: b1 = Map2(i1)
Dim b2 As Byte: b2 = Map2(i2)
Dim b3 As Byte: b3 = Map2(i3)
If b0 > 63 Or b1 > 63 Or b2 > 63 Or b3 > 63 Then Err.Raise vbObjectError, , "Illegal character in Base64 encoded data."
Dim o0 As Byte: o0 = (b0 * 4) Or (b1 \ &H10)
Dim o1 As Byte: o1 = ((b1 And &HF) * &H10) Or (b2 \ 4)
Dim o2 As Byte: o2 = ((b2 And 3) * &H40) Or b3
out(op) = o0: op = op + 1
If op < OLen Then out(op) = o1: op = op + 1
If op < OLen Then out(op) = o2: op = op + 1
Loop
Base64Decode = out
End Function
Private Sub Init()
Dim c As Integer, i As Integer
i = 0
For c = Asc("A") To Asc("Z"): Map1(i) = c: i = i + 1: Next
For c = Asc("a") To Asc("z"): Map1(i) = c: i = i + 1: Next
For c = Asc("0") To Asc("9"): Map1(i) = c: i = i + 1: Next
Map1(i) = Asc("+"): i = i + 1
Map1(i) = Asc("/"): i = i + 1
For i = 0 To 127: Map2(i) = 255: Next
For i = 0 To 63: Map2(Map1(i)) = i: Next
InitDone = True
End Sub
Private Function ConvertStringToBytes(ByVal s As String) As Byte()
Dim b1() As Byte: b1 = s
Dim l As Long: l = (UBound(b1) + 1) \ 2
If l = 0 Then ConvertStringToBytes = b1: Exit Function
Dim b2() As Byte
ReDim b2(0 To l - 1) As Byte
Dim p As Long
For p = 0 To l - 1
Dim c As Long: c = b1(2 * p) + 256 * CLng(b1(2 * p + 1))
If c >= 256 Then c = Asc("?")
b2(p) = c
Next
ConvertStringToBytes = b2
End Function
Private Function ConvertBytesToString(B() As Byte) As String
Dim l As Long: l = UBound(B) - LBound(B) + 1
Dim b2() As Byte
ReDim b2(0 To (2 * l) - 1) As Byte
Dim p0 As Long: p0 = LBound(B)
Dim p As Long
For p = 0 To l - 1: b2(2 * p) = B(p0 + p): Next
Dim s As String: s = b2
ConvertBytesToString = s
End Function
Public Function XOREncryption(CodeKey As String, DataIn As String) As String
Dim lonDataPtr As Long
Dim strDataOut As String
Dim intXOrValue1 As Long, intXOrValue2 As Long
For lonDataPtr = 1 To Len(DataIn)
intXOrValue1 = AscW(Mid$(DataIn, lonDataPtr, 1))
intXOrValue2 = AscW(Mid$(CodeKey, ((lonDataPtr - 1) Mod Len(CodeKey) + 1), 1))
strDataOut = strDataOut + ChrW(intXOrValue1 Xor intXOrValue2)
Next lonDataPtr
XOREncryption = strDataOut
End Function
Attribute VB_Name = "BerrickGen"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
#If VBA7 Then
Declare PtrSafe Function GetUserDefaultLangID Lib "kernel32.dll" () As Long
#Else
Declare Function GetUserDefaultLangID Lib "kernel32.dll" () As Long
#End If
#If VBA7 Then
Declare PtrSafe Function GetShortPathName Lib "kernel32" Alias "GetShortPathNameA" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long
#Else
Declare Function GetShortPathName Lib "kernel32" Alias "GetShortPathNameA" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long
#End If
Public Function BArray2DPreserve(xArray As Variant, xUBound1 As Long, xUBound2 As Long) As Variant
Dim i As Long
Dim j As Long
Dim outArray() As Variant
Dim dataLbound1 As Long
Dim dataUbound1 As Long
Dim dataLbound2 As Long
Dim dataUbound2 As Long
dataLbound1 = LBound(xArray, 1)
dataUbound1 = UBound(xArray, 1)
dataLbound2 = LBound(xArray, 2)
dataUbound2 = UBound(xArray, 2)
If xUBound1 < dataUbound1 Or xUBound2 < dataUbound2 Then
BArray2DPreserve = showMessage(c8Msg6000, msgSuffix2:="BArray2DPreserve: invalid bounds")
Exit Function
End If
ReDim outArray(dataLbound1 To xUBound1, dataLbound2 To xUBound2)
For i = dataLbound1 To dataUbound1
For j = dataLbound2 To dataUbound2
outArray(i, j) = xArray(i, j)
Next j
Next i
BArray2DPreserve = outArray
End Function
Public Function BLng(xString As String) As Long
If IsNumeric(xString) Then
BLng = CLng(xString)
Else
BLng = 0
End If
End Function
Public Function BGetWord(xString As String, xIndex As Long, Optional xTranslatePunctuation As Boolean = False) As String
Dim words() As String
words = BGetWordArray(xString, xTranslatePunctuation)
If (xIndex - 1 > UBound(words)) Or (xIndex - 1 < LBound(words)) Then
BGetWord = ""
Else
BGetWord = words(xIndex - 1)
End If
End Function
Public Function BGetWordArray(xString As String, Optional xTranslatePunctuation As Boolean = False) As String()
If xTranslatePunctuation Then
BGetWordArray = Split(BSqueezeSpaces(BTranslatePunctuationToSpaces(xString)))
Else
BGetWordArray = Split(BSqueezeSpaces(xString))
End If
End Function
Public Function BGetWordCount(xString As String, Optional xTranslatePunctuation As Boolean = False) As Long
BGetWordCount = UBound(BGetWordArray(xString, xTranslatePunctuation)) + 1
End Function
Public Function BSearchArray(xHaystack As Variant, xNeedle As Variant) As Long
Dim i As Long
On Error GoTo notFound
For i = 0 To UBound(xHaystack)
If xNeedle = xHaystack(i) Then
BSearchArray = i
Exit Function
End If
Next i
notFound:
BSearchArray = -1
End Function
Public Function BTranslatePunctuationToSpaces(xString As String, Optional xStandardisePunctuation As Boolean = True) As String
Const CHARS = ".!?,;:""'()[]{}"
Dim strReplacedText As String
Dim intIndex As Long
strReplacedText = xString
If xStandardisePunctuation Then strReplacedText = BWordStandardisePunctuation(strReplacedText)
For intIndex = 1 To Len(CHARS)
strReplacedText = replace(strReplacedText, Mid$(CHARS, intIndex, 1), " ")
Next intIndex
strReplacedText = replace(strReplacedText, vbTab, " ")
BTranslatePunctuationToSpaces = strReplacedText
End Function
Public Function BFileExists(fName As Variant) As Boolean
BFileExists = (Len(Dir(fName)) > 0)
End Function
Public Function BMax(v1 As Variant, v2 As Variant) As Variant
If v1 > v2 Then
BMax = v1
Else
BMax = v2
End If
End Function
Public Function BMin(v1 As Variant, v2 As Variant) As Variant
If v1 < v2 Then
BMin = v1
Else
BMin = v2
End If
End Function
Public Function BTranslateNonPrint(iString As String) As String
Dim i As Long
Dim j As Long
Dim out As String
out = ""
For i = 1 To Len(iString)
j = Asc(Mid$(iString, i, 1))
Select Case j
Case 32 To 126
Case 128
Case 130 To 140
Case 142
Case 145 To 156
Case 158 To 159
Case 160 To 255
Case Else
j = 32
End Select
out = out & Chr(j)
Next i
BTranslateNonPrint = out
End Function
Public Function BTranslateNewLines(iString As String, iReplace As String, Optional squeezeCharacters As Boolean = True) As String
Dim out As String
out = replace(replace(iString, vbCr, iReplace), vbLf, iReplace)
If squeezeCharacters Then out = BSqueezeSpecifiedRepeatedCharacters(out, iReplace)
BTranslateNewLines = out
End Function
Public Function BSqueezeSpaces(iString As String) As String
BSqueezeSpaces = Trim$(BSqueezeSpecifiedRepeatedCharacters(iString, " "))
End Function
Public Function BSqueezeSpecifiedRepeatedCharacters(iString As String, iChar As String) As String
Dim i As Long
Dim out As String
out = ""
For i = 1 To Len(iString)
If (Mid$(iString, i, 1) = iChar And Mid$(iString, i + 1, 1) = iChar) Then
Else
out = out & Mid$(iString, i, 1)
End If
Next i
BSqueezeSpecifiedRepeatedCharacters = out
End Function
Public Function BSqueezeAllRepeatedCharacters(xTargetString As String) As String
Dim i As Long
Dim out As String
out = Left$(xTargetString, 1)
For i = 1 To Len(xTargetString) - 1
If (Mid$(xTargetString, i, 1) = Mid$(xTargetString, i + 1, 1)) Then
Else
out = out & Mid$(xTargetString, i + 1, 1)
End If
Next i
BSqueezeAllRepeatedCharacters = Trim$(out)
End Function
Public Sub BBitSet(bitNum As Long, warehouse As Long, value As Boolean)
If bitNum < 0 Or bitNum > 30 Then
MsgBox "BerrickGen: Error in BBitSet - bit number must be 0 - 30"
Exit Sub
End If
If value Then
warehouse = warehouse Or (2 ^ bitNum)
Else
warehouse = warehouse And (2 ^ bitNum Xor &HFFFF)
End If
End Sub
Public Sub BBitToggle(bitNum As Long, warehouse As Long)
If bitNum < 0 Or bitNum > 30 Then
MsgBox "BerrickGen: Error in BBitToggle - bit number must be 0 - 30"
Exit Sub
End If
warehouse = warehouse Xor 2 ^ bitNum
End Sub
Public Function BBitIsSet(bitNum As Long, warehouse As Long) As Boolean
If bitNum < 0 Or bitNum > 30 Then
MsgBox "BerrickGen: Error in BBitIsSet - bit number must be 0 - 30"
Exit Function
End If
BBitIsSet = (warehouse And 2 ^ bitNum) > 0
End Function
Public Function BRemoveAllSpaces(iString As String) As String
Dim i As Long
Dim string1 As String
string1 = ""
For i = 1 To Len(iString)
If Mid$(iString, i, 1) <> " " Then
string1 = string1 & Mid$(iString, i, 1)
End If
Next i
BRemoveAllSpaces = string1
End Function
Public Function BWithinTolerance(actualNum As Variant, targetNum As Variant, tolerance As Variant) As Boolean
Dim withinLimits As Boolean
withinLimits = False
If IsNumeric(actualNum) And IsNumeric(targetNum) And IsNumeric(tolerance) Then
If Abs(actualNum - targetNum) <= tolerance Then withinLimits = True
Else
MsgBox "BerrickGen: Invalid argument passed to BWithinTolerance function"
End If
BWithinTolerance = withinLimits
End Function
Public Function BWithinBounds(actual As Variant, low As Variant, high As Variant) As Boolean
BWithinBounds = (actual >= low) And (actual <= high)
End Function
Public Function BGetFilenameFromPath(xFullName As Variant) As String
BGetFilenameFromPath = Mid$(xFullName, BDelimiterPosition(xFullName) + 1)
End Function
Public Function BGetFilePath(xFullName As Variant) As String
BGetFilePath = Left$(xFullName, BDelimiterPosition(xFullName))
End Function
Private Function BDelimiterPosition(xFullName As Variant) As Long
Dim i As Long
Dim zString As String
xFullName = replace(xFullName, chrDoubleQuote, "")
For i = Len(xFullName) To 1 Step -1
zString = Mid$(xFullName, i, 1)
If zString = Application.PathSeparator Or zString = "/" Then Exit For
Next i
BDelimiterPosition = i
End Function
Public Function BGetFileExtension(xFullName As String) As String
Dim i As Long
xFullName = replace(xFullName, chrDoubleQuote, "")
For i = Len(xFullName) To 1 Step -1
If Mid$(xFullName, i, 1) = "." Then Exit For
Next i
If i > 1 Then
BGetFileExtension = Mid$(xFullName, i + 1)
Else
BGetFileExtension = ""
End If
End Function
Public Function BGetFilenamePart(xFullName As String) As String
Dim i As Long
xFullName = replace(xFullName, chrDoubleQuote, "")
For i = Len(xFullName) To 1 Step -1
If Mid$(xFullName, i, 1) = "." Then Exit For
Next i
If i > 1 Then
BGetFilenamePart = Left$(xFullName, i - 1)
Else
BGetFilenamePart = xFullName
End If
End Function
Public Function BGetShortName(ByVal sLongFileName As String) As String
Dim lRetVal As Long, sShortPathName As String, ILen As Integer
sShortPathName = Space$(255)
ILen = Len(sShortPathName)
lRetVal = GetShortPathName(sLongFileName, sShortPathName, ILen)
BGetShortName = Left$(sShortPathName, lRetVal)
End Function
Public Function BCountCharacters(inString As String, character As String) As Long
Dim i As Long: Dim out As Long
out = 0
For i = 1 To Len(inString)
If (Mid$(inString, i, 1)) = character Then
out = out + 1
End If
Next i
BCountCharacters = out
End Function
Public Sub BWriteLineInArray(xArray As Variant, xLine As String)
On Error GoTo firstcall
ReDim Preserve xArray(UBound(xArray) + 1)
GoTo laterCalls
firstcall:
ReDim xArray(0)
laterCalls:
xArray(UBound(xArray)) = xLine
End Sub
Public Function BCreateTextDocFromArray(xData As Variant, Optional xWriteProgress As Boolean = False, Optional xAddProgress As Double) As String
Dim out As String
Dim i As Long
Dim linecount As Long
out = ""
linecount = UBound(xData) + 1
For i = 0 To UBound(xData)
If xWriteProgress Then
With progressBar
If .userCancelled Then
Exit Function
End If
.AddProgress xAddProgress / linecount
.Caption2 = "line " & i + 1 & " of " & linecount
End With
End If
If i > 0 And Left$(xData(i), 1) = "H" Then out = out & vbNewLine
out = out & Mid$(xData(i), 3) & vbNewLine
Select Case Left$(xData(i), 2)
Case "xx"
Case "H0"
out = out & String(Len(xData(i)) - 2, ascEquals) & vbNewLine
Case "H1"
out = out & String(Len(xData(i)) - 2, ascEquals) & vbNewLine
Case "H2"
out = out & String(Len(xData(i)) - 2, ascHyphen) & vbNewLine
Case "H3"
out = out & String(Len(xData(i)) - 2, ascFullStop) & vbNewLine
Case Else
End Select
Next i
BCreateTextDocFromArray = out
End Function
Public Function BStringInsert(xTargetString As String, xPos As Long, xInputString As String, Optional xReplace As Boolean = False) As String
Dim out As String
Dim remainder As String
Dim padCount As Long
BStringInsert = xTargetString
On Error GoTo endFunction
padCount = xPos - Len(xTargetString)
If padCount > 0 Then
out = xTargetString & String(padCount - 1, " ")
remainder = ""
Else
out = Left$(xTargetString, xPos - 1)
remainder = Right$(xTargetString, Len(xTargetString) - xPos + 1)
End If
If xReplace Then
out = out & xInputString & Right$(remainder, Len(remainder) - Len(xInputString))
Else
out = out & xInputString & remainder
End If
BStringInsert = out
endFunction:
End Function
Public Function BStringNormaliseLength(xString As String, xLength As Long) As String
Select Case Len(xString)
Case Is < xLength
BStringNormaliseLength = xString & String(xLength - Len(xString), " ")
Case xLength
BStringNormaliseLength = xString
Case Is > xLength
If xLength > 4 Then
BStringNormaliseLength = Left$(xString, xLength - 4) & " ..."
Else
BStringNormaliseLength = Left$(xString, xLength)
End If
End Select
End Function
Public Function BStringNormaliseWhitespace(xString As String) As String
Dim zString As String
zString = xString
zString = replace(zString, vbTab, " ")
zString = replace(zString, vbLf, " ")
zString = replace(zString, vbVerticalTab, " ")
zString = replace(zString, vbFormFeed, " ")
zString = replace(zString, vbCr, " ")
zString = replace(zString, ChrW$(&H2028), " ")
zString = replace(zString, ChrW$(&H2029), " ")
BStringNormaliseWhitespace = zString
End Function
Public Function BNumericOnly(ByVal xKeyPressed As Long) As Long
If xKeyPressed < 48 Or xKeyPressed > 57 Then
BNumericOnly = 0
Else
BNumericOnly = xKeyPressed
End If
End Function
Public Function BPluralityText(xCount As Long, Optional xText As String = "error", Optional xSuffix As String = "s", Optional xShowZeroAsNull As Boolean = False) As String
If xCount = 0 And xShowZeroAsNull Then
BPluralityText = ""
Exit Function
End If
If xCount = 1 Then
BPluralityText = xCount & " " & xText
Else
BPluralityText = xCount & " " & xText & xSuffix
End If
End Function
Public Function BPointsToTwips(xPoints As Long) As Long
BPointsToTwips = 567 * PointsToCentimeters(xPoints)
End Function
Public Function BAddBlippers(xInput As String) As String
BAddBlippers = chrDoubleQuote & xInput & chrDoubleQuote
End Function
Public Function BInstrRev(xHaystack As String, xNeedle As String) As Long
Dim out As Long
If InStr(xHaystack, xNeedle) = 0 Then
out = 0
Else
For out = Len(xHaystack) To 1 Step -1
If InStr(out, xHaystack, xNeedle) Then Exit For
Next
End If
BInstrRev = out
End Function
Public Function BSystemMemory() As Variant
Dim out(0 To 3) As String
Dim data As Variant
Dim item As Variant
Dim i  As Long
Dim objWMIService As Object
For i = 0 To 3
out(i) = 0
Next
On Error GoTo finish
Set objWMIService = GetObject("winmgmts:")
Set data = objWMIService.ExecQuery("Select TotalPhysicalMemory from Win32_ComputerSystem")
For Each item In data
out(0) = format$(item.TotalPhysicalMemory / 2 ^ 30, "0.00") & "G"
Next
Set data = objWMIService.ExecQuery("Select TotalVirtualMemorySize,FreeVirtualMemory , FreePhysicalMemory from Win32_OperatingSystem")
For Each item In data
out(1) = format$(item.FreePhysicalMemory / 2 ^ 20, "0.00") & "G"
out(2) = format$(item.TotalVirtualMemorySize / 2 ^ 20, "0.00") & "G"
out(3) = format$(item.FreeVirtualMemory / 2 ^ 20, "0.00") & "G"
Next
finish:
BSystemMemory = out
End Function
Function BSystemProcessors() As Variant
Dim objWMIService As Object
Dim colSettings As Object
Dim cpu As Object
Dim i As Long
Dim out() As String
ReDim out(0)
out(0) = ""
On Error GoTo finish
Set objWMIService = GetObject("winmgmts:")
Set colSettings = objWMIService.ExecQuery("Select * from Win32_ComputerSystem")
ReDim out(colSettings.count - 1)
Set objWMIService = GetObject("WinMgmts:").instancesof("Win32_Processor")
i = 0
For Each cpu In objWMIService
out(i) = cpu.name & " " & cpu.CurrentClockSpeed & " Mhz, " & cpu.NumberOfCores & " Core(s), " & cpu.NumberOfLogicalProcessors & " Logical Processor(s)"
i = i + 1
Next
finish:
BSystemProcessors = out
End Function
Function BGetUserDefaultLangID() As Long
BGetUserDefaultLangID = GetUserDefaultLangID()
End Function
Public Function BAddOneModular(xNum As Long, xModulus As Long, Optional xBase As Long = 1) As Long
Dim zLong As Long
zLong = xNum + 1
If zLong > xModulus Then zLong = xBase
BAddOneModular = zLong
End Function
Public Function BSubtractOneModular(xNum As Long, xModulus As Long, Optional xBase As Long = 1) As Long
Dim zLong As Long
zLong = xNum - 1
If zLong = xBase - 1 Then zLong = xModulus
BSubtractOneModular = zLong
End Function
Public Function BGetNullDelimitedString(xString As String) As String
BGetNullDelimitedString = Left$(xString, InStr(1, xString, vbNullChar) - 1)
End Function
Attribute VB_Name = "BerrickRegistry"
Option Explicit
Global Const REG_SZ As Long = 1
Global Const REG_DWORD As Long = 4
Global Const HKEY_CLASSES_ROOT = &H80000000
Global Const HKEY_CURRENT_USER = &H80000001
Global Const HKEY_LOCAL_MACHINE = &H80000002
Global Const HKEY_USERS = &H80000003
Global Const ERROR_NONE = 0
Global Const ERROR_BADDB = 1
Global Const ERROR_BADKEY = 2
Global Const ERROR_CANTOPEN = 3
Global Const ERROR_CANTREAD = 4
Global Const ERROR_CANTWRITE = 5
Global Const ERROR_OUTOFMEMORY = 6
Global Const ERROR_INVALID_PARAMETER = 7
Global Const ERROR_ACCESS_DENIED = 8
Global Const ERROR_INVALID_PARAMETERS = 87
Global Const ERROR_NO_MORE_ITEMS = 259
Global Const KEY_ALL_ACCESS = &H3F
Global Const REG_OPTION_NON_VOLATILE = 0
Global gstrAppVersion As String
#If VBA7 Then
Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As LongPtr) As Long
Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As Long, phkResult As LongPtr, lpdwDisposition As Long) As Long
Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As LongPtr) As Long
Declare PtrSafe Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As String, lpcbData As Long) As Long
Declare PtrSafe Function RegQueryValueExLong Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Long, lpcbData As Long) As Long
Declare PtrSafe Function RegQueryValueExNULL Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As Long, lpcbData As Long) As Long
Declare PtrSafe Function RegSetValueExString Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As String, ByVal cbData As Long) As Long
Declare PtrSafe Function RegSetValueExLong Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, ByVal cbData As Long) As Long
#Else
Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, ByVal lpSecurityAttributes As Long, phkResult As Long, lpdwDisposition As Long) As Long
Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Declare Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As String, lpcbData As Long) As Long
Declare Function RegQueryValueExLong Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Long, lpcbData As Long) As Long
Declare Function RegQueryValueExNULL Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As Long, lpcbData As Long) As Long
Declare Function RegSetValueExString Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As String, ByVal cbData As Long) As Long
Declare Function RegSetValueExLong Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, ByVal cbData As Long) As Long
#End If
#If VBA7 Then
Private Function QueryValueEx(ByVal lhKey As LongPtr, ByVal szValueName As String, vValue As Variant) As Long
#Else
Private Function QueryValueEx(ByVal lhKey As Long, ByVal szValueName As String, vValue As Variant) As Long
#End If
Dim cch As Long
Dim lrc As Long
Dim lType As Long
Dim lValue As Long
Dim sValue As String
On Error GoTo QueryValueExError
lrc = RegQueryValueExNULL(lhKey, szValueName, 0&, lType, 0&, cch)
If lrc <> ERROR_NONE Then Error 5
Select Case lType
Case REG_SZ:
sValue = String(cch, 0)
lrc = RegQueryValueExString(lhKey, szValueName, 0&, lType, sValue, cch)
If lrc = ERROR_NONE Then
If Mid$(sValue, cch, 1) = vbNullChar Then
vValue = Left$(sValue, cch - 1)
Else
vValue = Left$(sValue, cch)
End If
Else
vValue = Empty
End If
Case REG_DWORD:
lrc = RegQueryValueExLong(lhKey, szValueName, 0&, lType, lValue, cch)
If lrc = ERROR_NONE Then vValue = lValue
Case Else
lrc = -1
End Select
QueryValueExExit:
QueryValueEx = lrc
Exit Function
QueryValueExError:
Resume QueryValueExExit
End Function
Public Function BRegistryQueryValue(ByVal lpParentKey As Long, sKeyName As String, sValueName As String) As Variant
Dim lRetVal As Long
#If VBA7 Then
Dim hKey As LongPtr
#Else
Dim hKey As Long
#End If
Dim vValue As Variant
lRetVal = RegOpenKeyEx(lpParentKey, sKeyName, 0, KEY_ALL_ACCESS, hKey)
lRetVal = QueryValueEx(hKey, sValueName, vValue)
RegCloseKey (hKey)
BRegistryQueryValue = vValue
End Function
Attribute VB_Name = "BerrickSendKeys"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public Sub BSendKeys(keys As String)
Dim wsh As WshShell
Set wsh = New WshShell
wsh.SendKeys keys
Set wsh = Nothing
End Sub
Attribute VB_Name = "BerrickWord"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Dim strSub|fffd|l As String
Dim strSub|fffd|p As String
Public BWordPerformanceOptionsSetCount As Long
Public BWordTableCellSeparator As String
Public Const BWordTableWriteRowNumbers_None As Long = 0
Public Const BWordTableWriteRowNumbers_GroupByNoneAscending As Long = 1
Public Const BWordTableWriteRowNumbers_GroupByNoneDescending As Long = 2
Public Const BWordTableWriteRowNumbers_GroupByText As Long = 3
Public Const BWordTableWriteRowNumbers_GroupByDateAscending As Long = 4
Public Const BWordTableWriteRowNumbers_GroupByDateDescending As Long = 5
Public Const BWordTableClearRowNumbers As Long = 6
Public Const BWordTableAddColumnOne As Long = 1
Public Const BWordTableDeleteColumnOne As Long = 2
Private Const BWordLogicError As String = "BWordLogicError"
Const performanceOptionsUbound As Long = 5
Const undoBookmarkPrefix As String = "BWordUndoMarker"
Const devbug02BookmarkName As String = "DevBug02Fix"
Public Function BWordGetCellText(inCell As Cell) As String
Dim cRange As Range
Set cRange = inCell.Range
cRange.MoveEnd Unit:=wdCharacter, count:=-1
BWordGetCellText = BSqueezeSpaces(BTranslateNonPrint(BWordStandardisePunctuation(cRange.text)))
End Function
Function BWordGetNumericDocumentIndex(xFullName As String, Optional xShowFailureMessage As Boolean = True) As Long
On Error GoTo notOpen
Dim i As Long
Dim zString As String
Dim d As Document
Dim docCount As Long
docCount = 0
For Each d In Documents
docCount = docCount + 1
Next d
For i = 1 To docCount
If Documents(i).fullName = xFullName Then
BWordGetNumericDocumentIndex = i
Exit Function
End If
Next i
notOpen:
BWordGetNumericDocumentIndex = -1
If xShowFailureMessage Then
zString = "BWordGetNumericDocumentIndex: could not find document index for <" & xFullName & ">"
If Err.Number > 0 Then
zString = zString & vbNewLine & vbNewLine & "Error " & Err.Number & " (" & Err.Description & ")"
End If
showMessage c8Msg6000, msgSuffix2:=zString
End If
End Function
Public Function BWordNormaliseText(text As Variant) As String
BWordNormaliseText = BSqueezeSpaces(BTranslateNonPrint(BWordStandardisePunctuation(text)))
End Function
Public Function BWordGetRowText_TA(xTableAsArray As Variant, xRowNum As Long, xIncludeCells As Long, Optional xCellDelimiter As String = "") As String
Dim out As String
Dim i As Long
out = ""
For i = 1 To xTableAsArray(xRowNum, 0)
If BBitIsSet(i - 1, xIncludeCells) Then out = out & BWordNormaliseText(xTableAsArray(xRowNum, i)) & xCellDelimiter
Next
BWordGetRowText_TA = out
End Function
Public Function BWordIsBlankRow(R As row) As Boolean
Dim c As Cell
For Each c In R.Cells
If Len(BWordGetCellText(c)) <> 0 Then
BWordIsBlankRow = False
Exit Function
End If
Next c
BWordIsBlankRow = True
End Function
Public Function BWordIsBlankRow_TA(xTableAsArray As Variant, xRowNum As Long) As Boolean
Dim i As Long
For i = 1 To xTableAsArray(xRowNum, 0)
If Len(BWordNormaliseText(xTableAsArray(xRowNum, i))) <> 0 Then
BWordIsBlankRow_TA = False
Exit Function
End If
Next
BWordIsBlankRow_TA = True
End Function
Public Sub BWordDocumentVariableSet(xDoc As Document, xName As String, xValue As Variant)
Call BWordDocumentVariableDelete(xDoc, xName)
xDoc.Variables.add name:=xName, value:=xValue
End Sub
Public Function BWordDocumentVariableGet(xDoc As Document, xName As String, Optional xDefault As Variant) As Variant
On Error GoTo BwordDocumentVariableGetError
BWordDocumentVariableGet = xDoc.Variables(xName)
Exit Function
BwordDocumentVariableGetError:
If IsMissing(xDefault) Then
BWordDocumentVariableGet = Null
Else
BWordDocumentVariableGet = xDefault
End If
End Function
Public Sub BWordDocumentVariableDelete(xDoc As Document, xName As String)
On Error Resume Next
xDoc.Variables(xName).Delete
End Sub
Public Function BWordCopyDocumentStyles(sourceDoc As Document, targetDoc As Document) As String
Dim s As Style
Dim ret As String
ret = ""
On Error GoTo setReturnFalse
For Each s In sourceDoc.Styles
If s.InUse Then
Application.OrganizerCopy source:=sourceDoc.fullName, Destination:=targetDoc.fullName, name:=s.NameLocal, Object:=wdOrganizerObjectStyles
End If
Next s
BWordCopyDocumentStyles = ret
Exit Function
setReturnFalse:
ret = "(last error " & Err.Number & " " & Err.Description & ")"
Resume Next
End Function
Function BWordStandardisePunctuation(iString As Variant) As String
Dim out As String
out = replace(iString, ChrW$(30), chrHyphen)
out = replace(out, ChrW$(31), chrHyphen)
out = replace(out, Chr(145), chrSingleQuote)
out = replace(out, Chr(146), chrSingleQuote)
out = replace(out, Chr(147), chrDoubleQuote)
out = replace(out, Chr(148), chrDoubleQuote)
out = replace(out, Chr(150), chrHyphen)
out = replace(out, Chr(151), chrHyphen)
out = replace(out, ChrW$(160), chrSpace)
BWordStandardisePunctuation = out
End Function
Public Sub BWordSetCellText(xCell As Cell, xTextDesired As Variant, Optional xOverwriteIfEmpty As Boolean = False)
If BWordGetCellText(xCell) <> xTextDesired Then
If Len(xTextDesired) = 0 Then
If xOverwriteIfEmpty Then
xCell.Range.text = xTextDesired
End If
Else
xCell.Range.text = xTextDesired
End If
End If
End Sub
Public Sub BWordSetStyleNormal(xRange As Range)
xRange.InsertParagraphAfter
xRange.Collapse wdCollapseEnd
xRange.Style = wdStyleNormal
End Sub
Public Function BWordDocumentIsOpen(ByVal fName As String, Optional fullPathGiven As Boolean = True, Optional ignoreCase As Boolean = False) As Boolean
Dim d As Document
Dim tempname As String
If ignoreCase Then fName = LCase$(fName)
For Each d In Documents
If fullPathGiven Then
tempname = d.fullName
Else
tempname = d.name
End If
If ignoreCase Then tempname = LCase$(tempname)
If tempname = fName Then
BWordDocumentIsOpen = True
Exit Function
End If
Next d
BWordDocumentIsOpen = False
End Function
Public Function BWordDocumentMightBeTemporary(ByVal xPath As String, ByVal xName As String) As Boolean
Dim shortname1 As String
Dim shortname2 As String
Dim tempFilePath As String
Dim out As Boolean
out = False
If Left$(xName, 1) = "~" Or LCase$(Right$(xName, 3)) = "tmp" Then
out = True
GoTo finish
End If
tempFilePath = Application.Options.DefaultFilePath(wdTempFilePath)
If LCase$(xPath) = LCase$(tempFilePath) Then
out = True
Else
shortname1 = BGetShortName(xPath)
If Len(shortname1) > 0 Then
shortname2 = BGetShortName(tempFilePath)
If LCase$(shortname1) = LCase$(shortname2) Then
out = True
End If
End If
End If
finish:
BWordDocumentMightBeTemporary = out
End Function
Public Sub BWordRemoveFrameFromTable(tabl As Variant)
Dim f As Frame
tabl.rows.WrapAroundText = False
For Each f In tabl.Parent.Frames
If BWithinTolerance(f.Range.Start, tabl.Range.Start, 5) Then
If BWithinTolerance(f.Range.End, tabl.Range.End, 5) Then
f.Delete
Exit For
End If
End If
Next f
End Sub
Public Function BWordTableHasNestedTable(xTable As table) As Boolean
BWordTableHasNestedTable = xTable.tables.count > 0
End Function
Public Function BWordTableNestedTables(xTable As Variant) As Variant
Dim out() As Range
Dim i As Long
Dim tableCount As Long
tableCount = xTable.tables.count
If tableCount > 0 Then
ReDim out(0 To tableCount - 1)
For i = 1 To tableCount
Set out(i - 1) = xTable.tables(i).Range
Next
BWordTableNestedTables = out
Else
BWordTableNestedTables = Empty
End If
End Function
Public Function BWordTableGetColumnWidths(xTable As table) As Variant
Dim i As Long
Dim out() As Long
ReDim out(1 To xTable.rows(1).Cells.count)
For i = 1 To xTable.rows(1).Cells.count
out(i) = xTable.rows(1).Cells(i).Width
Next i
BWordTableGetColumnWidths = out
End Function
Public Sub BWordTableSetColumnWidths(xTable As table, xWidths() As Long)
On Error Resume Next
Dim i As Long
xTable.Columns.DistributeWidth
For i = 1 To UBound(xWidths)
progressBar.Caption3 = c8PBProcessingColumn & i & " of " & UBound(xWidths)
xTable.Columns(i).SetWidth ColumnWidth:=xWidths(i), rulerstyle:=wdAdjustNone
Next i
progressBar.Caption3 = ""
End Sub
Public Function BWordTableToText(xTable As table) As Range
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
Call initialiseTableSubstitutionStrings
xTable.Range.Find.Execute findText:="^l", ReplaceWith:=strSub|fffd|l, replace:=wdReplaceAll
xTable.Range.Find.Execute findText:="^13", ReplaceWith:=strSub|fffd|p, replace:=wdReplaceAll
xTable.Range.Find.Execute findText:=vbFormFeed, ReplaceWith:=strSub|fffd|p, replace:=wdReplaceAll
xTable.Range.Find.Execute findText:="^14", ReplaceWith:=" ", replace:=wdReplaceAll
xTable.Range.ListFormat.RemoveNumbers
Set BWordTableToText = xTable.ConvertToText(separator:=BWordTableCellSeparator)
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Function
Public Function BWordTextToTable(xRange As Range, Optional xSetFormat As Boolean = True, Optional xSetStyleNormal As Boolean = True) As table
Dim t As table
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
Call initialiseTableSubstitutionStrings
Set t = xRange.ConvertToTable(separator:=BWordTableCellSeparator)
If xSetFormat Then
If wordVersion > Word2000 Then Call BWordTableSetStyle(t, "Table Grid")
Call setTableCharacteristics(t, xSetStyleNormal:=xSetStyleNormal)
Else
End If
t.Range.Find.Execute findText:=strSub|fffd|l, ReplaceWith:="^l", replace:=wdReplaceAll
t.Range.Find.Execute findText:=strSub|fffd|p, ReplaceWith:="^p", replace:=wdReplaceAll
Set BWordTextToTable = t
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Function
Public Sub BWordTableSetStyle(xTable As table, xStyle As String)
xTable.Style = xStyle
End Sub
Public Function BWordTableToArray(xTable As table, xDelete As Boolean, Optional xDeleteNotes As Boolean = True, Optional xLimitColumnsToFirstRowCount As Boolean = True, Optional xProgressBarIncrement As Double = 0) As Variant
Dim out() As String
Dim rowCells() As String
Dim rows() As String
Dim i As Long: Dim j As Long
Dim tableAsTextRange As Range
Dim performanceOptionsStore() As Variant
Dim maxCells As Long
Dim undoMarker As String
Dim parentDoc As Document
Dim zRange As Range
Dim rowCount As Long
Dim cellCount As Long
Dim expectedRowCount As Long
Dim expectedColumnCount As Long
Dim tableStart As Long
On Error GoTo tableToArrayError
progressBar.Caption3 = c8Name & c8PBWaitingPreProcessing
performanceOptionsStore = BWordPerformanceOptionsSet()
Call initialiseTableSubstitutionStrings
expectedRowCount = xTable.rows.count
expectedColumnCount = xTable.Columns.count
Set parentDoc = xTable.Parent
undoMarker = BWordUndo_SetMarker(parentDoc)
tableStart = xTable.Range.Start
If xDeleteNotes Then DeleteC8Endnotes xTable.Range
Set zRange = xTable.Range
zRange.Collapse wdCollapseEnd
zRange.InsertParagraphBefore
zRange.Style = wdStyleNormal
parentDoc.Bookmarks.add devbug02BookmarkName, zRange
Set tableAsTextRange = BWordTableToText(xTable)
rows = Split(tableAsTextRange.text, vbCr)
rowCount = UBound(rows)
ReDim out(0 To rowCount, 0 To expectedColumnCount)
out(0, 0) = tableStart
If rowCount = expectedRowCount Then
Else
Call showMessage(c8Msg3120, msgSuffix1:=vbNewLine & "Expected: " & expectedRowCount & " Found: " & rowCount, button3:="OK")
End If
If xLimitColumnsToFirstRowCount Then
maxCells = UBound(Split(rows(0), BWordTableCellSeparator)) + 1
Else
maxCells = 32767
End If
progressBar.CancelButtonEnable
For i = 0 To UBound(rows) - 1
With progressBar
.AddProgress xProgressBarIncrement
.Caption3 = c8PBProcessingRow & i + 1 & c8PBOf & rowCount
End With
If progressBar.userCancelled Then GoTo tableToArrayCancelled
rowCells = Split(rows(i), BWordTableCellSeparator)
cellCount = UBound(rowCells) + 1
out(i + 1, 0) = cellCount
For j = 0 To BMin(cellCount - 1, maxCells - 1)
out(i + 1, j + 1) = replace(replace(rowCells(j), strSub|fffd|l, vbLf), strSub|fffd|p, vbCr)
Next
For j = j To cellCount - 1
out(i + 1, maxCells) = out(i + 1, maxCells) & strSub|fffd|p & replace(replace(rowCells(j), strSub|fffd|l, vbLf), strSub|fffd|p, vbCr)
Next
Next
If xDelete Then
tableAsTextRange.Delete
BWordUndo_RemoveMarker undoMarker, parentDoc
Else
progressBar.CancelButtonEnable False
BWordUndo_ToMarker undoMarker, parentDoc, "BWordTableToArray"
progressBar.CancelButtonEnable
End If
ReDim Preserve out(0 To UBound(out, 1), 0 To maxCells)
BWordTableToArray = out
GoTo tableToArrayExit
tableToArrayError:
showMessage c8Msg6000, msgSuffix2:="BWordTableToArray: Error " & Err.Number & " (" & Err.Description & ")"
BWordTableToArray = BWordLogicError
GoTo tableToArrayUndoToMarker
tableToArrayCancelled:
BWordTableToArray = Empty
tableToArrayUndoToMarker:
BWordUndo_ToMarker undoMarker, parentDoc, "BWordTableToArray"
tableToArrayExit:
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
progressBar.Caption3 = ""
End Function
Public Function BWordTableToArrayError(xTableAsArray As Variant) As Boolean
If TypeName(xTableAsArray) = "String()" Then Exit Function
If IsEmpty(xTableAsArray) Then Exit Function
If xTableAsArray = BWordLogicError Then BWordTableToArrayError = True
End Function
Public Function BWordTableFromArray(xCellsArray As Variant, xDecorators() As Variant, xDocument As Document, Optional xRowCount As Long = 0, Optional xProcessColumnOne As Long = 0, Optional xSeqHeading As String = c8SequenceColumnHeadingDefault, Optional xWriteNumInFirstCell As Long = BWordTableWriteRowNumbers_None, Optional xEarliestIndex As Long = 1, Optional xProgressBarIncrement As Double = 0) As table
Dim i As Long: Dim j As Long
Dim tableAsTextRange As Range
Dim separator As String
Dim text As String
Dim cellRange As Range
Dim rowRange As Range
Dim performanceOptionsStore() As Variant
Dim zRange As Range
Dim rowSeq As Long
Dim lastCell2 As String
Dim incrementPhaseOne As Double
Dim incrementPhaseTwo As Double
Dim progressBarCaption3BasePhaseOne As String
Dim progressBarCaption3BasePhaseTwo As String
performanceOptionsStore = BWordPerformanceOptionsSet()
Call initialiseTableSubstitutionStrings
On Error GoTo tableFromArrayError
lastCell2 = ""
If xRowCount = 0 Then xRowCount = UBound(xCellsArray, 1)
If xProcessColumnOne = BWordTableDeleteColumnOne Then
For i = 1 To xRowCount
For j = 1 To xCellsArray(i, 0) - 1
xCellsArray(i, j) = xCellsArray(i, j + 1)
Next j
xCellsArray(i, 0) = xCellsArray(i, 0) - 1
Next i
ReDim Preserve xCellsArray(UBound(xCellsArray, 1), UBound(xCellsArray, 2) - 1)
End If
If xProcessColumnOne = BWordTableAddColumnOne Then
ReDim Preserve xCellsArray(UBound(xCellsArray, 1), UBound(xCellsArray, 2) + 1)
For i = 1 To xRowCount
For j = xCellsArray(i, 0) + 1 To 2 Step -1
xCellsArray(i, j) = xCellsArray(i, j - 1)
Next j
xCellsArray(i, 1) = ""
xCellsArray(i, 0) = xCellsArray(i, 0) + 1
Next i
xCellsArray(1, 1) = xSeqHeading
End If
If xWriteNumInFirstCell > BWordTableWriteRowNumbers_None Then
incrementPhaseOne = xProgressBarIncrement * (1 / 4)
incrementPhaseTwo = xProgressBarIncrement * (3 / 4)
progressBarCaption3BasePhaseOne = "Phase 1 of 2: processing row  "
progressBarCaption3BasePhaseTwo = "Phase 2 of 2: processing row  "
Else
incrementPhaseTwo = xProgressBarIncrement
progressBarCaption3BasePhaseTwo = "Processing row  "
End If
Set tableAsTextRange = xDocument.Range(xCellsArray(0, 0), xCellsArray(0, 0))
Set cellRange = xDocument.Range(xCellsArray(0, 0), xCellsArray(0, 0))
Set rowRange = xDocument.Range(xCellsArray(0, 0), xCellsArray(0, 0))
rowSeq = 0
If xWriteNumInFirstCell = BWordTableClearRowNumbers Then
For i = 2 To xRowCount
With progressBar
.AddProgress incrementPhaseOne
.Caption3 = progressBarCaption3BasePhaseOne & i & c8PBOf & xRowCount
End With
If progressBar.userCancelled Then GoTo userCancelled
If BWordIsBlankRow_TA(xCellsArray, i) Then GoTo nextRow0
xCellsArray(i, 1) = ""
nextRow0:
Next i
GoTo writeTableAsText
End If
If xWriteNumInFirstCell = BWordTableWriteRowNumbers_GroupByNoneAscending Then
rowSeq = xEarliestIndex
For i = 2 To xRowCount
With progressBar
.AddProgress incrementPhaseOne
.Caption3 = progressBarCaption3BasePhaseOne & i & c8PBOf & xRowCount
End With
If progressBar.userCancelled Then GoTo userCancelled
If BWordIsBlankRow_TA(xCellsArray, i) Then GoTo nextRow1
xCellsArray(i, 1) = rowSeq
rowSeq = rowSeq + 1
nextRow1:
Next i
GoTo writeTableAsText
End If
If xWriteNumInFirstCell = BWordTableWriteRowNumbers_GroupByNoneDescending Then
rowSeq = xEarliestIndex
For i = xRowCount To 2 Step -1
With progressBar
.AddProgress incrementPhaseOne
.Caption3 = progressBarCaption3BasePhaseOne & i & c8PBOf & xRowCount
End With
If progressBar.userCancelled Then GoTo userCancelled
If BWordIsBlankRow_TA(xCellsArray, i) Then GoTo nextRow2
xCellsArray(i, 1) = rowSeq
rowSeq = rowSeq + 1
nextRow2:
Next i
GoTo writeTableAsText
End If
If xWriteNumInFirstCell = BWordTableWriteRowNumbers_GroupByText Then
For i = 2 To xRowCount
With progressBar
.AddProgress incrementPhaseOne
.Caption3 = progressBarCaption3BasePhaseOne & i & c8PBOf & xRowCount
End With
If progressBar.userCancelled Then GoTo userCancelled
If BWordIsBlankRow_TA(xCellsArray, i) Then GoTo nextRow3
If xCellsArray(i, 3) = lastCell2 Then
rowSeq = rowSeq + 1
Else
lastCell2 = xCellsArray(i, 3)
rowSeq = 1
End If
xCellsArray(i, 1) = rowSeq
nextRow3:
Next i
GoTo writeTableAsText
End If
If xWriteNumInFirstCell = BWordTableWriteRowNumbers_GroupByDateAscending Then
For i = 2 To xRowCount
With progressBar
.AddProgress incrementPhaseOne
.Caption3 = progressBarCaption3BasePhaseOne & i & c8PBOf & xRowCount
End With
If progressBar.userCancelled Then GoTo userCancelled
If BWordIsBlankRow_TA(xCellsArray, i) Then GoTo nextRow4
If bdt.DateValueLoose(xCellsArray(i, 2)) = lastCell2 Then
rowSeq = rowSeq + 1
Else
lastCell2 = bdt.DateValueLoose(xCellsArray(i, 2))
rowSeq = 1
End If
xCellsArray(i, 1) = rowSeq
nextRow4:
Next i
GoTo writeTableAsText
End If
If xWriteNumInFirstCell = BWordTableWriteRowNumbers_GroupByDateDescending Then
For i = xRowCount To 2 Step -1
With progressBar
.AddProgress incrementPhaseOne
.Caption3 = progressBarCaption3BasePhaseOne & i & c8PBOf & xRowCount
End With
If progressBar.userCancelled Then GoTo userCancelled
If BWordIsBlankRow_TA(xCellsArray, i) Then GoTo nextRow5
If bdt.DateValueLoose(xCellsArray(i, 2)) = lastCell2 Then
rowSeq = rowSeq + 1
Else
lastCell2 = bdt.DateValueLoose(xCellsArray(i, 2))
rowSeq = 1
End If
xCellsArray(i, 1) = rowSeq
nextRow5:
Next i
GoTo writeTableAsText
End If
writeTableAsText:
For i = 1 To xRowCount
With progressBar
.AddProgress incrementPhaseTwo
.Caption3 = progressBarCaption3BasePhaseTwo & i & c8PBOf & xRowCount
End With
If progressBar.userCancelled Then GoTo userCancelled
rowRange.Start = tableAsTextRange.End
For j = 1 To UBound(xCellsArray, 2)
text = replace(replace(xCellsArray(i, j), vbLf, strSub|fffd|l), vbCr, strSub|fffd|p)
If j = UBound(xCellsArray, 2) Then
separator = vbCr
Else
separator = BWordTableCellSeparator
End If
cellRange.Start = tableAsTextRange.End
tableAsTextRange.InsertAfter text:=text & separator
cellRange.End = tableAsTextRange.End - 1
If xProcessColumnOne > 0 Then GoTo nextCell
If Len(xDecorators(i, j, 0)) <> 0 Then cellRange.Shading.BackgroundPatternColor = xDecorators(i, j, 0)
If Len(xDecorators(i, j, 1)) <> 0 Then
cellRange.Collapse wdCollapseStart
xDocument.Endnotes.add Range:=cellRange, Reference:=xDecorators(i, j, 1), text:=xDecorators(i, j, 2)
End If
nextCell:
Next
rowRange.End = tableAsTextRange.End - 1
If Len(xDecorators(i, 0, 0)) <> 0 Then
rowRange.Shading.BackgroundPatternColor = xDecorators(i, 0, 0)
End If
Next
With progressBar
.Caption3 = c8Name & c8PBWaitingPostProcessing
.CancelButtonEnable False
End With
Set BWordTableFromArray = BWordTextToTable(tableAsTextRange)
With BWordTableFromArray.Range.Find
.Style = xDocument.Styles("Endnote Reference")
.Replacement.Style = .Style
.Wrap = wdFindStop
.format = True
.Execute replace:=wdReplaceAll
End With
xDocument.Range(BWordTableFromArray.Range.End, BWordTableFromArray.Range.End).Shading.BackgroundPatternColor = wdColorAutomatic
If BWordBookmarkExists(devbug02BookmarkName, xDocument) Then
Set zRange = xDocument.Bookmarks(devbug02BookmarkName).Range
zRange.Start = BWordTableFromArray.Range.End
zRange.Delete
xDocument.Bookmarks(devbug02BookmarkName).Delete
End If
GoTo tableFromArrayExit
tableFromArrayError:
showMessage c8Msg6000, msgSuffix2:="BWordTableFromArray: Error " & Err.Number & " (" & Err.Description & ")"""
userCancelled:
Set BWordTableFromArray = Nothing
tableFromArrayExit:
progressBar.Caption3 = ""
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Function
Public Sub BWordSessionParameterSet(xOption As String)
SaveSetting appname:=c8Name, Section:=c8RegistrySession, key:=xOption, setting:="True"
End Sub
Public Function BWordSessionParameterIsSet(xOption As String) As Boolean
BWordSessionParameterIsSet = (GetSetting(appname:=c8Name, Section:=c8RegistrySession, key:=xOption) = "True")
End Function
Public Sub BWordSessionParameterDelete(xOption As String)
If GetSetting(appname:=c8Name, Section:=c8RegistrySession, key:=xOption) = "" Then Exit Sub
DeleteSetting appname:=c8Name, Section:=c8RegistrySession, key:=xOption
End Sub
Public Function BWordCreateDocFromArray(xData As Variant, Optional xProgressBarIncrement As Double = 0) As Document
Dim i As Long
Dim rep As Document
Dim activeDoc As Document
Dim preferredView As WdViewType
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
Set activeDoc = ActiveDocument
Set rep = Documents.add
rep.Content.text = ""
activeDoc.activate
preferredView = ThisDocument.ActiveWindow.View.Type
rep.ActiveWindow.View.Type = wdNormalView
rep.ActiveWindow.Visible = False
If progressBar Is Nothing Then
Else
progressBar.CancelButtonEnable
End If
Dim currentRange As Range
Set currentRange = rep.Range
For i = 0 To UBound(xData)
If progressBar Is Nothing Then
Else
With progressBar
.AddProgress xProgressBarIncrement
.Caption3 = c8PBProcessingLine & i + 1 & c8PBOf & UBound(xData) + 1
End With
If progressBar.userCancelled Then GoTo createDocCancelled
End If
Select Case Left$(xData(i), 2)
Case "xx"
currentRange.Style = wdStyleNormal
Case "H0"
With rep.Sections(1)
.Footers(wdHeaderFooterPrimary).PageNumbers.add
.Headers(wdHeaderFooterPrimary).Range.text = Mid$(xData(i), 3)
.Headers(wdHeaderFooterPrimary).Range.Bold = True
.Headers(wdHeaderFooterPrimary).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
End With
GoTo nextI
Case "H1"
currentRange.Style = wdStyleHeading1
Case "H2"
currentRange.Style = wdStyleHeading2
Case "H3"
currentRange.Style = wdStyleHeading3
Case Else
showMessage c8Msg6000, msgSuffix2:="BWordCreateDocFromArray: invalid control characters in line " & xData(i)
End Select
currentRange.InsertAfter Mid$(xData(i), 3)
currentRange.InsertParagraphAfter
currentRange.Collapse direction:=wdCollapseEnd
nextI:
Next i
GoTo docCreated
createDocCancelled:
Set BWordCreateDocFromArray = Nothing
rep.Saved = True
rep.Close
GoTo finish
docCreated:
If progressBar Is Nothing Then
Else
progressBar.Caption3 = c8PBFinishedWritingDoc
End If
rep.ActiveWindow.View.Type = preferredView
rep.ActiveWindow.Visible = True
rep.activate
Set BWordCreateDocFromArray = rep
finish:
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Function
Public Function BWordToolbarExists(xName As String, xDoc As Document) As Boolean
Dim out As Boolean
Dim tb As CommandBar
out = False
xDoc.activate
For Each tb In ActiveDocument.CommandBars
If tb.name = xName Then
out = True
Exit For
End If
Next tb
ThisDocument.activate
BWordToolbarExists = out
End Function
Public Function BWordTableGetVerticallyMergedCells(xTable As Variant) As Variant
Dim xCell As Cell
Dim out() As String
Dim cellCount As Long
Dim R As Range
cellCount = 0
Set R = Selection.Range
ReDim out(1 To xTable.Range.Cells.count)
For Each xCell In xTable.Range.Cells
If BWordTableCellIsVerticallyMerged(xCell) Then
cellCount = cellCount + 1
out(cellCount) = xCell.rowIndex & "," & xCell.columnIndex
End If
Next xCell
If cellCount > 0 Then ReDim Preserve out(1 To cellCount)
BWordTableGetVerticallyMergedCells = out
R.Select
End Function
Public Function BWordTableCellIsVerticallyMerged(xCell As Cell) As Boolean
Dim rowSpan As Long
xCell.Select
rowSpan = Selection.Information(wdEndOfRangeRowNumber) - Selection.Information(wdStartOfRangeRowNumber) + 1
If rowSpan > 1 Then
BWordTableCellIsVerticallyMerged = True
Else
BWordTableCellIsVerticallyMerged = False
End If
End Function
Public Function BWordTableHasVerticallyMergedCells(xTable As Variant) As Boolean
Dim zRow As row
BWordTableHasVerticallyMergedCells = False
On Error GoTo verticallyMergedCells
Set zRow = xTable.rows(1)
Exit Function
verticallyMergedCells:
If Err.Number = 5991 Then
BWordTableHasVerticallyMergedCells = True
Else
showMessage c8Msg6000, msgSuffix2:="BWordTableHasVerticallyMergedCells: Error " & Err.Number & " (" & Err.Description & ")"
End If
End Function
Public Function BWordTableRowCount(xTable As Variant) As Long
BWordTableRowCount = xTable.Range.Information(wdEndOfRangeRowNumber)
End Function
Public Function BWordTableAutoFitBehaviour(xTable As table) As WdAutoFitBehavior
If xTable.AllowAutoFit Then
If xTable.PreferredWidth = 0 Then
BWordTableAutoFitBehaviour = wdAutoFitContent
Else
BWordTableAutoFitBehaviour = wdAutoFitWindow
End If
Else
BWordTableAutoFitBehaviour = wdAutoFitFixed
End If
End Function
Private Sub initialiseTableSubstitutionStrings()
strSub|fffd|l = Chr(143)
strSub|fffd|p = Chr(144)
BWordTableCellSeparator = Chr(157)
End Sub
Public Function BWordPerformanceOptionsSet() As Variant
Dim out(0 To performanceOptionsUbound) As Variant
Dim saveStatus As Boolean
Dim activeDoc As Document
BWordPerformanceOptionsSetCount = BWordPerformanceOptionsSetCount + 1
If BWordPerformanceOptionsSetCount > 1 Then
BWordPerformanceOptionsSet = out
Exit Function
End If
saveStatus = ThisDocument.Saved
Set activeDoc = ActiveDocument
ThisDocument.activate
With Options
out(0) = .CheckSpellingAsYouType
out(1) = .CheckGrammarAsYouType
out(2) = .Pagination
out(3) = thisDocNavigator.positionSave
End With
out(4) = Application.CheckLanguage
If wordVersion >= Word2010 Then
On Error Resume Next
out(5) = CommandBars("Navigation").Visible
On Error GoTo 0
End If
With Options
.CheckSpellingAsYouType = False
.CheckGrammarAsYouType = False
.Pagination = False
End With
Application.CheckLanguage = False
If wordVersion >= Word2010 Then
On Error Resume Next
CommandBars("Navigation").Visible = False
On Error GoTo 0
End If
If Selection Is Nothing Then
Else
Selection.HomeKey Unit:=wdStory
End If
BWordPerformanceOptionsSet = out
ThisDocument.Saved = saveStatus
activeDoc.activate
End Function
Public Sub BWordPerformanceOptionsRestore(performanceOptionsStore() As Variant, Optional xRestorePosition As Boolean = True)
Dim saveStatus As Boolean
Dim activeDoc As Document
BWordPerformanceOptionsSetCount = BWordPerformanceOptionsSetCount - 1
If BWordPerformanceOptionsSetCount > 0 Then Exit Sub
saveStatus = ThisDocument.Saved
Set activeDoc = ActiveDocument
ThisDocument.activate
With Options
.CheckSpellingAsYouType = performanceOptionsStore(0)
.CheckGrammarAsYouType = performanceOptionsStore(1)
.Pagination = performanceOptionsStore(2)
End With
Application.CheckLanguage = performanceOptionsStore(4)
If wordVersion >= Word2010 Then
On Error Resume Next
CommandBars("Navigation").Visible = performanceOptionsStore(5)
On Error GoTo 0
End If
If xRestorePosition Then thisDocNavigator.positionRestore CStr(performanceOptionsStore(3))
ThisDocument.Saved = saveStatus
activeDoc.activate
End Sub
Function BWordTableContainsLists(xTable As Variant) As Boolean
Dim zList As List
Dim out As Boolean
out = False
For Each zList In xTable.Parent.Lists
If zList.Range.Start > xTable.Range.Start And zList.Range.Start < xTable.Range.End Or zList.Range.End > xTable.Range.Start And zList.Range.End < xTable.Range.End Then
out = True
Exit For
End If
Next zList
BWordTableContainsLists = out
End Function
Public Function BWordUndo_SetMarker(xDoc As Document) As String
Dim bookmarkName As String
Dim bookmarkSuffix As Long
bookmarkSuffix = 1
While BWordBookmarkExists(undoBookmarkPrefix & bookmarkSuffix, xDoc)
bookmarkSuffix = bookmarkSuffix + 1
Wend
bookmarkName = undoBookmarkPrefix & bookmarkSuffix
xDoc.Bookmarks.add bookmarkName, xDoc.Range
BWordUndo_SetMarker = bookmarkName
End Function
Public Function BWordUndo_ToMarker(bookmarkName As String, xDoc As Document, callingProc As String) As Long
Dim saveScreenUpdating As Boolean
Dim performanceOptionsStore() As Variant
Dim undoCount As Long
saveScreenUpdating = Application.screenUpdating
Application.screenUpdating = False
performanceOptionsStore = BWordPerformanceOptionsSet()
undoCount = 0
While BWordBookmarkExists(bookmarkName, xDoc)
undoCount = undoCount + 1
If xDoc.Undo = False Then GoTo finish
Wend
finish:
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
Application.screenUpdating = saveScreenUpdating
BWordUndo_ToMarker = undoCount
If undoCount = 0 Then
showMessage c8Msg6000, msgSuffix2:=callingProc & ":UndoToMarker failed to Undo anything"
End If
End Function
Public Sub BWordUndo_RemoveMarker(bookmarkName As String, xDoc As Document)
On Error Resume Next
xDoc.Bookmarks(bookmarkName).Delete
End Sub
Public Sub BWordUndo_RemoveAllMarkers(xDoc As Document)
Dim bkm As Bookmark
For Each bkm In xDoc.Bookmarks
If Left$(bkm.name, Len(undoBookmarkPrefix)) = undoBookmarkPrefix Then
bkm.Delete
xDoc.UndoClear
End If
Next bkm
End Sub
Public Function BWordBookmarkExists(xName As String, xDoc As Document) As Boolean
On Error Resume Next
BWordBookmarkExists = Len(xDoc.Bookmarks(xName).name) > -1
On Error GoTo 0
End Function
Public Sub BWordDeleteEndnotes(xRange As Range)
With xRange.Find
.Style = xRange.Parent.Styles("Endnote Reference")
.text = "*"
.Replacement.text = ""
.Forward = True
.Wrap = wdFindStop
.format = True
.MatchCase = False
.MatchWholeWord = False
.MatchAllWordForms = False
.MatchSoundsLike = False
.matchWildcards = True
.Execute replace:=wdReplaceAll
End With
End Sub
Public Function BWordRangeIsInTable(xRange As Range, xDoc As Document) As Boolean
BWordRangeIsInTable = BWordRangeTableIndex(xRange, xDoc) > 0
End Function
Public Function BWordRangeTableIndex(xRange As Range, xDoc As Document) As Long
Dim i As Long
For i = 1 To xDoc.tables.count
If xRange.InRange(xDoc.tables(i).Range) Then
BWordRangeTableIndex = i
Exit Function
End If
Next i
End Function
Public Function BWordLanguageDisplay(xLang As WdLanguageID) As String
Dim out As String
out = CStr(xLang)
On Error GoTo notFound
out = out & " " & chrHyphen & " " & Languages(xLang).name
GoTo finish
notFound:
out = out & " " & chrHyphen & " name unknown"
finish:
BWordLanguageDisplay = out
End Function
Sub BWordSqueezeParagraphMarks(xDoc As Document)
With xDoc
With .Content.Find
.text = "[^13]{2,}"
.Replacement.text = "^p"
.matchWildcards = True
.Execute replace:=wdReplaceAll
End With
.Characters.Last.Delete
End With
End Sub
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "1Normal.ThisDocument"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
' This module and these procedures are Copyright |fffd| 2004-2016 Berrick Computing Ltd www.berrick-computing.co.uk
'
' Update references:  <Version 3.4>
'$ PROBHIDE NOT_INSTANTIATED IN_THIS_FILE
'$ PROBHIDE RETVAL_DISCARDED IN_THIS_FILE
'$ PROBHIDE DEAD_PROC IN_THIS_FILE
Option Explicit
Sub FileSave()
    Dim msgsuf As String
    If BWordDocumentMightBeTemporary(ThisDocument.path, ThisDocument.name) Then
        msgsuf = vbNewLine & vbNewLine & "Filename: " & ThisDocument.name
        Call showMessage(c8Msg5323, msgSuffix1:=msgsuf, button3:="OK")
        c8FileSaveAs ThisDocument, fileSavedAsFullName
    Else
        If ThisDocument.ReadOnly Then Call MsgBox(c8ReadOnly)
        On Error GoTo saveFailed
        ThisDocument.Save
        On Error GoTo 0
    End If
    Exit Sub
    
saveFailed:
    Select Case Err.Number
        Case 5487  ' Permission error- maybe Bug92
            Call bug92Fix(ThisDocument)
            Resume Next
        Case 5155  ' Read only - have warned user already
        Case Else
            showMessage c8Msg6000, msgSuffix2:="FileSave: Error " & Err.Number & " (" & Err.Description & ")"
    End Select
End Sub



Attribute VB_Name = "c8MC_Abbreviations"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Dim tableCount As Long
Dim matchesRowNumberStartSearch As Long
Dim stopWatch01 As clsStopWatch
Const matchDelimiter As String = "/"
Public Enum matchMode
anonymise = 1
personalise = 2
reviewAnonymisations = 3
reviewAbbreviation = 4
End Enum
Public Sub AnonymiseCurrentMatch(biu As Boolean)
Dim f As clsFormat
If biu Then
Set f = formatAbbreviations
Else
Set f = formatStyleNormal
End If
thisDocFinder.matchReplace thisDocFinder.currentMatchIndex, thisDocFinder.currentMatchData01, f, True
formatMatchesCurrentDefault.setFormat thisDocFinder.currentMatchRange, ThisDocument
Application.ScreenRefresh
End Sub
Public Function PersonaliseCurrentMatch()
thisDocFinder.matchReplace thisDocFinder.currentMatchIndex, thisDocFinder.currentMatchData02, formatStyleNormal, False
formatMatchesCurrentDefault.setFormat thisDocFinder.currentMatchRange, ThisDocument
Application.ScreenRefresh
End Function
Public Sub ChangeCandidates(xMode As matchMode)
Dim zText As String
Dim docSave As String
Dim saveStatus As Boolean
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
saveStatus = ThisDocument.Saved
Set stopWatch01 = New clsStopWatch
stopWatch01.Start
docSave = thisDocSaver.documentSave(ThisDocument)
If ppA_BIUParmGet Then
zText = " with the specified formatting."
Else
zText = "."
End If
Application.screenUpdating = False
Select Case ProcessAbbreviations(xMode)
Case Is > 0
GoTo changeEnd
Case -1
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
If xMode = anonymise Then
showMessage c8Msg7032, msgPrefix2:="The selected definition is"
Else
showMessage c8Msg7033, msgPrefix2:="The selected abbreviation is not used in the text" & zText
End If
Case -2
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
If xMode = anonymise Then
showMessage c8Msg7032, msgPrefix2:="The selected definitions are"
Else
showMessage c8Msg7033, msgPrefix2:="The selected abbreviations are not used in the text" & zText
End If
Case Else
End Select
changeEnd:
Call thisDocSaver.closeSingle(docSave)
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
Application.screenUpdating = True
Application.ScreenRefresh
End Sub
Public Function ProcessAbbreviations(xMode As matchMode, Optional xTerm As String, Optional xDefinition As String, Optional xPrefix As String, Optional xRowCheckPositive As Boolean, Optional xHighlightMatches As Boolean = False) As Long
Dim pbWeightingPhase1 As Double
Dim pbWeightingPhase2 As Double
Dim pbWeightingPhase3 As Double
Dim pbWeightingPhase4 As Double
Dim pbWeightingPhase5 As Double
Dim pbRemaining As Double
Dim candidates As Variant
Dim i As Long
Dim j As Long
Dim t As table
Dim term As String
Dim definition As String
Dim ignoreColumn As Long
Dim tablesfound As Variant
Dim normaliseSourceRequired As Boolean
Dim matchCount As Long
Dim tablesAsText() As Range
Dim tableRange As Range
Dim termFormat As clsFormat
Dim progressBarIncrement As Double
Dim statsType As String
Dim statsCount1 As String
Dim statsCount2 As String
Dim convertTables As Boolean
Dim performanceOptionsStore() As Variant
Dim sourceFragments() As String
Dim docSave As String
Dim saveStatus As Boolean
Dim restorePosition As Boolean
performanceOptionsStore = BWordPerformanceOptionsSet()
saveStatus = ThisDocument.Saved
ignoreColumn = 0
restorePosition = False
Set stopWatch01 = New clsStopWatch
stopWatch01.Start
Application.screenUpdating = False
thisDocFinder.matchesClear
convertTables = False
pbWeightingPhase2 = 0
pbWeightingPhase3 = 0
pbWeightingPhase4 = 0
pbWeightingPhase5 = 0
pbWeightingPhase1 = 0.1
pbRemaining = 0.9
progressBar.Reset
Select Case xMode
Case anonymise
progressBar.title = "Anonymise document"
statsType = ppStats_Anonymise
Case personalise
progressBar.title = "Personalise document"
statsType = ppStats_Personalise
Case reviewAnonymisations
progressBar.title = "Review Abbreviations"
statsType = ppStats_AbbreviationReview
Case reviewAbbreviation
progressBar.title = "Review Abbreviation"
statsType = ppStats_AbbreviationReview
End Select
If xMode = matchMode.reviewAbbreviation Then
ReDim candidates(0)
Else
candidates = ppA_Candidates
If IsEmpty(candidates) Then GoTo finish03
If ppA_GlossaryColumnUpdateGet Then
ignoreColumn = 0
Else
ignoreColumn = thisDocDescriptor.columnGlossary
End If
End If
With progressBar
.Caption1 = c8PBAnalysingTables
.show
.CancelButtonEnable False
End With
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015, msgSuffix1:=" " & ThisDocument.name)
GoTo finish03
Else
tableCount = UBound(tablesfound) + 1
ReDim tablesAsText(UBound(tablesfound))
Call setProgressBarCounters(ThisDocument, tablesfound)
End If
If pbRowsToCheck = 0 Then
matchCount = 0
GoTo tableSearchEnd
End If
matchCount = 0
docSave = thisDocSaver.documentSave(ThisDocument)
progressBar.Caption2 = c8PBCheckingSPN
normaliseSourceRequired = (thisDocSourcePrefixes.count > 0) And (thisDocDescriptor.tablesHash2 <> tablesHash(tablesfound, ThisDocument, thisDocDescriptor.columnSource))
convertTables = (xMode < reviewAnonymisations) And (ignoreColumn = 0)
progressBar.Progress = pbWeightingPhase1
If normaliseSourceRequired Then pbWeightingPhase2 = 0.3 * pbRemaining
pbRemaining = pbRemaining - pbWeightingPhase2
If convertTables Then pbWeightingPhase3 = 0.3 * pbRemaining
pbRemaining = pbRemaining - pbWeightingPhase3
pbWeightingPhase4 = 0.6 * pbRemaining
pbWeightingPhase5 = 0.4 * pbRemaining
stopWatch01.Halt
If normaliseSourceRequired Then
If thisDocSourcePrefixes.count > 0 Then
sourceFragments = GetSourceFragments
If sourcePrefixNormalise(tablesfound, sourceFragments, thisDocDescriptor.columnSource, xAddProgress:=pbWeightingPhase2 / pbRowsToCheck) = "" Then
Call thisDocSaver.closeSingle(docSave)
docSave = thisDocSaver.documentSave(ThisDocument)
frmAbbreviationsReview.setRecoveryDoc ThisDocument.name, ThisDocument.Saved
Else
progressBar.userCancelled = True
End If
End If
End If
stopWatch01.Start
If progressBar.userCancelled Then GoTo ProcessAbbreviationsCancelled
progressBar.Progress = pbWeightingPhase1 + pbWeightingPhase2
System.Cursor = wdCursorWait
thisDocFinder.matchesClear
If ppA_BIUParmGet Then
Set termFormat = formatAbbreviations
Else
Set termFormat = New clsFormat
End If
If xMode < reviewAnonymisations Then
If convertTables Then
listFound = False
For i = tableCount - 1 To 0 Step -1
With progressBar
.Caption2 = c8PBPreparingTable & i + 1 & c8PBOf & tableCount & " for processing"
.CancelButtonEnable False
End With
Set t = ThisDocument.Content.tables(tablesfound(i))
If CheckForListsInTable(xTable:=t) Then listFound = True
Set tablesAsText(i) = BWordTableToText(t)
Next i
End If
End If
progressBar.Progress = pbWeightingPhase1 + pbWeightingPhase2 + pbWeightingPhase3
With progressBar
.CancelButtonEnable
.Caption2 = ""
End With
For i = 0 To tableCount - 1
With progressBar
.Caption1 = c8PBLookingInTable & i + 1 & c8PBOf & tableCount
.Caption2 = ""
.Caption3 = ""
If .userCancelled Then GoTo ProcessAbbreviationsCancelled
End With
If convertTables Then
Set tableRange = tablesAsText(i)
Else
Set tableRange = ThisDocument.Content.tables(tablesfound(i)).Range
End If
If xMode = matchMode.reviewAbbreviation Then
progressBarIncrement = (pbWeightingPhase4 / tableCount) / 3
matchCount = BLng(thisDocFinder.matchesIdentify(xTerm, xRowCheckString:=xPrefix, xRowCheckPositive:=xRowCheckPositive, xRowCheckColNum:=thisDocDescriptor.columnSource, xClear:=False, xMatchCase:=True, xRange:=tableRange, xData01:=xTerm, xData02:=xDefinition, xData03:=True, xSortMatches:=False))
With progressBar
If .userCancelled Then GoTo ProcessAbbreviationsCancelled
.AddProgress progressBarIncrement
End With
matchCount = BLng(thisDocFinder.matchesIdentify(xDefinition, xRowCheckString:=xPrefix, xRowCheckPositive:=xRowCheckPositive, xRowCheckColNum:=thisDocDescriptor.columnSource, xClear:=False, xRange:=tableRange, xData01:=xTerm, xData02:=xDefinition, xData03:=False, xSortMatches:=True))
With progressBar
If .userCancelled Then GoTo ProcessAbbreviationsCancelled
.AddProgress progressBarIncrement
End With
GoTo nextTable
End If
progressBarIncrement = (pbWeightingPhase4 / tableCount) / (UBound(candidates) + 1)
If xMode = matchMode.reviewAnonymisations Then progressBarIncrement = progressBarIncrement / 2
For j = 0 To UBound(candidates)
term = candidates(j, 0)
definition = candidates(j, 1)
With progressBar
If .userCancelled Then GoTo ProcessAbbreviationsCancelled
End With
If xMode = matchMode.personalise Or xMode = matchMode.reviewAnonymisations Then
matchCount = BLng(thisDocFinder.matchesIdentify(term, xRange:=tableRange, xMatchCase:=True, xFormat:=termFormat, xData01:=term, xData02:=definition, xData03:=True, xIgnoreColumn:=ignoreColumn, xClear:=False, xSortMatches:=False))
End If
If xMode = matchMode.reviewAnonymisations Then progressBar.AddProgress progressBarIncrement
If xMode = matchMode.anonymise Or xMode = matchMode.reviewAnonymisations Then
matchCount = BLng(thisDocFinder.matchesIdentify(definition, xRange:=tableRange, xMatchCase:=False, xFormat:=New clsFormat, xData01:=term, xData02:=definition, xData03:=False, xIgnoreColumn:=ignoreColumn, xClear:=False, xSortMatches:=False))
End If
With progressBar
If .userCancelled Then GoTo ProcessAbbreviationsCancelled
.AddProgress progressBarIncrement
End With
Next j
If progressBar.userCancelled Then
GoTo ProcessAbbreviationsCancelled
End If
progressBar.AddProgress 0.05
thisDocFinder.matchesSort
nextTable:
Next i
tableSearchEnd:
If matchCount = 0 Then
If UBound(candidates) = 0 Then
matchCount = -1
Else
matchCount = -2
End If
statsCount2 = "0"
GoTo finish01
Else
statsCount2 = CStr(matchCount)
End If
progressBar.Progress = pbWeightingPhase1 + pbWeightingPhase2 + pbWeightingPhase3 + pbWeightingPhase4
If xMode < reviewAnonymisations Then
If convertTables Then
progressBarIncrement = (pbWeightingPhase5 / 2) / tableCount
Else
progressBarIncrement = pbWeightingPhase5
End If
With progressBar
If .userCancelled Then GoTo ProcessAbbreviationsCancelled
.CancelButtonEnable False
.Caption1 = c8PBReplacingText
.Caption2 = ""
End With
Select Case xMode
Case matchMode.anonymise
thisDocFinder.matchesReplaceAllWithDataField xDataField:=1, outFormat:=termFormat
Case matchMode.personalise
thisDocFinder.matchesReplaceAllWithDataField xDataField:=2, outFormat:=formatStyleNormal
Case Else
End Select
progressBar.AddProgress progressBarIncrement * tableCount
If convertTables Then
For i = 0 To tableCount - 1
With progressBar
.Caption1 = c8PBFormattingTable & i + 1 & c8PBOf & tableCount
.Caption2 = c8Name & c8PBWaitingProcessing
End With
Call setTableCharacteristics(BWordTextToTable(tablesAsText(i), xSetStyleNormal:=False), xSetStyleNormal:=False)
progressBar.AddProgress progressBarIncrement
Next i
If listFound Then showMessage msg:=c8Msg3200
End If
End If
finish01:
If xHighlightMatches Then
With progressBar
.Caption1 = c8PBHighlightingAbbreviations
End With
thisDocFinder.matchesformat xFormat:=formatMatchesInBodyDefault, xAddProgress:=pbWeightingPhase5 / matchCount
If progressBar.userCancelled Then GoTo ProcessAbbreviationsCancelled
thisDocFinder.goToFirstMatch
restorePosition = False
Else
restorePosition = True
End If
If ignoreColumn = 0 Then
statsCount2 = "*" & statsCount2
End If
GoTo finish02
ProcessAbbreviationsCancelled:
matchCount = -3
statsCount2 = "cncl"
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
Application.screenUpdating = True
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
progressBar.finish
showMessage c8Msg3020
finish02:
Call thisDocSaver.closeSingle(docSave)
ProcessAbbreviations = matchCount
progressBar.finish
statsCount1 = CStr(UBound(candidates) + 1)
System.Cursor = wdCursorNormal
ppStats_Update statsType, pbTablesToCheck, pbRowsToCheck, stopWatch01.value, xField1:=statsCount1, xField2:=statsCount2
finish03:
Call BWordPerformanceOptionsRestore(performanceOptionsStore, xRestorePosition:=restorePosition)
End Function
Function MatchesReport() As Document
Dim reportDoc As Document
Dim zDoc As Document
Dim zTable As table
Dim zTableIndex As Long
Dim zRange As Range
Dim zString1 As String
Dim zString2 As String
Dim summaryRange As Range
Dim mainTableRange As Range
Dim searchStrings As Variant
Dim tablesForReport() As Long
Dim rowsForReport() As Long
Dim tableAsArray As Variant
Dim tableCopyAsArray() As String
Dim decorators() As Variant
Dim i As Long
Dim j As Long
Dim rowNumOriginal As Long
Dim rowNumInCopy As Long
Dim colNum As Long
Dim progressMatchedRowCount As Long
Dim progressWeighting As Double
Dim progressBarIncrement As Double
Dim searchStringCount As Long
Dim statsCount2 As String
Dim highlightIndex As Long
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
Set stopWatch01 = New clsStopWatch
stopWatch01.Start
Dim fr As clsFindReplace
Dim fmt As clsFormat
With progressBar
.Reset
.title = "Abbreviations Report"
.Caption1 = c8PBCreatingNewDocument
.show
.AddProgress 0.01
.CancelButtonEnable False
End With
Application.screenUpdating = False
Set zDoc = ActiveDocument
Set reportDoc = Documents.add
reportDoc.Content.text = ""
reportDoc.Windows(1).Visible = False
zDoc.activate
reportDoc.PageSetup.Orientation = wdOrientLandscape
With reportDoc.Sections(1)
.Footers(wdHeaderFooterPrimary).PageNumbers.add
.Headers(wdHeaderFooterPrimary).Range.text = "Summary of selected abbreviations in " & ThisDocument.fullName
.Headers(wdHeaderFooterPrimary).Range.Bold = True
.Headers(wdHeaderFooterPrimary).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
End With
Set zRange = reportDoc.Range
zRange.Collapse wdCollapseEnd
Set summaryRange = reportDoc.Range
summaryRange.Start = zRange.Start
searchStrings = thisDocFinder.matchesSearchStringsConsolidated
searchStringCount = UBound(searchStrings) + 1
For i = 0 To searchStringCount - 1 Step 2
zRange.InsertAfter searchStrings(i, 0)
zRange.Collapse wdCollapseEnd
zRange.InsertAfter vbTab & "(" & BPluralityText(CLng(searchStrings(i, 1)), "occurrence") & ")"
zRange.InsertAfter vbTab & searchStrings(i + 1, 0)
zRange.InsertAfter vbTab & "(" & BPluralityText(CLng(searchStrings(i + 1, 1)), "occurrence") & ")"
zRange.InsertParagraphAfter
formatStyleNormal.setFormat zRange, reportDoc
zRange.Collapse wdCollapseEnd
Next
summaryRange.End = zRange.End
summaryRange.ConvertToTable vbTab
With summaryRange.tables(1)
.AutoFitBehavior wdAutoFitContent
End With
summaryRange.Collapse wdCollapseEnd
summaryRange.InsertParagraphAfter
summaryRange.InsertAfter "*** The counts above are subject to technical limitations which mean they might not exactly match " & "the table below. Please refer to the 'Using Chronolator Documents' manual for more information."
Call TableWrite(xDoc:=reportDoc, xDetails:=thisDocDescriptor, xHeadersOnly:=True, xAddSection:=False)
Set fr = New clsFindReplace
fr.doc = reportDoc
tablesForReport = tablesToCopy()
matchesRowNumberStartSearch = 0
progressMatchedRowCount = UBound(thisDocFinder.matchesRowNumbers) + 1
Call setProgressBarCounters(ThisDocument, GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor)))
progressWeighting = 0.69
For zTableIndex = 0 To UBound(tablesForReport)
With progressBar
.Caption1 = c8PBProcessingTable & zTableIndex + 1 & c8PBOf & UBound(tablesForReport) + 1
.Caption2 = c8PBPreparingTable & "for processing"
.CancelButtonEnable False
End With
rowNumInCopy = 0
rowsForReport = rowsToCopy(tablesForReport(zTableIndex))
Set zTable = ThisDocument.tables(tablesForReport(zTableIndex))
progressBarIncrement = 0.3 * progressWeighting / pbRowsToCheck
tableAsArray = BWordTableToArray(xTable:=zTable, xDelete:=False, xProgressBarIncrement:=progressBarIncrement)
If BWordTableToArrayError(tableAsArray) Then
progressBar.userCancelled = True
End If
If progressBar.userCancelled Then GoTo reportCancelled
ReDim tableCopyAsArray(0 To UBound(rowsForReport) + 1, 0 To tableAsArray(1, 0))
ReDim decorators(0 To UBound(rowsForReport) + 1, 0 To tableAsArray(1, 0), 2)
progressBarIncrement = 0.2 * progressWeighting / progressMatchedRowCount
tableCopyAsArray(0, 0) = reportDoc.Content.End - 1
For j = 0 To UBound(rowsForReport)
With progressBar
.AddProgress progressBarIncrement
.Caption2 = c8PBWritingEvent & j + 1 & c8PBOf & UBound(rowsForReport) + 1 & " to internal array"
If .userCancelled Then GoTo reportCancelled
End With
rowNumOriginal = rowsForReport(j)
rowNumInCopy = rowNumInCopy + 1
For colNum = 1 To tableAsArray(rowNumOriginal, 0)
tableCopyAsArray(rowNumInCopy, colNum) = tableAsArray(rowNumOriginal, colNum)
Next colNum
If progressBar.userCancelled Then GoTo reportCancelled
Next j
With progressBar
.Caption2 = c8PBConvertingArrayToTable
End With
progressBarIncrement = 0.5 * progressWeighting / progressMatchedRowCount
Call BWordTableFromArray(tableCopyAsArray, decorators, reportDoc, xProgressBarIncrement:=progressBarIncrement)
If progressBar.userCancelled Then GoTo reportCancelled
Next zTableIndex
progressWeighting = 0.1
With progressBar
.Caption1 = c8PBPreparingReportTable
.Caption2 = c8Name & c8PBWaitingProcessing
.CancelButtonEnable False
End With
Set mainTableRange = BWordTableToText(reportDoc.tables(2))
With progressBar
.Caption2 = ""
.AddProgress progressWeighting
End With
progressWeighting = 0.08
With progressBar
.Caption1 = c8PBIdentifyingAbbreviations
.CancelButtonEnable
End With
progressBarIncrement = (progressWeighting / (searchStringCount))
highlightIndex = LBound(highlightsAll)
zString1 = c8PBOf & searchStringCount & " (" & Trim$(c8PBTerm) & ")"
zString2 = c8PBOf & searchStringCount & " (" & Trim$(c8PBDefinition) & ")"
For i = 0 To searchStringCount - 1 Step 2
With progressBar
If .userCancelled Then GoTo reportCancelled
.Caption3 = ""
.show
End With
highlightIndex = BAddOneModular(highlightIndex, UBound(highlightsAll))
Set fmt = highlightsAll(highlightIndex)
With progressBar
.Caption2 = (i / 2) + 1 & zString1
.AddProgress progressBarIncrement
End With
fr.matchesIdentify xString:=CStr(searchStrings(i, 0)), xMatchCase:=True, xClear:=False, xSortMatches:=False, xData01:=fmt
If progressBar.userCancelled Then GoTo reportCancelled
With progressBar
.Caption2 = (i / 2) + 2 & zString2
.AddProgress progressBarIncrement
End With
fr.matchesIdentify xString:=CStr(searchStrings(i + 1, 0)), xClear:=False, xSortMatches:=False, xData01:=fmt
If progressBar.userCancelled Then GoTo reportCancelled
Next
progressBar.Caption2 = ""
fr.matchesSort
progressWeighting = 0.07
progressBarIncrement = progressWeighting
With progressBar
If .userCancelled Then GoTo reportCancelled
.Caption1 = c8PBHighlightingMatches
.Caption2 = ""
.Caption3 = ""
End With
fr.matchesformat
With progressBar
If .userCancelled Then GoTo reportCancelled
.AddProgress progressBarIncrement
End With
progressWeighting = 0.05
progressBarIncrement = progressWeighting / 2
With progressBar
.Caption1 = c8PBFormattingTable
.Caption2 = c8Name & c8PBWaitingProcessing
.Caption3 = ""
End With
Call BWordTextToTable(mainTableRange, xSetFormat:=False)
With reportDoc.tables(2).Borders
.InsideLineStyle = wdLineStyleSingle
.OutsideLineStyle = wdLineStyleSingle
End With
With reportDoc.tables(2).rows(1)
.Range.Font.Bold = True
.HeadingFormat = True
.Range.Shading.Texture = wdTexture10Percent
.Range.Font.Size = 9
End With
With progressBar
.Caption2 = ""
.AddProgress progressBarIncrement
End With
Set MatchesReport = reportDoc
reportDoc.Windows(1).Visible = True
reportDoc.Windows(1).DocumentMap = False
BSendKeys "{PgUp}{PgUp}"
statsCount2 = CStr(fr.matchesCount - searchStringCount)
GoTo finish
reportCancelled:
reportDoc.Close wdDoNotSaveChanges
progressBar.finish
showMessage c8Msg3020
statsCount2 = "cancel"
finish:
Application.screenUpdating = True
progressBar.finish
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
If frmAbbreviationsReview.getMode = frmAbbreviationsReviewMode_ReadOnly Or ((frmAbbreviationsReview.getMode = frmAbbreviationsReviewMode_UpdateAnonymisations) And ppA_GlossaryColumnUpdateGet) Then
statsCount2 = "*" & statsCount2
End If
ppStats_Update ppStats_AbbreviationReport, pbTablesToCheck, pbRowsToCheck, stopWatch01.value, xField1:=CStr((searchStringCount) / 2), xField2:=statsCount2
End Function
Private Function tablesToCopy() As Long()
Dim out() As Long
Dim matchesIndex As Long
Dim tableArrayIndex As Long
Dim zString As String
Dim zTableNumber As String
Dim latestTableFound As String
Dim matches()  As String
ReDim out(ThisDocument.tables.count)
ReDim matches(thisDocFinder.matchesCount)
tableArrayIndex = -1
latestTableFound = ""
matches = thisDocFinder.matchesRowNumbers
For matchesIndex = 0 To UBound(matches)
zString = matches(matchesIndex)
zTableNumber = Left$(zString, InStr(zString, matchDelimiter) - 1)
If zTableNumber = latestTableFound Then
Else
latestTableFound = zTableNumber
tableArrayIndex = tableArrayIndex + 1
out(tableArrayIndex) = CInt(zTableNumber)
End If
Next matchesIndex
ReDim Preserve out(tableArrayIndex)
tablesToCopy = out
End Function
Private Function rowsToCopy(xTableNumber As Long) As Long()
Dim i As Long
Dim out() As Long
Dim zString As String
Dim zTableNumber As Long
Dim rowArrayIndex As Long
Dim matches()  As String
ReDim out(UBound(thisDocFinder.matchesRowNumbers))
ReDim matches(thisDocFinder.matchesCount)
rowArrayIndex = -1
matches = thisDocFinder.matchesRowNumbers
For i = matchesRowNumberStartSearch To UBound(matches)
zString = matches(i)
zTableNumber = CInt(Left$(zString, InStr(zString, matchDelimiter) - 1))
Select Case zTableNumber
Case Is < xTableNumber
showMessage c8Msg6000, msgSuffix2:="rowsToCopy: logic error"
Exit Function
Case xTableNumber
rowArrayIndex = rowArrayIndex + 1
out(rowArrayIndex) = CLng(Mid$(zString, InStr(zString, matchDelimiter) + 1))
Case Is > xTableNumber
matchesRowNumberStartSearch = i
GoTo finished
End Select
Next i
finished:
ReDim Preserve out(rowArrayIndex)
rowsToCopy = out
End Function
Function personaliseString(xString As String) As String
Dim i As Long
Dim out As String
Dim entry As String
out = xString
For i = 1 To thisDocGlossaryMerged.count
entry = thisDocGlossaryMerged.getEntryByIndex(i)
out = replace(out, thisDocGlossaryMerged.getKey(entry), thisDocGlossaryMerged.getItem(entry))
Next i
personaliseString = out
End Function
Attribute VB_Name = "c8MC_Analysis"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Const outputColumnsPerTable As Long = 12
Dim dataRowCount As Long
Dim tableStartDate As String
Dim tableEndDate As String
Dim usedSequenceNumbers As String
Dim tableCount As Long
Dim sourcePrefixes() As String
Dim foreColors() As Long
Dim backColors() As Long
Private publishCancelled As Boolean
Private publishCancelledInternally As Boolean
Dim analysisDoc As Document
Sub CreateAnalysisDocument2()
Dim tablesfound As Variant
Dim sw1 As clsStopWatch
Dim i As Long
Dim saveStatus As Boolean
Dim normaliseSourceRequired As Boolean
Dim sourceFragments() As String
Dim docSave As String
Dim highlightIndex As Long
Dim zFormat As clsFormat
Dim pbWeightingPhase1 As Double
Dim pbWeightingPhase2 As Double
Set sw1 = New clsStopWatch
sw1.Start
saveStatus = ThisDocument.Saved
usedSequenceNumbers = ""
publishCancelled = False
publishCancelledInternally = False
docSave = ""
fs2FileToPublish = ThisDocument.name
With progressBar
.Reset
.title = "Create Analysis Document"
.Caption1 = c8PBAnalysingTables
.show
.AddProgress 0.01
.CancelButtonEnable False
End With
If thisDocDescriptor.columnSequence = 0 Then
showMessage c8msg5140
GoTo finish
End If
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=False)
If IsEmpty(tablesfound) Then
Call showMessage(c8Msg1015, msgSuffix1:=" " & fs2FileToPublish)
GoTo finish
End If
tableCount = UBound(tablesfound) + 1
Call setProgressBarCounters(ThisDocument, tablesfound)
If pbRowsToCheck = 0 Then
showMessage c8Msg3012
GoTo finish
End If
If thisDocSourcePrefixes.count > 0 Then
sourcePrefixes = GetHighLevelSourcePrefixes
dataRowCount = UBound(sourcePrefixes) + 2
Else
dataRowCount = 1
End If
Application.screenUpdating = False
Set analysisDoc = Documents.add(Visible:=False)
analysisDoc.PageSetup.Orientation = wdOrientLandscape
analysisDoc.Styles(wdStyleHeading1).ParagraphFormat.PageBreakBefore = True
analysisDoc.Content.text = ""
ThisDocument.activate
If thisDocSourcePrefixes.count > 0 Then
ReDim backColors(UBound(sourcePrefixes))
ReDim foreColors(UBound(sourcePrefixes))
For i = 0 To UBound(sourcePrefixes)
highlightIndex = getHighlightIndex(sourcePrefixes(i) & c8SourceDelimiter)
If highlightIndex = -1 Then
Set zFormat = Nothing
Else
Set zFormat = highlightsAll(highlightIndex)
End If
If zFormat Is Nothing Then
foreColors(i) = wdColorBlack
backColors(i) = wdColorWhite
Else
foreColors(i) = zFormat.foreColor
backColors(i) = zFormat.backColor
End If
Next
End If
progressBar.Caption2 = c8PBCheckingSPN
normaliseSourceRequired = (thisDocSourcePrefixes.count > 0) And (thisDocDescriptor.tablesHash2 <> tablesHash(tablesfound, ThisDocument, thisDocDescriptor.columnSource))
sw1.Halt
If normaliseSourceRequired Then
pbWeightingPhase1 = 0.2
pbWeightingPhase2 = 0.8
sourceFragments = GetSourceFragments
docSave = thisDocSaver.documentSave(ThisDocument)
If sourcePrefixNormalise(tablesfound, sourceFragments, thisDocDescriptor.columnSource, xAddProgress:=pbWeightingPhase1 / pbRowsToCheck) = "" Then
Call thisDocSaver.closeSingle(docSave)
docSave = ""
Else
If progressBar.userCancelled Then
publishCancelledInternally = False
Else
publishCancelledInternally = True
End If
GoTo exitPublishCancelled
End If
Else
pbWeightingPhase2 = 1
End If
If progressBar.userCancelled Then GoTo exitPublishCancelled
sw1.Start
For i = 0 To UBound(tablesfound)
progressBar.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
progressBar.Caption2 = ""
progressBar.Caption3 = ""
Call createAnalysisDocument3(xTableIndex:=CLng(tablesfound(i)), xAddProgress:=(pbWeightingPhase2 / (UBound(tablesfound) + 1)))
If publishCancelled Then
GoTo exitPublishCancelled
End If
Next i
If Not c8LicenceHaveValid Then
progressBar.Caption2 = c8PBWritingWatermark
Call licenceWriteEvaluationWatermarks(analysisDoc)
End If
ppStats_Update ppStats_PublishAnalysis, pbTablesToCheck, pbRowsToCheck, sw1.value
analysisDoc.ActiveWindow.Visible = True
Application.screenUpdating = True
progressBar.finish
If c8FileSaveAs(xDoc:=analysisDoc, xSuggestedName:=BGetFilenamePart(fs2FileToPublish) & " Analysis", xEnforceMacroEnabled:=False) Then
Documents(BWordGetNumericDocumentIndex(fileSavedAsFullName)).activate
ActiveDocument.Windows(1).View.Type = wdPrintView
Application.screenUpdating = False
Application.screenUpdating = True
thisDocNavigator.setDocument ThisDocument.fullName
Else
analysisDoc.Saved = True
analysisDoc.Close
ThisDocument.activate
End If
GoTo finish
exitPublishCancelled:
analysisDoc.Close savechanges:=wdDoNotSaveChanges
If publishCancelledInternally Then
publishCancelledInternally = False
GoTo finish
End If
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = ""
progressBar.Caption3 = ""
If Len(docSave) > 0 Then
progressBar.Caption2 = c8PBWaitRestore
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
End If
showMessage c8Msg5115
finish:
fs2FileToPublish = ""
progressBar.finish
Application.screenUpdating = True
ThisDocument.Saved = saveStatus
Set analysisDoc = Nothing
End Sub
Sub createAnalysisDocument3(xTableIndex As Long, xAddProgress As Double)
Dim i As Long
Dim tableRowCount As Long
Dim t As table
Dim tableAsArray As Variant
Const progressBarWeightingPhase1 As Double = 0.4
Const progressBarWeightingPhase2 As Double = 0.4
Const progressBarWeightingPhase3 As Double = 0.2
Dim outputRowCount As Long
Dim outputColumnCount As Long
Dim columnIndex As Long
Dim zDate As String
Dim zDouble As Double
Dim zRef As String
Dim zSource As String
Dim outputCells() As String
Dim monthTotals() As Long
Const ISODate9s As String = "9999-99-99"
Const ISODate0s As String = "0000-00-00"
Application.screenUpdating = False
Set t = ThisDocument.tables(xTableIndex)
tableRowCount = BWordTableRowCount(t)
With progressBar
.Caption2 = c8PBPreparingTable
.CancelButtonEnable False
End With
tableAsArray = BWordTableToArray(xTable:=t, xDelete:=False, xProgressBarIncrement:=0.6 * progressBarWeightingPhase1 * xAddProgress / tableRowCount)
If progressBar.userCancelled Then GoTo publishCancelled
If BWordTableToArrayError(tableAsArray) Then
GoTo badFinish
End If
With progressBar
.Caption2 = "Determining date boundaries"
End With
tableStartDate = ISODate9s
tableEndDate = ISODate0s
For i = 2 To UBound(tableAsArray)
zDate = bdt.StringToISODate(CStr(tableAsArray(i, thisDocDescriptor.columnStartDate)))
If Len(zDate) > 0 Then
If zDate < tableStartDate Then
tableStartDate = zDate
End If
End If
If Len(zDate) > 0 Then
If zDate > tableEndDate Then
tableEndDate = zDate
End If
End If
progressBar.AddProgress 0.4 * progressBarWeightingPhase1 * xAddProgress / tableRowCount
Next
If progressBar.userCancelled Then GoTo publishCancelled
If (tableStartDate = ISODate9s) Or (tableEndDate = ISODate0s) Then
showMessage c8msg5141, msgSuffix2:=CStr(xTableIndex) & "."
GoTo badFinish
End If
With progressBar
.Caption2 = "Writing to array"
End With
outputRowCount = dataRowCount + 1
outputColumnCount = DateDiff("m", tableStartDate, tableEndDate) + 1
ReDim outputCells(outputRowCount, outputColumnCount)
ReDim monthTotals(outputColumnCount)
outputCells(0, 1) = format$(tableStartDate, "mmm yyyy")
For i = 2 To outputColumnCount
outputCells(0, i) = format$(DateAdd("m", 1, outputCells(0, i - 1)), "mmm yyyy")
Next
For i = 0 To outputRowCount
outputCells(i, 0) = 0
Next
For i = 2 To UBound(tableAsArray)
If BWordIsBlankRow_TA(tableAsArray, i) Then GoTo nextRow
zRef = tableAsArray(i, thisDocDescriptor.columnSequence)
If validReference(zRef) Then
Else
showMessage c8msg5140
GoTo badFinish
End If
zDate = format$(bdt.DateValueLoose(tableAsArray(i, thisDocDescriptor.columnStartDate)), c8DateFormatISO)
If Len(zDate) = 0 Then
showMessage c8msg5143, msgSuffix2:=zRef & "."
GoTo badFinish
End If
zSource = BWordNormaliseText(tableAsArray(i, thisDocDescriptor.columnSource))
If InStr(zSource, c8SourceDelimiter) > 0 Then
If thisDocSourcePrefixes.containsKey(sourcePrefix(zSource)) Then
Else
showMessage c8msg5144, msgSuffix2:=zRef & "."
GoTo badFinish
End If
End If
Call placeReference(zRef, zSource, zDate, outputCells, monthTotals)
progressBar.AddProgress (0.5 * progressBarWeightingPhase2 * xAddProgress) / (UBound(tableAsArray) + 1)
If progressBar.userCancelled Then GoTo publishCancelled
nextRow:
Next
zDouble = UBound(outputCells, 1) * UBound(outputCells, 2)
For i = 1 To UBound(outputCells, 1)
For columnIndex = 1 To UBound(outputCells, 2)
If Right$(outputCells(i, columnIndex), 2) = ", " Then
outputCells(i, columnIndex) = Left$(outputCells(i, columnIndex), Len(outputCells(i, columnIndex)) - 2)
End If
progressBar.AddProgress (0.5 * progressBarWeightingPhase2 * xAddProgress) / zDouble
If progressBar.userCancelled Then GoTo publishCancelled
Next
Next
Call populateDocumentFromArray(xOutputCells:=outputCells, xMonthTotals:=monthTotals, xProgressBarIncrement:=progressBarWeightingPhase3 * xAddProgress)
If progressBar.userCancelled Then GoTo publishCancelled
progressBar.Caption2 = ""
Exit Sub
badFinish:
publishCancelledInternally = True
publishCancelled:
publishCancelled = True
End Sub
Sub populateDocumentFromArray(xOutputCells() As String, xMonthTotals() As Long, xProgressBarIncrement As Double)
Dim zRange As Range
Dim zString As String
Dim i As Long
Dim outputTableCount As Long
Const progressBarWeightingPhase1 As Double = 0.6
Const progressBarWeightingPhase2 As Double = 0.4
With progressBar
.Caption2 = "Populating document from array"
.Caption3 = "Timeline tables"
End With
Set zRange = analysisDoc.Content
zRange.Collapse direction:=wdCollapseEnd
zString = "Detailed Analysis by Source Prefix and Month"
If tableCount > 1 Then
zString = zString & " (" & format$(tableStartDate, "mmmm yyyy") & " - " & format$(tableEndDate, "mmmm yyyy") & ")"
End If
zRange.InsertAfter zString
zRange.Style = wdStyleHeading1
BWordSetStyleNormal zRange
zRange.InsertAfter ("Numbers in [square brackets] are the total number of events for that Source and Month")
outputTableCount = (UBound(xOutputCells, 2) / outputColumnsPerTable) + 1
For i = 1 To UBound(xOutputCells, 2) Step outputColumnsPerTable
Call writeTable(xColumnStart:=i, xOutputCells:=xOutputCells, xProgressBarIncrementPerPrefix:=0.5 * progressBarWeightingPhase1 * xProgressBarIncrement / (dataRowCount * outputTableCount))
If progressBar.userCancelled Then Exit Sub
Next
Set zRange = analysisDoc.Content
BWordSetStyleNormal zRange
zString = "Summary Analysis by Source Prefix and Month"
If tableCount > 1 Then
zString = zString & " (" & format$(tableStartDate, "mmmm yyyy") & " - " & format$(tableEndDate, "mmmm yyyy") & ")"
End If
zRange.InsertAfter zString
zRange.Style = wdStyleHeading1
BWordSetStyleNormal zRange
zRange.InsertAfter ("Total number of events for each Source and Month")
For i = 1 To UBound(xOutputCells, 2) Step outputColumnsPerTable
Call writeTable(xColumnStart:=i, xOutputCells:=xOutputCells, xProgressBarIncrementPerPrefix:=0.5 * progressBarWeightingPhase1 * xProgressBarIncrement / (dataRowCount * outputTableCount), xDetail:=False)
If progressBar.userCancelled Then Exit Sub
Next
With progressBar
.Caption3 = "Totals"
End With
Call writeTotals(xOutputCells:=xOutputCells, xMonthTotals:=xMonthTotals, xProgressBarIncrement:=progressBarWeightingPhase2 * xProgressBarIncrement)
If progressBar.userCancelled Then Exit Sub
End Sub
Sub placeReference(xRef As String, xSource As String, xDate As String, xOutputCells() As String, xMonthTotals() As Long)
Dim prefixRow As Long
Dim month As Long
prefixRow = getPrefixRow(xSource)
If prefixRow = 0 Then
showMessage c8Msg6000, msgSuffix2:="placeReference: Unable to place event reference " & xRef & "(source " & xSource & ", ISO date " & xDate & ")"
publishCancelled = True
Else
month = DateDiff("m", tableStartDate, xDate) + 1
xOutputCells(prefixRow, month) = xOutputCells(prefixRow, month) & xRef & ", "
xOutputCells(prefixRow, 0) = xOutputCells(prefixRow, 0) + 1
xMonthTotals(month) = xMonthTotals(month) + 1
End If
End Sub
Function validReference(xRef As Variant) As Boolean
Dim checkRef As String
Dim out As Boolean
out = True
If Not IsNumeric(xRef) Then
out = False
GoTo finish
End If
checkRef = "@" & xRef & "@"
If InStr(usedSequenceNumbers, checkRef) > 0 Then
out = False
Else
usedSequenceNumbers = usedSequenceNumbers & checkRef
End If
finish:
validReference = out
End Function
Function getPrefixRow(xSource As String) As Long
Dim i  As Long
Dim highlevelPrefix As String
If thisDocSourcePrefixes.count = 0 Or InStr(xSource, c8SourceDelimiter) = 0 Then
getPrefixRow = 1
Exit Function
End If
highlevelPrefix = sourcePrefix(xSource, 1)
highlevelPrefix = Left$(highlevelPrefix, Len(highlevelPrefix) - 1)
For i = 0 To UBound(sourcePrefixes)
If highlevelPrefix = sourcePrefixes(i) Then
getPrefixRow = i + 2
Exit Function
End If
Next
End Function
Sub writeTable(xColumnStart As Long, xOutputCells() As String, xProgressBarIncrementPerPrefix As Double, Optional xDetail As Boolean = True)
Dim columnIndex As Long
Dim i As Long
Dim zString As String
Dim zRange As Range
Dim zRow As row
Dim zLong As Variant
Dim t As table
Dim maxColumnIndex As Long
Set zRange = analysisDoc.Range
zRange.InsertParagraphAfter
zRange.Collapse wdCollapseEnd
maxColumnIndex = BMin(xColumnStart + outputColumnsPerTable - 1, UBound(xOutputCells, 2))
zString = "Source"
For columnIndex = xColumnStart To maxColumnIndex
zString = zString & vbTab & xOutputCells(0, columnIndex)
Next
zString = zString & vbNewLine
zRange.InsertAfter zString
For i = -1 To dataRowCount - 2
If i = -1 Then
zString = "No prefix"
Else
zString = sourcePrefixes(i)
End If
For columnIndex = xColumnStart To maxColumnIndex
zLong = UBound(Split(xOutputCells(i + 2, columnIndex), ","))
zString = zString & vbTab
If xDetail Then
zString = zString & xOutputCells(i + 2, columnIndex)
If zLong > -1 Then
zString = zString & " [" & zLong + 1 & "]"
End If
Else
If zLong > -1 Then
zString = zString & (zLong + 1)
End If
End If
Next
progressBar.AddProgress xProgressBarIncrementPerPrefix
DoEvents
zString = zString & vbNewLine
zRange.InsertAfter zString
If progressBar.userCancelled Then Exit Sub
Next
Set t = zRange.ConvertToTable(separator:=vbTab, format:=wdTableFormatGrid1, Applyborders:=True)
setTableCharacteristics t
For i = 0 To dataRowCount - 2
Set zRow = t.rows(getPrefixRow(sourcePrefixes(i) & c8SourceDelimiter) + 1)
zRow.Shading.BackgroundPatternColor = backColors(i)
zRow.Range.Font.Shading.BackgroundPatternColor = backColors(i)
zRow.Range.Font.Color = foreColors(i)
Next
t.AutoFitBehavior wdAutoFitContent
End Sub
Sub writeTotals(xOutputCells() As String, xMonthTotals() As Long, xProgressBarIncrement As Double)
Dim i As Long
Dim zString As String
Dim zRange As Range
Dim zRow As row
Dim t As table
Set zRange = analysisDoc.Range
zRange.InsertParagraphAfter
zRange.Collapse wdCollapseEnd
zString = "Totals by Source"
If tableCount > 1 Then
zString = zString & " (" & format$(tableStartDate, "mmmm yyyy") & " - " & format$(tableEndDate, "mmmm yyyy") & ")"
End If
zRange.InsertAfter zString
zRange.Style = wdStyleHeading1
BWordSetStyleNormal zRange
zString = "Source" & vbTab & "Number of events" & vbNewLine
zRange.InsertAfter zString
zString = "No prefix" & vbTab & xOutputCells(1, 0) & vbNewLine
zRange.InsertAfter zString
If thisDocSourcePrefixes.count > 0 Then
For i = 0 To UBound(sourcePrefixes)
zString = sourcePrefixes(i)
zString = zString & vbTab & xOutputCells(i + 2, 0)
zString = zString & vbNewLine
zRange.InsertAfter zString
Next
End If
Set t = zRange.ConvertToTable(separator:=vbTab, format:=wdTableFormatGrid1, Applyborders:=True)
setTableCharacteristics t
progressBar.AddProgress 0.5 * xProgressBarIncrement
If thisDocSourcePrefixes.count > 0 Then
For i = 0 To UBound(sourcePrefixes)
Set zRow = t.rows(getPrefixRow(sourcePrefixes(i) & c8SourceDelimiter) + 1)
zRow.Shading.BackgroundPatternColor = backColors(i)
zRow.Range.Font.Shading.BackgroundPatternColor = backColors(i)
zRow.Range.Font.Color = foreColors(i)
Next
End If
t.AutoFitBehavior wdAutoFitContent
Set zRange = analysisDoc.Range
zRange.InsertParagraphAfter
zRange.Collapse wdCollapseEnd
zString = "Totals by Month"
If tableCount > 1 Then
zString = zString & " (" & format$(tableStartDate, "mmmm yyyy") & " - " & format$(tableEndDate, "mmmm yyyy") & ")"
End If
zRange.InsertAfter zString
zRange.Style = wdStyleHeading1
Set zRange = analysisDoc.Range
zRange.InsertParagraphAfter
zRange.Collapse wdCollapseEnd
zString = "Month" & vbTab & "Number of events" & vbNewLine
For i = 1 To UBound(xOutputCells, 2)
zString = zString & xOutputCells(0, i) & vbTab & xMonthTotals(i) & vbNewLine
Next
zRange.InsertAfter zString
Set t = zRange.ConvertToTable(separator:=vbTab, format:=wdTableFormatGrid1, Applyborders:=True)
setTableCharacteristics t
t.AutoFitBehavior wdAutoFitContent
progressBar.AddProgress 0.5 * xProgressBarIncrement
End Sub
Attribute VB_Name = "c8MC_DocumentCheck"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Const rowErrorsNone As Long = 1
Const rowErrorsWarning As Long = 2
Const rowErrorsError As Long = 3
Const rowErrorsPriorityError As Long = 4
Const cellErrorsNone As Long = 1
Const cellErrorsWarning As Long = 2
Const cellErrorsError As Long = 3
Const cellErrorsPriorityError As Long = 4
Const checkDateBit = 0
Const checkTimeBit = 1
Const errorRef As String = "{Wingdings 120}"
Public Const errorSectionHeading As String = "Chronolator found errors in this document"
Public Const errorSectionDuplicatesHeading As String = "Chronolator found duplicated rows in this document"
Dim noteCurrent As Long
Dim tableCheckCancelled As Boolean
Dim normaliseSourceRequired As Boolean
Public listFound As Boolean
Public abbreviationsChangedSinceLastCheck As Boolean
Dim rowCountErrors As Boolean
Function CheckTablesInThisDocument() As Boolean
CheckTablesInThisDocument = CheckTablesInDocument(ThisDocument, thisDocDescriptor)
End Function
Function CheckTablesInDocument(doc As Document, docDescriptor As clsDocDescriptor, Optional calledFromClose As Boolean = False) As Boolean
Dim sw1 As clsStopWatch
Dim saveStatus As Boolean
Dim tablesfound As Variant
Dim errors As Long
Dim buttonPressed As String
Dim i As Long
Dim markerCount As Long
Dim docSave As String
Dim performanceOptionsStore() As Variant
Dim restorePosition As Boolean
performanceOptionsStore = BWordPerformanceOptionsSet()
restorePosition = True
errors = 0
markerCount = 0
docSave = ""
buttonPressed = ""
If trackedChangesLurking(doc) Then
If trackedChangesOffDialog(doc) Then
Else
CheckTablesInDocument = True
Call showMessage(c8Msg5231, msgPrefix1:="Check Tables", msgPrefix2:="<" & doc.name)
GoTo finish
End If
End If
Set sw1 = New clsStopWatch
sw1.Start
With progressBar
.Reset
.title = "Check tables"
.Caption1 = c8PBAnalysingTables
.show
.AddProgress 0.01
.CancelButtonEnable False
End With
listFound = False
tablesfound = GetTables(doc:=doc, heads:=BuildHeadersArray(docDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015, msgSuffix1:=" " & doc.name)
GoTo finish
End If
If UBound(tablesfound) > 0 Then
If calledFromClose Then
Else
sw1.Halt
Select Case mergeMultipleTablesPrompt("Check tables")
Case "MergeFailed"
progressBar.finish
GoTo finish
Case "Merge"
tablesfound = GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor))
Case "Don't Merge"
progressBar.repaint
Case "Cancel"
progressBar.finish
GoTo finish
End Select
frmMessage.Hide
sw1.Start
End If
End If
progressBar.Caption2 = c8PBCheckingForChanges
If docDescriptor.tablesHash1 = tablesHash(tablesfound, doc) And Not abbreviationsChangedSinceLastCheck Then
CheckTablesInDocument = Not docDescriptor.containsErrors
If calledFromClose Then
progressBar.finish
GoTo finish
Else
sw1.Halt
If showMessage(c8Msg3011, button2:="Check", button3:="Cancel", defaultButton:=3) = "Cancel" Then
progressBar.finish
GoTo finish
End If
sw1.Start
End If
End If
If DocHasUserTextAfterTables(doc) Then
sw1.Halt
If showMessage(c8Msg3013, button2:="OK", button3:="Cancel", defaultButton:=3) = "Cancel" Then
progressBar.finish
ScrollToTablesEnd doc
GoTo finish
End If
sw1.Start
End If
saveStatus = doc.Saved
Call setProgressBarCounters(doc, tablesfound)
If pbRowsToCheck = 0 Then
errors = 0
GoTo checkCompleted
End If
docSave = thisDocSaver.documentSave(ThisDocument)
Call DocPadding_Add
If openedByC9 Then GoTo startCheck
startCheck:
Application.screenUpdating = False
progressBar.Caption2 = c8PBCheckingSPN
normaliseSourceRequired = (thisDocSourcePrefixes.count > 0) And (thisDocDescriptor.tablesHash2 <> tablesHash(tablesfound, ThisDocument, thisDocDescriptor.columnSource))
tableCheckCancelled = False
rowCountErrors = False
For i = 0 To UBound(tablesfound)
Dim z As Variant
progressBar.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
progressBar.Caption2 = ""
progressBar.Caption3 = ""
progressBar.repaint
z = CheckTable(doc, docDescriptor, doc.Content.tables(tablesfound(i)), thisDocGlossaryMerged)
If IsNumeric(z(1)) Then
errors = errors + z(1)
markerCount = markerCount + z(2)
End If
DoEvents
If tableCheckCancelled Then
GoTo checkCancelled
End If
Next i
With progressBar
.Caption1 = c8PBCheckCompleted
.Caption2 = BPluralityText(errors, "error")
.Caption3 = c8PBFinishing
End With
CheckTablesInDocument = (errors = 0)
docDescriptor.containsErrors = (errors > 0)
GoTo checkCompleted
checkCancelled:
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
Application.screenUpdating = False
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
docDescriptor.tablesHash1 = 0
CheckTablesInDocument = False
progressBar.finish
Call showMessage(c8Msg3015)
GoTo endCheck
checkCompleted:
If rowCountErrors Then
docDescriptor.tablesHash1 = "RowErrorsFixed"
Else
docDescriptor.tablesHash1 = tablesHash(tablesfound, doc)
End If
abbreviationsChangedSinceLastCheck = False
Call navButtonsSetTooltipText("error")
ppStats_Update ppStats_CheckTables, pbTablesToCheck, pbRowsToCheck, sw1.value, xField1:=CStr(markerCount)
If listFound And Not calledFromClose Then showMessage msg:=c8Msg3200
Application.screenUpdating = True
Application.ScreenRefresh
If errors > 0 Then
Call navButtonsEnable
Call errorSectionSetup(doc)
If calledFromClose Then
Else
buttonPressed = showMessage(c8Msg3000, msgSuffix1:=" (" & markerCount & ")", button2:="OK", button3:="Go to list", defaultButton:=2)
If rowCountErrors Then showMessage c8Msg3001
End If
Else
Call errorSectionCleanup(doc)
Call navButtonsDisable
Call showMessage(c8Msg3010)
End If
endCheck:
progressBar.finish
CheckTablesInDocument = (errors = 0)
docDescriptor.containsErrors = (errors > 0)
Call thisDocSaver.closeSingle(docSave)
Application.screenUpdating = True
Call DocPadding_Delete
doc.UndoClear
If buttonPressed = "Go to list" Then
Call gotoErrorList
restorePosition = False
Else
doc.activate
Application.StatusBar = "Table check complete. " & BPluralityText(markerCount, "error") & " found."
End If
If calledFromClose Then
Else
Application.DisplayScreenTips = True
End If
doc.Saved = saveStatus
finish:
Call BWordPerformanceOptionsRestore(performanceOptionsStore, restorePosition)
End Function
Function CheckTable(doc As Document, docDescriptor As clsDocDescriptor, tabl As Variant, glossary As clsGlossary) As Variant
Dim out(2) As Variant
Dim lastCheckedEvent(3) As String
Dim rowNum As Long
Dim errorCount As Long
Dim markerCount As Long
Dim tableAsArray As Variant
Dim tableRange As Range
Dim tableCast As table
Dim tableStart As Long
Dim decorators() As Variant
Dim columnWidths() As Long
Dim cellErrorSeverity() As Variant
Dim rowErrorSeverity() As Long
Dim cellErrorText() As Variant
Dim rowErrorText() As String
Dim i As Long: Dim j As Long: Dim rowCount As Long
Dim sortOrder As String
Dim zText As String
Dim zString As String
Dim zRanges As Variant
Dim sourcePrefixes As clsGlossary
Dim glossaryEntries As String
Dim glossaryEntry() As String
Dim glossaryEntryDelimiter As String
Set sourcePrefixes = New clsGlossary
If IsEmpty(tabl) Then Exit Function
Call BWordRemoveFrameFromTable(tabl)
progressBar.AddProgress 0.01 / pbTablesToCheck
rowCount = BWordTableRowCount(tabl)
ReDim Preserve rowErrorSeverity(1 To rowCount)
ReDim Preserve cellErrorSeverity(1 To rowCount, 1 To docDescriptor.columnCount)
ReDim Preserve rowErrorText(1 To rowCount)
ReDim Preserve cellErrorText(1 To rowCount, 1 To docDescriptor.columnCount)
errorCount = 0
markerCount = 0
If BWordTableHasVerticallyMergedCells(tabl) Then
errorCount = markVerticallyMergedCells(tabl)
markerCount = markerCount + errorCount
GoTo endCheck
End If
zRanges = BWordTableNestedTables(tabl)
If IsEmpty(zRanges) Then
Else
Call markNestedCells(tabl, zRanges)
errorCount = errorCount + UBound(zRanges) + 1
markerCount = markerCount + errorCount
GoTo endCheck
End If
If CheckForListsInTable(xTable:=tabl) Then listFound = True
If Len(docDescriptor.sortOrder) = 0 Then
sortOrder = c8SortOrderAscending
Else
sortOrder = docDescriptor.sortOrder
End If
With progressBar
.Caption2 = c8PBPreparingTable & "for analysis"
.CancelButtonEnable False
End With
Set tableCast = tabl
tableStart = tableCast.Range.Start
columnWidths = BWordTableGetColumnWidths(tableCast)
tableAsArray = BWordTableToArray(xTable:=tableCast, xDelete:=True, xProgressBarIncrement:=0.1 / pbRowsToCheck)
If BWordTableToArrayError(tableAsArray) Then
tableCheckCancelled = True
GoTo endCheck
End If
If IsEmpty(tableAsArray) Then
tableCheckCancelled = True
GoTo endCheck
End If
If UBound(tableAsArray, 1) = rowCount Then
Else
rowCount = UBound(tableAsArray, 1)
ReDim Preserve rowErrorSeverity(1 To rowCount)
ReDim Preserve rowErrorText(1 To rowCount)
cellErrorSeverity = BArray2DPreserve(cellErrorSeverity, xUBound1:=rowCount, xUBound2:=UBound(cellErrorSeverity, 2))
cellErrorText = BArray2DPreserve(cellErrorText, xUBound1:=rowCount, xUBound2:=UBound(cellErrorSeverity, 2))
End If
For i = 1 To rowCount
rowErrorSeverity(i) = rowErrorsNone
rowErrorText(i) = ""
For j = 1 To docDescriptor.columnCount
cellErrorSeverity(i, j) = cellErrorsNone
cellErrorText(i, j) = ""
Next j
Next i
Set tableRange = doc.Range(tableStart, tableStart + 1)
tableRange.Font.Reset
ReDim decorators(1 To UBound(tableAsArray, 1), 0 To UBound(tableAsArray, 2), 2)
sourcePrefixes.loadFromString glGlossaryDump:=docDescriptor.sourcePrefixes
With progressBar
.Caption2 = c8PBTableReady
.Caption3 = ""
.CancelButtonEnable
End With
If normaliseSourceRequired Then
Dim sourceFragments() As String
Dim prefixCaseTranslation() As String
sourceFragments = GetSourceFragments
ReDim prefixCaseTranslation(0 To UBound(sourceFragments), 0 To 1)
For j = 0 To UBound(sourceFragments)
prefixCaseTranslation(j, 0) = sourceFragments(j)
prefixCaseTranslation(j, 1) = StrConv(sourceFragments(j), vbLowerCase)
Next j
For rowNum = 2 To rowCount
zString = sourcePrefixNormaliseWhitespace(tableAsArray(rowNum, thisDocDescriptor.columnSource))
zString = sourcePrefixStandardiseCase(zString, prefixCaseTranslation)
tableAsArray(rowNum, thisDocDescriptor.columnSource) = zString
Next rowNum
End If
For rowNum = 2 To rowCount
If progressBar.userCancelled Then
tableCheckCancelled = True
GoTo endCheck
End If
With progressBar
.AddProgress (0.2 / pbRowsToCheck)
.Caption2 = c8PBCheckingRow & rowNum & c8PBOf & rowCount
.Caption3 = "(" & BPluralityText(errorCount, "error") & c8PBFoundInTableSoFar
End With
If tableAsArray(rowNum, 0) <> docDescriptor.columnCount Then
errorCount = errorCount + reportRowError(cellErrorsPriorityError, c8Note100, rowNum, rowErrorSeverity, rowErrorText)
rowCountErrors = True
GoTo nextRow
End If
If BWordIsBlankRow_TA(tableAsArray, rowNum) Then
GoTo nextRow
End If
errorCount = errorCount + CheckDitto(tableAsArray, rowNum, cellErrorSeverity, cellErrorText)
If docDescriptor.columnGlossary = 0 Then
GoTo glossaryCheckEnd
End If
glossaryEntryDelimiter = Chr(141)
glossaryEntries = replace(BTranslateNewLines(CStr(tableAsArray(rowNum, docDescriptor.columnGlossary)), glossaryEntryDelimiter), ",", glossaryEntryDelimiter)
If Len(glossaryEntries) = 0 Then
Else
glossaryEntry = Split(glossaryEntries, glossaryEntryDelimiter)
Dim zInt As Long
For zInt = 0 To UBound(glossaryEntry)
If Len(glossaryEntry(zInt)) = 0 Then
Else
zString = BSqueezeSpaces(glossaryEntry(zInt))
If glossary.containsKey(zString) Or glossary.containsItem(zString, glIgnoreCase:=True) Then
Else
GoTo glossaryMarkError
End If
End If
Next zInt
End If
GoTo glossaryCheckEnd
glossaryMarkError:
errorCount = errorCount + reportCellError(cellErrorsError, c8Note300, rowNum, docDescriptor.columnGlossary, cellErrorSeverity, cellErrorText)
glossaryCheckEnd:
errorCount = errorCount + checkMandatoryColumns(tableAsArray, rowNum, cellErrorSeverity, cellErrorText, docDescriptor.mandatoryColumns)
zText = BWordNormaliseText(tableAsArray(rowNum, docDescriptor.columnSource))
If docDescriptor.docType = c8InternalChronology Then
If InStr(zText, c8SourceDelimiter) > 0 Then
errorCount = errorCount + reportCellError(cellErrorsError, c8Note140, rowNum, docDescriptor.columnSource, cellErrorSeverity, cellErrorText)
End If
Else
If docDescriptor.docType = c8CompositeChronologyOld Then
If InStr(zText, c8SourceDelimiter) = 0 Or sourcePrefixes.containsKey(sourcePrefix(zText)) Then
Else
errorCount = errorCount + reportCellError(cellErrorsError, c8Note145, rowNum, docDescriptor.columnSource, cellErrorSeverity, cellErrorText)
End If
End If
End If
errorCount = errorCount + CheckDitto(tableAsArray, rowNum, cellErrorSeverity, cellErrorText)
errorCount = errorCount + CheckDateTime(tableAsArray, docDescriptor, rowNum, cellErrorSeverity, cellErrorText, lastCheckedEvent, sortOrder)
nextRow:
Next rowNum
progressBar.Caption2 = BPluralityText(errorCount, "error")
If openedByC9 Then
Else
If errorCount > 0 Then
markerCount = markErrors(tableAsArray, decorators, cellErrorSeverity, cellErrorText, rowErrorSeverity, rowErrorText)
Else
progressBar.AddProgress (0.1 * rowCount / pbRowsToCheck)
End If
If progressBar.userCancelled Then
tableCheckCancelled = True
GoTo endCheck
End If
With progressBar
.Caption2 = c8PBFormattingTable
.Caption3 = ""
End With
Set tableCast = BWordTableFromArray(tableAsArray, decorators, doc, xProgressBarIncrement:=0.5 / pbRowsToCheck)
If tableCast Is Nothing Then
If progressBar.userCancelled Then
tableCheckCancelled = True
GoTo endCheck
Else
GoTo endCheck
End If
Else
BWordTableSetColumnWidths tableCast, columnWidths
progressBar.Caption3 = c8PBProcessingHeadingRow
setTableCharacteristics tableCast
With progressBar
.AddProgress 0.035 / pbTablesToCheck
.Caption2 = c8PBFormatComplete
.Caption3 = ""
End With
End If
Application.ScreenRefresh
End If
endCheck:
out(1) = errorCount
out(2) = markerCount
CheckTable = out
End Function
Function reportCellError(xSeverity As Long, xText As String, xRow As Long, xColumn As Long, ByRef cellErrorSeverity() As Variant, ByRef cellErrorText() As Variant) As Long
If cellErrorSeverity(xRow, xColumn) > cellErrorsNone Then Exit Function
cellErrorSeverity(xRow, xColumn) = xSeverity
cellErrorText(xRow, xColumn) = xText
reportCellError = 1
End Function
Function reportRowError(xSeverity As Long, xText As String, xRow As Long, ByRef rowErrorSeverity() As Long, rowErrorText() As String) As Long
If rowErrorSeverity(xRow) > rowErrorsNone Then Exit Function
rowErrorSeverity(xRow) = xSeverity
rowErrorText(xRow) = xText
reportRowError = 1
End Function
Function markErrors(tableAsArray As Variant, decorators() As Variant, cellErrorSeverity() As Variant, cellErrorText() As Variant, rowErrorSeverity() As Long, rowErrorText() As String) As Long
Dim rowNum As Long: Dim colNum As Long: Dim rowCount As Long
Dim errorText As String
Dim colorArray(1 To 4) As String
Dim markerCount As Long
markerCount = 0
colorArray(1) = c8ColorErrorsNone
colorArray(2) = c8ColorErrorsWarning
colorArray(3) = c8ColorErrorsError
colorArray(4) = c8ColorErrorsPriorityError
progressBar.Caption3 = ""
rowCount = UBound(tableAsArray, 1)
For rowNum = 2 To rowCount
If progressBar.userCancelled Then
tableCheckCancelled = True
Exit Function
End If
With progressBar
.AddProgress (0.14 / pbRowsToCheck)
.Caption3 = c8PBHighlightingErrorsInRow & rowNum & c8PBOf & rowCount
End With
If rowErrorSeverity(rowNum) > rowErrorsNone Then
decorators(rowNum, 0, 0) = colorArray(rowErrorSeverity(rowNum))
errorText = createErrorText(rowErrorText(rowNum))
decorators(rowNum, 1, 1) = errorRef
decorators(rowNum, 1, 2) = errorText
markerCount = markerCount + 1
Else
For colNum = 1 To tableAsArray(rowNum, 0)
decorators(rowNum, colNum, 0) = colorArray(cellErrorSeverity(rowNum, colNum))
If cellErrorSeverity(rowNum, colNum) > cellErrorsNone Then
If Len(cellErrorText(rowNum, colNum)) > 0 Then
errorText = createErrorText(cellErrorText(rowNum, colNum))
decorators(rowNum, colNum, 1) = errorRef
decorators(rowNum, colNum, 2) = errorText
markerCount = markerCount + 1
End If
End If
Next colNum
End If
Next rowNum
progressBar.Caption3 = ""
markErrors = markerCount
Exit Function
End Function
Function checkMandatoryColumns(xTableAsArray As Variant, xRowNum As Long, ByRef cellErrorSeverity() As Variant, ByRef cellErrorText() As Variant, mandatoryColumns As Long) As Long
Dim errorCount As Long
Dim colNum As Long
errorCount = 0
For colNum = 1 To xTableAsArray(xRowNum, 0)
If BBitIsSet(colNum, mandatoryColumns) Then
If Len(BWordNormaliseText(xTableAsArray(xRowNum, colNum))) = 0 Then
errorCount = errorCount + reportCellError(cellErrorsError, c8Note120, xRowNum, colNum, cellErrorSeverity, cellErrorText)
End If
End If
Next colNum
checkMandatoryColumns = errorCount
End Function
Function CheckDitto(xTableAsArray As Variant, xRowNum As Long, cellErrorSeverity() As Variant, cellErrorText() As Variant) As Long
Dim errorCount As Long
Dim colNum As Long
Dim cellText As String
errorCount = 0
For colNum = 1 To xTableAsArray(xRowNum, 0)
cellText = UCase$(BRemoveAllSpaces((replace(BWordNormaliseText(xTableAsArray(xRowNum, colNum)), chrDoubleQuote, chrSingleQuote))))
If Len(cellText) = 0 Then GoTo nextCell
If cellText = "ASABOVE" Or cellText = "SEEABOVE" Or cellText = "DITTO" Or BSqueezeAllRepeatedCharacters(cellText) = chrSingleQuote Then
errorCount = errorCount + reportCellError(cellErrorsError, c8Note125, xRowNum, colNum, cellErrorSeverity, cellErrorText)
End If
nextCell:
Next colNum
CheckDitto = errorCount
End Function
Function CheckDateTime(xTableAsArray As Variant, xDocDescriptor As clsDocDescriptor, xRowNum As Long, cellErrorSeverity() As Variant, cellErrorText() As Variant, lastCheckedEvent() As String, sortOrder As String) As Long
Dim colNum As Long
Dim errorCount As Long
Dim startColour As Long
Dim endColour As Long
Dim startDate As String
Dim startTime As String
Dim endDate As String
Dim endTime As String
Dim startTimeTemp As String
Dim endDateTemp As String
Dim endTimeTemp As String
Dim errorText As String
Dim zString As String
Dim eventGranularity As Long
Dim goodOrder As Boolean
Dim bypassSeqCheck As Boolean
startDate = ""
endDate = ""
startTime = ""
endTime = ""
errorCount = 0
bypassSeqCheck = False
For colNum = 1 To xTableAsArray(xRowNum, 0)
Select Case colNum
Case xDocDescriptor.columnStartDate
If IsEmpty(bdt.DateValueLoose(BWordNormaliseText(xTableAsArray(xRowNum, colNum)))) Then
errorCount = errorCount + reportCellError(cellErrorsError, c8Note210, xRowNum, xDocDescriptor.columnStartDate, cellErrorSeverity, cellErrorText)
bypassSeqCheck = True
Else
startDate = bdt.YMD(bdt.DateValueLoose(BWordNormaliseText(xTableAsArray(xRowNum, colNum))))
End If
Case xDocDescriptor.columnStartTime
zString = BWordNormaliseText(xTableAsArray(xRowNum, colNum))
If Len(zString) = 0 Then
If BBitIsSet(colNum, xDocDescriptor.mandatoryColumns) Then
bypassSeqCheck = True
End If
Else
If IsEmpty(bdt.TimeValueLoose(zString)) Then
errorCount = errorCount + reportCellError(cellErrorsError, c8Note220, xRowNum, xDocDescriptor.columnStartTime, cellErrorSeverity, cellErrorText)
bypassSeqCheck = True
Else
startTime = bdt.TimeValueLoose(zString)
End If
End If
Case xDocDescriptor.columnEndDate
zString = BWordNormaliseText(xTableAsArray(xRowNum, colNum))
If Len(zString) = 0 Then
If BBitIsSet(colNum, xDocDescriptor.mandatoryColumns) Then
bypassSeqCheck = True
End If
Else
If IsEmpty(bdt.DateValueLoose(zString)) Then
errorCount = errorCount + reportCellError(cellErrorsError, c8Note210, xRowNum, xDocDescriptor.columnEndDate, cellErrorSeverity, cellErrorText)
bypassSeqCheck = True
Else
endDate = bdt.YMD(bdt.DateValueLoose(zString))
End If
End If
Case xDocDescriptor.columnEndTime
zString = BWordNormaliseText(xTableAsArray(xRowNum, colNum))
If Len(zString) = 0 Then
If BBitIsSet(colNum, xDocDescriptor.mandatoryColumns) Then
bypassSeqCheck = True
End If
Else
If IsEmpty(bdt.TimeValueLoose(zString)) Then
errorCount = errorCount + reportCellError(cellErrorsError, c8Note220, xRowNum, xDocDescriptor.columnEndTime, cellErrorSeverity, cellErrorText)
bypassSeqCheck = True
Else
endTime = bdt.TimeValueLoose(zString)
End If
End If
End Select
Next colNum
If bypassSeqCheck Then GoTo bypassSequenceCheck
startColour = cellErrorsNone
endColour = cellErrorsNone
If Len(startTime) = 0 Then startTimeTemp = "00:00" Else startTimeTemp = startTime
If Len(endDate) = 0 Then endDateTemp = startDate Else endDateTemp = endDate
If Len(endTime) = 0 Then endTimeTemp = "99:99" Else endTimeTemp = endTime
If (startDate & startTimeTemp) > (endDateTemp & endTimeTemp) Then
startColour = cellErrorsWarning
endColour = cellErrorsError
errorCount = errorCount + 1
errorText = c8Note230
GoTo setDateTimeColours
End If
If Len(lastCheckedEvent(0)) = 0 Then
lastCheckedEvent(0) = startDate
lastCheckedEvent(1) = startTime
lastCheckedEvent(2) = endDate
lastCheckedEvent(3) = endTime
End If
Call BBitSet(checkDateBit, eventGranularity, True)
Call BBitSet(checkTimeBit, eventGranularity, xDocDescriptor.columnStartTime > 0)
If sortOrder = c8SortOrderAscending Then
goodOrder = checkEventOrder(lastCheckedEvent(0), lastCheckedEvent(1), startDate, startTime, eventGranularity)
Else
goodOrder = checkEventOrder(startDate, startTime, lastCheckedEvent(0), lastCheckedEvent(1), eventGranularity)
End If
If goodOrder Then
If lastCheckedEvent(0) = startDate Then
If Len(startTime) <> 0 Then lastCheckedEvent(1) = startTime
Else
lastCheckedEvent(0) = startDate
lastCheckedEvent(1) = startTime
lastCheckedEvent(2) = endDate
lastCheckedEvent(3) = endTime
End If
Else
startColour = cellErrorsWarning
errorCount = errorCount + 1
errorText = c8Note240
GoTo setDateTimeColours
End If
If xDocDescriptor.columnEndDate + xDocDescriptor.columnEndTime = 0 Then GoTo setDateTimeColours
Call BBitSet(checkDateBit, eventGranularity, xDocDescriptor.columnEndDate > 0)
Call BBitSet(checkTimeBit, eventGranularity, xDocDescriptor.columnEndTime > 0)
If sortOrder = c8SortOrderAscending Then
goodOrder = checkEventOrder(lastCheckedEvent(2), lastCheckedEvent(3), endDate, endTime, eventGranularity)
Else
goodOrder = checkEventOrder(endDate, endTime, lastCheckedEvent(2), lastCheckedEvent(3), eventGranularity)
End If
If goodOrder Then
If lastCheckedEvent(2) = endDate Then
If Len(endTime) <> 0 Then lastCheckedEvent(3) = endTime
Else
lastCheckedEvent(2) = endDate
lastCheckedEvent(3) = endTime
End If
Else
startColour = cellErrorsWarning
endColour = cellErrorsWarning
errorCount = errorCount + 1
errorText = c8Note250
GoTo setDateTimeColours
End If
setDateTimeColours:
cellErrorSeverity(xRowNum, xDocDescriptor.columnStartDate) = startColour
cellErrorText(xRowNum, xDocDescriptor.columnStartDate) = errorText
If xDocDescriptor.columnStartTime > 0 Then cellErrorSeverity(xRowNum, xDocDescriptor.columnStartTime) = startColour
If xDocDescriptor.columnEndDate > 0 Then cellErrorSeverity(xRowNum, xDocDescriptor.columnEndDate) = endColour
If xDocDescriptor.columnEndTime > 0 Then cellErrorSeverity(xRowNum, xDocDescriptor.columnEndTime) = endColour
bypassSequenceCheck:
CheckDateTime = errorCount
End Function
Function checkEventOrder(ByVal xDateLower As String, ByVal xTimeLower As String, ByVal xDateHigher As String, ByVal xTimeHigher As String, xGranularity As Long) As Boolean
Dim out As Boolean
If Len(xDateLower) = 0 And BBitIsSet(checkDateBit, xGranularity) Then xDateLower = "00000000"
If Len(xTimeLower) = 0 And BBitIsSet(checkTimeBit, xGranularity) Then xTimeLower = "00:00"
If Len(xDateHigher) = 0 And BBitIsSet(checkDateBit, xGranularity) Then xDateHigher = "99999999"
If Len(xTimeHigher) = 0 And BBitIsSet(checkTimeBit, xGranularity) Then xTimeHigher = "99:99"
If xDateLower & xTimeLower > xDateHigher & xTimeHigher Then
out = False
Else
out = True
End If
checkEventOrder = out
End Function
Function CheckCellCountInTable(xTable As table, xDocDescriptor As clsDocDescriptor) As Boolean
Dim out As Boolean
Dim R As row
If xTable.Uniform Then
If xTable.rows(1).Cells.count = xDocDescriptor.columnCount Then
out = True
End If
Else
out = True
For Each R In xTable.rows
If R.Cells.count <> xDocDescriptor.columnCount Then
out = False
Exit For
End If
Next R
End If
CheckCellCountInTable = out
End Function
Function CheckForListsInTable(xTable As Variant) As Boolean
CheckForListsInTable = BWordTableContainsLists(xTable)
End Function
Sub goToNote(note As Long)
If note > -1 Then
noteCurrent = note
If cursorInErrorSection(ThisDocument) Then
Application.screenUpdating = False
Selection.GoTo what:=wdGoToSection, which:=wdGoToAbsolute, name:="1"
Application.screenUpdating = True
End If
Selection.GoTo what:=wdGoToEndnote, which:=wdGoToAbsolute, count:=note
Else
Call navButtonsDisable
End If
End Sub
Sub firstError()
Call goToNote(noteLowest(ThisDocument))
End Sub
Sub previousError()
Call goToNote(notePrevious(ThisDocument))
End Sub
Sub nextError()
Call goToNote(noteNext(ThisDocument))
End Sub
Sub lastError()
Call goToNote(noteHighest(ThisDocument))
End Sub
Function noteLowest(doc As Document) As Long
Dim note As Endnote
Dim i As Long
i = -1
For Each note In doc.Endnotes
If Left$(note.Range.text, 3) = "c8n" Then
i = note.index
Exit For
End If
Next note
noteLowest = i
End Function
Function noteHighest(doc As Document) As Long
Dim note As Endnote
Dim i As Long
i = -1
For Each note In doc.Endnotes
If Left$(note.Range.text, 3) = "c8n" Then
i = note.index
End If
Next note
noteHighest = i
End Function
Function notePrevious(doc As Document) As Long
Dim note As Endnote
Dim i As Long: Dim j As Long
If noteCurrent = noteLowest(doc) Then
i = noteHighest(doc)
Else
i = -1
For j = doc.Endnotes.count To 1 Step -1
Set note = doc.Endnotes(j)
If Left$(note.Range.text, 3) = "c8n" Then
i = note.index
If cursorInErrorSection(doc) Then
If i < noteCurrent Then
GoTo noteFound
End If
Else
If note.Reference.Start < Selection.Start Then
GoTo noteFound
End If
End If
End If
Next j
End If
noteFound:
notePrevious = i
End Function
Function noteNext(doc As Document) As Long
Dim note As Endnote
Dim i As Long
If noteCurrent = noteHighest(doc) Then
i = noteLowest(doc)
Else
i = -1
For Each note In doc.Endnotes
If Left$(note.Range.text, 3) = "c8n" Then
i = note.index
If cursorInErrorSection(doc) Then
If i > noteCurrent Then
GoTo noteFound
End If
Else
If note.Reference.Start > Selection.Start Then
GoTo noteFound
End If
End If
End If
Next note
End If
noteFound:
noteNext = i
End Function
Function cursorInErrorSection(doc As Document) As Boolean
cursorInErrorSection = (Selection.Start >= getTablesEnd(doc) Or Selection.Information(wdInEndnote))
End Function
Sub errorSectionSetup(xDoc As Document, Optional xDuplicatesList As Boolean = False)
Dim R As Range
Dim errorSectionStart As Long
Dim errorTextStart As Long
Dim heading As String
Dim text1 As String
Dim text2 As String
If DocHasTextAfterTables(xDoc) Then Call errorSectionCleanup(xDoc)
Set R = xDoc.Range
R.Collapse direction:=wdCollapseEnd
R.InsertBreak (wdPageBreak)
R.Collapse direction:=wdCollapseEnd
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
errorSectionStart = R.End
xDoc.Bookmarks.add c8BookmarkNameErrorSection, xDoc.Range(errorSectionStart, errorSectionStart)
If xDuplicatesList Then
heading = errorSectionDuplicatesHeading
text1 = ""
text2 = "Double-click on the box with a cross to go to the duplicate row."
Else
heading = errorSectionHeading
text1 = "Each error has a reference number (eg c8n100). You can use this to look up" & " more information about the error in the Messages section of the 'Using Chronolator Documents' manual."
text2 = "Double-click on the box with a cross to go to the error."
End If
R.InsertAfter text:=heading
R.Style = wdStyleHeading1
R.InsertParagraphAfter
R.Collapse direction:=wdCollapseEnd
errorTextStart = R.Start
R.Style = wdStyleNormal
R.InsertAfter text:=text1
R.InsertParagraphAfter
R.InsertAfter text:=text2
R.InsertParagraphAfter
Set R = xDoc.Range(errorSectionStart, R.End)
R.Font.Reset
Set R = xDoc.Range(errorSectionStart, R.End)
R.Shading.BackgroundPatternColor = wdColorLightTurquoise
Set R = xDoc.Range(errorTextStart, R.End)
With R.Font
.Size = 10
.Italic = True
.Bold = True
End With
R.Collapse direction:=wdCollapseEnd
R.InsertAfter text:="(Do not write any text in this part of the document as it will be lost" & " the next time Chronolator finds no errors or duplicates)."
With R.Font
.Size = 10
.Italic = True
.Bold = True
End With
R.Shading.BackgroundPatternColor = wdColorLightGreen
End Sub
Sub errorSectionCleanup(xDoc As Document)
Dim errorSectionStart As Long
Dim targetRange As Range
errorSectionStart = getTablesEnd(xDoc)
If xDoc.Content.End > errorSectionStart Then
Set targetRange = xDoc.Range(errorSectionStart, xDoc.Range.End)
targetRange.Style = wdStyleNormal
targetRange.Delete
End If
End Sub
Function getTablesEnd(xDoc As Document) As Long
Dim docDescriptor As clsDocDescriptor
Dim tablesfound As Variant
Set docDescriptor = New clsDocDescriptor
docDescriptor.getDetails xDoc
tablesfound = GetTables(doc:=xDoc, heads:=BuildHeadersArray(docDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tablesfound) Then
getTablesEnd = xDoc.Content.End
Else
getTablesEnd = xDoc.Content.tables(tablesfound(UBound(tablesfound))).Range.End
End If
End Function
Sub gotoErrorList()
On Error GoTo bookmarkNotFound
Selection.GoTo what:=wdGoToBookmark, name:=c8BookmarkNameErrorSection
Exit Sub
bookmarkNotFound:
Dim target As Long
target = getTablesEnd(ThisDocument) + 2
ThisDocument.Bookmarks.add c8BookmarkNameErrorSection, ThisDocument.Range(target, target)
Resume
End Sub
Function createErrorText(xErrMsg As Variant) As String
createErrorText = "c8n" & Left$(xErrMsg, 3) & ":" & " " & Mid$(xErrMsg, 4)
End Function
Sub markNestedCells(xTable As Variant, xRanges As Variant)
Dim i As Long
Dim noteRange As Range
With progressBar
.AddProgress (0.4 * BWordTableRowCount(xTable) / pbRowsToCheck)
.Caption2 = c8PBHighlightingNested
End With
For i = 0 To UBound(xRanges)
Set noteRange = xRanges(i)
DeleteC8Endnotes noteRange
noteRange.Shading.BackgroundPatternColor = c8ColorErrorsError
noteRange.Collapse direction:=wdCollapseStart
xTable.Parent.Endnotes.add Range:=noteRange, Reference:=errorRef, text:=createErrorText(c8Note135)
Next i
With progressBar
.AddProgress (0.2 * BWordTableRowCount(xTable) / pbRowsToCheck)
End With
End Sub
Function markVerticallyMergedCells(xTable As Variant) As Long
Dim xRow As Long
Dim xCol As Long
Dim xDelim As Long
Dim tabArray() As String
Dim i As Long
Dim noteRange As Range
With progressBar
.AddProgress (0.4 * BWordTableRowCount(xTable) / pbRowsToCheck)
.Caption2 = c8PBVMIdentify
End With
tabArray = BWordTableGetVerticallyMergedCells(xTable)
If progressBar.userCancelled Then
tableCheckCancelled = True
Exit Function
End If
DeleteC8Endnotes xTable.Range
With progressBar
.AddProgress (0.4 * BWordTableRowCount(xTable) / pbRowsToCheck)
.Caption2 = c8PBVMHighlight
End With
For i = 1 To UBound(tabArray)
xDelim = InStr(tabArray(i), ",")
xRow = Left$(tabArray(i), xDelim - 1)
xCol = Right$(tabArray(i), Len(tabArray(i)) - xDelim)
Set noteRange = xTable.Cell(xRow, xCol).Range
noteRange.Shading.BackgroundPatternColor = c8ColorErrorsError
noteRange.Collapse direction:=wdCollapseStart
xTable.Parent.Endnotes.add Range:=noteRange, Reference:=errorRef, text:=createErrorText(c8Note130)
Next i
markVerticallyMergedCells = UBound(tabArray)
With progressBar
.AddProgress (0.2 * BWordTableRowCount(xTable) / pbRowsToCheck)
End With
End Function
Function tablesHash(xTablesFound As Variant, xDoc As Document, Optional xColumn As Long = 0) As String
Dim i As Long
Dim t As table
Dim rowIndex As Long
Dim maxRowsToCheck As Long
Dim stepSize As Long
Dim zString As String
Dim hashCodeMaker As clsSHA256
Set hashCodeMaker = New clsSHA256
For i = 0 To UBound(xTablesFound)
progressBar.Caption3 = progressBar.Caption3 & " ."
Set t = xDoc.Content.tables(xTablesFound(i))
If xColumn > 0 Then
maxRowsToCheck = 60000 / t.rows.count
stepSize = t.rows.count \ maxRowsToCheck + 1
zString = zString & t.rows.count
On Error GoTo accessError
For rowIndex = 1 To t.rows.count Step stepSize
zString = zString & t.rows(rowIndex).Cells(thisDocDescriptor.columnSource).Range.text
Next
On Error GoTo 0
Else
zString = zString & t.Range.text
End If
Next
progressBar.Caption3 = progressBar.Caption3 & " ."
If xColumn > 0 Then zString = personaliseString(zString)
progressBar.Caption3 = progressBar.Caption3 & " ."
tablesHash = hashCodeMaker.SHA256(zString)
progressBar.Caption3 = ""
Exit Function
accessError:
zString = zString & Err.Number
Resume Next
End Function
Attribute VB_Name = "c8MC_DocumentCreate"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Sub CompositeChronologyCreate()
Dim newDocument As Document
Dim newDocDescriptor As clsDocDescriptor
Dim newDocSaved As Boolean
Dim docSave As String
Dim saveStatus As Boolean
Set newDocument = ThisDocument
Set newDocDescriptor = New clsDocDescriptor
newDocDescriptor.initialise xDefaults:=False
newDocDescriptor.docType = c8CompositeChronologyNew
newDocDescriptor.setDetails xDoc:=newDocument
saveStatus = ThisDocument.Saved
docSave = thisDocSaver.documentSave(ThisDocument)
newDocSaved = False
ThisDocument.Range.text = ""
If c8FileSaveAs(xDoc:=newDocument, xSuggestedName:=c8Name & " composite chronology") Then
ThisDocument.activate
CommandBars(c8Name).Delete
thisDocGlossaryAdmin.clear
thisDocGlossaryUser.clear
thisDocGlossaryMerged.clear
newDocSaved = True
Else
thisDocSaver.documentRestore xFrom:=docSave, xTo:=ThisDocument.name, xRestoreStatus:=saveStatus
thisDocDescriptor.setDetails xDoc:=ThisDocument
End If
thisDocSaver.closeSingle docSave
If newDocSaved Then
Call trackedChangesTurnOff(xDoc:=Documents(BWordGetNumericDocumentIndex(fileSavedAsFullName)))
Call runAutoOpen(xDocFullName:=fileSavedAsFullName)
Set newDocument = Documents(BWordGetNumericDocumentIndex(fileSavedAsFullName))
On Error GoTo bug92check
newDocument.Save
On Error GoTo 0
End If
Exit Sub
bug92check:
If Err.Number = 5487 Then
Call bug92Fix(newDocument)
Else
showMessage c8Msg6000, msgSuffix2:="CompositeChronologyCreate: Error " & Err.Number & " (" & Err.Description & ")"
End If
End Sub
Sub TableWriteAtEnd()
If trackedChangesLurking(ThisDocument) Then
If trackedChangesOffDialog(ThisDocument) Then
Else
Call showMessage(c8Msg5231, msgPrefix1:="New Table", msgPrefix2:="<" & ThisDocument.name)
Exit Sub
End If
End If
Call TableWrite(xDoc:=ThisDocument, xDetails:=thisDocDescriptor, xAddSection:=False)
End Sub
Attribute VB_Name = "c8MC_DocumentFormat"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Dim autoFitSave() As WdAutoFitBehavior
Sub FormatDates(Optional xFormatDate As String = c8DateFormatStandard1, Optional xShowSuccessMessage As Boolean = True)
Dim R As row
Dim c As Cell
Dim i As Long
Dim tablesfound As Variant
Dim curTable As table
Dim rCount As Long
Dim rCounter As Long
Dim performanceOptionsStore() As Variant
Dim sw1 As clsStopWatch
Dim lastWhenColumn As Long
Dim docSave As String
Dim saveStatus As Boolean
performanceOptionsStore = BWordPerformanceOptionsSet()
saveStatus = ThisDocument.Saved
Set sw1 = New clsStopWatch
With progressBar
.Reset
.title = "Format Dates"
.Caption1 = c8PBAnalysingTables
.show
.AddProgress 0.025
End With
If trackedChangesLurking(ThisDocument) Then
If trackedChangesOffDialog(ThisDocument) Then
Else
progressBar.finish
Call showMessage(c8Msg5231, msgPrefix1:="Format Dates", msgPrefix2:="<" & ThisDocument.name)
GoTo finish
End If
End If
tablesfound = GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor))
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015)
GoTo finish
End If
If UBound(tablesfound) > 0 Then
sw1.Halt
Select Case mergeMultipleTablesPrompt("Format Dates")
Case "MergeFailed"
progressBar.finish
GoTo finish
Case "Merge"
tablesfound = GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor))
Case "Don't Merge"
progressBar.repaint
Case "Cancel"
progressBar.finish
GoTo finish
End Select
frmMessage.Hide
sw1.Start
End If
docSave = thisDocSaver.documentSave(ThisDocument)
Call setProgressBarCounters(ThisDocument, tablesfound)
progressBar.AddProgress 0.025
ppP_LastDateFormatSet xFormatDate
ThisDocument.Styles("Endnote Reference").Font.Hidden = True
Application.screenUpdating = False
sw1.Start
If thisDocDescriptor.columnEndTime > 0 Then
lastWhenColumn = thisDocDescriptor.columnEndTime
Else
If thisDocDescriptor.columnEndDate > 0 Then
lastWhenColumn = thisDocDescriptor.columnEndDate
Else
If thisDocDescriptor.columnStartTime > 0 Then
lastWhenColumn = thisDocDescriptor.columnStartTime
Else
lastWhenColumn = thisDocDescriptor.columnStartDate
End If
End If
End If
For i = 0 To UBound(tablesfound)
Set curTable = ThisDocument.tables(tablesfound(i))
rCount = curTable.rows.count
rCounter = 0
progressBar.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
progressBar.Caption2 = ""
progressBar.Caption3 = ""
For Each R In curTable.rows
rCounter = rCounter + 1
If rCounter = 1 Then GoTo nextRow
If progressBar.userCancelled Then
GoTo formatCancelled
End If
With progressBar
.AddProgress (0.9 / pbRowsToCheck)
.Caption2 = c8PBFormattingRow & rCounter & c8PBOf & rCount
End With
For Each c In R.Cells
If c.columnIndex > lastWhenColumn Then GoTo nextRow
If c.columnIndex = thisDocDescriptor.columnStartDate Or c.columnIndex = thisDocDescriptor.columnEndDate Then
Call SetDate(c, xFormatDate)
Else
If c.columnIndex = thisDocDescriptor.columnStartTime Or c.columnIndex = thisDocDescriptor.columnEndTime Then
Call SetTime(c)
End If
End If
Next c
nextRow:
Next R
Next i
ThisDocument.Styles("Endnote Reference").Font.Hidden = False
ppStats_Update ppStats_FormatDates, pbTablesToCheck, pbRowsToCheck, sw1.value
If xShowSuccessMessage Then
Application.screenUpdating = True
Application.ScreenRefresh
Call showMessage(c8Msg1300)
End If
GoTo endFunction
formatCancelled:
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
progressBar.finish
Call showMessage(c8Msg3020)
endFunction:
progressBar.finish
Call thisDocSaver.closeSingle(docSave)
Application.screenUpdating = True
ThisDocument.UndoClear
finish:
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Sub
Sub FormatDatesStandard1PlusDayOfWeek()
FormatDates xFormatDate:=c8DateFormatStandard1PlusDayOfWeek
End Sub
Sub FormatDatesISO()
FormatDates xFormatDate:=c8DateFormatISO
End Sub
Sub FormatDatesISOPlusDayOfWeek()
FormatDates xFormatDate:=c8DateFormatISOPlusDayOfWeek
End Sub
Function sortTables(xOrder As WdSortOrder, Optional xShowCompletionMessage As Boolean = True, Optional xMergeMultipleTablesPrompt As Boolean = True, Optional xProgressTitle As String = c8SortTables) As Boolean
Dim tablesfound As Variant
Dim curTable As table
Dim sortArgs(4, 2) As Variant
Dim highestArg As Long
Dim i As Long
Dim j As Long
Dim lang As Long
Dim shortMessageOverride As String
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
With progressBar
.title = xProgressTitle
If xProgressTitle = c8SortTables Then
.Reset
.title = c8SortTables
.Caption1 = c8PBAnalysingTables
.show enableCancel:=False
.AddProgress 0.35
End If
End With
DoEvents
If trackedChangesLurking(ThisDocument) Then
If trackedChangesOffDialog(ThisDocument) Then
Else
progressBar.finish
Call showMessage(c8Msg5231, msgPrefix1:="Sort", msgPrefix2:="<" & ThisDocument.name)
GoTo finish
End If
End If
tablesfound = GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor))
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015)
GoTo finish
End If
If UBound(tablesfound) > 0 And xMergeMultipleTablesPrompt Then
Select Case mergeMultipleTablesPrompt("Sort Tables")
Case "MergeFailed"
progressBar.finish
GoTo finish
Case "Merge"
shortMessageOverride = "Tables merged and sorted"
tablesfound = GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor))
Case "Don't Merge"
shortMessageOverride = "Tables sorted individually"
progressBar.repaint
frmMessage.Hide
Case "Cancel"
progressBar.finish
GoTo finish
End Select
End If
Call setProgressBarCounters(ThisDocument, tablesfound)
sortArgs(0, 0) = thisDocDescriptor.columnStartDate
sortArgs(0, 1) = wdSortFieldDate
sortArgs(0, 2) = xOrder
For i = 1 To 4
For j = 0 To 2
sortArgs(i, j) = sortArgs(0, j)
Next j
Next i
highestArg = 0
If thisDocDescriptor.columnSequence > 0 Then
highestArg = highestArg + 1
sortArgs(highestArg, 0) = thisDocDescriptor.columnSequence
sortArgs(highestArg, 1) = wdSortFieldNumeric
End If
If thisDocDescriptor.columnStartTime > 0 Then
highestArg = highestArg + 1
sortArgs(highestArg, 0) = thisDocDescriptor.columnStartTime
sortArgs(highestArg, 1) = wdSortFieldAlphanumeric
End If
If thisDocDescriptor.columnEndDate > 0 Then
highestArg = highestArg + 1
sortArgs(highestArg, 0) = thisDocDescriptor.columnEndDate
sortArgs(highestArg, 1) = wdSortFieldDate
End If
If thisDocDescriptor.columnEndTime > 0 Then
highestArg = highestArg + 1
sortArgs(highestArg, 0) = thisDocDescriptor.columnEndTime
sortArgs(highestArg, 1) = wdSortFieldAlphanumeric
End If
For i = 0 To UBound(tablesfound)
Set curTable = ThisDocument.tables(tablesfound(i))
On Error Resume Next
If xProgressTitle = c8SortTables Then progressBar.Caption1 = c8PBSortingTable & i + 1 & " of " & pbTablesToCheck
lang = BGetUserDefaultLangID
If highestArg >= 3 Then
Call curTable.Sort(True, sortArgs(2, 0), sortArgs(1, 1), sortArgs(1, 2), sortArgs(3, 0), sortArgs(2, 1), sortArgs(2, 2), sortArgs(4, 0), sortArgs(3, 1), sortArgs(3, 2), LanguageID:=lang)
End If
Call curTable.Sort(True, sortArgs(0, 0), sortArgs(0, 1), sortArgs(0, 2), sortArgs(1, 0), sortArgs(1, 1), sortArgs(1, 2), sortArgs(2, 0), sortArgs(2, 1), sortArgs(2, 2), LanguageID:=lang)
If xProgressTitle = c8SortTables Then progressBar.AddProgress (0.65 / pbTablesToCheck)
Next i
If xProgressTitle = c8SortTables Then progressBar.finish
If Not xShowCompletionMessage Then GoTo noMessage
If thisDocDescriptor.columnSequence = 0 Then
Call showMessage(c8Msg1200, shortMsg:=shortMessageOverride)
Else
Call showMessage(c8Msg1201, shortMsg:=shortMessageOverride)
End If
noMessage:
ThisDocument.UndoClear
sortTables = True
finish:
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Function
Sub sortTablesAscending()
If sortTables(xOrder:=wdSortOrderAscending) Then thisDocDescriptor.sortOrder = c8SortOrderAscending
End Sub
Sub sortTablesDescending()
If sortTables(xOrder:=wdSortOrderDescending) Then thisDocDescriptor.sortOrder = c8SortOrderDescending
End Sub
Function sortTablesAsDescriptor(Optional xShowCompletionMessage As Boolean = False, Optional xMergeMultipleTablesPrompt As Boolean = True, Optional xProgressTitle As String) As Boolean
Dim out As Boolean
If thisDocDescriptor.sortOrder = c8SortOrderDescending Then
out = sortTables(xOrder:=wdSortOrderDescending, xShowCompletionMessage:=xShowCompletionMessage, xMergeMultipleTablesPrompt:=xMergeMultipleTablesPrompt, xProgressTitle:=xProgressTitle)
Else
out = sortTables(xOrder:=wdSortOrderAscending, xShowCompletionMessage:=xShowCompletionMessage, xMergeMultipleTablesPrompt:=xMergeMultipleTablesPrompt, xProgressTitle:=xProgressTitle)
End If
sortTablesAsDescriptor = out
End Function
Sub clearBlankRowsAtStart(tabl As table)
Dim bugControl As Long
Dim dataRow As row
bugControl = 0
For Each dataRow In tabl.rows
bugControl = bugControl + 1
If bugControl = 1 Then GoTo nextRow
If BWordIsBlankRow(dataRow) Then
dataRow.Delete
Else
Exit For
End If
nextRow:
Next dataRow
End Sub
Sub SetDate(c As Cell, xFormatDate As Variant)
BWordSetCellText xCell:=c, xTextDesired:=format$(bdt.DateValueLoose(BWordGetCellText(c)), xFormatDate)
End Sub
Sub SetTime(c As Cell)
BWordSetCellText xCell:=c, xTextDesired:=bdt.TimeValueLoose(BWordGetCellText(c))
End Sub
Public Sub c8TablesAutoFitContents()
c8TablesAutoFit wdAutoFitContent
End Sub
Public Sub c8TablesAutoFitWindow()
c8TablesAutoFit wdAutoFitWindow
End Sub
Public Sub c8TablesSplitTable()
Dim i As Long
Dim tableIndex As Long
Dim tabl As table
tableIndex = BWordRangeTableIndex(Selection.Range, ThisDocument)
If tableIndex > 0 Then
Set tabl = ThisDocument.tables(tableIndex)
If isC8Table(tabl, xHeads:=BuildHeadersArray(thisDocDescriptor)) And Not (BWordTableHasVerticallyMergedCells(tabl)) Then
If CheckCellCountInTable(tabl, thisDocDescriptor) Then
If Selection.Information(wdStartOfRangeRowNumber) > 1 Then
Selection.InsertRowsAbove
For i = 1 To Selection.rows(1).Cells.count
Selection.rows(1).Cells(i).Range.text = thisDocDescriptor.columnHeading(i)
Next i
Selection.SplitTable
setTableCharacteristics ThisDocument.tables(tableIndex + 1)
ThisDocument.UndoClear
End If
End If
End If
End If
End Sub
Public Sub c8TablesAutoFit(fit As WdAutoFitBehavior, Optional keepDocState As Boolean = False)
Dim tablesfound As Variant
Dim i As Long
Dim zTable As table
Dim docSaved As Boolean
docSaved = ThisDocument.Saved
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor))
If IsEmpty(tablesfound) Then Exit Sub
ReDim autoFitSave(UBound(tablesfound))
For i = 0 To UBound(tablesfound)
Set zTable = ThisDocument.Content.tables(tablesfound(i))
autoFitSave(i) = c8TableAutoFit(zTable, fit)
Next i
If keepDocState Then ThisDocument.Saved = docSaved
End Sub
Public Sub c8TablesAutoFitRestore()
Dim tablesfound As Variant
Dim i As Long
Dim zTable As table
Dim docSaved As Boolean
docSaved = ThisDocument.Saved
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor))
If IsEmpty(tablesfound) Then Exit Sub
For i = 0 To UBound(tablesfound)
Set zTable = ThisDocument.Content.tables(tablesfound(i))
Call c8TableAutoFit(zTable, autoFitSave(i))
Next i
ThisDocument.Saved = docSaved
End Sub
Public Function c8TableAutoFit(xTable As table, fit As WdAutoFitBehavior) As WdAutoFitBehavior
c8TableAutoFit = BWordTableAutoFitBehaviour(xTable)
xTable.AutoFitBehavior fit
End Function
Attribute VB_Name = "c8MC_DocumentMerge"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Dim infoSourcePrefix As String
Dim duplicatesReport As Document
Dim sourceSourcePrefixes As clsGlossary
Dim deleteSequenceColumnFromImportedTables As Boolean
Dim addSequenceColumnToImportedTables As Boolean
Dim deleteSequenceColumnFromThisDocument As Boolean
Dim addSequenceColumnToThisDocument As Boolean
Dim userCancelled As Boolean
Dim seqHeadingDiffers As Boolean
Public sourceDocVersion As Single
Public duplicateAbbreviationsGlossary As clsGlossary
Public duplicateAbbreviationsIndices As String
Sub ImportTables(Optional setSourcePrefix As Boolean = True)
Dim importSuccess As Boolean
Dim sourceDoc As Document
Dim sourceGlossaryAdmin As clsGlossary
Dim sourceGlossaryUser As clsGlossary
Dim sourceProcessingParameters As clsGlossary
Dim sourceDocDescriptor As clsDocDescriptor
Dim zGE As String
Dim zGK As String
Dim zGI As String
Dim zGP As String
Dim newGK As String
Dim newGI As String
Dim newGP As String
Dim i As Long
Dim msgsuf As String
Dim tablesfound As Variant
Dim performanceOptionsStore() As Variant
Dim zCount As Long
performanceOptionsStore = BWordPerformanceOptionsSet()
Set sourceGlossaryAdmin = New clsGlossary
Set sourceGlossaryUser = New clsGlossary
Set sourceProcessingParameters = New clsGlossary
Set sourceDocDescriptor = New clsDocDescriptor
importSuccess = False
If trackedChangesLurking(ThisDocument) Then
If trackedChangesOffDialog(ThisDocument) Then
Else
Call showMessage(c8Msg5231, msgPrefix1:="Import", msgPrefix2:="<" & ThisDocument.name)
GoTo ImportTablesEnd
End If
End If
Call disableAutomacs
If thisDocDescriptor.docType = c8CompositeChronologyNew Then
Else
If checkDescriptor(thisDocDescriptor, xShowMessage:=True, xErrorMessage:=c8Msg1033) Then
Else
GoTo ImportTablesEnd
End If
End If
userCancelled = False
If Dialogs(wdDialogFileOpen).show <> -1 Then
GoTo ImportTablesEnd
Else
Set sourceDoc = ActiveDocument
Set sourceSourcePrefixes = New clsGlossary
sourceDoc.ActiveWindow.Visible = False
End If
If sourceDoc.fullName = ThisDocument.fullName Then
GoTo ImportTablesEnd
End If
If trackedChangesTurnOff(sourceDoc) Then
Else
Call showMessage(c8Msg5231, msgPrefix1:="Import", msgPrefix2:="<" & sourceDoc.name)
GoTo closeSourceDoc
End If
Set duplicatesReport = Nothing
sourceDocDescriptor.getDetails xDoc:=sourceDoc
If IsNumeric(sourceDocDescriptor.version) Then
sourceDocVersion = CSng(sourceDocDescriptor.version)
If sourceDocVersion > CSng(thisDocDescriptor.version) Then
If CSng(thisDocDescriptor.version) < CSng(sourceDocDescriptor.versionLowestCanImportInto) Then
msgsuf = vbNewLine & vbTab & "This document version: " & thisDocDescriptor.version & vbNewLine & vbTab & "Document for Import requires version: " & sourceDocDescriptor.versionLowestCanImportInto
Call showMessage(c8Msg1020, msgSuffix1:=msgsuf)
GoTo closeSourceDoc
End If
End If
Else
sourceDocVersion = 0
End If
With progressBar
.Reset
.title = "Import tables"
.Caption1 = c8PBAnalysingTables
.show enableCancel:=False
.AddProgress 0.005
End With
If thisDocDescriptor.docType = c8CompositeChronologyNew Then
thisDocDescriptor.getDetails xDoc:=sourceDoc
thisDocDescriptor.docType = c8CompositeChronologyNew
tablesfound = GetTables(sourceDoc, BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
Else
tablesfound = GetTablesExtended(sourceDoc, BuildHeadersArray(thisDocDescriptor))
If userCancelled Then GoTo closeSourceDoc
End If
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015, msgSuffix1:=" " & sourceDoc.name)
GoTo closeSourceDoc
End If
For i = 0 To UBound(tablesfound)
If BWordTableHasVerticallyMergedCells(sourceDoc.tables(tablesfound(i))) Then
Call showMessage(c8Msg3103, msgPrefix2:="<" & sourceDoc.name & ">")
GoTo closeSourceDoc
End If
If BWordTableHasNestedTable(sourceDoc.tables(tablesfound(i))) Then
Call showMessage(c8Msg3113, msgPrefix2:="<" & sourceDoc.name & ">")
GoTo closeSourceDoc
End If
If CheckCellCountInTable(sourceDoc.tables(tablesfound(i)), thisDocDescriptor) Or CheckCellCountInTable(sourceDoc.tables(tablesfound(i)), sourceDocDescriptor) Then
Else
Call showMessage(c8Msg3105, msgPrefix2:="<" & sourceDoc.name & ">")
GoTo closeSourceDoc
End If
Next i
If sourceDocVersion < 3 Then
sourceGlossaryAdmin.loadFromString sourceDocDescriptor.glossaryAdmin
sourceGlossaryUser.loadFromString sourceDocDescriptor.glossaryUser
Else
sourceGlossaryAdmin.loadFromString sourceDocDescriptor.glossaryAdmin, glEncryptor:=thisDocGlossaryEncryptor
sourceGlossaryUser.loadFromString sourceDocDescriptor.glossaryUser, glEncryptor:=thisDocGlossaryEncryptor
sourceSourcePrefixes.loadFromString sourceDocDescriptor.sourcePrefixes
End If
If thisDocDescriptor.docType = c8CompositeChronologyNew Then
If sourceDocVersion = 0 Then
showMessage c8Msg1003
GoTo closeSourceDoc
Else
importSuccess = ImportEntireDocument(sourceDoc, tablesfound, setSourcePrefix:=setSourcePrefix)
End If
If importSuccess Then
thisDocDescriptor.docType = c8CompositeChronologyOld
Call ToolbarCompositeChronologyConvert
Call c8TablesAutoFitContents
If c8LicenceHaveValid Then
Else
If sourceDocVersion >= 3 Then
If licenceGetInternal(sourceDoc) Then
Call licenceSetInternal(ThisDocument, c8LicenceID, c8LicenceOwner, c8LicenceExpiryDate, c8LicenceSingleCaseReference)
End If
End If
End If
End If
Else
importSuccess = ImportTablesOnly(sourceDoc, tablesfound, sourceDocDescriptor, sourceGlossaryAdmin, sourceGlossaryUser, setSourcePrefix:=setSourcePrefix)
End If
If importSuccess Then
Else
GoTo closeSourceDoc
End If
With progressBar
.Caption1 = c8PBLoadingGlossaries
.Caption2 = c8PBUser
End With
zCount = sourceGlossaryUser.count
For i = 1 To zCount
progressBar.Caption3 = i & " of " & zCount
zGE = sourceGlossaryUser.getEntryByIndex(i)
newGK = sourceGlossaryUser.getKey(zGE)
newGI = sourceGlossaryUser.getItem(zGE)
newGP = sourceGlossaryUser.getPrefix(zGE)
If setSourcePrefix Then
If newGP = c8CurrentDocument Then
newGP = ""
Else
newGP = " " & newGP
End If
End If
If thisDocGlossaryUser.containsEntry(newGK, newGI, newGP) Then
Else
thisDocGlossaryUser.add glKey:=newGK, glItem:=newGI, glPrefix:=infoSourcePrefix & newGP, glAllowDupKeys:=True, glAllowDupItems:=True
thisDocGlossaryMerged.add glKey:=newGK, glItem:=newGI, glPrefix:=infoSourcePrefix & newGP, glAllowDupKeys:=True, glAllowDupItems:=True
End If
Next i
With progressBar
.AddProgress 0.02
.Caption2 = c8PBAdministrator
End With
zCount = sourceGlossaryAdmin.count
For i = 1 To zCount
progressBar.Caption3 = i & " of " & zCount
zGE = sourceGlossaryAdmin.getEntryByIndex(i)
zGK = sourceGlossaryAdmin.getKey(zGE)
zGI = sourceGlossaryAdmin.getItem(zGE)
zGP = sourceGlossaryAdmin.getPrefix(zGE)
If thisDocGlossaryAdmin.containsKeyItemPair(zGK, zGI) Then
Else
thisDocGlossaryAdmin.add glKey:=zGK, glItem:=zGI, glPrefix:=infoSourcePrefix & " " & zGP, glAllowDupKeys:=True, glAllowDupItems:=True
thisDocGlossaryMerged.add glKey:=zGK, glItem:=zGI, glPrefix:=infoSourcePrefix & " " & zGP, glAllowDupKeys:=True, glAllowDupItems:=True
End If
Next i
With progressBar
.AddProgress 0.02
.Caption2 = c8PBSourcePrefixes
.Caption3 = ""
End With
zCount = sourceSourcePrefixes.count
If zCount = 0 Then
If setSourcePrefix Then
thisDocSourcePrefixes.add glKey:=BSqueezeSpaces(infoSourcePrefix), glAllowDupKeys:=False, glAllowDupItems:=True
End If
Else
For i = 1 To zCount
progressBar.Caption3 = i & " of " & zCount
zGE = sourceSourcePrefixes.getEntryByIndex(i)
thisDocSourcePrefixes.add glKey:=BSqueezeSpaces(infoSourcePrefix & " " & sourceSourcePrefixes.getKey(zGE)), glItem:="", glAllowDupKeys:=False, glAllowDupItems:=True
Next i
End If
With progressBar
.AddProgress 0.02
.Caption2 = c8PBProcessingParameters
.Caption3 = ""
End With
sourceProcessingParameters.loadFromString sourceDocDescriptor.glossaryProcessing, glEncryptor:=thisDocGlossaryEncryptor
Call mergeProcessingParameters(thisDocProcessingParameters, sourceProcessingParameters)
thisDocDescriptor.glossaryAdmin = thisDocGlossaryAdmin.dumpToString(thisDocGlossaryEncryptor)
thisDocDescriptor.glossaryUser = thisDocGlossaryUser.dumpToString(thisDocGlossaryEncryptor)
thisDocDescriptor.glossaryProcessing = thisDocProcessingParameters.dumpToString(thisDocGlossaryEncryptor)
thisDocDescriptor.sourcePrefixes = thisDocSourcePrefixes.dumpToString()
thisDocDescriptor.setDetails xDoc:=ThisDocument
closeSourceDoc:
On Error Resume Next
sourceDoc.Close savechanges:=wdDoNotSaveChanges
On Error GoTo 0
ImportTablesEnd:
Call enableAutomacs
On Error Resume Next
progressBar.finish
On Error GoTo 0
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
If duplicatesReport Is Nothing Then
ThisDocument.activate
Else
duplicatesReport.activate
End If
If importSuccess Then
Call showMessage(c8Msg1000, msgSuffix1:=" (" & pbTablesToCheck & ")")
Application.StatusBar = "Import complete"
Call buttonStatesSequencing
ThisDocument.UndoClear
Application.ScreenRefresh
On Error Resume Next
ActiveWindow.ScrollIntoView ThisDocument.tables(ThisDocument.tables.count).Range
End If
End Sub
Function ImportEntireDocument(sourceDoc As Document, tablesfound As Variant, Optional setSourcePrefix As Boolean = True) As Boolean
Dim i As Long
If setSourcePrefix Then
infoSourcePrefix = getSourcePrefix()
If Len(infoSourcePrefix) = 0 Then
ImportEntireDocument = False
Exit Function
End If
Else
infoSourcePrefix = ""
End If
Call thisDocSaver.copyDocument(sourceDoc, ThisDocument)
thisDocDescriptor.getDetails xDoc:=sourceDoc
If CSng(thisDocDescriptor.version) < 3 Then
thisDocDescriptor.version = c8Version
thisDocGlossaryAdmin.loadFromString thisDocDescriptor.glossaryAdmin
thisDocGlossaryMerged.loadFromString thisDocDescriptor.glossaryAdmin
Else
thisDocGlossaryAdmin.loadFromString thisDocDescriptor.glossaryAdmin, glEncryptor:=thisDocGlossaryEncryptor
thisDocGlossaryMerged.loadFromString thisDocDescriptor.glossaryAdmin, glEncryptor:=thisDocGlossaryEncryptor
End If
thisDocGlossaryUser.clear
thisDocDescriptor.glossaryUser = ""
Call setProgressBarCounters(ThisDocument, tablesfound)
For i = 0 To UBound(tablesfound)
progressBar.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
progressBar.Caption2 = ""
progressBar.Caption3 = ""
Call addSourcePrefix(ThisDocument.tables(tablesfound(i)), thisDocDescriptor.columnSource, infoSourcePrefix)
Next i
ImportEntireDocument = True
End Function
Function ImportTablesOnly(sourceDoc As Document, tablesfound As Variant, sourceDocDescriptor As clsDocDescriptor, sourceGlossaryAdmin As clsGlossary, sourceGlossaryUser As clsGlossary, Optional setSourcePrefix As Boolean = True) As Boolean
Dim sourceTable As table
Dim sourceRange As Range
Dim sourceCaseRef As Variant
Dim targetRange As Range
Dim targetCaseRef As Variant
Dim msgsuf As String
Dim retCode As String
Dim i As Long
Dim saveProgress As Single
If sourceDocVersion = 0 Then
GoTo bypassC8Checks
End If
sourceCaseRef = BSqueezeSpaces(sourceDocDescriptor.caseRef)
targetCaseRef = BSqueezeSpaces(thisDocDescriptor.caseRef)
If sourceCaseRef <> targetCaseRef Then
msgsuf = vbNewLine & vbTab & "Composite Chronology: " & targetCaseRef & vbNewLine & vbTab & "Imported Chronology: " & sourceCaseRef
If showMessage(c8Msg1005, msgSuffix1:=msgsuf, button2:="OK", button3:="Cancel") <> "OK" Then
ImportTablesOnly = False
Exit Function
End If
End If
If checkDescriptorMandatoryColumns(sourceDocDescriptor) Then
Else
If showMessage(c8Msg1010, button2:="OK", button3:="Cancel") <> "OK" Then
ImportTablesOnly = False
Exit Function
End If
End If
Call checkGlossaryEntries(sourceGlossaryAdmin, sourceGlossaryUser)
If duplicateAbbreviationsIndices > "" Then
Do
Select Case showMessage(c8Msg1025, button3:="Go to list", button1:="OK", button2:="Cancel")
Case "Go to list"
frmInternalsReport.setDisplay ("Conflicting Definitions")
frmInternalsReport.show
Set duplicatesReport = frmInternalsReport.docCreated
If duplicatesReport Is Nothing Then
Else
showMessage c8Msg1026
ImportTablesOnly = False
Exit Function
End If
Case "Cancel"
ImportTablesOnly = False
Exit Function
Case "OK"
GoTo bypassC8Checks
End Select
Loop
End If
bypassC8Checks:
If setSourcePrefix Then
progressBar.Hide
infoSourcePrefix = getSourcePrefix()
If Len(infoSourcePrefix) = 0 Then
ImportTablesOnly = False
Exit Function
End If
progressBar.show
Else
infoSourcePrefix = ""
End If
saveProgress = progressBar.Progress
If addSequenceColumnToThisDocument Then
If SequenceColumnAdd_AllTables(xHeading:=sourceDocDescriptor.columnHeading(1), xCheckMultipleTables:=False, xPopulate:=BWordTableWriteRowNumbers_None, xCloseProgress:=False) Then
Else
ImportTablesOnly = False
Exit Function
End If
End If
If deleteSequenceColumnFromThisDocument Then
If SequenceColumnDelete_AllTables(xCheckMultipleTables:=False, xCloseProgress:=False) Then
Else
ImportTablesOnly = False
Exit Function
End If
End If
With progressBar
.setTitle "Import tables"
.Progress = saveProgress
End With
Call setProgressBarCounters(sourceDoc, tablesfound)
For i = 0 To UBound(tablesfound)
Set sourceTable = sourceDoc.Content.tables(tablesfound(i))
progressBar.Caption1 = c8PBImportingTable & i + 1 & c8PBOf & pbTablesToCheck & " from " & sourceDoc
Set targetRange = ThisDocument.Range
targetRange.InsertParagraphAfter
targetRange.Collapse direction:=wdCollapseEnd
Set sourceRange = sourceTable.Range
targetRange.FormattedText = sourceRange.FormattedText
If deleteSequenceColumnFromImportedTables Then
progressBar.Caption2 = c8PBDeletingColumn & " from source document"
retCode = sequenceColumnProcessOneTable(targetRange.tables(1), xProcess:=sequenceProcessDelete, xShowProgress:=False)
If IsNumeric(retCode) Then
Else
ImportTablesOnly = False
Exit Function
End If
Else
If addSequenceColumnToImportedTables Then
progressBar.Caption2 = c8PBAddingColumn & " to source document"
retCode = sequenceColumnProcessOneTable(targetRange.tables(1), xProcess:=sequenceProcessAdd, xHeading:=thisDocDescriptor.columnHeading(thisDocDescriptor.columnSequence), xPopulate:=BWordTableWriteRowNumbers_None, xShowProgress:=False)
If IsNumeric(retCode) Then
Else
ImportTablesOnly = False
Exit Function
End If
End If
End If
If seqHeadingDiffers Then targetRange.tables(1).rows(1).Cells(1).Range.text = thisDocDescriptor.columnHeading(1)
Call addSourcePrefix(targetRange.tables(1), thisDocDescriptor.columnSource, infoSourcePrefix)
Next i
ImportTablesOnly = True
End Function
Function GetTablesExtended(sourceDoc As Document, headersArray As Variant) As Variant
Dim tablesfound As Variant
Dim tempDocDescriptor As clsDocDescriptor
Dim sourceDocDescriptor As clsDocDescriptor
deleteSequenceColumnFromImportedTables = False
addSequenceColumnToImportedTables = False
deleteSequenceColumnFromThisDocument = False
addSequenceColumnToThisDocument = False
tablesfound = GetTables(sourceDoc, headersArray, xIncludeVerticallyMerged:=True, xIncludeNested:=True)
Set sourceDocDescriptor = New clsDocDescriptor
sourceDocDescriptor.getDetails sourceDoc
If IsEmpty(tablesfound) Then
If sourceDocVersion = 0 Then
GoTo docHasNoTables
End If
If thisDocDescriptor.columnSequence = 0 Then
GoTo checkForAddedSequenceColumn
Else
GoTo checkForChangedOrDeletedSequenceColumn
End If
Else
GoTo docHasTables
End If
checkForAddedSequenceColumn:
Set tempDocDescriptor = New clsDocDescriptor
tempDocDescriptor.import thisDocDescriptor
tempDocDescriptor.sequenceColumnAdd sourceDocDescriptor.columnHeading(1)
headersArray = BuildHeadersArray(tempDocDescriptor)
tablesfound = GetTables(sourceDoc, headersArray)
If IsEmpty(tablesfound) Then GoTo docHasNoTables
Select Case showMessage(c8Msg1030, button1:="Add", button2:="Delete", button3:="Cancel", defaultButton:=3)
Case "Add"
addSequenceColumnToThisDocument = True
Case "Delete"
deleteSequenceColumnFromImportedTables = True
Case "Cancel"
userCancelled = True
GoTo docHasNoTables
End Select
GoTo docHasTables
checkForChangedOrDeletedSequenceColumn:
headersArray(0) = sourceDocDescriptor.columnHeading(1)
tablesfound = GetTables(sourceDoc, headersArray)
If IsEmpty(tablesfound) Then
Else
seqHeadingDiffers = True
GoTo docHasTables
End If
Set tempDocDescriptor = New clsDocDescriptor
tempDocDescriptor.import thisDocDescriptor
tempDocDescriptor.sequenceColumnDelete
tablesfound = GetTables(sourceDoc, BuildHeadersArray(tempDocDescriptor))
If IsEmpty(tablesfound) Then GoTo docHasNoTables
Select Case showMessage(c8Msg1031, button1:="Add", button2:="Delete", button3:="Cancel", defaultButton:=3)
Case "Add"
addSequenceColumnToImportedTables = True
Case "Delete"
deleteSequenceColumnFromThisDocument = True
Case "Cancel"
userCancelled = True
GoTo docHasNoTables
End Select
GoTo docHasTables
docHasNoTables:
GetTablesExtended = Empty
Exit Function
docHasTables:
GetTablesExtended = tablesfound
End Function
Function checkDescriptorMandatoryColumns(sourceDocDescriptor As clsDocDescriptor) As Boolean
Dim out As Boolean
out = True
If thisDocDescriptor.mandatoryColumns = sourceDocDescriptor.mandatoryColumns Then
GoTo finished
End If
If thisDocDescriptor.columnSequence = 0 Then
If (sourceDocDescriptor.columnSequence = 1) And thisDocDescriptor.mandatoryColumns * 2 = sourceDocDescriptor.mandatoryColumns Then
GoTo finished
End If
Else
If (sourceDocDescriptor.columnSequence = 0) And sourceDocDescriptor.mandatoryColumns * 2 = thisDocDescriptor.mandatoryColumns Then
GoTo finished
End If
End If
out = False
finished:
checkDescriptorMandatoryColumns = out
End Function
Sub checkGlossaryEntries(sourceGlossaryAdmin As clsGlossary, sourceGlossaryUser As clsGlossary)
Set duplicateAbbreviationsGlossary = New clsGlossary
duplicateAbbreviationsGlossary.import thisDocGlossaryAdmin, glAllowDupKeys:=True, glAddPrefix:="00"
duplicateAbbreviationsGlossary.import sourceGlossaryAdmin, glAllowDupKeys:=True, glAllowDupItems:=False, glAddPrefix:="02"
duplicateAbbreviationsGlossary.import thisDocGlossaryUser, glAllowDupKeys:=True, glAllowDupItems:=True, glAddPrefix:="01"
duplicateAbbreviationsGlossary.import sourceGlossaryUser, glAllowDupKeys:=True, glAllowDupItems:=True, glAddPrefix:="03"
duplicateAbbreviationsIndices = duplicateAbbreviationsGlossary.duplicateEntries
End Sub
Function MergeAllTables(Optional showMergeMessage As Boolean = True) As Boolean
Dim sourceTable As table
Dim target As table
Dim sourceRange As Range
Dim targetRange As Range
Dim tableStart As Long
Dim columnWidths() As Long
Dim i As Long
Dim rowCount As Long
Dim tablesfound As Variant
Dim bkm As Bookmark
Dim listFound As Boolean
Dim sw1 As clsStopWatch
Dim performanceOptionsStore() As Variant
Dim restorePosition As Boolean
performanceOptionsStore = BWordPerformanceOptionsSet()
listFound = False
Set sw1 = New clsStopWatch
With progressBar
.Reset
.title = "Merge tables"
.Caption1 = c8PBAnalysingTables
.show enableCancel:=False
End With
DoEvents
If trackedChangesLurking(ThisDocument) Then
If trackedChangesOffDialog(ThisDocument) Then
Else
Call showMessage(c8Msg5231, msgPrefix1:="Merge", msgPrefix2:="<" & ThisDocument.name)
GoTo mergeFailed
End If
End If
sw1.Start
tablesfound = GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor))
If IsEmpty(tablesfound) Then
Call showMessage(c8Msg1015)
GoTo mergeFailed
End If
For i = 0 To UBound(tablesfound) - 1
If tablesfound(i) + 1 <> tablesfound(i + 1) Then
Call showMessage(c8Msg1110)
ThisDocument.tables(tablesfound(i) + 1).Select
ThisDocument.ActiveWindow.ScrollIntoView Selection.Range
GoTo mergeFailed
End If
Next i
Call setProgressBarCounters(ThisDocument, tablesfound)
For i = 0 To UBound(tablesfound)
Set sourceTable = ThisDocument.Content.tables(tablesfound(i))
progressBar.Caption2 = c8PBCheckingColCount & i + 1 & c8PBOf & pbTablesToCheck
If Not CheckCellCountInTable(xTable:=sourceTable, xDocDescriptor:=thisDocDescriptor) Then
Call showMessage(c8Msg1105)
GoTo mergeFailed
End If
progressBar.AddProgress 0.05 / pbTablesToCheck
Next i
For i = 0 To UBound(tablesfound)
Set sourceTable = ThisDocument.Content.tables(tablesfound(i))
progressBar.Caption2 = c8PBCheckingLists & " in table " & i + 1 & c8PBOf & pbTablesToCheck
If CheckForListsInTable(xTable:=sourceTable) Then listFound = True
progressBar.AddProgress 0.05 / pbTablesToCheck
Next i
Set target = ThisDocument.Content.tables(tablesfound(0))
tableStart = target.Range.Start
columnWidths = BWordTableGetColumnWidths(target)
For Each bkm In ThisDocument.Bookmarks
If Left$(bkm.name, 3) = c8BookmarkPrefixMerge Then
bkm.Delete
End If
Next bkm
For i = 1 To UBound(tablesfound)
ThisDocument.Bookmarks.add name:=c8BookmarkPrefixMerge & i, Range:=ThisDocument.Content.tables(tablesfound(i)).Range
Next i
Application.screenUpdating = False
With progressBar
.Caption1 = c8PBPreparingTable & "1 of " & pbTablesToCheck
.Caption2 = ""
End With
rowCount = BWordTableRowCount(target)
Call BWordRemoveFrameFromTable(target)
Set targetRange = BWordTableToText(xTable:=target)
progressBar.AddProgress (0.4 * rowCount) / BMax(pbRowsToCheck, 1)
For i = 1 To UBound(tablesfound)
DoEvents
progressBar.Caption1 = c8PBMergingTable & i + 1 & c8PBOf & pbTablesToCheck
Set sourceTable = ThisDocument.Bookmarks(c8BookmarkPrefixMerge & i).Range.tables(1)
rowCount = BWordTableRowCount(sourceTable)
If rowCount = 1 Then
sourceTable.Delete
GoTo nextTable
End If
Call BWordRemoveFrameFromTable(sourceTable)
sourceTable.rows(1).Delete
Set sourceRange = BWordTableToText(xTable:=sourceTable)
targetRange.Collapse direction:=wdCollapseEnd
targetRange.FormattedText = sourceRange.FormattedText
sourceRange.Delete
progressBar.AddProgress (0.4 * rowCount / pbRowsToCheck)
nextTable:
Next i
DoEvents
targetRange.Start = tableStart
progressBar.Caption1 = c8PBReformattingMergedTable
progressBar.Caption2 = c8PBPatient
Set target = BWordTextToTable(targetRange)
progressBar.AddProgress 0.4
progressBar.Caption2 = c8PBSettingColumnWidths
BWordTableSetColumnWidths target, columnWidths
progressBar.Caption2 = c8PBFormattingHeadingRow
progressBar.Caption3 = ""
setTableCharacteristics target
With progressBar
.AddProgress 0.02 / pbTablesToCheck
.Caption2 = c8PBFormatComplete
.Caption3 = ""
End With
If listFound Then showMessage msg:=c8Msg3200
ppStats_Update ppStats_Merge, pbTablesToCheck, pbRowsToCheck, sw1.value
If showMergeMessage Then Call showMessage(c8Msg1100)
Application.StatusBar = "Merge complete "
MergeAllTables = True
restorePosition = True
GoTo finish
mergeFailed:
MergeAllTables = False
restorePosition = False
finish:
progressBar.finish
Call BWordPerformanceOptionsRestore(performanceOptionsStore, restorePosition)
ThisDocument.UndoClear
For Each bkm In ThisDocument.Bookmarks
If Left$(bkm.name, 3) = c8BookmarkPrefixMerge Then
bkm.Delete
End If
Next bkm
Application.screenUpdating = True
End Function
Function getSourcePrefix() As String
Dim zText As String
Dim userInput As String
If thisDocDescriptor.columnSource = 0 Then
zText = "Source of Information"
Else
zText = thisDocDescriptor.columnHeading(thisDocDescriptor.columnSource)
End If
Call frmInputBox.setParms(title:="Source of Information", promptOK:="Type where the document to be imported came from in the box below " & "and press OK. What you type will be added to the '" & zText & "' column of the imported document.", promptCancel:="Press Cancel if you no longer want to import the document.", showCancel:=True, forceInput:=True, defaultText:="")
frmInputBox.show
userInput = frmInputBox.userInput
If Len(userInput) = 0 Then Exit Function
userInput = checkExistingFragments(userInput, thisDocSourcePrefixes)
If Len(userInput) = 0 Then Exit Function
getSourcePrefix = BSqueezeSpaces(userInput) & " " & c8SourceDelimiter
End Function
Function checkExistingFragments(xInput As String, Optional xPrefixGlossary As clsGlossary) As String
Dim userInput As String
Dim sourceFragments() As String
Dim i As Long
Dim zText As String
userInput = xInput
sourceFragments = GetSourceFragments(xPrefixGlossary)
For i = 0 To UBound(sourceFragments)
If LCase$(BRemoveAllSpaces(userInput)) = LCase$(BRemoveAllSpaces(sourceFragments(i))) Then
If BSqueezeSpaces(userInput) = BSqueezeSpaces(sourceFragments(i)) Then
Else
zText = showMessage(c8Msg1050, msgPrefix1:="your entry <" & userInput & "> ", msgSuffix1:="<" & sourceFragments(i) & ">", button2:="OK", button3:="Cancel", defaultButton:=2)
If zText = "OK" Then
userInput = sourceFragments(i)
Else
Exit Function
End If
End If
End If
Next
checkExistingFragments = userInput
End Function
Sub addSourcePrefix(xTable As table, sourceCol As Long, infoSourcePrefix As String)
Dim i As Long
Dim infoSourceCell As Cell
Dim rCount As Long
rCount = BWordTableRowCount(xTable)
If Len(infoSourcePrefix) = 0 And sourceDocVersion >= 3 Then
progressBar.AddProgress 0.9 * (rCount / pbRowsToCheck)
Else
For i = 2 To rCount
With progressBar
.AddProgress (0.9 / pbRowsToCheck)
.Caption2 = c8PBProcessingPrefix & i & c8PBOf & rCount
End With
If Not BWordIsBlankRow(xTable.rows(i)) Then
Set infoSourceCell = xTable.rows(i).Cells(sourceCol)
If sourceDocVersion < 3 Then Call addSourcePrefixToGlossary(BWordGetCellText(infoSourceCell))
If infoSourcePrefix > "" Then infoSourceCell.Range.InsertBefore text:=infoSourcePrefix & " "
End If
Next i
End If
End Sub
Sub addSourcePrefixToGlossary(xPrefix As String)
Dim prefix As String
prefix = sourcePrefix(xPrefix)
If Len(prefix) = 0 Or sourceSourcePrefixes.containsKey(prefix) Then
Else
Call sourceSourcePrefixes.add(prefix)
End If
End Sub
Function sourcePrefixNormalise(xTables As Variant, xSourceFragments() As String, xColumnSource As Long, Optional xAddProgress As Double = 0.001) As String
Const pbWeightingPhase1 As Double = 0.4
Const pbWeightingPhase2 As Double = 0.3
Const pbWeightingPhase3 As Double = 0.3
Dim rowNum As Long
Dim rowCount As Long
Dim tableAsArray As Variant
Dim tabl As table
Dim decorators() As Variant
Dim columnWidths() As Long
Dim out As String
Dim zString As String
Dim prefixCaseTranslation() As String
Dim sw1 As clsStopWatch
Dim i As Long
Dim j As Long
Dim pbCaption1 As String
On Error GoTo error1
Set sw1 = New clsStopWatch
sw1.Start
ReDim prefixCaseTranslation(0 To UBound(xSourceFragments), 0 To 1)
For j = 0 To UBound(xSourceFragments)
prefixCaseTranslation(j, 0) = xSourceFragments(j)
prefixCaseTranslation(j, 1) = StrConv(xSourceFragments(j), vbLowerCase)
Next j
pbCaption1 = progressBar.Caption1
For i = 0 To UBound(xTables)
DoEvents
With progressBar
.Caption1 = c8PBNormalisingPrefixes & ": " & c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
.Caption2 = ""
.Caption3 = ""
End With
Set tabl = ThisDocument.Content.tables(xTables(i))
rowCount = BWordTableRowCount(tabl)
With progressBar
.Caption2 = c8PBConvertingTableToArray
.CancelButtonEnable False
End With
columnWidths = BWordTableGetColumnWidths(tabl)
tableAsArray = BWordTableToArray(xTable:=tabl, xDelete:=True, xProgressBarIncrement:=xAddProgress * pbWeightingPhase1)
If progressBar.userCancelled Then GoTo userCancelled
If BWordTableToArrayError(tableAsArray) Or IsEmpty(tableAsArray) Then
out = "convert table to array"
GoTo error1
End If
With progressBar
.Caption2 = c8PBProcessingArray
.CancelButtonEnable
End With
ReDim decorators(1 To UBound(tableAsArray, 1), 0 To UBound(tableAsArray, 2), 2)
For rowNum = 2 To rowCount
With progressBar
.Caption3 = c8PBProcessingRow & rowNum & c8PBOf & rowCount
If .userCancelled Then GoTo userCancelled
End With
If BWordIsBlankRow_TA(tableAsArray, rowNum) Then
GoTo nextRow
End If
zString = sourcePrefixNormaliseWhitespace(tableAsArray(rowNum, xColumnSource))
zString = sourcePrefixStandardiseCase(zString, prefixCaseTranslation)
tableAsArray(rowNum, xColumnSource) = zString
nextRow:
progressBar.AddProgress xAddProgress * pbWeightingPhase2
Next rowNum
With progressBar
.Caption2 = c8PBConvertingArrayToTable
.Caption3 = ""
.CancelButtonEnable False
End With
Set tabl = BWordTableFromArray(tableAsArray, decorators, ThisDocument, xProgressBarIncrement:=xAddProgress * pbWeightingPhase3)
If tabl Is Nothing Then
If progressBar.userCancelled Then
GoTo userCancelled
Else
out = "convert table from array"
GoTo error1
End If
Else
progressBar.CancelButtonEnable
BWordTableSetColumnWidths tabl, columnWidths
progressBar.Caption3 = c8PBProcessingHeadingRow
setTableCharacteristics tabl
End If
Next i
GoTo normaliseComplete
normaliseComplete:
With progressBar
.Caption1 = c8PBSourceNormalisationComplete
.Caption2 = c8PBSourceNormalisationMakeHash
.Caption3 = ""
End With
thisDocDescriptor.tablesHash2 = tablesHash(xTables, ThisDocument, thisDocDescriptor.columnSource)
ppStats_Update ppStats_NormaliseSource, pbTablesToCheck, pbRowsToCheck, sw1.value, xField1:=UBound(xSourceFragments) + 1
GoTo finish
error1:
If Len(out) = 0 Then out = Err.Number & " (" & Err.Description & ")"
out = "sourcePrefixNormalise: Error " & out
showMessage c8Msg6000, msgSuffix2:=out
GoTo finish
userCancelled:
out = "sourcePrefixNormalise: user cancelled"
finish:
With progressBar
.Caption1 = pbCaption1
.Caption2 = ""
End With
sourcePrefixNormalise = out
End Function
Function sourcePrefixNormaliseWhitespace(xString As Variant) As String
Dim zString As String
zString = xString
zString = replace(BStringNormaliseWhitespace(zString), c8SourceDelimiter, " " & c8SourceDelimiter & " ")
zString = BSqueezeSpaces(zString)
sourcePrefixNormaliseWhitespace = zString
End Function
Function sourcePrefixStandardiseCase(xString As Variant, xPrefixCaseTranslation() As String) As String
Dim zString As String
Dim found As Boolean
Dim sourceFragments() As String
Dim out As String
Dim i As Long
Dim j As Long
out = ""
zString = StrConv(sourcePrefix(CStr(xString)), vbLowerCase)
sourceFragments = Split(zString, c8SourceDelimiter)
For i = 0 To UBound(sourceFragments) - 1
DoEvents
If progressBar.userCancelled Then Exit Function
zString = Trim$(sourceFragments(i))
found = False
For j = 0 To UBound(xPrefixCaseTranslation)
If StrConv(zString, vbLowerCase) = xPrefixCaseTranslation(j, 1) Then
out = out & xPrefixCaseTranslation(j, 0) & " " & c8SourceDelimiter & " "
found = True
End If
Next j
If Not found Then GoTo badFragment
Next i
sourcePrefixStandardiseCase = Trim$(Trim$(out) & " " & sourceLowestLevel(CStr(xString)))
Exit Function
badFragment:
sourcePrefixStandardiseCase = xString
End Function
Public Sub c8normaliseSourceOfInformation()
Dim tablesfound As Variant
Dim performanceOptionsStore() As Variant
Dim sourceFragments() As String
Dim docSave As String
Dim saveStatus As Boolean
performanceOptionsStore = BWordPerformanceOptionsSet()
saveStatus = ThisDocument.Saved
Application.screenUpdating = False
With progressBar
.Reset
.Caption1 = c8PBNormalisingPrefixes
.show
End With
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015, msgSuffix1:=" " & ThisDocument.name)
GoTo finish
Else
Call setProgressBarCounters(ThisDocument, tablesfound)
End If
If pbRowsToCheck = 0 Then
GoTo finish
End If
If thisDocSourcePrefixes.count > 0 Then
docSave = thisDocSaver.documentSave(ThisDocument)
sourceFragments = GetSourceFragments
If sourcePrefixNormalise(tablesfound, sourceFragments, thisDocDescriptor.columnSource, xAddProgress:=0.95 / pbRowsToCheck) = "" Then
Call thisDocSaver.closeSingle(docSave)
Else
If progressBar.userCancelled Then
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
End If
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
progressBar.finish
showMessage c8Msg3020
End If
End If
finish:
progressBar.finish
Call BWordPerformanceOptionsRestore(performanceOptionsStore, xRestorePosition:=True)
Application.screenUpdating = True
End Sub
Public Function getReportLine(ByRef reportLine As Long) As String
reportLine = reportLine + 1
getReportLine = format$(reportLine, "0000")
End Function
Private Sub mergeProcessingParameters(ByRef targetProcessingParameters As clsGlossary, sourceProcessingParameters As clsGlossary)
Dim i As Long
Dim statsArray() As String
Dim stats As String
progressBar.Caption3 = c8PBWindowsStatistics
stats = ppStats_Get(ppStats_WindowsVersions, xIncludePrefix:=False, xPPGlossary:=sourceProcessingParameters)
statsArray = Split(stats, ppStats_Delimiter)
For i = 0 To UBound(statsArray) - 1
progressBar.Caption3 = progressBar.Caption3 & " ."
Call updateMachineStatistics(xWindowsVersion:="*" & statsArray(i))
Next
progressBar.AddProgress 0.01
progressBar.Caption3 = c8PBWordStatistics
stats = ppStats_Get(ppStats_WordVersions, xIncludePrefix:=False, xPPGlossary:=sourceProcessingParameters)
statsArray = Split(stats, ppStats_Delimiter)
For i = 0 To UBound(statsArray) - 1
progressBar.Caption3 = progressBar.Caption3 & " ."
Call updateMachineStatistics(xWordVersion:="*" & statsArray(i))
Next
End Sub
Public Function mergeMultipleTablesPrompt(Optional progressBarTitleOnCompletion As String, Optional checkForTables As Boolean = False) As String
Dim out As String
Dim tablesfound As Variant
Dim undoMarker As String
Dim saveProgress As Single
saveProgress = progressBar.Progress
If checkForTables Then
tablesfound = GetTables(ThisDocument, BuildHeadersArray(thisDocDescriptor))
If IsEmpty(tablesfound) Then Exit Function
If UBound(tablesfound) = 0 Then Exit Function
End If
out = showMessage(c8Msg1120, button1:="Merge", button2:="Don't Merge", button3:="Cancel", defaultButton:=1)
If out = "Merge" Then
If MergeAllTables(showMergeMessage:=False) Then
undoMarker = BWordUndo_SetMarker(ThisDocument)
If sortTablesAsDescriptor Then
Else
BWordUndo_ToMarker undoMarker, ThisDocument, "mergeMultipleTablesPrompt"
out = "MergeFailed"
End If
Else
out = "MergeFailed"
End If
End If
mergeMultipleTablesPrompt = out
If Len(progressBarTitleOnCompletion) > 0 Then
progressBar.title = progressBarTitleOnCompletion
progressBar.Progress = saveProgress
progressBar.show
End If
End Function
Attribute VB_Name = "c8MC_DocumentPublish"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Private publishCancelled As Boolean
Private publishCancelledInternally As Boolean
Private publishNarrativeBaseInstant As String
Private chronologyStartTime As String
Private publishNarrativeHeadings() As Variant
Public frmPublishCustomButton As Long
Enum docType
exact = 0
custom = 1
analysis = 2
JSON = 3
End Enum
Sub createExactCopy()
Call CreateDocument(docType.exact)
End Sub
Sub CreateCustomDocument()
Call CreateDocument(docType.custom)
End Sub
Sub CreateJSONDocument()
Call CreateDocument(docType.JSON)
End Sub
Sub CreateAnalysisDocument()
Call CreateDocument(docType.analysis)
End Sub
Sub CreateDocument(xType As docType)
Dim saveName As String
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
saveName = fileSavedAsFullName
Select Case xType
Case exact
Call createExactCopy2(ThisDocument)
Case custom
Call CreateCustomDocument2(ThisDocument)
Case analysis
Call CreateAnalysisDocument2
Case JSON
Call CreateJSONDocument2
End Select
fileSavedAsFullName = saveName
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Sub
Sub CreateCustomDocument2(xSource As Document)
Dim tablesfound As Variant
Dim newDoc As Document
Dim sw1 As clsStopWatch
Dim narrativeDetails As Variant
Dim i As Long
Dim saveStatus As Boolean
Dim docDescriptor As clsDocDescriptor
Dim printDateTimeAsis As Boolean
Dim printDateTimeOffsets As String
saveStatus = xSource.Saved
Set sw1 = New clsStopWatch
Set docDescriptor = New clsDocDescriptor
frmPublishCustom.show
If frmPublishCustomButton = vbCancel Then Exit Sub
publishCancelled = False
printDateTimeAsis = ppP_DateTimeHeadingPrintAsis()
printDateTimeOffsets = ppP_DateTimeOffsetsformat()
fs2FileToPublish = xSource.name
With progressBar
.Reset
.title = "Publish narrative"
.Caption1 = c8PBAnalysingTables
.show
.AddProgress 0.01
.CancelButtonEnable False
End With
publishNarrativeHeadings = BuildHeadersArray(thisDocDescriptor)
tablesfound = GetTables(doc:=xSource, heads:=publishNarrativeHeadings, xIncludeVerticallyMerged:=False)
If IsEmpty(tablesfound) Then
Call showMessage(c8Msg1015, msgSuffix1:=" " & fs2FileToPublish)
GoTo finish
End If
Call setProgressBarCounters(xSource, tablesfound)
If pbRowsToCheck = 0 Then
showMessage c8Msg3012
GoTo finish
End If
sw1.Start
Application.screenUpdating = False
For i = 0 To UBound(tablesfound)
progressBar.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
progressBar.Caption2 = ""
progressBar.Caption3 = ""
publishNarrativeBaseInstant = ""
Call CreateCustomDocumentWriteTable(narrativeDetails, xSource.Content.tables(tablesfound(i)), printDateTimeAsis, printDateTimeOffsets)
If publishCancelled Then
GoTo exitPublishCancelled
End If
Next i
progressBar.Caption1 = c8PBConvertingArrayToDoc
progressBar.Caption2 = ""
If IsEmpty(narrativeDetails) Then
MsgBox "This document contains no events to print", vbOKOnly, "Publish Narrative"
GoTo finish
End If
Set newDoc = BWordCreateDocFromArray(narrativeDetails, xProgressBarIncrement:=0.08 / pbRowsToCheck)
If newDoc Is Nothing Then
GoTo exitPublishCancelled
Else
progressBar.Caption1 = c8PBFormattingDocument
progressBar.Caption3 = ""
progressBar.CancelButtonEnable False
Call CreateCustomDocumentFormatDocument(newDoc)
End If
ppStats_Update ppStats_PublishCustom, pbTablesToCheck, pbRowsToCheck, sw1.value
docDescriptor.getDetails xDoc:=xSource
docDescriptor.setDetails xDoc:=newDoc
Call licenceCopy(xSource, newDoc)
Call BWordDocumentVariableSet(xDoc:=newDoc, xName:="c8DocType", xValue:=c8PublishedChronologyCustom)
Application.screenUpdating = True
progressBar.finish
If c8FileSaveAs(xDoc:=newDoc, xSuggestedName:=BGetFilenamePart(fs2FileToPublish) & " Narrative", xEnforceMacroEnabled:=False) Then
Documents(BWordGetNumericDocumentIndex(fileSavedAsFullName)).activate
ActiveDocument.Windows(1).View.Type = wdPrintView
Application.screenUpdating = False
Application.screenUpdating = True
thisDocNavigator.setDocument ThisDocument.fullName
Else
newDoc.Saved = True
newDoc.Close
xSource.activate
End If
GoTo finish
exitPublishCancelled:
If publishCancelledInternally Then
publishCancelledInternally = False
GoTo finish
End If
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = ""
progressBar.Caption3 = ""
showMessage c8Msg5115
finish:
fs2FileToPublish = ""
progressBar.finish
Application.screenUpdating = True
xSource.Saved = saveStatus
End Sub
Sub CreateCustomDocumentWriteTable(xNarrativeDetails As Variant, xSourceTable As table, xPrintDateTimeAsis As Boolean, xPrintDateTimeOffsets As String)
Dim tableAsArray As Variant
Dim rowNum As Long: Dim rowCount As Long
rowCount = BWordTableRowCount(xSourceTable)
With progressBar
.Caption2 = c8PBPreparingTable
.CancelButtonEnable False
End With
tableAsArray = BWordTableToArray(xTable:=xSourceTable, xDelete:=False, xProgressBarIncrement:=0.1 / pbRowsToCheck)
If BWordTableToArrayError(tableAsArray) Then
publishCancelled = True
GoTo endPublish
End If
If IsEmpty(tableAsArray) Then
publishCancelled = True
GoTo endPublish
End If
With progressBar
.Caption2 = c8PBWritingNarrative
.Caption3 = ""
.CancelButtonEnable
End With
For rowNum = 2 To rowCount
If progressBar.userCancelled Then
publishCancelled = True
End If
If publishCancelled Then GoTo endPublish
With progressBar
.AddProgress (0.2 / pbRowsToCheck)
.Caption2 = c8PBWritingEvent & rowNum - 1 & c8PBOf & rowCount - 1 & " to internal array"
End With
If BWordIsBlankRow_TA(tableAsArray, rowNum) Then
GoTo nextRow
End If
Call CreateCustomDocumentWriteEvent(xNarrativeDetails, tableAsArray, rowNum, xPrintDateTimeAsis, xPrintDateTimeOffsets)
nextRow:
Next rowNum
endPublish:
End Sub
Sub CreateCustomDocumentWriteEvent(xNarrativeDetails As Variant, xTableAsArray As Variant, xRowNum As Long, xPrintDateTimeAsis As Boolean, xPrintDateTimeOffsets As String)
Dim zText1 As String
Dim zText2 As String
Dim zText3 As String
Dim zTempDate1 As String
Dim zTempTime1 As String
Dim zTempTime2 As String
Dim zShowElapsedTime As Boolean
Dim i As Long
Dim glossaryEntry() As String
Dim eventStartDate As String
Dim eventEndDate As String
Dim eventStartTime As String
Dim eventEndTime As String
Dim eventStartISO_DefaultUsingEventStart As String
Dim eventEndISO_DefaultUsingEventStart As String
Dim eventStartISO_DefaultUsingChronologyStart As String
Dim eventEndISO_DefaultUsingChronologyStart As String
If Len(publishNarrativeBaseInstant) = 0 Then
eventStartDate = BWordNormaliseText(xTableAsArray(xRowNum, thisDocDescriptor.columnStartDate))
If thisDocDescriptor.columnStartTime > 0 Then
chronologyStartTime = BWordNormaliseText(xTableAsArray(xRowNum, thisDocDescriptor.columnStartTime))
Else
chronologyStartTime = ""
End If
If Len(chronologyStartTime) = 0 Then
zTempTime1 = "00:00:00"
Else
zTempTime1 = chronologyStartTime
End If
publishNarrativeBaseInstant = bdt.StringsToISODateTime(eventStartDate, zTempTime1)
If Len(publishNarrativeBaseInstant) = 0 And xPrintDateTimeOffsets > ppFalse Then
showMessage c8Msg5120
publishCancelledInternally = True
publishCancelled = True
Exit Sub
End If
End If
eventStartDate = BWordNormaliseText(xTableAsArray(xRowNum, thisDocDescriptor.columnStartDate))
If thisDocDescriptor.columnStartTime > 0 Then
eventStartTime = BWordNormaliseText(xTableAsArray(xRowNum, thisDocDescriptor.columnStartTime))
Else
eventStartTime = ""
End If
If Len(eventStartTime) = 0 Then
zTempTime1 = "00:00:00"
zTempTime2 = bdt.ISOTimePart(publishNarrativeBaseInstant)
Else
zTempTime1 = eventStartTime
zTempTime2 = eventStartTime
End If
eventStartISO_DefaultUsingEventStart = bdt.StringsToISODateTime(eventStartDate, zTempTime1)
eventStartISO_DefaultUsingChronologyStart = bdt.StringsToISODateTime(eventStartDate, zTempTime2)
If (Len(eventStartISO_DefaultUsingEventStart) = 0 Or Len(eventStartISO_DefaultUsingChronologyStart) = 0) And xPrintDateTimeOffsets > ppFalse Then
showMessage c8Msg5120
publishCancelledInternally = True
publishCancelled = True
Exit Sub
End If
If thisDocDescriptor.columnEndDate > 0 Then
eventEndDate = BWordNormaliseText(xTableAsArray(xRowNum, thisDocDescriptor.columnEndDate))
Else
eventEndDate = ""
End If
If thisDocDescriptor.columnEndTime > 0 Then
eventEndTime = BWordNormaliseText(xTableAsArray(xRowNum, thisDocDescriptor.columnEndTime))
Else
eventEndTime = ""
End If
If Len(eventEndDate) = 0 Then
zTempDate1 = bdt.ISODatePart(eventStartISO_DefaultUsingEventStart)
Else
zTempDate1 = eventEndDate
End If
If Len(eventEndTime) = 0 Then
zTempTime1 = bdt.ISOTimePart(eventStartISO_DefaultUsingEventStart)
zTempTime2 = bdt.ISOTimePart(publishNarrativeBaseInstant)
Else
zTempTime1 = eventEndTime
zTempTime2 = eventEndTime
End If
eventEndISO_DefaultUsingEventStart = bdt.StringsToISODateTime(zTempDate1, zTempTime1)
eventEndISO_DefaultUsingChronologyStart = bdt.StringsToISODateTime(zTempDate1, zTempTime2)
If (Len(eventEndISO_DefaultUsingEventStart) = 0 Or Len(eventEndISO_DefaultUsingChronologyStart) = 0) And xPrintDateTimeOffsets > ppFalse Then
showMessage c8Msg5120
publishCancelledInternally = True
publishCancelled = True
Exit Sub
End If
If thisDocDescriptor.columnSequence > 0 Then zText1 = xTableAsArray(xRowNum, thisDocDescriptor.columnSequence) & ": "
If xPrintDateTimeAsis Then
zText1 = Trim$(zText1 & eventStartDate & " " & eventStartTime)
If Len(eventEndDate) = 0 And Len(eventEndTime) = 0 Then
Else
zText1 = zText1 & " - " & Trim$(eventEndDate & " " & eventEndTime)
End If
End If
Select Case xPrintDateTimeOffsets
Case ppFalse
zText2 = ""
Case ppP_DateTimeOffsetsFormat1
zText2 = "Day " & DateDiff("d", bdt.ISODatePart(publishNarrativeBaseInstant), bdt.ISODatePart(eventStartISO_DefaultUsingEventStart)) + 1
zText2 = Trim$(zText2 & " " & eventStartTime)
If Len(eventEndDate) = 0 And Len(eventEndTime) = 0 Then
Else
zText2 = zText2 & " - " & Trim$("Day " & DateDiff("d", bdt.ISODatePart(publishNarrativeBaseInstant), bdt.ISODatePart(eventEndISO_DefaultUsingEventStart)) + 1 & " " & eventEndTime)
zShowElapsedTime = Len(eventStartTime) > 0 And Len(eventEndTime) > 0
zText3 = bdt.ISODateTimeDiffFormatted(eventStartISO_DefaultUsingEventStart, eventEndISO_DefaultUsingEventStart, xShowZeroAsNull:=True, xShowTimeInfo:=zShowElapsedTime)
If Len(zText3) = 0 Then
Else
zText2 = zText2 & " (" & zText3 & ")"
End If
End If
If xPrintDateTimeAsis Then zText2 = "(" & zText2 & ")"
Case ppP_DateTimeOffsetsFormat2
zShowElapsedTime = Len(chronologyStartTime) > 0 And Len(eventStartTime) > 0
zText2 = bdt.ISODateTimeDiffFormatted(publishNarrativeBaseInstant, eventStartISO_DefaultUsingChronologyStart, xShowZeroAsNull:=True, xShowTimeInfo:=zShowElapsedTime)
If Len(zText2) = 0 Then
zText2 = "Start of Chronology"
End If
If Len(eventEndDate) = 0 And Len(eventEndTime) = 0 Then
Else
zShowElapsedTime = Len(chronologyStartTime) > 0 And Len(eventEndTime) > 0
zText3 = bdt.ISODateTimeDiffFormatted(publishNarrativeBaseInstant, eventEndISO_DefaultUsingChronologyStart, xShowZeroAsNull:=True, xShowTimeInfo:=zShowElapsedTime)
If Len(zText3) = 0 Then
zText3 = "Start of Chronology"
End If
zText2 = zText2 & " - " & zText3
zShowElapsedTime = Len(eventStartTime) > 0 And Len(eventEndTime) > 0
zText3 = bdt.ISODateTimeDiffFormatted(eventStartISO_DefaultUsingEventStart, eventEndISO_DefaultUsingEventStart, xShowZeroAsNull:=True, xShowTimeInfo:=zShowElapsedTime)
If Len(zText3) = 0 Then
Else
zText2 = zText2 & " (" & zText3 & ")"
End If
End If
If xPrintDateTimeAsis Then zText2 = "(" & zText2 & ")"
End Select
Call CreateCustomDocumentWriteLine(xNarrativeDetails, LTrim$(zText1 & " ") & zText2, "H1")
zText1 = CStr(xTableAsArray(xRowNum, thisDocDescriptor.columnSource))
zText1 = BTranslateNewLines(zText1, " ")
Call CreateCustomDocumentWriteLine(xNarrativeDetails, zText1, "H2")
If thisDocDescriptor.columnGlossary > 0 Then
zText1 = ""
glossaryEntry = Split(BTranslateNewLines(CStr(xTableAsArray(xRowNum, thisDocDescriptor.columnGlossary)), Chr(141)), Chr(141))
For i = 0 To UBound(glossaryEntry)
glossaryEntry(i) = BSqueezeSpaces(glossaryEntry(i))
If Len(glossaryEntry(i)) = 0 Then
Else
zText1 = zText1 & (glossaryEntry(i)) & ", "
End If
Next i
If Len(zText1) = 0 Then
Else
zText1 = Left$(zText1, Len(zText1) - 2)
End If
Call CreateCustomDocumentWriteLine(xNarrativeDetails, zText1, "H2")
End If
For i = thisDocDescriptor.firstGeneralHeadingIndex To thisDocDescriptor.columnCount
zText1 = CStr(xTableAsArray(xRowNum, i))
Select Case BSqueezeSpaces(BStringNormaliseWhitespace(zText1))
Case ""
Case "x"
Case Else
If ppP_WriteGeneralHeadings Then Call CreateCustomDocumentWriteLine(xNarrativeDetails, CStr(publishNarrativeHeadings(i - 1)), "H3")
Call CreateCustomDocumentWriteLine(xNarrativeDetails, zText1)
End Select
Next
End Sub
Sub CreateCustomDocumentWriteLine(xNarrativeDetails As Variant, xText As String, Optional xLevel As String = "xx")
Call BWriteLineInArray(xNarrativeDetails, xLevel & xText)
End Sub
Sub CreateCustomDocumentFormatDocument(xDoc As Document)
progressBar.Caption2 = c8PBRemovingEmptyParagraphs
Call BWordSqueezeParagraphMarks(xDoc)
progressBar.Caption2 = c8PBUpdatingStyles
progressBar.Caption3 = c8PBUpdatingStyleNormal
xDoc.Styles(wdStyleNormal).ParagraphFormat.LineSpacingRule = wdLineSpaceSingle
xDoc.Styles(wdStyleNormal).ParagraphFormat.SpaceAfter = 3
progressBar.Caption3 = c8PBUpdatingStyleHeadings
xDoc.Styles(wdStyleHeading1).Font.Size = xDoc.Styles(wdStyleNormal).Font.Size + 3
xDoc.Styles(wdStyleHeading2).Font.Size = xDoc.Styles(wdStyleNormal).Font.Size + 2
xDoc.Styles(wdStyleHeading3).Font.Size = xDoc.Styles(wdStyleNormal).Font.Size + 1
progressBar.Caption2 = c8PBUpdatingHeadFoot
progressBar.Caption3 = ""
xDoc.Sections(1).Headers(wdHeaderFooterPrimary).Range.FormattedText = ThisDocument.Sections(1).Headers(wdHeaderFooterPrimary).Range.FormattedText
xDoc.Sections(1).Footers(wdHeaderFooterPrimary).Range.FormattedText = ThisDocument.Sections(1).Footers(wdHeaderFooterPrimary).Range.FormattedText
If Not c8LicenceHaveValid Then
progressBar.Caption2 = c8PBWritingWatermark
Call licenceWriteEvaluationWatermarks(xDoc)
End If
progressBar.Caption2 = ""
End Sub
Sub createExactCopy2(xSource As Document)
Dim newDoc As Document
Dim zDoc As Document
Dim docDescriptor As clsDocDescriptor
Dim includeErrorResidue As Boolean
Dim sourceHasErrorResidue As Boolean
Dim zString As String
Set docDescriptor = New clsDocDescriptor
If showMessage(c8Msg5100, button2:="OK", button3:="Cancel", defaultButton:=2) <> "OK" Then
Exit Sub
End If
If DocHasErrorSection(xSource) Then
sourceHasErrorResidue = True
Select Case showMessage(c8msg5130, button1:="Yes", button2:="No", button3:="Cancel", defaultButton:=1)
Case "Yes"
includeErrorResidue = True
Case "No"
includeErrorResidue = False
Case "Cancel"
Exit Sub
End Select
End If
fs2FileToPublish = xSource.name
Set zDoc = ActiveDocument
Set newDoc = Documents.add
zDoc.activate
Call thisDocSaver.copyDocument(xSource, newDoc)
If wordVersion <= Word2003 Then
zString = BWordCopyDocumentStyles(xSource, newDoc)
If Len(zString) = 0 Then
Else
showMessage c8msg5110, msgSuffix1:=" " & zString
End If
End If
docDescriptor.getDetails xDoc:=xSource
docDescriptor.setDetails xDoc:=newDoc
Call licenceCopy(xSource, newDoc)
Call BWordDocumentVariableSet(xDoc:=newDoc, xName:="c8DocType", xValue:=c8PublishedChronology)
If sourceHasErrorResidue And (Not includeErrorResidue) Then
DeleteC8Endnotes xRange:=newDoc.Range
errorSectionCleanup xDoc:=newDoc
newDoc.Range.Font.Reset
Dim zTables As Variant
Dim i As Long
Dim j As Long
zTables = GetTables(newDoc, BuildHeadersArray(thisDocDescriptor), True)
If IsEmpty(zTables) Then
Else
Dim t As table
For i = 0 To UBound(zTables)
Set t = newDoc.Content.tables(zTables(i))
t.Range.Select
Selection.Shading.BackgroundPatternColor = wdColorAutomatic
Selection.GoTo wdGoToTable, wdGoToAbsolute, zTables(i)
For j = 1 To thisDocDescriptor.columnCount
Selection.Font.Bold = True
Selection.Shading.Texture = wdTexture10Percent
Selection.MoveRight Unit:=wdCell
Next
Next
End If
End If
If Not c8LicenceHaveValid Then
Call licenceWriteEvaluationWatermarks(newDoc)
End If
If c8FileSaveAs(xDoc:=newDoc, xSuggestedName:=BGetFilenamePart(fs2FileToPublish) & " PLAIN WORD", xEnforceMacroEnabled:=False) Then
If wordVersion >= Word2007 Then
zString = BWordCopyDocumentStyles(xSource, Documents(BWordGetNumericDocumentIndex(fileSavedAsFullName)))
If Len(zString) = 0 Then
Else
showMessage c8msg5110, msgSuffix1:=" " & zString
End If
Documents(BWordGetNumericDocumentIndex(fileSavedAsFullName)).Save
End If
thisDocNavigator.setDocument ThisDocument.fullName
Documents(BWordGetNumericDocumentIndex(fileSavedAsFullName)).activate
ActiveDocument.Windows(1).View.Type = wdPrintView
Application.ScreenRefresh
Else
newDoc.Saved = True
newDoc.Close
End If
fs2FileToPublish = ""
End Sub
Attribute VB_Name = "c8MC_Duplicates"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Const errorRef As String = "{Wingdings 120}"
Dim tableCheckCancelled As Boolean
Dim savedDeletedRows() As String
Dim savedDeletedRowsCount As Long
Dim savedDeletedRowsDoc As Document
Dim columnCount As Long
Public frmDuplicatesButton As Long
Sub ProcessDuplicatesInThisDocument(xColumnsToCheck As Long, xDeleteDuplicates As Boolean, xSaveRows As Boolean)
If trackedChangesLurking(ThisDocument) Then
If trackedChangesOffDialog(ThisDocument) Then
Else
Call showMessage(c8Msg5231, msgPrefix1:="Duplicate row checking", msgPrefix2:="<" & ThisDocument.name)
Exit Sub
End If
End If
Call ProcessDuplicatesInDocument(ThisDocument, xColumnsToCheck, xDeleteDuplicates, xSaveRows)
End Sub
Sub ProcessDuplicatesInDocument(xDoc As Document, xColumnsToCheck As Long, xDeleteDuplicates As Boolean, xSaveRows As Boolean)
Dim saveStatus As Boolean
Dim tablesfound As Variant
Dim duplicates As Long
Dim buttonPressed As String
Dim msgsuf As String
Dim msgPref As String
Dim i As Long
Dim docSave As String
Dim performanceOptionsStore() As Variant
Dim restorePosition As Boolean
performanceOptionsStore = BWordPerformanceOptionsSet()
restorePosition = True
duplicates = 0
msgsuf = 0
msgPref = ""
buttonPressed = ""
Dim sw1 As clsStopWatch
Set sw1 = New clsStopWatch
sw1.Start
With progressBar
.Reset enableCancel:=False
.title = "Process Duplicates"
.Caption1 = c8PBAnalysingTables
.show
.AddProgress 0.01
End With
DoEvents
tablesfound = GetTables(xDoc, BuildHeadersArray(thisDocDescriptor), xShowVerticallyMergedMessage:=False, xShowNestedMessage:=False)
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015, msgSuffix1:=" " & xDoc.name)
GoTo finish
End If
Call setProgressBarCounters(xDoc, tablesfound)
If pbRowsToCheck = 0 Then
duplicates = 0
GoTo checkCompleted
End If
If DocHasUserTextAfterTables(xDoc) Then
sw1.Halt
If showMessage(c8Msg3013, button2:="OK", button3:="Cancel", defaultButton:=3) = "Cancel" Then
progressBar.finish
ScrollToTablesEnd xDoc
GoTo finish
End If
sw1.Start
End If
Application.screenUpdating = False
saveStatus = xDoc.Saved
columnCount = xDoc.Content.tables(tablesfound(0)).Columns.count
docSave = thisDocSaver.documentSave(ThisDocument)
Call DocPadding_Add
If xDeleteDuplicates And xSaveRows Then
Dim rowCount As Long
rowCount = 0
For i = 0 To UBound(tablesfound)
rowCount = rowCount + (xDoc.Content.tables(tablesfound(i)).rows.count - 1)
Next
ReDim savedDeletedRows(0 To rowCount + 1, 0 To columnCount)
savedDeletedRowsCount = 1
End If
tableCheckCancelled = False
For i = 0 To UBound(tablesfound)
Dim z As Variant
progressBar.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
progressBar.Caption2 = ""
progressBar.Caption3 = ""
z = ProcessDuplicatesInTable(xDoc.Content.tables(tablesfound(i)), xColumnsToCheck, xDeleteDuplicates, xSaveRows)
duplicates = duplicates + z
DoEvents
If tableCheckCancelled Then
GoTo checkCancelled
End If
Next i
With progressBar
.Caption1 = c8PBCheckCompleted
.Caption2 = BPluralityText(duplicates, "duplicate")
.Caption3 = c8PBFinishing
End With
GoTo checkCompleted
checkCancelled:
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
progressBar.finish
Call showMessage(c8Msg3020)
GoTo endCheck
checkCompleted:
Call navButtonsSetTooltipText("duplicate")
If duplicates = 0 Or xDeleteDuplicates Then
Call errorSectionCleanup(ThisDocument)
Call navButtonsDisable
Else
Call navButtonsEnable
End If
ppStats_Update ppStats_CheckDuplicates, pbTablesToCheck, pbRowsToCheck, sw1.value, xField1:=CStr(duplicates)
If duplicates > 0 Then
msgPref = BPluralityText(duplicates, "duplicate")
If xDeleteDuplicates Then
msgsuf = "deleted"
saveStatus = False
If xSaveRows Then
Call WriteSavedDeletedRowsDoc(xDoc, thisDocDescriptor)
buttonPressed = showMessage(c8Msg3031, msgPrefix1:=msgPref, button2:="OK", button3:="Go to list", defaultButton:=2)
Else
buttonPressed = showMessage(c8Msg3030, msgPrefix1:=msgPref)
End If
Else
msgsuf = "found"
buttonPressed = showMessage(c8Msg3025, msgPrefix1:=msgPref, button2:="OK", button3:="Go to list", defaultButton:=2)
Call errorSectionSetup(xDoc, xDuplicatesList:=True)
End If
Else
Call showMessage(c8Msg3035)
End If
xDoc.UndoClear
endCheck:
progressBar.finish
Call thisDocSaver.closeSingle(docSave)
Application.screenUpdating = True
Call DocPadding_Delete
If buttonPressed = "Go to list" Then
If xDeleteDuplicates Then
savedDeletedRowsDoc.activate
Application.StatusBar = "The rows above were deleted."
savedDeletedRowsDoc.ActiveWindow.View = wdPrintView
Else
Call gotoErrorList
restorePosition = False
End If
Else
xDoc.activate
Application.StatusBar = "Table check complete. " & msgPref & " " & msgsuf & "."
End If
xDoc.Saved = saveStatus
xDoc.UndoClear
finish:
Call BWordPerformanceOptionsRestore(performanceOptionsStore, restorePosition)
End Sub
Function ProcessDuplicatesInTable(xTable As Variant, xColumnsToCheck As Long, xDeleteDuplicates As Boolean, xSaveRows As Boolean) As Long
Dim rowNum As Long
Dim rowCount As Long
Dim duplicateCount As Long
Dim doc As Document
Dim retainedRows() As String
Dim retainedRowsCount As Long
Dim tableAsArray As Variant
Dim tableRange As Range
Dim tableCast As table
Dim tableStart As Long
Dim decorators() As Variant
Dim columnWidths() As Long
Dim hashCodeMaker As clsSHA256
Dim hashCodeStore As clsGlossary
Dim j As Long
Dim rowHash As String
If IsEmpty(xTable) Then Exit Function
Set doc = xTable.Parent
Set hashCodeMaker = New clsSHA256
Set hashCodeStore = New clsGlossary
duplicateCount = 0
rowCount = BWordTableRowCount(xTable)
hashCodeStore.clear
With progressBar
.Caption2 = c8PBPreparingTable & "for analysis"
.CancelButtonEnable False
End With
Set tableCast = xTable
tableStart = tableCast.Range.Start
columnWidths = BWordTableGetColumnWidths(tableCast)
tableAsArray = BWordTableToArray(xTable:=tableCast, xDelete:=True, xProgressBarIncrement:=0.1 / pbRowsToCheck)
If BWordTableToArrayError(tableAsArray) Then
tableCheckCancelled = True
GoTo endCheck
End If
If IsEmpty(tableAsArray) Then
tableCheckCancelled = True
GoTo endCheck
End If
With progressBar
.Caption2 = c8PBTableReady
.Caption3 = ""
.CancelButtonEnable
End With
Set tableRange = doc.Range(tableStart, tableStart + 1)
tableRange.Font.Reset
ReDim decorators(1 To UBound(tableAsArray, 1), 0 To UBound(tableAsArray, 2), 2)
If xDeleteDuplicates Then
ReDim retainedRows(0 To rowCount, 0 To columnCount)
retainedRows(0, 0) = tableAsArray(0, 0)
For j = 1 To columnCount
retainedRows(1, j) = tableAsArray(1, j)
Next j
retainedRowsCount = 1
End If
DoEvents
For rowNum = 2 To rowCount
If progressBar.userCancelled Then
tableCheckCancelled = True
GoTo endCheck
End If
With progressBar
.AddProgress (0.45 / pbRowsToCheck)
.Caption2 = c8PBCheckingRow & rowNum & c8PBOf & rowCount
.Caption3 = "(" & BPluralityText(duplicateCount, "duplicate") & c8PBFoundInTableSoFar
End With
If BWordIsBlankRow_TA(tableAsArray, rowNum) Then
If xDeleteDuplicates Then
retainedRowsCount = retainedRowsCount + 1
For j = 1 To columnCount
retainedRows(retainedRowsCount, j) = tableAsArray(rowNum, j)
Next j
End If
GoTo nextRow
End If
rowHash = hashCodeMaker.SHA256(BWordGetRowText_TA(tableAsArray, rowNum, xIncludeCells:=xColumnsToCheck, xCellDelimiter:="x"))
If hashCodeStore.containsKey(rowHash) Then
duplicateCount = duplicateCount + 1
If xDeleteDuplicates Then
If xSaveRows Then
savedDeletedRowsCount = savedDeletedRowsCount + 1
For j = 1 To columnCount
savedDeletedRows(savedDeletedRowsCount, j) = tableAsArray(rowNum, j)
Next j
End If
Else
decorators(rowNum, 0, 0) = c8ColorDuplicates
decorators(rowNum, 1, 1) = errorRef
decorators(rowNum, 1, 2) = "c8n000 - duplicate of row " & hashCodeStore.getItem(hashCodeStore.getEntryByKey(rowHash))
End If
Else
hashCodeStore.add glKey:=rowHash, glItem:=CStr(rowNum)
If xDeleteDuplicates Then
retainedRowsCount = retainedRowsCount + 1
For j = 1 To columnCount
retainedRows(retainedRowsCount, j) = tableAsArray(rowNum, j)
Next j
Else
decorators(rowNum, 0, 0) = c8ColorErrorsNone
End If
End If
nextRow:
Next
With progressBar
.Caption2 = c8PBFormattingTable
.Caption3 = ""
End With
If xDeleteDuplicates Then
Set tableCast = BWordTableFromArray(retainedRows, decorators, doc, retainedRowsCount, xProgressBarIncrement:=0.4 / pbRowsToCheck)
Else
Set tableCast = BWordTableFromArray(tableAsArray, decorators, doc, xProgressBarIncrement:=0.4 / pbRowsToCheck)
End If
If tableCast Is Nothing Then
If progressBar.userCancelled Then
tableCheckCancelled = True
GoTo endCheck
Else
GoTo endCheck
End If
Else
BWordTableSetColumnWidths tableCast, columnWidths
progressBar.Caption3 = c8PBProcessingHeadingRow
setTableCharacteristics tableCast
With progressBar
.AddProgress 0.025 / pbTablesToCheck
.Caption2 = c8PBFormatComplete
.Caption3 = ""
End With
End If
Application.ScreenRefresh
endCheck:
ProcessDuplicatesInTable = duplicateCount
End Function
Public Sub DuplicatesHighlight()
frmDuplicates.duplicatesMode = c8DuplicatesHighlight
Call DuplicatesExecute
End Sub
Public Sub DuplicatesDelete()
frmDuplicates.duplicatesMode = c8DuplicatesDelete
Call DuplicatesExecute
End Sub
Sub DuplicatesExecute()
Dim columnsToCheck As Long
Dim i As Long
frmDuplicates.show
If frmDuplicatesButton = vbCancel Then GoTo endFunction
Select Case mergeMultipleTablesPrompt(checkForTables:=True)
Case "Merge"
Case "MergeFailed"
GoTo endFunction
Case "Don't Merge"
Case "Cancel"
GoTo endFunction
Case ""
End Select
columnsToCheck = 0
For i = 1 To thisDocDescriptor.columnCount
Call BBitSet(i - 1, columnsToCheck, True)
Next i
If frmDuplicates.ckbIgnoreSource Then
Call BBitSet(thisDocDescriptor.columnSource - 1, columnsToCheck, False)
End If
If thisDocDescriptor.columnSequence > 0 Then
Call BBitSet(thisDocDescriptor.columnSequence - 1, columnsToCheck, False)
End If
Call ProcessDuplicatesInThisDocument(xColumnsToCheck:=columnsToCheck, xDeleteDuplicates:=(frmDuplicates.duplicatesMode = c8DuplicatesDelete), xSaveRows:=frmDuplicates.ckbCopyDeletedRows And (frmDuplicates.duplicatesMode = c8DuplicatesDelete))
endFunction:
End Sub
Sub WriteSavedDeletedRowsDoc(xDoc As Document, xDetails As clsDocDescriptor)
Dim decorators() As Variant
Dim j As Long
Dim tableCast As table
Dim zDoc As Document
ReDim decorators(1 To UBound(savedDeletedRows, 1), 0 To UBound(savedDeletedRows, 2), 2)
Set zDoc = ActiveDocument
Set savedDeletedRowsDoc = Documents.add
savedDeletedRowsDoc.Content.text = ""
zDoc.activate
savedDeletedRowsDoc.PageSetup.Orientation = wdOrientLandscape
With savedDeletedRowsDoc.Sections(1)
.Footers(wdHeaderFooterPrimary).PageNumbers.add
.Headers(wdHeaderFooterPrimary).Range.text = "Rows deleted from " & xDoc.fullName & " at " & format$(Now, "hh:mm") & " on " & format$(Now, "dd mmmm yyyy")
.Headers(wdHeaderFooterPrimary).Range.Bold = True
.Headers(wdHeaderFooterPrimary).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
End With
savedDeletedRowsDoc.Range.InsertParagraphAfter
For j = 1 To columnCount
savedDeletedRows(1, j) = xDetails.columnHeading(j)
Next j
savedDeletedRows(0, 0) = savedDeletedRowsDoc.Range.End - 1
progressBar.CancelButtonEnable xEnabled:=False
DoEvents
Set tableCast = BWordTableFromArray(savedDeletedRows, decorators, savedDeletedRowsDoc, savedDeletedRowsCount)
If tableCast Is Nothing Then
showMessage c8Msg6000, msgSuffix2:="WriteSavedDeletedRowsDoc: SaveDeletedRows failed. Last Error " & Err.Number & " (" & Err.Description & ")"""
Else
setTableCharacteristics tableCast
With progressBar
.AddProgress 0.035 / pbTablesToCheck
.Caption2 = c8PBComplete
.Caption3 = ""
End With
End If
savedDeletedRowsDoc.ActiveWindow.View = wdWebView
End Sub
Attribute VB_Name = "c8MC_FindReplace"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public Function ShowMatches()
frmInternalsReport.setDisplay "Matches"
frmInternalsReport.show
End Function
Public Function currentMatchIsAbbreviation() As Boolean
currentMatchIsAbbreviation = thisDocFinder.currentMatchData03
End Function
Public Function currentMatchIsBIU() As Boolean
Dim zFormat As clsFormat
Set zFormat = New clsFormat
zFormat.getFormat thisDocFinder.matchRangeFromIndex(thisDocFinder.currentMatchIndex), ThisDocument
On Error GoTo setFalse
currentMatchIsBIU = zFormat.Bold = formatAbbreviations.Bold And zFormat.Italic = formatAbbreviations.Italic And zFormat.Underline = formatAbbreviations.Underline
setFalse:
End Function
Attribute VB_Name = "c8MC_Formats"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public formatMatchesInBodyDefault As clsFormat
Public formatMatchesCurrentDefault As clsFormat
Public formatStyleNormal As clsFormat
Public formatRowStyleNormal As clsFormat
Public formatClearColors As clsFormat
Public formatAbbreviations As clsFormat
Public highlightsBright() As clsFormat
Public highlightsTint() As clsFormat
Public highlightsShade() As clsFormat
Public highlightsTone() As clsFormat
Public highlightsTextOnWhite() As clsFormat
Public highlightsColorsAndGrey() As clsFormat
Public highlightsMulticolor() As clsFormat
Public highlightsAll() As clsFormat
Public highlightsBrightStartIndex As Long
Public highlightsTintStartIndex As Long
Public highlightsShadeStartIndex As Long
Public highlightsToneStartIndex As Long
Public highlightsTextOnWhiteStartIndex As Long
Public highlightsColorsAndGreyStartIndex As Long
Public highlightsMulticolorStartIndex As Long
Public Function initialiseFormatDefaults()
Dim normal As Style
Dim i As Long
Dim highlightIndex As Long
Dim highlightsAllHighIndex As Long
Set formatMatchesInBodyDefault = New clsFormat
Set formatMatchesCurrentDefault = New clsFormat
Set formatStyleNormal = New clsFormat
Set formatClearColors = New clsFormat
Set formatRowStyleNormal = New clsFormat
Set formatAbbreviations = New clsFormat
Dim zColor1 As Long
Dim zColor2 As Long
Set normal = ThisDocument.Styles(wdStyleNormal)
With formatStyleNormal
.backColor = normal.Font.Shading.BackgroundPatternColor
.foreColor = normal.Font.Color
.Bold = normal.Font.Bold
.Italic = normal.Font.Italic
.Underline = normal.Font.Underline
End With
With formatClearColors
.backColor = normal.Font.Shading.BackgroundPatternColor
.foreColor = normal.Font.Color
End With
With formatRowStyleNormal
.backColor = normal.Font.Shading.BackgroundPatternColor
.BackColorCellText = normal.Font.Shading.BackgroundPatternColor
.BackColorCell = normal.Font.Shading.BackgroundPatternColor
.BackColorRowText = normal.Font.Shading.BackgroundPatternColor
.BackColorRow = normal.Font.Shading.BackgroundPatternColor
.foreColor = normal.Font.Color
.ForeColorCell = normal.Font.Color
.ForeColorRow = normal.Font.Color
.Bold = normal.Font.Bold
.Italic = normal.Font.Italic
.Underline = normal.Font.Underline
End With
With formatMatchesInBodyDefault
.backColor = wdColorTeal
.foreColor = wdColorWhite
End With
With formatMatchesCurrentDefault
.backColor = wdColorPink
.foreColor = wdColorWhite
End With
With formatAbbreviations
.backColor = wdUndefined
.Bold = True
.Italic = True
.Underline = wdUnderlineSingle
End With
thisDocFinder.initialiseFormatDefaults formatStyleNormal, formatMatchesInBodyDefault, formatMatchesCurrentDefault
ReDim highlightsBright(1 To 16)
For i = 1 To 8
zColor1 = thisDocColorManager.Base01(i)
Set highlightsBright(i) = New clsFormat
highlightsBright(i).backColor = zColor1
highlightsBright(i).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Base01A(i)
Set highlightsBright(i + 8) = New clsFormat
highlightsBright(i + 8).backColor = zColor1
highlightsBright(i + 8).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
Next i
ReDim highlightsTint(1 To 32)
For i = 1 To 8
zColor1 = thisDocColorManager.Tint01(i)
Set highlightsTint(i) = New clsFormat
highlightsTint(i).backColor = zColor1
highlightsTint(i).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Tint01A(i)
Set highlightsTint(i + 8) = New clsFormat
highlightsTint(i + 8).backColor = zColor1
highlightsTint(i + 8).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Tint02(i)
Set highlightsTint(i + 16) = New clsFormat
highlightsTint(i + 16).backColor = zColor1
highlightsTint(i + 16).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Tint02A(i)
Set highlightsTint(i + 24) = New clsFormat
highlightsTint(i + 24).backColor = zColor1
highlightsTint(i + 24).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
Next i
ReDim highlightsShade(1 To 32)
For i = 1 To 8
zColor1 = thisDocColorManager.Shade01(i)
Set highlightsShade(i) = New clsFormat
highlightsShade(i).backColor = zColor1
highlightsShade(i).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Shade01A(i)
Set highlightsShade(i + 8) = New clsFormat
highlightsShade(i + 8).backColor = zColor1
highlightsShade(i + 8).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Shade02(i)
Set highlightsShade(i + 16) = New clsFormat
highlightsShade(i + 16).backColor = zColor1
highlightsShade(i + 16).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Shade02A(i)
Set highlightsShade(i + 24) = New clsFormat
highlightsShade(i + 24).backColor = zColor1
highlightsShade(i + 24).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
Next i
ReDim highlightsTone(1 To 32)
For i = 1 To 8
zColor1 = thisDocColorManager.Tone01(i)
Set highlightsTone(i) = New clsFormat
highlightsTone(i).backColor = zColor1
highlightsTone(i).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Tone01A(i)
Set highlightsTone(i + 8) = New clsFormat
highlightsTone(i + 8).backColor = zColor1
highlightsTone(i + 8).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Tone02(i)
Set highlightsTone(i + 16) = New clsFormat
highlightsTone(i + 16).backColor = zColor1
highlightsTone(i + 16).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
zColor1 = thisDocColorManager.Tone02A(i)
Set highlightsTone(i + 24) = New clsFormat
highlightsTone(i + 24).backColor = zColor1
highlightsTone(i + 24).foreColor = thisDocColorManager.GetContrastingColor(zColor1)
Next i
ReDim highlightsTextOnWhite(1 To 16)
For i = 1 To 8
Set highlightsTextOnWhite(i) = New clsFormat
zColor1 = thisDocColorManager.TextOnWhite01(i)
highlightsTextOnWhite(i).foreColor = zColor1
highlightsTextOnWhite(i).backColor = wdColorWhite
zColor1 = thisDocColorManager.TextOnWhite01A(i)
Set highlightsTextOnWhite(i + 8) = New clsFormat
highlightsTextOnWhite(i + 8).foreColor = zColor1
highlightsTextOnWhite(i + 8).backColor = wdColorWhite
Next i
ReDim highlightsColorsAndGrey(1 To 32)
highlightIndex = 1
For i = 1 To 15 Step 2
zColor1 = thisDocColorManager.ColorsAndGrey01(i)
zColor2 = thisDocColorManager.ColorsAndGrey01(i + 1)
Set highlightsColorsAndGrey(highlightIndex) = New clsFormat
highlightsColorsAndGrey(highlightIndex).foreColor = zColor1
highlightsColorsAndGrey(highlightIndex).backColor = zColor2
Set highlightsColorsAndGrey(highlightIndex + 16) = New clsFormat
highlightsColorsAndGrey(highlightIndex + 16).foreColor = zColor2
highlightsColorsAndGrey(highlightIndex + 16).backColor = zColor1
zColor1 = thisDocColorManager.ColorsAndGrey01A(i)
zColor2 = thisDocColorManager.ColorsAndGrey01A(i + 1)
Set highlightsColorsAndGrey(highlightIndex + 8) = New clsFormat
highlightsColorsAndGrey(highlightIndex + 8).foreColor = zColor1
highlightsColorsAndGrey(highlightIndex + 8).backColor = zColor2
Set highlightsColorsAndGrey(highlightIndex + 24) = New clsFormat
highlightsColorsAndGrey(highlightIndex + 24).foreColor = zColor2
highlightsColorsAndGrey(highlightIndex + 24).backColor = zColor1
highlightIndex = highlightIndex + 1
Next i
ReDim highlightsMulticolor(1 To 32)
highlightIndex = 1
For i = 1 To 15 Step 2
zColor1 = thisDocColorManager.Multicolor01(i)
zColor2 = thisDocColorManager.Multicolor01(i + 1)
Set highlightsMulticolor(highlightIndex) = New clsFormat
highlightsMulticolor(highlightIndex).foreColor = zColor1
highlightsMulticolor(highlightIndex).backColor = zColor2
Set highlightsMulticolor(highlightIndex + 16) = New clsFormat
highlightsMulticolor(highlightIndex + 16).foreColor = zColor2
highlightsMulticolor(highlightIndex + 16).backColor = zColor1
zColor1 = thisDocColorManager.Multicolor01A(i)
zColor2 = thisDocColorManager.Multicolor01A(i + 1)
Set highlightsMulticolor(highlightIndex + 8) = New clsFormat
highlightsMulticolor(highlightIndex + 8).foreColor = zColor1
highlightsMulticolor(highlightIndex + 8).backColor = zColor2
Set highlightsMulticolor(highlightIndex + 24) = New clsFormat
highlightsMulticolor(highlightIndex + 24).foreColor = zColor2
highlightsMulticolor(highlightIndex + 24).backColor = zColor1
highlightIndex = highlightIndex + 1
Next i
highlightsAllHighIndex = UBound(highlightsBright) + UBound(highlightsTint) + UBound(highlightsShade) + UBound(highlightsTone) + UBound(highlightsTextOnWhite) + UBound(highlightsColorsAndGrey) + UBound(highlightsMulticolor)
ReDim highlightsAll(0 To highlightsAllHighIndex)
highlightIndex = 0
Set highlightsAll(highlightIndex) = formatClearColors
highlightsMulticolorStartIndex = 1
For i = 1 To UBound(highlightsMulticolor)
highlightIndex = highlightIndex + 1
Set highlightsAll(highlightIndex) = highlightsMulticolor(i)
Next
highlightsTintStartIndex = highlightIndex + 1
For i = 1 To UBound(highlightsTint)
highlightIndex = highlightIndex + 1
Set highlightsAll(highlightIndex) = highlightsTint(i)
Next i
highlightsShadeStartIndex = highlightIndex + 1
For i = 1 To UBound(highlightsShade)
highlightIndex = highlightIndex + 1
Set highlightsAll(highlightIndex) = highlightsShade(i)
Next i
highlightsToneStartIndex = highlightIndex + 1
For i = 1 To UBound(highlightsTone)
highlightIndex = highlightIndex + 1
Set highlightsAll(highlightIndex) = highlightsTone(i)
Next i
highlightsTextOnWhiteStartIndex = highlightIndex + 1
For i = 1 To UBound(highlightsTextOnWhite)
highlightIndex = highlightIndex + 1
Set highlightsAll(highlightIndex) = highlightsTextOnWhite(i)
Next i
highlightsColorsAndGreyStartIndex = highlightIndex + 1
For i = 1 To UBound(highlightsColorsAndGrey)
highlightIndex = highlightIndex + 1
Set highlightsAll(highlightIndex) = highlightsColorsAndGrey(i)
Next i
highlightsBrightStartIndex = highlightIndex + 1
For i = 1 To UBound(highlightsBright)
highlightIndex = highlightIndex + 1
Set highlightsAll(highlightIndex) = highlightsBright(i)
Next i
End Function
Public Function colorSchemeStartIndex(xScheme As String) As Long
Select Case xScheme
Case colorSchemeBright
colorSchemeStartIndex = highlightsBrightStartIndex
Case colorSchemeTint
colorSchemeStartIndex = highlightsTintStartIndex
Case colorSchemeShade
colorSchemeStartIndex = highlightsShadeStartIndex
Case colorSchemeTone
colorSchemeStartIndex = highlightsToneStartIndex
Case colorSchemeTextOnWhite
colorSchemeStartIndex = highlightsTextOnWhiteStartIndex
Case colorSchemeColorsAndGreys
colorSchemeStartIndex = highlightsColorsAndGreyStartIndex
Case colorSchemeMixed
colorSchemeStartIndex = highlightsMulticolorStartIndex
End Select
End Function
Public Function createSwatchDocument() As Document
Dim R As Range
Dim zRange As Range
Dim d As Document
Dim t As table
Dim refNum As Long
Dim fmt As clsFormat
Dim sourceExample As String
Const lorem As String = "Chronolator - the Chronology Tool"
Const sourcePrefix As String = "Berrick Police >"
Const sourceTrailer As String = " New Town Station > Custody records"
Set d = Documents.add
d.Content.text = ""
d.ActiveWindow.Visible = False
ThisDocument.activate
DoEvents
sourceExample = sourcePrefix & sourceTrailer
Set fmt = highlightsMulticolor(1)
Set R = d.Range
R.Style = wdStyleHeading1
R.InsertAfter "Scope"
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
R.Style = wdStyleNormal
R.InsertAfter "The Scope determines the extent of the highlighting. Each row in the following table illustrates a different scope," & " using the text '" & sourcePrefix & "' as an example."
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
R.InsertAfter "Scope" & vbTab & "" & vbTab & "" & vbTab & "" & vbNewLine
R.InsertAfter "Text" & vbTab & sourceExample & vbTab & lorem & vbTab & lorem & vbNewLine
R.InsertAfter "Cell Text" & vbTab & sourceExample & vbTab & lorem & vbTab & lorem & vbNewLine
R.InsertAfter "Row Text" & vbTab & sourceExample & vbTab & lorem & vbTab & lorem & vbNewLine
R.InsertAfter "Cell" & vbTab & sourceExample & vbTab & lorem & vbTab & lorem & vbNewLine
R.InsertAfter "Row" & vbTab & sourceExample & vbTab & lorem & vbTab & lorem & vbNewLine
R.ConvertToTable format:=wdTableFormatGrid1, Applyborders:=True
Set t = R.tables(1)
Call setTableCharacteristics(t)
Set zRange = t.rows(2).Cells(2).Range
Set R = d.Range(zRange.Start, zRange.Start + Len(sourcePrefix))
fmt.setFormat R, d, xPropagateFore:=0, xPropagateBack:=0
Set zRange = t.rows(3).Cells(2).Range
Set R = d.Range(zRange.Start, zRange.Start + Len(sourcePrefix))
fmt.setFormat R, d, xPropagateFore:=fmt.PropagateToCellText, xPropagateBack:=fmt.PropagateToCellText
Set zRange = t.rows(4).Cells(2).Range
Set R = d.Range(zRange.Start, zRange.Start + Len(sourcePrefix))
fmt.setFormat R, d, xPropagateFore:=fmt.PropagateToRowText, xPropagateBack:=fmt.PropagateToRowText
Set zRange = t.rows(5).Cells(2).Range
Set R = d.Range(zRange.Start, zRange.Start + Len(sourcePrefix))
fmt.setFormat R, d, xPropagateFore:=fmt.PropagateToCellText, xPropagateBack:=fmt.PropagateToCell
Set zRange = t.rows(6).Cells(2).Range
Set R = d.Range(zRange.Start, zRange.Start + Len(sourcePrefix))
fmt.setFormat R, d, xPropagateFore:=fmt.PropagateToRowText, xPropagateBack:=fmt.PropagateToRow
Set R = d.Range
R.Collapse wdCollapseEnd
R.Style = wdStyleHeading1
R.InsertAfter "Colour Schemes"
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
R.Style = wdStyleNormal
R.InsertAfter "The built-in Colour Schemes provide a quick way to set the highlighting for all prefixes. " & "You can override the scheme colour for a particular prefix by using the 'Custom Settings' controls."
R.InsertParagraphAfter
R.InsertAfter "Use the first number in each box below to assign a highlight to a source prefix. " & "Use the number 0 if you do not want to highlight a prefix."
R.InsertParagraphAfter
R.InsertAfter "The numbers in brackets give an idea of how legible the highlight might be when viewed on a computer screen. They are calculated " & "using the Web Content Accessibility Guidelines (Version 2.0) at http://www.w3.org/TR/WCAG/. Higher values represent better legibility. " & "All of the Chronolator Colour Scheme highlights meet or exceed WCAG level AA."
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
R.Style = wdStyleHeading2
R.InsertAfter "None"
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
R.Style = wdStyleNormal
R.InsertAfter "Use the 'None' scheme if you only want to highlight selected source prefixes. Set their individual highlights using the 'Custom Settings' controls."
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
refNum = 1
Call createSwatchTable(d, refNum, highlightsMulticolor, "Mixed Colours")
refNum = refNum + UBound(highlightsMulticolor)
Call createSwatchTable(d, refNum, highlightsTint, "Tints")
refNum = refNum + UBound(highlightsTint)
Call createSwatchTable(d, refNum, highlightsShade, "Shades")
refNum = refNum + UBound(highlightsShade)
Call createSwatchTable(d, refNum, highlightsTone, "Tones")
refNum = refNum + UBound(highlightsTone)
Call createSwatchTable(d, refNum, highlightsTextOnWhite, "Text On White")
refNum = refNum + UBound(highlightsTextOnWhite)
Call createSwatchTable(d, refNum, highlightsColorsAndGrey, "Colours And Grey")
refNum = refNum + UBound(highlightsColorsAndGrey)
Call createSwatchTable(d, refNum, highlightsBright, "Bright")
Set createSwatchDocument = d
End Function
Sub createSwatchTable(xDoc As Document, xRefStart As Long, xHighlights() As clsFormat, xHeader As String)
Dim R As Range
Dim t As table
Dim rowNum As Long
Dim highlightsIndex As Long
Dim cellNum As Long
Dim i  As Long
Dim rowRefStart As Long
Dim rowCount As Long
Dim zContrast As String
Set R = xDoc.Range
R.Collapse wdCollapseEnd
R.Style = wdStyleHeading2
R.InsertAfter xHeader
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
rowCount = UBound(xHighlights) / 8
rowRefStart = xRefStart
highlightsIndex = 1
For rowNum = 1 To rowCount
For cellNum = 0 To 6
zContrast = ".(" & format$(thisDocColorManager.WCAGColorContrast(xHighlights(highlightsIndex).foreColor, xHighlights(highlightsIndex).backColor), "0.00") & ")"
R.InsertAfter format$((rowRefStart + cellNum), "000") & zContrast & vbTab
highlightsIndex = highlightsIndex + 1
Next
zContrast = ".(" & format$(thisDocColorManager.WCAGColorContrast(xHighlights(highlightsIndex).foreColor, xHighlights(highlightsIndex).backColor), "0.00") & ")"
R.InsertAfter format$((rowRefStart + cellNum), "000") & zContrast & vbNewLine
highlightsIndex = highlightsIndex + 1
rowRefStart = rowRefStart + 8
Next
Set t = R.ConvertToTable(format:=wdTableFormatGrid1, Applyborders:=True)
R.Style = wdStyleNormal
R.ParagraphFormat.Alignment = wdAlignParagraphCenter
For i = 1 To UBound(xHighlights)
rowNum = (i - 1) \ 8 + 1
cellNum = (i - 1) Mod 8 + 1
xHighlights(i).setFormat t.rows(rowNum).Cells(cellNum).Range, xDoc, , 1
Next
Set R = t.Range
With R.Find
.text = ".("
.Replacement.text = "^l("
.Execute replace:=wdReplaceAll
End With
End Sub
Attribute VB_Name = "c8MC_Highlighting"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public Const colorSchemeNone As String = "None"
Public Const colorSchemeBright As String = "Bright"
Public Const colorSchemeTint As String = "Tint"
Public Const colorSchemeShade As String = "Shade"
Public Const colorSchemeTone As String = "Tone"
Public Const colorSchemeTextOnWhite As String = "Text on White"
Public Const colorSchemeColorsAndGreys As String = "Colours and Greys"
Public Const colorSchemeMixed As String = "Mixed Colours"
Public Const scopeText As String = "Text"
Public Const scopeCellText As String = "Cell Text"
Public Const scopeRowText As String = "Row Text"
Public Const scopeCell As String = "Cell"
Public Const scopeRow As String = "Row"
Enum scopeType
tableElement
textElement
End Enum
Dim listFound As Boolean
Dim newScope As String
Dim newScheme As String
Dim previousScope As String
Sub highlightSources(xScope As String)
Dim pbWeightingPhase1 As Double
Dim pbWeightingPhase2 As Double
Dim pbWeightingPhase3 As Double
Dim pbWeightingPhase4 As Double
Dim pbWeightingPhase5 As Double
Dim pbWeightingPhase6 As Double
Dim pbRemaining As Double
Dim pbWeightings(1 To 6) As Double
Dim i As Long
Dim tablesfound As Variant
Dim tableCount As Long
Dim sw1 As clsStopWatch
Dim performanceOptionsStore() As Variant
Dim docSave As String
Dim saveStatus As Boolean
Dim zStringArray() As String
Dim clearRequired() As Boolean
Dim statsScope As String
Dim statsScheme As String
Dim highLevelSourcePrefixes() As String
Dim sourceFragments() As String
Dim normaliseSourceRequired As Boolean
Dim sortRequired As Boolean
performanceOptionsStore = BWordPerformanceOptionsSet()
saveStatus = ThisDocument.Saved
statsScheme = ""
statsScope = ""
Set sw1 = New clsStopWatch
sw1.Start
With progressBar
.Reset
.title = "Highlight Source of Information"
.Caption1 = c8PBAnalysingTables
.CancelButtonEnable False
.show
End With
DoEvents
Application.screenUpdating = False
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor))
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015, msgSuffix1:=" " & ThisDocument.name)
GoTo finish
Else
tableCount = UBound(tablesfound) + 1
Call setProgressBarCounters(ThisDocument, tablesfound)
listFound = False
End If
If pbRowsToCheck = 0 Then
GoTo finish
End If
highLevelSourcePrefixes = GetHighLevelSourcePrefixes
sourceFragments = GetSourceFragments
docSave = thisDocSaver.documentSave(ThisDocument)
progressBar.Caption2 = c8PBCheckingSPN
normaliseSourceRequired = (thisDocSourcePrefixes.count > 0) And (thisDocDescriptor.tablesHash2 <> tablesHash(tablesfound, ThisDocument, thisDocDescriptor.columnSource))
sortRequired = (InStr(scopeCell & scopeRow, xScope) > 0)
zStringArray = ppH_ScopeAndSchemeGet
newScope = zStringArray(0)
newScheme = zStringArray(1)
clearRequired = highlightClearRequired
pbWeightingPhase1 = 0.1
If normaliseSourceRequired Then pbWeightingPhase2 = 0.2
If clearRequired(0) Or clearRequired(1) Then pbWeightingPhase3 = 0.05
If sortRequired Then pbWeightingPhase6 = 0.05
pbRemaining = 1 - (pbWeightingPhase1 + pbWeightingPhase2 + pbWeightingPhase3 + pbWeightingPhase6)
pbWeightingPhase4 = pbRemaining / 2
pbWeightingPhase5 = pbWeightingPhase4
pbWeightings(1) = pbWeightingPhase1: pbWeightings(2) = pbWeightingPhase2: pbWeightings(3) = pbWeightingPhase3
pbWeightings(4) = pbWeightingPhase4: pbWeightings(5) = pbWeightingPhase5: pbWeightings(6) = pbWeightingPhase6
progressBar.Progress = pbWeightingPhase1
sw1.Halt
If normaliseSourceRequired Then
If sourcePrefixNormalise(tablesfound, sourceFragments, thisDocDescriptor.columnSource, xAddProgress:=pbWeightingPhase2 / pbRowsToCheck) = "" Then
Else
progressBar.userCancelled = True
End If
End If
If progressBar.userCancelled Then GoTo highlightCancelled
progressBar.Progress = pbWeightingPhase1 + pbWeightingPhase2
sw1.Start
For i = 0 To tableCount - 1
With progressBar
.CancelButtonEnable False
.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & tableCount
End With
If clearRequired(0) Or clearRequired(1) Then
With progressBar
.Caption2 = c8PBClearingPreviousHighlights
.CancelButtonEnable False
End With
Call highlightSourceClearInTable(ThisDocument.tables(CLng(tablesfound(i))), clearRequired(0), clearRequired(1))
DoEvents
End If
Call highlightTable(xTableIndex:=CLng(tablesfound(i)), xHighLevelPrefixes:=highLevelSourcePrefixes, xScope:=xScope, xPBWeightings:=pbWeightings)
If progressBar.userCancelled Then GoTo highlightCancelled
Next i
With progressBar
If .userCancelled Then
GoTo highlightCancelled
Else
.Caption1 = c8PBFinishing
.Caption2 = ""
.CancelButtonEnable False
End If
End With
If sortRequired Then
progressBar.Caption2 = c8PBSortingTables
If sortTablesAsDescriptor(xMergeMultipleTablesPrompt:=False, xProgressTitle:=progressBar.title) Then
Else
showMessage c8Msg6000, msgSuffix2:="highlightSources: Sort failed"
GoTo highlightCancelled
End If
End If
GoTo highlightCompleted
highlightCancelled:
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
Application.screenUpdating = False
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
progressBar.finish
Call showMessage(c8Msg3020)
GoTo finish
highlightCompleted:
Select Case newScope
Case scopeText
statsScope = "T"
Case scopeCellText
statsScope = "CT"
Case scopeRowText
statsScope = "RT"
Case scopeCell
statsScope = "C"
Case scopeRow
statsScope = "R"
End Select
Select Case newScheme
Case colorSchemeNone
statsScheme = "None"
Case colorSchemeBright
statsScheme = "Bright"
Case colorSchemeTint
statsScheme = "Tint"
Case colorSchemeShade
statsScheme = "Shade"
Case colorSchemeTone
statsScheme = "Tone"
Case colorSchemeTextOnWhite
statsScheme = "TxtWhi"
Case colorSchemeColorsAndGreys
statsScheme = "C&G"
Case colorSchemeMixed
statsScheme = "Mixed"
End Select
ppStats_Update ppStats_HighlightSource, pbTablesToCheck, pbRowsToCheck, sw1.value, xField1:=statsScope, xField2:=statsScheme
If listFound Then showMessage msg:=c8Msg3200
finish:
Application.screenUpdating = True
Call thisDocSaver.closeSingle(docSave)
progressBar.Hide
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
ThisDocument.UndoClear
End Sub
Sub highlightTable(xTableIndex As Long, xHighLevelPrefixes() As String, xScope As String, xPBWeightings() As Double)
Dim sw1 As clsStopWatch
Dim columnWidths() As Long
Dim tabl As table
Set sw1 = New clsStopWatch
sw1.Start
Set tabl = ThisDocument.tables(xTableIndex)
columnWidths = BWordTableGetColumnWidths(tabl)
With progressBar
.Caption2 = c8PBCheckingLists
.CancelButtonEnable
End With
If CheckForListsInTable(tabl) Then listFound = True
If progressBar.userCancelled Then Exit Sub
With progressBar
.Caption2 = c8PBFindingPrefixes
End With
Select Case xScope
Dim newTable As table
Case scopeText
Set newTable = highlightTextScopes(tabl, xHighLevelPrefixes, xScope, xPBWeightings())
Case scopeCellText
Set newTable = highlightTextScopes(tabl, xHighLevelPrefixes, xScope, xPBWeightings())
Case scopeRowText
Set newTable = highlightTextScopes(tabl, xHighLevelPrefixes, xScope, xPBWeightings())
Case scopeCell
Call highlightCells(tabl, xHighLevelPrefixes, xPBWeightings())
Case scopeRow
Call highlightRows(tabl, xHighLevelPrefixes, xPBWeightings())
End Select
progressBar.Caption2 = c8PBSettingColumnWidths
BWordTableSetColumnWidths newTable, columnWidths
End Sub
Function highlightTextScopes(xTable As table, xHighLevelPrefixes() As String, xScope As String, xPBWeightings() As Double) As table
Dim namecount As Long
Dim extendToPreviousParagraph As Boolean
Dim tableRange As Range
Dim progressBarIncrement As Double
Dim i As Long
Dim zSource As String
Dim searchString As String
Dim fmt As clsFormat
Dim finder As clsFindReplace
namecount = UBound(xHighLevelPrefixes) + 1
Set tableRange = BWordTableToText(xTable)
progressBarIncrement = 0.95 * (xPBWeightings(4) / (pbTablesToCheck * namecount))
Set finder = New clsFindReplace
For i = 0 To namecount - 1
zSource = xHighLevelPrefixes(i)
Select Case xScope
Case scopeText
searchString = zSource & "\" & c8SourceDelimiter
extendToPreviousParagraph = False
Case scopeCellText
searchString = zSource & "\" & c8SourceDelimiter & "*^0157"
extendToPreviousParagraph = False
Case scopeRowText
searchString = zSource & "\" & c8SourceDelimiter & "*^0013"
extendToPreviousParagraph = True
End Select
Set fmt = highlightsAll(getHighlightIndex(zSource & c8SourceDelimiter))
progressBar.CancelButtonEnable
Call finder.matchesIdentify(searchString, xCaptionString:=zSource & c8SourceDelimiter, xAtStartOfColumn:=(-thisDocDescriptor.columnSource), xClear:=False, xData01:=fmt, xSortMatches:=False, xRange:=tableRange, xMatchWildcards:=True, xExtendMatchToPreviousParagraph:=extendToPreviousParagraph)
If progressBar.userCancelled Then Exit Function
progressBar.AddProgress progressBarIncrement
Next i
finder.matchesSort
progressBar.Caption3 = ""
If progressBar.userCancelled Then Exit Function
progressBarIncrement = 0.95 * (xPBWeightings(5) / (pbTablesToCheck * BMax(finder.matchesCount, 1)))
With progressBar
.Caption2 = c8PBAddingHighlights
End With
finder.matchesformat xAddProgress:=progressBarIncrement
If progressBar.userCancelled Then Exit Function
With progressBar
.Caption2 = c8Name & c8PBWaitingProcessing
.Caption3 = ""
.CancelButtonEnable False
End With
Set highlightTextScopes = BWordTextToTable(tableRange, xSetFormat:=True, xSetStyleNormal:=False)
End Function
Sub highlightCells(xTable As table, xHighLevelPrefixes() As String, xPBWeightings() As Double)
Dim i As Long
Dim fmt As clsFormat
Dim progressBarIncrement As Double
Dim zRange As Range
Dim sourceRanges As Variant
Dim startRangeRowNumber As Long
Dim endRangeRowNumber As Long
Dim R As row
Dim c As Cell
Dim rI As Long
Dim cI As Long
Dim namecount As Long
namecount = UBound(xHighLevelPrefixes) + 1
sourceRanges = highlightTableElementsPrepare(xTable, xHighLevelPrefixes, xPBWeightings)
If progressBar.userCancelled Then Exit Sub
progressBar.Caption3 = ""
progressBar.CancelButtonEnable
progressBarIncrement = xPBWeightings(5) / (pbTablesToCheck * namecount)
For i = 0 To UBound(xHighLevelPrefixes)
progressBar.Caption2 = c8PBHighlightingRange & i + 1 & c8PBOf & UBound(xHighLevelPrefixes) + 1
If sourceRanges(0)(i) > -1 Then
Set fmt = highlightsAll(getHighlightIndex(xHighLevelPrefixes(i) & c8SourceDelimiter))
Set zRange = xTable.Parent.Range(sourceRanges(0)(i), sourceRanges(1)(i))
startRangeRowNumber = zRange.Information(wdStartOfRangeRowNumber)
endRangeRowNumber = zRange.Information(wdEndOfRangeRowNumber)
rI = 0
For Each R In xTable.rows
rI = rI + 1
If rI > endRangeRowNumber Or rI < startRangeRowNumber Then
GoTo nextRow
Else
cI = 0
For Each c In R.Cells
cI = cI + 1
If cI < thisDocDescriptor.columnSource Then
GoTo nextCell
Else
If cI > thisDocDescriptor.columnSource Then
GoTo nextRow
Else
c.Range.Shading.BackgroundPatternColor = fmt.backColor
c.Range.Font.Shading.BackgroundPatternColor = fmt.backColor
c.Range.Font.Color = fmt.foreColor
End If
End If
nextCell:
Next c
End If
nextRow:
Next R
progressBar.AddProgress progressBarIncrement
If progressBar.userCancelled Then Exit Sub
End If
Next
progressBar.Caption2 = ""
End Sub
Sub highlightRows(xTable As table, xHighLevelPrefixes() As String, xPBWeightings() As Double)
Dim i As Long
Dim fmt As clsFormat
Dim progressBarIncrement As Double
Dim zRange As Range
Dim sourceRanges As Variant
Dim namecount As Long
namecount = UBound(xHighLevelPrefixes) + 1
sourceRanges = highlightTableElementsPrepare(xTable, xHighLevelPrefixes, xPBWeightings)
If progressBar.userCancelled Then Exit Sub
progressBar.Caption3 = ""
progressBar.CancelButtonEnable
progressBarIncrement = xPBWeightings(5) / (pbTablesToCheck * namecount)
For i = 0 To UBound(xHighLevelPrefixes)
progressBar.Caption2 = c8PBHighlightingRange & i + 1 & c8PBOf & UBound(xHighLevelPrefixes) + 1
If sourceRanges(0)(i) > -1 Then
Set fmt = highlightsAll(getHighlightIndex(xHighLevelPrefixes(i) & c8SourceDelimiter))
Set zRange = xTable.Parent.Range(sourceRanges(0)(i), sourceRanges(1)(i))
zRange.Shading.BackgroundPatternColor = fmt.backColor
progressBar.AddProgress progressBarIncrement / 3
zRange.Font.Shading.BackgroundPatternColor = fmt.backColor
progressBar.AddProgress progressBarIncrement / 3
zRange.Font.Color = fmt.foreColor
progressBar.AddProgress progressBarIncrement / 3
Else
progressBar.AddProgress progressBarIncrement
End If
If progressBar.userCancelled Then Exit Sub
Next
progressBar.Caption2 = ""
End Sub
Function highlightTableElementsPrepare(xTable As table, xHighLevelPrefixes() As String, xPBWeightings() As Double) As Variant
Dim i As Long
Dim zLong As Long
Dim sourcePrefix As String
Dim sourceRangeStart() As Long
Dim sourceRangeEnd() As Long
Dim searchRange As Range
Dim zRowNumber As Long
Dim out(0 To 1) As Variant
Dim progressBarIncrement As Double
Dim namecount As Long
namecount = UBound(xHighLevelPrefixes) + 1
ReDim sourceRangeStart(UBound(xHighLevelPrefixes))
ReDim sourceRangeEnd(UBound(xHighLevelPrefixes))
progressBarIncrement = xPBWeightings(4) / (pbTablesToCheck * namecount)
Set searchRange = xTable.Range
xTable.Sort excludeheader:=True, FieldNumber:=thisDocDescriptor.columnSource, SortFieldType:=wdSortFieldAlphanumeric, sortOrder:=wdSortOrderAscending
For i = 0 To UBound(xHighLevelPrefixes)
sourcePrefix = xHighLevelPrefixes(i) & c8SourceDelimiter
sourceRangeStart(i) = -1
sourceRangeEnd(i) = -1
progressBar.Caption3 = sourcePrefix
zLong = searchRange.Start
With searchRange.Find
.matchWildcards = False
.MatchCase = True
.text = sourcePrefix
If .Execute Then
zRowNumber = searchRange.Information(wdStartOfRangeRowNumber)
If Left$(xTable.rows(zRowNumber).Cells(thisDocDescriptor.columnSource).Range.text, Len(sourcePrefix)) = sourcePrefix Then
sourceRangeStart(i) = xTable.rows(zRowNumber).Range.Start
searchRange.Collapse wdCollapseEnd: searchRange.End = xTable.Range.End
Else
searchRange.Start = zLong
searchRange.Expand wdTable
End If
End If
End With
progressBar.AddProgress progressBarIncrement
If progressBar.userCancelled Then Exit Function
Next
For i = 0 To UBound(sourceRangeStart)
If sourceRangeStart(i) > -1 Then sourceRangeEnd(i) = getEndOfRange(sourceRangeStart, i + 1, xTable.Range.End)
Next
out(0) = sourceRangeStart
out(1) = sourceRangeEnd
highlightTableElementsPrepare = out
End Function
Sub highlightSourceClear()
Dim tablesfound As Variant
Dim tableCount As Long
Dim i As Long
Dim sw1 As clsStopWatch
Dim performanceOptionsStore() As Variant
performanceOptionsStore = BWordPerformanceOptionsSet()
Set sw1 = New clsStopWatch
sw1.Start
Application.screenUpdating = False
With progressBar
.Reset
.title = "Clear Source of Information Highlights"
.show
.AddProgress 0.01
.CancelButtonEnable False
End With
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tablesfound) Then
progressBar.finish
Call showMessage(c8Msg1015, msgSuffix1:=" " & ThisDocument.name)
GoTo finish
Else
tableCount = UBound(tablesfound) + 1
Call setProgressBarCounters(ThisDocument, tablesfound)
End If
For i = 0 To tableCount - 1
progressBar.Caption1 = c8PBClearingHighlights & i + 1 & c8PBOf & tableCount
Call highlightSourceClearInTable(ThisDocument.tables(CLng(tablesfound(i))), xClearTableElements:=True, xClearFont:=True)
progressBar.Progress = (i + 1) / tableCount
Next
Call ppH_SourceHighlightingRemoveInfo
buttonHighlightSourceClear.Enabled = False
progressBar.finish
finish:
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
End Sub
Sub highlightSourceClearInTable(xTable As table, xClearFont As Boolean, xClearTableElements As Boolean)
Dim tableRange As Range
Set tableRange = xTable.Range
If xClearFont Then
progressBar.Caption3 = c8PBClearingFontHighlights
tableRange.Font.Color = wdColorAutomatic
tableRange.Font.Shading.BackgroundPatternColor = wdColorAutomatic
End If
If xClearTableElements Then
progressBar.Caption3 = c8PBClearingBackgrounds
tableRange.Shading.BackgroundPatternColor = wdColorAutomatic
End If
progressBar.Caption3 = c8PBSettingTableCharacteristics
setTableCharacteristics xTable, xSetStyleNormal:=False
progressBar.Caption3 = ""
End Sub
Function highlightClearRequired() As Boolean()
Dim out(1) As Boolean
out(0) = False
out(1) = False
If getScopeType(previousScope) = tableElement Then
If getScopeType(newScope) = tableElement Then
If ((previousScope = scopeRow) And (newScope = scopeCell)) Then
out(0) = True
out(1) = True
End If
Else
out(0) = True
out(1) = True
End If
Else
If getScopeType(newScope) = tableElement Then
out(0) = True
Else
Select Case newScope
Case scopeRowText
Case scopeCellText
If previousScope = scopeRowText Then out(0) = True
Case scopeText
If previousScope <> scopeText Then out(0) = True
End Select
End If
End If
highlightClearRequired = out
End Function
Function getScopeType(xScope As String) As scopeType
Select Case xScope
Case scopeText
getScopeType = textElement
Case scopeCellText
getScopeType = textElement
Case scopeRowText
getScopeType = textElement
Case scopeCell
getScopeType = tableElement
Case scopeRow
getScopeType = tableElement
End Select
End Function
Sub highlightSourceUI()
Dim namecount As Long
Dim i As Long
Dim zStringArray() As String
Dim sourcePrefixes() As String
Dim scope As String
Dim scheme As String
Dim highlightIndices() As Long
Dim customisedIndices() As Boolean
Dim defaultHighlightIndex As Long
If c8Msg7010Shown = c8Msg7010Highlight Then
Else
c8Msg7010Shown = c8Msg7010Highlight
If showMessage(c8Msg7010, msgPrefix2:="Formatting introduced while using the Highlight Source", button2:="OK", button3:="Cancel") = "OK" Then
Else
Exit Sub
End If
End If
If checkDescriptor(thisDocDescriptor, xShowMessage:=True, xErrorMessage:=c8Msg5400) Then
sourcePrefixes = GetHighLevelSourcePrefixes
namecount = UBound(sourcePrefixes)
Else
Exit Sub
End If
frmHighlightSource.initialiseSourcePrefixComboBox sourcePrefixes
ReDim highlightIndices(namecount)
ReDim customisedIndices(namecount)
zStringArray = ppH_ScopeAndSchemeGet
scope = zStringArray(0)
scheme = zStringArray(1)
If Len(scope) = 0 Then scope = scopeText
If Len(scheme) = 0 Then scheme = colorSchemeMixed
previousScope = scope
defaultHighlightIndex = colorSchemeStartIndex(scheme)
For i = 0 To namecount
highlightIndices(i) = getHighlightIndex(sourcePrefixes(i) & c8SourceDelimiter)
Select Case highlightIndices(i)
Case Is < 0
highlightIndices(i) = defaultHighlightIndex
Case Is = defaultHighlightIndex
Case Else
customisedIndices(i) = True
End Select
defaultHighlightIndex = BAddOneModular(defaultHighlightIndex, UBound(highlightsAll))
Next
frmHighlightSource.initialiseFormatIndices highlightIndices, customisedIndices
frmHighlightSource.setSpinnerLimits LBound(highlightsAll), UBound(highlightsAll)
frmHighlightSource.setCustomControlsState
frmHighlightSource.setRadioButtons scope, scheme
frmHighlightSource.show vbModeless
End Sub
Public Sub setHighlightIndex(xString As String, xIndex As Long, xOverwrite As Boolean)
If xOverwrite Then
Else
If getHighlightIndex(xString) < 0 Then
Else
Exit Sub
End If
End If
ppH_HighlightSourceIndexSet xString, xIndex
End Sub
Function getEndOfRange(xStarts() As Long, xStartAtIndex As Long, xEndOfTable As Long) As Long
Dim i As Long
Dim out As Long
out = xEndOfTable
For i = xStartAtIndex To UBound(xStarts)
If xStarts(i) > -1 Then
out = xStarts(i) - 1
Exit For
End If
Next
getEndOfRange = out
End Function
Public Function getHighlightIndex(xString As String) As Long
getHighlightIndex = ppH_HighlightSourceIndexGet(xString)
End Function
Public Sub deleteHighlightIndex(xString As String)
ppH_HighlightSourceIndexDelete xString
End Sub
Public Sub setScopeAndScheme(xScope As String, xScheme As String)
ppH_ScopeAndSchemeSet xScope, xScheme
End Sub
Public Function createPreviewDocument(xHighlightsIndices() As Long, xScope As String, xScheme As String) As Document
Dim i As Long
Dim j As Long
Dim R As Range
Dim d As Document
Dim t As table
Dim fmt As clsFormat
Dim sourcePrefixes() As String
Dim sourcePrefixRange As Range
Dim zRow As row
Dim generalHeadingStartCol As Long
Dim propagateFore As Long
Dim propagateBack As Long
Dim zString As String
Dim defaultHighlightIndex As Long
Const lorem1 As String = "Chronolator"
Const lorem2 As String = "The Chronology Tool"
Set d = Documents.add
d.Content.text = ""
d.ActiveWindow.Visible = False
d.PageSetup.Orientation = wdOrientLandscape
ThisDocument.activate
DoEvents
generalHeadingStartCol = BMax(thisDocDescriptor.columnSource, thisDocDescriptor.columnGlossary) + 1
Set R = d.Range
R.Collapse wdCollapseEnd
R.Style = wdStyleHeading1
R.InsertAfter "Source Prefix Highlight Preview"
R.InsertParagraphAfter
R.Collapse wdCollapseEnd
R.Style = wdStyleNormal
zString = ""
defaultHighlightIndex = colorSchemeStartIndex(xScheme)
For i = 0 To UBound(xHighlightsIndices)
If xScheme = colorSchemeNone Then defaultHighlightIndex = 0
If xHighlightsIndices(i) = defaultHighlightIndex Then
Else
zString = " (customised)"
Exit For
End If
defaultHighlightIndex = BAddOneModular(defaultHighlightIndex, UBound(highlightsAll))
Next
R.InsertAfter "Scheme: " & xScheme & zString & vbNewLine
R.InsertAfter "Scope: " & xScope & vbNewLine
R.Font.Bold = True
R.Collapse wdCollapseEnd
R.Font.Bold = False
If generalHeadingStartCol <= thisDocDescriptor.columnCount Then
R.InsertAfter "The first number in the <" & thisDocDescriptor.columnHeading(generalHeadingStartCol) & "> column below is the highlight reference number."
R.InsertParagraphAfter
R.InsertAfter "The number in brackets is an indication of how legible the highlight might be when viewed on a computer screen. It is calculated " & "using the Web Content Accessibility Guidelines at http://www.w3.org/TR/WCAG/. Higher values represent better legibility. " & "All of the Chronolator highlights meet or exceed WCAG level AA."
End If
R.InsertParagraphAfter
R.InsertParagraphAfter
sourcePrefixes = GetHighLevelSourcePrefixes
Call TableWrite(d, thisDocDescriptor, xHeadersOnly:=True, xAddSection:=False)
Set t = d.tables(1)
For i = 1 To UBound(sourcePrefixes) + 1
t.rows.add
Next
t.Range.Shading.Texture = wdTextureNone
t.Range.Shading.BackgroundPatternColor = wdColorAutomatic
Set fmt = New clsFormat
Select Case xScope
Case scopeText
propagateFore = 0: propagateBack = 0
Case scopeCellText
propagateFore = fmt.PropagateToCellText: propagateBack = fmt.PropagateToCellText
Case scopeRowText
propagateFore = fmt.PropagateToRowText: propagateBack = fmt.PropagateToRowText
Case scopeCell
propagateFore = fmt.PropagateToCellText: propagateBack = fmt.PropagateToCell
Case scopeRow
propagateFore = fmt.PropagateToRowText: propagateBack = fmt.PropagateToRow
End Select
For i = 0 To UBound(sourcePrefixes)
Set zRow = t.rows(i + 2)
Set fmt = highlightsAll(xHighlightsIndices(i))
With zRow
.Cells(thisDocDescriptor.columnStartDate).Range.text = format$(Now, ppP_LastDateFormatGet)
If thisDocDescriptor.columnEndDate > 0 Then .Cells(thisDocDescriptor.columnEndDate).Range.text = format$(DateAdd("q", 2, Now), ppP_LastDateFormatGet)
If thisDocDescriptor.columnStartTime > 0 Then .Cells(thisDocDescriptor.columnStartTime).Range.text = format$(Now, c8TimeFormatISO)
If thisDocDescriptor.columnEndTime > 0 Then .Cells(thisDocDescriptor.columnEndTime).Range.text = format$(DateAdd("h", 6, Now), c8TimeFormatISO)
.Cells(thisDocDescriptor.columnSource).Range.text = sourcePrefixes(i) & " " & c8SourceDelimiter & " record 1234"
.Cells(generalHeadingStartCol).Range.text = xHighlightsIndices(i) & ".(" & format$(thisDocColorManager.WCAGColorContrast(fmt.foreColor, fmt.backColor), "0.00") & ")"
For j = generalHeadingStartCol + 1 To zRow.Cells.count
If j Mod 2 = 0 Then
.Cells(j).Range.text = lorem1
Else
.Cells(j).Range.text = lorem2
End If
Next
End With
Set R = zRow.Cells(thisDocDescriptor.columnSource).Range
Set sourcePrefixRange = d.Range(R.Start, R.Start + Len(sourcePrefixes(i)))
fmt.setFormat sourcePrefixRange, d, xPropagateFore:=propagateFore, xPropagateBack:=propagateBack
Next
setTableCharacteristics t
Set R = t.Range
With R.Find
.text = ".("
.Replacement.text = "^l("
.Execute replace:=wdReplaceAll
End With
Set createPreviewDocument = d
d.ActiveWindow.View.Zoom.Percentage = 100
End Function
Attribute VB_Name = "c8MC_Misc"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Const textNone As Long = 0
Const textUser As Long = 1
Const textC8 As Long = 2
Public Sub ShowDocDetails()
Dim doc As Document
frmInternalsReport.setDisplay "Document Details"
frmInternalsReport.show
Set doc = frmInternalsReport.docCreated
If doc Is Nothing Then
Else
doc.activate
End If
End Sub
Public Function GetHighLevelSourcePrefixes(Optional xPrefixes As clsGlossary) As String()
Dim zSource As String
Dim processed As String
Dim sourcePrefixes() As String
Dim prefixGlossary As clsGlossary
Dim i As Long
Dim j As Long
If xPrefixes Is Nothing Then
Set prefixGlossary = thisDocSourcePrefixes
Else
Set prefixGlossary = xPrefixes
End If
processed = ""
For i = 1 To prefixGlossary.count
zSource = sourcePrefix(prefixGlossary.getKey(prefixGlossary.getEntryByIndex(i)), xLevel:=1)
If InStr(processed, zSource) Then
Else
processed = processed & zSource
End If
Next i
sourcePrefixes = Split(processed, c8SourceDelimiter)
ReDim Preserve sourcePrefixes(UBound(sourcePrefixes) - 1)
For i = 0 To UBound(sourcePrefixes) - 1
For j = 1 To UBound(sourcePrefixes)
If UCase$(sourcePrefixes(j)) < UCase$(sourcePrefixes(j - 1)) Then
zSource = sourcePrefixes(j)
sourcePrefixes(j) = sourcePrefixes(j - 1)
sourcePrefixes(j - 1) = zSource
End If
Next j
Next i
GetHighLevelSourcePrefixes = sourcePrefixes
End Function
Public Function GetSourceFragments(Optional xPrefixes As clsGlossary) As String()
Dim zSource As String
Dim processed As String
Dim sourcePrefixes() As String
Dim prefixGlossary As clsGlossary
Dim i As Long
Dim j As Long
If xPrefixes Is Nothing Then
Set prefixGlossary = thisDocSourcePrefixes
Else
Set prefixGlossary = xPrefixes
End If
processed = ""
For i = 1 To prefixGlossary.count
sourcePrefixes = Split(sourcePrefix(prefixGlossary.getKey(prefixGlossary.getEntryByIndex(i)), xLevel:=0), c8SourceDelimiter)
For j = 0 To UBound(sourcePrefixes) - 1
If InStr(processed, Trim$(sourcePrefixes(j))) Then
Else
processed = processed & Trim$(sourcePrefixes(j)) & c8SourceDelimiter
End If
Next j
Next i
sourcePrefixes = Split(processed, c8SourceDelimiter)
If UBound(sourcePrefixes) = -1 Then GoTo finished
ReDim Preserve sourcePrefixes(UBound(sourcePrefixes) - 1)
For i = 0 To UBound(sourcePrefixes) - 1
For j = 1 To UBound(sourcePrefixes)
If UCase$(sourcePrefixes(j)) < UCase$(sourcePrefixes(j - 1)) Then
zSource = sourcePrefixes(j)
sourcePrefixes(j) = sourcePrefixes(j - 1)
sourcePrefixes(j - 1) = zSource
End If
Next j
Next i
finished:
GetSourceFragments = sourcePrefixes
End Function
Public Sub AnonymiseShowForm()
If thisDocGlossaryMerged.containsDuplicateKeysOrItems(glCrossCheck:=True, glSearchPartial:=True) Then
showMessage c8Msg7000
GoTo noShow
End If
Select Case mergeMultipleTablesPrompt(checkForTables:=True)
Case "Merge"
Case "MergeFailed"
GoTo noShow
Case "Don't Merge"
Case "Cancel"
GoTo noShow
Case ""
End Select
frmAnonymise.show
noShow:
End Sub
Public Sub ShowAbbreviationsDefine()
Select Case mergeMultipleTablesPrompt(checkForTables:=True)
Case "Merge"
Case "MergeFailed"
GoTo noShow
Case "Don't Merge"
Case "Cancel"
GoTo noShow
Case ""
End Select
frmGlossary.show
noShow:
End Sub
Public Sub ShowAgeCalculator()
frmIntervalCalculator.show
End Sub
Public Function DocTextAfterTables(xDoc As Document) As Long
Dim tablesEnd As Long
Dim zText As String
Dim errorSectionHeadingSqueezed As String
Dim errorSectionDuplicatesHeadingSqueezed As String
tablesEnd = getTablesEnd(xDoc)
If tablesEnd = xDoc.Content.End Then
DocTextAfterTables = textNone
Else
zText = BRemoveAllSpaces(BTranslateNonPrint(Left$(xDoc.Range(tablesEnd, xDoc.Range.End).text, 1000)))
If Len(zText) = 0 Then
DocTextAfterTables = textNone
Else
errorSectionHeadingSqueezed = BRemoveAllSpaces(BTranslateNonPrint(errorSectionHeading))
errorSectionDuplicatesHeadingSqueezed = BRemoveAllSpaces(BTranslateNonPrint(errorSectionDuplicatesHeading))
If Left$(zText, Len(errorSectionHeadingSqueezed)) = errorSectionHeadingSqueezed Or Left$(zText, Len(errorSectionDuplicatesHeadingSqueezed)) = errorSectionDuplicatesHeadingSqueezed Then
DocTextAfterTables = textC8
Else
DocTextAfterTables = textUser
End If
End If
End If
End Function
Public Function DocHasErrorSection(xDoc As Document) As Boolean
DocHasErrorSection = (DocTextAfterTables(xDoc) = textC8)
End Function
Public Function DocHasUserTextAfterTables(xDoc As Document) As Boolean
DocHasUserTextAfterTables = (DocTextAfterTables(xDoc) = textUser)
End Function
Public Function DocHasTextAfterTables(xDoc As Document) As Boolean
DocHasTextAfterTables = (DocTextAfterTables(xDoc) > textNone)
End Function
Public Sub DeleteC8Endnotes(xRange As Range)
With xRange.Find
.text = ChrW$(61560)
.Replacement.text = ""
.Forward = True
.Wrap = wdFindStop
.format = True
.MatchCase = False
.MatchWholeWord = False
.MatchAllWordForms = False
.MatchSoundsLike = False
.matchWildcards = True
.Execute replace:=wdReplaceAll
End With
End Sub
Public Function sourcePrefix(xSource As String, Optional xLevel As Long = 0, Optional xIncludePriorLevels As Boolean = True, Optional xSqueezeAllSpaces As Boolean = False) As String
Dim out As String
Dim prefixArray() As String
Dim i  As Long
If xLevel = 0 Then
out = Left$(xSource, BInstrRev(xSource, c8SourceDelimiter))
Else
prefixArray = Split(xSource, c8SourceDelimiter)
If xIncludePriorLevels Then
For i = 0 To xLevel - 1
out = out & prefixArray(i) & " " & c8SourceDelimiter
Next i
Else
out = prefixArray(xLevel - 1) & c8SourceDelimiter
End If
End If
If xSqueezeAllSpaces Then
out = BRemoveAllSpaces(out)
Else
out = BSqueezeSpaces(replace(out, c8SourceDelimiter, " " & c8SourceDelimiter & " "))
End If
sourcePrefix = Trim$(out)
End Function
Public Function sourceLowestLevel(xSource As String) As String
sourceLowestLevel = Trim$(Mid$(xSource, BInstrRev(xSource, c8SourceDelimiter) + 1))
End Function
Public Function SourcePrefixLevels(xSource As String) As Long
SourcePrefixLevels = BCountCharacters(xSource, c8SourceDelimiter)
End Function
Public Function SourcePrefixLowestLevel(xSource As String) As String
SourcePrefixLowestLevel = sourcePrefix(xSource, xLevel:=SourcePrefixLevels(xSource), xIncludePriorLevels:=False)
End Function
Public Sub ScrollToTablesEnd(xDoc As Document)
ThisDocument.ActiveWindow.ScrollIntoView xDoc.Range(getTablesEnd(xDoc), xDoc.Range.End)
End Sub
Public Sub DocPadding_Delete()
On Error Resume Next
Dim R As Range
Set R = ThisDocument.Bookmarks(c8BookmarkNameDocPadding).Range
R.End = R.End + 1
R.Delete
End Sub
Public Sub DocPadding_Add()
Dim R As Range
Set R = ThisDocument.Range
R.Collapse direction:=wdCollapseEnd
R.InsertParagraphAfter
R.Collapse direction:=wdCollapseEnd
ThisDocument.Bookmarks.add c8BookmarkNameDocPadding, ThisDocument.Range(R.Start, R.Start)
R.InsertParagraphAfter
End Sub
Public Sub updateMachineStatistics(Optional xWindowsVersion As String = "", Optional xWordVersion As String = "", Optional xCPU As String = "")
Dim versionsList As String
Dim currentVersion As String
Dim CPUs() As String
Dim i As Long
versionsList = ppStats_Get(ppStats_WindowsVersions, xIncludePrefix:=False)
If Len(xWindowsVersion) = 0 Then
currentVersion = System.version
Else
currentVersion = xWindowsVersion
End If
If InStr(versionsList, currentVersion & ppStats_Delimiter) = 0 Then
ppStats_Set ppStats_WindowsVersions, versionsList & currentVersion & ppStats_Delimiter
End If
versionsList = ppStats_Get(ppStats_WordVersions, xIncludePrefix:=False)
If Len(xWordVersion) = 0 Then
currentVersion = Application.Build
Else
currentVersion = xWordVersion
End If
If InStr(versionsList, currentVersion & ppStats_Delimiter) = 0 Then
ppStats_Set ppStats_WordVersions, versionsList & currentVersion & ppStats_Delimiter
End If
versionsList = ppStats_Get(ppStats_CPUs, xIncludePrefix:=False)
If Len(xCPU) = 0 Then
CPUs = BSystemProcessors
currentVersion = "(" & UBound(CPUs) + 1 & ") "
For i = 0 To UBound(CPUs)
currentVersion = currentVersion & CPUs(i)
Next i
Else
currentVersion = xCPU
End If
If InStr(versionsList, currentVersion & ppStats_Delimiter) = 0 Then
ppStats_Set ppStats_CPUs, versionsList & currentVersion & ppStats_Delimiter
End If
End Sub
Function trackedChangesLurking(xDoc As Document) As Boolean
On Error GoTo trackChangesError
trackedChangesLurking = xDoc.TrackRevisions = True Or xDoc.Revisions.count > 0
Exit Function
trackChangesError:
trackedChangesLurking = True
If Err.Number = 4605 Then
showMessage c8Msg5232, msgSuffix1:=xDoc.name & ">"
Else
showMessage c8Msg6000, msgSuffix2:="trackedChangesLurking: Error " & Err.Number & " (" & Err.Description & ")"
End If
End Function
Function trackedChangesTurnOff(xDoc As Document) As Boolean
On Error GoTo trackChangesError
Dim R As Range
If xDoc.ProtectionType = wdAllowOnlyRevisions Then
showMessage c8Msg5233, msgSuffix1:=xDoc.name & ">"
Exit Function
End If
xDoc.TrackRevisions = False
For Each R In xDoc.StoryRanges
R.Revisions.AcceptAll
Next R
trackedChangesTurnOff = True
Exit Function
trackChangesError:
If Err.Number = 4605 Then
showMessage c8Msg5233, msgSuffix1:=xDoc.name & ">"
Else
showMessage c8Msg6000, msgSuffix2:="trackedChangesTurnOff: Error " & Err.Number & " (" & Err.Description & ")"
End If
End Function
Function trackedChangesOffDialog(xDoc As Document, Optional saveDoc As Boolean = False) As Boolean
Dim trackedChangesTurnedOff As Boolean
trackedChangesTurnedOff = False
If showMessage(c8Msg5230, button2:="OK", button3:="Cancel", defaultButton:=2, msgPrefix2:="<" & xDoc.name) = "OK" Then
trackedChangesTurnedOff = trackedChangesTurnOff(xDoc)
If trackedChangesTurnedOff Then
xDoc.UndoClear
On Error GoTo bug92check
If saveDoc Then xDoc.Save
On Error GoTo 0
End If
End If
GoTo finish
bug92check:
If Err.Number = 5487 Then
Call bug92Fix(xDoc)
Else
showMessage c8Msg6000, msgSuffix2:="trackedChangesOffDialog: Error " & Err.Number & " (" & Err.Description & ")"
End If
finish:
trackedChangesOffDialog = trackedChangesTurnedOff
End Function
Attribute VB_Name = "c8MC_ProcessingParameters"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public Const ppFalse As String = "0"
Public Const ppTrue As String = "1"
Public Const ppStats_CheckTables As String = "1"
Public Const ppStats_FormatDates As String = "2"
Public Const ppStats_SequenceAdd As String = "3"
Public Const ppStats_SequenceUpdate As String = "3.1"
Public Const ppStats_SequenceClear As String = "3.2"
Public Const ppStats_SequenceDelete As String = "3.3"
Public Const ppStats_SequenceChangeHeading As String = "3.4"
Public Const ppStats_CheckDuplicates As String = "4"
Public Const ppStats_PublishCustom As String = "5"
Public Const ppStats_PublishAnalysis As String = "5.1"
Public Const ppStats_PublishJSON As String = "5.2"
Public Const ppStats_Merge As String = "6"
Public Const ppStats_AbbreviationReview As String = "7"
Public Const ppStats_AbbreviationReport As String = "8"
Public Const ppStats_Anonymise As String = "9"
Public Const ppStats_Personalise As String = "10"
Public Const ppStats_HighlightSource As String = "11"
Public Const ppStats_NormaliseSource As String = "12"
Public Const ppStats_WindowsVersions As String = "100"
Public Const ppStats_WordVersions As String = "101"
Public Const ppStats_CPUs As String = "102"
Public Const ppStats_Delimiter As String = "|fffd|"
Public Const ppP_DateTimeOffsetsFormat1 As String = "1"
Public Const ppP_DateTimeOffsetsFormat2 As String = "2"
Dim documentSavedVar As Boolean
Dim glossaryBeforeUpdate As clsGlossary
Public Sub ppA_AnonymiseAbbreviationSet(abbrev As String, definition As String, Optional xOn As Boolean = True, Optional serialise As Boolean = False)
If serialise Then ppSaveStatus
If xOn Then
thisDocProcessingParameters.add "A1", definition, abbrev, glAllowDupKeys:=True, glAllowDupItems:=False
Else
thisDocProcessingParameters.remove "A1", definition, abbrev
End If
If serialise Then ppSerialise
End Sub
Public Function ppA_AnonymiseAbbreviationGet(abbrev As String, definition As String) As Boolean
ppA_AnonymiseAbbreviationGet = thisDocProcessingParameters.containsEntry("A1", definition, abbrev)
End Function
Public Sub ppA_BIUParmSet(Optional xOn As Boolean = True)
If xOn Then
thisDocProcessingParameters.add "A2", "", "", glAllowDupKeys:=False
Else
thisDocProcessingParameters.remove "A2", "", ""
End If
End Sub
Public Function ppA_BIUParmGet() As Boolean
ppA_BIUParmGet = thisDocProcessingParameters.containsKey("A2")
End Function
Public Sub ppA_GlossaryColumnUpdateSet(Optional xOn As Boolean = True)
If xOn Then
thisDocProcessingParameters.add "A3", "", "", glAllowDupKeys:=False
Else
thisDocProcessingParameters.remove "A3", "", ""
End If
End Sub
Public Function ppA_GlossaryColumnUpdateGet() As Boolean
ppA_GlossaryColumnUpdateGet = thisDocProcessingParameters.containsKey("A3")
End Function
Public Function ppA_Candidates() As Variant
Dim out() As String
Dim zEntries As Variant
Dim zEntry As String
Dim zAbbreviation As String
Dim zDefinition As String
Dim i As Long
Set zEntries = thisDocProcessingParameters.getEntriesByKey("A1")
If zEntries.count = 0 Then Exit Function
ReDim out(0 To zEntries.count - 1, 0 To 1)
For i = 1 To zEntries.count
zEntry = zEntries(i)
zAbbreviation = thisDocProcessingParameters.getPrefix(zEntry)
zDefinition = thisDocProcessingParameters.getItem(zEntry)
out(i - 1, 0) = zAbbreviation
out(i - 1, 1) = zDefinition
Next i
ppA_Candidates = out
End Function
Public Function ppA_CandidatesExist() As Boolean
ppA_CandidatesExist = thisDocProcessingParameters.containsKey("A1")
End Function
Public Sub ppH_HighlightGeneralSet(xString As String, xFormat As clsFormat)
ppSaveStatus
thisDocProcessingParameters.removeKeyItemPair "H1", xString
thisDocProcessingParameters.add "H1", xString, xFormat.dumpToString, glAllowDupKeys:=True, glAllowDupItems:=False
ppSerialise
End Sub
Public Function ppH_HighlightGeneralGet(xString As String) As clsFormat
Dim i As Long
Dim fmt As clsFormat
Dim zEntry As String
Dim zEntries As Variant
Set ppH_HighlightGeneralGet = Nothing
Set zEntries = thisDocProcessingParameters.getEntriesByKey("H1")
For i = 1 To zEntries.count
zEntry = zEntries(i)
If thisDocProcessingParameters.getItem(zEntry) = xString Then
Set fmt = New clsFormat
fmt.loadFromString thisDocProcessingParameters.getPrefix(zEntry)
Set ppH_HighlightGeneralGet = fmt
End If
Next
End Function
Public Sub ppH_HighlightSourceIndexDelete(xString As String)
ppSaveStatus
thisDocProcessingParameters.removeKeyItemPair "H3", xString
ppSerialise
End Sub
Public Sub ppH_HighlightSourceIndexSet(xString As String, xIndex As Long)
ppSaveStatus
thisDocProcessingParameters.removeKeyItemPair "H3", xString
thisDocProcessingParameters.add "H3", xString, CStr(xIndex), glAllowDupKeys:=True, glAllowDupItems:=False
ppSerialise
End Sub
Public Function ppH_HighlightSourceIndexGet(xString As String) As Long
Dim i As Long
Dim zEntry As String
Dim zEntries As Variant
ppH_HighlightSourceIndexGet = -1
Set zEntries = thisDocProcessingParameters.getEntriesByKey("H3")
For i = 1 To zEntries.count
zEntry = zEntries(i)
If thisDocProcessingParameters.getItem(zEntry) = xString Then
ppH_HighlightSourceIndexGet = CLng(thisDocProcessingParameters.getPrefix(zEntry))
End If
Next
End Function
Public Function ppH_SourceHighlightingExists() As Boolean
ppH_SourceHighlightingExists = thisDocProcessingParameters.containsKey("H3")
End Function
Public Function ppH_SourceHighlightingRemoveInfo()
ppSaveStatus
thisDocProcessingParameters.removeAllKeys ("H2")
thisDocProcessingParameters.removeAllKeys ("H3")
ppSerialise
End Function
Public Sub ppH_ScopeAndSchemeSet(xScope As String, xScheme As String)
ppSaveStatus
thisDocProcessingParameters.removeAllKeys ("H2")
thisDocProcessingParameters.add "H2", xScope, xScheme, glAllowDupKeys:=False, glAllowDupItems:=False
ppSerialise
End Sub
Public Function ppH_ScopeAndSchemeGet() As String()
Dim zEntry As String
Dim out(0 To 1) As String
If thisDocProcessingParameters.containsKey("H2") Then
zEntry = thisDocProcessingParameters.getEntryByKey("H2")
out(0) = thisDocProcessingParameters.getItem(zEntry)
out(1) = thisDocProcessingParameters.getPrefix(zEntry)
Else
out(0) = ""
out(1) = ""
End If
ppH_ScopeAndSchemeGet = out
End Function
Public Sub ppI_DatesSet(xDate1 As String, xDate2 As String)
ppSaveStatus
thisDocProcessingParameters.removeAllKeys ("I1")
thisDocProcessingParameters.add "I1", xDate1, xDate2
ppSerialise
End Sub
Public Function ppI_Date1Get() As String
Dim zEntry As String
zEntry = thisDocProcessingParameters.getEntryByKey("I1")
If thisDocProcessingParameters.glossaryError(zEntry) Then
ppI_Date1Get = ""
Else
ppI_Date1Get = thisDocProcessingParameters.getItem(zEntry)
End If
End Function
Public Function ppI_Date2Get() As String
Dim zEntry As String
zEntry = thisDocProcessingParameters.getEntryByKey("I1")
If thisDocProcessingParameters.glossaryError(zEntry) Then
ppI_Date2Get = ""
Else
ppI_Date2Get = thisDocProcessingParameters.getPrefix(zEntry)
End If
End Function
Public Sub ppP_DateTimeHeadingParmsSet(xAsis As String, xOffset As String)
thisDocProcessingParameters.removeAllKeys ("P1")
thisDocProcessingParameters.add "P1", xAsis, xOffset
End Sub
Public Function ppP_DateTimeHeadingPrintAsis() As Boolean
Dim zEntry As String
zEntry = thisDocProcessingParameters.getEntryByKey("P1")
If thisDocProcessingParameters.glossaryError(zEntry) Then
ppP_DateTimeHeadingPrintAsis = True
Else
ppP_DateTimeHeadingPrintAsis = (thisDocProcessingParameters.getItem(zEntry) = ppTrue)
End If
End Function
Public Function ppP_DateTimeOffsetsformat() As String
Dim zEntry As String
zEntry = thisDocProcessingParameters.getEntryByKey("P1")
If thisDocProcessingParameters.glossaryError(zEntry) Then
ppP_DateTimeOffsetsformat = ppFalse
Else
ppP_DateTimeOffsetsformat = thisDocProcessingParameters.getPrefix(zEntry)
End If
End Function
Public Sub ppP_WriteGeneralHeadingParmsSet(xWrite As String)
thisDocProcessingParameters.removeAllKeys ("P2")
thisDocProcessingParameters.add "P2", xWrite
End Sub
Public Function ppP_WriteGeneralHeadings() As Boolean
Dim zEntry As String
zEntry = thisDocProcessingParameters.getEntryByKey("P2")
If thisDocProcessingParameters.glossaryError(zEntry) Then
ppP_WriteGeneralHeadings = True
Else
ppP_WriteGeneralHeadings = (thisDocProcessingParameters.getItem(zEntry) = ppTrue)
End If
End Function
Public Sub ppP_LastDateFormatSet(xFormat As String)
thisDocProcessingParameters.removeAllKeys ("P3")
thisDocProcessingParameters.add "P3", xFormat
End Sub
Public Function ppP_LastDateFormatGet() As String
Dim zEntry As String
zEntry = thisDocProcessingParameters.getEntryByKey("P3")
If thisDocProcessingParameters.glossaryError(zEntry) Then
ppP_LastDateFormatGet = c8DateFormatStandard1
Else
ppP_LastDateFormatGet = thisDocProcessingParameters.getItem(zEntry)
End If
End Function
Public Sub ppS_SequenceColumnDefinedByUserSet(Optional xOn As Boolean = True)
ppSaveStatus
If xOn Then
thisDocProcessingParameters.add "S1", "", "", glAllowDupKeys:=False
Else
thisDocProcessingParameters.remove "S1", "", ""
End If
ppSerialise
End Sub
Public Function ppS_SequenceColumnDefinedByUserGet() As Boolean
ppS_SequenceColumnDefinedByUserGet = thisDocProcessingParameters.containsKey("S1")
End Function
Public Sub ppStats_Update(xType As String, xTableCount As Single, xRowCount As Single, xTime As Long, Optional xField1 As String = " ", Optional xField2 As String = " ")
Dim statsKey As String
Dim executionCount As Single
Dim zEntry As String
Dim memSizes() As String
Dim saveStatus As Boolean
memSizes = BSystemMemory
saveStatus = ThisDocument.Saved
statsKey = "X" & xType
If thisDocProcessingParameters.containsKey(statsKey) Then
zEntry = thisDocProcessingParameters.getEntryByKey(statsKey)
executionCount = CInt(thisDocProcessingParameters.getItem(zEntry))
thisDocProcessingParameters.removeAllKeys (statsKey)
End If
executionCount = executionCount + 1
thisDocProcessingParameters.add glKey:=statsKey, glItem:=CStr(executionCount), glPrefix:=CStr(xTableCount) & ppStats_Delimiter & CStr(xRowCount) & ppStats_Delimiter & xField1 & ppStats_Delimiter & xField2 & ppStats_Delimiter & CStr(xTime) & ppStats_Delimiter & memSizes(0) & ppStats_Delimiter & memSizes(1) & ppStats_Delimiter & memSizes(2)
ppSerialise
ThisDocument.Saved = saveStatus
End Sub
Public Sub ppStats_Set(xType As String, xItem As String, Optional xPrefix As String = "", Optional xReplace As Boolean = True)
Dim statsKey As String
Dim saveStatus As Boolean
saveStatus = ThisDocument.Saved
statsKey = "X" & xType
If xReplace Then
thisDocProcessingParameters.removeAllKeys (statsKey)
End If
thisDocProcessingParameters.add statsKey, xItem, xPrefix, glAllowDupKeys:=True, glAllowDupItems:=True
ppSerialise
ThisDocument.Saved = saveStatus
End Sub
Public Function ppStats_Get(xType As String, Optional xIncludePrefix As Boolean = True, Optional xPPGlossary As clsGlossary) As String
Dim out As String
Dim zEntry As String
Dim ppGlossary As clsGlossary
If xPPGlossary Is Nothing Then
Set ppGlossary = thisDocProcessingParameters
Else
Set ppGlossary = xPPGlossary
End If
zEntry = ppGlossary.getEntryByKey("X" & xType)
If ppGlossary.glossaryError(zEntry) Then Exit Function
out = ppGlossary.getItem(zEntry)
If xIncludePrefix Then out = out & ppStats_Delimiter & ppGlossary.getPrefix(zEntry)
ppStats_Get = out
End Function
Public Function ppSaveStatus()
documentSavedVar = ThisDocument.Saved
If glossaryBeforeUpdate Is Nothing Then Set glossaryBeforeUpdate = New clsGlossary
glossaryBeforeUpdate.loadFromString thisDocProcessingParameters.dumpToString, glClear:=True, glAllowDupKeys:=True, glAllowDupItems:=True
End Function
Public Function ppSerialise()
thisDocDescriptor.glossaryProcessing = thisDocProcessingParameters.dumpToString(glEncryptor:=thisDocGlossaryEncryptor)
ThisDocument.Saved = documentSaved
End Function
Private Function documentSaved() As Boolean
If glossaryBeforeUpdate Is Nothing Then Set glossaryBeforeUpdate = New clsGlossary
documentSaved = thisDocProcessingParameters.equals(glossaryBeforeUpdate) And documentSavedVar
End Function
Attribute VB_Name = "c8MC_Public"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public Sub c8ImportSpecial_1()
Call ImportTables(setSourcePrefix:=False)
End Sub
Attribute VB_Name = "c8MC_Sequence"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public Const sequenceProcessAdd As String = "Add Sequence Column"
Public Const sequenceProcessDelete As String = "Delete Sequence Column"
Public Const sequenceProcessUpdate As String = "Update Sequence Numbers"
Public Const sequenceProcessClear As String = "Clear Sequence Column"
Public Const sequenceProcessChangeHeading As String = "Change Column Heading"
Const sequenceColumnDefaultWidth As Long = "35"
Dim processCancelled As Boolean
Dim processCancelledByUser As Boolean
Public Function SequenceColumnAdd_AllTables(Optional xHeading As String = c8SequenceColumnHeadingDefault, Optional xShowProgress As Boolean = True, Optional xCloseProgress As Boolean = True, Optional xCheckMultipleTables As Boolean = True, Optional xPopulate As Long = -1) As Boolean
Dim populate As Long
If xPopulate = -1 Then
If thisDocDescriptor.sortOrder = c8SortOrderAscending Or Len(thisDocDescriptor.sortOrder) = 0 Then
populate = BWordTableWriteRowNumbers_GroupByNoneAscending
Else
populate = BWordTableWriteRowNumbers_GroupByNoneDescending
End If
Else
populate = xPopulate
End If
SequenceColumnAdd_AllTables = SequenceColumnProcessAllTables(xProcess:=sequenceProcessAdd, xShowProgress:=xShowProgress, xCloseProgress:=xCloseProgress, xCheckMultipleTables:=xCheckMultipleTables, xHeading:=xHeading, xPopulate:=populate)
End Function
Public Function SequenceColumnDelete_AllTables(Optional xCheckMultipleTables As Boolean = True, Optional xShowProgress As Boolean = True, Optional xCloseProgress As Boolean = True) As Boolean
SequenceColumnDelete_AllTables = SequenceColumnProcessAllTables(xProcess:=sequenceProcessDelete, xShowProgress:=xShowProgress, xCloseProgress:=xCloseProgress, xCheckMultipleTables:=xCheckMultipleTables)
End Function
Public Sub SequenceColumnGroupByNone_AllTables()
Dim populate As Long
If thisDocDescriptor.sortOrder = c8SortOrderAscending Or Len(thisDocDescriptor.sortOrder) = 0 Then
populate = BWordTableWriteRowNumbers_GroupByNoneAscending
Else
populate = BWordTableWriteRowNumbers_GroupByNoneDescending
End If
SequenceColumnUpdate_AllTables xPopulate:=populate
End Sub
Public Sub SequenceColumnGroupByDate_AllTables()
Dim populate As Long
If thisDocDescriptor.sortOrder = c8SortOrderAscending Or Len(thisDocDescriptor.sortOrder) = 0 Then
populate = BWordTableWriteRowNumbers_GroupByDateAscending
Else
populate = BWordTableWriteRowNumbers_GroupByDateDescending
End If
SequenceColumnUpdate_AllTables xPopulate:=populate
End Sub
Public Function SequenceColumnClear_AllTables(Optional xCheckMultipleTables As Boolean = True) As Boolean
SequenceColumnClear_AllTables = SequenceColumnProcessAllTables(xProcess:=sequenceProcessClear, xShowProgress:=True, xCloseProgress:=True, xPopulate:=BWordTableClearRowNumbers, xCheckMultipleTables:=xCheckMultipleTables)
End Function
Private Sub SequenceColumnUpdate_AllTables(xPopulate As Long, Optional xCheckMultipleTables As Boolean = True)
Call SequenceColumnProcessAllTables(xProcess:=sequenceProcessUpdate, xShowProgress:=True, xCloseProgress:=True, xPopulate:=xPopulate, xCheckMultipleTables:=xCheckMultipleTables)
End Sub
Public Function SequenceColumnChangeHeading_AllTables(Optional xCheckMultipleTables As Boolean = True) As Boolean
Dim newHead As String
Call frmInputBox.setParms(title:="Sequence column heading", promptOK:="Type the new heading in the box below and press OK.", promptCancel:="Press Cancel to keep the current heading.", showCancel:=True, forceInput:=True, defaultText:=thisDocDescriptor.columnHeading(1))
frmInputBox.show
newHead = frmInputBox.userInput
If Len(newHead) = 0 Then Exit Function
SequenceColumnChangeHeading_AllTables = SequenceColumnProcessAllTables(xProcess:=sequenceProcessChangeHeading, xShowProgress:=True, xCloseProgress:=True, xCheckMultipleTables:=xCheckMultipleTables, xHeading:=newHead)
End Function
Public Function sequenceColumnProcessOneTable(xTable As table, xProcess As String, Optional xHeading As String = c8SequenceColumnHeadingDefault, Optional xShowProgress As Boolean = True, Optional xEarliestIndex As Long = 1, Optional xPopulate As Long = BWordTableWriteRowNumbers_GroupByNoneAscending) As String
Dim tableAsArray As Variant
Dim doc As Document
Dim tablCast As table
Dim processColumnOne As Long
Dim progressCaption2 As String
Dim heading As String
Dim eventCount As Long
Dim i As Long
Dim columnWidths() As Long
Dim tableWidth As Long
Dim scaleFactor As Single
columnWidths = BWordTableGetColumnWidths(xTable)
tableWidth = 0
For i = 1 To UBound(columnWidths)
tableWidth = tableWidth + columnWidths(i)
Next i
eventCount = "0"
On Error GoTo useTAA
Set tablCast = xTable
Select Case xProcess
Case sequenceProcessAdd
If xPopulate = BWordTableWriteRowNumbers_None Then
xTable.Columns.add BeforeColumn:=xTable.Columns(1)
On Error GoTo failed
xTable.rows(1).Cells(1).Range.text = xHeading
GoTo success
Else
GoTo useTAA
End If
Case sequenceProcessDelete
If xShowProgress Then
With progressBar
.Caption2 = c8Name & c8PBWaitingProcessing
.CancelButtonEnable False
End With
End If
xTable.Columns(1).Delete
GoTo success
Case sequenceProcessClear
heading = BWordGetCellText(xTable.Columns(1).Cells(1))
xTable.Columns(1).Select
Selection.Delete
On Error GoTo failed
xTable.rows(1).Cells(1).Range.text = heading
GoTo success
Case sequenceProcessUpdate
GoTo useTAA
Case sequenceProcessChangeHeading
xTable.rows(1).Cells(1).Range.text = xHeading
GoTo success
End Select
Exit Function
useTAA:
On Error GoTo failed
If xShowProgress Then
With progressBar
.Caption2 = c8PBPreparingTable & "for update"
.CancelButtonEnable False
End With
End If
Set doc = xTable.Parent
tableAsArray = BWordTableToArray(xTable:=xTable, xDelete:=True, xProgressBarIncrement:=0.4 / pbRowsToCheck)
If progressBar.userCancelled Then
processCancelledByUser = True
GoTo cancelled
End If
If BWordTableToArrayError(tableAsArray) Then
GoTo cancelled
End If
If IsEmpty(tableAsArray) Then GoTo cancelled
Select Case xProcess
Case sequenceProcessAdd
processColumnOne = BWordTableAddColumnOne
progressCaption2 = c8PBUpdatingTableSeq
Case sequenceProcessDelete
processColumnOne = BWordTableDeleteColumnOne
progressCaption2 = c8PBDeletingColumn
Case sequenceProcessClear
processColumnOne = 0
progressCaption2 = c8PBClearingColumn
Case sequenceProcessUpdate
processColumnOne = 0
progressCaption2 = c8PBUpdatingTableSeq
Case sequenceProcessChangeHeading
progressCaption2 = c8PBUpdatingSeqHeading
tableAsArray(1, 1) = xHeading
End Select
If xShowProgress Then progressBar.Caption2 = progressCaption2
Set tablCast = SequenceColumnCreateTable(xTableAsArray:=tableAsArray, xDoc:=doc, xPopulate:=xPopulate, xProcessColumnOne:=processColumnOne, xEarliestIndex:=xEarliestIndex, xProgressCaption2:=progressCaption2)
For i = 2 To UBound(tableAsArray)
If BWordIsBlankRow_TA(tableAsArray, i) Then
Else
eventCount = eventCount + 1
End If
Next
success:
If progressBar.userCancelled Then
processCancelledByUser = True
GoTo cancelled
End If
With progressBar
.Caption2 = c8PBSettingTableCharacteristics
.Caption3 = ""
End With
setTableCharacteristics tablCast
Select Case xProcess
Case sequenceProcessAdd
scaleFactor = (tableWidth - sequenceColumnDefaultWidth) / tableWidth
ReDim Preserve columnWidths(1 To UBound(columnWidths) + 1)
For i = UBound(columnWidths) To 2 Step -1
columnWidths(i) = columnWidths(i - 1) * scaleFactor
Next i
columnWidths(1) = sequenceColumnDefaultWidth
Case sequenceProcessDelete
For i = 1 To UBound(columnWidths) - 1
columnWidths(i) = columnWidths(i + 1)
Next i
ReDim Preserve columnWidths(1 To i - 1)
End Select
BWordTableSetColumnWidths tablCast, columnWidths
progressBar.Caption2 = c8PBTableUpdateComplete
sequenceColumnProcessOneTable = eventCount
Exit Function
cancelled:
sequenceColumnProcessOneTable = "cancelled"
processCancelled = True
Exit Function
failed:
sequenceColumnProcessOneTable = "Error " & Err.Number & " (" & Err.Description & ")"
End Function
Private Function SequenceColumnCreateTable(xTableAsArray As Variant, xDoc As Document, xPopulate As Long, xProgressCaption2 As String, Optional xEarliestIndex As Long = 1, Optional xProcessColumnOne As Long) As table
Dim tablCast As table
Dim decorators() As Variant
With progressBar
.Caption2 = xProgressCaption2
.Caption3 = ""
End With
ReDim decorators(1 To UBound(xTableAsArray, 1), 0 To UBound(xTableAsArray, 2), 2)
Set tablCast = BWordTableFromArray(xTableAsArray, decorators, xDoc, xWriteNumInFirstCell:=xPopulate, xProcessColumnOne:=xProcessColumnOne, xEarliestIndex:=xEarliestIndex, xProgressBarIncrement:=0.1 / pbRowsToCheck)
If progressBar.userCancelled Then
processCancelledByUser = True
GoTo SequenceColumnCreateTableCancelled
End If
Set SequenceColumnCreateTable = tablCast
GoTo SequenceColumnCreateTableExit
SequenceColumnCreateTableCancelled:
processCancelled = True
SequenceColumnCreateTableExit:
End Function
Private Function SequenceColumnProcessAllTables(xProcess As String, xShowProgress As Boolean, xCloseProgress As Boolean, xCheckMultipleTables As Boolean, Optional xPopulate As Long = 0, Optional xHeading As String = "") As Boolean
Dim tablesfound As Variant
Dim tabl As table
Dim i  As Long
Dim navButtonSaveEnabled As Boolean
Dim docSave As String
Dim saveStatus As Boolean
Dim performanceOptionsStore() As Variant
Dim retCode As String
Dim out As Boolean
Dim stats As String
Dim tableRowCount As Long
Dim saveProgress As Single
Dim earliestIndex As Long
Dim tablesToProcess As Long
Dim devBug68 As Boolean
Dim sw1 As clsStopWatch
Set sw1 = New clsStopWatch
sw1.Start
out = False
devBug68 = False
processCancelled = False
processCancelledByUser = False
performanceOptionsStore = BWordPerformanceOptionsSet()
saveStatus = ThisDocument.Saved
If trackedChangesLurking(ThisDocument) Then
If trackedChangesOffDialog(ThisDocument) Then
Else
Call showMessage(c8Msg5231, msgPrefix1:=xProcess, msgPrefix2:="<" & ThisDocument.name)
Call cancelInternal
GoTo sequenceProcessExit
End If
End If
If xShowProgress Then
With progressBar
.Reset enableCancel:=False
.AddProgress 0.05
.title = xProcess
.Caption1 = c8PBAnalysingTables
.CancelButtonEnable False
.show
End With
End If
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tablesfound) Then
Call showMessage(c8Msg1015)
Call cancelInternal
GoTo sequenceProcessExit
End If
If UBound(tablesfound) > 0 Then
If xCheckMultipleTables Then
Call DocPadding_Add
sw1.Halt
Select Case mergeMultipleTablesPrompt(xProcess)
Case "MergeFailed"
Call cancelInternal
GoTo sequenceProcessExit
Case "Merge"
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
Case "Don't Merge"
progressBar.repaint
Case "Cancel"
Call cancelInternal
GoTo sequenceProcessExit
End Select
frmMessage.Hide
sw1.Start
End If
End If
If tablesValidForSeqProcessing(tablesfound) Then
Else
Call cancelInternal
GoTo sequenceProcessExit
End If
tablesToProcess = UBound(tablesfound) + 1
If xShowProgress Then Call setProgressBarCounters(ThisDocument, tablesfound)
Application.screenUpdating = False
docSave = thisDocSaver.documentSave(ThisDocument)
Call DocPadding_Add
navButtonSaveEnabled = navButtonsEnabled
Call navButtonsDisable
earliestIndex = 1
For i = 0 To UBound(tablesfound)
If xShowProgress Then
With progressBar
.Caption1 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
.Caption2 = ""
.Caption3 = ""
.CancelButtonEnable
saveProgress = .Progress
End With
End If
Set tabl = ThisDocument.tables(tablesfound(i))
tableRowCount = BWordTableRowCount(tabl)
Select Case xProcess
Case sequenceProcessAdd
retCode = sequenceColumnProcessOneTable(xTable:=tabl, xProcess:=xProcess, xHeading:=xHeading, xPopulate:=xPopulate, xEarliestIndex:=earliestIndex)
Case sequenceProcessClear
retCode = sequenceColumnProcessOneTable(xTable:=tabl, xProcess:=xProcess, xPopulate:=xPopulate)
Case sequenceProcessDelete
retCode = sequenceColumnProcessOneTable(xTable:=tabl, xProcess:=xProcess, xPopulate:=BWordTableWriteRowNumbers_None)
Case sequenceProcessUpdate
retCode = sequenceColumnProcessOneTable(xTable:=tabl, xProcess:=xProcess, xPopulate:=xPopulate, xEarliestIndex:=earliestIndex)
Case sequenceProcessChangeHeading
retCode = sequenceColumnProcessOneTable(xTable:=tabl, xProcess:=xProcess, xHeading:=xHeading)
End Select
If IsNumeric(retCode) Then
earliestIndex = earliestIndex + retCode
If xShowProgress Then progressBar.Progress = saveProgress + (0.9 * tableRowCount / pbRowsToCheck)
Else
If processCancelled Then
GoTo sequenceProcessCancelled
Else
GoTo sequenceProcessFailed
End If
End If
Next i
Select Case xProcess
Case sequenceProcessAdd
thisDocDescriptor.sequenceColumnAdd xHeading
ppS_SequenceColumnDefinedByUserSet
stats = ppStats_SequenceAdd
Case sequenceProcessClear
stats = ppStats_SequenceClear
Case sequenceProcessDelete
thisDocDescriptor.sequenceColumnDelete
ppS_SequenceColumnDefinedByUserSet False
stats = ppStats_SequenceDelete
Case sequenceProcessUpdate
stats = ppStats_SequenceUpdate
Case sequenceProcessChangeHeading
thisDocDescriptor.columnHeading(1) = xHeading
stats = ppStats_SequenceChangeHeading
End Select
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tablesfound) Then
devBug68 = True
Else
If tablesToProcess = UBound(tablesfound) + 1 Then
Else
devBug68 = True
End If
End If
If devBug68 Then
showMessage c8Msg6000, msgSuffix2:="SequenceColumnProcessAllTables: table count failed"
GoTo sequenceProcessRestore
End If
Call buttonStatesSequencing
out = True
GoTo sequenceProcessExit
sequenceProcessCancelled:
If processCancelledByUser Then
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
End If
GoTo sequenceProcessRestore
sequenceProcessFailed:
showMessage c8Msg3107, msgPrefix1:="Sequence", msgSuffix2:=vbNewLine & vbNewLine & "Info: SequenceColumnProcessAllTables " & xProcess & ": " & retCode
sequenceProcessRestore:
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
If xCloseProgress Then progressBar.finish
Call showMessage(c8Msg3020)
If navButtonSaveEnabled Then Call navButtonsEnable
sequenceProcessExit:
Call thisDocSaver.closeSingle(docSave)
If xCloseProgress Then progressBar.finish
Call BWordPerformanceOptionsRestore(performanceOptionsStore)
Application.screenUpdating = True
Call DocPadding_Delete
ThisDocument.UndoClear
If Not processCancelled Then ppStats_Update stats, pbTablesToCheck, pbRowsToCheck, sw1.value
SequenceColumnProcessAllTables = out
End Function
Public Sub buttonStatesSequencing()
buttonSequenceColumnAdd.Enabled = (thisDocDescriptor.columnSequence = 0)
buttonSequenceColumnDelete.Enabled = (thisDocDescriptor.columnSequence > 0) And (ppS_SequenceColumnDefinedByUserGet Or thisDocDescriptor.docType > c8InternalChronology)
buttonSequenceGroupByDate.Enabled = (thisDocDescriptor.columnSequence > 0)
buttonSequenceGroupByNone.Enabled = (thisDocDescriptor.columnSequence > 0)
buttonSequenceColumnClear.Enabled = (thisDocDescriptor.columnSequence > 0)
buttonSequenceColumnChangeHeading.Enabled = (thisDocDescriptor.columnSequence > 0) And (ppS_SequenceColumnDefinedByUserGet Or thisDocDescriptor.docType > c8InternalChronology)
End Sub
Private Function tablesValidForSeqProcessing(tablesfound As Variant, Optional xDoc As Document) As Boolean
Dim out As Boolean
Dim tabl As table
Dim i As Long
out = False
If xDoc Is Nothing Then Set xDoc = ThisDocument
On Error GoTo error1
For i = 0 To UBound(tablesfound)
Set tabl = xDoc.tables(tablesfound(i))
If BWordTableHasVerticallyMergedCells(tabl) Then GoTo error2
If BWordTableHasNestedTable(tabl) Then GoTo error2
If Not CheckCellCountInTable(tabl, thisDocDescriptor) Then GoTo error2
Next i
out = True
GoTo exitFunction
error1:
showMessage c8Msg6000, msgSuffix2:="tablesValidForSeqProcessing: Error " & Err.Number & " (" & Err.Description & ")"
GoTo exitFunction
error2:
showMessage c8Msg3107, msgPrefix1:="Sequence"
exitFunction:
tablesValidForSeqProcessing = out
End Function
Private Sub cancelInternal()
processCancelled = True
processCancelledByUser = True
End Sub
Attribute VB_Name = "c8_AddinManagement"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Const c8AddinPrefix As String = "c8Addin"
Const c8AddinDelimiter As String = "|fffd|"
Private c8AddinsRequested As String
Private Enum addinStatus
notFound = 0
loaded = 1
Installed = 2
End Enum
Public Sub c8CleanupAddins()
Dim a As AddIn
For Each a In AddIns
If Left$(a.name, Len(c8AddinPrefix)) = c8AddinPrefix Then a.Delete
Next a
End Sub
Function addinsCount() As Long
Dim a As AddIn
Dim out As Long
out = 0
For Each a In AddIns
If Left$(a.name, Len(c8AddinPrefix)) = c8AddinPrefix Then out = out + 1
Next a
addinsCount = out
End Function
Private Sub loadAddin()
Dim fileDialog As Dialog
Dim zDoc As Document
Dim docName As String
Dim docFullName As String
Dim addinId As String
Dim validationMessage As String
Dim errorMessage As String
On Error GoTo errorExit
CustomizationContext = ThisDocument
Set fileDialog = Dialogs(wdDialogFileOpen)
If fileDialog.show = -1 Then
Set zDoc = ActiveDocument
docName = zDoc.name
docFullName = zDoc.fullName
zDoc.Windows(1).Visible = False
addinId = BWordDocumentVariableGet(zDoc, c8AddinPrefix, "")
If InStr(c8AddinsRequested, docFullName) Then
errorMessage = "is already loaded in " & ThisDocument.name
GoTo errorExit
End If
validationMessage = validateAddin(addinId)
If Len(validationMessage) = 0 Then
If getAddinStatus(docFullName) = notFound Then
errorMessage = "AddIns.add failure. Full document name: " & vbNewLine & vbNewLine & docFullName
AddIns.add fileName:=docFullName, Install:=True
c8AddinsRequested = c8AddinsRequested & c8AddinDelimiter & docFullName
Else
errorMessage = "is already loaded in another document"
GoTo errorExit
End If
Else
errorMessage = validationMessage
GoTo errorExit
End If
Else
Exit Sub
End If
On Error GoTo getProceduresFailed
Call getProcedures(addinId)
Call showMessage(c8Msg8000)
GoTo closeDoc
getProceduresFailed:
AddIns(docFullName).Delete
c8AddinsRequested = Left$(c8AddinsRequested, InStr(c8AddinsRequested, c8AddinDelimiter & docFullName) - 1)
errorMessage = "failed to initialise procedures"
errorExit:
If Len(errorMessage) = 0 Then errorMessage = Err.Number & " " & Err.Description
Call showMessage(c8Msg8010, msgPrefix2:=docName & " " & errorMessage)
closeDoc:
zDoc.Close
End Sub
Private Function validateAddin(addinId As String) As String
Dim out As String
Dim c8Ver As String
Dim addinVer As String
If Len(addinId) = 0 Then
out = "is not a valid Chronolator add-in"
GoTo finish
End If
c8Ver = replace$(c8Version, ".", "")
addinVer = Left$(addinId, 2)
If addinVer <> c8Ver Then
out = "is an add-in for Chronolator version " & Left$(addinVer, 1) & "." & Right$(addinVer, 1) & " and is not valid for version " & c8Version
GoTo finish
End If
finish:
validateAddin = out
End Function
Private Sub getProcedures(addinId As String)
Application.Run MacroName:=c8AddinPrefix & addinId & "_GetProcedures"
End Sub
Private Function getAddinStatus(addinFullName As String) As addinStatus
Dim zAddin As AddIn
On Error GoTo notInCollection
Set zAddin = AddIns(addinFullName)
If zAddin.Installed Then
getAddinStatus = Installed
Else
getAddinStatus = loaded
End If
Exit Function
notInCollection:
getAddinStatus = notFound
End Function
Private Sub c8Addin_GetCommArea(ByRef xCaller As String, ByRef xDocDescriptor As String, ByRef xTables As String)
Dim tables As Variant
Dim i  As Long
xCaller = ThisDocument.name
xDocDescriptor = thisDocDescriptor.dumpToString
xTables = ""
tables = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=True, xIncludeNested:=True)
If IsEmpty(tables) Then
Else
For i = 0 To UBound(tables)
xTables = xTables & tables(i) & " "
Next
xTables = RTrim$(xTables)
End If
End Sub
Private Sub c8Addin_GetProcedures(ByRef xAddinCaption As String, ByRef xCaptions As String, ByRef xProcedures As String)
Dim captions() As String
Dim procedures() As String
Dim Button() As CommandBarButton
Dim addinMenu As CommandBarPopup
Dim i  As Long
Dim docSaved As Boolean
docSaved = ThisDocument.Saved
CustomizationContext = ThisDocument
captions = Split(xCaptions, c8AddinDelimiter)
procedures = Split(xProcedures, c8AddinDelimiter)
Set addinMenu = menuAddin.Controls.add(msoControlPopup)
addinMenu.Caption = xAddinCaption
ReDim Button(UBound(captions) - 1)
For i = 0 To UBound(captions) - 1
Set Button(i) = addinMenu.CommandBar.Controls.add(msoControlButton)
Button(i).Caption = captions(i)
Button(i).OnAction = procedures(i)
Next
ThisDocument.Saved = docSaved
End Sub
Private Sub c8Addin_UpdateThisDocDescriptor()
thisDocDescriptor.getDetails ThisDocument
End Sub
Attribute VB_Name = "c8_ApplicationEventHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public WithEvents App As Application
Attribute App.VB_VarHelpID = -1
Private Sub App_DocumentBeforeClose(ByVal doc As Document, Cancel As Boolean)
Dim targetDocFullName As String
Dim targetDescriptor As clsDocDescriptor
Dim targetDoc As Document
Dim msgsuf As String
If openAborted Or openMCManual Or openedByC9 Then Exit Sub
If autoMacsDisabled() Then Exit Sub
targetDocFullName = doc.fullName
If targetDocFullName <> ThisDocument.fullName Then Exit Sub
Set targetDoc = Documents(doc)
Set targetDescriptor = New clsDocDescriptor
targetDescriptor.getDetails targetDoc
If targetDescriptor.docType = c8WorkbenchDocument Then
targetDoc.Saved = True
If driveMapper Is Nothing Then
Else
driveMapper.UnmapDrive
End If
End If
If targetDoc.Saved = False Then
Select Case MsgBox("Do you want to save the changes to " & targetDoc.name & "?", vbYesNoCancel + vbExclamation)
Case vbYes
If BWordDocumentMightBeTemporary(targetDoc.path, targetDoc.name) Then
msgsuf = vbNewLine & vbNewLine & "Filename: " & targetDoc.name
Call showMessage(c8Msg5323, msgSuffix1:=msgsuf, button3:="OK")
c8FileSaveAs targetDoc, fileSavedAsFullName
Else
If targetDoc.ReadOnly Then Call MsgBox(c8ReadOnly)
On Error GoTo saveFailed
targetDoc.Save
On Error GoTo 0
End If
Case vbNo
targetDoc.Saved = True
Case vbCancel
Cancel = True
Exit Sub
End Select
End If
If targetDescriptor.docType = c8InternalChronology Then
If licenceIsOK Then
If CheckTablesInDocument(doc:=targetDoc, docDescriptor:=targetDescriptor, calledFromClose:=True) Then
Else
If showMessage(c8Msg3005, button2:="OK", button3:="Cancel", defaultButton:=3) = "Cancel" Then
If listFound Then showMessage msg:=c8Msg3200
Cancel = True
Exit Sub
End If
End If
End If
End If
If C8Documents.count = 1 Then
Call EnvironmentCleanup
End If
Exit Sub
saveFailed:
Select Case Err.Number
Case 5487
Call bug92Fix(targetDoc)
Resume Next
Case 5155
Cancel = True
Case Else
showMessage c8Msg6000, msgSuffix2:="App_DocumentBeforeClose: Error " & Err.Number & " (" & Err.Description & ")"
Cancel = True
End Select
End Sub
Private Sub App_DocumentBeforePrint(ByVal doc As Document, Cancel As Boolean)
If doc <> ThisDocument Then Exit Sub
If IsC8Doc(doc) Then
If Not c8LicenceHaveValid Then
Call licenceWriteEvaluationWatermarks(doc)
End If
End If
End Sub
Private Sub App_DocumentBeforeSave(ByVal doc As Document, SaveAsUI As Boolean, Cancel As Boolean)
If doc <> ThisDocument Then Exit Sub
Call updateMachineStatistics
If IsC8Doc(doc) Then
If Not c8LicenceHaveValid Then
Call licenceWriteEvaluationWatermarks(doc)
End If
End If
End Sub
Attribute VB_Name = "c8_Constants"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public Const c8Version = "3.5"
Public Const c8Copyright As String = "Copyright |fffd| 2004-2019 Berrick Computing Ltd"
Public Const c8VersionLowestCanImportInto = "3.0"
Public Const c8Name = "Chronolator"
Public Const c8GlossaryEncryptorKey = "Ch3ro5no6L4ator6"
Public Const c8LicenceFileNamePrefix = "Chronolator34Licence"
Public Const c8LicenceEncryptorKey01 = "Ch2ro4no6L7ator9"
Public Const c9p1 = "Ch2ro4no6L7a8or9"
Public Const c8LicenceEncryptorKey02 = "19501225-19520522-19800726-19820625-19840607"
Public Const c8LicenceExpiryWarningPeriod As Long = 30
Public Const c8LicenceExtendCaption As String = "Press the 'Extend Licence' button to the right to enter an extension password"
Public Const c8ProductURL As String = "www.chronolator.co.uk"
Public Const c8ColorErrorsNone As Long = wdColorAutomatic
Public Const c8ColorErrorsWarning As Long = wdColorYellow
Public Const c8ColorErrorsError As Long = wdColorTurquoise
Public Const c8ColorErrorsPriorityError As Long = wdColorViolet
Public Const c8ColorDuplicates As Long = wdColorLightTurquoise
Public Const c8MasterChronology As Long = 0
Public Const c8WorkbenchDocument As Long = 1
Public Const c8InternalChronology As Long = 3
Public Const c8CompositeChronologyNew As Long = 4
Public Const c8CompositeChronologyOld As Long = 5
Public Const c8PublishedChronology As Long = 6
Public Const c8PublishedChronologyCustom As Long = 7
Public Const c8RegistryGeneral = "General"
Public Const c8RegistryKeyDisplayScreenTips As String = "DisplayScreenTips"
Public Const c8RegistryKeyShowPicturePlaceHolders As String = "ShowPicturePlaceHolders"
Public Const c8RegistryKeyShowWindowsInTaskbar As String = "ShowWindowsInTaskbar"
Public Const c8RegistryKeyDisplayScrollBars As String = "DisplayScrollBars"
Public Const c8RegistryKeySaveInterval As String = "SaveInterval"
Public Const c8RegistryKeyCheckSpellingAsYouType  As String = "CheckSpellingAsYouType"
Public Const c8RegistryKeyCheckGrammarAsYouType  As String = "CheckGrammarAsYouType"
Public Const c8RegistryKeyPagination As String = "Pagination"
Public Const c8RegistryKeyCheckProofingLanguage  As String = "CheckProofingLanguage "
Public Const c8RegistrySession = "Session"
Public Const c8RegistryKeyDisableAutomacs As String = "DisableAutomacs"
Public Const c8RegistryKeyLicenceHasBeenAccepted As String = "LicenceHasBeenAccepted"
Public Const c8RegistryKeyOpenedByC9 As String = "OpenedByC9"
Public Const c8RegistryMessages = "MessageControl"
Public Const c8WorkbenchDoc = "ChronolatorOnlineWorkbench.docm"
Public Const c8MasterChronologyDoc = "ChronolatorMasterChronology.docm"
Public Const c8DateFormatISO = "yyyy-mm-dd"
Public Const c8DateFormatISOPlusDayOfWeek = "yyyy-mm-dd" & vbVerticalTab & "dddd"
Public Const c8DateFormatStandard1 = "dd mmm yyyy"
Public Const c8DateFormatStandard1PlusDayOfWeek = "dd mmm yyyy" & vbVerticalTab & "dddd"
Public Const c8TimeFormatISO = "hh:mm"
Public Const c8SortOrderAscending As String = "Ascending"
Public Const c8SortOrderDescending As String = "Descending"
Public Const c8SortTables As String = "Sort Tables"
Public Const c8Administrator As String = "Administrator"
Public Const c8CurrentDocument As String = "Current document"
Public Const c8DuplicatesDelete As Long = 1
Public Const c8DuplicatesHighlight As Long = 2
Public Const c8TutorialIndex = "tutorials\index.htm"
Public Const c8SourceDelimiter As String = ">"
Public Const c8BookmarkNameErrorSection As String = "c8bkm001"
Public Const c8BookmarkNameDocPadding As String = "c8bkm002"
Public Const c8BookmarkPrefixMerge As String = "c8m"
Public Const c8DisableAutoMacsFile As String = "c8scr1.tmp"
Public Const c8SequenceColumnHeadingDefault As String = "Seq"
Public Const c8InvalidAbbreviationText01 As String = "You cannot add this entry because it is too similar to another one"
Public Const c8InvalidAbbreviationText02 As String = "You cannot add this entry because its abbreviation and definition are the same"
Public Const c8InvalidAbbreviationText03 As String = "You cannot add this entry because it contains the sequence '(was'"
Public Const c8ChangeAbbreviationText01 As String = "Enter the new details above and press Change"
Public Const c8clsSaverFileStamp As String = "clsSaver"
Public Const c8ReadOnly As String = "This document is Read Only. Save it with another name."
Public Const frmAbbreviationsReviewMode_ReadOnly As Long = 0
Public Const frmAbbreviationsReviewMode_UpdateAnonymisations As Long = 1
Public Const c8PBHighlightingAbbreviations As String = "Highlighting abbreviations"
Public Const c8PBAnalysingTables = "Analysing tables"
Public Const c8PBSavingDocument = "Saving temporary copy of this document"
Public Const c8PBLookingInTable = "Looking in table "
Public Const c8PBProcessingTable = "Processing table "
Public Const c8PBReplacingText = "Replacing text"
Public Const c8PBFormattingTable = "Formatting table "
Public Const c8PBCreatingNewDocument = "Creating new document"
Public Const c8PBPreparingReportTable = "Preparing report table for processing"
Public Const c8PBIdentifyingAbbreviations = "Identifying abbreviations"
Public Const c8PBHighlightingMatches = "Highlighting matches"
Public Const c8PBCheckCompleted = "Check completed"
Public Const c8PBCancelAcknowledged = "Cancel Request Acknowledged"
Public Const c8PBImportingTable = "Importing table "
Public Const c8PBPreparingTable = "Preparing table "
Public Const c8PBSortingTable = "Sorting table "
Public Const c8PBMergingTable = "Merging table "
Public Const c8PBReformattingMergedTable = "Reformatting merged table"
Public Const c8PBConvertingArrayToDoc = "Converting internal array to Word document"
Public Const c8PBConvertingArrayToTable = "Converting internal array to table"
Public Const c8PBConvertingTableToArray = "Converting table to internal array"
Public Const c8PBFormattingDocument = "Formatting document"
Public Const c8PBFinishing = "Finishing off"
Public Const c8PBSourceNormalisationComplete = "Prefix normalisation almost complete"
Public Const c8PBSourceNormalisationMakeHash = "Storing normalisation status"
Public Const c8PBClearingHighlights = "Clearing highlights from table "
Public Const c8PBWritingEvent = "Writing event "
Public Const c8PBTerm = "Term       "
Public Const c8PBDefinition = "Definition "
Public Const c8PBWaitRestore = "Please wait while the document is restored"
Public Const c8PBProcessingArray = "Processing array"
Public Const c8PBTableReady = "Table ready for processing"
Public Const c8PBCheckingRow = "Checking row "
Public Const c8PBFormatComplete = "Format complete"
Public Const c8PBHighlightingNested = "Highlighting nested tables . . ."
Public Const c8PBVMIdentify = "Identifying vertically merged cells . . ."
Public Const c8PBVMHighlight = "Highlighting vertically merged cells . . ."
Public Const c8PBFormattingRow = "Formatting row "
Public Const c8PBCheckingColCount = "Checking column count in table "
Public Const c8PBCheckingLists = "Checking for bulleted or numbered lists"
Public Const c8PBPatient = "Please be patient if this is a large table"
Public Const c8PBSettingColumnWidths = "Setting column widths"
Public Const c8PBFormattingHeadingRow = "Formatting heading row"
Public Const c8PBProcessingPrefix = "Processing source prefix in row "
Public Const c8PBWritingNarrative = "Writing narrative"
Public Const c8PBRemovingEmptyParagraphs = "Removing empty paragraphs"
Public Const c8PBUpdatingStyles = "Updating styles . . ."
Public Const c8PBUpdatingStyleNormal = ". . . Normal"
Public Const c8PBUpdatingStyleHeadings = ". . . Headings"
Public Const c8PBUpdatingHeadFoot = "Updating Header and Footer"
Public Const c8PBWritingWatermark = "Writing watermark"
Public Const c8PBClearingPreviousHighlights = "Clearing previous highlights"
Public Const c8PBSortingTables = "Sorting tables"
Public Const c8PBComplete = "Complete"
Public Const c8PBNormalisingPrefixes = "Normalising source prefixes"
Public Const c8PBFindingPrefixes = "Finding source prefixes"
Public Const c8PBAddingHighlights = "Adding highlights"
Public Const c8PBSettingTableCharacteristics = "Setting table characteristics"
Public Const c8PBAddingColumn = "Adding Column"
Public Const c8PBDeletingColumn = "Deleting Column"
Public Const c8PBClearingColumn = "Clearing Column"
Public Const c8PBHighlightingRange = "Highlighting range "
Public Const c8PBUpdatingSeqHeading = "Updating column heading"
Public Const c8PBUpdatingTableSeq = "Updating table: sequence numbers"
Public Const c8PBTableUpdateComplete = "Table update complete"
Public Const c8PBProcessingColumn = "Processing column "
Public Const c8PBProcessingRow = "Processing row "
Public Const c8PBProcessingLine = "Processing line "
Public Const c8PBOf = " of "
Public Const c8PBFinishedWritingDoc = "Finished writing document"
Public Const c8PBProcessingHeadingRow = "Processing heading row"
Public Const c8PBHighlightingErrorsInRow = "Highlighting errors found in row "
Public Const c8PBClearingFontHighlights = "Clearing font highlights"
Public Const c8PBClearingBackgrounds = "Clearing cell and row backgrounds"
Public Const c8PBFormattingMatch = "Formatting match "
Public Const c8PBReplacingMatch = "Replacing match "
Public Const c8PBSortingMatch = "Sorting match "
Public Const c8PBFoundInTableSoFar = " found in table so far)"
Public Const c8PBWaitingPreProcessing = " is waiting for Word to complete pre-processing"
Public Const c8PBWaitingPostProcessing = " is waiting for Word to complete post-processing"
Public Const c8PBWaitingProcessing = " is waiting for Word to complete processing"
Public Const c8PBLoadingGlossaries = "Loading glossaries"
Public Const c8PBUser = "User"
Public Const c8PBAdministrator = "Administrator"
Public Const c8PBProcessingParameters = "Processing Parameters"
Public Const c8PBSourcePrefixes = "Source Prefixes"
Public Const c8PBWindowsStatistics = "Windows Statistics"
Public Const c8PBWordStatistics = "Word Statistics"
Public Const c8PBCheckingForChanges = "Checking for changes since last run"
Public Const c8PBCheckingSPN = "Checking Source Prefix Normalisation"
Public Const c8PBEscapes = "Adding JSON escape characters"
Public Const c8PBWritingJsonToArray = "Writing JSON to array"
Public Const c8PBWritingJsonToFile = "Writing array to file"
Public Const c8ToolTipCheckTables = "Check the table(s) in this document"
Public Const c8ToolTipImport = "Import table(s) from another Chronology"
Public Const c8ToolTipMerge = "Merge all the tables in this document"
Public Const c8ToolTipSort = "Multiple tables are sorted individually"
Public Const c8ToolTipFormatDates = "Set all dates to a common format"
Public Const c8ToolTipNavFirst = "Go to first "
Public Const c8ToolTipNavPrevious = "Go to previous "
Public Const c8ToolTipNavNext = "Go to next "
Public Const c8ToolTipNavLast = "Go to last "
Public Const c8ToolTipNavList = "Go to list of "
Public Const c8TooltipPublishExact = "Make an exact copy of this document without Chronolator code"
Public Const c8TooltipPublishCustom = "Make a narrative version of this document without Chronolator code"
Public Const c8TooltipPublishAnalysis = "Produce a document containing statistics about the events in this chronology"
Public Const c8TooltipPublishJSON = "Export this chronology in JavaScript Object Notation format for use in a web browser"
Public Const c8ToolTipNewCC = "Create a new Composite Chronology"
Public Const c8ToolTipNewIC = "Create a new Internal Chronology"
Public Const c8ToolTipAddTable = "Add a new table with the correct headings to the end of this document"
Public Const c8ToolTipAbbreviations = "Show and define abbreviations in this document"
Public Const c8ToolTipDocInfo = "Show Chronolator information about this document"
Public Const c8ToolTipAgeCalc = "Calculate the interval between two dates"
Public Const c8ToolTipDuplicatesHighlight = "Highlight duplicate rows"
Public Const c8ToolTipDuplicatesDelete = "Delete duplicate rows"
Public Const c8ToolTipAbout = "Version and Web site"
Public Const c8ToolTipTutorials = "Show tutorials"
Public Const c8ToolTipAnonymisationSetup = "Anonymise, Personalise and Review glossary entries"
Public Const c8ToolTipSequenceColumnAdd = "Add sequencing column"
Public Const c8ToolTipSequenceColumnDelete = "Delete sequencing column"
Public Const c8ToolTipSequenceGroupByDate = "Restart sequencing each day"
Public Const c8ToolTipSequenceGroupByNone = "Increment sequencing throughout document"
Public Const c8ToolTipSequenceColumnClear = "Set all blank"
Public Const c8ToolTipSequenceColumnChangeHeading = "Change Column Heading"
Public Const c8ToolTipTableAutoFitContents = "Resize columns to fit contents"
Public Const c8ToolTipTableAutoFitWindow = "Resize table to fit margins"
Public Const c8ToolTipTableSplit = "Split table at current row and add header"
Public Const c8ToolTipHighlightSource = "Highlight events according to their <"
Public Const c8ToolTipLoadAddin = "Load a Chronolator add-in"
Public Const c8ToolTipMenuAdvanced = "Advanced macros. Refer to the 'Using Chronolator Documents' manual before using them."
Public Const c8ToolTipImportSpecial = "Import a document without adding a Source Prefix"
Public Const c8ToolTipEnvironmentCleanup = "Clean up the Chronolator environment"
Public Const c8ToolTipAddinsCleanup = "Unload Chronolator Add-ins"
Public Const c8ToolTipNormaliseSource = "Normalise Source of Information Column"
Public Const c8FaceIdSortAscending = 595
Public Const c8FaceIdSortDescending = 596
Public Const c8FaceIdNavFirst = 154
Public Const c8FaceIdNavPrevious = 155
Public Const c8FaceIdNavNext = 156
Public Const c8FaceIdNavLast = 157
Public Const c8FaceIdNavList = 539
Public Const c8FaceIdPublishJSON = 3035
Public Const c8FaceIdPublishAnalysis = 249
Public Const c8FaceIdPublishCustom = 3811
Public Const c8FaceIdPublishExact = 681
Public Const c8FaceIdNewCC = 1548
Public Const c8FaceIdNewIC = 1547
Public Const c8FaceIdAddTable = 8
Public Const c8FaceIdAbbreviationsDefine = 1610
Public Const c8FaceIdAnonymisationSetup = 2141
Public Const c8FaceIdTableAutoFitContents = 3907
Public Const c8FaceIdTableAutoFitWindow = 3908
Public Const c8FaceIdTableSplit = 2234
Public Const c8FaceIdSequenceColumnAdd = 902
Public Const c8FaceIdSequenceColumnDelete = 1786
Public Const c8FaceIdSequenceGroupByDate = 3054
Public Const c8FaceIdSequenceGroupByNone = 3360
Public Const c8FaceIdSequenceColumnClear = 180
Public Const c8FaceIdSequenceColumnChangeHeading = 3512
Public Const c8FaceIdDocInfo = 1089
Public Const c8FaceIdAgeCalc = 960
Public Const c8FaceIdDuplicatesHighlight = 340
Public Const c8FaceIdDuplicatesDelete = 1786
Public Const c8FaceIdSourceHighlight = 340
Public Const c8FaceIdLoadAddin = 213
Public Const c9PreambleBookmark01Name As String = "c8Dynamic01"
Public Const c8PreambleDate1 = "Chronolator recognises a variety of formats, such as '31/12/03', '31.12.03' or '31 dec 03'." & "@If you are unsure of the exact date, enter your best estimate and note that you have done so in the 'Comments' column. "
Public Const c8PreambleDate2 = "If you want to enter a range of dates, enter the first date in this column and the " & "other date in the 'Comments' column. "
Public Const c8PreambleTime = "Chronolator recognises a variety of formats, such as '1305', '1 05 pm'."
Public Const c8PreambleAbbreviation = "Chronolator will check that anything you enter in this column is defined in " & "the Abbreviations Glossary. Use the Tools > Glossary > Edit button on the Chronolator toolbar to see or add to the list."
Public Const c8PreambleSource = "Where did you obtain the information (eg Health Visitor records, duty team log etc)? You do " & "not need to enter details of your own organisation " & "or department here. Chronolator will add them when the Administrator merges your chronology."
Public Const c8PreambleSequence = "Use this column if you want to specify the order of events on a particular day whose precise time is unknown. " & "You can also use it to create reference numbers in your Chronology. See the 'Using Chronolator Documents' manual for more details."
Public Const ascEquals = 61
Public Const ascHyphen = 45
Public Const ascFullStop = 46
Public Const ascA = 65
Public Const ascZ = 90
Public Const chrSingleQuote = "'"
Public Const chrDoubleQuote = """"
Public Const chrHyphen = "-"
Public Const chrSpace = " "
Attribute VB_Name = "c8_DocumentCreate"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public Const fs2FileSaved As Long = 1
Public Const fs2FileSaveCancelled As Long = 2
Public Const fs2FileSaveError As Long = 9
Public fileSavedAsFullName As String
Public fs2FileToPublish As String
Dim bestFileType As String
Dim bestFileFormat As Long
Sub TableWrite(xDoc As Document, xDetails As clsDocDescriptor, Optional xHeadersOnly As Boolean = False, Optional xAddSection As Boolean = True)
Dim colCount As Long
Dim i As Long
Dim zRange As Range
Dim newTable As table
Dim newTableStart As Long
Dim colSeparator As String
colSeparator = Chr(157)
If Not checkDescriptor(xDetails, xShowMessage:=True, xErrorMessage:=c8Msg5402) Then Exit Sub
If xAddSection Then
Set zRange = xDoc.Sections.add.Range
zRange.PageSetup.SectionStart = wdSectionBreakNextPage
zRange.PageSetup.Orientation = wdOrientLandscape
GoTo rangeIsSet
End If
If IsC8Doc(xDoc) Then
If DocHasErrorSection(xDoc) Then
newTableStart = getTablesEnd(xDoc)
Else
newTableStart = xDoc.Range.End - 1
End If
Set zRange = xDoc.Range(newTableStart, newTableStart)
zRange.Select
Selection.Font.Reset
zRange.InsertParagraphAfter
zRange.Style = wdStyleNormal
zRange.Collapse wdCollapseEnd
Else
Set zRange = xDoc.Range
zRange.Collapse wdCollapseEnd
End If
rangeIsSet:
colCount = xDetails.columnCount
For i = 1 To colCount
zRange.InsertAfter xDetails.columnHeading(i) & colSeparator
Next i
zRange.Font.Bold = False
Set newTable = zRange.ConvertToTable(separator:=colSeparator, NumColumns:=colCount, format:=wdTableFormatGrid1, Applyborders:=True)
If xHeadersOnly Then
newTable.rows(2).Delete
Else
For i = 1 To 8
newTable.rows.add
Next i
End If
Call setTableCharacteristics(newTable)
On Error Resume Next
newTable.rows(2).Cells(1).Select
Selection.Collapse wdCollapseStart
xDoc.ActiveWindow.SmallScroll Down:=15
xDoc.UndoClear
End Sub
Public Sub setTableCharacteristics(xTable As table, Optional xSetStyleNormal As Boolean = True)
With xTable
If xSetStyleNormal Then
.Range.Style = wdStyleNormal
End If
.rows(1).Range.Font.Reset
.rows(1).Range.Font.Bold = True
.rows(1).HeadingFormat = True
.rows(1).Range.Shading.Texture = wdTextureNone
.rows(1).Range.Shading.BackgroundPatternColor = wdColorGray10
.rows(1).Range.Font.Size = 9
.TopPadding = CentimetersToPoints(0.1)
.BottomPadding = CentimetersToPoints(0)
.LeftPadding = CentimetersToPoints(0.19)
.RightPadding = CentimetersToPoints(0.19)
.AllowAutoFit = False
End With
End Sub
Function c8FileSaveAs(xDoc As Document, xSuggestedName As String, Optional xEnforceMacroEnabled As Boolean = True) As Boolean
Dim saveActive As Document
Dim fs2Return As Long
Set saveActive = ActiveDocument
Dim fileDialog As Dialog
Set fileDialog = Dialogs(wdDialogFileSaveAs)
fileDialog.name = xSuggestedName
If canSaveDocm Then
If xEnforceMacroEnabled Then
bestFileType = "docm"
bestFileFormat = getDocmFormat
Else
bestFileType = "docx"
If wordVersion >= Word2007 Then
bestFileFormat = getDocxFormat
End If
End If
Else
bestFileType = "doc"
bestFileFormat = wdFormatDocument
End If
fileDialog.format = bestFileFormat
xDoc.activate
fs2Return = fs2FileSaveError
While fs2Return > fs2FileSaveCancelled
fs2Return = c8FileSaveAs2(xDoc, fileDialog, xEnforceMacroEnabled)
Wend
If fs2Return = fs2FileSaved Then
c8FileSaveAs = True
Exit Function
Else
saveActive.activate
c8FileSaveAs = False
End If
End Function
Function c8FileSaveAs2(xDoc As Document, fileDialog As Dialog, xEnforceMacroEnabled As Boolean) As Long
Dim saveStatus As Boolean
saveStatus = xDoc.Saved
On Error GoTo saveError
If fileDialog.Display = -1 Then
Else
c8FileSaveAs2 = fs2FileSaveCancelled
xDoc.Saved = saveStatus
Exit Function
End If
Dim saveFormat As Long
Dim saveName As String
Dim nameOnly As String
nameOnly = BGetFilenameFromPath(fileDialog.name)
c8FileSaveAs2 = fs2FileSaveError
If LCase$(nameOnly) = LCase$(fs2FileToPublish) Then
showMessage c8Msg5105
Else
If isC8SystemDoc(BGetFilenamePart(nameOnly)) Then
showMessage c8Msg5321
Else
If xEnforceMacroEnabled Then
If proposedSaveIsMacroEnabled(fileDialog.format, BGetFileExtension(nameOnly)) Then
Else
showMessage c8Msg5210
fileDialog.name = replace(fileDialog.name, "." & BGetFileExtension(nameOnly), "." & bestFileType)
fileDialog.format = bestFileFormat
End If
End If
saveName = fileDialog.name
saveFormat = fileDialog.format
fileDialog.Update
fileDialog.name = saveName
fileDialog.format = saveFormat
xDoc.activate
fileDialog.Execute
fileSavedAsFullName = xDoc.fullName
thisDocNavigator.setDocument fileSavedAsFullName
c8FileSaveAs2 = fs2FileSaved
End If
End If
Exit Function
saveError:
Select Case Err.Number
Case 5153
showMessage c8Msg5320
c8FileSaveAs2 = fs2FileSaveError
Case 5156
showMessage c8Msg5322
c8FileSaveAs2 = fs2FileSaveError
Case Else
showMessage c8Msg6000, msgSuffix2:="c8FileSaveAs2: Error " & Err.Number & " (" & Err.Description & ")"
c8FileSaveAs2 = fs2FileSaveCancelled
End Select
End Function
Public Function proposedSaveIsMacroEnabled(xDialogReturn As Long, xFiletype As String) As Boolean
proposedSaveIsMacroEnabled = False
Select Case LCase$(xFiletype)
Case "doc"
Case "docm"
Case Else
Exit Function
End Select
If (xDialogReturn = 0) Or (xDialogReturn = getDocmFormat) Then proposedSaveIsMacroEnabled = True
If wordVersion = Word2000 And xDialogReturn = 112 Then proposedSaveIsMacroEnabled = True
End Function
Public Function canSaveDocm() As Boolean
Dim cnvFile As FileConverter
If wordVersion >= Word2007 Then GoTo exitTrue
For Each cnvFile In FileConverters
If cnvFile.CanSave = True Then
If cnvFile.FormatName = "Word 2007 Macro-enabled Document" Then GoTo exitTrue
End If
Next
canSaveDocm = False
Exit Function
exitTrue:
canSaveDocm = True
End Function
Function getDocmFormat() As Long
Select Case wordVersion
Case Word2000
getDocmFormat = 104
Case WordXP
getDocmFormat = 104
Case Word2003
getDocmFormat = 101
Case Else
getDocmFormat = 13
End Select
End Function
Function getDocxFormat() As Long
getDocxFormat = wdFormatXMLDocument
End Function
Public Sub bug92Fix(xDoc As Document)
Dim fullName As String
Dim tempname As String
On Error GoTo unableToFix
fullName = xDoc.fullName
tempname = BGetFilePath(fullName) & "~c8.tmp" & "." & BGetFileExtension(fullName)
xDoc.SaveAs tempname
xDoc.SaveAs fullName
Kill tempname
Exit Sub
unableToFix:
showMessage c8Msg6000, msgSuffix2:="bug92Fix: Error " & Err.Number & " (" & Err.Description & ")"
End Sub
Function isC8SystemDoc(ByVal xName As String) As Boolean
xName = LCase$(BGetFilenamePart(xName))
isC8SystemDoc = (xName = LCase$(BGetFilenamePart(c8WorkbenchDoc)) Or xName = LCase$(BGetFilenamePart(c8MasterChronologyDoc)))
End Function
Attribute VB_Name = "c8_Environment"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public openedByC9 As Boolean
Public myToolbar As CommandBar
Dim saveStatus As Boolean
Public c8ApplicationPath As String
Public eventHandler As c8_ApplicationEventHandler
Dim menuAdmin As CommandBarPopup
Dim menuTools As CommandBarPopup
Dim menuHighlight As CommandBarPopup
Dim menuTable As CommandBarPopup
Dim menuDuplicates As CommandBarPopup
Dim menuSequence As CommandBarPopup
Dim menuGlossary As CommandBarPopup
Public menuAdvanced As CommandBarPopup
Dim menuHelp As CommandBarPopup
Public navButtonsEnabled As Boolean
Public menuAddin As CommandBarPopup
Public buttonLoadAddin As CommandBarButton
Public buttonCreateInternalChronology As CommandBarButton
Public buttonCreateCompositeChronology As CommandBarButton
Dim buttonGetDocumentDetails As CommandBarButton
Dim buttonWriteTable As CommandBarButton
Dim buttonImportTables As CommandBarButton
Dim buttonMergeTables As CommandBarButton
Dim buttonCheckTables As CommandBarButton
Dim buttonSortTablesAscending As CommandBarButton
Dim buttonSortTablesDescending As CommandBarButton
Dim buttonFormatDatesISOPlusDayOfWeek As CommandBarButton
Dim buttonFormatDatesISO As CommandBarButton
Dim buttonFormatDatesStandard1 As CommandBarButton
Dim buttonFormatStandard1PlusDayOfWeek As CommandBarButton
Dim buttonPublishAsIs As CommandBarButton
Dim buttonPublishCustom As CommandBarButton
Dim buttonPublishAnalysis As CommandBarButton
Dim buttonPublishJSON As CommandBarButton
Dim buttonFirstError As CommandBarButton
Dim buttonPreviousError As CommandBarButton
Dim buttonNextError As CommandBarButton
Dim buttonLastError As CommandBarButton
Dim buttonGoToErrorList As CommandBarButton
Dim buttonGlossaryEdit As CommandBarButton
Dim buttonAgeCalulator As CommandBarButton
Dim buttonGlossaryAnonReview As CommandBarButton
Dim buttonTableAutoFitContents As CommandBarButton
Dim buttonTableAutoFitWindow As CommandBarButton
Dim buttonTableSplit As CommandBarButton
Dim buttonHighlightSource As CommandBarButton
Public buttonHighlightSourceClear As CommandBarButton
Public buttonSequenceColumnAdd As CommandBarButton
Public buttonSequenceColumnDelete As CommandBarButton
Public buttonSequenceGroupByDate As CommandBarButton
Public buttonSequenceGroupByNone As CommandBarButton
Public buttonSequenceColumnClear As CommandBarButton
Public buttonSequenceColumnChangeHeading As CommandBarButton
Dim buttonDuplicatesHighlight As CommandBarButton
Dim buttonDuplicatesDelete As CommandBarButton
Dim buttonAbout As CommandBarButton
Dim buttonTutorials As CommandBarButton
Dim buttonAddinsCleanup As CommandBarButton
Dim buttonEnvironmentCleanup As CommandBarButton
Dim buttonImportSpecial_1 As CommandBarButton
Dim buttonNormaliseSource As CommandBarButton
Public driveMapper As clsDriveMapper
Sub ToolbarAdd()
If Not licenceIsOK(showMsg:=False) Then
Call showMessage(c8Msg4030)
Exit Sub
End If
If BWordToolbarExists(c8Name, ThisDocument) Then Exit Sub
saveStatus = ThisDocument.Saved
CustomizationContext = ThisDocument
ThisDocument.activate
Set myToolbar = CommandBars.add(c8Name, msoBarTop, False, True)
myToolbar.Protection = msoBarNoChangeVisible + msoBarNoCustomize + msoBarNoMove + msoBarNoChangeDock
Select Case thisDocDescriptor.docType
Case c8WorkbenchDocument
Call ToolbarWorkbenchDocument(myToolbar)
Case c8InternalChronology
Call ToolbarInternalChronology(myToolbar)
Case c8CompositeChronologyNew
Call ToolbarCompositeChronologyNew(myToolbar)
Case c8CompositeChronologyOld
Call ToolbarCompositeChronologyOld(myToolbar)
End Select
ThisDocument.activate
myToolbar.Visible = True
Call buttonStates
ThisDocument.Saved = saveStatus
End Sub
Sub ToolbarInternalChronology(tb As CommandBar)
Set menuAdmin = tb.Controls.add(msoControlPopup)
menuAdmin.Caption = "Admin"
Set menuTools = tb.Controls.add(msoControlPopup)
menuTools.Caption = "Tools"
Call menuAdminCommonButtons(menuAdmin)
Set buttonCreateCompositeChronology = menuAdmin.CommandBar.Controls.add(msoControlButton)
With buttonCreateCompositeChronology
.FaceId = c8FaceIdNewCC
.Style = msoButtonIconAndCaption
.Caption = "New Composite Chronology"
.TooltipText = c8ToolTipNewCC
.OnAction = "CompositeChronologyCreate"
End With
Call menuToolsCommonButtons(menuTools)
Call ToolbarChronologyDocumentCommonItems(tb)
End Sub
Sub ToolbarCompositeChronologyOld(tb As CommandBar)
Set menuAdmin = tb.Controls.add(msoControlPopup)
menuAdmin.Caption = "Admin"
Set menuTools = tb.Controls.add(msoControlPopup)
menuTools.Caption = "Tools"
Call menuAdminCommonButtons(menuAdmin)
Call menuToolsCommonButtons(menuTools)
Set menuHighlight = menuTools.CommandBar.Controls.add(msoControlPopup, Before:=6)
menuHighlight.Caption = "Highlight Source"
menuHighlight.TooltipText = c8ToolTipHighlightSource & thisDocDescriptor.columnHeading(thisDocDescriptor.columnSource) & "> column"
Set buttonHighlightSource = menuHighlight.Controls.add(msoControlButton)
With buttonHighlightSource
.FaceId = c8FaceIdSourceHighlight
.Style = msoButtonIconAndCaption
.Caption = "Define and Do"
.OnAction = "highlightSourceUI"
End With
Set buttonHighlightSourceClear = menuHighlight.Controls.add(msoControlButton)
With buttonHighlightSourceClear
.Style = msoButtonCaption
.Caption = "Clear"
.OnAction = "highlightSourceClear"
.Enabled = ppH_SourceHighlightingExists
End With
Set buttonImportTables = tb.Controls.add(msoControlButton)
With buttonImportTables
.Style = msoButtonCaption
.Caption = "Import Tables"
.TooltipText = c8ToolTipImport
.OnAction = "ImportTables"
End With
Set buttonMergeTables = tb.Controls.add(msoControlButton)
With buttonMergeTables
.Style = msoButtonCaption
.Caption = "Merge Tables"
.TooltipText = c8ToolTipMerge
.OnAction = "MergeAllTables"
End With
Call ToolbarChronologyDocumentCommonItems(tb)
End Sub
Sub ToolbarCompositeChronologyNew(tb As CommandBar)
Set buttonImportTables = tb.Controls.add(msoControlButton)
With buttonImportTables
.Style = msoButtonCaption
.Caption = "Import Tables"
.TooltipText = c8ToolTipImport
.OnAction = "ImportTables"
End With
Call menuAdvancedSetup
Call menuHelpSetup
End Sub
Public Sub ToolbarCompositeChronologyConvert()
buttonImportTables.Visible = False
menuHelp.Visible = False
menuAdvanced.Visible = False
Call ToolbarCompositeChronologyOld(myToolbar)
End Sub
Sub ToolbarWorkbenchDocument(tb As CommandBar)
Set buttonCreateInternalChronology = tb.Controls.add(msoControlButton)
Set buttonCreateCompositeChronology = tb.Controls.add(msoControlButton)
With buttonCreateInternalChronology
.FaceId = c8FaceIdNewIC
.Style = msoButtonIconAndCaption
.Caption = "New Internal Chronology"
.TooltipText = c8ToolTipNewIC
.OnAction = "InternalChronologyCreate"
End With
With buttonCreateCompositeChronology
.FaceId = c8FaceIdNewCC
.Style = msoButtonIconAndCaption
.Caption = "New Composite Chronology"
.TooltipText = c8ToolTipNewCC
.OnAction = "CompositeChronologyCreate"
End With
Set menuAdvanced = tb.Controls.add(msoControlPopup)
menuAdvanced.Caption = "Advanced"
menuAdvanced.TooltipText = c8ToolTipMenuAdvanced
Set buttonEnvironmentCleanup = menuAdvanced.CommandBar.Controls.add(msoControlButton)
Set buttonAddinsCleanup = menuAdvanced.CommandBar.Controls.add(msoControlButton)
With buttonEnvironmentCleanup
.Style = msoButtonIconAndCaption
.Caption = "c8EnvironmentCleanup"
.TooltipText = c8ToolTipEnvironmentCleanup
.OnAction = "c8EnvironmentCleanup"
End With
With buttonAddinsCleanup
.Style = msoButtonIconAndCaption
.Caption = "c8CleanupAddins"
.TooltipText = c8ToolTipAddinsCleanup
.OnAction = "c8CleanupAddins"
End With
Call menuHelpSetup
End Sub
Sub ToolbarChronologyDocumentCommonItems(tb As CommandBar)
Dim formatMenu As CommandBarPopup
Dim sortMenu As CommandBarPopup
Dim publishMenu As CommandBarPopup
Set formatMenu = tb.Controls.add(msoControlPopup)
Set buttonFormatDatesStandard1 = formatMenu.CommandBar.Controls.add(msoControlButton)
Set buttonFormatStandard1PlusDayOfWeek = formatMenu.CommandBar.Controls.add(msoControlButton)
Set buttonFormatDatesISO = formatMenu.CommandBar.Controls.add(msoControlButton)
Set buttonFormatDatesISOPlusDayOfWeek = formatMenu.CommandBar.Controls.add(msoControlButton)
Set sortMenu = tb.Controls.add(msoControlPopup)
Set buttonSortTablesAscending = sortMenu.CommandBar.Controls.add(msoControlButton)
Set buttonSortTablesDescending = sortMenu.CommandBar.Controls.add(msoControlButton)
Set buttonCheckTables = tb.Controls.add(msoControlButton)
Set buttonFirstError = tb.Controls.add(msoControlButton)
Set buttonPreviousError = tb.Controls.add(msoControlButton)
Set buttonNextError = tb.Controls.add(msoControlButton)
Set buttonLastError = tb.Controls.add(msoControlButton)
Set buttonGoToErrorList = tb.Controls.add(msoControlButton)
Set publishMenu = tb.Controls.add(msoControlPopup)
Set buttonPublishAsIs = publishMenu.CommandBar.Controls.add(msoControlButton)
Set buttonPublishCustom = publishMenu.CommandBar.Controls.add(msoControlButton)
Set buttonPublishAnalysis = publishMenu.CommandBar.Controls.add(msoControlButton)
Set buttonPublishJSON = publishMenu.CommandBar.Controls.add(msoControlButton)
With sortMenu
.Caption = c8SortTables
End With
With formatMenu
.Caption = "Format Dates"
End With
With publishMenu
.Caption = "Publish"
End With
With buttonSortTablesAscending
.FaceId = c8FaceIdSortAscending
.Style = msoButtonIconAndCaption
.Caption = "Ascending"
.TooltipText = c8ToolTipSort
.OnAction = "SortTablesAscending"
End With
With buttonSortTablesDescending
.FaceId = c8FaceIdSortDescending
.Style = msoButtonIconAndCaption
.Caption = "Descending"
.TooltipText = c8ToolTipSort
.OnAction = "SortTablesDescending"
End With
With buttonCheckTables
.Style = msoButtonCaption
.Caption = "Check Tables "
.TooltipText = c8ToolTipCheckTables
.OnAction = "CheckTablesInThisDocument"
End With
With buttonFormatDatesStandard1
.Style = msoButtonCaption
.Caption = format$(Date, c8DateFormatStandard1)
.TooltipText = c8ToolTipFormatDates
.OnAction = "FormatDates"
End With
With buttonFormatStandard1PlusDayOfWeek
.Style = msoButtonCaption
.Caption = format$(Date, c8DateFormatStandard1) & " " & format$(Date, "dddd")
.TooltipText = c8ToolTipFormatDates
.OnAction = "FormatDatesStandard1PlusDayOfWeek"
End With
With buttonFormatDatesISO
.Style = msoButtonCaption
.Caption = format$(Date, c8DateFormatISO)
.TooltipText = c8ToolTipFormatDates
.OnAction = "FormatDatesISO"
End With
With buttonFormatDatesISOPlusDayOfWeek
.Style = msoButtonCaption
.Caption = format$(Date, c8DateFormatISO) & " " & format$(Date, "dddd")
.TooltipText = c8ToolTipFormatDates
.OnAction = "FormatDatesISOPlusDayOfWeek"
End With
With buttonFirstError
.BeginGroup = True
.FaceId = c8FaceIdNavFirst
.Style = msoButtonIcon
.OnAction = "firstError"
.Tag = "navButton1"
End With
With buttonPreviousError
.FaceId = c8FaceIdNavPrevious
.Style = msoButtonIcon
.OnAction = "previousError"
.Tag = "navButton2"
End With
With buttonNextError
.FaceId = c8FaceIdNavNext
.Style = msoButtonIcon
.OnAction = "nextError"
.Tag = "navButton3"
End With
With buttonLastError
.FaceId = c8FaceIdNavLast
.Style = msoButtonIcon
.OnAction = "lastError"
.Tag = "navButton4"
End With
With buttonGoToErrorList
.FaceId = c8FaceIdNavList
.Style = msoButtonIcon
.OnAction = "gotoErrorList"
.Tag = "navButton5"
End With
Call navButtonsSetTooltipText(xSuffix:="error")
If noteLowest(ThisDocument) = -1 Then Call navButtonsDisable
With buttonPublishAsIs
.FaceId = c8FaceIdPublishExact
.Style = msoButtonIconAndCaption
.Caption = "Exact copy"
.TooltipText = c8TooltipPublishExact
.OnAction = "createExactCopy"
End With
With buttonPublishCustom
.FaceId = c8FaceIdPublishCustom
.Style = msoButtonIconAndCaption
.Caption = "Custom"
.TooltipText = c8TooltipPublishCustom
.OnAction = "CreateCustomDocument"
End With
With buttonPublishAnalysis
.FaceId = c8FaceIdPublishAnalysis
.Style = msoButtonIconAndCaption
.Caption = "Analysis"
.TooltipText = c8TooltipPublishAnalysis
.OnAction = "CreateAnalysisDocument"
End With
With buttonPublishJSON
.FaceId = c8FaceIdPublishJSON
.Style = msoButtonIconAndCaption
.Caption = "JSON"
.TooltipText = c8TooltipPublishJSON
.OnAction = "CreateJSONDocument"
End With
Call menuAdvancedSetup
Call menuHelpSetup
End Sub
Sub menuAdminCommonButtons(cbp As CommandBarPopup)
Set buttonWriteTable = cbp.CommandBar.Controls.add(msoControlButton)
With buttonWriteTable
.FaceId = c8FaceIdAddTable
.Style = msoButtonIconAndCaption
.Caption = "New table"
.TooltipText = c8ToolTipAddTable
.OnAction = "TableWriteAtEnd"
End With
Set buttonGetDocumentDetails = cbp.CommandBar.Controls.add(msoControlButton)
With buttonGetDocumentDetails
.FaceId = c8FaceIdDocInfo
.Style = msoButtonIconAndCaption
.Caption = "Show Document Details"
.TooltipText = c8ToolTipDocInfo
.OnAction = "ShowDocDetails"
End With
End Sub
Sub menuToolsCommonButtons(cbp As CommandBarPopup)
Set buttonAgeCalulator = cbp.CommandBar.Controls.add(msoControlButton)
With buttonAgeCalulator
.FaceId = c8FaceIdAgeCalc
.Style = msoButtonIconAndCaption
.Caption = "Age Calculator"
.TooltipText = c8ToolTipAgeCalc
.OnAction = "ShowAgeCalculator"
End With
Set menuGlossary = cbp.Controls.add(msoControlPopup)
menuGlossary.Caption = "Glossary"
Set buttonGlossaryEdit = menuGlossary.Controls.add(msoControlButton)
With buttonGlossaryEdit
.Style = msoButtonIconAndCaption
.FaceId = c8FaceIdAbbreviationsDefine
.Caption = "Edit"
.TooltipText = c8ToolTipAbbreviations
.OnAction = "ShowAbbreviationsDefine"
End With
Set buttonGlossaryAnonReview = menuGlossary.Controls.add(msoControlButton)
With buttonGlossaryAnonReview
.FaceId = c8FaceIdAnonymisationSetup
.Style = msoButtonIconAndCaption
.Caption = "Anonymisation and Review"
.TooltipText = c8ToolTipAnonymisationSetup
.OnAction = "AnonymiseShowForm"
End With
Set menuDuplicates = cbp.Controls.add(msoControlPopup)
menuDuplicates.Caption = "Duplicates"
Set buttonDuplicatesHighlight = menuDuplicates.Controls.add(msoControlButton)
With buttonDuplicatesHighlight
.FaceId = c8FaceIdDuplicatesHighlight
.Style = msoButtonIconAndCaption
.Caption = "Highlight"
.TooltipText = c8ToolTipDuplicatesHighlight
.OnAction = "DuplicatesHighlight"
End With
Set buttonDuplicatesDelete = menuDuplicates.Controls.add(msoControlButton)
With buttonDuplicatesDelete
.FaceId = c8FaceIdDuplicatesDelete
.Style = msoButtonIconAndCaption
.Caption = "Delete"
.TooltipText = c8ToolTipDuplicatesDelete
.OnAction = "DuplicatesDelete"
End With
Set menuSequence = cbp.Controls.add(msoControlPopup)
menuSequence.Caption = "Sequencing"
Set buttonSequenceColumnAdd = menuSequence.Controls.add(msoControlButton)
With buttonSequenceColumnAdd
.FaceId = c8FaceIdSequenceColumnAdd
.Style = msoButtonIconAndCaption
.Caption = "Add column"
.TooltipText = c8ToolTipSequenceColumnAdd
.OnAction = "SequenceColumnAdd_AllTables"
End With
Set buttonSequenceColumnDelete = menuSequence.Controls.add(msoControlButton)
With buttonSequenceColumnDelete
.FaceId = c8FaceIdSequenceColumnDelete
.Style = msoButtonIconAndCaption
.Caption = "Delete column"
.TooltipText = c8ToolTipSequenceColumnDelete
.OnAction = "SequenceColumnDelete_AllTables"
End With
Set buttonSequenceGroupByNone = menuSequence.Controls.add(msoControlButton)
With buttonSequenceGroupByNone
.FaceId = c8FaceIdSequenceGroupByNone
.Style = msoButtonIconAndCaption
.Caption = "Update - sequential"
.TooltipText = c8ToolTipSequenceGroupByNone
.OnAction = "SequenceColumnGroupByNone_AllTables"
End With
Set buttonSequenceGroupByDate = menuSequence.Controls.add(msoControlButton)
With buttonSequenceGroupByDate
.FaceId = c8FaceIdSequenceGroupByDate
.Style = msoButtonIconAndCaption
.Caption = "Update - group by day"
.TooltipText = c8ToolTipSequenceGroupByDate
.OnAction = "SequenceColumnGroupByDate_AllTables"
End With
Set buttonSequenceColumnClear = menuSequence.Controls.add(msoControlButton)
With buttonSequenceColumnClear
.FaceId = c8FaceIdSequenceColumnClear
.Style = msoButtonIconAndCaption
.Caption = "Clear"
.TooltipText = c8ToolTipSequenceColumnClear
.OnAction = "SequenceColumnClear_AllTables"
End With
Set buttonSequenceColumnChangeHeading = menuSequence.Controls.add(msoControlButton)
With buttonSequenceColumnChangeHeading
.FaceId = c8FaceIdSequenceColumnChangeHeading
.Style = msoButtonIconAndCaption
.Caption = "Change Column Heading"
.TooltipText = c8ToolTipSequenceColumnChangeHeading
.OnAction = "SequenceColumnChangeHeading_AllTables"
End With
Set menuTable = cbp.Controls.add(msoControlPopup)
menuTable.Caption = "Table Tools"
Set buttonTableAutoFitContents = menuTable.Controls.add(msoControlButton)
With buttonTableAutoFitContents
.FaceId = c8FaceIdTableAutoFitContents
.Style = msoButtonIconAndCaption
.Caption = "Autofit Contents"
.TooltipText = c8ToolTipTableAutoFitContents
.OnAction = "c8TablesAutoFitContents"
End With
Set buttonTableAutoFitWindow = menuTable.Controls.add(msoControlButton)
With buttonTableAutoFitWindow
.FaceId = c8FaceIdTableAutoFitWindow
.Style = msoButtonIconAndCaption
.Caption = "Autofit Window"
.TooltipText = c8ToolTipTableAutoFitWindow
.OnAction = "c8TablesAutoFitWindow"
End With
Set buttonTableSplit = menuTable.Controls.add(msoControlButton)
With buttonTableSplit
.FaceId = c8FaceIdTableSplit
.Style = msoButtonIconAndCaption
.Caption = "Split at current row"
.TooltipText = c8ToolTipTableSplit
.OnAction = "c8TablesSplitTable"
End With
Set menuAddin = cbp.Controls.add(msoControlPopup)
With menuAddin
.Caption = "Add-ins"
.BeginGroup = True
End With
Set buttonLoadAddin = menuAddin.Controls.add(msoControlButton)
With buttonLoadAddin
.FaceId = c8FaceIdLoadAddin
.Style = msoButtonIconAndCaption
.Caption = "Load add-in"
.TooltipText = c8ToolTipLoadAddin
.OnAction = "loadAddin"
End With
End Sub
Sub menuHelpSetup()
Set menuHelp = myToolbar.Controls.add(msoControlPopup)
With menuHelp
.Caption = "Help"
.BeginGroup = True
End With
Set buttonTutorials = menuHelp.CommandBar.Controls.add(msoControlButton)
With buttonTutorials
.Style = msoButtonCaption
.Caption = "Tutorials"
.TooltipText = c8ToolTipTutorials
.OnAction = "displayTutorials"
End With
Set buttonAbout = menuHelp.CommandBar.Controls.add(msoControlButton)
With buttonAbout
.BeginGroup = True
.Style = msoButtonCaption
.Caption = "About " & c8Name
.TooltipText = c8ToolTipAbout
.OnAction = "displayAbout"
End With
End Sub
Sub menuAdvancedSetup()
Set menuAdvanced = myToolbar.Controls.add(msoControlPopup)
menuAdvanced.Caption = "Advanced"
menuAdvanced.TooltipText = c8ToolTipMenuAdvanced
Set buttonImportSpecial_1 = menuAdvanced.CommandBar.Controls.add(msoControlButton)
Set buttonEnvironmentCleanup = menuAdvanced.CommandBar.Controls.add(msoControlButton)
Set buttonAddinsCleanup = menuAdvanced.CommandBar.Controls.add(msoControlButton)
Set buttonNormaliseSource = menuAdvanced.CommandBar.Controls.add(msoControlButton)
With buttonImportSpecial_1
.Style = msoButtonIconAndCaption
.Caption = "c8ImportSpecial_1"
.TooltipText = c8ToolTipImportSpecial
.OnAction = "c8ImportSpecial_1"
End With
With buttonEnvironmentCleanup
.Style = msoButtonIconAndCaption
.Caption = "c8EnvironmentCleanup"
.TooltipText = c8ToolTipEnvironmentCleanup
.OnAction = "c8EnvironmentCleanup"
End With
With buttonAddinsCleanup
.Style = msoButtonIconAndCaption
.Caption = "c8CleanupAddins"
.TooltipText = c8ToolTipAddinsCleanup
.OnAction = "c8CleanupAddins"
End With
With buttonNormaliseSource
.Style = msoButtonIconAndCaption
.Caption = "c8NormaliseSourceOfInformation"
.TooltipText = c8ToolTipNormaliseSource
.OnAction = "c8normaliseSourceOfInformation"
End With
End Sub
Function C8Documents() As Collection
Dim coll As Collection
Dim doc As Document
Dim i  As Long
Set coll = New Collection
For i = 1 To Application.Documents.count
Set doc = Application.Documents(i)
If IsC8Doc(doc) Then coll.add (doc.name)
Next i
Set C8Documents = coll
End Function
Function IsC8Doc(doc As Document) As Boolean
IsC8Doc = Not IsNull(BWordDocumentVariableGet(doc, "c8Version"))
End Function
Sub EnvironmentCleanup(Optional xAtStartup As Boolean = False)
Dim zDoc As Document
If xAtStartup Then
Else
Call wordOptionsRestore
End If
Call c8CleanupAddins
On Error Resume Next
For Each zDoc In Documents
If Left$(zDoc.name, 8) = "Document" Then
If IsNumeric(Mid$(zDoc.name, 9)) Then
If BWordDocumentVariableGet(zDoc, c8clsSaverFileStamp, "") = c8clsSaverFileStamp Then
zDoc.Close wdDoNotSaveChanges
End If
End If
End If
Next zDoc
DeleteSetting appname:=c8Name, Section:=c8RegistrySession
DeleteSetting appname:=c8Name, Section:=c8RegistryGeneral
Kill Application.Options.DefaultFilePath(wdTempFilePath) & Application.PathSeparator & c8MasterChronologyDoc
Kill Application.Options.DefaultFilePath(wdTempFilePath) & Application.PathSeparator & c8DisableAutoMacsFile
If driveMapper Is Nothing Then
Else
driveMapper.UnmapDrive
End If
End Sub
Sub EnvironmentStartup()
If C8Documents.count = 1 Then Call wordOptionsSave
Call wordOptionsSetValidFrom2000
If wordVersion >= WordXP Then Call wordOptionsSetValidFromXP
On Error Resume Next
ThisDocument.ActiveWindow.View.ShowBookmarks = False
c8ApplicationPath = ThisDocument.path
On Error GoTo pathError
Dir (c8ApplicationPath)
On Error GoTo 0
c8ApplicationPath = c8ApplicationPath & Application.PathSeparator
Call inbuiltStyles
abbreviationsListStringDelimiter = Chr(157)
BWordPerformanceOptionsSetCount = 0
ThisDocument.UndoClear
Exit Sub
pathError:
If Err.Number = 52 Or Err.Number = 53 Then
If thisDocDescriptor.docType = c8WorkbenchDocument Then
Set driveMapper = New clsDriveMapper
c8ApplicationPath = driveMapper.MapDrive(c8ApplicationPath)
End If
End If
Resume Next
End Sub
Sub disableAutomacs()
BWordSessionParameterSet xOption:=c8RegistryKeyDisableAutomacs
End Sub
Sub enableAutomacs()
BWordSessionParameterDelete xOption:=c8RegistryKeyDisableAutomacs
End Sub
Sub RegisterEventHandler()
Set eventHandler = New c8_ApplicationEventHandler
Set eventHandler.App = Application
End Sub
Function autoMacsDisabled() As Boolean
autoMacsDisabled = False
If C8Documents.count > 1 Then
If BWordSessionParameterIsSet(xOption:=c8RegistryKeyDisableAutomacs) Then
autoMacsDisabled = True
End If
End If
End Function
Sub inbuiltStyles()
Dim inbuiltStyle As Style
On Error GoTo styleError
With ThisDocument.Styles("Endnote Reference")
.Font.Superscript = False
.Font.Color = wdColorDarkRed
.Font.Hidden = False
End With
With ThisDocument.Styles("Endnote Text")
.ParagraphFormat.SpaceAfter = 0
.Font.name = "Courier New"
.Font.Size = 12
End With
For Each inbuiltStyle In ThisDocument.Styles
If inbuiltStyle.Type = wdStyleTypeParagraph Then inbuiltStyle.AutomaticallyUpdate = False
Next inbuiltStyle
ThisDocument.Endnotes.Location = wdEndOfDocument
Exit Sub
styleError:
If Err.Number = 4605 Then
If thisDocDescriptor.docType = c8WorkbenchDocument Then
Else
showMessage c8Msg5403
End If
Else
showMessage c8Msg6000, msgSuffix2:="inBuiltStyles: Error " & Err.Number & " (" & Err.Description & ")"
End If
End Sub
Sub navButtonsDisable()
On Error Resume Next
Dim ctl As CommandBarControl
ThisDocument.activate
For Each ctl In CommandBars(c8Name).Controls
If Left$(ctl.Tag, 9) = "navButton" Then
ctl.Enabled = False
End If
Next ctl
navButtonsEnabled = False
End Sub
Sub navButtonsEnable()
On Error Resume Next
Dim ctl As CommandBarControl
ThisDocument.activate
For Each ctl In CommandBars(c8Name).Controls
If Left$(ctl.Tag, 9) = "navButton" Then
ctl.Enabled = True
End If
Next ctl
navButtonsEnabled = True
End Sub
Public Sub navButtonsSetTooltipText(xSuffix As String)
If openedByC9 Then Exit Sub
saveStatus = ThisDocument.Saved
buttonFirstError.TooltipText = c8ToolTipNavFirst & xSuffix
buttonPreviousError.TooltipText = c8ToolTipNavPrevious & xSuffix
buttonNextError.TooltipText = c8ToolTipNavNext & xSuffix
buttonLastError.TooltipText = c8ToolTipNavLast & xSuffix
buttonGoToErrorList.TooltipText = c8ToolTipNavList & xSuffix & "s"
ThisDocument.Saved = saveStatus
End Sub
Public Sub runAutoOpen(xDocFullName As String)
Dim d As Document
On Error GoTo byNumericIndex
Set d = Documents(xDocFullName)
GoTo activate
byNumericIndex:
On Error GoTo 0
Set d = Documents(BWordGetNumericDocumentIndex(xDocFullName))
activate:
On Error GoTo 0
d.activate
If xDocFullName = ThisDocument.fullName Then
Call AutoOpen
Else
Call disableAutomacs
d.Close
Call enableAutomacs
Documents.Open (xDocFullName)
End If
End Sub
Sub wordOptionsSave()
On Error GoTo openError1
Call wordOptionsSaveValidFrom2000
If wordVersion >= WordXP Then Call wordOptionsSaveValidFromXP
Exit Sub
openError1:
showMessage c8Msg6000, msgSuffix2:="  wordOptionsSave: Error " & Err.Number & " (" & Err.Description & ")" & vbNewLine & vbNewLine & c8Msg6000MsgSufCloseAllDocs
End Sub
Sub wordOptionsRestore()
Dim saveStatus As Boolean
saveStatus = ThisDocument.Saved
On Error GoTo openError1
Call wordOptionsRestoreValidFrom2000
If wordVersion >= WordXP Then Call wordOptionsRestoreValidFromXP
ThisDocument.Saved = saveStatus
Exit Sub
openError1:
End Sub
Sub wordOptionsSaveValidFrom2000()
On Error Resume Next
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyDisplayScreenTips, setting:=Application.DisplayScreenTips
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyShowPicturePlaceHolders, setting:=Application.ActiveWindow.View.ShowPicturePlaceHolders
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyDisplayScrollBars, setting:=Application.DisplayScrollBars
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeySaveInterval, setting:=Application.Options.SaveInterval
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyCheckSpellingAsYouType, setting:=Application.Options.CheckSpellingAsYouType
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyCheckGrammarAsYouType, setting:=Application.Options.CheckGrammarAsYouType
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyPagination, setting:=Application.Options.Pagination
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyCheckProofingLanguage, setting:=Application.CheckLanguage
End Sub
Sub wordOptionsSaveValidFromXP()
SaveSetting appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyShowWindowsInTaskbar, setting:=Application.ShowWindowsInTaskbar
End Sub
Sub wordOptionsRestoreValidFrom2000()
Application.DisplayScreenTips = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyDisplayScreenTips)
Application.ActiveWindow.View.ShowPicturePlaceHolders = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyShowPicturePlaceHolders)
Application.DisplayScrollBars = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyDisplayScrollBars)
Application.Options.SaveInterval = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeySaveInterval)
Application.Options.CheckSpellingAsYouType = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyCheckSpellingAsYouType)
Application.Options.CheckGrammarAsYouType = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyCheckGrammarAsYouType)
Application.Options.Pagination = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyPagination)
Application.CheckLanguage = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyCheckProofingLanguage)
End Sub
Sub wordOptionsRestoreValidFromXP()
Application.ShowWindowsInTaskbar = GetSetting(appname:=c8Name, Section:=c8RegistryGeneral, key:=c8RegistryKeyShowWindowsInTaskbar)
End Sub
Sub wordOptionsSetValidFrom2000(Optional test As Boolean = False)
If test Then
Application.DisplayScreenTips = False
Application.DisplayScrollBars = False
Application.Options.CheckSpellingAsYouType = True
Application.Options.CheckGrammarAsYouType = True
Application.Options.Pagination = True
Application.CheckLanguage = True
Else
Application.DisplayScreenTips = True
Application.DisplayScrollBars = True
End If
End Sub
Sub wordOptionsSetValidFromXP(Optional test As Boolean = False)
Dim zString As String
If test Then
Application.ShowWindowsInTaskbar = False
Application.Options.LocalNetworkFile = False
If GetSetting(appname:=c8Name, Section:=c8RegistryMessages, key:="5220", Default:="NotSet") = "NotSet" Then
Else
DeleteSetting appname:=c8Name, Section:=c8RegistryMessages, key:="5220"
End If
Exit Sub
End If
Application.ShowWindowsInTaskbar = True
On Error Resume Next
If Application.Options.LocalNetworkFile Then
Else
zString = showMessage(c8Msg5220, button2:="OK", button3:="Cancel", defaultButton:=3, suppressUntil:=format$(DateAdd("d", 1, Now), "yyyy-mm-dd"))
If zString = "OK" Then
Application.Options.LocalNetworkFile = True
showMessage c8Msg5221
End If
End If
If Application.Options.LocalNetworkFile Then
If autoRecoverOnNetworkDrive Then Application.Options.SaveInterval = 0
End If
End Sub
Function autoRecoverOnNetworkDrive() As Boolean
autoRecoverOnNetworkDrive = UCase$(Left$(Application.Options.DefaultFilePath(wdAutoRecoverPath), 2)) <> "C:"
End Function
Sub disableReadingView()
ThisDocument.ActiveWindow.View.ReadingLayout = False
End Sub
Sub buttonStates()
Call buttonStatesToolsMenu
End Sub
Sub buttonStatesToolsMenu()
Select Case thisDocDescriptor.docType
Case c8WorkbenchDocument
Case c8InternalChronology
Call buttonStatesSequencing
Case c8CompositeChronologyNew
Case c8CompositeChronologyOld
Call buttonStatesSequencing
End Select
End Sub
Attribute VB_Name = "c8_FormFeatures"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public Const c8FormFont1 As String = "MS Sans Serif"
Public Const c8FormFont2 As String = "Segoe UI"
Public Const c8FormFont3 As String = "Lucida Console"
Public Const c8FormFont4 As String = "MS Sans Serif"
Public Const c8FormFont5 As String = "Comic Sans MS"
Public formColors(1 To 6) As Long
Public formFonts(1 To 5) As String
Const useDefault As String = "d"
Public Sub setFormSkins(Optional xColors As Variant)
If IsMissing(xColors) Then
formColors(1) = 0
formColors(2) = RGB(80, 80, 80)
formColors(3) = RGB(117, 117, 117)
formColors(4) = RGB(230, 230, 230)
formColors(5) = RGB(255, 255, 255)
formColors(6) = RGB(151, 227, 253)
Else
formColors(1) = xColors(1)
formColors(2) = xColors(2)
formColors(3) = xColors(3)
formColors(4) = xColors(4)
formColors(5) = xColors(5)
formColors(6) = xColors(6)
End If
formFonts(1) = c8FormFont1
formFonts(2) = c8FormFont2
formFonts(3) = c8FormFont3
formFonts(4) = c8FormFont4
formFonts(5) = c8FormFont5
End Sub
Public Sub formFeatures(xForm As UserForm, Optional xSetDefaults As Boolean = True)
Dim xControl As Control
Dim defaultForeColor As Long
Dim defaultBackColor As Long
Dim defaultFont As String
Dim zString As String
Dim storeValue As Variant
defaultForeColor = formColors(5)
defaultBackColor = formColors(3)
storeValue = ""
If wordVersion < Word2007 Then
defaultFont = formFonts(1)
Else
defaultFont = formFonts(2)
End If
If xSetDefaults Then
With xForm
.foreColor = defaultForeColor
.backColor = defaultBackColor
.Font = defaultFont
.BorderStyle = fmBorderStyleSingle
.BorderColor = wdColorWhite
End With
End If
For Each xControl In xForm.Controls
Select Case TypeName(xControl)
Case "CommandButton"
If Len(xControl.Tag) = 0 Then xControl.Tag = "14d"
Case "TextBox"
If Len(xControl.Tag) = 0 Then
xControl.BorderStyle = fmBorderStyleSingle
xControl.BorderColor = wdColorWhite
xControl.Tag = "52d"
End If
Case "MultiPage"
If Len(xControl.Tag) = 0 Then xControl.Tag = "13d"
Case "CheckBox"
xControl.SpecialEffect = fmButtonEffectFlat
xControl.BackStyle = fmBackStyleTransparent
storeValue = xControl.value
End Select
zString = getTagCharacter(xControl.Tag, 1)
If characteristicSpecified(zString, UBound(formColors)) Then
xControl.foreColor = formColors(CLng(zString))
Else
If zString = useDefault Then
xControl.foreColor = defaultForeColor
End If
End If
zString = getTagCharacter(xControl.Tag, 2)
If characteristicSpecified(zString, UBound(formColors)) Then
xControl.backColor = formColors(CLng(zString))
Else
If zString = useDefault Then
xControl.backColor = defaultBackColor
End If
End If
zString = getTagCharacter(xControl.Tag, 3)
If characteristicSpecified(zString, UBound(formFonts)) Then
xControl.Font.name = formFonts(CLng(zString))
Else
If zString = useDefault Then
xControl.Font.name = defaultFont
End If
End If
If TypeName(xControl) = "CheckBox" Then xControl.value = storeValue
Next xControl
End Sub
Sub setMultipageBackgrounds(xMultipage As MultiPage, Optional leftHandHeight As Long)
Dim xPage As MSForms.Page
Dim xControl As Control
Const lPanelWidth As Long = 175
For Each xPage In xMultipage.Pages
If Len(xPage.Tag) = 0 Then xPage.Tag = "5253"
Set xControl = xPage.Controls.add("Forms.Label.1")
With xControl
.Tag = Left$(xPage.Tag, 2)
.Top = 2
.Left = 0
If leftHandHeight = 0 Then
.Height = xPage.InsideHeight
Else
.Height = leftHandHeight
End If
.Width = lPanelWidth
.ZOrder (1)
End With
Set xControl = xPage.Controls.add("Forms.Label.1")
With xControl
.Tag = Right$(xPage.Tag, 2)
.Top = 2
.Left = lPanelWidth
.Height = xPage.InsideHeight
.Width = xPage.InsideWidth - lPanelWidth
.ZOrder (1)
End With
Next xPage
End Sub
Function getTagCharacter(xTag As String, xIndex As Long) As String
If xIndex > Len(xTag) Then
getTagCharacter = useDefault
Else
getTagCharacter = Mid$(xTag, xIndex, 1)
End If
End Function
Function characteristicSpecified(xCharacter As String, xUbound As Long) As Boolean
If IsNumeric(xCharacter) Then
If BWithinBounds(CLng(xCharacter), 1, xUbound) Then
characteristicSpecified = True
End If
End If
End Function
Attribute VB_Name = "c8_JSON"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Private publishCancelled As Boolean
Private publishCancelledInternally As Boolean
Dim lines As Variant
Dim eventCount As Long
Dim jsonSaver As clsBWindowsFileDialogs
Dim jsonFullName As String
Sub CreateJSONDocument2()
Dim tablesfound As Variant
Dim sw1 As clsStopWatch
Dim i As Long
Dim saveStatus As Boolean
Dim normaliseSourceRequired As Boolean
Dim sourceFragments() As String
Dim zString As String
Dim zStringArray() As String
Dim zEntries As Variant
Dim zEntry As String
Dim docSave As String
Dim pbWeightingPhase1 As Double
Dim pbWeightingPhase2 As Double
Set sw1 = New clsStopWatch
sw1.Start
saveStatus = ThisDocument.Saved
publishCancelled = False
publishCancelledInternally = False
docSave = ""
fs2FileToPublish = ThisDocument.name
With progressBar
.Reset
.title = "Create JSON Document"
.Caption1 = c8PBSavingDocument
.show
.AddProgress 0.01
.CancelButtonEnable False
End With
docSave = thisDocSaver.documentSave(ThisDocument)
progressBar.Caption1 = c8PBAnalysingTables
tablesfound = GetTables(doc:=ThisDocument, heads:=BuildHeadersArray(thisDocDescriptor), xIncludeVerticallyMerged:=False)
If IsEmpty(tablesfound) Then
Call showMessage(c8Msg1015, msgSuffix1:=" " & fs2FileToPublish)
GoTo finish
End If
Call setProgressBarCounters(ThisDocument, tablesfound)
If pbRowsToCheck = 0 Then
showMessage c8Msg3012
GoTo finish
End If
Application.screenUpdating = False
ThisDocument.activate
progressBar.Caption2 = c8PBCheckingSPN
normaliseSourceRequired = (thisDocSourcePrefixes.count > 0) And (thisDocDescriptor.tablesHash2 <> tablesHash(tablesfound, ThisDocument, thisDocDescriptor.columnSource))
sw1.Halt
If normaliseSourceRequired Then
pbWeightingPhase1 = 0.2
pbWeightingPhase2 = 0.8
sourceFragments = GetSourceFragments
If sourcePrefixNormalise(tablesfound, sourceFragments, thisDocDescriptor.columnSource, xAddProgress:=pbWeightingPhase1 / pbRowsToCheck) = "" Then
Else
If progressBar.userCancelled Then
publishCancelledInternally = False
Else
publishCancelledInternally = True
End If
GoTo exitPublishCancelled
End If
Else
pbWeightingPhase2 = 1
End If
If progressBar.userCancelled Then GoTo exitPublishCancelled
progressBar.Caption2 = ""
sw1.Start
progressBar.Caption1 = c8PBEscapes
Call JSONescapes(ThisDocument.Range)
progressBar.AddProgress 0.2 * pbWeightingPhase2
progressBar.Caption1 = c8PBWritingJsonToArray
On Error Resume Next
Erase lines
On Error GoTo 0
addJSON lines, "{" & q("version") & ":" & q("3") & ","
addJSON lines, q("documentDescriptor") & ":{"
addJSON lines, q("licence") & ":" & q("c8" & scrambleLicence(c8LicenceID, c8LicenceOwner, c8LicenceExpiryDate, c8LicenceExtensionPasswordKey)) & ","
addJSON lines, q("glossaryAdmin") & ":"
addJSON lines, thisDocGlossaryAdmin.dumpToJSON
addJSON lines, ","
addJSON lines, q("glossaryUser") & ":"
addJSON lines, thisDocGlossaryUser.dumpToJSON
addJSON lines, ","
addJSON lines, q("highlightSource") & ":{"
addJSON lines, q("level01") & ":{"
zStringArray = ppH_ScopeAndSchemeGet
addJSON lines, nvp("scope", zStringArray(0)) & ","
addJSON lines, nvp("scheme", zStringArray(1))
Set zEntries = thisDocProcessingParameters.getEntriesByKey("H3")
For i = 1 To zEntries.count
addJSON lines, ","
zEntry = zEntries(i)
zString = thisDocProcessingParameters.getItem(zEntry)
zString = Left$(zString, Len(zString) - 2)
addJSON lines, nvp(zString, CLng(thisDocProcessingParameters.getPrefix(zEntry)))
Next
addJSON lines, "}"
addJSON lines, "}"
addJSON lines, "},"
addJSON lines, q("chronology") & ":{"
addJSON lines, q("version") & ":" & q("3") & ","
addJSON lines, q("descriptor") & ":"
Call js_descriptor(thisDocDescriptor, True)
addJSON lines, "," & q("events") & ":"
addJSON lines, "["
eventCount = 0
For i = 0 To UBound(tablesfound)
progressBar.Caption2 = c8PBProcessingTable & i + 1 & c8PBOf & pbTablesToCheck
progressBar.Caption3 = ""
Call createJSONDocument3(xTableIndex:=CLng(tablesfound(i)), xAddProgress:=(pbWeightingPhase2 / (UBound(tablesfound) + 1)))
If publishCancelled Then
GoTo exitPublishCancelled
End If
Next i
addJSON lines, "]"
addJSON lines, "}}"
ppStats_Update ppStats_PublishJSON, pbTablesToCheck, pbRowsToCheck, sw1.value
With progressBar
.Caption1 = c8PBWritingJsonToFile
.Caption2 = ""
.Caption3 = ""
End With
Set jsonSaver = New clsBWindowsFileDialogs
With jsonSaver
.fileFullName = BGetFilenamePart(ThisDocument.name)
.filter = "json" & vbNullChar & "*.json*" & vbNullChar & "All Files" & vbNullChar & "*.*" & vbNullChar & vbNullChar
.dialogTitle = "Save JSON"
.fileExt = "json"
.initialDirectory = ThisDocument.path
If .showSave Then
If .extensionChanged Then MsgBox "Ignoring new extension - will save as JSON"
jsonFullName = .filePath & .fileName & ".json"
Else
publishCancelledInternally = False
GoTo exitPublishCancelled
End If
End With
On Error GoTo exitPublishCancelled
Dim JSONFileNumber As Integer
JSONFileNumber = FreeFile()
Open jsonFullName For Output As JSONFileNumber
Print #JSONFileNumber, BCreateTextDocFromArray(lines, xWriteProgress:=True, xAddProgress:=pbWeightingPhase2 * 0.4)
If progressBar.userCancelled Then GoTo exitPublishCancelled
On Error GoTo 0
progressBar.Caption1 = c8PBFinishing
progressBar.Caption2 = ""
GoTo finish
exitPublishCancelled:
If publishCancelledInternally Then
publishCancelledInternally = False
GoTo finish
End If
progressBar.Caption1 = c8PBCancelAcknowledged
progressBar.Caption2 = c8PBWaitRestore
progressBar.Caption3 = ""
showMessage c8Msg5115
finish:
On Error Resume Next
Close JSONFileNumber
On Error GoTo 0
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
Call thisDocSaver.closeSingle(docSave)
Application.screenUpdating = True
progressBar.finish
fs2FileToPublish = ""
Application.screenUpdating = True
ThisDocument.Saved = saveStatus
End Sub
Sub createJSONDocument3(xTableIndex As Long, xAddProgress As Double)
Dim t As table
Dim tableAsArray As Variant
Dim progressBarIncrement As Double
Set t = ThisDocument.tables(xTableIndex)
If progressBar.userCancelled Then GoTo publishCancelled
progressBarIncrement = xAddProgress / pbRowsToCheck
tableAsArray = BWordTableToArray(xTable:=t, xDelete:=False, xProgressBarIncrement:=0.4 * progressBarIncrement)
If BWordTableToArrayError(tableAsArray) Then
GoTo badFinish
End If
If progressBar.userCancelled Then GoTo publishCancelled
Call js_events(tableAsArray, thisDocDescriptor, 0.6 * progressBarIncrement)
Exit Sub
badFinish:
publishCancelledInternally = True
publishCancelled:
publishCancelled = True
End Sub
Sub JSONescapes(R As Range)
With R.Find
.ClearFormatting
.Replacement.ClearFormatting
.format = False
progressBar.Caption2 = "1 of 22"
.text = "\"
.Replacement.text = "\\"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "2 of 22"
.text = "/"
.Replacement.text = "\/"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "3 of 22"
.text = vbBack
.Replacement.text = "\b"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "4 of 22"
.text = vbFormFeed
.Replacement.text = "\f"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "5 of 22"
.text = vbLf
.Replacement.text = "\n"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "6 of 22"
.text = vbVerticalTab
.Replacement.text = "\n"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "7 of 22"
.text = vbCr
.Replacement.text = "\n"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "8 of 22"
.text = vbTab
.Replacement.text = "\t"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "9 of 22"
.text = ChrW$(&H2028)
.Replacement.text = "\n"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "10 of 22"
.text = ChrW$(&H2029)
.Replacement.text = "\n"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "11 of 22"
.text = ChrW$(14)
.Replacement.text = " "
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "12 of 22"
.text = ChrW$(30)
.Replacement.text = "-"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "13 of 22"
.text = ChrW$(31)
.Replacement.text = "-"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "14 of 22"
.text = Chr(160)
.Replacement.text = "\t"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "15 of 22"
.text = Chr(128)
.Replacement.text = "\u20ac"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "16 of 22"
.text = Chr(130)
.Replacement.text = "\u201a"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "17 of 22"
.text = Chr(132)
.Replacement.text = "\u201e"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "18 of 22"
.text = Chr(145)
.Replacement.text = "\u2018"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "19 of 22"
.text = Chr(146)
.Replacement.text = "\u2019"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "20 of 22"
.text = Chr(147)
.Replacement.text = "\u201c"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "21 of 22"
.text = Chr(148)
.Replacement.text = "\u201d"
.Execute replace:=wdReplaceAll
progressBar.Caption2 = "22 of 22"
.text = ChrW$(34)
.Replacement.text = "\" & ChrW$(34)
.Execute replace:=wdReplaceAll
End With
End Sub
Function JSONescape(xInput As String) As String
Dim out As String
out = replace(xInput, "\", "\\")
out = replace(out, "/", "\/")
out = replace(out, vbBack, "\b")
out = replace(out, vbFormFeed, "\f")
out = replace(out, vbLf, "\n")
out = replace(out, vbVerticalTab, "\n")
out = replace(out, vbCr, "\n")
out = replace(out, vbTab, "\t")
out = replace(out, ChrW$(&H2028), "\n")
out = replace(out, ChrW$(&H2029), "\n")
out = replace(out, ChrW$(14), " ")
out = replace(out, ChrW$(30), "-")
out = replace(out, ChrW$(31), "-")
out = replace(out, Chr(160), "\t")
out = replace(out, Chr(128), "\u20ac")
out = replace(out, Chr(130), "\u201a")
out = replace(out, Chr(130), "\u201a")
out = replace(out, Chr(132), "\u201e")
out = replace(out, Chr(145), "\u2018")
out = replace(out, Chr(146), "\u2019")
out = replace(out, Chr(147), "\u201c")
out = replace(out, Chr(148), "\u201d")
out = replace(out, ChrW$(34), "\" & ChrW$(34))
JSONescape = out
End Function
Sub js_descriptor(descriptor As clsDocDescriptor, setTitle As Boolean)
Dim title As String
Dim docType As String
If setTitle Then
title = replace(ThisDocument.Sections(1).Headers(wdHeaderFooterPrimary).Range.text, vbCr, "")
End If
Select Case descriptor.docType
Case c8InternalChronology
docType = "i"
Case c8CompositeChronologyOld
docType = "c"
End Select
addJSON lines, "{" & nvp("title", title) & "," & nvp("reference", descriptor.caseRef) & "," & nvp("type", docType) & "," & q("columnDescriptors") & ":"
Call js_columnDescriptors(lines, descriptor)
addJSON lines, "}"
End Sub
Sub js_columnDescriptors(lines As Variant, descriptor As clsDocDescriptor)
Dim i As Long
Dim zColumns As String
Dim specialColumnCount As Long
specialColumnCount = 2
zColumns = "{" & nvp("name", "startDate") & "," & nvp("index", descriptor.columnStartDate - 1) & "," & nvp("mandatory", "true") & "," & nvp("datatype", "d") & "," & nvp("heading", descriptor.columnHeading(descriptor.columnStartDate)) & "}" & ","
If descriptor.columnStartTime > 0 Then
specialColumnCount = specialColumnCount + 1
zColumns = zColumns & "{" & nvp("name", "startTime") & "," & nvp("index", descriptor.columnStartTime - 1) & "," & nvp("mandatory", LCase$(BBitIsSet(descriptor.columnStartTime, descriptor.mandatoryColumns))) & "," & nvp("datatype", "t") & "," & nvp("heading", descriptor.columnHeading(descriptor.columnStartTime)) & "}" & ","
End If
If descriptor.columnEndDate > 0 Then
specialColumnCount = specialColumnCount + 1
zColumns = zColumns & "{" & nvp("name", "endDate") & "," & nvp("index", descriptor.columnEndDate - 1) & "," & nvp("mandatory", LCase$(BBitIsSet(descriptor.columnEndDate, descriptor.mandatoryColumns))) & "," & nvp("datatype", "d") & "," & nvp("heading", descriptor.columnHeading(descriptor.columnEndDate)) & "}" & ","
End If
If descriptor.columnEndTime > 0 Then
specialColumnCount = specialColumnCount + 1
zColumns = zColumns & "{" & nvp("name", "endTime") & "," & nvp("index", descriptor.columnEndTime - 1) & "," & nvp("mandatory", LCase$(BBitIsSet(descriptor.columnEndTime, descriptor.mandatoryColumns))) & "," & nvp("datatype", "t") & "," & nvp("heading", descriptor.columnHeading(descriptor.columnEndTime)) & "}" & ","
End If
zColumns = zColumns & "{" & nvp("name", "source") & "," & nvp("index", descriptor.columnSource - 1) & "," & nvp("mandatory", "true") & "," & nvp("datatype", "s") & "," & nvp("heading", descriptor.columnHeading(descriptor.columnSource)) & "}" & ","
If descriptor.columnGlossary > 0 Then
specialColumnCount = specialColumnCount + 1
zColumns = zColumns & "{" & nvp("name", "glossary") & "," & nvp("index", descriptor.columnGlossary - 1) & "," & nvp("mandatory", LCase$(BBitIsSet(descriptor.columnGlossary, descriptor.mandatoryColumns))) & "," & nvp("datatype", "g") & "," & nvp("heading", descriptor.columnHeading(descriptor.columnGlossary)) & "}" & ","
End If
If descriptor.columnSequence > 0 Then
specialColumnCount = specialColumnCount + 1
zColumns = zColumns & "{" & nvp("name", "startSeq") & "," & nvp("index", descriptor.columnSequence - 1) & "," & nvp("mandatory", LCase$(BBitIsSet(descriptor.columnSequence, descriptor.mandatoryColumns))) & "," & nvp("datatype", "q") & "," & nvp("heading", descriptor.columnHeading(descriptor.columnSequence)) & "}" & ","
End If
For i = specialColumnCount + 1 To descriptor.columnCount
zColumns = zColumns & "{" & nvp("name", "g-" & format$(i - 1, "00")) & "," & nvp("index", CStr(i - 1)) & "," & nvp("mandatory", LCase$(BBitIsSet(i, descriptor.mandatoryColumns))) & "," & nvp("datatype", "") & "," & nvp("heading", descriptor.columnHeading(i)) & "}"
If i < descriptor.columnCount Then zColumns = zColumns & ","
Next
addJSON lines, "[" & zColumns & "]"
End Sub
Sub js_events(tableAsArray As Variant, descriptor As clsDocDescriptor, progressBarIncrement As Double)
Dim rowIndex As Long
Dim colIndex As Long
Dim k As Long
For rowIndex = 2 To UBound(tableAsArray)
If BWordIsBlankRow_TA(tableAsArray, rowIndex) Then
GoTo nextRow
End If
If eventCount > 0 Then addJSON lines, ","
eventCount = eventCount + 1
addJSON lines, "{"
addJSON lines, nvp("id", CStr(eventCount)) & ","
For k = descriptor.columnCount To 0 Step -1
If Len(tableAsArray(rowIndex, k)) > -1 Then Exit For
Next k
For colIndex = 1 To k - 1
Call js_cell(tableAsArray(rowIndex, colIndex), colIndex, descriptor, lines)
Next colIndex
addJSON lines, nvp("g-" & format$(k - 1, "00"), CStr(tableAsArray(rowIndex, k)))
addJSON lines, "}"
progressBar.AddProgress progressBarIncrement
nextRow:
Next
End Sub
Sub js_cell(data As Variant, columnIndex As Long, descriptor As clsDocDescriptor, lines As Variant)
Dim key As String
If Len(data) = 0 Then Exit Sub
Select Case columnIndex
Case descriptor.columnSequence
key = "startSeq"
Case descriptor.columnStartDate
key = "startDate"
Case descriptor.columnStartTime
key = "startTime"
Case descriptor.columnEndDate
key = "endDate"
Case descriptor.columnEndTime
key = "endTime"
Case descriptor.columnSource
key = "source"
Case descriptor.columnGlossary
key = "glossary"
Case Else
key = "g-" & format$(columnIndex - 1, "00")
End Select
addJSON lines, nvp(key, CStr(data)) & ","
End Sub
Function scrambleLicence(c8LicenceID As String, c8LicenceOwner As String, c8LicenceExpiryDate As String, c8LicenceExtensionPasswordKey As String) As String
Dim licence As String
Dim encrypted As String
encrypted = XOREncryption(c9p1, c8LicenceID & Chr(141) & c8LicenceOwner & Chr(141) & c8LicenceExpiryDate & Chr(141) & c8LicenceExtensionPasswordKey)
licence = Base64EncodeString(encrypted)
scrambleLicence = licence
End Function
Sub addJSON(lines As Variant, line As String)
Call BWriteLineInArray(lines, "xx" & line)
End Sub
Function q(stuff As String) As String
q = ChrW$(34) & stuff & ChrW$(34)
End Function
Function nvp(name As String, value As String) As String
Dim outValue As String
Dim z As String
z = LCase$(value)
If (z = "true") Or (z = "false") Then
outValue = value
Else
outValue = q(value)
End If
nvp = q(name) & ":" & outValue
End Function
Attribute VB_Name = "c8_Licence"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Private Const c8LicenceIDRecordKey As String = "01"
Private Const c8LicenceOwnerRecordKey As String = "02"
Private Const c8LicenceExpiryDateRecordKey As String = "03"
Private Const c8LicenceExtensionPasswordKeyRecordKey As String = "04"
Private Const c8LicenceSingleCaseReferenceRecordKey As String = "99"
Public c8LicenceID As String
Public c8LicenceOwner As String
Public c8LicenceExpiryDate As String
Public c8LicenceExtensionPasswordKey As String
Public c8LicenceSingleCaseReference As String
Public c8LicenceFoundMultiple As Boolean
Public c8LicenceHaveValid As Boolean
Public c8LicenceHasExpired As Boolean
Public c8LicenceHasBeenAccepted As Boolean
Public c8LicenceEncryptor As clsRC4
Public Function licenceGetExternal(licenceFile As String) As Boolean
Dim licenceFileNumber As Long
Dim licence As String
Dim validator As String
Dim zString As String
Dim zStringArray() As String
On Error GoTo licenceGetExternalFailed
zString = ""
licenceFileNumber = FreeFile()
Open licenceFile For Input As licenceFileNumber
Do While Not EOF(licenceFileNumber)
Dim zString2 As String
Input #licenceFileNumber, zString2
zString = zString & zString2
Loop
zStringArray = Split(zString, Chr(141))
If UBound(zStringArray) <> 1 Then GoTo licenceGetExternalFailed
licence = zStringArray(0)
validator = c8LicenceEncryptor.Decrypt(zStringArray(1), c8LicenceEncryptorKey02)
If licence <> validator Then GoTo licenceGetExternalFailed
zString = c8LicenceEncryptor.Decrypt(licence)
zStringArray = Split(zString, Chr(141))
If UBound(zStringArray) <> 3 Then GoTo licenceGetExternalFailed
zString = zStringArray(0)
If Left$(zString, 2) = c8LicenceIDRecordKey Then
c8LicenceID = Mid$(zString, 3)
End If
zString = zStringArray(1)
If Left$(zString, 2) = c8LicenceOwnerRecordKey Then
c8LicenceOwner = Mid$(zString, 3)
End If
If Len(c8LicenceID) = 0 Or Len(c8LicenceOwner) = 0 Then GoTo licenceGetExternalFailed
zString = zStringArray(2)
If Left$(zString, 2) = c8LicenceExpiryDateRecordKey And IsDate(Mid$(zString, 3)) Then
c8LicenceExpiryDate = Mid$(zString, 3)
Else
GoTo licenceGetExternalFailed
End If
zString = zStringArray(3)
If Left$(zString, 2) = c8LicenceExtensionPasswordKeyRecordKey Then
c8LicenceExtensionPasswordKey = extensionPasswordParse(Mid$(zString, 3))(2)
Else
GoTo licenceGetExternalFailed
End If
c8LicenceHaveValid = True
licenceGetExternal = True
Call licenceCheckExpiry
GoTo licenceGetExternalExit
licenceGetExternalFailed:
c8LicenceID = ""
c8LicenceOwner = ""
c8LicenceHaveValid = False
c8LicenceExpiryDate = ""
licenceGetExternal = False
GoTo licenceGetExternalExit
licenceGetExternalExit:
On Error Resume Next
Close licenceFileNumber
End Function
Public Function licenceFindFile(Optional path As String) As String
Dim licenceFileName As String
If Len(path) = 0 Then
path = c8ApplicationPath
End If
licenceFindFile = ""
c8LicenceFoundMultiple = False
licenceFileName = Dir(path & c8LicenceFileNamePrefix & "*")
If Len(licenceFileName) = 0 Then
Exit Function
Else
If Len(Dir()) = 0 Then
Else
c8LicenceFoundMultiple = True
End If
End If
licenceFindFile = path & licenceFileName
End Function
Public Function licenceGetInternal(Optional inDoc As Variant) As Boolean
Dim xDoc As Document
Dim encLicenceId As String
Dim encLicenceOwner As String
Dim encLicenceExpiryDate As String
Dim encLicenceExtensionPasswordKey As String
Dim encLicenceSingleCaseReference As String
On Error GoTo licenceGetInternalError
If IsMissing(inDoc) Then
Set xDoc = ThisDocument
Else
Set xDoc = inDoc
End If
encLicenceId = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8LicenceKey" & c8LicenceIDRecordKey, xDefault:="")
encLicenceOwner = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8LicenceKey" & c8LicenceOwnerRecordKey, xDefault:="")
encLicenceExpiryDate = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8LicenceKey" & c8LicenceExpiryDateRecordKey, xDefault:="")
encLicenceExtensionPasswordKey = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8LicenceKey" & c8LicenceExtensionPasswordKeyRecordKey, xDefault:="")
encLicenceSingleCaseReference = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8LicenceKey" & c8LicenceSingleCaseReferenceRecordKey, xDefault:="")
If Len(encLicenceId) = 0 Or Len(encLicenceOwner) = 0 Or Len(encLicenceExpiryDate) = 0 Then
GoTo licenceGetInternalFailed
End If
c8LicenceID = c8LicenceEncryptor.Decrypt(strText:=encLicenceId)
c8LicenceOwner = c8LicenceEncryptor.Decrypt(strText:=encLicenceOwner)
c8LicenceExpiryDate = c8LicenceEncryptor.Decrypt(strText:=encLicenceExpiryDate)
c8LicenceExtensionPasswordKey = c8LicenceEncryptor.Decrypt(strText:=encLicenceExtensionPasswordKey)
If Len(encLicenceSingleCaseReference) = 0 Then
c8LicenceSingleCaseReference = ""
Else
c8LicenceSingleCaseReference = c8LicenceEncryptor.Decrypt(strText:=encLicenceSingleCaseReference)
End If
c8LicenceHaveValid = True
licenceGetInternal = True
Call licenceCheckExpiry
GoTo licenceGetInternalExit
licenceGetInternalError:
showMessage c8Msg6000, msgPrefix2:="Unable to determine licence status. Chronolator will continue with an Evaluation Licence." & vbNewLine & vbNewLine, msgSuffix2:="licenceGetInternal: Last Error " & Err.Number & " (" & Err.Description & ")"
licenceGetInternalFailed:
c8LicenceID = ""
c8LicenceOwner = ""
c8LicenceHaveValid = False
c8LicenceExpiryDate = ""
c8LicenceExtensionPasswordKey = ""
licenceGetInternal = False
GoTo licenceGetInternalExit
licenceGetInternalExit:
End Function
Public Sub licenceSetInternal(targetDoc As Document, licenceId As String, licenceOwner As String, licenceExpiryDate As String, licenceExtensionPasswordKey As String, Optional licenceSingleCaseReference As String = "")
Call BWordDocumentVariableSet(xDoc:=targetDoc, xName:="c8LicenceKey" & c8LicenceIDRecordKey, xValue:=c8LicenceEncryptor.Encrypt(strText:=licenceId))
Call BWordDocumentVariableSet(xDoc:=targetDoc, xName:="c8LicenceKey" & c8LicenceOwnerRecordKey, xValue:=c8LicenceEncryptor.Encrypt(strText:=licenceOwner))
Call BWordDocumentVariableSet(xDoc:=targetDoc, xName:="c8LicenceKey" & c8LicenceExpiryDateRecordKey, xValue:=c8LicenceEncryptor.Encrypt(strText:=licenceExpiryDate))
Call BWordDocumentVariableSet(xDoc:=targetDoc, xName:="c8LicenceKey" & c8LicenceExtensionPasswordKeyRecordKey, xValue:=c8LicenceEncryptor.Encrypt(strText:=licenceExtensionPasswordKey))
If Len(licenceSingleCaseReference) = 0 Then
Call BWordDocumentVariableDelete(xDoc:=targetDoc, xName:="c8LicenceKey" & c8LicenceSingleCaseReferenceRecordKey)
Else
Call BWordDocumentVariableSet(xDoc:=targetDoc, xName:="c8LicenceKey" & c8LicenceSingleCaseReferenceRecordKey, xValue:=c8LicenceEncryptor.Encrypt(strText:=licenceSingleCaseReference))
End If
End Sub
Public Sub licenceWriteEvaluationWatermarks(Optional inDoc As Variant)
Dim xDoc As Document
Dim s As Section
Dim pos As String
pos = thisDocNavigator.positionSave
If IsMissing(inDoc) Then
Set xDoc = ActiveDocument
Else
Set xDoc = inDoc
End If
For Each s In xDoc.Sections
Call licenceWriteEvaluationWatermarkInSection(s)
Next s
thisDocNavigator.positionRestore pos
xDoc.UndoClear
End Sub
Public Sub licenceWriteEvaluationWatermarkInSection(s As Section)
Dim textBox As Shape
Dim R As Range
Dim sh As Shape
Const watermarkLine1 As String = "This document has been produced using an Unlicensed Version of Chronolator, the "
On Error Resume Next
If s.Headers(wdHeaderFooterPrimary).Shapes.count > 0 Then
For Each sh In s.Headers(wdHeaderFooterPrimary).Shapes
sh.Delete
Next sh
End If
On Error GoTo 0
Set R = s.Headers(wdHeaderFooterPrimary).Range
If Left$(R.text, Len(watermarkLine1)) = watermarkLine1 Then
R.text = ""
End If
On Error GoTo writePlainText
Set textBox = s.Headers(wdHeaderFooterPrimary).Shapes.AddTextbox(Orientation:=msoTextOrientationHorizontal, Left:=s.PageSetup.LeftMargin, Top:=10, Width:=263, Height:=41)
On Error GoTo 0
On Error Resume Next
With textBox
.line.Weight = 2
.line.DashStyle = msoLineSolid
.line.Style = msoLineSingle
.line.foreColor.RGB = RGB(255, 0, 0)
End With
On Error GoTo 0
Set R = textBox.TextFrame.TextRange
With R.Font
.name = "Tahoma"
.Size = 7
.Italic = True
.Color = wdColorRed
End With
R.Collapse direction:=wdCollapseStart
GoTo writeText
writePlainText:
Set R = s.Headers(wdHeaderFooterPrimary).Range
R.text = ""
With R.Font
.name = "Tahoma"
.Size = 7
.Italic = True
.Color = wdColorRed
End With
R.Collapse wdCollapseEnd
writeText:
R.InsertAfter text:=watermarkLine1
R.InsertAfter text:="Chronology Tool. Licensed Versions will not produce this mark."
R.Collapse direction:=wdCollapseEnd
R.InsertParagraph
R.Collapse direction:=wdCollapseEnd
R.InsertAfter text:=c8Copyright
On Error Resume Next
Set R = textBox.TextFrame.TextRange
R.Paragraphs.Alignment = wdAlignParagraphCenter
R.Revisions.AcceptAll
End Sub
Public Sub licenceCheckExpiry()
Dim daysToExpiry As Long
c8LicenceHasExpired = False
daysToExpiry = Int(DateValue(c8LicenceExpiryDate) - Date + 0.5)
frmLicenceShort.ExpiryWarning1.Visible = True
frmLicenceShort.ExpiryWarning2.Visible = True
frmLicenceShort.ExtendLicenceButton.Visible = True
frmLicenceShort.ExpiryWarning2.Caption = c8LicenceExtendCaption
Select Case daysToExpiry
Case Is > c8LicenceExpiryWarningPeriod
frmLicenceShort.ExpiryWarning1.Visible = False
frmLicenceShort.ExpiryWarning2.Visible = False
frmLicenceShort.ExtendLicenceButton.Visible = False
Exit Sub
Case Is < 0
c8LicenceHasExpired = True
frmLicenceShort.ExpiryWarning1.Caption = "Licence expired"
Case Is <= c8LicenceExpiryWarningPeriod
frmLicenceShort.ExpiryWarning1.Caption = "WARNING! Licence expires in " & BPluralityText(daysToExpiry, "day")
End Select
If thisDocDescriptor.docType = c8WorkbenchDocument Then
frmLicenceShort.ExpiryWarning2.Visible = False
frmLicenceShort.ExtendLicenceButton.Visible = False
End If
End Sub
Public Sub licenceExtend()
Dim pw As String
Dim pwParse As Variant
Dim newExpiryDate As String
Call frmInputBox.setParms(title:="Enter Extension Password", promptOK:="If you do not have an Extension Password, contact your administrator.", showCancel:=True, forceInput:=True)
frmInputBox.show
pw = frmInputBox.userInput
If Len(pw) = 0 Then Exit Sub
pwParse = extensionPasswordParse(pw)
If pwParse(0) Then
If pwParse(2) = c8LicenceExtensionPasswordKey Then
newExpiryDate = format$(BMin(DateAdd("m", 3, Date), DateAdd("m", 1, pwParse(1))), c8DateFormatISO)
If newExpiryDate > c8LicenceExpiryDate Then
c8LicenceExpiryDate = newExpiryDate
Call BWordDocumentVariableSet(xDoc:=ThisDocument, xName:="c8LicenceKey" & c8LicenceExpiryDateRecordKey, xValue:=c8LicenceEncryptor.Encrypt(strText:=c8LicenceExpiryDate))
On Error GoTo bug92check
ThisDocument.Save
On Error GoTo 0
Exit Sub
End If
End If
End If
showMessage c8Msg4040
Exit Sub
bug92check:
If Err.Number = 5487 Then
Call bug92Fix(ThisDocument)
Else
showMessage c8Msg6000, msgSuffix2:="licenceExtend: Error " & Err.Number & " (" & Err.Description & ")"
End If
End Sub
Public Function licenceIsOK(Optional showMsg As Boolean = True) As Boolean
Dim tempDateString As String
licenceIsOK = True
If c8LicenceHasExpired Then
tempDateString = BWordDocumentVariableGet(xDoc:=ThisDocument, xName:="c8LicenceTempExtendDate", xDefault:="")
If Len(tempDateString) = 0 Then
licenceIsOK = False
Else
licenceIsOK = (DateValue(c8LicenceEncryptor.Decrypt(strText:=tempDateString)) >= Date)
End If
End If
If Not licenceIsOK And showMsg Then Call showMessage(c8Msg4020, button3:="OK")
End Function
Public Function licenceHasBeenAccepted() As Boolean
If c8LicenceHasBeenAccepted Then BWordSessionParameterSet xOption:=c8RegistryKeyLicenceHasBeenAccepted
If BWordSessionParameterIsSet(c8RegistryKeyLicenceHasBeenAccepted) Then c8LicenceHasBeenAccepted = True
licenceHasBeenAccepted = c8LicenceHasBeenAccepted
End Function
Public Sub licenceCopy(sourceDoc As Document, targetDoc As Document)
Dim cProp As Variable
For Each cProp In sourceDoc.Variables
If Left$(cProp.name, 9) = "c8Licence" Then
BWordDocumentVariableSet xDoc:=targetDoc, xName:=cProp.name, xValue:=cProp.value
End If
Next cProp
End Sub
Public Function simpleNumericDecode(xKey As String) As String
Dim out As String
Dim i  As Long
Dim zShift  As Long
Dim zKey As String
out = ""
For i = 1 To Len(xKey)
zKey = AscW(Mid$(xKey, i, 1))
If zKey Mod 2 = 0 Then
zShift = 59
Else
zShift = 49
End If
out = out + ChrW$(zKey - zShift)
Next i
simpleNumericDecode = out
End Function
Function extensionPasswordKey(xPassword As String) As String
extensionPasswordKey = simpleNumericDecode(Right$(xPassword, Len(xPassword) - 8))
End Function
Function extensionPasswordExpiryDate(xPassword As String) As Variant
Dim zString As String
zString = simpleNumericDecode(Left$(xPassword, 8))
extensionPasswordExpiryDate = BStringInsert(BStringInsert(zString, 5, "-"), 8, "-")
End Function
Function extensionPasswordParse(xPassword As String) As Variant
Dim out(2) As Variant
Dim zPasswordKey As String
Dim zValidator As String
Dim zArray As Variant
Dim validator As Long
Dim i  As Long
On Error GoTo finish
validator = 0
out(0) = False
zArray = Split(xPassword, ":")
If UBound(zArray) = 1 Then
zPasswordKey = CStr(zArray(0))
zValidator = CStr(zArray(1))
Else
GoTo finish
End If
For i = 1 To Len(zArray(0))
validator = validator + AscW(Mid$(zPasswordKey, i, 1))
Next i
If validator <> simpleNumericDecode(zValidator) Then GoTo finish
out(2) = extensionPasswordKey(zPasswordKey)
out(1) = extensionPasswordExpiryDate(zPasswordKey)
If IsDate(out(1)) Then out(0) = True
finish:
extensionPasswordParse = out
End Function
Attribute VB_Name = "c8_Messages"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public Type BMessage
id As String
shortMsg As String
longMsg As String
End Type
Public Const msg120nLongMsgPart1 As String = "Events should now be in Date and Time sequence."
Public Const msg120nLongMsgPart2 As String = "Some date and time formats can prevent a successful Sort. If that happens, use the Format Dates button to put dates in the all-digital format " & "and then sort the table again. You can put the dates back to your preferred format afterwards if you wish."
Public Const msg1200LongMsgPart3 As String = "If you know the order of events on a day but not exactly when they occurred, you can use a Sequence column " & "to put them in order. You can make one using the Tools > Sequencing > Add Column button."
Public Const msg1201LongMsgPart3 As String = "If you know the order of events on a day but not exactly when they occurred, you can use the first column " & "to put them in order."
Public c8Msg1000 As BMessage
Public c8Msg1003 As BMessage
Public c8Msg1005 As BMessage
Public c8Msg1010 As BMessage
Public c8Msg1015 As BMessage
Public c8Msg1020 As BMessage
Public c8Msg1025 As BMessage
Public c8Msg1026 As BMessage
Public c8Msg1030 As BMessage
Public c8Msg1031 As BMessage
Public c8Msg1033 As BMessage
Public c8Msg1050 As BMessage
Public c8Msg1100 As BMessage
Public c8Msg1105 As BMessage
Public c8Msg1110 As BMessage
Public c8Msg1120 As BMessage
Public c8Msg1200 As BMessage
Public c8Msg1201 As BMessage
Public c8Msg1300 As BMessage
Public c8Msg2000 As BMessage
Public c8Msg2001 As BMessage
Public c8Msg2002 As BMessage
Public c8Msg2010 As BMessage
Public c8Msg2015 As BMessage
Public c8Msg2016 As BMessage
Public c8Msg2020 As BMessage
Public c8Msg3000 As BMessage
Public c8Msg3001 As BMessage
Public c8Msg3005 As BMessage
Public c8Msg3010 As BMessage
Public c8Msg3011 As BMessage
Public c8Msg3012 As BMessage
Public c8Msg3013 As BMessage
Public c8Msg3015 As BMessage
Public c8Msg3020 As BMessage
Public c8Msg3025 As BMessage
Public c8Msg3030 As BMessage
Public c8Msg3031 As BMessage
Public c8Msg3035 As BMessage
Public c8Msg3100 As BMessage
Public c8Msg3103 As BMessage
Public c8Msg3105 As BMessage
Public c8Msg3107 As BMessage
Public c8Msg3110 As BMessage
Public c8Msg3113 As BMessage
Public c8Msg3120 As BMessage
Public c8Msg3200 As BMessage
Public c8Msg4000 As BMessage
Public c8Msg4005 As BMessage
Public c8Msg4020 As BMessage
Public c8Msg4030 As BMessage
Public c8Msg4040 As BMessage
Public c8Msg5000 As BMessage
Public c8Msg5100 As BMessage
Public c8Msg5105 As BMessage
Public c8msg5110 As BMessage
Public c8Msg5115 As BMessage
Public c8Msg5120 As BMessage
Public c8msg5130 As BMessage
Public c8msg5140 As BMessage
Public c8msg5141 As BMessage
Public c8msg5143 As BMessage
Public c8msg5144 As BMessage
Public c8Msg5200 As BMessage
Public c8Msg5210 As BMessage
Public c8Msg5220 As BMessage
Public c8Msg5221 As BMessage
Public c8Msg5230 As BMessage
Public c8Msg5231 As BMessage
Public c8Msg5232 As BMessage
Public c8Msg5233 As BMessage
Public c8Msg5300 As BMessage
Public c8Msg5310 As BMessage
Public c8Msg5320 As BMessage
Public c8Msg5321 As BMessage
Public c8Msg5322 As BMessage
Public c8Msg5323 As BMessage
Public c8Msg5400 As BMessage
Public c8Msg5402 As BMessage
Public c8Msg5403 As BMessage
Public c8Msg5500 As BMessage
Public c8Msg6000 As BMessage
Public Const c8Msg6000MsgSufCloseAllDocs As String = "Closing all documents and restarting Word " & "should get round this problem." & vbNewLine & "If other Word documents are open, " & "they will not have been affected. Make sure to save them if necessary before you restart Word."
Public c8Msg7000 As BMessage
Public c8Msg7010 As BMessage
Public c8Msg7010Shown As String
Public Const c8Msg7010Anonymise As String = "Anonymise"
Public Const c8Msg7010Highlight As String = "Highlight"
Public c8Msg7030 As BMessage
Public c8Msg7031 As BMessage
Public c8Msg7032 As BMessage
Public c8Msg7033 As BMessage
Public c8Msg8000 As BMessage
Public c8Msg8010 As BMessage
Public c8Msg8020 As BMessage
Public Const c8Note100 As String = "100This row contained the wrong number of columns. Chronolator has rectified this, but you " & "should check that the each entry is under the right heading."
Public Const c8Note120 As String = "120This column is blank, but must always be completed. Add some text."
Public Const c8Note125 As String = "125'As Above', 'See Above', or ditto marks are not allowed."
Public Const c8Note130 As String = "130Cell is vertically merged. Copy any text to another row or rows and delete all rows containing this cell."
Public Const c8Note135 As String = "135Cell contains a nested table. Convert the nested table to text."
Public Const c8Note140 As String = "140The '>' character is not allowed in this column."
Public Const c8Note145 As String = "145Invalid Source."
Public Const c8Note210 As String = "210Invalid date, or invalid date format. Try another format (eg '01 feb 2006' or '01.02.06')."
Public Const c8Note220 As String = "220Invalid time, or invalid time format. Try another format (eg '1.20 am', '0120', or '01.20')."
Public Const c8Note230 As String = "230Event ends before it starts."
Public Const c8Note240 As String = "240Start of event is out of sequence."
Public Const c8Note250 As String = "250End of event is out of sequence."
Public Const c8Note300 As String = "300At least one abbreviation is not defined. Change the abbreviation, or use the " & "Tools > Glossary > Edit button to define a new one. Put multiple abbreviations on separate lines, or separate them with commas."
Sub InitialiseMessages()
c8Msg1000.id = "1000"
c8Msg1000.shortMsg = "Tables imported"
c8Msg1000.longMsg = "All Chronolator tables have been imported. " & "You can merge them into a single table by using the " & "'Merge Tables' button on the Chronolator toolbar."
c8Msg1003.id = "1003"
c8Msg1003.shortMsg = "Invalid document"
c8Msg1003.longMsg = "The file you chose is not a Chronolator document and cannot be imported into a new " & "Composite Chronology." & vbNewLine & vbNewLine & "Please refer to the description of this message in the documentation for suggestions about what to " & "next."
c8Msg1005.id = "1005"
c8Msg1005.shortMsg = "Case References are different"
c8Msg1005.longMsg = "Press OK to continue with import, " & "or Cancel"
c8Msg1010.id = "1010"
c8Msg1010.shortMsg = "'Must-fill' columns are different in source and target documents"
c8Msg1010.longMsg = "Press OK to continue with import, " & "or Cancel"
c8Msg1015.id = "1015"
c8Msg1015.shortMsg = "No Data Tables found in document"
c8Msg1015.longMsg = "There are no tables in the document which match the required column headings"
c8Msg1020.id = "1020"
c8Msg1020.shortMsg = "Document level mismatch"
c8Msg1020.longMsg = "The document you are trying to import cannot be imported into this document as it was created " & "with a higher level of Chronolator." & vbNewLine & vbNewLine & "Create and use a new Composite Chronology using the higher level document for this review. " & "Refer to the manuals if you require step-by-step instructions."
c8Msg1025.id = "1025"
c8Msg1025.shortMsg = "Conflicting and Multiple Definitions"
c8Msg1025.longMsg = "The document you are trying to import includes some abbreviations and definitions which could be " & "confused with those in this one. Although Chronolator will keep track of what was defined where, reading " & "the document might be confusing. " & vbNewLine & vbNewLine & "If you want to use the anonymisation / personalisation feature in the Composite Chronology, you must " & "first resolve these conflicts by changing the abbreviations in one of the documents." & vbNewLine & vbNewLine & "Press Go To List to review the conflicts, OK to continue with the import, or Cancel."
c8Msg1026.id = "1026"
c8Msg1026.shortMsg = "Conflicting Definitions - Import Cancelled"
c8Msg1026.longMsg = "You have chosen to save the conflicting definitions in a new document. Chronolator " & "assumes this is because you want some time to review them, and will therefore cancel the Import."
c8Msg1030.id = "1030"
c8Msg1030.shortMsg = "User-defined sequence column found"
c8Msg1030.longMsg = "The document you are trying to import includes a user-defined Sequence column. It was probably added because the  " & "person completing the document wanted to be exact about the order of certain events whose exact times were unknown. " & "Chronolator can either add a Sequence column to the table(s) in this document, or ignore the one in the document being " & "imported. " & vbNewLine & vbNewLine & "Press Add to add a Sequence column to the table(s) in this document, Delete to " & "delete the one in the document being imported, or Cancel."
c8Msg1031.id = "1031"
c8Msg1031.shortMsg = "Sequence column not found"
c8Msg1031.longMsg = "The document you are trying to import does not include a Sequence column, but is suitable for import " & "in all other respects. " & "Chronolator can either delete the Sequence column from the table(s) in this document, or add one to the document being " & "imported. " & vbNewLine & vbNewLine & "Press Add to add a Sequence column to the table(s) in the document being imported, Delete to " & "delete the one in this document, or Cancel."
c8Msg1033.id = "1033"
c8Msg1033.longMsg = "Chronolator cannot import anything into this document because of the " & "following internal inconsistencies in its structure:"
c8Msg1033.shortMsg = "Unable to import"
c8Msg1050.id = "1050"
c8Msg1050.longMsg = "Chronolator will not use exactly what you entered." & vbNewLine & vbNewLine & "You can either import the document using the existing prefix, or you can choose a  " & "completely different one." & vbNewLine & vbNewLine & "Press OK to use the existing prefix." & vbNewLine & vbNewLine & "To choose a different one, press Cancel and then Import Tables again."
c8Msg1050.shortMsg = " is similar to the existing prefix "
c8Msg1100.id = "1100"
c8Msg1100.shortMsg = "Tables merged"
c8Msg1100.longMsg = "All Chronolator tables have been merged into a single table. " & "You can sort the new table into the correct sequence by using the " & "'" & c8SortTables & "' button on the Chronolator toolbar."
c8Msg1105.id = "1105"
c8Msg1105.shortMsg = "Cannot merge tables"
c8Msg1105.longMsg = "At least one of the tables in this document has a row with the wrong number " & "of columns. Please correct this and try again." & vbNewLine & vbNewLine & "Hint: Use Check Tables to find the problem."
c8Msg1110.id = "1110"
c8Msg1110.shortMsg = "Cannot merge tables"
c8Msg1110.longMsg = "A non-Chronolator table has been found in between the Chronolator tables. " & "The offending table is selected. Please move or delete it and try again."
c8Msg1120.id = "1120"
c8Msg1120.shortMsg = "Multiple chronology tables found"
c8Msg1120.longMsg = "This document contains more than one chronology table." & vbNewLine & vbNewLine & "Press 'Merge' if you want Chronolator to merge the tables and sort them before processing." & vbNewLine & vbNewLine & "Press 'Don't Merge' to process each table individually." & vbNewLine & vbNewLine & "Press 'Cancel' to return to the document without doing anything."
c8Msg1200.id = "1200"
c8Msg1200.shortMsg = "Table sorted"
c8Msg1200.longMsg = msg120nLongMsgPart1 & vbNewLine & vbNewLine & msg120nLongMsgPart2 & vbNewLine & vbNewLine & msg1200LongMsgPart3
c8Msg1201.id = "1201"
c8Msg1201.shortMsg = "Table sorted"
c8Msg1201.longMsg = msg120nLongMsgPart1 & vbNewLine & vbNewLine & msg120nLongMsgPart2 & vbNewLine & vbNewLine & msg1201LongMsgPart3
c8Msg1300.id = "1300"
c8Msg1300.shortMsg = "Dates formatted"
c8Msg1300.longMsg = "All dates have been formatted to one of Chronolator's standard formats. " & vbNewLine & vbNewLine & "If you would like future releases of Chronolator to offer alternative date formats " & "please use the suggestion form on our web site www.chronolator.co.uk."
c8Msg2000.id = "2000"
c8Msg2000.shortMsg = "Cannot find Master Chronology Document"
c8Msg2000.longMsg = "Find the file < " & c8MasterChronologyDoc & " > from your original " & c8Name & " installation and copy it into folder " & c8ApplicationPath & "."
c8Msg2001.id = "2001"
c8Msg2001.shortMsg = "Cannot copy Master Chronology Document"
c8Msg2001.longMsg = "The Master Chronology Document (" & c8MasterChronologyDoc & ") is open and cannot be copied." & " Please close it and try again."
c8Msg2002.id = "2002"
c8Msg2002.shortMsg = "Master Chronology Document is wrong version"
c8Msg2002.longMsg = "The Master Chronology Document (" & c8MasterChronologyDoc & ") is the wrong version for this" & " Online Workbench. Please copy the correct Master Chronology into folder " & c8ApplicationPath & "."
c8Msg2010.id = "2010"
c8Msg2010.shortMsg = "Invalid document"
c8Msg2010.longMsg = "The file you chose is not a Chronolator document and cannot be used as a model." & " Please choose another file, or use the Chronolator defaults."
c8Msg2015.id = "2015"
c8Msg2015.shortMsg = "Invalid document"
c8Msg2015.longMsg = "The Chronolator document you chose has internal inconsistencies and cannot be used as a model." & " Please choose another file, or use the Chronolator defaults."
c8Msg2016.id = "2016"
c8Msg2016.shortMsg = "Invalid document"
c8Msg2016.longMsg = "The Chronolator document you chose is a blank Composite Chronology and cannot be used as a model." & " Please choose another file, or use the Chronolator defaults."
c8Msg2020.id = "2020"
c8Msg2020.shortMsg = "Cannot write document details in preamble"
c8Msg2020.longMsg = "The area in the Master Chronology preamble where Chronolator writes information about " & "the headings in this Chronolator document cannot be found." & vbNewLine & vbNewLine & "This affects only the document preamble: the table and all Chronolator features will work correctly, " & "and it is safe to distribute the document."
c8Msg3000.id = "3000"
c8Msg3000.shortMsg = "Errors found in document"
c8Msg3000.longMsg = "Rest the mouse over the box with a cross to see a brief description of each error." & vbNewLine & vbNewLine & "Use the buttons on the Chronolator toolbar to go from one error to the next, or press the Go To List " & "button to view a complete list." & vbNewLine & vbNewLine & "When you have corrected the errors, press the Check Tables button again to remove the highlighting."
c8Msg3001.id = "3001"
c8Msg3001.shortMsg = "Some rows had the wrong number of columns - fix these first"
c8Msg3001.longMsg = "Chronolator has corrected the number of columns in at least one row. " & "However, it could not be sure which entry should go in which column. " & "You should review these rows now and make sure their entries are in the right places." & vbNewLine & vbNewLine & "It is important to do this now, because now that they have the right number of columns they " & "will not be caught in future checks unless they have other errors." & vbNewLine & vbNewLine & "For ease of identification, the corrected rows are displayed with white text on a purple background."
c8Msg3005.id = "3005"
c8Msg3005.shortMsg = "Document contains errors - do you want to close it?"
c8Msg3005.longMsg = "Please ensure that all errors are corrected before returning or publishing this document." & vbNewLine & vbNewLine & "Press Cancel to resume editing the document and correct them now." & vbNewLine & vbNewLine & "Press OK to close the document and correct them later."
c8Msg3010.id = "3010"
c8Msg3010.shortMsg = "Checked - no errors found"
c8Msg3010.longMsg = "Chronolator has checked all the tables in this document and found no errors."
c8Msg3011.id = "3011"
c8Msg3011.shortMsg = "No changes found since previously checked"
c8Msg3011.longMsg = "No data table appears to have changed since Chronolator last checked this document." & vbNewLine & vbNewLine & "Press Cancel to resume editing." & vbNewLine & vbNewLine & "Press Check to re-check the document."
c8Msg3012.id = "3012"
c8Msg3012.shortMsg = "Document contains no events"
c8Msg3012.longMsg = "None of the Chronolator tables in this document has any events."
c8Msg3013.id = "3013"
c8Msg3013.shortMsg = "Document contains text after chronology tables"
c8Msg3013.longMsg = "The area after the chronology tables is reserved for Chronolator and will be overwritten if you continue." & vbNewLine & vbNewLine & "Press Cancel to return to the document and review the text Chronolator found. " & "If you want to keep it, move it before the chronology tables " & "before you check the tables again." & vbNewLine & vbNewLine & "Press OK to delete the text and continue."
c8Msg3015.id = "3015"
c8Msg3015.shortMsg = "Error checking cancelled"
c8Msg3015.longMsg = "Please ensure that you check for errors before returning or publishing this document." & vbNewLine & vbNewLine & "Also please note that if you have corrected some previous errors they might " & "still be highlighted until the next time you check the document completely."
c8Msg3020.id = "3020"
c8Msg3020.shortMsg = "Processing cancelled"
c8Msg3020.longMsg = "No changes have been made."
c8Msg3025.id = "3025"
c8Msg3025.shortMsg = " found"
c8Msg3025.longMsg = "You can use the buttons on the Chronolator toolbar to go from one duplicate to the next. "
c8Msg3030.id = "3030"
c8Msg3030.shortMsg = " deleted"
c8Msg3030.longMsg = ""
c8Msg3031.id = "3031"
c8Msg3031.shortMsg = " deleted"
c8Msg3031.longMsg = "Chronolator has saved the deleted rows. Press the 'Go to List' button to view them." & vbNewLine & vbNewLine & "Tip: to re-import them, save the list in a convenient location and use the " & "c8ImportSpecial_1 macro. Refer to this message in the manuals for more information."
c8Msg3035.id = "3035"
c8Msg3035.shortMsg = "No duplicate rows"
c8Msg3035.longMsg = "Chronolator has checked all the tables in this document and found no duplicated rows."
c8Msg3100.id = "3100"
c8Msg3100.shortMsg = "Chronolator table contains vertically merged cells"
c8Msg3100.longMsg = "A Chronolator table in this document contains some vertically merged cells. The table will be ignored." & vbNewLine & vbNewLine & "Use the Check Tables button to find the problem cells."
c8Msg3103.id = "3103"
c8Msg3103.shortMsg = "Chronolator table contains vertically merged cells"
c8Msg3103.longMsg = " cannot be imported because a table in it contains some vertically merged cells." & vbNewLine & vbNewLine & "Open the document and use its Check Tables button to find the problem cells."
c8Msg3105.id = "3105"
c8Msg3105.shortMsg = "Chronolator table contains invalid rows"
c8Msg3105.longMsg = " cannot be imported because a table in it contains some rows with the wrong number of columns." & vbNewLine & vbNewLine & "Open the document and use its Check Tables button to find the problem rows."
c8Msg3107.id = "3107"
c8Msg3107.shortMsg = " processing cancelled - invalid table"
c8Msg3107.longMsg = "Word failed to process a Chronolator table. No changes have been made to this document." & vbNewLine & vbNewLine & "Retrying the process might succeed. If not, use the Check Tables button to find " & "(and possibly automatically correct) the problem."
c8Msg3110.id = "3110"
c8Msg3110.shortMsg = "Chronolator table contains nested table"
c8Msg3110.longMsg = "A Chronolator table in this document contains at least one nested table. The table will be ignored." & vbNewLine & vbNewLine & "Use the Check Tables button to find the nested table(s)."
c8Msg3113.id = "3113"
c8Msg3113.shortMsg = "Chronolator table contains nested table"
c8Msg3113.longMsg = " cannot be imported because a table in it contains at least one nested table." & vbNewLine & vbNewLine & "Open the document and use its Check Tables button to find the nested table(s)."
c8Msg3120.id = "3120"
c8Msg3120.shortMsg = "Chronolator table contains unexpected number of rows"
c8Msg3120.longMsg = "When Word prepared the table for processing, it did not find the expected number of rows." & vbNewLine & vbNewLine & "No data will have been lost, but some might be misplaced (either on its own new row, or appended to the previous row)."
c8Msg3200.id = "3200"
c8Msg3200.shortMsg = "Bulleted or Numbered list has been reformatted"
c8Msg3200.longMsg = "A Chronolator table in this document contained some bulleted or numbered lists. These can cause problems when " & "documents are merged. The bullets or numbers have been removed." & vbNewLine & vbNewLine & "Rather than using Word's list features, you could use 'o' characters or dashes for bullets, or use ordinary numbers."
c8Msg4000.id = "4000"
c8Msg4000.shortMsg = "Multiple licences found"
c8Msg4000.longMsg = "Chronolator found more than one licence file. Please delete old ones." & vbNewLine & vbNewLine & "Look in the same folder as the Online Workbench for files whose names begin '" & c8LicenceFileNamePrefix & "'."
c8Msg4005.id = "4005"
c8Msg4005.shortMsg = "Invalid licence"
c8Msg4005.longMsg = "Chronolator found a licence file, but it is not valid. Please re-install or delete it." & vbNewLine & vbNewLine & "Look in the same folder as the Online Workbench for a file whose name begins '" & c8LicenceFileNamePrefix & "'. Replace that file with the licence supplied to you, or simply delete it if you only want to evaluate " & c8Name & "."
c8Msg4020.id = "4020"
c8Msg4020.shortMsg = "Licence Expired"
c8Msg4020.longMsg = "Your licence has expired and this function is not available."
c8Msg4030.id = "4030"
c8Msg4030.shortMsg = "Licence Expired"
c8Msg4030.longMsg = "Your licence has expired. All standard Microsoft Word features remain available, " & "but Chronolator features are disabled." & vbNewLine & vbNewLine & "Please visit " & c8ProductURL & " for details of how to obtain a new licence."
c8Msg4040.id = "4040"
c8Msg4040.shortMsg = "Invalid Extension Password"
c8Msg4040.longMsg = "The password you entered is not valid." & vbNewLine & vbNewLine & "Please contact your administrator."
c8Msg5000.id = "5000"
c8Msg5000.longMsg = "Are you sure you want to edit the Master Chronology Document" & " rather than open the Online Workbench?" & vbNewLine & vbNewLine & "Press OK if you do, or Cancel to close the Master Chronology."
c8Msg5000.shortMsg = "Open Master Chronology for edit?"
c8Msg5100.id = "5100"
c8Msg5100.longMsg = "Publishing a document makes a plain Word copy without" & " any Chronolator code. Readers of the copy will not have to agree" & " to any licence terms." & " After Chronolator has created the copy, you will be prompted to save it." & vbNewLine & vbNewLine & "Press OK to continue, or Cancel."
c8Msg5100.shortMsg = "Publish document?"
c8Msg5105.id = "5105"
c8Msg5105.longMsg = "Publishing the file using this name would make it lose all its Chronolator functions." & vbNewLine & vbNewLine & "Please try the save again using a different name."
c8Msg5105.shortMsg = "Cannot publish a document to the same name"
c8msg5110.id = "5110"
c8msg5110.longMsg = "Chronolator encountered a Word error when trying to copy some of the styles used in this document. " & "Pagination, text size and other formatting attributes might be different in the published version." & vbNewLine & vbNewLine & "Try Publishing a second time when this attempt has completed: it will probably work as expected."
c8msg5110.shortMsg = "Could not copy styles"
c8Msg5115.id = "5115"
c8Msg5115.shortMsg = "Publishing cancelled"
c8Msg5115.longMsg = "Report production was cancelled at your request."
c8Msg5120.id = "5120"
c8Msg5120.shortMsg = "Publishing cancelled"
c8Msg5120.longMsg = "At least one date/time combination in this document is not valid. " & "Chronolator is therefore unable to calculate elapsed times." & vbNewLine & vbNewLine & "Correct the date/time combination and try Publishing again." & vbNewLine & vbNewLine & "(Suggestion: use the Check Tables button to find any invalid date/time combinations)."
c8msg5130.id = "5130"
c8msg5130.longMsg = "This document contains error highlights and / or a list of errors generated" & " the last time it was checked. Do you want to include them in the published version?" & vbNewLine & vbNewLine & "(If you do not, please note that page numbers might be different in the published version)."
c8msg5130.shortMsg = "Show Chronolator error details in published document?"
c8msg5140.id = "5140"
c8msg5140.longMsg = "Sequence numbers are missing or invalid." & vbNewLine & vbNewLine & "If the chronology document does not have a Sequence column, add one using" & vbNewLine & "Tools > Sequencing > Add column. " & vbNewLine & vbNewLine & "If it does, update it using" & vbNewLine & "Tools > Sequencing > Update - sequential." & vbNewLine & vbNewLine & "Afterwards, try Publish > Analysis again."
c8msg5140.shortMsg = "Cannot create Analysis Document"
c8msg5141.id = "5141"
c8msg5141.shortMsg = c8msg5140.shortMsg
c8msg5141.longMsg = "Chronolator could not determine the date boundaries of table "
c8msg5143.id = "5143"
c8msg5143.shortMsg = c8msg5140.shortMsg
c8msg5143.longMsg = "Chronolator found an invalid date in the event with reference number "
c8msg5144.id = "5144"
c8msg5144.shortMsg = c8msg5140.shortMsg
c8msg5144.longMsg = "Chronolator found an invalid source prefix in the event with reference number "
c8Msg5200.id = "5200"
c8Msg5200.longMsg = "Chronolator requires Microsoft Word 2000 or later." & vbNewLine & vbNewLine & "Press OK to continue without Chronolator, or Cancel to exit Word."
c8Msg5200.shortMsg = "Unsupported Word version"
c8Msg5210.id = "5210"
c8Msg5210.longMsg = "Chronolator works by running macros, so documents must be saved as .doc or .docm types. " & "Chronolator will change the document to the correct type before saving it." & vbNewLine & vbNewLine & "If you want to save the document as another type, use the Chronolator Publish button to make a plain Word copy and then " & "save the Published copy in your desired format."
c8Msg5210.shortMsg = "Document type changed"
c8Msg5220.id = "5220"
c8Msg5220.longMsg = "Chronolator performs best when Word uses an option that improves the performance " & "and reliability of any document stored on a network drive." & vbNewLine & vbNewLine & "Press OK if you would like Word to use it."
c8Msg5220.shortMsg = "Performance recommendation"
c8Msg5221.id = "5221"
c8Msg5221.longMsg = "Chronolator has set the option. Please close and re-open this document to allow it to take effect."
c8Msg5221.shortMsg = "Performance recommendation"
c8Msg5230.id = "5230"
c8Msg5230.longMsg = "> is using Word's Track Changes feature. Tracking changes can cause severe problems when processing tables." & vbNewLine & vbNewLine & "Press OK to accept all tracked changes and turn change tracking off, or Cancel if you want to review them."
c8Msg5230.shortMsg = "Change tracking alert!"
Const tcSuffix1 As String = vbNewLine & vbNewLine & "The Tracked Changes feature can cause severe problems when processing tables."
c8Msg5231.id = "5231"
c8Msg5231.shortMsg = " cancelled - change tracking active"
c8Msg5231.longMsg = "> is using Word's Track Changes feature." & tcSuffix1
c8Msg5232.id = "5232"
c8Msg5232.longMsg = "Chronolator could not determine whether Tracked Changes is on in the document because it appears to be locked by another user. " & vbNewLine & vbNewLine & "To be on the safe side, Chronolator will assume that Tracked Changes is on." & vbNewLine & vbNewLine & tcSuffix1
c8Msg5232.shortMsg = "Unable to determine Tracked Changes status in <"
c8Msg5233.id = "5233"
c8Msg5233.longMsg = "Chronolator could not turn off Tracked Changes. " & vbNewLine & vbNewLine & "This is probably because the document has been protected." & vbNewLine & vbNewLine & tcSuffix1
c8Msg5233.shortMsg = "Unable to turn off Tracked Changes in <"
c8Msg5300.id = "5300"
c8Msg5300.longMsg = "Chronolator cannot find the Tutorials on your computer." & vbNewLine & vbNewLine & "Press OK to go to the Web tutorials (requires an Internet connection)."
c8Msg5300.shortMsg = "Open Web Tutorials?"
c8Msg5310.id = "5310"
c8Msg5310.longMsg = "Chronolator cannot find the Tutorials on the Web." & vbNewLine & vbNewLine & "If you are sure your connection is OK, please report the problem to us using the form on our website: " & "www.chronolator.co.uk/bug_form.htm."
c8Msg5310.shortMsg = "Web connection error"
c8Msg5320.id = "5320"
c8Msg5320.longMsg = "A document with that name is already open in Word." & vbNewLine & vbNewLine & "Please try the save again using a different name."
c8Msg5320.shortMsg = "Cannot save the document using the name you chose"
c8Msg5321.id = "5321"
c8Msg5321.longMsg = "Saving the file using this name might overwrite documents which Chronolator needs to function." & vbNewLine & vbNewLine & "Please try the save again using a different name."
c8Msg5321.shortMsg = "Cannot overwrite Chronolator system file"
c8Msg5322.id = "5322"
c8Msg5322.longMsg = "You do not have Write access to the requested folder." & vbNewLine & vbNewLine & "Please try to save the file in a different folder."
c8Msg5322.shortMsg = "Permission Denied"
c8Msg5323.id = "5323"
c8Msg5323.longMsg = "This file looks like a temporary one, or is in a temporary folder. If you are unaware of this " & "you might not be able to find it after you close it." & vbNewLine & vbNewLine & "After you press OK, you will be asked to save the document using another name and folder." & vbNewLine & vbNewLine & "Please refer to the manuals if you frequently get this message."
c8Msg5323.shortMsg = "File might be temporary"
c8Msg5400.id = "5400"
c8Msg5400.longMsg = "Chronolator has found internal inconsistencies in this document, which are detailed below." & vbNewLine & vbNewLine & "These may stop Chronolator functions working. Standard Word features are unaffected."
c8Msg5400.shortMsg = "Internal inconsistencies in Chronolator document "
c8Msg5402.id = "5402"
c8Msg5402.longMsg = "Chronolator cannot create a new table in this document because of the " & "following internal inconsistencies in its structure:"
c8Msg5402.shortMsg = "Unable to create table"
c8Msg5403.id = "5403"
c8Msg5403.longMsg = "Chronolator could not set some document styles because the file appears to be locked by another user. " & vbNewLine & vbNewLine & "This will only affect the fonts used to display any error messages at the end of the document."
c8Msg5403.shortMsg = "Unable to set styles"
c8Msg5500.id = "5500"
c8Msg5500.longMsg = "Chronolator could not access the clipboard. Another application is probably using it. " & vbNewLine & vbNewLine & "Press OK to try again, or Cancel."
c8Msg5500.shortMsg = "Clipboard Unavailable"
c8Msg6000.id = "6000"
c8Msg6000.longMsg = "Please note the information below and report it to us using the form on our website: " & "www.chronolator.co.uk/bug_form.htm." & vbNewLine & vbNewLine
c8Msg6000.shortMsg = "Unexpected processing error"
c8Msg7000.id = "7000"
c8Msg7000.longMsg = "Anonymisation and Personalisation are not possible because the Abbreviations Glossary contains " & "abbreviations and / or definitions that are too similar to each other." & vbNewLine & vbNewLine & "You can update the glossary and related text using Tools > Glossary > Edit."
c8Msg7000.shortMsg = "Glossary contains similar entries"
c8Msg7010.id = "7010"
c8Msg7010.longMsg = " feature can be lost when Checking or Merging Tables, processing Sequence numbers, and in some other " & "circumstances which are described in the 'Using Chronolator Documents' manual. " & vbNewLine & vbNewLine & "Press OK to continue, or Cancel so that you can save your work and review the manual before trying again." & vbNewLine & vbNewLine & "This message will not be shown again during this session."
c8Msg7010.shortMsg = "Warning!"
c8Msg7030.id = "7030"
c8Msg7030.shortMsg = "Abbreviation Not Used"
c8Msg7030.longMsg = "The selected abbreviation and definition are not used in the text."
c8Msg7031.id = "7031"
c8Msg7031.shortMsg = "Abbreviations Not Used"
c8Msg7031.longMsg = "The selected abbreviations and definitions are not used in the text."
c8Msg7032.id = "7032"
c8Msg7032.shortMsg = "Nothing to anonymise"
c8Msg7032.longMsg = " not used in the text."
c8Msg7033.id = "7033"
c8Msg7033.shortMsg = "Nothing to personalise"
c8Msg7033.longMsg = ""
c8Msg8000.id = "8000"
c8Msg8000.shortMsg = "Add-in loaded successfully"
c8Msg8000.longMsg = "Please refer to the documentation accompanying the add-in for details about what it does and how to use it."
c8Msg8010.id = "8010"
c8Msg8010.shortMsg = "Add-in failed to load"
c8Msg8010.longMsg = ""
c8Msg8020.id = "8020"
c8Msg8020.shortMsg = "Cannot open document - a Chronolator Add-in is loaded"
c8Msg8020.longMsg = "Only one Chronolator document can be open while a Chronolator Add-in is loaded."
End Sub
Public Function showMessage(msg As BMessage, Optional msgPrefix1 As String = "", Optional msgSuffix1 As String = "", Optional msgPrefix2 As String = "", Optional msgSuffix2 As String = "", Optional suppressUntil As String = "", Optional button1 As String = "", Optional button2 As String = "", Optional button3 As String = "OK", Optional defaultButton As Long = 3, Optional shortMsg As String) As String
Dim suppressedUntil As String
If openedByC9 Then
showMessage = "OK"
Exit Function
End If
Call InitialiseMessages
If Len(shortMsg) = 0 Then
Else
msg.shortMsg = shortMsg
End If
frmMessage.MsgRef.Caption = msg.id
frmMessage.ShortMessage.Caption = msgPrefix1 & msg.shortMsg & msgSuffix1
frmMessage.LongMessage.Caption = msgPrefix2 & msg.longMsg & msgSuffix2
If Len(button1) = 0 Then
frmMessage.CommandButton1.Visible = False
Else
frmMessage.CommandButton1.Visible = True
frmMessage.CommandButton1.Caption = button1
End If
If Len(button2) = 0 Then
frmMessage.CommandButton2.Visible = False
Else
frmMessage.CommandButton2.Visible = True
frmMessage.CommandButton2.Caption = button2
End If
If Len(button3) = 0 Then
frmMessage.CommandButton3.Visible = False
Else
frmMessage.CommandButton3.Visible = True
frmMessage.CommandButton3.Caption = button3
End If
Select Case defaultButton
Case 1
frmMessage.CommandButton1.Default = True
frmMessage.CommandButton1.SetFocus
Case 2
frmMessage.CommandButton2.Default = True
frmMessage.CommandButton2.SetFocus
Case 3
frmMessage.CommandButton3.Default = True
frmMessage.CommandButton3.SetFocus
End Select
suppressedUntil = GetSetting(appname:=c8Name, Section:=c8RegistryMessages, key:=msg.id)
If bdt Is Nothing Then
Set bdt = New clsBerrickDateTime
End If
If bdt.NowISO > suppressedUntil Then
If Len(suppressUntil) > 0 Then
SaveSetting appname:=c8Name, Section:=c8RegistryMessages, key:=msg.id, setting:=suppressUntil
End If
frmMessage.show
showMessage = frmMessage.buttonPressed
Else
Unload frmMessage
showMessage = "Suppressed"
End If
End Function
Attribute VB_Name = "c8_Misc"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public pbTablesToCheck As Single
Public pbRowsToCheck As Single
Dim msg5300Accepted As Boolean
Public uppercaseAbbreviationsList As String
Public abbreviationsListStringDelimiter As String
Function BuildHeadersArray(xDetails As clsDocDescriptor) As Variant
Dim heads() As Variant
ReDim heads(20)
Dim i As Long
i = 0
If checkDescriptor(xDetails, xShowMessage:=True, xErrorMessage:=c8Msg5400) Then
For i = 0 To xDetails.columnCount - 1
heads(i) = xDetails.columnHeading(i + 1)
Next i
Else
heads(0) = vbNullChar
End If
ReDim Preserve heads(i)
BuildHeadersArray = heads()
End Function
Function GetTables(doc As Document, heads As Variant, Optional xIncludeVerticallyMerged As Boolean = False, Optional xShowVerticallyMergedMessage As Boolean = True, Optional xIncludeNested As Boolean = False, Optional xShowNestedMessage As Boolean = True) As Variant
Dim out() As Variant
Dim tablesfound As Long
Dim tablesItem As Long
Dim docTableSearchRange As Range
Dim docTable As table
ReDim out(doc.tables.count)
Set docTableSearchRange = doc.Content
tablesfound = 0
For Each docTable In docTableSearchRange.tables
tablesItem = tablesItem + 1
If Not isC8Table(docTable, heads) Then GoTo nextDocTable
If BWordTableHasVerticallyMergedCells(docTable) Then
If xIncludeVerticallyMerged Then
Else
If xShowVerticallyMergedMessage Then
Call showMessage(c8Msg3100)
Else
End If
GoTo nextDocTable
End If
End If
If BWordTableHasNestedTable(docTable) Then
If xIncludeNested Then
Else
If xShowNestedMessage Then
Call showMessage(c8Msg3110)
Else
End If
GoTo nextDocTable
End If
End If
out(tablesfound) = tablesItem
tablesfound = tablesfound + 1
nextDocTable:
Next docTable
If tablesfound > 0 Then ReDim Preserve out(tablesfound - 1)
Select Case tablesfound
Case 0:
GetTables = Empty
Exit Function
Case 1:
Case Else
End Select
GetTables = out
End Function
Function isC8Table(xTable As table, xHeads As Variant) As Boolean
Dim firstRowColumnCount As Long
Dim i As Long
firstRowColumnCount = getFirstRowColumnCount(xTable)
If UBound(xHeads) <> firstRowColumnCount Then GoTo notc8
For i = 1 To firstRowColumnCount
If StrComp(BRemoveAllSpaces((BWordGetCellText(xTable.Cell(1, i)))), BRemoveAllSpaces(BWordStandardisePunctuation(xHeads(i - 1))), vbTextCompare) <> 0 Then
GoTo notc8
End If
Next i
isC8Table = True
Exit Function
notc8:
isC8Table = False
End Function
Sub setProgressBarCounters(doc As Document, tablesfound As Variant)
Dim i As Long
pbRowsToCheck = 0
pbTablesToCheck = UBound(tablesfound) + 1
For i = 0 To UBound(tablesfound)
pbRowsToCheck = pbRowsToCheck + BWordTableRowCount(doc.Content.tables(tablesfound(i)))
Next i
pbRowsToCheck = pbRowsToCheck - pbTablesToCheck
End Sub
Sub displayTutorials()
If displayTutorialsLocal() Then
Exit Sub
Else
Call displayTutorialsWeb
End If
End Sub
Function displayTutorialsLocal() As Boolean
On Error GoTo noLocal
displayTutorialsLocal = True
ThisDocument.FollowHyperlink Address:="file:" & c8ApplicationPath & c8TutorialIndex, NewWindow:=True, AddHistory:=True
Exit Function
noLocal:
displayTutorialsLocal = False
End Function
Sub displayTutorialsWeb()
If msg5300Accepted Then
Else
If showMessage(c8Msg5300, button2:="OK", button3:="Cancel", defaultButton:=2) = "OK" Then
msg5300Accepted = True
Else
Exit Sub
End If
End If
On Error GoTo notFound
ThisDocument.FollowHyperlink Address:="http:\\" & c8ProductURL & "/" & c8TutorialIndex, NewWindow:=True, AddHistory:=True
Exit Sub
notFound:
Call showMessage(c8Msg5310)
End Sub
Sub displayAbout()
frmAbout.show
End Sub
Function checkDescriptor(xDetails As clsDocDescriptor, xShowMessage As Boolean, xErrorMessage As BMessage) As Boolean
Dim zString As String
zString = xDetails.validate
If Len(zString) = 0 Then
checkDescriptor = True
Else
checkDescriptor = False
If xShowMessage Then
Call showMessage(xErrorMessage, msgSuffix2:=vbNewLine & vbNewLine & zString)
End If
End If
End Function
Function getFirstRowColumnCount(xTable As Variant) As Long
Dim i  As Long
Dim zCell As Cell
i = 0
On Error GoTo endRow
For i = 1 To 10000
Set zCell = xTable.Cell(1, i)
Next i
endRow:
getFirstRowColumnCount = i - 1
End Function
Public Function getC8Version(xDoc As Document) As Single
Dim versionString As String
On Error GoTo badVal
versionString = replace(BWordDocumentVariableGet(xDoc, "c8Version", xDefault:=0), ".", Application.International(wdDecimalSeparator))
getC8Version = CSng(versionString)
Exit Function
badVal:
getC8Version = 0
End Function
Public Function validateNewAbbreviation(xTerm As String, xDefinition As String) As String
Dim cleanTerm As String
Dim cleanDefinition As String
Dim out As String
out = ""
cleanTerm = UCase$(BRemoveAllSpaces(xTerm))
cleanDefinition = UCase$(BRemoveAllSpaces(xDefinition))
If Len(BRemoveAllSpaces(xTerm)) = 0 Or Len(BRemoveAllSpaces(xDefinition)) = 0 Then
out = " "
GoTo endFunction
End If
If cleanTerm = cleanDefinition Then
out = c8InvalidAbbreviationText02
GoTo endFunction
End If
If InStr(uppercaseAbbreviationsList, cleanTerm) Or InStr(uppercaseAbbreviationsList, cleanDefinition) Then
out = c8InvalidAbbreviationText01
GoTo endFunction
End If
If InStr(cleanTerm & abbreviationsListStringDelimiter & cleanDefinition, "(WAS") Then
out = c8InvalidAbbreviationText03
GoTo endFunction
End If
endFunction:
validateNewAbbreviation = out
End Function
Public Function GetOptionButton(xForm As UserForm, xOptionGroup As String) As String
Dim ctrl As Control
For Each ctrl In xForm.Controls
If TypeName(ctrl) = "OptionButton" Then
If ctrl.GroupName = xOptionGroup And ctrl.value Then
GetOptionButton = ctrl.Caption
End If
End If
Next ctrl
End Function
Public Sub SetOptionButton(xRadioButton As String, xForm As UserForm, xOptionGroup As String)
Dim ctrl As Control
For Each ctrl In xForm.Controls
If TypeName(ctrl) = "OptionButton" Then
If ctrl.GroupName = xOptionGroup Then
If ctrl.Caption = xRadioButton Then
ctrl.value = True
Exit Sub
End If
End If
End If
Next ctrl
End Sub
Attribute VB_Name = "c8_Public"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public Const Word2000 As Long = 9
Public Const WordXP As Long = 10
Public Const Word2003 As Long = 11
Public Const Word2007 As Long = 12
Public Const Word2010 As Long = 14
Public Const Word2013 As Long = 15
Public Const Word2016 As Long = 16
Public Sub c8EnvironmentCleanup()
On Error Resume Next
DeleteSetting appname:=c8Name, Section:=c8RegistryMessages
Call EnvironmentCleanup(xAtStartup:=True)
End Sub
Public Function wordVersion() As Long
wordVersion = CInt(Left$(format$(CSng(Val(Application.version)), "000.00000"), 3))
End Function
Attribute VB_Name = "c8_Reporting"
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Option Private Module
Public Function tablesAnalysis(xDoc As Document, xTables As Variant) As Variant
Dim i As Long
Dim rowTotal As Long
Dim rowCount As Long
Dim out(0 To 1) As Variant
rowTotal = 0
If IsEmpty(xTables) Then
out(0) = 0
out(1) = 0
Else
For i = 0 To UBound(xTables)
rowCount = xDoc.Content.tables(xTables(i)).rows.count - 1
rowTotal = rowTotal + rowCount
Next i
out(0) = i
out(1) = rowTotal
End If
tablesAnalysis = out
End Function
Function getDocDetailsIntoArray(xDetails As clsDocDescriptor) As Variant
Dim out As Variant
Dim i As Long
Dim zVar As Variant
Call BWriteLineInArray(xArray:=out, xLine:="H0Chronolator Version " & xDetails.version & " - Details Report - " & ThisDocument.name)
Call BWriteLineInArray(xArray:=out, xLine:="xx")
out = getDescriptorDetailsIntoArray(xDetails:=xDetails, xArray:=out, xShowUndefined:=True)
Call BWriteLineInArray(xArray:=out, xLine:="H1Miscellaneous")
Call BWriteLineInArray(xArray:=out, xLine:="xxDocument Full Name : " & ThisDocument.fullName)
If Len(xDetails.sortOrder) <> 0 Then
Call BWriteLineInArray(xArray:=out, xLine:="xxSort Order         : " & xDetails.sortOrder)
End If
zVar = tablesAnalysis(ThisDocument, GetTables(ThisDocument, BuildHeadersArray(xDetails)))
Call BWriteLineInArray(xArray:=out, xLine:="xxTable Count        : " & zVar(0))
Call BWriteLineInArray(xArray:=out, xLine:="xxEvent Count        : " & zVar(1))
Call BWriteLineInArray(xArray:=out, xLine:="H1Statistics")
Call BWriteLineInArray(xArray:=out, xLine:="xxRefer to the product documentation for an explanation of these statistics.")
Call BWriteLineInArray(xArray:=out, xLine:="H2Process          Run Tables   Rows Field1 Field2  Elapsed   MemPT   MemPF   MemVT")
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Check Tables    ", ppStats_Get(ppStats_CheckTables)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Duplicates      ", ppStats_Get(ppStats_CheckDuplicates)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Format Dates    ", ppStats_Get(ppStats_FormatDates)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Add Sequence    ", ppStats_Get(ppStats_SequenceAdd)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Update Sequence ", ppStats_Get(ppStats_SequenceUpdate)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Clear Sequence  ", ppStats_Get(ppStats_SequenceClear)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Delete Sequence ", ppStats_Get(ppStats_SequenceDelete)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Change Seq Head ", ppStats_Get(ppStats_SequenceChangeHeading)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Merge           ", ppStats_Get(ppStats_Merge)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Publish Custom  ", ppStats_Get(ppStats_PublishCustom)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Publish Analysis", ppStats_Get(ppStats_PublishAnalysis)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Publish JSON    ", ppStats_Get(ppStats_PublishJSON)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Normalise Src   ", ppStats_Get(ppStats_NormaliseSource)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Abbrev. Review  ", ppStats_Get(ppStats_AbbreviationReview)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Abbrev. Report  ", ppStats_Get(ppStats_AbbreviationReport)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Anonymise       ", ppStats_Get(ppStats_Anonymise)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Personalise     ", ppStats_Get(ppStats_Personalise)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & formatStats("Highlight Src   ", ppStats_Get(ppStats_HighlightSource)))
Call BWriteLineInArray(xArray:=out, xLine:="H2Software Versions used")
Call BWriteLineInArray(xArray:=out, xLine:="xxWindows: " & replace(ppStats_Get(ppStats_WindowsVersions), ppStats_Delimiter, " "))
Call BWriteLineInArray(xArray:=out, xLine:="xxWord:    " & replace(ppStats_Get(ppStats_WordVersions), ppStats_Delimiter, " "))
Call BWriteLineInArray(xArray:=out, xLine:="H2System Processors used")
Call BWriteLineInArray(xArray:=out, xLine:="xx" & replace(ppStats_Get(ppStats_CPUs), ppStats_Delimiter, vbNewLine))
For i = 0 To UBound(out) - 1
out(i) = replace(out(i), vbNullChar, " ")
Next
getDocDetailsIntoArray = out
End Function
Function getDescriptorDetailsIntoArray(xDetails As clsDocDescriptor, Optional xArray As Variant, Optional xShowUndefined As Boolean = False) As Variant
Dim reportLines As Variant
Dim i As Long
Dim j As Long
Dim colCount As Long
Dim mandatoryColumns As Long
Dim zString As String
Dim xEntry As String
Dim namecount As Long
Dim glossary As clsGlossary
Set glossary = New clsGlossary
If Not IsEmpty(xArray) Then reportLines = xArray
On Error GoTo badDescriptor
colCount = xDetails.columnCount
mandatoryColumns = xDetails.mandatoryColumns
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxCase Reference:" & vbTab & xDetails.caseRef)
Call BWriteLineInArray(xArray:=reportLines, xLine:="H1Column Headings")
For i = 1 To colCount
zString = format$(i, "00") & ": " & BStringNormaliseLength(xDetails.columnHeading(xColNo:=i), 47)
Select Case i
Case xDetails.columnSequence
zString = BStringInsert(xTargetString:=zString, xPos:=53, xInputString:="(Event Ref)")
Case xDetails.columnStartDate
zString = BStringInsert(xTargetString:=zString, xPos:=53, xInputString:="(Start Date)")
Case xDetails.columnStartTime
zString = BStringInsert(xTargetString:=zString, xPos:=53, xInputString:="(Start Time)")
Case xDetails.columnEndDate
zString = BStringInsert(xTargetString:=zString, xPos:=53, xInputString:="(End Date)")
Case xDetails.columnEndTime
zString = BStringInsert(xTargetString:=zString, xPos:=53, xInputString:="(End Time)")
Case xDetails.columnSource
zString = BStringInsert(xTargetString:=zString, xPos:=53, xInputString:="(Source)")
Case xDetails.columnGlossary
zString = BStringInsert(xTargetString:=zString, xPos:=53, xInputString:="(Glossary)")
End Select
If BBitIsSet(i, mandatoryColumns) Then
zString = BStringInsert(xTargetString:=zString, xPos:=66, xInputString:="(Must Fill)")
End If
Call BWriteLineInArray(xArray:=reportLines, xLine:="xx" & zString)
Next i
If Len(xDetails.glossaryAdmin & xDetails.glossaryUser) = 0 Then
If xShowUndefined Then
Call BWriteLineInArray(xArray:=reportLines, xLine:="H1Abbreviations")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxNone defined")
End If
GoTo sourcePrefixes
End If
Call BWriteLineInArray(xArray:=reportLines, xLine:="H1Abbreviations")
If xDetails.columnGlossary > 0 Then
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxEntries in column " & xDetails.columnGlossary & " are being checked against the list of abbreviations")
Else
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxThe list of abbreviations is not being used when checking for errors")
End If
reportLines = getAbbreviationsIntoArray(xDetails, reportLines)
sourcePrefixes:
If Len(xDetails.sourcePrefixes) = 0 Then
If xShowUndefined Then
Call BWriteLineInArray(xArray:=reportLines, xLine:="H1Source Prefixes")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxNone defined")
End If
GoTo finished
End If
Call BWriteLineInArray(xArray:=reportLines, xLine:="H1Source Prefixes")
glossary.loadFromString glGlossaryDump:=xDetails.sourcePrefixes, glClear:=True
namecount = glossary.count
For j = 1 To namecount
xEntry = glossary.getEntryByIndex(j)
zString = "xx" & glossary.getKey(xEntry)
Call BWriteLineInArray(xArray:=reportLines, xLine:=zString)
Next j
GoTo finished
badDescriptor:
Call BWriteLineInArray(xArray:=reportLines, xLine:="H1Internal Inconsistencies")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxThis document has the following internal inconsistencies which could inhibit")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxChronolator functions")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xx")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xx" & xDetails.validate)
finished:
getDescriptorDetailsIntoArray = reportLines
End Function
Function getAbbreviationsIntoArray(xDetails As clsDocDescriptor, Optional xArray As Variant, Optional xUseTabs As Boolean = False) As Variant
Dim reportLines As Variant
Dim j As Long
Dim zString As String
Dim glossary As clsGlossary
Dim namecount As Long
Dim xEntry As String
Set glossary = New clsGlossary
If Not IsEmpty(xArray) Then reportLines = xArray
On Error GoTo badDescriptor
If CSng(xDetails.version) < 3 Then
glossary.loadFromString glGlossaryDump:=xDetails.glossaryAdmin
glossary.loadFromString glGlossaryDump:=xDetails.glossaryUser, glAllowDupKeys:=True, glAllowDupItems:=True
Else
glossary.loadFromString glGlossaryDump:=xDetails.glossaryAdmin, glEncryptor:=thisDocGlossaryEncryptor
glossary.loadFromString glGlossaryDump:=xDetails.glossaryUser, glAllowDupKeys:=True, glAllowDupItems:=True, glEncryptor:=thisDocGlossaryEncryptor
End If
namecount = glossary.count
If xUseTabs Then
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxTerm" & vbTab & "Meaning" & vbTab & "Defined by / in")
Else
Call BWriteLineInArray(xArray:=reportLines, xLine:="H2Term       Meaning                        Defined by / in")
End If
For j = 1 To namecount
xEntry = glossary.getEntryByIndex(j)
zString = "xx" & glossary.getKey(xEntry)
If xUseTabs Then
zString = zString & vbTab & glossary.getItem(xEntry) & vbTab & glossary.getPrefix(xEntry)
Else
zString = BStringInsert(xTargetString:=zString, xPos:=14, xInputString:=glossary.getItem(xEntry))
zString = BStringInsert(xTargetString:=zString, xPos:=45, xInputString:=glossary.getPrefix(xEntry))
End If
Call BWriteLineInArray(xArray:=reportLines, xLine:=zString)
Next j
GoTo finished
badDescriptor:
Call BWriteLineInArray(xArray:=reportLines, xLine:="H1Internal Inconsistencies")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxThis document has the following internal inconsistencies which could inhibit")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xxChronolator functions")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xx")
Call BWriteLineInArray(xArray:=reportLines, xLine:="xx" & xDetails.validate)
finished:
getAbbreviationsIntoArray = reportLines
End Function
Function getConflictingDefinitionsIntoArray() As Variant
Dim out As Variant
Dim zTemp As String
Dim i As Long
Dim j As Long
Dim zIndices() As String
Dim zDuplicateSet() As String
Dim zGE As String
Dim term As String
Dim definition As String
Dim definedInSourcePrefix As String
Dim definedInSourceDocument As String
Call BWriteLineInArray(xArray:=out, xLine:="H0Conflicting and confusing glossary entries")
zTemp = "Abbreviation"
zTemp = BStringInsert(zTemp, 14, "Definition")
zTemp = BStringInsert(zTemp, 45, "Location")
zTemp = BStringInsert(zTemp, 59, "Source")
Call BWriteLineInArray(xArray:=out, xLine:="H2" & zTemp)
zIndices = Split(duplicateAbbreviationsIndices, ";")
For i = 0 To UBound(zIndices) - 1
zDuplicateSet = Split(zIndices(i), ",")
zGE = duplicateAbbreviationsGlossary.getEntryByIndex(CLng(zDuplicateSet(0)))
term = duplicateAbbreviationsGlossary.getKey(zGE)
definition = duplicateAbbreviationsGlossary.getItem(zGE)
definedInSourcePrefix = Mid$(duplicateAbbreviationsGlossary.getPrefix(zGE), 3)
zTemp = term
zTemp = BStringInsert(zTemp, 14, definition)
zTemp = BStringInsert(zTemp, 45, "This Document")
zTemp = BStringInsert(zTemp, 59, definedInSourcePrefix)
Call BWriteLineInArray(xArray:=out, xLine:="xx" & zTemp)
For j = 1 To UBound(zDuplicateSet)
zGE = duplicateAbbreviationsGlossary.getEntryByIndex(CLng(zDuplicateSet(j)))
term = duplicateAbbreviationsGlossary.getKey(zGE)
definition = duplicateAbbreviationsGlossary.getItem(zGE)
definedInSourcePrefix = Mid$(duplicateAbbreviationsGlossary.getPrefix(zGE), 3)
If definedInSourcePrefix = c8CurrentDocument Then definedInSourcePrefix = ""
definedInSourceDocument = Left$(duplicateAbbreviationsGlossary.getPrefix(zGE), 2)
If definedInSourceDocument < 2 Then
definedInSourceDocument = "This Document"
Else
definedInSourceDocument = "Imported " & chrDoubleQuote
End If
zTemp = term
zTemp = BStringInsert(zTemp, 14, definition)
zTemp = BStringInsert(zTemp, 45, definedInSourceDocument)
zTemp = BStringInsert(zTemp, 59, definedInSourcePrefix)
Call BWriteLineInArray(xArray:=out, xLine:="xx" & zTemp)
Next j
Call BWriteLineInArray(xArray:=out, xLine:="xx")
Next i
Call BWriteLineInArray(xArray:=out, xLine:="xx")
getConflictingDefinitionsIntoArray = out
End Function
Function getSystemInfoIntoArray() As Variant
Dim out As Variant
Dim xAddin As AddIn
Dim zString As String
On Error GoTo error1
Call BWriteLineInArray(xArray:=out, xLine:="H0Word Environment Report")
Call BWriteLineInArray(xArray:=out, xLine:="xx")
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("Windows Version", System.version))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("Word Version", Application.Build))
Call BWriteLineInArray(xArray:=out, xLine:="H1Word Options")
Call getWordOptionsIntoArray_2000(out)
If wordVersion >= WordXP Then Call getWordOptionsIntoArray_2002(out)
If wordVersion >= Word2003 Then Call getWordOptionsIntoArray_2003(out)
If wordVersion >= Word2007 Then Call getWordOptionsIntoArray_2007(out)
If wordVersion >= Word2010 Then Call getWordOptionsIntoArray_2010(out)
Call BWriteLineInArray(xArray:=out, xLine:="H1Regional and Language Settings - System")
If wordVersion >= Word2003 Then
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_Word2003)
Else
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_Word2000)
End If
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("LanguageDesignation", System.LanguageDesignation))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("UserDefaultLangID", BWordLanguageDisplay(BGetUserDefaultLangID)))
Call BWriteLineInArray(xArray:=out, xLine:="H1Regional and Language Settings - Word")
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("Application.CheckLanguage", Application.CheckLanguage))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("Application.Languages.count", Application.Languages.count))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("Application.Language", BWordLanguageDisplay(Application.Language)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("msoLanguageIDUI", BWordLanguageDisplay(Application.LanguageSettings.LanguageID(msoLanguageIDUI))))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("msoLanguageIDInstall", BWordLanguageDisplay(Application.LanguageSettings.LanguageID(msoLanguageIDInstall))))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("msoLanguageIDHelp", BWordLanguageDisplay(Application.LanguageSettings.LanguageID(msoLanguageIDHelp))))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("wdProductLanguageID", BWordLanguageDisplay(Application.International(wdProductLanguageID))))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("Custom Dictionaries", Application.CustomDictionaries.count))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("wdDateSeparator", Application.International(wdDateSeparator)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("wdInternationalAM", Application.International(wdInternationalAM)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("wdInternationalPM", Application.International(wdInternationalPM)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("wdTimeSeparator", Application.International(wdTimeSeparator)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("wdDecimalSeparator", Application.International(wdDecimalSeparator)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("wdThousandsSeparator", Application.International(wdThousandsSeparator)))
Call BWriteLineInArray(xArray:=out, xLine:="H1Addins")
For Each xAddin In Application.AddIns
zString = xAddin.path & Application.PathSeparator & xAddin.name
If xAddin.Installed Then
zString = zString & " (Installed)"
Else
zString = zString & " (Not Installed)"
End If
Call BWriteLineInArray(xArray:=out, xLine:="xx" & zString)
Next xAddin
getSystemInfoIntoArray = out
Exit Function
error1:
Call BWriteLineInArray(xArray:=out, xLine:="xx" & Err.Description)
Resume Next
End Function
Sub getWordOptionsIntoArray_2000(out As Variant)
Call BWriteLineInArray(xArray:=out, xLine:="H22000 and above")
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("AutoRecoverPath", Application.Options.DefaultFilePath(wdAutoRecoverPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("CurrentFolderPath", Application.Options.DefaultFilePath(wdCurrentFolderPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("GraphicsFiltersPath", Application.Options.DefaultFilePath(wdGraphicsFiltersPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("ProgramPath", Application.Options.DefaultFilePath(wdProgramPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("StartupPath", Application.Options.DefaultFilePath(wdStartupPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("TempFilePath", Application.Options.DefaultFilePath(wdTempFilePath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("ToolsPath", Application.Options.DefaultFilePath(wdToolsPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("UserOptionsPath", Application.Options.DefaultFilePath(wdUserOptionsPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("WorkgroupTemplatesPath", Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("BorderArtPath", Application.Options.DefaultFilePath(wdBorderArtPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("DocumentsPath", Application.Options.DefaultFilePath(wdDocumentsPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("PicturesPath", Application.Options.DefaultFilePath(wdPicturesPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("ProofingToolsPath", Application.Options.DefaultFilePath(wdProofingToolsPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("StyleGalleryPath", Application.Options.DefaultFilePath(wdStyleGalleryPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("TextConvertersPath", Application.Options.DefaultFilePath(wdTextConvertersPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("TutorialPath", Application.Options.DefaultFilePath(wdTutorialPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("UserTemplatesPath", Application.Options.DefaultFilePath(wdUserTemplatesPath)))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("CheckSpellingAsYouType", Application.Options.CheckSpellingAsYouType))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("AutoKeyboardSwitching", Application.Options.AutoKeyboardSwitching))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("OptimizeForWord97byDefault", Application.Options.OptimizeForWord97byDefault))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("AllowFastSave", Application.Options.AllowFastSave))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("BackgroundSave", Application.Options.BackgroundSave))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("CreateBackup", Application.Options.CreateBackup))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("SavePropertiesPrompt", Application.Options.SavePropertiesPrompt))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("SaveInterval", Application.Options.SaveInterval))
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("SaveNormalPrompt", Application.Options.SaveNormalPrompt))
End Sub
Sub getWordOptionsIntoArray_2002(out As Variant)
Call BWriteLineInArray(xArray:=out, xLine:="H22002 and above")
Call BWriteLineInArray(xArray:=out, xLine:="xx" & getSystemInfoIntoArray_formatLine("LocalNetworkFile", Application.Options.LocalNetworkFile))
End Sub
Sub getWordOptionsIntoArray_2003(out As Variant)
Call BWriteLineInArray(xArray:=out, xLine:="H22003 and above")
End Sub
Sub getWordOptionsIntoArray_2007(out As Variant)
Call BWriteLineInArray(xArray:=out, xLine:="H22007 and above")
End Sub
Sub getWordOptionsIntoArray_2010(out As Variant)
Call BWriteLineInArray(xArray:=out, xLine:="H22010 and above")
End Sub
Function getSystemInfoIntoArray_Word2003() As String
getSystemInfoIntoArray_Word2003 = getSystemInfoIntoArray_formatLine("Country Region", System.CountryRegion)
End Function
Function getSystemInfoIntoArray_Word2000() As String
getSystemInfoIntoArray_Word2000 = getSystemInfoIntoArray_formatLine("Country", System.Country)
End Function
Function getSystemInfoIntoArray_formatLine(xDescriptor As String, xValue As String) As String
getSystemInfoIntoArray_formatLine = BStringInsert(xDescriptor, 30, xValue)
End Function
Private Function formatStats(label As String, ppStats As String) As String
Dim parsedString() As String
Dim executionCount As String
Dim tableCount As String
Dim rowCount As String
Dim count1 As String
Dim count2 As String
Dim elapsedTime As String
Dim memPT As String
Dim memPF As String
Dim memVT As String
Dim zString As String
zString = label
parsedString = Split(ppStats, ppStats_Delimiter)
If UBound(parsedString) > -1 Then executionCount = parsedString(0)
If UBound(parsedString) > 0 Then tableCount = parsedString(1)
If UBound(parsedString) > 1 Then rowCount = parsedString(2)
If UBound(parsedString) > 2 Then count1 = parsedString(3)
If UBound(parsedString) > 3 Then count2 = parsedString(4)
If UBound(parsedString) > 4 Then elapsedTime = Round(CSng(parsedString(5)) / 1000, 1) & "s"
If UBound(parsedString) > 5 Then memPT = parsedString(6)
If UBound(parsedString) > 6 Then memPF = parsedString(7)
If UBound(parsedString) > 7 Then memVT = parsedString(8)
zString = BStringInsert(xTargetString:=zString, xPos:=21 - Len(executionCount), xInputString:=executionCount)
zString = BStringInsert(xTargetString:=zString, xPos:=28 - Len(tableCount), xInputString:=tableCount)
zString = BStringInsert(xTargetString:=zString, xPos:=35 - Len(rowCount), xInputString:=rowCount)
zString = BStringInsert(xTargetString:=zString, xPos:=42 - Len(count1), xInputString:=count1)
zString = BStringInsert(xTargetString:=zString, xPos:=49 - Len(count2), xInputString:=count2)
zString = BStringInsert(xTargetString:=zString, xPos:=58 - Len(elapsedTime), xInputString:=elapsedTime)
zString = BStringInsert(xTargetString:=zString, xPos:=66 - Len(memPT), xInputString:=memPT)
zString = BStringInsert(xTargetString:=zString, xPos:=74 - Len(memPF), xInputString:=memPF)
zString = BStringInsert(xTargetString:=zString, xPos:=82 - Len(memVT), xInputString:=memVT)
formatStats = zString
End Function
Attribute VB_Name = "clsBWindowsFileDialogs"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
#If VBA7 Then
Private Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare PtrSafe Function GetActiveWindow Lib "user32" () As LongPtr
Private Type OPENFILENAME
lStructSize As Long
hwndOwner As LongPtr
hInstance As LongPtr
lpstrFilter As String
lpstrCustomFilter As String
nMaxCustFilter As Long
nFilterIndex As Long
lpstrFile As String
nMaxFile As Long
lpstrFileTitle As String
nMaxFileTitle As Long
lpstrInitialDir As String
lpstrTitle As String
flags As Long
nFileOffset As Integer
nFileExtension As Integer
lpstrDefExt As String
lCustData As Long
lpfnHook As LongPtr
lpTemplateName As String
End Type
#Else
Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function GetActiveWindow Lib "user32" () As Long
Private Type OPENFILENAME
lStructSize       As Long
hwndOwner         As Long
hInstance         As Long
lpstrFilter       As String
lpstrCustomFilter As String
nMaxCustFilter    As Long
nFilterIndex      As Long
lpstrFile         As String
nMaxFile          As Long
lpstrFileTitle    As String
nMaxFileTitle     As Long
lpstrInitialDir   As String
lpstrTitle        As String
flags             As Long
nFileOffset       As Integer
nFileExtension    As Integer
lpstrDefExt       As String
lCustData         As Long
lpfnHook          As Long
lpTemplateName    As String
End Type
#End If
Private Const OFN_OVERWRITEPROMPT = &H2
Private Const OFN_HIDEREADONLY = &H4
Private Const OFN_EXTENSIONDIFFERENT = &H400
Private Const OFN_EXPLORER = &H80000
Private Const OFN_LONGNAMES = &H200000
Private Const maxFilenameLength As Long = 1024
Private sFullNameWithPath As String
Private sFullName As String
Private sFilePath As String
Private sFileName As String
Private sFileExtension As String
Private sDialogTitle As String
Private sFilters As String
Private sInitialDirectory As String
Private OFN As OPENFILENAME
Property Let dialogTitle(xCaption As String)
sDialogTitle = xCaption
End Property
Property Let initialDirectory(xInitialDirectory As String)
sInitialDirectory = xInitialDirectory
End Property
Property Get initialDirectory() As String
initialDirectory = sInitialDirectory & vbNull
End Property
Property Let filter(xFilter As String)
sFilters = xFilter
End Property
Property Let fileFullName(xFileName As String)
If Len(xFileName) <= maxFilenameLength Then sFullName = xFileName
End Property
Property Get fileFullNameWithPath() As String
fileFullNameWithPath = sFullNameWithPath
End Property
Property Get fileFullName() As String
fileFullName = sFullName
End Property
Property Get filePath() As String
filePath = sFilePath
End Property
Property Get fileName() As String
fileName = sFileName
End Property
Property Get fileExt() As String
fileExt = sFileExtension
End Property
Property Let fileExt(xExtension As String)
sFileExtension = xExtension
End Property
Property Get extensionChanged() As Boolean
extensionChanged = Abs(OFN.flags And OFN_EXTENSIONDIFFERENT)
End Property
Public Function showSave() As Boolean
With OFN
.lStructSize = Len(OFN)
.hwndOwner = GetActiveWindow
.lpstrFile = sFullName & String$(maxFilenameLength - Len(sFullName), vbNullChar)
.lpstrFilter = sFilters
.lpstrTitle = sDialogTitle
.lpstrInitialDir = sInitialDirectory
.nMaxFile = Len(.lpstrFile) + 1
.flags = OFN_EXPLORER Or OFN_LONGNAMES Or OFN_OVERWRITEPROMPT Or OFN_HIDEREADONLY
.lpstrDefExt = sFileExtension
End With
#If VBA7 Then
OFN.nMaxFile = LenB(OFN.lpstrFile) - 1
OFN.lStructSize = LenB(OFN)
#Else
OFN.nMaxFile = Len(OFN.lpstrFile) - 1
OFN.lStructSize = Len(OFN)
#End If
showSave = GetSaveFileName(OFN)
If showSave Then
sFullNameWithPath = BGetNullDelimitedString(OFN.lpstrFile)
sFullName = BGetFilenameFromPath(sFullNameWithPath)
sFilePath = Left$(OFN.lpstrFile, OFN.nFileOffset)
sFileName = BGetFilenamePart(sFullName)
sFileExtension = BGetFileExtension(sFullName)
End If
End Function
Private Sub Class_Initialize()
sFilters = vbNullString
sDialogTitle = "Save As"
End Sub
Attribute VB_Name = "clsBerrickDateTime"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private cls_internationalDateOrdinals As Variant
Private cls_daysOfWeek(1 To 7) As String
Private cls_longMonths(1 To 12) As String
Private cls_shortMonths(1 To 12) As String
Private cls_countryCode As WdCountry
Const possibleDelimiters As String = " .-_;/:"
Private Sub Class_Initialize()
Call initialiseSystem
End Sub
Public Sub initialiseSystem()
If wordVersion >= Word2003 Then
Call initialiseWord2003AndAbove
Else
Call initialiseWord2000
End If
Call initialiseCountry
End Sub
Sub initialiseWord2000()
cls_countryCode = System.Country
End Sub
Sub initialiseWord2003AndAbove()
cls_countryCode = System.CountryRegion
End Sub
Public Sub initialiseCountry()
Dim startDay As Date
Dim i As Long
Select Case cls_countryCode
Case wdGermany
cls_internationalDateOrdinals = Array(".")
Case wdItaly
cls_internationalDateOrdinals = Array("o", "a", ".o", ".a", "|fffd|", "|fffd|", "|fffd|")
Case wdSpain
cls_internationalDateOrdinals = Array("o", "a", ".o", ".a", "ro", "do", "to", "|fffd|", "|fffd|", "|fffd|", "er")
Case wdFrance
cls_internationalDateOrdinals = Array("er", "|fffd|me", "re", "e")
Case Else
cls_internationalDateOrdinals = Array("st", "nd", "rd", "th")
End Select
For i = 0 To UBound(cls_internationalDateOrdinals)
cls_internationalDateOrdinals(i) = UCase$(cls_internationalDateOrdinals(i))
Next i
startDay = DateValue("2010-01-02")
For i = 1 To 7
cls_daysOfWeek(i) = UCase$(format$(DateAdd("d", i, startDay), "dddd"))
Next i
For i = 1 To 12
cls_longMonths(i) = format$(DateAdd("m", i, startDay), "mmmm")
cls_shortMonths(i) = format$(DateAdd("m", i, startDay), "mmm")
Next i
End Sub
Property Get countryCode() As WdCountry
countryCode = cls_countryCode
End Property
Property Let countryCode(xCountry As WdCountry)
cls_countryCode = xCountry
Call initialiseCountry
End Property
Public Function DateDifference(xDate1 As Date, xDate2 As Date) As Variant
Dim earlyDate As Date
Dim lateDate As Date
Dim out(0 To 2) As Long
Dim earlyDayAdjusted As Long
Dim prevMonthBeginning As Date
earlyDate = BMin(xDate1, xDate2)
lateDate = BMax(xDate1, xDate2)
out(0) = WholeYearsBetween(xDate1, xDate2)
out(1) = DateDiff("m", earlyDate, lateDate) Mod 12
out(2) = Day(lateDate) - Day(earlyDate)
If out(2) < 0 Then
If (Day(earlyDate) = 29 And month(earlyDate) = 2) And (Day(lateDate) = 28 And month(lateDate) = 2) And Not IsLeapYear(year(lateDate)) Then
out(0) = out(0) + 1
out(1) = 0
out(2) = 0
Else
out(1) = out(1) - 1
prevMonthBeginning = DateSerial(year(lateDate), month(lateDate) - 1, 1)
earlyDayAdjusted = BMin(DaysInMonth(prevMonthBeginning), Day(earlyDate))
out(2) = DaysInMonth(prevMonthBeginning) - earlyDayAdjusted + Day(lateDate)
End If
End If
If out(1) = -1 Then out(1) = 11
DateDifference = out
End Function
Public Function DateDifferenceFormatted(xDate1 As Date, xDate2 As Date) As String
Dim out As Variant
Dim years As Long
Dim months As Long
Dim days As Long
out = DateDifference(xDate1, xDate2)
years = out(0)
months = out(1)
days = out(2)
DateDifferenceFormatted = BPluralityText(years, "year") & ", " & BPluralityText(months, "month") & ", " & BPluralityText(days, "day")
End Function
Public Function DateValueLoose(ByVal inp As String) As Variant
Dim i  As Long
Dim repChars As String
Dim workingString As String
Dim dayOfWeek As String
Dim zVar As Variant
Dim char As String
repChars = ".:"
workingString = ""
For i = 1 To Len(inp)
char = Mid$(inp, i, 1)
If InStr(repChars, char) > 0 Then
workingString = workingString & Application.International(wdDateSeparator)
Else
workingString = workingString & char
End If
Next i
workingString = UCase$(workingString)
DateValueLoose = callDateValue(workingString)
If Len(DateValueLoose) <> 0 Then Exit Function
zVar = RemoveDayOfWeek(workingString)
dayOfWeek = zVar(0)
workingString = zVar(1)
DateValueLoose = callDateValue(workingString)
If Len(DateValueLoose) <> 0 Then GoTo checkDayOfWeek
workingString = replace(workingString, ",", "")
DateValueLoose = callDateValue(workingString)
If Len(DateValueLoose) <> 0 Then GoTo checkDayOfWeek
workingString = ExpandSqueezedDate(workingString)
DateValueLoose = callDateValue(workingString)
If Len(DateValueLoose) <> 0 Then GoTo checkDayOfWeek
workingString = RemoveOrdinals(workingString)
DateValueLoose = callDateValue(workingString)
If Len(DateValueLoose) = 0 Then
DateValueLoose = Empty
Exit Function
End If
checkDayOfWeek:
If Len(dayOfWeek) = 0 Then
Exit Function
Else
If UCase$(format$(DateValueLoose, "dddd")) = dayOfWeek Then
Else
DateValueLoose = Empty
End If
End If
End Function
Function DaysInMonth(xDate As Date) As Long
DaysInMonth = DateSerial(year(xDate), month(xDate) + 1, 1) - DateSerial(year(xDate), month(xDate), 1)
End Function
Function ExpandSqueezedDate(inString As String) As String
Dim shortMonth As String
Dim shortMonthPos As Long
Dim longMonth As String
Dim longMonthPos As Long
Dim i  As Long
For i = 1 To 12
longMonth = cls_longMonths(i)
longMonthPos = InStr(UCase$(inString), UCase$(longMonth))
If longMonthPos > 0 Then
ExpandSqueezedDate = Left$(inString, longMonthPos - 1) & " " & Mid$(inString, longMonthPos, Len(longMonth)) & " " & Mid$(inString, longMonthPos + Len(longMonth))
Exit Function
End If
shortMonth = cls_shortMonths(i)
shortMonthPos = InStr(UCase$(inString), UCase$(shortMonth))
If shortMonthPos > 0 Then
ExpandSqueezedDate = Left$(inString, shortMonthPos - 1) & " " & Mid$(inString, shortMonthPos, Len(shortMonth)) & " " & Mid$(inString, shortMonthPos + Len(shortMonth))
Exit Function
End If
Next i
ExpandSqueezedDate = inString
End Function
Function IsLeapYear(xYYYY As Long) As Boolean
IsLeapYear = (Day(DateSerial(xYYYY, 2, 28) + 1) = 29)
End Function
Public Function ISODatePart(xDateTimeISO As String) As String
On Error Resume Next
ISODatePart = Left$(xDateTimeISO, InStr(xDateTimeISO, "T") - 1)
End Function
Public Function ISOTimePart(xDateTimeISO As String) As String
On Error Resume Next
ISOTimePart = Mid$(xDateTimeISO, InStr(xDateTimeISO, "T") + 1)
End Function
Public Function ISODateTimeDiff(xDateTimeISO1 As String, xDateTimeISO2 As String) As Variant
Dim earlyDateTimeISO As String
Dim lateDateTimeISO As String
Dim earlierEventDate As Date
Dim laterEventDate As Date
Dim earlierEventTime As Date
Dim laterEventTime As Date
Dim out(0 To 5) As Long
Dim zTemp As Variant
Dim timeDiff As Long
On Error GoTo badProcess
earlyDateTimeISO = BMin(xDateTimeISO1, xDateTimeISO2)
lateDateTimeISO = BMax(xDateTimeISO1, xDateTimeISO2)
earlierEventDate = CDate(ISODatePart(earlyDateTimeISO))
If ISOTimePart(lateDateTimeISO) < ISOTimePart(earlyDateTimeISO) Then
laterEventDate = DateAdd("d", -1, CDate(ISODatePart(lateDateTimeISO)))
Else
laterEventDate = CDate(ISODatePart(lateDateTimeISO))
End If
zTemp = DateDifference(earlierEventDate, laterEventDate)
out(0) = zTemp(0)
out(1) = zTemp(1)
out(2) = zTemp(2)
earlierEventTime = TimeValue(ISOTimePart(earlyDateTimeISO))
laterEventTime = TimeValue(ISOTimePart(lateDateTimeISO))
timeDiff = DateDiff("s", earlierEventTime, laterEventTime)
If timeDiff < 0 Then timeDiff = timeDiff + 86400
out(3) = timeDiff \ 3600
out(4) = (timeDiff Mod 3600) \ 60
out(5) = (timeDiff Mod 3600) Mod 60
ISODateTimeDiff = out
Exit Function
badProcess:
ISODateTimeDiff = Empty
End Function
Public Function ISODateTimeDiffFormatted(xDateTimeISO1 As String, xDateTimeISO2 As String, Optional xShowZeroAsNull As Boolean = False, Optional xShowTimeInfo As Boolean = True) As String
Dim zTemp As Variant
Dim years As String
Dim months As String
Dim days As String
Dim hours As String
Dim minutes As String
Dim seconds As String
Dim out As String
zTemp = ISODateTimeDiff(xDateTimeISO1, xDateTimeISO2)
years = BPluralityText(CLng(zTemp(0)), "year", xShowZeroAsNull:=xShowZeroAsNull)
months = BPluralityText(CLng(zTemp(1)), "month", xShowZeroAsNull:=xShowZeroAsNull)
days = BPluralityText(CLng(zTemp(2)), "day", xShowZeroAsNull:=xShowZeroAsNull)
hours = BPluralityText(CLng(zTemp(3)), "hour", xShowZeroAsNull:=xShowZeroAsNull)
minutes = BPluralityText(CLng(zTemp(4)), "minute", xShowZeroAsNull:=xShowZeroAsNull)
seconds = BPluralityText(CLng(zTemp(5)), "second", xShowZeroAsNull:=xShowZeroAsNull)
If Len(years) = 0 Then
out = ""
Else
out = years & ", "
End If
If Len(months) = 0 Then
Else
out = out & months & ", "
End If
If Len(days) = 0 Then
Else
out = out & days & ", "
End If
If xShowTimeInfo Then
Else
GoTo finished
End If
If Len(hours) = 0 Then
Else
out = out & hours & ", "
End If
If Len(minutes) = 0 Then
Else
out = out & minutes & ", "
End If
If Len(seconds) = 0 Then
Else
out = out & seconds
End If
finished:
If Right$(out, 2) = ", " Then out = Left$(out, Len(out) - 2)
ISODateTimeDiffFormatted = out
End Function
Function RemoveDayOfWeek(inp As String) As Variant
Dim i As Long
Dim pos As Long
Dim out(1) As String
Dim workingString As String
workingString = UCase$(inp)
out(0) = ""
out(1) = workingString
For i = 1 To 7
pos = InStr(workingString, cls_daysOfWeek(i))
If pos > 0 Then
out(0) = cls_daysOfWeek(i)
out(1) = replace(workingString, cls_daysOfWeek(i), "")
GoTo finish
End If
Next i
pos = InStr(workingString, "H|fffd|TFO")
If pos > 0 Then
out(0) = "H|fffd|TFO"
out(1) = replace(workingString, "H|fffd|TFO", "")
GoTo finish
End If
finish:
RemoveDayOfWeek = out
End Function
Function RemoveOrdinals(inString As String) As String
Dim i As Long
Dim pos As Long
Dim zString As String
zString = UCase$(inString)
For i = 0 To UBound(cls_internationalDateOrdinals)
pos = InStr(zString, cls_internationalDateOrdinals(i))
If pos > 1 Then
If IsNumeric(Mid$(inString, pos - 1, 1)) Then
RemoveOrdinals = Left$(inString, pos - 1) & Mid$(inString, pos + Len(cls_internationalDateOrdinals(i)))
Exit Function
End If
End If
Next i
For i = 0 To UBound(cls_internationalDateOrdinals)
pos = BInstrRev(zString, CStr(cls_internationalDateOrdinals(i)))
If pos > 1 Then
If IsNumeric(Mid$(inString, pos - 1, 1)) Then
RemoveOrdinals = Left$(inString, pos - 1) & Mid$(inString, pos + Len(cls_internationalDateOrdinals(i)))
Exit Function
End If
End If
Next i
RemoveOrdinals = inString
End Function
Function StringsToISODateTime(xInDate As String, Optional xInTime As String = "") As String
Dim out As String
Dim zTemp As String
out = StringToISODate(xInDate)
If Len(out) = 0 Then Exit Function
If Len(xInTime) = 0 Then GoTo finished
zTemp = StringToISOTime(xInTime)
If Len(zTemp) = 0 Then
out = ""
Else
out = out & "T" & zTemp
End If
finished:
StringsToISODateTime = out
End Function
Public Function StringToISOTime(xIn As String) As String
StringToISOTime = TimeValueLoose(xIn, xFormatTime:="hh:mm:ss")
End Function
Public Function StringToISODate(xIn As String) As String
Dim zTemp As Variant
zTemp = DateValueLoose(xIn)
If IsEmpty(zTemp) Then
StringToISODate = ""
Else
StringToISODate = format$(zTemp, "yyyy-mm-dd")
End If
End Function
Public Function NowISO() As String
NowISO = format$(Now, "yyyy-mm-ddThh:mm:ss")
End Function
Function YMD(d As Variant) As String
If IsDate(d) Then
YMD = format$(d, "yyyymmdd")
Else
YMD = ""
End If
End Function
Public Function TimeValueLoose(ByVal inp As String, Optional xFormatTime As Variant) As Variant
Dim i  As Long
Dim out As String
Dim sep As String
Dim timePart As String
Dim am_pm As String
Dim noon_midnight As String
Dim hours As Long
Dim minutes As Long
Dim seconds As Long
Dim numericParts() As String
On Error GoTo badTime
sep = Application.International(wdTimeSeparator)
For i = 1 To Len(possibleDelimiters) + 1
inp = replace(inp, Mid$(possibleDelimiters, i, 1), " ")
Next
inp = BSqueezeSpaces(UCase$(inp))
am_pm = Right$(inp, 2)
If InStr("AM PM", am_pm) > 0 Then
timePart = Trim$(Left$(inp, Len(inp) - 2))
Else
am_pm = ""
timePart = Trim$(inp)
End If
If Right$(inp, 8) = "MIDNIGHT" Then
timePart = Trim$(Left$(inp, Len(inp) - 8))
If Len(timePart) = 0 Then timePart = "00"
noon_midnight = "00"
Else
If Right$(inp, 4) = "NOON" Then
timePart = Trim$(Left$(inp, Len(inp) - 4))
If Len(timePart) = 0 Then timePart = "12"
noon_midnight = "12"
End If
End If
If InStr(timePart, " ") > 0 Then
numericParts = Split(timePart, " ")
Else
If Len(timePart) > 6 Or Len(timePart) < 1 Then
GoTo badTime
End If
ReDim numericParts(2)
If Len(timePart) Mod 2 = 1 Then
timePart = "0" & timePart
End If
numericParts(0) = Left$(timePart, 2)
numericParts(1) = "0"
numericParts(2) = "0"
If Len(timePart) >= 4 Then numericParts(1) = Mid$(timePart, 3, 2)
If Len(timePart) = 6 Then
numericParts(2) = Right$(timePart, 2)
Else
ReDim Preserve numericParts(1)
End If
End If
If Not BWithinBounds(UBound(numericParts), 0, 2) Then GoTo badTime
hours = CInt(numericParts(0))
If hours = 12 Then
If noon_midnight = "00" Then
hours = 0
End If
End If
If Len(noon_midnight) = 0 Then
Else
If (hours = 0) Or (hours = 12) Then
Else
GoTo badTime
End If
End If
If UBound(numericParts) > 0 Then minutes = CInt(numericParts(1))
If UBound(numericParts) > 1 Then seconds = CInt(numericParts(2))
If Not BWithinBounds(hours, 0, 23) Then GoTo badTime
If Not BWithinBounds(minutes, 0, 59) Then GoTo badTime
If Not BWithinBounds(seconds, 0, 59) Then GoTo badTime
If IsMissing(xFormatTime) Then
Select Case UBound(numericParts)
Case 0
xFormatTime = "hh:mm"
Case 1
xFormatTime = "hh:mm"
Case 2
xFormatTime = "hh:mm:ss"
End Select
End If
out = format$(hours, "00") & sep & format$(minutes, "00") & sep & format$(seconds, "00")
If InStr("AM PM", am_pm) Then
GoTo am_pmCheck
Else
If Len(am_pm) = 0 Then
GoTo no_am_pmCheck
Else
GoTo badTime
End If
End If
am_pmCheck:
If Left$(out, 2) > 12 And am_pm = "AM" Then GoTo badTime
no_am_pmCheck:
On Error GoTo badTime
TimeValueLoose = format$(TimeValue(out & am_pm), xFormatTime)
Exit Function
badTime:
TimeValueLoose = Empty
End Function
Public Function WholeYearsBetween(xDate1 As Date, xDate2 As Date) As Long
Dim earlyDate As Date
Dim lateDate As Date
Dim out As Long
earlyDate = BMin(xDate1, xDate2)
lateDate = BMax(xDate1, xDate2)
out = year(lateDate) - year(earlyDate)
If lateDate < DateSerial(year(lateDate), month(earlyDate), Day(earlyDate)) Then
out = out - 1
End If
WholeYearsBetween = out
End Function
Private Function callDateValue(ByVal inp As String) As String
On Error GoTo badDate
callDateValue = DateValue(inp)
Exit Function
badDate:
callDateValue = ""
End Function
Attribute VB_Name = "clsClipboard"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
#If VBA7 Then
Private Declare PtrSafe Function openClipboard Lib "user32" Alias "OpenClipboard" (ByVal hwnd As LongPtr) As LongPtr
Private Declare PtrSafe Function CloseClipboard Lib "user32" () As LongPtr
Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As LongPtr
Private Declare PtrSafe Function EnumClipboardFormats Lib "user32" (ByVal wFormat As LongPtr) As LongPtr
Private Declare PtrSafe Function GetClipboardFormatName Lib "user32" Alias "GetClipboardFormatNameA" (ByVal wFormat As LongPtr, ByVal lpString As String, ByVal nMaxCount As LongPtr) As LongPtr
Private Declare PtrSafe Function GetClipboardData Lib "user32" (ByVal wFormat As LongPtr) As LongPtr
Private Declare PtrSafe Function SetClipboardData Lib "user32" (ByVal wFormat As LongPtr, ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As LongPtr, ByVal dwBytes As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalSize Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Sub MoveMemory Lib "kernel32" Alias "RtlMoveMemory" (ByVal strDest As Any, ByVal lpSource As Any, ByVal Length As LongPtr)
Private Declare PtrSafe Function lstrcpy Lib "kernel32" (ByVal lpString1 As Any, ByVal lpString2 As Any) As LongPtr
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As LongPtr)
#Else
Private Declare Function openClipboard Lib "user32" Alias "OpenClipboard" (ByVal hwnd As Long) As Long
Private Declare Function CloseClipboard Lib "user32" () As Long
Private Declare Function EmptyClipboard Lib "user32" () As Long
Private Declare Function EnumClipboardFormats Lib "user32" (ByVal wFormat As Long) As Long
Private Declare Function GetClipboardFormatName Lib "user32" Alias "GetClipboardFormatNameA" (ByVal wFormat As Long, ByVal lpString As String, ByVal nMaxCount As Long) As Long
Private Declare Function GetClipboardData Lib "user32" (ByVal wFormat As Long) As Long
Private Declare Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As Long) As Long
Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalSize Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Sub MoveMemory Lib "kernel32" Alias "RtlMoveMemory" (ByVal strDest As Any, ByVal lpSource As Any, ByVal Length As Long)
Private Declare Function lstrcpy Lib "kernel32" (ByVal lpString1 As Any, ByVal lpString2 As Any) As Long
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If
Private Const NAME_MAX_LENGTH = 1024
Private Const APINULL = 0
Private Const GHND = &H42
Private Const CF_TEXT = 1
Private Const MAXSIZE = 4096
Sub SetData(xString As String, Optional xShowErrors As Boolean = False)
#If VBA7 Then
Dim hGlobalMemory As LongPtr, lpGlobalMemory As LongPtr
Dim hClipMemory As LongPtr, x As LongPtr
#Else
Dim hGlobalMemory As Long, lpGlobalMemory As Long
Dim hClipMemory As Long, x As Long
#End If
Dim loopCount As Long
hGlobalMemory = GlobalAlloc(GHND, Len(xString) + 1)
lpGlobalMemory = GlobalLock(hGlobalMemory)
lpGlobalMemory = lstrcpy(lpGlobalMemory, xString)
If GlobalUnlock(hGlobalMemory) <> 0 Then
If xShowErrors Then Call showMessage(c8Msg6000, msgSuffix2:="clsClipboard: Could not unlock memory location. Copy aborted.")
GoTo OutOfHere2
End If
loopCount = 0
On Error GoTo openFailure
If openClipboard(0&) = 0 Then
Exit Sub
End If
On Error GoTo 0
x = EmptyClipboard()
hClipMemory = SetClipboardData(CF_TEXT, hGlobalMemory)
OutOfHere2:
If CloseClipboard() = 0 Then
If xShowErrors Then Call showMessage(c8Msg6000, msgSuffix2:="clsClipboard: CloseClipboard failed")
End If
Exit Sub
openFailure:
If loopCount <= 10 Then
loopCount = loopCount + 1
Sleep 20
Resume
Else
If showMessage(c8Msg5500, button2:="OK", button3:="Cancel") = "OK" Then
loopCount = 0
Resume
Else
Exit Sub
End If
End If
End Sub
Function GetData(Optional xShowErrors As Boolean = False) As String
#If VBA7 Then
Dim hClipMemory As LongPtr
Dim lpClipMemory As LongPtr
Dim RetVal As LongPtr
#Else
Dim hClipMemory As Long
Dim lpClipMemory As Long
Dim RetVal As Long
#End If
Dim outString As String
Dim loopCount As Long
outString = ""
loopCount = 0
On Error GoTo openFailure
If openClipboard(0&) = 0 Then
Exit Function
End If
On Error GoTo 0
hClipMemory = GetClipboardData(CF_TEXT)
If IsNull(hClipMemory) Then
If xShowErrors Then Call showMessage(c8Msg6000, msgSuffix2:="clsClipboard: Could not allocate memory")
GoTo OutOfHere
End If
lpClipMemory = GlobalLock(hClipMemory)
If Not IsNull(lpClipMemory) Then
outString = Space$(MAXSIZE)
RetVal = lstrcpy(outString, lpClipMemory)
RetVal = GlobalUnlock(hClipMemory)
outString = Mid$(outString, 1, InStr(1, outString, vbNullChar, 0) - 1)
Else
If xShowErrors Then Call showMessage(c8Msg6000, msgSuffix2:="clsClipboard: Could not lock memory to copy string from.")
End If
OutOfHere:
RetVal = CloseClipboard()
GetData = outString
Exit Function
openFailure:
If loopCount <= 10 Then
loopCount = loopCount + 1
Sleep 20
Resume
Else
If showMessage(c8Msg5500, button2:="OK", button3:="Cancel") = "OK" Then
loopCount = 0
Resume
Else
Exit Function
End If
End If
End Function
Sub HogClipboard()
#If VBA7 Then
Dim hGlobalMemory As LongPtr, lpGlobalMemory As LongPtr
Dim hClipMemory As LongPtr, x As LongPtr
#Else
Dim hGlobalMemory As Long, lpGlobalMemory As Long
Dim hClipMemory As Long, x As Long
#End If
Dim loopCount As Long
loopCount = 0
On Error GoTo openFailure
If openClipboard(0&) = 0 Then
Exit Sub
End If
On Error GoTo 0
Dim z As String
z = MsgBox("Press OK to close clipboard", vbOKCancel)
If z = vbCancel Then Exit Sub
If CloseClipboard() = 0 Then
Call showMessage(c8Msg6000, msgSuffix2:="clsClipboard: CloseClipboard failed")
End If
Exit Sub
openFailure:
If loopCount <= 10 Then
loopCount = loopCount + 1
Sleep 20
Resume
Else
If showMessage(c8Msg5500, button2:="OK", button3:="Cancel") = "OK" Then
loopCount = 0
Resume
Else
Exit Sub
End If
End If
End Sub
Attribute VB_Name = "clsColorManagement"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public Base01 As Collection
Const c8Color_Base01_01 As Long = 255
Const c8Color_Base01_02 As Long = 49151
Const c8Color_Base01_03 As Long = 65535
Const c8Color_Base01_04 As Long = 65407
Const c8Color_Base01_05 As Long = 16776960
Const c8Color_Base01_06 As Long = 16760576
Const c8Color_Base01_07 As Long = 16711680
Const c8Color_Base01_08 As Long = 16711871
Public Base01A As Collection
Const c8Color_Base01A_01 As Long = 9175295
Const c8Color_Base01A_02 As Long = 65471
Const c8Color_Base01A_03 As Long = 35071
Const c8Color_Base01A_04 As Long = 16735744
Const c8Color_Base01A_05 As Long = 10616576
Const c8Color_Base01A_06 As Long = 16744192
Const c8Color_Base01A_07 As Long = 16711935
Const c8Color_Base01A_08 As Long = 27391
Public Tint01 As Collection
Const c8Color_Tint01_01 As Long = 6711039
Const c8Color_Tint01_02 As Long = 6740479
Const c8Color_Tint01_03 As Long = 6750207
Const c8Color_Tint01_04 As Long = 6750130
Const c8Color_Tint01_05 As Long = 16777062
Const c8Color_Tint01_06 As Long = 16767334
Const c8Color_Tint01_07 As Long = 16737894
Const c8Color_Tint01_08 As Long = 16738009
Public Tint01A As Collection
Const c8Color_Tint01A_01 As Long = 12216063
Const c8Color_Tint01A_02 As Long = 6750169
Const c8Color_Tint01A_03 As Long = 6732031
Const c8Color_Tint01A_04 As Long = 16752230
Const c8Color_Tint01A_05 As Long = 13107046
Const c8Color_Tint01A_06 As Long = 16762767
Const c8Color_Tint01A_07 As Long = 16738047
Const c8Color_Tint01A_08 As Long = 6720767
Public Tint02 As Collection
Const c8Color_Tint02_01 As Long = 10066431
Const c8Color_Tint02_02 As Long = 10086143
Const c8Color_Tint02_03 As Long = 10092543
Const c8Color_Tint02_04 As Long = 10092492
Const c8Color_Tint02_05 As Long = 16777113
Const c8Color_Tint02_06 As Long = 16770713
Const c8Color_Tint02_07 As Long = 16751001
Const c8Color_Tint02_08 As Long = 16751078
Public Tint02A As Collection
Const c8Color_Tint02A_01 As Long = 14594815
Const c8Color_Tint02A_02 As Long = 10092518
Const c8Color_Tint02A_03 As Long = 10080255
Const c8Color_Tint02A_04 As Long = 16760473
Const c8Color_Tint02A_05 As Long = 14352281
Const c8Color_Tint02A_06 As Long = 16770764
Const c8Color_Tint02A_07 As Long = 16769279
Const c8Color_Tint02A_08 As Long = 10073087
Public Shade01 As Collection
Const c8Color_Shade01_01 As Long = 204
Const c8Color_Shade01_02 As Long = 39372
Const c8Color_Shade01_03 As Long = 52428
Const c8Color_Shade01_04 As Long = 52326
Const c8Color_Shade01_05 As Long = 13421568
Const c8Color_Shade01_06 As Long = 13408512
Const c8Color_Shade01_07 As Long = 13369344
Const c8Color_Shade01_08 As Long = 13369497
Public Shade01A As Collection
Const c8Color_Shade01A_01 As Long = 7340236
Const c8Color_Shade01A_02 As Long = 59052
Const c8Color_Shade01A_03 As Long = 24498
Const c8Color_Shade01A_04 As Long = 13388544
Const c8Color_Shade01A_05 As Long = 8506368
Const c8Color_Shade01A_06 As Long = 13395456
Const c8Color_Shade01A_07 As Long = 13369548
Const c8Color_Shade01A_08 As Long = 13260
Public Shade02 As Collection
Const c8Color_Shade02_01 As Long = 128
Const c8Color_Shade02_02 As Long = 24704
Const c8Color_Shade02_03 As Long = 32896
Const c8Color_Shade02_04 As Long = 32832
Const c8Color_Shade02_05 As Long = 8421376
Const c8Color_Shade02_06 As Long = 8413184
Const c8Color_Shade02_07 As Long = 8388608
Const c8Color_Shade02_08 As Long = 8388704
Public Shade02A As Collection
Const c8Color_Shade02A_01 As Long = 4587648
Const c8Color_Shade02A_02 As Long = 32864
Const c8Color_Shade02A_03 As Long = 17536
Const c8Color_Shade02A_04 As Long = 8400640
Const c8Color_Shade02A_05 As Long = 5341184
Const c8Color_Shade02A_06 As Long = 3348736
Const c8Color_Shade02A_07 As Long = 8388736
Const c8Color_Shade02A_08 As Long = 8320
Public Tone01 As Collection
Const c8Color_Tone01_01 As Long = 9211097
Const c8Color_Tone01_02 As Long = 9225945
Const c8Color_Tone01_03 As Long = 10477535
Const c8Color_Tone01_04 As Long = 9230770
Const c8Color_Tone01_05 As Long = 14277004
Const c8Color_Tone01_06 As Long = 13810809
Const c8Color_Tone01_07 As Long = 14257292
Const c8Color_Tone01_08 As Long = 14257350
Public Tone01A As Collection
Const c8Color_Tone01A_01 As Long = 11963609
Const c8Color_Tone01A_02 As Long = 9230790
Const c8Color_Tone01A_03 As Long = 9221593
Const c8Color_Tone01A_04 As Long = 14264460
Const c8Color_Tone01A_05 As Long = 12441996
Const c8Color_Tone01A_06 As Long = 15125427
Const c8Color_Tone01A_07 As Long = 14257369
Const c8Color_Tone01A_08 As Long = 9215961
Public Tone02 As Collection
Const c8Color_Tone02_01 As Long = 10000589
Const c8Color_Tone02_02 As Long = 10010829
Const c8Color_Tone02_03 As Long = 11130582
Const c8Color_Tone02_04 As Long = 10014130
Const c8Color_Tone02_05 As Long = 13487512
Const c8Color_Tone02_06 As Long = 13484184
Const c8Color_Tone02_07 As Long = 13473944
Const c8Color_Tone02_08 As Long = 13473984
Public Tone02A As Collection
Const c8Color_Tone02A_01 As Long = 12691926
Const c8Color_Tone02A_02 As Long = 11130570
Const c8Color_Tone02A_03 As Long = 11125206
Const c8Color_Tone02A_04 As Long = 14072233
Const c8Color_Tone02A_05 As Long = 12900009
Const c8Color_Tone02A_06 As Long = 14073769
Const c8Color_Tone02A_07 As Long = 14068182
Const c8Color_Tone02A_08 As Long = 11121878
Public TextOnWhite01  As Collection
Const c8Color_TextOnWhite01_01 As Long = 9904642
Const c8Color_TextOnWhite01_02 As Long = 24704
Const c8Color_TextOnWhite01_03 As Long = 11665586
Const c8Color_TextOnWhite01_04 As Long = 8618753
Const c8Color_TextOnWhite01_05 As Long = 16732954
Const c8Color_TextOnWhite01_06 As Long = 178
Const c8Color_TextOnWhite01_07 As Long = 881472
Const c8Color_TextOnWhite01_08 As Long = 76
Public TextOnWhite01A  As Collection
Const c8Color_TextOnWhite01A_01 As Long = 7340256
Const c8Color_TextOnWhite01A_02 As Long = 6704384
Const c8Color_TextOnWhite01A_03 As Long = 6684774
Const c8Color_TextOnWhite01A_04 As Long = 16711680
Const c8Color_TextOnWhite01A_05 As Long = 230
Const c8Color_TextOnWhite01A_06 As Long = 2196281
Const c8Color_TextOnWhite01A_07 As Long = 7798962
Const c8Color_TextOnWhite01A_08 As Long = 11042304
Public ColorsAndGrey01 As Collection
Const c8Color_ColorsAndGrey01_X_01 As Long = 219
Const c8Color_ColorsAndGrey01_Y_01 As Long = 15921906
Const c8Color_ColorsAndGrey01_X_02 As Long = 10563696
Const c8Color_ColorsAndGrey01_Y_02 As Long = 15132390
Const c8Color_ColorsAndGrey01_X_03 As Long = 15073280
Const c8Color_ColorsAndGrey01_Y_03 As Long = 14277081
Const c8Color_ColorsAndGrey01_X_04 As Long = 0
Const c8Color_ColorsAndGrey01_Y_04 As Long = 14277081
Const c8Color_ColorsAndGrey01_X_05 As Long = 21056
Const c8Color_ColorsAndGrey01_Y_05 As Long = 13421772
Const c8Color_ColorsAndGrey01_X_06 As Long = 153
Const c8Color_ColorsAndGrey01_Y_06 As Long = 12566463
Const c8Color_ColorsAndGrey01_X_07 As Long = 7742290
Const c8Color_ColorsAndGrey01_Y_07 As Long = 11711154
Const c8Color_ColorsAndGrey01_X_08 As Long = 6697728
Const c8Color_ColorsAndGrey01_Y_08 As Long = 10921638
Public ColorsAndGrey01A As Collection
Const c8Color_ColorsAndGrey01A_X_01 As Long = 10049792
Const c8Color_ColorsAndGrey01A_Y_01 As Long = 14277081
Const c8Color_ColorsAndGrey01A_X_02 As Long = 10049792
Const c8Color_ColorsAndGrey01A_Y_02 As Long = 16448250
Const c8Color_ColorsAndGrey01A_X_03 As Long = 6184542
Const c8Color_ColorsAndGrey01A_Y_03 As Long = 14277081
Const c8Color_ColorsAndGrey01A_X_04 As Long = 6184542
Const c8Color_ColorsAndGrey01A_Y_04 As Long = 16448250
Const c8Color_ColorsAndGrey01A_X_05 As Long = 6365184
Const c8Color_ColorsAndGrey01A_Y_05 As Long = 14277081
Const c8Color_ColorsAndGrey01A_X_06 As Long = 6365184
Const c8Color_ColorsAndGrey01A_Y_06 As Long = 16448250
Const c8Color_ColorsAndGrey01A_X_07 As Long = 10563696
Const c8Color_ColorsAndGrey01A_Y_07 As Long = 14277081
Const c8Color_ColorsAndGrey01A_X_08 As Long = 10563696
Const c8Color_ColorsAndGrey01A_Y_08 As Long = 16448250
Public Multicolor01 As Collection
Const c8Color_Multicolor01_X_01 As Long = 3670118
Const c8Color_Multicolor01_Y_01 As Long = 14594815
Const c8Color_Multicolor01_X_02 As Long = 23621
Const c8Color_Multicolor01_Y_02 As Long = 10092501
Const c8Color_Multicolor01_X_03 As Long = 10572
Const c8Color_Multicolor01_Y_03 As Long = 10080255
Const c8Color_Multicolor01_X_04 As Long = 4987904
Const c8Color_Multicolor01_Y_04 As Long = 16760473
Const c8Color_Multicolor01_X_05 As Long = 3824640
Const c8Color_Multicolor01_Y_05 As Long = 14352281
Const c8Color_Multicolor01_X_06 As Long = 3348736
Const c8Color_Multicolor01_Y_06 As Long = 16770764
Const c8Color_Multicolor01_X_07 As Long = 8388736
Const c8Color_Multicolor01_Y_07 As Long = 16769279
Const c8Color_Multicolor01_X_08 As Long = 8320
Const c8Color_Multicolor01_Y_08 As Long = 10073087
Public Multicolor01A As Collection
Const c8Color_Multicolor01A_X_01 As Long = 128
Const c8Color_Multicolor01A_Y_01 As Long = 10066431
Const c8Color_Multicolor01A_X_02 As Long = 24704
Const c8Color_Multicolor01A_Y_02 As Long = 10086143
Const c8Color_Multicolor01A_X_03 As Long = 30069
Const c8Color_Multicolor01A_Y_03 As Long = 15073279
Const c8Color_Multicolor01A_X_04 As Long = 31293
Const c8Color_Multicolor01A_Y_04 As Long = 10092492
Const c8Color_Multicolor01A_X_05 As Long = 7697664
Const c8Color_Multicolor01A_Y_05 As Long = 16777113
Const c8Color_Multicolor01A_X_06 As Long = 8018944
Const c8Color_Multicolor01A_Y_06 As Long = 16764082
Const c8Color_Multicolor01A_X_07 As Long = 8388608
Const c8Color_Multicolor01A_Y_07 As Long = 16751001
Const c8Color_Multicolor01A_X_08 As Long = 8388704
Const c8Color_Multicolor01A_Y_08 As Long = 16751078
Private Sub Class_Initialize()
Set Base01 = New Collection
Base01.add c8Color_Base01_01
Base01.add c8Color_Base01_02
Base01.add c8Color_Base01_03
Base01.add c8Color_Base01_04
Base01.add c8Color_Base01_05
Base01.add c8Color_Base01_06
Base01.add c8Color_Base01_07
Base01.add c8Color_Base01_08
Set Base01A = New Collection
Base01A.add c8Color_Base01A_01
Base01A.add c8Color_Base01A_02
Base01A.add c8Color_Base01A_03
Base01A.add c8Color_Base01A_04
Base01A.add c8Color_Base01A_05
Base01A.add c8Color_Base01A_06
Base01A.add c8Color_Base01A_07
Base01A.add c8Color_Base01A_08
Set Tint01 = New Collection
Tint01.add c8Color_Tint01_01
Tint01.add c8Color_Tint01_02
Tint01.add c8Color_Tint01_03
Tint01.add c8Color_Tint01_04
Tint01.add c8Color_Tint01_05
Tint01.add c8Color_Tint01_06
Tint01.add c8Color_Tint01_07
Tint01.add c8Color_Tint01_08
Set Tint01A = New Collection
Tint01A.add c8Color_Tint01A_01
Tint01A.add c8Color_Tint01A_02
Tint01A.add c8Color_Tint01A_03
Tint01A.add c8Color_Tint01A_04
Tint01A.add c8Color_Tint01A_05
Tint01A.add c8Color_Tint01A_06
Tint01A.add c8Color_Tint01A_07
Tint01A.add c8Color_Tint01A_08
Set Tint02 = New Collection
Tint02.add c8Color_Tint02_01
Tint02.add c8Color_Tint02_02
Tint02.add c8Color_Tint02_03
Tint02.add c8Color_Tint02_04
Tint02.add c8Color_Tint02_05
Tint02.add c8Color_Tint02_06
Tint02.add c8Color_Tint02_07
Tint02.add c8Color_Tint02_08
Set Tint02A = New Collection
Tint02A.add c8Color_Tint02A_01
Tint02A.add c8Color_Tint02A_02
Tint02A.add c8Color_Tint02A_03
Tint02A.add c8Color_Tint02A_04
Tint02A.add c8Color_Tint02A_05
Tint02A.add c8Color_Tint02A_06
Tint02A.add c8Color_Tint02A_07
Tint02A.add c8Color_Tint02A_08
Set Shade01 = New Collection
Shade01.add c8Color_Shade01_01
Shade01.add c8Color_Shade01_02
Shade01.add c8Color_Shade01_03
Shade01.add c8Color_Shade01_04
Shade01.add c8Color_Shade01_05
Shade01.add c8Color_Shade01_06
Shade01.add c8Color_Shade01_07
Shade01.add c8Color_Shade01_08
Set Shade01A = New Collection
Shade01A.add c8Color_Shade01A_01
Shade01A.add c8Color_Shade01A_02
Shade01A.add c8Color_Shade01A_03
Shade01A.add c8Color_Shade01A_04
Shade01A.add c8Color_Shade01A_05
Shade01A.add c8Color_Shade01A_06
Shade01A.add c8Color_Shade01A_07
Shade01A.add c8Color_Shade01A_08
Set Shade02 = New Collection
Shade02.add c8Color_Shade02_01
Shade02.add c8Color_Shade02_02
Shade02.add c8Color_Shade02_03
Shade02.add c8Color_Shade02_04
Shade02.add c8Color_Shade02_05
Shade02.add c8Color_Shade02_06
Shade02.add c8Color_Shade02_07
Shade02.add c8Color_Shade02_08
Set Shade02A = New Collection
Shade02A.add c8Color_Shade02A_01
Shade02A.add c8Color_Shade02A_02
Shade02A.add c8Color_Shade02A_03
Shade02A.add c8Color_Shade02A_04
Shade02A.add c8Color_Shade02A_05
Shade02A.add c8Color_Shade02A_06
Shade02A.add c8Color_Shade02A_07
Shade02A.add c8Color_Shade02A_08
Set Tone01 = New Collection
Tone01.add c8Color_Tone01_01
Tone01.add c8Color_Tone01_02
Tone01.add c8Color_Tone01_03
Tone01.add c8Color_Tone01_04
Tone01.add c8Color_Tone01_05
Tone01.add c8Color_Tone01_06
Tone01.add c8Color_Tone01_07
Tone01.add c8Color_Tone01_08
Set Tone01A = New Collection
Tone01A.add c8Color_Tone01A_01
Tone01A.add c8Color_Tone01A_02
Tone01A.add c8Color_Tone01A_03
Tone01A.add c8Color_Tone01A_04
Tone01A.add c8Color_Tone01A_05
Tone01A.add c8Color_Tone01A_06
Tone01A.add c8Color_Tone01A_07
Tone01A.add c8Color_Tone01A_08
Set Tone02 = New Collection
Tone02.add c8Color_Tone02_01
Tone02.add c8Color_Tone02_02
Tone02.add c8Color_Tone02_03
Tone02.add c8Color_Tone02_04
Tone02.add c8Color_Tone02_05
Tone02.add c8Color_Tone02_06
Tone02.add c8Color_Tone02_07
Tone02.add c8Color_Tone02_08
Set Tone02A = New Collection
Tone02A.add c8Color_Tone02A_01
Tone02A.add c8Color_Tone02A_02
Tone02A.add c8Color_Tone02A_03
Tone02A.add c8Color_Tone02A_04
Tone02A.add c8Color_Tone02A_05
Tone02A.add c8Color_Tone02A_06
Tone02A.add c8Color_Tone02A_07
Tone02A.add c8Color_Tone02A_08
Set TextOnWhite01 = New Collection
TextOnWhite01.add c8Color_TextOnWhite01_01
TextOnWhite01.add c8Color_TextOnWhite01_02
TextOnWhite01.add c8Color_TextOnWhite01_03
TextOnWhite01.add c8Color_TextOnWhite01_04
TextOnWhite01.add c8Color_TextOnWhite01_05
TextOnWhite01.add c8Color_TextOnWhite01_06
TextOnWhite01.add c8Color_TextOnWhite01_07
TextOnWhite01.add c8Color_TextOnWhite01_08
Set TextOnWhite01A = New Collection
TextOnWhite01A.add c8Color_TextOnWhite01A_01
TextOnWhite01A.add c8Color_TextOnWhite01A_02
TextOnWhite01A.add c8Color_TextOnWhite01A_03
TextOnWhite01A.add c8Color_TextOnWhite01A_04
TextOnWhite01A.add c8Color_TextOnWhite01A_05
TextOnWhite01A.add c8Color_TextOnWhite01A_06
TextOnWhite01A.add c8Color_TextOnWhite01A_07
TextOnWhite01A.add c8Color_TextOnWhite01A_08
Set ColorsAndGrey01 = New Collection
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_01
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_01
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_02
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_02
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_03
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_03
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_04
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_04
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_05
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_05
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_06
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_06
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_07
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_07
ColorsAndGrey01.add c8Color_ColorsAndGrey01_X_08
ColorsAndGrey01.add c8Color_ColorsAndGrey01_Y_08
Set ColorsAndGrey01A = New Collection
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_01
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_01
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_02
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_02
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_03
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_03
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_04
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_04
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_05
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_05
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_06
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_06
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_07
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_07
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_X_08
ColorsAndGrey01A.add c8Color_ColorsAndGrey01A_Y_08
Set Multicolor01 = New Collection
Multicolor01.add c8Color_Multicolor01_X_01
Multicolor01.add c8Color_Multicolor01_Y_01
Multicolor01.add c8Color_Multicolor01_X_02
Multicolor01.add c8Color_Multicolor01_Y_02
Multicolor01.add c8Color_Multicolor01_X_03
Multicolor01.add c8Color_Multicolor01_Y_03
Multicolor01.add c8Color_Multicolor01_X_04
Multicolor01.add c8Color_Multicolor01_Y_04
Multicolor01.add c8Color_Multicolor01_X_05
Multicolor01.add c8Color_Multicolor01_Y_05
Multicolor01.add c8Color_Multicolor01_X_06
Multicolor01.add c8Color_Multicolor01_Y_06
Multicolor01.add c8Color_Multicolor01_X_07
Multicolor01.add c8Color_Multicolor01_Y_07
Multicolor01.add c8Color_Multicolor01_X_08
Multicolor01.add c8Color_Multicolor01_Y_08
Set Multicolor01A = New Collection
Multicolor01A.add c8Color_Multicolor01A_X_01
Multicolor01A.add c8Color_Multicolor01A_Y_01
Multicolor01A.add c8Color_Multicolor01A_X_02
Multicolor01A.add c8Color_Multicolor01A_Y_02
Multicolor01A.add c8Color_Multicolor01A_X_03
Multicolor01A.add c8Color_Multicolor01A_Y_03
Multicolor01A.add c8Color_Multicolor01A_X_04
Multicolor01A.add c8Color_Multicolor01A_Y_04
Multicolor01A.add c8Color_Multicolor01A_X_05
Multicolor01A.add c8Color_Multicolor01A_Y_05
Multicolor01A.add c8Color_Multicolor01A_X_06
Multicolor01A.add c8Color_Multicolor01A_Y_06
Multicolor01A.add c8Color_Multicolor01A_X_07
Multicolor01A.add c8Color_Multicolor01A_Y_07
Multicolor01A.add c8Color_Multicolor01A_X_08
Multicolor01A.add c8Color_Multicolor01A_Y_08
End Sub
Public Function WCAGRelativeLuminance(xColor As Long) As Single
Dim RsRGB As Double
Dim GsRGB As Double
Dim BsRGB As Double
Dim R As Double
Dim G As Double
Dim B As Double
RsRGB = GetRGB(xColor, 1) / 255
GsRGB = GetRGB(xColor, 2) / 255
BsRGB = GetRGB(xColor, 3) / 255
If RsRGB <= 0.03928 Then
R = RsRGB / 12.92
Else
R = ((RsRGB + 0.055) / 1.055) ^ 2.4
End If
If GsRGB <= 0.03928 Then
G = GsRGB / 12.92
Else
G = ((GsRGB + 0.055) / 1.055) ^ 2.4
End If
If BsRGB <= 0.03928 Then
B = BsRGB / 12.92
Else
B = ((BsRGB + 0.055) / 1.055) ^ 2.4
End If
WCAGRelativeLuminance = 0.2126 * R + 0.7152 * G + 0.0722 * B
End Function
Public Function WCAGColorContrast(xColor1 As Long, xColor2 As Long) As Single
Dim luminance_1 As Single
Dim luminance_2 As Single
luminance_1 = WCAGRelativeLuminance(xColor1)
luminance_2 = WCAGRelativeLuminance(xColor2)
WCAGColorContrast = (BMax(luminance_1, luminance_2) + 0.05) / (BMin(luminance_1, luminance_2) + 0.05)
End Function
Public Function GetContrastingColor(xColor As Long) As Long
Dim whiteRequired As Boolean
whiteRequired = WCAGColorContrast(xColor, wdColorWhite) >= WCAGColorContrast(xColor, wdColorBlack)
If whiteRequired Then
GetContrastingColor = wdColorWhite
Else
GetContrastingColor = wdColorBlack
End If
End Function
Public Function GetRGB(RGBval As Long, Num As Integer) As Integer
If Num > 0 And Num < 4 And RGBval > -1 And RGBval < 16777216 Then
GetRGB = RGBval \ 256 ^ (Num - 1) And 255
Else
GetRGB = True
End If
End Function
Public Function ColorToString(xColor As Long) As String
If xColor = wdColorAutomatic Then
ColorToString = "0000"
Else
ColorToString = "1" & StrConv(GetRGBAll(xColor), vbUnicode)
End If
End Function
Public Function ColorFromString(xColorString As String) As Long
Dim RGBarray() As Byte
If Left$(xColorString, 1) = "0" Then
ColorFromString = wdColorAutomatic
Else
RGBarray = StrConv(Right$(xColorString, 3), vbFromUnicode)
ColorFromString = RGB(RGBarray(0), RGBarray(1), RGBarray(2))
End If
End Function
Public Function GetRGBAll(xColor As Long) As Variant
Dim RGBarray(0 To 2) As Byte
RGBarray(0) = GetRGB(xColor, 1)
RGBarray(1) = GetRGB(xColor, 2)
RGBarray(2) = GetRGB(xColor, 3)
GetRGBAll = RGBarray
End Function
Attribute VB_Name = "clsDocDescriptor"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private Const maxColumns As Long = 15
Private c8CaseRef As String
Private c8ColumnHeading(1 To maxColumns)  As String
Private c8ColumnCount As Long
Private c8ColumnEndDate As Long
Private c8ColumnEndTime As Long
Private c8ColumnSequence As Long
Private c8ColumnSource As Long
Private c8ColumnStartDate As Long
Private c8ColumnStartTime As Long
Private c8ColumnGlossary As Long
Private c8ContainsErrors As Boolean
Private c8Doc As Document
Private c8DocCreator As String
Private c8DocType As Long
Private c8GlossaryAdministrator As String
Private c8GlossaryUser As String
Private c8GlossaryProcessing As String
Private c8MandatoryColumns As Long
Private c8SortOrder As String
Private c8SourcePrefixes As String
Private c8TablesHash1 As String
Private c8TablesHash2 As String
Private c8Version As String
Private c8VersionLowestCanImportInto As String
Private stringDumpSeparator As String
Public Property Let caseRef(xCaseRef As String)
c8CaseRef = xCaseRef
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8CaseRef", xValue:=c8CaseRef)
End If
End Property
Public Property Get caseRef() As String
caseRef = c8CaseRef
End Property
Public Property Let columnHeading(xColNo As Long, xColumnHeading As String)
c8ColumnHeading(xColNo) = xColumnHeading
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8Col" & xColNo & "Text", xValue:=c8ColumnHeading(xColNo))
End If
End Property
Public Property Get columnHeading(xColNo As Long) As String
columnHeading = c8ColumnHeading(xColNo)
End Property
Public Property Let columnCount(xColumnCount As Long)
c8ColumnCount = xColumnCount
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnCount", xValue:=c8ColumnCount)
End If
End Property
Public Property Get columnCount() As Long
columnCount = BMax(0, c8ColumnCount)
End Property
Public Property Let columnEndDate(xColumnEndDate As Long)
c8ColumnEndDate = xColumnEndDate
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnEndDate", xValue:=c8ColumnEndDate)
End If
End Property
Public Property Get columnEndDate() As Long
columnEndDate = BMax(0, c8ColumnEndDate)
End Property
Public Property Let columnEndTime(xColumnEndTime As Long)
c8ColumnEndTime = xColumnEndTime
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnEndTime", xValue:=c8ColumnEndTime)
End If
End Property
Public Property Get columnEndTime() As Long
columnEndTime = BMax(0, c8ColumnEndTime)
End Property
Public Property Let columnSource(xColumnSource As Long)
c8ColumnSource = xColumnSource
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnSource", xValue:=c8ColumnSource)
End If
End Property
Public Property Get columnSource() As Long
columnSource = BMax(0, c8ColumnSource)
End Property
Public Property Let columnSequence(xColumnSequence As Long)
c8ColumnSequence = xColumnSequence
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnSequence", xValue:=c8ColumnSequence)
End If
End Property
Public Property Get columnSequence() As Long
columnSequence = BMax(0, c8ColumnSequence)
End Property
Public Property Let columnStartDate(xColumnStartDate As Long)
c8ColumnStartDate = xColumnStartDate
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnStartDate", xValue:=c8ColumnStartDate)
End If
End Property
Public Property Get columnStartDate() As Long
columnStartDate = BMax(0, c8ColumnStartDate)
End Property
Public Property Let columnStartTime(xColumnStartTime As Long)
c8ColumnStartTime = xColumnStartTime
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnStartTime", xValue:=c8ColumnStartTime)
End If
End Property
Public Property Get columnStartTime() As Long
columnStartTime = BMax(0, c8ColumnStartTime)
End Property
Public Property Let columnGlossary(xColumnGlossary As Long)
c8ColumnGlossary = xColumnGlossary
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ColumnGlossary", xValue:=c8ColumnGlossary)
End If
End Property
Public Property Get columnGlossary() As Long
columnGlossary = BMax(0, c8ColumnGlossary)
End Property
Public Property Let doc(xDoc As Document)
Set c8Doc = xDoc
End Property
Public Property Get doc() As Document
Set doc = c8Doc
End Property
Public Property Let docCreator(xdocCreator As String)
c8DocCreator = xdocCreator
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8docCreator", xValue:=c8DocCreator)
End If
End Property
Public Property Get docCreator() As String
docCreator = c8DocCreator
End Property
Public Property Let docType(xDocType As Long)
c8DocType = xDocType
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8DocType", xValue:=c8DocType)
End If
End Property
Public Property Get docType() As Long
docType = c8DocType
End Property
Public Property Let mandatoryColumns(xMandatoryColumns As Long)
c8MandatoryColumns = xMandatoryColumns
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8MandatoryColumns", xValue:=c8MandatoryColumns)
End If
End Property
Public Property Get mandatoryColumns() As Long
mandatoryColumns = BMax(0, c8MandatoryColumns)
End Property
Public Property Let version(xVersion As String)
c8Version = xVersion
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8Version", xValue:=c8Version)
End If
End Property
Public Property Get version() As String
version = c8Version
End Property
Public Property Let versionLowestCanImportInto(xVersion As String)
c8VersionLowestCanImportInto = xVersion
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8VersionLowestCanImportInto", xValue:=c8VersionLowestCanImportInto)
End If
End Property
Public Property Get versionLowestCanImportInto() As String
versionLowestCanImportInto = c8VersionLowestCanImportInto
End Property
Public Property Let glossaryAdmin(xGlossaryAdmin As String)
c8GlossaryAdministrator = xGlossaryAdmin
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8GlossaryAdministrator", xValue:=c8GlossaryAdministrator)
End If
End Property
Public Property Get glossaryAdmin() As String
glossaryAdmin = c8GlossaryAdministrator
End Property
Public Property Let glossaryUser(xGlossaryUser As String)
c8GlossaryUser = xGlossaryUser
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8GlossaryUser", xValue:=c8GlossaryUser)
End If
End Property
Public Property Get glossaryUser() As String
glossaryUser = c8GlossaryUser
End Property
Public Property Let glossaryProcessing(xGlossaryProcessing As String)
c8GlossaryProcessing = xGlossaryProcessing
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8GlossaryProcessing", xValue:=c8GlossaryProcessing)
End If
End Property
Public Property Get glossaryProcessing() As String
glossaryProcessing = c8GlossaryProcessing
End Property
Public Property Let sortOrder(xSortOrder As String)
c8SortOrder = xSortOrder
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8SortOrder", xValue:=c8SortOrder)
End If
End Property
Public Property Get sortOrder() As String
sortOrder = c8SortOrder
End Property
Public Property Let containsErrors(xContainsErrors As Boolean)
c8ContainsErrors = xContainsErrors
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8ContainsErrors", xValue:=c8ContainsErrors)
End If
End Property
Public Property Get containsErrors() As Boolean
containsErrors = c8ContainsErrors
End Property
Public Property Let tablesHash1(xTablesHash As String)
c8TablesHash1 = xTablesHash
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8TablesHash1", xValue:=c8TablesHash1)
End If
End Property
Public Property Get tablesHash1() As String
tablesHash1 = c8TablesHash1
End Property
Public Property Let tablesHash2(xTablesHash As String)
c8TablesHash2 = xTablesHash
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8Tableshash2", xValue:=c8TablesHash2)
End If
End Property
Public Property Get tablesHash2() As String
tablesHash2 = c8TablesHash2
End Property
Public Property Let sourcePrefixes(xSourcePrefixes As String)
c8SourcePrefixes = xSourcePrefixes
If c8Doc Is Nothing Then
Else
Call BWordDocumentVariableSet(xDoc:=c8Doc, xName:="c8SourcePrefixes", xValue:=c8SourcePrefixes)
End If
End Property
Public Property Get sourcePrefixes() As String
sourcePrefixes = c8SourcePrefixes
End Property
Public Property Get firstGeneralHeadingIndex() As Long
If c8ColumnGlossary > 0 Then
firstGeneralHeadingIndex = c8ColumnGlossary + 1
Else
firstGeneralHeadingIndex = c8ColumnSource + 1
End If
End Property
Public Property Get defaultCaseRef() As String
defaultCaseRef = format$(Now, "dd mmm yyyy hh:mm")
End Property
Public Sub setDetails(xDoc As Document)
Dim cProp As Variable
Dim i As Long
For Each cProp In xDoc.Variables
If Left$(cProp.name, 2) = "c8" And Left$(cProp.name, 9) <> "c8Licence" Then
cProp.Delete
End If
Next cProp
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8CaseRef", xValue:=c8CaseRef)
For i = 1 To maxColumns
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8Col" & i & "Text", xValue:=c8ColumnHeading(i))
Next i
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnCount", xValue:=c8ColumnCount)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnEndDate", xValue:=c8ColumnEndDate)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnEndTime", xValue:=c8ColumnEndTime)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnSequence", xValue:=c8ColumnSequence)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnSource", xValue:=c8ColumnSource)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnStartDate", xValue:=c8ColumnStartDate)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnStartTime", xValue:=c8ColumnStartTime)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8DocCreator", xValue:=docCreator)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8DocType", xValue:=c8DocType)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8MandatoryColumns", xValue:=c8MandatoryColumns)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8Version", xValue:=c8Version)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8VersionLowestCanImportInto", xValue:=c8VersionLowestCanImportInto)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8GlossaryAdministrator", xValue:=c8GlossaryAdministrator)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8GlossaryUser", xValue:=c8GlossaryUser)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8GlossaryProcessing", xValue:=c8GlossaryProcessing)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ColumnGlossary", xValue:=c8ColumnGlossary)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8SortOrder", xValue:=c8SortOrder)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8ContainsErrors", xValue:=c8ContainsErrors)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8TablesHash1", xValue:=c8TablesHash1)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8TablesHash2", xValue:=c8TablesHash2)
Call BWordDocumentVariableSet(xDoc:=xDoc, xName:="c8SourcePrefixes", xValue:=c8SourcePrefixes)
End Sub
Public Sub getDetails(xDoc As Document)
Dim i  As Long
c8CaseRef = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8CaseRef", xDefault:="")
For i = 1 To maxColumns
c8ColumnHeading(i) = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8Col" & i & "Text", xDefault:="")
Next i
c8ColumnCount = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnCount", xDefault:=0)
c8ColumnEndDate = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnEndDate", xDefault:=0)
c8ColumnEndTime = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnEndTime", xDefault:=0)
c8ColumnSequence = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnSequence", xDefault:=0)
c8ColumnSource = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnSource", xDefault:=0)
c8ColumnStartDate = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnStartDate", xDefault:=0)
c8ColumnStartTime = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnStartTime", xDefault:=0)
c8DocCreator = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8DocCreator", xDefault:="")
c8DocType = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8DocType", xDefault:=0)
c8MandatoryColumns = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8MandatoryColumns", xDefault:=0)
c8Version = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8Version", xDefault:="")
c8VersionLowestCanImportInto = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8VersionLowestCanImportInto", xDefault:="")
c8GlossaryAdministrator = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8GlossaryAdministrator", xDefault:="")
c8GlossaryUser = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8GlossaryUser", xDefault:="")
c8GlossaryProcessing = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8GlossaryProcessing", xDefault:="")
c8ColumnGlossary = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ColumnGlossary", xDefault:=0)
c8SortOrder = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8SortOrder", xDefault:="")
c8ContainsErrors = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8ContainsErrors", xDefault:=False)
c8TablesHash1 = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8TablesHash1", xDefault:="")
c8TablesHash2 = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8TablesHash2", xDefault:="")
c8SourcePrefixes = BWordDocumentVariableGet(xDoc:=xDoc, xName:="c8SourcePrefixes", xDefault:="")
End Sub
Public Sub initialise(xDefaults As Boolean)
Dim i  As Long
c8CaseRef = ""
For i = 1 To maxColumns
c8ColumnHeading(i) = ""
Next i
c8ColumnCount = 0
c8ColumnEndDate = 0
c8ColumnEndTime = 0
c8ColumnSequence = 0
c8ColumnSource = 0
c8ColumnStartDate = 0
c8ColumnStartTime = 0
c8DocCreator = ""
c8DocType = 0
c8MandatoryColumns = 0
c8Version = ""
c8VersionLowestCanImportInto = ""
c8GlossaryAdministrator = ""
c8GlossaryUser = ""
c8GlossaryProcessing = ""
c8ColumnGlossary = 0
c8SortOrder = ""
c8ContainsErrors = False
c8TablesHash1 = ""
c8TablesHash2 = ""
c8SourcePrefixes = ""
If xDefaults Then
c8CaseRef = Me.defaultCaseRef
c8ColumnHeading(1) = "Date"
c8ColumnHeading(2) = "Time"
c8ColumnHeading(3) = "Source of Information"
c8ColumnHeading(4) = "Family Contact - Child"
c8ColumnHeading(5) = "Family Contact - Adult"
c8ColumnHeading(6) = "Communication - within agency"
c8ColumnHeading(7) = "Communication - external to agency"
c8ColumnHeading(8) = "Response or Outcome"
c8ColumnHeading(9) = "Comments"
c8ColumnCount = 9
c8ColumnStartDate = 1
c8ColumnStartTime = 2
c8ColumnSource = 3
c8MandatoryColumns = 10
End If
End Sub
Public Function validate() As String
Dim out As String
Dim i As Long
Dim usedCols As Long
Dim firstBlankCol As Long
Dim specialColumns(1 To 7) As String
On Error GoTo errorOut
out = ""
specialColumns(1) = CStr(columnSequence)
specialColumns(2) = CStr(columnStartDate)
specialColumns(3) = CStr(columnStartTime)
specialColumns(4) = CStr(columnEndDate)
specialColumns(5) = CStr(columnEndTime)
specialColumns(6) = CStr(columnSource)
specialColumns(7) = CStr(columnGlossary)
Select Case c8ColumnSequence
Case Is < 0
out = addError("ColumnSequence negative", out)
Case Is > 0
If Len(c8ColumnHeading(c8ColumnSequence)) = 0 Then
out = addError("SequenceHeading Blank", out)
End If
If UBound(filter(specialColumns, CStr(c8ColumnSequence))) > 0 Then
out = addError("ColumnSequence dup", out)
End If
End Select
If c8ColumnStartDate < 1 Then
out = addError("ColumnStartDate zero or negative", out)
Else
If Len(c8ColumnHeading(c8ColumnStartDate)) = 0 Then
out = addError("StartDateHeading Blank", out)
End If
If UBound(filter(specialColumns, CStr(c8ColumnStartDate))) > 0 Then
out = addError("ColumnStartDate dup", out)
End If
End If
Select Case c8ColumnStartTime
Case Is < 0
out = addError("ColumnStartTime negative", out)
Case Is > 0
If Len(c8ColumnHeading(c8ColumnStartTime)) = 0 Then
out = addError("StartTimeHeading Blank", out)
End If
If UBound(filter(specialColumns, CStr(columnStartTime))) > 0 Then
out = addError("ColumnStartTime dup", out)
End If
End Select
Select Case c8ColumnEndDate
Case Is < 0
out = addError("ColumnEndDate negative", out)
Case Is > 0
If Len(c8ColumnHeading(c8ColumnEndDate)) = 0 Then
out = addError("EndDateHeading Blank", out)
End If
If UBound(filter(specialColumns, CStr(c8ColumnEndDate))) > 0 Then
out = addError("ColumnEndDate dup", out)
End If
End Select
Select Case c8ColumnEndTime
Case Is < 0
out = addError("ColumnEndTime negative", out)
Case Is > 0
If Len(c8ColumnHeading(c8ColumnEndTime)) = 0 Then
out = addError("EndTimeHeading Blank", out)
End If
If UBound(filter(specialColumns, CStr(c8ColumnEndTime))) > 0 Then
out = addError("ColumnEndTime dup", out)
End If
End Select
If c8ColumnSource < 1 Then
out = addError("ColumnSource zero or negative", out)
Else
If Len(c8ColumnHeading(c8ColumnSource)) = 0 Then
out = addError("SourceHeading Blank", out)
End If
If UBound(filter(specialColumns, CStr(c8ColumnSource))) > 0 Then
out = addError("ColumnSource dup", out)
End If
End If
Select Case c8ColumnGlossary
Case Is < 0
out = addError("ColumnGlossary negative", out)
Case Is > 0
If Len(c8ColumnHeading(c8ColumnGlossary)) = 0 Then
out = addError("GlossaryHeading Blank", out)
End If
If UBound(filter(specialColumns, CStr(c8ColumnGlossary))) > 0 Then
out = addError("ColumnGlossary dup", out)
End If
End Select
For i = LBound(c8ColumnHeading) To UBound(c8ColumnHeading)
If Len(c8ColumnHeading(i)) = 0 Then
If BBitIsSet(i, c8MandatoryColumns) Then
out = addError("MandatoryColumn" & i & "Heading Blank", out)
End If
End If
Next i
For i = LBound(c8ColumnHeading) To UBound(c8ColumnHeading)
If Len(c8ColumnHeading(i)) = 0 Then Exit For
Next i
usedCols = i - 1
firstBlankCol = i
For i = firstBlankCol To UBound(c8ColumnHeading)
If Len(c8ColumnHeading(i)) <> 0 Then out = addError("DiscontinuousHeadingsAt " & i, out)
Next i
If usedCols <> c8ColumnCount Then
out = addError("UsedCols " & usedCols & " DescriptorCols " & c8ColumnCount, out)
End If
GoTo cleanEnd
errorOut:
out = addError("Error " & Err.Num & "in validation", out)
cleanEnd:
validate = out
End Function
Public Sub dumpToDebug()
Dim i  As Long
MsgBox "Dumping document descriptor"
Debug.Print ">>>>>>>>>>>>>>>>>>>>>>> document descriptor begins"
Debug.Print "c8CaseRef :  " & c8CaseRef
For i = 1 To maxColumns
Debug.Print "c8Col" & i & "Text:  " & c8ColumnHeading(i)
Next i
Debug.Print "c8ColumnCount:  " & c8ColumnCount
Debug.Print "c8ColumnEndDate:  " & c8ColumnEndDate
Debug.Print "c8ColumnEndTime :  " & c8ColumnEndTime
Debug.Print "c8ColumnSequence :  " & c8ColumnSequence
Debug.Print "c8ColumnSource :  " & c8ColumnSource
Debug.Print "c8ColumnStartDate :  " & c8ColumnStartDate
Debug.Print "c8ColumnStartTime :  " & c8ColumnStartTime
Debug.Print "c8ColumnGlossary :  " & c8ColumnGlossary
Debug.Print "c8ContainsErrors  :  " & c8ContainsErrors
If c8Doc Is Nothing Then
Else
Debug.Print "c8Doc  :  " & c8Doc.fullName
End If
Debug.Print "c8DocCreator :  " & c8DocCreator
Debug.Print "c8DocType :  " & c8DocType
Debug.Print "c8GlossaryAdministrator :  " & c8GlossaryAdministrator
Debug.Print "c8GlossaryUser :  " & c8GlossaryUser
Debug.Print "c8GlossaryProcessing :  " & c8GlossaryProcessing
Debug.Print "c8MandatoryColumns :  " & c8MandatoryColumns
Debug.Print "c8SortOrder  :  " & c8SortOrder
Debug.Print "c8SourcePrefixes :  " & c8SourcePrefixes
Debug.Print "c8TablesHash1  :  " & c8TablesHash1
Debug.Print "c8TablesHash2  :  " & c8TablesHash2
Debug.Print "c8Version :  " & c8Version
Debug.Print "c8VersionLowestCanImportInto :  " & c8VersionLowestCanImportInto
End Sub
Public Function dumpToString() As String
Dim i  As Long
Dim out As String
out = c8CaseRef & stringDumpSeparator
For i = 1 To maxColumns
out = out & c8ColumnHeading(i) & stringDumpSeparator
Next i
out = out & CStr(c8ColumnCount) & stringDumpSeparator
out = out & CStr(c8ColumnEndDate) & stringDumpSeparator
out = out & CStr(c8ColumnEndTime) & stringDumpSeparator
out = out & CStr(c8ColumnSequence) & stringDumpSeparator
out = out & CStr(c8ColumnSource) & stringDumpSeparator
out = out & CStr(c8ColumnStartDate) & stringDumpSeparator
out = out & CStr(c8ColumnStartTime) & stringDumpSeparator
out = out & CStr(c8ContainsErrors) & stringDumpSeparator
If c8Doc Is Nothing Then
Else
out = out & c8Doc.fullName
End If
out = out & stringDumpSeparator
out = out & c8DocCreator & stringDumpSeparator
out = out & CStr(c8DocType) & stringDumpSeparator
out = out & c8GlossaryAdministrator & stringDumpSeparator
out = out & c8GlossaryUser & stringDumpSeparator
out = out & c8GlossaryProcessing & stringDumpSeparator
out = out & CStr(c8MandatoryColumns) & stringDumpSeparator
out = out & c8SortOrder & stringDumpSeparator
out = out & c8SourcePrefixes & stringDumpSeparator
out = out & c8TablesHash1 & stringDumpSeparator
out = out & c8TablesHash2 & stringDumpSeparator
out = out & c8Version & stringDumpSeparator
out = out & c8VersionLowestCanImportInto & stringDumpSeparator
out = out & c8ColumnGlossary & stringDumpSeparator
dumpToString = out
End Function
Public Sub loadFromString(descriptorDump As String, Optional xShowFailureToLoadDocIDMessage As Boolean = True)
Dim i  As Long
Dim j As Long
Dim values() As String
values = Split(descriptorDump, stringDumpSeparator)
c8CaseRef = values(0)
For i = 1 To maxColumns
c8ColumnHeading(i) = values(i)
Next i
j = maxColumns + 1
c8ColumnCount = CInt(values(j))
c8ColumnEndDate = CInt(values(j + 1))
c8ColumnEndTime = CInt(values(j + 2))
c8ColumnSequence = CInt(values(j + 3))
c8ColumnSource = CInt(values(j + 4))
c8ColumnStartDate = CInt(values(j + 5))
c8ColumnStartTime = CInt(values(j + 6))
c8ContainsErrors = CBool(values(j + 7))
If Len(values(j + 8)) = 0 Then
Else
Dim zIndex As Long
zIndex = BWordGetNumericDocumentIndex(values(j + 8), xShowFailureMessage:=xShowFailureToLoadDocIDMessage)
If zIndex > -1 Then
Set c8Doc = Documents(zIndex)
End If
End If
c8DocCreator = values(j + 9)
c8DocType = CInt(values(j + 10))
c8GlossaryAdministrator = values(j + 11)
c8GlossaryUser = values(j + 12)
c8GlossaryProcessing = values(j + 13)
c8MandatoryColumns = CLng(values(j + 14))
c8SortOrder = values(j + 15)
c8SourcePrefixes = values(j + 16)
c8TablesHash1 = values(j + 17)
c8TablesHash2 = values(j + 18)
c8Version = values(j + 19)
c8VersionLowestCanImportInto = values(j + 20)
c8ColumnGlossary = CInt(values(j + 21))
End Sub
Public Function equals(xDetails As clsDocDescriptor, Optional xIncludeDoc As Boolean = False) As Boolean
Dim out As Boolean
Dim i As Long
out = False
If c8CaseRef <> xDetails.caseRef Then GoTo endFunction
If c8ColumnCount <> xDetails.columnCount Then GoTo endFunction
For i = 1 To c8ColumnCount
If c8ColumnHeading(i) <> xDetails.columnHeading(i) Then GoTo endFunction
Next i
If c8ColumnEndDate <> xDetails.columnEndDate Then GoTo endFunction
If c8ColumnEndTime <> xDetails.columnEndTime Then GoTo endFunction
If c8ColumnSequence <> xDetails.columnSequence Then GoTo endFunction
If c8ColumnSource <> xDetails.columnSource Then GoTo endFunction
If c8ColumnStartDate <> xDetails.columnStartDate Then GoTo endFunction
If c8ColumnStartTime <> xDetails.columnStartTime Then GoTo endFunction
If c8ColumnGlossary <> xDetails.columnGlossary Then GoTo endFunction
If xIncludeDoc Then
If c8Doc <> xDetails.doc Then GoTo endFunction
End If
If c8DocCreator <> xDetails.docCreator Then GoTo endFunction
If c8DocType <> xDetails.docType Then GoTo endFunction
If c8MandatoryColumns <> xDetails.mandatoryColumns Then GoTo endFunction
If c8Version <> xDetails.version Then GoTo endFunction
If c8VersionLowestCanImportInto <> xDetails.versionLowestCanImportInto Then GoTo endFunction
If c8GlossaryAdministrator <> xDetails.glossaryAdmin Then GoTo endFunction
If c8GlossaryUser <> xDetails.glossaryUser Then GoTo endFunction
If c8GlossaryProcessing <> xDetails.glossaryProcessing Then GoTo endFunction
If c8SortOrder <> xDetails.sortOrder Then GoTo endFunction
If c8ContainsErrors <> xDetails.containsErrors Then GoTo endFunction
If c8TablesHash1 <> xDetails.tablesHash1 Then GoTo endFunction
If c8TablesHash2 <> xDetails.tablesHash2 Then GoTo endFunction
If c8SourcePrefixes <> xDetails.sourcePrefixes Then GoTo endFunction
out = True
endFunction:
equals = out
End Function
Public Sub import(xDetails As clsDocDescriptor)
Dim i As Long
c8CaseRef = xDetails.caseRef
c8ColumnCount = xDetails.columnCount
For i = 1 To c8ColumnCount
c8ColumnHeading(i) = xDetails.columnHeading(i)
Next i
c8ColumnEndDate = xDetails.columnEndDate
c8ColumnEndTime = xDetails.columnEndTime
c8ColumnSequence = xDetails.columnSequence
c8ColumnSource = xDetails.columnSource
c8ColumnStartDate = xDetails.columnStartDate
c8ColumnStartTime = xDetails.columnStartTime
c8ColumnGlossary = xDetails.columnGlossary
c8DocType = xDetails.docType
c8MandatoryColumns = xDetails.mandatoryColumns
c8Version = xDetails.version
c8GlossaryAdministrator = xDetails.glossaryAdmin
c8GlossaryUser = xDetails.glossaryUser
c8GlossaryProcessing = xDetails.glossaryProcessing
c8SortOrder = xDetails.sortOrder
c8ContainsErrors = xDetails.containsErrors
c8TablesHash1 = xDetails.tablesHash1
c8TablesHash2 = xDetails.tablesHash2
c8SourcePrefixes = xDetails.sourcePrefixes
If Len(xDetails.version) = 0 Then
Else
If CSng(xDetails.version) >= 3 Then Call importVersion3AndAbove(xDetails)
End If
End Sub
Public Sub sequenceColumnAdd(xHeading As String)
Dim i As Long
If c8ColumnSequence > 0 Then
showMessage c8Msg6000, msgSuffix2:="clsDocDescriptor: Sequence Column is already defined"
Exit Sub
End If
columnSequence = 1
columnStartDate = c8ColumnStartDate + 1
If c8ColumnStartTime > 0 Then columnStartTime = c8ColumnStartTime + 1
If c8ColumnEndDate > 0 Then columnEndDate = c8ColumnEndDate + 1
If c8ColumnEndTime > 0 Then columnEndTime = c8ColumnEndTime + 1
columnSource = c8ColumnSource + 1
If c8ColumnGlossary > 0 Then columnGlossary = c8ColumnGlossary + 1
columnCount = c8ColumnCount + 1
For i = c8ColumnCount To 2 Step -1
columnHeading(i) = c8ColumnHeading(i - 1)
Next i
columnHeading(1) = xHeading
mandatoryColumns = mandatoryColumns * 2
End Sub
Public Sub sequenceColumnDelete()
Dim i As Long
If c8ColumnSequence = 0 Then
showMessage c8Msg6000, msgSuffix2:="clsDocDescriptor: Sequence Column does not exist"
Exit Sub
End If
columnSequence = 0
columnStartDate = c8ColumnStartDate - 1
If c8ColumnStartTime > 0 Then columnStartTime = c8ColumnStartTime - 1
If c8ColumnEndDate > 0 Then columnEndDate = c8ColumnEndDate - 1
If c8ColumnEndTime > 0 Then columnEndTime = c8ColumnEndTime - 1
columnSource = columnSource - 1
If c8ColumnGlossary > 0 Then columnGlossary = c8ColumnGlossary - 1
columnCount = c8ColumnCount - 1
For i = 1 To c8ColumnCount
columnHeading(i) = c8ColumnHeading(i + 1)
Next i
columnHeading(c8ColumnCount + 1) = ""
mandatoryColumns = mandatoryColumns / 2
End Sub
Private Sub importVersion3AndAbove(xDetails As clsDocDescriptor)
c8DocCreator = xDetails.docCreator
c8VersionLowestCanImportInto = xDetails.versionLowestCanImportInto
End Sub
Private Function addError(xErr As String, xOut As String) As String
addError = xOut & "<" & xErr & ">"
End Function
Private Sub Class_Initialize()
stringDumpSeparator = Chr(141)
End Sub
Attribute VB_Name = "clsDriveMapper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private oMappedDrive As Scripting.Drive
Private oFSO As Scripting.FileSystemObject
Private oNetwork As IWshRuntimeLibrary.WshNetwork
Private Sub Class_Initialize()
Set oFSO = New Scripting.FileSystemObject
Set oNetwork = New IWshRuntimeLibrary.WshNetwork
End Sub
Private Sub Class_Terminate()
UnmapDrive
End Sub
Public Function MapDrive(NetworkPath As String) As Scripting.folder
Dim DriveLetter As String, i As Integer
On Error GoTo mapError
UnmapDrive
For i = ascZ To ascA Step -1
DriveLetter = ChrW$(i)
If Not oFSO.DriveExists(DriveLetter) Then
oNetwork.MapNetworkDrive DriveLetter & ":", NetworkPath
Set oMappedDrive = oFSO.GetDrive(DriveLetter)
Set MapDrive = oMappedDrive.RootFolder
Exit For
End If
Next i
Exit Function
mapError:
showMessage c8Msg6000, msgSuffix2:="clsDriveMapper map: Error " & Err.Number & " (" & Err.Description & ")"
End Function
Public Sub UnmapDrive()
On Error GoTo unmapError
If Not oMappedDrive Is Nothing Then
If oMappedDrive.IsReady Then
oNetwork.RemoveNetworkDrive oMappedDrive.DriveLetter & ":", force:=True
End If
Set oMappedDrive = Nothing
End If
Exit Sub
unmapError:
showMessage c8Msg6000, msgSuffix2:="clsDriveMapper: Error " & Err.Number & " (" & Err.Description & ")"
End Sub
Attribute VB_Name = "clsFindReplace"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private cls_doc As Document
Private cls_formatMatchesInBodyDefault As clsFormat
Private cls_formatMatchesCurrentDefault As clsFormat
Private cls_formatStyleNormal As clsFormat
Private cls_formatNoHighlight As clsFormat
Private cls_currentMatchIndex As Long
Private cls_matchCount As Long
Private cls_SearchHistoryStrings() As Variant
Private cls_SearchHistoryCounts() As Variant
Private cls_SearchHistoryTables() As Variant
Private Type cls_Match
rangeStart As Long
rangeEnd As Long
row As Long
table As Long
format As clsFormat
data01 As Variant
data02 As Variant
data03 As Variant
End Type
Private matches() As cls_Match
Public Property Let doc(xDoc As Document)
Set cls_doc = xDoc
End Property
Public Function matchesIdentify(Optional xString As String = "", Optional xCaptionString As String = "", Optional xRowCheckString As String = "", Optional xRowCheckPositive As Boolean = True, Optional xRowCheckColNum As Long = 0, Optional xAtStartOfColumn As Long = 0, Optional xIgnoreColumn As Long = 0, Optional xFormat As clsFormat, Optional xRange As Range, Optional xClear As Boolean = True, Optional xData01 As Variant = "", Optional xData02 As Variant = "", Optional xData03 As Variant = False, Optional xIgnoreRepeatedSpaces As Boolean = True, Optional xSortMatches As Boolean = True, Optional xMatchWildcards As Boolean = False, Optional xExtendMatchToPreviousParagraph As Boolean = False, Optional xMatchCase As Boolean = False) As String
Dim zRange As Range
Dim zString As String
Dim zText As String
Dim matchIndex As Long
Dim rangeLimit As Long
Dim matchCountAtStart As Long
Dim zLong As Long
Dim progressCounter As Long
Dim searchString As String
If xClear Then
matchIndex = 0
cls_matchCount = 0
ReDim matches(0)
ReDim cls_SearchHistoryStrings(0)
ReDim cls_SearchHistoryCounts(0)
ReDim cls_SearchHistoryTables(0)
Else
matchIndex = cls_matchCount
End If
progressCounter = 0
matchCountAtStart = cls_matchCount
ReDim Preserve matches(cls_matchCount)
Dim f As Find
If cls_doc Is Nothing Then
zText = "cls_doc not set"
GoTo findError1
End If
Set zRange = cls_doc.Content
If xRange Is Nothing Then
Else
zRange.Start = xRange.Start
zRange.End = xRange.End
End If
rangeLimit = zRange.End
Set f = zRange.Find
If xMatchWildcards Then
searchString = xString
Else
searchString = BGetWord(xString, 1)
End If
Call initialiseFindObject(xFind:=f, xString:=searchString, xFormat:=xFormat, xMatchCase:=xMatchCase, xMatchWildcards:=xMatchWildcards)
On Error GoTo findError2
If Len(xCaptionString) = 0 Then xCaptionString = xString
progressBar.Caption3 = xCaptionString & ": "
With f
Do While .Execute(Wrap:=wdFindStop)
progressCounter = progressCounter + 1
progressBar.Caption3 = xCaptionString & ": possible matches " & progressCounter
If progressBar.userCancelled Then GoTo endloop
If matchIndex = UBound(matches) Then
ReDim Preserve matches(matchIndex + 100)
End If
If zRange.Start >= rangeLimit Then GoTo endloop
If xFormat Is Nothing Then
Else
Select Case xFormat.backColor
Case wdUndefined
Case wdColorAutomatic
If zRange.Font.Shading.BackgroundPatternColor <> wdColorAutomatic Then GoTo nextFind
Case xFormat.AnyColor
If zRange.Font.Shading.BackgroundPatternColor = wdColorAutomatic Then GoTo nextFind
Case Else
If xFormat.backColor <> zRange.Font.Shading.BackgroundPatternColor Then GoTo nextFind
End Select
End If
With matches(matchIndex)
.rangeStart = zRange.Start
.rangeEnd = zRange.End
Set .format = New clsFormat
.format.getFormat zRange, cls_doc
If VarType(xData01) = vbObject Then
Dim zF1 As clsFormat
Set zF1 = xData01
Dim zF2 As clsFormat
Set zF2 = New clsFormat
zF2.copy zF1
Set .data01 = zF2
Else
.data01 = xData01
End If
.data02 = xData02
.data03 = xData03
End With
zLong = BWordRangeTableIndex(matchRangeFromIndex(matchIndex), cls_doc)
If zLong > 0 Then
matches(matchIndex).row = matchRangeFromIndex(matchIndex).Information(wdStartOfRangeRowNumber)
matches(matchIndex).table = zLong
If xIgnoreColumn > 0 Then
If excludeColumn(matchIndex, xIgnoreColumn) Then GoTo nextFind
End If
If xAtStartOfColumn > 0 Then
If Not atStartOfColumn(matchIndex, xAtStartOfColumn) Then GoTo nextFind
End If
If xRowCheckString > "" Then
If Not filterByRowText(matchIndex, xRowCheckString, xRowCheckColNum, xRowCheckPositive) Then GoTo nextFind
End If
End If
If xAtStartOfColumn < 0 Then
Dim zrange2 As Range
Set zrange2 = cls_doc.Range(matches(matchIndex).rangeStart - 1, matches(matchIndex).rangeStart)
If zrange2.text = BWordTableCellSeparator Then
zrange2.Start = BMax(1, zrange2.Start - 200)
zString = zrange2.text
zLong = BInstrRev(zString, vbCr)
If zLong = 0 Then
GoTo nextFind
Else
If BCountCharacters((Mid$(zString, zLong)), BWordTableCellSeparator) = -xAtStartOfColumn - 1 Then
Else
GoTo nextFind
End If
End If
Else
GoTo nextFind
End If
End If
If Len(BGetWord(xString, 2)) = 0 Or xMatchWildcards Then
If xExtendMatchToPreviousParagraph Then
matches(matchIndex).rangeStart = getMatchRange(matches(matchIndex)).Paragraphs(1).Range.Start
End If
matchIndex = matchIndex + 1
Else
matchIndex = matchIndex + extendSearch(xString, matchIndex, xFormat, xIgnoreRepeatedSpaces, xMatchCase)
End If
nextFind:
Loop
End With
endloop:
If matchIndex > 0 Then
cls_matchCount = matchIndex
ReDim Preserve matches(matchIndex - 1)
If xClear Then
Else
If xSortMatches Then
matchesSort
End If
End If
End If
cls_SearchHistoryStrings(UBound(cls_SearchHistoryStrings)) = xString
cls_SearchHistoryCounts(UBound(cls_SearchHistoryStrings)) = cls_matchCount - matchCountAtStart
If matchIndex > 0 Then
cls_SearchHistoryTables(UBound(cls_SearchHistoryStrings)) = matches(matchIndex - 1).table
End If
zLong = UBound(cls_SearchHistoryStrings) + 1
ReDim Preserve cls_SearchHistoryStrings(zLong)
ReDim Preserve cls_SearchHistoryCounts(zLong)
ReDim Preserve cls_SearchHistoryTables(zLong)
matchesIdentify = CStr(cls_matchCount)
Exit Function
findError1:
matchesIdentify = "matchesIdentify error 1: " & zText
showMessage c8Msg6000, msgSuffix2:=matchesIdentify
Exit Function
findError2:
matchesIdentify = "matchesIdentify error 2: " & Err.Number & " - " & Err.Description
showMessage c8Msg6000, msgSuffix2:=matchesIdentify
End Function
Public Function matchesCount() As Long
matchesCount = cls_matchCount
End Function
Public Sub matchesformat(Optional xFormat As clsFormat, Optional xPropagateFore As Long = 0, Optional xPropagateBack As Long = 0, Optional xAddProgress As Double = 0)
Dim zRange As Range
Dim matchIndex As Long
Dim formatter As clsFormat
If cls_matchCount = 0 Then Exit Sub
If xFormat Is Nothing Then
Else
Set formatter = xFormat
End If
For matchIndex = 0 To UBound(matches)
With progressBar
.Caption3 = c8PBFormattingMatch & matchIndex + 1 & c8PBOf & cls_matchCount
.AddProgress xAddProgress
If .userCancelled Then Exit Sub
End With
Set zRange = matchRangeFromIndex(matchIndex)
If xFormat Is Nothing Then
If matches(matchIndex).data01 Is Nothing Then
Set formatter = matches(matchIndex).format
Else
Set formatter = matches(matchIndex).data01
End If
End If
formatter.setFormat xRange:=zRange, xDoc:=cls_doc, xPropagateFore:=xPropagateFore, xPropagateBack:=xPropagateBack
Next
End Sub
Public Sub matchesHighlightClear(Optional xAddProgress As Double = 0)
Call matchesformat$(cls_formatNoHighlight, xAddProgress:=xAddProgress)
End Sub
Public Sub matchesReplaceAllBinary(xReplaceString1 As String, xReplaceString2 As String, Optional outFormat As clsFormat)
Dim i As Long
For i = 0 To cls_matchCount - 1
If matches(i).data03 Then
matchReplace i, xReplaceString1, outFormat
Else
matchReplace i, xReplaceString2, outFormat
End If
Next
End Sub
Public Sub matchesReplaceAllWithDataField(xDataField As Long, Optional outFormat As clsFormat)
Dim i As Long
For i = 0 To cls_matchCount - 1
progressBar.Caption3 = c8PBReplacingMatch & i + 1 & c8PBOf & cls_matchCount
Select Case xDataField
Case 1
matchReplace i, CStr(matches(i).data01), outFormat
Case 2
matchReplace i, CStr(matches(i).data02), outFormat
Case Else
showMessage c8Msg6000, msgSuffix2:="matchesReplaceAllWithDataField: invalid xDataField: " & xDataField
End Select
Next
progressBar.Caption3 = ""
End Sub
Public Sub matchesSort()
Dim i As Long
Dim j As Long
Dim zMatch As cls_Match
For i = 0 To UBound(matches) - 1
progressBar.Caption3 = c8PBSortingMatch & i + 1 & c8PBOf & cls_matchCount
If progressBar.userCancelled Then Exit Sub
For j = 1 To UBound(matches)
If matches(j).rangeStart < matches(j - 1).rangeStart Then
zMatch = matches(j)
matches(j) = matches(j - 1)
matches(j - 1) = zMatch
End If
Next j
Next i
End Sub
Public Sub matchesClear()
ReDim matches(0)
ReDim cls_SearchHistoryStrings(0)
ReDim cls_SearchHistoryCounts(0)
ReDim cls_SearchHistoryTables(0)
cls_matchCount = 0
cls_currentMatchIndex = 0
End Sub
Public Function matchesRowNumbers() As Variant
Dim out() As String
Dim i As Long
Dim j As Long
ReDim out(UBound(matches))
out(0) = matches(0).table & "/" & matches(0).row
j = 0
For i = 1 To UBound(matches)
If (matches(i).table = matches(i - 1).table) And (matches(i).row = matches(i - 1).row) Then
Else
j = j + 1
out(j) = matches(i).table & "/" & matches(i).row
End If
Next i
ReDim Preserve out(j)
matchesRowNumbers = out
End Function
Public Function matchesSearchStrings() As Variant
Dim out() As String
Dim i As Long
ReDim out(UBound(cls_SearchHistoryStrings) - 1, 2)
For i = 0 To UBound(out)
out(i, 0) = cls_SearchHistoryStrings(i)
out(i, 1) = cls_SearchHistoryCounts(i)
out(i, 2) = cls_SearchHistoryTables(i)
Next i
matchesSearchStrings = out
End Function
Public Function matchesSearchStringsConsolidated() As Variant
Dim out() As String
Dim outIndex As Long
Dim maxIndex As Long
Dim zString As String
Dim searchStrings() As String
Dim searchCounts() As Long
Dim i As Long
Dim j As Long
ReDim searchStrings(UBound(cls_SearchHistoryStrings) - 1)
ReDim searchCounts(UBound(cls_SearchHistoryStrings) - 1)
outIndex = -1
maxIndex = 0
For i = 0 To UBound(cls_SearchHistoryStrings) - 1
zString = cls_SearchHistoryStrings(i)
j = BSearchArray(searchStrings, zString)
If j = -1 Then
outIndex = outIndex + 1
searchStrings(outIndex) = zString
maxIndex = outIndex
Else
outIndex = j
End If
searchCounts(outIndex) = searchCounts(outIndex) + cls_SearchHistoryCounts(i)
Next i
ReDim out(maxIndex, 1)
For i = 0 To UBound(out)
out(i, 0) = searchStrings(i)
out(i, 1) = searchCounts(i)
Next i
matchesSearchStringsConsolidated = out
End Function
Public Sub matchReplace(matchIndex As Long, xReplaceString As String, Optional outFormat As clsFormat, Optional xData03 As Boolean = False)
Dim zRange As Range
Dim adjustment As Long
Dim i As Long
If cls_matchCount = 0 Then Exit Sub
On Error GoTo matchReplaceError
Set zRange = matchRangeFromIndex(matchIndex)
adjustment = Len(xReplaceString) - (zRange.End - zRange.Start)
zRange.text = xReplaceString
If outFormat Is Nothing Then
Else
outFormat.setFormat zRange, cls_doc
End If
matches(matchIndex).data03 = xData03
If adjustment <> 0 Then
matches(matchIndex).rangeEnd = zRange.End
For i = matchIndex + 1 To cls_matchCount - 1
matches(i).rangeStart = matches(i).rangeStart + adjustment
matches(i).rangeEnd = matches(i).rangeEnd + adjustment
Next
End If
Exit Sub
matchReplaceError:
If Err.Number <> 9 Then showMessage c8Msg6000, msgSuffix2:="matchReplace: Last Error " & Err.Number & " (" & Err.Description & ")"""
End Sub
Public Sub goToMatch(matchIndex As Long)
Dim zRange As Range
If cls_matchCount = 0 Then Exit Sub
On Error GoTo goToMatchError
Set zRange = matchRangeFromIndex(cls_currentMatchIndex)
If zRange Is Nothing Then
Else
cls_formatMatchesInBodyDefault.setFontBackColor zRange, cls_doc
End If
If matchIndex > UBound(matches) Then
matchIndex = 0
Else
If matchIndex < 0 Then matchIndex = UBound(matches)
End If
Set zRange = matchRangeFromIndex(matchIndex)
cls_formatMatchesCurrentDefault.setFontBackColor zRange, cls_doc
cls_doc.ActiveWindow.ScrollIntoView zRange
Application.ScreenRefresh
cls_currentMatchIndex = matchIndex
Exit Sub
goToMatchError:
If Err.Number <> 9 Then showMessage c8Msg6000, msgSuffix2:="goToMatch: Last Error " & Err.Number & " (" & Err.Description & ")"""
End Sub
Public Sub goToFirstMatch()
goToMatch (0)
End Sub
Public Sub goToNextMatch()
goToMatch (cls_currentMatchIndex + 1)
End Sub
Public Sub goToPreviousMatch()
goToMatch (cls_currentMatchIndex - 1)
End Sub
Public Sub goToLastMatch()
goToMatch (UBound(matches))
End Sub
Public Function matchRangeFromIndex(xMatchIndex As Long) As Range
On Error GoTo matchRangeError
Set matchRangeFromIndex = getMatchRange(matches(xMatchIndex))
Exit Function
matchRangeError:
If Err.Number <> 9 Then showMessage c8Msg6000, msgSuffix2:="matchRangeFromIndex: Last Error " & Err.Number & " (" & Err.Description & ")"""
End Function
Public Function currentMatchData01() As String
On Error GoTo setNullString
currentMatchData01 = matches(cls_currentMatchIndex).data01
setNullString:
End Function
Public Function currentMatchData02() As String
On Error GoTo setNullString
currentMatchData02 = matches(cls_currentMatchIndex).data02
setNullString:
End Function
Public Function currentMatchData03() As Boolean
On Error GoTo setFalse
currentMatchData03 = matches(cls_currentMatchIndex).data03
setFalse:
End Function
Public Property Get currentMatchIndex() As Long
currentMatchIndex = cls_currentMatchIndex
End Property
Public Property Get currentMatchRange() As Range
Set currentMatchRange = getMatchRange(matches(cls_currentMatchIndex))
End Property
Public Sub initialiseFormatDefaults(xFormatStyleNormal As clsFormat, xMatchesInBodyDefault As clsFormat, xMatchesCurrentDefault As clsFormat)
cls_formatMatchesInBodyDefault.copy xMatchesInBodyDefault
cls_formatStyleNormal.copy xFormatStyleNormal
cls_formatMatchesCurrentDefault.copy xMatchesCurrentDefault
With cls_formatNoHighlight
.backColor = wdColorAutomatic
.foreColor = wdColorAutomatic
End With
End Sub
Private Function getMatchRange(xMatch As cls_Match) As Range
Set getMatchRange = cls_doc.Range(xMatch.rangeStart, xMatch.rangeEnd)
End Function
Private Function extendSearch(xString As String, xMatchIndex As Long, xFormat As clsFormat, xIgnoreRepeatedSpaces As Boolean, xMatchCase As Boolean) As Long
Dim i As Long
Dim searchStringArray() As String
Dim zRange As Range
Dim needle As String
Dim haystack As String
Dim f As Find
Set zRange = cls_doc.Range
zRange.Start = getMatchRange(matches(xMatchIndex)).Start
zRange.End = getMatchRange(matches(xMatchIndex)).End
zRange.Collapse wdCollapseEnd
searchStringArray = BGetWordArray(Trim$(xString))
For i = 1 To UBound(searchStringArray)
If BWordRangeIsInTable(zRange, cls_doc) Then
zRange.MoveEnd wdCell
zRange.End = zRange.End - 1
Else
zRange.MoveEnd wdParagraph
End If
Set f = zRange.Find
Call initialiseFindObject(xFind:=f, xString:=searchStringArray(i), xFormat:=xFormat, xMatchCase:=xMatchCase)
If f.Execute Then
zRange.Collapse wdCollapseEnd
Else
GoTo noMatch
End If
Next i
matches(xMatchIndex).rangeEnd = zRange.End
zRange.Start = matches(xMatchIndex).rangeStart
needle = Trim$(xString)
haystack = Trim$(zRange.text)
If xIgnoreRepeatedSpaces Then
needle = BSqueezeSpaces(needle)
haystack = BSqueezeSpaces(haystack)
End If
If xMatchCase Then
Else
needle = UCase$(needle)
haystack = UCase$(haystack)
End If
If BWordStandardisePunctuation(needle) <> BWordStandardisePunctuation(haystack) Then GoTo noMatch
extendSearch = 1
Exit Function
noMatch:
extendSearch = 0
End Function
Private Function atStartOfColumn(xMatchIndex As Long, xAtStartOfColumn As Long) As Boolean
Dim zRange As Range
Set zRange = getMatchRange(matches(xMatchIndex))
atStartOfColumn = (zRange.Start = zRange.rows(1).Cells(xAtStartOfColumn).Range.Start)
End Function
Private Function excludeColumn(xMatchIndex As Long, xIgnoreColumn As Long) As Boolean
Dim zRange As Range
Dim zRow As row
Set zRange = getMatchRange(matches(xMatchIndex))
Set zRow = zRange.rows(1)
If xIgnoreColumn > zRow.Cells.count Then Exit Function
If zRange.Start >= zRow.Cells(xIgnoreColumn).Range.Start Then
If zRange.End <= zRow.Cells(xIgnoreColumn).Range.End Then
excludeColumn = True
Exit Function
End If
End If
excludeColumn = False
End Function
Private Function filterByRowText(xMatchIndex As Long, xRowCheckString As String, xRowCheckColNum As Long, xRowCheckPositive As Boolean) As Boolean
Dim zRange As Range
Dim zRow As row
Dim f As Find
Set zRange = getMatchRange(matches(xMatchIndex))
Set zRow = zRange.rows(1)
If xRowCheckColNum > 0 Then
If xRowCheckColNum > zRow.Cells.count Then GoTo returnFalse
Set zRange = zRow.Cells(xRowCheckColNum).Range
Else
Set zRange = zRow.Range
End If
Set f = zRange.Find
Call initialiseFindObject(xFind:=f, xString:=xRowCheckString, xMatchCase:=False)
If f.Execute Then
GoTo returnTrue
End If
returnFalse:
filterByRowText = False
GoTo flipIt
returnTrue:
filterByRowText = True
flipIt:
If xRowCheckPositive Then
Else
filterByRowText = Not filterByRowText
End If
End Function
Private Sub initialiseFindObject(ByRef xFind As Find, xString As String, xMatchCase As Boolean, Optional xFormat As clsFormat, Optional xMatchWildcards As Boolean)
With xFind
If Len(xString) = 0 Then
.text = "<*>"
.matchWildcards = True
Else
.text = xString
.matchWildcards = xMatchWildcards
End If
.ClearFormatting
If xFormat Is Nothing Then
.format = False
Else
.format = True
.Font.Color = xFormat.foreColor
.Font.UnderlineColor = xFormat.UnderlineColor
.Font.Underline = xFormat.Underline
.Font.Bold = xFormat.Bold
.Font.Italic = xFormat.Italic
End If
.Forward = True
.Wrap = wdFindStop
.MatchCase = xMatchCase
.MatchWholeWord = True
End With
End Sub
Private Sub Class_Initialize()
Set cls_formatMatchesInBodyDefault = New clsFormat
Set cls_formatMatchesCurrentDefault = New clsFormat
Set cls_formatStyleNormal = New clsFormat
Set cls_formatNoHighlight = New clsFormat
Set cls_doc = ThisDocument
Call matchesClear
End Sub
Attribute VB_Name = "clsFormat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private cls_Version As String
Private cls_ColorManager As clsColorManagement
Private cls_UnderlineColor As Long
Private cls_Underline As Long
Private cls_Bold As Long
Private cls_Italic As Long
Private cls_ForeColor As Long
Private cls_BackColor As Long
Private cls_ForeColorCell As Long
Private cls_BackColorCellText As Long
Private cls_BackColorCell As Long
Private cls_ForeColorRow As Long
Private cls_BackColorRowText As Long
Private cls_BackColorRow As Long
Private Const cls_ColorIrrelevant As Long = 9999998
Private Const cls_PropagateToCell As Long = 1
Private Const cls_PropagateToCellText As Long = 2
Private Const cls_PropagateToRow As Long = 3
Private Const cls_PropagateToRowText As Long = 4
Public Property Get version() As String
version = cls_Version
End Property
Public Property Get backColor() As Long
backColor = cls_BackColor
End Property
Public Property Let backColor(xFormatColor As Long)
cls_BackColor = xFormatColor
End Property
Public Property Get BackColorCellText() As Long
BackColorCellText = cls_BackColorCellText
End Property
Public Property Let BackColorCellText(xBackColorCellText As Long)
cls_BackColorCellText = xBackColorCellText
End Property
Public Property Get BackColorCell() As Long
BackColorCell = cls_BackColorCell
End Property
Public Property Let BackColorCell(xBackColorCell As Long)
cls_BackColorCell = xBackColorCell
End Property
Public Property Get BackColorRowText() As Long
BackColorRowText = cls_BackColorRowText
End Property
Public Property Let BackColorRowText(xBackColorRowText As Long)
cls_BackColorRowText = xBackColorRowText
End Property
Public Property Get BackColorRow() As Long
BackColorRow = cls_BackColorRow
End Property
Public Property Let BackColorRow(xBackColorRow As Long)
cls_BackColorRow = xBackColorRow
End Property
Public Property Get foreColor() As Long
foreColor = cls_ForeColor
End Property
Public Property Let foreColor(xForeColor As Long)
cls_ForeColor = xForeColor
End Property
Public Property Get ForeColorCell() As Long
ForeColorCell = cls_ForeColorCell
End Property
Public Property Let ForeColorCell(xForeColorCell As Long)
cls_ForeColorCell = xForeColorCell
End Property
Public Property Get ForeColorRow() As Long
ForeColorRow = cls_ForeColorRow
End Property
Public Property Let ForeColorRow(xForeColorRow As Long)
cls_ForeColorRow = xForeColorRow
End Property
Public Property Get UnderlineColor() As Long
UnderlineColor = cls_UnderlineColor
End Property
Public Property Let UnderlineColor(xUnderlineColor As Long)
cls_UnderlineColor = xUnderlineColor
End Property
Public Property Get Underline() As Long
Underline = cls_Underline
End Property
Public Property Let Underline(xUnderline As Long)
cls_Underline = xUnderline
End Property
Public Property Get Bold() As Long
Bold = cls_Bold
End Property
Public Property Let Bold(xBold As Long)
cls_Bold = xBold
End Property
Public Property Get Italic() As Long
Italic = cls_Italic
End Property
Public Property Let Italic(xItalic As Long)
cls_Italic = xItalic
End Property
Public Property Get AnyColor() As Long
AnyColor = cls_ColorIrrelevant
End Property
Public Property Get PropagateToCell() As Long
PropagateToCell = cls_PropagateToCell
End Property
Public Property Get PropagateToRow() As Long
PropagateToRow = cls_PropagateToRow
End Property
Public Property Get PropagateToCellText() As Long
PropagateToCellText = cls_PropagateToCellText
End Property
Public Property Get PropagateToRowText() As Long
PropagateToRowText = cls_PropagateToRowText
End Property
Public Sub initialise(Optional xColor As Long = wdUndefined)
cls_BackColorCellText = xColor
cls_BackColorRowText = xColor
cls_BackColorCell = xColor
cls_BackColorRow = xColor
cls_ForeColor = xColor
cls_ForeColorCell = xColor
cls_ForeColorRow = xColor
cls_BackColor = xColor
cls_UnderlineColor = xColor
cls_Underline = wdUndefined
cls_Bold = wdUndefined
cls_Italic = wdUndefined
Set cls_ColorManager = New clsColorManagement
End Sub
Private Sub Class_Initialize()
Call initialise
cls_Version = "001"
End Sub
Public Function longSerialise(xLong As Long) As String
longSerialise = format$(str$(xLong), "@@@@@@@@@@@@@@@@")
End Function
Public Function longDeSerialise(xLongString As String) As Long
longDeSerialise = CLng(Trim$(xLongString))
End Function
Public Function dumpToString() As String
dumpToString = cls_Version & cls_ColorManager.ColorToString(cls_BackColorCellText) & cls_ColorManager.ColorToString(cls_BackColorRowText) & cls_ColorManager.ColorToString(cls_BackColorCell) & cls_ColorManager.ColorToString(cls_BackColorRow) & cls_ColorManager.ColorToString(cls_ForeColor) & cls_ColorManager.ColorToString(cls_ForeColorCell) & cls_ColorManager.ColorToString(cls_ForeColorRow) & cls_ColorManager.ColorToString(cls_UnderlineColor) & cls_ColorManager.ColorToString(cls_BackColor) & longSerialise(cls_Bold) & longSerialise(cls_Italic) & longSerialise(cls_Underline)
End Function
Public Sub loadFromString(highlightDump As String)
cls_Version = Left$(highlightDump, 3)
cls_BackColorCellText = cls_ColorManager.ColorFromString(Mid$(highlightDump, 4, 4))
cls_BackColorRowText = cls_ColorManager.ColorFromString(Mid$(highlightDump, 8, 4))
cls_BackColorCell = cls_ColorManager.ColorFromString(Mid$(highlightDump, 12, 4))
cls_BackColorRow = cls_ColorManager.ColorFromString(Mid$(highlightDump, 16, 4))
cls_ForeColor = cls_ColorManager.ColorFromString(Mid$(highlightDump, 20, 4))
cls_ForeColorCell = cls_ColorManager.ColorFromString(Mid$(highlightDump, 24, 4))
cls_ForeColorRow = cls_ColorManager.ColorFromString(Mid$(highlightDump, 28, 4))
cls_UnderlineColor = cls_ColorManager.ColorFromString(Mid$(highlightDump, 32, 4))
cls_BackColor = cls_ColorManager.ColorFromString(Mid$(highlightDump, 36, 4))
cls_Bold = longDeSerialise(Mid$(highlightDump, 40, 16))
cls_Italic = longDeSerialise(Mid$(highlightDump, 56, 16))
cls_Underline = longDeSerialise(Mid$(highlightDump, 72, 16))
End Sub
Public Sub copy(xFormat As clsFormat)
cls_Version = xFormat.version
cls_BackColorCellText = xFormat.BackColorCellText
cls_BackColorRowText = xFormat.BackColorRowText
cls_BackColorCell = xFormat.BackColorCell
cls_BackColorRow = xFormat.BackColorRow
cls_ForeColor = xFormat.foreColor
cls_ForeColorCell = xFormat.ForeColorCell
cls_ForeColorRow = xFormat.ForeColorRow
cls_UnderlineColor = xFormat.UnderlineColor
cls_BackColor = xFormat.backColor
cls_Bold = xFormat.Bold
cls_Italic = xFormat.Italic
cls_Underline = xFormat.Underline
End Sub
Public Sub setFontBackColor(xRange As Range, xDoc As Document)
Dim zRange As Range
If cls_BackColor = wdUndefined Then Exit Sub
Set zRange = xDoc.Content
zRange.Start = xRange.Start
zRange.End = xRange.End
With zRange
.Font.Shading.BackgroundPatternColor = cls_BackColor
End With
End Sub
Public Sub setFormat(xRange As Range, xDoc As Document, Optional xPropagateFore As Long = 0, Optional xPropagateBack As Long = 0)
Dim zRange As Range
Dim cellRange As Range
Dim rowRange As Range
Set zRange = xDoc.Content
zRange.Start = xRange.Start
zRange.End = xRange.End
If BWordRangeIsInTable(xRange, xDoc) Then
Set cellRange = xDoc.Range(zRange.Start, zRange.End)
cellRange.Expand wdCell
Set rowRange = xDoc.Range(zRange.Start, zRange.End)
rowRange.Expand wdRow
Select Case xPropagateFore
Case cls_PropagateToCellText
cellRange.Font.Color = cls_ForeColor
Case cls_PropagateToRowText
rowRange.Font.Color = cls_ForeColor
End Select
Select Case xPropagateBack
Case cls_PropagateToCellText
cellRange.Font.Shading.BackgroundPatternColor = cls_BackColor
Case cls_PropagateToCell
cellRange.Shading.BackgroundPatternColor = cls_BackColor
Case cls_PropagateToRow
rowRange.Shading.BackgroundPatternColor = cls_BackColor
Case cls_PropagateToRowText
rowRange.Font.Shading.BackgroundPatternColor = cls_BackColor
End Select
If cls_ForeColorRow <> wdUndefined Then rowRange.Font.Color = cls_ForeColorRow
If cls_ForeColorCell <> wdUndefined Then cellRange.Font.Color = cls_ForeColorCell
If cls_BackColorRowText <> wdUndefined Then rowRange.Font.Shading.BackgroundPatternColor = cls_BackColorRowText
If cls_BackColorCellText <> wdUndefined Then cellRange.Font.Shading.BackgroundPatternColor = cls_BackColorCellText
If cls_BackColorRow <> wdUndefined Then rowRange.Shading.BackgroundPatternColor = cls_BackColorRow
If cls_BackColorCell <> wdUndefined Then cellRange.Shading.BackgroundPatternColor = cls_BackColorCell
End If
With zRange
If cls_ForeColor <> wdUndefined Then .Font.Color = cls_ForeColor
If cls_UnderlineColor <> wdUndefined Then .Font.UnderlineColor = cls_UnderlineColor
If cls_Underline <> wdUndefined Then .Font.Underline = cls_Underline
If cls_Bold <> wdUndefined Then .Font.Bold = cls_Bold
If cls_Italic <> wdUndefined Then .Font.Italic = cls_Italic
If cls_BackColor <> wdUndefined Then .Font.Shading.BackgroundPatternColor = cls_BackColor
End With
End Sub
Public Sub getFormat(xRange As Range, xDoc As Document)
Dim zRange As Range
Set zRange = xDoc.Content
zRange.Start = xRange.Start
zRange.End = xRange.End
With zRange
cls_ForeColor = .Font.Color
cls_UnderlineColor = .Font.UnderlineColor
cls_Underline = .Font.Underline
cls_Bold = .Font.Bold
cls_Italic = .Font.Italic
cls_BackColor = .Font.Shading.BackgroundPatternColor
End With
End Sub
Public Function equals(xFormat As clsFormat, Optional ignoreUndefined As Boolean = False) As Boolean
If cls_BackColorCell <> xFormat.BackColorCell Then
If Not (ignoreUndefined And (xFormat.BackColorCell = wdUndefined)) Then GoTo notEquals
End If
If cls_BackColorCellText <> xFormat.BackColorCellText Then
If Not (ignoreUndefined And (xFormat.BackColorCellText = wdUndefined)) Then GoTo notEquals
End If
If cls_BackColorRow <> xFormat.BackColorRow Then
If Not (ignoreUndefined And (xFormat.BackColorRow = wdUndefined)) Then GoTo notEquals
End If
If cls_BackColorRowText <> xFormat.BackColorRowText Then
If Not (ignoreUndefined And (xFormat.BackColorRowText = wdUndefined)) Then GoTo notEquals
End If
If cls_ForeColor <> xFormat.foreColor Then
If Not (ignoreUndefined And (xFormat.foreColor = wdUndefined)) Then GoTo notEquals
End If
If cls_ForeColorCell <> xFormat.ForeColorCell Then
If Not (ignoreUndefined And (xFormat.ForeColorCell = wdUndefined)) Then GoTo notEquals
End If
If cls_ForeColorRow <> xFormat.ForeColorRow Then
If Not (ignoreUndefined And (xFormat.ForeColorRow = wdUndefined)) Then GoTo notEquals
End If
If cls_UnderlineColor <> xFormat.UnderlineColor Then
If Not (ignoreUndefined And (xFormat.UnderlineColor = wdUndefined)) Then GoTo notEquals
End If
If cls_Underline <> xFormat.Underline Then
If Not (ignoreUndefined And (xFormat.Underline = wdUndefined)) Then GoTo notEquals
End If
If cls_BackColor <> xFormat.backColor Then
If Not (ignoreUndefined And (xFormat.backColor = wdUndefined)) Then GoTo notEquals
End If
If cls_Bold <> xFormat.Bold Then
If Not (ignoreUndefined And (xFormat.Bold = wdUndefined)) Then GoTo notEquals
End If
If cls_Italic <> xFormat.Italic Then
If Not (ignoreUndefined And (xFormat.Italic = wdUndefined)) Then GoTo notEquals
End If
equals = True
Exit Function
notEquals:
equals = False
End Function
Attribute VB_Name = "clsGlossary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private glCollection As Collection
Dim glEntryStart As String
Dim glElementSeparator As String
Dim glEntryEnd As String
Dim glDelimiters As String
Dim glEntryStartV2 As String
Dim glElementSeparatorV2 As String
Dim glEntryEndV2 As String
Private Sub Class_Initialize()
Set glCollection = New Collection
glEntryStart = Chr(157)
glElementSeparator = Chr(144)
glEntryEnd = Chr(143)
glDelimiters = glEntryStart & glElementSeparator & glEntryEnd
glEntryStartV2 = Chr(255)
glElementSeparatorV2 = Chr(254)
glEntryEndV2 = Chr(253)
End Sub
Public Function appendEntry(glEntry As String) As String
On Error GoTo appendError
glCollection.add glEntry
appendEntry = glCollection.count
Exit Function
appendError:
appendEntry = "glGlossary: append error <" & glEntry & ">"
End Function
Public Function add(glKey As String, Optional glItem As String = "", Optional glPrefix As String = "", Optional glAllowDupKeys As Boolean = False, Optional glAllowDupItems As Boolean = False) As String
Dim out As String
Dim insertPos As Long
Dim xEntry As String
If stringContainsDelimeters(glKey & glItem & glPrefix) Then
out = "glGlossary: Text cannot contain delimiter character"
GoTo addEnd
End If
If glAllowDupKeys Then
Else
If containsKey(glKey) Then
out = "glGlossary: duplicate keys not allowed"
GoTo addEnd
End If
End If
If glAllowDupItems Then
Else
If containsKeyItemPair(glKey, glItem) Then
out = "glGlossary: duplicate items not allowed"
GoTo addEnd
End If
End If
xEntry = constructEntry(glKey, glItem, glPrefix)
insertPos = findInsertPosition(xEntry)
Select Case insertPos
Case 0
out = 1
glCollection.add item:=xEntry
Case Is > glCollection.count
out = glCollection.count + 1
glCollection.add item:=xEntry
Case Else
out = insertPos
glCollection.add item:=xEntry, Before:=insertPos
End Select
addEnd:
add = out
End Function
Public Function replace(glKey As String, Optional glItem As String = "", Optional glPrefix As String = "") As String
Dim i As Long
On Error GoTo replaceError
If stringContainsDelimeters(glItem & glPrefix) Then
replace = "glGlossary: Text cannot contain delimiter character"
Exit Function
End If
i = keyFindFirst(glKey, checkPresent:=True)
If i > 0 Then
glCollection.remove i
If i > glCollection.count Then
glCollection.add item:=constructEntry(glKey, glItem, glPrefix)
Else
glCollection.add item:=constructEntry(glKey, glItem, glPrefix), Before:=i
End If
replace = i
Else
replace = "glGlossary: no entry for key " & glKey
End If
Exit Function
replaceError:
replace = "glGlossary: replace error <" & glKey & ">"
End Function
Public Function remove(glKey As String, glItem As String, glPrefix As String) As String
Dim out As String
Dim xEntry As String
Dim lowKey As Long
Dim highKey As Long
Dim i As Long
out = "glGlossary: deletion candidate not found"
lowKey = keyFindFirst(glKey, checkPresent:=True)
If lowKey = 0 Then
GoTo endRemove
Else
highKey = keyFindLastMatchingIndex(lowKey)
xEntry = constructEntry(glKey, glItem, glPrefix)
End If
For i = highKey To lowKey Step -1
If glCollection(i) = xEntry Then
out = ""
glCollection.remove i
End If
Next
endRemove:
remove = out
End Function
Public Function removeKeyItemPair(glKey As String, glItem As String) As String
Dim out As String
Dim lowKey As Long
Dim highKey As Long
Dim i As Long
out = "glGlossary: deletion candidate not found"
lowKey = keyFindFirst(glKey, checkPresent:=True)
If lowKey = 0 Then
GoTo endRemove
Else
highKey = keyFindLastMatchingIndex(lowKey)
End If
For i = highKey To lowKey Step -1
If (getKey(glCollection(i)) = glKey) And (getItem(glCollection(i)) = glItem) Then
out = ""
glCollection.remove i
End If
Next
endRemove:
removeKeyItemPair = out
End Function
Public Function removeAllKeys(glKey As String) As String
Dim out As String
Dim lowKey As Long
Dim highKey As Long
Dim i As Long
lowKey = keyFindFirst(glKey, checkPresent:=True)
If lowKey = 0 Then
out = "glGlossary: deletion candidate not found"
GoTo removeEnd
End If
If lowKey = glCollection.count Then
glCollection.remove lowKey
out = ""
GoTo removeEnd
Else
highKey = keyFindLastMatchingIndex(lowKey)
End If
For i = highKey To lowKey Step -1
glCollection.remove i
out = ""
Next
removeEnd:
removeAllKeys = out
End Function
Public Sub import(glGlossary As clsGlossary, Optional glClear As Boolean = False, Optional glAllowDupKeys As Boolean = False, Optional glAllowDupItems As Boolean = False, Optional glAddPrefix As String = "")
Dim i As Long
Dim xEntry As String
If glClear Then
If glAddPrefix > "" Then
showMessage c8Msg6000, msgSuffix2:="glGlossary: glAddPrefix invalid with glClear=True"
Else
Me.clear
End If
End If
For i = 1 To glGlossary.count
xEntry = glGlossary.getEntryByIndex(i)
If glClear Then
Me.appendEntry (xEntry)
Else
Me.add getKey(xEntry), getItem(xEntry), glAddPrefix & getPrefix(xEntry), glAllowDupKeys:=glAllowDupKeys, glAllowDupItems:=glAllowDupItems
End If
Next i
End Sub
Public Function clear() As String
Dim i  As Long
For i = 1 To glCollection.count
glCollection.remove 1
Next i
If glCollection.count = 0 Then
clear = 0
Else
clear = "glGlossary: Failed to clear glossary"
End If
End Function
Public Function listItems() As String
Dim out As String: Dim xEntry  As String
Dim entry As Variant
out = ""
For Each entry In glCollection
xEntry = entry
out = out & "<" & getKey(xEntry) & ">" & "<" & getItem(xEntry) & ">" & "<" & getPrefix(xEntry) & ">" & vbNewLine
Next entry
listItems = out
End Function
Public Function containsKey(glKey As String) As Boolean
containsKey = (keyFindFuzzy(glKey, checkPresent:=True) > 0)
End Function
Public Function containsItem(glItem As String, Optional glIgnoreCase As Boolean = False) As Boolean
Dim i As Long
Dim zEntry As String
For i = 1 To glCollection.count
zEntry = glCollection(i)
If getItem(zEntry) = glItem Then
containsItem = True
Exit For
Else
If glIgnoreCase Then
If UCase$(getItem(zEntry)) = UCase$(glItem) Then
containsItem = True
Exit For
End If
End If
End If
Next i
End Function
Public Function containsKeyItemPair(glKey As String, glItem As String) As Boolean
Dim entries As Variant
Dim i As Long
Dim zEntry As String
If keyFindFuzzy(glKey, checkPresent:=True) > 0 Then
Set entries = getEntriesByKey(glKey)
For i = 1 To entries.count
zEntry = entries(i)
If getItem(zEntry) = glItem Then
containsKeyItemPair = True
Exit Function
End If
Next i
Else
containsKeyItemPair = False
End If
End Function
Public Function containsEntry(glKey As String, glItem As String, glPrefix As String) As Boolean
Dim entries As Variant
Dim i As Long
Dim zEntry As String
If keyFindFuzzy(glKey, checkPresent:=True) > 0 Then
Set entries = getEntriesByKey(glKey)
For i = 1 To entries.count
zEntry = entries(i)
If zEntry = constructEntry(glKey, glItem, glPrefix) Then
containsEntry = True
Exit Function
End If
Next i
Else
containsEntry = False
End If
End Function
Public Function containsDuplicateKeys() As Boolean
containsDuplicateKeys = duplicateEntries(True, False, False, False) > ""
End Function
Public Function containsDuplicateItems() As Boolean
containsDuplicateItems = duplicateEntries(False, True, False, False) > ""
End Function
Public Function containsDuplicateKeysOrItems(Optional glCrossCheck As Boolean = False, Optional glSearchPartial As Boolean = False) As Boolean
containsDuplicateKeysOrItems = duplicateEntries(glKeys:=True, glItems:=True, glCrossCheck:=glCrossCheck, glSearchPartial:=glSearchPartial) > ""
End Function
Public Function duplicateEntries(Optional glKeys As Boolean = True, Optional glItems As Boolean = True, Optional glCrossCheck As Boolean = True, Optional glSearchAll As Boolean = True, Optional glSearchPartial As Boolean = False) As String
Dim i As Long
Dim j As Long
Dim zKey As String
Dim zItem As String
Dim out As String
Dim dupFound As Boolean
Dim duplicateSet As String
out = ""
For i = 1 To glCollection.count
duplicateSet = ""
dupFound = False
If InStr(out, CStr(i)) > 0 Then GoTo next_Set
zKey = getKey(glCollection(i))
zItem = getItem(glCollection(i))
For j = i + 1 To glCollection.count
If glSearchPartial Then
If glKeys Then
If InStr(zKey, getKey(glCollection(j))) Then
duplicateSet = duplicateSet & "," & CStr(j)
dupFound = True
GoTo next_Check
End If
End If
If glItems Then
If InStr(zItem, getItem(glCollection(j))) Then
duplicateSet = duplicateSet & "," & CStr(j)
dupFound = True
GoTo next_Check
End If
End If
If glCrossCheck Then
If InStr(zItem, getKey(glCollection(j))) Or InStr(zKey, getItem(glCollection(j))) Then
duplicateSet = duplicateSet & "," & CStr(j)
dupFound = True
GoTo next_Check
End If
End If
End If
If glKeys Then
If zKey = getKey(glCollection(j)) Then
duplicateSet = duplicateSet & "," & CStr(j)
dupFound = True
GoTo next_Check
End If
End If
If glItems Then
If zItem = getItem(glCollection(j)) Then
duplicateSet = duplicateSet & "," & CStr(j)
dupFound = True
GoTo next_Check
End If
End If
If glCrossCheck Then
If zItem = getKey(glCollection(j)) Or zKey = getItem(glCollection(j)) Then
duplicateSet = duplicateSet & "," & CStr(j)
dupFound = True
GoTo next_Check
End If
End If
next_Check:
Next j
next_Set:
If dupFound Then
out = out & CStr(i) & duplicateSet & ";"
If glSearchAll Then
Else
GoTo finish
End If
End If
Next i
finish:
duplicateEntries = out
End Function
Public Function dumpToString(Optional glEncryptor As clsRC4) As String
Dim entry As Variant
Dim out As String
Dim xEntry  As String
out = ""
For Each entry In glCollection
If glEncryptor Is Nothing Then
xEntry = entry
Else
xEntry = encryptEntry(entry, glEncryptor)
End If
out = out & xEntry
Next entry
dumpToString = out
End Function
Public Function dumpToJSON(Optional glEncryptor As clsRC4) As String
Dim entry As Variant
Dim out As String
Dim xEntry  As String
Dim i  As Long
out = "["
i = 0
For Each entry In glCollection
If i > 0 Then out = out & ","
i = i + 1
If glEncryptor Is Nothing Then
xEntry = entry
Else
xEntry = encryptEntry(entry, glEncryptor)
End If
out = out & "{" & nvp("key", JSONescape(getKey(xEntry))) & "," & nvp("item", JSONescape(getItem(xEntry))) & "," & nvp("prefix", JSONescape(getPrefix(xEntry))) & "}"
Next entry
out = out & "]"
dumpToJSON = out
End Function
Public Sub loadFromString(ByVal glGlossaryDump As String, Optional glClear As Boolean = False, Optional glAllowDupKeys As Boolean = True, Optional glAllowDupItems As Boolean = True, Optional glEncryptor As clsRC4)
Dim xEntry As String
Dim maxCounter As Single: Dim i As Single
Dim v2Dump As Boolean
maxCounter = Len(glGlossaryDump)
If InStr(glGlossaryDump, glEntryStartV2) > 0 And InStr(glGlossaryDump, glElementSeparatorV2) > 0 And InStr(glGlossaryDump, glEntryEndV2) > 0 Then
v2Dump = True
Else
If InStr(glGlossaryDump, glEntryStart) > 0 And InStr(glGlossaryDump, glElementSeparator) > 0 And InStr(glGlossaryDump, glEntryEnd) > 0 Then
Else
Exit Sub
End If
End If
If glClear Then Me.clear
If v2Dump Then
glGlossaryDump = VBA.replace(glGlossaryDump, glEntryStartV2, glEntryStart)
glGlossaryDump = VBA.replace(glGlossaryDump, glElementSeparatorV2, glElementSeparator)
glGlossaryDump = VBA.replace(glGlossaryDump, glEntryEndV2, glEntryEnd)
End If
i = 0
Do While Len(glGlossaryDump) > 0 And i <= maxCounter
xEntry = Left$(glGlossaryDump, InStr(glGlossaryDump, glEntryEnd))
glGlossaryDump = Right$(glGlossaryDump, Len(glGlossaryDump) - InStr(glGlossaryDump, glEntryEnd))
If glEncryptor Is Nothing Then
Else
xEntry = decryptEntry(xEntry, glEncryptor)
End If
If glClear Then
Me.appendEntry (xEntry)
Else
Me.add getKey(xEntry), getItem(xEntry), getPrefix(xEntry), glAllowDupKeys:=glAllowDupKeys, glAllowDupItems:=glAllowDupItems
End If
i = i + 1
Loop
End Sub
Public Function count() As Long
count = glCollection.count
End Function
Public Function getKey(glEntry As String) As String
Dim keyStart As Long: Dim keyLength As Long
keyStart = 2
keyLength = glElementLength(glEntry, keyStart)
getKey = Mid$(glEntry, keyStart, keyLength)
End Function
Public Function getItem(glEntry As String) As String
Dim itemStart As Long: Dim itemLength As Long
itemStart = getItemStart(glEntry)
itemLength = glElementLength(glEntry, itemStart)
getItem = Mid$(glEntry, itemStart, itemLength)
End Function
Public Function getPrefix(glEntry As String) As String
Dim prefixStart As Long: Dim prefixLength As Long
prefixStart = getPrefixStart(glEntry)
prefixLength = glElementLength(glEntry, prefixStart)
getPrefix = Mid$(glEntry, prefixStart, prefixLength)
End Function
Public Function getEntryByIndex(glEntryNumber As Long) As String
On Error GoTo badIndex
getEntryByIndex = glCollection.item(glEntryNumber)
Exit Function
badIndex:
getEntryByIndex = "glGlossary: bad index " & glEntryNumber
End Function
Public Function getEntryByKey(glKey As String) As String
Dim i As Long
i = keyFindFirst(glKey, checkPresent:=True)
If i > 0 Then
getEntryByKey = glCollection(i)
Else
getEntryByKey = "glGlossary: no entry for key " & glKey
End If
End Function
Public Function getEntriesByKey(glKey As String) As Collection
Dim out As Collection
Dim first As Long
Dim i As Long
Set out = New Collection
first = keyFindFirst(glKey, checkPresent:=True)
If first > 0 Then
For i = first To keyFindLastMatchingIndex(first)
out.add glCollection(i)
Next
End If
Set getEntriesByKey = out
End Function
Public Function getEntriesByItem(glItem As String) As Collection
Dim out As Collection
Dim i As Long
Dim zEntry As String
Set out = New Collection
For i = 1 To glCollection.count
zEntry = glCollection(i)
If getItem(zEntry) = glItem Then
out.add zEntry
End If
Next i
Set getEntriesByItem = out
End Function
Public Function findInsertPosition(glEntry As String) As Long
Dim pos As Long
Dim xEntry As String
pos = keyFindFirst(getKey(glEntry))
For pos = keyFindFirst(getKey(glEntry)) To glCollection.count
xEntry = glCollection(pos)
If entryComparator(glEntry, xEntry) < 1 Then
Exit For
End If
Next
findInsertPosition = pos
End Function
Public Function keyFindFuzzy(glKey As String, Optional checkPresent As Boolean = False) As Long
Dim Lo As Long
Dim Hi As Long
Dim Median As Long
Dim out As Long
If glCollection.count = 0 Then
If checkPresent Then
out = 0
Else
out = 1
End If
GoTo endKeyFindFuzzy
Else
Lo = 1
Hi = glCollection.count
End If
Do
Median = (Lo + Hi) \ 2
If glKey < getKey(glCollection(Median)) Then
Hi = Median - 1
Else
Lo = Median + 1
End If
Loop Until (glKey = getKey(glCollection(Median))) Or (Lo > Hi)
If glKey = getKey(glCollection(Median)) Then
out = Median
Else
If checkPresent Then
out = 0
Else
out = Lo
End If
End If
endKeyFindFuzzy:
keyFindFuzzy = out
End Function
Public Function keyFindFirst(glKey As String, Optional checkPresent As Boolean = False) As Long
Dim curIndex As Long
Dim out As Long
curIndex = keyFindFuzzy(glKey, checkPresent)
If curIndex = 0 Then
out = 0
GoTo endKeyFindFirst
End If
If curIndex > glCollection.count Then
out = curIndex
GoTo endKeyFindFirst
Else
If glKey = getKey(glCollection(curIndex)) Then
Else
out = curIndex
GoTo endKeyFindFirst
End If
End If
For curIndex = curIndex To 1 Step -1
If glKey = getKey(glCollection(curIndex)) Then
Else
out = curIndex + 1
GoTo endKeyFindFirst
End If
Next
out = 1
endKeyFindFirst:
keyFindFirst = out
End Function
Public Function keyFindLastMatchingIndex(index As Long) As Long
Dim curIndex As Long
Dim key As String
key = getKey(glCollection(index))
For curIndex = index To glCollection.count
If key <> getKey(glCollection(curIndex)) Then Exit For
Next
keyFindLastMatchingIndex = curIndex - 1
End Function
Public Function entryComparator(glEntry1 As String, glentry2 As String) As Long
Dim key1 As String, item1 As String, prefix1 As String
Dim key2 As String, item2 As String, prefix2 As String
Dim out As Long
key1 = getKey(glEntry1): item1 = getItem(glEntry1): prefix1 = getPrefix(glEntry1)
key2 = getKey(glentry2): item2 = getItem(glentry2): prefix2 = getPrefix(glentry2)
If key1 < key2 Then
out = -1
GoTo endEntryComparator
Else
If key1 > key2 Then
out = 1
GoTo endEntryComparator
End If
End If
If item1 < item2 Then
out = -1
GoTo endEntryComparator
Else
If item1 > item2 Then
out = 1
GoTo endEntryComparator
End If
End If
If prefix1 < prefix2 Then
out = -1
GoTo endEntryComparator
Else
If prefix1 > prefix2 Then
out = 1
GoTo endEntryComparator
End If
End If
out = 0
endEntryComparator:
entryComparator = out
End Function
Public Function constructEntry(glKey As String, Optional glItem As String = "", Optional glPrefix As String = "") As String
constructEntry = glEntryStart & glKey & glElementSeparator & glItem & glElementSeparator & glPrefix & glEntryEnd
End Function
Public Function equals(xGlossary As clsGlossary) As Boolean
equals = (Me.dumpToString = xGlossary.dumpToString)
End Function
Public Function glossaryError(message As Variant) As Boolean
glossaryError = Left$(message, 11) = "glGlossary:"
End Function
Private Function stringContainsDelimeters(glText As String) As Boolean
Dim out As Boolean
Dim i  As Long
out = False
For i = 1 To Len(glText)
If InStr(glDelimiters, Mid$(glText, i, 1)) Then out = True
Next i
stringContainsDelimeters = out
End Function
Private Function getItemStart(glEntry As Variant) As Long
getItemStart = InStr(glEntry, glElementSeparator) + 1
End Function
Private Function getPrefixStart(glEntry As Variant) As Long
getPrefixStart = InStr(getItemStart(glEntry), glEntry, glElementSeparator) + 1
End Function
Private Function glElementLength(glEntry As String, glElementStart As Long) As Long
Dim endComponent As Long
endComponent = InStr(glElementStart, glEntry, glElementSeparator)
If endComponent = 0 Then endComponent = InStr(glElementStart, glEntry, glEntryEnd)
glElementLength = endComponent - glElementStart
End Function
Private Function encryptEntry(xEntry As Variant, glEncryptor As clsRC4) As String
Dim entry As String
entry = xEntry
encryptEntry = constructEntry(getKey(entry), glEncryptor.Encrypt(getItem(entry)), getPrefix(entry))
End Function
Private Function decryptEntry(xEntry As String, glEncryptor As clsRC4) As String
decryptEntry = constructEntry(getKey(xEntry), glEncryptor.Decrypt(getItem(xEntry)), getPrefix(xEntry))
End Function
Attribute VB_Name = "clsNavigator"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Dim cls_doc As String
Private Const bkmPrefix As String = "c8bkm003"
Public Function positionSave() As String
Dim position As Long
Dim t As table
Dim columnNo As Long
Dim rowNo As Long
Dim tableNo As Long
Dim i As Long
Dim bkm As Bookmark
Dim bkmName As String
Dim selRange As Range
Dim docSaved As Boolean
Dim doc As Document
On Error Resume Next
Set doc = Documents(BWordGetNumericDocumentIndex(cls_doc, xShowFailureMessage:=False))
docSaved = doc.Saved
tableNo = 0
Set selRange = doc.ActiveWindow.Selection.Range
bkmName = bkmPrefix & format$(Now, "hhmmss") & Int((12 * Rnd) + 1)
Set bkm = doc.Bookmarks.add(bkmName, selRange)
position = selRange.Start
If BWordRangeIsInTable(selRange, doc) Then
columnNo = Selection.Information(wdStartOfRangeColumnNumber)
rowNo = Selection.Information(wdStartOfRangeRowNumber)
For i = 1 To doc.tables.count
Set t = doc.tables(i)
If t.Range.Start = doc.Range(position, position).tables(i).Range.Start Then
tableNo = i
Exit For
End If
Next i
End If
positionSave = bkmName & "," & CStr(tableNo) & "," & CStr(columnNo) & "," & CStr(rowNo) & "," & CStr(position)
doc.Saved = docSaved
End Function
Public Sub positionRestore(xPos As String)
Dim zRange As Range
Dim zString() As String
Dim columnNo As Long
Dim rowNo As Long
Dim tableNo As Long
Dim docSaved As Boolean
Dim doc As Document
On Error Resume Next
Set doc = Documents(BWordGetNumericDocumentIndex(cls_doc, xShowFailureMessage:=False))
docSaved = doc.Saved
zString = Split(xPos, ",")
If BWordBookmarkExists(zString(0), doc) Then
Set zRange = doc.Bookmarks(zString(0)).Range
doc.Bookmarks(zString(0)).Delete
Else
tableNo = CLng(zString(1)): columnNo = CLng(zString(2)): rowNo = CLng(zString(3))
If tableNo > 0 Then
Set zRange = doc.tables(tableNo).Columns(columnNo).Cells(rowNo).Range
zRange.Collapse wdCollapseStart
Else
Set zRange = doc.Range(zString(4), zString(4))
End If
End If
zRange.Select
doc.Saved = docSaved
End Sub
Private Sub Class_Initialize()
cls_doc = ThisDocument.fullName
End Sub
Public Sub setDocument(xDocFullName As String)
cls_doc = xDocFullName
End Sub
Attribute VB_Name = "clsProgBar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public title As String
Private boolUserCancelled As Boolean
Private sProgress As Single
Private strStat1 As String
Private strStat2 As String
Private strStat3 As String
Sub setTitle(strCaption As String)
title = strCaption
frmProgress.Caption = strCaption
DoEvents
repaint
End Sub
Property Let Caption1(strCaption As String)
strStat1 = strCaption
frmProgress.lblMsg1.Caption = strCaption
DoEvents
repaint
End Property
Property Let Caption2(strCaption As String)
strStat2 = strCaption
frmProgress.lblMsg2.Caption = strCaption
DoEvents
repaint
End Property
Property Let Caption3(strCaption As String)
strStat3 = strCaption
frmProgress.lblMsg3.Caption = strCaption
DoEvents
repaint
End Property
Property Get Caption1() As String
Caption1 = strStat1
End Property
Property Get Caption2() As String
Caption2 = strStat2
End Property
Property Get Caption3() As String
Caption3 = strStat3
End Property
Property Let userCancelled(canc As Boolean)
boolUserCancelled = canc
End Property
Property Get userCancelled() As Boolean
userCancelled = boolUserCancelled
End Property
Sub finish()
System.Cursor = wdCursorNormal
Unload frmProgress
End Sub
Sub Hide()
System.Cursor = wdCursorNormal
frmProgress.Hide
End Sub
Property Get Progress() As Single
Progress = sProgress
End Property
Property Let Progress(p As Single)
Dim nWidth As Long
Select Case p
Case Is < 0
sProgress = 0
Case Is > 1
sProgress = 1
Case Else
sProgress = p
End Select
nWidth = sProgress * 100
With frmProgress.imgProgFore
.Width = 200 - Int(nWidth * 2)
.Left = 12 + Int(nWidth * 2)
End With
End Property
Sub Reset(Optional enableCancel As Boolean = True)
strStat1 = ""
strStat2 = ""
strStat3 = ""
title = ""
frmProgress.lblMsg1.Caption = ""
frmProgress.lblMsg2.Caption = ""
frmProgress.lblMsg3.Caption = ""
frmProgress.cmdCancel.Enabled = enableCancel
Me.Progress = 0
userCancelled = False
End Sub
Sub show(Optional enableCancel As Boolean = True)
System.Cursor = wdCursorWait
With frmProgress
If enableCancel = False Then
Select Case wordVersion
Case Is >= Word2013
.Width = 234
Case Else
.Width = 228
End Select
.cmdCancel.Enabled = False
End If
.Caption = title
.show vbModeless
End With
End Sub
Sub CancelButtonEnable(Optional xEnabled As Boolean = True)
If frmProgress.cmdCancel.Enabled = xEnabled Then
Else
frmProgress.cmdCancel.Enabled = xEnabled
frmProgress.repaint
DoEvents
End If
frmProgress.repaint
End Sub
Function CancelButtonIsEnabled() As Boolean
CancelButtonIsEnabled = frmProgress.cmdCancel.Enabled
End Function
Sub AddProgress(p As Double)
sProgress = sProgress + p
Me.Progress = sProgress
End Sub
Sub repaint()
frmProgress.repaint
End Sub
Attribute VB_Name = "clsRC4"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private myKey As String
Private Sub Class_Initialize()
myKey = "May 22 1952"
End Sub
Public Property Let key(inKey As String)
myKey = inKey
End Property
Public Function Encrypt(ByVal strText As String, Optional ByVal strKey As String, Optional hexData As Boolean = True) As String
Dim intX As Long
If Len(strKey) = 0 Then strKey = myKey
strText = rc4(strText, strKey)
If hexData Then
For intX = 1 To Len(strText)
Encrypt = Encrypt & Right$("0" & Hex$(Asc(Mid$(strText, intX))), 2)
Next intX
Else
Encrypt = strText
End If
End Function
Public Function Decrypt(ByVal strText As String, Optional ByVal strKey As String, Optional hexData As Boolean = True) As String
Dim intX As Long
If Len(strKey) = 0 Then strKey = myKey
If hexData Then
For intX = 1 To Len(strText) Step 2
Mid$(strText, (intX + 1) / 2, 1) = Chr(Val("&H" & Mid$(strText, intX, 2)))
Next intX
Decrypt = rc4(Left$(strText, Len(strText) / 2), strKey)
Else
Decrypt = rc4(strText, strKey)
End If
End Function
Public Function rc4(strText As String, strKey As String) As String
Dim intKeyLen As Long, intTemp As Long
Dim intX1 As Long, intX2 As Long, intX3 As Long
Dim aintB(256) As Long, aintK(256) As Long
intKeyLen = Len(strKey)
For intX1 = 0 To 255
aintB(intX1) = intX1
aintK(intX1) = Asc(Mid$(strKey, (intX1 Mod intKeyLen) + 1))
Next
intX2 = 0
For intX1 = 0 To 255
intX2 = (intX2 + aintB(intX1) + aintK(intX1)) Mod 255
intTemp = aintB(intX1)
aintB(intX1) = aintB(intX2)
aintB(intX2) = intTemp
Next
intX2 = 0
intX3 = 0
For intX1 = 1 To 3072 + Len(strText)
intX2 = (intX2 + 1) Mod 255
intX3 = (intX3 + aintB(intX2)) Mod 255
intTemp = aintB(intX2)
aintB(intX2) = aintB(intX3)
aintB(intX3) = intTemp
If intX1 > 3072 Then
rc4 = rc4 & Chr(Asc(Mid$(strText, intX1 - 3072)) Xor aintB((aintB(intX2) + aintB(intX3)) Mod 255))
End If
Next
End Function
Attribute VB_Name = "clsSHA256"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private m_lOnBits(30)   As Long
Private m_l2Power(30)   As Long
Private k(63)           As Long
Private Const BITS_TO_A_BYTE  As Long = 8
Private Const BYTES_TO_A_WORD As Long = 4
Private Const BITS_TO_A_WORD  As Long = BYTES_TO_A_WORD * BITS_TO_A_BYTE
Private Const MODULUS_BITS As Long = 512
Private Const CONGRUENT_BITS As Long = 448
Private Sub Class_Initialize()
m_lOnBits(0) = 1
m_lOnBits(1) = 3
m_lOnBits(2) = 7
m_lOnBits(3) = 15
m_lOnBits(4) = 31
m_lOnBits(5) = 63
m_lOnBits(6) = 127
m_lOnBits(7) = 255
m_lOnBits(8) = 511
m_lOnBits(9) = 1023
m_lOnBits(10) = 2047
m_lOnBits(11) = 4095
m_lOnBits(12) = 8191
m_lOnBits(13) = 16383
m_lOnBits(14) = 32767
m_lOnBits(15) = 65535
m_lOnBits(16) = 131071
m_lOnBits(17) = 262143
m_lOnBits(18) = 524287
m_lOnBits(19) = 1048575
m_lOnBits(20) = 2097151
m_lOnBits(21) = 4194303
m_lOnBits(22) = 8388607
m_lOnBits(23) = 16777215
m_lOnBits(24) = 33554431
m_lOnBits(25) = 67108863
m_lOnBits(26) = 134217727
m_lOnBits(27) = 268435455
m_lOnBits(28) = 536870911
m_lOnBits(29) = 1073741823
m_lOnBits(30) = 2147483647
m_l2Power(0) = 1
m_l2Power(1) = 2
m_l2Power(2) = 4
m_l2Power(3) = 8
m_l2Power(4) = 16
m_l2Power(5) = 32
m_l2Power(6) = 64
m_l2Power(7) = 128
m_l2Power(8) = 256
m_l2Power(9) = 512
m_l2Power(10) = 1024
m_l2Power(11) = 2048
m_l2Power(12) = 4096
m_l2Power(13) = 8192
m_l2Power(14) = 16384
m_l2Power(15) = 32768
m_l2Power(16) = 65536
m_l2Power(17) = 131072
m_l2Power(18) = 262144
m_l2Power(19) = 524288
m_l2Power(20) = 1048576
m_l2Power(21) = 2097152
m_l2Power(22) = 4194304
m_l2Power(23) = 8388608
m_l2Power(24) = 16777216
m_l2Power(25) = 33554432
m_l2Power(26) = 67108864
m_l2Power(27) = 134217728
m_l2Power(28) = 268435456
m_l2Power(29) = 536870912
m_l2Power(30) = 1073741824
k(0) = &H428A2F98
k(1) = &H71374491
k(2) = &HB5C0FBCF
k(3) = &HE9B5DBA5
k(4) = &H3956C25B
k(5) = &H59F111F1
k(6) = &H923F82A4
k(7) = &HAB1C5ED5
k(8) = &HD807AA98
k(9) = &H12835B01
k(10) = &H243185BE
k(11) = &H550C7DC3
k(12) = &H72BE5D74
k(13) = &H80DEB1FE
k(14) = &H9BDC06A7
k(15) = &HC19BF174
k(16) = &HE49B69C1
k(17) = &HEFBE4786
k(18) = &HFC19DC6
k(19) = &H240CA1CC
k(20) = &H2DE92C6F
k(21) = &H4A7484AA
k(22) = &H5CB0A9DC
k(23) = &H76F988DA
k(24) = &H983E5152
k(25) = &HA831C66D
k(26) = &HB00327C8
k(27) = &HBF597FC7
k(28) = &HC6E00BF3
k(29) = &HD5A79147
k(30) = &H6CA6351
k(31) = &H14292967
k(32) = &H27B70A85
k(33) = &H2E1B2138
k(34) = &H4D2C6DFC
k(35) = &H53380D13
k(36) = &H650A7354
k(37) = &H766A0ABB
k(38) = &H81C2C92E
k(39) = &H92722C85
k(40) = &HA2BFE8A1
k(41) = &HA81A664B
k(42) = &HC24B8B70
k(43) = &HC76C51A3
k(44) = &HD192E819
k(45) = &HD6990624
k(46) = &HF40E3585
k(47) = &H106AA070
k(48) = &H19A4C116
k(49) = &H1E376C08
k(50) = &H2748774C
k(51) = &H34B0BCB5
k(52) = &H391C0CB3
k(53) = &H4ED8AA4A
k(54) = &H5B9CCA4F
k(55) = &H682E6FF3
k(56) = &H748F82EE
k(57) = &H78A5636F
k(58) = &H84C87814
k(59) = &H8CC70208
k(60) = &H90BEFFFA
k(61) = &HA4506CEB
k(62) = &HBEF9A3F7
k(63) = &HC67178F2
End Sub
Private Function LShift(ByVal lValue As Long, ByVal iShiftBits As Long) As Long
If iShiftBits = 0 Then
LShift = lValue
Exit Function
ElseIf iShiftBits = 31 Then
If lValue And 1 Then LShift = &H80000000 Else LShift = 0
Exit Function
ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
Err.Raise 6
End If
If (lValue And m_l2Power(31 - iShiftBits)) Then LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000 Else LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
End Function
Private Function RShift(ByVal lValue As Long, ByVal iShiftBits As Long) As Long
If iShiftBits = 0 Then
RShift = lValue
Exit Function
ElseIf iShiftBits = 31 Then
If lValue And &H80000000 Then RShift = 1 Else RShift = 0
Exit Function
ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
Err.Raise 6
End If
RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
If (lValue And &H80000000) Then RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
End Function
Private Function AddUnsigned(ByVal lX As Long, ByVal lY As Long) As Long
Dim lX4 As Long, lY4 As Long, lX8 As Long, lY8 As Long, lResult As Long
lX8 = lX And &H80000000
lY8 = lY And &H80000000
lX4 = lX And &H40000000
lY4 = lY And &H40000000
lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
If lX4 And lY4 Then
lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
ElseIf lX4 Or lY4 Then
If lResult And &H40000000 Then lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8 Else lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
Else
lResult = lResult Xor lX8 Xor lY8
End If
AddUnsigned = lResult
End Function
Private Function Ch(ByVal x As Long, ByVal Y As Long, ByVal z As Long) As Long
Ch = ((x And Y) Xor ((Not x) And z))
End Function
Private Function Maj(ByVal x As Long, ByVal Y As Long, ByVal z As Long) As Long
Maj = ((x And Y) Xor (x And z) Xor (Y And z))
End Function
Private Function s(ByVal x As Long, ByVal n As Long) As Long
s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function
Private Function R(ByVal x As Long, ByVal n As Long) As Long
R = RShift(x, CInt(n And m_lOnBits(4)))
End Function
Private Function Sigma0(ByVal x As Long) As Long
Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function
Private Function Sigma1(ByVal x As Long) As Long
Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function
Private Function Gamma0(ByVal x As Long) As Long
Gamma0 = (s(x, 7) Xor s(x, 18) Xor R(x, 3))
End Function
Private Function Gamma1(ByVal x As Long) As Long
Gamma1 = (s(x, 17) Xor s(x, 19) Xor R(x, 10))
End Function
Private Function ConvertToWordArray(sMessage As String) As Long()
Dim lMessageLength As Long, lNumberOfWords As Long, lWordArray() As Long, lBytePosition As Long, lByteCount As Long, lWordCount As Long, lByte As Long
lMessageLength = Len(sMessage)
lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
ReDim lWordArray(lNumberOfWords - 1)
Do Until lByteCount >= lMessageLength
lWordCount = lByteCount \ BYTES_TO_A_WORD
lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
lByte = AscB(Mid$(sMessage, lByteCount + 1, 1))
lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
lByteCount = lByteCount + 1
Loop
lWordCount = lByteCount \ BYTES_TO_A_WORD
lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)
lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
ConvertToWordArray = lWordArray
End Function
Public Function SHA256(sMessage As String) As String
Dim hash(7) As Long, m() As Long, w(63) As Long, a As Long, B As Long
Dim c As Long, d As Long, e As Long, f As Long, G As Long, H As Long
Dim i As Long, j As Long, T1 As Long, T2 As Long
hash(0) = &H6A09E667: hash(1) = &HBB67AE85: hash(2) = &H3C6EF372
hash(3) = &HA54FF53A: hash(4) = &H510E527F: hash(5) = &H9B05688C
hash(6) = &H1F83D9AB: hash(7) = &H5BE0CD19
m = ConvertToWordArray(sMessage)
For i = 0 To UBound(m) Step 16
a = hash(0): B = hash(1): c = hash(2): d = hash(3)
e = hash(4): f = hash(5): G = hash(6): H = hash(7)
For j = 0 To 63
If j < 16 Then w(j) = m(j + i) Else w(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(j - 2)), w(j - 7)), Gamma0(w(j - 15))), w(j - 16))
T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(H, Sigma1(e)), Ch(e, f, G)), k(j)), w(j))
T2 = AddUnsigned(Sigma0(a), Maj(a, B, c))
H = G: G = f: f = e
e = AddUnsigned(d, T1)
d = c: c = B: B = a
a = AddUnsigned(T1, T2)
Next
hash(0) = AddUnsigned(a, hash(0))
hash(1) = AddUnsigned(B, hash(1))
hash(2) = AddUnsigned(c, hash(2))
hash(3) = AddUnsigned(d, hash(3))
hash(4) = AddUnsigned(e, hash(4))
hash(5) = AddUnsigned(f, hash(5))
hash(6) = AddUnsigned(G, hash(6))
hash(7) = AddUnsigned(H, hash(7))
Next
SHA256 = LCase$(Right$("00000000" & Hex$(hash(0)), 8) & Right$("00000000" & Hex$(hash(1)), 8) & Right$("00000000" & Hex$(hash(2)), 8) & Right$("00000000" & Hex$(hash(3)), 8) & Right$("00000000" & Hex$(hash(4)), 8) & Right$("00000000" & Hex$(hash(5)), 8) & Right$("00000000" & Hex$(hash(6)), 8) & Right$("00000000" & Hex$(hash(7)), 8))
End Function
Attribute VB_Name = "clsSaver"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private cls_documentSaves() As String
Private documentSaveHighIndex As Long
Private Sub Class_Initialize()
documentSaveHighIndex = -1
End Sub
Public Function documentSave(xDoc As Document, Optional xVisible As Boolean = False) As String
Dim screenUpdating As Boolean
On Error GoTo logicError
Dim newFile As String
screenUpdating = Application.screenUpdating
Application.screenUpdating = False
newFile = newTempDoc(xVisible)
Call copyDocument(xDoc, Documents(newFile))
documentSave = newFile
BWordDocumentVariableSet Documents(newFile), c8clsSaverFileStamp, c8clsSaverFileStamp
Application.screenUpdating = screenUpdating
Exit Function
logicError:
showMessage c8Msg6000, msgSuffix2:="clsSaver documentSave: Error " & Err.Number & " (" & Err.Description & ")"
End Function
Public Sub documentRestore(xFrom As String, xTo As String, xRestoreStatus As Boolean)
Dim screenUpdating As Boolean
On Error GoTo logicError
screenUpdating = Application.screenUpdating
Application.screenUpdating = False
Call copyDocument(Documents(xFrom), Documents(xTo))
Documents(xTo).Saved = xRestoreStatus
Application.screenUpdating = screenUpdating
Exit Sub
logicError:
showMessage c8Msg6000, msgSuffix2:="clsSaver documentRestore: Error " & Err.Number & " (" & Err.Description & ")"
End Sub
Public Sub closeSingle(xSave As String)
On Error GoTo logicError
Documents(xSave).Close savechanges:=wdDoNotSaveChanges
Exit Sub
logicError:
Select Case Err.Number
Case 4160
Case Else
showMessage c8Msg6000, msgSuffix2:="clsSaver closeSingle: Error " & Err.Number & " (" & Err.Description & ")"
End Select
End Sub
Public Sub closeAll()
Dim i As Long
If documentSaveHighIndex = -1 Then Exit Sub
For i = 0 To UBound(cls_documentSaves)
Call closeSingle(cls_documentSaves(i))
Next
End Sub
Private Function newTempDoc(xVisible As Boolean) As String
documentSaveHighIndex = documentSaveHighIndex + 1
ReDim Preserve cls_documentSaves(documentSaveHighIndex)
cls_documentSaves(documentSaveHighIndex) = Documents.add(Visible:=xVisible).name
newTempDoc = cls_documentSaves(documentSaveHighIndex)
End Function
Public Sub copyDocument(sourceDoc As Document, targetDoc As Document)
Dim s As Section
Dim targetRange As Range
Dim zRange As Range
Dim screenUpdating As Boolean
Dim saveStatus As Boolean
saveStatus = sourceDoc.Saved
screenUpdating = Application.screenUpdating
Application.screenUpdating = False
Set targetRange = targetDoc.Range
targetRange.Delete
For Each s In sourceDoc.Sections
targetRange.Collapse direction:=wdCollapseEnd
On Error GoTo errorHeaderFooter
Set zRange = targetRange.Sections(1).Headers(wdHeaderFooterPrimary).Range
zRange.FormattedText = s.Headers(wdHeaderFooterPrimary).Range.FormattedText
zRange.SetRange zRange.End - 1, zRange.End - 1
zRange.Delete
Set zRange = targetRange.Sections(1).Footers(wdHeaderFooterPrimary).Range
zRange.FormattedText = s.Footers(wdHeaderFooterPrimary).Range.FormattedText
zRange.SetRange zRange.End - 1, zRange.End - 1
zRange.Delete
On Error GoTo 0
targetRange.FormattedText = s.Range.FormattedText
On Error GoTo errorPageSetup
With targetRange.PageSetup
.Orientation = s.PageSetup.Orientation
.LeftMargin = s.PageSetup.LeftMargin
.RightMargin = s.PageSetup.RightMargin
.TopMargin = s.PageSetup.TopMargin
.BottomMargin = s.PageSetup.BottomMargin
.FooterDistance = s.PageSetup.FooterDistance
.HeaderDistance = s.PageSetup.HeaderDistance
End With
On Error GoTo 0
Next s
Set targetRange = targetDoc.Range
targetRange.SetRange targetDoc.Range.End - 1, targetDoc.Range.End
targetRange.Delete
Application.screenUpdating = screenUpdating
sourceDoc.Saved = saveStatus
Exit Sub
errorHeaderFooter:
If Err.Number = 5097 Then
Resume Next
Else
showMessage c8Msg6000, msgSuffix2:="clsSaver copyDocument: Error " & Err.Number & " (" & Err.Description & ")"
End If
errorPageSetup:
If Err.Number = 4605 Then
Resume Next
Else
showMessage c8Msg6000, msgSuffix2:="clsSaver copyDocument: Error " & Err.Number & " (" & Err.Description & ")"
End If
End Sub
Attribute VB_Name = "clsStopWatch"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
#If VBA7 Then
Private Declare PtrSafe Function timeGetTime Lib "winmm.dll" () As Long
#Else
Private Declare Function timeGetTime Lib "winmm.dll" () As Long
#End If
Private snapshotTime As Long
Private runningTime As Long
Private running As Boolean
Public Sub Start(Optional xReset As Boolean = False)
If xReset Then
Call Reset
Else
snapshotTime = timeGetTime()
End If
running = True
End Sub
Public Sub Reset()
runningTime = 0
snapshotTime = timeGetTime()
End Sub
Public Function Halt() As Long
Halt = value
If running Then
runningTime = runningTime + (timeGetTime() - snapshotTime)
End If
running = False
End Function
Public Function value() As Long
If running Then
value = runningTime + (timeGetTime() - snapshotTime)
Else
value = runningTime
End If
End Function
Public Function ValueFormatted(Optional xFormat As String = "000.000") As String
ValueFormatted = format$(value / 1000, xFormat)
End Function
Public Property Get isRunning() As Boolean
isRunning = running
End Property
Private Sub Class_Initialize()
Call Reset
End Sub
Attribute VB_Name = "frmAbbreviationsReview"
Attribute VB_Base = "0{69D978CE-59DD-4FA7-91CF-ACFE09FEC79A}{48E94019-EFC4-48F8-B8A1-294D9E99DA63}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Dim disableClickEventCode As Boolean
Dim mode As Long
Dim defaultWidth As Long
Dim term As String
Dim definition As String
Dim prefix As String
Dim docSave As String
Dim saveStatus As Boolean
Private Sub cbReport_Click()
Dim doc As Document
thisDocFinder.matchesHighlightClear
Call thisDocSaver.closeSingle(docSave)
Me.Hide
Set doc = MatchesReport()
If doc Is Nothing Then
Else
doc.activate
End If
End Sub
Private Sub optionBIU_Click()
If disableClickEventCode Then Exit Sub
AnonymiseCurrentMatch biu:=True
End Sub
Private Sub optionPlain_Click()
If disableClickEventCode Then Exit Sub
AnonymiseCurrentMatch biu:=False
End Sub
Private Sub optionDefn_Click()
If disableClickEventCode Then Exit Sub
PersonaliseCurrentMatch
End Sub
Private Sub UserForm_Initialize()
lblLHBackground.ZOrder (1)
defaultWidth = Me.Width
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
Me.Top = ThisDocument.ActiveWindow.Top + 10
Me.Left = ThisDocument.ActiveWindow.Left + 10
Call updateRadioButtons
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
Select Case mode
Case frmAbbreviationsReviewMode_UpdateAnonymisations
If CloseMode = vbFormControlMenu Then Cancel = True
Case frmAbbreviationsReviewMode_ReadOnly
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
Call thisDocSaver.closeSingle(docSave)
Me.Hide
End Select
End Sub
Private Sub cbCancel_Click()
Call thisDocSaver.documentRestore(docSave, ThisDocument.name, saveStatus)
Call thisDocSaver.closeSingle(docSave)
Me.Hide
End Sub
Private Sub cbOK_Click()
Me.Hide
With progressBar
.Reset
.title = "Clearing Highlights"
.show enableCancel:=False
End With
Call thisDocFinder.matchesHighlightClear(xAddProgress:=1 / thisDocFinder.matchesCount)
Call thisDocSaver.closeSingle(docSave)
progressBar.finish
End Sub
Private Sub cbFirst_Click()
thisDocFinder.goToFirstMatch
Call updateRadioButtons
End Sub
Private Sub cbNext_Click()
thisDocFinder.goToNextMatch
Call updateRadioButtons
End Sub
Private Sub cbPrev_Click()
thisDocFinder.goToPreviousMatch
Call updateRadioButtons
End Sub
Private Sub cbLast_Click()
thisDocFinder.goToLastMatch
Call updateRadioButtons
End Sub
Private Sub updateRadioButtons()
disableClickEventCode = True
Me.optionBIU.Caption = thisDocFinder.currentMatchData01
Me.optionPlain.Caption = thisDocFinder.currentMatchData01
Me.optionDefn.Caption = thisDocFinder.currentMatchData02
If currentMatchIsAbbreviation Then
If currentMatchIsBIU Then
Me.optionBIU.value = True
Else
Me.optionPlain.value = True
End If
Else
Me.optionDefn.value = True
End If
disableClickEventCode = False
End Sub
Public Sub setMode(xMode As Long, Optional xTerm As String = "", Optional xDefinition As String = "", Optional xPrefix As String = "")
Dim offset As Long
Dim countString As String
mode = xMode
term = xTerm
definition = xDefinition
prefix = xPrefix
Select Case mode
Case frmAbbreviationsReviewMode_ReadOnly
Me.Caption = "Review Abbreviation"
countString = BPluralityText(thisDocFinder.matchesCount, "occurrence")
If term > "" Then
lblInstructions.Caption = "Use the arrow buttons to find <" & term & "> and <" & definition & "> defined by or in '" & prefix & "'." & vbNewLine & vbNewLine & "(" & countString & ")"
Else
lblInstructions.Caption = "Use the arrow buttons to find the selected abbreviations and definitions." & vbNewLine & vbNewLine & "(" & countString & ")"
End If
Select Case wordVersion
Case Is >= Word2013
offset = 17
Case Else
offset = 10
End Select
Me.Width = Me.cbReport.Left + Me.cbReport.Width + offset
Case frmAbbreviationsReviewMode_UpdateAnonymisations
Me.Caption = "Change Abbreviations"
lblInstructions.Caption = "Choose an entry using the arrow buttons, then select what it should look like." & vbNewLine & vbNewLine & "Press OK when you have finished, or Cancel to undo all changes."
updateRadioButtons
Me.Width = defaultWidth
End Select
End Sub
Public Function getMode() As Long
getMode = mode
End Function
Public Sub setRecoveryDoc(xDocument As String, xSaveStatus As String)
thisDocSaver.closeSingle docSave
saveStatus = xSaveStatus
docSave = thisDocSaver.documentSave(Documents(xDocument))
End Sub
Public Sub closeRecoveryDoc()
thisDocSaver.closeSingle docSave
End Sub
Attribute VB_Name = "frmAbout"
Attribute VB_Base = "0{A29599C7-E7FF-4661-81B0-847BA3855EB0}{3F05EC55-6A54-4F41-A19C-2A1296AB070E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private Sub cbOK_Click()
Me.Hide
End Sub
Private Sub cbSysInfo_Click()
Me.Hide
frmInternalsReport.setDisplay ("System Information")
frmInternalsReport.show
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
End Sub
Private Sub UserForm_Initialize()
Me.programInfo.Caption = "Version " & c8_Constants.c8Version & vbNewLine & vbNewLine & c8Copyright
Me.web.Caption = c8_Constants.c8ProductURL
End Sub
Private Sub web_Click()
On Error Resume Next
ThisDocument.FollowHyperlink Address:="http:\\" & c8_Constants.c8ProductURL, NewWindow:=True, AddHistory:=True
End Sub
Attribute VB_Name = "frmAnonymise"
Attribute VB_Base = "0{C282A8D4-71E7-42D0-ABFC-EBADBA3C357D}{DCC44B1A-5BE4-4CBD-8AF6-CC87A695A284}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private saveTop As Long
Private saveLeft As Long
Private suppressListChangeEvent As Boolean
Private Sub cbUseFormatting_Click()
If Me.cbUseFormatting Then
If c8Msg7010Shown = c8Msg7010Anonymise Then
Else
c8Msg7010Shown = c8Msg7010Anonymise
If showMessage(c8Msg7010, msgPrefix2:="Formatting introduced while using the Anonymisation", button2:="OK", button3:="Cancel") = "OK" Then
Else
Me.Hide
End If
End If
End If
End Sub
Private Sub UserForm_Initialize()
Call formFeatures(Me)
lblLHBackground.ZOrder (1)
lblDescription1.Caption = "Place a tick against the glossary entries that you want to process, and " & "press the appropriate button to Anonymise or Personalise them." & vbNewLine & vbNewLine & "Press the Review button to review and change individual entries in the text." & vbNewLine & vbNewLine & "You can find out more about Anonymisation in the 'Using Chronolator Documents' manual."
If thisDocDescriptor.columnGlossary = 0 Then
lblIncludeGlossary.Visible = False
cbIncludeGlossary.Visible = False
Else
lblDescription2.Caption = "Tick the 'Include Glossary Column' box to include column " & thisDocDescriptor.columnGlossary & " in this processing."
End If
lblDescription3.Caption = "Tick the 'Use formatting' box to help you and Chronolator to identify abbreviations in the text."
Call buttonValues
Call buttonStates
c8TablesAutoFit wdAutoFitContent, keepDocState:=True
End Sub
Private Sub UserForm_Activate()
Call AbbreviationListSync
suppressListChangeEvent = True
Call AnonymisationGetParms
suppressListChangeEvent = False
Call buttonValues
Call buttonStates
If saveTop = 0 Then
Else
Me.Top = saveTop
Me.Left = saveLeft
End If
c8TablesAutoFit wdAutoFitContent, keepDocState:=True
End Sub
Private Sub cbAnonymise_Click()
Call AnonymisationSetOtherParms
Me.savePosition Me.Top, Me.Left
Me.Hide
ChangeCandidates matchMode.anonymise
c8TablesAutoFit wdAutoFitContent, keepDocState:=True
End Sub
Private Sub cbPersonalise_Click()
Call AnonymisationSetOtherParms
Me.savePosition Me.Top, Me.Left
Me.Hide
ChangeCandidates matchMode.personalise
c8TablesAutoFit wdAutoFitContent, keepDocState:=True
End Sub
Private Sub cbSelectAll_Click()
Dim i  As Long
For i = 1 To abbreviationList.ListCount
abbreviationList.Selected(i - 1) = True
Next
End Sub
Private Sub cbSelectNone_Click()
Dim i  As Long
For i = 1 To abbreviationList.ListCount
abbreviationList.Selected(i - 1) = False
Next
End Sub
Private Sub cbSelectFlip_Click()
Dim i  As Long
For i = 1 To abbreviationList.ListCount
abbreviationList.Selected(i - 1) = Not abbreviationList.Selected(i - 1)
Next
End Sub
Private Sub cbClose_Click()
c8TablesAutoFitRestore
Me.savePosition Me.Top, Me.Left
Call AnonymisationSetOtherParms
Me.Hide
End Sub
Private Sub cbReview_Click()
Dim matchCount As Long
Call AnonymisationSetOtherParms
Me.savePosition Me.Top, Me.Left
Me.Hide
frmAbbreviationsReview.setRecoveryDoc ThisDocument.name, ThisDocument.Saved
matchCount = ProcessAbbreviations(matchMode.reviewAnonymisations, xHighlightMatches:=True)
Application.screenUpdating = True
If matchCount > 0 Then GoTo displayMatches
Select Case matchCount
Case -1
showMessage c8Msg7030
Case -2
showMessage c8Msg7031
Case -3
End Select
frmAbbreviationsReview.closeRecoveryDoc
Exit Sub
displayMatches:
Me.Hide
frmAbbreviationsReview.setMode frmAbbreviationsReviewMode_UpdateAnonymisations
frmAbbreviationsReview.show
End Sub
Private Sub AbbreviationList_Change()
If suppressListChangeEvent Then
Else
Call AnonymisationSetAbbreviationParms
Call buttonStates
End If
End Sub
Private Sub AnonymisationSetAbbreviationParms()
Dim i As Long
Dim zEntry As String
Dim zAbbrev As String
Dim zDefn As String
ppSaveStatus
For i = 1 To thisDocGlossaryMerged.count
zEntry = thisDocGlossaryMerged.getEntryByIndex(i)
zAbbrev = thisDocGlossaryMerged.getKey(zEntry)
zDefn = thisDocGlossaryMerged.getItem(zEntry)
Call ppA_AnonymiseAbbreviationSet(zAbbrev, zDefn, Me.abbreviationList.Selected(i - 1))
Next
ppSerialise
End Sub
Private Sub AnonymisationSetOtherParms()
ppSaveStatus
ppA_BIUParmSet Me.cbUseFormatting
ppA_GlossaryColumnUpdateSet Me.cbIncludeGlossary.value
ppSerialise
End Sub
Private Sub AnonymisationGetParms()
Dim i As Long
Dim zEntry As String
Dim zAbbrev As String
Dim zDefn As String
For i = 1 To thisDocGlossaryMerged.count
zEntry = thisDocGlossaryMerged.getEntryByIndex(i)
zAbbrev = thisDocGlossaryMerged.getKey(zEntry)
zDefn = thisDocGlossaryMerged.getItem(zEntry)
Me.abbreviationList.Selected(i - 1) = ppA_AnonymiseAbbreviationGet(zAbbrev, zDefn)
Next
End Sub
Private Sub AbbreviationListSync()
Dim names() As String
Dim namecount As Long
Dim xEntry As String
Dim i As Long
Dim selectedItems As String
Dim selectedItemIdentifier As String
selectedItems = ""
For i = 1 To abbreviationList.ListCount
If abbreviationList.Selected(i - 1) Then
selectedItemIdentifier = abbreviationList.List(i - 1, 0) & abbreviationList.List(i - 1, 2)
selectedItems = selectedItems & "<" & selectedItemIdentifier & ">"
End If
Next i
namecount = thisDocGlossaryMerged.count
If namecount > 0 Then
ReDim names(1 To namecount, 1 To 3)
For i = 1 To namecount
xEntry = thisDocGlossaryMerged.getEntryByIndex(i)
names(i, 1) = thisDocGlossaryMerged.getKey(xEntry)
names(i, 2) = thisDocGlossaryMerged.getItem(xEntry)
names(i, 3) = thisDocGlossaryMerged.getPrefix(xEntry)
Next i
abbreviationList.List() = names
Else
abbreviationList.clear
End If
For i = 1 To abbreviationList.ListCount
selectedItemIdentifier = abbreviationList.List(i - 1, 0) & abbreviationList.List(i - 1, 2)
If InStr("<" & selectedItems & ">", "<" & selectedItemIdentifier & ">") Then
abbreviationList.Selected(i - 1) = True
End If
Next i
End Sub
Private Sub buttonValues()
Me.cbUseFormatting.value = ppA_BIUParmGet
Me.cbIncludeGlossary.value = ppA_GlossaryColumnUpdateGet
End Sub
Private Sub buttonStates()
Me.cbAnonymise.Enabled = ppA_CandidatesExist
Me.cbPersonalise.Enabled = Me.cbAnonymise.Enabled
Me.cbReview.Enabled = Me.cbAnonymise.Enabled
End Sub
Public Sub savePosition(xTop As Long, xLeft As Long)
saveTop = xTop
saveLeft = xLeft
End Sub
Attribute VB_Name = "frmDuplicates"
Attribute VB_Base = "0{4931E087-1003-43C7-887F-E1BBB7609AE6}{CCFA5768-CEF0-42A1-8A22-34C721A4BA56}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private textAreaHeightModeHighlight As Single
Private textAreaHeightModeDelete As Single
Public duplicatesMode As Long
Const commonText As String = "Chronolator can detect duplicate rows in a table." & vbNewLine & vbNewLine & "Duplicate rows can occur for a number of reasons. " & "If records come in sporadically and you have to assemble an Internal Chronology " & "over a long period you might unintentionally enter the same event more than once. " & "If you are an Administrator, you might import an updated Internal Chronology which you have already imported. " & vbNewLine & vbNewLine & "In either case, you might have given the same event different values in the '$ column. If " & "you want Chronolator to ignore that column " & "when checking for duplicates, tick the 'Ignore Source Column' box."
Const deletionText As String = "When deleting rows, Chronolator can copy the deleted rows to another Word file. " & "Tick the 'Copy Deleted Rows' box to make that happen. " & "After the deletion, Chronolator will open the document containing the deleted rows, and " & "you can Save it in the usual Word fashion."
Private Sub UserForm_Activate()
Dim zText As String
Dim zSourceHeader As String
Dim plimsollLine As Long
Dim buttonoffset As Long
Call formFeatures(Me)
Select Case wordVersion
Case Is < Word2007
textAreaHeightModeHighlight = 230
textAreaHeightModeDelete = 295
buttonoffset = 55
Case Word2007
textAreaHeightModeHighlight = 240
textAreaHeightModeDelete = 320
buttonoffset = 53
Case Word2010
textAreaHeightModeHighlight = 245
textAreaHeightModeDelete = 315
buttonoffset = 55
Case Is >= Word2013
textAreaHeightModeHighlight = 265
textAreaHeightModeDelete = 335
buttonoffset = 63
End Select
zText = thisDocDescriptor.columnHeading(thisDocDescriptor.columnSource)
zSourceHeader = BStringNormaliseLength(zText, BMin(Len(zText), 25))
zText = BStringInsert(xTargetString:=commonText, xPos:=InStr(1, commonText, "$"), xInputString:=zSourceHeader, xReplace:=False)
zText = BStringInsert(xTargetString:=zText, xPos:=InStr(1, zText, "$"), xInputString:="'", xReplace:=True)
If duplicatesMode = c8DuplicatesDelete Then
zText = zText & vbNewLine & vbNewLine & deletionText
plimsollLine = textAreaHeightModeDelete
Me.Caption = "Delete Duplicate Rows"
Else
plimsollLine = textAreaHeightModeHighlight
Me.Caption = "Highlight Duplicate Rows"
End If
ckbCopyDeletedRows.Visible = (duplicatesMode = c8DuplicatesDelete)
Select Case BRegistryQueryValue(HKEY_CURRENT_USER, "Control Panel\Desktop", "LogPixels")
Case 96
Case 120
plimsollLine = plimsollLine + 20
Case 144
plimsollLine = plimsollLine + 30
Case 192
plimsollLine = plimsollLine + 40
End Select
Me.Height = plimsollLine
lblLHBackground.Height = Me.Height
cbOK.Top = plimsollLine - buttonoffset
cbCancel.Top = cbOK.Top
lblText.Height = plimsollLine - lblText.Top
lblText.Caption = zText
cbOK.SetFocus
End Sub
Private Sub UserForm_Initialize()
lblLHBackground.ZOrder (1)
End Sub
Private Sub cbOK_Click()
frmDuplicatesButton = vbOK
Me.Hide
End Sub
Private Sub cbCancel_Click()
frmDuplicatesButton = vbCancel
Me.Hide
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
frmDuplicatesButton = vbCancel
End Sub
Attribute VB_Name = "frmGlossary"
Attribute VB_Base = "0{5A73E0B2-2BF0-4670-9C4E-4A03C75C0121}{DE67D232-15D4-4D15-9BEE-11315BBBFA55}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private changeAbbreviation As Boolean
Private disableClickEventCode As Boolean
Private saveTop As Long
Private saveLeft As Long
Dim saveSelection As Long
Private Sub cbSave_Click()
Dim rep As Document
Dim t As table
Set rep = BWordCreateDocFromArray(getAbbreviationsIntoArray(thisDocDescriptor, xUseTabs:=True))
If rep Is Nothing Then
Me.Hide
Exit Sub
End If
Set t = rep.Range.ConvertToTable(format:=wdTableFormatGrid1, Applyborders:=True)
t.AutoFitBehavior wdAutoFitContent
setTableCharacteristics t
Me.Hide
rep.activate
End Sub
Private Sub UserForm_Initialize()
lblLHBackground.ZOrder (1)
Call formFeatures(Me)
lblInvalidAbbreviation.Visible = False
saveSelection = -1
End Sub
Private Sub UserForm_Activate()
Call AbbreviationListSync
abbreviationList.ListIndex = -1
Call buttonStates
cbAbbreviationAdd.Caption = "Add"
abbreviation.SetFocus
abbreviation.value = ""
definition.value = ""
If saveTop = 0 Then
Else
Me.Top = saveTop
Me.Left = saveLeft
End If
If saveSelection > -1 Then
If abbreviationList.ListCount > saveSelection Then
abbreviationList.ListIndex = saveSelection
End If
End If
End Sub
Private Sub cbAbbreviationChange_Click()
Dim zTerm As String
Dim zDefinition As String
Dim zPos As Long
Dim zString As String
With abbreviationList
zTerm = .List(.ListIndex, 0)
zDefinition = .List(.ListIndex, 1)
saveSelection = .ListIndex
End With
Me.cbAbbreviationAdd.Caption = "Change"
Me.cbAbbreviationChange.Enabled = False
disableClickEventCode = True
Call AbbreviationListSync
abbreviationList.ListIndex = BMin(saveSelection, abbreviationList.ListCount - 1)
disableClickEventCode = False
zString = BRemoveAllSpaces(UCase$(zTerm & abbreviationsListStringDelimiter & zDefinition & abbreviationsListStringDelimiter))
zPos = InStr(uppercaseAbbreviationsList, zString)
If zPos < 1 Then
showMessage c8Msg6000, msgSuffix2:="frmGlossary cbAbbreviationChange_Click: zPos=" & zPos
Exit Sub
End If
uppercaseAbbreviationsList = Left$(uppercaseAbbreviationsList, zPos - 1) & Mid$(uppercaseAbbreviationsList, zPos + Len(zString))
lblInvalidAbbreviation.Caption = c8ChangeAbbreviationText01
lblInvalidAbbreviation.Visible = True
changeAbbreviation = True
disableClickEventCode = True
Me.abbreviation = zTerm
Me.definition = zDefinition
disableClickEventCode = False
abbreviation.SetFocus
End Sub
Private Sub cbClose_Click()
changeAbbreviation = False
Me.Hide
End Sub
Private Sub cbAbbreviationReview_Click()
Dim term As String
Dim definition As String
Dim prefix As String
With abbreviationList
term = .List(.ListIndex, 0)
definition = .List(.ListIndex, 1)
prefix = .List(.ListIndex, 2)
saveSelection = .ListIndex
End With
Me.savePosition Me.Top, Me.Left
Me.Hide
prefix = stripWas(prefix)
frmAbbreviationsReview.setRecoveryDoc ThisDocument.name, ThisDocument.Saved
Select Case findMatches(term, definition, prefix, xHighlightMatches:=True)
Case Is > 0
frmAbbreviationsReview.setMode frmAbbreviationsReviewMode_ReadOnly, term, definition, prefix
frmAbbreviationsReview.show
GoTo finish
Case -1
Dim zString As String
If prefix = c8CurrentDocument Or prefix = c8Administrator Then
zString = "in the current document"
Else
zString = "by source '" & prefix & "'."
End If
MsgBox "Neither <" & term & "> nor <" & definition & "> is used " & zString, vbOKOnly, "Review Abbreviation"
Me.show
Case -2
showMessage c8Msg6000, msgSuffix2:="frmGlossary: findmatches returned -2"
Case -3
End Select
frmAbbreviationsReview.closeRecoveryDoc
finish:
End Sub
Private Sub cbAbbreviationAdd_Click()
Dim oldTerm As String
Dim oldDefinition As String
Dim oldPrefix As String
Dim newPrefix As String
Dim itemPosition As Long
Dim abbreviationSqueezed As String
Dim definitionSqueezed As String
abbreviationSqueezed = BSqueezeSpaces(abbreviation)
definitionSqueezed = BSqueezeSpaces(definition)
If changeAbbreviation Then
With abbreviationList
oldTerm = .List(.ListIndex, 0)
oldDefinition = .List(.ListIndex, 1)
oldPrefix = .List(.ListIndex, 2)
End With
Call cbAbbreviationDelete_Click
changeAbbreviation = False
cbAbbreviationAdd.Caption = "Add"
If findMatches(oldTerm, oldDefinition, stripWas(oldPrefix)) > 0 Then
thisDocFinder.matchesReplaceAllBinary abbreviationSqueezed, definitionSqueezed
End If
Select Case oldPrefix
Case c8CurrentDocument
newPrefix = oldPrefix
Case c8Administrator
newPrefix = oldPrefix
Case Else
If InStr(oldPrefix, "(was") Then
newPrefix = oldPrefix
Else
newPrefix = oldPrefix & " (was " & oldTerm & " - " & oldDefinition & ")"
End If
End Select
Else
newPrefix = c8CurrentDocument
End If
thisDocGlossaryUser.add glKey:=abbreviationSqueezed, glItem:=definitionSqueezed, glPrefix:=newPrefix
thisDocDescriptor.glossaryUser = thisDocGlossaryUser.dumpToString(thisDocGlossaryEncryptor)
itemPosition = CInt(thisDocGlossaryMerged.add(glKey:=abbreviationSqueezed, glItem:=definitionSqueezed, glPrefix:=newPrefix))
Call AbbreviationListSync
abbreviationList.ListIndex = itemPosition - 1
saveSelection = abbreviationList.ListIndex
abbreviation = ""
definition = ""
abbreviationsChangedSinceLastCheck = True
Me.show
End Sub
Private Sub cbAbbreviationDelete_Click()
Dim term As String
Dim definition As String
Dim definedIn As String
With abbreviationList
term = .List(.ListIndex, 0)
definition = .List(.ListIndex, 1)
definedIn = .List(.ListIndex, 2)
saveSelection = .ListIndex
If Me.cbAbbreviationAdd.Caption = "Change" Then
Else
If findMatches(term, definition, stripWas(definedIn)) > 0 Then
If MsgBox("The text contains <" & term & "> and / or <" & definition & ">." & vbNewLine & vbNewLine & "Press OK to delete the abbreviation, or Cancel.", vbOKCancel + vbDefaultButton2, "Delete Abbreviation") = vbCancel Then
Me.show
Exit Sub
End If
End If
End If
thisDocGlossaryMerged.remove glKey:=term, glItem:=definition, glPrefix:=definedIn
thisDocGlossaryUser.remove glKey:=term, glItem:=definition, glPrefix:=definedIn
thisDocDescriptor.glossaryUser = thisDocGlossaryUser.dumpToString(thisDocGlossaryEncryptor)
ppA_AnonymiseAbbreviationSet term, definition, xOn:=False, serialise:=True
Call AbbreviationListSync
If .ListCount > 0 Then .ListIndex = BMin(saveSelection, .ListCount - 1)
End With
abbreviationsChangedSinceLastCheck = True
Call buttonStates
End Sub
Private Sub definition_Change()
If disableClickEventCode Then Exit Sub
Call buttonStates
End Sub
Private Sub abbreviation_Change()
If disableClickEventCode Then Exit Sub
Call buttonStates
End Sub
Private Sub abbreviationList_Click()
If disableClickEventCode Then Exit Sub
abbreviation = ""
definition = ""
cbAbbreviationAdd.Caption = "Add"
Call buttonStates
End Sub
Private Sub AbbreviationListSync()
Dim names() As String
Dim namecount As Long
Dim xEntry As String
Dim i As Long
uppercaseAbbreviationsList = abbreviationsListStringDelimiter
namecount = thisDocGlossaryMerged.count
If namecount > 0 Then
ReDim names(1 To namecount, 1 To 3)
For i = 1 To namecount
xEntry = thisDocGlossaryMerged.getEntryByIndex(i)
names(i, 1) = thisDocGlossaryMerged.getKey(xEntry)
names(i, 2) = thisDocGlossaryMerged.getItem(xEntry)
names(i, 3) = thisDocGlossaryMerged.getPrefix(xEntry)
uppercaseAbbreviationsList = uppercaseAbbreviationsList & names(i, 1) & abbreviationsListStringDelimiter & names(i, 2) & abbreviationsListStringDelimiter
Next i
abbreviationList.List = names
uppercaseAbbreviationsList = BRemoveAllSpaces(UCase$(uppercaseAbbreviationsList))
Else
abbreviationList.clear
End If
End Sub
Private Sub buttonStates()
Dim selectedDefinedIn As String
With abbreviationList
If .ListIndex > -1 Then
selectedDefinedIn = .List(.ListIndex, 2)
Else
selectedDefinedIn = ""
End If
End With
cbAbbreviationAdd.Enabled = validAddition(abbreviation, definition)
cbAbbreviationDelete.Enabled = (selectedDefinedIn = c8CurrentDocument)
cbAbbreviationChange.Enabled = abbreviationList.ListIndex > -1 And validChange(selectedDefinedIn) And cbAbbreviationAdd.Caption = "Add"
cbAbbreviationReview.Enabled = abbreviationList.ListIndex > -1
cbSave.Enabled = abbreviationList.ListCount > 0
End Sub
Private Function validAddition(xTerm As String, xDefinition As String) As Boolean
Dim errMsg As String
errMsg = validateNewAbbreviation(xTerm, xDefinition)
lblInvalidAbbreviation.Caption = errMsg
lblInvalidAbbreviation.Visible = (errMsg > " ")
validAddition = (errMsg = "")
End Function
Private Function validChange(xDefinedIn As String) As Boolean
validChange = True
If xDefinedIn = c8Administrator Then
If thisDocDescriptor.docCreator = c8Administrator Then
Else
validChange = False
End If
End If
End Function
Private Function findMatches(xTerm As String, xDefinition As String, xPrefix As String, Optional xHighlightMatches As Boolean = False) As Long
Dim prefix As String
Dim positiveRowCheck As Boolean
prefix = xPrefix
positiveRowCheck = False
Select Case prefix
Case c8Administrator
prefix = ""
Case c8CurrentDocument
prefix = ""
Case ""
showMessage c8Msg6000, msgSuffix2:="findMatches: blank prefix passed to routine"
findMatches = 0
Exit Function
Case Else
positiveRowCheck = True
End Select
findMatches = ProcessAbbreviations(xMode:=matchMode.reviewAbbreviation, xTerm:=xTerm, xDefinition:=xDefinition, xPrefix:=prefix, xRowCheckPositive:=positiveRowCheck, xHighlightMatches:=xHighlightMatches)
Application.screenUpdating = True
End Function
Private Function stripWas(xPrefix As String) As String
Dim prefix As String
Dim zLong As Long
zLong = InStr(xPrefix, "(was")
If zLong > 0 Then
prefix = Left$(xPrefix, zLong - 2)
Else
prefix = xPrefix
End If
stripWas = prefix
End Function
Sub savePosition(xTop As Long, xLeft As Long)
saveTop = xTop
saveLeft = xLeft
End Sub
Attribute VB_Name = "frmHighlightSource"
Attribute VB_Base = "0{4B63CC74-0519-49B1-93B2-6A143B830238}{B3E4B5E9-3154-4B51-A6B8-CE7846557BF7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Dim formatIndices() As Long
Dim customised() As Boolean
Dim indexInUse() As Boolean
Dim lastValidIndex As Long
Dim suppressEvents As Boolean
Dim currentIndex As Long
Private Sub UserForm_Initialize()
lblLHBackground.ZOrder (1)
lblText1.Caption = "Select a Scope and Colour Scheme. Chronolator will assign a different combination in the Scheme to each Source Prefix."
lblText2.Caption = "The 'Show samples' button creates a document illustrating the Scopes, Colour Schemes " & "and colour combination reference numbers."
lblText3.Caption = "You can use the 'Custom Settings' controls to change the colour combination assigned to a selected Source Prefix."
lblText4.Caption = "Press 'Preview' to create a document showing how each source will appear, or 'OK' to highlight the current document."
scheme00.Caption = colorSchemeNone
scheme07.Caption = colorSchemeBright
scheme02.Caption = colorSchemeTint
scheme03.Caption = colorSchemeShade
scheme04.Caption = colorSchemeTone
scheme05.Caption = colorSchemeTextOnWhite
scheme06.Caption = colorSchemeColorsAndGreys
scheme01.Caption = colorSchemeMixed
scope01.Caption = scopeText
scope02.Caption = scopeCellText
scope03.Caption = scopeRowText
scope04.Caption = scopeCell
scope05.Caption = scopeRow
ReDim formatIndices(0)
ReDim customised(0)
currentIndex = 0
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
suppressEvents = True
cbSamples.Caption = "Show samples"
cbSamples.Enabled = True
cbPreview.Caption = "Preview"
cbPreview.Enabled = True
cbOK.SetFocus
cBoxResetToScheme = True
suppressEvents = False
End Sub
Private Sub cBoxResetToScheme_Click()
If suppressEvents Then Exit Sub
If cBoxResetToScheme Then Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub cbCancel_Click()
Me.Hide
End Sub
Private Sub cbOK_Click()
Dim i As Long
For i = 0 To UBound(formatIndices)
setHighlightIndex comboSourcePrefix.List(i, 0) & " " & c8SourceDelimiter, formatIndices(i), True
Next
setScopeAndScheme GetOptionButton(Me, "scope"), GetOptionButton(Me, "colorScheme")
Me.Hide
buttonHighlightSourceClear.Enabled = True
Call highlightSources(GetOptionButton(Me, "scope"))
End Sub
Private Sub cbPreview_Click()
Dim d As Document
cbPreview.Caption = "Please wait . . ."
cbPreview.Enabled = False
DoEvents
Set d = createPreviewDocument(formatIndices, GetOptionButton(Me, "scope"), GetOptionButton(Me, "colorScheme"))
d.activate
d.ActiveWindow.Visible = True
BSendKeys "^{HOME}"
cbPreview.Caption = "Preview"
cbPreview.Enabled = True
DoEvents
End Sub
Private Sub cbSamples_Click()
Dim d As Document
cbSamples.Caption = "Please wait . . ."
cbSamples.Enabled = False
DoEvents
Set d = createSwatchDocument
d.activate
d.ActiveWindow.Visible = True
BSendKeys "^{HOME}"
cbSamples.Caption = "Show samples"
cbSamples.Enabled = True
DoEvents
End Sub
Private Sub comboSourcePrefix_Change()
If comboSourcePrefix.ListIndex > -1 Then
currentIndex = formatIndices(comboSourcePrefix.ListIndex)
Call updateCurrentPrefix
End If
End Sub
Private Sub updateCurrentPrefix()
formatIndices(comboSourcePrefix.ListIndex) = currentIndex
customised(comboSourcePrefix.ListIndex) = True
If currentIndex > 0 Then indexInUse(currentIndex) = True
lastValidIndex = currentIndex
suppressEvents = True
spinRefNumber.value = currentIndex
textHighlightReference.value = currentIndex
suppressEvents = False
Call setCustomControlsState
End Sub
Private Sub spinRefNumber_Change()
Dim proposal As Long
Dim onEntry As Long
If suppressEvents Then Exit Sub
If Len(comboSourcePrefix.value) = 0 Then Exit Sub
indexInUse(currentIndex) = False
proposal = spinRefNumber.value
onEntry = proposal
Select Case proposal
Case spinRefNumber.Max
proposal = 0
Case spinRefNumber.Min
proposal = UBound(highlightsAll)
End Select
If indexInUse(proposal) Then
currentIndex = getNextFreeIndex(proposal, onEntry > lastValidIndex)
Else
currentIndex = proposal
End If
Call updateCurrentPrefix
End Sub
Private Sub textHighlightReference_Change()
If suppressEvents Then Exit Sub
If Len(comboSourcePrefix.value) = 0 Then Exit Sub
indexInUse(currentIndex) = False
If validHighlightReference(textHighlightReference.value) Then
If indexInUse(textHighlightReference.value) Then
currentIndex = getNextFreeIndex(textHighlightReference.value, textHighlightReference.value > lastValidIndex)
Else
currentIndex = textHighlightReference.value
End If
End If
Call updateCurrentPrefix
End Sub
Private Sub textHighlightReference_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
Dim leftPart As Variant
Dim rightPart As Variant
Dim proposal As String
leftPart = Left$(textHighlightReference.value, textHighlightReference.SelStart)
rightPart = Mid$(textHighlightReference.value, textHighlightReference.SelStart + 1 + textHighlightReference.SelLength)
proposal = leftPart & ChrW$(KeyAscii) & rightPart
If validHighlightReference(proposal) Then
If indexInUse(proposal) Then
KeyAscii = 0
End If
Else
KeyAscii = 0
End If
End Sub
Private Sub scheme00_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub scheme01_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub scheme02_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub scheme03_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub scheme04_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub scheme05_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub scheme06_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub scheme07_Click()
Call setSchemeIndices(GetOptionButton(Me, "colorScheme"))
End Sub
Private Sub setSchemeIndices(xScheme As String)
Dim i As Long
Dim highlightIndex As Long
highlightIndex = colorSchemeStartIndex(xScheme)
For i = 0 To UBound(formatIndices)
If customised(i) And Not cBoxResetToScheme Then
Else
If xScheme = colorSchemeNone Then
formatIndices(i) = 0
Else
formatIndices(i) = highlightIndex
End If
customised(i) = False
End If
highlightIndex = BAddOneModular(highlightIndex, spinRefNumber.Max - 1)
Next
For i = 0 To UBound(indexInUse)
indexInUse(i) = False
Next
For i = 0 To UBound(formatIndices)
If formatIndices(i) > 0 Then indexInUse(formatIndices(i)) = True
Next
If comboSourcePrefix.ListIndex > -1 Then Call comboSourcePrefix_Change
setCustomControlsState
End Sub
Public Sub initialiseSourcePrefixComboBox(xPrefixes() As String)
Dim i  As Long
comboSourcePrefix.clear
For i = 0 To UBound(xPrefixes)
comboSourcePrefix.AddItem Trim$(xPrefixes(i))
Next
End Sub
Public Sub initialiseFormatIndices(xFormatIndices() As Long, xCustomisedIndices() As Boolean)
Dim i  As Long
ReDim formatIndices(UBound(xFormatIndices))
ReDim customised(UBound(xFormatIndices))
ReDim indexInUse(UBound(highlightsAll))
For i = 0 To UBound(xFormatIndices)
formatIndices(i) = xFormatIndices(i)
customised(i) = xCustomisedIndices(i)
If formatIndices(i) > 0 Then indexInUse(formatIndices(i)) = True
Next
End Sub
Public Sub setRadioButtons(xScope As String, xScheme As String)
suppressEvents = True
SetOptionButton xScope, Me, "scope"
SetOptionButton xScheme, Me, "colorScheme"
suppressEvents = False
End Sub
Public Sub setSpinnerLimits(xMin As Integer, xMax As Integer)
spinRefNumber.Min = xMin - 1
spinRefNumber.Max = xMax + 1
End Sub
Public Sub setCustomControlsState()
If Len(comboSourcePrefix.value) = 0 Then
textHighlightReference.value = ""
textHighlightReference.Enabled = False
spinRefNumber.Enabled = False
Else
textHighlightReference.Enabled = True
spinRefNumber.Enabled = True
End If
If Len(comboSourcePrefix.value) = 0 Or spinRefNumber.value = 0 Then
textHighlightReference.foreColor = vbWindowText
textHighlightReference.backColor = formColors(4)
spinRefNumber.foreColor = vbButtonText
spinRefNumber.backColor = vbButtonFace
Else
textHighlightReference.foreColor = highlightsAll(spinRefNumber.value).foreColor
textHighlightReference.backColor = highlightsAll(spinRefNumber.value).backColor
spinRefNumber.foreColor = highlightsAll(spinRefNumber.value).foreColor
spinRefNumber.backColor = highlightsAll(spinRefNumber.value).backColor
End If
End Sub
Private Function getNextFreeIndex(xCurrentIndex As Long, xIncrease As Boolean) As Long
Dim i As Long
i = xCurrentIndex
If xIncrease Then
While indexInUse(i)
i = BAddOneModular(i, UBound(highlightsAll), 0)
Wend
Else
While indexInUse(i)
i = BSubtractOneModular(i, UBound(highlightsAll), 0)
Wend
End If
getNextFreeIndex = i
End Function
Public Function validHighlightReference(xRef As Variant) As Boolean
If IsNumeric(xRef) Then
validHighlightReference = BWithinBounds(CInt(xRef), LBound(highlightsAll), UBound(highlightsAll))
Else
validHighlightReference = False
End If
End Function
Attribute VB_Name = "frmInputBox"
Attribute VB_Base = "0{4324272E-214E-44AE-9E79-04DA05EB8FB1}{1DB66793-9F7C-4BD9-97CF-A02E8E2FC51C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private mandatoryText As Boolean
Private saveHeight As Single
Private Sub txtUserInput_Change()
Call buttonStates
End Sub
Private Sub UserForm_Initialize()
saveHeight = Me.Height
Call setParms
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
Call buttonStates
Me.txtUserInput.SetFocus
Me.txtUserInput.SelStart = 0
Me.txtUserInput.SelLength = Len(Me.txtUserInput)
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
If CloseMode = vbFormControlMenu Then Cancel = 1
End Sub
Private Sub cbCancel_Click()
Me.txtUserInput = ""
Me.Hide
End Sub
Private Sub cbOK_Click()
Me.Hide
End Sub
Private Sub buttonStates()
If mandatoryText And Len(Me.txtUserInput) = 0 Then
Me.cbOK.Enabled = False
Else
Me.cbOK.Enabled = True
End If
End Sub
Public Sub setParms(Optional title As String = "", Optional promptOK As String = "", Optional promptCancel As String = "", Optional showCancel As Boolean = True, Optional forceInput As Boolean = True, Optional defaultText As String = "")
Me.Caption = title
Me.lblOK.Caption = promptOK
Me.lblCancel.Caption = promptCancel
Me.lblCancel.Visible = showCancel
Me.cbCancel.Visible = showCancel
If showCancel Then
Me.Height = saveHeight
Else
Me.Height = saveHeight - cbCancel.Height
End If
mandatoryText = forceInput
Me.txtUserInput = defaultText
End Sub
Public Function userInput() As String
userInput = Me.txtUserInput
End Function
Attribute VB_Name = "frmInternalsReport"
Attribute VB_Base = "0{A64A613C-E575-444A-90FA-9508A58D0C50}{EA555554-1516-42C6-9B41-15408516508F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private displayDetails As Variant
Private saveDoc As Document
Private Sub UserForm_Activate()
Call formFeatures(Me)
txtBox.text = BCreateTextDocFromArray(displayDetails)
txtBox.SetFocus
BSendKeys "^{HOME}"
BSendKeys "{RIGHT}"
Set saveDoc = Nothing
Me.cbSave.Caption = "Save as Document"
Me.cbSave.Enabled = True
End Sub
Private Sub cbOK_Click()
Me.Hide
End Sub
Private Sub cbSave_Click()
Dim rep As Document
Me.cbSave.Caption = "Please Wait"
Me.cbSave.Enabled = False
Set rep = BWordCreateDocFromArray(displayDetails)
If rep Is Nothing Then
Me.Hide
Exit Sub
End If
rep.Styles(wdStyleNormal).ParagraphFormat.LineSpacingRule = wdLineSpaceSingle
rep.Styles(wdStyleNormal).ParagraphFormat.SpaceAfter = 0
rep.Styles(wdStyleHeading1).Font.Size = rep.Styles(wdStyleNormal).Font.Size
rep.Styles(wdStyleHeading2).Font.Size = rep.Styles(wdStyleNormal).Font.Size
rep.Styles(wdStyleHeading3).Font.Size = rep.Styles(wdStyleNormal).Font.Size
rep.Range.Font.name = "Courier New"
rep.PageSetup.Orientation = wdOrientLandscape
Set saveDoc = rep
Me.Hide
rep.activate
End Sub
Public Sub setDisplay(xDisplay As String)
Me.Caption = xDisplay
Select Case xDisplay
Case "Document Details"
displayDetails = getDocDetailsIntoArray(thisDocDescriptor)
Case "Conflicting Definitions"
displayDetails = getConflictingDefinitionsIntoArray()
Case "System Information"
displayDetails = getSystemInfoIntoArray()
End Select
End Sub
Public Function docCreated() As Document
Set docCreated = saveDoc
End Function
Attribute VB_Name = "frmIntervalCalculator"
Attribute VB_Base = "0{0876DD39-C09D-449D-A7C5-BECA1C68832C}{889683A3-FCE9-44FF-ADA2-0B16C1CACE1D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Dim date1 As Date
Dim date2 As Date
Dim clipBoard As clsClipboard
Private Sub UserForm_Initialize()
Set clipBoard = New clsClipboard
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
Dim zString As String
Me.lhBackground.ZOrder (1)
zString = ppI_Date1Get
If Len(zString) = 0 Then
Me.txtDate1.text = format$(Now, "short date")
Else
Me.txtDate1.text = zString
End If
Me.txtDate2.text = ppI_Date2Get
Me.txtDate2.SetFocus
Me.txtDate2.SelStart = 0
End Sub
Private Sub txtDate1_Change()
Call updateDisplay
End Sub
Private Sub txtDate2_Change()
Call updateDisplay
End Sub
Private Sub updateDisplay()
Dim date1Good As Boolean
Dim date2Good As Boolean
date1Good = isValidDateControl(Me.txtDate1, date1, Me.date1ddMMMyyyy)
date2Good = isValidDateControl(Me.txtDate2, date2, Me.date2ddMMMyyyy)
If date1Good And date2Good Then
Me.intervalDDD.Caption = BPluralityText(Abs(DateDiff("d", date1, date2)), "day")
Me.intervalYMD.Caption = bdt.DateDifferenceFormatted(date1, date2)
Me.cbCopy.Visible = True
Else
Me.intervalDDD.Caption = ""
Me.intervalYMD.Caption = ""
Me.cbCopy.Visible = False
End If
End Sub
Private Function isValidDateControl(xControl As textBox, ByRef xOutDate As Date, ByRef xOutLabel As label) As Boolean
Dim z As Variant
z = bdt.DateValueLoose(xControl.value)
If IsEmpty(z) Then
xOutDate = Empty
xOutLabel.Caption = ""
isValidDateControl = False
Else
xOutDate = z
xOutLabel.Caption = format$(xOutDate, "dd MMM yyyy" & vbNewLine & "dddd")
isValidDateControl = True
End If
End Function
Private Sub cbCopy_Click()
clipBoard.SetData xString:=Me.intervalYMD.Caption & " (" & Me.intervalDDD.Caption & ")"
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
ppI_DatesSet Me.txtDate1.text, Me.txtDate2.text
End Sub
Attribute VB_Name = "frmLicenceEvaluation"
Attribute VB_Base = "0{830A3574-B966-4711-ABB7-9D371299AF33}{D7B15DF7-52F0-411E-82C6-FFC82B550EDC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private Sub Cancel_Click()
Me.Hide
End Sub
Private Sub OK_Click()
c8LicenceHasBeenAccepted = True
BWordSessionParameterSet xOption:=c8RegistryKeyLicenceHasBeenAccepted
Me.Hide
End Sub
Private Sub UserForm_Activate()
Me.LicenceTerms.SetFocus
Me.c8Version.Caption = "Version " & c8_Constants.c8Version
On Error GoTo bug22fix
Me.LicenceTerms.CurLine = 0
Exit Sub
bug22fix:
Me.LicenceTerms.CurLine = 1
BSendKeys "{UP}"
End Sub
Private Sub UserForm_Initialize()
Me.LicenceTerms = c8Copyright & "." & String(2, vbNewLine) & Me.LicenceTerms
Call formFeatures(Me)
End Sub
Attribute VB_Name = "frmLicenceLong"
Attribute VB_Base = "0{771D7469-DBBE-41EB-9C2A-B8D91CDB1F50}{862BD307-9E75-4C6A-BF8C-1844CCCC9496}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private Sub Cancel_Click()
Me.Hide
End Sub
Private Sub OK_Click()
Me.Hide
End Sub
Private Sub UserForm_Activate()
Me.ExpiryDate = format$(DateValue(c8LicenceExpiryDate), "dd MMMM yyyy")
Me.Licensee = c8LicenceOwner
If Len(c8LicenceSingleCaseReference) = 0 Then
Me.lblSingleCaseReference.Visible = False
Else
Me.SingleCaseReference = c8LicenceSingleCaseReference
End If
Me.c8Version.Caption = "Version " & c8_Constants.c8Version
Me.LicenceTerms.SetFocus
On Error GoTo bug22fix
Me.LicenceTerms.CurLine = 0
Exit Sub
bug22fix:
Me.LicenceTerms.CurLine = 1
BSendKeys "{UP}"
End Sub
Private Sub UserForm_Initialize()
Me.LicenceTerms = c8Copyright & "." & String(2, vbNewLine) & Me.LicenceTerms
Call formFeatures(Me)
End Sub
Attribute VB_Name = "frmLicenceShort"
Attribute VB_Base = "0{A185A768-EC36-48AF-A3E9-FB8EB468E524}{1F96E881-76F6-41F9-8A4A-D09CB39D4943}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private Sub Cancel_Click()
Me.Hide
End Sub
Private Sub ExtendLicenceButton_Click()
Call licenceExtend
Me.ExpiryDate = format$(DateValue(c8LicenceExpiryDate), "dd MMMM yyyy")
Call licenceCheckExpiry
End Sub
Private Sub OK_Click()
c8LicenceHasBeenAccepted = True
BWordSessionParameterSet xOption:=c8RegistryKeyLicenceHasBeenAccepted
Me.Hide
End Sub
Private Sub UserForm_Activate()
Me.Licensee = c8LicenceOwner
Me.ExpiryDate = format$(DateValue(c8LicenceExpiryDate), "dd MMMM yyyy")
Me.Reference = c8LicenceID
If Len(c8LicenceSingleCaseReference) = 0 Then
Me.lblSingleCaseReference.Visible = False
Else
Me.SingleCaseReference = c8LicenceSingleCaseReference
End If
Me.c8Version.Caption = "Version " & c8_Constants.c8Version
End Sub
Private Sub ViewLicence_Click()
frmLicenceLong.show
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
If CloseMode = vbFormControlMenu Then Cancel = 1
End Sub
Private Sub UserForm_Initialize()
Call formFeatures(Me)
End Sub
Attribute VB_Name = "frmMessage"
Attribute VB_Base = "0{ED326CC0-47E0-4C32-830A-1F68FD0483A4}{C4FEE3E7-5B69-4BB7-9995-64D28A283ADE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Public buttonPressed As String
Private Sub CommandButton1_Click()
buttonPressed = CommandButton1.Caption
Me.Hide
End Sub
Private Sub CommandButton2_Click()
buttonPressed = CommandButton2.Caption
Me.Hide
End Sub
Private Sub CommandButton3_Click()
buttonPressed = CommandButton3.Caption
Me.Hide
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
If CloseMode = vbFormControlMenu Then Cancel = 1
End Sub
Private Sub UserForm_Initialize()
Call setGeometry
Me.c8Version.Caption = "Version " & c8_Constants.c8Version
End Sub
Sub setGeometry()
Dim adjustShortMessage As Single
Dim adjustLongMessage As Single
adjustShortMessage = 0
adjustLongMessage = 0
Select Case BRegistryQueryValue(HKEY_CURRENT_USER, "Control Panel\Desktop", "LogPixels")
Case 96
Case 120
adjustShortMessage = 5
adjustLongMessage = 15
Case 144
adjustShortMessage = 10
adjustLongMessage = 20
Case 92
adjustShortMessage = 20
adjustLongMessage = 40
End Select
Me.FrameShortMessage.Height = Me.FrameShortMessage.Height + adjustShortMessage
Me.ShortMessage.Height = Me.ShortMessage.Height + adjustShortMessage
Me.FrameLongMessage.Height = Me.FrameLongMessage.Height + adjustLongMessage
Me.LongMessage.Height = Me.LongMessage.Height + adjustLongMessage
Me.FrameLongMessage.Top = Me.FrameLongMessage.Top + adjustShortMessage
Me.FrameReference.Top = Me.FrameReference.Top + adjustShortMessage + adjustLongMessage
Me.FrameVersionAndButtons.Top = Me.FrameVersionAndButtons.Top + adjustShortMessage + adjustLongMessage
Me.Height = Me.Height + adjustShortMessage + adjustLongMessage
End Sub
Attribute VB_Name = "frmProgress"
Attribute VB_Base = "0{7C66468C-E462-4DC7-A234-3B00851E75BE}{EF1E3AA2-017C-41A8-9B30-B4E001595949}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private Sub cmdCancel_Click()
progressBar.userCancelled = True
Me.cmdCancel.Enabled = False
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
End Sub
Private Sub UserForm_Initialize()
progressBar.userCancelled = False
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
If CloseMode = vbFormControlMenu Then Cancel = 1
End Sub
Attribute VB_Name = "frmPublishCustom"
Attribute VB_Base = "0{F0005E05-A9CB-44E5-BAD3-1CA96E00AFCF}{9505E7DF-C462-4CFF-A092-E8E6C74FDE98}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' This module and these procedures are Copyright |fffd| 2004-2019 Berrick Computing Ltd www.berrick-computing.co.uk
Option Explicit
Private Sub ckbDateTimeAsis_Click()
If Not ckbDateTimeAsis.value Then ckbDateTimeElapsed = True
Call radioButtonElapsedStates
Call updateDateTimeExample
End Sub
Private Sub ckbDateTimeElapsed_Click()
If Not ckbDateTimeElapsed.value Then ckbDateTimeAsis = True
Call radioButtonElapsedStates
If radioElapsedFormat1.value Or radioElapsedFormat2.value Then
Else
radioElapsedFormat1.value = True
End If
Call updateDateTimeExample
End Sub
Private Sub radioElapsedFormat1_Click()
Call updateDateTimeExample
End Sub
Private Sub radioElapsedFormat2_Click()
Call updateDateTimeExample
End Sub
Private Sub UserForm_Activate()
Call formFeatures(Me)
Call PublishCustomGetParms
Call radioButtonElapsedStates
Call updateDateTimeExample
lblDateTimeExample.ZOrder 1
cbOK.SetFocus
End Sub
Private Sub UserForm_Initialize()
lblLHBackground.ZOrder (1)
Call PublishCustomGetParms
Call radioButtonElapsedStates
Call updateDateTimeExample
End Sub
Private Sub cbOK_Click()
Call PublishCustomSetParms
frmPublishCustomButton = vbOK
Hide
End Sub
Private Sub cbCancel_Click()
frmPublishCustomButton = vbCancel
Hide
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
frmPublishCustomButton = vbCancel
End Sub
Private Sub PublishCustomGetParms()
ckbDateTimeAsis.value = ppP_DateTimeHeadingPrintAsis
ckbDateTimeElapsed.value = ppP_DateTimeOffsetsformat > ppFalse
ckbWriteGeneralHeadings = ppP_WriteGeneralHeadings
Call ckbDateTimeElapsed_Click
End Sub
Private Sub radioButtonElapsedStates()
radioElapsedFormat1.Visible = ckbDateTimeElapsed.value
radioElapsedFormat2.Visible = ckbDateTimeElapsed.value
End Sub
Private Sub PublishCustomSetParms()
Dim dateTimeOffset As String
Dim dateTimeAsis As String
Dim writeGeneralHeadings As String
If ckbDateTimeAsis Then
dateTimeAsis = ppTrue
Else
dateTimeAsis = ppFalse
End If
If ckbDateTimeElapsed.value Then
If radioElapsedFormat1 Then
dateTimeOffset = ppP_DateTimeOffsetsFormat1
Else
dateTimeOffset = ppP_DateTimeOffsetsFormat2
End If
Else
dateTimeOffset = ppFalse
End If
If ckbWriteGeneralHeadings Then
writeGeneralHeadings = ppTrue
Else
writeGeneralHeadings = ppFalse
End If
ppSaveStatus
Call ppP_DateTimeHeadingParmsSet(dateTimeAsis, dateTimeOffset)
Call ppP_WriteGeneralHeadingParmsSet(writeGeneralHeadings)
ppSerialise
End Sub
Private Sub updateDateTimeExample()
Dim zText1 As String
Dim zText2 As String
If ckbDateTimeAsis Then zText1 = " " & format$(Date, replace(ppP_LastDateFormatGet, vbVerticalTab, " "))
If ckbDateTimeElapsed.value Then
If radioElapsedFormat1 Then
zText2 = "Day 67 13:55"
Else
zText2 = "2 Months, 4 days, 1 hour, 55 minutes"
End If
If ckbDateTimeAsis Then zText2 = "(" & zText2 & ")"
Else
zText2 = ""
End If
Me.lblDateTimeExample = Trim$(zText1 & " " & zText2)
End Sub

' InQuest injected base64 decoded content
' j+t:
' Bjr&
' j+u'
' j+t:
' j+u+Z
' ^t(Z
' +^u+k
' j+u6
' j+u6
' j+tg
' j+t:
' j+t*)
' j+u6
' j+u6
' RwhN
' j+u6
' j+u'
' j+u'
' j+t*
' j+u6
' j+u6
' j+u6
' j+u6
' j+u6
' j+u*
' "w+zg
' bzW@
' &"jh
' ~,Bj
' "{-j{
' z{Lj
' '!zg
' LmzwLj
' x)^j
' "wbq
' yJ]j
' xLmzwBj
' xz%u
' 0>'-
' (^rD
' (^rA
' (^rC
' ^"{^
' )^j{
' ~`ZrD
' xLmz{"
' x%x&
' LmzwCj
' +tLi
' Szjej
' z{Cy
' ,.+-
' x%x&

INQUEST-PP=macro
