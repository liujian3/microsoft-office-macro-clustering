Attribute VB_Name = "AutoStart"
Option Explicit

Public Const dot_type_addin    As Long = 1
Public Const dot_type_template As Long = 2
Public Const Property_Addin_Version As String = "addin_version"
Public Const addin_name             As String = "audimex_addin.dot"
Public Const addin_name_prefix      As String = "audimex_addin_v"
Public Const addin_name_suffix      As String = ".dot"
Public Const addin_name_pattern     As String = addin_name_prefix & "#*" & addin_name_suffix
Public Const addin_version_marker   As String = "###"

Public eventListener   As EventsModule ' gesetzt in RegisterEventHandler
Public oldNoOfOpenDocs As Long
Public FirstNewDoc     As Boolean
Public dot_type As Long
Public attached_addin_name As String

Public clean          As Boolean ' zeigt an, ob am Ende "CleanUp" laufen soll
Public developer_mode As Boolean ' falls true, werden einige MsgBox-Meldungen mehr gezeigt
Public test_mode      As Boolean ' in release deaktivieren!

Sub ActivateTestMode()
    test_mode = True
End Sub

Sub AutoExec()
    dot_type = dot_type_addin
    Call OpenProc("AutoExec")
End Sub

Sub AutoOpen()
    dot_type = dot_type_template
    Call OpenProc("AutoOpen")
    update_keep_alive_time
    start_keep_alive
End Sub

Sub AutoExit()
    Call CloseProc("AutoExit")
End Sub

Sub AutoClose()
    Call CloseProc("AutoClose")
    update_keep_alive_time
End Sub


Private Sub DeveloperActivateAddin()
    developer_mode = True
    Call AutoExec
End Sub

Sub OpenProc(Caller As String)
    Dim ActiveDocName As String
    Dim ActiveDocFullName As String
    Dim res As Long
    Dim saved_state As Boolean
    Log_Enter "OpenProc() called from " & Caller
    
    ' in release deaktivieren!
    test_mode = False
    
    ' Folgender Abschnitt nur zur Unterst|fffd|tzung des Entwicklers
    On Error Resume Next
    ActiveDocName = ""
    ActiveDocName = ActiveDocument.name
    ActiveDocFullName = ""
    ActiveDocFullName = ActiveDocument.FullName
    On Error GoTo 0
    
    ' Testen, ob das ActiveDocument (falls es existiert) das als Datei ge|fffd|ffnete Addin ist...
    If (ActiveDocFullName <> ThisDocument.FullName) Then
        Log_Info "Code l|fffd|uft nicht im ActiveDocument -> Praxis oder Test, weiter."
    ElseIf (developer_mode) Then
        Log_Info "Code l|fffd|uft zwar im ActiveDocument, aber developer_mode = true -> Praxis oder Test, weiter."
    Else
        Log_Info "Code l|fffd|uft im ActiveDocument -> Entwicklung, Stop."
        MsgBox "Audimex-Addin ist als Dokument ge|fffd|ffnet,  AutoOpen-Makro wird nicht ausgef|fffd|hrt (" & ActiveDocument.name & ")", vbOKOnly, "audimex-Addin"
        Log_Leave "OpenProc()"
        Exit Sub
    End If
    
    If (ThisDocument.name Like addin_name_pattern) Then
        If (Not developer_mode) Then
            MsgBox "Audimex-Addin l|fffd|uft im Entwicklermodus."
        End If
        Log_Info "developer_mode = true"
        developer_mode = True
    Else
        Log_Info "developer_mode = false"
        developer_mode = False
    End If
    
    If (dot_type = dot_type_template) Then
        Log_Trace "Running as template: checking installed addins"
        If (audimex_addin_installed) Then
            On Error Resume Next
            Log_Dev "Template.OpenProc: Gleichzeitig installiertes Addin entdeckt -> Addin hat Vorrang"
            saved_state = ActiveDocument.Saved
            Log_Trace "Storing saved state of ActiveDocument (" & saved_state & ")"
            Log_Trace "Detaching template (" & ActiveDocument.AttachedTemplate.FullName & ") from " & ActiveDocument.name
            ActiveDocument.AttachedTemplate = ""
            Log_Trace "Closing template file"
            ThisDocument.Close saveChanges:=False
            Log_Trace "Setting saved state of ActiveDocument to previous value (" & saved_state & ")"
            ActiveDocument.Saved = saved_state
            Log_Leave "OpenProc() [Addin detected]"
            On Error GoTo 0
            Exit Sub
        End If
    End If
    
    clean = False ' CleanUp soll laufen
    
    If (Not dm_is_initialized) Then
        Log_Info "dm_is_initialized() -> false"
        Err.Clear
        On Error GoTo 0
        Call lg_open
        Log_Info "in OpenProc called from " & Caller
        Call dm_init
        Call RegisterEventHandler
        attached_addin_name = ThisDocument.FullName
    End If
    On Error GoTo 0
    
    Call refreshDokuSlots_v2("OpenProc")
    
    ThisDocument.Saved = True
    Log_Leave "OpenProc()"
    Log_Separator
End Sub


Sub CloseProc(Caller As String)
    Dim d As Document
    Dim C As Long
    
    If (Application.Documents.Count >= 1) Then
        If (ActiveDocument.name = ThisDocument.name) Then
            Exit Sub
        End If
    End If
    
    If (dot_type = dot_type_template) Then
        If (audimex_addin_installed) Then
            Log_Dev "Template.AutoClose: Gleichzeitig installiertes Addin entdeckt -> Addin hat Vorrang"
            Exit Sub
        End If
    End If
    
    Log_Enter "CloseProc() called from " & Caller
    
    Log_Trace "Checking existing documents for attached template..."
    C = 0
    For Each d In Application.Documents
        If (d.AttachedTemplate.name = ThisDocument.name) Then
            Log_Info "found " & d.name
            C = C + 1
        End If
    Next
    
    If (C > 1) Then
        Log_Info "more than 1 document based on '" & ThisDocument.name & "' exists"
        Log_Leave "CloseProc() [still in use, CleanUp not called]"
        Log_Separator
        Exit Sub
    Else
        Log_Info "0 or 1 documents found."
    End If
    
    Call CleanUp("CloseProc")
    Log_Leave "CloseProc()"
    Log_Separator
    Call lg_close
End Sub


Function audimex_addin_installed() As Boolean
    Dim a As AddIn
    Dim addinname As String
    Dim addincount As Long, addinindex As Long
    
    Log_Enter "audimex_addin_installed()"
    audimex_addin_installed = False
    
    On Error Resume Next
    addincount = -1
    addincount = Application.AddIns.Count
    If (Err.Number > 0) Then
        Log_Warn "Error accessing Application.AddIns.Count"
        Err.Clear
    Else
        Log_Info "Collection ""Application.AddIns"" has " & addincount & " element(s)."
    End If
    On Error GoTo 0
    
    For Each a In Application.AddIns
        
        On Error Resume Next
        addinname = ""
        addinname = a.name
        If (Err.Number > 0) Then
            addinindex = -1
            addinindex = a.Index
            Log_Warn "Error accessing .Name of Application.AddIns.Item(" & addinindex & ")"
            Err.Clear
        End If
        On Error GoTo 0
        
        If (a.Installed And (addinname Like addin_name_pattern Or addinname = addin_name)) Then
            Log_Info "found " & a.name
            audimex_addin_installed = True
            Log_Leave "audimex_addin_installed() [found]"
            Exit Function
        End If
    Next
    
    Log_Leave "audimex_addin_installed() [not found]"
End Function


Private Sub RegisterEventHandler()
    Log_Enter "RegisterEventHandler()"
    Set eventListener = New EventsModule ' free in EventsModule.WdApp_Quit
    Set eventListener.WdApp = Word.Application
    Log_Leave "RegisterEventHandler()"
End Sub


Public Sub CleanUp(Caller As String)
    Log_Enter "CleanUp() called from " & Caller
    
    If (clean) Then
        Log_Leave "CleanUp() [already clean]"
        Exit Sub
    End If
    
    Log_Trace "Removing temp files"
    Call killTempDokuSlots
    Log_Trace "Removing audimex menu"
    Call AudimexMenuRemove
    Log_Trace "Removing Dok() array"
    Call dm_final
    Log_Trace "Removing default display texts"
    Call sk_final(rm_default)
    Log_Trace "Removing loaded display texts"
    Call sk_final(rm_i18n)
    Log_Trace "Removing list of docParams"
    Call pu_final
    
    If (eventListener Is Nothing) Then
        Log_Trace "Event listener already detached"
    Else
        Log_Trace "Detaching event listener"
        Set eventListener.WdApp = Nothing
        Set eventListener = Nothing
    End If
    
    clean = True
    Log_Leave "CleanUp()"
End Sub


Private Sub Test_ShowMenuMacros()
    Dim C As CommandBarControl
    Dim s As String
    Dim l As Long
    l = 60
    s = ""
    With Application.CommandBars(cstrAudimexMenuPositionWord) ' "menu bar"
        With .Controls("audimex")
            For Each C In .Controls
                s = s & C.Enabled & vbTab & Left(C.OnAction & String(l, " "), l) & vbTab & C.Caption & vbNewLine
            Next
        End With
    End With
    MsgBox s, vbOKOnly + vbInformation, "audimex Test"
End Sub


Attribute VB_Name = "ConversionUtilities"
Function hours_stamp_from_seconds(x As Long) As String
    If x >= 86400 Then hours_stamp_from_seconds = "23:59:59": Exit Function
    If x = 0 Then hours_stamp_from_seconds = "00:00:00": Exit Function
    Dim hours As Long
    Dim minutes As Byte
    Dim seconds As Byte
    hours = x \ 3600
    Debug.Print hours
    x = x Mod 3600
    minutes = x \ 60
    Debug.Print minutes
    x = x Mod 60
    seconds = x
    Debug.Print seconds
    hours_stamp_from_seconds = lpad(LTrim(Str(hours)), 2, "0") & ":" & lpad(LTrim(Str(minutes)), 2, "0") & ":" & lpad(LTrim(Str(seconds)), 2, "0")
    
End Function

Function rpad(existing As String, padding_character As String, width As Long) As String
    rpad = Left(existing & String(width, padding_character), width)
End Function
Attribute VB_Name = "DocParam"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const cstr_param_mandatory As String = "1"
Private Const cstr_param_optional  As String = "0"

Private m_name As String
Private m_mandatory As String
Private m_type As String
Private m_default As String


Property Get name() As String
    name = m_name
End Property

Property Let name(x As String)
    m_name = x
End Property


Property Get ptype() As String
    ptype = m_type
End Property

Property Let ptype(x As String)
    m_type = x
End Property


Property Get mandatory() As Boolean
    mandatory = (m_mandatory = cstr_param_mandatory)
End Property

Property Let mandatory(x As Boolean)
    m_mandatory = IIf(x, cstr_param_mandatory, cstr_param_optional)
End Property


Property Get default() As String
    default = m_default
End Property

Property Let default(x As String)
    m_default = x
End Property


Attribute VB_Name = "DocuManager"
Option Explicit

Public Const DOC_FILE_NUM As Integer = 100
Public Dok() As DocuSlot

Public Function dm_is_initialized() As Boolean
    Dim dummy As Long
    On Error Resume Next
    dm_is_initialized = True
    dummy = UBound(Dok)
    dm_is_initialized = (Err.Number = 0)
    Err.Clear
End Function

Public Sub dm_init()
    Dim i As Long
    ReDim Dok(0 To DOC_FILE_NUM)
    For i = 0 To DOC_FILE_NUM
        Set Dok(i) = New DocuSlot
        Dok(i).freeSlot
        Dok(i).slot_index = i
    Next
    oldNoOfOpenDocs = 0
    FirstNewDoc = True
End Sub

Public Sub dm_final()
    Dim i As Long
    If (Not dm_is_initialized) Then Exit Sub
    For i = 0 To DOC_FILE_NUM
        Set Dok(i) = Nothing
    Next
    Erase Dok
End Sub

Sub checkDokument()
    Log_Enter "checkDokument()"
    Call refreshDokuSlots_v2("checkDocument")
    Log_Leave "checkDokument()"
End Sub

Sub killTempDokuSlots()
    Dim i As Long
    Log_Enter "killTempDokuSlots()"
    ' Array vorhanden?
    If (Not dm_is_initialized) Then
        Log_Leave "killTempDokuSlots() [ERROR: DocumentManager not initialized]"
        Exit Sub
    End If
    ' Array durchlaufen, Temp-Eintr|fffd|ge l|fffd|schen
    For i = 0 To DOC_FILE_NUM
        With Dok(i)
            If (.is_temp) Then
                Log_Trace "Found remaining temporary file '" & .name & "' in slot " & i
                Call .killSlot
            End If
        End With
    Next
    Log_Leave "killTempDokuSlots()"
End Sub

' Dokumentenliste mit WordApplication abgleichen
Sub refreshDokuSlots_v2(Caller As String, Optional bUpdateMenu As Boolean = True, Optional bReadParams As Boolean = True)
    Dim txt As String
    Dim i As Long
    Dim aktSlot As DocuSlot
    Log_Enter "refreshDokuSlots() called by " & Caller
    ' Array vorhanden?
    If (Not dm_is_initialized) Then
        MsgBox2 asr(ark_DocMan_NotInitialized), vbCritical + vbOKOnly
        Log_Leave "refreshDokuSlots() [ERROR: DocumentManager not initialized]"
        Exit Sub
    End If
    Call refreshDokuSlots_v2_A(aktSlot)
    Call refreshDokuSlots_v2_B(aktSlot, bReadParams)
    Call refreshDokuSlots_v2_C(aktSlot, bUpdateMenu)
    Log_Leave "refreshDokuSlots()"
End Sub

Sub refreshDokuSlots_v2_A(ByRef aktSlot As DocuSlot)
    Dim i As Long, firstFree As Long
    Dim anyDoc As Boolean
    Log_Trace "Scanning document array"
    firstFree = -1
    Set aktSlot = Nothing
    anyDoc = dm_checkForActiveDocument()
    For i = 0 To DOC_FILE_NUM
        With Dok(i)
            If (Not .is_free) Then
                If (Not .is_open) Then
                    If (.is_temp) Then
                        Log_Info "-> found closed temp document (Slot=" & i & ")"
                        Call .killSlot
                    Else
                        Log_Info "-> found closed, non-temp document  (Slot=" & i & ", nothing to do)"
                    End If
                    Log_Trace "freeing slot " & i & " (" & .name & ")"
                    Call .freeSlot
                    If (firstFree = -1) Then
                        Log_Info "-> this slot becomes first free slot (" & i & ")"
                        firstFree = i
                    End If
                Else
                    ' Gibt es ein aktives Dokument und ist es noch nicht gefunden?
                    If (anyDoc And (aktSlot Is Nothing)) Then
                        ' Ist es das Aktuelle Dokument ?
                        If (.name = ActiveDocument.FullName) Then
                            Log_Info "-> found ActiveDocument (Slot=" & i & ", " & .name & ")"
                            Set aktSlot = Dok(i)
                        End If
                    End If
                End If
            Else
                ' freier Slot gefunden
                If (firstFree = -1) Then
                    Log_Info "-> found first free slot (" & i & ")"
                    firstFree = i
                End If
            End If
        End With
    Next

    ' gibt es ein neues Dokument?
    If (anyDoc And (aktSlot Is Nothing)) Then
        ' Wenn kein freier Slot bekannt ist, Fehler ausgeben
        If (firstFree = -1) Then
            MsgBox2 asr(ark_DocMan_NoFreeSlot), vbCritical + vbOKOnly
            Log_Error "No free slot found."
            Exit Sub
        Else
            Set aktSlot = Dok(firstFree)
        End If
    End If
End Sub

'---------------------------------------------------------------------------------
' B. tr|fffd|gt ggf. neues aktives Dokument in den freien Slot ein und liest Parameter ein
' aktSlot:
'    Nothing - kein Dokument ge|fffd|ffnet
'       leer - ActiveDocument ist neu
'      sonst - ActiveDocument ist nicht neu, aktSlot enth|fffd|lt Daten
Sub refreshDokuSlots_v2_B(aktSlot As DocuSlot, bReadParams As Boolean)
    Log_Trace "Check for new document"
    ' Wenn kein ActiveDocument vorhanden ist, nichts tun
    If (aktSlot Is Nothing) Then
        Log_Info "-> no ActiveDocument, nothing to do"
        Exit Sub
    End If
    Log_Info "-> ActiveDocument present"
    ' Wenn Dokument in den Slots vorhanden ist, nichts tun
    If (Not aktSlot.is_free) Then
        Log_Info "-> ActiveDocument already registered (slot=" & aktSlot.slot_index & ")"
        Exit Sub
    End If
    Log_Info "-> ActiveDocument not registered yet"
    ' Wenn wir hierhin kommen, ist der Slot noch leer -> neu belegen
    Log_Info "-> filling slot " & aktSlot.slot_index & ", name=" & ActiveDocument.FullName
    With aktSlot
        Set .doc_object = ActiveDocument
        .name = ActiveDocument.FullName
        .id = ""
        .is_temp = False ' TODO: falsch, falls refreshDokuSlots waehrend Upload aufgerufen wird (nach temp save)
        .is_read_only = False
    End With
    ' evtl. noch Parameter lesen
    If (bReadParams) Then
        Call readParams(ActiveDocument, aktSlot)
    End If
End Sub

'---------------------------------------------------------------------------------
' C. passt Menue-Anzeige an
Sub refreshDokuSlots_v2_C(aktSlot As DocuSlot, bUpdateMenu As Boolean)
    ' Men|fffd|-Anpassung nur auf Anforderung
    If Not bUpdateMenu Then
        Log_Trace "Skipping menu update"
        Exit Sub
    End If
    Log_Trace "Show/hide menu"
    
    ' Addin: Men|fffd| wird dynamisch erzeugt/entfernt
    If (aktSlot Is Nothing) Then
        Log_Trace "no ActiveDocument, hide menu"
        Call AudimexMenuHide
        Exit Sub
    End If
    
    Log_Trace "check type of ActiveDocument"
    If (CheckParams(ActiveDocument, True)) Then
        Log_Info "-> audimex document, show menu"
        Log_Push
        Log_Trace "ActiveDocument   = " & ActiveDocument.FullName
        Log_Trace "aktSlot.name     = " & aktSlot.name
        Log_Trace "ThisDocument     = " & ThisDocument.FullName
        Log_Trace "AttachedTemplate = " & ActiveDocument.AttachedTemplate.FullName
        If aktSlot.fallback_path() <> "" Then
            Log_Trace "Fallback         = " & aktSlot.fallback_path()
        End If
        Log_Pop
        If ActiveDocument.AttachedTemplate.FullName = ThisDocument.FullName Then
            'Um evtl. im Cache befindliche AddIns auszuschlie|fffd|en
            Log_Push
            Log_Trace "check resource manager"
            If (rm_i18n Is Nothing) Then
                ' audimex-Dokument & Strings fehlen -> holen
                Log_Info "-> loading resources"
                Call sk_PingServerConnection(aktSlot)
                Call sk_loadResourceManager(aktSlot, rm_i18n)
            Else
                Log_Info "-> already initialized"
            End If
            Log_Pop
            Log_Info "-> show menu"
            If AudimexMenuInstalled() = False Then
                ' Maximales Men|fffd| installieren
                Call AudimexMenuInstall(Nothing, False)
            End If
            ' Alles unsichtbar schalten + zugeh|fffd|rige Men|fffd|punkte einblenden
            Call AudimexMenuHide
            Call AudimexMenuActivate(aktSlot, aktSlot.is_read_only)
            aktSlot.SetCaption
        Else
            Log_Info "AttachedTemplate and ThisDocument do missmatch."
            If aktSlot.fallback_path = ThisDocument.FullName Then
                Log_Info "But a proper fallback was set, so showing menu."
                If AudimexMenuInstalled() = False Then
                    ' Maximales Men|fffd| installieren
                    Call AudimexMenuInstall(Nothing, False)
                End If
                Call AudimexMenuHide
                Call AudimexMenuActivate(aktSlot, aktSlot.is_read_only)
                aktSlot.SetCaption
            Else
                Log_Info "So not showing menu."
            End If
        End If
    Else
        Log_Info "no audimex document, hide menu"
        Call AudimexMenuHide
    End If
End Sub

' Gibt es momentan |fffd|berhaupt ein ge|fffd|ffnetes Dokument?
Function dm_checkForActiveDocument() As Boolean
    Dim dummy As String
    On Error Resume Next
    dummy = Application.ActiveDocument.name
    dm_checkForActiveDocument = (Err.Number = 0)
    Err.Clear
End Function

Private Sub testStrings()
    Dim aktds As DocuSlot
    Dim test_rm_i18n As Collection
    If (dm_is_initialized) Then
        Call refreshDokuSlots_v2_A(aktds)
        Call sk_loadResourceManager(aktds, test_rm_i18n)
    End If
End Sub

Sub test_dumpDokuSlots()
    Dim i As Long
    Dim txt As String
    txt = "dumpDokuSlots" & Chr(10) & Chr(10)
    For i = 0 To DOC_FILE_NUM
        With Dok(i)
            If (.name <> "") Then
                txt = txt & .name & Chr(9) & """" & .docName & """" & Chr(9) & .id & Chr(9) & .is_temp & Chr(10)
            End If
        End With
    Next
    MsgBox txt
End Sub

' Bestimme zum ActiveDocument das DocuSlot-Objekt
Function GetActiveDocumentSlot() As DocuSlot
    On Error Resume Next
    Set GetActiveDocumentSlot = Nothing
    Set GetActiveDocumentSlot = Dok(GetActiveDocumentIndex())
    Err.Clear
End Function

' Bestimme zum ActiveDocument den Index in Dok()
Function GetActiveDocumentIndex() As Long
    On Error Resume Next
    GetActiveDocumentIndex = -1
    GetActiveDocumentIndex = GetDocumentIndexByDocument(ActiveDocument)
    Err.Clear
End Function

Function GetDocumentIndexByName(docName As String) As Long
    Dim i As Long
    For i = 0 To DOC_FILE_NUM
        If (docName = Dok(i).name) Then
            GetDocumentIndexByName = i
            Exit Function
        End If
    Next i
    GetDocumentIndexByName = -1
End Function
    
' Bestimme zum Dokument doc den Index in Dok()
Function GetDocumentIndexByDocument(doc As Document) As Long
    Dim i As Long
    For i = 0 To DOC_FILE_NUM
        If (Dok(i).doc_object Is doc) Then
            GetDocumentIndexByDocument = i
            Exit Function
        End If
    Next i
    GetDocumentIndexByDocument = -1
End Function
        
' get first valid audimex doc
Function GetNextAudimexDocIndex() As Long
    Dim i As Long
    For i = 0 To DOC_FILE_NUM
        If (Not Dok(i).doc_object Is Nothing) Then
            GetNextAudimexDocIndex = i
            Exit Function
        End If
    Next i
    GetNextAudimexDocIndex = -1
End Function

' Bestimme zum Dokument doc das DocuSlot-Objekt
Function GetDocumentSlotByDocument(doc As Document) As DocuSlot
    On Error Resume Next
    Set GetDocumentSlotByDocument = Nothing
    Set GetDocumentSlotByDocument = Dok(GetDocumentIndexByDocument(doc))
    Err.Clear
End Function
        
' nach login neue session-ID verteilen
Sub dm_ReSetIdAll(src_ds As DocuSlot)
    Dim dst_doc As Document
    Dim dst_ds As DocuSlot
    Dim dp As DocParam
    Log_Enter "dm_ReSetIdAll()"
    On Error Resume Next
    Set dp = makeDocParam(AUDIMEX_ID, msoPropertyTypeString) ' free lokal
    
    For Each dst_doc In Application.Documents
        Log_Trace "Inspecting " & dst_doc.name
        Set dst_ds = GetDocumentSlotByDocument(dst_doc)
        If (Not (dst_ds Is Nothing)) Then
            If (CheckParams(dst_doc)) Then
                Log_Info "-> resetting ID to " & src_ds.id & " (was: " & dst_ds.id & ")"
                dst_ds.id = src_ds.id
                Call setParam(dst_doc, dp, src_ds.id) ' auch in DocumentProperties setzen
            Else
                Log_Info "-> no audimex document."
            End If
        Else
            Log_Info "-> not registered in this scope"
        End If
    Next
    
    Set dp = Nothing
    If (Err.Number > 0) Then
        Log_Leave "dm_ReSetIdAll() [Error: (" & Err.Number & ") " & Err.Description & "]"
        Err.Clear
        Exit Sub
    End If
    Log_Leave "dm_ReSetIdAll()"
End Sub

Attribute VB_Name = "DocuSlot"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const cstr_Tag_Tempfile       As String = "X"
Private Const cstr_Tag_Persistentfile As String = "-"
Private Const cstr_Tag_ReadOnly       As String = "1"
Private Const cstr_Tag_ReadWrite      As String = "0"
Private Const cstr_Tag_NTLM           As String = "win"
Private Const cstr_Tag_SITEMINDER     As String = "SITEMINDER"
Private Const cstr_Tag_MELLON         As String = "MELLON"

'Die m|fffd|ssen String sein, weil sie an anderer Stelle genau so |fffd|bergeben/erwartet werden!
Private m_id As String              ' AUDIMEX_ID
Private m_server As String          ' AUDIMEX_SERVER
Private m_url As String             ' AUDIMEX_URL
Private m_docname As String         ' AUDIMEX_DOC_NAME
Private m_obj_id As String          ' AUDIMEX_OBJ_ID
Private m_doc_id As String          ' AUDIMEX_DOC_ID
Private m_doc_type_id As String     ' AUDIMEX_DOC_TYPE
Private m_tx_time As String         ' AUDIMEX_TX_TIME
Private m_tx_user As String         ' AUDIMEX_TX_USER
Private m_doc_status As String      ' AUDIMEX_DOC_STATE
Private m_port As String            ' AUDIMEX_PORT
Private m_protocol As String        ' AUDIMEX_PROTOCOL
Private m_read_only As String       ' AUDIMEX_READ_ONLY
Private m_can_extract As String     ' AUDIMEX_CAN_EXTRACT
Private m_customize As String       ' AUDIMEX_CUSTOMIZE
Private m_auth As String            ' AUDIMEX_AUTH
Private m_save_format As String     ' AUDIMEX_SAVE_FORMAT
Private m_doc_mode As String        ' AUDIMEX_DOC_MODE
Private m_tab_col_id As String      ' AUDIMEX_TAB_COL_ID
Private m_keep_alive_time As String ' AUDIMEX_KEEP_ALIVE_TIME
Private m_fallback_path As String   ' AUDIMEX_FALLBACK_PATH


Private m_name As String
Private m_is_temp As String
Private m_slot_index As Long
Private m_doc_object As Document
Private m_username As String
Private m_server_ping_interval As Long

#If VBA7 Or Win64 Then
Private Declare PtrSafe Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As LongPtr) As Long
#Else
Private Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#End If

' Constructor!
Private Sub Class_Initialize()
    m_keep_alive_time = "0"
End Sub


'------------------------------
' Getter / Setter
'------------------------------
Property Get slot_index() As Long
    slot_index = m_slot_index
End Property
Property Let slot_index(x As Long)
    m_slot_index = x
End Property

Property Get doc_object() As Document
    Set doc_object = m_doc_object
End Property
Property Set doc_object(x As Document)
    Set m_doc_object = x
End Property

Property Get name() As String
    name = m_name
End Property
Property Let name(x As String)
    m_name = x
End Property

Property Get is_temp() As Boolean
    is_temp = (m_is_temp = cstr_Tag_Tempfile)
End Property
Property Let is_temp(x As Boolean)
    m_is_temp = IIf(x, cstr_Tag_Tempfile, cstr_Tag_Persistentfile)
End Property

Property Get temp() As String
    is_temp = m_is_temp
End Property
Property Let temp(x As String)
    m_is_temp = x
End Property

Property Get ping_interval() As Long
    ping_interval = m_server_ping_interval
End Property
Property Let ping_interval(x As Long)
    m_server_ping_interval = x
End Property

'AUDIMEX_DOC_MODE
Property Get doc_mode() As String
    doc_mode = m_doc_mode
End Property
Property Let doc_mode(x As String)
    m_doc_mode = x
End Property

'AUDIMEX_TAB_COL_ID
Property Get tab_col_id() As String
    tab_col_id = m_tab_col_id
End Property
Property Let tab_col_id(x As String)
    m_tab_col_id = x
End Property

'AUDIMEX_ID
Property Get id() As String
    id = m_id
End Property
Property Let id(x As String)
    m_id = x
End Property

'AUDIMEX_SERVER
Property Get server() As String
    server = m_server
End Property
Property Let server(x As String)
    m_server = x
End Property

'AUDIMEX_URL
Property Get url() As String
    url = m_url
End Property
Property Let url(x As String)
    m_url = x
End Property

'AUDIMEX_DOCNAME
Property Get docName() As String
    docName = m_docname
End Property
Property Let docName(x As String)
    m_docname = x
End Property

'AUDIMEX_OBJ_ID
Property Get obj_id() As String
    obj_id = m_obj_id
End Property
Property Let obj_id(x As String)
    m_obj_id = x
End Property

'AUDIMEX_DOC_ID
Property Get doc_id() As String
    doc_id = m_doc_id
End Property
Property Let doc_id(x As String)
    m_doc_id = x
End Property

'AUDIMEX_DOC_TYPE_ID
Property Get doc_type_id() As String
    doc_type_id = m_doc_type_id
End Property
Property Let doc_type_id(x As String)
    m_doc_type_id = x
End Property

'AUDIMEX_TX_TIME
Property Get tx_time() As String
    tx_time = m_tx_time
End Property
Property Let tx_time(x As String)
    m_tx_time = x
End Property

'AUDIMEX_TX_USER
Property Get tx_user() As String
    tx_user = m_tx_user
End Property
Property Let tx_user(x As String)
    m_tx_user = x
End Property

'AUDIMEX_DOC_STATUS
Property Get doc_status() As String
    doc_status = m_doc_status
End Property
Property Let doc_status(x As String)
    m_doc_status = x
End Property

'AUDIMEX_PORT
Property Get port() As String
    port = m_port
End Property
Property Let port(x As String)
    m_port = x
End Property

'AUDIMEX_PROTOCOL
Property Get protocol() As String
    protocol = m_protocol
End Property
Property Let protocol(x As String)
    m_protocol = x
End Property

'AUDIMEX_READ_ONLY
Property Get read_only() As String
    read_only = m_read_only
End Property
Property Let read_only(x As String)
    m_read_only = x
End Property

Property Get is_read_only() As Boolean
    is_read_only = (m_read_only = cstr_Tag_ReadOnly)
End Property
Property Let is_read_only(x As Boolean)
    m_read_only = IIf(x, cstr_Tag_ReadOnly, cstr_Tag_ReadWrite)
End Property

'AUDIMEX_CAN_EXTRACT
Property Get can_extract() As String
    can_extract = m_can_extract
End Property
Property Let can_extract(x As String)
    m_can_extract = x
End Property

'AUDIMEX_CUSTOMIZE
Property Get customize() As String
    customize = m_customize
End Property
Property Let customize(x As String)
    m_customize = x
End Property

'AUDIMEX_SAVE_FORMAT
Property Get save_format() As String
    save_format = m_save_format
End Property
Property Let save_format(x As String)
    m_save_format = x
End Property

'AUDIMEX_AUTH
Property Get auth() As String
    auth = m_auth
End Property
Property Let auth(x As String)
    Dim Puffer As String * 256
    Dim ret As Long
    m_auth = x
    m_username = ""
    If (x = "win") Then
        ret = GetUserName(Puffer, Len(Puffer))
        m_username = IIf(ret = 0, "", Left$(Puffer, InStr(1, Puffer, vbNullChar) - 1))
    End If
End Property

Property Get is_ntlm() As Boolean
    is_ntlm = (m_auth = cstr_Tag_NTLM)
End Property

Property Get is_siteminder() As Boolean
    is_siteminder = (UCase(m_auth) = cstr_Tag_SITEMINDER)
End Property

Property Get is_mellon() As Boolean
    is_mellon = (UCase(m_auth) = cstr_Tag_MELLON)
End Property

Property Get username() As String
    username = m_username
End Property

Property Let username(x As String)
    m_username = x
End Property

'AUDIMEX_KEEP_ALIVE_TIME
Property Get keep_alive_time() As String
    keep_alive_time = m_keep_alive_time
End Property

Property Let keep_alive_time(x As String)
    m_keep_alive_time = Val(x)
End Property

'AUDIMEX_CAN_EXTRACT
Property Get fallback_path() As String
    fallback_path = m_fallback_path
End Property
Property Let fallback_path(x As String)
    If x <> "" Then
        Log_Info "Found fallback path in word document, applying it..."
        Dim old_x As String
        old_x = x
        Call replaceText(x, "%appdata%", Environ("appdata"))
        Call replaceText(x, "%homepath%", Environ("homepath"))
        Call replaceText(x, "%homedrive%", Environ("homedrive"))
        If old_x <> x Then Log_Info "Expanded " & old_x & " to " & x
        If (Right(x, 1) <> "\" And UCase(Right(x, 17)) <> "audimex_addin.dot") Then x = x + "\audimex_addin.dot"
        If Right(x, 1) = "\" Then x = x + "\audimex_addin.dot"
    End If
    m_fallback_path = x
End Property


'------------------------------
' Methoden
'------------------------------

Sub freeSlot()
    m_is_temp = False
    m_name = ""
    m_id = ""
    Set m_doc_object = Nothing
    m_server_ping_interval = 0
End Sub

Function is_free() As Boolean
    is_free = (m_name = "")
End Function

Function is_open() As Boolean
    Dim dummy As String
    On Error Resume Next
    dummy = Application.Documents(m_name).name
    is_open = (Err.Number = 0)
    Err.Clear
End Function

' Setze Fenstertitel auf (logischen / audimex-) Dateinamen
Sub SetCaption()
    ActiveWindow.Caption = ActiveDocument.name & " (audimex: " & m_docname & ")"
End Sub

Function dumpParam(Optional indent As Boolean = False) As String
    Dim b As String
    Dim indent_level As String
    indent_level = IIf(indent, Log_Indent_Level(), "")
    b = vbCrLf
    b = b & indent_level & "              id = " & m_id & vbCrLf
    b = b & indent_level & "          server = " & m_server & vbCrLf
    b = b & indent_level & "             url = " & m_url & vbCrLf
    b = b & indent_level & "         docname = " & m_docname & vbCrLf
    b = b & indent_level & "          obj_id = " & m_obj_id & vbCrLf
    b = b & indent_level & "          doc_id = " & m_doc_id & vbCrLf
    b = b & indent_level & "     doc_type_id = " & m_doc_type_id & vbCrLf
    b = b & indent_level & "         tx_time = " & m_tx_time & vbCrLf
    b = b & indent_level & "         tx_user = " & m_tx_user & vbCrLf
    b = b & indent_level & "      doc_status = " & m_doc_status & vbCrLf
    b = b & indent_level & "            port = " & m_port & vbCrLf
    b = b & indent_level & "        protocol = " & m_protocol & vbCrLf
    b = b & indent_level & "       read_only = " & m_read_only & vbCrLf
    b = b & indent_level & "     can_extract = " & m_can_extract & vbCrLf
    b = b & indent_level & "       customize = " & m_customize & vbCrLf
    b = b & indent_level & "     save_format = " & m_save_format & vbCrLf
    b = b & indent_level & "            auth = " & m_auth & vbCrLf
    b = b & indent_level & "        doc_mode = " & m_doc_mode & vbCrLf
    b = b & indent_level & "      tab_col_id = " & m_tab_col_id & vbCrLf
    b = b & indent_level & " keep_alive_time = " & m_keep_alive_time & vbCrLf
    b = b & indent_level & "   fallback_path = " & m_fallback_path & vbCrLf
    dumpParam = b
End Function

Sub set_param(i As String, v As String)
    Select Case i
    Case AUDIMEX_ID
        id = v
    Case AUDIMEX_SERVER
        server = v
    Case AUDIMEX_URL
        url = v
    Case AUDIMEX_DOCNAME
        docName = v
    Case AUDIMEX_OBJECT_ID
        obj_id = v
    Case AUDIMEX_DOC_ID
        doc_id = v
    Case AUDIMEX_DOC_TYPE_ID
        doc_type_id = v
    Case AUDIMEX_TX_TIME
        tx_time = v
    Case AUDIMEX_TX_USER
        tx_user = v
    Case AUDIMEX_DOC_STATE
        doc_status = v
    Case AUDIMEX_PORT
        port = v
    Case AUDIMEX_PROTOCOL
        protocol = v
    Case AUDIMEX_READ_ONLY
        read_only = v
    Case AUDIMEX_CAN_EXTRACT
        can_extract = v
    Case AUDIMEX_CUSTOMIZE
        customize = v
    Case AUDIMEX_SAVE_FORMAT
        save_format = v
    Case AUDIMEX_AUTH
        auth = v
    Case AUDIMEX_DOC_MODE
        doc_mode = v
    Case AUDIMEX_TAB_COL_ID
        tab_col_id = v
    Case AUDIMEX_KEEP_ALIVE_TIME
        keep_alive_time = v
    Case AUDIMEX_FALLBACK_PATH
        fallback_path = v
    Case Else
        Log_Warn "DocuSlot.set_param() called with unknown key(" & i & "), value(" & v & ")"
    End Select
End Sub

Sub killSlot()
    Log_Enter "DocuSlot.killSlot(" & m_name & ")"
    On Error Resume Next
    If (is_open) Then
        Log_Warn "still open."
    ElseIf (Dir(m_name) = "") Then
        Log_Warn "does not exist."
    Else
        Kill m_name
        If (Err.Number > 0) Then
            Log_Warn "delete failed (" & Err.Description & ")"
            Err.Clear
        Else
            Log_Info "deleted."
            Call freeSlot
        End If
    End If
    Log_Leave "DocuSlot.killSlot()"
End Sub

Attribute VB_Name = "EventsModule"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' The WithEvents keyword specifies that WdApp will provide events.
Public WithEvents WdApp As Word.Application ' gesetzt in AutoStart.RegisterEventHandler
Attribute WdApp.VB_VarHelpID = -1

Private Sub WdApp_Quit()
    Log_Enter_EventProc "WdApp_Quit()"
    Call CleanUp("EventsModule.WdApp_Quit")
    Log_Leave "WdApp_Quit()"
End Sub

Private Sub WdApp_DocumentBeforeClose(ByVal doc As Document, Cancel As Boolean)
    Dim res As String
    Dim showFragments As Boolean
    Dim old_doc_mode As String
    Dim save_ret As Boolean
    Log_Enter "WdApp_DocumentBeforeClose()"
    If (Not IsObjectValid(doc) Or doc Is Nothing) Then
        Log_Leave "WdApp_DocumentBeforeClose() [doc object not valid or nothing]"
        Log_Separator
        Exit Sub
    End If
    Log_Trace "WdApp_DocumentBeforeClose(Doc = " & doc.name & ", Cancel = " & Cancel & ")"
    Dim openNewDocument As Boolean
    openNewDocument = (Documents.Count = 1 And TimerIsRunning)
    
    If (doc.Saved) Then
        Log_Trace "WdApp_DocumentBeforeClose() [saved]"
    Else
        If (CheckParams(doc)) Then
            Dim ds As DocuSlot
            Set ds = GetDocumentSlotByDocument(doc)
            
            showFragments = False
            If (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL) Then
                showFragments = True
            End If
            res = SaveAsBox2(asr(ark_ExtendedSaveBox_Question), asr(ark_ExtendedSaveBox_Title), showFragments)
            Select Case res
            Case "OK"
                Log_Info "save"
                old_doc_mode = ds.doc_mode
                If (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL) Then
                    ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_DOCUMENT
                End If
                Call Audimex_Save(doc, True)
                ds.doc_mode = old_doc_mode
                Cancel = Not doc.Saved
            Case "OK_FRAGMENTS"
                Log_Info "save fragments too"
                old_doc_mode = ds.doc_mode
                
                If (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL) Then
                    ' Schnipsel sichern
                    save_ret = Audimex_Save(doc, False)
                    If save_ret = True Then
                        ' Dokument sichern
                        ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_DOCUMENT
                        Call Audimex_Save(doc, True)
                    End If
                Else
                    ' Dokument sichern
                    Call Audimex_Save(doc, True)
                End If
                ds.doc_mode = old_doc_mode
                Cancel = Not doc.Saved
            Case "NO"
                Log_Info "don't save"
                doc.Saved = True
            Case "CANCEL"
                Log_Info "Cancel=True"
                Cancel = True
                openNewDocument = False
            End Select
            
            Log_Trace "WdApp_DocumentBeforeClose() [audimex doc]"
        Else
            Log_Trace "WdApp_DocumentBeforeClose() [no audimex doc]"
        End If
    End If
    
    ' leave at least 1 document open to preserve siteminder connection
    If (openNewDocument) Then Documents.Add
    
    Log_Leave "WdApp_DocumentBeforeClose()"
    Log_Separator
End Sub


Private Sub WdApp_DocumentBeforeSave(ByVal doc As Document, SaveAsUI As Boolean, Cancel As Boolean)
    If Not SaveAsUI Then
        Cancel = Cancel
    End If
End Sub


Private Sub WdApp_DocumentChange()
    Dim newNoOfOpenDocs As Long
    Dim docAdded As Boolean
    Dim docClosed As Boolean
    Log_Enter "WdApp_DocumentChange()"
    ' Log_Info "Setting .DisplayAlerts=wdAlertsAll (was:" & Application.DisplayAlerts & ", -1=all, -2=msgbox, 0=none)"
    ' Application.DisplayAlerts = wdAlertsAll
    Call checkDokument
    On Error GoTo ExitCode

    ' Feststellen, ob ein Dokument ge|fffd|ffnet, geschlossen oder nur der Focus gewechselt wurde
    newNoOfOpenDocs = Application.Documents.Count
    Log_Info "#doc before: " & oldNoOfOpenDocs
    Log_Info "#doc after:  " & newNoOfOpenDocs
    If newNoOfOpenDocs > oldNoOfOpenDocs Then
        Log_Info "-> more documents"
        docAdded = True
        If ActiveDocument.name = "Document1" And FirstNewDoc Then
            Log_Info "FirstNewDoc and 'Document1'"
            FirstNewDoc = True
        Else
            Log_Info "not FirstNewDoc or not 'Document1'"
            FirstNewDoc = False
        End If
        oldNoOfOpenDocs = newNoOfOpenDocs
    ElseIf oldNoOfOpenDocs > newNoOfOpenDocs Then
        Log_Info "-> fewer documents"
        docClosed = True
        FirstNewDoc = False
        oldNoOfOpenDocs = newNoOfOpenDocs
    Else
        Log_Info "-> same number of documents"
    End If

    ' Entsprechend reagieren
    If docAdded Then
        Log_Info "If docAdded"
        If Len(ActiveDocument.Path) = 0 Then
            Call PseudoAutoNew
        Else
            Call PseudoAutoOpen
        End If
    ElseIf docClosed Then
        Log_Info "Elsif docClosed"
        Call PseudoAutoClose
    ElseIf FirstNewDoc Then
        Log_Info "Elsif FirstNewDoc"
        If Len(ActiveDocument.Path) = 0 Then
            Call PseudoAutoNew
        Else
            Call PseudoAutoOpen
        End If
    Else
        Log_Info "Else"
        Call DocChangedFocus
    End If
    
    ' Schlusswort
    Log_Leave "WdApp_DocumentChange()"
    Log_Separator
    Exit Sub
ExitCode:
    Log_Error "(" & Err.Number & ")" & Err.Description
    Log_Leave "WdApp_DocumentChange() [Error]"
    Log_Separator
End Sub

Private Sub PseudoAutoNew()
    Log_Trace "PseudoAutoNew()"
End Sub

Private Sub PseudoAutoOpen()
    Log_Trace "PseudoAutoOpen()"
End Sub

Private Sub PseudoAutoClose()
    Log_Trace "PseudoAutoClose()"
End Sub

Private Sub DocChangedFocus()
    Log_Trace "DocChangedFocus()"
End Sub

Attribute VB_Name = "ExtendedInputBox"
Attribute VB_Base = "0{040BA593-9864-48C1-8767-D143E2F4955C}{04F57BCF-200D-4A97-AFD4-276BA9668134}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit


Private Sub ExtendedInputBox_Button_Cancel_Click()
  Log_Trace "ExtendedInputBox_Button_Cancel_Click()"
  ExtendedInputBox_Ok = False
  Me.Hide
  DoEvents
End Sub

Private Sub ExtendedInputBox_Button_Ok_Click()
  Log_Trace "ExtendedInputBox_Button_Ok_Click()"
  ExtendedInputBox_Ok = True
  Me.Hide
  DoEvents
End Sub
Attribute VB_Name = "ExtendedSaveBox"
Attribute VB_Base = "0{8A287934-144F-43BE-802F-F1D99906D8F3}{2E9BB902-3496-4397-8EE0-49FA36E00911}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub ExtendedSaveBox_Button_Cancel_Click()
  Log_Trace "ExtendedSaveBox_Button_Cancel_Click()"
  ExtendedSaveBox_Ret = "CANCEL"
  Me.Hide
  DoEvents
End Sub

Private Sub ExtendedSaveBox_Button_No_Click()
  Log_Trace "ExtendedSaveBox_Button_Ok_Click()"
  ExtendedSaveBox_Ret = "NO"
  Me.Hide
  DoEvents
End Sub

Private Sub ExtendedSaveBox_Button_Yes_Click()
  Log_Trace "ExtendedSaveBox_Button_Ok_Click()"
  If (Me.chk_Fragments.Visible = True And Me.chk_Fragments.value = True) Then
    ExtendedSaveBox_Ret = "OK_FRAGMENTS"
  Else
    ExtendedSaveBox_Ret = "OK"
  End If
  Me.Hide
  DoEvents
End Sub
Attribute VB_Name = "Extract"
Option Explicit

Public global_vals As Collection

Sub Audimex_Menu_UploadTable()
    Dim dummy As Long
    Log_Enter "Audimex_Menu_UploadTable()"
    dummy = UploadTable(True)
    Log_Leave "Audimex_Menu_UploadTable()"
    Log_Separator
End Sub

Function UploadTable(checkSession As Boolean) As Long
    Dim C As comment
    Dim i As Long, num As Long, maxNum As Long
    Dim x As String
    Dim res As Boolean
    Dim ds As DocuSlot
    Dim ThisProc As String
    ThisProc = "UploadTable"
    Log_Enter ThisProc
    UploadTable = au_export_not_set
    Set ds = GetActiveDocumentSlot
    Log_Info ds.dumpParam(True)
    ' Jetzt gehts los
    Set global_vals = Nothing ' gef|fffd|llt in ProcessIrRegularTable
    Log_Trace "Searching for stb comments..."
    maxNum = 0
    For Each C In ActiveDocument.content.Comments
        If isAudimexComment(C) Then
            num = extractOrder(C)
            maxNum = IIf(num > maxNum, num, maxNum)
        End If
    Next
    Log_Info "Found " & maxNum & " stb comments."
    res = True
    For i = 1 To maxNum
        Log_Trace "Processing stb comment #" & i
        For Each C In ActiveDocument.content.Comments
            If isAudimexComment(C) Then
                num = extractOrder(C)
                If (num = i) Then
                    Log_Info "comment text: " & Left(C.Range.Text, 15) & "..."
                    res = ProcessComment(ds, C, checkSession) ' allokiert global_vals
                    Exit For
                End If
            Else
                Log_Info "not audimex comment"
            End If
        Next
        If (Not res) Then Exit For
    Next i
    
    If (Not res) Then
        UploadTable = au_export_error
        If (checkSession) Then
            MsgBox2 asr(ark_Upload_Failed), vbCritical
        End If
    Else
        UploadTable = au_export_ok
        If (checkSession) Then
            MsgBox2 asr(ark_Upload_Succeeded), vbInformation
        End If
    End If
    
    Set global_vals = Nothing ' aus ProcessComment ff.
    Log_Leave ThisProc
End Function

Function isAudimexComment(C As comment) As Boolean
    isAudimexComment = (C.Initial = "stb")
End Function

Function ExtractType(C As comment) As Long
    Dim t As String, t1 As String
    ExtractType = 0
    t = C.Range.Text
    t1 = getItemN(t, 2, ",")
    If (UCase(t1) Like "TABLES*") Then
        ExtractType = 2 ' Regular
    Else
        ExtractType = 1 ' Irregular
    End If
End Function

Function extractOrder(C As comment) As Long
    Dim t As String, t1 As String
    On Error Resume Next
    extractOrder = 0
    t = C.Range.Text
    t1 = getItemN(t, 1, ",") ' order(x)
    extractOrder = CLng(extractKeywordValue(t1, "order(", ")")) ' x
    Err.Clear
End Function

Function extractKeywordValue(s As String, before As String, after As String) As String
    On Error Resume Next
    extractKeywordValue = ""
    extractKeywordValue = Mid(s, Len(before) + 1, Len(s) - Len(after) - Len(before))
    Err.Clear
End Function

Function ProcessComment(ds As DocuSlot, C As comment, checkSession As Boolean) As Boolean
    Dim c_type As String
    Log_Enter "ProcessComment()"
    If (C.Scope.Tables.Count <> 1) Then
        Log_Error "Keine oder mehr als zwei Tabellen in Kommentar[" & C.Index & "]"
        MsgBox asr(ark_Extract_Error_Number_Tables) & "[" & C.Index & "]"
        C.Scope.Select
        ProcessComment = False
    Else
        c_type = ExtractType(C)
        Select Case c_type
        Case 1
            ProcessComment = ProcessIrRegularTable(C.Scope.Tables(1), C.Range) ' allokiert global_vals
        Case 2
            ProcessComment = ProcessRegularTable(ds, C.Scope.Tables(1), C.Range.Text, checkSession)
        End Select
    End If
    Log_Leave "ProcessComment()"
End Function

Function ProcessIrRegularTable(t As Table, desc As String) As Boolean
    Dim init_finish_date As String
    Dim t1 As String, errtxt As String
    Dim v_name As String, v_cell As String, v_nametype As String, v_type As String
    Dim cell_row As String, cell_col As String, myval As String
    Dim type_ok As Boolean, dummy_date As Date, dummy_long As Long, dummy_double As Double
    Dim ThisProc As String
    ThisProc = "ProcessIrRegularTable()"
    Log_Enter ThisProc
    t1 = getNextItem(desc, ",") ' order(x)
    Do While (desc <> "")
        t1 = getNextItem(desc, ",") ' name(xxx@ttt)=>cell(yyy/zzz)
        If (t1 = "") Then Exit Do
        v_nametype = getItemN(t1, 1, "=>")  ' name(xxx@ttt)
        v_nametype = extractKeywordValue(v_nametype, "name(", ")") 'xxx@ttt
        v_name = getItemN(v_nametype, 1, "@")
        v_type = getItemN(v_nametype, 2, "@")
        v_cell = getItemN(t1, 2, "=>") ' cell(yyy/zzz) oder value(aaa)
        ' cell(.) oder value(.)
        If (UCase(v_cell) Like "CELL*") Then
            v_cell = extractKeywordValue(v_cell, "cell(", ")") ' yyy/zzz
            cell_row = getItemN(v_cell, 1, "/") 'yyy
            cell_col = getItemN(v_cell, 2, "/") 'zzz
            On Error Resume Next
            myval = ""
            myval = t.Cell(CLng(cell_row), CLng(cell_col)).Range.Text
            Err.Clear
        Else
            myval = extractKeywordValue(v_cell, "value(", ")") ' aaa
        End If
        ' Typ pr|fffd|fen
        type_ok = True
        On Error Resume Next
        Select Case v_type
        Case "date"
            dummy_date = CDate(myval)
            errtxt = asr(ark_Extract_Error_Datatype_Date)
            type_ok = (myval <> "")
        Case "long"
            dummy_long = CLng(myval)
            errtxt = asr(ark_Extract_Error_Datatype_Long)
        Case "double"
            dummy_double = CDbl(myval)
            errtxt = asr(ark_Extract_Error_Datatype_Double)
        End Select
        If (type_ok) Then type_ok = (Err.Number = 0)
        If (type_ok) Then errtxt = ""
        On Error GoTo 0
        ' evt. fehlermeldung ausgeben
        If (Not type_ok) Then
            t.Cell(CLng(cell_row), CLng(cell_col)).Select
            MsgBox asr(ark_Extract_Error_Cell) & vbCrLf & errtxt
            ProcessIrRegularTable = False
            Log_Leave ThisProc & "[Error]"
            Exit Function
        Else
            ' in Collection eintragen
            If (global_vals Is Nothing) Then
                Set global_vals = New Collection ' free in audimex_menu_upload_table
            End If
            On Error Resume Next
            global_vals.Add key:=v_name, Item:=myval
            Err.Clear
        End If
    Loop
    ProcessIrRegularTable = True
    Log_Leave ThisProc
End Function

Function ProcessRegularTable(ds As DocuSlot, t As Table, desc As String, checkSession As Boolean) As Boolean
    Dim r As row, C As Cell
    Dim x As String, y As String
    Dim first As Boolean
    Dim extra_cols_index As Long, extra_cols As String, extra_col As String
    Dim res As String, operation As String
    Dim z As Long, s As Long, m As String
    Dim ThisProc As String
    ThisProc = "ProcessRegularTable()"
    Log_Enter ThisProc
    y = ""
    For Each r In t.rows
        x = ""
        first = True
        For Each C In r.Cells
            If (Not first) Then x = x & ","
            x = x & prepareCellText(C.Range.Text)
            first = False
        Next
        ' now add extra cols
        extra_cols_index = InStr(UCase(desc), "EXTRA_COLS")
        extra_cols = Mid(desc, extra_cols_index)
        extra_cols = extractKeywordValue(extra_cols, "extra_cols(", ")")
        Do While (extra_cols <> "")
            extra_col = getNextItem(extra_cols, ",")
            If (Not first) Then x = x & ","
            If (extra_col = "$") Then
                x = x & "-" ' dummy-Spalte, hier wird auf dem Server activity_id eingesetzt
            Else
                On Error Resume Next
                x = x & prepareCellText(global_vals.Item(extra_col))
                If (Err.Number > 0) Then
                    Log_Error "No value for key >" & extra_col & "<"
                    ProcessRegularTable = False
                    Log_Leave ThisProc & " [non-exixtent key]"
                    Exit Function
                End If
                On Error GoTo 0
            End If
            first = False
        Loop
        y = y & x & Chr(10)
    Next
    
    ' Session_ID
    If (Not checkSession) Then
        Log_Trace "Skipping session validation"
    Else
        Log_Trace "Session-ID valid?"
        Call cursorWait
        Call showStatus(asr(ark_Status_CheckSessionid))
        x = Audimex_SessionOK(ds)
        Log_Info "-> Audimex_SessionOk() = " & x
        If (x <> au_session_valid) Then
            Select Case x
            Case au_session_user_cancel
                MsgBox2 asr(ark_Save_SessionidInvalid), vbExclamation + vbOKOnly
            Case au_session_error
                MsgBox2 asr(ark_Save_SessionidError), vbExclamation + vbOKOnly
            Case Else
                MsgBox2 asr(ark_Save_SessionidUnknownError), vbExclamation + vbOKOnly
            End Select
            Call clearStatus
            Call cursorNormal
            ProcessRegularTable = False
            Log_Leave "ProcessRegularTable [Session]"
            Exit Function
        End If
    End If
    
    ' Operation bestimmen, insert ist default, update muss in einem "irregular table" stehen
    On Error Resume Next
    operation = "INSERT"
    operation = global_vals.Item("p_operation")
    On Error GoTo 0
    
    ' Upload
    res = Request_Data(ds, desc, y, operation)
    ProcessRegularTable = (res Like cstr_ServerOkPattern)
    If (res Like cstr_ServerOkPattern) Then
        ' nop
    ElseIf (res Like "NOK*") Then
        z = CLng(getItemN(res, 2, vbLf))
        s = CLng(getItemN(res, 3, vbLf))
        m = getItemN(res, 4, vbLf)
        If (z = 0) Then
            t.Select
        ElseIf (s = 0) Then
            t.rows(z).Select
        Else
            t.Cell(z, s).Select
        End If
        MsgBox2 asr(ark_Extract_Error_Cell) & vbCrLf & UrlDecode(m), vbExclamation + vbOKOnly
    Else
        MsgBox2 asr(ark_Http_NoServer), vbCritical + vbOKOnly
    End If
    Log_Leave "ProcessRegularTable() [" & ProcessRegularTable & "]"
End Function

Function prepareCellText(s As String) As String
    Call replaceText(s, Chr(13) & Chr(7), "")
    prepareCellText = UrlEncode(s)
End Function

Attribute VB_Name = "HttpProtokoll"
Option Explicit

Public going_on As Boolean
Public connection_retry_interval As String

' Initializes an application's use of the Win32 Internet functions
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" _
(ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, _
ByVal sProxyBypass As String, ByVal lFlags As Long) As LongPtr
#Else
Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" _
(ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, _
ByVal sProxyBypass As String, ByVal lFlags As Long) As Long
#End If

' Use registry access settings.
Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0

' Opens a HTTP session for a given site.
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function InternetConnect Lib "wininet.dll" Alias "InternetConnectA" _
(ByVal hInternetSession As LongPtr, ByVal sServerName As String, ByVal nServerPort As Integer, _
ByVal sUserName As String, ByVal sPassword As String, ByVal lService As Long, _
ByVal lFlags As Long, ByVal lContext As Long) As LongPtr
#Else
Private Declare Function InternetConnect Lib "wininet.dll" Alias "InternetConnectA" _
(ByVal hInternetSession As Long, ByVal sServerName As String, ByVal nServerPort As Integer, _
ByVal sUserName As String, ByVal sPassword As String, ByVal lService As Long, _
ByVal lFlags As Long, ByVal lContext As Long) As Long
#End If

' Number of the TCP/IP port on the server to connect to.
Private Const INTERNET_DEFAULT_FTP_PORT = 21
Private Const INTERNET_DEFAULT_GOPHER_PORT = 70
Private Const INTERNET_DEFAULT_HTTP_PORT = 80
Private Const INTERNET_DEFAULT_HTTPS_PORT = 443
Private Const INTERNET_DEFAULT_SOCKS_PORT = 1080

' Type of service to access.
Private Const INTERNET_SERVICE_FTP = 1
Private Const INTERNET_SERVICE_GOPHER = 2
Private Const INTERNET_SERVICE_HTTP = 3

' Opens an HTTP request handle.
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function HttpOpenRequest Lib "wininet.dll" Alias "HttpOpenRequestA" _
(ByVal hHttpSession As LongPtr, ByVal sVerb As String, ByVal sObjectName As String, ByVal sVersion As String, _
ByVal sReferer As String, ByVal something As Long, ByVal lFlags As Long, ByVal lContext As Long) As LongPtr
#Else
Private Declare Function HttpOpenRequest Lib "wininet.dll" Alias "HttpOpenRequestA" _
(ByVal hHttpSession As Long, ByVal sVerb As String, ByVal sObjectName As String, ByVal sVersion As String, _
ByVal sReferer As String, ByVal something As Long, ByVal lFlags As Long, ByVal lContext As Long) As Long
#End If

' Brings the data across the wire even if it locally cached.
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_SECURE = &H800000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_IGNORE_CERT_CN_INVALID = &H1000
Private Const INTERNET_FLAG_IGNORE_CERT_DATE_INVALID = &H2000
Private Const SECURITY_FLAG_IGNORE_UNKNOWN_CA = &H100
Private Const INTERNET_OPTION_SECURITY_FLAGS = 31
Private Const RECEIVE_TIMEOUT = 60000
Private Const SEND_TIMEOUT = 900000
Private Const INTERNET_OPTION_RECEIVE_TIMEOUT = 6
Private Const INTERNET_OPTION_SEND_TIMEOUT = 5

' sets a cookie, only needed for Siteminder
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function InternetSetCookie Lib "wininet.dll" Alias "InternetSetCookieA" _
(ByVal lpszUrlName As String, ByVal lpszCookieName As String, _
ByVal lpszCookieData As String) As Boolean
#Else
Private Declare Function InternetSetCookie Lib "wininet.dll" Alias "InternetSetCookieA" _
(ByVal lpszUrlName As String, ByVal lpszCookieName As String, _
ByVal lpszCookieData As String) As Boolean
#End If

' Sends the specified request to the HTTP server.
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function HttpSendRequest Lib "wininet.dll" Alias "HttpSendRequestA" (ByVal _
hHttpRequest As LongPtr, ByVal sHeaders As String, ByVal lHeadersLength As Long, ByVal sOptional As _
String, ByVal lOptionalLength As Long) As Integer
#Else
Private Declare Function HttpSendRequest Lib "wininet.dll" Alias "HttpSendRequestA" (ByVal _
hHttpRequest As Long, ByVal sHeaders As String, ByVal lHeadersLength As Long, ByVal sOptional As _
String, ByVal lOptionalLength As Long) As Integer
#End If

' Reads data from a handle opened by the HttpOpenRequest function.
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
(ByVal hFile As LongPtr, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
lNumberOfBytesRead As Long) As Integer
#Else
Private Declare Function InternetReadFile Lib "wininet.dll" _
(ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
lNumberOfBytesRead As Long) As Integer
#End If

' Closes a single Internet handle or a subtree of Internet handles.
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" _
(ByVal hInet As LongPtr) As Integer
#Else
Private Declare Function InternetCloseHandle Lib "wininet.dll" _
(ByVal hInet As Long) As Integer
#End If

' Queries an Internet option on the specified handle
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function InternetQueryOption Lib "wininet.dll" Alias "InternetQueryOptionA" _
(ByVal hInternet As LongPtr, ByVal lOption As Long, ByRef sBuffer As Any, ByRef lBufferLength As Long) As Integer
#Else
Private Declare Function InternetQueryOption Lib "wininet.dll" Alias "InternetQueryOptionA" _
(ByVal hInternet As Long, ByVal lOption As Long, ByRef sBuffer As Any, ByRef lBufferLength As Long) As Integer
#End If

#If VBA7 Or Win64 Then
Private Declare PtrSafe Function InternetSetOption Lib "wininet.dll" Alias "InternetSetOptionA" _
(ByVal hInternet As LongPtr, ByVal lOption As Long, ByVal sBuffer As LongPtr, ByVal lBufferLength As Long) As Integer
#Else
Private Declare Function InternetSetOption Lib "wininet.dll" Alias "InternetSetOptionA" _
(ByVal hInternet As Long, ByVal lOption As Long, ByVal sBuffer As Long, ByVal lBufferLength As Long) As Integer
#End If

' Adds one or more HTTP request headers to the HTTP request handle.
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function HttpAddRequestHeaders Lib "wininet.dll" Alias "HttpAddRequestHeadersA" _
(ByVal hHttpRequest As LongPtr, ByVal sHeaders As String, ByVal lHeadersLength As Long, _
ByVal lModifiers As Long) As Integer
#Else
Private Declare Function HttpAddRequestHeaders Lib "wininet.dll" Alias "HttpAddRequestHeadersA" _
(ByVal hHttpRequest As Long, ByVal sHeaders As String, ByVal lHeadersLength As Long, _
ByVal lModifiers As Long) As Integer
#End If

' Replaces or removes a header. If the header value is empty and the header is found,
' it is removed. If not empty, the header value is replaced
Private Const HTTP_ADDREQ_FLAG_REPLACE = &H80000000
Private Const HTTP_ADDREQ_FLAG_ADD_IF_NEW = &H10000000
Private Const HTTP_ADDREQ_FLAG_ADD = &H20000000
'
' Fehlerbehandlung
Private Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
Private Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Private Const SUBLANG_DEFAULT = &H1
Private Const LANG_NEUTRAL = &H0
#If VBA7 Or Win64 Then
Private Declare PtrSafe Function GetLastError Lib "kernel32" () As Long
Private Declare PtrSafe Function FormatMessage Lib "kernel32" Alias "FormatMessageA" ( _
ByVal dwFlags As Long, _
lpSource As Any, _
ByVal dwMessageId As Long, _
ByVal dwLanguageId As Long, _
ByVal lpBuffer As String, _
ByVal nSize As Long, _
Arguments As LongPtr) As Long
#Else
Private Declare Function GetLastError Lib "kernel32" () As Long
Private Declare Function FormatMessage Lib "kernel32" Alias "FormatMessageA" ( _
ByVal dwFlags As Long, _
lpSource As Any, _
ByVal dwMessageId As Long, _
ByVal dwLanguageId As Long, _
ByVal lpBuffer As String, _
ByVal nSize As Long, _
Arguments As Long) As Long
#End If

Dim audimex_web_login As Object

Function GetPlainWalUrl(url As String) As String
Dim pos As Integer
pos = InStr(1, url, "wal.fcgi")
If (pos > 0) Then
    GetPlainWalUrl = Left(url, pos + 7)
    Exit Function
End If
pos = InStr(1, url, "wal2.fcgi")
If (pos > 0) Then
    GetPlainWalUrl = Left(url, pos + 8)
    Exit Function
End If
pos = InStr(1, url, "wal3.fcgi")
If (pos > 0) Then
    GetPlainWalUrl = Left(url, pos + 8)
    Exit Function
End If
pos = InStr(1, url, "wal4.fcgi")
If (pos > 0) Then
    GetPlainWalUrl = Left(url, pos + 8)
    Exit Function
End If
pos = InStr(1, url, "wal.pl")
If (pos > 0) Then
    GetPlainWalUrl = Left(url, pos + 5)
    Exit Function
End If
GetPlainWalUrl = ""
End Function

Function HTTP_REQ(myHost As String, myMethod As String, myURL As String, myHeader As String, myData As String, myPort As String, myProtocol As String, is_siteminder As Boolean, is_mellon As Boolean) As String
    Dim result As String
    Log_Enter "HTTP_REQ()"
    Dim lPort As Long
    If (IsNumeric(myPort)) Then
        lPort = CLng(myPort)
    Else
        Dim portMap As New Collection ' free lokal
        With portMap
            .Add 80, ""
            .Add 80, "http"
            .Add 443, "https"
        End With
        On Error Resume Next
        lPort = 80 ' fallback
        lPort = portMap(myPort)
        On Error GoTo 0
        Set portMap = Nothing
    End If
    
    Dim strURL As String
    strURL = myProtocol + ":" + "//" + myHost + ":" + CStr(lPort) + myURL
    
    'Cut all behind 'wal.fcgi' or 'wal.pl'
    Dim url As String
    url = GetPlainWalUrl(strURL)
    If (url = "") Then
        MsgBox2 "URL does not contain wal.[fcgi|pl]: " + strURL, vbCritical
        HTTP_REQ = ""
        Exit Function
    End If
    Dim loginURL As String
    loginURL = url + "?action=login_succeeded"
    Log_Info ("loginUrl = " + loginURL)
    
    Dim siteminder As Object
    Dim siteminderCookieFullPath As String
    Dim previousSiteminderCookie As String
    'Wenn siteminder konfiguriert ist, dann ggf. gemerktes Cookie setzen
    If (is_siteminder = True) Then
        Dim userAddinPath As String
        Set siteminder = CreateObject("WordSiteminderConnector.SMConnector")
        userAddinPath = Environ("AppData") + "\\audimex ag\\Word Addin"
        If (FolderExists(userAddinPath) = False) Then
            CreateFolders (userAddinPath)
        End If
        siteminderCookieFullPath = userAddinPath + "\\AddinData.bin"
        Dim tmpCookie As String
        tmpCookie = siteminder.GetCookie(url, "SMSESSION")
        If (tmpCookie = "") Then
            Log_Info "siteminder cookie is not yet set"
            If (FileExists(siteminderCookieFullPath) = True) Then
                Log_Info "Loading cookie from file " + siteminderCookieFullPath
                previousSiteminderCookie = LoadTextFile(siteminderCookieFullPath)
                Log_Info "InternetSetCookie with previousSiteminderCookie for URL: " + url
                Dim bR As Boolean
                bR = siteminder.SetCookie(url, "SMSESSION", previousSiteminderCookie)
                Log_Info "InternetSetCookie returns: " + CStr(bR)
            Else
                Log_Info "there exists no previously used siteminder cookie => nothing to do"
            End If
        Else
            Log_Info "siteminder cookie is already set: " + tmpCookie
        End If
    End If
    
    Dim mellon_cookie As String
    Dim isc_result As Boolean
    
    If (is_mellon = True) Then
            ' AudimexWebLogin -> COM Komponente die Web-Login durchf|fffd|hrt
        If (audimex_web_login Is Nothing) Then
            Set audimex_web_login = CreateObject("AudimexWebLogin.MellonLogin")
        End If
        
                ' Evtl. gecachten Cookie holen
        mellon_cookie = audimex_web_login.GetLastResult()
        
        ' Kein Cookie gecachet
        If (mellon_cookie = "") Then
            mellon_cookie = audimex_web_login.DoLogin(url)
        End If
  
        If (mellon_cookie = "") Then
            MsgBox "Mellon Login fehlgeschlagen!", vbCritical + vbOKOnly
            Exit Function
        End If
        
                ' Mellon-Cookie setzen
        isc_result = InternetSetCookie(url, "mellon-cookie", mellon_cookie)
    End If
    
    Log_Info "Calling HTTP_REQ2 first time"
    result = HTTP_REQ2(myHost, myMethod, myURL, myHeader, myData, lPort, myProtocol, is_siteminder, is_mellon)
    If (is_mellon = True) Then
       If (result Like StringKonstanten.cstr_ServerNotOkPattern) Then
       ' Die Mellon Session ist wohl abgelaufen
       ' Neues Login forcieren
           
           ' Objekt neu erzeugen um GetLastResult() zur|fffd|ckzusetzen
        Set audimex_web_login = CreateObject("AudimexWebLogin.MellonLogin")
        
                ' Erneuter Login Versuch
        mellon_cookie = audimex_web_login.DoLogin(url)
        
        isc_result = InternetSetCookie(url, "mellon-cookie", mellon_cookie)
        
        result = HTTP_REQ2(myHost, myMethod, myURL, myHeader, myData, lPort, myProtocol, is_siteminder, is_mellon)
        If (Not result Like StringKonstanten.cstr_ServerOkPattern) Then
            MsgBox2 asr(StringKonstanten.ark_Error_Siteminder_Login), vbOK
        Else
            Log_Info "HTTP_REQ2 second time successful"
        End If
       End If
    End If
    
    If (is_siteminder = True) Then
        Dim cookie  As String
        If (result Like StringKonstanten.cstr_ServerOkPattern) Then
            Log_Info "HTTP_REQ2 returns ok, must get cookie for further use"
            cookie = siteminder.GetCookie(url, "SMSESSION")
            If (cookie = "") Then
                Log_Info "siteminder.GetCookie(""" + url + """, ""SMSESSION"" returns empty string"
            Else
                Log_Info "siteminder.GetCookie(""" + url + """, ""SMSESSION"" returns:"
                Log_Info cookie
            End If
        Else
            ' Siteminder ist konfiguriert. Es wurde aber vom Server ein 'Nicht ok' geliefert.
            ' Das bedeutet, Siteminder muss einloggen und dann muss das SM-Cookie gesetzt werden
            Dim bResult As Boolean
            Log_Info "HTTP_REQ2 returns not ok"
            Log_Info "InternetSetCookie expires: " + url
            bResult = siteminder.SetCookie(url, "SMSESSION", "bye; expires = Sat,01-Jan-1970 00:00:00 GMT")
            Log_Info "InternetSetCookie expires returns: " + CStr(bResult)
            Log_Info "Challenging Siteminder with URL: " + loginURL
            cookie = siteminder.Login("abc", loginURL)
            Log_Info "Siteminder Challenge returns: " + cookie
            If (cookie <> "") Then
                Log_Info "InternetSetCookie for URL: " + url
                bResult = siteminder.SetCookie(url, "SMSESSION", cookie)
                Log_Info "InternetSetCookie returns: " + CStr(bResult) + ", calling HTTP_REQ2 second time"
                result = HTTP_REQ2(myHost, myMethod, myURL, myHeader, myData, lPort, myProtocol, is_siteminder, is_mellon)
                If (Not result Like StringKonstanten.cstr_ServerOkPattern) Then
                    MsgBox2 asr(StringKonstanten.ark_Error_Siteminder_Login), vbOK
                Else
                    Log_Info "HTTP_REQ2 second time successful"
                End If
            Else
                MsgBox2 asr(StringKonstanten.ark_Error_Siteminder_Login), vbOK
            End If
        End If
        If (cookie <> "") Then
            Log_Info ("cookie has been set or refreshed => remember value for future use")
            If (cookie Like "SMSESSION=*") Then
                cookie = Right(cookie, Len(cookie) - Len("SMSESSION="))
            End If
            ' WriteTextFile siteminderCookieFullPath, EncryptString(cookie, Environ("USERNAME"))
            Log_Info "Write cookie to file " + siteminderCookieFullPath
            Log_Info "Cookie value: " + cookie
            WriteTextFile siteminderCookieFullPath, cookie
        End If
    End If
    HTTP_REQ = result
    Log_Leave "HTTP_REQ()"
End Function

Function HTTP_REQ2(myHost As String, myMethod As String, myURL As String, myHeader As String, myData As String, lPort As Long, myProtocol As String, is_siteminder As Boolean, is_mellon As Boolean) As String
    #If VBA7 Or Win64 Then
    Dim hInternetOpen As LongPtr
    Dim hInternetConnect As LongPtr
    Dim hHttpOpenRequest As LongPtr
    #Else
    Dim hInternetOpen As Long
    Dim hInternetConnect As Long
    Dim hHttpOpenRequest As Long
    #End If
    
    Dim bResult As Boolean
    Dim lPostDataLen As Long
    Dim lFlags As Long
    Log_Enter "HTTP_REQ2()"
    Log_Info "myProtocol=" & myProtocol
    Log_Info "is_siteminder=" & is_siteminder
    
    ' Internet-, Connect- und HttpRequest-Handle holen
    ' ------------------------------------------------
    ' Internet-Handle
    hInternetOpen = InternetOpen("http generic", _
    INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0)

    ' Connect-Handle
    Log_Info "InternetConnect(server=" & myHost & ", port=" & lPort & ")"
    hInternetConnect = InternetConnect(hInternetOpen, _
    myHost, lPort, vbNullString, "HTTP/1.0", INTERNET_SERVICE_HTTP, 0, 0)
    
    ' Flags fuer Request-Handle
    lFlags = INTERNET_FLAG_RELOAD
    If (myProtocol = "https") Then
        lFlags = lFlags Or _
        INTERNET_FLAG_IGNORE_CERT_CN_INVALID Or _
        INTERNET_FLAG_IGNORE_CERT_DATE_INVALID Or _
        INTERNET_FLAG_SECURE
    End If
    
    ' Request Handle
    Log_Info "HttpOpenRequest(method=" & myMethod & ", url=" & myURL & ")"
    hHttpOpenRequest = HttpOpenRequest(hInternetConnect, myMethod, myURL, "HTTP/1.0", vbNullString, 0, lFlags, 0)
    
    ' ignore unknown ca
    #If VBA7 Or Win64 Then
    Dim dwFlags As LongPtr
    #Else
    Dim dwFlags As Long
    #End If
    Dim dwBuffLen As Long
    
    If (myProtocol = "https") Then
        bResult = InternetQueryOption(hHttpOpenRequest, INTERNET_OPTION_SECURITY_FLAGS, dwFlags, Len(dwFlags))
        dwFlags = dwFlags Or SECURITY_FLAG_IGNORE_UNKNOWN_CA
        bResult = InternetSetOption(hHttpOpenRequest, INTERNET_OPTION_SECURITY_FLAGS, VarPtr(dwFlags), Len(dwFlags))
    End If
    
    ' Set Timeout
    ' ------------------------------------------------
    bResult = InternetQueryOption(hHttpOpenRequest, INTERNET_OPTION_RECEIVE_TIMEOUT, dwFlags, Len(dwFlags))
    Log_Info "InternetOptions(receive timeout before=" & dwFlags & ")"
    If (dwFlags < RECEIVE_TIMEOUT) Then
        dwFlags = RECEIVE_TIMEOUT
        bResult = InternetSetOption(hHttpOpenRequest, INTERNET_OPTION_RECEIVE_TIMEOUT, VarPtr(dwFlags), Len(dwFlags))
        bResult = InternetQueryOption(hHttpOpenRequest, INTERNET_OPTION_RECEIVE_TIMEOUT, dwFlags, Len(dwFlags))
        Log_Info "InternetOptions(receive timeout after=" & dwFlags & ")"
    Else
        Log_Info "InternetOptions(receive timeout remain unchanged = " & dwFlags & ")"
    End If
    
    bResult = InternetQueryOption(hHttpOpenRequest, INTERNET_OPTION_SEND_TIMEOUT, dwFlags, Len(dwFlags))
    Log_Info "InternetOptions(send timeout before=" & dwFlags & ")"
    If (dwFlags < SEND_TIMEOUT) Then
        dwFlags = SEND_TIMEOUT
        bResult = InternetSetOption(hHttpOpenRequest, INTERNET_OPTION_SEND_TIMEOUT, VarPtr(dwFlags), Len(dwFlags))
        bResult = InternetQueryOption(hHttpOpenRequest, INTERNET_OPTION_SEND_TIMEOUT, dwFlags, Len(dwFlags))
        Log_Info "InternetOptions(send timeout after=" & dwFlags & ")"
    Else
        Log_Info "InternetOptions(send timeout remains unchanged = " & dwFlags & ")"
    End If
    
    ' Header & Payload bauen und abschicken
    ' ------------------------------------------------
    If myHeader <> "" Then
        bResult = HttpAddRequestHeaders(hHttpOpenRequest, _
        myHeader, Len(myHeader), HTTP_ADDREQ_FLAG_REPLACE Or HTTP_ADDREQ_FLAG_ADD)
    End If
    
    ' Payload
    lPostDataLen = Len(myData)
    Log_Trace "HttpSendRequest()"
    bResult = HttpSendRequest(hHttpOpenRequest, vbNullString, 0, myData, lPostDataLen)
    
    If bResult = False Then
        Dim Flags As Long, Puffer As String
        Dim Retval As Long, Sprache As Long
        Dim Fehler As Long
        Fehler = GetLastError
        Log_Info "HttpSendRequest failed:"
        ' den Fehlertext mit FormatMessage in der Standardsprache ausgeben
        Flags = FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS
        Sprache = LANG_NEUTRAL Or (SUBLANG_DEFAULT * 1024)
        Puffer = Space(256) ' Puffergr|fffd||fffd|e festlegen
        Retval = FormatMessage(Flags, 0&, Fehler, Sprache, Puffer, Len(Puffer), 0&)
        If Retval = 0 Then
            Log_Info "FormatMessage failed; last error: " & Fehler
        Else
            Log_Info "Last Error Message: " & Left$(Puffer, Retval)
        End If
    End If
    
    ' Antwort lesen
    ' ------------------------------------------------
    Dim sBuffer As String
    Dim sReadBuffer As String * 2049
    Dim bDoLoop As Boolean
    Dim lNumberOfBytesRead As Long
    sBuffer = ""
    bDoLoop = True
    While bDoLoop
        sReadBuffer = ""
        bDoLoop = InternetReadFile( _
        hHttpOpenRequest, _
        sReadBuffer, _
        2048, _
        lNumberOfBytesRead)
        sBuffer = sBuffer & Left(sReadBuffer, lNumberOfBytesRead)
        If Not CBool(lNumberOfBytesRead) Then
            bDoLoop = False
        End If
    Wend
    HTTP_REQ2 = sBuffer
    
    ' Aufr|fffd|umen
    ' ------------------------------------------------
    bResult = InternetCloseHandle(hHttpOpenRequest)
    bResult = InternetCloseHandle(hInternetConnect)
    bResult = InternetCloseHandle(hInternetOpen)
    Log_Leave "HTTP_REQ2()"
End Function

Function GenerateMultiPartHeader(Boundary As String) As String
    GenerateMultiPartHeader = "Content-Type: multipart/form-data; boundary=" + Boundary + vbNewLine
End Function

Function GeneratePostParam(Boundary As String, key As String, value As String) As String
    Dim d As String
    d = "--" & Boundary & vbNewLine
    d = d & "Content-Disposition: form-data; name=""" & key & """" & vbNewLine & vbNewLine
    d = d & value & vbNewLine
    GeneratePostParam = d
End Function

Function GeneratePostParamFilePart(Boundary As String, FieldName As String, FileName As String) As String
    Dim d As String
    Dim sFormData As String
    ' Get source file content as a string.
    sFormData = GetFile(FileName)
    d = ""
    d = d & "--" & Boundary & vbNewLine
    d = d & "Content-Disposition: form-data; name=""" & FieldName & """;"
    d = d & " filename=""" & FileName & """" & vbNewLine
    d = d & "Content-Type: application/upload" & vbNewLine & vbNewLine
    d = d & sFormData & vbNewLine
    GeneratePostParamFilePart = d
End Function

Function GeneratePostParamEndMultipart(Boundary As String) As String
    GeneratePostParamEndMultipart = "--" & Boundary & "--" & vbNewLine
End Function

Function GeneratePostParamFromUrl(Boundary As String, url_ As String) As String
    Dim url As String
    Dim nurl As String
    Dim Params As String
    Dim key As String
    Dim value As String
    Dim idxSem As Long
    Params = ""
    url = url_
    GeneratePostParamFromUrl = ""
    nurl = getNextItem(url, "?")
    While nurl <> ""
        nurl = getNextItem(url, "?")
        If nurl <> "" Then
            idxSem = InStr(nurl, "=")
            If (idxSem > 0) Then
                If (idxSem = 1) Then
                    key = ""
                Else
                    key = Left(nurl, idxSem - 1)
                End If
                value = Mid(nurl, idxSem + 1)
                Params = Params + GeneratePostParam(Boundary, key, value)
            End If
        End If
    Wend
    GeneratePostParamFromUrl = Params
End Function

Sub hold_connection_loop() 'not to be used directly! use start_keep_alive and stop_keep_alive, instead.
    If going_on = False Then Exit Sub
    Log_Info "Keeping connection(s) alive..."
    If (Not Dok) <> -1 Then
        Dim document_counter As Long
        For document_counter = 0 To UBound(Dok)
            'only those, who are explicitly meant to do additional keep alives (>0), but intentionally for potentially all files (mixed different servers and logins are possible)
            If (Val(Dok(document_counter).keep_alive_time) > 0) Then Log_Info "For file: '" & Dok(document_counter).docName & "'": Request_Ping Dok(document_counter)
        Next document_counter
    End If
    Log_Info "Next connection keep-alive in " & connection_retry_interval
    Application.OnTime Now + TimeValue(connection_retry_interval), "hold_connection_loop"
End Sub

Sub start_keep_alive() 'use this to start the keep alive loop properly
    Log_Info "Starting connection alive loop."
    If (going_on = False) Then
        going_on = True
        Application.OnTime Now, "hold_connection_loop"
    End If
End Sub

Sub stop_keep_alive() 'use this to stop the keep alive loop
    Log_Info "Stopping connection alive loop."
    going_on = False
End Sub

Sub update_keep_alive_time() 'Sets the currently used keep alive time, taking the shortest intervall found in the documents currently opened
    Dim start_value As Long
    start_value = 10 ^ 7
    Dim doc_counter As Long
    If (Not Dok) <> -1 Then
        For doc_counter = 0 To UBound(Dok)
            If (Val(Dok(doc_counter).keep_alive_time) < start_value) And (Val(Dok(doc_counter).keep_alive_time) > 0) Then start_value = Dok(doc_counter).keep_alive_time
        Next doc_counter
        connection_retry_interval = hours_stamp_from_seconds(start_value)
    Else
        connection_retry_interval = "00:01:00" 'In this case, no slots used, no actual connection tries, so let's run it once a minute as compromise
    End If
End Sub


Attribute VB_Name = "ListUtilities"
Option Explicit

' ohne 'preserve', umkopieren der elemente
Function push2(list As Variant, element As Variant) As Variant
    Dim n As Long, i As Long
    Dim list2 As Variant
    If (IsEmpty(list)) Then
        n = -1
        ReDim list2(0)
    Else
        n = UBound(list)
        ReDim list2(n + 1)
        For i = 0 To UBound(list)
            If (VarType(list(i)) = vbObject) Then
                Set list2(i) = list(i)
            Else
                list2(i) = list(i)
            End If
        Next
        Erase list
    End If
    If (VarType(element) = vbObject) Then
        Set list2(n + 1) = element
    Else
        list2(n + 1) = element
    End If
    push2 = list2
End Function

' mit 'preserve'
Sub push1(ByRef list As Variant, element As Variant)
    Dim n As Long
    If (IsEmpty(list)) Then
        n = -1
        ReDim list(0)
    Else
        n = UBound(list)
        ReDim Preserve list(n + 1)
    End If
    If (VarType(element) = vbObject) Then
        Set list(n + 1) = element
    Else
        list(n + 1) = element
    End If
End Sub

Sub unshift(ByRef list As Variant, element As Variant)
    Dim n As Long, i As Long
    If (IsEmpty(list)) Then
        n = -1
        ReDim list(0)
    Else
        n = UBound(list)
        ReDim Preserve list(n + 1)
        For i = n + 1 To 1 Step -1
            list(i) = list(i - 1)
        Next
    End If
    list(0) = element
End Sub

Sub append(ByRef list As Variant, list2 As Variant)
    Dim n As Long, n2 As Long, i As Long
    If (IsEmpty(list2)) Then Exit Sub ' 2. Liste leer? -> fertig
    If (Not IsArray(list2)) Then
        list = push2(list, list2)
        Exit Sub
    End If
    If (IsEmpty(list)) Then
        n = -1
        ReDim list(0)
    Else
        n = UBound(list)
        n2 = UBound(list2)
        ReDim Preserve list(n + n2 + 1)
    End If
    For i = 0 To n2
        list(n + 1 + i) = list2(i)
    Next
End Sub

Function pop(ByRef Tokens As Variant) As Variant
    Dim i As Long
    Dim t As Variant
    pop = Empty
    If (IsEmpty(Tokens)) Then Exit Function
    If (Not IsArray(Tokens)) Then Exit Function
    t = Tokens(0)
    For i = 0 To UBound(Tokens) - 1
        Tokens(i) = Tokens(i + 1)
    Next
    If (UBound(Tokens) = 0) Then
        Tokens = Empty
    Else
        ReDim Preserve Tokens(UBound(Tokens) - 1)
    End If
    pop = t
End Function

Function printList(l As Variant) As String
    Dim i As Long
    printList = ""
    If (Not IsArray(l)) Then
        printList = l
        Exit Function
    End If
    printList = "("
    For i = 0 To UBound(l)
        printList = printList & IIf(i > 0, ", ", "") & printList(l(i))
    Next i
    printList = printList & ")"
End Function

Function printTree(t As Variant) As String
    printTree = printTreeR(t, "", "", "+-", True, True)
End Function

Function printTreeR( _
    t As Variant, _
    Optional indentgrandfather As String = "", _
    Optional indentfather As String = "", _
    Optional indent_char As String = "", _
    Optional grandfatherlast As Boolean = False, _
    Optional fatherlast As Boolean = False) As String
    Dim i As Long
    Dim s As String
    s = ""
    If (Not IsArray(t)) Then
        s = s & IIf(grandfatherlast, indentgrandfather, indentfather) & indent_char & IIf(IsEmpty(t), "[empty]", t) & vbLf
    Else
        s = s & IIf(grandfatherlast, indentgrandfather, indentfather) & indent_char & "." & vbLf
        For i = 0 To UBound(t)
            s = s & printTreeR( _
            t(i), _
            indentgrandfather & IIf(fatherlast, "  ", "| "), _
            indentfather & IIf(fatherlast, "  ", "| "), _
            "+-", _
            fatherlast, _
            i = UBound(t))
        Next
        s = s & indentfather & IIf(fatherlast, "  ", "| ") & vbLf
    End If
    printTreeR = s
End Function

Attribute VB_Name = "Logging"
Option Explicit

Public au_log_filename    As String
Public au_log_fd          As Long
Public au_log_delete_log  As Boolean
Public au_log_indent      As String

Public Const cstr_log_dev         As String = "DEV"
Public Const cstr_log_trace       As String = "TRACE"
Public Const cstr_log_error       As String = "ERROR"
Public Const cstr_log_warning     As String = "WARNING"
Public Const cstr_log_information As String = "INFO"
Public Const cstr_log_indent      As String = "    "
Public Const cstr_log_separator   As String = "-------------------------"

Public Sub Log_Dev(st As String)
    If (Not developer_mode) Then Exit Sub
    Log st, cstr_log_dev
    MsgBox st
End Sub

Public Sub Log_Separator()
    Log_Trace (cstr_log_separator)
End Sub

Public Sub Log_Trace(st As String)
    Log st, cstr_log_trace
End Sub

Public Sub Log_Error(st As String)
    Log st, cstr_log_error
End Sub

Public Sub Log_Warn(st As String)
    Log st, cstr_log_warning
End Sub

Public Sub Log_Info(st As String)
    Log st, cstr_log_information
End Sub

Public Sub Log_Enter(st As String)
    Log "Entering " & st, cstr_log_trace
    Log_Push
End Sub

Public Sub Log_Leave(st As String)
    Log_Pop
    Log "Leaving  " & st, cstr_log_trace
End Sub

Public Sub Log_Enter_EventProc(st As String)
    If (developer_mode) Then
        MsgBox IIf(dot_type = dot_type_addin, "Addin", "Template") & " caught event " & st
    End If
    Log "Entering " & st, cstr_log_trace
    Log_Push
End Sub

Public Sub Log_Push()
    au_log_indent = au_log_indent & cstr_log_indent
End Sub

Public Sub Log_Pop()
    au_log_indent = Left(au_log_indent, IIf(Len(au_log_indent) >= Len(cstr_log_indent), Len(au_log_indent) - Len(cstr_log_indent), 0))
End Sub

Public Function Log_Indent_Level() As String
    Log_Indent_Level = au_log_indent
End Function

Function rpad(st As String, ln As Long, Optional ch As String = " ")
    rpad = Left(st & String(ln, ch), ln)
End Function

Function lpad(st As String, ln As Long, Optional ch As String = " ")
    lpad = Right(String(ln, ch) & st, ln)
End Function

Public Sub Log(ByVal st As String, Optional typ As String = cstr_log_trace)
    Dim trenner As String, prefix As String, line As String
    Dim i As Long
    Dim saved_text As String
    On Error Resume Next
    saved_text = rpad(CStr(ThisDocument.Saved), 6)
    prefix = Date & " " & Time & " " & dot_type_flag() & " " & rpad(typ, 8) & " Document" & saved_text & " " & au_log_indent
    trenner = vbLf
    If (InStr(st, vbCrLf) > 0) Then trenner = vbCrLf
    i = 0
    Do
        i = i + 1
        line = getNextItem(st, trenner)
        Print #au_log_fd, prefix & line
        If ((Err.Number > 0) Or (developer_mode)) Then
            Debug.Print prefix & line
            Err.Clear
        End If
    Loop Until ((st = "") Or (i > 100))
    Err.Clear
End Sub

Public Function dot_type_flag() As String
    dot_type_flag = dot_type_text(True)
End Function

Public Function dot_type_name() As String
    dot_type_name = dot_type_text()
End Function

Public Function dot_type_text(Optional flag As Boolean = False) As String
    Select Case dot_type
    Case dot_type_addin
        dot_type_text = "Addin"
    Case dot_type_template
        dot_type_text = "Template"
    Case Else
        dot_type_text = "?"
    End Select
    If (flag) Then
        dot_type_text = Left(dot_type_text, 1)
    End If
End Function

Public Sub lg_open()
    au_log_filename = MakeTempFileName() & ".log"
    au_log_fd = FreeFile
    au_log_delete_log = True
    Open au_log_filename For Output Shared As au_log_fd Len = 1
    Log "Logfile Open", cstr_log_trace
    Log "Addin-Name:    " & ThisDocument.FullName, cstr_log_trace
    Log "Addin-Version: " & getAddinVersion()
End Sub

Public Sub lg_close()
    Log "Logfile Close", cstr_log_trace
    Close au_log_fd
    If (Not au_log_delete_log) Then Exit Sub
    If (developer_mode) Then
        MsgBox "developer_mode, Logfile bleibt (" & au_log_filename & ")"
        Exit Sub
    End If
    On Error Resume Next
    Kill au_log_filename
    Err.Clear
End Sub

Sub Audimex_Menu_Log_Show()
    Dim task_id As Variant
    If (au_log_filename = "") Then
        MsgBox asr(ark_log_NoLogFile), vbOKOnly + vbExclamation, asr(ark_MsgBoxTitle_Audimex)
        Exit Sub
    End If
    On Error Resume Next
    task_id = Shell(PathName:="notepad " & au_log_filename, windowstyle:=vbNormalFocus)
    If (Err.Number > 0) Then
        MsgBox asr(ark_log_LogFileError) & vbLf & "[" & au_log_filename & "]", vbOKOnly + vbExclamation, asr(ark_MsgBoxTitle_Audimex)
        Err.Clear
    End If
End Sub

Sub Audimex_Menu_Log_Toggle()
    Dim btn As CommandBarButton
    Dim saved_flag As Boolean
    Application.CustomizationContext = ThisDocument
    saved_flag = ThisDocument.Saved
    If (au_log_filename = "") Then
        MsgBox asr(ark_log_NoLogFile), vbOKOnly + vbExclamation, asr(ark_MsgBoxTitle_Audimex)
        Exit Sub
    End If
    Set btn = Application.CommandBars(cstrAudimexMenuPositionWord).Controls(asr(ark_Menu_Audimex)).Controls(asr(ark_Menu_Log_Toggle))
    If (btn Is Nothing) Then
        au_log_delete_log = Not au_log_delete_log
        MsgBox asr(ark_log_Menu_Fehler) & IIf(au_log_delete_log, asr(ark_log_delete), asr(ark_log_keep)), vbExclamation + vbOKOnly, asr(ark_MsgBoxTitle_Audimex)
    Else
        With btn
            .State = Not .State
            au_log_delete_log = .State
            ThisDocument.Saved = saved_flag ' |fffd|nderung am Men|fffd| nicht speichern
        End With
    End If
End Sub

Attribute VB_Name = "LoginDialog"
Attribute VB_Base = "0{6E9BC513-2AC0-4AFF-B072-1602CF0DF256}{79C55097-6C1B-4CE3-AE0B-0CFCC4EB4350}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







Option Explicit


Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then
    Cancel = True
  End If
End Sub


Private Sub LoginButtonCancel_Click()
  Log_Enter "LoginButtonCancel_Click()"
  
  login_ok = False
  Me.Hide
  DoEvents
  
  Log_Leave "LoginButtonCancel_Click()"
End Sub


Private Sub LoginButtonOk_Click()
  Dim i As Long
  Dim s As String
  Dim newID As String
  Dim start As Date
  Dim ds As DocuSlot
  
  
  Log_Enter "LoginButtonOk_Click()"
  
  ' neue Session-ID vom Server holen
  With Me
    s = .LoginMessage.Caption
    .LoginMessage.Caption = asr(ark_Login_Msg_Sessionid)
    .Repaint
    
    If (Len(.LoginUsername_Text.Text) < 1) Then
      Log_Info "Login failed"
      .LoginMessage.Caption = asr(ark_Login_Msg_Failed)
      .Repaint
      .LoginUsername_Text.SetFocus
      Call warteSekunden(2)
      Exit Sub
    End If
    If (Len(.LoginPassword_Text.Text) < 1) Then
      Log_Info "Login failed"
      .LoginMessage.Caption = asr(ark_Login_Msg_Failed)
      .Repaint
      .LoginPassword_Text.SetFocus
      Call warteSekunden(2)
      Exit Sub
    End If
    
    
    Set ds = GetActiveDocumentSlot
    newID = Request_SessionId(ds, .LoginUsername_Text.Text, .LoginPassword_Text.Text)
      
    If (Not (newID Like (cstr_ServerOkPattern))) Then
      Log_Info "Server's answer is unlike Ok pattern /" & guiEncode(cstr_ServerOkPattern) & "/"
      Log_Leave "LoginButtonOk_Click() [Error]"
      Exit Sub
    End If
    
    newID = Mid(newID, Len(cstr_ServerOkString) + 1) ' "OK<lf>" abschneiden
    Call replaceText(newID, vbLf, "")  ' evtl. trailing Lf entfernen
    
    If (newID <> cstr_InvalidSessionid) Then ' offline_login() in session.pm liefert 0 bei falschem User/Passwort
      
      Log_Info "Server emitted new ID [" & newID & "]"
      login_ok = True
      ds.id = newID
      Call dm_ReSetIdAll(ds)
      .Hide
    
    Else
      
      Log_Info "Login failed"
      .LoginMessage.Caption = asr(ark_Login_Msg_Failed)
      .Repaint
      Call warteSekunden(2)
      
      With .LoginPassword_Text
        .Text = ""
        .SetFocus
      End With
      
      .LoginMessage.Caption = s
      .Repaint
    
    End If
  
  End With

  Log_Leave "LoginButtonOk_Click()"
End Sub



Public Sub warteSekunden(delay As Long)
  Dim start As Date
  Dim mydelay As Double

  mydelay = delay / (24 * 3600!) ' 1 Tag == 1.0
  start = Time
  While CDbl(Time - start) < mydelay
    DoEvents
  Wend
End Sub


Attribute VB_Name = "MenuAudimex"
Option Explicit

Public Const cstrAudimexMenuPositionWord As String = "Menu Bar"

Public Const cstr_Tag_Audimex           As String = "Audimex Menu"
Public Const cstr_Tag_Speichern         As String = "Audimex Speichern"
Public Const cstr_Tag_Speichern_Unter   As String = "Audimex Speichern Unter..."
Public Const cstr_Tag_Speichern_Version As String = "Audimex Speichern Version"
Public Const cstr_Tag_Speichern_Fragmente As String = "Audimex Speichern Fragmente"
Public Const cstr_Tag_Einstellungen     As String = "Audimex Einstellungen"
Public Const cstr_Tag_Log_Filename      As String = "Audimex Log Filename"
Public Const cstr_Tag_Log_Toggle        As String = "Audimex Log ein/aus"
Public Const cstr_Tag_Extract           As String = "Audimex Extrahieren"
Public Const cstr_Tag_Reserviert        As String = "Audimex Reserviert"
Public Const cstr_Tag_About             As String = "Audimex About"
Public Const cstr_Tag_Test_01           As String = "Audimex Test 01"
Public Const cstr_Tag_Test_02           As String = "Audimex Test 02"
Public Const cstr_Tag_Test_03           As String = "Audimex Test 03"

Sub LogChildMenus(cb As Object)
    Dim cbn As CommandBarControl
    Log_Push
    For Each cbn In cb.Controls
        Log_Trace cbn.Caption & " | " & cbn.Type & " | " & cbn.Parent.Context
        If cbn.Type <> msoControlButton And cbn.Type <> msoControlSplitDropdown And cbn.Type <> msoControlExpandingGrid And _
            cbn.Type <> msoControlComboBox And cbn.Type <> msoControlGraphicCombo And cbn.Type <> msoControlGraphicDropdown And _
            cbn.Type <> msoControlEdit And cbn.Type <> msoControlGrid And cbn.Type <> msoControlDropdown And cbn.Type <> msoControlGauge And _
            cbn.Type <> msoControlOCXDropdown And cbn.Type <> msoControlLabel And cbn.Type <> msoControlWorkPane And cbn.Type <> msoControlPane Then
            LogChildMenus cbn
        End If
    Next
    Log_Pop
End Sub

Sub LogAllMenus()
    Dim cb As CommandBar
    Dim cbn As CommandBarControl
    Log_Enter "ShowAllMenus"
    For Each cb In Application.CommandBars
        Log_Trace "CommandBar = " & cb.name & " : " & cb.Type
        Log_Push
        For Each cbn In cb.Controls
            Log_Trace cbn.Caption & " | " & cbn.Type & " | " & cbn.Parent.Context
            If cbn.Type <> msoControlButton And cbn.Type <> msoControlSplitDropdown And cbn.Type <> msoControlExpandingGrid And _
                cbn.Type <> msoControlComboBox And cbn.Type <> msoControlGraphicCombo And cbn.Type <> msoControlGraphicDropdown And _
                cbn.Type <> msoControlEdit And cbn.Type <> msoControlGrid And cbn.Type <> msoControlDropdown And cbn.Type <> msoControlGauge And _
                cbn.Type <> msoControlOCXDropdown And cbn.Type <> msoControlLabel And cbn.Type <> msoControlWorkPane And cbn.Type <> msoControlPane Then
                LogChildMenus cbn
            End If
        Next
        Log_Pop
    Next
    Log_Leave "ShowAllMenus"
End Sub

Sub TestAudimexMenuRemove()
    Call AudimexMenuRemove
End Sub

Sub TestAudimexMenuInstall()
    Call AudimexMenuInstall(Nothing, False)
End Sub

Function AudimexMenuDefinition(ds As DocuSlot, restricted As Boolean)
    Dim isSchnipselMode As Boolean
    Dim isExtractSchnipselMode As Boolean
    isSchnipselMode = False
    isExtractSchnipselMode = False
    If (Not ds Is Nothing) Then
        isSchnipselMode = (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_SCHNIPSEL)
        isExtractSchnipselMode = (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL)
    End If
    Log_Trace "isSchnipselMode = " & isSchnipselMode & ";  isExtractSchnipselMode = " & isExtractSchnipselMode

    Dim menuItems() As Variant
    If (ds Is Nothing) Then
        Log_Trace "AudimexMenuDefinition Fall 1"
        menuItems = Array( _
        Array(asr(ark_Menu_Extrahieren), "button", "Audimex_Menu_UploadTable", "true", cstr_Tag_Extract, "up"), _
        Array(asr(ark_Menu_SpeichernFragmente), "button", "Audimex_Menu_SaveFragments", IIf(restricted, "false", "true"), cstr_Tag_Speichern_Fragmente, "up"), _
        Array(asr(ark_Menu_Speichern), "button", "Audimex_Menu_Save", IIf(restricted, "false", "true"), cstr_Tag_Speichern, "up", "true"), _
        Array(asr(ark_Menu_SpeichernUnter), "button", "Audimex_Menu_SaveAs", "true", cstr_Tag_Speichern_Unter, "up"), _
        Array(asr(ark_Menu_SpeichernVersion), "button", "Audimex_Menu_SaveVersion", IIf(restricted, "false", "true"), cstr_Tag_Speichern_Version, "up"), _
        Array(asr(ark_Menu_Log_Filename), "button", "Audimex_Menu_Log_Show", "true", cstr_Tag_Log_Filename, "up", "true"), _
        Array(asr(ark_Menu_Log_Toggle), "button", "Audimex_Menu_Log_Toggle", "true", cstr_Tag_Log_Toggle, IIf(au_log_delete_log, "down", "up")), _
        Array(asr(ark_Menu_About), "button", "Audimex_Menu_About", "true", cstr_Tag_About, "up", "true") _
        )
    ElseIf (isSchnipselMode) Then
        Log_Trace "AudimexMenuDefinition Fall 2 isSchnipselMode"
        menuItems = Array( _
        Array(asr(ark_Menu_Speichern), "button", "Audimex_Menu_Save", IIf(restricted, "false", "true"), cstr_Tag_Speichern, "up"), _
        Array(asr(ark_Menu_Log_Filename), "button", "Audimex_Menu_Log_Show", "true", cstr_Tag_Log_Filename, "up", "true"), _
        Array(asr(ark_Menu_Log_Toggle), "button", "Audimex_Menu_Log_Toggle", "true", cstr_Tag_Log_Toggle, IIf(au_log_delete_log, "down", "up")), _
        Array(asr(ark_Menu_About), "button", "Audimex_Menu_About", "true", cstr_Tag_About, "up", "true") _
        )
    ElseIf (isExtractSchnipselMode) Then
        Log_Trace "AudimexMenuDefinition Fall 3 isExtractSchnipselMode"
        menuItems = Array( _
        Array(asr(ark_Menu_SpeichernFragmente), "button", "Audimex_Menu_SaveFragments", IIf(restricted, "false", "true"), cstr_Tag_Speichern_Fragmente, "up"), _
        Array(asr(ark_Menu_Speichern), "button", "Audimex_Menu_Save", IIf(restricted, "false", "true"), cstr_Tag_Speichern, "up"), _
        Array(asr(ark_Menu_SpeichernUnter), "button", "Audimex_Menu_SaveAs", "true", cstr_Tag_Speichern_Unter, "up"), _
        Array(asr(ark_Menu_SpeichernVersion), "button", "Audimex_Menu_SaveVersion", IIf(restricted, "false", "true"), cstr_Tag_Speichern_Version, "up"), _
        Array(asr(ark_Menu_Log_Filename), "button", "Audimex_Menu_Log_Show", "true", cstr_Tag_Log_Filename, "up", "true"), _
        Array(asr(ark_Menu_Log_Toggle), "button", "Audimex_Menu_Log_Toggle", "true", cstr_Tag_Log_Toggle, IIf(au_log_delete_log, "down", "up")), _
        Array(asr(ark_Menu_About), "button", "Audimex_Menu_About", "true", cstr_Tag_About, "up", "true") _
        )
    Else
        Log_Trace "AudimexMenuDefinition Fall 4"
        menuItems = Array( _
        Array(asr(ark_Menu_Speichern), "button", "Audimex_Menu_Save", IIf(restricted, "false", "true"), cstr_Tag_Speichern, "up"), _
        Array(asr(ark_Menu_SpeichernUnter), "button", "Audimex_Menu_SaveAs", "true", cstr_Tag_Speichern_Unter, "up"), _
        Array(asr(ark_Menu_SpeichernVersion), "button", "Audimex_Menu_SaveVersion", IIf(restricted, "false", "true"), cstr_Tag_Speichern_Version, "up"), _
        Array(asr(ark_Menu_Log_Filename), "button", "Audimex_Menu_Log_Show", "true", cstr_Tag_Log_Filename, "up", "true"), _
        Array(asr(ark_Menu_Log_Toggle), "button", "Audimex_Menu_Log_Toggle", "true", cstr_Tag_Log_Toggle, IIf(au_log_delete_log, "down", "up")), _
        Array(asr(ark_Menu_About), "button", "Audimex_Menu_About", "true", cstr_Tag_About, "up", "true") _
        )
    End If

    If (test_mode) Then
        ReDim Preserve menuItems(0 To UBound(menuItems) + 1)
        menuItems(UBound(menuItems)) = Array(cstr_Tag_Test_01, "button", "Audimex_Menu_Test_01", "true", cstr_Tag_Test_01, "up", "true")
        ReDim Preserve menuItems(0 To UBound(menuItems) + 1)
        menuItems(UBound(menuItems)) = Array(cstr_Tag_Test_02, "button", "Audimex_Menu_Test_02", "true", cstr_Tag_Test_02, "up", "true")
        ReDim Preserve menuItems(0 To UBound(menuItems) + 1)
        menuItems(UBound(menuItems)) = Array(cstr_Tag_Test_03, "button", "Audimex_Menu_Test_03", "true", cstr_Tag_Test_03, "up", "true")
    End If

    AudimexMenuDefinition = Array(asr(ark_Menu_Audimex), "popup", menuItems, "true", cstr_Tag_Audimex)
End Function

Sub AudimexMenuRestrict(ds As DocuSlot)
    Dim writable As Boolean
    Dim saved_flag As Boolean
    Application.CustomizationContext = ThisDocument
    saved_flag = ThisDocument.Saved
    On Error Resume Next
    writable = (Not ds.is_read_only)
    With Application.CommandBars(cstrAudimexMenuPositionWord).Controls(asr(ark_Menu_Audimex))
        .Controls(asr(ark_Menu_Speichern)).Enabled = writable
        .Controls(asr(ark_Menu_SpeichernVersion)).Enabled = writable
    End With
    ThisDocument.Saved = saved_flag ' |fffd|nderung am Men|fffd| nicht speichern
End Sub

Sub AudimexMenuInstall(ds As DocuSlot, restricted As Boolean)
    Dim m As Variant
    Dim saved_flag As Boolean
    Application.CustomizationContext = ThisDocument
    saved_flag = ThisDocument.Saved
    Log_Enter "AudimexMenuInstall(restricted=" & restricted & ")"
    Log_Trace "Current document = " & ThisDocument.FullName
    Log_Trace ("""Saved"" is " & saved_flag)
    Log_Trace "Try to remove menu first to avoid duplicates."

    Call AudimexMenuRemove
    m = AudimexMenuDefinition(ds, restricted)
    Call MenuInstall(m, Application.CommandBars(cstrAudimexMenuPositionWord))

    Log_Info "Resetting ""Saved"" state of audimex addin / template to ""true"""
    ThisDocument.Saved = saved_flag ' Template gets "dirty" by menu manipulation, avoid "Save?" question on close
    Log_Leave "AudimexMenuInstall()"
End Sub

Sub TestAudimexMenuTags()
    Dim ds As New DocuSlot ' free lokal
    ds.freeSlot
    MsgBox printList(AudimexMenuTags(AudimexMenuDefinition(ds, False)))
    Set ds = Nothing
End Sub

' aus rekursiver Menu-Definitions-Struktur Liste der tags extrahieren
' Array(Name, popup, Array [, Enable [, Tag]])
' Array(Name, button, Macro [, Enable [, Tag [, State]]])
Function AudimexMenuTags(m As Variant) As Variant
    Dim l As Variant, i As Long, mm As Variant
    l = Array()
    Select Case m(1)
    Case "popup"
        mm = m(2)
        For i = 0 To UBound(mm)
            append l, AudimexMenuTags(mm(i))
        Next
        l = push2(l, m(4))
    Case "button"
        l = push2(l, m(4))
    End Select
    AudimexMenuTags = l
End Function

Sub AudimexMenuRemove()
    Dim ct As Variant
    Dim ctrl As CommandBarControl
    Dim first As Boolean
    Dim saved_flag As Boolean
    Application.CustomizationContext = ThisDocument
    saved_flag = ThisDocument.Saved
    Log_Enter "AudimexMenuRemove()"
    Log_Trace "Current document = " & ThisDocument.FullName
    On Error Resume Next
    For Each ct In AudimexMenuTags(AudimexMenuDefinition(Nothing, True))
        Log_Trace "Locating MenuItem (Tag=" & ct & ")"
        first = True
        ' alle Vorkommen l|fffd|schen
        With Application.CommandBars(cstrAudimexMenuPositionWord)
            Do
                Set ctrl = .FindControl(Tag:=ct, Recursive:=True)
                If (ctrl Is Nothing) Then
                    If first Then Log_Info "not found."
                    Exit Do
                End If
                first = False
                Log_Trace "Deleting MenuItem"
                ctrl.Delete
                If (Err.Number > 0) Then
                    Log_Warn "failed (" & Err.Number & ", " & Err.Description & ")"
                    Err.Clear
                Else
                    Log_Info "Ok."
                End If
            Loop
        End With
    Next
    Log_Info "Resetting ""Saved"" state of audimex addin / template to previous value (" & saved_flag & ")"
    ThisDocument.Saved = saved_flag ' Template gets "dirty" by menu manipulation, avoid "Save?" question on close
    Log_Leave "AudimexMenuRemove()"
End Sub

Function AudimexMenuInstalled() As Boolean
    Dim ct As Variant
    Dim ctrl As CommandBarControl
    Dim first As Boolean
    Dim saved_flag As Boolean
    Dim isinstalled As Boolean
    Log_Enter "AudimexMenuInstalled()"
    Log_Trace "Current document = " & ThisDocument.FullName
    isinstalled = False
    On Error Resume Next
    For Each ct In AudimexMenuTags(AudimexMenuDefinition(Nothing, True))
        Log_Trace "Locating MenuItem (Tag=" & ct & ")"
        first = True
        ' Vorkommen suchen, sobald eines gefunden wird gelten die Audimex Men|fffd|s als installiert, weil jetzt alle Eintr|fffd|ge hinzugef|fffd|gt
        ' werden und dann entsprechend des Typs ausgeblendet werden
        With Application.CommandBars(cstrAudimexMenuPositionWord)
            Set ctrl = .FindControl(Tag:=ct, Recursive:=True)
            If (ctrl Is Nothing) Then
                Log_Trace "Menu item not found"
            Else
                Log_Trace "found control"
                isinstalled = True
                Exit For
            End If
        End With
    Next
    Log_Leave "AudimexMenuInstalled()"
    AudimexMenuInstalled = isinstalled
End Function

Sub AudimexMenuHide()
    Dim ct As Variant
    Dim ctrl As CommandBarControl
    Dim first As Boolean
    Dim saved_flag As Boolean
    Application.CustomizationContext = ThisDocument
    saved_flag = ThisDocument.Saved
    Log_Enter "AudimexMenuHide()"
    Log_Trace "Current document = " & ThisDocument.FullName
    On Error Resume Next
    For Each ct In AudimexMenuTags(AudimexMenuDefinition(Nothing, True))
        Log_Trace "Locating MenuItem (Tag=" & ct & ")"
        first = True
        ' alle Vorkommen ausblenden
        With Application.CommandBars(cstrAudimexMenuPositionWord)
            Set ctrl = .FindControl(Tag:=ct, Recursive:=True)
            If (ctrl Is Nothing) Then
                If first Then Log_Info "not found."
            Else
                first = False
                Log_Trace "Hiding MenuItem" & ct
                ctrl.Visible = False
                If (Err.Number > 0) Then
                    Log_Warn "failed (" & Err.Number & ", " & Err.Description & ")"
                    Err.Clear
                Else
                    Log_Info "Ok."
                End If
            End If
        End With
    Next
    Log_Info "Resetting ""Saved"" state of audimex addin / template to previous value (" & saved_flag & ")"
    ThisDocument.Saved = saved_flag ' Template gets "dirty" by menu manipulation, avoid "Save?" question on close
    Log_Leave "AudimexMenuHide()"
End Sub

Sub AudimexMenuActivate(ds As DocuSlot, restricted As Boolean)
    Dim ct As Variant
    Dim ctrl As CommandBarControl
    Dim first As Boolean
    Dim saved_flag As Boolean
    Application.CustomizationContext = ThisDocument
    saved_flag = ThisDocument.Saved
    Log_Enter "AudimexMenuActivate()"
    Log_Trace "Current document = " & ThisDocument.FullName
    Application.CustomizationContext = ThisDocument
    On Error Resume Next
    For Each ct In AudimexMenuTags(AudimexMenuDefinition(ds, restricted))
        Log_Trace "Locating MenuItem (Tag=" & ct & ")"
        ' alle Vorkommen einblenden
        With Application.CommandBars(cstrAudimexMenuPositionWord)
            Set ctrl = .FindControl(Tag:=ct, Recursive:=True)
            If (ctrl Is Nothing) Then
                Log_Info "not found."
            Else
                If (ctrl.Visible = False) Then
                    Log_Trace "Activating MenuItem"
                    ctrl.Visible = True
                    If (Err.Number > 0) Then
                        Log_Warn "failed (" & Err.Number & ", " & Err.Description & ")"
                        Err.Clear
                    Else
                        Log_Info "Ok."
                    End If
                End If
            End If
        End With
    Next
    Log_Info "Resetting ""Saved"" state of audimex addin / template to previous value (" & saved_flag & ")"
    ThisDocument.Saved = saved_flag ' Template gets "dirty" by menu manipulation, avoid "Save?" question on close
    Log_Leave "AudimexMenuActivate()"
End Sub

Attribute VB_Name = "MenuMacros"
Option Explicit

Public came_from_save      As Boolean
Public login_ok            As Boolean
Public ExtendedInputBox_Ok As Boolean
Public ExtendedSaveBox_Ret As String

Public Const cstr_Tag_save_version       As String = "@version"
Public Const cstr_Tag_save_as            As String = "@save_as"
Public Const cstr_Tag_save               As String = "@save"
Public Const cstr_Tag_save_empty_comment As String = "@"
Public Const au_writable_not_set    As Integer = -1
Public Const au_writable_yes        As Integer = 0
Public Const au_writable_no_perm    As Integer = 1
Public Const au_writable_no_dup     As Integer = 2
Public Const au_writable_no         As Integer = 3
Public Const au_writable_error      As Integer = 4
Public Const au_conflict_not_set    As Integer = -1
Public Const au_conflict_none       As Integer = 0
Public Const au_conflict_user       As Integer = 1
Public Const au_conflict_time       As Integer = 2
Public Const au_conflict_both       As Integer = 3
Public Const au_conflict_error      As Integer = 4
Public Const au_conflict_str_time   As String = "TIME "
Public Const au_conflict_str_user   As String = "USER "
Public Const au_session_not_set     As Integer = -1
Public Const au_session_valid       As Integer = 0
Public Const au_session_user_cancel As Integer = 1
Public Const au_session_error       As Integer = 2
Public Const au_upload_not_set      As Integer = -1
Public Const au_upload_ok           As Integer = 0
Public Const au_upload_no_timestamp As Integer = 1
Public Const au_upload_error        As Integer = 2
Public Const au_export_not_set      As Integer = -1
Public Const au_export_ok           As Integer = 0
Public Const au_export_error        As Integer = 1
Private Const CP_UTF8 As Long = 65001

#If VBA7 Or Win64 Then
Private Declare PtrSafe Function MultiByteToWideChar Lib "kernel32" ( _
ByVal CodePage As Long, _
ByVal dwFlags As Long, _
ByVal lpMultiByteStr As LongPtr, _
ByVal cbMultiByte As Long, _
ByVal lpWideCharStr As LongPtr, _
ByVal cchWideChar As Long) As Long
Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
ByVal CodePage As Long, _
ByVal dwFlags As Long, _
ByVal lpWideCharStr As LongPtr, _
ByVal cchWideChar As Long, _
ByVal lpMultiByteStr As LongPtr, _
ByVal cchMultiByte As Long, _
ByVal lpDefaultChar As LongPtr, _
ByVal lpUsedDefaultChar As LongPtr) As Long
#Else
Private Declare Function WideCharToMultiByte Lib "kernel32.dll" ( _
ByVal CodePage As Long, _
ByVal dwFlags As Long, _
ByVal lpWideCharStr As Long, _
ByVal cchWideChar As Long, _
ByVal lpMultiByteStr As Long, _
ByVal cbMultiByte As Long, _
ByVal lpDefaultChar As Long, _
ByVal lpUsedDefaultChar As Long) As Long
Private Declare Function MultiByteToWideChar Lib "kernel32.dll" ( _
ByVal CodePage As Long, _
ByVal dwFlags As Long, _
ByVal lpMultiByteStr As Long, _
ByVal cbMultiByte As Long, _
ByVal lpWideCharStr As Long, _
ByVal cchWideChar As Long) As Long
#End If

Public Function ConvertToUTF8(ByRef Source As String) As Byte()
    Dim Length As Long
    #If VBA7 Or Win64 Then
    Dim Pointer As LongPtr
    #Else
    Dim Pointer As Long
    #End If
    Dim Size As Long
    Dim Buffer() As Byte
    Length = Len(Source)
    Pointer = StrPtr(Source)
    Size = WideCharToMultiByte(CP_UTF8, 0, Pointer, Length, 0, 0, 0, 0)
    ReDim Buffer(0 To Size - 1)
    WideCharToMultiByte CP_UTF8, 0, Pointer, Length, VarPtr(Buffer(0)), Size, 0, 0
    ConvertToUTF8 = Buffer
End Function

Public Function ConvertFromUTF8(ByRef Source() As Byte) As String
    Dim Size As Long
    #If VBA7 Or Win64 Then
    Dim Pointer As LongPtr
    #Else
    Dim Pointer As Long
    #End If
    Dim Length As Long
    Dim Buffer As String
    Size = UBound(Source) - LBound(Source) + 1
    Pointer = VarPtr(Source(LBound(Source)))
    Length = MultiByteToWideChar(CP_UTF8, 0, Pointer, Size, 0, 0)
    Buffer = Space$(Length)
    MultiByteToWideChar CP_UTF8, 0, Pointer, Size, StrPtr(Buffer), Length
    ConvertFromUTF8 = Buffer
End Function


'Prozeduren-Jumptable fuer Entwickler
'------------------------------------
Private Sub Test_Audimex_Menu_Save()
    Call Audimex_Menu_Save
End Sub

Private Sub Test_Audimex_Menu_SaveAs()
    Call Audimex_Menu_SaveAs
End Sub

Private Sub Test_Audimex_Menu_SaveVersion()
    Call Audimex_Menu_SaveVersion
End Sub

Private Sub Test_Audimex_Menu_SaveFragments()
    Call Audimex_Menu_SaveFragments
End Sub

Private Sub Test_Audimex_Menu_Log_Show()
    Call Audimex_Menu_Log_Show
End Sub

Private Sub Test_Audimex_Menu_Log_Toggle()
    Call Audimex_Menu_Log_Toggle
End Sub

Private Sub Test_Audimex_Menu_About()
    Call Audimex_Menu_About
End Sub


'Prozeduren fuer das audimex-Menue
'---------------------------------

Sub Audimex_Menu_Test_01()
    Dim info As String
    Dim ThisProc As String
    Dim logmenus As String
    ThisProc = "Audimex_Menu_Test_01"
    Log_Enter ThisProc
    
    info = "TEST ping"
    Dim aktSlot As DocuSlot
    Set aktSlot = GetActiveDocumentSlot
    If (aktSlot Is Nothing) Then
        MsgBox2 ThisProc & vbCrLf & info & vbCrLf & "invalid slot", vbOKOnly
    Else
        MsgBox2 ThisProc & vbCrLf & info & vbCrLf & "Start Ping", vbOKOnly
        
        Dim x As String
        x = Request_Ping(aktSlot)
        If Not (x Like cstr_ServerOkPattern) Then
            MsgBox2 ThisProc & vbCrLf & info & vbCrLf & "Ping Failed:" & vbCrLf & x, vbOKOnly
            Exit Sub
        End If
    
        MsgBox2 ThisProc & vbCrLf & info & vbCrLf & "Server Response:" & vbCrLf & x, vbOKOnly
        Dim pingTimerInterval As Long
        Dim nextLine As String
        nextLine = getItemN(x, 2, vbLf)
        If (InStr(1, nextLine, "PINGTIME ") = 1) Then
            Dim sInterval As String
            sInterval = Mid(nextLine, 10)
            Dim intervalSec As Long
            intervalSec = CLng(sInterval)
            Dim doc As Document
            Set doc = aktSlot.doc_object
            If (intervalSec > 0 And Not doc Is Nothing) Then
                aktSlot.ping_interval = intervalSec
                StartTimer intervalSec, doc
            End If
        End If
    End If
    
    Log_Leave ThisProc
    Log_Separator
    logmenus = GetParamsOne(ActiveDocument, "Audimex_LogMenu", False)
    If logmenus = "1" Then
        Call LogAllMenus
    End If
End Sub

Sub Audimex_Menu_Test_02()
    Dim info As String
    Dim ThisProc As String
    Dim logmenus As String
    ThisProc = "Audimex_Menu_Test_02"
    Log_Enter ThisProc
    info = "Hello World!"
    MsgBox2 ThisProc & vbCrLf & info, vbOKOnly
    Log_Leave ThisProc
    Log_Separator
    logmenus = GetParamsOne(ActiveDocument, "Audimex_LogMenu", False)
    If logmenus = "1" Then
        Call LogAllMenus
    End If
End Sub

Sub Audimex_Menu_Test_03()
    Dim info As String
    Dim ThisProc As String
    Dim logmenus As String
    ThisProc = "Audimex_Menu_Test_03"
    Log_Enter ThisProc
    info = "Hello World!"
    MsgBox2 ThisProc & vbCrLf & info, vbOKOnly
    Log_Leave ThisProc
    Log_Separator
    logmenus = GetParamsOne(ActiveDocument, "Audimex_LogMenu", False)
    If logmenus = "1" Then
        Call LogAllMenus
    End If
End Sub

Sub Audimex_Menu_Save()
    Dim ds As DocuSlot
    Log_Enter "Audimex_Menu_Save()"
    Set ds = GetActiveDocumentSlot
    If (ds.is_read_only) Then
        Log_Leave "Audimex_Menu_Save() [Read_only]"
        Exit Sub
    End If
    came_from_save = True
    'docMode f|fffd|r EXTRACTSCHNITZEL tempor|fffd|r l|fffd|schen (erm|fffd|glicht Speichern des gesamten Dokumentes)
    Dim saved_doc_mode As String
    If (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL) Then
        saved_doc_mode = ds.doc_mode
        ds.doc_mode = ""
    End If
    Call Audimex_Save(ActiveDocument, True)
    'docMode f|fffd|r EXTRACTSCHNITZEL wieder herstellen (erm|fffd|glicht Speichern der Fragmente)
    If Not saved_doc_mode = "" Then
        ds.doc_mode = saved_doc_mode
    End If
    Log_Leave "Audimex_Menu_Save()"
    Log_Separator
End Sub

Sub Audimex_Menu_SaveFragments()
    Dim ds As DocuSlot
    Log_Enter "Audimex_Menu_SaveFragments()"
    Set ds = GetActiveDocumentSlot
    If (ds.is_read_only) Then
        Log_Leave "Audimex_Menu_SaveFragments() [Read_only]"
        Exit Sub
    End If
    came_from_save = True
    Call Audimex_Save(ActiveDocument, True)
    Log_Leave "Audimex_Menu_SaveFragments()"
    Log_Separator
End Sub

Sub Audimex_Menu_SaveAs()
    Dim ds As DocuSlot
    Log_Enter "Audimex_Menu_SaveAs()"
    Set ds = GetActiveDocumentSlot
    came_from_save = True
    'docMode f|fffd|r EXTRACTSCHNITZEL tempor|fffd|r l|fffd|schen (erm|fffd|glicht Speichern des gesamten Dokumentes)
    Dim saved_doc_mode As String
    If (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL) Then
        saved_doc_mode = ds.doc_mode
        ds.doc_mode = ""
    End If
    Call Audimex_SaveAs(ActiveDocument)
    'docMode f|fffd|r EXTRACTSCHNITZEL wieder herstellen (erm|fffd|glicht Speichern der Fragmente)
    If Not saved_doc_mode = "" Then
        ds.doc_mode = saved_doc_mode
    End If
    Log_Leave "Audimex_Menu_SaveAs()"
    Log_Separator
End Sub

Sub Audimex_Menu_SaveVersion()
    Dim ds As DocuSlot
    Log_Enter "Audimex_Menu_SaveVersion()"
    Set ds = GetActiveDocumentSlot
    If (ds.is_read_only) Then
        Log_Leave "Audimex_Menu_SaveVersion() [Read_only]"
        Exit Sub
    End If
    came_from_save = True
    'docMode f|fffd|r EXTRACTSCHNITZEL tempor|fffd|r l|fffd|schen (erm|fffd|glicht Speichern des gesamten Dokumentes)
    Dim saved_doc_mode As String
    If (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL) Then
        saved_doc_mode = ds.doc_mode
        ds.doc_mode = ""
    End If
    Call Audimex_SaveVersion(ActiveDocument)
    'docMode f|fffd|r EXTRACTSCHNITZEL wieder herstellen (erm|fffd|glicht Speichern der Fragmente)
    If Not saved_doc_mode = "" Then
        ds.doc_mode = saved_doc_mode
    End If
    Log_Leave "Audimex_Menu_SaveVersion()"
    Log_Separator
End Sub

'Worker-Prozeduren
'-----------------
Sub Audimex_SaveVersion(doc As Document)
    Dim comment As Variant
    Dim r As Long
    Log_Enter "Audimex_SaveVersion()"
    ' Kommentar abfragen
    comment = InputBox2(asr(ark_SaveAs_commentPlease), asr(ark_MsgBoxTitle_Audimex))
    If (VarType(comment) <> vbString) Then
        Log_Leave "Audimex_SaveVersion() [cancelled]"
        Exit Sub
    End If
    If (comment = "") Then
        MsgBox2 asr(ark_SaveAs_NoCommentGiven), vbInformation
        Log_Leave "Audimex_SaveVersion() [empty input]"
        Exit Sub
    End If
    ' Speichern
    Call Audimex_Save(doc, True, cstr_Tag_save_version, UrlEncode(CStr(comment)))
    Log_Leave "Audimex_SaveVersion()"
End Sub

Private Sub Audimex_SaveAs(doc As Document)
    Dim name As Variant
    Dim comment As String
    Dim r As Long
    Log_Enter "Audimex_SaveAs()"
    ' Name abfragen
    name = InputBox2(asr(ark_SaveAs_NamePlease), asr(ark_MsgBoxTitle_Audimex))
    If (VarType(name) <> vbString) Then
        Log_Leave "Audimex_SaveAs() [cancelled]"
        Exit Sub
    End If
    If (name = "") Then
        MsgBox2 asr(ark_SaveAs_NoNameGiven), vbInformation
        Log_Leave "Audimex_SaveAs() [empty input]"
        Exit Sub
    End If
    ' Speichern
    Call Audimex_Save(doc, True, UrlEncode(CStr(name)))
    Log_Leave "Audimex_SaveAs()"
End Sub

Function Audimex_Save(doc As Document, showOK As Boolean, Optional name As String = cstr_Tag_save, Optional comment As String = cstr_Tag_save_empty_comment) As Boolean
    Dim x As Long
    Dim r As Long
    Dim ds As DocuSlot
    Dim ThisProc As String
    ThisProc = "Audimex_Save"
    Audimex_Save = False
    Log_Enter ThisProc & "(name=" & name & ", comment=" & comment & ")"
    Set ds = GetDocumentSlotByDocument(doc)
    Log_Info ds.dumpParam()

    Log_Trace "Session-ID valid?"
    Call cursorWait
    Call showStatus(asr(ark_Status_CheckSessionid))
    x = Audimex_SessionOK(ds)
    Log_Info "-> Audimex_SessionOk() = " & x
    If (x <> au_session_valid) Then
        Select Case x
        Case au_session_user_cancel
            MsgBox2 asr(ark_Save_SessionidInvalid), vbExclamation + vbOKOnly
        Case au_session_error
            MsgBox2 asr(ark_Save_SessionidError), vbExclamation + vbOKOnly
        Case Else
            MsgBox2 asr(ark_Save_SessionidUnknownError), vbExclamation + vbOKOnly
        End Select
        Call clearStatus
        Call cursorNormal
        Log_Leave ThisProc & " [Abort]"
        Exit Function
    End If
    
    Log_Trace "Check for write protection"
    Call showStatus(asr(ark_Status_Schreibbar))
    x = Audimex_Writable( _
    ds, _
    IIf(name = cstr_Tag_save_version Or name = cstr_Tag_save, name, cstr_Tag_save_as), _
    IIf(name = cstr_Tag_save_version Or name = cstr_Tag_save, "", name))
    Log_Info "-> Audimex_Writable() = " & x
    Select Case x
        
    Case au_writable_yes
        ' Ok, nichts tun
    Case au_writable_no_perm
        MsgBox2 asr(ark_Save_Writable_No_Perm), vbExclamation
        Call clearStatus
        Call cursorNormal
        Log_Leave ThisProc & " [Not Writable]"
        Exit Function
    Case au_writable_no_dup
        MsgBox2 asr(ark_Save_Writable_No_Dup), vbExclamation
        Call clearStatus
        Call cursorNormal
        Log_Leave ThisProc & " [Not Writable]"
        Exit Function
    Case au_writable_no
        MsgBox2 asr(ark_Save_Writable_No), vbExclamation
        Call clearStatus
        Call cursorNormal
        Log_Leave ThisProc & " [Not Writable]"
        Exit Function
    Case au_writable_error
        Log_Error "writable error"
        Call clearStatus
        Call cursorNormal
        Log_Leave ThisProc & " [Error]"
        Exit Function
    Case Else
        Log_Error "unknown error"
        Call clearStatus
        Call cursorNormal
        Log_Leave ThisProc & " [" & x & "]"
        Exit Function
    End Select
    
    ' Speicherkonflikt pr|fffd|fen nur bei "Save"
    If (name = cstr_Tag_save) Then
        ' Speicherkonflikt
        Log_Trace "Check for save conflict"
        Call showStatus(asr(ark_Status_Speicherkonflikt))
        x = Audimex_Speicherkonflikt(ds)
        Log_Info "-> Audimex_Speicherkonflikt() = " & x
        Select Case x
        Case au_conflict_none
            ' Ok, nichts tun
        Case au_conflict_user, au_conflict_time, au_conflict_both
            If (x = au_conflict_time) Then
                r = MsgBox3(asr(ark_Save_Conflict_Time), vbInformation + vbYesNo)
            Else
                r = MsgBox3(asr(ark_Save_Conflict_User), vbInformation + vbYesNo)
            End If
            If (r = vbNo) Then
                If came_from_save Then
                    Log_Info "Save_as not requested"
                    Call clearStatus
                    Call cursorNormal
                    Log_Leave ThisProc & " [conflict]"
                    Exit Function
                End If
                ' Speicherkonflikt beim Schliessen -> saveAs anbieten
                Log_Info "Show Save_as dialog"
                Call Audimex_SaveAs(doc)
                Call clearStatus
                Call cursorNormal
                Log_Leave ThisProc & " [SaveAs]"
                Exit Function
            End If
        Case au_conflict_error
            Log_Error "conflict error"
            Call clearStatus
            Call cursorNormal
            Log_Leave ThisProc & " [Error]"
            Exit Function
        Case Else
            Log_Error "unknown error"
            Call clearStatus
            Call cursorNormal
            Log_Leave ThisProc & " [" & x & "]"
            Exit Function
        End Select
    End If  ' Speicherkonflikt pr|fffd|fen nur bei "Save"
    
    ' Export versuchen
    Call showStatus(asr(ark_Status_Extract))
    x = UploadTable(False)
    Select Case x
    Case au_export_ok, au_export_not_set
        ' Ok, nichts tun
    Case au_export_error
        r = MsgBox3(asr(ark_Extract_Error_Save_Anyway), vbQuestion + vbYesNo)
        If (r = vbNo) Then
            Log_Info "'Save anyway' not requested"
            Call clearStatus
            Call cursorNormal
            Log_Leave ThisProc & " [Export error, no upload]"
            Exit Function
        End If
    Case Else
        Log_Error "unknown error"
        Call clearStatus
        Call cursorNormal
        Log_Leave ThisProc & " [" & x & "]"
        Exit Function
    End Select
    
    ' Upload
    Call showStatus(asr(ark_Status_Upload))
    Dim errstr As String
    x = Audimex_Upload(doc, ds, name, comment, errstr)
    Log_Info "-> Audimex_Upload() = " & x
    Select Case x
    Case au_upload_ok
        If showOK = True Then
            MsgBox2 asr(ark_Upload_Succeeded), vbInformation + vbOKOnly
        End If
        Audimex_Save = True
    Case au_upload_no_timestamp
        MsgBox2 asr(ark_Upload_Warning), vbExclamation + vbOKOnly
    Case Else
        Dim bytehaufen() As Byte
        bytehaufen = StrConv(errstr, vbFromUnicode)
        errstr = ConvertFromUTF8(bytehaufen)
        MsgBox2 asr(ark_Upload_Failed) + vbCrLf + vbCrLf + errstr, vbCritical + vbOKOnly
    End Select
    
    Call clearStatus
    Call cursorNormal
    Log_Leave "Audimex_Save"
End Function

'             ds - DocuSlot, der auf das zu uploadende Document verweist
' SaveAsFilename - Dokumentname in audimex bei SaveAs
'        comment - Versionskommentar in audimex bei SaveVersion
' Return: 0 - OK | 1 - Upload Ok, aber Fehler bei Zeitstempel Holen | 2 - Upload fehlgeschlagen
Function Audimex_Upload(doc As Document, ds As DocuSlot, Optional SaveAsFilename As String = cstr_Tag_save, Optional comment As String = cstr_Tag_save_empty_comment, Optional ByRef errstr As String = "") As Long
    Dim ThisProc As String
    Dim tempname As String
    Dim x As String
    Dim ds_neu As DocuSlot
    Dim sav_id As String, sav_user As String, sav_time As String, sav_name As String, sav_doc_id As String, sav_doc_mode As String
    Dim saved_state As Boolean
    ThisProc = "Audimex_Upload"
    Log_Enter ThisProc & "(SaveAsFilename=" & SaveAsFilename & ", comment=" & comment & ")"
    Audimex_Upload = au_upload_not_set
    
    ' Tempor|fffd|r lokal speichern
    ' di = ds.slot_index .. Filename |fffd|ndert sich -> Index merken
    tempname = MakeTempFileName()
    Log_Info "Saving temporary copy (" & tempname & ")..."
    On Error Resume Next
    saved_state = doc.Saved
    Dim audimexFileFormat As Integer
    audimexFileFormat = wdFormatRTF
    If Not IsEmpty(ds.save_format) And Not Len(ds.save_format) = 0 Then
        audimexFileFormat = Val(ds.save_format)
        If Val(Application.Version) < 12 And audimexFileFormat = 12 Then
            audimexFileFormat = 100
        End If
    End If
    Log_Info "SaveAs: FileName:=" & tempname & "; fileFormat:=" & audimexFileFormat & "; Application.Version=" & Application.Version
    doc.SaveAs FileName:=tempname, fileFormat:=audimexFileFormat
    If (Err.Number > 0) Then
        Log_Error "Error saving temp file [" & Err.Description & "]"
        Audimex_Upload = au_upload_error
        Log_Leave ThisProc & "() [Error]"
        Exit Function
    End If
    On Error GoTo 0
    
    ' DokuManager-Eintrag erg|fffd|nzen/anpassen
    If (Not ds.is_temp) Then
        Log_Info "No previous local copy. Assigning new name to slot " & ds.slot_index & " <- " & doc.FullName
        ds.name = doc.FullName ' neuer Filename in Dokumenten-Array |fffd|berschreibt alten Namen
    Else
        ' war vorher schon lokal tempor|fffd|r gespeichert -> neuen Slot belegen
        Log_Info "Local copy existed before (slot " & ds.slot_index & ", " & ds.name & ")"
        With ds
            sav_id = .id
            sav_user = .tx_user
            sav_time = .tx_time
            sav_name = .docName
            sav_doc_id = .doc_id
            sav_doc_mode = .doc_mode
        End With
        Call refreshDokuSlots_v2(ThisProc, False) ' neuer, unbekannter Name -> neuer Slot wird belegt
        Set ds_neu = GetActiveDocumentSlot
        Log_Info "-> New slot (" & ds_neu.slot_index & ", " & Dok(ds_neu.slot_index).name & ")"
        With ds_neu
            .id = sav_id ' wurde evtl. bei refreshDokuSlots wieder auf alten Wert aus DocumentProperties gesetzt
            .tx_user = sav_user
            .tx_time = sav_time
            .docName = sav_name
            .doc_id = sav_doc_id
            .doc_mode = sav_doc_mode
        End With
        Set ds = ds_neu
        Set ds_neu = Nothing
    End If
    ds.is_temp = True
    
    ' Word hat beim Speichern die Titelleiste |fffd|bernommen. Wieder zur|fffd|ckholen.
    ds.SetCaption
    
    ' Upload durchf|fffd|hren
    Call showStatus(asr(ark_Status_Upload))
    Call cursorWait
    x = Request_Upload(ds, tempname, SaveAsFilename, comment)
    If (Not x Like cstr_ServerOkPattern) Then
        Log_Info "Upload failed"
        Log_Error "unrecognized reply (" & guiEncode(x) & ")"
        errstr = x
        Audimex_Upload = au_upload_error
        If (doc.Saved <> saved_state) Then
            Log_Trace "Resetting 'doc.Saved' to previous value (" & saved_state & ")"
            doc.Saved = saved_state ' "saved" auf vorherigen Stand zur|fffd|cksetzen, wird evtl. in BeforeClose abgefragt
        End If
        Log_Leave ThisProc & "() [Error]"
        Exit Function
    End If
    
    ' Hat sich der logische (audimex-)Name ge|fffd|ndert? (weil wir von SAVE_AS kommen)
    If ((SaveAsFilename <> cstr_Tag_save_version) And (SaveAsFilename <> cstr_Tag_save)) Then
        Log_Trace "Changing document name from '" & ds.docName & "'"
        ds.docName = UrlDecode(SaveAsFilename)
        Log_Trace "                         to '" & ds.docName & "'"
        ds.SetCaption
    End If

    ' Hat sich die Doc-Id ge|fffd|ndert?
    If (SaveAsFilename <> cstr_Tag_save) Then
        Log_Trace "Changing document id from '" & ds.doc_id & "'"
        ds.doc_id = getItemN(x, 2, vbLf)
        ds.set_param "AUDIMEX_DOC_ID", ds.doc_id
        Dim p As DocParam
        Set p = GetParam(ds.doc_object, "AUDIMEX_DOC_ID")
        If p Is Nothing Then
            Log_Error "Empty document property AUDIMEX_DOC_ID"
        Else
            Call setParam(ds.doc_object, p, ds.doc_id)
            Log_Trace "                       to '" & ds.doc_id & "'"
        End If
    End If

    ' Neu gesetzten Zeitstempel holen
    x = Request_Timeinfo(ds)
    If (x Like cstr_ServerOkPattern) Then
        x = Mid(x, Len(cstr_ServerOkString) + 1)                              ' "OK<lf>"
        Log_Trace "Changing document tx_time / user from '" & ds.tx_time & " / " & ds.tx_user & "'"
        ds.tx_time = Mid(getNextItem(x, vbLf), Len(au_conflict_str_time) + 1) ' "TIME t+<lf>"
        ds.tx_user = Mid(getNextItem(x, vbLf), Len(au_conflict_str_user) + 1) ' "USER u+<lf>"
        Log_Trace "                                   to '" & ds.tx_time & " / " & ds.tx_user & "'"
        Audimex_Upload = au_upload_ok
    Else
        Log_Warn "Could not update time stamp."
        Log_Error "unrecognized reply (" & guiEncode(x) & ")"
        Audimex_Upload = au_upload_no_timestamp
    End If

    Log_Leave ThisProc
End Function

' Ret: -1 - nicht gesetzt, 0 - nein, 1 - ja, 2 - Fehler
Function Audimex_Writable(ds As DocuSlot, operation As String, save_as_filename As String) As Long
    Dim x As String, reason As String
    Dim writable As Boolean
    Log_Enter "Audimex_Writable"
    Audimex_Writable = au_writable_not_set
    x = Request_Writable(ds, operation, save_as_filename)
    If Not (x Like cstr_ServerOkPattern) Then
        Log_Info "Server's answer is unlike ok pattern /" & guiEncode(cstr_ServerOkPattern) & "/"
        Log_Error "unrecognized reply (" & guiEncode(x) & ")"
        MsgBox2 asr(ark_WritableError), vbOKOnly
        Audimex_Writable = au_writable_error
        Log_Leave "Audimex_Writable"
        Exit Function
    End If

    writable = (getItemN(x, 2, vbLf) = "1")   ' extrahiere n aus "OK<lf>n<lf>REASON<lf>"
    reason = getItemN(x, 3, vbLf)
    If (writable) Then
        Log_Info "document on server is writable"
        Audimex_Writable = au_writable_yes
    Else
        Log_Info "server denies writing [" & reason & "]"
        Audimex_Writable = au_writable_no
        If (reason Like "FILE EXISTS*") Then
            Audimex_Writable = au_writable_no_dup
        ElseIf (reason Like "NO PERM*") Then
            Audimex_Writable = au_writable_no_perm
        End If
    End If
    Log_Leave "Audimex_Writable"
End Function

' Ret: -1 - nicht gesetzt, 0 - OK
'       1 - Konflikt time, 2 - Konflikt user, 3 - Konflikt time & user
'       4 - Fehler
Function Audimex_Speicherkonflikt(ds As DocuSlot) As Long
    Dim x As String
    Dim myTime As String
    Dim myUser As String
    Log_Enter "Audimex_Speicherkonflikt"
    Audimex_Speicherkonflikt = au_conflict_not_set
    x = Request_Timeinfo(ds)
    If Not (x Like cstr_ServerOkPattern) Then
        Log_Info "Server's answer is unlike ok pattern /" & guiEncode(cstr_ServerOkPattern) & "/"
        Log_Error "unrecognized reply (" & guiEncode(x) & ")"
        Audimex_Speicherkonflikt = au_conflict_error
        Log_Leave "Audimex_Speicherkonflikt"
        Exit Function
    End If

    x = Mid(x, Len(cstr_ServerOkString) + 1)                             ' "OK<lf>"
    myTime = Mid(getNextItem(x, vbLf), Len(au_conflict_str_time) + 1)    ' "TIME t+<lf>"
    myUser = Mid(getNextItem(x, vbLf), Len(au_conflict_str_user) + 1)    ' "USER u+<lf>"
    If ((myTime = ds.tx_time) And (myUser = ds.tx_user)) Or ((myTime = "") And (myUser = "")) Then
        Log_Info "same user/time or no previous user/time"
        Audimex_Speicherkonflikt = au_conflict_none
    Else
        ' Jetzt gilt: (not (mt = at and mu = au)) and (not (mt = "" and mu = ""))
        Log_Info "user/time changed since last download:"
        Log_Info "local:  user(" & ds.tx_user & ")," & vbTab & "time(" & ds.tx_time & ")"
        Log_Info "remote: user(" & myUser & ")," & vbTab & "time(" & myTime & ")"
        If (myUser = ds.tx_user) Or (myUser = "") Then
            Log_Info "-> time differs."
            Audimex_Speicherkonflikt = au_conflict_time
        ElseIf (myTime = ds.tx_time) Or (myTime = "") Then
            Log_Info "-> user differs."
            Audimex_Speicherkonflikt = au_conflict_user
        Else
            Audimex_Speicherkonflikt = au_conflict_both
        End If
    End If
    Log_Leave "Audimex_Speicherkonflikt"
End Function

' Ret: 0 - OK, 1 - Session-ID ung|fffd|ltig und User hat abgebrochen, 2 - Fehler
Function Audimex_SessionOK(ds As DocuSlot) As Long
    Dim x As String
    Log_Enter "Audimex_SessionOk"

    If (ds.is_ntlm Or ds.is_siteminder) Then
        Log_Info "Authentication: NTLM or SITEMINDER"
        Audimex_SessionOK = au_session_valid
        Log_Leave "Audimex_SessionOk [Ok]"
        Exit Function
    End If

    Audimex_SessionOK = au_session_not_set
    login_ok = True
    x = Request_VerifySessionId(ds)

    If (x Like cstr_ServerOkPattern) Then
        Log_Info "Server's answer matches ok pattern /" & guiEncode(cstr_ServerOkPattern) & "/"
        Audimex_SessionOK = au_session_valid
    ElseIf (x Like cstr_ServerNotOkPattern) Then
        Log_Info "Server's answer matches not-ok pattern /" & guiEncode(cstr_ServerNotOkPattern) & "/"
        Log_Info "login required"
        login_ok = False
        Call Login
    Else
        Log_Error "unrecognized reply (" & guiEncode(x) & ")"
        Audimex_SessionOK = au_session_error
        Log_Leave "Audimex_SessionOk [Error]"
        Exit Function
    End If

    If login_ok Then
        Audimex_SessionOK = au_session_valid
    Else
        Audimex_SessionOK = au_session_user_cancel
    End If
    Log_Leave "Audimex_SessionOk"
End Function

Private Sub Login()
    Log_Enter "Login()"
    load LoginDialog
    With LoginDialog
        .LoginMessage.Caption = asr(ark_Login_Msg_SessionidInvalid)
        .LoginMessage.ControlTipText = ""
        .LoginUsername_Lbl.Caption = asr(ark_Login_Username_Label)
        .LoginUsername_Lbl.ControlTipText = asr(ark_Login_Username_Label_Tooltip)
        .LoginUsername_Text.Text = ""
        .LoginUsername_Text.ControlTipText = asr(ark_Login_Username_Input_Tooltip)
        .LoginPassword_Lbl.Caption = asr(ark_Login_Password_Label)
        .LoginPassword_Lbl.ControlTipText = asr(ark_Login_Password_Label_Tooltip)
        .LoginPassword_Text.Text = ""
        .LoginPassword_Text.ControlTipText = asr(ark_Login_Password_Input_Tooltip)
        .LoginButtonOk.Caption = asr(ark_Login_Button_Ok_Caption)
        .LoginButtonOk.ControlTipText = asr(ark_Login_Button_Ok_Tooltip)
        .LoginButtonCancel.Caption = asr(ark_Login_Button_Cancel_Caption)
        .LoginButtonCancel.ControlTipText = asr(ark_Login_Button_Cancel_Tooltip)
        .Show
    End With
    Unload LoginDialog
    Log_Leave "Login()"
End Sub

Public Sub cursorWait()
    Application.System.Cursor = wdCursorWait
End Sub

Public Sub cursorNormal()
    Application.System.Cursor = wdCursorNormal
End Sub

Public Sub showStatus(msg As String)
    Application.StatusBar = msg
End Sub

Public Sub clearStatus()
    Call showStatus("")
End Sub

' wie MsgBox, aber mit Logging
Public Sub MsgBox2(msg As String, buttons As Long)
    Log_Info "User Message: " & msg
    MsgBox msg, buttons, asr(ark_MsgBoxTitle_Audimex)
End Sub

' wie MsgBox(), d.h. mit Antwort, aber mit Logging
Public Function MsgBox3(msg As String, buttons As Long) As Long
    Log_Info "User Dialog: " & msg
    MsgBox3 = MsgBox(msg, buttons, asr(ark_MsgBoxTitle_Audimex))
    Log_Info "-> " & MsgBox3
End Function

' bessere InputBox, das Original unterscheidet nicht zwischen Cancel und Ok mit leerem Text
' Liefert Variant: String bei Ok, false  bei Cancel
Public Function InputBox2(prompt As String, title As String) As Variant
    Log_Enter "InputBox2(" & prompt & ")"
    InputBox2 = False
    ExtendedInputBox_Ok = False
    load ExtendedInputBox
    With ExtendedInputBox
        .Caption = title
        .ExtendedInputBox_Prompt_Label.Caption = prompt
        .ExtendedInputBox_Prompt_Label.ControlTipText = ""
        .ExtendedInputBox_Button_Ok.Caption = asr(ark_ExtendedInputBox_Button_Ok_Caption)
        .ExtendedInputBox_Button_Ok.ControlTipText = asr(ark_ExtendedInputBox_Button_Ok_Tooltip)
        .ExtendedInputBox_Button_Cancel.Caption = asr(ark_ExtendedInputBox_Button_Cancel_Caption)
        .ExtendedInputBox_Button_Cancel.ControlTipText = asr(ark_ExtendedInputBox_Button_Cancel_Tooltip)
        .ExtendedInputBox_Input_Text.Text = ""
        .ExtendedInputBox_Input_Text.ControlTipText = asr(ark_ExtendedInputBox_Input_Text_Tooltip)
        .Show
        If (ExtendedInputBox_Ok) Then
            InputBox2 = .ExtendedInputBox_Input_Text.Text
        End If
    End With
    Unload ExtendedInputBox
    Log_Leave "InputBox2 ->" & InputBox2 & "<-"
End Function

' bessere SaveAsBox, damit kann auch abgefragt werden, ob in einem nichtgespeicherten Dokument
' neben dem Dokument selbst auch die Fragmente gespeichert werden sollen.
' Liefert Variant: String = "Ok" bei Dokument speichern,
'                  String = "OkFragment" bei Dokument zusammen mit Fragenment speichern und
'                  String = "false" bei Cancel
Public Function SaveAsBox2(prompt As String, title As String, showFragments As Boolean) As String
    Log_Enter "SaveAsBox2(" & prompt & ")"
    SaveAsBox2 = False
    ExtendedSaveBox_Ret = ""
    load ExtendedSaveBox
    With ExtendedSaveBox
        .Caption = title
        .ExtendedSaveBox_Button_Yes.Caption = asr(ark_ExtendedSaveBox_Button_Yes_Caption)
        .ExtendedSaveBox_Button_No.Caption = asr(ark_ExtendedSaveBox_Button_No_Caption)
        .ExtendedSaveBox_Button_Cancel.Caption = asr(ark_ExtendedSaveBox_Button_Cancel_Caption)
        .lbl_Question.Caption = prompt
        .chk_Fragments.Visible = False
        If showFragments = True Then
            .chk_Fragments.Visible = True
            .chk_Fragments.Caption = asr(ark_ExtendedSaveBox_Button_Checked_Caption)
            .chk_Fragments.Enabled = True
            .chk_Fragments.value = True
        End If
        .Show
        SaveAsBox2 = ExtendedSaveBox_Ret
    End With
    Unload ExtendedSaveBox
    Log_Leave "SaveAsBox2 ->" & SaveAsBox2 & "<-"
End Function

Sub Audimex_Menu_About()
    Dim ThisProc As String
    Dim logmenus As String
    ThisProc = "Audimex_Menu_About"
    Log_Enter ThisProc
    MsgBox2 getAddinVersion, vbOKOnly
    Log_Leave ThisProc
    Log_Separator
    logmenus = GetParamsOne(ActiveDocument, "Audimex_LogMenu", False)
    If logmenus = "1" Then
        Call LogAllMenus
    End If
End Sub

Public Function getAddinVersion() As String
    ' Absichtlich nur den statischen Text aus dem Code, NICHT aus der DB nehmen!
    getAddinVersion = asr_About_Text1 & asr_About_Text2
End Function

Attribute VB_Name = "MenuUtilities"
Option Explicit

Public Property Get Version() As String
    Version = "$Revision: 1.3 $"
End Property

Sub MenuInstall(m As Variant, C As CommandBar)
    Dim Ok As Boolean
    Log_Trace "Call MakeMenu from MenuInstall"
    Ok = MakeMenu(m, C.Controls, True)
    If Not Ok Then
        Log_Error "Syntaxfehler in der Men|fffd|definition."
        MsgBox "Syntaxfehler in der Men|fffd|definition.", vbCritical + vbOKOnly, "Men|fffd|-Installation"
    Else
        Log_Trace "Call MakeMenu again from MenuInstall"
        Ok = MakeMenu(m, C.Controls, False)
        If Not Ok Then
            Log_Error "Men|fffd|installation fehlgeschlagen."
            MsgBox "Men|fffd|installation fehlgeschlagen.", vbCritical + vbOKOnly, "Men|fffd|-Installation"
        Else
            Log_Info "Menu installed successfully."
        End If
    End If
End Sub

Function MakeMenu(m As Variant, Ctrls As CommandBarControls, check As Boolean) As Boolean
    Dim name As String, typ As String
    Dim Ok As Boolean
    Log_Enter "MakeMenu"
    ' Array(Name, popup, Array [, Enable [, Tag]])
    ' Array(Name, button, Macro [, Enable [, Tag [, State]]])
    On Error Resume Next
    name = m(0)
    typ = m(1)
    If (Err.Number <> 0) Then
        MakeMenu = False
        Log_Trace "Errors exist in MakeMenu --> leaving"
        Exit Function
    End If
    On Error GoTo 0
    Select Case typ
    Case "popup"
        If (check = True) Then
            Log_Trace "Checking popup menu : " & name
        Else
            Log_Trace "Adding popup menu: " & name
        End If
        Ok = MakePopup(name, m, Ctrls, check)
    Case "button"
        If (check = True) Then
            Log_Trace "Checking menu button: " & name
        Else
            Log_Trace "Adding menu button: " & name
        End If
        Ok = MakeButton(name, m, Ctrls, check)
    Case Else
        Ok = False
    End Select
    MakeMenu = Ok
    Log_Leave "MakeMenu"
End Function

Function MakePopup(name As String, ByVal m As Variant, Ctrls As CommandBarControls, check As Boolean) As Boolean
    Dim NewPopup As CommandBarPopup
    Dim NewPopupControls As CommandBarControls
    Dim Ok As Boolean
    Dim i As Long
    Dim NewM As Variant
    Dim Enable As String, Tag As String, Group As String
    On Error Resume Next
    Enable = "true"
    Enable = m(3)
    Tag = ""
    Tag = m(4)
    Group = ""
    Group = m(5)
    On Error GoTo 0
    Set NewPopup = Nothing
    Set NewPopupControls = Nothing
    If (Not check) Then
        Set NewPopup = Ctrls.Add(Type:=msoControlPopup, id:=1, temporary:=True)
        With NewPopup
            .Caption = name
            .Enabled = (Enable = "true")
            .Tag = Tag
            .BeginGroup = (Group = "true")
            Set NewPopupControls = .Controls
        End With
    End If
    On Error Resume Next
    NewM = m(2) ' Array mit Popup-Controls
    If (Err.Number <> 0) Then
        MakePopup = False
        Log_Trace "Errors exist in MakePopup --> leaving"
        Exit Function
    End If
    On Error GoTo 0
    Ok = True
    For i = 0 To UBound(NewM)
        Log_Trace "Call MakeMenu from MakePopup | check = " & check
        Ok = MakeMenu(NewM(i), NewPopupControls, check)
        If (Not Ok) Then Exit For
    Next i
    MakePopup = Ok
    Log_Trace "Leaving MakePopup"
End Function

Function MakeButton(name As String, ByVal m As Variant, Ctrls As CommandBarControls, check As Boolean) As Boolean
    Dim Macro As String, Enable As String
    Dim Tag As String, State As String, Group As String
    Dim NewButton As CommandBarButton
    On Error Resume Next
    Macro = ""
    Macro = m(2)
    Enable = "true"
    Enable = m(3)
    Tag = ""
    Tag = m(4)
    State = "up"
    State = m(5)
    Group = ""
    Group = m(6)
    If (Not check) Then
        Set NewButton = Ctrls.Add(Type:=msoControlButton, id:=1, temporary:=True)
        With NewButton
            .Caption = name
            .OnAction = Macro
            .Enabled = (Enable = "true")
            .Tag = Tag
            .State = IIf(State = "down", msoButtonDown, msoButtonUp)
            .BeginGroup = (Group = "true")
        End With
        Log_Trace "Button added : " & name
    Else
        Log_Trace "Button check only : " & name
    End If
    MakeButton = True
End Function

Sub listCommandBars()
    Dim cb As CommandBar
    Dim ct As CommandBarControl
    Dim m As Long, l As Long
    For Each cb In Application.CommandBars
        l = Len(cb.name)
        If l > m Then m = l
    Next
    For Each cb In Application.CommandBars
        Debug.Print Format(cb.Index, "00#") & " " & Left(cb.name & String(m, " "), m) & " ";
        For Each ct In cb.Controls
            Debug.Print ct.Caption & " ";
        Next
        Debug.Print
    Next
End Sub

Sub listCommandBar36()
    Dim cb As CommandBar
    Dim ct As CommandBarControl
    Dim ct1 As CommandBarButton
    Dim m As Long, l As Long
    Set ct1 = Application.CommandBars(36).Controls(11).Controls(4).Controls(2)
    Set ct = Application.CommandBars.FindControl(Tag:=cstr_Tag_Log_Toggle)
    Debug.Print ct1.Caption & "(" & ct1.Tag & ")" & ct1.State
End Sub

Attribute VB_Name = "ParamUtilities"
Option Explicit

Public Const AUDIMEX_ID                        As String = "AUDIMEX_ID"
Public Const AUDIMEX_SERVER                    As String = "AUDIMEX_SERVER"
Public Const AUDIMEX_URL                       As String = "AUDIMEX_URL"
Public Const AUDIMEX_DOCNAME                   As String = "AUDIMEX_DOCNAME"
Public Const AUDIMEX_OBJECT_ID                 As String = "AUDIMEX_OBJECT_ID"
Public Const AUDIMEX_DOC_ID                    As String = "AUDIMEX_DOC_ID"
Public Const AUDIMEX_DOC_TYPE_ID               As String = "AUDIMEX_DOC_TYPE_ID"
Public Const AUDIMEX_TX_TIME                   As String = "AUDIMEX_TX_TIME"
Public Const AUDIMEX_TX_USER                   As String = "AUDIMEX_TX_USER"
Public Const AUDIMEX_DOC_STATE                 As String = "AUDIMEX_DOC_STATE"
Public Const AUDIMEX_PORT                      As String = "AUDIMEX_PORT"
Public Const AUDIMEX_PROTOCOL                  As String = "AUDIMEX_PROTOCOL"
Public Const AUDIMEX_READ_ONLY                 As String = "AUDIMEX_READ_ONLY"
Public Const AUDIMEX_CAN_EXTRACT               As String = "AUDIMEX_CAN_EXTRACT"
Public Const AUDIMEX_CUSTOMIZE                 As String = "AUDIMEX_CUSTOMIZE"
Public Const AUDIMEX_AUTH                      As String = "AUDIMEX_AUTH"
Public Const AUDIMEX_SAVE_FORMAT               As String = "AUDIMEX_SAVE_FORMAT"
Public Const AUDIMEX_DOC_MODE                  As String = "AUDIMEX_DOC_MODE" 'Wertebereich: SCHNIPSEL|DOCUMENT|EXTRACTSCHNITZEL
Public Const AUDIMEX_DOC_MODE_DOCUMENT         As String = "DOCUMENT"
Public Const AUDIMEX_DOC_MODE_SCHNIPSEL        As String = "SCHNITZEL"
Public Const AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL As String = "EXTRACTSCHNITZEL"
Public Const AUDIMEX_TAB_COL_ID                As String = "AUDIMEX_TAB_COL_ID"
Public Const AUDIMEX_KEEP_ALIVE_TIME           As String = "AUDIMEX_KEEP_ALIVE_TIME"
Public Const AUDIMEX_FALLBACK_PATH             As String = "AUDIMEX_FALLBACK_PATH"

Public Const PI_NAME As Long = 0
Public Const PI_MAND As Long = 1
Public Const PI_TYPE As Long = 2
Public Const PI_DFLT As Long = 3

Dim DocParams As Collection

' Nur Testen (mandatory)
Function CheckParams(doc As Document, Optional do_log As Boolean = False) As Boolean
    CheckParams = GetParams(doc, Nothing, True, do_log)
End Function

' Lesen (alle)
Sub readParams(doc As Document, ds As DocuSlot)
    Dim dummy As Boolean
    dummy = GetParams(doc, ds, False)
End Sub

' Param_name, Mandatory, Property_Type, Default_Value
Function listofParams(Optional CleanUp As Boolean = False) As Collection
    Dim l As Variant, l1 As Variant, i As Long
    If (DocParams Is Nothing) Then
        Set DocParams = New Collection
        l1 = Array( _
        Array(AUDIMEX_ID, True, msoPropertyTypeString, "12345"), _
        Array(AUDIMEX_SERVER, True, msoPropertyTypeString, "gschoch.stb-ag.org"), _
        Array(AUDIMEX_URL, True, msoPropertyTypeString, "cgi-bin/audimex/wal.pl?action=document_upload.pl"), _
        Array(AUDIMEX_DOCNAME, True, msoPropertyTypeString, "test1.rtf"), _
        Array(AUDIMEX_OBJECT_ID, True, msoPropertyTypeString, "29"), _
        Array(AUDIMEX_DOC_ID, True, msoPropertyTypeString, "30"), _
        Array(AUDIMEX_DOC_TYPE_ID, True, msoPropertyTypeString, "31"), _
        Array(AUDIMEX_TX_TIME, True, msoPropertyTypeString, "123"), _
        Array(AUDIMEX_TX_USER, True, msoPropertyTypeString, "1"), _
        Array(AUDIMEX_DOC_STATE, True, msoPropertyTypeString, "1"), _
        Array(AUDIMEX_PORT, True, msoPropertyTypeString, "80"), _
        Array(AUDIMEX_PROTOCOL, True, msoPropertyTypeString, "http"), _
        Array(AUDIMEX_READ_ONLY, True, msoPropertyTypeString, "1"), _
        Array(AUDIMEX_CAN_EXTRACT, False, msoPropertyTypeString, "0"), _
        Array(AUDIMEX_AUTH, False, msoPropertyTypeString, "0"), _
        Array(AUDIMEX_SAVE_FORMAT, False, msoPropertyTypeString, ""), _
        Array(AUDIMEX_CUSTOMIZE, False, msoPropertyTypeString, "standard"), _
        Array(AUDIMEX_TAB_COL_ID, False, msoPropertyTypeString, ""), _
        Array(AUDIMEX_DOC_MODE, False, msoPropertyTypeString, ""), _
        Array(AUDIMEX_FALLBACK_PATH, False, msoPropertyTypeString, "0"), _
        Array(AUDIMEX_KEEP_ALIVE_TIME, False, msoPropertyTypeString, "0"))
        For i = 0 To UBound(l1)
            l = l1(i)
            DocParams.Add Item:=makeDocParam(l(PI_NAME), l(PI_TYPE), l(PI_DFLT), l(PI_MAND)), key:=CStr(l(PI_NAME))
        Next
    End If
    Set listofParams = DocParams
End Function

Sub pu_final()
    Dim i As Long
    Dim dummy As DocParam
    Log_Enter "sk_final()"
    If (DocParams Is Nothing) Then
        Log_Info "DocParams already clean"
    Else
        Do While (DocParams.Count > 0)
            Set dummy = DocParams.Item(1)
            DocParams.Remove Index:=1
            Set dummy = Nothing
        Loop
        Set DocParams = Nothing
    End If
    Log_Leave "sk_final()"
End Sub

' Liest DocuSlot-Werte aus Dokument-Eigenschaften (auch unvollst|fffd|ndig), falls Check = false
' sonst nur Pr|fffd|fung auf Vollst|fffd|ndigkeit der mandatory-Parameter (-> true/false)
Function GetParams(doc As Document, ds As DocuSlot, check As Boolean, Optional do_log As Boolean = False) As Boolean
    Dim value As Variant
    Dim parmList As Collection
    Dim p As DocParam
    GetParams = True
    Set parmList = listofParams()
    For Each p In parmList
        value = GetParamsOne(doc, p.name, do_log)
        If (check) Then
            If (IsEmpty(value) And p.mandatory) Then
                GetParams = False ' Existiert nicht und check -> unvollst|fffd|ndig, Ende
                Exit Function
            End If
        Else
            ' kein check -> auslesen
            If (IsEmpty(value) And p.mandatory) Then GetParams = False ' unvollst|fffd|ndig, weiterauslesen
            ds.set_param p.name, CStr(value)
        End If
    Next
End Function

' Liefert den Wert zu einem Schl|fffd|ssel in "Datei -> Eigenschaften -> Anpassen"
' bei Nichtvorhandensein wird Empty zur|fffd|ckgegeben
Function GetParamsOne(doc As Document, key As String, do_log As Boolean) As Variant
    Dim found As Boolean, s As String
    'check for existing key
    found = False
    On Error Resume Next
    GetParamsOne = Empty
    GetParamsOne = doc.CustomDocumentProperties(key).value
    found = (Err.Number = 0)
    On Error GoTo 0
    If (found) Then
        s = Trim(CStr(GetParamsOne))
        Call replaceText(s, vbLf, "")
        Call replaceText(s, vbCr, "")
        GetParamsOne = s
    End If
    Dim parameter_name As String
    parameter_name = "GetParamsOne(" & key & ")"
    parameter_name = parameter_name + Space(40 - Len(parameter_name))
    If (do_log Or developer_mode) Then
        Log_Info parameter_name & ">" & GetParamsOne & "<"
    End If
End Function

Function GetParam(doc As Document, key As String) As DocParam
    Dim parmList As Collection
    Dim p As DocParam
    Dim found As Boolean
    ' check for exising key
    On Error Resume Next
    GetParam = Empty
    Set parmList = listofParams()
    found = False
    For Each p In parmList
        If p.name = key Then
            Set GetParam = p
            found = True
            Exit For
        End If
    Next
    If found = False Then
        Set GetParam = Nothing
    End If
    On Error GoTo 0
End Function

Function makeDocParam(name As Variant, typ As Variant, Optional default As Variant = "", Optional mand As Variant = False) As DocParam
    Set makeDocParam = New DocParam ' free beim Aufrufer
    With makeDocParam
        .name = CStr(name)
        .ptype = CLng(typ)
        .default = CStr(default)
        .mandatory = CBool(mand)
    End With
End Function

' Wert value von Parameter p soll in DocumentProperties von Dokument doc gesetzt werden
' Aufrufer: dm_ReSetIdAll, castAudimexDoc
Sub setParam(doc As Document, p As DocParam, value As String)
    On Error Resume Next
    With doc.CustomDocumentProperties
        .Item(p.name).value = value
        If (Err.Number > 0) Then
            .Add name:=p.name, Type:=p.ptype, value:=value, LinkToContent:=False
            Err.Clear
        End If
    End With
End Sub

Sub castAudimexDoc()
    Dim p As DocParam
    For Each p In listofParams()
        Call setParam(ActiveDocument, p, p.default)
    Next
End Sub

Sub unCastAudimexDoc()
    Dim p As DocParam
    On Error Resume Next
    With ActiveDocument.CustomDocumentProperties
        For Each p In listofParams()
            .Item(p.name).Delete
        Next
    End With
End Sub
Attribute VB_Name = "StringKonstanten"
Option Explicit

' Extract
Public Const ark_Extract_Error_Save_Anyway               As String = "ark_Extract_Error_Save_Anyway"
Public Const asr_Extract_Error_Save_Anyway               As String = _
"Schritt 1/2 (Datenexport) fehlgeschlagen." & vbLf & _
"Fortfahren mit Schritt 2/2 (Dokument nach audimex zur|fffd|ckspeichern)?"
Public Const ark_Extract_Error_Number_Tables            As String = "ark_Extract_Error_Number_Tables "
Public Const asr_Extract_Error_Number_Tables            As String = "Keine oder mehr als zwei Tabellen in Kommentar"
Public Const ark_Extract_Error_Cell                     As String = "ark_Extract_Error_Cell"
Public Const asr_Extract_Error_Cell                     As String = "Problem mit markierter Zelle:"
Public Const ark_Extract_Error_Datatype_Date            As String = "ark_Extract_Error_Datatype_Date"
Public Const asr_Extract_Error_Datatype_Date            As String = "Falsches Datumsformat"
Public Const ark_Extract_Error_Datatype_Long            As String = "ark_Extract_Error_Datatype_Long"
Public Const asr_Extract_Error_Datatype_Long            As String = "Falsches Ganzzahlformat"
Public Const ark_Extract_Error_Datatype_Double          As String = "ark_Extract_Error_Datatype_Double"
Public Const asr_Extract_Error_Datatype_Double          As String = "Falsches Gleitkommaformat"

' Button-Beschriftung custInputBox
Public Const ark_ExtendedInputBox_Button_Ok_Caption     As String = "ark_ExtendedInputBox_Button_Ok_Caption"
Public Const asr_ExtendedInputBox_Button_Ok_Caption     As String = "Ok"
Public Const ark_ExtendedInputBox_Button_Ok_Tooltip     As String = "ark_ExtendedInputBox_Button_Ok_Tooltip"
Public Const asr_ExtendedInputBox_Button_Ok_Tooltip     As String = "Ok"
Public Const ark_ExtendedInputBox_Button_Cancel_Caption As String = "ark_ExtendedInputBox_Button_Cancel_Caption"
Public Const asr_ExtendedInputBox_Button_Cancel_Caption As String = "Abbrechen"
Public Const ark_ExtendedInputBox_Button_Cancel_Tooltip As String = "ark_ExtendedInputBox_Button_Cancel_Tooltip"
Public Const asr_ExtendedInputBox_Button_Cancel_Tooltip As String = "Abbrechen"
Public Const ark_ExtendedInputBox_Input_Text_Tooltip    As String = "ark_ExtendedInputBox_Input_Text_Tooltip"
Public Const asr_ExtendedInputBox_Input_Text_Tooltip    As String = "Texteingabe"


' Button-Beschriftung custSaveBox
Public Const ark_ExtendedSaveBox_Button_Yes_Caption     As String = "ark_ExtendedSaveBox_Button_Yes_Caption"
Public Const asr_ExtendedSaveBox_Button_Yes_Caption     As String = "Ja"
Public Const ark_ExtendedSaveBox_Button_No_Caption      As String = "ark_ExtendedSaveBox_Button_No_Caption"
Public Const asr_ExtendedSaveBox_Button_No_Caption      As String = "Nein"
Public Const ark_ExtendedSaveBox_Button_Cancel_Caption  As String = "ark_ExtendedSaveBox_Button_Cancel_Caption"
Public Const asr_ExtendedSaveBox_Button_Cancel_Caption  As String = "Abbrechen"
Public Const ark_ExtendedSaveBox_Button_Checked_Caption As String = "ark_ExtendedSaveBox_Button_Checked_Caption"
Public Const asr_ExtendedSaveBox_Button_Checked_Caption As String = "Fragmente ebenfalls speichern"
Public Const ark_ExtendedSaveBox_Question               As String = "ark_ExtendedSaveBox_Question"
Public Const asr_ExtendedSaveBox_Question               As String = "|fffd|nderungen zu audimex zur|fffd|ckspeichern" & _
                                                                    vbLf & "Ja    = Speichern" & _
                                                                    vbLf & "Nein  = |fffd|nderungen verwerfen" & vbLf
Public Const ark_ExtendedSaveBox_Title                  As String = "ark_ExtendedSaveBox_Title"
Public Const asr_ExtendedSaveBox_Title                  As String = "|fffd|nderungen zur|fffd|ckspeichern"

' Allgemein
Public Const ark_AppTitle                   As String = "ark_AppTitle"
Public Const asr_AppTitle                   As String = " - audimex Dokument"
Public Const ark_MsgBoxTitle_Audimex        As String = "ark_MsgBoxTitle_Audimex"
Public Const asr_MsgBoxTitle_Audimex        As String = "audimex"
Public Const ark_Http_NoServer              As String = "ark_Http_NoServer"
Public Const asr_Http_NoServer              As String = "Server nicht bekannt. Bearbeitung nicht m|fffd|glich"

' Doku-Manager
Public Const ark_DocMan_NotInitialized      As String = "ark_DocMan_NotInitialized"
Public Const asr_DocMan_NotInitialized      As String = "DokuManager fehlerhaft. Bitte Word beenden und neu starten"
Public Const ark_DocMan_NoFreeSlot          As String = "ark_DocMan_NoFreeSlot"
Public Const asr_DocMan_NoFreeSlot          As String = "Keinen freien Slot gefunden"
Public Const ark_DocMan_DocNotFound         As String = "ark_DocMan_DocNotFound"
Public Const asr_DocMan_DocNotFound         As String = "Kann Dokument im DokuManager nicht finden!"

' Status-Zeile
Public Const ark_Status_CheckSessionid      As String = "ark_Status_CheckSessionid"
Public Const asr_Status_CheckSessionid      As String = "Pr|fffd|fe Sessionid..."
Public Const ark_Status_Upload              As String = "ark_Status_Upload"
Public Const asr_Status_Upload              As String = "Zur|fffd|ckspeichern..."
Public Const ark_Status_Speicherkonflikt    As String = "ark_Status_Speicherkonflikt"
Public Const asr_Status_Speicherkonflikt    As String = "Pr|fffd|fe Speicherkonflikt..."
Public Const ark_Status_Schreibbar          As String = "ark_Status_Schreibbar"
Public Const asr_Status_Schreibbar          As String = "Pr|fffd|fe Schreiberlaubnis..."
Public Const ark_Status_Ping                As String = "ark_Status_Ping"
Public Const asr_Status_Ping                As String = "Verbindungstest..."
Public Const ark_Status_Resource            As String = "ark_Status_Resource"
Public Const asr_Status_Resource            As String = "Hole Anzeigetexte..."
Public Const ark_Status_Extract             As String = "ark_Status_Extract"
Public Const asr_Status_Extract             As String = "Exportiere Daten..."

' Men|fffd|
Public Const ark_Menu_Audimex               As String = "ark_Menu_Audimex"
Public Const asr_Menu_Audimex               As String = "audi&mex"
Public Const ark_Menu_Speichern             As String = "ark_Menu_Speichern"
Public Const asr_Menu_Speichern             As String = "&Speichern"
Public Const ark_Menu_SpeichernUnter        As String = "ark_Menu_SpeichernUnter"
Public Const asr_Menu_SpeichernUnter        As String = "Speichern &Unter..."
Public Const ark_Menu_SpeichernFragmente    As String = "ark_Menu_SpeichernFragmente"
Public Const asr_Menu_SpeichernFragmente    As String = "Speichern &Fragmente"
Public Const ark_Menu_SpeichernVersion      As String = "ark_Menu_SpeichernVersion"
Public Const asr_Menu_SpeichernVersion      As String = "Speichern als neue Version..."
Public Const ark_Menu_Extrahieren           As String = "ark_Menu_Extrahieren"
Public Const asr_Menu_Extrahieren           As String = "Daten nach audimex exportieren"
Public Const ark_Menu_Einstellungen         As String = "ark_Menu_Einstellungen"
Public Const asr_Menu_Einstellungen         As String = "Einstellungen..."
Public Const ark_Menu_Log_Filename          As String = "ark_Menu_Log_Filename"
Public Const asr_Menu_Log_Filename          As String = "Inhalt der tempor|fffd|ren Log-Datei anzeigen..."
Public Const ark_Menu_Log_Toggle            As String = "ark_Menu_Log_Toggle"
Public Const asr_Menu_Log_Toggle            As String = "Log-Datei beim Beenden l|fffd|schen"
Public Const ark_Menu_Reserviert            As String = "ark_Menu_Reserviert"
Public Const asr_Menu_Reserviert            As String = "Reserviert"
Public Const ark_Menu_About                 As String = "ark_Menu_About"
Public Const asr_Menu_About                 As String = "|fffd|ber audimex_addin.dot..."

' Speichern
Public Const ark_Upload_NoAttrib            As String = "ark_Upload_NoAttrib"
Public Const asr_Upload_NoAttrib            As String = _
"Das Dokument ist zwar erfolgreich gespeichert worden," & vbLf & _
"ein Fehler beim Aktualisieren des Zeitstempels f|fffd|hrt" & vbLf & _
"jedoch evtl. zu einer falschen Speicherkonflikt-Meldung" & vbLf & _
"beim sp|fffd|teren erneuten Speichern."
Public Const ark_Upload_Failed              As String = "ark_Upload_Failed"
Public Const asr_Upload_Failed              As String = "Zur|fffd|ckspeichern fehlgeschlagen"
Public Const ark_Upload_Succeeded           As String = "ark_Upload_Succeeded"
Public Const asr_Upload_Succeeded           As String = "Zur|fffd|ckspeichern erfolgreich"
Public Const ark_Upload_Warning             As String = "ark_Upload_Warning"
Public Const asr_Upload_Warning             As String = _
"Zur|fffd|ckspeichern nur teilweise erfolgreich (gespeichert, aber Zeitstempel wurde nicht neu gesetzt)" & vbLf & _
"Empfehlung: Dokument Schliessen und aus audimex neu herunterladen."
Public Const ark_Save_Writable_No_Perm      As String = "ark_Save_Writable_No_Perm"
Public Const asr_Save_Writable_No_Perm      As String = _
"Das Dokument kann nicht unter demselben Namen auf den Server zur|fffd|ckgespeichert werden. M|fffd|gliche Gr|fffd|nde:" & vbLf & _
" - es wurde zwischenzeitlich autorisiert und darf nicht mehr ver|fffd|ndert werden" & vbLf & _
" - es wurde zwischenzeitlich schreibgesch|fffd|tzt" & vbLf & vbLf & _
"Ziehen Sie bitte ""Speicher Unter..."" mit einem anderen Namen in Erw|fffd|gung."
Public Const ark_Save_Writable_No_Dup       As String = "ark_Save_Writable_No_Dup"
Public Const asr_Save_Writable_No_Dup       As String = _
"Das Dokument kann nicht unter diesem Namen auf den Server zur|fffd|ckgespeichert werden. Es existiert bereits ein anderes Dokument mit diesem Namen" & vbLf & vbLf & _
"Ziehen Sie bitte ""Speicher Unter..."" mit einem anderen Namen in Erw|fffd|gung."
Public Const ark_Save_Writable_No           As String = "ark_Save_Writable_No"
Public Const asr_Save_Writable_No           As String = _
"Das Dokument kann nicht unter demselben Namen auf den Server zur|fffd|ckgespeichert werden. M|fffd|gliche Gr|fffd|nde:" & vbLf & _
" - es wurde zwischenzeitlich autorisiert und darf nicht mehr ver|fffd|ndert werden" & vbLf & _
" - es wurde zwischenzeitlich schreibgesch|fffd|tzt" & vbLf & vbLf & _
"Ziehen Sie bitte ""Speicher Unter..."" mit einem anderen Namen in Erw|fffd|gung."
Public Const ark_Save_Conflict_User         As String = "ark_Save_Conflict_User"
Public Const asr_Save_Conflict_User         As String = _
"Ein anderer Anwender hat dasselbe Dokument zwischenzeitlich ver|fffd|ndert. " & _
"Wenn Sie es |fffd|berschreiben wollen, dann klicken Sie ""Ja"". Andernfalls klicken Sie bitte ""Nein"" " & _
"und ziehen Sie ""Speicher Unter"" mit einem anderen Namen in Erw|fffd|gung." & vbLf & vbLf & "|fffd|berschreiben?"
Public Const ark_Save_Conflict_Time         As String = "ark_Save_Conflict_Time"
Public Const asr_Save_Conflict_Time         As String = _
"Der Zeitstempel des Dokuments auf dem Server hat sich ver|fffd|ndert. " & _
"Wenn Sie es |fffd|berschreiben wollen, dann klicken Sie ""Ja"". Andernfalls klicken Sie bitte ""Nein"" " & _
"und ziehen Sie ""Speicher Unter"" mit einem anderen Namen in Erw|fffd|gung." & vbLf & vbLf & "|fffd|berschreiben?"
Public Const ark_Save_SessionidInvalid      As String = "ark_Save_SessionidInvalid"
Public Const asr_Save_SessionidInvalid      As String = "Die Session-ID ist ung|fffd|ltig. Speichern wird nicht ausgef|fffd|hrt."
Public Const ark_Save_SessionidError        As String = "ark_Save_SessionidError"
Public Const asr_Save_SessionidError        As String = _
"Die Session-ID konnte nicht gepr|fffd|ft werden." & vbLf & _
"Evtl. besteht ein Problem bei der Verbindung zum Server." & vbLf & "Speichern wird nicht ausgef|fffd|hrt."
Public Const ark_Save_SessionidUnknownError As String = "ark_Save_SessionidUnknownError"
Public Const asr_Save_SessionidUnknownError As String = _
"Die Session-ID konnte nicht gepr|fffd|ft werden." & vbLf & "Speichern wird nicht ausgef|fffd|hrt."
Public Const ark_SaveAs_NoNameGiven         As String = "ark_SaveAs_NoNameGiven"
Public Const asr_SaveAs_NoNameGiven         As String = _
"Sie haben keinen Namen vergeben, " & vbLf & _
"""Speichern Unter"" wird daher nicht ausgef|fffd|hrt." & vbLf
Public Const ark_SaveAs_NoCommentGiven      As String = "ark_SaveAs_NoCommentGiven"
Public Const asr_SaveAs_NoCommentGiven      As String = _
"Sie haben keinen Kommentar vergeben, " & vbLf & _
"""Speichern als neue Version"" wird daher nicht ausgef|fffd|hrt." & vbLf
Public Const ark_SaveAs_NamePlease          As String = "ark_SaveAs_NamePlease"
Public Const asr_SaveAs_NamePlease          As String = _
"Bitte geben Sie einen Namen ein, unter dem dieses Dokument k|fffd|nftig in audimex erscheinen soll."
Public Const ark_SaveAs_commentPlease       As String = "ark_SaveAs_commentPlease"
Public Const asr_SaveAs_commentPlease       As String = "Bitte geben Sie einen Kommentar f|fffd|r die neue Version ein."
Public Const ark_SaveBeforeClose            As String = "ark_SaveBeforeClose"
Public Const asr_SaveBeforeClose            As String = _
"Sollen |fffd|nderungen auf dem audimex-Server gespeichert werden?" & vbLf & vbLf & _
"Ja = Speichern und Dokument Schlie|fffd|en" & vbLf & _
"Nein = |fffd|nderungen verwerfen und Dokument Schlie|fffd|en" & vbLf & _
"Abbrechen = Dokument ge|fffd|ffnet lassen"
Public Const ark_WritableError              As String = "ark_WritableError"
Public Const asr_WritableError              As String = "Error: This document cannot be written back."

' Siteminder
Public Const ark_Error_Siteminder_Login       As String = "ark_Error_Siteminder_Login"
Public Const asr_Error_Siteminder_Login       As String = "Fehler bei der Authentifizierung mit Siteminder"

' Log-File
Public Const ark_log_NoLogFile                As String = "ark_log_NoLogFile"
Public Const asr_log_NoLogFile                As String = _
"Derzeit ist kein Log-File ge|fffd|ffnet." & vbLf & vbLf & "Abhilfe: Word beenden und wieder starten."
Public Const ark_log_LogFileError             As String = "ark_log_LogFileError"
Public Const asr_log_LogFileError             As String = "Fehler beim Anzeigen der Log-Datei"
Public Const ark_log_Menu_Fehler              As String = "ark_log_Menu_Fehler"
Public Const asr_log_Menu_Fehler              As String = "Die Statusanzeige der Log-Datei im Men|fffd| audimex ist fehlerhaft. Folgender Status gilt:" & vbLf
Public Const ark_log_delete                   As String = "ark_log_delete"
Public Const asr_log_delete                   As String = "Die Log-Datei wird beim Beenden gel|fffd|scht."
Public Const ark_log_keep                     As String = "ark_log_keep"
Public Const asr_log_keep                     As String = "Die Log-Datei bleibt nach dem Beenden erhalten."

' Login-Dialog
Public Const ark_Login_Username_Label         As String = "ark_Login_Username_Label"
Public Const asr_Login_Username_Label         As String = "Username"
Public Const ark_Login_Username_Label_Tooltip As String = "ark_Login_Username_Label_Tooltip"
Public Const asr_Login_Username_Label_Tooltip As String = "Username"
Public Const ark_Login_Username_Input_Tooltip As String = "ark_Login_Username_Input_Tooltip"
Public Const asr_Login_Username_Input_Tooltip As String = "Username"
Public Const ark_Login_Password_Label         As String = "ark_Login_Password_Label"
Public Const asr_Login_Password_Label         As String = "Password"
Public Const ark_Login_Password_Label_Tooltip As String = "ark_Login_Password_Label_Tooltip"
Public Const asr_Login_Password_Label_Tooltip As String = "Password"
Public Const ark_Login_Password_Input_Tooltip As String = "ark_Login_Password_Input_Tooltip"
Public Const asr_Login_Password_Input_Tooltip As String = "Password"
Public Const ark_Login_Button_Ok_Caption      As String = "ark_Login_Button_Ok_Caption"
Public Const asr_Login_Button_Ok_Caption      As String = "Ok"
Public Const ark_Login_Button_Ok_Tooltip      As String = "ark_Login_Button_Ok_Tooltip"
Public Const asr_Login_Button_Ok_Tooltip      As String = "Ok"
Public Const ark_Login_Button_Cancel_Caption  As String = "ark_Login_Button_Cancel_Caption"
Public Const asr_Login_Button_Cancel_Caption  As String = "Cancel"
Public Const ark_Login_Button_Cancel_Tooltip  As String = "ark_Login_Button_Cancel_Tooltip"
Public Const asr_Login_Button_Cancel_Tooltip  As String = "Cancel"
Public Const ark_Login_Msg_Sessionid          As String = "ark_Login_Msg_Sessionid"
Public Const asr_Login_Msg_Sessionid          As String = "Session-ID wird angefordert."
Public Const ark_Login_Msg_SessionidInvalid   As String = "ark_Login_Msg_SessionidInvalid"
Public Const asr_Login_Msg_SessionidInvalid   As String = _
"Ihre Sitzung ist auf dem Server nicht mehr g|fffd|ltig. Bitte melden Sie sich erneut an oder verwerfen Sie Ihre |fffd|nderungen."
Public Const ark_Login_Msg_Failed             As String = "ark_Login_Msg_Failed"
Public Const asr_Login_Msg_Failed             As String = "Anmeldung fehlgeschlagen. Bitte wiederholen."

' About-Box
Public Const ark_About_Text1                  As String = "ark_About_Text1"
Public Const asr_About_Text1                  As String = "audimex Addin for MS Word" & vbLf & "Version 1.0.9"
Public Const ark_About_Text2                  As String = "ark_About_Text2"
Public Const asr_About_Text2                  As String = vbLf & "(c) 2018 audimex ag"

' String-Konstanten ohne Anzeige
Public Const cstr_ServerOkPattern As String = "OK[" & vbCr & vbLf & "]*"
Public Const cstr_ServerOkString As String = "OK" & vbLf
Public Const cstr_ServerNotOkPattern As String = "BAD[" & vbCr & vbLf & "]*"
Public Const cstr_InvalidSessionid As String = "0"


Public rm_default        As Collection
Public rm_i18n           As Collection

' Baue eine Liste von Paaren (key, value)
Private Function resource_data() As Variant
    Dim rd As Variant
    rd = Array()
    rd = push2(rd, Array(ark_ExtendedInputBox_Button_Ok_Caption, asr_ExtendedInputBox_Button_Ok_Caption))
    rd = push2(rd, Array(ark_ExtendedInputBox_Button_Ok_Tooltip, asr_ExtendedInputBox_Button_Ok_Tooltip))
    rd = push2(rd, Array(ark_ExtendedInputBox_Button_Cancel_Caption, asr_ExtendedInputBox_Button_Cancel_Caption))
    rd = push2(rd, Array(ark_ExtendedInputBox_Button_Cancel_Tooltip, asr_ExtendedInputBox_Button_Cancel_Tooltip))
    rd = push2(rd, Array(ark_ExtendedInputBox_Input_Text_Tooltip, asr_ExtendedInputBox_Input_Text_Tooltip))
    rd = push2(rd, Array(ark_AppTitle, asr_AppTitle))
    rd = push2(rd, Array(ark_MsgBoxTitle_Audimex, asr_MsgBoxTitle_Audimex))
    rd = push2(rd, Array(ark_Http_NoServer, asr_Http_NoServer))
    rd = push2(rd, Array(ark_DocMan_NotInitialized, asr_DocMan_NotInitialized))
    rd = push2(rd, Array(ark_DocMan_NoFreeSlot, asr_DocMan_NoFreeSlot))
    rd = push2(rd, Array(ark_DocMan_DocNotFound, asr_DocMan_DocNotFound))
    rd = push2(rd, Array(ark_Status_CheckSessionid, asr_Status_CheckSessionid))
    rd = push2(rd, Array(ark_Status_Resource, asr_Status_Resource))
    rd = push2(rd, Array(ark_Status_Upload, asr_Status_Upload))
    rd = push2(rd, Array(ark_Status_Speicherkonflikt, asr_Status_Speicherkonflikt))
    rd = push2(rd, Array(ark_Status_Schreibbar, asr_Status_Schreibbar))
    rd = push2(rd, Array(ark_Status_Extract, asr_Status_Extract))
    rd = push2(rd, Array(ark_Menu_Audimex, asr_Menu_Audimex))
    rd = push2(rd, Array(ark_Menu_Speichern, asr_Menu_Speichern))
    rd = push2(rd, Array(ark_Menu_SpeichernUnter, asr_Menu_SpeichernUnter))
    rd = push2(rd, Array(ark_Menu_SpeichernFragmente, asr_Menu_SpeichernFragmente))
    rd = push2(rd, Array(ark_Menu_SpeichernVersion, asr_Menu_SpeichernVersion))
    rd = push2(rd, Array(ark_Menu_Extrahieren, asr_Menu_Extrahieren))
    rd = push2(rd, Array(ark_Menu_Einstellungen, asr_Menu_Einstellungen))
    rd = push2(rd, Array(ark_Menu_Log_Filename, asr_Menu_Log_Filename))
    rd = push2(rd, Array(ark_Menu_Log_Toggle, asr_Menu_Log_Toggle))
    rd = push2(rd, Array(ark_Menu_Reserviert, asr_Menu_Reserviert))
    rd = push2(rd, Array(ark_Menu_About, asr_Menu_About))
    rd = push2(rd, Array(ark_Upload_NoAttrib, asr_Upload_NoAttrib))
    rd = push2(rd, Array(ark_Upload_Failed, asr_Upload_Failed))
    rd = push2(rd, Array(ark_Upload_Succeeded, asr_Upload_Succeeded))
    rd = push2(rd, Array(ark_Upload_Warning, asr_Upload_Warning))
    rd = push2(rd, Array(ark_Save_Writable_No_Perm, asr_Save_Writable_No_Perm))
    rd = push2(rd, Array(ark_Save_Writable_No_Dup, asr_Save_Writable_No_Dup))
    rd = push2(rd, Array(ark_Save_Writable_No, asr_Save_Writable_No))
    rd = push2(rd, Array(ark_Save_Conflict_User, asr_Save_Conflict_User))
    rd = push2(rd, Array(ark_Save_Conflict_Time, asr_Save_Conflict_Time))
    rd = push2(rd, Array(ark_Save_SessionidInvalid, asr_Save_SessionidInvalid))
    rd = push2(rd, Array(ark_Save_SessionidError, asr_Save_SessionidError))
    rd = push2(rd, Array(ark_Save_SessionidUnknownError, asr_Save_SessionidUnknownError))
    rd = push2(rd, Array(ark_SaveAs_NoNameGiven, asr_SaveAs_NoNameGiven))
    rd = push2(rd, Array(ark_SaveAs_NoCommentGiven, asr_SaveAs_NoCommentGiven))
    rd = push2(rd, Array(ark_SaveAs_NamePlease, asr_SaveAs_NamePlease))
    rd = push2(rd, Array(ark_SaveAs_commentPlease, asr_SaveAs_commentPlease))
    rd = push2(rd, Array(ark_SaveBeforeClose, asr_SaveBeforeClose))
    rd = push2(rd, Array(ark_log_NoLogFile, asr_log_NoLogFile))
    rd = push2(rd, Array(ark_log_LogFileError, asr_log_LogFileError))
    rd = push2(rd, Array(ark_log_Menu_Fehler, asr_log_Menu_Fehler))
    rd = push2(rd, Array(ark_log_delete, asr_log_delete))
    rd = push2(rd, Array(ark_log_keep, asr_log_keep))
    rd = push2(rd, Array(ark_Login_Username_Label, asr_Login_Username_Label))
    rd = push2(rd, Array(ark_Login_Username_Label_Tooltip, asr_Login_Username_Label_Tooltip))
    rd = push2(rd, Array(ark_Login_Username_Input_Tooltip, asr_Login_Username_Input_Tooltip))
    rd = push2(rd, Array(ark_Login_Password_Label, asr_Login_Password_Label))
    rd = push2(rd, Array(ark_Login_Password_Label_Tooltip, asr_Login_Password_Label_Tooltip))
    rd = push2(rd, Array(ark_Login_Password_Input_Tooltip, asr_Login_Password_Input_Tooltip))
    rd = push2(rd, Array(ark_Login_Button_Ok_Caption, asr_Login_Button_Ok_Caption))
    rd = push2(rd, Array(ark_Login_Button_Ok_Tooltip, asr_Login_Button_Ok_Tooltip))
    rd = push2(rd, Array(ark_Login_Button_Cancel_Caption, asr_Login_Button_Cancel_Caption))
    rd = push2(rd, Array(ark_Login_Button_Cancel_Tooltip, asr_Login_Button_Cancel_Tooltip))
    rd = push2(rd, Array(ark_Login_Msg_Sessionid, asr_Login_Msg_Sessionid))
    rd = push2(rd, Array(ark_Login_Msg_SessionidInvalid, asr_Login_Msg_SessionidInvalid))
    rd = push2(rd, Array(ark_Login_Msg_Failed, asr_Login_Msg_Failed))
    rd = push2(rd, Array(ark_Extract_Error_Cell, asr_Extract_Error_Cell))
    rd = push2(rd, Array(ark_Extract_Error_Datatype_Date, asr_Extract_Error_Datatype_Date))
    rd = push2(rd, Array(ark_Extract_Error_Datatype_Double, asr_Extract_Error_Datatype_Double))
    rd = push2(rd, Array(ark_Extract_Error_Datatype_Long, asr_Extract_Error_Datatype_Long))
    rd = push2(rd, Array(ark_Extract_Error_Number_Tables, asr_Extract_Error_Number_Tables))
    rd = push2(rd, Array(ark_Extract_Error_Save_Anyway, asr_Extract_Error_Save_Anyway))
    rd = push2(rd, Array(ark_About_Text1, asr_About_Text1))
    rd = push2(rd, Array(ark_About_Text2, asr_About_Text2))
    rd = push2(rd, Array(ark_Error_Siteminder_Login, asr_Error_Siteminder_Login))
    rd = push2(rd, Array(ark_ExtendedSaveBox_Button_Yes_Caption, asr_ExtendedSaveBox_Button_Yes_Caption))
    rd = push2(rd, Array(ark_ExtendedSaveBox_Button_No_Caption, asr_ExtendedSaveBox_Button_No_Caption))
    rd = push2(rd, Array(ark_ExtendedSaveBox_Button_Cancel_Caption, asr_ExtendedSaveBox_Button_Cancel_Caption))
    rd = push2(rd, Array(ark_ExtendedSaveBox_Button_Checked_Caption, asr_ExtendedSaveBox_Button_Checked_Caption))
    rd = push2(rd, Array(ark_ExtendedSaveBox_Question, asr_ExtendedSaveBox_Question))
    rd = push2(rd, Array(ark_ExtendedSaveBox_Title, asr_ExtendedSaveBox_Title))
    rd = push2(rd, Array(ark_WritableError, asr_WritableError))
    
    resource_data = rd ' free beim aufrufer
End Function

Public Sub sk_final(ByRef rm As Collection)
    Log_Enter "rm_final()"
    Set rm = Nothing
    Log_Leave "rm_final()"
End Sub

Private Sub initResourceManager(ByRef rm As Collection)
    Log_Enter "initResourceManager()"
    Call m_loadResourceManager(Nothing, rm, False)
    Log_Leave "initResourceManager()"
End Sub

Public Sub sk_PingServerConnection(ds As DocuSlot)
    Log_Enter "PingServerConnection()"
    Call showStatus(asr(ark_Status_Ping))
    Call cursorWait
    ServerPing ds
    Call cursorNormal
    Call clearStatus
    Log_Leave "PingServerConnection()"
End Sub

Public Sub sk_loadResourceManager(ds As DocuSlot, ByRef rm As Collection)
    Log_Enter "loadResourceManager()"
    Call showStatus(asr(ark_Status_Resource))
    Call cursorWait
    Call m_loadResourceManager(ds, rm, True)
    Call cursorNormal
    Call clearStatus
    Log_Leave "loadResourceManager()"
End Sub

Private Sub Test_m_buildKeyListOrCollection()
    Dim my_keys As String, my_values As String
    Dim my_tuples As Variant
    my_tuples = Array( _
    Array("key1", "value1"), _
    Array("key2", "value2"))
    Call m_buildKeyListValueList(my_keys, my_values, my_tuples)
    MsgBox my_keys
    MsgBox my_values
End Sub

' Baue aus den Resource-Tuples entweder eine Collection key->value oder eine Liste der keys fuer die Server-Anfrage
Private Sub m_buildKeyListValueList(ByRef keylist As String, ByRef valuelist As String, tuples As Variant)
    Dim key As String, value As String
    Dim tuple As Variant
    Dim keylistseparator As String
    Dim valuelistseparator As String
    Dim i As Long
    i = 0
    keylist = ""
    valuelist = ""
    keylistseparator = ""
    valuelistseparator = ""
    On Error Resume Next
    For Each tuple In tuples
        key = CStr(tuple(0))
        value = UrlEncode(CStr(tuple(1)))
        If (Err.Number > 0) Then
            Log_Error "resource data error (tuple " & i & ")"
            Err.Clear
        Else
            keylist = keylist & keylistseparator & key
            valuelist = valuelist & valuelistseparator & value
            keylistseparator = vbLf
            valuelistseparator = "%0B"
        End If
        i = i + 1
    Next
End Sub

Private Sub Test_m_buildResourceTable()
    Dim my_keys As String
    Dim my_values As String
    Dim my_rm As Collection
    ' Gut-Fall
    my_keys = "key1" & vbLf & "key2"
    my_values = "value1" & vbLf & "value2"
    Set my_rm = New Collection ' free lokal
    Call m_buildResourceTable(my_rm, my_keys, my_values)
    MsgBox my_rm.Count & vbLf & "key1 => " & my_rm.Item("key1") & vbLf & "key2 => " & my_rm.Item("key2")
    Set my_rm = Nothing
    ' B|fffd|se-Fall 1: mehr Schluessel
    my_keys = "key1" & vbLf & "key2" & vbLf & "key3"
    my_values = "value1" & vbLf & "value2"
    Set my_rm = New Collection ' free lokal
    Call m_buildResourceTable(my_rm, my_keys, my_values)
    MsgBox my_rm.Count & vbLf & "key1 => " & my_rm.Item("key1") & vbLf & "key2 => " & my_rm.Item("key2")
    Set my_rm = Nothing
    ' B|fffd|se-Fall 2: mehr Werte
    my_keys = "key1" & vbLf & "key2"
    my_values = "value1" & vbLf & "value2" & vbLf & "value3"
    Set my_rm = New Collection ' free lokal
    Call m_buildResourceTable(my_rm, my_keys, my_values)
    MsgBox my_rm.Count & vbLf & "key1 => " & my_rm.Item("key1") & vbLf & "key2 => " & my_rm.Item("key2")
    Set my_rm = Nothing
End Sub

' Baue aus der Server-Antwort und den Resource-Tuples eine Collection key->value
Private Sub m_buildResourceTable(rm As Collection, keylist As String, valuelist As String)
    Dim dummy As String, mystr As String, mykey As String
    On Error Resume Next
    While (keylist <> "")
        mykey = getNextItem(keylist, vbLf)
        ' remove, if already exists
        dummy = rm.Item(mykey)
        If (Err.Number = 0) Then
            Log_Warn "duplicate key (" & mykey & ")"
            rm.Remove mykey
        Else
            Err.Clear
        End If
        If (valuelist = "") Then
            Log_Warn "more keys than values (next key = >" & mykey & "<)"
            Exit Sub
        End If
        ' add
        mystr = getNextItem(valuelist, "%0B")
        Dim bytehaufen() As Byte
        bytehaufen = StrConv(mystr, vbFromUnicode, 1033) ' Englisch (USA)
        mystr = ConvertFromUTF8(bytehaufen)
        
        rm.Add Item:=UrlDecode(mystr), key:=mykey
    Wend
    If (valuelist <> "") Then
        Log_Warn "more values than keys (next value = >" & getNextItem(valuelist, vbLf) & "<)"
    End If
End Sub

' Hole String-Ressourcen entweder vom Server oder aus Konstanten
Private Sub m_loadResourceManager(ds As DocuSlot, ByRef rm As Collection, load As Boolean)
    Dim tuples As Variant
    Dim keylist As String, valuelist As String, servervaluelist As String
    Log_Enter "m_loadResourceManager(load = " & load & ")"
    tuples = resource_data() ' free lokal
    ' build list of keys / default values
    Call m_buildKeyListValueList(keylist, valuelist, tuples)
    Erase tuples
    ' replace default values with actual values from server
    If (load) Then
        Log_Info "retrieving list of values"
        servervaluelist = Request_StringResource(ds, keylist)
        If (servervaluelist Like cstr_ServerOkPattern) Then
            Log_Info "Server's answer matches ok pattern /" & guiEncode(cstr_ServerOkPattern) & "/"
            Log_Info "using server values"
            valuelist = Mid(servervaluelist, Len(cstr_ServerOkString) + 1) ' "OK<lf>" abschneiden
        ElseIf (servervaluelist Like cstr_ServerNotOkPattern) Then
            Log_Error "Server's answer matches not-ok pattern /" & guiEncode(cstr_ServerNotOkPattern) & "/"
            Log_Info "keeping default values"
        Else
            Log_Error "unrecognized reply (" & guiEncode(servervaluelist) & ")"
            Log_Info "keeping default values"
        End If
    End If
    ' build resource table from retrieved strings / default values
    Log_Info "building resource table"
    Set rm = New Collection ' free in rm_final / WdApp_Quit
    Call m_buildResourceTable(rm, keylist, valuelist)
    Log_Leave "m_loadResourceManager()"
End Sub

Public Function asr(key As String) As String
    Dim found As Boolean
    ' konstante Strings initialisieren, falls noch nicht geschehen
    If (rm_default Is Nothing) Then
        Call initResourceManager(rm_default)
    End If
    ' rm_i18n wird in refreshDokuSlots geladen, falls ein audimex-Dokument
    ' und damit Information |fffd|ber den Server zur Verf|fffd|gung steht
    ' Zuerst aus dynamisch geladenen Strings lesen
    On Error Resume Next
    asr = rm_i18n.Item(key)
    found = (Err.Number = 0)
    ' Falls erfolglos, aus konstanten Strings lesen
    If (Not found) Then
        Err.Clear
        asr = rm_default.Item(key)
        found = (Err.Number = 0)
    End If
    ' Falls weder dynamische noch konstanter String existiert, Schluesselnamen verwenden
    If (Not found) Then
        Err.Clear
        Log_Error "no display text for key '" & key & "'"
        asr = key
    End If
    If (developer_mode) Then
        asr = dot_type_flag & " " & asr
    End If
    On Error GoTo 0
End Function

Private Sub test_make_dump()
    Dim tuples As Variant, tuple As Variant
    Dim key As String, value As String
    Dim stamp As Double, i As Long
    stamp = CDbl(Date + Time - DateSerial(1970, 1, 1)) * 86400
    tuples = resource_data()
    For Each tuple In tuples
        key = CStr(tuple(0))
        value = CStr(tuple(1))
        value = replace(value, Chr(10), Chr(13) & Chr(10))
        If (Err.Number > 0) Then
            MsgBox "resource data error (tuple " & i & ")"
            Stop
        Else
            Debug.Print """de"";""application"";""text"";""*"";""*"";""" & key & """;""" & value & """;""" & stamp & """;""19"";"
        End If
        i = i + 1
    Next
End Sub

Attribute VB_Name = "StringUtilities"
Option Explicit

Public Property Get Version() As String
    Version = "$Revision: 1.7 $"
End Property

Public Function guiEncode(x As String) As String
    Dim y As String, z As String
    Dim i As Long
    y = ""
    For i = 1 To Len(x)
        z = Mid(x, i, 1)
        If ((Asc(z) > 32) And (Asc(z) < 128)) Then
            y = y + z
        Else
            y = y + "<" + Right("00" + Hex(Asc(z)), 2) + ">"
        End If
    Next
    guiEncode = y
End Function

Public Function UrlEncode(x As String) As String
    Dim y As String, z As String
    Dim i As Long
    y = ""
    For i = 1 To Len(x)
        z = Mid(x, i, 1)
        If (z Like "[-a-zA-Z0-9_]") Then
            y = y + z
        ElseIf (z = " ") Then
            y = y + "+"
        Else
            y = y + "%" + Right("00" + Hex(Asc(z)), 2)
        End If
    Next
    UrlEncode = y
End Function

Public Function UrlDecode(ByVal x As String) As String
    Dim y As String, z As String, C As String
    y = ""
    While (x <> "")
        z = Left(x, 1)
        x = Mid(x, 2)
        Select Case z
        Case "+"
            y = y + " "
        Case "%"
            y = y + Chr(Val("&h" + Left(x, 2)))
            x = Mid(x, 3)
        Case Else
            y = y + z
        End Select
    Wend
    UrlDecode = y
End Function

Sub hexDump(s As String)
    Const linelen As Long = 16
    Dim adr As Long
    Dim line As String
    Dim i As Long
    Dim ac As Long
    Dim ch As String
    On Error Resume Next
    adr = 0
    Do
        If (adr > Len(s)) Then Exit Do
        line = Mid(s, adr + 1)
        line = Mid(s, adr + 1, adr + linelen + 1)
        Debug.Print Right("0000" & Hex(adr), 4) & " - ";
        For i = 0 To linelen - 1
            If (adr + i + 1) > Len(s) Then
                Debug.Print "   ";
            Else
                ch = Mid(s, adr + i + 1, 1)
                ch = IIf(ch = "", Chr(32), ch)
                ac = Asc(ch)
                Debug.Print Right("00" & Hex(ac), 2) & " ";
            End If
        Next
        For i = 0 To linelen - 1
            ch = Mid(s, adr + i + 1, 1)
            ch = IIf(ch = "", Chr(32), ch)
            ac = Asc(ch)
            Debug.Print IIf(ac < 32, ".", ch);
        Next
        Debug.Print
        adr = adr + linelen
    Loop
End Sub

Function textBetween(fld As String, pos1 As Long, pos2 As Long, default As String) As String
    Dim s As String
    s = Mid(fld, pos1 + 1, pos2 - pos1 - 1)
    textBetween = IIf(s = "", default, s)
End Function

Public Sub replaceText(ByRef Text As String, find As String, replace As String)
    Dim pos As Long
    Dim start As Long
    start = 1
    Do
        pos = InStr(start, Text, find)
        If (pos = 0) Then Exit Do
        Text = Left(Text, pos - 1) + replace + Mid(Text, pos + Len(find))
        start = pos + Len(replace)
    Loop
End Sub
Public Function replaceTextCopy(ByVal Text As String, find As String, replace As String) As String
    Dim newText As String
    newText = Text
    Call replaceText(newText, find, replace)
    replaceTextCopy = newText
End Function

'liefere den String vom Anfang von s bis zum ersten ';'.
'Schneide von s den ersten Teil bis einschliesslich ';' ab.
'Wenn kein ';' in s vorkommt, liefere ""
Function getNextItem(ByRef s As String, Optional trenner As String = ";") As String
    Dim idxSem As Long
    Dim s1 As String
    idxSem = InStr(s, trenner)
    If (idxSem > 0) Then
        If (idxSem = 1) Then
            getNextItem = ""
        Else
            getNextItem = Left(s, idxSem - 1)
        End If
        s = Mid(s, idxSem + Len(trenner))
    Else
        getNextItem = s
        s = ""
    End If
End Function

Function getItemN(s As String, n As Long, Optional trenner As String = ";") As String
    Dim ss As String
    Dim i As Long, j As Long, k As Long
    getItemN = ""
    If n <= 0 Then Exit Function ' Index beginnt bei 1
    i = 0
    k = 1 - Len(trenner) ' k zeigt auf den letzten gefundenen Trenner oder 0, falls es keinen mehr gibt
    Do
        j = k + Len(trenner)    ' N|fffd|chster Feldanfang ist letzter Trenner + L|fffd|nge des Trenners
        k = InStr(j, s, trenner)               ' N|fffd|chster Trenner ab neuem Feldanfang
        i = i + 1                              ' Feldnr. mitz|fffd|hlen
    Loop Until (i >= n) Or (k = 0)           ' Abbruch, falls Feld N oder letztes Feld
    If (i < n) Then Exit Function ' weniger als N Felder im String: "" zur|fffd|ckgeben
    If (k = 0) Then
        getItemN = Mid(s, j)        ' k = 0: Feld N ist letztes Feld
    Else
        getItemN = Mid(s, j, k - j)   ' k > 0: Feld N liegt zwischen j und (k - 1)
    End If
End Function

Public Function FolderExists(ByVal PathName As String) As Boolean
    Dim lngAttr As Long
    On Error GoTo NoFolder
    lngAttr = GetAttr(PathName)
    If (lngAttr And vbDirectory) = vbDirectory Then
        FolderExists = True
    End If
NoFolder:
End Function

Public Function CreateFolders(strPath As String)
    Dim strTempPath As String
    Dim lngPath As Long
    Dim vPath As Variant
    vPath = Split(strPath, "\")
    strPath = vPath(0) & "\"
    For lngPath = 1 To UBound(vPath)
        strPath = strPath & vPath(lngPath) & "\"
        If Not FolderExists(strPath) Then MkDir strPath
    Next lngPath
End Function

Function FileExists(strFile As String) As Boolean
    FileExists = Not Dir(strFile) = ""
End Function

Public Function LoadTextFile(sFile As String) As String
    Dim iFile As Integer
    On Local Error Resume Next
    iFile = FreeFile
    Open sFile For Input As #iFile
    LoadTextFile = Input$(LOF(iFile), iFile)
    Close #iFile
End Function

Public Function WriteTextFile(sFile As String, content As String) As String
    Dim iFile As Integer
    On Local Error Resume Next
    iFile = FreeFile
    Open sFile For Output As #iFile
    Print #iFile, content;
    Close #iFile
End Function

Public Function EncryptString(strSource As String, strPassword As String) As String
    Dim strTarget As String
    Dim cls As New clsEncrypt
    cls.Password = strPassword
    cls.InBuffer = strSource
    cls.Encrypt
    strTarget = cls.OutBuffer
    Set cls = Nothing
    EncryptString = strTarget
End Function

Public Function DecryptString(strSource As String, strPassword As String) As String
    Dim strTarget As String
    Dim cls As New clsEncrypt
    cls.Password = strPassword
    cls.InBuffer = strSource
    cls.Decrypt
    strTarget = cls.OutBuffer
    Set cls = Nothing
    DecryptString = strTarget
End Function


''' Returns hex-encoded string from array of bytes (with spaces)
''' E.g. aBytes(&HFE, &HDC, &H80) will return "FE DC 80"
Public Function bv_HexFromBytesSp(aBytes() As Byte) As String
    Dim i As Long

    If Not IsArray(aBytes) Then
        Exit Function
    End If
    
    For i = LBound(aBytes) To UBound(aBytes)
        If (i > 0) Then bv_HexFromBytesSp = bv_HexFromBytesSp & " "
        If aBytes(i) < 16 Then
            bv_HexFromBytesSp = bv_HexFromBytesSp & "0" & Hex(aBytes(i))
        Else
            bv_HexFromBytesSp = bv_HexFromBytesSp & Hex(aBytes(i))
        End If
    Next
    
End Function
Attribute VB_Name = "TempFileUtils"
Option Explicit

#If VBA7 Or Win64 Then
Public Declare PtrSafe Function GetTempFileName Lib "kernel32.dll" Alias "GetTempFileNameA" ( _
ByVal sPathName As String, ByVal sPrefixString As String, ByVal iUnique As Integer, _
ByVal sTempFileName As String) As Long
#Else
Public Declare Function GetTempFileName Lib "kernel32.dll" Alias "GetTempFileNameA" ( _
ByVal sPathName As String, ByVal sPrefixString As String, ByVal iUnique As Integer, _
ByVal sTempFileName As String) As Long
#End If

#If VBA7 Or Win64 Then
Public Declare PtrSafe Function GetTempPath Lib "kernel32.dll" Alias "GetTempPathA" ( _
ByVal nBufferLength As Long, ByVal sBuffer As String) As Long
#Else
Public Declare Function GetTempPath Lib "kernel32.dll" Alias "GetTempPathA" ( _
ByVal nBufferLength As Long, ByVal sBuffer As String) As Long
#End If

#If VBA7 Or Win64 Then
Public Declare PtrSafe Function DeleteFile Lib "kernel32.dll" Alias "DeleteFileA" ( _
ByVal lpFileName As String) As Long
#Else
Public Declare Function DeleteFile Lib "kernel32.dll" Alias "DeleteFileA" ( _
ByVal lpFileName As String) As Long
#End If

Public Property Get Version() As String
    Version = "$Revision: 1.4 $"
End Property

Function MakeTempFileName() As String
    Dim sPathName As String
    Dim sPrefixString As String
    Dim iUnique As Integer
    Dim sTempFileName As String * 256
    Dim iRet As Long
    Dim sBuffer As String * 256
    ' Determine TempPath
    sPathName = Left$(sBuffer, GetTempPath(255, sBuffer))
    ' Determine TempFileName
    sPrefixString = "adx"
    iUnique = 0
    iRet = GetTempFileName(sPathName, sPrefixString, iUnique, sTempFileName)
    On Error Resume Next
    Kill sTempFileName
    On Error GoTo 0
    MakeTempFileName = Mid$(sTempFileName, 1, InStr(sTempFileName, Chr$(0)) - 1)
End Function

Function GetFile(FileName As String) As String
    Dim FileContents() As Byte, FileNumber As Integer
    ReDim FileContents(FileLen(FileName) - 1)
    FileNumber = FreeFile
    Open FileName For Binary As FileNumber
    Get FileNumber, , FileContents
    Close FileNumber
    GetFile = StrConv(FileContents, vbUnicode)
End Function

Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Timer"
Option Explicit

' Ping Timer (to keep Siteminder session open)
Dim TimerActive As Boolean
Dim TimerInterval As Long
Dim TimerDoc As Document

Public Sub StartTimer(intervalSec As Long, doc As Document)
    TimerInterval = intervalSec
    Set TimerDoc = doc
    Start_Timer
End Sub

Private Sub TestTimer()
    TimerInterval = 5
    Set TimerDoc = ActiveDocument
    Start_Timer
End Sub

Private Sub Start_Timer()
    TimerActive = True
    Dim startTime As Date
    Dim nextTimerRun As Date
    startTime = Now
    nextTimerRun = DateAdd("s", TimerInterval, startTime)
    Application.OnTime nextTimerRun, "PingTimer"
End Sub

Private Sub Stop_Timer()
    TimerActive = False
    TimerInterval = 0
    Set TimerDoc = Nothing
End Sub

Function TimerIsRunning() As Boolean
    TimerIsRunning = TimerActive
End Function


Public Sub PingTimer()
    If TimerActive Then
        Dim docIndex As Long
        docIndex = GetDocumentIndexByDocument(TimerDoc)
        If (docIndex < 0) Then
            docIndex = GetNextAudimexDocIndex
            If docIndex >= 0 Then
                Set TimerDoc = Dok(docIndex).doc_object
            End If
            If (docIndex < 0 Or TimerDoc Is Nothing) Then
                ' no audimex doc found
                Stop_Timer
                Exit Sub
            End If
        End If
        
        Dim ds As DocuSlot
        Set ds = Dok(docIndex)
        ServerPing ds
        
        Log_Trace "Pingtimer " & ds.docName
        Dim startTime As Date
        Dim nextTimerRun As Date
        startTime = Now
        nextTimerRun = DateAdd("s", TimerInterval, startTime)
        Application.OnTime nextTimerRun, "PingTimer"
    End If
End Sub

' reconnect audimex server
Public Sub ServerPing(ds As DocuSlot)
    Dim response As String
    response = Request_Ping(ds)
    If Not (response Like cstr_ServerOkPattern) Then
        Log_Trace "ServerPing Failed: " & vbCrLf & response & vbCrLf & "====="
        Exit Sub
    End If
    Log_Trace "ServerPing Response: " & response
    Dim nextLine As String
    nextLine = getItemN(response, 2, vbLf)
    If (InStr(1, nextLine, "PINGTIME ") = 1) Then
        Dim sInterval As String
        sInterval = Mid(nextLine, 10)
        Dim intervalSec As Long
        intervalSec = CLng(sInterval)
        Dim doc As Document
        Set doc = ds.doc_object
        If (intervalSec > 0 And Not doc Is Nothing) Then
            ds.ping_interval = intervalSec
            If Not TimerActive Then
                StartTimer intervalSec, doc
            End If
        End If
    End If
End Sub



Attribute VB_Name = "Transfer"
Option Explicit

Public asked_before As Boolean
Const resp_len As Long = 50
Const Boundary As String = "913114112"
Function Generate_Tid() As String
    Generate_Tid = CStr((Now() - 25569) * 86400)
End Function

Function Request_Ping(ds As DocuSlot) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_Ping()"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "SERVER_PING")
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_username", ds.username)
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_Ping = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_Ping() [" & guiEncode(Left(Request_Ping, resp_len)) & "...]"
End Function

Function Request_StringResource(ds As DocuSlot, wordList As String) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_StringResource(" & guiEncode(Left(wordList, resp_len)) & "...)"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "STRING_RESOURCE")
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_word_list", wordList)
    strData = strData + GeneratePostParam(Boundary, "p_username", ds.username)
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_StringResource = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_StringResource() [" & guiEncode(Left(Request_StringResource, resp_len)) & "...]"
End Function

Function Request_Writable(ds As DocuSlot, operation As String, Optional save_as_filename As String = "") As String
    Dim strHeader As String
    Dim strData As String
    Dim isSchnipselMode As Boolean
    isSchnipselMode = (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_SCHNIPSEL)
    Log_Enter "Request_Writable()"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "WRITABLE")
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_server", ds.server)
    strData = strData + GeneratePostParam(Boundary, "p_url", ds.url)
    strData = strData + GeneratePostParam(Boundary, "p_doc_name", ds.docName)
    strData = strData + GeneratePostParam(Boundary, "p_obj_id", ds.obj_id)
    strData = strData + GeneratePostParam(Boundary, "p_doc_id", ds.doc_id)
    strData = strData + GeneratePostParam(Boundary, "p_doc_type_id", ds.doc_type_id)
    strData = strData + GeneratePostParam(Boundary, "p_doc_state", ds.doc_status)
    strData = strData + GeneratePostParam(Boundary, "p_tx_time", ds.tx_time)
    strData = strData + GeneratePostParam(Boundary, "p_tx_user", ds.tx_user)
    strData = strData + GeneratePostParam(Boundary, "p_port", ds.port)
    strData = strData + GeneratePostParam(Boundary, "p_protocol", ds.protocol)
    strData = strData + GeneratePostParam(Boundary, "p_read_only", ds.read_only)
    strData = strData + GeneratePostParam(Boundary, "p_customize", ds.customize)
    strData = strData + GeneratePostParam(Boundary, "p_username", ds.username)
    strData = strData + GeneratePostParam(Boundary, "p_can_extract", ds.can_extract)
    strData = strData + GeneratePostParam(Boundary, "p_operation", operation)
    strData = strData + GeneratePostParam(Boundary, "p_save_as_filename", save_as_filename)
    If (isSchnipselMode) Then
        strData = strData + GeneratePostParam(Boundary, "p_tab_col_id", ds.tab_col_id)
    End If
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_Writable = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_Writable() [" & guiEncode(Left(Request_Writable, resp_len)) & "...]"
End Function

Function Request_DocumentDescription(ds As DocuSlot) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_DocumentDescription()"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "DESCRIPTION")
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_obj_id", ds.obj_id)
    strData = strData + GeneratePostParam(Boundary, "p_username", ds.username)
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_DocumentDescription = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_DocumentDescription() [" & guiEncode(Left(Request_DocumentDescription, resp_len)) & "...]"
End Function

Function Request_Data(ds As DocuSlot, desc As String, data As String, operation As String) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_Data(" & Left(desc, 15) & "..., " & Left(data, 15) & "...)"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "EXTRACT")
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_obj_id", ds.obj_id)
    strData = strData + GeneratePostParam(Boundary, "p_ext_desc", desc)
    strData = strData + GeneratePostParam(Boundary, "p_ext_data", data)
    strData = strData + GeneratePostParam(Boundary, "p_mode", "do")
    strData = strData + GeneratePostParam(Boundary, "p_operation", operation)
    strData = strData + GeneratePostParam(Boundary, "p_username", ds.username)
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_Data = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_Data() [" & guiEncode(Left(Request_Data, resp_len)) & "...]"
End Function

Function Request_SQL(ds As DocuSlot, strSQL As String) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_SQL(" & strSQL & ")"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "INSERT")
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_sql", strSQL)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_SQL = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_SQL() [" & guiEncode(Left(Request_SQL, resp_len)) & "...]"
End Function

Function Request_Upload(ds As DocuSlot, strFileName As String, _
    Optional strSaveAsFilename As String = cstr_Tag_save, Optional strComment As String = cstr_Tag_save_empty_comment) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_Upload(Filename=" & strFileName & ", SaveAsFilename=" & strSaveAsFilename & ")"
    Dim functionCode As String
    functionCode = "UPLOAD"
    Dim isSchnipselMode As Boolean
    isSchnipselMode = (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_SCHNIPSEL)
    Dim isExtractSchnipselMode As Boolean
    If (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_EXTRACTSCHNIPSEL) Then
        isExtractSchnipselMode = True
    Else
        isExtractSchnipselMode = False
    End If
    If (isSchnipselMode) Then
        functionCode = "SCHNITZEL"
    ElseIf (isExtractSchnipselMode) Then
        functionCode = "EXTRACTSCHNITZEL"
    End If
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", functionCode)
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_obj_id", ds.obj_id)
    strData = strData + GeneratePostParam(Boundary, "p_doc_id", ds.doc_id)
    strData = strData + GeneratePostParam(Boundary, "p_doc_type_id", ds.doc_type_id)
    strData = strData + GeneratePostParam(Boundary, "p_save_as", strSaveAsFilename)
    strData = strData + GeneratePostParam(Boundary, "p_version_comment", strComment)
    strData = strData + GeneratePostParam(Boundary, "p_username", ds.username)
    strData = strData + GeneratePostParam(Boundary, "p_old_name", UrlEncode(ds.docName))
    If (isSchnipselMode) Then
        strData = strData + GeneratePostParam(Boundary, "p_tab_col_id", ds.tab_col_id)
    End If
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    Log_Info "Payload: " + strData
    strData = strData + GeneratePostParamFilePart(Boundary, "uploadfield", strFileName)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_Upload = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_Upload() [" & guiEncode(Left(Request_Upload, resp_len)) & "...]"
End Function

' Ret: "OK" - Session-ID g|fffd|ltig, sonst - Session-ID ung|fffd|ltig, Anmeldung erforderlich
Function Request_VerifySessionId(ds As DocuSlot) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_VerifySessionId()"
    ' Header
    strHeader = GenerateMultiPartHeader(Boundary)
    ' Payload
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "SESSION")
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_VerifySessionId = doReq(ds.server, "POST", ds.url, strHeader, strData, "OK", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_VerifySessionId() [" & guiEncode(Left(Request_VerifySessionId, resp_len)) & "...]"
End Function

' Ret: "0" - Falsche Kombination von User und Passwort, sonst - neue Session-ID
Function Request_SessionId(ds As DocuSlot, User As String, Pass As String) As String
    Dim strHeader As String
    Dim strData As String
    Log_Enter "Request_SessionId()"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "LOGIN")
    strData = strData + GeneratePostParam(Boundary, "p_user_id", UrlEncode(User))
    strData = strData + GeneratePostParam(Boundary, "p_passwd", UrlEncode(Pass))
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_SessionId = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_SessionId() [" & guiEncode(Left(Request_SessionId, resp_len)) & "...]"
End Function

Function Request_Timeinfo(ds As DocuSlot) As String
    Dim strHeader As String
    Dim strData As String
    Dim isSchnipselMode As Boolean
    isSchnipselMode = (ds.doc_mode = ParamUtilities.AUDIMEX_DOC_MODE_SCHNIPSEL)
    Log_Enter "Request_Timeinfo()"
    strHeader = GenerateMultiPartHeader(Boundary)
    strData = ""
    strData = strData + GeneratePostParam(Boundary, "function_code", "ATTRIB")
    If (isSchnipselMode) Then
        strData = strData + GeneratePostParam(Boundary, "p_tab_col_id", ds.tab_col_id)
    End If
    strData = strData + GeneratePostParam(Boundary, "p_doc_id", ds.doc_id)
    strData = strData + GeneratePostParam(Boundary, "id", ds.id)
    strData = strData + GeneratePostParam(Boundary, "tid", Generate_Tid())
    strData = strData + GeneratePostParam(Boundary, "p_username", ds.username)
    strData = strData + GeneratePostParamFromUrl(Boundary, ds.url)
    strData = strData + GeneratePostParamEndMultipart(Boundary)
    Request_Timeinfo = doReq(ds.server, "POST", ds.url, strHeader, strData, "", ds.port, ds.protocol, ds.is_siteminder, ds.is_mellon)
    Log_Leave "Request_Timeinfo() [" & guiEncode(Left(Request_Timeinfo, resp_len)) & "...]"
End Function

Function doReq(server As String, method As String, url As String, header As String, data As String, default As String, port As String, protocol As String, is_siteminder As Boolean, is_mellon As Boolean) As String
    doReq = default
    If Not CheckServerURL(server, url) Then Exit Function
    doReq = HTTP_REQ(server, method, url, header, data, port, protocol, is_siteminder, is_mellon)
    ' remove multi-char newlines and cr
    Call replaceText(doReq, vbCrLf, vbLf)      ' Step1: normal CrLf
    Call replaceText(doReq, vbLf & vbCr, vbLf) ' Step2: string of n reverse LfCrLfCr contains n-1 normal CrLf,
    ' at most one reverse LfCr survives Step1
    Call replaceText(doReq, vbCr, vbLf)        ' Step3: single Cr
End Function

Function CheckServerURL(str_server As String, str_url As String) As Boolean
    CheckServerURL = True
    If str_url = "" Or str_server = "" Or str_url Like "*[#]" Or str_server Like "*[#]" Then
        If Not asked_before Then
            MsgBox2 asr(ark_Http_NoServer) & vbLf & str_server & "/" & str_url, vbCritical + vbOKOnly
            asked_before = True
        End If
        CheckServerURL = False
    End If
End Function

Attribute VB_Name = "clsEncrypt"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA7 Or Win64 Then
Private Declare PtrSafe Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" (phProv As LongPtr, pszContainer As String, pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptCreateHash Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal Algid As Long, ByVal hKey As LongPtr, ByVal dwFlags As Long, phHash As LongPtr) As Long
Private Declare PtrSafe Function CryptDeriveKey Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal Algid As Long, ByVal hBaseData As LongPtr, ByVal dwFlags As Long, phKey As LongPtr) As Long
Private Declare PtrSafe Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash As LongPtr) As Long
Private Declare PtrSafe Function CryptDestroyKey Lib "advapi32.dll" (ByVal hKey As LongPtr) As Long
Private Declare PtrSafe Function CryptEncrypt Lib "advapi32.dll" (ByVal hKey As LongPtr, ByVal hHash As LongPtr, ByVal Final As Long, ByVal dwFlags As Long, ByVal pbData As String, pdwDataLen As Long, ByVal dwBufLen As Long) As Long
Private Declare PtrSafe Function CryptDecrypt Lib "advapi32.dll" (ByVal hKey As LongPtr, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByVal pbData As String, pdwDataLen As Long) As Long
Private Declare PtrSafe Function CryptGenKey Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal Algid As Long, ByVal dwFlags As Long, phKey As Long) As Long
Private Declare PtrSafe Function CryptGetProvParam Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal dwParam As Long, pbData As Any, pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptGetUserKey Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal dwKeySpec As Long, phUserKey As Long) As Long
Private Declare PtrSafe Function CryptHashData Lib "advapi32.dll" (ByVal hHash As LongPtr, ByVal pbData As String, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv As LongPtr, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function CryptSignHash Lib "advapi32.dll" Alias "CryptSignHashA" (ByVal hHash As LongPtr, ByVal dwKeySpec As Long, ByVal sDescription As String, ByVal dwFlags As Long, ByVal pbSignature As String, pdwSigLen As Long) As Long
Private Declare PtrSafe Function CryptVerifySignature Lib "advapi32.dll" Alias "CryptVerifySignatureA" (ByVal hHash As LongPtr, ByVal pbSignature As String, ByVal dwSigLen As Long, ByVal hPubKey As Long, ByVal sDescription As String, ByVal dwFlags As Long) As Long
'API error function
Private Declare PtrSafe Function GetLastError Lib "kernel32" () As Long
#Else
Private Declare Function CryptAcquireContext Lib "advapi32.dll" Alias "CryptAcquireContextA" (phProv As Long, pszContainer As String, pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptCreateHash Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal hKey As Long, ByVal dwFlags As Long, phHash As Long) As Long
Private Declare Function CryptDeriveKey Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal hBaseData As Long, ByVal dwFlags As Long, phKey As Long) As Long
Private Declare Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash As Long) As Long
Private Declare Function CryptDestroyKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Private Declare Function CryptEncrypt Lib "advapi32.dll" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByVal pbData As String, pdwDataLen As Long, ByVal dwBufLen As Long) As Long
Private Declare Function CryptDecrypt Lib "advapi32.dll" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByVal pbData As String, pdwDataLen As Long) As Long
Private Declare Function CryptGenKey Lib "advapi32.dll" (ByVal hProv As Long, ByVal Algid As Long, ByVal dwFlags As Long, phKey As Long) As Long
Private Declare Function CryptGetProvParam Lib "advapi32.dll" (ByVal hProv As Long, ByVal dwParam As Long, pbData As Any, pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptGetUserKey Lib "advapi32.dll" (ByVal hProv As Long, ByVal dwKeySpec As Long, phUserKey As Long) As Long
Private Declare Function CryptHashData Lib "advapi32.dll" (ByVal hHash As Long, ByVal pbData As String, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptSignHash Lib "advapi32.dll" Alias "CryptSignHashA" (ByVal hHash As Long, ByVal dwKeySpec As Long, ByVal sDescription As String, ByVal dwFlags As Long, ByVal pbSignature As String, pdwSigLen As Long) As Long
Private Declare Function CryptVerifySignature Lib "advapi32.dll" Alias "CryptVerifySignatureA" (ByVal hHash As Long, ByVal pbSignature As String, ByVal dwSigLen As Long, ByVal hPubKey As Long, ByVal sDescription As String, ByVal dwFlags As Long) As Long
'API error function
Private Declare Function GetLastError Lib "kernel32" () As Long
#End If
'Private Const GHND = (GMEM_MOVEABLE Or GMEM_ZEROINIT)
'constants for Cryptography API functions
Private Const MS_DEF_PROV = "Microsoft Base Cryptographic Provider v1.0"
Private Const PROV_RSA_FULL = 1
Private Const CRYPT_NEWKEYSET = &H8
Private Const PP_CONTAINER = 6
Private Const AT_KEYEXCHANGE = 1
Private Const AT_SIGNATURE = 2
Private Const SIMPLEBLOB = 1
Private Const ALG_CLASS_DATA_ENCRYPT = 24576
Private Const ALG_CLASS_HASH = 32768
Private Const ALG_TYPE_ANY = 0
Private Const ALG_TYPE_BLOCK = 1536
Private Const ALG_TYPE_STREAM = 2048
Private Const ALG_SID_RC2 = 2
Private Const ALG_SID_RC4 = 1
Private Const ALG_SID_MD5 = 3
Private Const CALG_MD5 = ((ALG_CLASS_HASH Or ALG_TYPE_ANY) Or ALG_SID_MD5)
Private Const CALG_RC2 = ((ALG_CLASS_DATA_ENCRYPT Or ALG_TYPE_BLOCK) Or ALG_SID_RC2)
Private Const CALG_RC4 = ((ALG_CLASS_DATA_ENCRYPT Or ALG_TYPE_STREAM) Or ALG_SID_RC4)
'constants from WinErr.h
Private Const NTE_NO_KEY As Long = -2146893811 '0x8009000DL
Private Const NTE_BAD_SIGNATURE As Long = -2146893818
'clsCryptoFilterBox constants
Private Const CFB_BUSY = 0
Private Const CFB_READY = 1
Private Const CFB_VALID = 2
Private Const ENCRYPT_ALGORITHM = CALG_RC4
Private Const ENCRYPT_BLOCK_SIZE = 1
Private Const CRYPT_EXPORTABLE = 1
'private property buffers
Private sInBuffer As String
Private sOutBuffer As String
Private sPassword As String
Private sSignature As String
Private lStatus As Long

Public Property Get InBuffer() As String
    InBuffer = sInBuffer
End Property

Public Property Let InBuffer(vNewValue As String)
    sInBuffer = vNewValue
End Property

Public Property Get OutBuffer() As String
    OutBuffer = sOutBuffer
End Property

Public Property Get Signature() As String
    Signature = sSignature
End Property

Public Property Let Signature(vNewValue As String)
    sSignature = vNewValue
End Property

Public Sub Sign()
    'Create a signature for Inbuffer and place in Signature
    Dim sContainer As String, sDescription As String, sProvider As String
    #If VBA7 Or Win64 Then
        Dim lHCryptprov As LongPtr, lHHash As LongPtr
    #Else
        Dim lHCryptprov As Long, lHHash As Long
    #End If
    
    Dim lResult As Long, lSignatureLen As Long
    On Error GoTo ErrSign
    'switch Status property
    lStatus = CFB_BUSY
    'init Signature property
    sSignature = ""
    'Get handle to the default provider.
    sContainer = vbNullChar
    sProvider = MS_DEF_PROV & vbNullChar
    If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptAcquireContext!"
        GoTo ReleaseHandles:
    End If
    'Create a hash object.
    If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptCreateHash!"
        GoTo ReleaseHandles:
    End If
    If Not CBool(CryptHashData(lHHash, sInBuffer, Len(sInBuffer), 0)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptHashData!"
        GoTo ReleaseHandles:
    End If
    'Sign hash object.
    'Determine size of signature.
    sDescription = vbNullChar
    lResult = CryptSignHash(lHHash, AT_SIGNATURE, sDescription, 0, sSignature, lSignatureLen)
    sSignature = String(lSignatureLen, vbNullChar)
    'Sign hash object (with signature key).
    If Not CBool(CryptSignHash(lHHash, AT_SIGNATURE, sDescription, 0, sSignature, lSignatureLen)) Then
        MsgBox "Error " & CStr(GetLastError()) & " during CryptSignHash"
        GoTo ReleaseHandles:
    End If
ReleaseHandles:
    'Destroy hash object.
    If lHHash Then lResult = CryptDestroyHash(lHHash)
    'Release provider handle.
    If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)
    'switch Status property
    lStatus = CFB_READY
    Exit Sub
ErrSign:
    MsgBox "ErrSign " & Err.Description
    GoTo ReleaseHandles
End Sub

Public Sub Validate()
    'Validate InBuffer with Signature and assign Status with result
    Dim bValid As Boolean, sContainer As String, sDescription As String, sProvider As String
    Dim lDataLen As Long, lDataPoint As Long
    Dim lResult As Long, lSignatureLen As Long, lHCryptKey As Long
    #If VBA7 Or Win64 Then
        Dim lHCryptprov As LongPtr, lHHash As LongPtr
    #Else
        Dim lHCryptprov As Long, lHHash As Long
    #End If

    ReDim aByteData(0) As Byte
    On Error GoTo ErrValidate
    'switch Status property
    lStatus = CFB_BUSY
    'init internal valid flag
    bValid = True
    'Get handle to the default provider.
    sContainer = vbNullChar
    sProvider = MS_DEF_PROV & vbNullChar
    If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
        bValid = False
        MsgBox "Error " & CStr(GetLastError) & " during CryptAcquireContext!"
        GoTo ReleaseHandles:
    End If
    'Create a hash object.
    If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
        bValid = False
        MsgBox "Error " & CStr(GetLastError) & " during CryptCreateHash!"
        GoTo ReleaseHandles:
    End If
    'Add data to hash object.
    If Not CBool(CryptHashData(lHHash, sInBuffer, Len(sInBuffer), 0)) Then
        bValid = False
        MsgBox "Error " & CStr(GetLastError) & " during CryptHashData!"
        GoTo ReleaseHandles:
    End If
    'Determine size of signature.
    'sDescription = vbNullChar
    'lResult = CryptSignHash(lHHash, AT_SIGNATURE, sDescription, 0, 0, lSignatureLen)
    'Get handle to signature key.
    If Not CBool(CryptGetUserKey(lHCryptprov, AT_SIGNATURE, lHCryptKey)) Then
        bValid = False
        MsgBox "Error " & CStr(GetLastError) & " during CryptGetUserKey!"
        GoTo ReleaseHandles:
    End If
    lSignatureLen = Len(sSignature)
    'Verify signature.
    If Not CBool(CryptVerifySignature(lHHash, sSignature, lSignatureLen, lHCryptKey, sDescription, 0)) Then
        If GetLastError = NTE_BAD_SIGNATURE Then
            bValid = False
            GoTo ReleaseHandles:
        Else
            bValid = False
            MsgBox "Error " & CStr(GetLastError) & " during CryptVerifySignature!"
            GoTo ReleaseHandles:
        End If
    End If
ReleaseHandles:
    'Release signature key.
    If lHCryptKey Then lResult = CryptDestroyKey(lHCryptKey)
    'Destroy hash object.
    If lHHash Then lResult = CryptDestroyHash(lHHash)
    'Release provider handle.
    If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)
    Select Case bValid
        Case True
            lStatus = CFB_VALID
        Case Else
            lStatus = CFB_READY
    End Select
    Exit Sub
ErrValidate:
    MsgBox "ErrValidate " & Err.Description
    Resume
End Sub

Public Sub Encrypt()
    #If VBA7 Or Win64 Then
        Dim lHCryptprov As LongPtr, lHHash As LongPtr, lHkey As LongPtr
    #Else
        Dim lHCryptprov As Long, lHHash As Long, lHkey As Long
    #End If
    'Encrypt InBuffer into OutBuffer
    Dim lHExchgKey As Long
    Dim lResult As Long, sContainer As String, sProvider As String, sCryptBuffer As String
    Dim lCryptLength As Long, lCryptBufLen As Long


    On Error GoTo ErrEncrypt
    'switch Status property
    lStatus = CFB_BUSY
    'Get handle to the default provider
    sContainer = vbNullChar
    sProvider = vbNullChar
    sProvider = MS_DEF_PROV & vbNullChar
    If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptAcquireContext!"
        GoTo Done
    End If
    'Create a hash object.
    If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptCreateHash!"
        GoTo Done
    End If
    'Hash in the password data.
    If Not CBool(CryptHashData(lHHash, sPassword, Len(sPassword), 0)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptHashData!"
        GoTo Done
    End If
    'Derive a session key from the hash object.
    If Not CBool(CryptDeriveKey(lHCryptprov, ENCRYPT_ALGORITHM, lHHash, 0, lHkey)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptDeriveKey!"
        GoTo Done
    End If
    'Destroy the hash object.
    CryptDestroyHash (lHHash)
    lHHash = 0
    'Prepare a string buffer for the CryptEncrypt function
    lCryptLength = Len(sInBuffer)
    lCryptBufLen = lCryptLength * 2
    sCryptBuffer = String(lCryptBufLen, vbNullChar)
    LSet sCryptBuffer = sInBuffer
    'Encrypt data
    If Not CBool(CryptEncrypt(lHkey, 0, 1, 0, sCryptBuffer, lCryptLength, lCryptBufLen)) Then
        MsgBox "bytes required:" & CStr(lCryptLength)
        MsgBox "Error " & CStr(GetLastError) & " during CryptEncrypt!"
    End If
    sOutBuffer = Mid$(sCryptBuffer, 1, lCryptLength)
Done:
    'Destroy session key.
    If (lHkey) Then lResult = CryptDestroyKey(lHkey)
    'Release key exchange key handle.
    If lHExchgKey Then CryptDestroyKey (lHExchgKey)
    'Destroy hash object.
    If lHHash Then CryptDestroyHash (lHHash)
    'Release provider handle.
    If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)
    'switch Status property
    lStatus = CFB_READY
    Exit Sub
ErrEncrypt:
    MsgBox "ErrEncrypt " & Err.Description
    Resume
End Sub

Public Sub Decrypt()
    #If VBA7 Or Win64 Then
        Dim lHCryptprov As LongPtr, lHHash As LongPtr, lHkey As LongPtr
    #Else
        Dim lHCryptprov As Long, lHHash As Long, lHkey As Long
    #End If
    'Decrypt InBuffer into OutBuffer
    Dim lHExchgKey As Long
    Dim lResult As Long, sContainer As String, sProvider As String
    Dim sCryptBuffer As String, lCryptBufLen As Long, lCryptPoint As Long
    Dim lPasswordPoint As Long, lPasswordCount As Long
    On Error GoTo ErrDecrypt
    'switch Status property
    lStatus = CFB_BUSY
    'Init sOutBuffer
    sOutBuffer = ""
    'Get handle to the default provider.
    sContainer = vbNullChar
    sProvider = vbNullChar
    sProvider = MS_DEF_PROV & vbNullChar
    If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptAcquireContext!"
        GoTo Done
    End If
    'Create a hash object.
    If Not CBool(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptCreateHash!"
        GoTo Done
    End If
    'Hash in the password data.
    If Not CBool(CryptHashData(lHHash, sPassword, Len(sPassword), 0)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptHashData!"
        GoTo Done
    End If
    'Derive a session key from the hash object.
    If Not CBool(CryptDeriveKey(lHCryptprov, ENCRYPT_ALGORITHM, lHHash, 0, lHkey)) Then
        MsgBox "Error " & CStr(GetLastError) & " during CryptDeriveKey!"
        GoTo Done
    End If
    'Destroy the hash object.
    CryptDestroyHash (lHHash)
    lHHash = 0
    'Prepare sCryptBuffer for CryptDecrypt
    lCryptBufLen = Len(sInBuffer) * 2
    sCryptBuffer = String(lCryptBufLen, vbNullChar)
    LSet sCryptBuffer = sInBuffer
    'Decrypt data
    If Not CBool(CryptDecrypt(lHkey, 0, 1, 0, sCryptBuffer, lCryptBufLen)) Then
        MsgBox "bytes required:" & CStr(lCryptBufLen)
        MsgBox "Error " & CStr(GetLastError) & " during CryptDecrypt!"
        GoTo Done
    End If
    'Apply decrypted string from sCryptBuffer to private buffer for OutBuffer property
    sOutBuffer = Mid$(sCryptBuffer, 1, Len(sInBuffer))
Done:
    'Destroy session key.
    If (lHkey) Then lResult = CryptDestroyKey(lHkey)
    'Release key exchange key handle.
    If lHExchgKey Then CryptDestroyKey (lHExchgKey)
    'Destroy hash object.
    If lHHash Then CryptDestroyHash (lHHash)
    'Release provider handle.
    If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)
    'switch Status property
    lStatus = CFB_READY
    Exit Sub
ErrDecrypt:
    MsgBox "ErrDecrypt " & Err.Description
    GoTo Done
End Sub

Public Property Get Status() As Long
    Status = lStatus
End Property

Private Function InitUser() As Long
    #If VBA7 Or Win64 Then
        Dim lHCryptprov As LongPtr
    #Else
        Dim lHCryptprov As Long
    #End If
    Dim lHCryptKey As Long, avProviderData(1000) As Byte
    Dim lProviderDataAddress As Long, lProviderDataLen As Long, lDataSize As Long
    Dim lResult As Long, sContainer As String, sProvider As String
    Dim sUserName As String, lPoint As Long, lMemHandle As Long
    Dim lReturn As Long, sBuffer As String
    On Error GoTo ErrInitUser
    'prepare string buffers
    sContainer = vbNullChar
    sProvider = MS_DEF_PROV & vbNullChar
    'Attempt to acquire a handle to the default key container.
    If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, 0)) Then
        'Create default key container.
        If Not CBool(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal sProvider, PROV_RSA_FULL, CRYPT_NEWKEYSET)) Then
            MsgBox "Error creating key container! " & CStr(GetLastError)
            Exit Function
        End If
        'Get name of default key container.
        lProviderDataLen = Len(avProviderData(0)) * (UBound(avProviderData) + 1)
        If Not CBool(CryptGetProvParam(lHCryptprov, PP_CONTAINER, avProviderData(0), lProviderDataLen, 0)) Then
            MsgBox "Error getting user name! " & CStr(GetLastError)
            avProviderData(0) = 0
        End If
        'Get sUserName from avProviderData()
        lPoint = LBound(avProviderData)
        Do While lPoint <= UBound(avProviderData)
            If avProviderData(lPoint) <> 0 Then
                sUserName = sUserName & Chr$(avProviderData(lPoint))
            Else
                lPoint = UBound(avProviderData)
            End If
            lPoint = lPoint + 1
        Loop
        MsgBox "Create key container " & sUserName
    End If
    'Attempt to get handle to signature key
    If Not CBool(CryptGetUserKey(lHCryptprov, AT_SIGNATURE, lHCryptKey)) Then
        If GetLastError = NTE_NO_KEY Then
            'MsgBox "Create key exchange key pair"
            If Not CBool(CryptGenKey(lHCryptprov, AT_SIGNATURE, 0, lHCryptKey)) Then
                MsgBox "Error during CryptGenKey! " & CStr(GetLastError)
                Exit Function
            Else
                lResult = CryptDestroyKey(lHCryptprov)
            End If
        Else
            MsgBox "Error during CryptGetUserKey! " & CStr(GetLastError)
            Exit Function
        End If
    End If
    'Attempt to get handle to exchange key
    If Not CBool(CryptGetUserKey(lHCryptprov, AT_KEYEXCHANGE, lHCryptKey)) Then
        If GetLastError = NTE_NO_KEY Then
            'MsgBox "Create key exchange key pair"
            If Not CBool(CryptGenKey(lHCryptprov, AT_KEYEXCHANGE, 0, lHCryptKey)) Then
                MsgBox "Error during CryptGenKey! " & CStr(GetLastError)
                Exit Function
            Else
                lResult = CryptDestroyKey(lHCryptprov)
            End If
        Else
            MsgBox "Error during CryptGetUserKey! " & CStr(GetLastError)
            Exit Function
        End If
    End If
    'release handle to provider
    lResult = CryptReleaseContext(lHCryptprov, 0)
    InitUser = True
    Exit Function
ErrInitUser:
    MsgBox "ErrInitUser " & Err.Description
    Resume
End Function

Private Sub Class_Initialize()
    If InitUser = False Then
        MsgBox "InitUser failed"
    End If
End Sub

Public Property Get Password() As String
    Password = sPassword
End Property

Public Property Let Password(vNewValue As String)
    sPassword = vNewValue
End Property


' InQuest injected base64 decoded content
' bp*&n
' *lzS(u
' .+-:

INQUEST-PP=macro
