Attribute VB_Name = "Diagramm1"
Attribute VB_Base = "0{00020821-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Diagramm2"
Attribute VB_Base = "0{00020821-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Diagramm3"
Attribute VB_Base = "0{00020821-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


Private Sub Workbook_Open()
Dim sVersion As String, sError As String
Dim sh As Variant, wsh As Worksheet, ch As Chart
Dim shx As Long, msg As String

    ' standard settings
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    sVersion = Application.Version
    sVersion = nextValue(sVersion, ".")
    If CInt(sVersion) < 9 Then
        MsgBox "EXCEL Version |fffd|lter als 9.0 (Office 2000): nicht getestet."
    End If
'Debug.Print "Open", ActiveWorkbook.name

' followed by Workbook_Activate; Window_Activate
End Sub

Private Sub Workbook_Activate()
' issue: if more than one Liquiplan model is open
'        LiquiMenu and ActiveVBProject may not be in sync
End Sub

Private Sub testWindowActivate()
Application.EnableEvents = True
    Workbook_WindowActivate Application.ActiveWindow
End Sub

Private Sub Workbook_WindowActivate(ByVal Wn As Window)
Dim ws As Worksheet, sError As String

'Debug.Print "WindowActivate", Wn.caption
'For Each ws In ActiveWorkbook.Worksheets
'Debug.Print "WindowActivate(..)", isLiquiplanSheet(ws), ws.name, ws.ProtectContents
'Next
    
Debug.Print ""
Debug.Print "=========="
Debug.Print "WindowActivate(..)", ActiveWorkbook.name, ActiveWorkbook.ActiveSheet.name

' 8.4B
    If gb_dataImportActive And gs_importTargetFullName = ActiveWorkbook.FullName Then
        finishDataImport
        Exit Sub
    End If
    
    Application.EnableEvents = False
    
    gb_protectionIssue = False
    
    removeLiquiPlanMenu

    If go_SheetsWarden Is Nothing Then
        Set go_SheetsWarden = New SheetsWatch
        go_SheetsWarden.setWorkbook Application.ActiveWorkbook
    End If
        
    getCodeVariant
    
    initializeModel ' calls validateMainSheet(..)
    addLiquiMenus
    
    addToContextMenu "Cell"
    addToContextMenu "Row"
    
Application.Calculation = xlCalculationAutomatic
Application.CalculateFull
Application.ScreenUpdating = True
Application.EnableEvents = True
Application.StatusBar = False
End Sub

Private Sub Workbook_WindowDeactivate(ByVal Wn As Window)
Dim ob As Object
    
    Application.EnableEvents = False
    Set ob = Wn.ActiveSheet
    handleWindowDeactivate Wn
    
    removeLiquiPlanMenu
    
    deleteFromContextMenu "Cell"
    deleteFromContextMenu "Row"
    deleteFromContextMenu "Column"

    Set go_SheetsWarden = Nothing
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub Workbook_SheetActivate(ByVal sh As Object)
Dim pop As CommandBarPopup
    On Error Resume Next
    Set pop = Nothing
    Set pop = Application.CommandBars("Worksheet Menu Bar").Controls("LiquiPlan")
    If pop Is Nothing Then
        addLiquiMenus
        initOptions
    End If
    On Error GoTo 0
    
    Application.EnableEvents = False
    handleSheetActivate sh
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub Workbook_SheetDeactivate(ByVal sh As Object)
'
End Sub

Private Sub Workbook_SheetChange(ByVal sh As Object, ByVal Target As Range)
    handleWorkSheetChange ByVal Target
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub Workbook_SheetSelectionChange(ByVal sh As Object, ByVal Target As Range)
    ' Soll-Ist: "Grafik" als Schaltfl|fffd|che
    ' selection/context dependent LiquiPlan menu items
    handleSheetSelectionChange ByVal Target
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub Workbook_SheetBeforeDoubleClick(ByVal sh As Object, ByVal Target As Range, Cancel As Boolean)
'Remove cell protection: allow manual update of 'Kontostand am 1. des Monats'
    handleDoubleClick Target, Cancel
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub Workbook_SheetBeforeRightClick(ByVal sh As Object, ByVal Target As Range, Cancel As Boolean)
' ToDo: right-click on red cell => "Warnfarbe entfernen ?"
    handleRightClick Target, Cancel
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub Workbook_SheetBeforeDelete(ByVal sh As Object)
' after prompt := OK (Application.DisplayAlerts = True)
End Sub

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
Dim sError As String
    
    storeColorMap Application.ActiveSheet

    ' update menus (development: version may have changed
    addLiquiMenus
    addToContextMenu "Cell"
    addToContextMenu "Row"
    
    ' restore sheet protection
'    If (Not gb_sheetsAreProtected) Then     ' by beforeClose()
'        If (Not restoreModelProtection()) Then
'            Cancel = Not gb_ignoreProtectionError
'            gb_ignoreProtectionError = True
'        Else
'            gb_ignoreProtectionError = False
'        End If
'    End If
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub Workbook_BeforeClose(Cancel As Boolean)
Dim ws As Worksheet, ync As VbMsgBoxResult
Dim sError As String

' cf. initializeModel()

    ' restore sheet protection unconditionally
'If MsgBox("Blattschutz f|fffd|r " & srcSheet.name & " wiederherstellen?", vbYesNo, cs_MsgTitle) = vbYes Then
'    gb_sheetsAreProtected = False
'    If (Not restoreModelProtection()) Then
'        Cancel = Not gb_ignoreProtectionError
'        gb_ignoreProtectionError = True
'Exit Sub
'    End If
'    gb_ignoreProtectionError = False
'    gb_sheetsAreProtected = True
    
    If Application.ActiveWorkbook.Saved Then
        removeLiquiPlanMenu
        deleteFromContextMenu "Cell"
        deleteFromContextMenu "Row"
        deleteFromContextMenu "Column"
    Else
        ' user may cancel the  Close operation
    End If
    
' asks for another Save
'Application.Calculation = xlCalculationAutomatic

Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.EnableEvents = True
Application.StatusBar = False
End Sub

Attribute VB_Name = "LibAnalytics"
Option Explicit

#Const OFFICE_VERSION = 14


' performance analysis:
' selected quantities (KPI, key performance indicators)
'       selected on input sheet: separate chart (standard, single KPI, several KPI's)
'       marked in analysis sheet: chart objects on sheet

Public Const cn_rowOffMonthly As Long = 0
Public Const cn_rowOffAccrued As Long = 7 ' one empty row between sub sections (month, accrued)
Public Const cn_seriesNameLength As Long = 12
Public Const cn_colorCreditLine As Long = 3 ' red

Public Const cs_titlePerformanceAnalysis As String = "Soll/Ist-Vergleich"
Public Const cs_headerPerformanceAnalysis As String = "Soll/Ist-Vergleich f|fffd|r Monat"

Public gb_isUserOK As Boolean  'set by some forms
Public gb_isChartWithAccumulation As Boolean  '
Public gb_isClearWithProlog As Boolean
Public gb_isKeepLastYear As Boolean
Public gb_isKeepInputData As Boolean
Public gb_isClearMasterData As Boolean

Public gb_isAddPlotsDenied As Boolean

' Charts with several quantities (clustered column)
Public Const cs_SheetNameSep As String = "*" ' ! must not be allowed in sheet names !
'


Function checkOfficeVersion() As Boolean
Dim office As Long, msg As String

    checkOfficeVersion = False
    office = val(Application.Version)
    #If OFFICE_VERSION >= 15 Then
        If (office < 15) Then
            'issue
            msg = "Warnung: Compiler-Konstante OFFICE_VERSION muss " _
                & vbLf & "auf den Wert " & office & " gesetzt werden."
            MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
        End If
    #Else
        If (office >= 15) Then
            'hint
            msg = "Hinweis: Compiler-Konstante OFFICE_VERSION kann " _
                & vbLf & "auf den Wert " & office & " gesetzt werden."
'            MsgBox msg, vbInformation, cs_MsgTitle
            checkOfficeVersion = True
        End If
    #End If
End Function
 
Sub updateReports(ByVal Target As Range, lastMonthName As String)
Dim sError As String, isOk As Boolean

    'Soll/Ist Tabelle aktualisieren
    isOk = rebuildTableAndPlots(Target, sError)
    If Not isOk Then
        Target.Cells(1, 1) = lastMonthName ' undo change
        sError = sError & vbLf & vbLf & "Soll/Ist-Vergleich abgebrochen."
    End If
    If sError <> "" Then
Debug.Print sError
        MsgBox sError, vbCritical, cs_MsgTitle
    End If
    If Not isOk Then
Exit Sub
    End If
    
    'Grafiken aktualisieren: nur Haupteingabedaten (U&L | Konsolidierung)
    If Target.parent.name <> gs_MainSheetName Then
Exit Sub
    End If
    If Not updateLiquiCharts(Target, sError) Then
        If (sError <> "") Then MsgBox sError, vbCritical, cs_MsgTitle
Exit Sub
    End If
End Sub

Function rebuildTableAndPlots(ByVal Target As Range, sError As String) As Boolean
' update / rebuild analysis table
' update /rebuild plots
'###
'must have current and new month
'called when month changes
'new = '<ohne>': reset, copy row headers
'old = '<ohne>' and new = '<monat>':
'   reset, copy row headers; initialize month
'old = '<monat>' and new = '<monat>':
'   compare row headers; prompt difference; exit or reset; initialize month


Dim srcSheet As Worksheet, cmpSheet As Worksheet, masterSheet As Worksheet
Dim srcSheetName As String, cmpSheetName As String, masterSheetName As String
Dim monthName As String, month As Long
Dim first As Long, last As Long, row As Long, clm As Long
Dim notFound As Boolean
Dim formula As String
Dim idx As Long, msg As String, temp As String, value As Variant

'###
Dim isProtected As Boolean, visibility As XlSheetVisibility
    
    Set srcSheet = Target.parent
    srcSheetName = srcSheet.name
    If Not isSourceSheet(srcSheet) Then
        sError = "Blatt '" & srcSheetName & "' kein Datenblatt (Profit Center oder Konsolidierung)."
Exit Function
    End If

    rebuildTableAndPlots = False

    
    cmpSheetName = getCompareSheetName(srcSheet.name)
    Set cmpSheet = getSheet(cmpSheetName)
    If cmpSheet Is Nothing Then
        Set cmpSheet = copyCompareSheet(cmpSheetName)
    End If
    If cmpSheet Is Nothing Then
        sError = "Blatt '" & cmpSheetName & "' nicht gefunden."
Exit Function
    End If
    
    ' tentatively, skip comparison sheets hidden by user (speed-up operation)
    If (cmpSheet.visible = xlSheetHidden) Then
        rebuildTableAndPlots = True
Exit Function
    End If
    
Debug.Print "rebuildTableAndPlots(..)", srcSheet.name, cmpSheet.name
    
    If (Not unprotectSheet(cmpSheet, True)) Then
Exit Function
    End If

    monthName = Target.Cells(1, 1)
    month = monthToNumber(monthName)
    
    masterSheetName = getMasterSheetName(srcSheet.name)
    Set masterSheet = getSheet(masterSheetName)
    If masterSheet Is Nothing Then
        sError = "Blatt mit Plandaten fuer " & srcSheetName & " nicht gefunden."
Exit Function
    End If

    'validate row titles
    clm = 2
    findTextOrFormula srcSheet, "Kontokorrent - Kredit", True, True, row, clm, , 2
    last = row
    If clm = 0 Then
        sError = "Abschnittsgrenzen nicht erkennbar (Kontokorrent - Kredit)."
Exit Function
    End If
    
    'compare row titles
    With srcSheet
        If Not isRangeEmpty(.Range(.Cells(1, 2), .Cells(2, last))) Then
            For row = 1 To last
                If .Cells(row, 2) <> masterSheet.Cells(row, 2) Then
                    sError = "Aktuelle Daten nicht mehr konsistent mit Plandaten"
                    sError = sError & vbLf & "Zeile: " & row & ":  " & .name & " || " & masterSheet.name
                    sError = sError & vbLf & "'" & .Cells(row, 2) & "' != '" & masterSheet.Cells(row, 2) & "'"
                    srcSheet.Activate
                    srcSheet.Rows(row).Select
Exit Function
                End If
            Next
        End If
    End With
    
'determine source range
    notFound = False
    row = gn_monthRow
    clm = 2
    findTextOrFormula srcSheet, "III. ", True, True, row, clm, , 2
    If clm = 0 Then notFound = True
    first = row + 2
    findTextOrFormula srcSheet, "G. u. V.", True, True, row, clm, , 2
    last = row
    If clm = 0 Then notFound = True
    
    If notFound Then
        sError = "Abschnittsgrenzen nicht erkennbar (III. bis G. u. V.)."
Exit Function
    End If
    
    
    monthName = Target.Cells(1, 1)
    month = monthToNumber(monthName)

Dim used As Range, changeDisabled As Boolean, eventsFlag As Boolean
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False

'Debug.Print "rebuildTableAndPlots: ", srcSheetName, masterSheetName, cmpSheetName, monthName

Dim cll As Range
    With cmpSheet
        .Activate
'Debug.Print "rebuildTableAndPlots(..)", cmpSheet.name
        Set used = .usedRange
        visibility = .visible
        
        ' transitional: fix headers and title, group cells
'Set cll = .Cells(cn_compareRowOff + 1, 2)
'Debug.Print "rebuildTableAndPlots(..)", cll.Font.color
        row = cn_compareRowOff
        If (.Cells(row, 3) = "" Or .Cells(row, 4) = "" Or .Cells(row, 5) = "" _
            Or .Cells(row, 7) = "" Or .Cells(row, 8) = "" Or .Cells(row, 9) = "") Then
            .Range(.Cells(row, 1), .Cells(row, 9)).ClearContents
            .Range(.Cells(row, 1), .Cells(row, 9)).Interior.ColorIndex = xlNone
            .Range(.Cells(row, 1), .Cells(row, 9)).ClearFormats
        
            .Cells(row, 3) = "Soll": .Cells(row, 4) = "Ist": .Cells(row, 5) = "Ist - Soll"    ' "Abweichung"
            .Cells(row, 7) = "Soll": .Cells(row, 8) = "Ist": .Cells(row, 9) = "Ist - Soll"
        
            .Range(.Cells(row, 1), .Cells(row, 9)).HorizontalAlignment = xlCenter
            .Range(.Cells(row, 1), .Cells(row, 9)).Font.Color = 16711680
        
'            ActiveWindow.FreezePanes = False
'            .Rows(row + 2).Select
'            ActiveWindow.FreezePanes = True
        
            .Cells(row + 1, 2) = cs_headerPerformanceAnalysis
            For Each cll In .Range(.Cells(2, 2), .Cells(6, 9))
                If startsWith(cll.value, "Soll") Then
                    cll.value = cs_titlePerformanceAnalysis
                    Exit For
                End If
            Next
            
            .Cells(row + 1, cn_clm_PlotCheck).Font.Bold = False
            .Columns(cn_clm_PlotCheck).ColumnWidth = 6
        End If
        
        row = cn_compareRowOff + 1
        If (.Cells(row, 2) = "" _
                Or .Cells(row, cn_clm_PlotCheck) = "" _
                Or .Cells(row, cn_clm_PlotCheck + 1) = "") Then
            .Cells(row, 2) = cs_headerPerformanceAnalysis
            .Cells(row, cn_clm_PlotCheck) = "Grafik"
            .Cells(row, cn_clm_PlotCheck + 1) = "Aufgelaufen seit Jahresbeginn"
            
            .Range(.Cells(row, 1), .Cells(row, 9)).Font.Color = 16711680
            .Range(.Cells(row, 1), .Cells(row, 9)).Font.Bold = True
            .Cells(row, cn_clm_PlotCheck).Font.Bold = False
            
            .Range(.Cells(row, 3), .Cells(row, 5)).MergeCells = True
            .Range(.Cells(row, 7), .Cells(row, 9)).MergeCells = True

            .Cells(row, 2).HorizontalAlignment = xlCenter
            .Cells(row, 3).HorizontalAlignment = xlCenter
            .Cells(row, cn_clm_PlotCheck).HorizontalAlignment = xlCenter
            .Cells(row, 7).HorizontalAlignment = xlCenter
            
            .Cells(row, 2).BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
            .Range(.Cells(row, 3), .Cells(row, 5)).BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
            .Cells(row, cn_clm_PlotCheck).BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
            .Range(.Cells(row, 7), .Cells(row, 9)).BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
        End If
     
        .Cells(cn_compareRowOff + 1, 3) = ""  ' no month yet
        'reset: as long as row header <> ""
        row = cn_compareRowOff + 2  ' ??? 3

'Debug.Print "rebuildTableAndPlots (A)"
        
' reset and remember KPI selection (column F = cn_clm_PlotCheck)
Dim checkedQuantities As String, checkSymbol As String
        checkSymbol = ""
        For row = cn_compareRowOff + 2 To getLastRow(used)
            If (.Cells(row, cn_clm_PlotCheck) <> "") Then
                checkedQuantities = checkedQuantities & .Cells(row, 2) & "/"
                checkSymbol = .Cells(row, cn_clm_PlotCheck)     ' If checkSymbol = "" Then
            End If
            .Range(.Cells(row, 1), .Cells(row, 9)).ClearContents
            .Range(.Cells(row, 1), .Cells(row, 9)).Interior.ColorIndex = xlNone
            .Range(.Cells(row, 1), .Cells(row, 9)).ClearFormats
            .Range(.Cells(row, 1), .Cells(row, 9)).MergeCells = False
            
            .Cells(row, cn_clm_PlotCheck).HorizontalAlignment = xlCenter
        Next
                
'Debug.Print "rebuildTableAndPlots (B)"
        
        ' eventually all cells locked but plot check column
        .Cells.Locked = True
'        For row = 3 To last - first + 3
'            idx = first + row - 3
        For row = 2 To last - first + 2
            idx = first + row - 2
            'validate to-be, as-is
            If Not masterSheet Is Nothing Then
                If srcSheet.Cells(idx, 2) <> masterSheet.Cells(idx, 2) Then
Debug.Print "rebuildTableAndPlots(..)", srcSheet.name, masterSheet.name
'Debug.Print srcSheet.Cells(idx, 2), .Cells(cn_compareRowOff + row, 2), masterSheet.Cells(idx, 2)
'                    sError = "Aktuelle Daten nicht mehr konsistent mit Plandaten"
'                    sError = sError & vbLf & "Zeile: " & idx & ":  " & srcSheet.name & " || " & .name & " || " & masterSheet.name
'                    sError = sError & vbLf & "'" & srcSheet.Cells(idx, 2) & "' || '" & .Cells(cn_compareRowOff + row, 2) & "' || '" & masterSheet.Cells(idx, 2) & "'"
Debug.Print "rebuildTableAndPlots(..)", srcSheet.Cells(idx, 2), masterSheet.Cells(idx, 2)
                    If sError = "" Then sError = "Aktuelle Daten nicht mehr konsistent mit Plandaten"   '
                    sError = sError & vbLf & "Zeile: " & idx & ":  " & srcSheet.name & " || " & masterSheet.name
                    sError = sError & vbLf & "'" & srcSheet.Cells(idx, 2) & "' || '" & masterSheet.Cells(idx, 2) & "'"
                    srcSheet.Activate
                    srcSheet.Rows(idx).Select
Exit Function
                End If
            End If
            
            'copy original row numbers
            .Cells(cn_compareRowOff + row, 1) = idx
            '.Cells(cn_compareRowOff + row, 1).Font.ColorIndex = srcSheet.Cells(idx, 1).Font.ColorIndex
            '.Cells(cn_compareRowOff + row, 1).Font.FontStyle = srcSheet.Cells(idx, 1).Font.FontStyle
            '.Cells(cn_compareRowOff + row, 1).Font.Size = srcSheet.Cells(idx, 1).Font.Size
            
            'copy row headers
            .Cells(cn_compareRowOff + row, 2) = srcSheet.Cells(idx, cn_clm_Quantity)
            .Cells(cn_compareRowOff + row, 2).Font.ColorIndex = srcSheet.Cells(idx, 2).Font.ColorIndex
            .Cells(cn_compareRowOff + row, 2).Font.FontStyle = srcSheet.Cells(idx, 2).Font.FontStyle
            .Cells(cn_compareRowOff + row, 2).Font.size = srcSheet.Cells(idx, 2).Font.size
            
            .Range(.Cells(cn_compareRowOff + row, 2), .Cells(cn_compareRowOff + row, 5)).Interior.Color = srcSheet.Cells(idx, 2).Interior.Color
            .Range(.Cells(cn_compareRowOff + row, 7), .Cells(cn_compareRowOff + row, 9)).Interior.Color = srcSheet.Cells(idx, 2).Interior.Color
            
            .Cells(cn_compareRowOff + row, cn_clm_PlotCheck).Locked = False
            If (srcSheet.Cells(idx, 2) <> "" And InStr(1, checkedQuantities, srcSheet.Cells(idx, 2)) > 0) Then
                .Cells(cn_compareRowOff + row, cn_clm_PlotCheck) = checkSymbol
            End If
        Next

'Debug.Print "rebuildTableAndPlots (C)"
        
        If monthName <> cs_NoMonth Then
            'current month; otherwise sheet has no data
            .visible = xlSheetVisible
            .Cells(cn_compareRowOff + 1, 3) = monthName
            clm = month + 3
            
            'build formulae for comparison target/actual
'            For row = 3 To last - first + 3
'            idx = first + row - 3
            For row = 2 To last - first + 2
                idx = first + row - 2
                'current month
                'budget
                formula = "='" + masterSheetName + "'!"
                formula = formula & "R" & (idx) & "C" & clm
                .Cells(cn_compareRowOff + row, 3).FormulaR1C1 = formula
                
                'current
                formula = "='" + srcSheetName + "'!"
                formula = formula & "R" & (idx) & "C" & clm
                .Cells(cn_compareRowOff + row, 4).FormulaR1C1 = formula
            
            'accumulated
                formula = "=Sum('" + masterSheetName + "'!"
                formula = formula & "R" & (idx) & "C" & (clm - month + 1) & ":R" & (idx) & "C" & (clm) & ")"    ' / " & month
                .Cells(cn_compareRowOff + row, 7).FormulaR1C1 = formula
                
                'current
                formula = "=Sum('" + srcSheetName + "'!"
                formula = formula & "R" & (idx) & "C" & (clm - month + 1) & ":R" & (idx) & "C" & (clm) & ")"    ' / " & month
                .Cells(cn_compareRowOff + row, 8).FormulaR1C1 = formula
                
            'formulae for difference
                .Cells(cn_compareRowOff + row, 5).FormulaR1C1 = "=RC[-1]-RC[-2]"
                .Cells(cn_compareRowOff + row, 9).FormulaR1C1 = "=RC[-1]-RC[-2]"
            Next
        End If
        
        ' borders
Dim tableBottomRow As Long
        tableBottomRow = cn_compareRowOff + row - 1
        With .Range(.Cells(cn_compareRowOff + 2, 2), .Cells(tableBottomRow, 9))
            .Borders(xlEdgeLeft).LineStyle = xlNone
            .Borders(xlEdgeTop).LineStyle = xlNone
            .Borders(xlEdgeBottom).LineStyle = xlNone
            .Borders(xlEdgeRight).LineStyle = xlNone
        End With
        .Range(.Cells(cn_compareRowOff + 1, 2), .Cells(tableBottomRow, 2)).BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
        .Range(.Cells(cn_compareRowOff + 1, 3), .Cells(tableBottomRow, 5)).BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
        .Range(.Cells(cn_compareRowOff + 1, 7), .Cells(tableBottomRow, 9)).BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
        With .Range(.Cells(cn_compareRowOff + 1, 1), .Cells(cn_compareRowOff + 1, 9)).Borders(xlEdgeBottom)
            .LineStyle = xlContinuous
            .Weight = xlMedium
            .ColorIndex = xlAutomatic
        End With
        With .Range(.Cells(tableBottomRow, 1), .Cells(tableBottomRow, 9)).Borders(xlEdgeBottom)
            .LineStyle = xlContinuous
            .Weight = xlMedium
            .ColorIndex = xlAutomatic
        End With

'Debug.Print "rebuildTableAndPlots (D)"
        
        ' clean-up below table
        Set used = .usedRange
        Do While .usedRange.row + .usedRange.Rows.Count > tableBottomRow + 1
            .Rows(tableBottomRow + 1).Delete
        Loop

'Debug.Print "rebuildTableAndPlots (E)"
        
        ' minimum empty space between table and plots
Const space As Long = 2
Dim chObj As ChartObject, plotsTopRow As Long
        If .ChartObjects.Count > 0 Then
            Set chObj = .ChartObjects(1)
            plotsTopRow = chObj.TopLeftCell.row
            Do While plotsTopRow <= tableBottomRow + space
                .Rows(tableBottomRow + 2).Insert
                plotsTopRow = chObj.TopLeftCell.row
            Loop
        End If
        
' print area, page breaks, scale factor
Dim breakCount As Long, plotCount As Long, ch As Chart
Dim brCell As Range, bottomRow As Long, rightClm As Long, area As Range
Dim hBreak1 As Range, hBreak2 As Range

    ' With cmpSheet (cont'd)
On Error GoTo PAGEBREAK_ERROR

'Debug.Print "rebuildTableAndPlots (F)"
        
        breakCount = .HPageBreaks.Count
        plotCount = 0
        If Not .ChartObjects Is Nothing Then
            plotCount = .ChartObjects.Count
        End If
        
        rightClm = 11
        bottomRow = getLastRow(.usedRange)
        .Columns(rightClm).Delete
        .Columns(rightClm).ColumnWidth = 3.1
            
        ' reset PageSetup
        With .PageSetup
            .Orientation = xlLandscape
            .CenterHorizontally = True
            .CenterVertically = True
            .PrintGridlines = .PrintGridlines ' don't touch; matter of taste
            
            .Zoom = False
            .FitToPagesWide = 1
            .FitToPagesTall = 1
        End With

'Stop

' To remove all manual page breaks on a worksheet, set Cells.PageBreak to xlPageBreakNone.
'            .Cells.PageBreak = xlPageBreakNone  ' Die PageBreak-Eigenschaft des Range-Objektes kann nicht zugeordnet werden.
'Debug.Print .Cells.PageBreak
'Debug.Print .usedRange.PageBreak
'Debug.Print .usedRange.Cells(1, 1).PageBreak

'Debug.Print "rebuildTableAndPlots (G)"
        
        .ResetAllPageBreaks
        ' voodoo: ResetAllPageBreaks issue
'Dim i As Long
'        For i = 1 To 1000
'            DoEvents
'        Next
'        Do While .HPageBreaks.Count > 0
'            .HPageBreaks(1).Delete
'            .ResetAllPageBreaks
'        Loop
'        Do While .VPageBreaks.Count > 0
'            .VPageBreaks(1).Delete
'        Loop
        If .HPageBreaks.Count > 0 Then
            .HPageBreaks(1).Delete
            .ResetAllPageBreaks
        End If
        If .VPageBreaks.Count > 0 Then
            .VPageBreaks(1).Delete
            .ResetAllPageBreaks
        End If
            
        ' insert page breaks
        ' get posistions
        With .PageSetup
            bottomRow = getLastRow(cmpSheet.usedRange)
            If plotCount > 0 Then
                ' break before Chart1
                Set chObj = cmpSheet.ChartObjects(1)
                row = chObj.TopLeftCell.row - 1
                Set hBreak1 = cmpSheet.Cells(row, 1)
                Set brCell = chObj.BottomRightCell
                bottomRow = brCell.row + 1
                clm = brCell.Column + 1
                If (chObj.Left + chObj.width < brCell.Left + 1) Then
                    clm = brCell.Column
                End If
                If clm > rightClm Then
                    rightClm = clm
                End If
            End If
            If plotCount > 1 Then
                ' break before Chart2
                Set chObj = cmpSheet.ChartObjects(2)
                Set ch = chObj.Chart
                row = chObj.TopLeftCell.row - 1
                Set hBreak2 = cmpSheet.Cells(row, 1)
                Set brCell = chObj.BottomRightCell
                bottomRow = brCell.row + 1
                If (chObj.Top + chObj.height < brCell.Top + 2) Then
                    bottomRow = brCell.row
                End If
                clm = brCell.Column + 1
                If (chObj.Left + chObj.width < brCell.Left + 2) Then
                    clm = brCell.Column
                End If
                If clm > rightClm Then
                    rightClm = clm
                End If
             End If
            
            ' set zoom factor
Dim pageHeight As Double, zoomFactor As Long
            Set area = cmpSheet.Range(cmpSheet.Cells(1, 1), cmpSheet.Cells(bottomRow, rightClm))
            zoomFactor = 75
'Debug.Print cmpSheetName, area
            .PrintArea = area.Address
            If (Not hBreak1 Is Nothing) Then
            pageHeight = .TopMargin + .BottomMargin + (hBreak1.row - 1) * hBreak1.height
'Debug.Print area.Height, hBreak1.row, .TopMargin, .BottomMargin, hBreak1.Height, pageHeight
            If pageHeight > 694.2 Then    ' reference height (measured)
                zoomFactor = 694.2 / pageHeight * 75
                zoomFactor = (zoomFactor \ 5) * 5 ' in steps of 5
            End If
            End If
            .Zoom = zoomFactor
        End With ' cmpSheet.PageSetup
        

'Debug.Print "rebuildTableAndPlots (H)"
        
        ' insert breaks
        If (Not hBreak1 Is Nothing) Then .HPageBreaks.Add before:=hBreak1
        If (Not hBreak2 Is Nothing) Then .HPageBreaks.Add before:=hBreak2
            
        ' finish up worksheet
'        .Cells(2, 5).Select
        .Cells(1, 1).Select
        .Cells.Locked = True
        
        protectSheet cmpSheet
        .visible = visibility
    End With    'cmpSheet

    ' update plots
'Debug.Print "rebuildTableAndPlots: ", "entering updatePlots"
'    updatePlots srcSheet, sError, False
    updatePlots srcSheet, Nothing, sError
    srcSheet.Activate
    
    Application.EnableEvents = eventsFlag
    rebuildTableAndPlots = True
    sError = ""
Exit Function

PAGEBREAK_ERROR:
    Debug.Print Err.Description
    Err.Clear
    Resume Next

End Function

' Aufruf durch  (*) Men|fffd|: f|fffd|r aktuellen Bereich (Eingabe | Soll-Ist)
'               (*) Wechsel Berichtsmonat auf Hauptseite
'               (*) deaktiviert: Klick auf Zelle "Grafik" in einem Soll/Ist-Vergleich (~> handleSheetSelectionChange(..))

' wrapper: menu item "Soll/Ist-Vergleich"
Function performanceAnalysis(Optional checked As Range = Nothing, Optional rebuild As Boolean = False)
Dim srcSheet As Worksheet, mainSheet As Worksheet, cmpSheet As Worksheet, dtaSheet As Worksheet, ws As Worksheet, monthCell As Range
Dim srcName As String, cmpMonth As String, row As Long
Dim chrt As Chart, details() As String, monthName As String, sYear As String
Dim sError As String, eventsFlag As Boolean
    
    If (gs_MainSheetName = "" Or gs_currentMonthName = "") Then
        Set mainSheet = validateMainSheet(sError)
        If (mainSheet Is Nothing) Then
            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
        End If
    Else
        Set mainSheet = getSheet(gs_MainSheetName)
    End If
    
    ' active: either input sheet or analysis (comparison) sheet, diagramm possibly out of sync
    
    If (TypeOf Application.ActiveWorkbook.ActiveSheet Is Chart) Then
        ' ToDo: update chart possibly out-of-sync
        Set chrt = ActiveChart
        details = getDetailsChart(chrt, sError)
        monthName = details(5)
        sYear = details(6)
        
        Set monthCell = mainSheet.Cells(gn_monthRow, 3)
        If (Not updateLiquiCharts(monthCell, sError)) Then
            If sError <> "" Then MsgBox sError, vbInformation, cs_MsgTitle
        End If
        chrt.Activate
Exit Function
    End If
    
    Set srcSheet = Application.ActiveWorkbook.ActiveSheet
    
    Set cmpSheet = getSheet(getCompareSheetName(srcSheet.name))
    If (cmpSheet Is Nothing) Then
        Set ws = getSourceSheet(srcSheet)
        If (ws Is Nothing) Then
Exit Function
        End If
        Set srcSheet = ws
        Set cmpSheet = getSheet(getCompareSheetName(srcSheet.name))
    End If
    If (cmpSheet Is Nothing) Then
        MsgBox "Blatt '" & getCompareSheetName(srcSheet.name) & "' nicht gefunden; wird erneuert.", vbExclamation, cs_MsgTitle
'Exit Function
        ' create missing analytics sheet
        eventsFlag = Application.EnableEvents
        Application.EnableEvents = False
        Set cmpSheet = Application.ActiveWorkbook.Worksheets.Add(after:=ActiveWorkbook.Worksheets(ActiveWorkbook.Worksheets.Count))
        If (Not unprotectSheet(cmpSheet, True)) Then
Exit Function
        End If
        With cmpSheet
            .name = getCompareSheetName(srcSheet.name)
            .Columns(1).ColumnWidth = 3.11
            .Columns(2).ColumnWidth = 32.22
            
            .Cells(2, 5).formula = "='" & srcSheet.name & "'!$H$4"
            .Cells(3, 5).formula = "='" & srcSheet.name & "'!$H$5"
            .Cells(4, 5).formula = "='" & srcSheet.name & "'!$H$7"
            .Cells(6, 5).formula = cs_titlePerformanceAnalysis
            
            .Range(.Cells(2, 5), .Cells(6, 5)).HorizontalAlignment = xlCenter
            .Range(.Cells(2, 5), .Cells(6, 5)).Font.Bold = True
            .Columns(cn_clm_PlotCheck).HorizontalAlignment = xlCenter
        End With
        Application.EnableEvents = eventsFlag
        If (Not go_SheetsWarden Is Nothing) Then go_SheetsWarden.updateLists
    End If
    If (Not unprotectSheet(cmpSheet, True)) Then
Exit Function
    End If
    cmpSheet.visible = xlSheetVisible
'    ActiveWindow.ScrollRow = getLastRow(cmpSheet.usedRange) + 1 ' below table bottom row

'    Set dtaSheet = getSheet(cs_PlotData)
    Set dtaSheet = findOrCreateWorksheet(cs_PlotData)
    If (Not unprotectSheet(dtaSheet, True)) Then
Exit Function
    End If
    Set dtaSheet = getSheet(cs_GraphicsData)
    If (Not unprotectSheet(dtaSheet, True)) Then
Exit Function
    End If
    
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    
Dim checkPlots As Boolean
    checkPlots = False
    If (srcSheet.name = cmpSheet.name And Not checked Is Nothing) Then
        If (checked.Column = cn_clm_PlotCheck And Not isRangeEmpty(checked) And Not gb_isAddPlotsDenied) Then
            checkPlots = True
        End If
    End If
    
    
    
    ' active: either input sheet or analysis (comparison) sheet
    ' is PA sheet up-to-date ?
    cmpMonth = "xxxxx"
    With cmpSheet
        For row = 1 To getLastRow(.usedRange)
'            If (.Cells(row, 2) = cs_headerPerformanceAnalysis) Then
            If (startsWith(.Cells(row, 2), "Soll")) Then
                cmpMonth = .Cells(row, 3)
                Exit For
            End If
        Next
    End With
    If (cmpMonth = "") Then cmpMonth = cs_NoMonth
    If (rebuild Or cmpMonth <> gs_currentMonthName) Then
        If (Not rebuildTableAndPlots(srcSheet.Cells(gn_monthRow, 3), sError)) Then
            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
        End If
    
'    ElseIf Not updatePlots(srcSheet, sError, checkPlots) Then
    ElseIf Not updatePlots(srcSheet, checked, sError) Then
        If sError <> "" Then MsgBox sError, vbInformation, cs_MsgTitle
    End If

    If (srcSheet.name = gs_MainSheetName) Then
        If (gn_monthRow = 0) Then validateMainSheet sError
        If (gn_monthRow = 0) Then Exit Function
        Set monthCell = srcSheet.Cells(gn_monthRow, 3)
        updateLiquiCharts monthCell, sError
    End If
    
    protectSheet dtaSheet
'    protectSheet cmpSheet
    
    cmpSheet.Activate
    
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.StatusBar = False
End Function

'Function updatePlots(srcSheet As Worksheet, sError As String, checkPlots As Boolean) As Boolean
Function updatePlots(srcSheet As Worksheet, checked As Range, sError As String) As Boolean
' to be called
'   a) when master data are being saved
'   b) current month changes
'   c) after plot dialog (right-click) ???

'   called by ProcessMonthChange/updateReports/rebuildTableAndPlots for each profit center

Dim masterSheet As Worksheet, cmpSheet As Worksheet, plotDataSheet As Worksheet    ' ,plotSheet As Worksheet
Dim plotDataSheetName As String, cmpSheetName As String
Dim srcRow As Long, srcClm As Long, trgRow As Long, trgClm As Long
Dim monthName As String, month As Long, year As Long

Dim first As Long, last As Long, row As Long, clm As Long
Dim notFound As Boolean
Dim formula As String
Dim idx As Long, msg As String, step As String, tmp As String, value As Variant

Dim isDataProtected As Boolean, isPlotsProtected As Boolean, visibility As XlSheetVisibility, eventsFlag As Boolean
Dim checkPlots As Boolean


    updatePlots = False

On Error Resume Next
On Error GoTo CHART_ERROR
    step = "validate"
    If srcSheet Is Nothing Then
Exit Function
    End If

    Set masterSheet = getSheet(getMasterSheetName(srcSheet.name)) '
    If masterSheet Is Nothing Then
        sError = "Blatt mit Plandaten f|fffd|r '" & srcSheet.name & "' nicht gefunden."
Exit Function
    End If
    
    plotDataSheetName = cs_PlotData
    Set plotDataSheet = findOrCreateWorksheet(plotDataSheetName)
    If (plotDataSheet Is Nothing) Then
        sError = "Blatt '" & plotDataSheetName & "' nicht gefunden."
Exit Function
    ElseIf (Not unprotectSheet(plotDataSheet, True)) Then
Exit Function
    End If
'    plotDataSheet.Visible = xlSheetHidden

'Debug.Print "updatePlots(..)", srcSheet.name
    
    'performance analysis (table and plots) for source
    cmpSheetName = getCompareSheetName(srcSheet.name)
    Set cmpSheet = getSheet(cmpSheetName)
    If cmpSheet Is Nothing Then
        ' get copy of 'master' compare sheet
Dim cmpSheet2 As Worksheet
        Set cmpSheet2 = getSheet(cs_CompareSheetName)
        If cmpSheet2 Is Nothing Then
            sError = "Vorlage '" & cs_CompareSheetName & "' nicht gefunden."
Exit Function
        End If
        ' ! .copy copies code as well !
        cmpSheet2.Copy before:=cmpSheet2
        ' locate copy (.copy is not a function but copy becomes the active sheet)
        If InStr(1, ActiveSheet.name, cs_CompareSheetName & " (") = 1 Then
            Set cmpSheet = ActiveSheet
        Else
            For idx = 1 To ActiveWorkbook.Worksheets.Count
                If ActiveWorkbook.Worksheets(idx).name = cs_CompareSheetName Then
                    Set cmpSheet = ActiveWorkbook.Worksheets(idx - 1)
                    Exit For
                End If
            Next
        End If
        If cmpSheet Is Nothing Then
            sError = "Blatt mit Soll-Ist f|fffd|r '" & srcSheet.name & "' nicht gefunden."
Exit Function
        End If
'Debug.Print cmpSheet.name
        cmpSheet.name = cmpSheetName
        ' company name should be name of profit center (srcSheet.name)
'        isPlotsProtected = cmpSheet.ProtectContents
'        cmpSheet.Unprotect cs_LiquiPWD
        If (Not unprotectSheet(cmpSheet, True)) Then
Exit Function
        End If
        
'        Application.Calculation = xlCalculationManual
'        ActiveWorkbook.UpdateLinks = xlUpdateLinksNever
        For clm = 2 To 9
            tmp = cmpSheet.Cells(2, clm).formula
            If (startsWith(tmp, "=")) Then
'                idx = InStr(tmp, "!")
'                If (idx > 0) Then
'                    tmp = Mid(tmp, idx)
'                    tmp = "='" & srcSheet.name & " '" & tmp
'
'                    cmpSheet.Cells(2, clm) = tmp    ' Excel wants to update links in srcSheet
'                    Exit For
'                End If
                cmpSheet.Cells(2, clm) = srcSheet.name
                Exit For
            End If
'        ActiveWorkbook.UpdateLinks = xlUpdateLinksAlways
        Next
    ElseIf (Not unprotectSheet(cmpSheet, True)) Then
Exit Function
    ElseIf (cmpSheet.visible = xlSheetHidden) Then
        updatePlots = True
Exit Function
    End If  ' cmpSheet Is Nothing
    
'Debug.Print "updatePlots(..)", cmpSheet.name
Application.StatusBar = cmpSheet.name
    
    'validate row titles
    clm = 2
    findTextOrFormula srcSheet, "Kontokorrent - Kredit", True, True, row, clm, , 2
    last = row
    If clm = 0 Then
        sError = "Abschnittsgrenzen nicht erkennbar (Kontokorrent - Kredit)."
        Exit Function
    End If

    'compare row titles
    With masterSheet
        If Not isRangeEmpty(.Range(.Cells(1, 2), .Cells(2, last))) Then
            With srcSheet
                For row = 1 To last
                    If srcSheet.Cells(row, 2) <> .Cells(row, 2) Then
                        sError = "Aktuelle Daten nicht mehr konsistent mit Plandaten"
                        sError = sError & vbLf & "Zeile: " & idx & ":  " & srcSheet.name & " || " & .name
                        sError = sError & vbLf & "'" & srcSheet.Cells(row, 2) & "' != '" & .Cells(row, 2) & "'"
                        srcSheet.Activate
                        srcSheet.Rows(row).Select
Exit Function
                    End If
                Next
            End With
        End If
    End With


'determine source range
    notFound = False
    row = 20
    clm = 2
    findTextOrFormula srcSheet, "III. ", True, True, row, clm, , 2
    If clm = 0 Then notFound = True
    first = row + 2
    findTextOrFormula srcSheet, "G. u. V.", True, True, row, clm, , 2
    last = row
    If clm = 0 Then notFound = True

    If notFound Then
        sError = "Soll/Ist-Vergleich: Abschnittsgrenzen nicht erkennbar (III. bis G. u. V.)."
Exit Function
    End If


' validate target and actual
    For srcRow = 1 To last - first + 1
        idx = first + srcRow - 1
        If Not masterSheet Is Nothing Then
            If srcSheet.Cells(idx, 2) <> masterSheet.Cells(idx, 2) Then
                sError = "Soll/Ist-Vergleich: Aktuelle Daten nicht mehr konsistent mit Plandaten: Zeile " _
                    & idx & " - " & masterSheet.Cells(idx, 2)
                masterSheet.visible = True
Exit Function
            End If
        End If
    Next

    eventsFlag = Application.EnableEvents
Application.EnableEvents = False

' Firmenname/Profitcenter, Wirtschaftsjahr, Berichtsmonat, W|fffd|hrung
Dim companyName As String, unit As String
    companyName = srcSheet.Cells(gn_yearRow - 1, 3)
    year = srcSheet.Cells(gn_yearRow, 3)
    unit = srcSheet.Cells(gn_yearRow + 1, 3)
    monthName = srcSheet.Cells(gn_monthRow, 3)
    month = monthToNumber(monthName)

    ' plot data sources: section with two sub sections (month, accrued) for each input sheet
    ' find, remove existing, append new
    step = "chart data sources"
    With plotDataSheet
        visibility = .visible
        .visible = xlSheetVisible
'        isDataProtected = .ProtectContents
'        .Unprotect Password:=cs_LiquiPWD

Dim sectStart As Long, sectEnd As Long, maxDataRow As Long
        maxDataRow = 0
        If Not IsEmpty(.usedRange) Then
            maxDataRow = getLastRow(.usedRange)
        End If
        'maxDataRow may be > 1 yet all rows are empty
        If maxDataRow > 0 Then
            Do While isRangeEmpty(.Rows(maxDataRow))
                .Rows(maxDataRow).Delete
                maxDataRow = maxDataRow - 1
                If maxDataRow = 0 Then Exit Do
            Loop
        End If
        
        row = 1: clm = 1
        findTextOrFormula plotDataSheet, "[" & srcSheet.name & "]", True, True, row, clm, , 1
        sectStart = row
        row = row + 1
        If sectStart > 0 Then
            findTextOrFormula plotDataSheet, "[", True, True, row, clm, , 1
            If row > 0 Then
                sectEnd = row - 1
            Else
                sectEnd = maxDataRow + 1
            End If
'Debug.Print sectStart, sectEnd
            ' .clear, replace; delete, append would destroy other plots
            .Range(.Cells(sectStart, 1), .Cells(sectEnd, 255)).Clear
        ElseIf IsEmpty(.Cells(1, 1)) Then
            sectStart = 1
        Else
            sectStart = maxDataRow + 4 ' three blank rows separating
        End If
        
        ' build section: create headers, empty data
        .Cells(sectStart, 1) = "[" & srcSheet.name & "]"
        .Cells(sectStart + cn_rowOffMonthly + 1, 1) = companyName & "  " & year & ""
        .Cells(sectStart + cn_rowOffMonthly + 2, 1) = "Soll/Ist-Vergleich  " & monthName

        .Cells(sectStart + cn_rowOffAccrued + 1, 1) = companyName & "  " & year & ""
        .Cells(sectStart + cn_rowOffAccrued + 2, 1) = "Soll/Ist-Vergleich  " & monthName & ", aufgelaufen"

Dim variable As String, caption As String, checkedVars As String, foundTable As Boolean
Dim isDataSelected As Boolean
Dim tableHeaderRow As Long, maxRow As Long
        cmpSheetName = cmpSheet.name
        With cmpSheet.usedRange
            maxRow = .row + .Rows.Count - 1
        End With
        foundTable = False
        trgClm = 1
        
        ' look for checked quantities (cn_clm_PlotCheck) below header row ("Grafik")
        ' collect plot data on plot data sheet; links to comparison sheet, not to respective input sheet
        ' reset protection: all cells but plot check locked
        ' comparison sheet remains unchanged otherwise (cf. rebuildTableAndPlots for update)
        cmpSheet.Cells.Locked = True
        isDataSelected = False
        For row = 1 To maxRow
            variable = cmpSheet.Cells(row, 2).value
            checkedVars = Trim$(cmpSheet.Cells(row, cn_clm_PlotCheck).value)
            If checkedVars = "Grafik" Then
                foundTable = True
                tableHeaderRow = row
                GoTo continue_row
            End If
            If foundTable Then
                cmpSheet.Cells(row, cn_clm_PlotCheck).Locked = False
            End If
            If Not foundTable Or checkedVars = "" Then
                GoTo continue_row
            End If
            If Not (variable = "" _
                    Or startsWith(variable, "Soll") _
                    Or variable = "Zus|fffd|tzliche Gr|fffd||fffd|en") Then
'                    Or variable = cs_headerPerformanceAnalysis
                isDataSelected = True
                caption = plotItemName(cmpSheet.Cells(row, 2), cn_seriesNameLength)
                    
                ' monthly
                .Cells(sectStart + cn_rowOffMonthly + 3, trgClm) = caption
                .Cells(sectStart + cn_rowOffMonthly + 4, trgClm) = "Plan"
                .Cells(sectStart + cn_rowOffMonthly + 4, trgClm + 1) = "Ist"

                formula = "='" + cmpSheetName + "'!R" & (row) & "C3"
                .Cells(sectStart + cn_rowOffMonthly + 5, trgClm).FormulaR1C1 = formula
                formula = "='" + cmpSheetName + "'!R" & (row) & "C4"
                .Cells(sectStart + cn_rowOffMonthly + 6, trgClm + 1).FormulaR1C1 = formula

                ' accrued
                .Cells(sectStart + cn_rowOffAccrued + 3, trgClm) = caption
                .Cells(sectStart + cn_rowOffAccrued + 4, trgClm) = "Plan"
                .Cells(sectStart + cn_rowOffAccrued + 4, trgClm + 1) = "Ist"

                formula = "='" + cmpSheetName + "'!R" & (row) & "C7"
                .Cells(sectStart + cn_rowOffAccrued + 5, trgClm).FormulaR1C1 = formula
                formula = "='" + cmpSheetName + "'!R" & (row) & "C8"
                .Cells(sectStart + cn_rowOffAccrued + 6, trgClm + 1).FormulaR1C1 = formula

                trgClm = trgClm + 2
            End If
continue_row:
        Next
        
'         .Cells.Locked = True
'        If isDataProtected Then protectSheet plotDataSheet, ""
        protectSheet plotDataSheet, lockCells:=True, isLocked:=True
        .visible = visibility
    End With ' plotDataSheet
        
' plots (chart objects of performance analysis sheet)
    step = "plots"
    With cmpSheet
        .Activate
'        isPlotsProtected = .ProtectContents
'        .Unprotect

' minimum empty space between table and plots
Const space As Long = 2
Dim uRng As Range, tableBottomRow As Long
Dim chObj As ChartObject, plotTopRow As Long
Dim l As Long, t As Long, w As Long, h As Long
        Set uRng = .usedRange
        tableBottomRow = getLastRow(uRng)
        If .ChartObjects.Count > 0 Then
            Set chObj = .ChartObjects(1)
            plotTopRow = chObj.TopLeftCell.row
            Do While plotTopRow <= tableBottomRow + space
                .Rows(tableBottomRow + 2).Insert
                plotTopRow = chObj.TopLeftCell.row
            Loop
        End If
        l = .Columns(2).Left
        t = .Rows(tableBottomRow + space + 1).Top
        w = .Columns(10).Left - l - 1 ' B - I
        h = 25 * .Rows(tableBottomRow + space + 1).RowHeight - 1

Dim chMonth As Chart, chAccrued As Chart, ch As Chart
Dim plotCount As Long, addPlots As Boolean, ync As Long
        plotCount = 0
        If Not .ChartObjects Is Nothing Then
            plotCount = .ChartObjects.Count
        End If
        
        checkPlots = False
        addPlots = False
        If (Not checked Is Nothing) Then
            Set checked = .Range(.Cells(cn_compareRowOff + 2, cn_clm_PlotCheck), .Cells(getLastRow(.usedRange), cn_clm_PlotCheck))
            checkPlots = (Not isRangeEmpty(checked) And Not gb_isAddPlotsDenied)
            If isRangeEmpty(checked) Then
                gb_isAddPlotsDenied = False
            End If
        End If
        
        If plotCount < 2 And checkPlots Then
'            ync = MsgBox("Fehlende Soll/Ist-Grafiken hinzuf|fffd|gen ?", vbYesNoCancel, cs_MsgTitle)
'            If ync = vbCancel Or (plotCount = 0 And ync = vbNo) Then
''                .Cells(cn_compareRowOff + 1, 3).Select
'                .Cells(1, 1).Select
'                If isPlotsProtected Then protectSheet cmpSheet, ""
'                Application.EnableEvents = eventsFlag
'                updatePlots = True
'Application.EnableEvents = eventsFlag
'Exit Function
'            Else
'                addPlots = (ync = vbYes)
'                gb_isAddPlotsDenied = Not addPlots
'            End If
            ync = MsgBox("Fehlende Soll/Ist-Grafiken hinzuf|fffd|gen ?", vbYesNo, cs_MsgTitle)
            If (ync = vbNo) Then
'                .Cells(cn_compareRowOff + 1, 3).Select
                .Cells(1, 1).Select
                If isPlotsProtected Then protectSheet cmpSheet, ""
                Application.EnableEvents = eventsFlag
                updatePlots = True
                gb_isAddPlotsDenied = True
Application.EnableEvents = eventsFlag
Exit Function
            Else
                addPlots = True
                gb_isAddPlotsDenied = False
            End If
        End If
        
Dim shp As Shape, xAxis As Axis, yAxis As Axis
Dim versionOffice As Long
        If plotCount = 0 And addPlots Then
            Set shp = .Shapes.AddChart(xlColumnClustered, l, t, w, h)
            Set ch = shp.Chart
            
            If ch.HasLegend Then ch.Legend.Delete
            
            Set xAxis = ch.Axes(xlCategory)
            With xAxis
                .TickLabels.MultiLevel = True
                .TickLabelPosition = xlLow
            End With
            
            Set yAxis = ch.Axes(xlValue)
            tmp = srcSheet.Cells(gn_yearRow + 1, 3)
            With yAxis
                .HasTitle = True
                .AxisTitle.Text = tmp  ' "Euro"
                .AxisTitle.Orientation = xlUpward
                .CrossesAt = 0
            End With
            
            versionOffice = val(Application.Version)
            If (versionOffice >= 15) Then
                ch.ClearToMatchStyle
                ch.ChartStyle = 205
            Else
                ch.ClearToMatchStyle
                ch.ChartStyle = 34
            End If
            plotCount = 1
        End If
        
        If plotCount = 1 And addPlots Then
            Set chObj = .ChartObjects(1)
            chObj.Left = l
            chObj.Top = t
            
            Set ch = chObj.Chart
            ch.ChartArea.Copy
            plotTopRow = chObj.BottomRightCell.row + space + 1
            .Cells(plotTopRow, 2).Select ' upper left corner of chart pasted
            .Paste
            plotCount = 2
        End If
        
        Set chMonth = Nothing
        Set chAccrued = Nothing
        If plotCount >= 2 Then
            Set chMonth = .ChartObjects(1).Chart
            Set chAccrued = .ChartObjects(2).Chart
        ElseIf plotCount = 1 Then
            Set ch = .ChartObjects(1).Chart
            If InStr(1, ch.ChartTitle.Text, ", aufgelaufen") = 0 Then
                Set chMonth = ch
            Else
                Set chAccrued = ch
            End If
        End If
    End With ' cmpSheet
    
    ' plot data
    With plotDataSheet
' Chart1: individual month
    step = "Chart1"
    If Not chMonth Is Nothing Then
        Set ch = chMonth
        ch.HasTitle = True
        ch.ChartTitle.Text = .Cells(sectStart + cn_rowOffMonthly + 1, 1) & vbLf & .Cells(sectStart + cn_rowOffMonthly + 2, 1)
        ' reset chart if no variables selected
        If trgClm < 3 Then trgClm = 3
'        If trgClm > 1 Then
            ch.SetSourceData _
                source:=.Range(.Cells(sectStart + cn_rowOffMonthly + 3, 1), .Cells(sectStart + cn_rowOffMonthly + 6, trgClm - 1)), _
                PlotBy:=xlRows
'        End If

        ' axes
Dim minVal As Double, maxVal As Double
Dim maxScale As Long

        minVal = 0: maxVal = 0
        If isDataSelected Then
            For row = sectStart + cn_rowOffMonthly + 5 To sectStart + cn_rowOffMonthly + 6
            For clm = 1 To trgClm - 1
                If .Cells(row, clm) < minVal Then
                    minVal = .Cells(row, clm)
                End If
                If .Cells(row, clm) > maxVal Then
                    maxVal = .Cells(row, clm)
                End If
            Next: Next
        End If
        maxScale = getScale(maxVal)
        
On Error Resume Next
        With ch.Axes(xlValue)
            .AxisTitle.Text = unit
If False Then ' leave to user
            .HasDisplayUnitLabel = False
            If maxVal > 20000 Then
                .HasDisplayUnitLabel = True
                .DisplayUnit = xlThousands
            End If
End If
            .TickLabels.NumberFormat = "0" ' no grouping
            .MaximumScale = maxScale
            .MajorUnit = maxScale / 5
'            .Crosses = xlAutomatic
'            If minVal < 0 Then
'                .Crosses = xlCustom
'                .CrossesAt = -.MajorUnit
'                Do While minVal < .CrossesAt
'                    .CrossesAt = .CrossesAt - .MajorUnit
'                Loop
'            End If
            .CrossesAt = 0
        End With
On Error GoTo CHART_ERROR

        With ch.Axes(xlCategory)
            .TickLabels.MultiLevel = True
            .TickLabelPosition = xlLow
        End With
    End If
    
' Chart2: accrued
    step = "Chart2"
    If Not chAccrued Is Nothing Then
        Set ch = chAccrued
        ch.HasTitle = True
        ch.ChartTitle.Text = .Cells(sectStart + cn_rowOffAccrued + 1, 1) & vbLf & .Cells(sectStart + cn_rowOffAccrued + 2, 1)
        If trgClm < 3 Then trgClm = 3
        ch.SetSourceData _
            source:=.Range(.Cells(sectStart + cn_rowOffAccrued + 3, 1), .Cells(sectStart + cn_rowOffAccrued + 6, trgClm - 1)), _
            PlotBy:=xlRows

        minVal = 0: maxVal = 0
        If isDataSelected Then
            For row = sectStart + cn_rowOffAccrued + 5 To sectStart + cn_rowOffAccrued + 6
            For clm = 1 To trgClm - 1
                If .Cells(row, clm) < minVal Then
                    minVal = .Cells(row, clm)
                End If
                If .Cells(row, clm) > maxVal Then
                    maxVal = .Cells(row, clm)
                End If
            Next: Next
        End If
        maxScale = getScale(maxVal)
        
On Error Resume Next
        With ch.Axes(xlValue)
            .AxisTitle.Text = unit
If False Then ' leave to user
            .HasDisplayUnitLabel = False
            If maxVal > 20000 Then
                .HasDisplayUnitLabel = True
                .DisplayUnit = xlThousands
            End If
End If
            .TickLabels.NumberFormat = "0" ' no grouping
            .MaximumScale = maxScale
            .MajorUnit = maxScale / 5
'            .Crosses = xlAutomatic
'            If minVal < 0 Then
'                .Crosses = xlCustom
'                .CrossesAt = -.MajorUnit
'                Do While minVal < .CrossesAt
'                    .CrossesAt = .CrossesAt - .MajorUnit
'                Loop
'            End If
            .CrossesAt = 0
        End With
On Error GoTo CHART_ERROR

        With ch.Axes(xlCategory)
            .TickLabels.MultiLevel = True
            .TickLabelPosition = xlLow
        End With
    End If
    End With    'plotDataSheet
        
step = "finish update: "
'    ' scroll to top of charts
'    If checkPlots Then Application.ActiveWindow.ScrollRow = tableBottomRow + 1
    ' keep user scroll position
    row = Application.ActiveWindow.ScrollRow
    If (cmpSheet.visible = xlSheetVisible) Then
'        cmpSheet.Cells(cn_compareRowOff + 1, 3).Select
        cmpSheet.Cells(1, 1).Select
    End If
    If checkPlots Then Application.ActiveWindow.ScrollRow = row
    
'    If isPlotsProtected Then protectSheet cmpSheet, ""
'    protectSheet cmpSheet, lockCells:=True, isLocked:=True
    With cmpSheet
        .Unprotect
        .Cells.Locked = True
        .Range(.Cells(tableHeaderRow + 2, cn_clm_PlotSelection), .Cells(tableBottomRow, cn_clm_PlotSelection)).Locked = False
        protectSheet cmpSheet
    End With
    
Application.EnableEvents = eventsFlag
    updatePlots = True
Exit Function

CHART_ERROR: ' develop
Debug.Print plotDataSheet.name, IIf(Not (cmpSheet Is Nothing), cmpSheet.name, "")
Debug.Print step, Err.Description
    Err.Clear
    Resume Next
    
End Function

Sub selectCompareSheetTitle(cmpSh As Worksheet)

End Sub


' wrapper: called by menu action
'        single variable (standard or custom): line chart, with or w/o accumulation
'           ||
'        several variables: new type of chart (clustered columns), no accumulation
Function doAddOrRemoveChart()
Dim srcSheet As Worksheet, sh As Object
Dim srcRange As Range, rng As Range, cll As Range
Dim isInputRange As Boolean
Dim idx As Long
Dim msg As String, sError As String
    
    Set sh = Nothing
    sError = ""
    If gs_MainSheetName = "" Or gn_MainSheetIndex = 0 Then
        Set sh = validateMainSheet(sError)
        If sh Is Nothing Then
            If sError <> "" Then MsgBox sError, vbExclamation, cs_MsgTitle
            Exit Function
        End If
    End If
    
    Set srcRange = Nothing
On Error Resume Next ' skip non-range (type error)
    Set srcRange = Application.Selection ' selection on active sheet
On Error GoTo 0
    If srcRange Is Nothing Then
        msg = "Keine Plangr|fffd||fffd|e ausgew|fffd|hlt."
        MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
    End If
    Set srcSheet = srcRange.parent
    If Not isMainOrPC(srcSheet, idx) Then
        msg = "Bitte Gr|fffd||fffd|e auf einem Eingabeblatt w|fffd|hlen."
        MsgBox msg, vbExclamation, cs_MsgTitle
Exit Function
    End If
'Debug.Print srcSheet.name
        
    ' quantities selected: comma separated list of row numbers
    With srcRange
Dim rowList As String, seriesCount As Long
        rowList = ""
        seriesCount = 0
        For Each cll In .Cells ' in order of being selected
            If InStr(1, rowList, cll.row & ",") = 0 Then
                rowList = rowList & cll.row & ","
                seriesCount = seriesCount + 1
            End If
        Next
'Debug.Print rowList
        If seriesCount = 0 Then
            ' nothing to do
            msg = "Keine Gr|fffd||fffd|e ausgew|fffd|hlt."
            MsgBox msg, vbInformation, cs_MsgTitle
Exit Function
        End If
        ' clean-up graphics data sheet
        processSheetsDeleted ""
        If seriesCount = 1 Then
            ' single variable (standard or custom)
            addSimpleChart
        Else
            ' several variables: type of chart = clustered columns
            addMultiChart
        End If
    End With
End Function

Function addSimpleChart()
Dim mainSheet As Worksheet, dtaSheet As Worksheet, ch As Chart
Dim srcSheet As Worksheet, srcRange As Range, usedRange As Range
Dim first As Long, last As Long
Dim srcRow As Long, row As Long, clm As Long, idx As Long
Dim quantity As String, nameCh As String
Dim msg As String, sError As String

'    Set mainSheet = validateMainSheet(sError)
'    If mainSheet Is Nothing Then
'        MsgBox sError, vbCritical, cs_MsgTitle
'Exit Function
'    End If
    
    Set srcRange = Application.ActiveCell
    Set srcSheet = srcRange.parent
    srcRow = srcRange.row
    
    Set dtaSheet = getSheet(cs_GraphicsData)
    If dtaSheet Is Nothing Then
        msg = "Blatt '" & cs_GraphicsData & "' nicht gefunden."
        MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
    End If
    
'    Set usedRange = mainSheet.usedRange
    Set usedRange = srcSheet.usedRange
    last = getLastRow(usedRange)
    
    row = gn_row_Section_I_Start
    clm = 2
    findTextOrFormula srcSheet, "I. ", True, True, row, clm, , 2
    first = row
    If first = 0 Or last = 0 Or first <> gn_row_Section_I_Start Then
        msg = "Blatt '" & srcSheet.name & "' inkonsistent."
        MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
    End If
' ????? any input sheet (main or PC) || main only (basic or PC) ?????
    With srcSheet
        quantity = .Cells(srcRow, 2)
        If srcRow < first Or quantity = "" Or Not IsRangeNumeric(.Range(.Cells(srcRow, 3), .Cells(srcRow, cn_dataWidth))) Then
            msg = "Zeile " & srcRow & " (" & nameCh & ") ist nicht geeignet f|fffd|r Grafik."
            MsgBox msg, vbInformation, cs_MsgTitle
Exit Function
        End If
        nameCh = getValidSheetName(quantity)
        If (nameCh <> quantity) Then
            msg = "Zeile " & srcRow & " (" & quantity & ") ist nicht geeignet f|fffd|r Grafik."
            msg = msg + vbLf + "Die Zeichen  \  /  ?  *  :  [  ]  sind nicht erlaubt in Namen von Tabellen oder Diagrammen."
            MsgBox msg, vbInformation, cs_MsgTitle
Exit Function
        End If
    
        If nameCh = "Gesamtumsatz" Or nameCh = "G. u. V. vor Steuern" Then
            Set ch = getSheet(nameCh)
            If Not ch Is Nothing Then
                msg = nameCh & " ist Standard-Grafik."
                MsgBox msg, vbExclamation, cs_MsgTitle
Exit Function
            End If
        End If
        If nameCh = "Kto-Stand Monatsende" Or nameCh = "Kontokorrent - Kredit" Then
            Set ch = getSheet("Kto-Stand Monatsende")
            If Not ch Is Nothing Then
                msg = "Kto-Stand Monatsende" & " ist Standard-Grafik."
                MsgBox msg, vbExclamation, cs_MsgTitle
Exit Function
            End If
        End If
        
        'non-standard chart: name must be unambiguous
        row = first
        findTextOrFormula srcSheet, quantity, True, True, row, clm, , 2
        If row < srcRow Then
            msg = "Bezeichnung '" & quantity & "' wird mehrfach verwendet; Zeile " & row & " wird verwendet."
            If MsgBox(msg, vbOKCancel, cs_MsgTitle) <> vbOK Then
                Exit Function
            Else
                srcRow = row
                Set srcRange = srcSheet.Cells(srcRow, 2)
            End If
        Else
            row = row + 1
            findTextOrFormula srcSheet, quantity, True, True, row, clm, , 2
            If row > 0 Then
                msg = "Hinweis: Bezeichnung '" & nameCh & "' wird mehrfach verwendet."
                MsgBox msg, vbInformation, cs_MsgTitle
            End If
        End If
    End With
    
    If (srcSheet.name <> gs_MainSheetName) Then
        nameCh = nameCh & "(" & srcSheet.name & ")"
    End If
    Set ch = getSheet(nameCh)
    If Not ch Is Nothing Then
        ch.visible = xlSheetVisible
        ch.Activate
        msg = "Diagramm '" & nameCh & "' existiert bereits."
        msg = msg & vbLf & "Bitte erst l|fffd|schen."
        MsgBox msg, vbInformation, cs_MsgTitle
        Exit Function
    End If
    
    gb_isUserOK = False
    With frmOptions
        .caption = "Grafik erstellen"
        .BorderStyle = fmBorderStyleSingle
        .lblDescription = "Neue Grafik f|fffd|r Zeile " & "(" & srcRange.row & ") " & nameCh
        .chkOption1.caption = "Werte aufgelaufen"
        .chkOption1.value = gb_isChartWithAccumulation ' last value
        .chkOption1.Enabled = True
        If (startsWith(nameCh, "Kto-Stand")) Then
            .chkOption1.value = False
            .chkOption1.Enabled = False
        End If
        .chkOption1.visible = True
        .chkOption2.visible = False
        .chkOption3.visible = False
        
        .chkOption1.Top = 48 - 6
        .chkOption1.Left = 48 + 12
        
        .btnOK.Top = 126 - 48
        .btnCancel.Top = 126 - 48
        
        .height = 170 - 48
        .Show
        
        If gb_isUserOK Then
            gb_isChartWithAccumulation = .chkOption1
            createSimpleChart srcRange, gb_isChartWithAccumulation, sError
        End If
    End With
End Function


Function createSimpleChart(srcRange As Range, isAccrued As Boolean, sError As String)
' OFFICE_VERSION >= 15: Chart.FullSeriesCollection, Series.isFiltered
Dim srcSheet As Worksheet, dtSheet As Worksheet, mstSheet As Worksheet, chrt As Chart
Dim usedRange As Range, dataRow As Long
Dim srcName As String, monthName As String, month As Long, lastMonth As Long
Dim monthRow As Long, srcRow As Long
Dim row As Long, clm As Long, idx As Long
Dim title As String, src As String, tmp As String
Dim quantity As String, nameCh As String, txt As String, msg As String, flag1 As Boolean, flag2 As Boolean, eventsFlag As Boolean
Dim formula As String
Dim sectStart As Long, sectEnd As Long, maxRow As Long
Dim step As String

Dim descr As String, chartHeader() As String


On Error GoTo CHART_ERROR
    
    createSimpleChart = False
step = "initialize"

    With srcRange
        Set srcSheet = .parent
        srcName = srcSheet.name
        quantity = srcSheet.Cells(.row, 2)
        descr = getDescriptorSource(srcSheet.Cells(.row, 2), isAccrued, sError)
'        chartHeader = getDescriptorSource_new(srcSheet.Cells(.row, 2), isAccrued, sError)
        If (descr = "") Then
            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
'        ElseIf (chartHeader(1) = "") Then
'            MsgBox sError, vbInformation
'Exit Function
        End If
        nameCh = quantity
        If (srcName <> gs_MainSheetName) Then
            nameCh = nameCh & "(" & srcName & ")"
        End If
        If (getValidSheetName(quantity) <> quantity) Then
            sError = "Folgende Zeichen sind in Namen von Tabellen und Diagrammen nicht erlaubt."
            sError = sError + vbLf + vbLf + ": \ / ? * [ ]"
            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
        ElseIf (Len(nameCh) > 31) Then
'            msg = nameCh & ": der Name hat mehr als 31 Zeichen."
'            nameCh = InputBox(msg, cs_MsgTitle, nameCh)
'            If (nameCh = "") Then
'Exit Function
'            ElseIf (Len(nameCh) > 31) Then
                sError = nameCh & ": der Name hat mehr als 31 Zeichen."
                MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
'            End If
        End If
        If (Not getSheet(nameCh) Is Nothing) Then
            sError = nameCh & ": der Name wird bereits verwendet."
            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
        End If
        
        srcRow = .row
        msg = "Grafik wird erstellt f|fffd|r Zeile " & srcRange.row & " von " & srcName
        msg = msg & " (" & quantity & IIf(isAccrued, ", akkumuliert)", ")")
Debug.Print msg
    End With
'    MsgBox msg, vbInformation, cs_MsgTitle

    monthRow = 1
    clm = 2
    txt = cs_MonthTitle
    findTextOrFormula srcSheet, txt, True, True, monthRow, clm, , 2
    
    monthName = srcSheet.Cells(monthRow, 3)
    month = monthToNumber(monthName)
    If monthName = cs_NoMonth Then monthName = "Planung"
    
    Set mstSheet = getSheet(cs_MasterSheetName)
    
    Set dtSheet = getSheet(cs_GraphicsData)
    row = 1: clm = 1
    findTextOrFormula dtSheet, "[Berichtsmonat]", True, True, row, clm, , 1
    lastMonth = dtSheet.Cells(row + 1, 1)
    
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    flag2 = gb_SheetListChangeDisabled
    gb_SheetListChangeDisabled = True
    
    If startsWith(nameCh, "Kto-Stand") Then
        isAccrued = False
    End If
    
step = "data sheet entry"
    With dtSheet
'        .Unprotect cs_LiquiPWD
'        descr = "[" & quantity & IIf(isAccrued, ", akkumuliert]", "]")
'        If (srcName <> gs_MainSheetName) Then
'            descr = descr & "{" & srcName & "}"
'        End If
             
        ' existing chart section: delete
        ' issue: data value links to subsequent charts
        maxRow = getLastRow(.usedRange)
        findTextOrFormula dtSheet, descr, True, True, row, clm, , 1
        sectStart = row
        row = row + 1
        If sectStart > 0 Then
            findTextOrFormula dtSheet, "[", True, True, row, clm, , 1
            If row > 0 Then
                sectEnd = row - 1
            Else
                sectEnd = maxRow + 1
            End If
'Debug.Print sectStart, sectEnd
            For idx = 0 To sectEnd - sectStart + 1
                dtSheet.Rows(sectStart - 1).Delete
            Next
        End If
        
        Set usedRange = .usedRange
        maxRow = getLastRow(usedRange)
        For row = maxRow To 1 Step -1
            If (.Cells(row, 1) <> "") Then Exit For
        Next
        dataRow = row + 2   'blank separating
        
        .Cells(dataRow, 1) = descr
'        .Range(.Cells(dataRow, 1), .Cells(dataRow, 4)) = chartHeader
        .Cells(dataRow + 1, 1) = "Soll"
        .Cells(dataRow + 2, 1) = "Ist"
        If startsWith(nameCh, "Kto-Stand") Then
            .Cells(dataRow + 3, 1) = "Kredit"
        Else
            .Cells(dataRow + 3, 1) = "Soll akkum."
            .Cells(dataRow + 4, 1) = "Ist akkum."
        End If
        For idx = 0 To 13
            .Cells(dataRow + 1, idx + 2).FormulaR1C1 = "='" + cs_MasterSheetName + "'!R" & srcRow & "C" & (idx + 3)
            .Cells(dataRow + 2, idx + 2).FormulaR1C1 = "='" + gs_MainSheetName + "'!R" & srcRow & "C" & (idx + 3)
            If startsWith(nameCh, "Kto-Stand") Then
                .Cells(dataRow + 3, idx + 2).FormulaR1C1 = "='" + gs_MainSheetName + "'!R" & srcRow + 1 & "C" & (idx + 3)
            Else
                If idx > 0 And idx < 13 Then
                    formula = "=sum(R[-2]C3:R[-2]C" & idx + 2 & ")"
                    .Cells(dataRow + 3, idx + 2).FormulaR1C1 = formula
                    .Cells(dataRow + 4, idx + 2).FormulaR1C1 = formula
                End If
            End If
        Next
        
        protectSheet dtSheet
    End With

step = "create chart"

Dim officeVersion As Long
Dim seriesToBe As Series, seriesAsIs As Series, seriesCredit As Series
Dim template As Chart, cnt As Long
    With ActiveWorkbook
        On Error Resume Next
            Set template = .Charts("Gesamtumsatz")
        On Error GoTo CHART_ERROR
'        If Not (template Is Nothing) Then
        If False Then
            ' ! .copy copies code as well !
            template.Copy , .Charts(.Charts.Count)
            Set chrt = .Charts(.Charts.Count)
        Else
            ' without template
            cnt = .Charts.Count
            Set chrt = .Charts.Add()
            If (cnt > 0) Then
                chrt.Move after:=.Charts(cnt)
            Else
                chrt.Move after:=.Worksheets(cs_MasterSheetName)
            End If
            With chrt
On Error GoTo PWD_ERROR
                .Unprotect Password:=""
On Error GoTo CHART_ERROR
If True Then
                officeVersion = val(Application.Version)
                .ChartType = xlLineMarkers
                .ClearToMatchStyle
                If officeVersion >= 15 Then
                    .ChartStyle = 228
                Else
                    .ChartStyle = 34
                End If
'                .SetElement (msoElementDataLabelNone)
''                .SetElement (msoElementPrimaryCategoryAxisTitleAdjacentToAxis)
'                .SetElement (msoElementPrimaryValueAxisTitleAdjacentToAxis)
'                .SetElement (msoElementLegendRight)
'                .HasTitle = True

Else    ' in case .ChartStyle doesn't work
                With .PlotArea
                    .width = chrt.ChartArea.width - 100
                    .height = chrt.ChartArea.height - 100
                    With .Format.line
                        .visible = msoTrue
                        .ForeColor.ObjectThemeColor = msoThemeColorAccent1
                        .ForeColor.TintAndShade = 0
        '                .ForeColor.Brightness = 0   '8.0.1.3: undefined in Excel 2007:
                    End With
                    With .Format.Fill
                        .visible = msoTrue
                        .ForeColor.ObjectThemeColor = msoThemeColorBackground1  '...2
                        .ForeColor.TintAndShade = -0.5
        '                .ForeColor.Brightness = 0   '8.0.1.3: undefined in Excel 2007:
                        .Transparency = 0
                        .Solid
                    End With
                End With ' .PlotArea
End If
            End With 'chrt
        End If ' template or not
        
step = "prepare chart"

        With chrt
On Error GoTo PWD_ERROR
                .Unprotect Password:=""
On Error GoTo CHART_ERROR
            #If OFFICE_VERSION >= 15 Then
'Debug.Print .FullSeriesCollection.Count
                Do While (.FullSeriesCollection.Count > 0)
                    .FullSeriesCollection(1).Delete
                Loop
            #Else
'Debug.Print .SeriesCollection.Count
                Do While (.SeriesCollection.Count > 0)
                    .SeriesCollection(1).Delete
                Loop
            #End If
            Set seriesToBe = .SeriesCollection.NewSeries
            Set seriesAsIs = .SeriesCollection.NewSeries
            Set seriesCredit = .SeriesCollection.NewSeries
            
            seriesToBe.XValues = "='" + cs_GraphicsData + "'!R1C3:R1C14"
'            seriesToBe.DataLabels.ShowValue = False
'            seriesAsIs.DataLabels.ShowValue = False
'            seriesCredit.DataLabels.ShowValue = False
            
            .HasAxis(xlValue) = True
            tmp = srcSheet.Cells(gn_yearRow + 1, 3)
            With .Axes(xlValue)
                .HasTitle = True
                .AxisTitle.Text = tmp
                .Crosses = xlCustom
                .CrossesAt = 0
            End With
            
            .HasLegend = True
            .Legend.Position = xlRight
            .Legend.IncludeInLayout = True
        End With ' chrt
    End With ' ActiveWorkbook
    On Error GoTo CHART_ERROR
    
step = "create series'"
    clm = 3
    With chrt
'        .name = getValidSheetName(quantity)
'        nameCh = quantity
'        If (srcName <> gs_MainSheetName) Then
'            nameCh = nameCh & "(" & srcName & ")"
'        End If
''        If (chartHeader(4) <> "") Then
''            nameCh = chartHeader(4)
''Debug.Print "createSimpleChart(..)", nameCh, Len(nameCh)
''        End If
'        If (getSheet(nameCh) Is Nothing) Then
'            .name = nameCh
'        End If
        .name = nameCh
        
        'Soll
        row = IIf(isAccrued, dataRow + 3, dataRow + 1)
        src = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C14"
        With seriesToBe
            .Values = src
            .name = "Soll"
            .Border.LineStyle = xlContinuous
            .Border.Weight = xlMedium ' xlThin
            .MarkerStyle = xlCircle
            .MarkerSize = 7 ' 5 ' 13 '
            If (.HasDataLabels) Then
                .DataLabels.ShowValue = False
            End If
        End With
        
        ' Ist
        row = row + 1
        src = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C" & (month + 2)
        With seriesAsIs
            .Values = src
            .name = "Ist"
            .Border.LineStyle = xlContinuous
            .Border.Weight = xlMedium ' xlThin
            .MarkerStyle = xlCircle
            .MarkerSize = 7 ' 5 ' 13 '
            If (.HasDataLabels) Then
                .DataLabels.ShowValue = False
            End If
        End With
        
        ' Kreditlinie
        row = row + 1
        src = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C14"
        With seriesCredit
            .Values = src
            .name = "Kredit"
            .Border.LineStyle = xlContinuous
            .Border.ColorIndex = cn_colorCreditLine
            .Border.Weight = xlMedium ' xlThin
            .MarkerStyle = xlCircle
            .MarkerSize = 7 ' 5 ' 13 '
            If (.HasDataLabels) Then
                .DataLabels.ShowValue = False   ' ==> .HasDataLabels = false
            End If
            .MarkerBackgroundColorIndex = cn_colorCreditLine
            .MarkerForegroundColorIndex = cn_colorCreditLine
        End With

        #If OFFICE_VERSION >= 15 Then
            seriesToBe.IsFiltered = False
            seriesAsIs.IsFiltered = False
            seriesCredit.IsFiltered = False
            If month = 0 Then
                ' kein Ist
                seriesAsIs.IsFiltered = True
            End If
            If Not startsWith(nameCh, "Kto-Stand") Then
                ' no credit line
                seriesCredit.IsFiltered = True
            End If
        #Else
        If month = 0 Then
            ' kein Ist
            seriesAsIs.Delete
        End If
        If Not startsWith(quantity, "Kto-Stand") Then
            ' no credit line
            seriesCredit.Delete
        End If
        #End If
        
On Error Resume Next
step = "legends"

'On Error GoTo 0
        .HasAxis(xlValue) = True
        tmp = srcSheet.Cells(gn_yearRow + 1, 3)
        With .Axes(xlValue)
            .HasTitle = True
            .AxisTitle.Text = tmp
            .Crosses = xlCustom
            .CrossesAt = 0  ' .MinimumScale
        End With
        With .Legend
            .width = 60
            .height = 50
            If startsWith(nameCh, "Kto-Stand") Then
                .height = 70
            End If
        End With
On Error GoTo CHART_ERROR
        
step = "title"
        
        .HasTitle = True
'        title = srcSheet.Cells(monthRow - 3, clm)    'company | PC name
        title = getMainTitleSource(srcSheet)
        title = title & Chr(10) & quantity & IIf(isAccrued, ", akkumuliert", "")
        title = title & Chr(10) & "Stand: " & monthName & " " & srcSheet.Cells(monthRow - 2, clm)    'year
        .ChartTitle.caption = title
        .ChartTitle.Format.TextFrame2.TextRange.Font.size = 14
        .ChartTitle.Left = (.ChartArea.width - .ChartTitle.width) / 2
        
Dim h_0 As Long
        h_0 = .ChartTitle.height
        With .PlotArea
            .width = chrt.ChartArea.width - 100
            .height = chrt.ChartArea.height - h_0 - 50
            .Top = h_0 + 25
        End With    ' .PlotArea
        
        .Activate
        ActiveWindow.Zoom = 90
' voodoo: deselect chart area
' .ChartArea.Deselect
' .Deselect ' no longer works
' .Select ' counter-productive
'SendKeys "{ENTER}" ' no effect
'SendKeys "{ESC}" ' dangerous
'http://stackoverflow.com/questions/25326925/deselect-label-and-chart-excel-vba
'Works, but highly unreliable, as if used with other macros it will break the code,
'and this will give the "code execution has been interrupted" error.

On Error GoTo PWD_ERROR
        .Protect Password:="", DrawingObjects:=True, Scenarios:=True, userinterfaceonly:=False
On Error GoTo CHART_ERROR
    End With ' chrt

    ' force SheetsWatch.updateLists
    srcSheet.Activate
    chrt.Activate
    chrt.visible = xlSheetVisible
    gb_SheetListChangeDisabled = flag2
    Application.EnableEvents = eventsFlag
    createSimpleChart = True
Exit Function

CHART_ERROR:
Debug.Print "createSimpleChart(..)", step, Err.Description
    Err.Clear
    Resume Next
    
PWD_ERROR:
Debug.Print "createSimpleChart(..)", step, Err.Description
    Err.Clear
    msg = "Bitte heben Sie den Blattschutz von '" + chrt.name + "' auf."
    msg = msg + vbLf + "Andernfalls ist die Konsistenz des Modells nicht mehr gew|fffd|hrleistet."
    MsgBox msg, vbExclamation, cs_MsgTitle
    Resume Next
    
End Function

Function updateSimpleChart(srcSheet As Worksheet, mstSheet As Worksheet, chrt As Chart, _
                month As Long, lastMonth As Long, sectionRow As Long, accrued As Boolean, sError As String)
' OFFICE_VERSION >= 15: Chart.FullSeriesCollection, Series.isFiltered
Dim srcBook As Workbook, dtaSheet As Worksheet

' section header = [chart name(, akkumuliert)]{source sheet name}
Dim sectionHeader As String
Dim chrtName As String, srcSheetName As String, mstSheetName As String
Dim quantity As String, rowHeader As String, seriesItem As Series, seriesId As String, seriesValues As String
Dim seriesToBe As Series, seriesAsIs As Series, seriesCredit As Series

Dim pos1 As Long, pos2 As Long

Dim row As Long, clm As Long, idx As Long
Dim dataRow As Long, monthRow As Long, srcRow As Long
Dim monthName As String, title As String
Dim msg As String, tmp As String, step As String, cnt As Long
Dim rebuildSeries As Boolean
Dim isProtected As Boolean
Dim descr As String, isAccrued As Boolean

    ' check if chart is still valid simple LiquiChart
    Set srcBook = srcSheet.parent
    chrtName = chrt.name

On Error Resume Next
On Error GoTo CHART_ERROR
    With chrt
        If (.visible = xlSheetHidden) Then
            updateSimpleChart = True
Exit Function
        End If
step = "check PWD"
        isProtected = (.ProtectDrawingObjects Or .ProtectContents)
        If (isProtected) Then
            .Unprotect ""   ' charts w/o PWD
        End If
        
step = "check chart"
        Set seriesToBe = Nothing
        Set seriesAsIs = Nothing
        Set seriesCredit = Nothing
        
        updateSimpleChart = True
        rebuildSeries = False
        #If OFFICE_VERSION >= 15 Then
            On Error Resume Next
            Set seriesToBe = .FullSeriesCollection("Soll")
            Set seriesAsIs = .FullSeriesCollection("Ist")
            Set seriesCredit = .FullSeriesCollection("Kredit")
            On Error GoTo CHART_ERROR
            If (seriesToBe Is Nothing) Then
                updateSimpleChart = False
            End If
            If (seriesAsIs Is Nothing Or seriesCredit Is Nothing) Then
                rebuildSeries = True
            End If
        #Else
            On Error Resume Next
            Set seriesToBe = .SeriesCollection("Soll")
            Set seriesAsIs = .SeriesCollection("Ist")
            Set seriesCredit = .SeriesCollection("Kredit")
            On Error GoTo CHART_ERROR
            If (seriesToBe Is Nothing) Then
                updateSimpleChart = False
            Else
                rebuildSeries = True
            End If
        #End If
        
        If (updateSimpleChart = False) Then
            msg = "Diagramm '" & chrtName & "' wurde zerst|fffd|rt."
            msg = msg + vbLf + "Bitte l|fffd|schen und neu erstellen ('Diagramm einf|fffd|gen'). "
            MsgBox msg, vbExclamation, cs_MsgTitle
Exit Function
        End If
        
        If (rebuildSeries) Then
step = "rebuild series"
            On Error Resume Next
            seriesAsIs.Delete
            seriesCredit.Delete
            On Error GoTo CHART_ERROR
            Set seriesAsIs = .SeriesCollection.NewSeries
            Set seriesCredit = .SeriesCollection.NewSeries
            With seriesAsIs
                .name = "Ist"
                ' order of statements is important
                .Border.LineStyle = seriesToBe.Border.LineStyle '(1) e.g. xlContinuous
                .Border.ColorIndex = xlAutomatic                '(2) [sic]
                .Border.Weight = seriesToBe.Border.Weight       '(3) e.g. xlMedium
                .MarkerStyle = seriesToBe.MarkerStyle ' e.g. xlDiamond
                .Smooth = seriesToBe.Smooth ' False
                .MarkerSize = seriesToBe.MarkerSize ' e.g. 7
                .Shadow = seriesToBe.Shadow ' e.g. False
                If (.HasDataLabels) Then
                    .DataLabels.ShowValue = seriesToBe.HasDataLabels    ' False ==> .HasDataLabels = false
                End If
            End With
            With seriesCredit
                .name = "Kredit"
                .Border.LineStyle = seriesToBe.Border.LineStyle  ' e.g. xlContinuous
                .Border.ColorIndex = cn_colorCreditLine
                .Border.Weight = seriesToBe.Border.Weight   ' e..g. xlMedium
                .MarkerStyle = seriesToBe.MarkerStyle
                If (.HasDataLabels) Then
                    .DataLabels.ShowValue = seriesToBe.HasDataLabels    ' False ==> .HasDataLabels = false
                End If
                .Smooth = seriesToBe.Smooth ' False
                .MarkerSize = seriesToBe.MarkerSize ' 7
                .Shadow = seriesToBe.Shadow ' e.g. False
                .MarkerBackgroundColorIndex = cn_colorCreditLine
                .MarkerForegroundColorIndex = cn_colorCreditLine
            End With
        End If
    End With

Dim pos As Long

step = "simple chart"
    'simple chart (standard or custom)
    updateSimpleChart = False

    Set dtaSheet = getSheet(cs_GraphicsData)
    dataRow = sectionRow
    chrtName = chrt.name
    quantity = getQuantityChart(chrt)
    pos = InStr(1, quantity, "(" & srcSheet.name & ")")
    If (pos > 0) Then
        quantity = Left(quantity, pos - 1)
    End If
    isAccrued = isAccruedChart(chrt)
    monthName = numberToMonth(month)
    
'    descr = "[" & quantity & IIf(isAccrued, ", akkumuliert", "") & "]"
'    If (srcSheet.name <> gs_MainSheetName) Then
'        descr = descr & "{" & srcSheet.name & "}"
'    End If
    descr = getDescriptorChart(chrt)
    
'Debug.Print "updateSimpleChart(..)", srcSheet.name, quantity, descr
    srcRow = gn_row_Section_I_Start
    clm = 2
    findTextOrFormula srcSheet, quantity, True, True, srcRow, clm, , 2
    If srcRow = 0 Then
        sError = "Diagramm '" & chrtName & "' geh|fffd|rt zu keiner Plangr|fffd||fffd|e von '" & srcSheet.name & "'"
Exit Function
    End If
    
    '   - one quantity: two series ('Soll' and 'Ist'), +- accrued
    If (month = 0 Or lastMonth = 0) And Not mstSheet Is Nothing Then
        'no month or first time: initialize/reset chart data
'        dtaSheet.Unprotect Password:=cs_LiquiPWD
        For idx = 0 To 13
            dtaSheet.Cells(dataRow + 1, idx + 2).FormulaR1C1 = "='" + mstSheet.name + "'!R" & srcRow & "C" & (idx + 3)
            dtaSheet.Cells(dataRow + 2, idx + 2).FormulaR1C1 = "='" + srcSheet.name + "'!R" & srcRow & "C" & (idx + 3)
            If startsWith(chrtName, "Kto-Stand") Then
                dtaSheet.Cells(dataRow + 3, idx + 2).FormulaR1C1 = "='" + srcSheet.name + "'!R" & (srcRow + 1) & "C" & (idx + 3)
            End If
        Next
'        protectSheet dtaSheet
    End If
        
    clm = 3
    With chrt
'        title = srcSheet.Cells(gn_monthRow - 3, clm)    'company / profit center name
        title = getMainTitleSource(srcSheet)
        title = title & Chr(10) & chrtName & IIf(accrued, ", akkumuliert", "")
        title = title & Chr(10) & "Stand: " & monthName & " " & srcSheet.Cells(gn_monthRow - 2, clm)    'year
        .ChartTitle.Text = title
        
        'Soll
        row = IIf(accrued, dataRow + 3, dataRow + 1)
        seriesValues = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C14"
        seriesToBe.Values = seriesValues
        
        'Ist
        row = row + 1
        seriesValues = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C" & (month + 2)
        seriesAsIs.Values = seriesValues
        
        'Kredit
        row = row + 1
        seriesValues = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C14"
        seriesCredit.Values = seriesValues
        
        If (month = 0) Then
            #If OFFICE_VERSION >= 15 Then
                seriesAsIs.IsFiltered = True
            #Else
                seriesAsIs.Delete
            #End If
        End If
        If Not startsWith(chrtName, "Kto-Stand") Then
            #If OFFICE_VERSION >= 15 Then
                seriesCredit.IsFiltered = True
            #Else
                seriesCredit.Delete
            #End If
        End If
        
        ' center updates title
        .ChartTitle.Left = (.ChartArea.width - .ChartTitle.width) / 2
        
        On Error Resume Next
        ' may fail if edited by user
        If (.HasAxis(xlValue)) Then
            With .Axes(xlValue)
               .Crosses = xlCustom
               .CrossesAt = 0   ' .MinimumScale
               If (.HasTitle) Then
                    tmp = srcSheet.Cells(gn_yearRow + 1, 3)
                    .AxisTitle.Text = tmp  ' "Euro"
                    .AxisTitle.Orientation = xlUpward
                End If
            End With
        End If
        On Error GoTo CHART_ERROR
' .ChartArea.Deselect    ' not supported
' SendKeys "{ESC}"       ' run-time error "code execution has been interrupted"
        .Activate
    End With    'chrt
    
'    ActiveWindow.Zoom = 90
    If (isProtected) Then
        protectSheet chrt
    End If
'Debug.Print "updateSimpleChart(..)", chrt.name
    updateSimpleChart = True
Exit Function

CHART_ERROR:
Debug.Print "updateSimpleChart(..)", chrt.name & " @ " & step & ": " & Err.Description
    Err.Clear
    If (step = "check PWD") Then
        updateSimpleChart = False
'        chrt.Activate
        msg = "Bitte heben Sie den Blattschutz von Diagramm '" + chrt.name + "' auf."
        MsgBox msg, vbExclamation, cs_MsgTitle
        sError = ""
Exit Function
    Else
        Resume Next
    End If
    
End Function

Private Sub testDetailsSource()
Dim wsh As Worksheet, rng As Range, details() As String, sError As String, i As Long
    If (gn_MainSheetIndex = 0) Then validateMainSheet (sError)
    Set wsh = getSheet("Nord")
    Set wsh = getSheet(gs_MainSheetName)
    Set rng = wsh.Cells(75, cn_clm_Quantity)
    details = getDetailsSource(rng, False, sError)
    details = getDetailsSource(rng, True, sError)
    If (details(1) = "") Then
        MsgBox sError, , cs_MsgTitle
Exit Sub
    End If
    For i = 1 To 7: Debug.Print details(i); " | ";: Next
End Sub
Function getDetailsSource(srcRange As Range, isAccrued As Boolean, sError As String, Optional chartName As String = "") As String()
Dim srcSheet As Worksheet, srcName As String, quantity As String
Dim details(1 To 7) As String
Dim msg As String
    
    With srcRange
        Set srcSheet = .parent
        srcName = srcSheet.name
        quantity = .Cells(1, 1)
        If (getValidSheetName(quantity) <> quantity) Then
            sError = "Folgende Zeichen sind in Namen von Tabellen und Diagrammen nicht erlaubt."
            sError = sError + vbLf + vbLf + ": \ / ? * [ ]"
            details(1) = ""
            getDetailsSource = details
Exit Function
        End If
        details(1) = quantity
        details(2) = IIf(isAccrued, "akkumuliert", "")
        details(3) = srcName
    End With

    ' company / PC
    details(4) = srcSheet.Cells(gn_row_Prolog_Start + 1, 3)
    
    ' month, year
    details(5) = srcSheet.Cells(gn_monthRow, 3)
    details(6) = srcSheet.Cells(gn_monthRow - 2, 3)
    
    ' chart name
    If (chartName = "") Then
        chartName = quantity
        If (srcName <> gs_MainSheetName) Then
            chartName = quantity & "(" & srcName & ")"
        End If
'            If (Len(chartName) > 31) Then
'                msg = chartName & ": der Name hat mehr als 31 Zeichen."
'                chartName = InputBox(msg, cs_MsgTitle, chartName)
'            End If
        If (Len(chartName) > 31) Then
            sError = chartName & ": Name hat mehr als 31 Zeichen."
            details(1) = ""
            getDetailsSource = details
Exit Function
        End If
    End If
    details(7) = chartName
    
    getDetailsSource = details
End Function

Private Sub testDetailsChart()
Dim chrt As Chart, details() As String, sError As String, i As Long
    If (gn_MainSheetIndex = 0) Then validateMainSheet (sError)
    Set chrt = getSheet("Variable Kosten gesamt(B.-W.)")
    Set chrt = getSheet("Personal.Raum.Pacht")
    Set chrt = getSheet("Fixkosten gesamt(Nord)")
    details = getDetailsChart(chrt, sError)
    If (details(1) = "") Then
        MsgBox sError, , cs_MsgTitle
Exit Sub
    End If
    For i = 1 To 7: Debug.Print details(i); " | ";: Next
End Sub
Function getDetailsChart(chrt As Chart, sError As String) As String()
Dim details(1 To 7) As String
Dim lines() As String, tmp As String, pos As Long
Dim srcSheet As Worksheet, srcName As String, quantity As String, isSimple As Boolean

' XlChartType
'   simple chart: xlLineMarkers = 65
'   multi chart:  xlColumnClustered = 51
'Debug.Print chrt.ChartType, chrt.ChartStyle

'    If (chrt.ChartType <> xlLineMarkers) Then
'        sError = "Not a simple chart"
'        details(1) = ""
'        getDetailsChart = details
'Exit Function
'    End If
    
    isSimple = (chrt.ChartType = xlLineMarkers)
    lines() = Split(chrt.ChartTitle.caption, Chr(10))
    
    ' source name, company / PC
    tmp = lines(LBound(lines))
    pos = lastInStr(tmp, " / ")
    If (pos = 0) Then
        srcName = gs_MainSheetName
        details(3) = srcName
        details(4) = tmp
    Else
        tmp = Mid(tmp, pos + 3)
        srcName = tmp
        details(3) = srcName
        Set srcSheet = getSheet(srcName)
        If (Not srcSheet Is Nothing) Then
            details(4) = srcSheet.Cells(gn_row_Prolog_Start + 1, 3)
        End If
    End If
    
    ' quantity, accrued
    If isSimple Then
        tmp = lines(LBound(lines) + 1)
        pos = InStr(1, tmp, ", akkumuliert")
        If (pos > 0) Then
            tmp = Left(tmp, pos - 1)
        End If
        details(2) = IIf(pos = 0, "", "akkumuliert")
        quantity = tmp
        pos = InStr(1, quantity, "(" & srcName & ")")
        If (pos > 0) Then quantity = Left(quantity, pos - 1)
        details(1) = quantity
    Else
        details(1) = ""
        details(2) = ""
    End If
    
    ' month, year
    tmp = Mid(lines(LBound(lines) + 2), Len("Stand: ") + 1)
    details(5) = nextValue(tmp, " ")
    details(6) = tmp
    
    ' chart name
    details(7) = chrt.name
    
    getDetailsChart = details
End Function

Function getSourceNameChart(chrt As Chart) As String
' must match getMainTitleSource(..)
Dim lines() As String, tmp As String, pos As Long

    lines() = Split(chrt.ChartTitle.caption, Chr(10))
    tmp = lines(LBound(lines))
    pos = lastInStr(tmp, " / ")
    If (pos = 0) Then
        getSourceNameChart = gs_MainSheetName
    Else
        getSourceNameChart = Mid(tmp, pos + 3)
    End If
End Function

Function getSourceNameDescriptor(descr As String) As String
Dim srcName As String, tmp As String, pos As Long

    srcName = gs_MainSheetName
    If endsWith(descr, "}") Then
        tmp = descr
        pos = lastInStr(tmp, "{")
        srcName = Mid(tmp, pos + 1, Len(tmp) - pos - 1)
    End If
    getSourceNameDescriptor = srcName
End Function

Function getQuantityChart(chrt As Chart) As String
Dim lines() As String, tmp As String, pos As Long

    lines() = Split(chrt.ChartTitle.caption, Chr(10))
    tmp = lines(LBound(lines) + 1)
    pos = InStr(1, tmp, ", akkumuliert")
    If (pos > 0) Then
        tmp = Left(tmp, pos - 1)
    End If
    getQuantityChart = tmp
End Function

Function isAccruedChart(chrt As Chart) As Boolean
Dim lines() As String, tmp As String

    lines() = Split(chrt.ChartTitle.caption, Chr(10))
    tmp = lines(LBound(lines) + 1)
    isAccruedChart = (InStr(1, tmp, ", akkumuliert") > 0)
End Function

Function getChartNameDescr(descriptor As Range) As String
Dim quantity As String, srcName As String, chrtName As String, tmp As String, isSimple As Boolean
    srcName = ""
    tmp = Mid(descriptor(1, 1), 2)
    isSimple = (descriptor(2, 1) = "Soll")
    quantity = nextValue(tmp, "]")
    quantity = Replace(quantity, ", akkumuliert", "")
    chrtName = quantity
    If (isSimple And tmp <> "") Then
        srcName = Replace(Replace(tmp, "{", ""), "}", "")
        If (srcName <> gs_MainSheetName) Then
            chrtName = quantity & "(" & srcName & ")"
        End If
    End If
    getChartNameDescr = chrtName
End Function

Function getMainTitleSource(srcSheet As Worksheet) As String
' must match getSourceNameChart(..)
Dim mainSheet As Worksheet, title As String

    title = srcSheet.Cells(gn_monthRow - 3, 3)    'company | PC name
    If (srcSheet.name <> gs_MainSheetName) Then
        Set mainSheet = getSheet(gs_MainSheetName)
        If (mainSheet.Cells(gn_monthRow - 3, 3) <> title) Then
            title = mainSheet.Cells(gn_monthRow - 3, 3) & " / " & srcSheet.name ' title '
        End If
    End If
    getMainTitleSource = title
End Function

' old format: [Fixkosten gesamt, akkumuliert]{Nord}
' new format: [Fixkosten gesamt]  akkumuliert  Nord  Fixkosten gesamt(Nord)
'
Function getDescriptorSource_new(srcRange As Range, isAccrued As Boolean, sError As String) As String()
Dim srcSheet As Worksheet, srcName As String, quantity As String, chartName As String
Dim chartHeader(1 To 4) As String
Dim msg As String
    
    With srcRange
        Set srcSheet = .parent
        srcName = srcSheet.name
        quantity = .Cells(1, 1)
        If (getValidSheetName(quantity) <> quantity) Then
            sError = "Folgende Zeichen sind in Namen von Tabellen und Diagrammen nicht erlaubt."
            sError = sError + vbLf + vbLf + ": \ / ? * [ ]"
            chartHeader(1) = ""
            getDescriptorSource_new = chartHeader
Exit Function
        End If
        chartName = quantity
        If (srcName <> gs_MainSheetName) Then
            chartName = quantity & "(" & srcName & ")"
        End If
        If (Len(chartName) > 31) Then
            msg = chartName & ": der Name hat mehr als 31 Zeichen."
            chartName = InputBox(msg, cs_MsgTitle, chartName)
        End If
        If (Len(chartName) > 31) Then
            sError = chartName & ": Name hat mehr als 31 Zeichen."
            chartHeader(1) = ""
            getDescriptorSource_new = chartHeader
Exit Function
        End If
        chartHeader(1) = "[" & quantity & "]"
        chartHeader(2) = IIf(isAccrued, "akkumuliert", "")
        chartHeader(3) = srcName
        chartHeader(4) = chartName
    End With
    getDescriptorSource_new = chartHeader
End Function

Function getDescriptorSource(srcRange As Range, isAccrued As Boolean, sError As String) As String
Dim srcSheet As Worksheet, srcName As String, quantity As String, descr As String
    
    With srcRange
        Set srcSheet = .parent
        srcName = srcSheet.name
        quantity = .Cells(1, 1)
        If (getValidSheetName(quantity) <> quantity) Then
            sError = "Folgende Zeichen sind in Namen von Tabellen und Diagrammen nicht erlaubt."
            sError = sError + vbLf + vbLf + ": \ / ? * [ ]"
            getDescriptorSource = ""
Exit Function
        End If
        descr = "[" & quantity & IIf(isAccrued, ", akkumuliert]", "]")
        If (srcName <> gs_MainSheetName) Then
            descr = descr & "{" & srcName & "}"
        End If
    End With
    getDescriptorSource = descr
End Function

Function getDescriptorChart(chrt As Chart) As String
Dim chrtName As String, srcName As String, quantity As String, isAccrued As Boolean, descr As String
Dim tmp As String, pos As Long
    
'    chrtName = chrt.name
    quantity = getQuantityChart(chrt)
    isAccrued = isAccruedChart(chrt)
    srcName = getSourceNameChart(chrt)
    pos = InStr(1, quantity, "(" & srcName & ")")
    If (pos > 0) Then
        quantity = Left(quantity, pos - 1)
    End If
    
    descr = "[" & quantity & IIf(isAccrued, ", akkumuliert]", "]")
    If (srcName <> gs_MainSheetName) Then
        descr = descr & "{" & srcName & "}"
    End If
    getDescriptorChart = descr
End Function

Function updateLiquiCharts(ByVal Target As Range, sError As String) As Boolean
Dim srcSheet As Worksheet, dtaSheet As Worksheet, mstSheet As Worksheet, chrt As Chart, ch As Chart
Dim row As Long, clm As Long, idx As Long
Dim dataRow As Long, monthRow As Long, srcRow As Long
Dim monthName As String, month As Long, lastMonth As Long
Dim title As String, temp As String, step As String

On Error GoTo CHART_ERROR
step = "initialize"

    Set srcSheet = Target.parent
    
    Set dtaSheet = getSheet(cs_GraphicsData)
    If dtaSheet Is Nothing Then
        sError = "Blatt '" & cs_GraphicsData & "' nicht gefunden."
Exit Function
    End If
    
    Set mstSheet = getSheet(cs_MasterSheetName)
    If mstSheet Is Nothing Then
        sError = "Blatt '" & cs_MasterSheetName & "' nicht gefunden."
Exit Function
    End If
    
    monthRow = Target.row
    monthName = Target.Cells(1, 1)
    month = monthToNumber(monthName)
    If monthName = cs_NoMonth Then monthName = "Planung"
    
    findTextOrFormula dtaSheet, "[Berichtsmonat]", True, True, dataRow, clm, , 1
    lastMonth = dtaSheet.Cells(dataRow + 1, 1)
    
' section header = [chart name(, akkumuliert)]{source sheet name}
Dim sectionHeader As String
Dim chrtName As String, srcSheetName As String, mstSheetName As String, tmp As String
Dim quantity As String, rowHeader As String, seriesItem As Series, seriesId As String, seriesValues As String
Dim isAccrued As Boolean, pos1 As Long, pos2 As Long
Dim doCleanupDataSheet As Boolean

    doCleanupDataSheet = False
    dataRow = dataRow + 2
    findTextOrFormula dtaSheet, "[", True, True, dataRow, clm, , 1
    Do While dataRow > 0
        srcSheetName = gs_MainSheetName
        chrtName = ""
        sError = ""
        isAccrued = False
        sectionHeader = dtaSheet.Cells(dataRow, 1)
        isAccrued = (InStr(sectionHeader, ", akkumuliert]") > 0)
        srcSheetName = getSourceNameDescriptor(sectionHeader)
        
        Set srcSheet = getSheet(srcSheetName)
        If srcSheet Is Nothing Then
            sError = "Tabelle '" & srcSheetName & "' nicht gefunden."
Exit Function
        End If
        If (srcSheetName <> gs_MainSheetName) Then
            chrtName = chrtName & "(" & srcSheetName & ")"
        End If
        
        chrtName = getChartNameDescr(dtaSheet.Cells(dataRow, 1))
        
        mstSheetName = getMasterSheetName(srcSheetName)
        Set mstSheet = getSheet(mstSheetName)
        If mstSheet Is Nothing Then
            sError = "Tabelle '" & mstSheetName & "' nicht gefunden."
Exit Function
        End If
'Debug.Print sectionHeader, chrtName, srcSheetName
    
Dim msg As String
step = "chart"
'        Set chrt = getSheet(getValidSheetName(quantity))
        Set chrt = getSheet(chrtName)
        If chrt Is Nothing Then
            ' first check if chart was renamed
            ' if found, finish renaming in chart title and data section
            ' otherwise, remove section
            Set chrt = findRenamedChart(chrtName)
            If chrt Is Nothing Then
                msg = "Diagramm '" & chrtName & "' nicht gefunden; Eintrag wird ge|fffd|scht."
                MsgBox msg, vbInformation, cs_MsgTitle
                doCleanupDataSheet = True
                GoTo NEXT_SECTION
            Else
                tmp = chrt.ChartTitle.Text
                tmp = Replace(tmp, chrtName, chrt.name)
                chrt.ChartTitle.Text = tmp
                
                tmp = dtaSheet.Cells(dataRow, 1)
                tmp = Replace(tmp, chrtName, chrt.name)
'                dtaSheet.Unprotect cs_LiquiPWD
                    dtaSheet.Cells(dataRow, 1) = tmp
'                protectSheet dtaSheet
                
                chrtName = chrt.name
            End If
        ElseIf (chrt.visible = xlSheetHidden) Then
            GoTo NEXT_SECTION
        End If
        
    tmp = dtaSheet.Cells(dataRow + 1, 1)
    If tmp = "Soll" Then
        'simple chart (standard or custom)
step = "simple chart"
Application.StatusBar = chrt.name
        If Not updateSimpleChart(srcSheet, mstSheet, chrt, month, lastMonth, dataRow, isAccrued, sError) Then
            If (sError <> "") Then sError = "updateSimpleChart(..): " & sError
'            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
        End If

    Else ' diagram is multi-chart
step = "multi-chart"
Application.StatusBar = chrt.name
        ' new chart type (clustered columns)
        '   - several quantities: '...(Soll)' and '...(Ist)'
        If Not updateMultiChart(srcSheet, mstSheet, chrt, month, lastMonth, dataRow, sError) Then
            sError = "updateMultiChart(..): " & sError
'            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
        End If
    End If
    
NEXT_SECTION:
        dataRow = dataRow + 1
        clm = 1
        findTextOrFormula dtaSheet, "[", True, True, dataRow, clm, , 1
    Loop
    
    If doCleanupDataSheet Then
        cleanupGraphicsData
    End If

    updateLiquiCharts = True
Exit Function

CHART_ERROR:
Debug.Print chrt.name & " @ " & step & ": " & Err.Description
    Err.Clear
    Resume Next
    
End Function

Sub updateMonth(Target As Range)
Dim dataSheet As Worksheet, dataRow As Long
Dim monthName As String, month As Long
Dim row As Long, clm As Long

    monthName = Target.Cells(1, 1)
    month = monthToNumber(monthName)
    
    Set dataSheet = getSheet(cs_GraphicsData)
If (dataSheet.ProtectContents) Then
    dataSheet.Unprotect cs_LiquiPWD
End If
    findTextOrFormula dataSheet, "[Berichtsmonat]", True, True, dataRow, clm, , 1
    dataSheet.Cells(dataRow + 1, 1) = month
    dataSheet.Cells(dataRow + 1, 2) = monthName
'    protectSheet dataSheet
End Sub


' remove orphaned sections in grphics data sheet
' issue: can destroy the data references of remaining charts
'        !!! must be followed by updateLiquiCharts(..) !!! cf. processSheetsDeleted(..)
Function cleanupGraphicsData() As Boolean
Dim dtSheet As Worksheet, chrt As Chart
Dim maxRow As Long, row As Long, clm As Long, idx As Long
Dim chrtName As String, quantity As String, tmp As String, flag As Boolean, eventsFlag As Boolean
Dim isProtected As Boolean

On Error GoTo CHART_ERROR
    
    cleanupGraphicsData = False
    Set dtSheet = getSheet(cs_GraphicsData)
    If dtSheet Is Nothing Then
Exit Function
    End If
    isProtected = dtSheet.ProtectContents
    If (isProtected) Then
        If (Not unprotectSheet(dtSheet, True)) Then
Exit Function
        End If
    End If
    
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    With dtSheet
'        .Unprotect cs_LiquiPWD
        maxRow = getLastRow(.usedRange)
        
        row = 1: clm = 1
        findTextOrFormula dtSheet, "[Berichtsmonat]", True, True, row, clm, , 1
        row = row + 1
        
Dim sectStart As Long, sectEnd As Long, isSimple As Boolean
Dim msg As String, srcName As String
        Do While row > 0
            ' existing chart sections: delete if orphaned
            findTextOrFormula dtSheet, "[", True, True, row, clm, , 1
            sectStart = row
            tmp = ""
            quantity = ""
            srcName = ""
            If sectStart > 0 Then
                srcName = ""
                tmp = Mid(dtSheet.Cells(row, 1), 2)
                isSimple = (dtSheet.Cells(row + 1, 1) = "Soll")
                quantity = nextValue(tmp, "]")
                quantity = Replace(quantity, ", akkumuliert", "")
                chrtName = quantity
                If (isSimple And tmp <> "") Then
                    srcName = Replace(Replace(tmp, "{", ""), "}", "")
                    If (srcName <> gs_MainSheetName) Then
                        chrtName = quantity & "(" & srcName & ")"
                    End If
                End If
                If (dtSheet.Cells(sectStart, 4) <> "") Then
                    chrtName = dtSheet.Cells(sectStart, 4)
                End If
                If (Not getSheet(chrtName) Is Nothing) Then
                    row = sectStart + 1
                Else
                    ' orphaned?
                    ' first check if chart was renamed
                    ' if found finish renaming in chart title and data section
                    ' otherwise, remove section
                    Set chrt = findRenamedChart(chrtName)
                    If Not chrt Is Nothing Then
                        tmp = chrt.ChartTitle.Text
                        tmp = Replace(tmp, chrtName, chrt.name)
                        chrt.ChartTitle.Text = tmp
                        
                        tmp = dtSheet.Cells(sectStart, 1)
                        tmp = Replace(tmp, chrtName, chrt.name)
                        dtSheet.Cells(sectStart, 1) = tmp
                        
                        chrtName = chrt.name
                    Else
                        msg = "Eintrag f|fffd|r Diagramm '" & chrtName & "' wird gel|fffd|scht."
'MsgBox msg, vbInformation, cs_MsgTitle
Debug.Print msg
                        ' section end: blank row after data
                        row = row + 1
                        findTextOrFormula dtSheet, "[", True, True, row, clm, , 1
                        If row > 0 Then
                            sectEnd = row - 1
                            ' after deleting of rows, data value links of subsequent charts are no longer valid
                            ' must update charts
                            cleanupGraphicsData = True
                        Else
                            sectEnd = maxRow + 1
                        End If
'Debug.Print sectStart, sectEnd
                        For idx = 0 To sectEnd - sectStart
                            dtSheet.Rows(sectStart - 1).Delete
                        Next
                        row = sectStart
                    End If
                End If
            End If
        Loop
    End With
    
    If isProtected Then protectSheet dtSheet
    Application.EnableEvents = eventsFlag
Exit Function

CHART_ERROR:
Debug.Print Err.Description
    Err.Clear
    Resume Next
    
End Function

Sub processSheetsMoved(nameList As String)
Debug.Print "processSheetsMoved(..): " & nameList
    ' nothing to do
End Sub

Sub processSheetsAdded(nameList As String)
Dim srcSheet As Worksheet, monthCell As Range
Dim sError As String

Debug.Print "processSheetsAdded(..): " & nameList

' charts
' useless: a new chart either
'           has just been created with its data or,
'           it is a copy of an existing one and has the same data or,
'           it has no data at all yet
'    Set srcSheet = GetSheet(gs_MainSheetName)
'    Set monthCell = srcSheet.Cells(gn_monthRow, 3)
'    If (Not UpdateLiquiCharts(monthCell, sError)) Then
'        If sError <> "" Then MsgBox sError, vbInformation, cs_MsgTitle
'    End If
End Sub

Private Sub processDeleted()
    processSheetsDeleted ""
End Sub
Sub processSheetsDeleted(Optional nameList As String = "")
Dim mainSheet As Worksheet, monthCell As Range
Dim sError As String
Dim eventsFlag As Boolean

If (nameList <> "") Then
Debug.Print "processSheetsDeleted(..): " & nameList
End If

    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    If cleanupGraphicsData() Then
        ' graphics data sheet was changed
        Set mainSheet = getSheet(gs_MainSheetName)
        If mainSheet Is Nothing Then Exit Sub
        Set monthCell = mainSheet.Cells(gn_monthRow, 3)
        If (Not updateLiquiCharts(monthCell, sError)) Then
            If sError <> "" Then MsgBox sError, vbInformation, cs_MsgTitle
        End If
    End If
    Application.EnableEvents = eventsFlag
End Sub

Sub processSheetRenamed(nameList As String)
Dim wb As Workbook, ws As Worksheet, ch As Chart, ob  As Object
Dim dtaSheet As Worksheet, row As Long, clm As Long, sectStart As Long, sectEnd As Long
Dim oldName As String, newName As String, descr As String, tmp As String, msg As String, flag As Boolean, eventsFlag As Boolean
    
Debug.Print "processSheetRenamed: " & nameList
    Set wb = Application.ActiveWorkbook
    
    If nameList <> "" Then
        tmp = nameList
        oldName = nextValue(tmp, cs_SheetNameSep)
        newName = nextValue(tmp, cs_SheetNameSep)
'Debug.Print "update renamed: " & oldName & " ~> " & newName
        Set ob = getSheet(newName)
        If TypeOf ob Is Worksheet Then
            ' master sheet, compare sheet
            Set ws = getSheet(getMasterSheetName(oldName))
            If Not ws Is Nothing Then
                ws.name = getMasterSheetName(newName)
            End If
            Set ws = getSheet(getCompareSheetName(oldName))
            If Not ws Is Nothing Then
                ws.name = getCompareSheetName(newName)
            End If
            
            ' special Liqui data sheets
            If (oldName = cs_PlotData Or oldName = cs_GraphicsData Or oldName = cs_optionsSheetName) Then
                Set ws = getSheet(newName)
                msg = "Blatt '" & oldName & "' kann nicht umbenannt werden."
                MsgBox msg, vbExclamation, cs_MsgTitle
                ws.name = oldName
            End If
            If (newName = cs_PlotData Or newName = cs_GraphicsData Or newName = cs_optionsSheetName) Then
                Set ws = getSheet(newName)
                msg = "Der Name '" & newName & "' ist gesch|fffd|tzt."
                MsgBox msg, vbExclamation, cs_MsgTitle
                ws.name = oldName
            End If
            
' Allgemeine Kosten: done by getProfitCenters()
'            If gs_GeneralCosts = oldName Then
'                gs_GeneralCosts = newName
'            End If
            
            ' formulae are updated by Excel if some sheet is renamed
        
        Else
            ' chart data, title (cf. cleanupGraphicsData)
            Set ch = ob
            Set dtaSheet = getSheet(cs_GraphicsData)
            If dtaSheet Is Nothing Then
Exit Sub
            ElseIf (Not unprotectSheet(dtaSheet, True)) Then
Exit Sub
            End If
            eventsFlag = Application.EnableEvents
            Application.EnableEvents = False
            With dtaSheet
'                .Unprotect cs_LiquiPWD
                row = 1: clm = 1
                descr = "[" & oldName & "]"
                findTextOrFormula dtaSheet, descr, True, True, row, clm, , 1
                If row = 0 Then
                    row = 1: clm = 1
                    descr = "[" & oldName & ", akkumuliert]"
                    findTextOrFormula dtaSheet, descr, True, True, row, clm, , 1
                End If
                If row > 0 Then
                    sectStart = row
                    ' single quantity ?
                    tmp = dtaSheet.Cells(sectStart + 1, 1)
                    If tmp = "Soll" Then
                        msg = "Gr|fffd||fffd|e '" & oldName & "' konsistent umbenennen ?"
Debug.Print msg
                        If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel Then
                            ch.name = oldName
                        Else
                        ' unfinished: consistent renaming of quantities
                            MsgBox "to come: consistent renaming of quantities", vbExclamation, cs_MsgTitle
                            ch.name = oldName
                        End If
                    Else
                        tmp = dtaSheet.Cells(sectStart, 1)
                        tmp = Replace(tmp, oldName, newName)
                        dtaSheet.Cells(sectStart, 1) = tmp
                                    
                        tmp = ch.ChartTitle.Text
                        tmp = Replace(tmp, oldName, newName)
                        ch.ChartTitle.Text = tmp
                    End If
                Else
'msg = "Daten f|fffd|r Diagramm '" & oldName & "' nicht gefunden."
'MsgBox msg, vbInformation, cs_MsgTitle
'Debug.Print msg
                End If
            End With
            protectSheet dtaSheet
            Application.EnableEvents = eventsFlag
        End If
    End If
End Sub

Sub processSheetListChanged(sheetRenamed As String, sheetsMoved As String, sheetsAdded As String, sheetsDeleted As String)
    ' sheets renamed
    If sheetRenamed <> "" Then
        processSheetRenamed sheetRenamed
    
    ' sheets moved
    ElseIf sheetsMoved <> "" Then
        processSheetsMoved sheetsMoved
    
    ' sheets added
    ElseIf sheetsAdded <> "" Then
        processSheetsAdded sheetsAdded
    
    ' sheets deleted
    ElseIf sheetsDeleted <> "" Then
        processSheetsDeleted sheetsDeleted
    End If
    
    ' only LiquiPlan input sheets left of main sheet
Dim sError As String
    If (validateMainSheet(sError) Is Nothing) Then
        MsgBox sError, vbExclamation, cs_MsgTitle
    End If
End Sub


' ===== utilities =====

' orphan
' returns corresponding input sheet
Function findInputSheet(ws As Worksheet) As Worksheet
Dim sh As Worksheet, idx As Long
        Set findInputSheet = Nothing
        For idx = 1 To gn_MainSheetIndex
            Set sh = Application.ActiveWorkbook.Worksheets(idx)
            If ws.name = getCompareSheetName(sh.name) Then
                Set findInputSheet = sh
Exit Function
            ElseIf (ws.name = getMasterSheetName(sh.name)) Then
                Set findInputSheet = sh
Exit Function
            End If
        Next
End Function

Function findRenamedChart(origName As String) As Chart
Dim chrt As Chart, ch As Chart
Dim pos1 As Long, pos2 As Long
Dim msg As String, tmp As String
        Set chrt = getSheet(getValidSheetName(origName))
        If chrt Is Nothing Then
            ' undo renaming ?
            For Each ch In Application.ActiveWorkbook.Charts
                'find original chart name in title
                pos1 = 0: pos2 = 0
                tmp = ch.ChartTitle.Text
                pos1 = InStr(1, tmp, Chr(10))
                If pos1 > 0 Then
                    pos2 = InStr(pos1 + 1, tmp, Chr(10))
                End If
                If (pos1 > 0 And pos2 > 0) Then
                    tmp = Mid(tmp, pos1 + 1, pos2 - pos1 - 1)
                    If tmp = origName Then
                        Set chrt = ch
                        Exit For
                    End If
                End If
            Next
            If Not chrt Is Nothing Then
'                ' prompt user
'                chrt.Activate
'                msg = "Diagramm '" & chrtName & "' wurde umbenannt; r|fffd|ckg|fffd|ngig machen?"
'                If MsgBox(msg, vbYesNo, cs_MsgTitle) = vbYes Then
'                    chrt.name = chrtName
'                Else
'                    Set chrt = Nothing
'                End If
            End If
        End If
        Set findRenamedChart = chrt
End Function


Function getScale(x As Double) As Long
' Normzahlen ~ M|fffd|nzen, Banknoten: 1, 2, 5
Dim s As Long, t As Long
    s = 1
    Do While x > s
        t = s
        s = 2 * t
        If x <= s Then Exit Do
        s = 5 * t
        If x <= s Then Exit Do
        s = 10 * t
    Loop
    getScale = s
End Function

Function getSeriesName(quantity As String, suffix As String, Optional length As Long = 12) As String
' series name for several quantities (KPI, key performance indicator) marked in analysis sheet
' suffix = '(Soll)' | '(Ist)'
Dim tmp As String
    tmp = quantity
    If InStr(tmp, suffix) > 0 Then
        tmp = Replace(tmp, suffix, "")
    End If
    If Len(tmp) > length Then
        tmp = Left(tmp, length - 2) + ".."
    End If
    getSeriesName = tmp & suffix
End Function

Function plotItemName(cl As Range, Optional length As Long = 12) As String
' series name for single quantity (KPI, key performance indicator) marked in analysis sheet
' marked in target/actual sheet
Dim kpi As String, tmp As String
    kpi = cl.Cells(1, 1)
    tmp = "(" & cl.Cells(1, 0) & ") "
    If Len(kpi) <= length Then
        tmp = tmp & kpi
    Else
        tmp = tmp & Left(kpi, length - 2) & ".."
    End If
    plotItemName = tmp
End Function


' ========== cemetery ==========

Attribute VB_Name = "LibAudXL"
Option Explicit

'http://opensolver.org/to-do/todo-formula-parsing/
'http://dailydoseofexcel.com/archives/2009/12/05/formula-tokenizer/

Public Const tkt_Operand = 2 ^ 0
Public Const tkt_OperandUnknown = tkt_Operand Or 2 ^ 1
Public Const tkt_OperandText = tkt_Operand Or 2 ^ 2
Public Const tkt_OperandError = tkt_Operand Or 2 ^ 3
Public Const tkt_OperandNumber = tkt_Operand Or 2 ^ 4
Public Const tkt_OperandBoolean = tkt_Operand Or 2 ^ 5
Public Const tkt_OperandReference = tkt_Operand Or 2 ^ 6
Public Const tkt_OperandReferenceWksQual = tkt_OperandReference Or 2 ^ 7
Public Const tkt_OperandReference3DWksQual = tkt_OperandReferenceWksQual Or 2 ^ 8
Public Const tkt_OperandReferenceRange = tkt_OperandReference Or 2 ^ 9
Public Const tkt_OperandReferenceName = tkt_OperandReference Or 2 ^ 10

Public Const tkt_WhiteSpace = 2 ^ 11

Public Const tkt_OperatorPrefix = 2 ^ 12
Public Const tkt_OperatorInfix = 2 ^ 13
Public Const tkt_OperatorPostfix = 2 ^ 14

Public Const tkt_OperatorArithmetic = 2 ^ 15
Public Const tkt_OperatorComparison = 2 ^ 16
Public Const tkt_OperatorText = 2 ^ 17
Public Const tkt_OperatorReference = 2 ^ 18

Public Const tkt_Expression = 2 ^ 19
Public Const tkt_Function = 2 ^ 20
Public Const tkt_FunctionArgument = 2 ^ 21
Public Const tkt_Array = 2 ^ 22
Public Const tkt_ArrayCol = 2 ^ 23
Public Const tkt_ArrayRow = 2 ^ 24

Public Const tkt_Begin = 2 ^ 25
Public Const tkt_End = 2 ^ 26

Private Const cStateDefault = 2 ^ 0
Private Const cStateArray = 2 ^ 1
Private Const cStateText = 2 ^ 2
Private Const cStateWksQuote = 2 ^ 3
Private Const cStateSqBracket = 2 ^ 4
Private Const cStateError = 2 ^ 5

Public Type token
    strValue As String
    lngType As Long
End Type

Public Function ParseFormula(strFormula As String) As token()
    Dim lngState As Long, str As String, strC As String
    Dim i As Long, j As Long, k As Long
    Dim udtTokens() As token, udtTokenStack() As token

    Dim strLeftBrace As String, strRightBrace As String
    Dim strColumnSeparator As String, strRowSeparator As String, strListSeparator As String

    strLeftBrace = Application.International(xlLeftBrace)
    strRightBrace = Application.International(xlRightBrace)
    strColumnSeparator = Application.International(xlColumnSeparator)
    strRowSeparator = Application.International(xlRowSeparator)
    strListSeparator = Application.International(xlListSeparator)

    lngState = cStateDefault
    i = 1

    If Left(strFormula, 1) = "=" Then i = i + 1

    Do Until i > Len(strFormula)
        strC = Mid(strFormula, i, 1)

        If (lngState And cStateText) = cStateText Then
            If strC = """" Then
                If Mid(strFormula, i + 1, 1) = strC Then
                    str = str & strC
                    i = i + 1
                Else
                    TokenPush udtTokens, str, tkt_OperandText
                    lngState = lngState And Not cStateText
                End If
            Else
                str = str & strC
            End If

        ElseIf (lngState And cStateWksQuote) = cStateWksQuote Then
            If strC = "'" Then
                If Mid(strFormula, i + 1, 1) = strC Then
                    str = str & strC
                    i = i + 1
                Else
                    lngState = lngState And Not cStateWksQuote
                End If
            Else
                str = str & strC
            End If

        ElseIf (lngState And cStateSqBracket) = cStateSqBracket Then
            If strC = "[" Then
                j = j + 1
            ElseIf strC = "]" Then
                If j = 0 Then lngState = lngState And Not cStateSqBracket Else j = j - 1
            End If
            str = str & strC

        ElseIf (lngState And cStateError) = cStateError Then
            str = str & strC
            If str = "#NULL!" Or str = "#DIV/0!" Or str = "#VALUE!" Or str = "#REF!" Or _
               str = "#NAME?" Or str = "#NUM!" Or str = "#N/A" Then

                TokenPush udtTokens, str, tkt_OperandError
                lngState = lngState And Not cStateError
            End If

        ElseIf (lngState And cStateDefault) = cStateDefault Then
            If strC = strLeftBrace Then
                lngState = (lngState And Not cStateDefault Or cStateArray)
                j = tkt_Array Or tkt_Begin
                TokenPush udtTokens(), strC, j
                TokenPush udtTokenStack(), strC, j

            ElseIf strC = """" Then
                lngState = lngState Or cStateText

            ElseIf strC = "'" Then
                lngState = lngState Or cStateWksQuote

            ElseIf strC = "[" Then
                j = 0
                str = str & strC
                lngState = lngState Or cStateSqBracket

            ElseIf strC = "#" Then
                str = str & strC
                lngState = lngState Or cStateError

            ElseIf strC = "!" Then
                j = TokenCount(udtTokens())
                If j >= 1 Then
                    If (udtTokens(j).lngType And (tkt_OperatorInfix Or tkt_OperatorReference)) = (tkt_OperatorInfix Or tkt_OperatorReference) And _
                        udtTokens(j).strValue = ":" And _
                       (udtTokens(j - 1).lngType And tkt_Operand) = tkt_Operand Then
                        str = udtTokens(j - 1).strValue & ":" & str
                        TokenPop udtTokens(), True
                        TokenPop udtTokens(), True
                    End If
                End If
                TokenPush udtTokens(), str, IIf(InStr(1, str, ":") = 0, tkt_OperandReferenceWksQual, tkt_OperandReference3DWksQual)
                TokenPush udtTokens(), strC, tkt_OperatorInfix Or tkt_OperatorReference

            ElseIf strC = "+" Or strC = "-" Then
                If str <> "" Then
                    If Right(str, 1) = "E" And IsNumeric(Left(str, Len(str) - 1)) Then
                        str = str & strC
                    Else
                        TokenPush udtTokens(), str, tkt_OperandUnknown
                    End If
                End If
                If str = "" Then
                    j = TokenPop(udtTokens, False).lngType
                    If ((j And (tkt_Array Or tkt_End)) = (tkt_Array Or tkt_End) Or _
                        (j And (tkt_Function Or tkt_End)) = (tkt_Function Or tkt_End) Or _
                        (j And (tkt_Expression Or tkt_End)) = (tkt_Expression Or tkt_End) Or _
                        (j And tkt_Operand) = tkt_Operand Or _
                        (j And tkt_OperatorPostfix) = tkt_OperatorPostfix) Then
                        j = tkt_OperatorInfix Or tkt_OperatorArithmetic
                    Else
                        j = tkt_OperatorPrefix Or tkt_OperatorArithmetic
                    End If
                    TokenPush udtTokens, strC, j
                End If

            ElseIf strC = "*" Or strC = "/" Or strC = "^" Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                TokenPush udtTokens, strC, tkt_OperatorInfix Or tkt_OperatorArithmetic

            ElseIf strC = "%" Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                TokenPush udtTokens, strC, tkt_OperatorPostfix Or tkt_OperatorArithmetic

            ElseIf strC = "=" Or strC = ">" Or strC = "<" Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                Select Case strC & Mid(strFormula, i + 1, 1)
                    Case ">=", "<=", "<>"
                        strC = strC & Mid(strFormula, i + 1, 1)
                        i = i + 1
                End Select
                TokenPush udtTokens(), strC, tkt_OperatorInfix Or tkt_OperatorComparison

            ElseIf strC = "&" Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                TokenPush udtTokens, strC, tkt_OperatorInfix Or tkt_OperatorText

            ElseIf strC = ":" Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                TokenPush udtTokens, strC, tkt_OperatorInfix Or tkt_OperatorReference

            ElseIf strC = " " Or strC = vbLf Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                str = strC
                Do
                    strC = Mid(strFormula, i + 1, 1)
                    If strC = " " Or strC = vbLf Then
                        str = str & strC
                        i = i + 1
                    Else
                        Exit Do
                    End If
                Loop
                TokenPush udtTokens(), str, tkt_WhiteSpace

            ElseIf strC = "(" Then
                j = IIf(str = "", tkt_Expression, tkt_Function) Or tkt_Begin
                str = str & strC
                TokenPush udtTokens(), str, j
                TokenPush udtTokenStack(), str, j

            ElseIf strC = ")" Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                j = TokenPop(udtTokenStack(), True).lngType
                TokenPush udtTokens(), strC, j And Not tkt_Begin Or tkt_End

            ElseIf strC = strListSeparator Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown

                If (TokenPop(udtTokenStack(), False).lngType And tkt_Function) = tkt_Function Then
                    TokenPush udtTokens(), strC, tkt_FunctionArgument
                Else
                    TokenPush udtTokens(), strC, tkt_OperatorInfix Or tkt_OperatorReference
                End If

            Else
                str = str & strC

            End If

        ElseIf (lngState And cStateArray) = cStateArray Then
            If strC = strRightBrace Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                lngState = (lngState And Not cStateArray Or cStateDefault)
                j = TokenPop(udtTokenStack(), True).lngType
                TokenPush udtTokens(), strC, j And Not tkt_Begin Or tkt_End

            ElseIf strC = """" Then
                lngState = lngState Or cStateText

            ElseIf strC = "#" Then
                str = str & strC
                lngState = lngState Or cStateError

            ElseIf strC = strRowSeparator Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                TokenPush udtTokens(), strC, tkt_ArrayRow

            ElseIf strC = strColumnSeparator Then
                If str <> "" Then TokenPush udtTokens(), str, tkt_OperandUnknown
                TokenPush udtTokens(), strC, tkt_ArrayCol

            Else
                str = str & strC

            End If

        End If

        i = i + 1
    Loop

    If str <> "" Then TokenPush udtTokens, str, tkt_OperandUnknown

    j = TokenCount(udtTokens)

    i = 1
    Do Until i > j - 1
        If (udtTokens(i).lngType And tkt_WhiteSpace) = tkt_WhiteSpace Then
            If ((udtTokens(i - 1).lngType And (tkt_Function Or tkt_End)) = (tkt_Function Or tkt_End) Or _
                (udtTokens(i - 1).lngType And (tkt_Expression Or tkt_End)) = (tkt_Expression Or tkt_End) Or _
                (udtTokens(i - 1).lngType And tkt_Operand) = tkt_Operand) And _
               ((udtTokens(i + 1).lngType And (tkt_Function Or tkt_Begin)) = (tkt_Function Or tkt_Begin) Or _
                (udtTokens(i + 1).lngType And (tkt_Expression Or tkt_Begin)) = (tkt_Expression Or tkt_Begin) Or _
                (udtTokens(i + 1).lngType And tkt_Operand) = tkt_Operand) Then
                udtTokens(i).lngType = tkt_OperatorInfix Or tkt_OperatorReference
            End If

        ElseIf (udtTokens(i).lngType And tkt_OperatorReference) = tkt_OperatorReference And udtTokens(i).strValue = ":" And _
               (udtTokens(i - 1).lngType And tkt_Operand) = tkt_Operand And _
               (udtTokens(i + 1).lngType And tkt_Operand) = tkt_Operand Then
            If isColumn(udtTokens(i - 1).strValue) And isColumn(udtTokens(i + 1).strValue) Then
                udtTokens(i - 1).strValue = udtTokens(i - 1).strValue & ":" & udtTokens(i + 1).strValue
                udtTokens(i - 1).lngType = tkt_OperandReferenceRange
                TokenPop udtTokens, True, i
                TokenPop udtTokens, True, i
                j = j - 2
                i = i - 1
            ElseIf isRow(udtTokens(i - 1).strValue) And isRow(udtTokens(i + 1).strValue) Then
                udtTokens(i - 1).strValue = udtTokens(i - 1).strValue & ":" & udtTokens(i + 1).strValue
                udtTokens(i - 1).lngType = tkt_OperandReferenceRange
                TokenPop udtTokens, True, i
                TokenPop udtTokens, True, i
                j = j - 2
                i = i - 1
            End If
        End If
        i = i + 1
    Loop

    For i = 0 To j
        If (udtTokens(i).lngType And tkt_OperandUnknown) = tkt_OperandUnknown Then
            str = udtTokens(i).strValue

            If IsNumeric(str) Then
                udtTokens(i).lngType = tkt_OperandNumber
            Else
                If UCase(str) = UCase(True) Or UCase(str) = UCase(False) Then
                    udtTokens(i).lngType = tkt_OperandBoolean
                Else
                    If IsReferenceA1(str) Then
                        udtTokens(i).lngType = tkt_OperandReferenceRange
                    Else
                        udtTokens(i).lngType = tkt_OperandReferenceName
                    End If
                End If
            End If
        End If
    Next

    ParseFormula = udtTokens()
End Function

Public Function TokenCount(udtTokens() As token)
    On Error Resume Next
    TokenCount = -1: TokenCount = UBound(udtTokens)
End Function

Private Function isColumn(strReference As String) As Boolean
    Dim str As String, i As Long, bln As Boolean

    i = 1
    If Left(strReference, 1) = "$" Then i = i + 1
    str = UCase(Mid(strReference, i))
    If str Like "[A-H][A-Z]" Or str Like "I[A-V]" Then
        bln = True
    ElseIf str Like "[A-Z]" Then
        bln = True
    Else
        bln = False
    End If
    isColumn = bln
End Function

Private Function isRow(strReference As String) As Boolean
    Dim str As String, i As Long, lng As Long, bln As Boolean

    bln = True
    i = 1
    If Left(strReference, 1) = "$" Then i = i + 1
    str = Mid(strReference, i)
    If IsNumeric(str) Then
        lng = str
        If lng = str Then
            If Not (lng >= 1 And lng <= 65536) Then bln = False
        Else
            bln = False
        End If
    Else
        bln = False
    End If
    isRow = bln
End Function

Private Function IsReferenceA1(strReference As String) As Boolean
    Dim str As String, i As Long, lng As Long, bln As Boolean

    bln = True
    i = 1
    If Left(strReference, 1) = "$" Then i = i + 1
    str = UCase(Mid(strReference, i, 2))
    If str Like "[A-H][A-Z]" Or str Like "I[A-V]" Then
        i = i + 2
    ElseIf str Like "[A-Z]#" Then
        i = i + 1
    ElseIf str Like "[A-Z]$" Then
        i = i + 1
    Else
        bln = False
    End If
    If bln Then
        If Mid(strReference, i, 1) = "$" Then i = i + 1
        str = Mid(strReference, i)

        If IsNumeric(str) Then
            lng = str
            If lng = str Then
                If Not (lng >= 1 And lng <= 65536) Then bln = False
            Else
                bln = False
            End If
        Else
            bln = False
        End If
    End If

    IsReferenceA1 = bln
End Function

Private Sub TokenPush(udtTokens() As token, strValue As String, lngType As Long)
    Dim i As Long

    i = TokenCount(udtTokens()) + 1
    ReDim Preserve udtTokens(i)
    udtTokens(i).strValue = strValue
    udtTokens(i).lngType = lngType

    strValue = ""
End Sub

Private Function TokenPop(udtTokens() As token, blnRemove As Boolean, Optional lngOffset As Long = -1) As token
    Dim i As Long, lngBound As Long

    lngBound = -1: On Error GoTo e: lngBound = UBound(udtTokens): On Error GoTo 0
    If lngOffset <> -1 Then i = lngOffset Else i = lngBound
    TokenPop.strValue = udtTokens(i).strValue
    TokenPop.lngType = udtTokens(i).lngType
    If blnRemove Then
        If lngBound = 0 Then
            Erase udtTokens
        Else
            If lngOffset <> -1 Then
                For i = lngOffset To lngBound - 1
                    udtTokens(i) = udtTokens(i + 1)
                Next
            End If
            ReDim Preserve udtTokens(lngBound - 1)
        End If
    End If
e:
End Function

Public Function TokenTypeDescription(TokenType As Long) As String
    Dim str As String

    Select Case TokenType
        Case tkt_OperandUnknown: str = "Operand Unknown"
        Case tkt_OperandText: str = "Operand Text"
        Case tkt_OperandError: str = "Operand Error"
        Case tkt_OperandNumber: str = "Operand Number"
        Case tkt_OperandBoolean: str = "Operand Boolean"
        Case tkt_OperandReferenceWksQual: str = "Operand Worksheet"
        Case tkt_OperandReference3DWksQual: str = "Operand Worksheet 3D"
        Case tkt_OperandReferenceRange: str = "Operand Reference Range"
        Case tkt_OperandReferenceName: str = "Operand Reference Named Range"
        
        Case tkt_WhiteSpace: str = "White Space"

        Case (tkt_OperatorPrefix Or tkt_OperatorArithmetic): str = "Operator Arithmetic Prefix"
        Case (tkt_OperatorInfix Or tkt_OperatorArithmetic): str = "Operator Arithmetic Infix"
        Case (tkt_OperatorPostfix Or tkt_OperatorArithmetic): str = "Operator Arithmetic Postfix"
        Case (tkt_OperatorInfix Or tkt_OperatorComparison): str = "Operator Comparison Infix"
        Case (tkt_OperatorInfix Or tkt_OperatorText): str = "Operator Text Infix"
        Case (tkt_OperatorInfix Or tkt_OperatorReference): str = "Operator Reference Infix"

        Case (tkt_Begin Or tkt_Expression): str = "Expression Begin"
        Case (tkt_End Or tkt_Expression): str = "Expression End"

        Case (tkt_Begin Or tkt_Function): str = "Function Begin"
        Case (tkt_End Or tkt_Function): str = "Function End"
        Case tkt_FunctionArgument: str = "Function Argument"

        Case (tkt_Begin Or tkt_Array): str = "Array Begin"
        Case (tkt_End Or tkt_Array): str = "Array End"
        Case tkt_ArrayCol: str = "Array Column"
        Case tkt_ArrayRow: str = "Array Row"
    End Select

    TokenTypeDescription = str
End Function
Attribute VB_Name = "LibCodeUpdate"
Option Explicit



' LiquiUtility: transform old Liquiplan models
' btn.caption = "|fffd|lteres Modell aktualisieren"

' template bk:  active, latest version; all code copied into target
' source book:  to be opened, old version; to be copied and updated
' target book:  new workbook, result; sheets of source to be copied into

' approach: copy sheets source ~> target
'           copy code by exporting/importing of modules source ~> target
'
' difficulty: links to original on 'Soll-Ist'
'   ==> remove links: find/replace string, break links
'
'
Function doModelUpdate() As String
' (Wrapper) <~ Sub menuCodeUpdate()
Dim abk As Workbook, ubk As Workbook, wb As Workbook
Dim srcSheet As Worksheet, monthCell As Range, mainName As String
Dim logPath As String, msg As String, sError As String
Dim ubkPath As String

Const msgTitle As String = "Liquiplan aktualisieren ..."
    
    Application.EnableEvents = False
    
    Set abk = Application.ActiveWorkbook
    If gs_MainSheetName = "" Then   ' Or gn_monthRow = 0
        Set srcSheet = validateMainSheet(sError)
        If srcSheet Is Nothing Then
            msg = sError & vbLf & "Keine LiquiPlan Vorlage."
            MsgBox msg, vbExclamation, cs_MsgTitle
Application.EnableEvents = True
Exit Function
        End If
    End If
    
Debug.Print "=========="
    Set ubk = updateModel(logPath, sError)
    
    If ubk Is Nothing Then
Debug.Print "doModelUpdate(..)", "Aktualisierung abgebrochen."
        MsgBox sError & vbLf & vbLf & "Aktualisierung abgebrochen.", vbInformation, msgTitle
        Application.EnableEvents = True
Exit Function
    End If
    If sError <> "" Then
        MsgBox sError, vbInformation, msgTitle
    End If

On Error GoTo UPDATE_ERROR
    ' success
    ' must not close template book; its code is what's being executed
'    abk.Close False

    ' default start setting (previous year links)
    ubk.UpdateLinks = xlUpdateLinksAlways
    ubkPath = ubk.FullName

    Set srcSheet = Nothing
    On Error Resume Next
        ubk.Activate
        Set srcSheet = ubk.Worksheets(cs_MainSheet_BasicModel)
        If srcSheet Is Nothing Then Set srcSheet = ubk.Worksheets(cs_MainSheet_ProfitCenter)
        If Not srcSheet Is Nothing Then
            srcSheet.Activate
            srcSheet.Select
            srcSheet.Cells(17, 3).Select
        End If
' model protection not that simple: template and source/updated copy can be arbitrarily different
' must be done at first Open; in updated copy, all sheets are unprotected
' ??? set flag in options sheet ???
' restoreModelProtection  ' prompt:=False    ' in ubk = ActiveWorkbook
    On Error GoTo UPDATE_ERROR
    
Dim wsh As Worksheet, shx As Long
Debug.Print "doModelUpdate(..)", ubk.name
    ' unprotect non-Liqui sheets
    For Each wsh In ubk.Worksheets
        If (Not isLiquiplanSheet(wsh)) Then
            If wsh.ProtectContents Then
                On Error GoTo UPDATE_ERROR
                On Error Resume Next
                wsh.Unprotect cs_LiquiPWD
                wsh.Unprotect ""
                wsh.Unprotect "LiquiConsult"
                wsh.Unprotect "xxxxx"
                On Error GoTo 0
            End If
        End If
    Next
    
    hideMasterSheets ubk
    
'    For shx = 1 To ubk.Worksheets.Count
'        Set wsh = ubk.Worksheets(shx)
'Debug.Print "doModelUpdate(..)", wsh.name, wsh.ProtectContents
'    Next
        
''' experimental: set password for VBProject
''ubk.VBProject.name = "LiquiTemp"
''SetPassword ubk.VBProject, "pwd"
''ubk.VBProject.name = "LiquiPlan"

' must close new book; macro security may pevent code execution
    msg = "Aktualisierung erfolgreich." & vbCrLf & ubk.name
    
    Application.Calculation = xlCalculationAutomatic
    Application.DisplayAlerts = False
        ubk.Save
        ubk.Close
    Application.DisplayAlerts = True
Application.StatusBar = False
    
    ' reset active Liquiplan (gs_MainSheetName etc.)
Dim mainSh As Worksheet
    abk.Activate
Debug.Print gs_MainSheetName
    Set mainSh = validateMainSheet(sError)
Debug.Print gs_MainSheetName
    If Not (mainSh Is Nothing) Then
        mainSh.Activate
    Else
        ' quite unlikely
        MsgBox "Schwerwiegender Fehler: " & vbLf & sError
    End If

    If logPath = "" Then
        MsgBox msg, vbInformation, msgTitle
    Else
        ' if new model was validated
        msg = msg & vbCrLf & vbCrLf & "Protokoll |fffd|ffnen ?"
        If MsgBox(msg, vbYesNo, msgTitle) = vbYes Then
            Shell "notepad.exe " & logPath, 1
        End If
    End If
'Debug.Print msg
      
On Error GoTo 0
    doModelUpdate = ubkPath
Exit Function

UPDATE_ERROR:
    Debug.Print Err.Description
    Err.Clear
    Stop
    Resume Next

End Function

Function updateModel(logPath As String, sError As String) As Workbook
Const msgTitle As String = "Liquiplan aktualisieren ..."
Const doOpen As Boolean = True

Dim templtBook As Workbook, sourceBook As Workbook, targetBook As Workbook, wb As Workbook
Dim sourcePath As Variant, sourceName As String, sourceParent As String
Dim sourceMonthRow As Long
Dim targetPath As Variant, targetName As String
Dim templtProject As VBProject, targetProject As VBProject, vbPrj As VBProject
Dim mainSheet As Worksheet, sourceMainIndex As Long, compareSheet As Worksheet, ws As Worksheet, ch As Chart, idx As Long
Dim templtMainSheet As Worksheet
Dim sVersion As String
Dim step As String, msg As String

'Debug.Print vbCrLf & "====="
    
    Set updateModel = Nothing
    sVersion = Application.Version
    sVersion = nextValue(sVersion, ".")
    If CInt(sVersion) <= 11 Then
        sError = "Dieser Vorgang erfordert Office 2007 oder j|fffd|nger."
Exit Function
    End If

    If Application.ActiveWorkbook Is Nothing Then
Exit Function
    End If
    Set templtBook = Application.ActiveWorkbook
    
    Set mainSheet = Nothing
    For idx = 1 To templtBook.Worksheets.Count
        Set ws = templtBook.Worksheets(idx)
        If (ws.name = cs_MainSheet_BasicModel Or ws.name = cs_MainSheet_ProfitCenter) Then
            Set mainSheet = ws
            Exit For
        End If
    Next
    Set compareSheet = Nothing
    For idx = 1 To templtBook.Worksheets.Count
        Set ws = templtBook.Worksheets(idx)
        If ws.name = cs_CompareSheetName Then
            Set compareSheet = ws
            Exit For
        End If
    Next
    If mainSheet Is Nothing Or compareSheet Is Nothing Then
        sError = "Keine g|fffd|ltige Vorlage ausgew|fffd|hlt."
Exit Function
    End If
    
    ' macro security
    Set templtMainSheet = mainSheet
    Set templtProject = Nothing
    On Error Resume Next
        Set templtProject = templtBook.VBProject
    On Error GoTo 0
    If templtProject Is Nothing Then
        sError = "Einstellungen zur Makrosicherheit:" & _
                    vbLf & "Diese Funktion verlangt, dass Sie dem Zugriff auf das VBA-Projektobjektmodell vertrauen."
Exit Function
    End If
    
Dim templtThisWB As VBComponent, targetThisWB As VBComponent, cmp As VBComponent
Dim templtMainCmp As VBComponent, templtCompareCmp As VBComponent, templtLiquiCode As VBComponent
Dim Code As CodeModule, codeString As String

    ' project must not be locked
    Set cmp = Nothing
    On Error Resume Next
        Set cmp = templtProject.VBComponents(1)
    On Error GoTo 0
    If cmp Is Nothing Then
        sError = "Diese Funktion verlangt die Eingabe des Kennworts f|fffd|r das VBA-Projekt."
Exit Function
''' experimental: set password for VBProject
''SetPassword templtProject, "pwd"
    End If
''On Error GoTo NO_STOP
''Stop
''On Error GoTo 0

    For Each cmp In templtProject.VBComponents
'Debug.Print cmp.name, cmp.Type
        If cmp.Type = vbext_ct_Document Then
            If (cmp.name = "DieseArbeitsmappe" Or cmp.name = "ThisWorkbook") Then
                Set templtThisWB = cmp
            ElseIf cmp.name = mainSheet.CodeName Then
                Set templtMainCmp = cmp
            ElseIf cmp.name = compareSheet.CodeName Then
                Set templtCompareCmp = cmp
            End If
        ElseIf cmp.Type = vbext_ct_ClassModule Then
        
        ElseIf cmp.Type = vbext_ct_MSForm Then
        
        ElseIf cmp.Type = vbext_ct_StdModule Then
            If cmp.name = "LiquiCode" Then
                Set templtLiquiCode = cmp
            End If
        End If
    Next
    If (templtThisWB Is Nothing Or templtMainCmp Is Nothing Or templtCompareCmp Is Nothing Or templtLiquiCode Is Nothing) Then
        sError = "Keine g|fffd|ltige Vorlage ausgew|fffd|hlt."
Exit Function
    End If
    
'Debug.Print templtProject.name
'Debug.Print templtProject.VBE.VBProjects.count
'Debug.Print templtThisWB.name, templtLiquiCode.name
'    For Each vbPrj In templtProject.VBE.VBProjects
'Debug.Print vbPrj.name
'    Next

    Set sourceBook = Nothing
    If Not sourceBook Is Nothing Then
'        sourcePath = sourceBook.FullName
'        sourceName = Mid(sourcePath, InStrRev(sourcePath, "\") + 1)
'        sourceParent = Left(sourcePath, InStrRev(sourcePath, "\"))
''Debug.Print sourcePath
''Debug.Print sourceName

    ElseIf doOpen Then
    
GetSource:
        sourcePath = pickFile("Zu aktualisierends Liquiplan Modell w|fffd|hlen ...", templtBook.path & "\")
'Debug.Print sourcePath
        If VarType(sourcePath) = vbBoolean Then
            ' canceled
            sourcePath = ""
        End If
        If sourcePath = "" Then
            sError = ""
Exit Function
        End If
        
        sourceParent = Left(sourcePath, InStrRev(sourcePath, "\"))
        sourceName = Mid(sourcePath, InStrRev(sourcePath, "\") + 1)
'Debug.Print sourceName
  
        ' load source file ...
        ' unless already open
        Set sourceBook = Nothing
        On Error Resume Next
        Set sourceBook = Application.Workbooks(sourceName)
        On Error GoTo 0
        If sourceName = templtBook.name Then
            msg = sourceName
            msg = msg & vbCrLf & "Eine Arbeitsmappe gleichen Namens ist als Vorlage ge|fffd|ffnet." & vbCrLf & "Bitte andere Quelle ausw|fffd|hlen."
            MsgBox msg, , msgTitle
            'repeat
            GoTo GetSource
            
        ElseIf Not sourceBook Is Nothing Then
            msg = sourceName
            msg = msg & vbCrLf & "Eine Arbeitsmappe gleichen Namens ist bereits ge|fffd|ffnet." & vbCrLf & "Als Quelle |fffd|bernehmen ?"
            If MsgBox(msg, vbYesNo, msgTitle) = vbYes Then
            Else
                'repeat
                GoTo GetSource
            End If
        Else
            Set sourceBook = Application.Workbooks.Open(sourcePath, False, True)
        End If
        If sourceBook Is Nothing Then
            msg = "Keine g|fffd|ltige Arbeitsmappe ausgew|fffd|hlt." & vbLf & "Aktualisierung beenden ?"
            If MsgBox(msg, vbYesNo, msgTitle) = vbNo Then
                'repeat
                GoTo GetSource
            Else
                sError = ""
Exit Function
            End If
        End If
    Else ' w/o open
        sError = "Keine |fffd|ltere Liquiplan-Arbeitsmappe ge|fffd|ffnet."
Exit Function
    End If
    
    ' valid Liquiplan workbook ?
    Set mainSheet = Nothing
    sourceMainIndex = 0
    For idx = 1 To sourceBook.Worksheets.Count
        Set ws = sourceBook.Worksheets(idx)
        If (ws.name = cs_MainSheet_BasicModel Or ws.name = cs_MainSheet_ProfitCenter) Then
            Set mainSheet = ws
            sourceMainIndex = idx
            Exit For
        End If
    Next
    If mainSheet Is Nothing Then
        msg = "Keine g|fffd|ltige Liquiplan-Arbeitsmappe ausgew|fffd|hlt." & vbLf & "Aktualisierung beenden ?"
        If MsgBox(msg, vbYesNo, msgTitle) = vbNo Then
            sourceBook.Close False
            GoTo GetSource
        Else
Exit Function
        End If
    End If

On Error GoTo UPDATE_ERROR
Dim fso As FileSystemObject

    Set fso = New FileSystemObject
    targetPath = Mid(sourcePath, 1, InStrRev(sourcePath, ".") - 1) + " (aktualisiert " & cs_Version & cs_VersionSuffix & ").xlsm"
'Debug.Print targetPath
SELECT_TARGET:
If True Then
Dim fd As office.FileDialog
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        .AllowMultiSelect = False
        .title = "|fffd|lteres Modell aktualisieren."
        .InitialFileName = targetPath
'Debug.Print .InitialFileName, .Filters.Count, .FilterIndex
        .FilterIndex = 2    ' xlsm
        If .Show = True Then
            targetPath = .SelectedItems(1)
        Else
            targetPath = ""
        End If
    End With
    If targetPath = "" Then
        ' clean-up ...
        sourceBook.Close False
        Set sourceBook = Nothing
Exit Function
    End If
    
Else    ' False
'    targetPath = Application.GetSaveAsFilename(targetPath, _
'                    "Excel-Arbeitsmappe mit Makros(*.xlsm), *.xlsm", 1, _
'                    "Aktualisierte Arbeitsmappe speichern ...") '
''Debug.Print targetPath
'    If VarType(targetPath) = vbBoolean Then
'        ' clean-up ...
'        sourceBook.Close False
'        Set sourceBook = Nothing
'Exit Function
'    End If
'    If (fso.FileExists(targetPath)) Then
'        If MsgBox("Zieldatei existiert; |fffd|berschreiben ?", vbYesNo, msgTitle) = vbNo Then
'            GoTo SELECT_TARGET
'        End If
'    End If
End If
    
    targetName = fso.GetFileName(targetPath)
    Set wb = Nothing
    On Error Resume Next
        Set wb = Application.Workbooks(targetName)
    On Error GoTo UPDATE_ERROR
    If Not wb Is Nothing Then
        MsgBox "Es ist bereits ein Dokument mit dem von Ihnen angegebenen Namen ge|fffd|ffnet.", vbInformation, msgTitle
        GoTo SELECT_TARGET  ' repeat
    End If
    
    ' options: copy comments, validate new
Dim isCopyComments As Boolean, isValidateModel As Boolean
    gb_isUserOK = False
    With frmOptions
        .caption = "VBA-COde aktualisieren"
        .BorderStyle = fmBorderStyleSingle
        .lblDescription = "Neues Modell: " & fso.GetFileName(targetPath)
        .chkOption1.caption = "Kommentare |fffd|bertragen"
        .chkOption1.value = False
        .chkOption1.Enabled = True
        .chkOption2.caption = "Neues Modell |fffd|berpr|fffd|fen"
        .chkOption2.value = False
        .chkOption2.Enabled = True
        
        .chkOption1.visible = True
        .chkOption2.visible = False ' True
        .chkOption3.visible = False
        .radioButton2a.visible = False
        .radioButton2b.visible = False
        
'        .chkOption1.Top = 48 - 6
'        .chkOption1.Left = 48 + 12

        .btnOK.Top = 126 - 24
        .btnCancel.Top = 126 - 24
        .height = 170 - 12
        .Show
        
        If gb_isUserOK Then
            isCopyComments = .chkOption1
            isValidateModel = .chkOption2
        Else
            ' cancel process
            sError = ""
Exit Function
        End If
    End With
    
    Set targetBook = Application.Workbooks.Add()
step = "Initial Save As"
    Application.DisplayAlerts = False
        targetBook.SaveAs fileName:=targetPath, FileFormat:=xlOpenXMLWorkbookMacroEnabled ' xlOpenXMLWorkbook   '
    Application.DisplayAlerts = True
    
    targetBook.Application.ScreenUpdating = False
    
Dim emptyWorksheetsCount As Long
    emptyWorksheetsCount = targetBook.Worksheets.Count
    
    Set targetProject = targetBook.VBProject
    ' needed: FileSystemObject
    addReference targetProject, "Scripting", "C:\WINDOWS\system32\scrrun.dll"
    ' needed: VBA project model
Dim sPF As String
    sPF = Get32BitProgramFilesPath()
    addReference targetProject, "VBIDE", sPF & "\Common Files\microsoft shared\VBA\VBA6\VBE6EXT.OLB"
    
' get work sheets of profit center source book in order;
' in target book, sheets must exist before being referenced in consolidation formulae copied
' if one of the formulae copied refers to a sheet not copied yet, Excel tries to get it
' => ToDo:  first add and name all sheets, then copy formulae
'        ||
'           reorder sheets in source book before copying
Application.StatusBar = "Aufr|fffd|umen"
DoEvents

Dim masterSheet As Worksheet
    If sourceMainIndex > 1 Then
        With sourceBook
            Set masterSheet = Nothing
                For idx = 1 To .Worksheets.Count
                    Set ws = .Worksheets(idx)
                    If ws.name = cs_MasterSheetName Then
                        Set masterSheet = ws
                    ElseIf Not masterSheet Is Nothing And startsWith(ws.name, cs_MasterPrefix, vbTextCompare) Then
'Debug.Print "place:", ws.name, "before:=", masterSheet.name
                        ws.Move before:=masterSheet
                    End If
                Next
        End With
    End If
    
    ' copy worksheets and charts source ~> target
    ' ! .copy copies code as well ! will be removed below
Dim sh2 As Worksheet, rng As Range
Application.StatusBar = "Arbeitsbl|fffd|tter"
DoEvents
    For Each ws In sourceBook.Worksheets
step = "Kopieren: " & ws.name
Application.StatusBar = "Kopieren: " & ws.name
DoEvents
        ' skip obsolete graphics/plot data sheets
        If LCase(ws.name) <> "sollistplotdaten" And InStr(1, LCase(ws.name), "plotdaten(") = 0 Then
        
' avoid SC icon issue: to get rid of bunches of the SC logo,
' don't copy sheet but create sheet and add
            If (True Or ws.name <> cs_MasterSheetName) Then ' And Not startsWith(ws.name, "OrigPD(", vbTextCompare)
'Debug.Print "copy:", ws.name, "after:=", targetBook.Worksheets(targetBook.Worksheets.Count).name
                
                ' issue: crash if ws is very hidden
                Dim vis As XlSheetVisibility
                vis = ws.visible
                If (vis = xlSheetVeryHidden) Then
                    ws.visible = xlSheetHidden
'Debug.Print step
                End If
                ws.Copy after:=targetBook.Worksheets(targetBook.Worksheets.Count)
                ws.visible = vis
            Else
            End If
        End If
Application.StatusBar = "Kopieren: " & ws.name
DoEvents
    Next
'For Each ws In targetBook.Worksheets
'Debug.Print "copy", ws.name, ws.ProtectContents
'Next

Application.StatusBar = "Diagramme"
DoEvents
    For Each ch In sourceBook.Charts
step = "Kopieren: " & ch.name
Application.StatusBar = "Kopieren: " & ch.name
DoEvents
On Error Resume Next
'Debug.Print "copy:", ch.name, "after:=", targetBook.sheets(targetBook.sheets.Count).name
On Error GoTo UPDATE_ERROR
        ch.Copy after:=targetBook.Sheets(targetBook.Sheets.Count)
Application.StatusBar = "Kopieren: " & ch.name
DoEvents
    Next
'For Each ch In targetBook.Charts
'Debug.Print "copy", ch.name, ch.ProtectContents
'Next
    
    ' remove w/o prompt one or more empty sheets created with new book
    targetBook.Sheets(1).Activate
'step = targetBook.sheets(1).name
    Application.DisplayAlerts = False
        For idx = 1 To emptyWorksheetsCount
            targetBook.Sheets(1).Delete
        Next
    Application.DisplayAlerts = True
    
Dim mainName As String
    mainName = mainSheet.name
    targetBook.Sheets(mainName).Activate
step = "Sheets copied"
    Application.DisplayAlerts = False
        targetBook.Save
    Application.DisplayAlerts = True
    
    'source book done; don't save ad-hoc changes, no prompt
    sourceBook.Close False
    Set sourceBook = Nothing
        
Application.StatusBar = "VBA Komponenten"
DoEvents
Dim path As String
    ' update target project
    With targetProject
        ' all class and standard modules of template book
        ' 2016-11 stand-alone: forms as well
step = "Adding code modules"
        For Each cmp In templtProject.VBComponents
'Application.StatusBar = "VBA Komponente: " & cmp.name
'DoEvents
'Debug.Print cmp.name, cmp.Type
            If cmp.Type = vbext_ct_Document Then    ' Or cmp.Type = vbext_ct_MSForm
            '
            ElseIf cmp.Type = vbext_ct_StdModule Or cmp.Type = vbext_ct_ClassModule Or cmp.Type = vbext_ct_MSForm Then
                If cmp.CodeModule.CountOfLines > 1 Then
                    path = sourceParent & cmp.name & IIf(cmp.Type = vbext_ct_MSForm, ".frm", _
                                                        IIf(cmp.Type = vbext_ct_StdModule, ".bas", ".cls"))
'step = "Adding module '" & cmp.name & "'"
'Debug.Print step, path
                    cmp.Export path
                    .VBComponents.Import path
                    fso.DeleteFile FileSpec:=path, force:=True
                    If cmp.Type = vbext_ct_MSForm Then
                        fso.DeleteFile FileSpec:=Replace(path, ".frm", ".frx"), force:=True
                    End If
                End If
            End If
        Next
step = "Code modules added"
        Application.DisplayAlerts = False
            targetBook.Save
        Application.DisplayAlerts = True
'Debug.Print step

Application.StatusBar = "DieseArbeitsmappe"
DoEvents
        ' find in target "DieseArbeitsmappe" ("ThisWorkbook"), replace code
        Set Code = templtThisWB.CodeModule
        codeString = Code.lines(1, Code.CountOfLines)
        For Each cmp In .VBComponents
'Debug.Print cmp.name, cmp.Type
            If (cmp.Type = vbext_ct_Document) Then
                If (cmp.name = "DieseArbeitsmappe" Or cmp.name = "ThisWorkbook") Then
                    With cmp.CodeModule
                        .DeleteLines 1, .CountOfLines
                        .AddFromString codeString
                    End With
                    Exit For
                End If
            End If
        Next
        
step = "'ThisWorkbook' updated"
        Application.DisplayAlerts = False
            targetBook.Save
        Application.DisplayAlerts = True
'Debug.Print step
        
Application.StatusBar = "Tabellen"
DoEvents
        For Each ws In targetBook.Worksheets
            For Each cmp In .VBComponents
                If (cmp.Type = vbext_ct_Document) Then
                    If (cmp.name = ws.CodeName) Then
'Debug.Print ws.CodeName & " (" & ws.name & ")"
                        With cmp.CodeModule
                            .DeleteLines 1, .CountOfLines
                        End With
                        Exit For
                    End If
                End If
            Next
        Next
    End With
    Application.DisplayAlerts = False
        targetBook.Save
    Application.DisplayAlerts = True
    
    
Dim wsh As Worksheet, shp As Shape, obj As Object
Dim logoLeft As Long, logoTop As Long, i As Long
Dim user As String, logoPath As String
Dim addLogo As Boolean, logoName As String
Dim visible As XlSheetVisibility, isProtected As Boolean
Dim scrLogo As Shape

Application.StatusBar = "SC Logos"
DoEvents
step = "update SCR logo"
' scan target worksheets for outdated logos (shapes of type Picture)
' find up-to-date logo on template input sheet
' cleanup target input sheets unless target main sheet has up-to-date logo

' Excel 2007 issue: shape has no .title

    addLogo = True
    Set wsh = targetBook.Worksheets(sourceMainIndex)
'Debug.Print wsh.name, wsh.parent.name
    For Each shp In wsh.Shapes
        If startsWith(shp.name, "Picture") Or startsWith(shp.name, "Grafik") Then
            If startsWith(shp.AlternativeText, "Senior Consult Ruhr") Then ' startsWith(shp.title, "SCR") And
                ' valid SCR logo
                addLogo = False
                Exit For
            End If
        End If
    Next
    If Not addLogo Then GoTo LOGO_DONE
    
    ' locate up-to-date logo on mainSheet
    templtBook.Activate
    templtMainSheet.Activate
On Error Resume Next
    templtMainSheet.Unprotect ""
    templtMainSheet.Unprotect cs_LiquiPWD
On Error GoTo UPDATE_ERROR
'Debug.Print templtMainSheet.name, templtMainSheet.parent.name
    Set scrLogo = Nothing
    logoLeft = -1
    logoTop = -1
    For Each shp In templtMainSheet.Shapes
        If startsWith(shp.name, "Picture") Or startsWith(shp.name, "Grafik") Then
            shp.Select
            shp.Locked = msoFalse
'Debug.Print shp.name, shp.TopLeftCell.Address
            If startsWith(shp.AlternativeText, "Senior Consult Ruhr") Then ' startsWith(shp.title, "SCR") Or
                ' valid SCR logo
'Debug.Print shp.name, shp.title, shp.AlternativeText, shp.width, shp.height
                Set scrLogo = shp
                logoLeft = shp.Left
                logoTop = shp.Top
                Exit For
            End If
        End If
    Next shp
    If Not scrLogo Is Nothing Then
        scrLogo.Copy    ' to clipboard
        templtMainSheet.Range("B1").Select
    Else
        GoTo LOGO_DONE
    End If
    
    'clean-up target
    For idx = 1 To sourceMainIndex
        Set wsh = targetBook.Worksheets(idx)
'Debug.Print wsh.name, wsh.parent.name
        wsh.visible = xlSheetVisible
        wsh.Activate
On Error Resume Next
        wsh.Unprotect ""
        wsh.Unprotect cs_LiquiPWD
On Error GoTo UPDATE_ERROR
        For Each shp In wsh.Shapes
            If startsWith(shp.name, "Picture") Or startsWith(shp.name, "Grafik") Then
                shp.Select
                shp.Locked = msoFalse
'Debug.Print shp.name, shp.title, shp.AlternativeText, shp.width, shp.height
                shp.Delete
            End If
        Next
        protectSheet wsh
    Next
    
    ' insert logo
    targetBook.Activate
'    For idx = 1 To sourceMainIndex
        idx = sourceMainIndex
        Set wsh = targetBook.Worksheets(idx)
'Debug.Print wsh.name, wsh.parent.name
        wsh.visible = xlSheetVisible
        wsh.Activate
        On Error Resume Next
        wsh.Unprotect ""
        wsh.Unprotect cs_LiquiPWD
        On Error GoTo UPDATE_ERROR
        Set rng = wsh.Range("M4") ' default UL corner of logo: row=Company, column=October
        rng.Select
        wsh.Pictures.Paste
        ' .title, .AlternativeText are lost during copy & paste
        For Each shp In wsh.Shapes
            If shp.TopLeftCell.Address = "$M$4" Then
                shp.Select
                shp.Locked = msoFalse
'Debug.Print shp.TopLeftCell.Address, shp.title, shp.AlternativeText
'   shp.title = "SCR Logo"
                shp.AlternativeText = "Senior Consult Ruhr" & vbLf & "http://www.senior-consult-ruhr.de/"
                Exit For
            End If
        Next
        protectSheet wsh
'    Next idx
    
LOGO_DONE:
step = "sheets were updated"
    Application.DisplayAlerts = False
        targetBook.Save
    Application.DisplayAlerts = True
'Debug.Print step
    
    ' remove references to source (original) created by copy sheet
    ' and break links
Application.StatusBar = "Verkn|fffd|pfungen"
DoEvents
step = "breaking links"
Debug.Print step, sourcePath
    For Each ws In targetBook.Worksheets
step = "breaking links: " & ws.name
        removeLinks ws, sourcePath  ' leaves ws unprotected
    Next
step = "targetBook.BreakLink"
    targetBook.BreakLink sourcePath, xlLinkTypeExcelLinks
DoEvents
    
    For Each ws In targetBook.Worksheets
        If (Not ws.ProtectContents) Then protectSheet ws
    Next
    
' update comments
' copy all comments template main sheet;
'   ! all columns !
'   ! must not overide formula if column > 2 !

'   ! only if template and source of same type (Basis || ProfitCenter)
'Debug.Print templtMainSheet.name, targetBook.Worksheets(sourceMainIndex).name

Dim cllSrc As Range, rowSrc As Long, clmSrc As Long
Dim cllTrg As Range, rowTrg As Long, clmTrg As Long, lastRowTrg As Long
Dim quantity As String
Dim missed As String, isModelTypesDiffer As Boolean

    isModelTypesDiffer = (templtMainSheet.name <> targetBook.Worksheets(sourceMainIndex).name)
    If isCopyComments And Not isModelTypesDiffer Then
Application.StatusBar = "Kommentare"
step = "update comments"
Application.EnableEvents = False
        For idx = 1 To sourceMainIndex
            ' apply to all input sheets of target book
            Set wsh = targetBook.Worksheets(idx)
            wsh.Unprotect
'Debug.Print wsh.name
Application.StatusBar = "Kommentare aktualisieren: " & wsh.name
DoEvents
'        clmSrc = 2
            clmTrg = 2
            lastRowTrg = 0
            missed = ""
'8.0.1.3: Beispiel 'B|fffd|ckerei'
' inside main sections ( I. thru VI.)
Dim rowTrg_Section_V_Start As Long
            rowTrg = 0
            findTextOrFormula wsh, "Kennzahlen", True, True, rowTrg, clmTrg, , 2
            If rowTrg > 0 Then
                rowTrg_Section_V_Start = rowTrg
            Else
                rowTrg_Section_V_Start = getLastRow(wsh.usedRange)
            End If
            
            For rowSrc = 1 To gn_row_Section_V_End ' getLastRow(templtMainSheet.usedRange)
                Set cllSrc = templtMainSheet.Cells(rowSrc, 2)
                quantity = cllSrc.value
                If quantity = "" Then GoTo NEXT_QUANTITY
                rowTrg = lastRowTrg
                clmTrg = 2
                findTextOrFormula wsh, quantity, True, True, rowTrg, clmTrg, , 2
                If (rowTrg = 0 Or clmTrg = 0) Then
                ' can't find quantity in target
'Debug.Print rowSrc, quantity
                    If Not cllSrc.Comment Is Nothing Then
                        missed = missed & vbCrLf & rowSrc & vbTab & quantity
                    End If
                    GoTo NEXT_QUANTITY
                End If
'8.0.1.3: Beispiel 'B|fffd|ckerei'
                If rowTrg < rowTrg_Section_V_Start Then
                    ' inside main sections
                    lastRowTrg = rowTrg
                End If
'Application.StatusBar = "Zeile " & rowSrc & ": " & quantity
'DoEvents
                For clmSrc = 1 To getLastRow(templtMainSheet.usedRange)
                    clmTrg = clmSrc
                    Set cllSrc = templtMainSheet.Cells(rowSrc, clmSrc)
                    Set cllTrg = wsh.Cells(rowTrg, clmTrg)
                    If cllSrc.Comment Is Nothing Then
                        If Not cllTrg.Comment Is Nothing Then cllTrg.Comment.Delete
                        GoTo NEXT_COMMENT
                    End If
                    If cllSrc.Comment.Text = "" Then
                        If Not cllTrg.Comment Is Nothing Then cllTrg.Comment.Delete
                        GoTo NEXT_COMMENT
                    End If
'Debug.Print rowSrc, cllSrc.value ' cllSrc.Comment.Text

' save target cell contents
Dim tmp As String
                    tmp = cllTrg.FormulaR1C1
                    cllSrc.Copy
                    wsh.Paste Destination:=cllTrg
                    If clmTrg > 2 Then cllTrg.FormulaR1C1 = tmp
NEXT_COMMENT:
                Next clmSrc
NEXT_QUANTITY:
'            DoEvents
            Next rowSrc
Application.CutCopyMode = False
'Application.StatusBar = False
'DoEvents
        Next idx
    Else
        ' comments not being copied
    End If
'Application.EnableEvents = True

    ' outliers
Dim outlierMarked As Boolean    ' overrideMarked As Boolean,
    If isValidateModel Then
Application.StatusBar = "Aktualisiertes Modell |fffd|berpr|fffd|fen"
DoEvents
        For idx = 1 To sourceMainIndex
            Set wsh = targetBook.Worksheets(idx)
Debug.Print wsh.name
Application.StatusBar = "Aktualisiertes Modell |fffd|berpr|fffd|fen: " & wsh.name
DoEvents
'            markOutliersInRows wsh, overrideMarked, outlierMarked
'            markOutliersInYearColumn wsh, overrideMarked, outlierMarked
' drop: use LiquiMenu
'            markOutliers wsh.usedRange, outlierMarked
        Next idx
    End If
    
' write error protocol
Dim logName As String, logStream As TextStream, logLine As String
    If missed <> "" Or outlierMarked Or (isCopyComments And isModelTypesDiffer) Then
        logName = "Protokoll Aktualisierung " & fso.GetBaseName(targetBook.name) & ".txt"
        logPath = longFileName(logName)
        Set logStream = fso.CreateTextFile(logPath, True)
        If Not logStream Is Nothing Then
            If outlierMarked Then   ' overrideMarked Or
                logStream.WriteLine "Abweichungen von Standardformeln wurden markiert."
                logStream.WriteLine
            End If
            If missed <> "" Then
                logStream.WriteLine "Kommentare zu folgenden Zeilen konnten nicht |fffd|bertragen werden:"
                logStream.WriteLine missed
            ElseIf (isCopyComments And isModelTypesDiffer) Then
                logStream.WriteLine "Kommentare wurden nicht |fffd|bertragen; Quelle und Vorlage sind unterschiedlichen Typs."
            End If
            logStream.Close
'            Shell "notepad.exe " & logPath, 1
        ElseIf missed <> "" Then
            MsgBox "Kommentare zu folgenden Zeilen konnten nicht |fffd|bertragen werden:" & vbCrLf & missed, vbInformation, msgTitle
        End If
    End If
    
    
step = "finalize"
    ' voodoo: apply code to formulae in cells
    ' why that ? target book is going to be closed int the end
'    Application.CalculateFull ' Debug.Print's all errors
'    Application.CalculateFullRebuild
'    Application.CalculateFull
'    Application.CalculateFullRebuild
    
    ' save updated target book
    targetBook.Application.ScreenUpdating = True
    Application.DisplayAlerts = False
        targetBook.Save
    Application.DisplayAlerts = True
    
'    templtBook.Close False

    targetBook.Sheets(mainName).Activate
    
On Error GoTo 0
    Set updateModel = targetBook
Application.StatusBar = False
DoEvents

Exit Function
    
UPDATE_ERROR:
    msg = "(error at step '" & step & "') " & Err.Description
    Err.Clear
Debug.Print msg
If True Then
    sError = sError & IIf(sError <> "", vbCrLf, "") & "Unerwartetes Problem: " & msg
    Set updateModel = Nothing
    If Not sourceBook Is Nothing Then
        sourceBook.Close False
        Set sourceBook = Nothing
    End If
    If Not targetBook Is Nothing Then
        targetBook.Close False
        Set targetBook = Nothing
    End If
Else
'   development
    Stop
    Resume Next
End If
Exit Function

NO_STOP:
    msg = "(error at step '" & step & "') " & Err.Description
    Err.Clear
Debug.Print msg
    sError = sError & IIf(sError <> "", vbCrLf, "") & "Unerwartetes Problem: " & msg
    Set updateModel = Nothing
    If Not sourceBook Is Nothing Then
        sourceBook.Close False
        Set sourceBook = Nothing
    End If
    If Not targetBook Is Nothing Then
        targetBook.Close False
        Set targetBook = Nothing
    End If
Exit Function


End Function

Private Sub removeLinks(sh As Worksheet, path As Variant)
'='C:\Users\Hartmann\Documents\Active\LiquiPlan\Library\Update\[Liquidit|fffd|tsplanung 7 1 BasisPlus.xlsm]Umsatz und Liquidit|fffd|t'!$H$4
'='C:\Users\Hartmann\Documents\Active\LiquiPlan\Library\Update Test\[Liquidit|fffd|tsplanung 7 1 BasisPlus.xlsm]Umsatz und Liquidit|fffd|t'!$H$4
'='C:\Users\Hartmann\Documents\Active\LiquiPlan\Library\Update Test\[Liquiditaetsplanung.xlsm]Umsatz und Liquidit|fffd|t'!$H$4

Dim rng As Range, cl As Range, row As Long, clm As Long, width As Long
Dim tmp As String
Dim pos As Long, parent As String, name As String, linkPath As String
    
    ' cross-book references put file name in [...]; see above
    pos = InStrRev(path, "\")
    parent = Left(path, pos)
    name = Mid(path, pos + 1)
    linkPath = parent & "[" & name & "]"
'Debug.Print "removeLinks(..)", linkPath
Debug.Print "removeLinks(..)", sh.name

Application.EnableEvents = False    ' must not trigger re-calculation
On Error GoTo LINK_ERROR
    Set rng = sh.usedRange
    width = getDataWidth(sh)
    For row = 1 To rng.Rows.Count
    For clm = 1 To width
        Set cl = sh.Cells(row, clm)
        If cl.HasFormula Then
            If sh.ProtectContents Then
                On Error Resume Next
                sh.Unprotect ""
                sh.Unprotect "LiquiConsult"
                sh.Unprotect "xxxxx"
                sh.Unprotect cs_LiquiPWD
                On Error GoTo 0
            End If
            If sh.ProtectContents Then
Exit Sub
            End If
            tmp = cl.formula
            If InStr(1, tmp, linkPath) > 0 Then
'Debug.Print tmp
                tmp = Replace(tmp, linkPath, "")
                cl.formula = tmp ' triggers re-calculation, Debug.Print's all errors
            End If
        End If
    Next
    Next
'    If (Not sh.ProtectContents) Then protectSheet sh
Exit Sub

LINK_ERROR:
    tmp = Err.Description
    Err.Clear
    Stop
    Resume Next
End Sub

Private Function addReference(vbProj As VBIDE.VBProject, name As String, fileName As String) As Boolean
' http://stackoverflow.com/questions/9879825/how-to-add-a-reference-programmatically
'Dim VBAEditor As VBIDE.VBE
'Dim vbProj As VBIDE.VBProject
Dim chkRef As VBIDE.Reference
Dim bRefExists As Boolean

Dim bFileExists As Boolean
Dim fso As FileSystemObject

    Set fso = New FileSystemObject

'    Set VBAEditor = Application.VBE
'    Set vbProj = ActiveWorkbook.VBProject

    '~~> Check if reference is already added
    For Each chkRef In vbProj.References
        If chkRef.name = name Then
            bRefExists = True
            GoTo CleanUp
        End If
    Next

    If (fso.FileExists(fileName)) Then
        bFileExists = True
        vbProj.References.AddFromFile fileName
    Else
        bFileExists = False
    End If

CleanUp:
    If bRefExists = True Then
'Debug.Print "Reference already exists"
        addReference = True
    ElseIf bFileExists Then
'Debug.Print "Reference '" & name & "' added successfully"
        addReference = True
    Else
Debug.Print "Reference '" & name & "' does not exist"
        addReference = False
    End If

'    Set vbProj = Nothing
'    Set VBAEditor = Nothing
End Function


' ===== development =====

Function isEditorInSync() As Boolean
'=======================================================================
' IsEditorInSync
' This tests if the VBProject selected in the Project window, and
' therefore the ActiveVBProject is the same as the VBProject associated
' with the ActiveCodePane. If these two VBProjects are the same,
' the editor is in sync and the result is True. If these are not the
' same project, the editor is out of sync and the result is True.
'=======================================================================
    With Application.VBE
        isEditorInSync = .ActiveVBProject Is _
            .ActiveCodePane.CodeModule.parent.Collection.parent
    End With
End Function

' You can force synchronization with code like the following. This will set the ActiveVBProject
' to the project associated with the ActiveCodePane.

Function SyncVBAEditor()
'=======================================================================
' SyncVBAEditor
' This syncs the editor with respect to the ActiveVBProject and the
' VBProject containing the ActiveCodePane. This makes the project
' that conrains the ActiveCodePane the ActiveVBProject.
'=======================================================================
    With Application.VBE
        If Not .ActiveCodePane Is Nothing Then
            Set .ActiveVBProject = .ActiveCodePane.CodeModule.parent.Collection.parent
        End If
    End With
End Function


' ===== cemetery =====


Attribute VB_Name = "LibCommon"
Option Explicit

Public gs_CodeVariant As String

Public Const cs_ProjectName As String = "Umsatz- und Liquidit|fffd|tsplanung"
Public gs_ModelType As String
Public Const cs_TypeSuffix As String = ""
Public gs_TypeSuffix As String
Public Const cs_Author As String = "Senior Consult Ruhr"
Public Const cs_MsgTitle As String = "Senior Consult LiquiPlan"

Public Const cs_RegAppName As String = "Senior Consult LiquiPlan"

Public Const cs_MainSheet_BasicModel As String = "Umsatz und Liquidit|fffd|t"
Public Const cs_MainSheet_ProfitCenter As String = "Konsolidierung"
Public Const cs_ModelType_BasicModel = "(Basismodell)"
Public Const cs_ModelType_ProfitCenter As String = "(Profitcenter)"
Public gs_MainSheetName As String

' cf. LiquiData
Public Enum LiquiYesNoCancel
    lqYes
    lqNo
    lqCancel
End Enum

' protection
'Public Const cs_LiquiPWD As String = "LiquiConsult"
Public Const cs_LiquiPWD As String = ""
Public Const cs_suspendModelProtection As String = "Formel|fffd|berwachung aufheben"  ' Modellschutz
Public Const cs_restoreModelProtection As String = "Formel|fffd|berwachung wiederherstellen"

Public gb_expertMode As Boolean
Public gb_ignoreProtectionError     ' prompt only once
Public gb_sheetsAreProtected As Boolean     ' beforeClose() followed by beforeSave()

Public gb_isModelInitialized As Boolean

Public gb_modelProtectionSuspended As Boolean   ' all cells of all Liquiplan sheets unlocked
Public gb_modelWatchDisabled As Boolean ' cf. handleWorksheetChange(..)
' equivalent to
Public gb_formulaWatchDisabled As Boolean ' == (gn_formulaProtectionLevel < 0)
Public gn_formulaProtectionLevel As Long


Public Const cs_MonthTitle As String = "Planung / Berichtsmonat"
Public Const cs_NoMonth As String = "<ohne>"
Public gn_yearRow As Long   ' = gn_monthRow - 2
Public gn_monthRow As Long
Public gn_row_Prolog_Start As Long
Public gn_row_Section_I_Start As Long
Public gn_row_Section_II_Start As Long
Public gn_row_Section_III_Start As Long
Public gn_row_Section_IV_Start As Long
Public gn_row_Section_IV_End As Long
Public gn_row_Section_V_Start As Long
Public gn_row_Section_V_End As Long
Public Const cn_height_Section_V As Long = 35
Public gn_row_Section_Custom_Start As Long
Public gn_row_Section_Custom_End As Long

Public gn_row_G_u_V As Long
Public gn_row_MonthRangeEnd As Long

Public Const cn_dataWidth As Long = 20 'S + 1
Public Const cn_userMargin As Long = 15 ' LiquiCheck, ...
Public Const cn_clm_Quantity As Long = 2
Public Const cn_clm_January As Long = 4
Public Const cn_clm_December As Long = 15
Public Const cn_clm_Year As Long = 16
Public Const cn_clm_PlotSelection As Long = 6
Public gn_clm_LiquiCheck As Long

Public Const cs_MasterSheetName As String = "Original Plandaten"
Public Const cs_CopySheet As String = "Plandaten"
Public Const cs_CompareSheetName As String = "Soll-Ist"
Public Const cs_GraphicsData As String = "Grafik-Daten"
Public Const cs_PlotData As String = "Soll-Ist Plotdaten"
Public Const cn_compareRowOff As Long = 8
Public Const cn_clm_PlotCheck As Long = 6


Public gs_currentMonthName As String
'Public gb_SheetChangeDisabled As Boolean ' ~> Application.EnableEvents
Public gb_SheetListChangeDisabled As Boolean
Public gb_ConsistenRenaming As Boolean
Public gb_allowChangeMaster As Boolean

Public gb_restoreProtection As Boolean
Public gb_warnIfUnprotected As Boolean
Public gb_protectionIssue As Boolean

Public gb_dataImportActive As Boolean
Public gs_importTargetFullName As String
Public gs_importTargetSheetName As String
Public gs_importTargetRow As Long
Public gs_importTargetHeight As Long
Public gs_importSourceFullName As String


'http://dmcritchie.mvps.org/excel/colors.htm
'red             3  255,0,0
'green           4  0,255,0
'blue            6  0,0,255
'yellow          6  255,255,0
'magenta         7  255,0,255
'cyan            8  0,255,255
'gray           15
'darker gray    16
'light magenta  38

' Excel standard colors
' highlight month in top row
' grau          15            12632256      wei|fffd|, Hintergund 1, dunkler 25%
' dunkelrot     3             192
' rot           3             255
' orange        44            49407
' gelb          6             65535
' hellgr|fffd|n      43            5296274
' gr|fffd|n          14            5287936
' hellblau      33            15773696
' blau          23            12611584
' dunkelblau    49            6299648
' lila          47            10498160
' grau          15            12632256

Public htmlColors As LiquiTokens
'Public ga_quantityColors() As Long
'Public ga_headerColors() As Long
Public ga_colorMap() As Long

Public Const cn_clrX_formulaDestroyed As Long = 38 ' light magenta
Public Const cn_clrX_formulaDestroyed_ As Long = 38 ' light magenta     ' 3 ' red ((legacy))
Public Const cn_clrX_destroyedFormulaCopied As Long = 6 ' yellow
'Public Const cn_clrX_destroyedFormulaRepaired As Long = 6 ' 4 ' green ' 7 ' magenta
Public Const cn_clrX_outlier As Long = 38  ' light magenta
Public Const cn_clrX_outlier_ As Long = 38  ' light magenta     ' 6 ' yellow  ((legacy))
Public Const cn_clrX_month As Long = 15 ' gray
Public Const cn_clrX_monthDark As Long = 16 ' darker gray
'Public Const cn_clrX_formulaUnlocked As Long = 6   '45  ' 6
Public Const cn_clrX_quantityUnlocked As Long = 45 ' 6  '  6
Public Const cn_clrX_monthHighlight As Long = 45 ' more orange

'Public gn_color_formulaDestroyed As Long
'Public gn_color_formulaDestroyed_ As Long
'Public gn_color_destroyedFormulaCopied As Long
Public gn_color_outlier As Long
Public gn_color_outlier_ As Long
Public gn_color_month As Long
Public gn_color_monthDark As Long
'Public gn_color_formulaUnlocked As Long
Public gn_color_quantityUnlocked As Long
Public gn_color_monthHighlight As Long

' cf. LiquiCode
' name prefix common to all versions of library Add-In
'Public Const cs_AddInBaseName As String = "LiquiLib"

'Public go_AddInWarden As AddInWatch
Public go_SheetsWarden As SheetsWatch
Public gb_IgnoreSheetsDeleted As Boolean
Public gb_IgnoreSheetListChanged As Boolean

Public gs_AddInFileName As String
Public gb_AddInChecked As Boolean ' avoid repeated checks and prompts if Add-In is missing
Public gb_AddInInstalled As Boolean
Public gb_AddInFailed As Boolean ' true if trial run failed
Public xlaIndex As Long ' in Application.AddIns

' cf. LiquiProfitCenter
Public Const cs_MasterPrefix As String = "OrigPD("

Public gn_MainSheetIndex As Long
Public gs_ProfitCenters As String
Public gs_GeneralCosts As String



Attribute VB_Name = "LibContextMenu"
Option Explicit

' ========== Context Menus ==========
' https://docs.microsoft.com/en-us/previous-versions/office/developer/office-2010/gg469862(v=office.14)


Function addToContextMenu(context As String)
Dim contextMenu As CommandBar
Dim subMenu As CommandBarControl

    ' Delete the controls first to avoid duplicates.
    Call deleteFromContextMenu(context)

If gs_CodeVariant <> "Variant_B" Then
    Exit Function
End If

    Set contextMenu = Application.CommandBars(context)
    Set subMenu = contextMenu.Controls.Add(Type:=msoControlPopup, before:=1)
    With subMenu
'        .caption = "LiquiPlan"
        .caption = "Modell bearbeiten"
'        .FaceId = 59   ' not supported
        .Tag = "Custom_Control_Tag_LiquiPlan"
    End With

    ' Add a separator to the Cell context menu.
    contextMenu.Controls(2).BeginGroup = True
End Function

Function deleteFromContextMenu(context As String)
Dim contextMenu As CommandBar
Dim ctrl As CommandBarControl

    Set contextMenu = Application.CommandBars(context)
    ' Delete the custom controls with the Tag : Custom_Control_Tag.
    ' Delete custom control "Modell bearbeiten" / "LiquiPlan" ((legacy)) .
    For Each ctrl In contextMenu.Controls
        If startsWith(ctrl.Tag, "Custom_Control_Tag") Then
            ctrl.Delete
        ElseIf (ctrl.caption = "LiquiPlan" Or ctrl.caption = "Modell bearbeiten") Then
            ctrl.Delete
        End If
    Next ctrl
End Function

Sub addToLiquiSubMenu(subMenu As CommandBarControl, context As String)
Dim contextMenu As CommandBar
Dim mnu As CommandBarControl, ctrl As CommandBarControl
Dim srcBk As Workbook, srcSh As Worksheet, mainSh As Worksheet, cll As Range, cll2 As Range
Dim quantities As Range, definition As Range
Dim srcRow As Long, srcClm As Long, row As Long, height As Long, shx As Long
Dim monthName As String, month As Long, clmMonth As Long, sError As String

Dim eventsEnabled As Boolean

Dim isSrcMain As Boolean
Dim isSrcInput As Boolean
Dim isSrcCompare As Boolean
Dim isNoMonth As Boolean
Dim isProlog As Boolean
Dim isUnlockedProlog As Boolean
Dim isSingleton As Boolean
Dim isVoid As Boolean
Dim isQuantity As Boolean
Dim isAllNumeric As Boolean
Dim isAllNamed As Boolean
Dim isAllUnnamed As Boolean
Dim isRestore As Boolean
Dim isDefLocked As Boolean
Dim isMarked As Boolean
Dim isMenuEmpty As Boolean
Dim isCell As Boolean
Dim isSingleCell As Boolean
Dim isSingleRow As Boolean
Dim isSingleColumn As Boolean
Dim isHeader As Boolean
Dim hasSrcDiagram As Boolean

Dim addCheck As Boolean
Dim addRename As Boolean
Dim addClear As Boolean
Dim addRestore As Boolean
Dim addUnlockQuantity As Boolean
Dim addLockQuantity As Boolean
'Dim addUnlockUnnamed As Boolean
'Dim addLockUnnamed As Boolean
Dim addDefine As Boolean
Dim addInsert As Boolean
Dim addDelete As Boolean
Dim addData As Boolean
Dim addUnprotectPlots As Boolean
Dim addProtectPlots As Boolean
Dim addHidePlotCheck As Boolean
Dim addShowPlotCheck As Boolean

    If (subMenu Is Nothing) Then
Exit Sub
    End If
'Debug.Print "addToLiquiSubMenu(..)", subMenu.caption
    
    If (gn_MainSheetIndex <= 0) Then
        If (validateMainSheet(sError) Is Nothing) Then
            MsgBox sError, vbCritical, cs_MsgTitle
Exit Sub
        End If
    End If

    ' avoid duplicates
    For Each ctrl In subMenu.Controls
        ctrl.Delete
    Next ctrl
    
    If (TypeOf ActiveSheet Is Chart) Then
    ' active sheet is chart
Exit Sub
    End If
    
'Debug.Print "addToLiquiSubMenu(..)", TypeName(Selection)
    
    ' context analysis
    isMenuEmpty = True
    If (TypeOf Selection Is Range) Then
        Set srcSh = Selection.parent
        srcRow = Selection.row
        srcClm = Selection.Column
        height = Selection.Rows.Count
        Set cll = srcSh.Cells(srcRow, cn_clm_Quantity)
        Set srcBk = srcSh.parent
        Set mainSh = getSheet(getMainSheetName(srcBk))
        With Selection
            If (.Rows.Count = 1 And .Columns.Count = srcSh.Columns.Count) Then
                isSingleRow = True
            ElseIf (.Columns.Count = 1 And .Rows.Count = srcSh.Rows.Count) Then
                isSingleColumn = True
            ElseIf (.Columns.Count < 250 And .Rows.Count < 500) Then
                isCell = True
            End If
        End With
    Else
        ' e.g. graphics object
Exit Sub
    End If
        
    ' case analysis
    With srcSh
        On Error Resume Next    ' error value in selection
        
        isHeader = False
        For row = srcRow To srcRow + height - 1
            If (.Cells(row, cn_clm_January).formula = "Januar") Then
                isHeader = True
                Exit For
            End If
            If (isSectionHeader(.Cells(row, cn_clm_Quantity))) Then
                isHeader = True
                Exit For
            End If
        Next
        
        isAllNumeric = True
        For row = srcRow To srcRow + height - 1
            If Not IsRowNumeric(srcSh, row) Then
                isAllNumeric = False
                Exit For
            End If
        Next
        
        isAllNamed = True
        For row = srcRow To srcRow + height - 1
            If (.Cells(row, cn_clm_Quantity) = "") Then
                isAllNamed = False
                Exit For
            ElseIf (row <> gn_yearRow And .Cells(row, cn_clm_January) = "Januar") Then
                isAllNamed = False
                Exit For
            ElseIf (isSectionHeader(.Cells(row, cn_clm_Quantity))) Then
                isAllNamed = False
                Exit For
            End If
        Next
        On Error GoTo 0
        
        isAllUnnamed = True
        For row = srcRow To srcRow + height - 1
            If (.Cells(row, cn_clm_Quantity) <> "") Then
                isAllUnnamed = False
                Exit For
            ElseIf (row <> gn_yearRow And .Cells(row, cn_clm_January) = "Januar") Then
                ' month header row
                isAllUnnamed = False
                Exit For
            End If
        Next
        On Error GoTo 0
        
        isSrcMain = (.name = cs_MainSheet_BasicModel Or .name = cs_MainSheet_ProfitCenter)
        isSrcInput = isMainOrPC(srcSh, shx)
        isSrcCompare = isCompareSheetName(.name)
        isNoMonth = (mainSh.Cells(gn_monthRow, 3).value = cs_NoMonth)
        isProlog = (srcRow + height - 1 < gn_row_Section_I_Start)
        isUnlockedProlog = (isProlog And isNoMonth)
        isSingleCell = (Selection.Rows.Count = 1 And Selection.Columns.Count = 1)
        isSingleton = (isSingleCell And srcClm = 2)
        isVoid = (cll.value = "")
        ' ??? isQuantity ??? ((no header | named | numeric data))
'        isQuantity = Not isHeader   ' prolog no exception
'        isQuantity = (cll.value = "" Or srcRow < gn_row_Prolog_Start Or srcRow >= gn_row_Section_I_Start)
'        isQuantity = (isSrcInput And isCell And Not isVoid And Not isHeader)
'        isQuantity = (isSrcInput And isCell And isAllNamed)
        isQuantity = (isSrcInput And isCell And isAllNumeric)
        isRestore = (isSrcInput And Not isSrcMain And IsEmpty(cll) And Not IsEmpty(mainSh.Cells(srcRow, 2)))
        isDefLocked = isDefinitionLocked(quantities, definition)    ' q'ties, def'n output only
        isMarked = False
        If Not (quantities Is Nothing) Then
            For Each cll2 In quantities
                If cll2.Interior.Color = gn_color_quantityUnlocked Then
                    isMarked = True
                    Exit For
                End If
            Next cll2
        End If
        hasSrcDiagram = (srcSh.ChartObjects.Count > 0)
    End With ' srcSh
    
    ' menu items filter
    If (context = "Cell") Then
        addCheck = isQuantity   ' (isSrcInput And isCell And Not isHeader)
        addRename = (isSrcMain And isSingleton And Not isHeader)
        addUnlockQuantity = (isQuantity And isDefLocked And Not isUnlockedProlog)    'And Not isMarked
        addLockQuantity = (isQuantity And (Not isDefLocked Or isMarked) And Not isUnlockedProlog)     ' Or isMarked
'        addUnlockUnnamed = False
'        If isSrcInput Then
'            addUnlockUnnamed = ((Not definition Is Nothing) And isAllUnnamed And isDefLocked And Not isUnlockedProlog)
'        ElseIf isSrcCompare Then
'            addUnlockUnnamed = ((Not definition Is Nothing) And isAllUnnamed And isDefLocked And Not (isSingleCell And srcRow = 1 And srcClm = 1))
'        End If
'        addLockUnnamed = ((isSrcInput Or isSrcCompare) And (Not definition Is Nothing) And isAllUnnamed And (Not isDefLocked) And Not isUnlockedProlog)
        addClear = (isQuantity And isSingleton) ' (isSingleton And isQuantity And isSrcInput And Not isVoid)
        addRestore = isRestore  ' (isSingleton And isQuantity And isSrcInput And Not isVoid)
        addData = (isQuantity And Not isProlog)   ' (isSrcInput And isCell And Not isVoid And Not isHeader)
        addUnprotectPlots = (hasSrcDiagram And srcSh.ProtectDrawingObjects)
        addProtectPlots = (hasSrcDiagram And Not srcSh.ProtectDrawingObjects)
        addHidePlotCheck = (isSrcCompare And srcSh.Columns(cn_clm_PlotCheck).EntireColumn.Hidden = False)
        addShowPlotCheck = (isSrcCompare And srcSh.Columns(cn_clm_PlotCheck).EntireColumn.Hidden = True)

    ElseIf (context = "Row") Then
        addInsert = isSingleRow And isSrcMain
        addDelete = addInsert And Not isHeader
    End If
'    isMenuEmpty = Not (addCheck Or addRename Or addUnlockQuantity Or addLockQuantity Or addUnlockUnnamed Or addLockUnnamed Or _
'            addClear Or addRestore Or addInsert Or addDelete Or addUnprotectPlots)
    
    ' filtered list of menu items
    isMenuEmpty = True
    If addLockQuantity Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Bearbeitung beenden"   ' "Gr|fffd||fffd|e sch|fffd|tzen"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellLockQuantity"
        End With
        isMenuEmpty = False
'    ElseIf addLockUnnamed Then
'        With subMenu.Controls.Add(Type:=msoControlButton)
'            .caption = "Bearbeitung beenden"   ' "Bereich sch|fffd|tzen"
'            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellLockUnnamed"
'        End With
'        isMenuEmpty = False
    End If
    If addUnlockQuantity Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Gr|fffd||fffd|e bearbeiten"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellUnlockQuantity"
        End With
        isMenuEmpty = False
'    ElseIf addUnlockUnnamed Then
'        With subMenu.Controls.Add(Type:=msoControlButton)
'            .caption = "Bereich bearbeiten"
'            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellUnlockUnnamed"
'        End With
'        isMenuEmpty = False
    End If
    If addCheck Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Gr|fffd||fffd|e |fffd|berpr|fffd|fen"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellCheckQuantity"    ' markOutliers(selection)
        End With
        isMenuEmpty = False
    End If
    If addRename Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = IIf(isVoid, "Gr|fffd||fffd|e benennen", "Gr|fffd||fffd|e umbenennen")
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellRenameQuantity"
        End With
        isMenuEmpty = False
    End If
    If addClear Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Gr|fffd||fffd|e l|fffd|schen"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellClearQuantity"
        End With
        isMenuEmpty = False
    End If
    If addData Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Datenfelder l|fffd|schen"
            .OnAction = "cellClearData"
            .TooltipText = "L|fffd|scht die Datenfelder (Nicht-Formeln) in dem ausgew|fffd|hlten Bereich."
        End With
        ' take a sledgehammer to crack a nut
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Daten |fffd|bernehmen"
            .OnAction = "cellImportData"
            .TooltipText = "|fffd|bernimmt Datenfelder (Nicht-Formeln) f|fffd|r den ausgew|fffd|hlten Bereich aus einer Vorlage."
        End With
        isMenuEmpty = False
    End If
    If addRestore Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Gr|fffd||fffd|e wiederherstellen: '" & mainSh.Cells(srcRow, 2) & "'"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellRenameQuantity"
        End With
        isMenuEmpty = False
    End If
    If addInsert Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .BeginGroup = True
            .caption = "Gr|fffd||fffd|e (Zeile) einf|fffd|gen"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "rowInsertQuantity"
        End With
        isMenuEmpty = False
    End If
    If addDelete Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Gr|fffd||fffd|e (Zeile) entfernen"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "rowDeleteQuantity"
        End With
        isMenuEmpty = False
    End If
    If addUnprotectPlots Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Plots bearbeiten"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellUnprotectPlots"
        End With
        isMenuEmpty = False
    End If
    If addProtectPlots Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Plots sch|fffd|tzen"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellProtectPlots"
        End With
        isMenuEmpty = False
    End If
    If addHidePlotCheck Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Spalte 'Grafik' ausblenden"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellHidePlotCheck"
        End With
        isMenuEmpty = False
    End If
    If addShowPlotCheck Then
        With subMenu.Controls.Add(Type:=msoControlButton)
            .caption = "Spalte 'Grafik' einblenden"
            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellShowPlotCheck"
        End With
        isMenuEmpty = False
    End If
    
    
    If (isMenuEmpty) Then
    ' default / non-operation
        With subMenu.Controls.Add(Type:=msoControlButton)
'            .caption = "Gr|fffd||fffd|e bearbeiten"
            .caption = ""
'            .OnAction = "'" & ThisWorkbook.name & "'!" & "cellEditQuantity"
        End With
    End If
    
    If (Not isCell) Then
Exit Sub
    End If
        
    ' remove warning colors
Dim selRng As Range, rng As Range, clr As Long
Dim found As Boolean
    With subMenu
'Debug.Print subMenu.caption
        Set selRng = Application.Selection
        Set rng = Application.Selection
        If Selection.Columns.Count = 1 And Selection.Column = cn_clm_Quantity Then
            Set rng = srcSh.Range(srcSh.Cells(srcRow, cn_clm_January - 1), srcSh.Cells(srcRow + height - 1, cn_clm_Year))
        End If
        For Each cll2 In rng.Cells
            clr = cll2.Interior.Color
'            If cll2.value <> gs_currentMonthName _
'                And (clr = gn_color_quantityUnlocked _
'                    Or clr = gn_color_outlier) Then
            If clr = gn_color_outlier Then
                found = True
                Exit For
            End If
        Next cll2
eventsEnabled = Application.EnableEvents
Application.EnableEvents = False
        If found And isQuantity Then
'            rng.Select
            With .Controls.Add(Type:=msoControlButton)
                .caption = "Warnfarbe(n) entfernen"
                .OnAction = "'" & ThisWorkbook.name & "'!" & "rangeResetColors"
            End With
            With .Controls.Add(Type:=msoControlButton)
                .caption = "Alle Warnfarben entfernen"
                .OnAction = "'" & ThisWorkbook.name & "'!" & "removeAllWarnings"
            End With
        End If
Application.EnableEvents = eventsEnabled
    End With ' subMenu
End Sub

Function addToLiquiContextMenu(context As String)
Dim contextMenu As CommandBar, subMenu As CommandBarControl
Dim sError As String

    If (gn_MainSheetIndex <= 0) Then
        If (validateMainSheet(sError) Is Nothing) Then
            MsgBox sError, vbCritical, cs_MsgTitle
Exit Function
        End If
    End If
    If Not (context = "Cell" Or context = "Row") Then
Exit Function
    End If
    
    Set contextMenu = Application.CommandBars(context)
    Set subMenu = contextMenu.FindControl(Tag:="Custom_Control_Tag_LiquiPlan")
    If (subMenu Is Nothing) Then
        Set subMenu = contextMenu.Controls.Add(Type:=msoControlPopup, before:=1)
        With subMenu
'            .caption = "LiquiPlan"
            .caption = "Modell bearbeiten"
    '        .FaceId = 59   ' not supported
            .Tag = "Custom_Control_Tag_LiquiPlan"
        End With
        ' Add a separator to the Cell context menu.
        contextMenu.Controls(2).BeginGroup = True
    End If
    addToLiquiSubMenu subMenu, context
    
End Function

' default Liqui cell menu item (if context menu is empty otherwise, disabled)
Private Sub cellEditQuantity()
MsgBox "cellEditQuantity"
Exit Sub

Dim srcSh As Worksheet, wsh As Worksheet, cll As Range, srcRow As Long, srcClm As Long
Dim idx As Long, msg As String
    
    Set cll = Application.Selection.Cells(1, 1)
    Set srcSh = cll.parent
    srcRow = cll.row
    srcClm = cll.Column
    
    If (Not isMainOrPC(srcSh, idx)) Then
        Set wsh = getSourceSheet(srcSh)
        If (Not wsh Is Nothing) Then
            msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & wsh.name & "' bearbeiten."
        Else
            msg = "Keine Planung."
        End If
        MsgBox msg, vbExclamation, cs_MsgTitle
Exit Sub
    End If
    
    If (Selection.Rows.Count > 1 Or Selection.Columns.Count > 1 Or srcClm <> 2) Then
        msg = "Keine Modellgr|fffd||fffd|e ausgew|fffd|hlt."
    ElseIf (isNameProtected(cll.value)) Then
        msg = "Der Name ist gesch|fffd|tzt."
    ElseIf (cll.value <> "" And srcRow >= gn_row_Prolog_Start And srcRow < gn_row_Section_I_Start) Then
        msg = "Der Name ist gesch|fffd|tzt."
    ElseIf (Not isMainOrPC(srcSh, idx)) Then
        msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & getMainSheetName(Application.ActiveWorkbook) & "' bearbeiten."
    Else    'If (srcRow > gn_row_Section_IV_End) Then
        msg = "Keine |fffd|berwachte Modellgr|fffd||fffd|e gew|fffd|hlt."
    End If
    MsgBox msg, vbExclamation, cs_MsgTitle

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

' default Liqui row menu item
Private Sub rowEditQuantity()
Dim srcSh As Worksheet, wsh As Worksheet, cll As Range, srcRow As Long, srcClm As Long
Dim idx As Long, msg As String
    
    Set cll = Application.Selection.Cells(1, 1)
    Set srcSh = cll.parent
    srcRow = cll.row
    
    If (Not isMainOrPC(srcSh, idx)) Then
        Set wsh = getSourceSheet(srcSh)
        If (Not wsh Is Nothing) Then
            msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & wsh.name & "' bearbeiten."
        Else
            msg = "Keine Planung."
        End If
        MsgBox msg, vbExclamation, cs_MsgTitle
Exit Sub
    End If
    
    If (Not (srcSh.name = cs_MainSheet_BasicModel Or srcSh.name = cs_MainSheet_ProfitCenter)) Then
        msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & getMainSheetName(Application.ActiveWorkbook) & "' bearbeiten."
    ElseIf (srcRow >= gn_row_Prolog_Start And srcRow < gn_row_Section_I_Start) Then
        msg = "Der Name ist gesch|fffd|tzt."
    ElseIf (srcRow > gn_row_Section_IV_End) Then
        msg = "Keine |fffd|berwachte Modellgr|fffd||fffd|e gew|fffd|hlt."
    Else    ' If (Selection.Rows.Count > 1) Then
        msg = "Keine Modellgr|fffd||fffd|e ausgew|fffd|hlt."
    End If
    MsgBox msg, vbExclamation, cs_MsgTitle

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub cellRenameQuantity()
Dim srcBk As Workbook, srcSh As Worksheet, trgSh As Worksheet, cll As Range
Dim srcRow As Long, clm As Long, shx As Long
Dim oldName As String, newName As String, isRestore As Boolean, isDerived As Boolean
Dim isProtected As Boolean
Dim msg As String, sError As String

    Set cll = Application.Selection.Cells(1, 1)
    Set srcSh = cll.parent
    Set srcBk = srcSh.parent
    Set trgSh = getSheet(getMainSheetName(srcBk))
    srcRow = cll.row
    isRestore = False
    If (srcSh.name <> cs_MainSheet_BasicModel And srcSh.name <> cs_MainSheet_ProfitCenter) Then
        If (isMainOrPC(srcSh, shx) And IsEmpty(cll) And Not IsEmpty(trgSh.Cells(srcRow, 2))) Then
            ' cf. separate restore menu item
            isRestore = True
        Else
            msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & getMainSheetName(srcBk) & "' bearbeiten."
            MsgBox msg, vbExclamation, cs_MsgTitle
Exit Sub
        End If
    End If
    
    oldName = cll.value
    If (isNameProtected(oldName)) Then
        MsgBox "Der Name ist gesch|fffd|tzt.", vbExclamation, cs_MsgTitle
Exit Sub

    ' all names in prologue ??
    ElseIf (oldName <> "" And srcRow >= gn_row_Prolog_Start And srcRow < gn_row_Section_I_Start) Then
        MsgBox "Vorsicht: Kontrollgr|fffd||fffd|e !", vbExclamation, cs_MsgTitle
'Exit Function
    End If
    
    isProtected = True
    If (Not unprotectSheet(srcSh, True)) Then
Exit Sub
    End If

'    ' no way to distinguish cancel and ""
'    ' !!! IsEmpty("") is false !!!
'    ' cf. separate clear menu item
'Dim tmp As Variant
'    tmp = InputBox("Neue Bezeichnung", cs_MsgTitle, oldName)
'    If (IsEmpty(tmp)) Then
'Exit Sub
'    Else
'        newName = Trim$(tmp)
'        If (newName = "") Then
'            If (MsgBox("Gr|fffd||fffd|e l|fffd|schen ?", vbOKCancel, cs_MsgTitle) <> vbOK) Then
'Exit Sub
'            End If
'        End If
'    End If
    
    If (srcSh.name <> cs_MainSheet_BasicModel And srcSh.name <> cs_MainSheet_ProfitCenter) Then
        If (isRestore) Then
            newName = trgSh.Cells(srcRow, 2).value
        End If
    Else
'        newName = Trim$(InputBox("Neue Bezeichnung", cs_MsgTitle, oldName))
'        If (newName = "" Or newName = oldName) Then
'Exit Sub
'        End If
        newName = oldName
        gb_isUserOK = False
        With frmInput
            .lblPrompt = "Bitte neuen Namen eingeben."
            .txtInput.Text = oldName
            .Show
            
            newName = Trim$(.txtInput.Text)
        End With
        If (Not gb_isUserOK Or newName = oldName) Then
If isProtected Then protectSheet srcSh
Exit Sub
        End If
        If (newName = "") Then
            If (MsgBox("Gr|fffd||fffd|e '" & oldName & "' l|fffd|schen ?", vbOKCancel, cs_MsgTitle) = vbCancel) Then
If isProtected Then protectSheet srcSh
Exit Sub
            End If
        End If
    End If
    
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    
    If (newName <> "") Then
        doConsistentRename srcSh, srcRow, oldName, newName, confirm:=False
    Else
        doConsistentClear srcSh, srcRow, oldName, confirm:=False
    End If
    If (isRestore) Then
        ' if derived quantity restore definition (formulae)
        isDerived = True
        With trgSh
            For clm = cn_clm_January - 1 To cn_clm_Year
                If (Not .Cells(srcRow, clm).HasFormula) Then
                    isDerived = False
                    Exit For
                ElseIf (isConsolidationFormula(.Cells(srcRow, clm).formula)) Then
                    isDerived = False
                    Exit For
                End If
            Next
            If isDerived Then
                For clm = cn_clm_January - 1 To cn_clm_Year
                    srcSh.Cells(srcRow, clm).formula = .Cells(srcRow, clm).formula
                Next
            End If
        End With
    End If  ' restore
    protectSheet srcSh
    srcSh.Activate
    
    ' edit immediately ?
    If (oldName = "" And newName <> "") Then    ' And Not isRestore
        cellUnlockQuantity
    End If
    
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Function cellUnlockQuantity()
Dim srcBk As Workbook, srcSh As Worksheet, cll As Range, definition As Range
Dim srcRow As Long, srcClm As Long, row As Long, clm As Long, width As Long, height As Long
Dim isProtected As Boolean, warn As Boolean, allow As Boolean, found As Boolean
Dim msg As String, sError As String
    
    Set cll = Application.Selection.Cells(1, 1)
    Set srcSh = cll.parent
    Set srcBk = srcSh.parent
    srcRow = cll.row
    srcClm = cll.Column
    width = Application.Selection.Columns.Count
    height = Application.Selection.Rows.Count
    
    '8.3.0.8: watch manual interior color changes
'    storeRowColors srcSh
'    storeColorMap srcSh    ' cf. unlockQuantity(..)
    
    isProtected = True
    If (Not unprotectSheet(srcSh, True)) Then
Exit Function
    End If
    warn = True
    allow = False
    found = False
    For row = srcRow To srcRow + height - 1
        For clm = cn_clm_January - 1 To cn_clm_Year
            With srcSh.Cells(row, clm)
                If (Not .HasFormula) Then
                    found = True
                Else
                    If warn Then
                        If (MsgBox("Formeln freigeben ?", vbYesNo, cs_MsgTitle) = vbYes) Then
                            allow = True
                        End If
                        warn = False
                        found = True
                    End If
                End If
            End With
        Next
    Next
    If found Then
        Set definition = srcSh.Range(srcSh.Cells(srcRow, cn_clm_Quantity), srcSh.Cells(srcRow + height - 1, cn_clm_Quantity))
        unlockQuantity definition, allow
    End If
    If isProtected Then protectSheet srcSh
    
    If (Not found) Then
        ' empty data range, quantity names only
        Set definition = srcSh.Range(srcSh.Cells(srcRow, cn_clm_Quantity), srcSh.Cells(srcRow + height - 1, cn_clm_Quantity))
    ElseIf (allow Or True) Then
        Set definition = srcSh.Range(srcSh.Cells(srcRow, cn_clm_January - 1), srcSh.Cells(srcRow + height - 1, cn_clm_Year))
    Else
'        Set definition = srcSh.Range(srcSh.Cells(srcRow, cn_clm_January), srcSh.Cells(srcRow + height - 1, cn_clm_December))
    End If
Application.EnableEvents = False
    definition.Select

Application.ScreenUpdating = True
Application.EnableEvents = True
End Function

Private Sub cellLockQuantity()
Dim srcBk As Workbook, mainSh As Worksheet, srcSh As Worksheet, cll As Range, definition As Range
Dim srcRow As Long, row As Long, clm As Long, height As Long, shx As Long
Dim monthName As String, month As Long
Dim isProtected As Boolean
Dim sError As String

    If (gn_MainSheetIndex = 0) Then
        Set mainSh = validateMainSheet(sError)
    Else
        Set mainSh = ActiveWorkbook.Worksheets(gn_MainSheetIndex)
    End If
    
    Set cll = Application.Selection.Cells(1, 1)
    Set srcSh = cll.parent
    srcRow = cll.row
    height = Application.Selection.Rows.Count
    
    monthName = mainSh.Cells(gn_yearRow + 2, 3)
    month = monthToNumber(monthName)
    
    Set definition = srcSh.Range(srcSh.Cells(srcRow, cn_clm_January - 1), srcSh.Cells(srcRow + height - 1, cn_clm_Year))
    isProtected = True
    If (Not unprotectSheet(srcSh, True)) Then
Exit Sub
    End If
    With definition
        .Locked = False
        For Each cll In definition
            If cll.HasFormula Then
                cll.Locked = True
            ElseIf (cll.row < gn_row_Section_I_Start And month > 0 And (cll.row <> gn_monthRow Or cll.Column <> 3)) Then
                cll.Locked = True
            ElseIf (cll.row >= gn_row_Section_I_Start And cll.Column = cn_clm_January - 1 Or cll.Column = cn_clm_Year) Then
                cll.Locked = True
            ElseIf (False Or _
                    (cll.row >= gn_row_Section_I_Start And month <> 0 And cll.Column <> cn_clm_January + month - 1)) Then
                cll.Locked = True
            End If
        Next
        
'        .Interior.ColorIndex = xlNone
'        For row = 1 To height
'            .Rows(row).Interior.ColorIndex = ga_headerColors(srcRow + row - 1)
'        Next
'        .Select
    End With
'    For Each cll In definition
'        If (cll.Interior.Color <> gn_color_outlier) Then
'            cll.Interior.Color = ga_headerColors(cll.row)
'        End If
'    Next
    For Each cll In definition
        If (cll.Interior.Color = gn_color_quantityUnlocked) Then
'            cll.Interior.Color = ga_headerColors(cll.row)
            cll.Interior.Color = ga_colorMap(cll.row, cll.Column)
        End If
    Next
    
Application.EnableEvents = False
    ' arrays ga_headerColors(), ga_quantityColors(), ga_colorMap() stored by validateMainSheet(..)
    With srcSh.Range(srcSh.Cells(srcRow, cn_clm_Quantity), srcSh.Cells(srcRow + height - 1, cn_clm_Quantity))
'        .Interior.ColorIndex = xlNone
        For Each cll In .Cells
'            cll.Interior.Color = ga_quantityColors(cll.row)
            cll.Interior.Color = ga_colorMap(cll.row, cll.Column)
        Next
        .Select
    End With
    
    If isProtected Then protectSheet srcSh

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub cellCheckQuantity()
Dim context As Range, outlierMarked As Boolean
    
Application.EnableEvents = False
    cellLockQuantity    ' finish editing
    Set context = markOutliers(Application.Selection, outlierMarked)
    If Not context Is Nothing Then context.Select

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub cellUnprotectPlots()
Dim srcBk As Workbook, srcSh As Worksheet, cll As Range, context As Range
Dim srcRow As Long, row As Long, clm As Long, height As Long
    
Application.EnableEvents = False
    Set srcSh = Application.Selection.parent
    With srcSh
        .Unprotect cs_LiquiPWD
        .Protect Password:=cs_LiquiPWD, userinterfaceonly:=False, _
                DrawingObjects:=False, Contents:=True, Scenarios:=True, _
                AllowFormattingCells:=True, AllowFormattingRows:=True, AllowFormattingColumns:=True
                
        .DrawingObjects(1).Select
        ActiveWindow.ScrollRow = getLastRow(.usedRange)
    End With

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub cellProtectPlots()
Dim srcBk As Workbook, srcSh As Worksheet, cll As Range, context As Range
Dim srcRow As Long, row As Long, clm As Long, height As Long
    
Application.EnableEvents = False
    Set srcSh = Selection.parent
    With srcSh
        .Unprotect cs_LiquiPWD
        .Protect Password:=cs_LiquiPWD, userinterfaceonly:=False, _
                DrawingObjects:=True, Contents:=True, Scenarios:=True, _
                AllowFormattingCells:=True, AllowFormattingRows:=True, AllowFormattingColumns:=True
'        .Cells(cn_compareRowOff + 1, 3).Select
        .Cells(1, 1).Select
        ActiveWindow.ScrollRow = 1
    End With

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub cellHidePlotCheck()
Dim srcBk As Workbook, srcSh As Worksheet, cll As Range, context As Range
Dim srcRow As Long, row As Long, clm As Long, height As Long
Dim isPlotCheckEmpty As Boolean, msg As String
    
Application.EnableEvents = False
    Set srcSh = Selection.parent
    With srcSh
        .Unprotect cs_LiquiPWD
        ' prompt: remove plots if no KPI is checked ?
        If (.ChartObjects.Count > 0) Then
            isPlotCheckEmpty = True
            For row = cn_compareRowOff + 2 To getLastRow(.usedRange)
                If (.Cells(row, 2) <> "" And .Cells(row, cn_clm_PlotCheck) <> "") Then
                    isPlotCheckEmpty = False
                    Exit For
                End If
            Next
            
            If isPlotCheckEmpty Then
                msg = "Keine Gr|fffd||fffd|en (KPI) ausgew|fffd|hlt; sollen die Grafiken entfernt werden ?"
                If (MsgBox(msg, vbYesNo, cs_MsgTitle) = vbYes) Then
                    Do While (.ChartObjects.Count > 0)
                        .ChartObjects(1).Delete
                    Loop
                End If
            End If
        End If

        .Columns(cn_clm_PlotCheck).EntireColumn.Hidden = True
        .Protect Password:=cs_LiquiPWD, userinterfaceonly:=False, _
                DrawingObjects:=True, Contents:=True, Scenarios:=True, _
                AllowFormattingCells:=True, AllowFormattingRows:=True, AllowFormattingColumns:=True
'        .Cells(cn_compareRowOff + 1, 3).Select
        .Cells(1, 1).Select
        ActiveWindow.ScrollRow = 1
    End With
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub cellShowPlotCheck()
Application.EnableEvents = False
    With Selection.parent
        .Unprotect cs_LiquiPWD
        .Columns(cn_clm_PlotCheck).EntireColumn.Hidden = False
        .Protect Password:=cs_LiquiPWD, userinterfaceonly:=False, _
                DrawingObjects:=True, Contents:=True, Scenarios:=True, _
                AllowFormattingCells:=True, AllowFormattingRows:=True, AllowFormattingColumns:=True
'        .Cells(cn_compareRowOff + 1, 3).Select
        .Cells(1, 1).Select
        ActiveWindow.ScrollRow = 1
    End With
Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Private Sub rangeResetColors()
Dim CaseRange As Range
Dim CalcMode As Long
Dim wsh As Worksheet, rng As Range, cll As Range, clm As Long
Dim rowClr As Long, clr As Long

Application.ScreenUpdating = False
Application.EnableEvents = False

    Set wsh = Selection.parent
    Set rng = Selection
    With Selection
        If .Column = cn_clm_Quantity Then
            Set rng = wsh.Range(wsh.Cells(.row, cn_clm_January), wsh.Cells(getLastRow(Selection), cn_clm_Year))
        End If
    End With
    For Each cll In rng.Cells
        ' 8.3.0.7 ~ 8.2.0.8
'        rowClr = wsh.Cells(cll.row, cn_clm_Quantity).Interior.ColorIndex
'        rowClr = ga_headerColors(cll.row)
        clr = cll.Interior.Color
        If cll.value <> gs_currentMonthName _
            And (clr = gn_color_quantityUnlocked _
                Or clr = gn_color_outlier) Then
'            cll.Interior.Color = rowClr
            cll.Interior.Color = ga_colorMap(cll.row, cll.Column)
        End If
        If cll.Interior.Color = gn_color_outlier Then
            ' outlier color in color map
            cll.Interior.Color = xlNone
        End If
    Next cll

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Function rowInsertQuantity()
Dim srcBk As Workbook, srcSh As Worksheet, trgSh As Worksheet, cll As Range
Dim oldName As String, newName As String, mode As Long
Dim isProtected As Boolean
Dim msg As String, sError As String
    
    If (Selection.Rows.Count > 1) Then
Exit Function
    End If
    
    Set cll = Selection.Cells(1, 2)
    Set srcSh = cll.parent
    Set srcBk = srcSh.parent
    If (srcSh.name <> cs_MainSheet_BasicModel And srcSh.name <> cs_MainSheet_ProfitCenter) Then
        msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & getMainSheetName(srcBk) & "' bearbeiten."
        MsgBox msg, vbExclamation, cs_MsgTitle
Exit Function
    End If
        
'    newName = Trim$(InputBox("Neue Bezeichnung", cs_MsgTitle, oldName))
'    If IsEmpty(newName) Then
'Exit Sub
'    End If
    
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    
    isProtected = srcSh.ProtectContents
    If (srcSh.name = cs_MainSheet_BasicModel Or srcSh.name = cs_MainSheet_ProfitCenter) Then
        doConsistentInsert srcSh, Selection.row
    End If
    
    srcSh.Activate
Application.ScreenUpdating = True
Application.EnableEvents = True
End Function

Function cellClearQuantity()
Dim srcBk As Workbook, srcSh As Worksheet, trgSh As Worksheet, cll As Range
Dim oldName As String, newName As String, mode As Long
Dim isProtected As Boolean
Dim msg As String, sError As String
    
    If (Selection.Rows.Count > 1) Then
Exit Function
    End If
    
    Set cll = Selection.Cells(1, 1)
    Set srcSh = Selection.parent
    Set srcBk = srcSh.parent
    ' weak: quantity may be missing (cleared) in PC
'    If (srcSh.name <> cs_MainSheet_BasicModel And srcSh.name <> cs_MainSheet_ProfitCenter) Then
'        msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & getMainSheetName(srcBk) & "' bearbeiten."
'        MsgBox msg, vbExclamation, cs_MsgTitle
'Exit Sub
'    End If
        
    oldName = cll.value
    newName = ""
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    
    isProtected = srcSh.ProtectContents
'    If (srcSh.name = cs_MainSheet_BasicModel Or srcSh.name = cs_MainSheet_ProfitCenter) Then
Dim idx As Long
    If (isMainOrPC(srcSh, idx)) Then
        doConsistentClear srcSh, cll.row, oldName, confirm:=True
    End If
    
    srcSh.Activate
Application.ScreenUpdating = True
Application.EnableEvents = True
End Function

' "L|fffd|scht die Datenfelder (Nicht-Formeln) in dem ausgew|fffd|hlten Bereich."
Private Sub cellClearData()
Dim trgSh As Worksheet, trgRow As Long, row As Long, height As Long, shx As Long
Dim name As String
Dim sError As String

Application.EnableEvents = True
    If gs_MainSheetName = "" Then
        If (validateMainSheet(sError) Is Nothing) Then
            MsgBox sError, vbCritical, cs_MsgTitle
Exit Sub
        End If
    End If
    
    sError = ""
    With Application.Selection
        Set trgSh = .parent
        If (Not isMainOrPC(trgSh, shx)) Then
            sError = "Bitte Eingabe-Arbeitsblatt w|fffd|hlen."
            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Sub
        End If
        
Application.EnableEvents = False
        trgRow = .row
        height = .Rows.Count
'        If (.Column <> cn_clm_Quantity Or .Columns.Count > 1) Then
'            sError = "Bitte ein oder mehrere Gr|fffd||fffd|en w|fffd|hlen."
'        Else
            For row = trgRow To trgRow + height - 1
                name = trgSh.Cells(row, cn_clm_Quantity)
                If (isSectionHeader(name)) Then
                    sError = "'" & name & "' ist keine Gr|fffd||fffd|e."
                    trgSh.Cells(row, cn_clm_Quantity).Select
                    Exit For
                End If
                If (trgSh.Cells(row, cn_clm_January).formula = "Januar") Then
                    sError = "|fffd|berschriften-Zeile ist keine Gr|fffd||fffd|e."
                    trgSh.Cells(row, cn_clm_Quantity).Select
                    Exit For
                End If
            Next
'        End If
    End With
    If (sError = "") Then
'        Application.EnableEvents = False
        trgSh.Range(trgSh.Cells(trgRow, cn_clm_Quantity), trgSh.Cells(trgRow + height - 1, cn_clm_Quantity)).Select
        clearData trgSh, trgRow, height
'        Application.EnableEvents = True
    Else
        MsgBox sError, vbExclamation, cs_MsgTitle
    End If

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

' "|fffd|bernimmt Datenfelder (Nicht-Formeln) f|fffd|r den ausgew|fffd|hlten Bereich aus einer Vorlage."
Private Sub cellImportData()
Dim trgSh As Worksheet, trgRow As Long, row As Long, height As Long, shx As Long
Dim name As String
Dim sError As String

    Application.EnableEvents = True
    If gs_MainSheetName = "" Then
        If (validateMainSheet(sError) Is Nothing) Then
            MsgBox sError, vbCritical, cs_MsgTitle
Exit Sub
        End If
    End If
    sError = ""
    With Application.Selection
        Set trgSh = .parent
        If (Not isMainOrPC(trgSh, shx)) Then
            sError = "Bitte Eingabe-Arbeitsblatt w|fffd|hlen."
            MsgBox sError, vbExclamation, cs_MsgTitle
Exit Sub
        End If
        
Application.EnableEvents = False
        trgRow = .row
        height = .Rows.Count
'        If (.Column <> cn_clm_Quantity Or .Columns.Count > 1) Then
'            sError = "Bitte ein oder mehrere Gr|fffd||fffd|en w|fffd|hlen."
'        Else
            For row = trgRow To trgRow + height - 1
                name = trgSh.Cells(row, cn_clm_Quantity)
                If (isSectionHeader(name)) Then
                    sError = "'" & name & "' ist keine Gr|fffd||fffd|e."
                    trgSh.Cells(row, cn_clm_Quantity).Select
                    Exit For
                End If
                If (trgSh.Cells(row, cn_clm_January).formula = "Januar") Then
                    sError = "|fffd|berschriften-Zeile ist keine Gr|fffd||fffd|e."
                    trgSh.Cells(row, cn_clm_Quantity).Select
                    Exit For
                End If
            Next
'        End If
    End With
    
    If (sError = "") Then
        trgSh.Range(trgSh.Cells(trgRow, cn_clm_Quantity), trgSh.Cells(trgRow + height - 1, cn_clm_Quantity)).Select
        startDataImport trgSh, trgRow, height
'        trgSh.Activate
'        ActiveWindow.ScrollColumn = cn_clm_Quantity
'        trgSh.Cells(trgRow, cn_clm_Quantity).Select
    Else
        MsgBox sError, vbExclamation, cs_MsgTitle
    End If

Application.ScreenUpdating = True
Application.EnableEvents = True
End Sub

Function rowDeleteQuantity()
Dim srcBk As Workbook, srcSh As Worksheet, trgSh As Worksheet, cll As Range, srcRow As Long
Dim oldName As String, newName As String, mode As Long
Dim isProtected As Boolean
Dim msg As String, sError As String
    
    If (Selection.Rows.Count > 1) Then
Exit Function
    End If
    
    srcRow = Selection.row
    Set srcSh = Selection.parent
    Set srcBk = srcSh.parent
    Set cll = srcSh.Cells(srcRow, 2)
    oldName = cll.value
    
    If (srcSh.name <> cs_MainSheet_BasicModel And srcSh.name <> cs_MainSheet_ProfitCenter) Then
        msg = "Bitte Gr|fffd||fffd|e aus Konsistenzgr|fffd|nden auf Blatt '" & getMainSheetName(srcBk) & "' bearbeiten."
        MsgBox msg, vbExclamation, cs_MsgTitle
Exit Function
    End If
        
'    newName = Trim$(InputBox("Neue Bezeichnung", cs_MsgTitle, oldName))
'    If IsEmpty(newName) Then
'Exit Sub
'    End If
    
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    
    doConsistentDelete srcSh, srcRow, oldName
    
    srcSh.Activate
Application.ScreenUpdating = True
Application.EnableEvents = True
End Function


Private Sub removeAllWarnings()
    If Application.ActiveWorkbook Is Nothing Then Exit Sub
    removeWarningColors Application.ActiveWorkbook
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
'SendKeys "{ESC}"
End Sub

' ========== utilities ==========

Function isDefinitionLocked(quantities As Range, definition As Range) As Boolean
' input: Selection
' quantities, definition: output only
Dim ulCell As Range, cll As Range
Dim srcSh As Worksheet, srcBk As Workbook
Dim srcRow As Long, row As Long, clm As Long, height As Long
Dim monthCell As Range, monthName As String, month As Long, clmMonth As Long
Dim isSource As Boolean

    Set ulCell = Selection(1, 1)
    Set srcSh = ulCell.parent
    Set srcBk = srcSh.parent
    srcRow = ulCell.row
    height = Selection.Rows.Count
    isSource = isSourceSheet(srcSh)
    With srcSh
        If isSource Then
            Set quantities = .Range(.Cells(srcRow, cn_clm_Quantity), .Cells(srcRow + height - 1, cn_clm_Quantity))
            Set definition = .Range(.Cells(srcRow, cn_clm_January - 1), .Cells(srcRow + height - 1, cn_clm_Year))
            Set monthCell = .Cells(gn_monthRow, 3)
            monthName = monthCell.value
            month = monthToNumber(monthName)
            clmMonth = cn_clm_January + month - 1
        ElseIf (isCompareSheetName(srcSh.name)) Then
            Set quantities = .Range(.Cells(srcRow, cn_clm_Quantity), .Cells(srcRow + height - 1, cn_clm_Quantity))
            Set definition = .Range(.Cells(srcRow, 3), .Cells(srcRow + height - 1, 9))
            monthName = ""
            month = 0
            clmMonth = 0
        End If
    End With

    isDefinitionLocked = True
    If (definition Is Nothing) Then
Exit Function
    End If
    
    For Each cll In definition
        If (cll.HasFormula And Not cll.Locked) Then
            isDefinitionLocked = False
'Debug.Print "isDefinitionLocked(..)", cll.Address, cll.formula, cll.Locked
Exit Function
        ElseIf (isSource And cll.row = gn_monthRow And cll.Column = 3) Then
            ' skip: month cell always unlocked
        ElseIf (isSource And month <> 0 And cll.Column <> clmMonth And Not cll.Locked) Then
            isDefinitionLocked = False
'Debug.Print "isDefinitionLocked(..)", cll.Address, cll.formula, cll.Locked
Exit Function
        ElseIf (isCompareSheetName(srcSh.name) And Not cll.Locked) Then
            isDefinitionLocked = False
'Debug.Print "isDefinitionLocked(..)", cll.Address, cll.formula, cll.Locked
Exit Function
        End If
    Next
End Function


' ========== cemetery ==========


Attribute VB_Name = "LibControl"
Option Explicit


'Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long

Function timeDiff(tm1 As Long, tm2 As Long) As String
    timeDiff = FormatNumber$((tm2 - tm1) / 1000#, 3) & " sec"
End Function


'Private Sub toggleDataWatch()
'    gb_modelWatchDisabled = Not gb_modelWatchDisabled
'    gb_formulaWatchDisabled = gb_modelWatchDisabled
'    dataWatchBtn.caption = "|fffd|berwachung " & IIf(gb_modelWatchDisabled, "einschalten", "abschalten") ' "Daten |fffd|berpr|fffd|fen"
'    addLiquiMenus ' refresh
'End Sub
Function toggleDataWatch()
' two levels only
Dim btnCaption As String

    If gn_formulaProtectionLevel = 0 Then
'        gn_formulaProtectionLevel = getOption(cs_keyModelProtection, -1)
        ' in sync with toggle button caption
        btnCaption = dataWatchBtn.caption
        If (InStr(1, btnCaption, "einschalten") > 0) Then
            ' off
            gn_formulaProtectionLevel = -1
        Else
            gn_formulaProtectionLevel = 2
        End If
'        setOption cs_keyModelProtection, gn_formulaProtectionLevel
    End If

    If gn_formulaProtectionLevel < 0 Then
        gn_formulaProtectionLevel = 2
    Else: gn_formulaProtectionLevel = -1
    End If
'    setOption cs_keyModelProtection, gn_formulaProtectionLevel
    
    gb_modelWatchDisabled = gn_formulaProtectionLevel < 0
    gb_formulaWatchDisabled = gb_modelWatchDisabled
    dataWatchBtn.caption = "|fffd|berwachung " & IIf(gb_modelWatchDisabled, "einschalten", "abschalten") ' "Daten |fffd|berpr|fffd|fen"
    
If True Then addLiquiMenus     ' must refresh
End Function

Function restoreModelProtection() As Boolean
' menu action; model update; etc.
' protect all worksheets, unconditionally, with cs_LiquiPWD
'   protect all charts w/o PWD
' restore cell locking for input sheets, completely lock all other LiquiPlan sheets
Dim sh As Variant, monthCell As Range, idx As Long
Dim isProtected As Boolean
Dim msg As String, pwdIssues As String
Dim startTime As Long, breakTime As Long

    Application.ScreenUpdating = False
'Application.ScreenUpdating = True
    Application.Calculation = xlCalculationManual
    
    If (gn_MainSheetIndex = 0) Then
        If (validateMainSheet(msg) Is Nothing) Then
            MsgBox msg, vbExclamation, cs_MsgTitle
            restoreModelProtection = False
Exit Function
        End If
    End If
    
'Debug.Print "restoreModelProtection(..)"
'startTime = GetTickCount()
'breakTime = GetTickCount()
    
    restoreModelProtection = True
    pwdIssues = ""
    'lock cells of input sheets
    For idx = 1 To gn_MainSheetIndex
        Set sh = ActiveWorkbook.Worksheets(idx)
'Debug.Print "restoreModelProtection()", sh.name
Application.StatusBar = "Modellschutz: " & sh.name
DoEvents
'        If (Not protectSheet(sh)) Then
'            restoreModelProtection = False
'            Exit For
'        End If
'Debug.Print "A", timeDiff(breakTime, GetTickCount())
'breakTime = GetTickCount()
        Set monthCell = sh.Cells(gn_yearRow + 2, 3)
        If (Not lockUnlockMonth(monthCell)) Then
            restoreModelProtection = False
            pwdIssues = pwdIssues & IIf(pwdIssues = "", "", ", ") & sh.name
'            Exit For
        End If
'Debug.Print "B", timeDiff(breakTime, GetTickCount())
'breakTime = GetTickCount()
    Next

    For idx = gn_MainSheetIndex + 1 To ActiveWorkbook.Worksheets.Count '
'breakTime = GetTickCount()
        Set sh = ActiveWorkbook.Worksheets(idx)
'Debug.Print "restoreModelProtection()", isLiquiplanSheet(sh), sh.name, sh.ProtectContents
        If (isLiquiplanSheet(sh)) Then
Application.StatusBar = "Modellschutz: " & sh.name
DoEvents
            If (Not protectSheet(sh, lockCells:=True, isLocked:=True)) Then
                restoreModelProtection = False
                pwdIssues = pwdIssues & IIf(pwdIssues = "", "", ", ") & sh.name
'                Exit For
            End If
        Else
        End If
'Debug.Print "B", timeDiff(breakTime, GetTickCount())
    Next
'Debug.Print "C", timeDiff(startTime, GetTickCount())
    
'    If (restoreModelProtection = True) Then
        For Each sh In ActiveWorkbook.Charts
'Debug.Print "restoreModelProtection()", sh.name
Application.StatusBar = "Modellschutz: " & sh.name
DoEvents
            If (Not protectSheet(sh)) Then
                restoreModelProtection = False
                pwdIssues = pwdIssues & IIf(pwdIssues = "", "", ", ") & sh.name
'                Exit For
            End If
        Next
'    End If
Dim tmp As String
    If (restoreModelProtection = False) Then
        If (Not gb_ignoreProtectionError) Then
            tmp = pwdIssues
            tmp = nextValue(tmp, ",")
            Set sh = getSheet(tmp)
            sh.Activate
'            msg = "Bitte heben Sie den Blattschutz von '" + sh.name + "' auf."
            msg = "Bitte heben Sie den Blattschutz folgender Bl|fffd|tter auf und stellen die Formel|fffd|berwachung wieder her:"
            msg = msg + vbLf + pwdIssues
            msg = msg + vbLf + "Andernfalls ist die Konsistenz des Modells nicht mehr gew|fffd|hrleistet."
'Stop '(6)
            MsgBox msg, vbExclamation, cs_MsgTitle
            
            gb_modelProtectionSuspended = True
            addLiquiMenus
        End If
    End If
    
    ' very-hide data sheets ?
'    Set sh = getSheet(cs_PlotData)
'    If (Not sh Is Nothing) Then sh.visible = xlSheetVeryHidden
'    Set sh = getSheet(cs_GraphicsData)
'    If (Not sh Is Nothing) Then sh.visible = xlSheetVeryHidden
'    Set sh = getSheet(cs_optionsSheetName)
'    If (Not sh Is Nothing) Then sh.visible = xlSheetVeryHidden
    
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
Application.StatusBar = False
DoEvents
        
'    gb_warnIfUnprotected = True
End Function

Function protectSheet(sh As Variant, _
    Optional lockCells As Boolean = False, Optional isLocked As Boolean = False) As Boolean
' If lockCells = False (default) and gb_modelProtectionSuspended = False, cell locking is left untouched
Dim actPwd As String
Dim row As Long, found As Boolean

'If lockCells Then
'Debug.Print "protectSheet(..)", TypeName(sh), sh.name, IIf(lockCells, CStr(lockCells), ""), IIf(lockCells, CStr(isLocked), "")
''Stop
'End If

    actPwd = cs_LiquiPWD
    If (TypeOf sh Is Chart) Then
        actPwd = ""
    End If
    
On Error GoTo PROTECTION_ERROR
    With sh
'Debug.Print "protectSheet(..)", TypeName(sh), sh.name, IIf(lockCells, CStr(lockCells), ""), IIf(lockCells, CStr(isLocked), "")
        .Unprotect actPwd
        If gb_modelProtectionSuspended Then
            .Cells.Locked = False
        ElseIf (lockCells And TypeOf sh Is Worksheet) Then
            .Cells.Locked = isLocked
        End If
        If (startsWith(.name, cs_CompareSheetName) And lockCells = True And isLocked = True) Then
            ' special case: unlock KPI check column
            found = False
            For row = 1 To getLastRow(.usedRange)
                If (.Cells(row, cn_clm_PlotCheck) = "Grafik") Then
                    found = True
                ElseIf (found And .Cells(row, 2) <> "") Then
                    .Cells(row, cn_clm_PlotCheck).Locked = False
                End If
            Next
        End If
        If (TypeOf sh Is Worksheet And val(Application.Version) >= 10) Then
            .Protect Password:=actPwd, userinterfaceonly:=False, _
                DrawingObjects:=True, Contents:=True, Scenarios:=True, _
                AllowFormattingCells:=True, AllowFormattingRows:=True, AllowFormattingColumns:=True
        Else
            .Protect Password:=actPwd, userinterfaceonly:=False, _
                DrawingObjects:=True, Contents:=True, Scenarios:=True
        End If
    End With
    protectSheet = True
Exit Function

PROTECTION_ERROR:
Debug.Print "protectSheet(..)", sh.name, Err.Description
    Err.Clear
    protectSheet = False
Exit Function

End Function

Private Sub testProtectUnprotect()
Dim sh As Variant
    Set sh = getSheet("Gesamtumsatz")
    unprotectSheet sh, True
    
    If (Not protectSheet(sh, True)) Then
        MsgBox "Passwort ung|fffd|ltig.", vbExclamation, cs_MsgTitle
    End If
End Sub

Function unprotectSheet(sh As Variant, prompt As Boolean) As Boolean  ', Optional pwd As String = ""
Dim msg As String

    unprotectSheet = True
    On Error GoTo PROTECTION_ERROR
    If (TypeOf sh Is Worksheet) Then
'        If isLiquiplanSheet(sh) Then
            sh.Unprotect cs_LiquiPWD
'        End If
    ElseIf (TypeOf sh Is Chart) Then
        sh.Unprotect ""
    End If
Exit Function

PROTECTION_ERROR:
Debug.Print "unprotectSheet(..)", sh.name, Err.Description
    Err.Clear
    If prompt Then
        sh.Activate
        msg = "Bitte heben Sie den Blattschutz von '" + sh.name + "' auf"
        msg = msg + vbLf + "und stellen Sie die Formel|fffd|berwachung wieder her."
        msg = msg + vbLf + "Andernfalls ist die Modell-Konsistenz nicht mehr gew|fffd|hrleistet."
        MsgBox msg, vbExclamation, cs_MsgTitle
    End If
    
    If (Not modelWatchBtn Is Nothing) Then
        modelWatchBtn.caption = cs_restoreModelProtection
    End If
    gb_protectionIssue = True
    gb_modelProtectionSuspended = True
    addLiquiMenus
    
    unprotectSheet = False
Exit Function
    
End Function

Function unprotectAllSheets(choice As Long) As Boolean
Dim mainSheet As Worksheet, wsh As Worksheet, shx As Long, sError As String
Dim eventsFlag As Boolean

    unprotectAllSheets = False
    
    Set mainSheet = getSheet(gs_MainSheetName)
    If mainSheet Is Nothing Then
        Set mainSheet = validateMainSheet(sError)
        If sError <> "" Then MsgBox sError, vbExclamation, cs_MsgTitle
        If mainSheet Is Nothing Then
Exit Function
        End If
    End If
    
    ' model sheets only
    For shx = 1 To gn_MainSheetIndex
        Set wsh = ActiveWorkbook.Worksheets(shx)
Application.StatusBar = "|fffd|ffnen: " & wsh.name
DoEvents
        If (choice >= 1) Then
            If (Not unprotectSheet(wsh, True)) Then
Exit Function
            End If
        End If
        If (choice >= 2) Then
            Set wsh = ActiveWorkbook.Worksheets(getMasterSheetName(wsh.name))
Application.StatusBar = "|fffd|ffnen: " & wsh.name
DoEvents
            If (Not unprotectSheet(wsh, True)) Then
Exit Function
            End If
        End If
        
        If (choice >= 3) Then
            Set wsh = ActiveWorkbook.Worksheets(shx)
            Set wsh = ActiveWorkbook.Worksheets(getCompareSheetName(wsh.name))
Application.StatusBar = "|fffd|ffnen: " & wsh.name
DoEvents
            If (Not unprotectSheet(wsh, True)) Then
Exit Function
            End If
        End If
        DoEvents
    Next
    If (choice >= 4) Then
        Set wsh = getSheet(cs_PlotData)
Application.StatusBar = "|fffd|ffnen: " & wsh.name
DoEvents
        If (Not unprotectSheet(wsh, True)) Then
Exit Function
        End If
        Set wsh = getSheet(cs_GraphicsData)
Application.StatusBar = "|fffd|ffnen: " & wsh.name
DoEvents
        If (Not unprotectSheet(wsh, True)) Then
Exit Function
        End If
        DoEvents
    End If
    
    For Each wsh In ActiveWorkbook.Worksheets
        If (Not isLiquiplanSheet(wsh)) Then
Application.StatusBar = "|fffd|ffnen: " & wsh.name
DoEvents
            unprotectSheet wsh, False
        End If
        DoEvents
    Next
    
    unprotectAllSheets = True
End Function

Function protectAllSheets(choice As Long) As Boolean
Dim mainSheet As Worksheet, wsh As Worksheet, shx As Long, sError As String

    Set mainSheet = getSheet(gs_MainSheetName)
    If mainSheet Is Nothing Then
        Set mainSheet = validateMainSheet(sError)
        If sError <> "" Then MsgBox sError, vbExclamation, cs_MsgTitle
        If mainSheet Is Nothing Then
Exit Function
        End If
    End If
    
    On Error Resume Next
    ' model sheets only
    For shx = 1 To gn_MainSheetIndex
        Set wsh = ActiveWorkbook.Worksheets(shx)
        If (choice >= 1 And Not wsh.ProtectContents) Then
            protectSheet wsh
        End If
        If (choice >= 2) Then
            Set wsh = ActiveWorkbook.Worksheets(getMasterSheetName(wsh.name))
            If Not wsh.ProtectContents Then protectSheet wsh
        End If
        If (choice >= 3) Then
            Set wsh = ActiveWorkbook.Worksheets(shx)
            Set wsh = ActiveWorkbook.Worksheets(getCompareSheetName(wsh.name))
            If Not wsh.ProtectContents Then protectSheet wsh
        End If
        DoEvents
    Next
    If (choice >= 4) Then
        Set wsh = getSheet(cs_PlotData)
        If Not wsh.ProtectContents Then protectSheet wsh
        DoEvents
        
        Set wsh = getSheet(cs_GraphicsData)
        If Not wsh.ProtectContents Then protectSheet wsh
        DoEvents
    End If
    On Error GoTo 0
End Function


Sub unlockQuantity(rng As Range, includeFormulae As Boolean)
Dim srcBk As Workbook, srcSh As Worksheet, srcRow As Long, srcClm As Long
Dim row As Long, clm As Long, width As Long, height As Long
Dim isProtected As Boolean, eventsFlag As Boolean
    
Application.ScreenUpdating = False
eventsFlag = Application.EnableEvents
Application.EnableEvents = False

    Set srcSh = rng.parent
    srcRow = rng.row
    srcClm = rng.Column
    width = rng.Columns.Count
    height = rng.Rows.Count
    
    '8.3.0.8: watch manual interior color changes
    ' not too often (validateMainSheet(..) only
'    storeRowColors srcSh
'    storeColorMap srcSh
    
    isProtected = srcSh.ProtectContents
    If (Not unprotectSheet(srcSh, True)) Then
Exit Sub
    End If
    
    For row = srcRow To srcRow + height - 1
        srcSh.Cells(row, cn_clm_Quantity).Interior.Color = gn_color_quantityUnlocked
        For clm = cn_clm_January - 1 To cn_clm_Year
            With srcSh.Cells(row, clm)
                If Not .HasFormula Or isConstantNumericFormula(srcSh.Cells(row, clm)) Then
                    .Locked = False
                ElseIf includeFormulae Then
                    .Locked = False
                    .Interior.Color = gn_color_quantityUnlocked
                End If
            End With
        Next
    Next
    If isProtected Then protectSheet srcSh
Application.ScreenUpdating = True
Application.EnableEvents = eventsFlag
End Sub

Sub markProtectedCells(sh As Worksheet, mark As Boolean)
Dim rng As Range, rowMax As Long, clmMax As Long
Dim isProtected As Boolean
Dim idx As Long, row As Long, clm As Long

    isProtected = sh.ProtectContents
    sh.Unprotect cs_LiquiPWD
    
    rowMax = getLastRow(sh.usedRange)
    clmMax = getDataWidth(sh)
    On Error GoTo WARNUNG
    Dim isFirst As Boolean, msg As String
    isFirst = True
    For row = 1 To rowMax: For clm = 1 To clmMax
        Set rng = sh.Cells(row, clm)
        If IsError(rng) Then
            GoTo WARNUNG
        End If
        If rng.HasFormula Or (Not IsNumeric(rng) And isNameProtected(rng.Cells(1, 1))) Then
            If mark Then
'                markCell rng
            Else
'                unmarkCell rng
            End If
        End If
CONTINUE:     Next
    Next
    If msg <> "" Then MsgBox msg
    If isProtected Then
        protectSheet sh
    End If
Exit Sub

WARNUNG:
    Err.Clear
'    msg = "Fehlerhafter Inhalt: Blatt '" & Sh.name & "' Zeile=" & row & ", Spalte=" & clm
    msg = "Fehlerhafter Inhalt: '" & sh.name & "'!" & Replace(rng.Address, "$", "")
    msg = msg & vbLf & rng.formula
    rng.parent.Activate
    rng.Select
    MsgBox msg
    If isProtected Then
        protectSheet sh
    End If
    Exit Sub
    
End Sub

Sub warnProtectedCellChanged(Target As Range)
Dim wsh As Worksheet, context As Range, cll As Range, row As Long, clm As Long

    If gb_formulaWatchDisabled Then Exit Sub
    
Dim repaired As Boolean
    Set wsh = Target.parent
'Debug.Print "warnProtectedCellChanged: ", wsh.name, Target.row, Target.Column, Target.Rows.Count, Target.Columns.Count
    
    For Each cll In Target
        row = cll.row
        clm = cll.Column
        If (clm >= cn_clm_January And clm <= cn_clm_December) Then
            ' quantity definition
'            cll.Interior.Color = ga_headerColors(cll.row)  ' xlNone
            With wsh
                Set context = .Range(.Cells(row, cn_clm_January), .Cells(row, cn_clm_December))
                markOutlierInContext context, cll
            End With
        ElseIf (row > gn_row_Section_I_Start And clm = cn_clm_January - 1) Then
            ' value previous year (value or link)
'            cll.Interior.Color = ga_headerColors(cll.row)  ' xlNone
            cll.Interior.Color = ga_colorMap(cll.row, cll.Column)
            If Not (wsh.Cells(row - 1, clm).HasFormula And wsh.Cells(row + 1, clm).HasFormula) Then GoTo CONTINUE
            If (cll.FormulaR1C1 <> wsh.Cells(row - 1, clm).FormulaR1C1 And cll.FormulaR1C1 <> wsh.Cells(row + 1, clm).FormulaR1C1) Then
                cll.Interior.Color = gn_color_outlier
            End If
        End If
CONTINUE:
    Next
End Sub

Function lockUnlockMonth(ByVal Target As Range) As Boolean ', gb_warnIfUnprotected As Boolean
Dim abk As Workbook, srcSheet As Worksheet, wsh As Worksheet, rng As Range, usedRange As Range, cll As Range
Dim monthName As String, month As Long
Dim customDataWidth As Long, firstRowUsed As Long, lastRowUsed As Long, row As Long, clm As Long
Dim name As String, formula As String, sError As String
Dim idx As Long, msg As String, temp As String, value As Variant
Dim isProtect As Boolean
    
    lockUnlockMonth = False
    
    If gs_MainSheetName = "" Or gn_MainSheetIndex = 0 Then
        Set wsh = validateMainSheet(sError)
        If (wsh Is Nothing) Then
Exit Function
        End If
    End If
    
    Set srcSheet = Target.parent
'Debug.Print "lockUnlockMonth(..)", srcSheet.name
    Set abk = srcSheet.parent
    With srcSheet
        isProtect = .ProtectContents
        On Error GoTo PWD_ERROR
        .Unprotect cs_LiquiPWD
        On Error GoTo 0
        
        firstRowUsed = .usedRange.row
        lastRowUsed = getLastRow(.usedRange)
        
        customDataWidth = WorksheetFunction.Min(cn_dataWidth + cn_userMargin, getLastColumn(.usedRange))
    
        monthName = Target.Cells(1, 1)
        month = monthToNumber(monthName)
        
'Debug.Print "lockUnlockMonth()", monthName, srcSheet.name
    
On Error Resume Next    'patch if cells have been lumped together
        If month = 0 Then
        'planning mode
            'names: all unlocked but prologue and section headers
            Set rng = .Range(.Cells(1, 2), .Cells(gn_row_Section_I_Start - 1, 2))
            rng.Locked = True
            Set rng = .Range(.Cells(gn_row_Section_I_Start, 2), .Cells(lastRowUsed, 2))
            rng.Locked = False
            For row = gn_row_Section_I_Start To lastRowUsed
                name = .Cells(row, 2)
                If isNameProtected(name) Then
                    .Cells(row, 2).Locked = True
                End If
            Next
            
            'prologue: only formulae are being locked
            For row = 1 To gn_row_Section_I_Start: For clm = 3 To customDataWidth ' cn_dataWidth
                Set cll = .Cells(row, clm)
                With cll
                    .Locked = .HasFormula
                End With
            Next: Next
            For row = gn_row_Section_I_Start To lastRowUsed: For clm = 3 To customDataWidth ' cn_dataWidth    'data
                Set cll = .Cells(row, clm)
                With cll
                    .Locked = .HasFormula
                End With
            Next: Next
        Else
        'some month
            'names: all locked
            Set rng = .Range(.Cells(1, 2), .Cells(lastRowUsed, 2))
            rng.Locked = True
            
            'prologue: all locked but actual month name
            Set rng = .Range(.Cells(1, 3), .Cells(lastRowUsed, customDataWidth)) ' cn_dataWidth
            rng.Locked = True
            Set cll = .Cells(gn_monthRow, 3)
            cll.Locked = False
            
            'data: all month columns but actual month
            For row = gn_row_Section_I_Start To gn_row_MonthRangeEnd: For clm = 3 To customDataWidth ' cn_dataWidth
                Set cll = .Cells(row, clm)
                With cll
                    If clm <> month + 3 Then
                        .Locked = True
                    Else
                        .Locked = .HasFormula
                    End If
                End With
            Next: Next
            
            ' below custom section: formulae only
            If lastRowUsed > gn_row_MonthRangeEnd Then
                For row = gn_row_MonthRangeEnd + 1 To lastRowUsed: For clm = 3 To customDataWidth ' cn_dataWidth
                    Set cll = .Cells(row, clm)
                    With cll
                        .Locked = .HasFormula
                    End With
                Next: Next
            End If
        End If
On Error GoTo 0

        ' highlight given month in column headers
        Set rng = .Range(.Cells(1, cn_clm_January - 1), .Cells(1, cn_clm_Year))
        rng.Interior.Color = gn_color_month
        If month > 0 Then
            .Cells(1, cn_clm_January + month - 1).Interior.Color = gn_color_monthHighlight
        End If
        For row = gn_row_Section_I_Start To lastRowUsed
            If Not .Cells(row, cn_clm_January).HasFormula Then
                If .Cells(row, cn_clm_January) = "Januar" Then
                    Set rng = .Range(.Cells(row, cn_clm_January), .Cells(row, cn_clm_Year))
                    rng.Interior.Color = gn_color_month
                    If month > 0 Then
                        .Cells(row, cn_clm_January + month - 1).Interior.Color = gn_color_monthHighlight
                    End If
                End If
            End If
        Next
            
        If gb_warnIfUnprotected And Not isProtect Then
            If MsgBox("Blattschutz f|fffd|r " & srcSheet.name & " wiederherstellen?", vbYesNo, cs_MsgTitle) = vbYes Then
                isProtect = True
            Else
                gb_warnIfUnprotected = False
            End If
        End If
                
        If isProtect Then
            protectSheet srcSheet
        End If
    End With    'srcSheet
    
    lockUnlockMonth = True
Exit Function

PWD_ERROR:
    srcSheet.Activate
    msg = "Bitte heben Sie den Blattschutz von '" + srcSheet.name + "' auf (Passwort-gesch|fffd|tzt)."
    msg = msg + vbLf + "Andernfalls ist die Konsistenz des Modells nicht mehr gew|fffd|hrleistet."
    MsgBox msg, vbExclamation, cs_MsgTitle
    lockUnlockMonth = False

End Function


' ========== develop: call in debug mode ==========

Private Sub formelnSchuetzen()
Dim idx As Long, row As Long, clm As Long
Dim sh As Worksheet, rng As Range, rowMax As Long, clmMax As Long

    For idx = 1 To ActiveWorkbook.Worksheets.Count
        Set sh = ActiveWorkbook.Worksheets(idx)
        'Set Sh = ActiveWorkbook.Worksheets(gs_MainSheetName)
        sh.Unprotect cs_LiquiPWD
        With sh.usedRange
            rowMax = .row + .Rows.Count - 1
            clmMax = .Column + .Columns.Count - 1
        End With
        For row = 1 To rowMax
        For clm = 1 To clmMax
            Set rng = sh.Cells(row, clm)
            On Error Resume Next 'if cells are merged
            rng.Locked = False
'            If rng.HasFormula Or clm < 3 Or Not IsNumeric(rng) Then
            If rng.HasFormula Or (Not IsNumeric(rng) And isNameProtected(rng.Cells(1, 1))) Then
                'MsgBox rng.FormulaLocal
                rng.Locked = True
            End If
            On Error GoTo 0
        Next: Next
        protectSheet sh
    Next
End Sub


' ========== cemetery ==========

Attribute VB_Name = "LibData"
Option Explicit

Function findReference(wshSelected As Worksheet, rowSelected As Long, oldName As String) As Range
Dim abk As Workbook, wsh As Worksheet, cll As Range
Dim addr As String, addr2 As String, row As Long, clm As Long, idx As Long

    Set findReference = Nothing
    With wshSelected
        For idx = 1 To cn_dataWidth
            Set cll = .Cells(rowSelected, idx)
            addr = cll.Address
            addr2 = Replace(addr, "$", "")
            For row = 1 To getLastRow(.usedRange)
                If row <> rowSelected Then
                    For clm = 1 To cn_dataWidth
                         ' issue: finds "=C131" for row = 31 (( InStr(..) > 0 ))
                         ' issue: after some insertion, links to previous year may be out-of-sync
'                        If .Cells(row, clm).HasFormula And InStr(1, .Cells(row, clm).formula, "" & rowSelected) > 0 Then
                        If (.Cells(row, clm).HasFormula And InStr(1, .Cells(row, clm).formula, "!") <= 0 And _
                                (InStr(1, .Cells(row, clm).formula, addr) > 0 Or InStr(1, .Cells(row, clm).formula, addr2) > 0)) Then
                            Set findReference = .Cells(row, clm)
Exit Function
                        End If
                    Next
                End If
            Next
        Next
    End With
End Function



' wrapper for copyDataToMaster
Function storeMasterData(checkMonth As Boolean) As Boolean
Dim mainSheet As Worksheet, cll As Range, nMonth As Long, sMonth As String
Dim srcBk As Workbook, srcSh As Worksheet, mstSh As Worksheet, wsh As Worksheet, shx As Long
Dim msg As String, sError As String
Dim eventsFlag As Boolean

    storeMasterData = False
    
' ???
' if called before anything else, some globals like gn_monthRow are not properly initialized
    If (gs_MainSheetName = "") Then
        Set mainSheet = validateMainSheet(sError)
    Else
        Set mainSheet = getSheet(gs_MainSheetName)
    End If
    If mainSheet Is Nothing Then
        MsgBox sError, vbCritical, cs_MsgTitle
Exit Function
    End If
    
    Set srcBk = ActiveWorkbook
    For shx = 1 To gn_MainSheetIndex
        Set srcSh = srcBk.Worksheets(shx)
        Set mstSh = findOrCreateWorksheet(getMasterSheetName(srcSh.name), srcBk)
        If (Not unprotectSheet(mstSh, True)) Then
Exit Function
        End If
    Next
    
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    
    With mainSheet
        Set cll = .Cells(gn_monthRow, 3)
        nMonth = 0
        If Not IsEmpty(cll) And cll.value <> cs_NoMonth Then
            nMonth = numberOfMonth(cll.value)
        End If
        If (checkMonth And nMonth > 0) Then
            sMonth = ""
            If nMonth < 12 Then
                sMonth = numberToMonth(nMonth + 1)
            End If
            msg = "Nicht mehr im Planungs-, sondern im Berichtszustand !"
            If sMonth = "" Then
                msg = msg & vbLf & "Ende des Jahres erreicht."
                MsgBox msg, , cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
            Else
                msg = msg & vbLf & "Neue Plandaten ab Monat " & sMonth & " in Original Plandaten speichern ?"
                If MsgBox(msg, vbOKCancel, cs_MsgTitle) <> vbOK Then
Application.EnableEvents = eventsFlag
Exit Function
                End If
            End If
        End If
Application.ScreenUpdating = False
Application.DisplayAlerts = False
Application.Calculation = xlCalculationManual
        If Not copyDataToMaster(mainSheet, nMonth, sError, standAlone:=True) Then
            If sError <> "" Then MsgBox sError, vbCritical, cs_MsgTitle
Application.ScreenUpdating = True
Application.DisplayAlerts = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = eventsFlag
Exit Function
        End If
        
'        updateReports .Cells(gn_monthRow, 3), cs_NoMonth
        
        .Activate
        .Cells(gn_monthRow, 3).Select
    End With
    
    For shx = 1 To gn_MainSheetIndex
        Set srcSh = srcBk.Worksheets(shx)
        Set mstSh = findOrCreateWorksheet(getMasterSheetName(srcSh.name), srcBk)
        protectSheet mstSh  ' unconditionally
    Next
    
    storeMasterData = True
    
' really needed / of some value ?
'    Application.CalculateFull ' Debug.prints all errors
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = eventsFlag
End Function

' wrapper for copyMaster (main and profit centers)
Function copyDataToMaster(srcSheet As Worksheet, nMonth As Long, sError As String, standAlone As Boolean) As Boolean

Const rowOff As Long = 8

Dim wb As Workbook, mstSheet As Worksheet, srcName As String, masterName As String
Dim first As Long, last As Long, row As Long, clm As Long
Dim isProtected As Boolean, notFound As Boolean, flag As Boolean, eventsFlag As Boolean
Dim formula As String
Dim idx As Long, msg As String, temp As String, value As Variant
    
    copyDataToMaster = False

Dim ync As VbMsgBoxResult
Dim makeNew As Boolean

    Set wb = srcSheet.parent
    
    makeNew = False
    masterName = getMasterSheetName(srcSheet.name)
    Set mstSheet = getSheet(masterName, wb)
    If mstSheet Is Nothing Then
        makeNew = True
    Else
'        With mstSheet
'            If standAlone And Not isRangeEmpty(.Cells) Then  ' .Range(.Cells(1, 2), .Cells(gn_row_Section_I_Start - 1, 2))
'                If nMonth = 0 Then
'                    ync = MsgBox("Original Plandaten |fffd|berschreiben?", vbYesNoCancel, cs_MsgTitle)
'                    If ync = vbCancel Then
'                        sError = ""
'Exit Function
'                    ElseIf ync = vbNo Then
'                        makeNew = True
'                    End If
''                Else
''                    ync = MsgBox("Original Plandaten |fffd|berschreiben?", vbOKCancel, cs_MsgTitle)
''                    If ync = vbCancel Then
''                        sError = ""
''Exit Function
''                    End If
'                End If
'            End If
'        End With
    End If
    If makeNew Then
        Set mstSheet = makeNewSheet(wb, masterName)
    End If
'Debug.Print srcSheet.name, mstSheet.name
Application.StatusBar = srcSheet.name
DoEvents
'Debug.Print "copyDataToMaster()", srcSheet.name, nMonth

    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    
'disable protection verification
    copyMaster srcSheet, mstSheet, nMonth
    
    On Error Resume Next
    If gs_MainSheetName = cs_MainSheet_ProfitCenter And gs_ProfitCenters <> "" Then
        ' vor dem Aktualisieren der Konsolidierungsformeln muessen PlanKopien aller PC existieren
        For idx = 1 To gn_MainSheetIndex - 1
'Application.StatusBar = wb.Worksheets(idx).name
            masterName = getMasterSheetName(wb.Worksheets(idx).name)
            Set mstSheet = Nothing
            Set mstSheet = wb.Worksheets(masterName)
            If mstSheet Is Nothing Then
                Set mstSheet = makeNewSheet(wb, masterName, wb.Worksheets(cs_MasterSheetName))
            End If
            copyMaster wb.Worksheets(idx), mstSheet, nMonth
        Next
        updateConsolidation isMaster:=True
    End If
    On Error GoTo 0
        
Application.StatusBar = False
DoEvents
    Application.EnableEvents = eventsFlag
    copyDataToMaster = True
End Function

Private Sub copyMaster(srcSheet As Worksheet, mstSheet As Worksheet, nMonth As Long)
Dim awb As Workbook, srcRng As Range, trgRng As Range, row As Long, clm As Long
Dim topRow As Long, leftClm As Long, bottomRow As Long, rightClm As Long    ' , width As Long, height As Long
Dim repeat As Boolean, repeat2 As Boolean
Dim srcVisible As XlSheetVisibility, mstVisible As XlSheetVisibility
Dim shp As Shape
Dim msg As String

Debug.Print "copyMaster(..)", nMonth, srcSheet.name, "=>", mstSheet.name
Application.StatusBar = "Plandaten speichern: " & srcSheet.name
DoEvents

    If (Not unprotectSheet(mstSheet, True)) Then
Exit Sub
    End If

On Error GoTo COPY_ERROR
        
        With srcSheet
            srcVisible = .visible
            .visible = xlSheetVisible
            .Activate
            .Cells.MergeCells = False
            If nMonth = 0 Then
                ' overwrite all
                topRow = 1: leftClm = 1
                bottomRow = getLastRow(.usedRange)
                rightClm = getLastColumn(.usedRange)
            Else
                topRow = gn_row_Section_I_Start
                leftClm = cn_clm_January + nMonth
                If gn_row_Section_V_Start > 0 Then
                    bottomRow = gn_row_Section_V_Start - 1
                Else
                    bottomRow = gn_row_Section_IV_End
                End If
                rightClm = cn_clm_December
            End If
            Set srcRng = .Range(.Cells(topRow, leftClm), .Cells(bottomRow, rightClm))
        End With
        
        With mstSheet
            mstVisible = .visible
            .visible = xlSheetVisible
            .Activate
            If nMonth = 0 Then
                ' clean-up
                .Cells.MergeCells = False
                .Cells.Clear
                For Each shp In .Shapes
                    If startsWith(shp.name, "Picture") Or startsWith(shp.name, "Grafik") Then
                        shp.Select
                        shp.Locked = msoFalse
                        shp.Delete
                    End If
                Next
            End If
            Set trgRng = .Range(.Cells(topRow, leftClm), .Cells(bottomRow, rightClm))
        End With

        Application.CutCopyMode = False
        srcSheet.Select
        srcRng.Select
        srcRng.Copy
        mstSheet.Select
        trgRng.Select
        mstSheet.Paste  '[sic!]
        
        mstSheet.Cells(topRow, leftClm).Select
        protectSheet mstSheet   ' unconditionally
        
        srcSheet.Activate
        srcSheet.Cells(topRow, leftClm).Select
        
        srcSheet.visible = srcVisible
        mstSheet.visible = mstVisible
Exit Sub

COPY_ERROR:
    Debug.Print Err.Number, Err.Description, row, clm ', "'" & srcSheet.Cells(row, clm).formula & "'"
    Err.Clear
    Resume Next
    
End Sub


Function findOrCreateWorksheet(nameSh As String, Optional wb As Workbook = Nothing) As Worksheet
Dim sh As Worksheet, before As Worksheet
Dim pos As Long

    Set findOrCreateWorksheet = Nothing
    If wb Is Nothing Then Set wb = Application.ActiveWorkbook
    Set sh = getSheet(nameSh, wb)
    If Not sh Is Nothing Or nameSh = gs_MainSheetName Or nameSh = cs_MasterSheetName Or nameSh = cs_CompareSheetName Then
        Set findOrCreateWorksheet = sh
        Exit Function
    End If
    
    pos = InStr(1, nameSh, "Plandaten(")
    If pos = 1 Then
        Set before = getSheet(cs_MasterSheetName, wb)
        Set findOrCreateWorksheet = makeNewSheet(wb, nameSh, before)
        Exit Function
    End If
    pos = InStr(1, nameSh, cs_CompareSheetName & "(")
    If pos = 1 Then
        Set before = getSheet(cs_CompareSheetName, wb)
        Set findOrCreateWorksheet = makeNewSheet(wb, nameSh, before)
        Exit Function
    End If
    pos = InStr(1, nameSh, "PlotDaten(")
    If pos = 1 Then
        Set before = getSheet(cs_PlotData)
        Set findOrCreateWorksheet = makeNewSheet(wb, nameSh, before)
        findOrCreateWorksheet.visible = xlSheetHidden
        Exit Function
    End If
    Set findOrCreateWorksheet = makeNewSheet(wb, nameSh)
    If (nameSh = cs_PlotData) Then
        findOrCreateWorksheet.visible = xlSheetHidden
    End If
End Function

Function copyCompareSheet(newName As String) As Worksheet
Dim cmpSheet As Worksheet, cmpSheet2 As Worksheet, idx As Long
    Set cmpSheet = getSheet(newName)
    If cmpSheet Is Nothing Then
        ' make copy of 'master' compare sheet
        ' ! .copy copies code as well !
        Set cmpSheet2 = ActiveWorkbook.Worksheets(cs_CompareSheetName)
        cmpSheet2.Copy cmpSheet2
        For idx = 1 To ActiveWorkbook.Worksheets.Count
            If ActiveWorkbook.Worksheets(idx).name = cs_CompareSheetName Then
                Set cmpSheet = ActiveWorkbook.Worksheets(idx - 1)
                cmpSheet.name = newName
                Exit For
            End If
        Next
    End If
    Set copyCompareSheet = cmpSheet
End Function

Function getMasterSheetName(srcSheetName As String) As String
    If srcSheetName = gs_MainSheetName Then
        getMasterSheetName = cs_MasterSheetName
    Else
        getMasterSheetName = cs_MasterPrefix & srcSheetName & ")"
    End If
End Function

Function getInputSheetName(mstSheetName As String) As String
    getInputSheetName = ""
    If startsWith(mstSheetName, cs_MasterPrefix) Then
        getInputSheetName = Mid$(mstSheetName, Len(cs_MasterPrefix) + 1, Len(mstSheetName) - Len(cs_MasterPrefix) - 1)
    End If
End Function

Function getCompareSheetName(srcSheetName As String) As String
    If srcSheetName = gs_MainSheetName Then
        getCompareSheetName = cs_CompareSheetName
    Else
        getCompareSheetName = cs_CompareSheetName & "(" & srcSheetName & ")"
    End If
End Function

Function isCompareSheetName(name As String) As Boolean
    isCompareSheetName = (name = cs_CompareSheetName Or startsWith(name, cs_CompareSheetName & "("))
End Function

Function getMainSheetName(Optional bk As Workbook = Nothing) As String
Dim wb As Workbook, sh As Worksheet, idx As Long
Dim hasMainSheet_BasicModel As Boolean, hasMainSheet_ProfitCenter As Boolean

    Set wb = Application.ActiveWorkbook
    If Not bk Is Nothing Then
        Set wb = bk
    End If
    hasMainSheet_BasicModel = False: hasMainSheet_ProfitCenter = False
    For idx = 1 To wb.Worksheets.Count
        Set sh = wb.Worksheets(idx)
        If sh.name = cs_MainSheet_BasicModel Then
            getMainSheetName = cs_MainSheet_BasicModel
            hasMainSheet_BasicModel = True
            gn_MainSheetIndex = idx
        ElseIf sh.name = cs_MainSheet_ProfitCenter Then
            getMainSheetName = cs_MainSheet_ProfitCenter
            hasMainSheet_ProfitCenter = True
            gn_MainSheetIndex = idx
        End If
    Next
    If hasMainSheet_BasicModel And hasMainSheet_ProfitCenter Then
        getMainSheetName = cs_MainSheet_BasicModel & "|" & cs_MainSheet_ProfitCenter
    ElseIf hasMainSheet_BasicModel Then
        getMainSheetName = cs_MainSheet_BasicModel
    ElseIf hasMainSheet_ProfitCenter Then
        getMainSheetName = cs_MainSheet_ProfitCenter
    Else
        getMainSheetName = ""
    End If
End Function


Function importData(trgSh As Worksheet, trgRow As Long, height As Long)
'   1.  Zweite Arbeitsmappe (Quelle) |fffd|ffnen (anderer Name!).
'   2.  Nur Daten, keine Formeln |fffd|bertragen
'       Zeilen-Titel m|fffd|ssen |fffd|bereinstimmen, sonst Warnung
'       (neue Tabelle entsprechend vorbereiten)

Dim srcBk As Workbook, srcSh As Worksheet, trgBk As Workbook
Dim shLog As Worksheet
Dim row As Long, clm As Long
Dim isProtected As Boolean
Dim msg As String, tmp As String, idx As Long, sError As String

Dim fso As FileSystemObject, srcBookPath As String, isSourceOpen As Boolean
Dim eventsFlag As Boolean

    Set trgBk = ActiveWorkbook
    
    ' must avoid repeated initializeModel()
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    
    Set fso = New FileSystemObject
    If Workbooks.Count = 1 Then
        srcBookPath = pickFile("Bitte Quelle f|fffd|r Daten|fffd|bernahme w|fffd|hlen.", trgBk.path & "\")
        If srcBookPath = "" Then
Application.EnableEvents = eventsFlag
Exit Function ' canceled
        End If
Debug.Print trgBk.FullName
Debug.Print srcBookPath
        If (Not fso.FileExists(srcBookPath)) Then
            msg = "Kann " & srcBookPath & " nicht finden."
            MsgBox msg, vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function ' canceled
        ElseIf srcBookPath = trgBk.FullName Then
            msg = "Ausgew|fffd|hlte Quelle stimmt mit Ziel |fffd|berein."
            MsgBox msg, vbInformation, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function ' canceled
        End If
        
        ' source already open
        isSourceOpen = False
        Set srcBk = Nothing
        On Error Resume Next
            Set srcBk = Application.Workbooks(fso.GetFileName(srcBookPath))
        On Error GoTo 0
        If (srcBk Is Nothing) Then
            isSourceOpen = False
        ElseIf (srcBk.FullName <> srcBookPath) Then
            srcBk.Close
            Set srcBk = Nothing
            isSourceOpen = False
        End If
        If (Not isSourceOpen) Then
            On Error Resume Next
            Set srcBk = Application.Workbooks.Open(srcBookPath, False)
            On Error GoTo 0
            If (srcBk Is Nothing) Then
                msg = "Kann " + fso.GetFileName(srcBookPath) + " nicht |fffd|ffnen."
                MsgBox msg, vbCritical
Application.EnableEvents = eventsFlag
Exit Function
            End If
        End If
    End If
    
    If Workbooks.Count > 2 Then
        MsgBox "Bitte alle Arbeitsmappen bis auf Ziel und Quelle schlie|fffd|en.", vbExclamation, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    Else
        For idx = 1 To Workbooks.Count
            If Workbooks(idx).name <> trgBk.name Then
                Set srcBk = Workbooks(idx)
                Exit For
            End If
        Next
    End If
    
'Stop

    If (getSheet(gs_MainSheetName, trgBk) Is Nothing) Then
        MsgBox "Keine g|fffd|ltige LiquiPlan Arbeitsmappe: '" & trgBk.name & "'", vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    ElseIf (getSheet(gs_MainSheetName, srcBk) Is Nothing) Then
        MsgBox "Keine g|fffd|ltige LiquiPlan Arbeitsmappe: '" & srcBk.name & "'", vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    End If
    
    Set srcSh = getSheet(trgSh.name, srcBk)
    If (srcSh Is Nothing) Then
        MsgBox "Quelle = [" & srcBk.name & "]" & trgSh.name & " existiert nicht.", vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    End If
    
    srcBk.Activate
    srcSh.Activate
    If (trgRow > 5) Then
        ActiveWindow.ScrollRow = trgRow - 5
    Else
        ActiveWindow.ScrollRow = 1
    End If
    With srcSh
        .Range(.Cells(trgRow, cn_clm_Quantity), .Cells(trgRow + height - 1, cn_clm_Quantity)).Select
    End With
    
'    ActiveWindow.ScrollRow = 33
'    Windows.Arrange ArrangeStyle:=xlVertical
'    Windows("PC 2019 (8.3.0.2 +b).xlsm").Activate
'    Application.Left = 102.4
'    Application.Top = 1
'    Application.width = 609
'    Application.height = 649.2
    
    trgBk.Activate
    trgSh.Activate
    If (trgRow > 5) Then
        ActiveWindow.ScrollRow = trgRow - 5
    Else
        ActiveWindow.ScrollRow = 1
    End If
    Windows.Arrange ArrangeStyle:=xlVertical
Application.StatusBar = False
DoEvents

    msg = "Bitte Daten|fffd|bernahme best|fffd|tigen: "
    If (height = 1) Then
        tmp = "Gr|fffd||fffd|e = (" & trgRow & ") '" & trgSh.Cells(trgRow, cn_clm_Quantity).formula & "'"
    Else
        tmp = "Gr|fffd||fffd|en = (" & trgRow & "-" & trgRow + height - 1 & ") '" & trgSh.Cells(trgRow, cn_clm_Quantity).formula & "', ff."
    End If
    msg = msg & vbCrLf & tmp
    msg = msg & vbCrLf & "Ziel (linke Seite) = [" & trgBk.name & "]" & trgSh.name
    msg = msg & vbCrLf & "Quelle (rechte Seite) = [" & srcBk.name & "]" & trgSh.name
    msg = msg & vbCrLf & vbCrLf & "Es werden nur leere Ziel-Felder beschrieben."
    If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel Then
        Application.DisplayAlerts = False
        srcBk.Close
        Application.DisplayAlerts = True
Application.EnableEvents = eventsFlag
Exit Function
    End If
    
    copyData srcSh, trgRow, trgSh, trgRow, height
    
    Application.DisplayAlerts = False
' ??? close source, restore active
    If False Then srcBk.Close
    Application.DisplayAlerts = True
'    ' maximize
'    Application.SendKeys "%{ }"
'    Application.Wait (Now + TimeValue("00:00:01"))
'    Application.SendKeys "x"
    
    ' update performance analysis, charts
    If (trgRow > gn_row_Section_III_Start And trgRow <= gn_row_G_u_V) Then
'        processMonthChange Target:=ActiveWorkbook.Worksheets(gs_MainSheetName).Cells(gn_monthRow, 3), force:=True
        performanceAnalysis
    End If
    trgBk.Activate
    trgSh.Activate
    With trgSh
        .Range(.Cells(trgRow, cn_clm_Quantity), .Cells(trgRow + height - 1, cn_clm_Quantity)).Select
    End With
    
    With ActiveWindow   ' target
        .width = 1.5 * .width ' to overlap source
        .ScrollColumn = 1
    End With
    
Application.EnableEvents = eventsFlag
Application.StatusBar = False
End Function

Function startDataImport(trgSh As Worksheet, trgRow As Long, trgHeight As Long)
'''   1.  Zweite Arbeitsmappe (Vorlage) |fffd|ffnen (anderer Name!);
'''       falls = Ziel, temp. Kopie anlegen.
'''   2.  Nur Daten, keine Formeln |fffd|bertragen ???
'''       nur leere Felder |fffd|berschreiben.
'''       Zeilen-Titel m|fffd|ssen |fffd|bereinstimmen, sonst Warnung
'''       (neue Tabelle entsprechend vorbereiten)
' 8.4B:
'   1.  Zweite Arbeitsmappe (Vorlage) |fffd|ffnen; falls = Ziel, temp. Kopie anlegen.
'   2   Gleich-gro|fffd|en Bereich in Vorlage ausw|fffd|hlen.
'   3.  Nur leere Felder werden |fffd|berschreiben.
'   4.  Zur Best|fffd|tigung Ziel aktivieren.

Dim srcBk As Workbook, srcSh As Worksheet, trgBk As Workbook
Dim shLog As Worksheet
Dim row As Long, clm As Long
Dim isProtected As Boolean
Dim msg As String, tmp As String, idx As Long, sError As String

Dim fso As FileSystemObject, srcBookPath As String, isSourceOpen As Boolean
Dim eventsFlag As Boolean

    Set trgBk = ActiveWorkbook
    
    ' must avoid repeated initializeModel()
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    
    Set fso = New FileSystemObject
    If Workbooks.Count = 1 Then
        srcBookPath = pickFile("Bitte Vorlage f|fffd|r Daten|fffd|bernahme w|fffd|hlen.", trgBk.path & "\")
        If srcBookPath = "" Then
Application.EnableEvents = eventsFlag
Exit Function ' canceled
        End If
Debug.Print trgBk.FullName
Debug.Print srcBookPath
        If (Not fso.FileExists(srcBookPath)) Then
            msg = "Kann " & srcBookPath & " nicht finden."
            MsgBox msg, vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function ' canceled
        ElseIf srcBookPath = trgBk.FullName Then
            msg = "Ausgew|fffd|hlte Vorlage stimmt mit Ziel |fffd|berein."
            msg = msg & vbLf & "Kopie anlegen ?"
            If MsgBox(msg, vbOKCancel, cs_MsgTitle) <> vbOK Then
Application.EnableEvents = eventsFlag
Exit Function ' canceled
            Else
Dim tmpBookName As String
                tmpBookName = "temp_" & trgBk.name
                srcBookPath = trgBk.path & "\" & tmpBookName
                fso.CopyFile trgBk.FullName, srcBookPath, True
            End If
        End If
'
        ' source already open
        isSourceOpen = False
        Set srcBk = Nothing
        On Error Resume Next
            Set srcBk = Application.Workbooks(fso.GetFileName(srcBookPath))
        On Error GoTo 0
        If (srcBk Is Nothing) Then
            isSourceOpen = False
        ElseIf (srcBk.FullName <> srcBookPath) Then
            srcBk.Close
            Set srcBk = Nothing
            isSourceOpen = False
        End If
        If (Not isSourceOpen) Then
            On Error Resume Next
            Set srcBk = Application.Workbooks.Open(srcBookPath, False)
            On Error GoTo 0
            If (srcBk Is Nothing) Then
                msg = "Kann " + fso.GetFileName(srcBookPath) + " nicht |fffd|ffnen."
                MsgBox msg, vbCritical
Application.EnableEvents = eventsFlag
Exit Function
            End If
        End If
    End If
    
    If Workbooks.Count > 2 Then
        MsgBox "Bitte alle Arbeitsmappen bis auf Ziel und Vorlage schlie|fffd|en.", vbExclamation, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    Else
        For idx = 1 To Workbooks.Count
            If Workbooks(idx).name <> trgBk.name Then
                Set srcBk = Workbooks(idx)
                Exit For
            End If
        Next
    End If
    
'Stop

    If (getSheet(gs_MainSheetName, trgBk) Is Nothing) Then
        MsgBox "Keine g|fffd|ltige LiquiPlan Arbeitsmappe: '" & trgBk.name & "'", vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    ElseIf (getSheet(gs_MainSheetName, srcBk) Is Nothing) Then
        MsgBox "Keine g|fffd|ltige LiquiPlan Arbeitsmappe: '" & srcBk.name & "'", vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    End If
    
    Set srcSh = getSheet(trgSh.name, srcBk)
    If (srcSh Is Nothing) Then
        MsgBox "Vorlage = [" & srcBk.name & "]" & trgSh.name & " existiert nicht.", vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
    End If
    
    trgBk.Activate
    trgSh.Activate
    If (trgRow > 5) Then
        ActiveWindow.ScrollRow = trgRow - 5
    Else
        ActiveWindow.ScrollRow = 1
    End If
    With trgSh.Range(trgSh.Cells(trgRow, cn_clm_Quantity), trgSh.Cells(trgRow + trgHeight - 1, cn_clm_Quantity))
        .Interior.Color = gn_color_quantityUnlocked
        .Select
    End With
    
    Windows.Arrange ArrangeStyle:=xlVertical
    
    srcBk.Activate
    srcSh.Activate
    If (trgRow > 5) Then
        ActiveWindow.ScrollRow = trgRow - 5
    Else
        ActiveWindow.ScrollRow = 1
    End If
    With srcSh
        .Range(.Cells(trgRow, cn_clm_Quantity), .Cells(trgRow + trgHeight - 1, cn_clm_Quantity)).Select
    End With
    
'    ActiveWindow.ScrollRow = 33
'    Windows.Arrange ArrangeStyle:=xlVertical
'    Windows("PC 2019 (8.3.0.2 +b).xlsm").Activate
'    Application.Left = 102.4
'    Application.Top = 1
'    Application.width = 609
'    Application.height = 649.2
    
Application.StatusBar = False
DoEvents

    gs_importSourceFullName = srcBk.FullName
    gs_importTargetFullName = trgBk.FullName
    gs_importTargetSheetName = trgSh.name
    gs_importTargetRow = trgRow
    gs_importTargetHeight = trgHeight
    gb_dataImportActive = True
    
    msg = "Bitte zu |fffd|bertragenden Bereich in der Vorlage (rechte Seite) ausw|fffd|hlen" _
        & vbLf & "und zur Best|fffd|tigung zur Zieltabelle (linke Seite) wechseln."
    MsgBox msg, vbOKOnly, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Function
End Function

Function finishDataImport()
Dim trgBk As Workbook, trgSh As Worksheet, trgRow As Long, trgHeight As Long
Dim srcBk As Workbook, srcSh As Worksheet, srcRow As Long, srcHeight As Long
Dim shLog As Worksheet
Dim rng As Range, row As Long, clm As Long
Dim isProtected As Boolean
Dim msg As String, tmp As String, idx As Long, sError As String

Dim fso As FileSystemObject, srcBookPath As String, isSourceOpen As Boolean
Dim eventsFlag As Boolean

    gb_dataImportActive = False
    
    ' must avoid repeated initializeModel()
    eventsFlag = Application.EnableEvents
Application.EnableEvents = False
Application.ScreenUpdating = False
    
    Set fso = New FileSystemObject

    Set trgBk = ActiveWorkbook
    Set trgSh = trgBk.ActiveSheet
    trgRow = gs_importTargetRow
    trgHeight = gs_importTargetHeight
    
    On Error Resume Next
        Set srcBk = Application.Workbooks(fso.GetFileName(gs_importSourceFullName))
        Set srcSh = srcBk.ActiveSheet
    On Error GoTo 0
    If srcBk Is Nothing Or srcSh Is Nothing Then
Application.EnableEvents = eventsFlag
Application.ScreenUpdating = True
Exit Function
    End If
    srcBk.Activate
    srcRow = Application.Selection.row
    trgBk.Activate
    
    msg = "Bitte Daten|fffd|bernahme best|fffd|tigen: "
    If (trgHeight = 1) Then
        tmp = "Gr|fffd||fffd|e = (" & trgRow & ") '" & trgSh.Cells(trgRow, cn_clm_Quantity).formula & "'"
    Else
        tmp = "Gr|fffd||fffd|en = (" & trgRow & "-" & trgRow + trgHeight - 1 & ") '" & trgSh.Cells(trgRow, cn_clm_Quantity).formula & "', ff."
    End If
    msg = msg & vbCrLf & "Ziel (linke Seite) = [" & trgBk.name & "]" & trgSh.name
    msg = msg & vbCrLf & tmp
    
    If (trgHeight = 1) Then
        tmp = "Gr|fffd||fffd|e = (" & srcRow & ") '" & srcSh.Cells(srcRow, cn_clm_Quantity).formula & "'"
    Else
        tmp = "Gr|fffd||fffd|en = (" & srcRow & "-" & srcRow + trgHeight - 1 & ") '" & srcSh.Cells(srcRow, cn_clm_Quantity).formula & "', ff."
    End If
    msg = msg & vbCrLf & "Vorlage (rechte Seite) = [" & srcBk.name & "]" & srcSh.name
    msg = msg & vbCrLf & tmp
    
    msg = msg & vbCrLf & vbCrLf & "Es werden nur leere Ziel-Felder beschrieben."
    If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel Then
'        Application.DisplayAlerts = False
'        srcBk.Close
'        Application.DisplayAlerts = True
Application.EnableEvents = eventsFlag
Application.ScreenUpdating = True
Exit Function
    End If
    
    copyData srcSh, srcRow, trgSh, trgRow, trgHeight
    
    Set rng = trgSh.Range(trgSh.Cells(trgRow, cn_clm_Quantity), trgSh.Cells(trgRow + trgHeight - 1, cn_clm_Quantity))
    unlockQuantity rng, False
    
    Application.DisplayAlerts = False
' ??? close source, restore active
    If False Then srcBk.Close
    Application.DisplayAlerts = True
'    ' maximize
'    Application.SendKeys "%{ }"
'    Application.Wait (Now + TimeValue("00:00:01"))
'    Application.SendKeys "x"
    
    ' update performance analysis, charts
    If (trgRow > gn_row_Section_III_Start And trgRow <= gn_row_G_u_V) Then
'        processMonthChange Target:=ActiveWorkbook.Worksheets(gs_MainSheetName).Cells(gn_monthRow, 3), force:=True
        performanceAnalysis
    End If
    trgBk.Activate
    trgSh.Activate
    With trgSh
        .Range(.Cells(trgRow, cn_clm_January - 1), .Cells(trgRow + trgHeight - 1, cn_clm_Year)).Select
    End With
    
    With ActiveWindow   ' target
        .width = 1.5 * .width ' to overlap source
        .ScrollColumn = 1
    End With
    
Application.EnableEvents = eventsFlag
Application.ScreenUpdating = True
Application.StatusBar = False
End Function

Sub clearData(trgSh As Worksheet, trgRow As Long, height As Long)
Dim definition As Range, cll As Range, row As Long, clm As Long
Dim isProtected As Boolean

    With trgSh
        isProtected = .ProtectContents
        .Unprotect cs_LiquiPWD
        Set definition = .Range(.Cells(trgRow, cn_clm_January), .Cells(trgRow + height - 1, cn_clm_December))
        definition.Select
        For Each cll In definition
            If (Not cll.HasFormula) Then
                cll.ClearContents
            End If
        Next
        If (isProtected) Then protectSheet trgSh
    End With
End Sub

Sub copyData(srcSh As Worksheet, srcRow As Long, trgSh As Worksheet, trgRow As Long, height As Long)
Dim definition As Range, cll As Range, cll2 As Range, row As Long, clm As Long
Dim isProtected As Boolean
Dim cmt As Comment, tmp As String

    With trgSh
        isProtected = .ProtectContents
        .Unprotect cs_LiquiPWD
        Set definition = .Range(.Cells(trgRow, cn_clm_January), .Cells(trgRow + height - 1, cn_clm_December))
        definition.Select
        For Each cll In definition
            If (IsEmpty(cll)) Then
                Set cll2 = srcSh.Cells(srcRow + (cll.row - trgRow), cll.Column)
'                cll.formula = cll2.formula
                cll2.Copy
                cll.PasteSpecial ' Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
            End If
        Next
        If (isProtected) Then protectSheet trgSh
    End With
End Sub

Function createModel(outlierMarked As Boolean, sError As String) As Workbook    ' overrideMarked As Boolean,
' Alle Daten(Eingabe)felder in 'Umsatz und Liquidit|fffd|t' / 'Konsolidierung' und in allen Profitcenters l|fffd|schen
' Optionen: Vorspann (Steuerungsparameter) |fffd|bernehmen
'           Jahresdaten als Vorjahr |fffd|bernehmen
'           Daten als Verweise |fffd|bernehmen
' sError: output
' overrideMarked: output
' outlierMarked: output

Dim actWb As Workbook, nxtWb As Workbook, mainSh As Worksheet, actSh As Worksheet, nxtSh As Worksheet
Dim rng As Range, rng2 As Range, cll As Range, row As Long, clm As Long
Dim startRow As Long, endRow As Long, liquiCheckRow As Long, endClm As Long
Dim msg As String, tmp As String, idx As Long
Dim isProtected As Boolean, eventsFlag As Boolean
Dim actYear As Long, nxtYear As Long, curYear As Long, sYear As String, repeat As Boolean

    Set createModel = Nothing
'    overrideMarked = False
    outlierMarked = False
    
    If gs_MainSheetName = "" Or gn_MainSheetIndex = 0 Or gn_row_Section_I_Start = 0 Then
        Set mainSh = validateMainSheet(sError)
        If mainSh Is Nothing Then
Exit Function
        End If
    End If
    
    Set actWb = Application.ActiveWorkbook
    Set mainSh = getSheet(gs_MainSheetName, actWb)
    mainSh.Activate
    Set cll = mainSh.Cells(gn_yearRow, 3)
    actYear = cll.value
    nxtYear = actYear + 1 ' consecutive years, only if KeepLastYear
    curYear = year(Now())
    If Not (nxtYear = curYear Or nxtYear = curYear + 1) Then
        ' out-of_date ?
        repeat = True
        Do While repeat
            repeat = False
            sYear = InputBox("Bitte Planungsjahr eingeben!", cs_MsgTitle, curYear + 1)
            If sYear = "" Then
                sError = "Abgebrochen"
Exit Function
            End If
            If Int(sYear) < 2000 Then
                MsgBox "Angabe ung|fffd|ltig.", , cs_MsgTitle
                repeat = True
            End If
        Loop
        nxtYear = Int(sYear)
    End If
    
    gb_isUserOK = False
    With frmNewModel
        .caption = "Neue Planung"
        .BorderStyle = fmBorderStyleSingle
'        .lblDescription.caption = fso.GetFileName(nxtPath) ' & "." & fso.GetExtensionName(nxtPath)
        .lblDescription.caption = "Neue Planung auf der Grundlage des vorliegenden Modells einrichten."
        
        .chkOption1.caption = "Stammdaten (Steuerelemente im Kopfteil) |fffd|bernehmen"
        .chkOption1.value = Not gb_isClearWithProlog ' last value
        .chkOption1.visible = True
        
        .chkOption2.caption = "Daten |fffd|bernehmen"
        .chkOption2.value = gb_isKeepInputData ' last value     'True
        .chkOption2.visible = True
        
        .chkOption3.caption = "Jahres-Daten als 'Vorjahr' |fffd|bernehmen"
        .chkOption3.value = gb_isKeepLastYear ' .chkOption1.value
        .chkOption3.visible = True
        .chkOption3.Enabled = True  ' .chkOption1.value
'     'do later as separate step ???
'    .chkOption3.value = False
'    .chkOption3.visible = False
        
'        .chkOption4.caption = "'Vorjahr' als Verweise"
'        .chkOption4.value = gb_previousYearByLink ' last value ?    ' False   '
'        .chkOption4.Enabled = .chkOption3.value
'        .chkOption4.visible = False
        
        .radioButton3a.caption = "Werte"
        .radioButton3b.caption = "Verweise"
        .radioButton3a.value = Not gb_previousYearByLink    ' True
        .radioButton3b.value = Not .radioButton3a.value
        .radioButton3a.Enabled = .chkOption3.value
        .radioButton3b.Enabled = .chkOption3.value
'        .radioButton3a.visible = Not .chkOption4.visible
'        .radioButton3b.visible = Not .chkOption4.visible
        .radioButton3a.visible = .chkOption3.visible
        .radioButton3b.visible = .chkOption3.visible
        
        If Not (.radioButton3a.visible Or .radioButton3b.visible) Then ' .chkOption4.visible Or
            .height = 170 ' - 48
            .btnOK.Top = 126 ' - 48
            .btnCancel.Top = 126 ' - 48
        End If
        
        .Show
        
        gb_isClearWithProlog = Not .chkOption1.value
        gb_isKeepInputData = .chkOption2.value
        gb_isKeepLastYear = .chkOption3.value
        gb_previousYearByLink = .radioButton3b.value    ' .chkOption4.value Or
        gb_isClearMasterData = True
        If Not gb_isUserOK Then
Exit Function
        End If
    End With

Dim fso As FileSystemObject, actPath As String, nxtPath As String, ext As String, pos As Long
Dim ync As VbMsgBoxResult

    Set fso = New FileSystemObject
    actPath = actWb.FullName
'Debug.Print actPath
'    ext = fso.GetExtensionName(actPath)
'    pos = InStr(1, actPath, ext)
'    nxtPath = Left(actPath, pos - 2)
'    If endsWith(nxtPath, " (" & actYear & ")") Then
'        nxtPath = Left(nxtPath, Len(nxtPath) - 7)
'    End If
'    nxtPath = nxtPath & " (" & nxtYear & ")." & ext
    nxtPath = fso.GetParentFolderName(actPath)
    nxtPath = nxtPath & "\" & "Neue Planung.xlsm"
'Debug.Print nxtPath
    
Dim fd As office.FileDialog
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        .AllowMultiSelect = False
        .title = "Neue Planung einrichten"
        .InitialFileName = nxtPath
'Debug.Print .InitialFileName, .Filters.Count, .FilterIndex
        .FilterIndex = 2    ' xlsm
        If .Show = True Then
            nxtPath = .SelectedItems(1)
        Else
            nxtPath = ""
        End If
    End With
    If nxtPath = "" Then
        sError = ""
        Set createModel = Nothing
Exit Function
    End If
    
Application.StatusBar = "Vorlage kopieren: " & fso.GetFileName(actPath) & " ~> " & fso.GetFileName(nxtPath)
DoEvents
    On Error GoTo FILE_ERROR
    fso.CopyFile actPath, nxtPath, True
    
    ' open copy: edit only
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    
    Set nxtWb = Application.Workbooks.Open(nxtPath, False)
    nxtWb.Activate
    On Error GoTo 0
    
    removeWarningColors nxtWb
    
    If (Not gb_isKeepLastYear) Then
        nxtYear = actYear
    End If
    
'Debug.Print "createModel()"
    For idx = 1 To gn_MainSheetIndex
        Set actSh = actWb.Worksheets(idx)
        Set nxtSh = nxtWb.Worksheets(idx)
'Debug.Print actWb.name, actSh.name
'Debug.Print nxtWb.name, nxtSh.name
Application.StatusBar = actSh.name & " einrichten."
DoEvents
'Debug.Print "edit: ", actSh.name
        With nxtSh
            .Unprotect ""
            Set cll = .Cells(gn_yearRow, 3)
            cll.value = nxtYear
            
            startRow = gn_row_Section_I_Start
            
            ' don't delete 'Liqui Check'
            row = startRow + 1
            liquiCheckRow = 0
            findTextOrFormula nxtSh, "Liqui Check", True, True, row, clm, , cn_dataWidth + cn_userMargin
            If row > 0 Then
                liquiCheckRow = row
            End If
            endRow = .usedRange.row + .usedRange.Rows.Count - 1
                     
            isProtected = .ProtectContents
            .Unprotect ""
            Application.Calculation = xlCalculationManual

            'clear parameters in prolog
            If gb_isClearWithProlog Then
                For row = 2 To startRow - 1
                    For clm = 3 To 4
                        .Cells(row, clm).ClearContents
                Next: Next
            End If
            .Cells(gn_monthRow, 3) = cs_NoMonth
            
            ' last year's volume
' ToDo: ? references rather than values ?
'       too clumsy: ties new model to current one
            
Dim rowVolume As Long, rowVolumeLastYear As Long
Dim rngVolume As Range, rngVolumeLastYear As Range
Dim volume(1 To 12), valuesYear()
Dim accountMonthEnd(1), rowAccountMonthEnd As Long
Dim balanceAccount(1), rowBalanceAccount As Long
            If gb_isKeepLastYear Then
                copyPreviousYear actSh, volume(), valuesYear(), accountMonthEnd(), sError      ', balanceAccount()
            Else
'                ReDim valuesYear(1 To gn_row_G_u_V + 1)
                ReDim valuesYear(1 To gn_row_Section_V_End)
            End If
            
' restore destroyed formulae; cf. addRedWarnings()
' beware: never override existing formula
' 2017-02-18
' 1. nur Warnung, keine Reparatur
' 2. Warnung nur, wenn Zelle nicht leer
'
' => don't repair, mark outliers only
'    must happen before non-formulae (input cells) are emptied
' 8.2.0.8: ???
Dim strictMode As Boolean

Dim monthR1C1 As String
Dim rowHeader As String
Const specialRows As String = "Zinseinnahmen*Zinsertr|fffd|ge"
Dim width  As Long
            width = getDataWidth(nxtSh)
            For row = startRow To endRow
                rowHeader = .Cells(row, 2)
                If isSectionHeader(rowHeader) Then
                    GoTo NEXT_ROW_RESTORE
                End If
                ' special cases:
                If rowHeader <> "" And InStr(1, specialRows, rowHeader) > 0 Then
                    GoTo NEXT_ROW_RESTORE
                End If
                ' month names
                If IsError(.Cells(row, 3)) Or IsError(.Cells(row, 4)) Then
                    GoTo NEXT_ROW_RESTORE
                End If
                If InStr(1, .Cells(row, 3), "Vorjahr") > 0 Or InStr(1, .Cells(row, 4), "Januar") > 0 Then
                    GoTo NEXT_ROW_RESTORE
                End If
                
                ' data (I. thru IV. only)
                If gn_row_Section_V_Start > 0 And row >= gn_row_Section_V_Start Then
                    GoTo NEXT_ROW_RESTORE
                ElseIf gn_row_Section_V_Start >= 0 And row > gn_row_Section_IV_End Then
                    GoTo NEXT_ROW_RESTORE
                End If

NEXT_ROW_RESTORE:
            Next

            'clear data: non-formula month fields
' 2017-02-18:   must happen after outliers are marked   ' 8.2.0.8: ???
'            endClm = 15 ' cn_dataWidth
            If Not gb_isKeepInputData Then
                For row = startRow To endRow
                    DoEvents
'                    If liquiCheckRow > 0 And row >= liquiCheckRow Then
'                        endClm = cn_dataWidth - 3
'                    End If
                    If isSectionHeader(.Cells(row, 2)) Then
                        GoTo NEXT_ROW_CLEAR ' skip section headers
                    End If
                    If IsError(.Cells(row, 3)) Or IsError(.Cells(row, 4)) Then
                        GoTo NEXT_ROW_CLEAR
                    End If
                    If startsWith(.Cells(row, 3), "Vorjahr") Or startsWith(.Cells(row, 4), "Januar") Then
                        GoTo NEXT_ROW_CLEAR
                    End If
                    
'                    For clm = cn_clm_January - 1 To cn_clm_December + 4     '8.2.0.8:  + userMargin ???
' Sanit|fffd|tshaus Lang, crash @ (219,22): cells merged
                    Set rng = .Range(.Cells(row, cn_clm_January - 1), .Cells(row, width))
                    rng.MergeCells = False
                    For clm = cn_clm_January - 1 To width
                        Set cll = .Cells(row, clm)
' 8.2.0.8: clear if no formula or if formula constant
                        If IsNumeric(cll) And (Not cll.HasFormula Or isConstantNumericFormula(cll)) Then
                            cll.ClearContents
                        End If
                    Next
NEXT_ROW_CLEAR: Next
            End If
            
            ' last years volume (empty or saved above)
'            If gb_isKeepLastYear Then
                storePreviousYear actSh, nxtSh, volume(), valuesYear(), accountMonthEnd      ', balanceAccount
'            End If
            
            ' colors: font and interior
            ' cell interior
Dim clr As Long
            .Columns(1).Interior.ColorIndex = xlColorIndexNone
            For row = 1 To IIf(gn_row_Section_V_Start > 0, gn_row_Section_V_Start, gn_row_Section_IV_End)
                Set cll = .Cells(row, cn_clm_January - 1)
                If startsWith(cll, "Vorjahr") Then
                    cll.Interior.Color = gn_color_month
                End If
                If cll.Interior.Color = gn_color_month Then
'                    .Range(cll, .Cells(row, cn_clm_December + 1)).Interior.ColorIndex = cn_clrX_month
                    For clm = cn_clm_January - 1 To cn_clm_Year
                        clr = .Cells(row, clm).Interior.Color
                        If Not (clr = gn_color_outlier) Then
                            .Cells(row, clm).Interior.Color = gn_color_month
                        End If
                    Next
                End If
                Set cll = .Cells(row, cn_clm_December)
                If startsWith(cll, "Dezember") Then
                    .Range(.Cells(row, cn_clm_January), .Cells(row, cn_clm_Year)).Interior.Color = gn_color_month
                End If
                Set cll = .Cells(row, cn_clm_December + 2)
                If startsWith(cll, "Dezember") Then
                    .Range(cll, .Cells(row, cn_clm_December + 4)).Interior.Color = gn_color_monthDark
                End If
            Next
            
' cell font
' ToDo: optional ?
'If False Then
'    Set rng = .Range(.Cells(gn_row_Section_I_Start, 3), .Cells(gn_row_MonthRangeEnd, cn_dataWidth))
'    rng.Font.ColorIndex = xlColorIndexAutomatic
'End If

'            markOutliersInRows nxtSh, overrideMarked, outlierMarked
'            markOutliersInYearColumn nxtSh, overrideMarked, outlierMarked
' drop: use LiquiMenu
'            markOutliers nxtSh.usedRange, outlierMarked
            
            protectSheet nxtSh ' unconditionally
            
'            ' master sheet: overwrite with updated input sheet
'Dim nMonth As Long
'            nMonth = 0
'            CopyDataToMaster nxtSh, nMonth, sError, False
        End With    'nxtSh / idx
    Next idx
    
    ' master sheets: overwrite with updated input sheets (main and all PCs)
Dim nMonth As Long
    Set nxtSh = nxtWb.Worksheets(gn_MainSheetIndex)
    nMonth = 0
    copyDataToMaster nxtSh, nMonth, sError, False
    
    Set createModel = nxtWb
    Application.EnableEvents = eventsFlag
    Application.StatusBar = False
DoEvents
Exit Function

FILE_ERROR:
    sError = Err.Description
    Err.Clear
    Set createModel = Nothing
Exit Function
    
End Function

Sub hideMasterSheets(wb As Workbook)
Dim sh As Worksheet, shx As Long
    For shx = 1 To wb.Worksheets.Count
        Set sh = ActiveWorkbook.Worksheets(shx)
        If sh.name = cs_MasterSheetName Or startsWith(sh.name, cs_MasterPrefix) Then
            sh.visible = xlSheetHidden
        End If
    Next
End Sub

Function getDataWidth(mSh As Worksheet) As Long
Dim width As Long
    width = WorksheetFunction.Min(mSh.usedRange.Columns.Count, cn_dataWidth + cn_userMargin)
    width = WorksheetFunction.Max(width, gn_clm_LiquiCheck + 5)
    getDataWidth = width
End Function

Sub updatePreviousYear(actWb As Workbook)
Dim fso As FileSystemObject
Dim actSh As Worksheet, prvWb As Workbook, prvSh As Worksheet, prvPath As String, prvPathOld As String
Dim sh As Worksheet, cll As Range, row As Long, clm As Long, i As Long
Dim actYear As Long, prvYear As Long
Dim previousYearOpen As Boolean

Dim rngVolumeLastYear As Range, volume(1 To 12), rowVolumeLastYear As Long
Dim valuesYear(), accountMonthEnd(1), rowAccountMonthEnd As Long
'Dim balanceAccount(1), rowBalanceAccount As Long
Dim msg As String, sError As String, alerts As Boolean

    Set actSh = getSheet(gs_MainSheetName, actWb)
    actSh.Activate
    
    ' do links exist already ?
    With actSh
        ' row volume per month
        row = gn_row_Section_I_Start: clm = 2
        findTextOrFormula actSh, "Umsatz Vorjahr", True, True, row, clm, , 2
        If row > 0 Then rowVolumeLastYear = row
        If rowVolumeLastYear > 0 Then
            Set rngVolumeLastYear = .Range(.Cells(rowVolumeLastYear, cn_clm_January), .Cells(rowVolumeLastYear, cn_clm_December))
            For clm = 1 To 12
                Set cll = rngVolumeLastYear.Cells(1, clm)
                If (cll.HasFormula) Then
                    prvPathOld = cll.formula
                    Exit For
                End If
            Next
        End If
        i = InStr(1, prvPathOld, "!")
        If (i > 1) Then
            msg = "Es existieren bereits Verkn|fffd|pfungen zum Vorjahr."
            msg = msg + vbLf + Left(prvPathOld, i - 1)
            msg = msg + vbLf + vbLf + "Fortfahren ?"
            If (MsgBox(msg, vbOKCancel) = vbCancel) Then
                Exit Sub
            Else
                gb_previousYearByLink = True ' ~> dialog, as is
            End If
        Else
            gb_previousYearByLink = False ' ~> dialog, as is
        End If
    End With

    Set fso = New FileSystemObject
'    prvPath = Application.GetOpenFilename( _
'                    "Excel-Arbeitsmappe (*.xls*), *.xls*", 1, _
'                    "Arbeitsmappe mit vorhergehender Planung w|fffd|hlen ...", MultiSelect:=False)  '|*.xlsx|*.xlsm
    prvPath = pickFile("Bitte ein Vorjahres-Modell w|fffd|hlen.", actWb.path & "\")
    If (Not fso.FileExists(prvPath)) Then
Exit Sub ' canceled
    End If
    Set prvWb = Nothing
    alerts = False
    ' previous year (source) already open
    previousYearOpen = True
    On Error Resume Next
        Set prvWb = Application.Workbooks(fso.GetFileName(prvPath))
    On Error GoTo 0
    If (prvWb Is Nothing) Then
        previousYearOpen = False
    ElseIf (prvWb.FullName <> prvPath) Then
        prvWb.Close
        Set prvWb = Nothing
        previousYearOpen = False
    End If
    If (Not previousYearOpen) Then
        On Error Resume Next
        Set prvWb = Application.Workbooks.Open(prvPath, False)
        On Error GoTo 0
'    If (prvWb Is Nothing) Then
'        'already open ?
'        Set prvWb = Application.Workbooks(fso.GetFileName(prvPath))
'        alerts = True
''        For i = 1 To Application.Workbooks.Count
''            If (Application.Workbooks(i).name = fso.GetFileName(prvPath)) Then
''                Set prvWb = Application.Workbooks(i)
''                Exit For
''            End If
''        Next
'    End If
        If (prvWb Is Nothing) Then
            msg = "Kann " + fso.GetFileName(prvPath) + " nicht |fffd|ffnen."
            MsgBox msg, vbExclamation
Exit Sub
        End If
    End If

    actWb.Activate
    actSh.Activate
    Set cll = actSh.Cells(gn_yearRow, 3)
    actYear = cll.value
    
    Set prvSh = getSheet(gs_MainSheetName, prvWb)
    Set cll = prvSh.Cells(gn_yearRow, 3)
    prvYear = cll.value
    If (prvYear <> actYear - 1) Then
        ' inconsistent
        msg = "Quelle ist kein Vorjahresmodell. Fortfahren ?"
        If (MsgBox(msg, vbOKCancel) = vbCancel) Then
            GoTo EXIT_SUB
        End If
    End If
    
    gb_isUserOK = False
    With frmPreviousYear
        .caption = "Vorjahresdaten aktualisieren"
        .BorderStyle = fmBorderStyleSingle
        .lblPreviousYear = "Vorjahresdaten einf|fffd|gen als"
        .btnValue.caption = "Wert"
        .btnValue.value = Not gb_previousYearByLink
        .btnValue.visible = True
        .btnLink.caption = "Verkn|fffd|pfung"
        .btnLink.value = gb_previousYearByLink
        .btnLink.visible = True
        .Show
        
        If gb_isUserOK Then
            gb_previousYearByLink = .btnLink.value
'            setOption cs_keyPreviousYear, IIf(gb_previousYearByLink, 1, 0)
        Else
            GoTo EXIT_SUB
        End If
    End With
    
Dim idx As Long
Dim actOpd As Worksheet
    For idx = 1 To gn_MainSheetIndex
        Set actSh = actWb.Worksheets(idx)
        Set prvSh = prvWb.Worksheets(idx)
        Set actOpd = findOrCreateWorksheet(getMasterSheetName(actSh.name), actWb)
'Debug.Print actWb.name, actSh.name, actOpd.name
'Debug.Print prvWb.name, prvSh.name
Application.StatusBar = "Verbindungen zum Vorjahr: " & actSh.name
DoEvents
Debug.Print "updatePreviousYear()", actSh.name
        sError = ""
        copyPreviousYear prvSh, volume(), valuesYear(), accountMonthEnd(), sError
        If (Not sError = "") Then
            ' inconsistent
            MsgBox sError, vbCritical
            GoTo EXIT_SUB
        End If
        
        ' update links/values in both input and master sheet
        sError = ""
        storePreviousYear prvSh, actSh, volume(), valuesYear(), accountMonthEnd()
        storePreviousYear prvSh, actOpd, volume(), valuesYear(), accountMonthEnd()
    Next
    
    Application.StatusBar = False
DoEvents
EXIT_SUB:
'   prvWb.Save
    Application.DisplayAlerts = False
    If (Not previousYearOpen) Then
        prvWb.Close
    End If
    
    ' remove obsolete link; requires sheets unprotected
'Debug.Print prvPathOld
    prvPathOld = Replace(prvPathOld, "[", "")
    prvPathOld = Replace(prvPathOld, "]", "")
'Debug.Print prvPathOld
'Debug.Print prvPath
    For Each sh In actWb.Worksheets
        If (isLiquiplanSheet(sh)) Then sh.Unprotect cs_LiquiPWD
    Next
    If (prvPathOld <> "" And (Not gb_previousYearByLink Or InStr(prvPathOld, prvPath) <= 0)) Then
        breakExternalLink prvPathOld
    End If
    If gb_previousYearByLink Then
        actWb.UpdateLinks = xlUpdateLinksAlways
    End If
    restoreModelProtection  ' prompt:=False
    Application.DisplayAlerts = alerts
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
End Sub

Function pickFile(title As String, initialFile As String) As String
Dim fd As office.FileDialog ', fso As FileSystemObject
Dim txtFileName As String, tmpFileName As String

    pickFile = ""
'    Set fso = New FileSystemObject
    Set fd = Application.FileDialog(msoFileDialogOpen)
    With fd
        .AllowMultiSelect = False
    
        ' Set the title of the dialog box.
        .title = title
'Debug.Print initialFile
        .InitialFileName = initialFile
'        .InitialFileName = "[C:\Users\Hartmann\Projekte\LiquiPlan\Dev 8.2\8.2.0.7\Basis\ACME 2019 (8.2.0.7 +o)+4 (2020)].xlsm"
'        .InitialFileName = fso.GetFileName(initialFile)
        
        ' Clear out the current filters, and add our own.
        .Filters.Clear
        .Filters.Add "Liquiplan Modell", "*.xlsm"
        .Filters.Add "All Files", "*.*"
    
        ' Show the dialog box. If the .Show method returns True, the
        ' user picked at least one file. If the .Show method returns
        ' False, the user clicked Cancel.
        If .Show = True Then
            pickFile = .SelectedItems(1)
        End If
    End With
End Function

Private Sub breakExternalLink(formula As String)
'https://stackoverflow.com/questions/17165280/how-do-i-remove-links-from-a-workbook-linked-to-another
'PURPOSE: Breaks all external links that would show up in Excel's "Edit Links" Dialog Box
'SOURCE: www.TheSpreadsheetGuru.com/The-Code-Vault

Dim ExternalLinksArray As Variant
Dim wb As Workbook
Dim strLink As String, lnkStatus As Long
Dim x As Long

    'Create an Array of all External Links stored in Workbook
    Set wb = ActiveWorkbook
    ExternalLinksArray = wb.LinkSources(Type:=xlLinkTypeExcelLinks)

    If IsEmpty(ExternalLinksArray) = False Then
        For x = 1 To UBound(ExternalLinksArray)
            strLink = CStr(ExternalLinksArray(x))
            lnkStatus = wb.LinkInfo(strLink, xlLinkInfoStatus)
Debug.Print strLink, GetLinkStatus(wb, strLink)
            If (InStr(formula, strLink) > 0 And (lnkStatus = xlLinkStatusOK Or lnkStatus = xlLinkStatusMissingFile)) Then
                wb.BreakLink name:=ExternalLinksArray(x), Type:=xlLinkTypeExcelLinks
            End If
        Next x
    End If
End Sub



Private Function copyPreviousYear(srcSh As Worksheet, volume(), valuesYear(), accountMonthEnd(), sError As String) As Boolean
Dim srcWb As Workbook, cll As Range
Dim rowSectionI As Long, rowSectionV As Long
Dim rngVolume As Range, rngVolumeLastYear As Range
Dim rowVolume As Long, rowVolumeLastYear As Long
Dim row As Long, clm As Long, tmp As String
    
    Set srcWb = srcSh.parent
'Debug.Print srcWb.name
    With srcSh
        ' sections, some mild consistency check
        sError = ""
        row = 1: clm = 2
        tmp = "I. "
        findTextOrFormula srcSh, tmp, True, True, row, clm, , 2
        rowSectionI = row
        
        row = row + 1: clm = 2
        tmp = "Kennzahlen"
        findTextOrFormula srcSh, tmp, True, True, row, clm, , 2
        rowSectionV = row
        If (rowSectionI <> gn_row_Section_I_Start Or rowSectionV <> gn_row_Section_V_Start) Then
            sError = "Bereiche I bis V sind verschieden lang. Vorgang wird abgebrochen."
            copyPreviousYear = False
Exit Function
        End If
    
        ' volume per month
        row = rowSectionI: clm = 2
        findTextOrFormula srcSh, "Umsatz Vorjahr", True, True, row, clm, , 2
        If row > 0 Then rowVolumeLastYear = row
        findTextOrFormula srcSh, "Gesamtumsatz", True, True, row, clm, , 2
        If row > 0 Then rowVolume = row
        If rowVolume > 0 And rowVolumeLastYear > 0 Then
            Set rngVolume = .Range(.Cells(rowVolume, cn_clm_January), .Cells(rowVolume, cn_clm_December))
            For clm = 1 To 12
                volume(clm) = getValueOrLink(rngVolume.Cells(1, clm))
            Next
        End If
        
        ' volume per year (w/o 'Umsatz Vorjahr')
Dim lastRow As Long
        lastRow = gn_row_Section_V_End  ' ignore any stuff below KPI section
' experimental: custom section
        If gn_row_Section_Custom_Start > 0 Then
            If .Cells(gn_row_Section_Custom_Start, cn_clm_January - 1) = "Vorjahr" _
            And .Cells(gn_row_Section_Custom_Start, cn_clm_Year) = "Jahr" Then
                lastRow = gn_row_Section_Custom_End
            End If
        End If
        If lastRow = 0 Then lastRow = gn_row_Section_IV_End
        ReDim valuesYear(1 To lastRow)
        For row = rowSectionI + 3 To lastRow
            If IsEmpty(.Cells(row, 2)) Then GoTo NEXT_ROW_YEAR
            If isSectionHeader(.Cells(row, 2)) Then GoTo NEXT_ROW_YEAR
'            If row = gn_row_Section_Custom_Start Then GoTo NEXT_ROW_YEAR    ' section header
            Set cll = .Cells(row, 3)
            If cll.value = "Vorjahr" Then GoTo NEXT_ROW_YEAR
            'only if proper annual sum
            If (Not .Cells(row, cn_clm_Year).HasFormula) Then GoTo NEXT_ROW_YEAR
            If (Not cll.HasFormula Or InStr(1, cll.formula, srcSh.name) > 0) Then
                ' value or link
                valuesYear(row) = getValueOrLink(.Cells(row, cn_clm_Year))
            End If
NEXT_ROW_YEAR:
        Next

        ' account, end of year
Dim rowAccountMonthEnd As Long
        row = gn_row_Section_IV_Start: clm = 2
        findTextOrFormula srcSh, "Kto-Stand Monatsende", True, True, row, clm, , 2
        If row > 0 Then
            rowAccountMonthEnd = row
                accountMonthEnd(1) = getValueOrLink(.Cells(rowAccountMonthEnd, cn_clm_December))
        End If
    End With
End Function

Private Sub storePreviousYear(prvSh As Worksheet, nxtSh As Worksheet, volume(), valuesYear(), accountMonthEnd())    ' , balanceAccount()
Dim rowVolume As Long, rowVolumeLastYear As Long
Dim rngVolume As Range, rngVolumeLastYear As Range
Dim rowAccountMonthEnd As Long, rowBalanceAccount As Long
Dim cll As Range, row As Long, clm As Long, tmp As String
Dim isProtected As Boolean

'Debug.Print "Active: ", nxtSh.name, nxtSh.parent.name
'Debug.Print "Previous: ", prvSh.name, prvSh.parent.name

Const compareStrict As Boolean = False

    isProtected = nxtSh.ProtectContents
    nxtSh.Unprotect cs_LiquiPWD
    With nxtSh
        ' volume per month
        row = gn_row_Section_I_Start: clm = 2
        findTextOrFormula nxtSh, "Umsatz Vorjahr", True, True, row, clm, , 2
        If row > 0 Then rowVolumeLastYear = row
        findTextOrFormula nxtSh, "Gesamtumsatz", True, True, row, clm, , 2
        If row > 0 Then rowVolume = row
        If rowVolume > 0 And rowVolumeLastYear > 0 Then
            Set rngVolumeLastYear = .Range(.Cells(rowVolumeLastYear, cn_clm_January), _
                            .Cells(rowVolumeLastYear, cn_clm_December))
            If Not gb_isKeepLastYear Or gb_previousYearByLink Then
                rngVolumeLastYear.formula = volume
            Else
                rngVolumeLastYear.value = volume
            End If
        End If
    
        ' column 'Vorjahr'
        ' compare names
Dim prvHdr As String, actHdr As String, sError As String
        For row = gn_row_Section_I_Start + 1 To UBound(valuesYear)  ' lastRow
'If row = gn_row_Section_Custom_Start Then Stop
            prvHdr = prvSh.Cells(row, 2)
            actHdr = nxtSh.Cells(row, 2)
            If (prvHdr <> actHdr And (compareStrict Or (prvHdr <> "" And actHdr <> ""))) Then
                If (sError = "") Then
                    sError = "Bereiche inkonsistent: " + prvHdr + " <> " + actHdr
                    nxtSh.Activate
                    nxtSh.Cells(row, 2).Select
                ElseIf (Right(sError, 5) <> ", ...") Then
                    sError = sError + ", ..."
                End If
                .Cells(row, cn_clm_January - 1).formula = ""
                .Cells(row, cn_clm_January - 1).Interior.Color = gn_color_outlier
            Else
                If isSectionHeader(prvHdr) Then     ' Or row = gn_row_Section_Custom_Start
                    GoTo NEXT_ROW
                End If
                Set cll = .Cells(row, cn_clm_January - 1)
                If Not IsEmpty(valuesYear(row)) Then
                    If gb_previousYearByLink Then
                        cll.formula = valuesYear(row)
                    Else
                        cll.value = valuesYear(row)
                    End If
                ElseIf (Not cll.HasFormula Or (cll.HasFormula And InStr(1, cll.formula, "!") > 0)) Then
                    cll.ClearContents
                End If
            End If
NEXT_ROW:
        Next
        
        ' account, liquidity section, end of year
        row = gn_row_Section_IV_Start: clm = 2
        findTextOrFormula nxtSh, "Kto-Stand Monatsende", True, True, row, clm, , 2
        If row > 0 Then
            Set cll = .Cells(row, cn_clm_January - 1)
            If Not IsEmpty(accountMonthEnd(1)) Then
                If gb_previousYearByLink Then
                    cll.formula = accountMonthEnd(1)
                Else
                    cll.value = accountMonthEnd(1)
                End If
            ElseIf (Not cll.HasFormula Or (cll.HasFormula And InStr(1, cll.formula, "!") > 0)) Then
                cll.ClearContents
            End If
        End If
    End With
    If isProtected Then protectSheet nxtSh
    If (sError <> "") Then MsgBox sError, vbInformation
End Sub

Private Function getValueOrLink(srcCl As Range)
'   "='[BasisPlus(8.2.0.5).xlsm]Umsatz und Liquidit|fffd|t'!D39"
Dim srcWb As Workbook, srcSh As Worksheet
Dim nameWb As String, nameSh As String, nameCell As String, link As String
    
    If Not gb_previousYearByLink Then
        getValueOrLink = srcCl.value
    Else
        Set srcSh = srcCl.parent
        Set srcWb = srcSh.parent
        nameWb = srcWb.name
        nameSh = srcSh.name
        nameCell = Replace(srcCl.Address, "$", "")
        link = "='[" + nameWb + "]" + nameSh + "'!" + nameCell
        getValueOrLink = link
    End If
End Function


' ===== Friedhof =====

Attribute VB_Name = "LibInteraction"
Option Explicit

Sub handleSheetActivate(ByVal Target As Object)
Dim abk As Workbook
Dim sheetsRenamed As String, sheetsAdded As String, sheetsDeleted As String, sheetsMoved As String
Dim pcs As String, name As String, tmp As String

    Application.EnableEvents = False
    Set abk = Application.ActiveWorkbook
    
'8.2.0.8: watch MainOrPc group of tables
Dim mpcSh As Variant, idx As Long, shx As Long, sError As String
    If gn_MainSheetIndex = 0 Or gs_MainSheetName = "" Then
        validateMainSheet sError
    End If
    If Not gb_modelWatchDisabled Then
        With abk.Sheets
            idx = 1
            Do While idx <= gn_MainSheetIndex
                Set mpcSh = .item(idx)
                If isMainOrPC(mpcSh, shx) Then
                    idx = idx + 1
                Else
                    ' bad pc moved to the right of main sheet
                End If
            Loop
        End With
    End If
        
    name = Target.name
    If name <> cs_MasterSheetName Then
        gb_allowChangeMaster = False
    End If
    
    ' sheets watch
    If go_SheetsWarden Is Nothing Then
        Set go_SheetsWarden = New SheetsWatch
        go_SheetsWarden.setWorkbook abk
    ElseIf go_SheetsWarden.getWorkbook().name <> abk.name Then
        Set go_SheetsWarden = New SheetsWatch
        go_SheetsWarden.setWorkbook abk
    End If
    If gb_SheetListChangeDisabled Then
        go_SheetsWarden.updateLists
        Application.EnableEvents = True
Exit Sub
    End If
    
    sheetsRenamed = go_SheetsWarden.getRenamedSheets()
    sheetsMoved = go_SheetsWarden.getMovedSheets()
    sheetsAdded = go_SheetsWarden.getAddedSheets()
    sheetsDeleted = go_SheetsWarden.getDeletedSheets()
    If (sheetsRenamed <> "" Or sheetsMoved <> "" Or sheetsAdded <> "" Or sheetsDeleted <> "") Then
        processSheetListChanged sheetsRenamed, sheetsMoved, sheetsAdded, sheetsDeleted
    End If
    go_SheetsWarden.updateLists
    
    ' ????
Dim trgSh As Worksheet
    If (TypeOf Target Is Worksheet) Then
        Set trgSh = getSheet(name)
        trgSh.Activate
        If (TypeOf ActiveWindow.Selection Is Range) Then
            handleSheetSelectionChange ActiveWindow.Selection
        End If
        
        storeColorMap trgSh
    End If
    
    Application.EnableEvents = True
End Sub

Sub handleWindowDeactivate(Wn As Window)
'Dim sheetsRenamed As String, sheetsAdded As String, sheetsDeleted As String, sheetsMoved As String
' issue: Application 'in transition'
' window is still the old book (warden's currentBook), active workbook is already the new one
'Debug.Print "transition", Wn.ActiveSheet.Parent.name, Application.ActiveWorkbook.name
Exit Sub

End Sub

Sub handleWorkSheetChange(ByVal Target As Range)
Dim monthName As String, month As Long, lastMonthName As String, lastMonth As Long
Dim awb As Workbook, wsh As Worksheet, rg As Range, dataRow As Long, row As Long, clm As Long, idx As Long
Dim msg As String, sError As String, eventsFlag As Boolean
Dim name As String, newVal As String, oldVal As String
Dim oldSize As Long, newSize As Long, mode As Long

If gb_modelProtectionSuspended Then
Exit Sub
End If
    
    Set wsh = Target.parent
    Set awb = wsh.parent
    name = wsh.name
    row = Target.row
    clm = Target.Column
'Debug.Print "handleWorkSheetChange", name, Target.Rows.Count, Target.Columns.Count, newVal

'8.2
    ' ignore user sheets (scratch pads, etc.)
    If Not isLiquiplanSheet(wsh) Then
Exit Sub
    End If
    
    eventsFlag = Application.EnableEvents
Application.EnableEvents = False

'    If name = cs_MasterSheetName Then
    If isMasterSheetName(name) Then
        If (Not wsh.ProtectContents) Then
Application.EnableEvents = eventsFlag
Exit Sub
        ElseIf Not gb_allowChangeMaster Then
        ' warning
            msg = "Bitte '" & name & "' aus Konsistenzgr|fffd|nden nicht direkt, sondern " & _
                vbLf & "auf Blatt '" & getMainSheetName(awb) & "' |fffd|ndern."
            msg = msg & vbLf & vbLf & "|fffd|nderungen r|fffd|ckg|fffd|ngig machen ?"
            If MsgBox(msg, vbYesNo, cs_ProjectName) = vbYes Then
                On Error Resume Next
                    Application.Undo
                On Error GoTo 0
Application.EnableEvents = eventsFlag
Exit Sub
            Else
                gb_allowChangeMaster = True
            End If
        End If
    End If
    

    If gn_monthRow = 0 Or gn_yearRow = 0 Or gn_row_Section_I_Start = 0 Or gn_row_Section_IV_End = 0 Then
        If validateMainSheet(sError) Is Nothing Then
            MsgBox sError, vbCritical, cs_MsgTitle
Application.EnableEvents = eventsFlag
Exit Sub
        End If
    End If
    
    Application.ScreenUpdating = False
    
    If row = gn_monthRow And clm = 3 Then
'MsgBox "Berichtsmonat wechselt."
        processMonthChange ByVal ActiveWorkbook.Worksheets(name).Cells(row, clm)  'Target
    
    ElseIf row = gn_yearRow And clm = 4 Then
'MsgBox "Beginn des Wirtschaftsjahrs wechselt."
        processFiscalYearChange Target
    
' canceled, unfinished
'    ElseIf gb_ConsistenRenaming And row >= gn_row_Section_I_Start And row <= gn_row_Section_IV_End Then
'        alphaConversion Target

    ElseIf ((name = cs_CompareSheetName Or startsWith(name, cs_CompareSheetName & "(")) And clm = cn_clm_PlotCheck) Then
Application.EnableEvents = False
        performanceAnalysis checked:=Target, rebuild:=False
        protectSheet wsh, lockCells:=True, isLocked:=True    ' should be redundant
        
'8.2 all formulae in some input table
    ElseIf Not gb_modelWatchDisabled Then   'And row >= gn_row_Section_I_Start And row <= gn_row_Section_IV_End
'        If clm = 2 Then
'            processQuantityChanged Target
'        ElseIf clm > 2 Then
'            warnProtectedCellChanged Target
'        Else
'        End If
        warnProtectedCellChanged Target
    
    Else
        'other cells
    End If
    
    Application.ScreenUpdating = True
    Application.EnableEvents = eventsFlag
End Sub

Sub handleRightClick(ByVal Target As Range, Cancel As Boolean)
Dim context As String

    deleteFromContextMenu "Cell"
    deleteFromContextMenu "Row"
    deleteFromContextMenu "Column"

    context = ""
    If (Target.Columns.Count = Target.parent.Columns.Count And Target.Rows.Count = Target.parent.Rows.Count) Then
        context = "Cells"
    ElseIf (Target.Columns.Count = Target.parent.Columns.Count) Then
        context = "Row"
    ElseIf (Target.Rows.Count = Target.parent.Rows.Count) Then
        context = "Column"
    Else
        context = "Cell"
    End If
    
    If gs_CodeVariant = "" Then getCodeVariant
    If (gs_CodeVariant = "Variant_B" And (context = "Cell" Or context = "Row")) Then
        addToLiquiContextMenu context
    ElseIf (gs_CodeVariant = "Variant_A" And Target.Columns.Count = 1 And Target.Rows.Count = 1) Then
Dim cll As Range, clr As Long
        Set cll = Target.Cells(1, 1)
        clr = cll.Interior.Color
        If clr = gn_color_outlier Then
            If MsgBox("Warnfarbe entfernen?", vbOKCancel, cs_MsgTitle) = vbOK Then
                cll.Interior.Color = ga_colorMap(cll.row, cll.Column)
                Cancel = True
            End If
        End If
    End If
End Sub

Sub processMonthChange(ByVal Target As Range, Optional force As Boolean = False)
'MsgBox "Berichtsmonat wechselt."
' 1. alle Soll/Ist-Vergleiche: Tabelle, Plotdaten, Plots (einzelner Monat, akkumuliert)
' 2. separate Grafiken (Standard, Benutzer - einzelne Gr|fffd||fffd|e, mehrere Gr|fffd||fffd|en)
Dim targetBook As Workbook, mainSheet As Worksheet, srcSheet As Worksheet, plotSheet As Worksheet, dtaSheet As Worksheet
Dim rng As Range, dataRow As Long, row As Long, clm As Long
Dim srcName As String, trgRow As Long, trgClm As Long
Dim monthCell As Range, monthName As String, month As Long, lastMonthName As String, lastMonth As Long
Dim msg As String, sError As String, eventsFlag As Boolean, idx As Long

    If (Not isMainOrPC(Target.parent, idx)) Then
        ' parent is master sheet
        msg = "Bitte |fffd|nderung des Berichtsmonats auf Blatt '" & gs_MainSheetName & "' vornehmen."
        MsgBox msg, vbInformation, cs_MsgTitle
        On Error Resume Next
            Application.Undo
        On Error GoTo 0
Exit Sub
    End If
        
    Set mainSheet = getSheet(gs_MainSheetName)
    Set dtaSheet = getSheet(cs_GraphicsData)
    If (dtaSheet Is Nothing) Then
        Set dtaSheet = makeNewSheet(Application.ActiveWorkbook, cs_GraphicsData)
        For month = 1 To 12
            dtaSheet.Cells(1, 2 + month) = Left(numberToMonth(month), 3)
        Next
        monthName = mainSheet.Cells(gn_monthRow, 3)
        month = monthToNumber(monthName)
        dtaSheet.Cells(3, 1) = "[Berichtsmonat]"
        dtaSheet.Cells(4, 1) = month
        dtaSheet.Cells(4, 2) = monthName
        gs_currentMonthName = monthName
    End If
    If dtaSheet Is Nothing Then
        On Error Resume Next
            Application.Undo
        On Error GoTo 0
        sError = "Blatt '" & cs_GraphicsData & "' nicht gefunden."
        MsgBox sError, vbExclamation, cs_MsgTitle
Exit Sub
    ElseIf (Not unprotectSheet(dtaSheet, True)) Then
        On Error Resume Next
            Application.Undo
        On Error GoTo 0
        dtaSheet.visible = xlSheetVisible
Exit Sub
    End If

    Set plotSheet = getSheet(cs_PlotData)
    If plotSheet Is Nothing Then
        On Error Resume Next
            Application.Undo
        On Error GoTo 0
        sError = "Blatt '" & cs_PlotData & "' nicht gefunden."
        MsgBox sError, vbExclamation, cs_MsgTitle
Exit Sub
    ElseIf (Not unprotectSheet(plotSheet, True)) Then
        On Error Resume Next
            Application.Undo
        On Error GoTo 0
Exit Sub
    End If
    
Dim wsh As Worksheet, cmpSh As Worksheet, shx As Long
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    
    ' first validate structure of main source sheet
    Set targetBook = Target.parent.parent
    targetBook.Activate
    Set mainSheet = validateMainSheet(sError)
    If mainSheet Is Nothing Then
        MsgBox sError, vbCritical, cs_MsgTitle
        Target.Cells(1, 1) = gs_currentMonthName
Application.ScreenUpdating = True
Application.DisplayAlerts = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = eventsFlag
Exit Sub
    End If
    
    monthName = Target.Cells(1, 1)
    Set srcSheet = Target.parent
    srcName = srcSheet.name
    trgRow = Target.row
    trgClm = Target.Column
    monthName = Target.Cells(1, 1)
    month = monthToNumber(monthName)
    
    ' remove 'orphaned' sections of graphics data (if not caught by SheetsWatch)
    processSheetsDeleted ""
    
    dataRow = 1
    clm = 1
    findTextOrFormula dtaSheet, "[Berichtsmonat]", True, True, dataRow, clm, , 1
    lastMonth = dtaSheet.Cells(dataRow + 1, 1)
    lastMonthName = dtaSheet.Cells(dataRow + 1, 2)
    If (lastMonthName = cs_NoMonth And numberOfMonth(monthName) > 0 And Not force) Then
        If MsgBox("Plandaten Speichern?", vbYesNo, cs_MsgTitle) = vbYes Then
            Target.Cells(1, 1) = gs_currentMonthName
            If (Not storeMasterData(checkMonth:=False)) Then
Application.ScreenUpdating = True
Application.DisplayAlerts = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = eventsFlag
Exit Sub
            End If
            Target.Cells(1, 1) = monthName
        End If
    End If
    
    For shx = 1 To gn_MainSheetIndex
        Set wsh = ActiveWorkbook.Worksheets(shx)
        Set cmpSh = getSheet(getCompareSheetName(wsh.name))
        If (Not cmpSh Is Nothing) Then
            If (cmpSh.visible = xlSheetVisible) Then
                If (Not unprotectSheet(cmpSh, True)) Then
Application.ScreenUpdating = True
Application.DisplayAlerts = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = eventsFlag
Exit Sub
                End If
            End If
        End If
    Next
    
    '|fffd|nderung in U&L/Kons. und allen PC
    For idx = 1 To gn_MainSheetIndex
        Set srcSheet = ActiveWorkbook.Worksheets(idx)
        Set cmpSh = getSheet(getCompareSheetName(srcSheet.name))
Application.StatusBar = "Soll/Ist-Vergleich: " & srcSheet.name
DoEvents
        Set monthCell = srcSheet.Cells(trgRow, trgClm)
        monthCell.value = monthName
            
        lockUnlockMonth monthCell
        updateReports monthCell, lastMonthName   'rebuildTableAndPlots(..) only if cmpSh.visible = xlSheetVisible
        updateMonth monthCell
    Next
    
    ' restore protection
    For shx = 1 To gn_MainSheetIndex
        Set wsh = ActiveWorkbook.Worksheets(shx)
        Set cmpSh = getSheet(getCompareSheetName(wsh.name))
        If (Not cmpSh Is Nothing) Then
            If (cmpSh.visible = xlSheetVisible) Then
                protectSheet cmpSh
            End If
            If (Not wsh.ProtectContents) Then
                protectSheet wsh
            End If
        End If
    Next
    protectSheet dtaSheet
    protectSheet plotSheet
Application.StatusBar = False
DoEvents
    gs_currentMonthName = monthName
    ActiveWorkbook.Worksheets(srcName).Activate
    
Application.ScreenUpdating = True
Application.DisplayAlerts = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = eventsFlag
End Sub

Sub processFiscalYearChange(ByVal Target As Range)
'MsgBox "Beginn des Wirtschaftsjahrs wechselt: " & Target.Cells(1, 1).value

Dim wsh As Worksheet
Dim idx As Long, row  As Long, clm As Long
Dim fiscalMonth As String, m As Long
Dim isProtected As Boolean, eventsFlag As Boolean

' profit centers
    ' for all source sheets
    ' ...
    
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    
    Set wsh = Target.parent
    If wsh.name <> gs_MainSheetName Then
        If Target.Cells(1, 1) <> wsh.Cells(1, 4) Then
            MsgBox "Beginn des Wirtschaftsjahrs kann nur im Blatt '" & gs_MainSheetName & "' ge|fffd|ndert werden.", vbInformation
            'undo change
            Target.Cells(1, 1) = wsh.Cells(1, 4)
        End If
Exit Sub
    End If
    If wsh.Cells(gn_monthRow, 3) = "" Then wsh.Cells(gn_monthRow, 3) = cs_NoMonth   'may be empty after clear data
    If wsh.Cells(gn_monthRow, 3) <> cs_NoMonth Then
        If Target.Cells(1, 1) <> wsh.Cells(1, 4) Then
            MsgBox "Beginn des Wirtschaftsjahrs kann nur w|fffd|hrend der Planung ge|fffd|ndert werden.", vbInformation
            'undo change
            Target.Cells(1, 1) = wsh.Cells(1, 4)
        End If
Exit Sub
    End If
    
    fiscalMonth = Target.Cells(1, 1)
    For idx = 1 To gn_MainSheetIndex
        Set wsh = ActiveWorkbook.Worksheets(idx)
        isProtected = wsh.ProtectContents
        wsh.Unprotect Password:=cs_LiquiPWD
        
        wsh.Cells(gn_yearRow, 4) = fiscalMonth
        ' alle Zeilen mit Monaten als Spalten-Titeln
        row = 1: clm = 3
        Do While row > 0
'Debug.Print "row: " & row, "clm: " & clm
            For m = 1 To 12
                wsh.Cells(row, 3 + m) = numberToMonth(m)
            Next
            If Not IsEmpty(wsh.Cells(row, 19)) Then
                wsh.Cells(row, 17) = numberToMonth(12)
                wsh.Cells(row, 18) = numberToMonth(11)
                wsh.Cells(row, 19) = numberToMonth(10)
            End If
            
            row = row + 1: clm = 3
            If row = 2 Then
                clm = 2
                findTextOrFormula wsh, "I. ", True, True, row, clm, , 3 ' "Vorjahr"
            Else
                findTextOrFormula wsh, "Vorjahr", True, True, row, clm, , 3
            End If
        Loop
    
' months: cell validation
'https://support.microsoft.com/en-us/kb/299490
'When you create a macro to specify a specific list of valid entries, always use a comma (,) as your list separator.
    Dim monthList As String
        monthList = cs_NoMonth
        For m = 1 To 12
            monthList = monthList & "," & numberToMonth(m) ' looks at first month of fiscal year
        Next
        With wsh.Cells(gn_monthRow, 3).Validation
            .Delete
            .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, _
                Operator:=xlBetween, Formula1:=monthList
            .IgnoreBlank = True
            .InCellDropdown = True
            .InputTitle = ""
            .ErrorTitle = ""
            .InputMessage = ""
            .ErrorMessage = ""
            .ShowInput = True
            .ShowError = True
        End With
        
        If isProtected Then
            protectSheet wsh
        End If
        
        ' short names
        Set wsh = Worksheets.item(cs_GraphicsData)
        If wsh Is Nothing Then Exit Sub
        wsh.Unprotect Password:=cs_LiquiPWD
        For m = 1 To 12
            wsh.Cells(1, 2 + m) = Left(numberToMonth(m), 3)
        Next
        
        protectSheet wsh
    Next
    Application.EnableEvents = eventsFlag
End Sub

Sub handleSheetSelectionChange(ByVal Target As Range)
' update liquiplan menu (selection/context dependent)
' disabled: catch user click on cell 'Grafik' of some performance analysis
Dim monthName As String, month As Long, lastMonthName As String, lastMonth As Long
Dim sh As Worksheet, dataRow As Long, row As Long, clm As Long
Dim sError As String
Dim name As String, flag As Boolean, eventsFlag As Boolean

    ' refresh context-dependent submenu
    If (Target.Columns.Count = Target.parent.Columns.Count And Target.Rows.Count = Target.parent.Rows.Count) Then
    ' total sheet
Exit Sub
    End If
    If (Target.Rows.Count = Target.parent.Rows.Count) Then
    ' one or more columns
Exit Sub
    End If
    
    On Error Resume Next
    With Application.CommandBars("Worksheet Menu Bar")
        .Controls("LiquiPlan").Delete
    End With
    On Error GoTo 0
    addLiquiPlanMenu "Worksheet Menu Bar"
    
If gb_modelProtectionSuspended Then
Exit Sub
End If

EXIT_SUB:
'    Application.EnableEvents = eventsFlag
End Sub


' ========== cemetery ==========


' cf. exported code modules

Sub handleDoubleClick(ByVal Target As Range, Cancel As Boolean)
Dim sh As Worksheet, row As Long, clm As Long, idx As Long
Dim isProtect As Boolean

' disable; ? obsolete with new protection schema ?
Exit Sub
End Sub


Attribute VB_Name = "LibMenu"
Option Explicit
 
Public renameBtn As CommandBarControl
Public lockUnlockBtn As CommandBarControl

Public modelWatchBtn As CommandBarControl
Public dataWatchBtn As CommandBarControl
Public redWarningBtn As CommandBarControl


Sub addLiquiPlanMenu(sMenuBar As String)
Dim modelPopup As CommandBarPopup, pop As CommandBarPopup, btn As CommandBarControl
Dim caption As String, idx As Long, pos As Long
Dim quantities As Range, definition As Range, isDefLocked As Boolean
Dim sError As String

    Application.EnableEvents = False
    
    If (gs_MainSheetName = "") Then
        validateMainSheet sError
    End If
    
    With Application.CommandBars(sMenuBar)
        'pos = .Controls("&?").Index
        'Set pop = .Controls.Add(Type:=msoControlPopup, Before:=pos, temporary:=True)
        'pos = .Controls("&?").Index
        
        Set pop = .Controls.Add(Type:=msoControlPopup, temporary:=True)
        pop.caption = "LiquiPlan"
        pop.TooltipText = "Befehle zur Handhabung von Liquiplan (siehe Liquiplan-Hinweise.pdf)."
        
        ' not for header rows
Dim srcBk As Workbook, srcSh As Worksheet, srcRow As Long, row As Long, height As Long, addSubMenu As Boolean, context As String
        addSubMenu = True
        On Error Resume Next    ' error value in selection
        With Selection
            Set srcSh = .parent
            srcRow = .row
            height = .Rows.Count
            For row = srcRow To srcRow + height - 1
                If (srcSh.Cells(row, cn_clm_January).formula = "Januar") Then
                    addSubMenu = False
                    Exit For
                End If
                If (isSectionHeader(srcSh.Cells(row, cn_clm_Quantity))) Then
                    addSubMenu = False
                    Exit For
                End If
            Next
            context = ""
            If (.Columns.Count = srcSh.Columns.Count And .Rows.Count = srcSh.Rows.Count) Then
                context = "Cells"
            ElseIf (.Columns.Count = srcSh.Columns.Count) Then
                context = "Row"
            ElseIf (.Rows.Count = srcSh.Rows.Count) Then
                context = "Column"
            Else
                context = "Cell"
            End If
        End With
        On Error GoTo 0
        
        ' sub menu: drop ?
If True Then
        If (gs_CodeVariant = "Variant_B" And sMenuBar = "Worksheet Menu Bar") Then
            Set modelPopup = pop.Controls.Add(Type:=msoControlPopup, temporary:=True)
            modelPopup.caption = "Modell bearbeiten"
            modelPopup.TooltipText = "Modell-Gr|fffd||fffd|en konsistent umbenennen, hinzuf|fffd|gen oder entfernen.."
            addToLiquiSubMenu modelPopup, context
        End If
End If

        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)
        btn.caption = "Modell |fffd|berpr|fffd|fen"
        btn.OnAction = "menuValidateModel"
        btn.TooltipText = " |fffd|berpr|fffd|ft die Konsistenz des Modell und stellt den Blattschutz wieder her."
        
        Set redWarningBtn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
'        redWarningBtn.caption = "Warn-Rot " & IIf(not gb_formulaWatchDisabled, "entfernen", "aktivieren")
        redWarningBtn.caption = "Alle Warnfarben entfernen"
        redWarningBtn.OnAction = "menuRemoveWarnings"
        redWarningBtn.TooltipText = "Entfernt die Hervorhebung von Feldern durch |fffd|berpr|fffd|fung oder |fffd|berwachung."
        
'        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)
'        btn.caption = "Blattschutz wiederherstellen"
'        btn.OnAction = "menuRestoreProtection"
'        btn.TooltipText = "Blattschutz f|fffd|r alle LiquiPlan Arbeitsbl|fffd|tter und Diagramme."
'        ' with timer
'        If sMenuBar = "Worksheet Menu Bar" Then
'            Set protectionButtonWorksheet = btn
'        ElseIf sMenuBar = "Chart Menu Bar" Then
'            Set protectionButtonChart = btn
'        End If
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
        btn.caption = "Plandaten speichern"
        btn.OnAction = "menuStoreMasterData"
        btn.TooltipText = "Speichert den aktuellen Planungszustand als 'Original Plandaten'."
        
Dim isRestore As Boolean
'8.4.0.1 disable:
        Set modelWatchBtn = pop.Controls.Add(Type:=msoControlButton, id:=2949)
        modelWatchBtn.visible = False
'        isRestore = (gb_modelProtectionSuspended Or gb_protectionIssue)
'        modelWatchBtn.caption = IIf(isRestore, cs_restoreModelProtection, cs_suspendModelProtection)
'        modelWatchBtn.OnAction = "menuToggleModelProtection"
'        modelWatchBtn.TooltipText = "Schutz f|fffd|r alle LiquiPlan Arbeitsbl|fffd|tter und Diagramme."
        
        Set dataWatchBtn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
        dataWatchBtn.visible = False
'        dataWatchBtn.BeginGroup = True
''8.2 several levels rather than toggle
''   removed !
''       dataWatchBtn.caption = "Formal|fffd|berwachung"
'        dataWatchBtn.caption = "|fffd|berwachung " & IIf(gb_modelWatchDisabled, "einschalten", "ausschalten") ' "Daten |fffd|berpr|fffd|fen"
'        dataWatchBtn.OnAction = "menuToggleDataWatch"
'        dataWatchBtn.TooltipText = "|fffd|berwacht Umbenennungen und das |fffd|berschreiben von Formeln."
'        ' new protection logic
'        dataWatchBtn.caption = "|fffd|berwachung einschalten" ' watch is off
'        dataWatchBtn.caption = "|fffd|berwachung ausschalten" ' watch is on
        
' @-conversion: canceled, unfinished
'        Set renameBtn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
'        renameBtn.caption = IIf(gb_ConsistenRenaming, "Gr|fffd||fffd|en konsistent umbenennen: Ein", "Gr|fffd||fffd|en konsistent umbenennen: Aus")
'        renameBtn.beginGroup = False
'        renameBtn.OnAction = "menuConsistentRenaming"
        
        'Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
        'btn.Caption = "Formel bearbeiten"
        'btn.OnAction = "menuAudXL"
        'btn.BeginGroup = False
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
    btn.BeginGroup = True
        btn.caption = cs_titlePerformanceAnalysis
        btn.OnAction = "menuPerformanceAnalysis"
        btn.TooltipText = "Aktualisiert Soll/Ist-Vergleich und Diagramme."
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
        btn.caption = "Diagramm einf|fffd|gen"
        btn.OnAction = "menuAddOrRemoveChart"
        btn.TooltipText = "Diagramm mit dem zeitlichen Verlauf ein oder mehrerer ausgew|fffd|hlter Gr|fffd||fffd|en."
        
'        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
'    btn.BeginGroup = True
'        btn.caption = "Datenfelder l|fffd|schen"
'        btn.OnAction = "menuClearData"
'        btn.TooltipText = "L|fffd|scht Datenfelder (Nicht-Formeln) des Modells."
''        If gs_MainSheetName = cs_MainSheet_ProfitCenter Then btn.Enabled = False

' ~> context menu
'        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
'        btn.caption = "Daten |fffd|bernehmen"
'        btn.OnAction = "menuImportData"
' ~>

        'Set btn = pop.Controls.Add(Type:=msoControlButton, ID:=2949)    '2950=Smily
        'btn.Caption = "Plandaten laden"
        'btn.onAction = "menuLoadData"
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
    btn.BeginGroup = True
        btn.caption = "Neue Planung einrichten"    '  "Planung fortschreiben"
        btn.OnAction = "menuNewModel"
        btn.TooltipText = "|fffd|bertr|fffd|gt das aktuelle Modell ganz oder teilweise in eine neue Planung."
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
        btn.caption = "Verkn|fffd|pfung mit Vorjahr erneuern"
        btn.OnAction = "menuUpdatePreviousYear"
        btn.TooltipText = "|fffd|bertr|fffd|gt Jahresdaten des Vorjahres in vorliegendes Modell, entweder als Wert oder als Verkn|fffd|pfung."
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
        btn.caption = "|fffd|lteres Modell aktualisieren" ' |fffd|lteres ' Liquiplan-'     ' umwandeln
        btn.OnAction = "menuCodeUpdate"
        btn.TooltipText = "|fffd|bertr|fffd|gt Makro-Code und Kommentare des vorliegenden Modells auf ein |fffd|lteres Modell."
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
    btn.BeginGroup = True
        btn.caption = "Formel durchleuchten"
        btn.OnAction = "menuPrettyPrint"
        btn.TooltipText = "Stellt den Aufbau einer Formel in einem gesonderten Fenster dar."
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
        btn.caption = "Hinweise |fffd|ffnen"
        btn.OnAction = "menuHelp"
        btn.BeginGroup = False
        btn.TooltipText = "|fffd|ffnet/Sucht das Dokument Liquiplan-Hinweise.pdf"
        
        Set btn = pop.Controls.Add(Type:=msoControlButton, id:=2949)    '2950=Smily
    btn.BeginGroup = False
        btn.caption = "Version"
        btn.OnAction = "menuVersion"
        btn.TooltipText = "Angaben zu Liquiplan und zum vorliegenden Dokument."
                
        Application.EnableEvents = True
    End With
End Sub

Function removeLiquiPlanMenu()
On Error Resume Next
    Application.EnableEvents = True
    With Application.CommandBars("Worksheet Menu Bar")
'       not in Excel 14
        .Controls("LiquiPlan").Delete
    End With
    With Application.CommandBars("Chart Menu Bar")
'       not in Excel 14
        .Controls("LiquiPlan").Delete
    End With
End Function

Function addLiquiMenus()
Dim sError As String
Dim eventsFlag As Boolean
    
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    If (gs_MainSheetName = "") Then
        validateMainSheet sError
    End If
    
    removeLiquiPlanMenu
    addLiquiPlanMenu "Worksheet Menu Bar"
    addLiquiPlanMenu "Chart Menu Bar"
'Stop '(8)
    initOptions
    Application.EnableEvents = eventsFlag
End Function


Private Sub menuValidateModel()
Dim mainSheet As Worksheet, wsh As Worksheet, rng As Range, shx As Long, sError As String

    If (gs_MainSheetName = "") Then
        Set mainSheet = validateMainSheet(sError)
    Else
        Set mainSheet = getSheet(gs_MainSheetName)
    End If
    If (mainSheet Is Nothing) Then
        MsgBox sError, vbExclamation, cs_MsgTitle
Exit Sub
    End If
    
    ' voodoo: deselect Liqui menu
'    Application.ScreenUpdating = True
'    mainSheet.Activate
'    DoEvents
'    Set wsh = ActiveWorkbook.Worksheets(gn_MainSheetIndex + 1)
'    wsh.Activate
'    DoEvents
'    mainSheet.Activate
'    DoEvents
'
'SendKeys "{ESC}"
        
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    Application.StatusBar = "Arbeitsbl|fffd|tter |fffd|ffnen."
    DoEvents
    
    If (Not unprotectAllSheets(3)) Then
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    Application.StatusBar = False
Exit Sub
    End If
    
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    
    Application.StatusBar = "Warnfarben entfernen."
    DoEvents
    removeWarningColors Application.ActiveWorkbook
Application.StatusBar = False
    DoEvents

Dim logStream As TextStream, logPath As String
Dim ync As LiquiYesNoCancel, msg As String, outlierMarked As Boolean    ' , overrideMarked As Boolean
Application.StatusBar = "Modell-Konsistenz |fffd|berpr|fffd|fen"
    DoEvents
    
    ync = validateDataStructure(logStream, logPath)     ' stores row default colors
    mainSheet.Activate

'    If ync = lqYes Then
Application.StatusBar = "Formel-Abweichungen"
DoEvents
        ' mark outliers in all input sheets
        For shx = 1 To gn_MainSheetIndex
            Set wsh = Application.ActiveWorkbook.Worksheets(shx)
            With wsh
                Set rng = .Range(.Rows(gn_row_Section_I_Start), .Rows(gn_row_MonthRangeEnd))
                markOutliers rng, outlierMarked
            End With
        Next shx
Application.StatusBar = False
DoEvents
    
        If outlierMarked Then
            msg = "Ein oder mehrere Zellen wurden als Ausrei|fffd|er markiert."
            MsgBox msg, vbInformation, cs_MsgTitle
            ync = lqNo
        End If
'    End If

'3.4.0.1
' protect all worksheets, unconditionally, with cs_LiquiPWD
' protect all charts w/o PWD
' restore cell locking for input sheets, completely lock all other LiquiPlan sheets
    restoreModelProtection
    
Application.StatusBar = "Arbeitsbl|fffd|tter schlie|fffd|en."
DoEvents
    If Not logStream Is Nothing Then logStream.Close
    protectAllSheets 4
    
Application.StatusBar = "Protokoll"
DoEvents
    Set mainSheet = getSheet(gs_MainSheetName)
    mainSheet.Activate
    
    If ync = lqYes Then
        msg = "Die |fffd|berpr|fffd|fung hat keine Abweichungen gefunden."
'        If gb_formulaWatchDisabled Then msg = msg & vbCrLf & "(Formel|fffd|berwachung ist abgeschaltet.)"
        MsgBox msg, vbInformation, cs_MsgTitle
'    Else
'        MsgBox "Die |fffd|berpr|fffd|fung hat Abweichungen gefunden.", vbExclamation, cs_MsgTitle
    End If
    DoEvents
    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False

    If logPath <> "" Then
        Shell "notepad.exe " & logPath, 1
    Else
SendKeys "{ESC}"
DoEvents
    End If
End Sub

Private Sub menuToggleDataWatch()
Dim mainSheet As Worksheet, sError As String

    Application.EnableEvents = True
    If Application.ActiveWorkbook Is Nothing Then Exit Sub
    
    Set mainSheet = getSheet(gs_MainSheetName)
    If mainSheet Is Nothing Then
        Set mainSheet = validateMainSheet(sError)
        If sError <> "" Then MsgBox sError, vbExclamation, cs_MsgTitle
        If mainSheet Is Nothing Then Exit Sub
    End If
    
    If dataWatchBtn Is Nothing Then
        addLiquiMenus
    End If
    
'8.2 levels of protection
'    If gb_formulaWatchDisabled Then
'        If setFormulaProtection() = True Then
'            toggleDataWatch
'        Else
'            ' operation was canceled
'        End If
'    Else
'        toggleDataWatch
'    End If

'    setFormulaProtection

    toggleDataWatch
    
' Office 15.0 issue: liquiMenu remains visible
' => all menu actions need some user interaction
    
'http://stackoverflow.com/questions/25326925/deselect-label-and-chart-excel-vba
'SendKeys "{ESC}"
'Works, but highly unreliable, as if used with other macros it will break the code,
'and this will give the "code execution has been interrupted" error.

    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuStoreMasterData()
Dim mainSh As Worksheet, wsh As Worksheet, monthCell As Range, shx As Long
Dim sError As String

    Application.EnableEvents = True
    
    If (gn_MainSheetIndex = 0) Then
        Set mainSh = validateMainSheet(sError)
        If sError <> "" Then MsgBox sError, vbExclamation, cs_MsgTitle
        If mainSh Is Nothing Then
Exit Sub
        End If
    End If
    
    Set mainSh = ActiveWorkbook.Worksheets(gn_MainSheetIndex)
    If (Not mainSh Is ActiveSheet) Then
        mainSh.Activate
        For shx = 1 To 100
            DoEvents
        Next
    End If
    
Application.ScreenUpdating = False
Application.DisplayAlerts = False
Application.Calculation = xlCalculationManual
Application.EnableEvents = False
    
    storeMasterData checkMonth:=True
' 8.2.0.8: hide master sheets
    hideMasterSheets Application.ActiveWorkbook
    
    ' update plots and charts
    For shx = 1 To gn_MainSheetIndex
        Set wsh = ActiveWorkbook.Worksheets(shx)
'        If Not updatePlots(wsh, sError, False) Then
        If Not updatePlots(wsh, Nothing, sError) Then
            MsgBox sError, vbExclamation, cs_MsgTitle
        End If
    Next
    
    Set mainSh = ActiveWorkbook.Worksheets(gn_MainSheetIndex)
    Set monthCell = mainSh.Cells(gn_monthRow, 3)
    If Not updateLiquiCharts(monthCell, sError) Then
        MsgBox sError, vbCritical, cs_MsgTitle
    End If
    
    mainSh.Activate
    monthCell.Select
    ActiveWindow.ScrollRow = 1

Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuToggleModelProtection()
Dim wsh As Worksheet, cll As Range
Dim isSuccess As Boolean, msg As String, tmp As String, sError As String
Dim i As Long

    Application.EnableEvents = True
    If Application.ActiveWorkbook Is Nothing Then Exit Sub
    
    If gs_MainSheetName = "" Then
        If (validateMainSheet(sError) Is Nothing) Then
            MsgBox sError, vbCritical, cs_MsgTitle
Exit Sub
        End If
    End If
    
    If (modelWatchBtn Is Nothing) Then
        addLiquiMenus
    End If
    
'    gb_modelProtectionSuspended = (modelWatchBtn.caption = cs_restoreModelProtection)
'    If (modelWatchBtn.caption = cs_suspendModelProtection) Then
' w/0 PWD
'        tmp = InputBox("Bitte Passwort eingeben.", cs_MsgTitle)
'        Do While (tmp <> cs_LiquiPWD)
'            If (tmp = "") Then
'Exit Sub
'            Else
'                tmp = InputBox("Bitte Passwort eingeben.", cs_MsgTitle)
'            End If
'        Loop
'    End If
    
    Set wsh = ActiveWorkbook.Worksheets(gn_MainSheetIndex)
    If (Not wsh Is ActiveSheet) Then
        wsh.Activate
        For i = 1 To 100
            DoEvents
        Next
    End If
    
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    
    If (modelWatchBtn.caption = cs_restoreModelProtection) Then
Application.StatusBar = "Modellschutz wiederherstellen: " & wsh.name
DoEvents
        gb_modelProtectionSuspended = False
        gb_protectionIssue = False
        If (restoreModelProtection()) Then
        Else
            gb_protectionIssue = True
        End If
        
    Else
        ' confirm
        msg = "Warnung: Solange die Formel|fffd|berwachung aufgehoben ist, ist die Konsistenz des Modells nicht gew|fffd|hrleistet."
        msg = msg & vbLf & "Fortfahren ?"
        If (MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel) Then
Exit Sub
        End If
        gb_modelProtectionSuspended = True
        gb_protectionIssue = False
        For Each wsh In Application.ActiveWorkbook.Worksheets
            If isLiquiplanSheet(wsh) Then
Application.StatusBar = "Formel|fffd|berwachung aufheben: " & wsh.name
DoEvents
'                wsh.Cells.Locked = False   ' assume sh.protect UserInterfaceOnly:=True
'Debug.Print "Formel|fffd|berwachung aufheben: " & wsh.name
                If (Not protectSheet(wsh, lockCells:=True, isLocked:=False)) Then
                    wsh.Activate
                    msg = "Bitte heben Sie den Blattschutz von '" + wsh.name + "' auf."
                    msg = msg + vbLf + "Andernfalls ist die Konsistenz des Modells nicht mehr gew|fffd|hrleistet."
'Stop '(7)
                    MsgBox msg, vbExclamation, cs_MsgTitle
                    gb_protectionIssue = True
                    Exit For    ' ???
                End If
            End If
        Next
    End If
    
    addLiquiMenus

    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

'Private Sub menuRestoreProtection()
'Dim wsh As Worksheet, isProtected As Boolean
'Dim sError As String
'    Application.EnableEvents = True
'    If Application.ActiveWorkbook Is Nothing Then Exit Sub
'
'    If gs_MainSheetName = "" Then
'        If (validateMainSheet(sError) Is Nothing) Then
'            MsgBox sError, vbCritical, cs_MsgTitle
'Exit Sub
'        End If
'    End If
'
'    Application.ScreenUpdating = False
'    Application.ActiveWorkbook.Worksheets(gs_MainSheetName).Activate
'    restoreSheetsProtected prompt:=False
'
'    'new protection scheme
'    For Each wsh In Application.ActiveWorkbook.Worksheets
'        If (isMasterSheetName(wsh.name) Or wsh.name = cs_PlotData Or wsh.name = cs_GraphicsData) Then
'            isProtected = wsh.ProtectContents
'            wsh.Unprotect cs_LiquiPWD
'            wsh.Cells.Locked = True
'            If isProtected Then protectSheet wsh
'        End If
'    Next
'
'    Application.ScreenUpdating = True
'    Application.Calculation = xlCalculationAutomatic
'    Application.EnableEvents = True
'    SendKeys "{ESC}"
'End Sub

Private Sub menuRemoveWarnings()
    Application.EnableEvents = True
    If Application.ActiveWorkbook Is Nothing Then Exit Sub
    
    removeWarningColors Application.ActiveWorkbook

    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuNewModel()
Dim wbThisYear As Workbook, wbNextYear As Workbook
Dim outlierMarked As Boolean, msg As String, sError As String   ' overrideMarked As Boolean,

    Application.EnableEvents = True
    If Application.ActiveWorkbook Is Nothing Then Exit Sub
    
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual 'Turn off Autocalculation
    
    Set wbThisYear = Application.ActiveWorkbook
    ' fso.CopyFile actPath, nxtPath of createModel(..) must get latest changes
    wbThisYear.Save
    
    ' new model
    Set wbNextYear = createModel(outlierMarked, sError)     ' overrideMarked,
    If wbNextYear Is Nothing Then
        If sError <> "" Then
            MsgBox sError, vbInformation, cs_MsgTitle
        End If

Application.ScreenUpdating = True
Application.DisplayAlerts = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Exit Sub
    End If
    
    wbNextYear.Activate
    
' 8.2.0.8: hide master sheets
    hideMasterSheets wbNextYear
    
Dim sh As Worksheet
'    performance analysis, charts (planning state: month = 'none'
    Set sh = wbNextYear.Worksheets(gs_MainSheetName)
'    cleanupGraphicsData
    processMonthChange Target:=sh.Cells(gn_monthRow, 3), force:=True
    sh.Activate
    sh.Cells(gn_row_Prolog_Start + 1, 3).Select ' company name
    ActiveWindow.ScrollRow = 1
    ActiveWindow.ScrollColumn = 1
    
'    restoreSheetsProtected  ' prompt:=False
    
'    Application.DisplayAlerts = False
'        wbThisYear.Close True
'    Application.DisplayAlerts = True

    msg = "Neue Planung eingerichtet und gespeichert:" & vbLf & wbNextYear.FullName
    
    ' must close new book; macro security may disable code execution
    Application.DisplayAlerts = False
        wbNextYear.Save
        wbNextYear.Close True
    Application.DisplayAlerts = True
    
    wbThisYear.Activate
    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
    
    MsgBox msg, , cs_MsgTitle
'    If overrideMarked Or outlierMarked Then
'        'MsgBox "Formeln wurden versuchsweise repariert (gelbe Markierung).", vbInformation, cs_MsgTitle
'        MsgBox "Abweichungen von Standardformeln in der neuen Planung wurden markiert.", vbInformation, cs_MsgTitle
'    End If
'    If overrideMarked Then
'        msg = "Ein oder mehrere Zellen wurden wegen m|fffd|glicher Zerst|fffd|rung einer Formel markiert."
'        MsgBox msg, vbInformation, cs_MsgTitle
'    End If
    If outlierMarked Then   ' overrideMarked Or
        msg = "Ein oder mehrere Zellen wurden als Ausrei|fffd|er markiert."
        MsgBox msg, vbInformation, cs_MsgTitle
    End If

Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents

    ' possible code confusion: which VBA project is active ?
    
    removeLiquiPlanMenu
    deleteFromContextMenu "Cell"
    deleteFromContextMenu "Row"
    deleteFromContextMenu "Column"

    wbThisYear.Save
    wbThisYear.Close   ' no more code executed after this
SendKeys "{ESC}"
End Sub
Private Sub menuUpdatePreviousYear()
' open previous model, copy year sums into current model (value | link)
Dim fso As FileSystemObject, actWb As Workbook, actSh As Worksheet, srcWb As Workbook, srcPath As String
Dim sError As String, msg As String

    Application.EnableEvents = False
    
    Set actWb = Application.ActiveWorkbook
'    If gs_MainSheetName = "" Then   ' Or gn_monthRow = 0
        Set actSh = validateMainSheet(sError)
        If actSh Is Nothing Then
            msg = sError & vbLf & "Keine LiquiPlan Vorlage."
            MsgBox msg, vbExclamation, cs_MsgTitle
Application.EnableEvents = True
Exit Sub
        End If
'    End If
    
    Application.ScreenUpdating = False
'    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    
    updatePreviousYear actWb
    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuPerformanceAnalysis()
Dim cmpSh As Worksheet, sError As String
    
    If (gn_MainSheetIndex = 0) Then
        validateMainSheet sError
    End If

'    If (isCompareSheetName(Application.ActiveSheet.name)) Then
'        Set cmpSh = Application.ActiveSheet
'        gb_isAddPlotsDenied = False
'        With cmpSh
'            performanceAnalysis _
'                checked:=.Range(.Cells(cn_compareRowOff + 2, cn_clm_PlotCheck), .Cells(getLastRow(.usedRange), cn_clm_PlotCheck)), _
'                rebuild:=True
'        End With
'    Else
'        performanceAnalysis checked:=Nothing, rebuild:=True
'    End If
    gb_isAddPlotsDenied = False
    performanceAnalysis checked:=Nothing, rebuild:=True
    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

' "Diagramm einf|fffd|gen"
Private Sub menuAddOrRemoveChart()
Dim mainSh As Worksheet, dataSh As Worksheet, msg As String, sError As String
Dim nMonth As Long, sMonth As String

    Application.EnableEvents = False
    
    If gs_MainSheetName = "" Then
        If (validateMainSheet(sError) Is Nothing) Then
            MsgBox sError, vbCritical, cs_MsgTitle
Exit Sub
        End If
    End If
    Set mainSh = getSheet(gs_MainSheetName)
    
    Set dataSh = getSheet(cs_GraphicsData)
    If (dataSh Is Nothing) Then
        Set dataSh = makeNewSheet(Application.ActiveWorkbook, cs_GraphicsData)
        For nMonth = 1 To 12
            dataSh.Cells(1, 2 + nMonth) = Left(numberToMonth(nMonth), 3)
        Next
        sMonth = mainSh.Cells(gn_monthRow, 3)
        nMonth = monthToNumber(sMonth)
        dataSh.Cells(3, 1) = "[Berichtsmonat]"
        dataSh.Cells(4, 1) = nMonth
        dataSh.Cells(4, 2) = sMonth
        gs_currentMonthName = sMonth
    End If
    If (Not unprotectSheet(dataSh, False)) Then
        dataSh.Activate
        dataSh.visible = xlSheetVisible
        msg = "Bitte heben Sie den Blattschutz von '" + dataSh.name + "' auf"
        msg = msg + vbLf + "und wiederholen Sie den Vorgang."
        MsgBox msg, vbExclamation, cs_MsgTitle
Exit Sub
    End If
    
    doAddOrRemoveChart
    
    protectSheet dataSh

Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuPrettyPrint()
    Application.EnableEvents = True
    If Application.ActiveWorkbook Is Nothing Then Exit Sub
    
    frmPretty.Show vbModeless

Application.ScreenUpdating = True
Application.DisplayAlerts = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuHelp()
Dim fso As FileSystemObject, helpPath As Variant
Dim readerPath As String

    Application.EnableEvents = True
    If Application.ActiveWorkbook Is Nothing Then Exit Sub

    Set fso = New FileSystemObject
    helpPath = Application.ActiveWorkbook.path & "\Liquiplan-Hinweise.pdf"
Debug.Print helpPath
'    gs_RoamingFolder = "C:\Users\" & Environ("username") & "\AppData\Roaming\" & cs_LiquiRoaming
'    helpPath = gs_RoamingFolder & "\Docs\Hinweise.pdf" ' "\LiquiHilfe.chm"
    If (Not fso.FileExists(helpPath)) Then
'Debug.Print helpPath
        MsgBox "Dokument Liquiplan-Hinweise.pdf nicht gefunden.", vbInformation
        helpPath = Application.GetOpenFilename( _
                         "PDF Dokument (*.pdf), *.pdf", 1, _
                        "Liquiplan-Hinweise |fffd|ffnen", MultiSelect:=False) ' Window has focus and is restored to its original size and position.
Debug.Print helpPath
        If VarType(helpPath) = vbBoolean Then
            ' canceled
            helpPath = ""
        End If
        If helpPath = "" Then
Exit Sub
        End If
    End If
    ' locate Acrobat Reader
    readerPath = "C:\Program Files\Adobe\Acrobat Reader DC\Reader\AcroRd32.exe"
    If Not fso.FileExists(readerPath) Then
        readerPath = "C:\Program Files (x86)\Adobe\Acrobat Reader DC\Reader\AcroRd32.exe"
    End If
    If Not fso.FileExists(readerPath) Then
'        MsgBox "Kann Acrobat Reader nicht finden.", vbInformation
        readerPath = ""
    End If
    If readerPath <> "" Then
        Shell readerPath & " """ & helpPath & """", 1
    ElseIf True Then
        Shell "hh.exe " & helpPath, 1
    Else
'Dim PDF_File As String
'        If Not FileLocked(helpPath) Then
'            Documents.Open helpPath
'        End If
    End If
    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuVersion()
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    Application.Calculation = xlCalculationAutomatic
    
    If Application.ActiveWorkbook Is Nothing Then Exit Sub
'Debug.Print ActiveWorkbook.name
'    With Application.VBE
'Debug.Print .VBProjects.Count
'Debug.Print .ActiveVBProject.FileName, .ActiveVBProject.name
'Debug.Print .ActiveCodePane.CodeModule.parent.Collection.parent.FileName
'
''        IsEditorInSync = .ActiveVBProject Is _
''            .ActiveCodePane.CodeModule.parent.Collection.parent
'    End With
'Debug.Print OFFICE_VERSION

    ' update menu
    addLiquiMenus
    
    addToContextMenu "Cell"
    addToContextMenu "Row"
'    addToContextMenu "Column"
    
    Application.EnableEvents = False
    If frmVersion.lblNameText <> "" Then
        frmVersion.Show vbModal
    End If
    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents
SendKeys "{ESC}"
End Sub

Private Sub menuCodeUpdate()
Dim abk As Workbook, resultFullName As String

    With Application
        .EnableEvents = True
        If .ActiveWorkbook Is Nothing Then Exit Sub
        
        Set abk = .ActiveWorkbook
    
        .ScreenUpdating = False
        .DisplayAlerts = False
        .Calculation = xlCalculationManual 'Turn off Autocalculation
    
        resultFullName = doModelUpdate()
    End With
    
Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False
DoEvents

    ' possible code confusion: which VBA project is active ?
    removeLiquiPlanMenu
    deleteFromContextMenu "Cell"
    deleteFromContextMenu "Row"
    deleteFromContextMenu "Column"

    abk.Save
    abk.Close   ' no more code executed after this
'SendKeys "{ESC}"
End Sub


' ========== cemetery ==========

Attribute VB_Name = "LibMultiChart"
Option Explicit


'
' ===== Charts with several quantities (clustered column, no accrued values) =====
'
' Version: Excel 14. and earlier
' Issue: some code of Excel 15.0 and later not downward compatible to Excel 14. and earlier
'       ((Chart.FullSeriesSollection, Series.isFiltered))
'
Function addMultiChart()
' wrapper for createMultiChart(..)
Dim srcSheet As Worksheet, dtaSheet As Worksheet, sh As Object
Dim srcRange As Range, usedRange As Range, selectedRange As Range, rng As Range, cl As Range
Dim first As Long, last As Long
Dim srcRow As Long, row As Long, clm As Long, idx As Long
Dim chartName As String
Dim isInputRange As Boolean
Dim msg As String, sError As String

'    ' main input sheet
    Set sh = validateMainSheet(sError)
    If sh Is Nothing Then
        MsgBox sError, vbCritical, cs_MsgTitle
Exit Function
    End If
    ' graphics data
    Set dtaSheet = getSheet(cs_GraphicsData)
    If dtaSheet Is Nothing Then
        msg = "Blatt '" & cs_GraphicsData & "' nicht gefunden."
        MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
    End If
    
    ' data to display
    Set srcSheet = Application.ActiveWorkbook.ActiveSheet
    If (Not TypeOf srcSheet Is Worksheet) Then
Debug.Print "not a worksheet: " & srcSheet.name
Exit Function
    End If
    If (Not TypeOf Application.Selection Is Range) Then
        msg = "Auswahl ist nicht geeignet f|fffd|r Grafik."
        MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
    End If
    Set srcRange = Application.Selection
'Debug.Print srcRange
    
    With srcSheet
        ' must be some input sheet
        isInputRange = False
        If .name = gs_MainSheetName Then
            isInputRange = True
        Else
            For idx = 1 To gn_MainSheetIndex - 1
            Set sh = Application.ActiveWorkbook.Worksheets(idx)
                If sh.name = .name Then
                    isInputRange = True
                    Exit For
                End If
            Next
        End If
        If Not isInputRange Then
            msg = "Auswahl ist nicht geeignet f|fffd|r Grafik."
            MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
        End If
    End With
        
    With srcRange
        ' comma separated list of row numbers
Dim rowList As String, seriesName As String, seriesCount As Long, tmp As String
        rowList = ""
        seriesCount = 0
        For Each cl In .Cells ' in order of being selected
            If InStr(1, rowList, cl.row & ",") = 0 Then
                rowList = rowList & cl.row & ","
                seriesCount = seriesCount + 1
            End If
        Next
'Debug.Print rowList
        If seriesCount = 1 Then
            ' for the time being
            If .name <> gs_MainSheetName Then
                msg = "In der Entwicklung: mehrere Gr|fffd||fffd|en einzelner Profitcenter."
                MsgBox msg, vbInformation, cs_MsgTitle
Exit Function
            End If
            ' nothing new
            addSimpleChart
Exit Function
        End If
    End With
    
    
    ' range of available data
'    Set usedRange = srcSheet.usedRange
'    last = usedRange.row + usedRange.Rows.count - 1
    row = 1
    clm = 2
    findTextOrFormula srcSheet, "I. ", True, True, row, clm, , 2
    first = row
    findTextOrFormula srcSheet, "Kennzahlen  Ertragslage", True, True, row, clm
    last = row
    If first = 0 Or last = 0 Then
        msg = "Blatt '" & srcSheet.name & "' inkonsistent."
        MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
    End If
    
    ' loop through list of rows
    tmp = rowList
    Do While tmp <> ""
        row = CInt(nextValue(tmp, ","))
        seriesName = srcSheet.Cells(row, 2)
'Debug.Print "" & row, seriesName
        If row < first Or row >= last Or seriesName = "" Or isSectionHeader(seriesName) Then
            msg = "Zeile " & row & " (" & seriesName & ") ist nicht geeignet f|fffd|r Grafik."
            MsgBox msg, vbCritical, cs_MsgTitle
Exit Function
        End If
    Loop
            
    ' non-standard chart: more than one quantity (series pair target-actual)
    ' user must confirm name of chart
    '   default: name of first row
'Dim chrt As Chart
    tmp = rowList
    row = CInt(nextValue(tmp, ","))
    chartName = Trim$(srcSheet.Cells(row, 2)) & IIf(srcSheet.name = gs_MainSheetName, "", "(" & srcSheet.name & ")")
CHOOSE_NAME:
    msg = "Bitte neue Grafik benennen."
    chartName = Trim$(InputBox(msg, cs_MsgTitle, chartName))
    If chartName = "" Then
Exit Function
    End If
    If chartName <> getValidSheetName(chartName) Then
        msg = "Folgende Zeichen sind in Namen von Tabellen und Diagrammen nicht erlaubt."
        msg = msg + vbLf + "\  /  ?  *  :  [  ]"
        MsgBox msg, , cs_MsgTitle
        GoTo CHOOSE_NAME
    End If
    If (Len(chartName) > 31) Then
        msg = "Name enth|fffd|lt mehr als 31 Zeichen."
        MsgBox msg, , cs_MsgTitle
        GoTo CHOOSE_NAME
    End If
    If chartName = "Gesamtumsatz" Or chartName = "G. u. V. vor Steuern" Then
        msg = "'" & chartName & "' ist Standard-Grafik." & vbCrLf & "Bitte anderen Namen w|fffd|hlen."
        MsgBox msg, , cs_MsgTitle
        GoTo CHOOSE_NAME
    End If
    If chartName = "Kto-Stand Monatsende" Or chartName = "Kontokorrent - Kredit" Then
        msg = "'Kto-Stand Monatsende'" & " ist Standard-Grafik." & vbCrLf & "Bitte anderen Namen w|fffd|hlen."
        MsgBox msg, , cs_MsgTitle
        GoTo CHOOSE_NAME
    End If
    Set sh = getSheet(chartName)
    If Not sh Is Nothing Then
        sh.Activate
'Debug.Print TypeName(sh)
        If (Not TypeOf sh Is Chart) Then
            msg = "Tabelle '" & chartName & "' existiert bereits." & vbCrLf & "Bitte einen anderen Namen w|fffd|hlen."
            MsgBox msg, , cs_MsgTitle
            GoTo CHOOSE_NAME
        End If
        msg = "Diagramm '" & chartName & "' existiert bereits." & vbCrLf & "Bitte einen anderen Namen w|fffd|hlen oder zuvor l|fffd|schen."
        If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbOK Then
            GoTo CHOOSE_NAME
        Else
Exit Function
        End If
    End If
    
    sError = ""
    If Not createMultiChart(chartName, srcSheet, rowList, sError) Then
        If sError <> "" Then
            MsgBox sError, vbCritical, cs_MsgTitle
        End If
Exit Function
    End If
    Application.ActiveWindow.Zoom = 90
        
End Function

Private Function createMultiChart(chartName As String, srcSheet As Worksheet, rowList As String, sError As String) As Boolean
Dim dtSheet As Worksheet, mstSheet As Worksheet, chrt As Chart
Dim srcRange As Range, usedRange As Range, dataRow As Long
Dim monthName As String, month As Long, lastMonth As Long
Dim monthRow As Long, srcRow As Long
Dim maxRow As Long, row As Long, clm As Long, idx As Long
Dim seriesToBe As Series, seriesAsIs As Series
Dim title As String, src As String, temp As String
Dim seriesName As String, txt As String, msg As String, step As String, tmp As String
Dim watchFlag As Boolean

Const accumulated As Boolean = False

On Error GoTo CHART_ERROR
step = "initialize"
    createMultiChart = False
    sError = ""
    If srcSheet Is Nothing Then
Exit Function
    End If
    
    monthRow = 1
    clm = 2
    txt = cs_MonthTitle
    findTextOrFormula srcSheet, txt, True, True, monthRow, clm, , 2
    monthName = srcSheet.Cells(monthRow, 3)
    month = monthToNumber(monthName)
    If monthName = cs_NoMonth Then monthName = "Planung"
    
    tmp = getMasterSheetName(srcSheet.name)
'Debug.Print srcSheet.name, tmp
    Set mstSheet = getSheet(tmp)
    If mstSheet Is Nothing Then
        sError = "Tabelle '" & tmp & "' existiert nicht."
Exit Function
    End If
    
Dim eventsFlag As Boolean
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False

    Set dtSheet = getSheet(cs_GraphicsData)
    If (dtSheet Is Nothing) Then
        sError = "Blatt '" & cs_GraphicsData & "' existiert nicht."
Exit Function
    End If
    If (Not unprotectSheet(dtSheet, True)) Then
Exit Function
    End If
    With dtSheet
        maxRow = getLastRow(.usedRange)
        
        row = 1: clm = 1
        findTextOrFormula dtSheet, "[Berichtsmonat]", True, True, row, clm, , 1
        lastMonth = dtSheet.Cells(row + 1, 1)
        
        ' existing chart section: delete
step = "delete exisiting"
Dim sectStart As Long, sectEnd As Long
        findTextOrFormula dtSheet, "[" & chartName & "]", True, True, row, clm, , 1
        sectStart = row
        row = row + 1
        If sectStart > 0 Then
            findTextOrFormula dtSheet, "[", True, True, row, clm, , 1
            If row > 0 Then
                sectEnd = row - 1
            Else
                sectEnd = maxRow + 1
            End If
'Debug.Print sectStart, sectEnd
            For idx = 0 To sectEnd - sectStart + 1
                dtSheet.Rows(sectStart - 1).Delete
            Next
        End If
        Set usedRange = .usedRange
        maxRow = getLastRow(usedRange)
        For row = maxRow To 1 Step -1
            If (.Cells(row, 1) <> "") Then Exit For
        Next
        sectStart = row + 2   'blank separating
        
        ' build section
step = "build section"
        
        .Cells(sectStart, 1) = "[" & chartName & "]" & "{" & srcSheet.name & "}"
        
        ' loop through list of series'; no accumulation
Dim formula As String
        tmp = rowList
        dataRow = sectStart + 1
        Do While tmp <> ""
            srcRow = CInt(nextValue(tmp, ","))
            Set srcRange = srcSheet.Rows(srcRow)
            seriesName = Trim$(srcRange.Cells(1, 2))
            .Cells(dataRow, 1) = seriesName & "(Soll)"
            .Cells(dataRow + 1, 1) = seriesName & "(Ist)"
            For idx = 0 To 13
                .Cells(dataRow, idx + 2).FormulaR1C1 = "='" + mstSheet.name + "'!R" & srcRow & "C" & (idx + 3)
                .Cells(dataRow + 1, idx + 2).FormulaR1C1 = "='" + srcSheet.name + "'!R" & srcRow & "C" & (idx + 3)
            Next
            dataRow = dataRow + 2
        Loop
        
        dtSheet.Calculate
        protectSheet dtSheet
    End With

step = "create"
    watchFlag = gb_IgnoreSheetListChanged
    gb_IgnoreSheetListChanged = True
    
    With ActiveWorkbook
        Set chrt = .Charts.Add
        chrt.name = chartName
'Debug.Print chrt.ChartType
        chrt.ChartType = xlColumnClustered ' default
'        chrt.ChartType = xlLine

        chrt.HasTitle = True
        title = getMainTitleSource(srcSheet)
        title = title & Chr(10) & chartName
        title = title & Chr(10) & "Stand: " & monthName & " " & srcSheet.Cells(monthRow - 2, 3)    'year
        chrt.ChartTitle.caption = title
        chrt.ChartTitle.Format.TextFrame2.TextRange.Font.size = 14
        
        With chrt.Axes(xlCategory) ' x-axis
            .TickLabels.MultiLevel = True
            .TickLabelPosition = xlLow
        End With
        tmp = srcSheet.Cells(gn_yearRow + 1, 3)
        With chrt.Axes(xlValue) ' y-axis
            .HasTitle = True
            .AxisTitle.Text = tmp   ' "Euro"
            .AxisTitle.Orientation = xlUpward
            .CrossesAt = 0
        End With
        
        ' tab position at right end
        idx = .Charts.Count
        If idx > 0 Then
            chrt.Move after:=.Charts(idx)
        Else
            'chrt.Move after:=.Worksheets(.Worksheets.count)
            chrt.Move after:=getSheet(cs_MasterSheetName)
        End If
    End With
    
step = "series collection"
    With chrt
        Do While .SeriesCollection.Count > 0
            .SeriesCollection(1).Delete
        Loop
        
        ' loop through list of series'; no accumulation
        tmp = rowList
        dataRow = sectStart
        Do While tmp <> ""
            nextValue tmp, ","
            
            'Soll
            dataRow = dataRow + 1
            seriesName = getSeriesName(dtSheet.Cells(dataRow, 1), "(Soll)")
            Set seriesToBe = .SeriesCollection.NewSeries
            src = "='" + cs_GraphicsData + "'!R" & dataRow & "C3:R" & dataRow & "C14"
            With seriesToBe
                .Values = src
                .name = seriesName
                .Border.LineStyle = xlContinuous
                .Border.Weight = xlThin
                .MarkerStyle = xlCircle
                .MarkerSize = 7
'Debug.Print .name     ', .SeriesCollection(idx).Values
            End With
            
            'Ist
            dataRow = dataRow + 1
            seriesName = getSeriesName(dtSheet.Cells(dataRow, 1), "(Ist)")
            If month > 0 Then
                Set seriesAsIs = .SeriesCollection.NewSeries
                src = "='" + cs_GraphicsData + "'!R" & dataRow & "C3:R" & dataRow & "C" & (month + 2)
                With seriesAsIs
                    .Values = src
                    .name = seriesName
                    .Border.LineStyle = xlContinuous
                    .Border.Weight = xlThin
                    .MarkerStyle = xlCircle
                    .MarkerSize = 7
'Debug.Print .name     ', .SeriesCollection(idx).Values
                End With
            End If
        Loop
On Error Resume Next

step = "chart type"
        If .ChartType = xlLine Then
            With .Axes(xlValue)
                .Crosses = xlCustom
                .CrossesAt = .MinimumScale
            End With
        End If
        If .ChartType = xlColumnClustered Then
            With .Axes(xlValue)
                .CrossesAt = 0
                If .MaximumScale > 20000 Then
                    .DisplayUnit = xlThousands
                    .HasDisplayUnitLabel = True
                End If
            End With
            With .Axes(xlCategory)
                .TickLabels.MultiLevel = True
                .TickLabelPosition = xlLow
            End With
        End If
        
On Error GoTo CHART_ERROR

        ' tick labels, x-axis
        tmp = "='" + cs_GraphicsData + "'!R1C3:R1C14"
        .SeriesCollection(1).XValues = tmp
'Debug.Print CVar(.SeriesCollection(1).XValues

        ' plot area and legend
Dim x_0 As Long, y_0 As Long
Dim h_0 As Long
'Debug.Print "chart", .ChartArea.Left, .ChartArea.Top, .ChartArea.Width, .ChartArea.Height
'Debug.Print "plot", .PlotArea.Left, .PlotArea.Top, .PlotArea.Width, .PlotArea.Height

step = "plot area"
        With .PlotArea
            x_0 = .Left
            y_0 = .Top
            h_0 = .height
        
            .width = chrt.ChartArea.width - 140
            With .Format.line
                .visible = msoTrue
                .ForeColor.ObjectThemeColor = msoThemeColorAccent1
                .ForeColor.TintAndShade = 0
'                .ForeColor.Brightness = 0   '8.0.1.3: undefined in Excel 2007:
            End With
            With .Format.Fill
                .visible = msoTrue
                .ForeColor.ObjectThemeColor = msoThemeColorBackground2
                .ForeColor.TintAndShade = 0
'                .ForeColor.Brightness = 0   '8.0.1.3: undefined in Excel 2007:
                .Transparency = 0
                .Solid
            End With
        End With ' .PlotArea
        
        With .Legend
            .Left = chrt.ChartArea.width - 120
            .width = 110
            .height = chrt.SeriesCollection.Count * 15
            .Top = y_0 + h_0 / 2 - .height / 2
        
            With .Format.line
'Debug.Print .Visible, .Style, .DashStyle, .Weight, .Transparency
                .visible = msoTrue
                .Style = msoLineSingle
                .DashStyle = msoLineSolid
                .Weight = 1#
                .Transparency = 0
'Debug.Print .Visible, .Style, .DashStyle, .Weight, .Transparency
            End With
        End With ' .legend

        .Activate
        .Deselect
    End With ' chrt
    
    gb_IgnoreSheetListChanged = watchFlag
    Application.EnableEvents = eventsFlag
    
    On Error GoTo PWD_ERROR
    chrt.Protect Password:="", DrawingObjects:=True, Scenarios:=True, userinterfaceonly:=False
    On Error GoTo 0
    createMultiChart = True
Exit Function


CHART_ERROR:
Debug.Print "createMultiChart(..)", step, Err.Description
    Err.Clear
    Resume Next
    
PWD_ERROR:
Debug.Print "createMultiChart(..)", Err.Description
    Err.Clear
    msg = "Bitte heben Sie den Blattschutz von '" + chrt.name + "' auf."
    msg = msg + vbLf + "Andernfalls ist die Konsistenz des Modells nicht mehr gew|fffd|hrleistet."
    MsgBox msg, vbExclamation, cs_MsgTitle
    Resume Next
    
End Function

Function updateMultiChart(srcSheet As Worksheet, mstSheet As Worksheet, chrt As Chart, _
                month As Long, lastMonth As Long, chartHeaderRow As Long, sError As String) ' isAccrued As Boolean,
Dim dtaSheet As Worksheet, quantity As String, chartName As String, rowHeader As String
Dim seriesItem As Series, seriesId As String, seriesIndex As Long, seriesValues As String
Dim pos1 As Long, pos2 As Long

Dim row As Long, clm As Long, idx As Long, sdx As Long
Dim dataRow As Long, monthRow As Long, srcRow As Long
Dim monthName As String, isAccrued As Boolean
Dim title As String, temp As String, step As String, tmp As String
Dim eventsFlag As Boolean
Dim isProtected As Boolean

' new chart type (lines or clustered columns)
'   - several quantities: '...(Soll)' and '...(Ist)', not accrued
step = "multi-chart"

    isProtected = (chrt.ProtectContents Or chrt.ProtectDrawingObjects)
    If isProtected Then
        chrt.Unprotect cs_LiquiPWD
    End If

' must keep filter (.FullSeriesCollection)
' issue: does not exist in Office 2010/14.0 or earlier
'If False Then
'If Not chrt.SeriesCollection Is Nothing Then
'    Debug.Print chrt.SeriesCollection.Count
'    For sdx = 1 To chrt.SeriesCollection.Count
'        Set seriesItem = chrt.SeriesCollection(sdx)
'Debug.Print seriesItem.name     ', seriesItem.IsFiltered
'    Next
'End If
'If Not chrt.FullSeriesCollection Is Nothing Then
'    Debug.Print chrt.FullSeriesCollection.Count
'    For sdx = 1 To chrt.FullSeriesCollection.Count
'        Set seriesItem = chrt.FullSeriesCollection(sdx)
'        Debug.Print seriesItem.name, seriesItem.IsFiltered
'    Next
'End If
'End If

'Dim filter() As Boolean
'    If Not chrt.FullSeriesCollection Is Nothing Then
'        ReDim filter(1 To chrt.FullSeriesCollection.Count)
'        For sdx = 1 To UBound(filter)
'            filter(sdx) = chrt.FullSeriesCollection(sdx).IsFiltered
'        Next
'    End If

    Set dtaSheet = getSheet(cs_GraphicsData)
    dataRow = chartHeaderRow
    
    monthName = numberToMonth(month)
    isAccrued = False
    
    ' update chart title (new month)
    clm = 3
    chartName = chrt.name
    With chrt
        title = getMainTitleSource(srcSheet)
        title = title & Chr(10) & chartName     ' & IIf(isAccrued, ", akkumuliert", "")
        title = title & Chr(10) & "Stand: " & monthName & " " & srcSheet.Cells(gn_monthRow - 2, clm)    'year
        .ChartTitle.Text = title
    End With
    
    row = dataRow + 1
    seriesIndex = 0
    rowHeader = dtaSheet.Cells(row, 1)
    Do While (Not rowHeader = "")
        quantity = ""
        tmp = rowHeader
        pos1 = InStr(1, tmp, "(Soll)")
        pos2 = InStr(1, tmp, "(Ist)")
        If (pos1 > 0) Then
            quantity = Left$(rowHeader, pos1 - 1)
        ElseIf (pos2 > 0) Then
            quantity = Left$(rowHeader, pos2 - 1)
        End If
        
        srcRow = gn_row_Section_I_Start
        clm = 2
        findTextOrFormula srcSheet, quantity, True, True, srcRow, clm, , 2
        If srcRow = 0 Then
            sError = "Zeile '" & quantity & "' nicht gefunden."
sError = sError & vbLf & "Diagramm " & chrt.name & " unver|fffd|ndert."
            updateMultiChart = False
            If isProtected Then protectSheet chrt
Exit Function
        End If
        
' keep 'Soll' of first quantity as pattern (user-selected properties)
' remove all other series'
Dim seriesPattern As Series
' Excel 14.0: .FullSeriesCollection ~> .SeriesCollection
        If seriesIndex = 0 Then
            seriesId = getSeriesName(quantity, "(Soll)")
            With chrt
                For Each seriesItem In .SeriesCollection
                    If .SeriesCollection.Count <= 1 Then Exit For
                    If Not seriesItem.name = seriesId Then
'Debug.Print "delete", seriesItem.name   ', seriesItem.IsFiltered
                        seriesItem.Delete ' no concurrent modification issue !
                    End If
                Next
                If .SeriesCollection.Count > 0 Then
                    Set seriesPattern = .SeriesCollection(1)
'Debug.Print "pattern", seriesPattern.name
                End If
            End With
        End If

        eventsFlag = Application.EnableEvents
        Application.EnableEvents = False
        If (month = 0 Or lastMonth = 0) And Not mstSheet Is Nothing Then
            'no month or first time: initialize/reset chart data
            dtaSheet.Unprotect Password:=cs_LiquiPWD
            For idx = 0 To 13
                dtaSheet.Cells(row, idx + 2).FormulaR1C1 = "='" + mstSheet.name + "'!R" & srcRow & "C" & (idx + 3)
                dtaSheet.Cells(row + 1, idx + 2).FormulaR1C1 = "='" + srcSheet.name + "'!R" & srcRow & "C" & (idx + 3)
            Next
            protectSheet dtaSheet
        End If
        Application.EnableEvents = eventsFlag
        
        clm = 3
        With chrt
            ' Soll
            seriesIndex = seriesIndex + 1
            seriesId = getSeriesName(quantity, "(Soll)")
            On Error Resume Next
            Set seriesItem = Nothing
            Set seriesItem = .SeriesCollection(seriesId)
            On Error GoTo CHART_ERROR
            If seriesItem Is Nothing Then
                Set seriesItem = .SeriesCollection.NewSeries
                With seriesItem
                    .name = seriesId
                    If chrt.ChartType = xlLine Then
                        If Not seriesPattern Is Nothing Then
                            .Border.LineStyle = seriesPattern.Border.LineStyle
                            .Border.Weight = seriesPattern.Border.Weight
                            .MarkerStyle = seriesPattern.MarkerStyle
                            .MarkerSize = seriesPattern.MarkerSize
                        Else
                            .Border.LineStyle = xlContinuous
                            .Border.Weight = xlThin
                            .MarkerStyle = xlCircle
                            .MarkerSize = 7
                        End If
                    End If
                End With
            End If
            seriesValues = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C14"
            seriesItem.Values = seriesValues
            
            ' Ist
            row = row + 1
            If month = 0 Then
                GoTo NEXT_QUANTITY
            End If
            seriesIndex = seriesIndex + 1
            seriesId = getSeriesName(quantity, "(Ist)")
            On Error Resume Next
            Set seriesItem = Nothing
            Set seriesItem = .SeriesCollection(seriesId)
            On Error GoTo CHART_ERROR
            If month = 0 Then
                If Not seriesItem Is Nothing Then seriesItem.Delete
                GoTo NEXT_QUANTITY
            ElseIf seriesItem Is Nothing Then
                Set seriesItem = .SeriesCollection.NewSeries
                With seriesItem
                    .name = seriesId
                    If .ChartType = xlLine Then
                        If Not seriesPattern Is Nothing Then
                            .Border.LineStyle = seriesPattern.Border.LineStyle
                            .Border.Weight = seriesPattern.Border.Weight
                            .MarkerStyle = seriesPattern.MarkerStyle
                            .MarkerSize = seriesPattern.MarkerSize
                        Else
                            .Border.LineStyle = xlContinuous
                            .Border.Weight = xlThin
                            .MarkerStyle = xlCircle
                            .MarkerSize = 7
                        End If
                    End If
                End With
            End If
            seriesValues = "='" + cs_GraphicsData + "'!R" & row & "C3:R" & row & "C" & (month + 2)
            seriesItem.Values = seriesValues
        End With
        
NEXT_QUANTITY:
        row = row + 1
        rowHeader = dtaSheet.Cells(row, 1)
    Loop ' quantities of multi-chart on graphics data sheet
    
'    ' apply filter
'    For sdx = 1 To chrt.FullSeriesCollection.Count
'        Set seriesItem = chrt.FullSeriesCollection(sdx)
'        If sdx <= UBound(filter) Then
'            seriesItem.IsFiltered = filter(sdx)
'        End If
'    Next
    
    With chrt
On Error Resume Next
        ' may fail if set by user
        If .ChartType = xlLine Then
            With .Axes(xlValue)
                .Crosses = xlCustom
                .CrossesAt = .MinimumScale
            End With
        End If
        If .ChartType = xlColumnClustered Then
            With .Axes(xlValue)
                .CrossesAt = 0
                If .MaximumScale > 20000 Then
                    .DisplayUnit = xlThousands
                    .HasDisplayUnitLabel = True
                End If
            End With
            With .Axes(xlCategory)
                .TickLabels.MultiLevel = True
                .TickLabelPosition = xlLow
            End With
        End If
        On Error GoTo CHART_ERROR
        
        .ChartTitle.Left = (.ChartArea.width - .ChartTitle.width) / 2
        .Activate
        .Deselect
    End With
    
    If isProtected Then protectSheet chrt
    chrt.Activate
    ActiveWindow.Zoom = 90
    updateMultiChart = True
'Debug.Print "updateMultiChart(..)", chrt.name, dtaSheet.Cells(chartHeaderRow, 1)
Exit Function

CHART_ERROR:
Debug.Print chrt.name & " @ " & step & ": " & Err.Description
    Err.Clear
    Resume Next
    
End Function



Attribute VB_Name = "LibOptions_"
Option Explicit

' cf. exported code modules

Public Const cs_optionsSheetName As String = "LiquiOptionen"
Public gb_previousYearByLink As Boolean
'

Function initOptions()
Dim wsh As Worksheet
' Office version
    checkOfficeVersion

    ' 8.2.0.8g,transitional
    Set wsh = getSheet(cs_optionsSheetName)
    If Not wsh Is Nothing Then
        Application.DisplayAlerts = False
            wsh.Delete
        Application.DisplayAlerts = True
    End If

' formula protection, called during addLiquiMenus()
    If gn_formulaProtectionLevel = 0 Then
'        gn_formulaProtectionLevel = getOption(cs_keyModelProtection, 2)
    End If
'    setOption cs_keyModelProtection, gn_formulaProtectionLevel
    gb_formulaWatchDisabled = (gn_formulaProtectionLevel < 0)
    gb_modelWatchDisabled = gb_formulaWatchDisabled

'    gb_previousYearByLink = getOption(cs_keyPreviousYear, True)
'    setOption cs_keyPreviousYear, gb_previousYearByLink

' ...
End Function


Attribute VB_Name = "LibPretty"
' Adaptation of AudXL Formula Formatter

Option Explicit

Private Const fmt_BeginNewLine = 2 ^ 0
Private Const fmt_BeginTabDown = 2 ^ 1
Private Const fmt_EndNewLine = 2 ^ 2
Private Const fmt_EndTabUp = 2 ^ 3
Private Const fmt_BeginTabDownOnNonEmptyFunction = 2 ^ 4
Private Const fmt_BeginNewLineOnNonEmptyFunction = 2 ^ 5

Private Const fmt_TabLen = 4

Private Const fmt_FunctionBegin = fmt_BeginNewLine Or fmt_EndNewLine Or fmt_EndTabUp
Private Const fmt_FunctionEnd = fmt_BeginNewLineOnNonEmptyFunction Or fmt_BeginTabDownOnNonEmptyFunction ' Or fmt_EndNewLine
Private Const fmt_FunctionArgument = fmt_EndNewLine
Private Const fmt_ArrayBegin = fmt_BeginNewLine Or fmt_EndNewLine Or fmt_EndTabUp
Private Const fmt_ArrayEnd = fmt_BeginNewLine Or fmt_BeginTabDown
Private Const fmt_ArrayRow = fmt_EndNewLine

Private Const strNonBreakingSpace = "_"
'

'Private Function StripLFCR(str As String) As String
'    StripLFCR = Replace(Replace(str, vbLf, ""), vbCr, "")
'End Function

Function prettyLiquiFormula(Cell As Range) As String
Dim udtTokens() As token, strFormula As String, i As Long, strMain As String, strPart As String
Dim str As String, lngTab As Long, blnNewLine As Boolean, lngTemp As Long, bln As Boolean

Dim sh As Worksheet, rowSelected As Long, clmSelected As Long
Dim rngRef As Range
Dim sError As String

    Set sh = Cell.parent
    strMain = "Arbeitsblatt " & vbTab & sh.name
    With Cell
        rowSelected = .row
        clmSelected = .Column
        strMain = strMain & vbNewLine & "Zeile " & rowSelected
        If isSourceSheet(sh) Then strMain = strMain & "  " & vbTab & sh.Cells(rowSelected, 2)
        strMain = strMain & vbNewLine & "Spalte " & columnToLetter(clmSelected)
        If isSourceSheet(sh) Then strMain = strMain & "  " & _
                IIf(rowSelected < gn_row_Section_I_Start, "", vbTab & sh.Cells(1, clmSelected))
        strMain = strMain & vbNewLine & vbNewLine
        
        If .HasFormula Then
            strFormula = .FormulaLocal
        Else
            prettyLiquiFormula = strMain & .value
            Exit Function
        End If
    End With

    udtTokens() = ParseFormula(strFormula)
    strMain = strMain & "="

    If sh.name = gs_MainSheetName Then
        If validateMainSheet(sError) Is Nothing Then
            prettyLiquiFormula = ""
            Exit Function
        End If
    End If
    
    blnNewLine = True
    lngTab = 0
    For i = 0 To TokenCount(udtTokens)
        With udtTokens(i)
            If (.lngType And tkt_Function) = tkt_Function Then
                If strPart <> "" Then
                    WritePart strMain, strPart, lngTab, blnNewLine, 0
                    strPart = ""
                End If

                If (.lngType And tkt_Begin) = tkt_Begin Then
                    WritePart strMain, .strValue, lngTab, blnNewLine, fmt_FunctionBegin

                ElseIf (.lngType And tkt_End) = tkt_End Then
                    lngTemp = fmt_FunctionEnd
                    bln = (udtTokens(i - 1).lngType And (tkt_Function Or tkt_Begin)) = (tkt_Function Or tkt_Begin)

                    If (lngTemp And fmt_BeginNewLineOnNonEmptyFunction) = fmt_BeginNewLineOnNonEmptyFunction Then
                        If bln Then blnNewLine = False Else lngTemp = lngTemp Or fmt_BeginNewLine
                    Else
                        lngTemp = lngTemp Or fmt_BeginNewLine
                    End If
                    If (lngTemp And fmt_BeginTabDownOnNonEmptyFunction) = fmt_BeginTabDownOnNonEmptyFunction Then
                        If bln Then lngTab = lngTab - 1 Else lngTemp = lngTemp Or fmt_BeginTabDown
                    Else
                        lngTemp = lngTemp Or fmt_BeginTabDown
                    End If
                    WritePart strMain, .strValue, lngTab, blnNewLine, lngTemp

                End If

            ElseIf (.lngType And tkt_FunctionArgument) = tkt_FunctionArgument Then
                If strPart <> "" Then
                    WritePart strMain, strPart, lngTab, blnNewLine, 0
                    strPart = ""
                End If

                WritePart strMain, .strValue, lngTab, blnNewLine, fmt_FunctionArgument

            ElseIf (.lngType And tkt_Array) = tkt_Array Then
                If strPart <> "" Then
                    WritePart strMain, strPart, lngTab, blnNewLine, 0
                    strPart = ""
                End If

                If (.lngType And tkt_Begin) = tkt_Begin Then
                    WritePart strMain, .strValue, lngTab, blnNewLine, fmt_ArrayBegin

                ElseIf (.lngType And tkt_End) = tkt_End Then
                    WritePart strMain, .strValue, lngTab, blnNewLine, fmt_ArrayEnd

                End If

            ElseIf (.lngType And tkt_ArrayRow) = tkt_ArrayRow Then
                If strPart <> "" Then
                    WritePart strMain, strPart, lngTab, blnNewLine, 0
                    strPart = ""
                End If

                WritePart strMain, .strValue, lngTab, blnNewLine, fmt_ArrayRow

            ElseIf (.lngType And tkt_OperandText) = tkt_OperandText Then
                strPart = strPart & """" & Replace(.strValue, """", """""") & """"

            ElseIf (.lngType And tkt_OperandReferenceWksQual) = tkt_OperandReferenceWksQual Then
                str = .strValue
                If InStr(1, str, "'") > 0 Or InStr(1, str, " ") > 0 Then str = "'" & Replace(str, "'", "''") & "'"
                strPart = strPart & str
            
            ElseIf (.lngType And tkt_OperandReferenceRange) = tkt_OperandReferenceRange Then
                Set rngRef = sh.Range(.strValue).Cells(1, 1)
                strPart = strPart & prettyReference(Cell, udtTokens(i), rngRef)
            
            ElseIf (.lngType And tkt_OperatorInfix) = tkt_OperatorInfix And .strValue <> "!" Then
                strPart = strPart & " " & .strValue & " "
                
            Else
                strPart = strPart & .strValue

            End If
        End With
    Next
    If strPart <> "" Then WritePart strMain, strPart, lngTab, blnNewLine, 0

    prettyLiquiFormula = strMain
End Function

Private Sub WritePart(strMain As String, strPart As String, lngTab As Long, blnNewLine As Boolean, lngFormat As Long)
    If (lngFormat And fmt_BeginTabDown) = fmt_BeginTabDown Then lngTab = lngTab - 1
    If (lngFormat And fmt_BeginNewLine) = fmt_BeginNewLine Then blnNewLine = True
    If Not strMain = "" And blnNewLine Then
        strMain = strMain & vbNewLine & String(lngTab * fmt_TabLen, " ")
        blnNewLine = False
    End If
    strMain = strMain & strPart
    If (lngFormat And fmt_EndNewLine) = fmt_EndNewLine Then blnNewLine = True
    If (lngFormat And fmt_EndTabUp) = fmt_EndTabUp Then lngTab = lngTab + 1
End Sub

Private Function prettyReference(Cell As Range, tk As token, rngRef As Range) As String
Dim sh As Worksheet, rowSelected As Long, clmSelected As Long
Dim str As String

    Set sh = Cell.parent
    If sh.name = gs_MainSheetName Then
        rowSelected = Cell.row
        clmSelected = Cell.Column
        With rngRef
            If .row < gn_row_Section_I_Start And .Column = 3 Then
                str = "(" & .row & ")" & Replace(sh.Cells(.row, 2), " ", strNonBreakingSpace)
            ElseIf .row >= gn_row_Section_I_Start And .Column = clmSelected Then
                str = "(" & .row & ")" & Replace(sh.Cells(.row, 2), " ", strNonBreakingSpace)
            ElseIf .row >= gn_row_Section_I_Start And .row = rowSelected Then
                str = "(" & columnToLetter(.Column) & ")" & sh.Cells(1, .Column)
            ElseIf .row >= gn_row_Section_I_Start And .Column <= cn_dataWidth Then
                str = "(" & columnToLetter(.Column) & .row & ")" & _
                        Replace(sh.Cells(.row, 2), " ", strNonBreakingSpace)
            Else
                str = tk.strValue
            End If
        End With
    Else
        str = tk.strValue
    End If
    
    prettyReference = str
End Function

Attribute VB_Name = "LibProfitCenter"
Option Explicit

'   Profit Center

'   Pro PC: Blatt PC, Soll-Ist PC, Plandaten PC
'   jeweils links von U&L(Haupt-Blatt), Soll-Ist, PlanDaten 'KONSOLODIERT'
'   Spezielles (Pseudo) PC, unmittelbar links von U&L:
'       AK: allgemeine Kosten, nach Schluessel in U&L auf PC verteilt
'   => mindestens 3 Arbeitsblaetter (2 PC + AK) links von U&L

'   Verhalten Formeln in U&L:
'       falls PC umbenannt wird, werden alle Formeln automatisch von Excel aktualisiert
'       falls ein PC entfernt wird, werden Formeln fehlerhaft ("Verweis")
'       falls PC hinzugefuegt wird, fehlt es in Formeln
'           => Formeln durch Prozedur aktualisieren
'               Kriterium: Formel enthaelt Verweis auf PC' (Blatt links von U&L)

'   Synchron:
'       Wirtsschaftsjahr+Monat, Berichtsmonat
'       Plandaten speichern

' ======================================================================

Function isProfitCenterModel() As Boolean
    If (gs_ModelType = "") Then
        getProfitCenters
    End If
    isProfitCenterModel = (gs_ModelType = cs_ModelType_ProfitCenter)
End Function

Function getProfitCenters() As String
Dim pattern As String, pcName As String, cellRef As String
Dim wb As Workbook, sh As Worksheet, cl As Range, rng As Range
Dim isProtected As Boolean
Dim indexMain As Long, idx As Long, pos As Long, pos2 As Long
Dim isFirst As Boolean, msg As String
Dim row As Long, clm As Long
Dim tmp As String

    Set wb = ActiveWorkbook
    getProfitCenters = ""
    gs_GeneralCosts = ""
    indexMain = 1
    For idx = 1 To wb.Worksheets.Count
        Set sh = wb.Worksheets(idx)
        If sh.name = cs_MainSheet_BasicModel Then
            ' Modell ohne Konsolidierung
            gs_MainSheetName = cs_MainSheet_BasicModel
            gs_ModelType = ""
            If idx > 1 Then
Debug.Print "moved left: " & wb.Worksheets(1).name
                sh.Move before:=wb.Worksheets(1)
            End If
            gn_MainSheetIndex = 1
            Exit Function
        End If
    Next
    For idx = 1 To wb.Worksheets.Count
        Set sh = wb.Worksheets(idx)
        If sh.name = cs_MainSheet_ProfitCenter Then
            gs_MainSheetName = cs_MainSheet_ProfitCenter
            indexMain = idx
            Exit For
        End If
    Next
    
    gn_MainSheetIndex = indexMain
    If indexMain <= 1 Then
        ' kein Eingabeblatt oder keine Arbeitsbl|fffd|tter links vom Eingabeblatt; nichts zu konsolidieren
        Exit Function
    End If
    
    gs_GeneralCosts = wb.Worksheets(indexMain - 1).name
    pattern = ""
    If indexMain > 2 Then
        pattern = "'" & wb.Worksheets(1).name & "'"
'        For idx = 2 To indexMain - 2 ' ohne Allg.Kosten
        For idx = 2 To indexMain - 1 ' mit Allg.Kosten
            pattern = pattern & "+'" & wb.Worksheets(idx).name & "'"
        Next
    End If
    getProfitCenters = pattern
End Function

Function isSourceSheet(sh As Worksheet) As Boolean
    isSourceSheet = (isProfitCenter(sh) Or sh.name = gs_MainSheetName)
End Function

Function getSourceSheet(wsh As Worksheet) As Worksheet
Dim name As String
    Set getSourceSheet = Nothing    '  wsh.parent.Worksheets(gn_MainSheetIndex)
    On Error Resume Next
    If (isSourceSheet(wsh)) Then
        Set getSourceSheet = wsh
    ElseIf (wsh.name = cs_MasterSheetName) Then
        Set getSourceSheet = wsh.parent.Worksheets(gn_MainSheetIndex)
    ElseIf (startsWith(wsh.name, cs_MasterPrefix)) Then
        name = Mid(wsh.name, Len(cs_MasterPrefix) + 1)
        name = Left(name, Len(name) - 1)
        Set getSourceSheet = wsh.parent.Worksheets(name)
    ElseIf (wsh.name = cs_CompareSheetName) Then
        Set getSourceSheet = wsh.parent.Worksheets(gn_MainSheetIndex)
    ElseIf (startsWith(wsh.name, cs_CompareSheetName & "(")) Then
        ' get profit center name
        name = Mid(wsh.name, Len(cs_CompareSheetName) + 2)
        name = Left(name, Len(name) - 1)
        Set getSourceSheet = wsh.parent.Worksheets(name)
    End If
End Function

Function isProfitCenter(sh As Worksheet) As Boolean
Dim awb As Workbook, pos As Long
    If gs_ProfitCenters = "" Then
        gs_ProfitCenters = getProfitCenters()
    End If
    isProfitCenter = isProfitCenterName(sh.name)
If Not isProfitCenter Then Exit Function
    
    ' profit centers must be located left of consolidation (main source sheet)
    If gn_MainSheetIndex > 0 Then
        Set awb = Application.ActiveWorkbook
        pos = getSheetPosition(sh)
        If pos > gn_MainSheetIndex Then
            awb.Worksheets(gn_MainSheetIndex).visible = xlSheetVisible
            sh.Move before:=awb.Worksheets(gn_MainSheetIndex)
Debug.Print "main sheet moved left: " & sh.name
        End If
    End If
End Function

Function isProfitCenterName(name As String) As Boolean
Dim awb As Workbook, pos As Long
    If gs_ProfitCenters = "" Then
        gs_ProfitCenters = getProfitCenters()
    End If
    If (gs_ProfitCenters = "") Then
        isProfitCenterName = False
    Else
        isProfitCenterName = (name = gs_GeneralCosts Or (name <> "" And InStr(1, gs_ProfitCenters, name) > 0))
    End If
End Function

Function isMasterSheetName(name As String) As Boolean
Dim awb As Workbook, srcName As String, pos As Long
    If (name = cs_MasterSheetName) Then
        isMasterSheetName = True
    Else
        srcName = getInputSheetName(name)
        isMasterSheetName = isProfitCenterName(srcName)
    End If
End Function

Function getSheetPosition(sh As Object) As Long
Dim awb As Workbook, idx As Long
    Set awb = Application.ActiveWorkbook
    For idx = 1 To awb.Sheets.Count
        If awb.Sheets(idx).name = sh.name Then
            getSheetPosition = idx
            Exit Function
        End If
    Next
End Function

Function isConsolidationFormula(formula As String) As Boolean
' wahr wenn Formel Bezug auf mindestens ein echtes PC enthaelt (d.h. ohne Allg.Kosten unmittelbar links von U&L)
Dim abk As Workbook, wsh As Worksheet, idx As Long
    Set abk = ActiveWorkbook
    isConsolidationFormula = False
    If (Not startsWith(formula, "=") Or InStr(1, formula, "!") = 0) Then
Exit Function
    End If
    For idx = 1 To gn_MainSheetIndex - 2 ' [sic!] Blatt 'Allg. Kosten' kann auch in anderen Formeln vorkommen
        Set wsh = abk.Worksheets(idx)
        If InStr(1, formula, wsh.name) > 0 Then
            isConsolidationFormula = True
Exit Function
        End If
    Next
End Function

Private Sub testBuild()
Dim formulaArray(1 To 12) As String, pcList As String
    pcList = getProfitCenters()
    buildConsolidation trgRow:=50, isMaster:=False
End Sub

Private Function buildConsolidation(trgRow As Long, isMaster As Boolean)
' must be Varaint array, otherwise will cells contain values of type String
Dim formulaArray(1 To 12)   ' As String
Dim pattern As String, cellName As String, cellRef As String, sheetRef As String
Dim abk As Workbook
Dim indexMain As Long, idx As Long, clm As Long

    Set abk = Application.ActiveWorkbook
    indexMain = gn_MainSheetIndex
    
    For clm = 1 To UBound(formulaArray)
        sheetRef = abk.Worksheets(1).name
        If isMaster Then sheetRef = getMasterSheetName(sheetRef)
        sheetRef = "'" & sheetRef & "'"
        cellName = Chr((Asc("A") - 1) + (cn_clm_January + clm - 1)) & trgRow
        cellRef = "!" & cellName
        pattern = "=" & sheetRef & cellRef
            For idx = 2 To gn_MainSheetIndex - 1 ' [sic!] mit AK
                sheetRef = abk.Worksheets(idx).name
                If isMaster Then sheetRef = getMasterSheetName(sheetRef)
                sheetRef = "'" & sheetRef & "'"
                pattern = pattern & "+" & sheetRef & cellRef
            Next
'Debug.Print monthName(clm, True), pattern
        formulaArray(clm) = pattern
    Next
    buildConsolidation = formulaArray
End Function

Private Sub testPC()
Dim pattern As String, prompt As Boolean
    prompt = (gs_ProfitCenters <> "")
    pattern = getProfitCenters()
'Debug.Print gs_ProfitCenters, pattern
'    If pattern <> gs_ProfitCenters Then
        If updateConsolidation() And prompt Then
            MsgBox "Konsolidierung wurde aktualisiert"
        End If
'    End If
End Sub

Function updateConsolidation(Optional isMaster As Boolean = False) As Boolean
Dim pattern As String, cellRef As String, sheetRef As String
Dim abk As Workbook, wsh As Worksheet, cl As Range, rng As Range
Dim isProtected As Boolean, isUpdate As Boolean
Dim indexMain As Long, idx As Long, pos As Long, pos2 As Long
Dim row As Long, clm As Long
Dim tmp As String

    Set abk = Application.ActiveWorkbook
    tmp = getProfitCenters()
    indexMain = 1
    For idx = 1 To abk.Worksheets.Count
        Set wsh = abk.Worksheets(idx)
        If wsh.name = cs_MainSheet_ProfitCenter Then
            indexMain = idx
            Exit For
        End If
    Next
    gn_MainSheetIndex = indexMain
    gs_ProfitCenters = ""
    gs_GeneralCosts = ""
    If indexMain = 1 Then
        ' nichts zu konsolidieren
        updateConsolidation = True
Exit Function
    ElseIf indexMain = 0 Or indexMain < 4 Then
        ' Strukturfehler, waehrend Aufbau
        ' muss verhindern dass bestehende Kons.Formeln weniger als zwei PC enthalten
        updateConsolidation = False
        Exit Function
    End If
    gs_ProfitCenters = getProfitCenters()
    gs_GeneralCosts = abk.Worksheets(indexMain - 1).name
    
    ' alle Blaetter, auf die sich neue Formel bezieht, muessen bereits existieren,
    ' sonst versucht Excel sie zu finden (um alle Werte zu aktualisieren)
    isUpdate = True
    On Error Resume Next
    If isMaster Then
        For idx = 1 To indexMain - 1
            Set wsh = Nothing
            Set wsh = abk.Worksheets(getMasterSheetName(abk.Worksheets(idx).name))
            If wsh Is Nothing Then
                isUpdate = False
                Exit For
            End If
        Next
    End If
    On Error GoTo 0
'Debug.Print gs_GeneralCosts

    If Not isMaster Then
        Set wsh = abk.Worksheets(cs_MainSheet_ProfitCenter)
    Else
        Set wsh = abk.Worksheets(cs_MasterSheetName)
    End If
    isProtected = wsh.ProtectContents
    wsh.Unprotect cs_LiquiPWD
    
    Application.EnableEvents = False
    
    If isUpdate Then
        Application.Calculation = xlCalculationManual
        Set rng = wsh.usedRange
        For row = 1 To rng.Rows.Count
        For clm = 4 To rng.Columns.Count    ' start with January
            Set cl = wsh.Cells(row, clm)
            If Not cl.HasFormula Then
                GoTo CONTINUE
            End If
            tmp = cl.formula
            If Not isConsolidationFormula(tmp) Then
                GoTo CONTINUE
            End If
If (True) Then
Dim formulaArray
    formulaArray = buildConsolidation(row, isMaster)
'Debug.Print monthName(5), formulaArray(5)
    With wsh
        .Range(.Cells(row, clm), .Cells(row, clm + 11)).formula = formulaArray
    End With
    clm = rng.Columns.Count
Else
'            pos = InStr(1, tmp, "!")
'            pos2 = InStr(pos, tmp, "+")
'            If pos = 0 Or pos2 = 0 Then
'                GoTo CONTINUE
'            End If
'            cellRef = Mid$(tmp, pos, pos2 - pos)
'Debug.Print cellRef
''Debug.Print tmp
'
'            sheetRef = abk.Worksheets(1).name
'            If isMaster Then sheetRef = getMasterSheetName(abk.Worksheets(1).name)
'            sheetRef = "'" & sheetRef & "'"
'            pattern = "=" & sheetRef & cellRef
''            For idx = 2 To indexMain - 2 ' [sic!] ohne 'Allgemeine Kosten' (Verwaltung)
'            For idx = 2 To indexMain - 1 ' [sic!] mit AK
'                sheetRef = abk.Worksheets(idx).name
'                If isMaster Then sheetRef = getMasterSheetName(abk.Worksheets(idx).name)
'                sheetRef = "'" & sheetRef & "'"
'                pattern = pattern & "+" & sheetRef & cellRef
'            Next
'Debug.Print pattern
'            cl.formula = pattern
End If  ' new | old
CONTINUE:    Next
        Next
'        Application.CalculateFull ' Debug.prints all errors  ' really needed ?
        Application.Calculation = xlCalculationAutomatic
    End If
    
    If isProtected Then
        protectSheet wsh
    End If
    
    Application.EnableEvents = True
    
    updateConsolidation = isUpdate
End Function


' ===== Friedhof =====


Attribute VB_Name = "LibUtils"
Option Explicit


Function regWriteValue(key As String, value As String)
    SaveSetting cs_RegAppName, Application.ActiveWorkbook.name, key, value
End Function

Function regReadValue(key As String, Optional defValue As String = "") As String
    regReadValue = GetSetting(cs_RegAppName, Application.ActiveWorkbook.name, key, defValue)
End Function

Function regClear()
    DeleteSetting cs_RegAppName, Application.ActiveWorkbook.name
End Function

Function getCodeVariant() As String
    If gs_CodeVariant = "" Then
        gs_CodeVariant = regReadValue("CodeVariant")
    End If
    If gs_CodeVariant = "" Then
        gs_CodeVariant = cs_CodeVariant
    End If
    regWriteValue "CodeVariant", gs_CodeVariant
    
    getCodeVariant = gs_CodeVariant
End Function



'VBA.Interaction:
'Function GetAllSettings(AppName As String, Section As String)
'Sub DeleteSetting(AppName As String, [Section], [Key])

'https://docs.microsoft.com/de-de/office/vba/language/reference/user-interface-help
'Dim MySettings As Variant, intSettings As Integer
'MySettings = GetAllSettings(appname:="MyApp", section:="Startup")
'    For intSettings = LBound(MySettings, 1) To UBound(MySettings, 1)
'        Debug.Print MySettings(intSettings, 0), MySettings(intSettings, 1)
'    Next intSettings
'DeleteSetting "MyApp", "Startup"


Function getUser() As String
    getUser = Environ$("UserName")
End Function

Function isDeveloper() As Boolean
Dim envString, idx
    isDeveloper = (getUser() = "Hartmann")
End Function



Sub storeColorMap(wsh As Variant)
Dim usedRange As Range, lastRowUsed As Long
Dim rng As Range, row As Long, clm As Long
Dim defClr As Long, clr As Long

    If Not (TypeOf wsh Is Worksheet) Then Exit Sub
    With wsh
        Set usedRange = .usedRange
        lastRowUsed = getLastRow(usedRange)
        ReDim ga_colorMap(1 To lastRowUsed, 1 To cn_clm_Year)
'    Set rng = .Range(.Cells(1, 1), .Cells(lastRowUsed, cn_clm_Year))
'    ga_colorMap() = rng.Interior.Color
        For row = 1 To lastRowUsed
            defClr = -1
            For clm = 1 To cn_clm_Year
                clr = .Cells(row, clm).Interior.Color
                If clr = gn_color_outlier Then
                    Set rng = .Range(.Cells(row, cn_clm_January - 1), .Cells(row, cn_clm_Year))
                    If defClr < 0 Then defClr = getMajorityColor(rng)
                    clr = defClr
                End If
                ga_colorMap(row, clm) = clr
            Next
        Next
'Debug.Print showRGB(ga_colorMap(68, 2)), showRGB(ga_colorMap(68, 3)), showRGB(ga_colorMap(68, 4)), showRGB(ga_colorMap(68, 5)), showRGB(ga_colorMap(68, 6))
    End With
End Sub

Sub findTextOrFormula(wkSheet As Worksheet, pattern As String, valueMode As Boolean, downThenOver As Boolean, _
        row As Long, clm As Long, Optional maxRow As Long = 0, Optional maxClm As Long = 0)
' 2016-11 fixed: Instr(..)>0 ~> StartsWith(..), must not find "I. " in "II. "
    ' get maxRow, maxClm from usedRange
    Dim usedRange As Range
    Dim idx As Long, idy As Long, found As Boolean
    Dim tmp As String
    
    found = False
    If row <= 0 Then row = 1
    If clm <= 0 Then clm = 1
    
    Set usedRange = wkSheet.usedRange
    With usedRange
        If maxRow = 0 Then maxRow = .row + .Rows.Count - 1
        If maxClm = 0 Then maxClm = .Column + .Columns.Count - 1
    End With
    
    If row > maxRow Or clm > maxClm Then
        row = 0
        clm = 0
        Exit Sub
    End If
    
    With wkSheet
        If downThenOver Then 'clm by clm
            For idy = clm To maxClm
                For idx = row To maxRow
                    tmp = ""
                    On Error Resume Next  ' value may be invalid (e.g. division by 0)
                    If valueMode Then
                        tmp = .Cells(idx, idy).value
                    Else
                        tmp = .Cells(idx, idy).formula
                    End If
                    On Error GoTo 0
                    If (pattern = "" And IsEmpty(.Cells(idx, idy))) Or _
                            (pattern <> "" And startsWith(LCase(tmp), LCase(pattern))) Then
                        found = True
                        Exit For
                    End If
                Next
                If found Then Exit For
            Next
        Else    'right then over, row by row
            For idx = row To maxRow
                For idy = clm To maxClm
                    tmp = ""
                    On Error Resume Next  ' value may be invalid (e.g. division by 0)
                    If valueMode Then
                        tmp = .Cells(idx, idy)
                    Else
                        tmp = .Cells(idx, idy).formula
                    End If
                    On Error GoTo 0
                    If (pattern = "" And IsEmpty(.Cells(idx, idy))) Or _
                            (pattern <> "" And startsWith(LCase(tmp), LCase(pattern))) Then
                        found = True
                        Exit For
                    End If
                Next
                If found Then Exit For
            Next
        End If
    End With
    
    If found Then
        row = idx
        clm = idy
    Else
        row = 0
        clm = 0
    End If
End Sub

' http://rosettacode.org/wiki/Sorting_algorithms/Quicksort#VBA
Sub quickSort(a() As Variant, last As Integer)
' quicksort a Variant array (1-based, numbers or strings)
Dim aLess() As Variant
Dim aEq() As Variant
Dim aGreater() As Variant
Dim pivot As Variant
Dim naLess As Integer
Dim naEq As Integer
Dim naGreater As Integer
' hjg: Option Explicit
Dim EL As Variant, P As Long, i As Long
 
If last > 1 Then
    'choose pivot in the middle of the array
    pivot = a(Int((last + 1) / 2))
    'construct arrays
    naLess = 0
    naEq = 0
    naGreater = 0
    For Each EL In a()
      If EL > pivot Then
        naGreater = naGreater + 1
        ReDim Preserve aGreater(1 To naGreater)
        aGreater(naGreater) = EL
      ElseIf EL < pivot Then
        naLess = naLess + 1
        ReDim Preserve aLess(1 To naLess)
        aLess(naLess) = EL
      Else
        naEq = naEq + 1
        ReDim Preserve aEq(1 To naEq)
        aEq(naEq) = EL
      End If
    Next
    'sort arrays "less" and "greater"
    quickSort aLess(), naLess
    quickSort aGreater(), naGreater
    'concatenate
    P = 1
    For i = 1 To naLess
      a(P) = aLess(i): P = P + 1
    Next
    For i = 1 To naEq
      a(P) = aEq(i): P = P + 1
    Next
    For i = 1 To naGreater
      a(P) = aGreater(i): P = P + 1
    Next
End If
End Sub
 
Private Sub quickSortTest()
Const size As Long = 5
Dim a(1 To size) As Variant
' hjg
Dim i As Long
 
' 'populate a with numbers in descending order, then sort
' For i = 1 To size: a(i) = size - i: Next
' quickSort a(), size
' For i = 1 To size: Debug.Print a(i);: Next
' Debug.Print
 'now populate a with strings in descending order, then sort
 For i = 1 To size: a(i) = Chr$(Asc("z") - (26 - size) + 1 - i) & "": Next ' -stuff
 For i = 1 To size: Debug.Print a(i); " ";: Next
 Debug.Print
 quickSort a(), size
 For i = 1 To size: Debug.Print a(i); " ";: Next
 Debug.Print
End Sub


' quicksort pairs (value, sort-arg)
Sub quickSortPairs(a() As Variant)
' quicksort a Variant 2-dimensional array (1-based, numbers or strings)
Dim aLess() As Variant
Dim aEq() As Variant
Dim aGreater() As Variant
Dim pivot As Variant
Dim naLess As Integer
Dim naEq As Integer
Dim naGreater As Integer

Dim EL As Variant, P As Long, i As Long
Dim size As Long, idx As Long
 
    size = UBound(a, 2)
    If size > 1 Then
        'choose pivot in the middle of the array
        pivot = a(2, Int((size + 1) / 2))
        'construct arrays
        naLess = 0
        naEq = 0
        naGreater = 0
        For idx = 1 To size
            EL = a(2, idx)
            If EL > pivot Then
                naGreater = naGreater + 1
                ReDim Preserve aGreater(1 To 2, 1 To naGreater)
                aGreater(1, naGreater) = a(1, idx): aGreater(2, naGreater) = EL
            ElseIf EL < pivot Then
                naLess = naLess + 1
                ReDim Preserve aLess(1 To 2, 1 To naLess)
                aLess(1, naLess) = a(1, idx): aLess(2, naLess) = EL
            Else
                naEq = naEq + 1
                ReDim Preserve aEq(1 To 2, 1 To naEq)
                aEq(1, naEq) = a(1, idx): aEq(2, naEq) = EL
            End If
        Next
        
        'sort arrays "less" and "greater"
        If naLess > 0 Then quickSortPairs aLess() ', naLess
        If naGreater > 0 Then quickSortPairs aGreater()   ', naGreater
        
        'concatenate
        P = 1
        For i = 1 To naLess
           a(1, P) = aLess(1, i): a(2, P) = aLess(2, i): P = P + 1
        Next
        For i = 1 To naEq
            a(1, P) = aEq(1, i): a(2, P) = aEq(2, i): P = P + 1
        Next
        For i = 1 To naGreater
            a(1, P) = aGreater(1, i): a(2, P) = aGreater(2, i): P = P + 1
        Next
    End If
End Sub
 
Private Sub quickSortPairsTest()
Const size As Long = 9
Dim a() As Variant
Dim i As Long
    If size <= 0 Then Exit Sub
    
    ReDim Preserve a(1 To 2, 1 To size)
    'populate a with strings in descending order, then sort
    For i = 1 To size: a(1, i) = i: a(2, i) = Chr$(Asc("z") - (26 - size) + 1 - i) & "": Next ' -stuff
    For i = 1 To size: Debug.Print "(" & a(1, i) & "," & a(2, i) & ")"; " ";: Next
    Debug.Print
    
'ReDim Preserve a(1 To 2, 1 To i)
'a(1, i) = i: a(2, i) = "x": i = i + 1
'For i = 1 To size + 1: Debug.Print "(" & a(1, i) & "," & a(2, i) & ")"; " ";: Next

    quickSortPairs a()
    For i = 1 To size: Debug.Print "(" & a(1, i) & "," & a(2, i) & ")"; " ";: Next
    Debug.Print
End Sub



 
Function nextValue(recval As String, delim As String) As String
'warning: delim must be a string of length 1
'items are delimited by specified character; text that may contain dekimiters is protected by quotes
'recval is reduced as a side effect of each call
Dim startpos As Long
Dim tmpstring As String
Dim tail As Long

    If Left(recval, 1) = Chr(34) Then     'string constant
        recval = Right(recval, Len(recval) - 1)
        startpos = InStr(recval, Chr(34))
        tmpstring = Left(recval, startpos - 1)
        tail = Len(recval) - startpos - 1
        If tail < 0 Then tail = 0
        recval = Right(recval, tail) 'quote followed by space or at end
        nextValue = tmpstring
    Else
        startpos = InStr(recval, delim)   'space delimited
        If startpos > 0 Then
            tmpstring = Left(recval, startpos - 1)
            recval = Right(recval, Len(recval) - startpos)
            nextValue = tmpstring
        ElseIf Len(recval) > 0 Then
            tmpstring = recval
            recval = ""
            nextValue = tmpstring
        Else
            nextValue = ""
        End If
    End If
End Function

Function getValidSheetName(name As String) As String
Dim tmp As String
    tmp = Trim$(name)
    tmp = Replace(tmp, ":", "-")  'must happen first
    tmp = Replace(tmp, "\", "|")
    tmp = Replace(tmp, "/", "|")
    tmp = Replace(tmp, "?", "_")
    tmp = Replace(tmp, "*", "_")
    
    tmp = Replace(tmp, "[", "{")
    tmp = Replace(tmp, "]", "}")
    
    getValidSheetName = tmp
End Function
    
Function getSheet(name As String, Optional book As Workbook = Nothing)
Dim wb As Workbook, sh As Object
    Set getSheet = Nothing
    Set wb = Application.ActiveWorkbook
    If Not book Is Nothing Then Set wb = book
    
    On Error Resume Next
    Set getSheet = wb.Sheets(name)
    On Error GoTo 0
    If getSheet Is Nothing Then
        ' try code name
        For Each sh In wb.Sheets
            If sh.CodeName = name Then
                Set getSheet = sh
                Exit For
            End If
        Next
    End If
End Function

Function makeNewSheet(wb As Workbook, name As String, Optional before As Object = Nothing, Optional after As Object = Nothing) As Object
Dim sh As Object, lastSheet As Worksheet, newSheet As Worksheet
Dim Count As Long
Dim curChangeDisabled As Boolean, eventsFlag As Boolean
    
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = True

    Count = 0
    For Each sh In wb.Worksheets  'ActiveWorkbook
        If InStr(1, sh.name, name) > 0 Then
            Set lastSheet = sh
            Count = Count + 1
        End If
    Next

    With ActiveWorkbook
        If Not before Is Nothing Then
            Set newSheet = .Worksheets.Add(before, , 1, xlWorksheet)
        ElseIf Not after Is Nothing Then
            Set newSheet = .Worksheets.Add(, after, 1, xlWorksheet)
        Else
            Set newSheet = .Worksheets.Add(, .Worksheets(.Worksheets.Count), 1, xlWorksheet)
        End If
        If Count = 0 Then
            newSheet.name = name
        Else
            newSheet.name = name & " (" & Count + 1 & ")"
            newSheet.Move , lastSheet
        End If
    End With
    
    Application.EnableEvents = eventsFlag
    Set makeNewSheet = newSheet
End Function


Function columnToLetter(clm As Long) As String
    columnToLetter = Chr$(Asc("A") + clm - 1)
End Function


Function startsWith(string1 As Variant, string2 As String, Optional compare As VbCompareMethod) As Boolean
Dim tmp As String
    If Not IsError(string1) Then
        tmp = string1
        startsWith = (InStr(1, tmp, string2, compare) = 1)
    Else
        startsWith = False
    End If
End Function

Function endsWith(string1 As Variant, string2 As String, Optional compare As VbCompareMethod) As Boolean
Dim tmp As String
    If Not IsError(string1) Then
        endsWith = (InStr(1, StrReverse(string1), StrReverse(string2)) = 1)
    Else
        endsWith = False
    End If
End Function
Private Sub testLastInStr()
Dim string1 As String

    string1 = "/xx / / xxx/xx//xx/x"
Debug.Print InStr(string1, "/"), lastInStr(string1, "/")
Debug.Print InStr(string1, " /"), lastInStr(string1, " /")

End Sub
Function lastInStr(string1 As String, string2 As String) As Long
Dim pos As Long
    
    If (string2 = "") Then
        lastInStr = Len(string1) + 1
Exit Function
    End If
    
    lastInStr = 0
    pos = InStr(1, string1, string2)
    Do While (pos > 0)
        lastInStr = pos
        pos = InStr(pos + Len(string2), string1, string2)
    Loop
End Function

Function isRangeEmpty(rg As Range) As Boolean
Dim row As Long, clm As Long

    isRangeEmpty = True
    With rg
        For row = 1 To rg.Rows.Count
        For clm = 1 To rg.Columns.Count
            If Not IsEmpty(rg.Cells(row, clm)) Then
                isRangeEmpty = False
                Exit Function
            End If
        Next: Next
    End With
    
End Function

Function IsRangeNumeric(rng As Range) As Boolean
Dim row As Long, clm As Long
    For row = 1 To rng.Rows.Count
    For clm = 1 To rng.Columns.Count
        If Not IsNumeric(rng.Cells(row, clm)) Then
            IsRangeNumeric = False
            Exit Function
        End If
    Next: Next
    IsRangeNumeric = True
End Function

Function IsRowNumeric(wsh As Worksheet, row As Long) As Boolean
Dim rng As Range
    With wsh
        Set rng = .Range(.Cells(row, cn_clm_January - 1), .Cells(row, cn_clm_Year))
        If Not IsRangeNumeric(rng) Then
            IsRowNumeric = False
            Exit Function
        End If
    End With
    IsRowNumeric = True
End Function

Function getLastRow(rng As Range) As Long
    getLastRow = rng.row + rng.Rows.Count - 1
End Function

Function getLastColumn(rng As Range) As Long
    getLastColumn = rng.Column + rng.Columns.Count - 1
End Function

Function findFormulaInRange(rng As Range) As Range
' find last cell in range with formula
Dim cll As Range, row As Long, clm As Long, tmp As String

    Set findFormulaInRange = Nothing
    For row = 1 To rng.Rows.Count
    For clm = 1 To rng.Columns.Count
        Set cll = rng.Cells(row, clm)
        tmp = cll.formula
        If InStr(1, tmp, "=") = 1 Then
            Set findFormulaInRange = cll
        End If
    Next: Next

End Function

' 8.2.0.8
Function getMajorityFormula(rng As Range) As Range
Dim stats As LiquiTokens, tkn As LiquiToken
Dim maxCount As Long, key As String, cnt As Long
Dim mainCell As Range, cll As Range, row As Long, clm As Long

    Set stats = New LiquiTokens
    maxCount = 0
    For Each cll In rng
        ' same relative formula (monthly data, standard)
        If cll.HasFormula Then
            key = cll.FormulaR1C1
        Else
            key = "*"
        End If
        Set tkn = stats.item(key)
        If tkn Is Nothing Then Set tkn = stats.Add(key, 0)
        cnt = tkn.attr_0 + 1
        tkn.attr_0 = cnt
        If cnt > maxCount Then
            maxCount = cnt
            Set mainCell = cll
        End If
        
        ' same absolute formla
        If cll.HasFormula Then
            key = cll.formula
            Set tkn = stats.item(key)
            If tkn Is Nothing Then Set tkn = stats.Add(key, 0)
            cnt = tkn.attr_0 + 1
            tkn.attr_0 = cnt
            If cnt > maxCount Then
                maxCount = cnt
                Set mainCell = cll
            End If
        End If
    Next
    Set getMajorityFormula = mainCell
End Function

Function getMajorityColor(rng As Range) As Long
Dim stats As LiquiTokens, tkn As LiquiToken
Dim majColor As Long, maxCount As Long, key As String, cnt As Long
Dim cll As Range, row As Long, clm As Long

    Set stats = New LiquiTokens
    maxCount = 0
    For Each cll In rng
        key = CStr(cll.Interior.Color)
        Set tkn = stats.item(key)
        If tkn Is Nothing Then Set tkn = stats.Add(key, 0)
        cnt = tkn.attr_0 + 1
        tkn.attr_0 = cnt
        If cnt > maxCount Then
            maxCount = cnt
            majColor = cll.Interior.Color
        End If
continueStats:
    Next
    getMajorityColor = majColor
End Function

Private Function checkFormula() As Boolean
Dim sh As Worksheet, cll As Range
    Set sh = getSheet(getMainSheetName())
    If sh Is Nothing Then Exit Function
    Set cll = Selection(1)
    checkFormula = isConstantNumericFormula(cll)
End Function

Function isConstantNumericFormula(cll As Range) As Boolean
Dim udtTokens() As token, strFormula As String, i As Long, strMain As String, strPart As String
Dim str As String, lngTab As Long, blnNewLine As Boolean, lngTemp As Long, bln As Boolean

    If Not IsNumeric(cll) Or Not cll.HasFormula Then
        isConstantNumericFormula = False
        Exit Function
    End If
    
    strFormula = cll.FormulaLocal
'Debug.Print strFormula
    udtTokens() = ParseFormula(strFormula)
'Debug.Print LBound(udtTokens()), UBound(udtTokens), TokenCount(udtTokens)
    isConstantNumericFormula = True
    For i = 0 To TokenCount(udtTokens)  ' token count == uBound
        With udtTokens(i)
'Debug.Print TokenTypeDescription(.lngType), .strValue
            If (.lngType And tkt_OperandReferenceRange) = tkt_OperandReferenceRange Then
                strPart = .strValue
                isConstantNumericFormula = False
                Exit Function
            End If
        End With
    Next
'Debug.Print cll.row, cll.Column, strFormula
End Function


Function isNumericConstant(cll As Range)
Dim udtTokens() As token, strFormula As String, i As Long, strMain As String, strPart As String
Dim str As String, lngTab As Long, blnNewLine As Boolean, lngTemp As Long, bln As Boolean

    If Not IsNumeric(cll) Then
        isNumericConstant = False
        Exit Function
    End If
    
    isNumericConstant = True
    If Not cll.HasFormula Then
        Exit Function
    End If
    strFormula = cll.FormulaLocal
'Debug.Print strFormula
    udtTokens() = ParseFormula(strFormula)
    For i = 0 To TokenCount(udtTokens)
        With udtTokens(i)
'Debug.Print TokenTypeDescription(.lngType), .strValue
            If (.lngType And tkt_OperandReferenceRange) = tkt_OperandReferenceRange Then
                strPart = .strValue
                isNumericConstant = False
                Exit Function
            End If
        End With
    Next
End Function


Function monthToNumber(sMonth As String) As Long
Dim monthNum As Long
Dim firstMonthName As String, firstMonthNumber As Long

    If sMonth = cs_NoMonth Or sMonth = "Planung" Or sMonth = "" Then
        monthToNumber = 0
Exit Function
    End If
    
    firstMonthName = getSheet(gs_MainSheetName).Cells(gn_yearRow, 4)
    firstMonthNumber = numberOfMonth(firstMonthName)
    
    If firstMonthName = "" Or firstMonthName = "Januar" Or firstMonthNumber = 0 Then
        monthToNumber = numberOfMonth(sMonth)
    Else
        monthToNumber = (numberOfMonth(sMonth) - firstMonthNumber + 12) Mod 12 + 1
    End If
'Debug.Print firstMonthName, sMonth, MonthToNumber
End Function

Function numberToMonth(nMonth As Long) As String
Dim m As Long
Dim firstMonthName As String, firstMonthNumber As Long
    
    firstMonthName = Sheets.item(gs_MainSheetName).Cells(gn_yearRow, 4)
    firstMonthNumber = numberOfMonth(firstMonthName)
    
    If firstMonthName = "" Or firstMonthName = "Januar" Or firstMonthNumber = 0 Then
        numberToMonth = monthOfNumber(nMonth)
    Else
        m = nMonth + firstMonthNumber - 1
        If m > 12 Then m = m - 12
        numberToMonth = monthOfNumber(m)
    End If
'Debug.Print firstMonthName, nMonth, NumberToMonth
End Function

Function numberOfMonth(sMonth As String) As Long
    numberOfMonth = 0
    Select Case sMonth
    Case "Januar"
        numberOfMonth = 1
    Case "Februar"
        numberOfMonth = 2
    Case "M|fffd|rz"
        numberOfMonth = 3
    Case "April"
        numberOfMonth = 4
    Case "Mai"
        numberOfMonth = 5
    Case "Juni"
        numberOfMonth = 6
    Case "Juli"
        numberOfMonth = 7
    Case "August"
        numberOfMonth = 8
    Case "September"
        numberOfMonth = 9
    Case "Oktober"
        numberOfMonth = 10
    Case "November"
        numberOfMonth = 11
    Case "Dezember"
        numberOfMonth = 12
    Case Else
        'MsgBox "Ung|fffd|ltige Monatsangabe: '" & month & "'.", vbCritical, cs_MsgTitle
        'Exit Function
    End Select
End Function

Function monthOfNumber(nMonth As Long) As String
    monthOfNumber = ""
    Select Case nMonth
    Case 1
        monthOfNumber = "Januar"
    Case 2
        monthOfNumber = "Februar"
    Case 3
        monthOfNumber = "M|fffd|rz"
    Case 4
        monthOfNumber = "April"
    Case 5
        monthOfNumber = "Mai"
    Case 6
        monthOfNumber = "Juni"
    Case 7
        monthOfNumber = "Juli"
    Case 8
        monthOfNumber = "August"
    Case 9
        monthOfNumber = "September"
    Case 10
        monthOfNumber = "Oktober"
    Case 11
        monthOfNumber = "November"
    Case 12
        monthOfNumber = "Dezember"
    Case Else
        'MsgBox "Ung|fffd|ltige Monatsangabe: '" & month & "'.", vbCritical, cs_MsgTitle
        'Exit Function
    End Select
End Function

Function longFileName(fileName As String) As String
Dim wkDir As String, sTmp As String
Dim wb As Workbook

    Set wb = ActiveWorkbook
      
    If InStr(1, fileName, ":") > 0 Then
        longFileName = fileName
    ElseIf fileName <> "" Then
        longFileName = wb.path & "\" & fileName
    Else
        longFileName = ""
    End If
End Function

Function baseFileName(name As String) As String
Dim fso As FileSystemObject, baseName As String
    Set fso = CreateObject("Scripting.FileSystemObject")
    baseName = fso.GetBaseName(name)
End Function

Function baseSheetName(name As String, Optional prefix As String = "") As String
Dim pos As Long, tmp As String
    If prefix <> "" Then
        pos = InStr(1, name, prefix)
        If pos = 1 Then
            ' starts with
            tmp = Mid$(name, Len(prefix) + 1)
            If InStr(1, prefix, "(") = Len(prefix) Then
                ' prefix ends with "("
                tmp = Mid$(tmp, 2, Len(tmp) - 2)
            End If
            baseSheetName = tmp
            Exit Function
        End If
    End If
    
    ' standard prefix (profit center)
    prefix = "Plandaten("
    pos = InStr(1, name, prefix)
    If pos = 1 Then
        tmp = Mid$(name, Len(prefix) + 1)
        baseSheetName = Mid$(tmp, 1, Len(tmp) - 1)
        Exit Function
    End If
    prefix = cs_CompareSheetName & "("
    pos = InStr(1, name, prefix)
    If pos = 1 Then
        tmp = Mid$(name, Len(prefix) + 1)
        baseSheetName = Mid$(tmp, 1, Len(tmp) - 1)
        Exit Function
    End If
End Function


Function XMLify(sAtt As String) As String
Dim tmp As String
    tmp = Replace(sAtt, "&", "&amp;")  'must happen first
    tmp = Replace(tmp, "<", "&lt;")
    tmp = Replace(tmp, ">", "&gt;")
    tmp = Replace(tmp, """", "&quot;")
    'tmp = Replace(tmp, "'", "&apos;")
    
    'tmp = Replace(tmp, vbCrLf, " ")
    'tmp = Replace(tmp, vbLf, " ")
    'tmp = Replace(tmp, vbCr, " ")
    'tmp = Replace(tmp, vbNewLine, " ")
    'tmp = Replace(tmp, vbTab, " ")
    
    'not necessary with encoding = ISO-8859-2
    tmp = Replace(tmp, "|fffd|", "&auml;", , , vbBinaryCompare)
    tmp = Replace(tmp, "|fffd|", "&Auml;", , , vbBinaryCompare)
    tmp = Replace(tmp, "|fffd|", "&ouml;", , , vbBinaryCompare)
    tmp = Replace(tmp, "|fffd|", "&Ouml;", , , vbBinaryCompare)
    tmp = Replace(tmp, "|fffd|", "&uuml;", , , vbBinaryCompare)
    tmp = Replace(tmp, "|fffd|", "&Uuml;", , , vbBinaryCompare)
    tmp = Replace(tmp, "|fffd|", "&szlig;", , , vbBinaryCompare)
    
    XMLify = tmp
End Function

Private Sub findRedundantSum()
Dim sh As Worksheet, used As Range, Cell As Range, row As Long, clm As Long
Dim strFormula As String

        Set sh = getSheet(gs_MainSheetName)
        If sh Is Nothing Then Exit Sub
        
        Set used = sh.usedRange
        For row = 1 To getLastRow(used)
        For clm = 1 To getLastColumn(used)
            Set Cell = sh.Cells(row, clm)
            With Cell
                If .HasFormula Then
                    strFormula = .FormulaLocal
                    If InStr(1, LCase(strFormula), "sum") > 0 And InStr(1, strFormula, ":") = 0 Then
                        Debug.Print sh.Cells(row, 2), row, clm
                        GoTo nextRow
                    End If
                End If
            End With
        Next
nextRow: Next

End Sub



' ===== obsolete // material =====
' cf. exported code modules

Attribute VB_Name = "LibValidation"
Option Explicit

Const isIgnoreDifferentTypes As Boolean = True
'

Function checkStatus(Optional checkPoint As String = "")
Dim wsh As Worksheet, ch As Chart, shx As Long
Debug.Print "===== " & checkPoint & " ====="

Debug.Print "EnableEvents", Application.EnableEvents
Application.EnableEvents = False
Application.EnableEvents = True
Debug.Print "StatusBar", Application.StatusBar

Debug.Print "CodeVariant", gs_CodeVariant

Dim contextMenu As CommandBar, ctrl As CommandBarControl, context As Variant
    For Each context In Array("CELL", "ROW", "COLUMN")
        Set contextMenu = Application.CommandBars(context)
        For Each ctrl In contextMenu.Controls
            If (ctrl.caption = "LiquiPlan" Or ctrl.caption = "Modell bearbeiten") Then
Debug.Print context, ctrl.caption
            End If
        Next ctrl
    Next context

Debug.Print "Workbook", Application.ActiveWorkbook.name
Debug.Print "MainSheet", gs_MainSheetName, gn_MainSheetIndex
Debug.Print "Prolog_Start", gn_row_Prolog_Start

If True Then
Debug.Print "Worksheets"
    With ActiveWorkbook.Worksheets
        For shx = 1 To .Count
            Set wsh = .item(shx)
Debug.Print , shx, wsh.name, wsh.ProtectContents
        Next
    End With
'Debug.Print "Charts"
'    With ActiveWorkbook.Charts
'        For shx = 1 To .Count
'            Set ch = .item(shx)
'Debug.Print , shx, ch.name
'        Next
'    End With
End If ' true|false

End Function

Function isLiquiplanSheet(sh As Variant) As Boolean
Dim abk As Workbook, wSht As Worksheet, dSht As Worksheet
Dim idx As Long, row As Long, clm As Long
Dim sError As String

'Debug.Print "(isLiquiplanSheet) ", sh.name
    Set abk = Application.ActiveWorkbook
    
    isLiquiplanSheet = True
'Stop
    If (TypeOf sh Is Worksheet) Then
        If isMainOrPC(sh, idx) Then
'Debug.Print "isLiquiplanSheet(..)", sh.name, CStr(isLiquiplanSheet)
Exit Function
        End If
        If (sh.name = cs_CompareSheetName Or sh.name = cs_MasterSheetName Or _
            sh.name = cs_PlotData Or sh.name = cs_GraphicsData Or sh.name = cs_optionsSheetName) Then
'Debug.Print "isLiquiplanSheet(..)", sh.name, CStr(isLiquiplanSheet)
Exit Function
        End If
        
        If gs_ProfitCenters = "" Then
            gs_ProfitCenters = getProfitCenters()
        End If
        If gs_MainSheetName = cs_MainSheet_ProfitCenter And gs_ProfitCenters <> "" Then
            For idx = 1 To gn_MainSheetIndex
                If sh.name = getMasterSheetName(abk.Worksheets(idx).name) Then
'Debug.Print "isLiquiplanSheet(..)", sh.name, CStr(isLiquiplanSheet)
Exit Function
                End If
                If sh.name = getCompareSheetName(abk.Worksheets(idx).name) Then
'Debug.Print "isLiquiplanSheet(..)", sh.name, CStr(isLiquiplanSheet)
Exit Function
                End If
            Next
        End If
        
    Else    ' Worksheet || Chart
    ' liqui charts || user charts
        Set dSht = getSheet(cs_GraphicsData)
        If dSht Is Nothing Then
            sError = "Blatt '" & cs_GraphicsData & "' nicht gefunden."
            isLiquiplanSheet = False
'Debug.Print "isLiquiplanSheet(..)", sh.name, "Blatt '" & cs_GraphicsData & "' nicht gefunden."
Exit Function
        End If
        row = 1: clm = 1
        findTextOrFormula dSht, "[" & sh.name, True, True, row, clm, , 1
        isLiquiplanSheet = (row > 0)
'Debug.Print "isLiquiplanSheet(..)", sh.name, CStr(isLiquiplanSheet)
    End If
    
    isLiquiplanSheet = False
End Function

Function isMainOrPC(sh As Variant, shIndex As Long) As Boolean
' shIndex: side effect
Dim wbk As Workbook, trgSh As Variant    'Worksheet | Chart
Dim idx As Long
Dim sError As String, msg As String

    If gs_MainSheetName = "" Or gn_MainSheetIndex = 0 Then
        validateMainSheet sError
    End If
    
    With sh.parent
        isMainOrPC = False
        shIndex = 0
        For idx = 1 To gn_MainSheetIndex
            If sh.name = .Worksheets(idx).name Then
                If validateProfitCenter(sh, sError) Then
                    shIndex = idx
                    isMainOrPC = True
    Exit Function
                Else
                    msg = "'" & sh.name & "' ist kein g|fffd|ltiges Profitcenter." & vbLf & sError
                    MsgBox msg, vbCritical, cs_MsgTitle
                    Set trgSh = .Sheets(.Sheets.Count)
                    sh.Move after:=trgSh
                    shIndex = 0
                    isMainOrPC = False
    Exit Function
                End If
            End If
        Next
    End With ' parent book
End Function

Private Function validateProfitCenter(sh As Variant, sError As String) As Boolean
Dim wsh As Worksheet, prologStart As Long, tmp As String
Dim sdx As Long, row As Long, clm As Long
    
    validateProfitCenter = False
    If Not (TypeOf sh Is Worksheet) Then
        sError = "Kein Arbeitsblatt"
Exit Function
    End If
    Set wsh = sh
    
    prologStart = 1
    clm = 2
    tmp = "Stammdaten"
    findTextOrFormula wsh, tmp, True, True, prologStart, clm, , 2
    If prologStart = 0 Then
        sError = "Stammdaten fehlen"
Exit Function
    End If
    
    If prologStart <> gn_row_Prolog_Start Then
        sError = "Anordnung der Zeilen stimmt nicht mit 'Konsolidierung' |fffd|berein."
Exit Function
    End If
    
    sError = ""
    validateProfitCenter = True
End Function


Function initializeModel()
Dim sVersion As String, sError As String
Dim sh As Variant, mainSh As Worksheet, actSh As Variant, ws As Worksheet, ch As Chart
Dim shx As Long, msg As String

    ' standard settings
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    sVersion = Application.Version
    sVersion = nextValue(sVersion, ".")
    If CInt(sVersion) < 9 Then
        MsgBox "EXCEL Version |fffd|lter als 9.0 (Office 2000): nicht getestet."
    End If
    
    If (Application.ActiveWorkbook Is Nothing) Then
    ' premature
Exit Function
    End If
    Set actSh = Application.ActiveSheet
    
Debug.Print "initializeModel", ActiveWorkbook.name, actSh.name, gs_CodeVariant

    gb_protectionIssue = False
    Set mainSh = validateMainSheet(sError)
    If (mainSh Is Nothing) Then
'Stop '(4)
        gb_protectionIssue = True
        MsgBox sError, vbExclamation, cs_MsgTitle
Application.EnableEvents = True
Exit Function

    ElseIf (sError <> "") Then
'Stop '(5)
        gb_protectionIssue = True
        MsgBox sError, vbExclamation, cs_MsgTitle
    End If
    
    Application.ActiveWorkbook.Worksheets(gs_MainSheetName).Activate
    Application.StatusBar = "Initialisierung von LiquiPlan"
    mainSh.Activate
    DoEvents
    
    Application.ScreenUpdating = False
'Stop

    restoreModelProtection
    
    protectAllSheets 4
    
    On Error Resume Next
    getSheet(cs_PlotData).visible = xlSheetHidden
    getSheet(cs_GraphicsData).visible = xlSheetHidden
    getSheet(cs_optionsSheetName).visible = xlSheetHidden
    On Error GoTo 0
    
    If (actSh.visible = xlSheetVisible) Then
        actSh.Activate
    Else
        mainSh.Activate
    End If
    
Application.StatusBar = False
DoEvents

Application.ScreenUpdating = True
Application.EnableEvents = True
End Function


' => menuValidateModel()
Function validateDataStructure(logStream As TextStream, logPath As String) As LiquiYesNoCancel
'   logPath:    side effect
'   vbYes:      no errors
'   vbNo:       errors in log file
'   vbCancel:   canceled

Dim mainSheet As Worksheet, wbk As Workbook, wsh As Worksheet
Dim row As Long
Dim sError As String, sError2 As String, tmp As String
Dim eventsFlag As Boolean, isProtected As Boolean

' write error protocol
Dim fso As FileSystemObject, logName As String, logLine As String
'On Error Resume Next
    Set fso = New FileSystemObject
'    Set fso = CreateObject("Scripting.FileSystemObject")
    logName = "Protokoll |fffd|berpr|fffd|fung " & fso.GetBaseName(ActiveWorkbook.name) & ".txt"
    logPath = longFileName(logName)
    Set logStream = fso.CreateTextFile(logPath, True)
    If Not logStream Is Nothing Then logStream.WriteLine ActiveWorkbook.name
    If Not logStream Is Nothing Then logStream.WriteLine ""
    
    validateDataStructure = lqYes

' if called before anything else, some globals like gn_monthRow are not properly initialized
    Set mainSheet = validateMainSheet(sError)   ' stores row default colors
    If sError <> "" Then
        MsgBox sError, vbExclamation, cs_MsgTitle
        If Not logStream Is Nothing Then logStream.WriteLine sError
    End If
    
    If mainSheet Is Nothing Then
        validateDataStructure = lqCancel
'        If Not logStream Is Nothing Then logStream.Close
Exit Function
    End If
    
    DoEvents
    eventsFlag = Application.EnableEvents
    Application.EnableEvents = False
    
Dim ync As LiquiYesNoCancel
    sError = ""
    
    ' row headers
Application.StatusBar = "Namen von Zeilen"
DoEvents
    ' normalize quantity names: moved to validateDataStructure (( must not .unprotect during Window_Activate))
    isProtected = mainSheet.ProtectContents
    If (unprotectSheet(mainSheet, True)) Then
        For row = 1 To gn_row_Section_IV_End
            tmp = mainSheet.Cells(row, cn_clm_Quantity)
            If tmp <> Trim$(tmp) Then
                mainSheet.Cells(row, cn_clm_Quantity) = Trim$(tmp)
                If row > gn_row_Section_I_Start Then
                    If Not applyQuantityChange(row, 0, tmp, Trim$(tmp), False, sError2) Then
                        MsgBox sError2, vbInformation, cs_MsgTitle
                        sError2 = ""
                    End If
                End If
            End If
        Next
    End If
    If isProtected Then protectSheet mainSheet
    
    ync = validateRowHeaders(sError, logStream)
    If sError <> "" Then
        MsgBox sError, vbExclamation, cs_MsgTitle
    End If
    If ync = lqCancel Then
        validateDataStructure = lqCancel
'        If Not logStream Is Nothing Then logStream.Close
'Shell "notepad.exe " & logPath, 1
Exit Function
    ElseIf ync = lqNo Then
        validateDataStructure = lqNo
    End If
    
    ' cells with errors like #DIV/0!, #REF!, etc.
    Set wbk = mainSheet.parent
    If Not logStream Is Nothing Then logStream.WriteLine ""
    For Each wsh In wbk.Worksheets
        If (Not isLiquiplanSheet(wsh)) Then GoTo NEXT_WORKSHEET
Application.StatusBar = "Formel-G|fffd|ltigkeit: " & wsh.name
DoEvents
        sError = ""
        ync = validateFormulae(wsh, sError, logStream)
        If ync = lqCancel Then
            ' user: cancel
            validateDataStructure = lqCancel
            Exit For
        ElseIf ync = lqNo Then
            ' user: continue
            validateDataStructure = lqNo
        End If
        
NEXT_WORKSHEET:
    Next

If Not logStream Is Nothing Then
'    logStream.Close
    If validateDataStructure = lqYes Then
        logPath = ""
    End If

End If
    Application.EnableEvents = eventsFlag
End Function


Function validateMainSheet(sError As String) As Worksheet
Dim wb As Workbook, sh As Worksheet, cl As Range, rng As Range
Dim wbx As Long, shx As Long, idx As Long
Dim bookType As String, sError2 As String

Dim mainSheet As Worksheet, mstSheet As Worksheet, dtaSheet As Worksheet
Dim usedRange As Range, firstRowUsed As Long, lastRowUsed As Long
Dim row As Long, clm As Long
Dim nameSh As String, sMonth As String, tmp As String
Dim isProtected As Boolean, eventsEnabled As Boolean, foundError As Boolean

    If (Application.ActiveWorkbook Is Nothing) Then
    'premature
Exit Function
    End If
    
    '8.3.0.8: standard colors ((!= color indexes))
'    gn_color_formulaDestroyed = ActiveWorkbook.Colors(cn_clrX_formulaDestroyed)
'    gn_color_formulaDestroyed_ = ActiveWorkbook.Colors(cn_clrX_formulaDestroyed_)
'    gn_color_destroyedFormulaCopied = ActiveWorkbook.Colors(cn_clrX_destroyedFormulaCopied)
    gn_color_outlier = ActiveWorkbook.Colors(cn_clrX_outlier)
    gn_color_outlier_ = ActiveWorkbook.Colors(cn_clrX_outlier_)
    gn_color_month = ActiveWorkbook.Colors(cn_clrX_month)
    gn_color_monthDark = ActiveWorkbook.Colors(cn_clrX_monthDark)
'    gn_color_formulaUnlocked = ActiveWorkbook.Colors(cn_clrX_formulaUnlocked)
    gn_color_quantityUnlocked = ActiveWorkbook.Colors(cn_clrX_quantityUnlocked)
    gn_color_monthHighlight = ActiveWorkbook.Colors(cn_clrX_monthHighlight)

    eventsEnabled = Application.EnableEvents
    Application.EnableEvents = False

'workbook
    ' mehr als eine Liquiplan-Arbeitsmappe ge|fffd|ffnet?
    bookType = ""
    For wbx = 1 To Application.Workbooks.Count
        Set wb = Application.Workbooks(wbx)
        For shx = 1 To wb.Worksheets.Count
            DoEvents
            Set sh = wb.Worksheets(shx)
            If sh.name = cs_MainSheet_BasicModel Or sh.name = cs_MainSheet_ProfitCenter Then
                If bookType = "" Then
                    bookType = sh.name
                ElseIf bookType <> sh.name Then
                    If Not isIgnoreDifferentTypes Then
                        sError2 = "Liquiplan-Arbeitsmappen unterschiedlichen Typs ge|fffd|ffnet."
                        MsgBox sError2, vbInformation, cs_MsgTitle
                        sError2 = ""
'                        Set validateMainSheet = Nothing
'Application.EnableEvents = eventsEnabled
'Exit Function
                    End If
                End If
            End If
        Next
    Next
    
    
    ' Basismodell oder Profitcenters ?
    If endsWith(ActiveWorkbook.name, ".xlam") Then
        ' historical (AddIn version)
        gs_MainSheetName = ""
Application.EnableEvents = eventsEnabled
Exit Function
    End If

    gs_MainSheetName = getMainSheetName()
    If gs_MainSheetName = "" Then
        Set validateMainSheet = Nothing
        sError = "Keine g|fffd|ltige Umsatz- und Liquidit|fffd|tsplanung:"
        sError = sError & vbCrLf & "Arbeitsblatt 'Umsatz und Liquidit|fffd|t' (Basismodell) bzw. 'Konsolidierung' (Profitcenter Modell) fehlt."
Application.EnableEvents = eventsEnabled
Exit Function
    ElseIf getMainSheetName = cs_MainSheet_BasicModel & "|" & cs_MainSheet_ProfitCenter Then
        Set validateMainSheet = Nothing
        sError = "Keine g|fffd|ltige Umsatz- und Liquidit|fffd|tsplanung:"
        sError = sError & vbCrLf & "Enth|fffd|lt sowohl 'Umsatz und Liquidit|fffd|t' (Basismodell) als auch 'Konsolidierung' (Profitcenter Modell)."
        gs_MainSheetName = ""
Application.EnableEvents = eventsEnabled
Exit Function
    End If
    
    If gs_MainSheetName = cs_MainSheet_BasicModel Then
        gs_ModelType = cs_ModelType_BasicModel
    Else
        gs_ModelType = cs_ModelType_ProfitCenter
        getProfitCenters
    End If

    ' essental sheets missing ?
    nameSh = gs_MainSheetName
    Set mainSheet = getSheet(nameSh)
    If mainSheet Is Nothing Then GoTo SheetMissing
    
    storeColorMap mainSheet
    
    nameSh = cs_CompareSheetName
    If getSheet(nameSh) Is Nothing Then GoTo SheetMissing
        
'8.2.0.4 Copy 'n Paste issue: must not protect/unprotect sheets during _WindowActivate
'    isProtected = mainSheet.ProtectContents
'    mainSheet.Unprotect
    isProtected = False
    
    gn_row_Prolog_Start = 1
    clm = 2
    tmp = "Stammdaten"
    findTextOrFormula mainSheet, tmp, True, True, gn_row_Prolog_Start, clm, , 2
    If gn_row_Prolog_Start = 0 Then GoTo PrologMissing
    
    gn_monthRow = gn_row_Prolog_Start + 1
    tmp = cs_MonthTitle
    findTextOrFormula mainSheet, tmp, True, True, gn_monthRow, clm, , 2
    If gn_monthRow = 0 Then GoTo PrologMissing
    gn_yearRow = gn_monthRow - 2
    sMonth = mainSheet.Cells(gn_monthRow, 3)
    If (numberOfMonth(sMonth) = 0) Then
        eventsEnabled = Application.EnableEvents
        Application.EnableEvents = False
        mainSheet.Cells(gn_monthRow, 3) = cs_NoMonth
        Application.EnableEvents = eventsEnabled
    End If
    
    nameSh = cs_MasterSheetName
    Set mstSheet = getSheet(nameSh)
    If mstSheet Is Nothing Then ' GoTo SheetMissing
        If sMonth <> cs_NoMonth Then
            GoTo SheetMissing
        Else
            Set mstSheet = makeNewSheet(Application.ActiveWorkbook, nameSh, after:=mainSheet)
        End If
    End If
    
' beware: must not add missing sheets here;
'   SheetsWatch (processSheetListChanged(..)) calls this
'    nameSh = cs_PlotData
'    Set dtaSheet = findOrCreateWorksheet(nameSh)
    
'    nameSh = cs_GraphicsData
'    Set dtaSheet = getSheet(nameSh)
'    If dtaSheet Is Nothing Then
'        If sMonth <> cs_NoMonth Then
'            GoTo SheetMissing
'        Else
'            Set dtaSheet = makeNewSheet(Application.ActiveWorkbook, nameSh)
'            For idx = 1 To 12
'                dtaSheet.Cells(1, 2 + idx) = Left(numberToMonth(idx), 3)
'            Next
'            dtaSheet.Cells(3, 1) = "[Berichtsmonat]"
'            dtaSheet.Cells(4, 1) = 0
'            dtaSheet.Cells(4, 2) = cs_NoMonth
'            gs_currentMonthName = cs_NoMonth
'        End If
'    End If

On Error Resume Next    ' sheet protection issue
On Error GoTo 0
    If (unprotectSheet(mainSheet, True)) Then
        row = gn_monthRow
        If (mainSheet.Cells(row, 3) = "") Then
            mainSheet.Cells(row, 3) = "<ohne>"
        End If
        gs_currentMonthName = mainSheet.Cells(row, 3)
        
        tmp = "Zinszahlung"
        findTextOrFormula mainSheet, tmp, True, True, row, clm, , 2
        If row = 0 Then GoTo PrologMissing
        If (mainSheet.Cells(row, 3) = "") Then
            mainSheet.Cells(row, 3) = "monatl."
        End If
        row = row + 1
        
        row = row + 1
        If IsEmpty(mainSheet.Cells(row, 3)) Then
            mainSheet.Cells(row, 3) = 19
        End If
    'On Error GoTo 0
    End If
    
    'section headers
    nameSh = gs_MainSheetName
    
    tmp = "Abschnitt I."
    findTextOrFormula mainSheet, "I. ", True, True, row, clm, , 2
    If row = 0 Then GoTo SectionMissing
    gn_row_Section_I_Start = row
    
    row = row + 1
    tmp = "Abschnitt II."
    findTextOrFormula mainSheet, "II. ", True, True, row, clm, , 2
    If row = 0 Then GoTo SectionMissing
    gn_row_Section_II_Start = row
    
    row = row + 1
    tmp = "Abschnitt III."
    findTextOrFormula mainSheet, "III. ", True, True, row, clm, , 2
    If row = 0 Then GoTo SectionMissing
    gn_row_Section_III_Start = row
    
    row = row + 1
    tmp = "Abschnitt IV."
    findTextOrFormula mainSheet, "IV. ", True, True, row, clm, , 2
    If row = 0 Then GoTo SectionMissing
    gn_row_Section_IV_Start = row
    
    ' Kennzahlen' (KPI's) : last section with month columns
    row = row + 1
    tmp = "Kennzahlen"   ' Ertragslage
    findTextOrFormula mainSheet, tmp, True, True, row, clm, , 2
    gn_row_Section_V_Start = 0
    If row = 0 Then GoTo SectionMissing
    gn_row_Section_V_Start = row
    
    row = row + 1: clm = 3
    tmp = "Zinsaufwand"   ' Ertragslage
    findTextOrFormula mainSheet, tmp, True, True, row, clm, , 3
    clm = 2
    If row > 0 Then
        gn_row_Section_V_End = row
    Else
        gn_row_Section_V_End = gn_row_Section_V_Start + cn_height_Section_V - 1
    End If
    gn_row_MonthRangeEnd = gn_row_Section_V_End
    
    Set usedRange = mainSheet.usedRange
    firstRowUsed = usedRange.row
    lastRowUsed = getLastRow(usedRange)
    
    'source data for standard charts
    row = gn_row_Section_III_Start
    tmp = "Gesamtumsatz"
    findTextOrFormula mainSheet, tmp, True, True, row, clm, , 2
    If row = 0 Then GoTo StandardQuantityMissing
    
    row = row + 1
    tmp = "G. u. V. vor Steuern"
    findTextOrFormula mainSheet, tmp, True, True, row, clm, , 2
    If row = 0 Then GoTo StandardQuantityMissing
    gn_row_G_u_V = row
    
    row = row + 1
    tmp = "Kontokorrent"
    findTextOrFormula mainSheet, tmp, True, True, row, clm, , 2
    If row = 0 Then GoTo StandardQuantityMissing
    gn_row_Section_IV_End = row


    ' custom section: eg. F|fffd|rster - Filialen (mini profit centers)
    ' look for month header row
    gn_row_Section_Custom_Start = 0
'    For row = IIf(gn_row_Section_V_Start > 0, gn_row_Section_V_Start + 1, gn_row_Section_IV_End) To lastRowUsed
    For row = gn_row_Section_V_End To lastRowUsed
        If isMonthHeaderRow(mainSheet, row) Then
            gn_row_Section_Custom_Start = row
            Exit For
        End If
    Next
    If gn_row_Section_Custom_Start > 0 Then
        row = row + 1
        tmp = "####################"
        findTextOrFormula mainSheet, tmp, True, True, row, clm, , 2
        If row > 0 Then
            gn_row_Section_Custom_End = row
        Else
            gn_row_Section_Custom_End = lastRowUsed
        End If
    End If
    If (gn_row_Section_Custom_Start > 0) Then
        gn_row_MonthRangeEnd = gn_row_Section_Custom_End
    End If
    
    ' Spalte LiquiCheck
    row = gn_row_Section_IV_Start
    tmp = "Liqui Check"
    findTextOrFormula mainSheet, tmp, True, True, row, clm, gn_row_Section_IV_End
    gn_clm_LiquiCheck = clm
    
' normalize quantity names: moved to validateDataStructure
' ((must not .unprotect during Window_Activate))
    
    ' validate profit centers in case some sheet was moved
Application.StatusBar = "Profit Center"
DoEvents
    If (gn_MainSheetIndex > 1) Then
        If (gs_MainSheetName = cs_MainSheet_BasicModel) Then
            idx = 1
            Do While (idx < gn_MainSheetIndex)
                Set sh = ActiveWorkbook.Worksheets(idx)
                sh.Move after:=mainSheet
                gn_MainSheetIndex = gn_MainSheetIndex - 1
                idx = idx + 1
            Loop
        Else
            idx = 1
            Do While (idx < gn_MainSheetIndex)
                Set sh = ActiveWorkbook.Worksheets(idx)
                If (Not validateSectionHeaders(sh, mainSheet, sError2, Nothing)) Then
                    sh.Move after:=mainSheet
                    gn_MainSheetIndex = gn_MainSheetIndex - 1
                Else
                    idx = idx + 1
                End If

            Loop
        End If
    End If

    ' update consolidation formulae
Application.StatusBar = "Konsolidierung"
DoEvents
    tmp = gs_ProfitCenters
    gs_ProfitCenters = getProfitCenters()
    If (gs_ProfitCenters <> "") Then
        If tmp <> "" And tmp <> gs_ProfitCenters Then
            If updateConsolidation() Then
                MsgBox "Konsolidierung wurde aktualisiert."
            End If
        End If
    End If
    
    Set validateMainSheet = mainSheet
Application.EnableEvents = eventsEnabled
Application.StatusBar = False
DoEvents
Exit Function

SheetMissing:
    sError = "Blatt '" & nameSh & "' fehlt oder umbenannt."
'    If isProtected Then protectSheet mainSheet
Application.EnableEvents = eventsEnabled
Exit Function

PrologMissing:
    sError = "Blatt '" & nameSh & "' inkonsistent;"
    sError = sError & vbCrLf & "Zeile '" & tmp & "' fehlt."
'    If isProtected Then protectSheet mainSheet
Application.EnableEvents = eventsEnabled
Exit Function

SectionMissing:
    sError = "Blatt '" & nameSh & "' inkonsistent;"
    sError = sError & vbCrLf & "Abschnitte fehlen oder in falscher Reihenfolge."
    sError = sError & vbCrLf & tmp
'    If isProtected Then protectSheet mainSheet
Application.EnableEvents = eventsEnabled
Exit Function

StandardQuantityMissing:
    sError = "Blatt '" & nameSh & "' inkonsistent;"
    sError = sError & vbCrLf & "Standard-Gr|fffd||fffd|e '" & tmp & "' fehlt."
'    If isProtected Then protectSheet mainSheet
Application.EnableEvents = eventsEnabled
Exit Function
    
PWD_ERROR:
    mainSheet.Activate
    sError = "Bitte heben Sie den Blattschutz von '" + mainSheet.name + "' auf"
    sError = sError + vbLf + "und stellen die Formel|fffd|berwachung wieder her."
    sError = sError + vbLf + "Andernfalls ist die Konsistenz des Modells nicht mehr gew|fffd|hrleistet."
    Set validateMainSheet = mainSheet  'Nothing
'Stop '(1)
    Resume Next
'Application.EnableEvents = eventsEnabled
'Exit Function

Application.EnableEvents = eventsEnabled
End Function

Function validateRowHeaders(sError As String, Optional logStream As TextStream = Nothing) As LiquiYesNoCancel
' validate row headers: input sheets and master sheets against main input sheet
' assumes source data validated successfully (prolog, section headers, standard quantities); mainSheet <> nothing
'
' 1. if some master sheet is empty or missing, model should be in planning mode (no month selected)
' 2. section headers
'   if error propose save master data
' 3. row headers for each section
'   if error propose consistent renaming
' 4. if some row header was changed, update performance analysis and charts

Dim awb As Workbook, mainSheet As Worksheet, srcSheet As Worksheet, trgSheet As Worksheet
Dim usedRange As Range, first As Long, last As Long
Dim monthCell As Range, month As String
Dim forceUpdateReports As Boolean
Dim idx As Long, idy As Long, row As Long, clm As Long
Dim nameSh As String, txt As String, msg As String, foundError As Boolean

' experimental: report up to N errors, N > 0
Const errorMax As Long = 10 ' = 0 ' no maximum

    validateRowHeaders = lqYes
    forceUpdateReports = False
    
    Set awb = Application.ActiveWorkbook
    Set mainSheet = getSheet(gs_MainSheetName)
    Set monthCell = mainSheet.Cells(gn_monthRow, 3)
    month = monthCell.value
    
    ' section headers
    
    ' master sheet (Original Plandaten)
    Set trgSheet = getSheet(cs_MasterSheetName)
    If trgSheet Is Nothing Then
        If month = cs_NoMonth Then
            sError = "Empfehlung: Plandaten speichern."
        Else
            sError = "Empfehlung: zur|fffd|ck zum Planungszustand, Plandaten speichern."
        End If
        validateRowHeaders = lqCancel
Exit Function
    End If
    
    If Not validateSectionHeaders(mainSheet, trgSheet, sError, logStream) Then
        validateRowHeaders = lqCancel
Exit Function
    End If
    
    ' profit centers
Dim sectionError As String, errorCount As Long
    sectionError = ""
    errorCount = 0
    For idx = 1 To gn_MainSheetIndex - 1
        Set trgSheet = awb.Worksheets(idx)
        If Not validateSectionHeaders(mainSheet, trgSheet, sError, logStream) Then
            errorCount = errorCount + 1
            validateRowHeaders = lqCancel
            If sectionError = "" Then sectionError = sError
        End If
        
        nameSh = getMasterSheetName(trgSheet.name)
        Set trgSheet = awb.Worksheets(nameSh)
        If trgSheet Is Nothing Then
            If month = cs_NoMonth Then
                sError = "Empfehlung: Plandaten speichern."
            Else
                sError = "Empfehlung: zur|fffd|ck zum Planungszustand, Plandaten speichern."
            End If
            errorCount = errorCount + 1
            validateRowHeaders = lqCancel
            If Not logStream Is Nothing Then logStream.WriteLine sError
            If sectionError = "" Then sectionError = sError
        End If
        If Not validateSectionHeaders(mainSheet, trgSheet, sError, logStream) Then
            errorCount = errorCount + 1
            validateRowHeaders = lqCancel
            If sectionError = "" Then sectionError = sError
        End If
    Next
    If sectionError <> "" Then
        sError = sectionError
        If errorCount > 1 Then
            sError = sError & vbCrLf & vbCrLf & "... und mehr (siehe Fehlerprotokoll)"
        End If
        msg = "|fffd|berpr|fffd|fung wurde nicht fortgesetzt."
        sError = sError & vbCrLf & vbCrLf & msg
        If Not logStream Is Nothing Then logStream.WriteLine (vbCrLf & msg)
        
Exit Function
    End If
    
    ' compare row headers: section by section
    ' suggested fix: target(lhs) <- source(rhs)
    '   rhs: usually, more recent edit; lhs: to be updated
    ' strict: equality up to trim$
    ' weak: ignore blank lhs

Dim checkedIssues As LiquiTokens, issue As LiquiToken, i As Long
' token: key, row, description, fixConfirmed

Dim sectionRows(), Section As String, sectionStart As Long, sectionEnd As Long
Dim isStrict As Boolean
Dim ync As LiquiYesNoCancel

    sectionRows = Array(gn_row_Prolog_Start, gn_row_Section_I_Start, gn_row_Section_II_Start, gn_row_Section_III_Start, _
                    gn_row_Section_IV_Start, gn_row_Section_IV_End)
    If Not logStream Is Nothing Then logStream.WriteLine ""
    For idx = 0 To UBound(sectionRows) - 1
        sectionStart = sectionRows(idx)
        Section = mainSheet.Cells(sectionStart, 2)
        sectionEnd = sectionRows(idx + 1) - 1
        
        Set checkedIssues = New LiquiTokens
        
        For idy = 1 To gn_MainSheetIndex
            Set srcSheet = mainSheet
            Set trgSheet = ActiveWorkbook.Worksheets(idy)
            ' consolidation to profit center
            ' weak comparison: ignore blank headers of target
            isStrict = False
            If idy < gn_MainSheetIndex Then
                ync = compareSection(srcSheet, trgSheet, sectionStart, sectionEnd, checkedIssues, isStrict, _
                        forceUpdateReports, sError, logStream, errorMax)
                If ync = lqCancel Then
                    validateRowHeaders = lqCancel
Exit Function
                ElseIf ync = lqNo Then
                    validateRowHeaders = lqNo
                End If
            End If
            
            ' input sheet to master sheet
            ' strict comparison
            isStrict = True
            Set srcSheet = ActiveWorkbook.Worksheets(idy)
            Set trgSheet = getSheet(getMasterSheetName(srcSheet.name))
            If Not trgSheet Is Nothing Then
                ync = compareSection(srcSheet, trgSheet, sectionStart, sectionEnd, checkedIssues, isStrict, _
                        forceUpdateReports, sError, logStream, errorMax)
                If ync = lqCancel Then
                    validateRowHeaders = lqCancel
Exit Function
                ElseIf ync = lqNo Then
                    validateRowHeaders = lqNo
                End If
            End If
        Next idy ' sheet
    Next idx ' section
    
' brute force update plots and diagrams ?
'    If forceUpdateReports Then
'        processMonthChange Target:=monthCell, force:=True '.Cells(gn_monthRow, 3)
'    End If
    
End Function

Function validateSectionHeaders(srcSheet, trgSheet As Worksheet, sError As String, logStream As TextStream) As Boolean
Dim sectionRows(), row

'Debug.Print "validateSectionHeaders", srcSheet.name, trgSheet.name
Application.StatusBar = "Abschnittsgrenzen: " & trgSheet.name
DoEvents

    validateSectionHeaders = False
    sError = ""
    If (gn_row_Section_I_Start = 0) Then
'        validateMainSheet sError
Exit Function
    End If
    
    sectionRows = Array(gn_row_Section_I_Start, gn_row_Section_II_Start, gn_row_Section_III_Start, _
        gn_row_Section_IV_Start, gn_row_Section_IV_End)
    For Each row In sectionRows
        If srcSheet.Cells(row, cn_clm_Quantity) <> trgSheet.Cells(row, cn_clm_Quantity) Then
'            sError = "Blatt '" & trgSheet.name & "', Zeile " & row
'            sError = sError & vbCrLf & "Abschnittsgrenzen stimmen nicht |fffd|berein: "
            sError = "Abschnittsgrenzen: " & "Blatt '" & trgSheet.name & "', Zeile " & row
            sError = sError & vbCrLf & "'" & trgSheet.Cells(row, cn_clm_Quantity) & "' <> '" & srcSheet.Cells(row, cn_clm_Quantity) & "'"
If Not logStream Is Nothing Then logStream.WriteLine (vbCrLf & sError)
            trgSheet.Activate
            trgSheet.Cells(row, cn_clm_Quantity).Select
Exit Function
        End If
    Next
    validateSectionHeaders = True
End Function

Private Function compareSection(srcSheet As Worksheet, trgSheet As Worksheet, sectionStart, sectionEnd As Long, _
                checkedIssues As LiquiTokens, isStrict As Boolean, forceUpdateReports As Boolean, _
                sError As String, logStream As TextStream, Optional errorMax As Long = 0) As LiquiYesNoCancel
Dim issue As LiquiToken
Dim Section As String, msg As String
Dim ync As Long, i As Long

    compareSection = lqYes ' no errors or all fixed
    Section = srcSheet.Cells(sectionStart, 2)
    If Not compareRowHeaders(srcSheet, trgSheet, sectionStart, sectionEnd, checkedIssues, isStrict, sError, logStream, errorMax) Then
'        msg = "Abschnitt = " & section & "; Tabelle = " & trgSheet.name & " gegen " & srcSheet.name
        msg = "Abschnitt '" & Section & vbCrLf & trgSheet.name & " || " & srcSheet.name
        msg = msg & sError
'        msg = msg & vbCrLf & sError
If Not logStream Is Nothing Then logStream.WriteLine msg
        msg = msg & vbCrLf & vbCrLf & "Rechte Seite |fffd|bernehmen ?"
' !!! ToDo: multi-enabled ListBox form
        sError = ""
        ync = MsgBox(msg, vbYesNoCancel, cs_MsgTitle)
        If ync = vbYes Then
            For i = 1 To checkedIssues.Count
                Set issue = checkedIssues.item(i)
'Debug.Print issue.key
                issue.attr_2 = True ' fix confirmed
            Next
            updateRowHeaders srcSheet, trgSheet, checkedIssues, isStrict
            If sectionStart >= gn_row_Section_I_Start And sectionEnd < gn_row_Section_IV_Start Then
                forceUpdateReports = True
            End If
            msg = vbTab & "Rechte Seite |fffd|bernommen." & vbCrLf ' & vbCrLf
If Not logStream Is Nothing Then logStream.WriteLine msg
        ElseIf ync = vbNo Then
            For i = 1 To checkedIssues.Count
                Set issue = checkedIssues.item(i)
'Debug.Print issue.key
                issue.attr_2 = False 'fix refused
            Next
            If Not logStream Is Nothing Then logStream.WriteLine ""
            compareSection = lqNo
        Else
            compareSection = lqCancel
            If Not logStream Is Nothing Then logStream.WriteLine vbCrLf & "|fffd|berpr|fffd|fung wurde abgebrochen."
        End If
    End If
End Function

Private Function compareRowHeaders(srcSheet As Worksheet, trgSheet As Worksheet, sectionStart, sectionEnd As Long, _
                checkedIssues As LiquiTokens, isStrict As Boolean, sError As String, logStream As TextStream, Optional errorMax As Long = 0) As Boolean
Dim issue As LiquiToken, fixConfirmed As Boolean
' token: key; 0=row, 1=description, 2=fixConfirmed
Dim row As Long, errorCount As Long
Dim src As String, trg As String, src2 As String, trg2 As String
Dim isProtected As Boolean
Dim msg As String
    
    errorCount = 0
    With trgSheet
        isProtected = .ProtectContents
        .Unprotect cs_LiquiPWD
        If isRangeEmpty(.Range(.Cells(1, 2), .Cells(sectionEnd, 2))) Then
            ' skip empty sheet
        Else
            sError = ""
            For row = sectionStart + 1 To sectionEnd
                src = srcSheet.Cells(row, cn_clm_Quantity)
                src2 = srcSheet.Cells(row, cn_clm_Quantity).formula
                Set issue = checkedIssues.item(src)
                If Not issue Is Nothing Then
                    fixConfirmed = issue.attr_2
                    If Not fixConfirmed Then
                        GoTo NEXT_ROW
                    End If
                End If
                
                trg = Trim$(.Cells(row, cn_clm_Quantity))
                trg2 = Trim$(.Cells(row, cn_clm_Quantity).formula)
                If trg <> .Cells(row, cn_clm_Quantity) And src = trg Then
                    .Cells(row, cn_clm_Quantity) = trg
                End If
                ' weak: ignore blank target(lhs)
                If src <> trg And (isStrict Or trg <> "") Then
                    If sError = "" Then ' first time
                        .parent.Activate
                        .Activate
                        .Rows(row).Select
                    End If
                    msg = "Zeile " & row & ": '" & trg & "' <> '" & src & "'"
                    If Not checkedIssues.contains(src) Then
                        checkedIssues.Add src, row, msg, False
                    End If
                    compareRowHeaders = False
                    errorCount = errorCount + 1
                    If errorMax = 0 Or errorCount <= errorMax Then
                        sError = sError & vbCrLf & msg
                    Else
                        sError = sError & vbCrLf & " ... "
Exit Function
                    End If
                End If
NEXT_ROW:   Next row
        End If
    End With
    
    If errorCount = 0 Then
        sError = ""
        compareRowHeaders = True
    End If
    If isProtected Then protectSheet trgSheet
End Function

Private Function updateRowHeaders(srcSheet As Worksheet, trgSheet As Worksheet, checkedIssues As LiquiTokens, isStrict As Boolean) As Boolean
' key; 0=row, 1=description, 2=fixConfirmed
Dim issue As LiquiToken, i As Long, fixConfirmed As Boolean
Dim abk As Workbook, sh As Worksheet, nameSh As String, src As String, trg As String, sError As String
Dim isProtected As Boolean, isProtected2 As Boolean, row As Long
Dim found As Boolean, idx As Long
Dim tsStart As Double, tsSection As Double

    tsStart = Timer
    tsSection = Timer
    
    Set abk = srcSheet.parent
    updateRowHeaders = False ' nothing was changed yet
    
    With trgSheet
        isProtected = .ProtectContents
        .Unprotect cs_LiquiPWD
            
        For i = 1 To checkedIssues.Count
            Set issue = checkedIssues.item(i)
            row = issue.attr_0
            fixConfirmed = issue.attr_2
'Debug.Print "updateRowHeaders", srcSheet.name, trgSheet.name, row, fixConfirmed
            If fixConfirmed Then
                tsSection = Timer
                If (False) Then
'                    renameQuantity srcSheet, trgSheet, row
                ElseIf (srcSheet.Cells(row, cn_clm_Quantity) <> trgSheet.Cells(row, cn_clm_Quantity)) Then
                    doConsistentRename srcSheet, row, trgSheet.Cells(row, cn_clm_Quantity), srcSheet.Cells(row, cn_clm_Quantity), confirm:=False
                End If
'Debug.Print "updateRowHeaders A: " & (Timer - tsSection)
            End If
        Next ' issue
        
        If isProtected Then protectSheet trgSheet
    End With
End Function

Private Sub renamePlotSeries(srcCell As Range)
Dim shPlotData As Worksheet, row As Long, clm As Long, caption As String, prefix As String
Dim isProtected As Boolean

    Set shPlotData = getSheet(cs_PlotData)
    If shPlotData Is Nothing Then Exit Sub
    
    prefix = "(" & srcCell.row & ")"
    caption = plotItemName(srcCell, cn_seriesNameLength)
    With shPlotData
        isProtected = .ProtectContents
        .Unprotect cs_LiquiPWD
        For row = 1 To getLastRow(.usedRange)
            For clm = 1 To getLastColumn(.usedRange)
                If startsWith(.Cells(row, clm), prefix) Then
'Debug.Print "update", cs_PlotData, row, .Cells(row, clm), caption
                    .Cells(row, clm) = caption
                End If
        Next: Next
        If isProtected Then protectSheet shPlotData
    End With
End Sub

Private Function applyQuantityChangeToCharts(mode As Long, oldName As String, newName As String, sError As String) As Boolean
Dim wb As Workbook, dtaSheet As Worksheet, ch As Chart, sectStart As Long, row As Long, row2 As Long, row3 As Long, clm As Long
Dim idx As Long, msg As String, tmp As String
Dim isProtected As Boolean

    Set dtaSheet = getSheet(cs_GraphicsData)
    If dtaSheet Is Nothing Then Exit Function
    With dtaSheet
        isProtected = .ProtectContents
        .Unprotect cs_LiquiPWD
    End With
    
Dim tmp2 As String, tmp3 As String, pos As Long, descr As String, chartName  As String, ser As Series
    If mode = 0 Then
        ' change
        With dtaSheet
            row = 1: clm = 1
            ' find chart name (quantity of simple chart)
            findTextOrFormula dtaSheet, "[" + oldName, True, True, row, clm, , 1
            Do While row > 0
                tmp = .Cells(row, 1)
                If InStr(1, tmp, "[" & oldName) = 1 And .Cells(row + 1, 1) = "Soll" Then
                    ' single quantity chart
                    sectStart = row
                    Set ch = getSheet(oldName)
                    If ch Is Nothing Then
                        ' ignore, for the time being
                    Else
                        If (unprotectSheet(ch, True)) Then
                            tmp = .Cells(sectStart, 1)
                            tmp = Replace(tmp, oldName, newName)
                            .Cells(sectStart, 1) = tmp
                                        
                            ch.name = newName
                            tmp = ch.ChartTitle.Text
                            tmp = Replace(tmp, oldName, newName)
                            ch.ChartTitle.Text = tmp
                        End If
                        protectSheet ch
                    End If
                    
                ElseIf startsWith(tmp, oldName & "(Soll)") Or startsWith(tmp, oldName & "(Ist)") Then
                    tmp = Replace(tmp, oldName, newName)
'Debug.Print "update", cs_GraphicsData, row, .Cells(row, clm), tmp
                    .Cells(row, 1) = tmp
                    ' new chart type: find section start
                    For row2 = row - 1 To 1 Step -1
                        descr = .Cells(row2, 1)
                        If startsWith(descr, "[") Then
                            pos = InStr(1, descr, "]")
                            chartName = Mid$(descr, 2, pos - 2)
                            Set ch = getSheet(chartName)
                            If Not ch Is Nothing Then
                                If (unprotectSheet(ch, True)) Then
                                    For Each ser In ch.SeriesCollection
                                        tmp2 = getSeriesName(oldName, "", cn_seriesNameLength)
                                        If startsWith(ser.name, tmp2) Then
                                            tmp3 = getSeriesName(newName, "", cn_seriesNameLength)
'Debug.Print "update", ch.name, ser.name, tmp3
                                            ser.name = Replace$(ser.name, tmp2, tmp3)
                                        End If
                                    Next
                                End If
                                protectSheet ch
                            End If
                            Exit For
                        End If
                    Next
                End If
                row = row + 1
                findTextOrFormula dtaSheet, "[" + oldName, True, True, row, clm, , 1
            Loop
        
            ' rename quantity in multiple charts
            row = 1: clm = 1
            findTextOrFormula dtaSheet, oldName & "(Soll)", True, True, row, clm, , 1
            row2 = 0
            Do While row > 0
                If row2 = 0 Then row2 = row
                tmp = .Cells(row, 1)
                .Cells(row, 1) = Replace(tmp, oldName, newName)
                row = row + 1
                tmp = .Cells(row, 1)
                If (tmp = oldName & "(Ist)") Then
                    .Cells(row, 1) = Replace(tmp, oldName, newName)
                    row = row + 1
                End If
                
                row3 = row
                ' rename multichart series
                ' search chart name backwards; starts with "["
                For row = row2 - 1 To 1 Step -1
                    descr = .Cells(row, 1)
                    If startsWith(descr, "[") Then
                        pos = InStr(1, descr, "]")
                        chartName = Mid$(descr, 2, pos - 2)
                        Set ch = getSheet(chartName)
                        If Not ch Is Nothing Then
                            If unprotectSheet(ch, True) Then
                                tmp2 = getSeriesName(oldName, "", cn_seriesNameLength)
                                tmp3 = getSeriesName(newName, "", cn_seriesNameLength)
                                For Each ser In ch.SeriesCollection
                                    If startsWith(ser.name, tmp2) Then
'Debug.Print "update", ch.name, ser.name, tmp3
                                    ser.name = Replace$(ser.name, tmp2, tmp3)
                                    End If
                                Next
                            End If
                            protectSheet ch
                        End If
                        Exit For
                    End If
                Next
                
                ' next occurrence of oldName in some multi chart
                row = row3
                row2 = 0
                findTextOrFormula dtaSheet, oldName & "(Soll)", True, True, row, clm, , 1
            Loop
        End With
        
    ElseIf mode > 0 Then
        ' insert
        
    Else
        ' delete
    End If
    
    ' finished successfully
    sError = ""
    If isProtected Then protectSheet dtaSheet
    applyQuantityChangeToCharts = True
Exit Function

FAILED:
    If isProtected Then protectSheet dtaSheet
    applyQuantityChangeToCharts = False
End Function

Private Function validateFormulae(wsh As Worksheet, sError As String, Optional logStream As TextStream = Nothing) As LiquiYesNoCancel
Dim urg As Range, cll As Range
Dim row As Long, clm As Long, frm As String, val As Variant, evl As Variant
Dim isProtected As Boolean
Dim msg As String, tmp As String, repeat As Boolean, width As Long, height As Long


'Debug.Print "validateFormulae(..)", wsh.name
On Error GoTo FORMULA_ERROR

    validateFormulae = lqYes
    With wsh
'Debug.Print wsh.name
        If (Not unprotectSheet(wsh, True)) Then
Exit Function
        End If
        
        sError = ""
        Set urg = .usedRange
'        width = getLastColumn(urg)
        width = getDataWidth(wsh)
        height = getLastRow(urg)
'        For clm = urg.Column To width
        For row = urg.row To height
Application.StatusBar = "Formeln Blatt " & wsh.name & ", Zeile " & row
DoEvents
            clm = 0: repeat = False
            .Range(.Cells(row, 1), .Cells(row, width)) = .Range(.Cells(row, 1), .Cells(row, width)).formula
            If repeat Then
                For clm = urg.Column To width
                    .Cells(row, clm).MergeCells = False
                    Set cll = .Cells(row, clm)
                    tmp = cll.formula
                    cll.Cells(1, 1) = tmp
                Next
            End If
            For clm = urg.Column To width
                Set cll = .Cells(row, clm)
                If IsError(cll.value) Then
                    evl = cll.value
                    Select Case evl
                        Case CVErr(xlErrDiv0)
                        val = "#DIV/0!"     ' "#DIV/0! error"   ' #DIV/0!
                        Case CVErr(xlErrNA)
                        val = "#NV"         ' "#N/A error"      ' #NV
                        Case CVErr(xlErrName)
                        val = "#NAME?"      ' "#NAME? error"    ' #NAME?
                        Case CVErr(xlErrNull)
                        val = "#NULL!"      ' "#NULL! error"    ' #NULL!
                        Case CVErr(xlErrNum)
                        val = "#ZAHL!"      ' "#NUM! error"     ' #ZAHL!
                        Case CVErr(xlErrRef)
                        val = "#BEZUG!"    ' "#REF! error"      ' #BEZUG!
                        Case CVErr(xlErrValue)
                        val = "#WERT!"      ' "#VALUE! error"   ' #WERT!
                        Case Else
                        val = "This should never happen!!"
                    End Select
'Debug.Print "(" & row & "," & clm & ")", val, cll.formula
'Debug.Print wsh.name, cll.Address(RowAbsolute:=False, ColumnAbsolute:=False), val, cll.formula

                    'first error only
                    wsh.visible = xlSheetVisible: wsh.Activate: cll.Select
                    sError = "Ung|fffd|ltiger Wert auf Blatt '" & wsh.name & "':   "
                    sError = sError & "Zelle " & cll.Address(RowAbsolute:=False, ColumnAbsolute:=False) & " = " & val
                    If Not logStream Is Nothing Then logStream.WriteLine sError
                    msg = sError & vbCrLf & "Fortfahren ?"
                    ' voodoo: MsgBox invisible
                    DoEvents
                    If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel Then
                        validateFormulae = lqCancel
                    Else
                        validateFormulae = lqNo ' continue
                    End If
'If isProtected Then protectSheet wsh
'protectSheet wsh
Application.StatusBar = False
DoEvents
Exit Function
                End If
'            Next ' row
'        Next ' clm
            Next clm
        Next row
    End With ' wsh
'    If isProtected Then protectSheet wsh
'    protectSheet wsh
Application.StatusBar = False
DoEvents
Exit Function

' debugging: unexpected only
FORMULA_ERROR:
Debug.Print Err.Number, Err.Description, row, clm ', "'" & srcSheet.Cells(row, clm).formula & "'"
    If row > 0 And clm > 0 Then
        Set cll = wsh.Cells(row, clm)
        wsh.visible = xlSheetVisible: wsh.Activate: cll.Select
        sError = "Ung|fffd|ltiger Wert auf Blatt '" & wsh.name & "', "
        sError = sError & "Zelle " & cll.Address(RowAbsolute:=False, ColumnAbsolute:=False)
        sError = sError & vbCrLf & "'" & cll.formula & "'"
        If Not logStream Is Nothing Then logStream.WriteLine sError
        
        msg = sError & vbCrLf & "Fortfahren ?"
        ' voodoo: MsgBox invisible
        DoEvents
        If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel Then
            validateFormulae = lqCancel ' stop validation
        Else
            validateFormulae = lqNo ' continue
        End If
'If isProtected Then protectSheet wsh
Application.StatusBar = False
DoEvents
Exit Function

'    ElseIf clm > 0 Then
    ElseIf row > 0 Then
        DoEvents
        repeat = True
        Resume Next
    End If

End Function

Function applyQuantityChange(rowSelected As Long, mode As Long, _
            oldName As String, newName As String, prompt As Boolean, sError As String) As Boolean
Dim wb As Workbook, ws As Worksheet, ch As Chart, ob As Object, row As Long, clm As Long
Dim idx As Long, msg As String, tmp As String

    Set wb = Application.ActiveWorkbook
    
    ' input sheets (profit centers)
    For idx = 1 To gn_MainSheetIndex - 1
        Set ws = wb.Worksheets(idx)
        If Not applyQuantityChangeToTable(ws, rowSelected, mode, oldName, newName, prompt, sError) Then
            GoTo FAILED
        End If
    Next
    
    
    ' master sheets ('Plandaten'))
    For idx = 1 To gn_MainSheetIndex
        tmp = getMasterSheetName(wb.Worksheets(idx).name)
        Set ws = getSheet(tmp)
        If ws Is Nothing Then
            sError = "Blatt " & tmp & " fehlt."
            If MsgBox(sError & vbCrLf & "Continue ?", vbYesNo, cs_MsgTitle) = vbNo Then
                GoTo FAILED
            Else: sError = ""
            End If
        End If
        If Not applyQuantityChangeToTable(ws, rowSelected, mode, oldName, newName, prompt, sError) Then
            GoTo FAILED
        End If
    Next
    
    ' charts
    If Not applyQuantityChangeToCharts(mode, oldName, newName, sError) Then
        GoTo FAILED
    End If
    
    ' finished successfully
    applyQuantityChange = True
Exit Function

FAILED:
    applyQuantityChange = False
    
End Function

Private Function applyQuantityChangeToTable(ws As Worksheet, rowSelected As Long, mode As Long, _
                        oldName As String, newName As String, prompt As Boolean, sError As String) As Boolean
Dim wb As Workbook, row As Long, clm As Long
Dim isProtected As Boolean
Dim idx As Long, msg As String, tmp As String

        isProtected = ws.ProtectContents
        ws.Unprotect cs_LiquiPWD
        
        If mode = 0 Then
            tmp = ws.Cells(rowSelected, 2)
            If Trim$(tmp) <> Trim$(oldName) Then
                ' inconsistency
                ws.Activate
                ws.Cells(rowSelected, 2).Select
                If prompt Then
                    sError = ws.name & ": '" & tmp & "' != '" & oldName & "'"
                    If MsgBox(sError & vbCrLf & "Continue ?", vbYesNo, cs_MsgTitle) = vbNo Then
                        GoTo FAILED
                    Else: sError = ""
                    End If
                End If
            End If
            ws.Cells(rowSelected, 2) = newName
        ElseIf mode > 0 Then
            'insert
            ws.Rows(rowSelected).Insert
            ws.Cells(rowSelected, 1).formula = ws.Cells(rowSelected + 1, 1).formula ' row number
            ws.Cells(rowSelected, 2) = newName
            
        ElseIf mode < 0 Then
            ' delete
            tmp = ws.Cells(rowSelected, 2)
            If tmp <> oldName Then
                ' inconsistency
                ws.Activate
                ws.Cells(rowSelected, 2).Select
                sError = ws.name & ": " & tmp & " != " & oldName
                If MsgBox(sError & vbCrLf & "Continue ?", vbYesNo, cs_MsgTitle) = vbNo Then
                    GoTo FAILED
                Else: sError = ""
                End If
            End If
            ws.Rows(rowSelected).Delete
        End If
        
    ' finished successfully
    sError = ""
    If isProtected Then protectSheet ws
    applyQuantityChangeToTable = True
Exit Function

FAILED:
    If isProtected Then protectSheet ws
    applyQuantityChangeToTable = False
    
End Function

Function markOutliers(context As Range, outlierMarked As Boolean) As Range
' context: e.g. selected range, whole sheet
' outlierMarked: some cell was marked as outlier
' result: data range of selected quantities

Dim wsh As Worksheet, rng As Range, rng2 As Range, cll As Range, row As Long, clm As Long
Dim startRow As Long, endRow As Long, liquiCheckRow As Long, endClm As Long
Dim msg As String, tmp As String, idx As Long
Dim isProtected As Boolean, eventsFlag As Boolean
Dim rowHeader As String
Dim defaultColor As Long, warnColor As Long, clr As Long

Const specialRows As String = "Zinseinnahmen*Zinsertr|fffd|ge"

    Set wsh = context.parent
    With wsh
        isProtected = .ProtectContents
        .Unprotect ""
        
        ' data only (I. thru V.) ?
        ' caller to decide
'        If context.row < gn_row_Section_I_Start Or context.row > gn_row_Section_V_End Then
'            Set markOutliers = Nothing
'Exit Function
'        End If
        
        startRow = context.row
        endRow = getLastRow(context)
        For row = startRow To endRow
            rowHeader = .Cells(row, cn_clm_Quantity)
            If isSectionHeader(rowHeader) Then
                GoTo CONTINUE_OUTLIERS
            End If
            ' special cases:
            If rowHeader <> "" And InStr(1, specialRows, rowHeader) > 0 Then
                GoTo CONTINUE_OUTLIERS
            End If
            ' month names
            If IsError(.Cells(row, 3)) Or IsError(.Cells(row, 4)) Then
                GoTo CONTINUE_OUTLIERS
            End If
            If InStr(1, .Cells(row, 3), "Vorjahr") > 0 Or InStr(1, .Cells(row, 4), "Januar") > 0 Then
                GoTo CONTINUE_OUTLIERS
            End If
            
            ' January - December
            Set rng = .Range(.Cells(row, cn_clm_January), .Cells(row, cn_clm_December))
            markOutliersInRange rng, outlierMarked
            
            ' year
Const yearSumR1C1 As String = "=SUM(RC[-12]:RC[-1])"
Const yearAvgR1C1 As String = "=SUM(RC[-12]:RC[-1])/12"
Const yearDecR1C1 As String = "=RC[-1]"
Dim majCll As Range, rowMainR1C1 As String, frmlR1C1 As String
            Set majCll = getMajorityFormula(rng)
            If majCll.HasFormula Then
                rowMainR1C1 = majCll.FormulaR1C1
'            ElseIf Not IsEmpty(majCll) Then
'                rowMainR1C1 = "*"
            Else
                rowMainR1C1 = ""
            End If
            
            On Error Resume Next
            Set cll = .Cells(row, cn_clm_Year)
            frmlR1C1 = cll.FormulaR1C1
'            clr = cll.Interior.Color
'            If clr = gn_color_outlier Then
'                GoTo CONTINUE_OUTLIERS
'            End If
            
            If frmlR1C1 <> yearSumR1C1 And frmlR1C1 <> yearAvgR1C1 And frmlR1C1 <> yearDecR1C1 And _
                cll.value <> majCll.value And frmlR1C1 <> rowMainR1C1 And _
                Not IsEmpty(cll) And IsNumeric(cll) Then
                cll.Interior.Color = gn_color_outlier
                outlierMarked = True
            End If
            On Error GoTo 0
CONTINUE_OUTLIERS:
        Next
        Set markOutliers = .Range(.Cells(startRow, cn_clm_January), .Cells(endRow, cn_clm_Year))
    End With    ' wsh
End Function

' finds some prevalent formula (with the most occurrences) in rng
' and marks all non-empty cells with a different formula or value
Private Sub markOutliersInRange(rng As Range, outlierMarked As Boolean)     ' overrideMarked As Boolean,    ' strictMode As Boolean,
Dim stats As LiquiTokens, tkn As LiquiToken
Dim main As String, mainR1C1 As String, frmla As String, frmlR1C1 As String
Dim wsh As Worksheet, mainCell As Range, cll As Range, row As Long, clm As Long
Dim defaultColor As Long, warnColor As Long, clr As Long

' 8.2.0.8: obsolete
Dim strictMode As Boolean
' strict: outliers
' weak:   outliers or constant numeric formulae (w/o cell addresses)

    ' get default color (row name),  prevalent formula
    Set wsh = rng.parent
    With wsh
'        defaultColor = .Cells(rng.row, cn_clm_Quantity).Interior.ColorIndex
'        defaultColor = ga_headerColors(rng.row)
        Set mainCell = getMajorityFormula(.Range(.Cells(rng.row, cn_clm_January), .Cells(rng.row, cn_clm_December)))
    End With
    If mainCell.HasFormula Then
        main = mainCell.formula
        mainR1C1 = mainCell.FormulaR1C1
    Else
        main = ""
        mainR1C1 = ""
    End If
        
    ' mark outliers
    For Each cll In rng
        frmla = cll.formula
        frmlR1C1 = cll.FormulaR1C1
        If Not cll.HasFormula Then
            frmla = ""
            frmlR1C1 = ""
        End If
'        cll.Interior.Color = defaultColor
        
        ' skip pseudo formulae (cf. hint in user instructions about avoiding warning color)
        warnColor = gn_color_outlier
        If Not isConstantNumericFormula(cll) Then
'            If (IsNumeric(mainCell) And mainCell.HasFormula) Then
'            End If
            If frmla <> main And frmlR1C1 <> mainR1C1 Then  ' Not IsEmpty(cll) And
                cll.Interior.Color = warnColor
                outlierMarked = True ' some cell marked as outlier
            End If
                
'            clr = cll.Interior.Color
'            If Not (clr = gn_color_outlier Or clr = gn_color_outlier_) Then
'                warnColor = gn_color_outlier
'                strictMode = False
'                If frmlR1C1 <> mainR1C1 Or strictMode Then
'                    cll.Interior.Color = warnColor
'                    outlierMarked = True ' some cell marked as outlier
'                End If
'            End If
        Else
        ' ...
        End If
    Next
End Sub

' finds some prevalent formula (with the most occurrences) in context
' and marks cell with a different formula or value
' ((cf. warnProtectedCellChanged(..)))
Function markOutlierInContext(context As Range, trgCell As Range) As Boolean
Dim stats As LiquiTokens, tkn As LiquiToken
Dim main As String, maxCount As Long, key As String, cnt As Long
Dim cll As Range, row As Long, clm As Long

    markOutlierInContext = False
    
    ' find prevalent formula
    Set stats = New LiquiTokens
    main = ""
    maxCount = 0
    For clm = 1 To context.Columns.Count
        Set cll = context.Cells(1, clm)
        If IsEmpty(cll) Then
            key = "0"
        ElseIf Not cll.HasFormula Then
            key = "0"
        Else: key = cll.FormulaR1C1
        End If
        Set tkn = stats.item(key)
        If tkn Is Nothing Then
            Set tkn = stats.Add(key, 0)
        End If
        cnt = tkn.attr_0 + 1
        tkn.attr_0 = cnt
        If cnt > maxCount Then
            maxCount = cnt
            main = key
        End If
continueStats:
    Next
'Debug.Print context.row, main, maxCount

    ' mark outlier
    If main = "" Then
    ' no formula in range
Exit Function
    End If

    If IsEmpty(trgCell) Then
        key = "0"
    ElseIf Not trgCell.HasFormula Then
        key = "0"
    Else: key = trgCell.FormulaR1C1
    End If
    If key <> main Then
        trgCell.Interior.Color = gn_color_outlier
        markOutlierInContext = True
    End If
End Function

Function removeWarningColors(wbk As Workbook)
Dim wsh As Worksheet, qty As Range, cll As Range, usedRange As Range
Dim row As Long, clm As Long, idx As Long
Dim msg As String, sError As String
Dim defaultColor As Long
    
    If gs_MainSheetName = "" Or gn_MainSheetIndex = 0 Then
        Set wsh = validateMainSheet(sError)
        If wsh Is Nothing Then
            If sError <> "" Then MsgBox sError, vbExclamation, cs_MsgTitle
Exit Function
        End If
    End If
    
    On Error Resume Next
        row = 0
        row = UBound(ga_colorMap, 1)
    On Error GoTo 0
    If row = 0 Then
        Set wsh = Application.ActiveWorkbook.Worksheets(gn_MainSheetIndex)
        storeColorMap wsh
    End If
     
Dim shName As String, repeat As Boolean, lastRow As Long, lastClm As Long
'Application.StatusBar = "LiquiPlan: Warnfarben werden entfernt"
'Debug.Print "color map: ", UBound(ga_colorMap, 1), UBound(ga_colorMap, 2)
    For idx = 1 To gn_MainSheetIndex
        Set wsh = Application.ActiveWorkbook.Worksheets(idx)
        shName = wsh.name
Application.StatusBar = "LiquiPlan: Warnfarben werden entfernt, Tabelle " & wsh.name
        Set usedRange = wsh.usedRange
        repeat = True
        Do While Not usedRange Is Nothing
            lastRow = WorksheetFunction.Min(getLastRow(usedRange), UBound(ga_colorMap, 1))
            lastClm = getDataWidth(wsh)
            For row = 1 To lastRow
                For clm = 1 To lastClm
                    Set cll = wsh.Cells(row, clm)
                    If cll.Interior.Color = gn_color_outlier Then
                        cll.Interior.Color = ga_colorMap(row, clm)
                    End If
                    If cll.Interior.Color = gn_color_outlier Then
                        ' outlier color in color map: should no longer happen (cf. LibUtils.storeColorMap(..))
                        cll.Interior.Color = xlNone
                    End If
                Next
            Next
            If repeat Then
Debug.Print shName, getMasterSheetName(shName)

                Set wsh = Application.ActiveWorkbook.Worksheets(getMasterSheetName(shName))
                Set usedRange = wsh.usedRange
            Else
                Set usedRange = Nothing
            End If
            repeat = Not repeat
        Loop
    Next
Application.StatusBar = False
End Function


Function doConsistentInsert(wshSelected As Worksheet, rowSelected As Long) As String
' consistent change: ALL input sheets, master sheets, analytics sheets, diagrams
' result = "": insert was canceled
' obsolete: insertion was undone; rowSelected = where to redo insert
Dim abk As Workbook, wsh As Worksheet, cll As Range, row As Long, clm As Long, idx As Long
Dim prvPath As String, oldName As String, newName As String, msg As String
Dim isProtected As Boolean

    doConsistentInsert = ""
    If wshSelected.name <> gs_MainSheetName Then
        msg = "|fffd|nderungen in Tabelle '" & gs_MainSheetName & "' vornehmen oder |fffd|berwachung ausschalten."
        MsgBox msg, vbInformation, cs_MsgTitle
Exit Function
    End If
    
    Set abk = Application.ActiveWorkbook
    Set wsh = wshSelected
    
    ' warn if linked to previous year
    With wsh
        ' volume per month row
        row = gn_row_Section_I_Start: clm = 2
        findTextOrFormula wsh, "Umsatz Vorjahr", True, True, row, clm, , 2
        If row > 0 Then
            With .Range(.Cells(row, cn_clm_January), .Cells(row, cn_clm_December)) ' rngVolumeLastYear
                For clm = 1 To 12
                    Set cll = .Cells(1, clm)
                        If (cll.HasFormula) Then
                            prvPath = cll.formula
                            Exit For
                        End If
                Next
            End With
        End If
Dim i As Long
        i = InStr(1, prvPath, "!")
        If (i > 1) Then
            i = InStr(1, prvPath, "]")
            prvPath = Replace(Left(prvPath, i - 1), "[", "")
            prvPath = Replace(Mid(prvPath, 2), "'", "")
            msg = "Modell ist verkn|fffd|pft mit einem Vorjahresmodell:"
            msg = msg + vbLf + prvPath
            msg = msg + vbLf + vbLf + "Falls noch nicht geschehen, sollten Sie dort die gleichen |fffd|nderungen vornehmen."
            MsgBox msg, vbExclamation, cs_MsgTitle
        End If
    End With
    
    oldName = wsh.Cells(rowSelected, 2)
'Debug.Print "insert: ", wsh.name, rowSelected, oldName

    ' new name, provisional
    newName = "Neue Gr|fffd||fffd|e"      ' "+" & oldName & "+"    ' incomplete formula
    newName = Trim$(InputBox("Bitte neue Gr|fffd||fffd|e benennen.", "Gr|fffd||fffd|e einf|fffd|gen", newName))
    If newName = "" Then
        ' canceled
Exit Function
        End If
    If Not isNameUnique(newName, wsh, gn_row_Prolog_Start, gn_row_Section_IV_End, 0, 2) Then
        MsgBox "Name ist bereits in Gebrauch."
Exit Function
    End If
    doConsistentInsert = newName
    
    'insertion
    For idx = 1 To gn_MainSheetIndex
        Set wsh = abk.Worksheets(idx)
        With wsh
'            If .Cells(rowSelected, 2) <> newName Then
'            End If
            isProtected = .ProtectContents
            .Unprotect cs_LiquiPWD
            .Rows(rowSelected).Insert
            .Cells(rowSelected, 2) = newName
            .Cells(rowSelected, 1).formula = .Cells(rowSelected + 1, 1).formula
            .Cells(rowSelected, cn_clm_Year).formula = .Cells(rowSelected + 1, cn_clm_Year).formula

' ??? protection: copy .locked ??? why? must be edited anyway ???
            For Each cll In .Range(.Cells(rowSelected, 1), .Cells(rowSelected, cn_dataWidth))
                cll.Locked = cll(2, 1).Locked
            Next
            If isProtected Then protectSheet wsh
        End With
        
        Set wsh = getSheet(getMasterSheetName(wsh.name))
        With wsh
            isProtected = .ProtectContents
            .Unprotect cs_LiquiPWD
            .Rows(rowSelected).Insert
            .Cells(rowSelected, 2) = newName
            .Cells(rowSelected, 1).formula = .Cells(rowSelected + 1, 1).formula
            .Cells(rowSelected, cn_clm_Year).formula = .Cells(rowSelected + 1, cn_clm_Year).formula
            
            For Each cll In .Range(.Cells(rowSelected, 1), .Cells(rowSelected, cn_dataWidth))
                cll.Locked = cll(2, 1).Locked
            Next
            If isProtected Then protectSheet wsh
        End With
        
        If (rowSelected > gn_row_Section_III_Start And rowSelected <= gn_row_G_u_V) Then
            Set wsh = abk.Worksheets(idx)
            Set wsh = getSheet(getCompareSheetName(wsh.name))
            ' ...
        End If
    Next
    
    ' re-check section headers
Dim sError As String
    If (validateMainSheet(sError) Is Nothing) Then
        MsgBox sError, vbCritical, cs_MsgTitle
    End If

If (rowSelected > gn_row_Section_III_Start And rowSelected <= gn_row_G_u_V) Then
    ' needs update of plots and diagrams
    Set wsh = getSheet(gs_MainSheetName)
    processMonthChange Target:=wsh.Cells(gn_monthRow, 3), force:=True
End If
End Function

Function doConsistentDelete(wshSelected As Worksheet, rowSelected As Long, oldName As String) As Boolean
Dim abk As Workbook, wsh As Worksheet, row As Long, clm As Long, idx As Long
Dim isProtected As Boolean
Dim cll As Range, definition As Range, topRow As Long, msg As String, ync As Long

    doConsistentDelete = False
    If wshSelected.name <> gs_MainSheetName Then
        msg = "|fffd|nderungen in Tabelle '" & gs_MainSheetName & "' vornehmen oder |fffd|berwachung ausschalten."
        MsgBox msg, vbInformation, cs_MsgTitle
Exit Function
    End If
    
    Set cll = wshSelected.Cells(rowSelected, 2)
    With wshSelected
        Set definition = .Range(.Cells(rowSelected, 3), .Cells(rowSelected, cn_clm_Year))
    End With
    If (isNameProtected(cll.value)) Then
        MsgBox "Der Name ist gesch|fffd|tzt.", vbExclamation, cs_MsgTitle
Exit Function
    ElseIf (rowSelected >= gn_row_Prolog_Start And rowSelected < gn_row_Section_I_Start And Not isRangeEmpty(definition)) Then
        MsgBox "Der Name ist gesch|fffd|tzt.", vbExclamation, cs_MsgTitle
Exit Function
    End If
    
    ' if deleted row is referred to in a formula there will be an #REF! error
    topRow = ActiveWindow.ScrollRow
    Set cll = findReference(wshSelected, rowSelected, oldName)
    If Not cll Is Nothing Then
        cll.Select
        If cll.row > 10 Then ActiveWindow.ScrollRow = cll.row - 10
        msg = "Das L|fffd|schen von Zeile (" & rowSelected & ") " & oldName & "  w|fffd|rde eine Formel zerst|fffd|ren."
'        msg = msg & vbCrLf & "Zur|fffd|cksetzen anstelle von L|fffd|schen ?"
'        ync = MsgBox(msg, vbYesNoCancel, "|fffd|berwachung")
'        If ync = vbYes Then
'            doConsistentClear wshSelected, rowSelected, oldName, False
'Exit Function
'        ElseIf ync = vbCancel Then
'' ActiveWindow.ScrollRow = topRow
'Exit Function ' leave unchanged
'        Else
'            ' continue
'            wshSelected.Rows(rowSelected).Select
'        End If
        MsgBox msg, vbExclamation, cs_MsgTitle
Exit Function
    End If
    
    Set abk = Application.ActiveWorkbook
Debug.Print "delete: ", wshSelected.name, rowSelected, oldName

    'warn if quantity appears in some plot or diagram
    If oldName <> "" Then
        ' analytics
        Set wsh = getSheet(getCompareSheetName(wshSelected.name))
        If Not wsh Is Nothing Then
            isProtected = wsh.ProtectContents
            wsh.Unprotect cs_LiquiPWD
            For row = cn_compareRowOff To getLastRow(wsh.usedRange)
                If wsh.Cells(row, 1) = rowSelected And wsh.Cells(row, cn_clm_PlotCheck) <> "" Then
                    msg = "Gr|fffd||fffd|e (" & rowSelected & ") " & oldName & "  ist angekreuzt in Tabelle " & wsh.name & "; fortfahren ?"
                    If MsgBox(msg, vbYesNo, "Gr|fffd||fffd|e l|fffd|schen") = vbNo Then
Exit Function
                    End If
                End If
            Next
            If isProtected Then protectSheet wsh
        End If
    
        Set wsh = getSheet(cs_GraphicsData)
        With wsh
            For row = 1 To getLastRow(.usedRange)
                If InStr(1, .Cells(row, 1), oldName) > 0 Then
                    msg = "Gr|fffd||fffd|e (" & rowSelected & ") " & oldName & " ist Name oder Reihe eines Diagramms; fortfahren ?"
                    If MsgBox(msg, vbYesNo, "Gr|fffd||fffd|e l|fffd|schen") = vbNo Then
Exit Function
                    End If
                End If
            Next
        End With
    End If
    
    ' warn if linked to previous year
Dim prvPath As String, i As Long
    Set wsh = wshSelected
    With wsh
        ' volume per month row
        row = gn_row_Section_I_Start: clm = 2
        findTextOrFormula wsh, "Umsatz Vorjahr", True, True, row, clm, , 2
        If row > 0 Then
            With .Range(.Cells(row, cn_clm_January), .Cells(row, cn_clm_December)) ' rngVolumeLastYear
                For clm = 1 To 12
                    Set cll = .Cells(1, clm)
                        If (cll.HasFormula) Then
                            prvPath = cll.formula
                            Exit For
                        End If
                Next
            End With
        End If
        i = InStr(1, prvPath, "!")
        If (i > 1) Then
            i = InStr(1, prvPath, "]")
            prvPath = Replace(Left(prvPath, i - 1), "[", "")
            prvPath = Replace(Mid(prvPath, 2), "'", "")
            msg = "Modell ist verkn|fffd|pft mit einem Vorjahresmodell:"
            msg = msg + vbLf + prvPath
            msg = msg + vbLf + vbLf + "Falls noch nicht geschehen, sollten Sie dort die gleichen |fffd|nderungen vornehmen."
            MsgBox msg, vbExclamation, cs_MsgTitle
        End If
    End With
    
    ' confirm delete
    If wshSelected.name = cs_MainSheet_BasicModel Then
        msg = "Gr|fffd||fffd|e (" & rowSelected & ") '" & oldName & "'  l|fffd|schen ?"
        If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel Then
Exit Function
        End If
    ElseIf wshSelected.name = cs_MainSheet_ProfitCenter Then
        msg = "Gr|fffd||fffd|e (" & rowSelected & ") '" & oldName & "'  in Konsolidierung und ALLEN Profit Center l|fffd|schen ?"
        If MsgBox(msg, vbOKCancel, cs_MsgTitle) = vbCancel Then
Exit Function
        End If
    End If
    
    For idx = 1 To gn_MainSheetIndex
        Set wsh = abk.Worksheets(idx)
        With wsh
            isProtected = .ProtectContents
            .Unprotect cs_LiquiPWD
            .Rows(rowSelected).Delete
            If isProtected Then protectSheet wsh
        End With
        
        Set wsh = getSheet(getMasterSheetName(wsh.name))
        With wsh
            isProtected = .ProtectContents
            .Unprotect cs_LiquiPWD
            .Rows(rowSelected).Delete
            If isProtected Then protectSheet wsh
        End With
        
' ???
        If (rowSelected > gn_row_Section_III_Start And rowSelected <= gn_row_G_u_V) Then
            Set wsh = abk.Worksheets(idx)
            Set wsh = getSheet(getCompareSheetName(wsh.name))
            ' ... ~> processMonthChange(..) ...
        End If
        
    Next
    doConsistentDelete = True
    
    ' re-check section headers
Dim sError As String
    If (validateMainSheet(sError) Is Nothing) Then
        MsgBox sError, vbCritical, cs_MsgTitle
    End If
        
' issue (infinite loop)
If (rowSelected > gn_row_Section_III_Start And rowSelected <= gn_row_G_u_V) Then
    ' needs update of plots and diagrams
    Set wsh = getSheet(gs_MainSheetName)
    processMonthChange Target:=wsh.Cells(gn_monthRow, 3), force:=True
End If
End Function

Sub doConsistentClear(srcSh As Worksheet, srcRow As Long, oldName As String, confirm As Boolean)
Dim abk As Workbook, wsh As Worksheet, cmpSh As Worksheet, row As Long, clm As Long, idx As Long
Dim msg As String
Dim isProtected As Boolean
    
    Set abk = Application.ActiveWorkbook
'Debug.Print "clear: ", srcSh.name, srcRow, oldName
    
    ' for sake of simplicity, don't erase KPI (quantity used in some plot or chart)
    Set cmpSh = Nothing
    If (srcRow > gn_row_Section_III_Start And srcRow <= gn_row_G_u_V) Then
        Set cmpSh = isUsedInPlot(srcSh, srcRow)
    End If
    If (Not cmpSh Is Nothing) Then
        msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & "  ist in " & cmpSh.name & " angekreuzt."
        MsgBox msg, vbInformation, cs_MsgTitle
Exit Sub
    End If
    If (isUsedInChart(oldName)) Then
        msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & "  geh|fffd|rt zu einem Diagramm."
        MsgBox msg, vbInformation, cs_MsgTitle
Exit Sub
    End If

    ' if selected sheet is main sheet, confirm clear in ALL input and master sheets
    If (confirm And (srcSh.name = cs_MainSheet_BasicModel Or srcSh.name <> cs_MainSheet_ProfitCenter)) Then
        msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & " l|fffd|schen ?"
        If MsgBox(msg, vbYesNo, cs_MsgTitle) = vbNo Then
Exit Sub 'keep old
        End If
    ElseIf confirm And srcSh.name = cs_MainSheet_ProfitCenter Then
        msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & " in Konsolidierung und ALLEN Profit Center l|fffd|schen ?"
        If MsgBox(msg, vbYesNo, cs_MsgTitle) = vbNo Then
Exit Sub 'keep old
        End If
    End If
    
    Set wsh = srcSh
    If wsh.name <> cs_MainSheet_ProfitCenter Then
        ' basic main or some profit center
        Set cmpSh = getSheet(getCompareSheetName(wsh.name))
        With wsh
            isProtected = .ProtectContents
            .Unprotect cs_LiquiPWD
            .Range(.Cells(srcRow, cn_clm_Quantity), .Cells(srcRow, cn_dataWidth)).ClearContents
            If isProtected Then protectSheet wsh
        End With
        
        Set wsh = getSheet(getMasterSheetName(wsh.name))
        With wsh
            isProtected = .ProtectContents
            .Unprotect cs_LiquiPWD
            .Range(.Cells(srcRow, cn_clm_Quantity), .Cells(srcRow, cn_dataWidth)).ClearContents
            If isProtected Then protectSheet wsh
        End With
        
        ' analytics
        If Not cmpSh Is Nothing Then
            With cmpSh
Application.StatusBar = cmpSh.name
DoEvents
                isProtected = .ProtectContents
                .Unprotect cs_LiquiPWD
                For row = cn_compareRowOff To getLastRow(.usedRange)
                    If .Cells(row, 1) = srcRow Then
                        .Range(.Cells(row, cn_clm_Quantity), .Cells(row, 9)).ClearContents
                        .Activate
    '                    performanceAnalysis
                        Exit For
                    End If
                Next
            End With
            If isProtected Then protectSheet cmpSh
        End If
        
    Else    ' PC main: clear everywhere
        For idx = gn_MainSheetIndex To 1 Step -1
            Set wsh = abk.Worksheets(idx)
            Set cmpSh = getSheet(getCompareSheetName(wsh.name))
            With wsh
                isProtected = .ProtectContents
                .Unprotect cs_LiquiPWD
                .Range(.Cells(srcRow, cn_clm_Quantity), .Cells(srcRow, cn_dataWidth)).ClearContents
                If isProtected Then protectSheet wsh
            End With
            
            Set wsh = getSheet(getMasterSheetName(wsh.name))
            With wsh
                isProtected = .ProtectContents
                .Unprotect cs_LiquiPWD
                .Range(.Cells(srcRow, cn_clm_Quantity), .Cells(srcRow, cn_dataWidth)).ClearContents
                If isProtected Then protectSheet wsh
            End With
        
            If Not cmpSh Is Nothing Then
Application.StatusBar = cmpSh.name
DoEvents
                isProtected = cmpSh.ProtectContents
                cmpSh.Unprotect cs_LiquiPWD
                For row = cn_compareRowOff To getLastRow(cmpSh.usedRange)
                    If cmpSh.Cells(row, 1) = srcRow Then
                        cmpSh.Cells(row, cn_clm_Quantity).ClearContents
                        cmpSh.Activate
'                        performanceAnalysis
                        Exit For
                    End If
                Next
                If isProtected Then protectSheet cmpSh
            End If
        Next
    End If
    
' obsolete: KPI's ruled out above
'Dim mode As Long, sError As String
'    renamePlotSeries srcSh.Cells(srcRow, 2)    ' cf. performanceAnalysis in loop
'    mode = 0    'change
'    applyQuantityChangeToCharts 0, oldName, "", sError
    
Application.StatusBar = False
DoEvents
End Sub

Sub doConsistentRename(srcSh As Worksheet, srcRow As Long, oldName As String, newName As String, confirm As Boolean)
Dim abk As Workbook, wsh As Worksheet, cmpSh As Worksheet, cll As Range, row As Long, clm As Long, idx As Long
Dim msg As String
Dim isProtected As Boolean
Dim tsStart As Double, tsFinish As Double, tsSection As Double

    tsStart = Timer
    tsSection = Timer
    
    Set abk = Application.ActiveWorkbook
'Debug.Print "doConsistentRename:", srcSh.name, srcRow, oldName, newName
    
    ' if selected sheet is main sheet, confirm clear in ALL input and master sheets
    If confirm And srcSh.name = cs_MainSheet_BasicModel Then
        msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & " umbenennen ?"
        If MsgBox(msg, vbYesNo, cs_MsgTitle) = vbNo Then
Exit Sub 'keep old
        End If
    ElseIf confirm And srcSh.name = cs_MainSheet_ProfitCenter Then
        msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & " in Konsolidierung und ALLEN Profit Center umbenennen ?"
        If MsgBox(msg, vbYesNo, cs_MsgTitle) = vbNo Then
Exit Sub 'keep old
        End If
    End If
'Debug.Print "A: " & (Timer - tsSection)
tsSection = Timer
    
If False Then
    'warn if quantity appears in some plot or diagram
    ' analytics
    Set wsh = getSheet(getCompareSheetName(srcSh.name))
    If Not wsh Is Nothing Then
        isProtected = wsh.ProtectContents
        wsh.Unprotect cs_LiquiPWD
        For row = cn_compareRowOff To getLastRow(wsh.usedRange)
            If wsh.Cells(row, 1) = srcRow And wsh.Cells(row, cn_clm_PlotCheck) <> "" Then
                msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & " ist angekreuzt in Tabelle " & wsh.name & "; fortfahren ?"
                If MsgBox(msg, vbYesNo, "Gr|fffd||fffd|e l|fffd|schen") = vbNo Then
Exit Sub
                Else
                    Exit For
                End If
            End If
        Next
        If isProtected Then protectSheet wsh
    End If
'Debug.Print "B: " & (Timer - tsSection)
tsSection = Timer
    
    Set wsh = getSheet(cs_GraphicsData)
    With wsh
        For row = 1 To getLastRow(.usedRange)
            If oldName <> "" And InStr(1, .Cells(row, 1), oldName) > 0 Then
                msg = "Gr|fffd||fffd|e (" & srcRow & ") " & oldName & " ist Name oder Reihe eines Diagramms; fortfahren ?"
                If MsgBox(msg, vbYesNo, "Gr|fffd||fffd|e l|fffd|schen") = vbNo Then
Exit Sub
                Else
                    Exit For
                End If
            End If
        Next
    End With
End If ' false

'Debug.Print "C: " & (Timer - tsSection)
tsSection = Timer

Application.StatusBar = "Arbeitsbl|fffd|tter |fffd|ffnen"
DoEvents
    For idx = 1 To gn_MainSheetIndex
        Set wsh = abk.Worksheets(idx)
        If (Not unprotectSheet(wsh, True)) Then
Exit Sub
        End If
        Set wsh = abk.Worksheets(getMasterSheetName(wsh.name))
        If (Not unprotectSheet(wsh, True)) Then
Exit Sub
        End If
        Set wsh = abk.Worksheets(idx)
        Set wsh = abk.Worksheets(getCompareSheetName(wsh.name))
        If (Not unprotectSheet(wsh, True)) Then
Exit Sub
        End If
    Next

    Set wsh = srcSh
    If wsh.name <> cs_MainSheet_ProfitCenter Then   ' basic main or profit center
Application.StatusBar = wsh.name
DoEvents
        Set cmpSh = getSheet(getCompareSheetName(wsh.name))
        With wsh
            .Cells(srcRow, cn_clm_Quantity) = newName
        End With
        
        Set wsh = getSheet(getMasterSheetName(srcSh.name))
Application.StatusBar = wsh.name
DoEvents
        With wsh
            .Cells(srcRow, cn_clm_Quantity) = newName
        End With

        ' analytics
        If Not cmpSh Is Nothing Then
            With cmpSh
Application.StatusBar = .name
DoEvents
                For row = cn_compareRowOff To getLastRow(.usedRange)
                    If .Cells(row, 1) = srcRow Then
                        .Cells(row, cn_clm_Quantity) = newName
                        .Activate
    '                    performanceAnalysis
                        Exit For
                    End If
                Next
            End With
        End If
        
'Debug.Print "D: " & (Timer - tsSection)
tsSection = Timer
        
    Else    ' profit center main sheet ('Konsolidoerung')
        For idx = gn_MainSheetIndex To 1 Step -1
            Set wsh = abk.Worksheets(idx)
Application.StatusBar = wsh.name
DoEvents
            ' weak: quantity may be missing on PC sheet
            If (wsh.name <> cs_MainSheet_ProfitCenter And oldName <> "" And wsh.Cells(srcRow, cn_clm_Quantity) = "") Then
                GoTo NEXT_SHEET
            End If
            Set cmpSh = getSheet(getCompareSheetName(wsh.name))
            With wsh
                .Cells(srcRow, cn_clm_Quantity) = newName
            End With
            
            Set wsh = getSheet(getMasterSheetName(wsh.name))
Application.StatusBar = wsh.name
DoEvents
            With wsh
                .Cells(srcRow, cn_clm_Quantity) = newName
            End With
            
            ' analytics
            If Not cmpSh Is Nothing Then
                With cmpSh
Application.StatusBar = .name
DoEvents
                    For row = cn_compareRowOff To getLastRow(.usedRange)
                        If .Cells(row, 1) = srcRow Then
                            .Cells(row, cn_clm_Quantity) = newName
                            .Activate
'                            performanceAnalysis
                            Exit For
                        End If
                    Next
                End With
            End If
NEXT_SHEET:
        Next
        
Application.StatusBar = False
DoEvents
'Debug.Print "E: " & (Timer - tsSection)
tsSection = Timer
    End If
    
'    ' takes too long, unnecessarily
'    ' brute force update of plots and diagrams
'    Set wsh = getSheet(gs_MainSheetName)
'    processMonthChange Target:=wsh.Cells(gn_monthRow, 3), force:=True

Dim mode As Long, sError As String

    renamePlotSeries srcSh.Cells(srcRow, cn_clm_Quantity)    ' cf. performanceAnalysis in loop

    mode = 0    'change
    applyQuantityChangeToCharts mode, oldName, newName, sError
    
Application.StatusBar = "Arbeitsbl|fffd|tter schlie|fffd|en"
DoEvents
    If srcSh.name <> cs_MainSheet_ProfitCenter Then   ' basic main or single profit center
        protectSheet srcSh
        Set wsh = abk.Worksheets(getMasterSheetName(srcSh.name))
        protectSheet wsh
        Set wsh = abk.Worksheets(getCompareSheetName(srcSh.name))
        protectSheet wsh
        
    Else
        For idx = 1 To gn_MainSheetIndex
            Set wsh = abk.Worksheets(idx)
            protectSheet wsh
            Set wsh = abk.Worksheets(getMasterSheetName(wsh.name))
            protectSheet wsh
            Set wsh = abk.Worksheets(idx)
            Set wsh = abk.Worksheets(getCompareSheetName(wsh.name))
            protectSheet wsh
        Next
    End If
'Debug.Print "F: " & (Timer - tsSection)
tsSection = Timer
Application.StatusBar = False
DoEvents
End Sub

Function isSectionHeader(name As String) As Boolean
    isSectionHeader = False
    If InStr(1, LCase(name), "stammdaten") = 1 _
    Or InStr(1, LCase(name), "i. ") = 1 _
    Or InStr(1, LCase(name), "ii. ") = 1 _
    Or InStr(1, LCase(name), "iii. ") = 1 _
    Or InStr(1, LCase(name), "iv. ") = 1 _
    Or InStr(1, LCase(name), "kennzahlen") = 1 _
    Or InStr(1, LCase(name), "bewegungsbilanz") = 1 Then
        isSectionHeader = True
    End If
    If isSectionHeader = False And gn_row_Section_Custom_Start > 0 Then
Dim wsh As Worksheet, cll As Range
        Set wsh = getSheet(gs_MainSheetName)
        If Not (wsh Is Nothing) Then
            Set cll = wsh.Cells(gn_row_Section_Custom_Start, cn_clm_Quantity)
            If cll.formula <> "" And name = cll.formula Then
                isSectionHeader = True
            End If
        End If
    End If
End Function

Function isMonthHeaderRow(wsh As Worksheet, row As Long) As Boolean
        ' skip error cells
        On Error Resume Next
            isMonthHeaderRow = False
            isMonthHeaderRow = (wsh.Cells(row, cn_clm_January) = "Januar" And wsh.Cells(row, cn_clm_December) = "Dezember")
        On Error GoTo 0
End Function

Function isNameUnique(name As String, _
                ws As Worksheet, rangeStart As Long, rangeEnd As Long, rowSelected As Long, clmSelected As Long) As Boolean
Dim row As Long, clm As Long, tmp As String

    If name = "" Then
        isNameUnique = False
Exit Function
    End If
    
    isNameUnique = True
    ' if rowSelected > 0, ignore its value
    For row = rangeStart To rangeEnd
        If rowSelected <= 0 Or row <> rowSelected Then
            If ws.Cells(row, clmSelected) = name Then
                isNameUnique = False
Exit Function
            End If
        End If
    Next
End Function

Function isNameProtected(name As String) As Boolean
    isNameProtected = False
    If isSectionHeader(name) _
    Or LCase(name) = LCase(cs_MonthTitle) _
    Or LCase(name) = "gesamtumsatz" _
    Or LCase(name) = "g. u. v. vor steuern" _
    Or LCase(name) = "kontostand am 1. des monats" _
    Or LCase(name) = "kto-stand monatsende" _
    Or InStr(1, LCase(name), "kontokorrent - kredit") = 1 Then
        isNameProtected = True
    End If
End Function

Private Sub testUsedIn()
'Dim srcSh As Worksheet, srcRow As Long, cmpSh As Worksheet, cll As Range, name As String
'    getProfitCenters
'
'    Set srcSh = getSheet(getMainSheetName())
'    srcRow = 66
'    srcRow = 81
'    name = srcSh.Cells(srcRow, 2).value '  "Raumkosten / Pacht"     ' "Gesamtleistung"
'    Set cmpSh = isUsedInPlot(srcSh, srcRow)
'    If (Not cmpSh Is Nothing) Then
'Debug.Print "plot", name, cmpSh.name
'    Else
'Debug.Print "plot", name, False
'    End If
'Debug.Print "chart", name, isUsedInChart(name)
'
End Sub

Function isUsedInChart(name As String) As Boolean
Dim chartDataSh As Worksheet, srcSh As Worksheet, row As Long, clm As Long
Dim pattern As String, pattern1 As String, pattern2 As String, pattern3 As String

    Set chartDataSh = getSheet(cs_GraphicsData)
    If chartDataSh Is Nothing Then Exit Function
    
    pattern1 = "[" & name & "]"
    pattern2 = name & "(Soll)"
    pattern3 = name & "(Ist)"
    isUsedInChart = False
    With chartDataSh
        For row = 1 To getLastRow(.usedRange)
            pattern = .Cells(row, 1).value
            If (pattern = pattern1 Or pattern = pattern2 Or pattern = pattern3) Then
                isUsedInChart = True
Exit Function
            End If
        Next
    End With
End Function

Function isUsedInPlot(srcSh As Worksheet, srcRow As Long) As Worksheet
Dim abk As Workbook, wsh As Worksheet, cmpSh As Worksheet, row As Long, clm As Long, idx As Long
Dim plotDataSh As Worksheet, caption As String

    Set abk = Application.ActiveWorkbook
    Set isUsedInPlot = Nothing
    Set wsh = srcSh
    If wsh.name <> cs_MainSheet_ProfitCenter Then   ' basic main or profit center
        Set cmpSh = getSheet(getCompareSheetName(wsh.name))
        For row = cn_compareRowOff To getLastRow(cmpSh.usedRange)
            If cmpSh.Cells(row, 1) = srcRow And cmpSh.Cells(row, cn_clm_PlotCheck) <> "" Then
                Set isUsedInPlot = cmpSh
Exit Function
            End If
        Next
    Else
        For idx = gn_MainSheetIndex To 1 Step -1
            Set wsh = abk.Worksheets(idx)
            Set cmpSh = getSheet(getCompareSheetName(wsh.name))
If (Not cmpSh Is Nothing) Then
Debug.Print "isUsedInPlot(..)", cmpSh.name
            For row = cn_compareRowOff To getLastRow(cmpSh.usedRange)
                If cmpSh.Cells(row, 1) = srcRow And cmpSh.Cells(row, cn_clm_PlotCheck) <> "" Then
                    Set isUsedInPlot = cmpSh
Exit Function
                End If
            Next
End If
        Next
    End If
End Function


' ========== development ==========

'Excel Developer Reference
'WorksheetFunction.IsError Method
'Checks the type of value and returns TRUE or FALSE depending if the value refers to any error value


' ========== cemetery ==========


Attribute VB_Name = "LiquiCode"
Option Explicit

' ===== User Utility (-> DEVELOP/Macros) =====

Public Sub LiquiPlan_Aktivieren()
Dim sError As String

'    checkStatus "A"

Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False

    ' add / remove context menu
    getCodeVariant
    If gs_CodeVariant = "Variant_A" Then
        If MsgBox("(Erprobung!) Untermen|fffd|/Kontextmen|fffd| 'Modell bearbeiten' hinzuf|fffd|gen ?", vbYesNo, cs_MsgTitle) = vbYes Then
            gs_CodeVariant = "Variant_B"
        End If
    Else
        If MsgBox("Untermen|fffd|/Kontextmen|fffd| 'Modell bearbeiten' entfernen ?", vbYesNo, cs_MsgTitle) = vbYes Then
            gs_CodeVariant = "Variant_A"
        End If
    End If
    regWriteValue "CodeVariant", gs_CodeVariant
    
    removeLiquiPlanMenu
    addLiquiMenus
    
    deleteFromContextMenu "Cell"
    deleteFromContextMenu "Row"
    addToContextMenu "Cell"
    addToContextMenu "Row"
    
    If validateMainSheet(sError) Is Nothing Then
        If sError <> "" Then MsgBox sError, vbExclamation, cs_MsgTitle
Application.EnableEvents = True
Exit Sub
    End If
    
    protectAllSheets 4  ' all Liquiplan sheets
    
    frmVersion.Show vbModal

Application.DisplayAlerts = True
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Application.EnableEvents = True
Application.StatusBar = False

End Sub

Private Sub Modellschutz_|fffd|berpr|fffd|fen()
    gb_modelProtectionSuspended = False
    gb_protectionIssue = (Not restoreModelProtection())
    addLiquiMenus
End Sub

Private Sub replaceLiquiPWD()
' after changing built-in LiquiPlan PWD, cs_LiquiPWD
Dim oldPWD As String, newPWD As String
Dim wsh As Worksheet, sError As String

Application.EnableEvents = False

    If gs_MainSheetName = "" Or gn_MainSheetIndex = 0 Then
        validateMainSheet sError
    End If
    
    newPWD = cs_LiquiPWD
    oldPWD = "LiquiConsult"
    
    For Each wsh In ActiveWorkbook.Worksheets
        If (isLiquiplanSheet(wsh)) Then
Debug.Print "changeLiquiPWD()", wsh.name
        
            wsh.Unprotect oldPWD
        
            If (val(Application.Version) >= 10) Then
                wsh.Protect Password:=newPWD, userinterfaceonly:=False, _
                    DrawingObjects:=True, Contents:=True, Scenarios:=True, _
                    AllowFormattingCells:=True, AllowFormattingRows:=True, AllowFormattingColumns:=True
            Else
                wsh.Protect Password:=newPWD, userinterfaceonly:=False, _
                    DrawingObjects:=True, Contents:=True, Scenarios:=True
            End If
        End If
    Next
    
Application.EnableEvents = True
Exit Sub

PROTECTION_ERROR:
    Debug.Print wsh.name, Err.Description
    Err.Clear
    Resume Next

End Sub

Private Sub Experten_Modus()
    If (Not gb_expertMode) Then
        If (InputBox("Bitte Passwort eingeben.", cs_MsgTitle) <> cs_LiquiPWD) Then
Exit Sub
        End If
    End If
    gb_expertMode = Not gb_expertMode
    
    Call LiquiPlan_Aktivieren
End Sub

Private Sub veryHideDataSheets()
Dim ws As Worksheet, ch As Chart

    Set ws = getSheet(cs_PlotData)
    If (Not ws Is Nothing) Then ws.visible = xlSheetVeryHidden
    Set ws = getSheet(cs_GraphicsData)
    If (Not ws Is Nothing) Then ws.visible = xlSheetVeryHidden
    Set ws = getSheet(cs_optionsSheetName)
    If (Not ws Is Nothing) Then ws.visible = xlSheetVeryHidden
End Sub

Private Sub unhideVeryHidden()
Dim ws As Worksheet, ch As Chart

    For Each ws In ActiveWorkbook.Worksheets
        If (ws.visible = xlSheetVeryHidden) Then
            ws.visible = xlSheetVisible
        End If
    Next
    For Each ch In ActiveWorkbook.Charts
        If (ch.visible = xlSheetVeryHidden) Then
            ch.visible = xlSheetVisible
        End If
    Next
End Sub


' ===== User Functions (-> formulae) =====

Public Function MitZiel(paramCell As Range, sourceCell As Range, Optional sourceRow As Range) As Double
'user-defined function to appear in formulae
'derives and adds fractional values from two contiguous months
'if month is in previous year, it takes the value from the righthand edge
'(appear in reverse order (1st ~ December, 2nd ~ November, etc.)
'argument sourceRow for automatic calculate only; not used here (voodoo ?)

Dim sh As Worksheet
Dim prm As Long, base As Long, days As Long
Dim fraction As Double, value1 As Double, value2 As Double
Dim srcVal(0 To 1) As Double, i As Long
Dim srcRow As Long, srcClm As Long

On Error GoTo CRASH ' due to erroneous cells
    
    Set sh = sourceCell.parent
    prm = paramCell.value
    base = Int(prm / 30)
    days = prm - base * 30
    
    srcRow = sourceCell.row
    srcClm = sourceCell.Column - base - IIf(days > 0, 1, 0)
    fraction = days / 30
    
    For i = 0 To 1
        If srcClm + i >= 4 Then  'this year
            srcVal(i) = sh.Cells(srcRow, srcClm + i)
        Else
            srcVal(i) = sh.Cells(srcRow, 17 + (3 - srcClm - i))
        End If
    Next
    
    If days = 0 Then
        MitZiel = srcVal(0)
    Else: MitZiel = srcVal(0) * fraction + srcVal(1) * (1 - fraction)
    End If
Exit Function

CRASH:
Debug.Print "MitZiel: ", sh.name, srcRow, srcClm, i
    MitZiel = 0
Exit Function
    
End Function

Attribute VB_Name = "LiquiDevelop_"
Option Explicit

'===================================
'Entwicklung
'===================================

' cf. exported code modules

'http://stackoverflow.com/questions/8701967/get-path-of-program-files-folder-that-contains-32-bit-programs
Function Get32BitProgramFilesPath() As String
    If Environ("ProgramW6432") = "" Then
       '32 bit Windows
       Get32BitProgramFilesPath = Environ("ProgramFiles")
    Else
       '64 bit Windows
       Get32BitProgramFilesPath = Environ("ProgramFiles(x86)")
    End If
End Function

''http://www.java2s.com/Code/VBA-Excel-Access-Word/Excel/CheckingtheStatusofAlltheLinksinaWorkbook.htm
Function GetLinkStatus(wb As Workbook, sLink As String) As String
    Dim avLinks As Variant
    Dim nIndex As Integer
    Dim sResult As String
    Dim nStatus As Integer

    avLinks = wb.LinkSources(xlExcelLinks)
    If IsEmpty(avLinks) Then
        GetLinkStatus = "No links in workbook."
        Exit Function
    End If
    For nIndex = 1 To UBound(avLinks)
        If StrComp(avLinks(nIndex), sLink, vbTextCompare) = 0 Then
            nStatus = ActiveWorkbook.LinkInfo(sLink, xlLinkInfoStatus)
            Select Case nStatus
                Case xlLinkStatusCopiedValues
                    sResult = "Copied values"
                Case xlLinkStatusIndeterminate
                    sResult = "Indeterminate"
                Case xlLinkStatusInvalidName
                    sResult = "Invalid name"
                Case xlLinkStatusMissingFile
                    sResult = "Missing file"
                Case xlLinkStatusMissingSheet
                    sResult = "Missing sheet"
                Case xlLinkStatusNotStarted
                    sResult = "Not started"
                Case xlLinkStatusOK
                    sResult = "OK"
                Case xlLinkStatusOld
                    sResult = "Old"
                Case xlLinkStatusSourceNotCalculated
                    sResult = "Source not calculated"
                Case xlLinkStatusSourceNotOpen

                    sResult = "Source not open"
                Case xlLinkStatusSourceOpen
                    sResult = "Source open"
                Case Else
                    sResult = "Unknown status code"
            End Select
            Exit For
        End If
    Next
    GetLinkStatus = sResult
End Function

Attribute VB_Name = "LiquiHtmlColors_"
Option Explicit

' cf. exported code modules

Function showRGB(clr As Long)
Dim xColor As String
    xColor = Right("000000" & Hex(clr), 6)
    showRGB = Right(xColor, 2) & Mid(xColor, 3, 2) & Left(xColor, 2)
End Function


Attribute VB_Name = "LiquiToken"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public key As String
Public attr_0 As Variant
Public attr_1 As Variant
Public attr_2 As Variant
Public attr_3 As Variant
Public attr_4 As Variant
Public attr_5 As Variant
Public attr_6 As Variant
Public attr_7 As Variant
Public attr_8 As Variant
Public attr_9 As Variant


Attribute VB_Name = "LiquiTokens"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_Col As Collection

Public Function Add(key As String, _
        Optional att0 As Variant, Optional att1 As Variant, _
        Optional att2 As Variant, Optional att3 As Variant, _
        Optional att4 As Variant, Optional att5 As Variant, _
        Optional att6 As Variant, Optional att7 As Variant, _
        Optional att8 As Variant, Optional att9 As Variant) As LiquiToken
Dim nw As LiquiToken
    Set nw = New LiquiToken
    nw.key = key
    
    If IsObject(att0) Then
        Set nw.attr_0 = att0
    Else
        nw.attr_0 = att0
    End If
    If IsObject(att1) Then
        Set nw.attr_1 = att1
    Else
        nw.attr_1 = att1
    End If
    If IsObject(att2) Then
        Set nw.attr_2 = att2
    Else
        nw.attr_2 = att2
    End If
    If IsObject(att3) Then
        Set nw.attr_3 = att3
    Else
        nw.attr_3 = att3
    End If
    If IsObject(att4) Then
        Set nw.attr_4 = att4
    Else
        nw.attr_4 = att4
    End If
    If IsObject(att5) Then
        Set nw.attr_5 = att5
    Else
        nw.attr_5 = att5
    End If
    If IsObject(att6) Then
        Set nw.attr_6 = att6
    Else
        nw.attr_6 = att6
    End If
    If IsObject(att7) Then
        Set nw.attr_7 = att7
    Else
        nw.attr_7 = att7
    End If
    If IsObject(att8) Then
        Set nw.attr_8 = att8
    Else
        nw.attr_8 = att8
    End If
    If IsObject(att9) Then
        Set nw.attr_9 = att9
    Else
        nw.attr_9 = att9
    End If
    
    If Len(key) = 0 Then
        m_Col.Add nw
    Else
        m_Col.Add nw, key
    End If

    Set Add = nw
    Set nw = Nothing
End Function

Public Property Get item(vntIndexOrKey As Variant) As LiquiToken
Attribute item.VB_UserMemId = 0
'Omit Item: > Tools/Procedure Attributes/Advanced: ProcedureID = (Default)
    Set item = Nothing
    On Error Resume Next
    Set item = m_Col(vntIndexOrKey)
    On Error GoTo 0
End Property

Public Property Get Count() As Long
    Count = m_Col.Count
End Property

Public Property Get contains(key As String) As Long
Dim token As LiquiToken
    Set token = Nothing
    On Error Resume Next
    Set token = m_Col(key)
    On Error GoTo 0
    contains = Not token Is Nothing
End Property

Public Sub remove(vntIndexOrKey As Variant)
    m_Col.remove vntIndexOrKey
End Sub

Private Sub Class_Initialize()
    Set m_Col = New Collection
End Sub

Private Sub Class_Terminate()
    Set m_Col = Nothing
End Sub



Attribute VB_Name = "LiquiVBEIndex_"
Option Explicit

' cf. exported code modules

Private Sub findGarbage()
' outputs list of blocks of commented lines
Dim vbProj As VBIDE.VBProject
Dim vbComp As VBIDE.VBComponent
Dim codeMod As VBIDE.CodeModule
Dim procName As String, procKind As VBIDE.vbext_ProcKind

Dim moduleName As String
Dim blockFirstLine As String, line As String
Dim moduleSize As Long, lineNum As Long, firstLineNum As Long, blockSize As Long

Const minSize As Long = 30
Const modulesToExclude As String = "LiquiVersion,LiquiDevelop,LiquiVBEIndex"     ' ,LibCommon
    
    Set vbProj = ActiveWorkbook.VBProject
    For Each vbComp In vbProj.VBComponents
        DoEvents
        moduleName = ""
        If (InStr(1, modulesToExclude, vbComp.name, vbTextCompare) > 0) Then
            GoTo CONTINUE_FOR
        End If
        If (vbComp.Type = vbext_ct_Document Or vbComp.Type = vbext_ct_MSForm Or vbComp.Type = vbext_ct_StdModule Or vbComp.Type = vbext_ct_ClassModule) Then
            moduleName = vbComp.name
            Set codeMod = vbComp.CodeModule
            With codeMod
                moduleSize = .CountOfLines
                lineNum = 1
                blockSize = 0
                Do While lineNum <= moduleSize
                    line = Trim(.lines(lineNum, 1))
                    If startsWith(line, "'") Then
                        If blockSize = 0 Then
                            ' start new block
                            procName = codeMod.ProcOfLine(lineNum, procKind)
                            blockFirstLine = .lines(lineNum, 1)
                            firstLineNum = lineNum
                            blockSize = 1
                        Else
                            blockSize = blockSize + 1
                        End If
                        GoTo CONTINUE_DO
                    ElseIf line = "" And blockSize > 0 Then
                        blockSize = blockSize + 1
                        GoTo CONTINUE_DO
                    Else
                        ' finish block
                        If blockSize >= minSize Then
Debug.Print moduleName, procName, blockSize, firstLineNum, blockFirstLine
                        End If
                        blockSize = 0
                    End If
CONTINUE_DO:
                    lineNum = lineNum + 1
                Loop
                ' finish last block
                If blockSize >= minSize Then
Debug.Print moduleName, procName, blockSize, firstLineNum, blockFirstLine
                End If
                blockSize = 0
            End With
        End If
CONTINUE_FOR:
    Next vbComp
End Sub


Attribute VB_Name = "LiquiVersion"
Option Explicit

' ===== Office Versions =====
' Tools/Project Properties/Conditional Compilation Arguments
' Extras/Eigenschaften von VBA Projekt/Argumente f|fffd|r bedingte Kompilierung
'   OFFICE_VERSION = 15 (>= Office 2013):   FullSeriesCollection, filter
'                    14 (<= Office 2010):   no     -"-
'                    12 (<= Office 2007):   no 'PtrSafe', no Win64
' ==========



' Version: m.h.n.d:
'   m ~ Liquiplan Modell
'   h ~ wesentliche |fffd|nderung: Liquiplan Men|fffd|, Funktionen
'   n ~ kleinere Code |fffd|nderung, neu auf SCR Server
'   d ~ nur Entwicklung (auf Server = 0)
'

' ToDo:
' doc, comment 'LiquiPlan'


Public Const cs_Version As String = "8.4.0.1"
Public Const cs_CodeVariant As String = "Variant_A"

Public Const cs_VersionSuffix As String = "c"
' menu item 'Formel|fffd|berwachung': entfernen ?

'Public Const cs_VersionSuffix As String = "b"
' + modelprotection: data width + user margin (( lockUnlockMonth(..) ))
' +     part of model validation ? model init !
' + separately, protectAllSheets !


'Public Const cs_VersionSuffix As String = "a"
' + code update, new model: close all in order to avoid VBA project confusion
' + run time error 13 (types incompatible) due to error cells (#DIV/0!)
' + run time error due to merged cells in LiquiCheck
' + events disabled after code update
' + must remove menu, context menus @ close

'Public Const cs_VersionSuffix As String = " beta"
'
' beta release: one version (( ~ 8.3)), two variants
'   A ~ 8.2.0.9 without sub menu / context menu 'Modell bearbeiten'
'   B ~ 8.3.0.9 with ...
' default:
'Public Const cs_CodeVariant As String = "Variant_A"
' + allow user to add/remove sub menu:
'       + macro LiquiPlan_Aktivieren()
'       + code variant ~> registry (per doc name)


'Public Const cs_Version As String = "8.3.0.9"
'Public Const cs_CodeVariant As String = "Variant_B"
''
'' one version (( ~ 8.3)), two variants
''   A ~ 8.2.0.9 without sub menu / context menu 'Modell bearbeiten'
''   B ~ 8.3.0.9 with ...
'
'Public Const cs_VersionSuffix As String = "a"
'' + must not normalize quantity names during validateMainSheet ((no unprotect during WIndow_Activate))
'' + only one warning color: gn_color_outlier (magenta)
'' + replace ga_quantityColors(), ga_headerColors() by ga_colorMap()
'' + findCodeGarbage ~> LiquiVBEIndex



'Public Const cs_Version As String = "8.4-B.0.1"
'' experimental: same version
''   A: without sub menu / conext menu 'Modell bearbeiten'
''   B: with ... (( ~ 8.3))
'Public Const cs_CodeVariant As String = "Variant_B"
'
'Public Const cs_VersionSuffix As String = "b"
'
' data import (context operation) more flexible: allow selecting of source range
'   enable editing of data range


'Public Const cs_Version As String = "8.3.0.8"
' synchronize 8.2 ~ 8.3

'Public Const cs_VersionSuffix As String = "i"
'
' user instructions update
'   unlock column 'Grafik' of performance analysis
'


'Public Const cs_VersionSuffix As String = "h"
'
' remove experimental timer
' remove LiquiOptions
'
' watch profit center group
'


'Public Const cs_VersionSuffix As String = "g"
'
' + enable/disable menu protection command
'   + experimental timer


'Public Const cs_VersionSuffix As String = "f"
'
' + VBE index: patterns in modules to exclude
'
' + clean-up: cemeteries, orphans


'Public Const cs_VersionSuffix As String = "e"
'
' + Excel colors
'   + interior.color, interior.colorindex
'   + lngColor = RGB(10, 20, 50); ActiveWorkbook.Colors(colorIndex) = lngColor
'
'   + .Interior.ColorIndex ~> .Interior.color
'   + ga_quantityColors(row), ga_headerColors(row)
'   + cn_clrX_... ~> gn_color_...
'
' + VBE index: patterns in modules to exclude


'Public Const cs_VersionSuffix As String = "d"
'
' + overrideMarked ~~ outlierMarked
'
' + code update: options comments, outliers
'
' + ga_quantityColors(row), ga_headerColors(row)


'Public Const cs_Version As String = "8.3.0.7"

'Public Const cs_VersionSuffix As String = "c"
'
' markCellInContext, cellCheckQuantity
'   override != outlier
'   row != year column, quty column ~> both ((~ whole sheet))
'   prevalent of each whole row


'Public Const cs_VersionSuffix As String = "b"
'Public Const cs_VersionSuffix As String = "a"
'
' update: 8.2.0.8 ~> 8.3
'   data width, user margin
'   outliers, pseudo formulae
'   remove warning colors, default color
'   hide master sheets
'   status bar

'Public Const cs_Version As String = "8.3.0.6"
'Public Const cs_VersionSuffix As String = ""
'

'Public Const cs_Version As String = "8.3.0.5"
'Public Const cs_VersionSuffix As String = "b"
'
' fixed LibData.copyData to include Comments (Fr. Kraft / Halaga)


'Public Const cs_Version As String = "8.3.0.4"
'Public Const cs_VersionSuffix As String = "d"
'
' show/hide plot check column, prompt 'delete plots?' if no KPI checked
'
' fixed removeLinks(..) / modelUpdate: protected non-Liqui sheets
' fixed sequence Open()/Window_Activate ~> initializeModel()
'   issue: during Open(), ActiveWorkbook maybe nothing
'
' no adding of sheets in validateMainSheet(..)
'   issue: calls itself, indirectly, via SheetsWatch



'Public Const cs_Version As String = "8.3.0.3"
'Public Const cs_VersionSuffix As String = "g"
'
' validateMainSheet(..): section VI = custom section, after section V = "Kennzahlen" (KPI); cf: F|fffd|rster
'
' PWD := ""
'
' cell context, edit unnamed row
'
' sh.Protect: UserInterfaceOnly:=False !!!
' user changed PWD
'
' fixed updateModel(): PWD protection
'
' fixed createModel(..): w/o Vorjahr must clear links, constants in column 3; only if proper annual sum
' fixed createModel(): redundant inner loops (master sheets, performance analysis)
'
' fixed rebuildTableAndPlots(..)
'   table row-off
'   after rowInsert/Delete
'   month change only if cmp sheet visible
'
' fixed create/update simple/multi chart
'   data sheet descriptors
'   chart names
'   graphics data sheet clean-up


'Public Const cs_Version As String = "8.3.0.2"
'Public Const cs_VersionSuffix As String = "d"
' Code clean-up
'   * find unused procedures (VBE index)
'   * obsolete code, commented out
' fixed cellCheckQuantity()
' fixed .FilterIndex in createModel()
' fixed isLiquiplanSheet(..)
'
' sh.Protect: UserInterfaceOnly
'   * cf. clearInputData(..), Copy&Paste issue
'
' "Datenfelder l|fffd|schen"
'   * Blatt/Modell
'   * mit/ohne Stamm-/Kontrolldaten
'
' DeveloperMode:
'   * LiquiMacro, PWD protected
'   * sh.Unprotect enable/disable
'

'Public Const cs_Version As String = "8.3.0.1"
'Public Const cs_VersionSuffix As String = "c"
' Re-organize protection
'   * simplify rules: Excel sheet protection vs. Liqui control

' Liqui Context Menu (model edit)
'   * Cell(s)
'   * Row

' Fix profit centers after sheets were moved, inserted or deleted

' Code clean-up
'   * find unused procedures (VBE index)

' ========== history ==========

'Public Const cs_Version As String = "8.2.0.7"
'Public Const cs_VersionSuffix As String = "p"
' Prompt: Plandaten speichern im Berichtszustand.
' Auf Profit-Center Modell (Halaga) |fffd|bertragen
'   * N|fffd|chstes Jahr einrichten
'   * Verbindung Vorjahr erneuern
' create chart, update chart
'   * quantity vs. legal chart name
'   FullSeriesCollection, filter
' "Soll/Ist-Vergleich": ... und Diagramme.
' FullSeriesCollection, filter doesn't work for Office 14.0 (2010) or older
'   * option: #Const OFFICE_VERSION = 15
'   * default: #Const OFFICE_VERSION = 14
'   * compiler constants (#Const ...) are defined per module only
'   * unless declared in Project Properties !!!
' ToDo:
' Re-organize protection
'   * simplify rules: Excel sheet protection vs. Liqui control
'   * code clean-up
' Liqui Context Menu
'   * Cell(s)
'   * Row
'   * Column


'Public Const cs_Version As String = "8.2.0.6"
'Public Const cs_VersionSuffix As String = "a"
' renamed menu ~> 'Verbindung mit Vorjahr erneuern'
' fixed: unprotected Application.undo
' clean-up protection (level) mess
' OriginalPlanDaten: |fffd|nderung m|fffd|glichst/nur in U & L


'Public Const cs_Version As String = "8.2.0.5"
'Public Const cs_VersionSuffix As String = "b"
' fixed: consistency check @ copyPreviousYear()
' fixed: previous year already open

'Public Const cs_VersionSuffix As String = "a"
' data: VG Services

'Public Const cs_VersionSuffix As String = " dev"
'8.2.0.5 Start next year: previous year ~> values|links
' fixed crash in protectUnprotectMonth()
' fixed #DIV/0 in calculations
' data: ACME 2017
' 3 options: prolog, data, previous year + (value | link)
' shipped: VG Services 'aktualisiert' ~> J|fffd|rg 20189-01-08

'Public Const cs_Version As String = "8.2.0.4"
'8.2.0.4 Copy 'n Paste between books: must not protect/unprotect sheets during _WindowActivate

'Public Const cs_Version As String = "8.2.0.3"
'8.2.0.3: Options sheet

'Public Const cs_Version As String = "8.2.0.2"
'Public Const cs_Version As String = "8.2.0.1"
'   alpha, beta; spezial Office 2007
'Public Const cs_VersionSuffix As String = " dev"   '""

'Public Const cs_Version As String = "8.1.0.0"
''   alpha, beta; spezial Office 2007
'Public Const cs_VersionSuffix As String = ""


'Public Const cs_Version As String = "8.0.1.5"
'Public Const cs_VersionSuffix As String = " (2007)"

'Public Const cs_Version As String = "8.0.1.4"
'Public Const cs_VersionSuffix As String = " (2007)"
'   Kommentare |fffd|berarbeitet

'Public Const cs_Version As String = "8.0.1.3"
'Public Const cs_VersionSuffix As String = " dev"
'Public Const cs_VersionSuffix As String = " beta"


Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "SheetsWatch"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' must be illegal in sheet name
Private Const listSep As String = "*"

Private currentWorkbook As Workbook
Private currentTables As String
Private currentTablesCount As Long
Private currentCharts As String
Private currentChartsCount As Long
'

Private Sub Class_Initialize()
    ' ~> user: setWorkbook
End Sub

Public Sub setWorkbook(wb As Workbook)
    Set currentWorkbook = wb
'Debug.Print "init sheets watch:", wb.name, wb.Path
    updateLists
'Debug.Print currentTables
'Debug.Print currentCharts
End Sub

Public Function getWorkbook() As Workbook
    Set getWorkbook = currentWorkbook
End Function

Public Sub updateLists()
    setCurrentTables
    setCurrentCharts
End Sub

Private Sub setCurrentTables()
Dim ws As Worksheet, ch As Chart, ob As Object
Dim res As String
    res = ""
    For Each ws In currentWorkbook.Worksheets
        res = res & ws.name & listSep
    Next
    currentTables = res
    currentTablesCount = currentWorkbook.Worksheets.Count
End Sub

Private Sub setCurrentCharts()
Dim ws As Worksheet, ch As Chart, ob As Object
Dim res As String
    res = ""
    For Each ch In currentWorkbook.Charts
        res = res & ch.name & listSep
    Next
    currentCharts = res
    currentChartsCount = currentWorkbook.Charts.Count
End Sub

Public Function getAddedSheets() As String
Dim ws As Worksheet, ch As Chart, ob As Object
Dim res As String
    res = ""
    If currentWorkbook.Worksheets.Count <> currentTablesCount Then
        For Each ws In currentWorkbook.Worksheets
            If InStr(1, LCase$(currentTables), LCase$(ws.name) & listSep) = 0 Then
                res = res & ws.name & listSep
            End If
        Next
    End If
    If currentWorkbook.Charts.Count <> currentChartsCount Then
        For Each ch In currentWorkbook.Charts
            If InStr(1, LCase$(currentCharts), LCase$(ch.name) & listSep) = 0 Then
                res = res & ch.name & listSep
            End If
        Next
    End If
    getAddedSheets = res
End Function

Public Function getDeletedSheets() As String
Dim ws As Worksheet, ch As Chart, ob As Object
Dim shName As String, res As String, tmp As String
    res = ""
    If currentWorkbook.Worksheets.Count <> currentTablesCount Then
        tmp = currentTables
        Do While tmp <> ""
            shName = nextValue(tmp, listSep)
            Set ob = getSheet(shName)
            If ob Is Nothing Then
                res = res & shName & listSep
            End If
        Loop
    End If
    If currentWorkbook.Charts.Count <> currentChartsCount Then
        tmp = currentCharts
        Do While tmp <> ""
            shName = nextValue(tmp, listSep)
            Set ob = getSheet(shName)
            If ob Is Nothing Then
                res = res & shName & listSep
            End If
        Loop
    End If
    getDeletedSheets = res
End Function

Public Function getRenamedSheets() As String
' in combination whith SheetActivate: at most one at a time; return pair old*new
Dim ws As Worksheet, ch As Chart, ob As Object
Dim shName As String, res As String, tmp As String, idx As Long
    res = ""
'Debug.Print currentWorkbook.name
    If currentWorkbook.Worksheets.Count = currentTablesCount Then
        tmp = currentTables
        idx = 0
        Do While tmp <> ""
            idx = idx + 1
            Set ws = currentWorkbook.Worksheets(idx)
            shName = nextValue(tmp, listSep)
            If LCase(shName) <> LCase(ws.name) Then
                Set ob = getSheet(shName)
                If ob Is Nothing Then
                    res = res & shName & listSep & ws.name
                End If
            End If
        Loop
    End If
    If currentWorkbook.Charts.Count = currentChartsCount Then
        tmp = currentCharts
        idx = 0
        Do While tmp <> ""
            idx = idx + 1
            Set ch = currentWorkbook.Charts(idx)
            shName = nextValue(tmp, listSep)
            If LCase(shName) <> LCase(ch.name) Then
                Set ob = getSheet(shName)
                If ob Is Nothing Then
                    res = res & shName & listSep & ch.name
                End If
            End If
        Loop
    End If
    getRenamedSheets = res
End Function

Public Function getMovedSheets() As String
Dim ws As Worksheet, ch As Chart, ob As Object
Dim shName As String, res As String, tmp As String, idx As Long
    res = ""
    If currentWorkbook.Worksheets.Count = currentTablesCount Then
        tmp = currentTables
        idx = 0
        Do While tmp <> ""
            idx = idx + 1
            Set ws = currentWorkbook.Worksheets(idx)
            shName = nextValue(tmp, listSep)
            If LCase(shName) <> LCase(ws.name) Then
                If InStr(1, LCase(currentTables), LCase(ws.name) & listSep) > 0 Then
                    res = res & shName & listSep
                End If
            End If
            Set ws = Nothing
        Loop
    End If
    If currentWorkbook.Charts.Count = currentChartsCount Then
        tmp = currentCharts
        idx = 0
        Do While tmp <> ""
            idx = idx + 1
            Set ch = currentWorkbook.Charts(idx)
            shName = nextValue(tmp, listSep)
            If LCase(shName) <> LCase(ch.name) Then
                If InStr(1, LCase(currentCharts), LCase(ch.name) & listSep) > 0 Then
                    res = res & shName & listSep
                End If
            End If
            Set ch = Nothing
        Loop
    End If
    getMovedSheets = res
End Function

Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "frmClearData"
Attribute VB_Base = "0{A600A784-C04C-4848-BEAD-7BBE847B9F58}{D0D343DF-334C-4F6F-A759-764B0AAFE308}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False












Option Explicit

Private Sub btnCancel_Click()
    gb_isUserOK = False
    Unload Me
End Sub

Private Sub btnOK_Click()
    gb_isUserOK = True
    Unload Me
End Sub


Attribute VB_Name = "frmFormulaProtect"
Attribute VB_Base = "0{54F7A0B2-D045-4653-B799-6CB7ACB6FCB4}{90FFEA8D-5A43-4931-B01B-AD705E406969}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





















Option Explicit

Private Sub btnCancel_Click()
    gb_isUserOK = False
    Unload Me
End Sub

Private Sub btnOK_Click()
    gb_isUserOK = True
    Unload Me
End Sub


Attribute VB_Name = "frmInput"
Attribute VB_Base = "0{2C2FD980-415D-4A32-A98C-6275D887B4D2}{67A1263D-6684-4058-AD74-442C93E06A82}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
















Option Explicit

Private Sub btnCancel_Click()
    gb_isUserOK = False
    Unload Me
End Sub

Private Sub btnOK_Click()
    gb_isUserOK = True
    Unload Me
End Sub


Attribute VB_Name = "frmListBox"
Attribute VB_Base = "0{288BBC8B-B6B0-4F79-B95D-E71F78E7E373}{68B3358E-77F9-4A9B-BC6E-528E2A9F6272}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





















Option Explicit

Public userAction As LiquiYesNoCancel
Public source As LiquiTokens
'

Private Sub UserForm_Initialize()
'
End Sub

Private Sub UserForm_Terminate()
'
End Sub

Private Sub btnYes_Click()
    userAction = lqYes
    Me.Hide
End Sub

Private Sub btnNo_Click()
    userAction = lqNo
    Me.Hide
End Sub

Private Sub btnCancel_Click()
    userAction = lqCancel
    Me.Hide
End Sub

' unfinished
Public Sub layout(source As LiquiTokens, mode As fmMultiSelect)
' (key As String, Optional att0 ... att9 As Variant) As LiquiToken
' key:  row number as String (quick-sorted)
' att0: row title as String
' att1: selected as Boolean
    Set Me.source = source
End Sub

'Private Sub testListBox() : cf. LiquiDevelop


Attribute VB_Name = "frmNewModel"
Attribute VB_Base = "0{112D458B-3AF6-4EE2-B49F-C1B093D64DC1}{231D2777-2DF9-4BCE-ACFF-FC2A38C5D7EB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub btnCancel_Click()
    gb_isUserOK = False
    Unload Me
End Sub

Private Sub btnOK_Click()
    gb_isUserOK = True
    Unload Me
End Sub

Private Sub chkOption1_Click()
'    Me.chkOption3.Enabled = Me.chkOption1.value
'    Me.radioButton3a.Enabled = Me.chkOption3.Enabled And Me.chkOption3.value
'    Me.radioButton3b.Enabled = Me.chkOption3.Enabled And Me.chkOption3.value
End Sub

Private Sub chkOption3_Click()
    Me.radioButton3a.Enabled = Me.chkOption3.Enabled And Me.chkOption3.value
    Me.radioButton3b.Enabled = Me.chkOption3.Enabled And Me.chkOption3.value
End Sub

Attribute VB_Name = "frmOptions"
Attribute VB_Base = "0{20B9554A-3C83-4198-B504-7B35CA129719}{69CFDFE4-22DD-4A6F-B4EB-56DFF7467370}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub btnCancel_Click()
    gb_isUserOK = False
    Unload Me
End Sub

Private Sub btnOK_Click()
    gb_isUserOK = True
    Unload Me
End Sub

Private Sub chkOption2_Click()
    Me.radioButton2a.Enabled = Me.chkOption2.value
    Me.radioButton2b.Enabled = Me.chkOption2.value
End Sub
Attribute VB_Name = "frmPretty"
Attribute VB_Base = "0{FE7BB640-BBB2-4E9D-AF36-720E452099DB}{E9A0C7DA-F74C-46A4-8AB1-83F92EB6C3AD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






Option Explicit


'#If OFFICE_VERSION >= 14 Then   '>= 2010
'Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As Any) As Long
'Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
'Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
'#Else   '<= 2007
'Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As Any) As Long
'Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal HWnd As Long, ByVal nIndex As Long) As Long
'Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal HWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
'#End If

Private WithEvents app As Application
Attribute app.VB_VarHelpID = -1

Private off_txtFormula_Width As Double
Private off_txtFormula_Height As Double
Private off_txtStatus_Top As Double
Private off_cmdSave_Top As Double
Private off_txtStatus_Width As Double
Private off_cmdClose_Left As Double
Private off_cmdClose_Top As Double
'

Private Sub app_SheetActivate(ByVal sh As Object)
    refreshFormula
End Sub

Private Sub app_SheetChange(ByVal sh As Object, ByVal Target As Range)
    If (TypeOf Selection Is Range) Then
        If Target.Address(False, False, xlA1, True) = Selection.Address(False, False, xlA1, True) Then
            refreshFormula
        End If
    End If
End Sub

Private Sub app_SheetSelectionChange(ByVal sh As Object, ByVal Target As Range)
    refreshFormula
End Sub

Private Sub refreshFormula()
Dim strFormula As String
    If (TypeOf Selection Is Range) Then
        strFormula = prettyLiquiFormula(Selection(1))
        txtFormula.Text = strFormula
        txtFormula.SelStart = 0
    End If
End Sub

Private Sub cmdSave_Click()
Dim sh As Worksheet, Cell As Range, prettyFormula As String
Dim fd As office.FileDialog
Dim fdfs As FileDialogFilters, fdf As FileDialogFilter, fx As Long
Dim fso As FileSystemObject, prettyStream As TextStream, fileName As String
    
    If (TypeOf Selection Is Range) Then
        Set Cell = Application.Selection(1)
        prettyFormula = prettyLiquiFormula(Cell)
        fileName = "LiquiFormel(" & Cell.parent.name & "_" & columnToLetter(Cell.Column) & Cell.row & ").txt"
        
'        Set fd = Application.FileDialog(msoFileDialogSaveAs)
'        With fd
'            Set fdfs = fd.Filters
'            For fx = 1 To fdfs.Count
'                Set fdf = fdfs.Item(fx)
'                If InStr(1, fdf.Description, "Unicode Text", vbTextCompare) > 0 Then
'                    Exit For
'                End If
'            Next
'            .title = "Formel speichern"
'            .AllowMultiSelect = False
'            .InitialView = msoFileDialogViewList
'            .InitialFileName = LongFileName(fileName)
'            If fx <= fdfs.Count Then
'                .FilterIndex = fx
'            Else
'                Set fdf = fdfs.Add("Unicode Text", "*.txt")
'                .FilterIndex = fdfs.Count
'            End If
'
'            If .Show Then
''Debug.Print .SelectedItems.count, .SelectedItems(1)
'                Set fso = CreateObject("Scripting.FileSystemObject")
'                Set prettyStream = fso.CreateTextFile(.SelectedItems(1), True)
'                prettyStream.WriteLine prettyFormula
'                prettyStream.Close
'            End If
'        End With
        Set fso = CreateObject("Scripting.FileSystemObject")
        Set prettyStream = fso.CreateTextFile(longFileName(fileName), , True)
        prettyStream.WriteLine prettyFormula
        prettyStream.Close
        MsgBox "Gespeichert als: " & longFileName(fileName), vbOKOnly, cs_MsgTitle
    End If
End Sub

Private Sub UserForm_Activate()
'    Const WS_THICKFRAME = &H40000, GWL_STYLE = (-16)
'    Dim lngHWnd As Long, lngStyle As Long, lngRet As Long
'
'    lngHWnd = FindWindow("ThunderDFrame", Me.caption)
'    lngStyle = GetWindowLong(lngHWnd, GWL_STYLE)
'    lngRet = SetWindowLong(lngHWnd, GWL_STYLE, lngStyle Or WS_THICKFRAME)

    txtFormula.SetFocus
End Sub

Private Sub UserForm_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    txtFormula_KeyDown KeyCode, Shift
End Sub

Private Sub cmdClose_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    txtFormula_KeyDown KeyCode, Shift
End Sub

Private Sub cmdSave_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    txtFormula_KeyDown KeyCode, Shift
End Sub

Private Sub txtStatus_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    txtFormula_KeyDown KeyCode, Shift
End Sub

Private Sub txtFormula_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
Dim str As String
    If KeyCode = vbKeyF9 Then
        With txtFormula
            If .SelLength = 0 Then
                str = .Text
            Else
                str = Mid(Replace(.Text, vbCr, ""), .SelStart + 1, .SelLength)
            End If
        End With

        'Status EvaluateFormula(str)
    End If
End Sub

Private Sub UserForm_Initialize()
    off_txtFormula_Width = Me.width - txtFormula.width
    off_txtFormula_Height = Me.height - txtFormula.height
    off_cmdSave_Top = Me.height - cmdSave.Top
    off_cmdClose_Left = Me.width - cmdClose.Left
    off_cmdClose_Top = Me.height - cmdClose.Top

    Set app = Application
    refreshFormula
End Sub

Private Sub cmdClose_Click()
    Unload Me
End Sub

Private Sub UserForm_Resize()
Dim dbl As Double
    On Error Resume Next
    cmdSave.Top = Me.height - off_cmdSave_Top
    cmdClose.Left = Me.width - off_cmdClose_Left
    cmdClose.Top = Me.height - off_cmdClose_Top

    If Me.width > off_txtFormula_Width And Me.height > off_txtFormula_Height Then
        txtFormula.visible = True
        txtFormula.width = Me.width - off_txtFormula_Width
        txtFormula.height = Me.height - off_txtFormula_Height
    Else
        txtFormula.visible = False
    End If
End Sub
Attribute VB_Name = "frmPreviousYear"
Attribute VB_Base = "0{8EBFB69F-90F9-459C-B441-DC63E7F685C3}{8E8F1C5A-2B3A-4833-8820-7B3233022688}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
















Option Explicit

Private Sub btnCancel_Click()
    gb_isUserOK = False
    Unload Me
End Sub

Private Sub btnOK_Click()
    gb_isUserOK = True
    Unload Me
End Sub
Attribute VB_Name = "frmVersion"
Attribute VB_Base = "0{52282346-9A6C-4B14-B789-D2876A5FD3DA}{BED50FF6-D897-489A-93CB-F6C957F908EB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

''http://vbadud.blogspot.de/2010/05/how-to-get-os-version-using-vba.html
'Private Type OSVERSIONINFO
'    dwOSVersionInfoSize As Long
'    dwMajorVersion As Long
'    dwMinorVersion As Long
'    dwBuildNumber As Long
'    dwPlatformId As Long
'    szCSDVersion As String * 128
'End Type
'
'Private Declare Function GetVersionEx Lib "kernel32" _
'    Alias "GetVersionExA" (lpVersionInformation As OSVERSIONINFO) As Long
'
''The following sub uses GetVersionEx function to get the Major and Minor version of OS
'Private Sub Get_OS_Version_VBA()
'Dim oOSInfo As OSVERSIONINFO
'    oOSInfo.dwOSVersionInfoSize = Len(oOSInfo)
'    GetVersionEx oOSInfo
'    MsgBox "Version of Current OS is " & oOSInfo.dwMajorVersion & "." & oOSInfo.dwMinorVersion
'End Sub

Private Sub UserForm_Initialize()
Dim sh As Worksheet, sError As String
'Debug.Print Application.ActiveWorkbook.name

    Me.lblNameText = ""
    If (gs_MainSheetName = "") Then
        Set sh = validateMainSheet(sError)
    Else
        Set sh = getSheet(gs_MainSheetName)
    End If
    If sh Is Nothing Then
        MsgBox sError, vbInformation, cs_MsgTitle
Exit Sub
    End If
    
    If gs_TypeSuffix = "" Then
        gs_TypeSuffix = cs_TypeSuffix
    End If
    Me.caption = cs_MsgTitle & IIf(gb_expertMode, " (Experten-Modus)", "")
    Me.lblNameText = Application.ActiveWorkbook.name
    Me.lblTypeText = cs_ProjectName + "  " + gs_ModelType + gs_TypeSuffix
    
'Dim oOSInfo As OSVERSIONINFO
Dim os As String, xl As String, tmp As String, i As Long
'    tmp = Application.OperatingSystem
'    oOSInfo.dwOSVersionInfoSize = Len(oOSInfo)
'    GetVersionEx oOSInfo
'    If InStr(1, tmp, "NT") > 0 Then
'        tmp = Left$(tmp, InStr(1, tmp, "NT") - 1)
'    End If
'    os = tmp & oOSInfo.dwMajorVersion & "." & oOSInfo.dwMinorVersion

'Application.OperatingSystem. Dies sind die Texte, die von der Eigenschaft zur|fffd|ckgegeben werden:
'
'Windows (32-bit) NT 4.00: Windows NT 4.0
'Windows (32-bit) 4.10: Windows 98
'Windows (32-bit) NT 5.00: Windows 2000
'Windows (32-bit) NT 5.01: Windows XP
'Windows (32-bit) NT 6.00: Windows Vista (32 Bit)
'Windows (64-bit) NT 6.00: Windows Vista (64 Bit)
'Windows (32-bit) NT 7.00: Windows 7 (32 Bit)
'Windows (64-bit) NT 7.00: Windows 7 (64 Bit)

    os = Application.OperatingSystem
' 8.2.0.1
    If os = "Windows (64-bit) NT :.00" Then
        os = "Win10 (64 Bit)"
    ElseIf os = "Windows (32-bit) NT :.00" Then
        os = "Win10 (32 Bit)"
    ElseIf os = "Windows (64-bit) NT :77.00" Then
        os = "Win7 (64 Bit)"
    ElseIf os = "Windows (32-bit) NT :7.00" Then
        os = "Win7 (32 Bit)"
    End If
    
'https://de.wikipedia.org/wiki/Microsoft_Office

'Dim strValue As String
'
'Select Case val(Application.Version)
'  Case 8
'    strValue = "Intern: 8" & vbCrLf & "Excel 97"
'  Case 9
'    strValue = "Intern: 9" & vbCrLf & "Excel 2000"
'  Case 10
'    strValue = "Intern: 10" & vbCrLf & "Excel 2002/XP"
'  Case 11
'    strValue = "Intern: 11" & vbCrLf & "Excel 2003"
'  Case 12
'    strValue = "Intern: 12" & vbCrLf & "Excel 2007"
'  Case Else
'    MsgBox "Unbekannte Version von Excel"
'    Exit Sub
'End Select
'
'MsgBox strValue, vbInformation

    Me.lblVersionText = cs_Version + cs_VersionSuffix
    tmp = Application.Version
    tmp = nextValue(tmp, ".")
    i = CInt(tmp) - 10
    xl = Application.Version
    If i >= 0 And i < 7 Then
        xl = xl + "/" + Array("XP", "2003", "2007", "", "2010", "2013", "2016")(i)
    End If
    Me.lblVersionText = Me.lblVersionText + ";    Plattform: MS Excel " + xl + ",  " + os
End Sub

Private Sub UserForm_Click()
    Unload Me
End Sub

Private Sub lblCopyright_Click()
    Unload Me
End Sub

Private Sub lblCopyrightText_Click()
    Unload Me
End Sub

Private Sub lblName_Click()
    Unload Me
End Sub

Private Sub lblNameText_Click()
    Unload Me
End Sub

Private Sub lblType_Click()
    Unload Me
End Sub

Private Sub lblTypeText_Click()
    Unload Me
End Sub

Private Sub lblVersion_Click()
    Unload Me
End Sub

Private Sub lblVersionText_Click()
    Unload Me
End Sub




' InQuest injected base64 decoded content
' x)br
' y(^z
' ZrH+
' jwQy
' )zwL
' ':sh
' +r2+,
' L\z_
' 'Mjg

INQUEST-PP=macro
