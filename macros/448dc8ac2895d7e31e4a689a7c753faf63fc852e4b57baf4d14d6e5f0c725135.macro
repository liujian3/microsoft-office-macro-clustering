Attribute VB_Name = "A_modAdminDefaults"

'* fcnGetDefaultINIValues **********************************************
'* Creates an instance of the clsINI_LineItems and adds default values
'* to the collection
'*
'* INPUT:
'*
'* RETURNS: clsINI_LineItems
'*
'***********************************************************************
Public Function fcnGetDefaultINIValues() As clsINI_LineItems
 
    Dim defaultINIVals As clsINI_LineItems
    Set defaultINIVals = New clsINI_LineItems

    'If Application.userName = "Gregory K. Maxey" Then '***GKM - Added so I can work remotely.
    '  p_strUSAOLocalWordINI = "h:\USAO\settings\word_settings.ini"
    'End If
    
    'SECTION [word file copy triggers]
        defaultINIVals.addKey "word file copy triggers", "replace Normal trigger", "0"
        defaultINIVals.addKey "word file copy triggers", "replace QAT trigger", "0"
    
    'SECTION [word base paths]
        defaultINIVals.addKey "word base paths", "remote base drive", "P:\"
        defaultINIVals.addKey "word base paths", "local base drive", "D:\"
        defaultINIVals.addKey "word base paths", "base folder", "Word\"
        defaultINIVals.addKey "word base paths", "workgroupTemplates folder", "WorkgroupTemplates\"
        
            'Path for Admin Division Folder
            defaultINIVals.addKey "word base paths", "districtTemplateAdminPath", "Admin\"
        
            'Path for Appellate Division Folder
            defaultINIVals.addKey "word base paths", "districtTemplateAppellatePath", "Appellate\"
        
            'Path for Civil Division Folder
            defaultINIVals.addKey "word base paths", "districtTemplateCivilPath", "Civil\"
        
            'Path for Criminal Division Folder
            defaultINIVals.addKey "word base paths", "districtTemplateCriminalPath", "Criminal\"
        
            'Path for General Folder
            defaultINIVals.addKey "word base paths", "districtTemplateGeneralPath", "General\"
        
            'Path for District Templates Pleadings, Civil (off of base path)
            defaultINIVals.addKey "word base paths", "districtTemplatePleadingsCivilPath", "Civil\Pleadings\"
        
            'change path for District Templates Pleadings, Criminal (off of base path)
            defaultINIVals.addKey "word base paths", "districtTemplatePleadingsCriminalPath", "Criminal\Pleadings\"
        
            'change path of District Templates Letters (off of base path)
            defaultINIVals.addKey "word base paths", "districtTemplateLettersPath", "General\Letters"
        
            'change path District Templates Memo (off of base path)
            defaultINIVals.addKey "word base paths", "districtTemplateMemosPath", "General\Memos"
        
            'change path of District Templates News Releases (off of base path)
            defaultINIVals.addKey "word base paths", "districtTemplateNewsPath", "General\News Releases"
        
            'change path of District Templates Fax Coversheets (off of base path)
            defaultINIVals.addKey "word base paths", "districtTemplateFaxPath", "General\Fax Coversheets"

    'SECTION [word supporting paths]
            defaultINIVals.addKey "word support paths", "supportingFiles folder", "SupportingFiles\"
            defaultINIVals.addKey "word support paths", "envelopes and labels folder", "EnvelopesAndLabels\"
    
    'SECTION [trusted locations]
        'District SharePoint Site
            defaultINIVals.addKey "word trusted locations", "trustedLocation1", "http://districtweb64.usa.doj.gov/district/" & p_userDistrict
            defaultINIVals.addKey "word trusted locations", "trustedLocation2", "D:\Word\WorkgroupTemplates"
            defaultINIVals.addKey "word trusted locations", "trustedLocation3", "P:\Word\WorkgroupTemplates"
        
    'SECTION [word ribbon settings]
        'GROUP templates
            'change name of Tab
            defaultINIVals.addKey "word ribbon settings", "usao_tabUSAO_Label", "USATab"
            
            'change visibility of entire Custom Tab
            defaultINIVals.addKey "word ribbon settings", "usao_tabUSAO_Visible", "True"
            
            'change size of dynamic menus
            defaultINIVals.addKey "word ribbon settings", "usao_dmSmallItems_Visible", "False"
            
            'change visibility of Templates Group
            defaultINIVals.addKey "word ribbon settings", "usao_grpDistrictTemplates_Visible", "True"
            
            'set label of Primay Template Folder Dynamic Menu to default
            defaultINIVals.addKey "word ribbon settings", "usao_dmDistrictTemplates_Label", "District All"
            
            'change visibility of Blank Document Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnBlankDocument_Visible", "False"
            
            'change visibility of District Templates Menu
            defaultINIVals.addKey "word ribbon settings", "usao_dmDistrictTemplates_Visible", "True"
            
            'change visibility of District Templates Pleadings Menu
            defaultINIVals.addKey "word ribbon settings", "usao_menuPleadings_Visible", "True"
                        
            'change visibility of District Templates Letters Menu
            defaultINIVals.addKey "word ribbon settings", "usao_dmLetters_Visible", "True"
            
            'change visibility of District Templates Memo Menu
            defaultINIVals.addKey "word ribbon settings", "usao_dmMemos_Visible", "True"
            
            'change visibility of District Templates News Releases Button
            defaultINIVals.addKey "word ribbon settings", "usao_dmNewsRelease_Visible", "True"
            
            'change visibility of District Templates Fax Coversheets
            defaultINIVals.addKey "word ribbon settings", "usao_dmFax_Visible", "True"
            
            'change visibility of District Tempaltes Appellate Menu
            defaultINIVals.addKey "word ribbon settings", "usao_dmAppellate_Visible", "False"
                        
            'change visibility of District Templates Envelopes and Labels Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnEnvelopesLabels_Visible", "True"
                       
            'change visibility of Personal Templates Button
            defaultINIVals.addKey "word ribbon settings", "usao_dmPersonalTemplates_Visible", "False"
                        
            'change path of Personal Templates
            defaultINIVals.addKey "word ribbon settings", "usao_personalTemplatesPath_Label", "N:\Word\Personal Templates"
    
        'GROUP drives
        
          'change visibility of Drives Group
            defaultINIVals.addKey "word ribbon settings", "usao_grpDrives_Visible", "True"
        
            'change visibility of N Drive Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnNDrive_Visible", "True"
            
            'change visibility of L Drive Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnLDrive_Visible", "True"
            
            'change visibility of M Drive Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnMDrive_Visible", "True"
            
            'change visibility of S Drive Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnSDrive_Visible", "True"
            
            'change visibility of Custom Drive Button 1
            defaultINIVals.addKey "word ribbon settings", "usao_btnCustomDrive1_Visible", "False"
            
            'change label of Custom Drive Button 1
            defaultINIVals.addKey "word ribbon settings", "usao_btnCustomDrive1_Label", "X"
            
            'change size of Custom Drive Button 1 icon --> For version 2.0
            'defaultINIVals.addKey "word ribbon settings", "Custom1DriveButtonSize", "small"
            
            'set path of Custom Drive Button 1
            defaultINIVals.addKey "word ribbon settings", "usao_Custom1DriveButtonPath_Label", "Test"
            
            'change visibility of Custom Drive Button 2
            defaultINIVals.addKey "word ribbon settings", "usao_btnCustomDrive2_Visible", "False"
            
            'change Label of Custom Drive Button 2
            defaultINIVals.addKey "word ribbon settings", "usao_btnCustomDrive2_Label", "Z"
                       
            'set path of Custom Drive Button 2
            defaultINIVals.addKey "word ribbon settings", "usao_Custom2DriveButtonPath_Label", "Test"
        
        'GROUP Content
        
        
        'change visibility of Content Group
            defaultINIVals.addKey "word ribbon settings", "usao_grpContent_Visible", "True"
            
            'change visibility of Date Plus Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnDatePlus_Visible", "True"
            
            'change visibility of Watermarks Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnWatermark_Visible", "True"
            
            'change visibility of Symbols
            defaultINIVals.addKey "word ribbon settings", "usao_galSymbols_Visible", "True"
            
            'change visibility of USAO Keyboard Shortcuts Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnUSAOKeyboardShortcuts_Visible", "True"
        
        
        'GROUP Tools
            
             'change visibility of Tools Group
            defaultINIVals.addKey "word ribbon settings", "usao_grpTools_Visible", "True"
            
            
            'change visibility of Word Perfect File Dropdown Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnWPFileOpen_Visible", "True"
                        
            'change visibility ofSearch Internet With Popup Button
            defaultINIVals.addKey "word ribbon settings", "usao_menuSearchInternet_Visible", "True"
            
            'change visibility of Print File List Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnPrintFileList_Visible", "True"
            
            'change visibility of Email Document Link Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnEmailDocLink_Visible", "True"
            
            'change visibility of Calculator Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnCalculator_Visible", "True"
                
        'GROUP Links
        
            'change visibility of Links Group
            defaultINIVals.addKey "word ribbon settings", "usao_grpLinks_Visible", "False"
        
            'change visibility of District Intranet Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnDistrictIntranet_Visible", "False"
            
            'change address for District Intranet Button
            If p_userDistrict = vbNullString Then
                defaultINIVals.addKey "word ribbon settings", "usao_districtIntranetButtonAddress_Label", "http://usanetsp.usa.doj.gov"
            Else
                defaultINIVals.addKey "word ribbon settings", "usao_districtIntranetButtonAddress_Label", "http://districtweb64.usa.doj.gov/district/" & p_userDistrict
            End If
            
            'change visibility of Training Videos Button
            defaultINIVals.addKey "word ribbon settings", "usao_menuTrainingVideos_Visible", "True"
            
            'change visibility of IT Help Button
            defaultINIVals.addKey "word ribbon settings", "usao_btnITHelp_Visible", "False"
            
            'determine whether the IT Help Button should trigger an email or web browswer call
            defaultINIVals.addKey "word ribbon settings", "usao_btnITHelpMailOrWeb", "Email"
            
            'change address for IT Help Button
            defaultINIVals.addKey "word ribbon settings", "usao_itHelpButtonAddress_Label", "notARealAddress@usa.doj.gov"
            
            'change visibility of District Links Button
            defaultINIVals.addKey "word ribbon settings", "usao_dmDistrictLinks_Visible", "False"
            
            'set path of District Links Button
            defaultINIVals.addKey "word ribbon settings", "usao_dmDistrictLinksPath_Label", "Test"
            
            'change visibility of Administrator Button
            defaultINIVals.addKey "word ribbon settings", "usao_grpAdmin_Visible", "False"
            
        Set fcnGetDefaultINIValues = defaultINIVals
        Set defaultINIVals = Nothing
        
End Function

Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "clsFileDictionary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Adaptation of class prepared by Jeffrey Berman, NDOH
'Adapted by Greg Maxey (gregmaxey.mvps.org) http://gregmaxey.mvps.org

Public fileList As Collection
Public includeFolders As Boolean
Private m_oFSO As Object
Private m_oCurrentPath As Object
Private m_lngCount As Long

Private Sub Class_Initialize()
  Set m_oFSO = CreateObject("Scripting.FileSystemObject")
  Set fileList = New Collection
  includeFolders = False
  m_lngCount = 0
lbl_Exit:
  Exit Sub
End Sub

Private Sub Class_Terminate()
  Set fileList = Nothing
  Set m_oCurrentPath = Nothing
  Set m_oFSO = Nothing
lbl_Exit:
  Exit Sub
End Sub

Public Property Get count() As Long
  count = m_lngCount
lbl_Exit:
  Exit Sub
End Property

Public Property Get Path() As String
  Path = m_oCurrentPath.Path
lbl_Exit:
  Exit Property
End Property

Public Property Let Path(ByVal value As String)
  'Add Error Checking Later
  Set m_oCurrentPath = m_oFSO.GetFolder(value)
lbl_Exit:
  Exit Property
End Property

Public Sub addFile(filePath As String, filename As String, Optional isFile As Boolean = True)
Dim nextFile As clsFolder_File
  
  Set nextFile = New clsFolder_File
  With nextFile
    .Index = m_lngCount
    .Name = filename
    .Path = filePath
    .file = isFile
  End With
  fileList.Add nextFile, m_lngCount & vbNullString
  m_lngCount = m_lngCount + 1
  Set nextFile = Nothing
lbl_Exit:
  Exit Sub
End Sub

Public Sub getFolderContent()
Dim oFiles As Object
Dim oFile As Object
Dim oSubFolders As Object
Dim oSubFolder As Object
  '*** GKM - There is no need or desire for a recursive process here so I took out that loop.
  Set oSubFolders = m_oCurrentPath.SubFolders
  For Each oSubFolder In oSubFolders
    If includeFolders Then addFile oSubFolder.Path, oSubFolder.Name, False
  Next
  Set oFiles = m_oCurrentPath.Files
  On Error Resume Next
  If Err.Number = 0 Then
    For Each oFile In oFiles
      addFile oFile.Path, oFile.Name, True
    Next
  End If
  On Error GoTo 0
  Set oFile = Nothing
  Set oFiles = Nothing
  Set oSubFolder = Nothing
  Set oSubFolders = Nothing
lbl_Exit:
  Exit Sub
End Sub
Attribute VB_Name = "clsFolder_File"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Adaptation of class prepared by Jeffrey Berman USDOJ
'Adapted by Greg Maxey (gregmaxey.mvps.org)
'Declare class property variables.

Public Path As String
Public Name As String
Public Index As Long

Private m_varFile As Variant

Public Property Get file() As Boolean
  file = m_varFile
lbl_Exit:
  Exit Property
End Property

Public Property Get Folder() As Boolean
  Folder = Not m_varFile
lbl_Exit:
  Exit Property
End Property

Public Property Let file(ByVal bValue As Boolean)
  m_varFile = bValue
lbl_Exit:
  Exit Property
End Property

Public Property Let Folder(ByVal bValue As Boolean)
  m_varFile = Not bValue
lbl_Exit:
  Exit Property
End Property

Public Property Get isFile() As Boolean
  isFile = m_varFile
lbl_Exit:
  Exit Property
End Property
Attribute VB_Name = "clsINI_File"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Class:    cIniFile
'Author:   Steve McMahon
'Date  :   21 Feb 1997
'
'A nice class wrapper around the INIFile functions
'Allows searching,deletion,modification and addition  of Keys or Values.
'
'Updated 10 May 1998 for VB5.
'   * Added EnumerateAllSections method
'   * Added Load and Save form position methods
'
'From: http://www.vbaccelerator.com/home/VB/Code/Libraries/Registry_and_Ini_Files/Easy_Ini_File_Access/article.asp

Private m_sPath As String
Private m_sKey As String
Private m_sSection As String
Private m_sDefault As String
Private m_lLastReturnCode As Long

#If Win32 Then
    ' Profile String functions:
    Private Declare Function WritePrivateProfileString Lib "KERNEL32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
    Private Declare Function GetPrivateProfileString Lib "KERNEL32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As Any, ByVal lpKeyName As Any, ByVal lpDefault As Any, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
#Else
    ' Profile String functions:
    Private Declare Function WritePrivateProfileString Lib "Kernel" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Integer
    Private Declare Function GetPrivateProfileString Lib "Kernel" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As Any, ByVal lpReturnedString As String, ByVal nSize As Integer, ByVal lpFileName As String) As Integer
#End If

Property Get LastReturnCode() As Long
    LastReturnCode = m_lLastReturnCode
End Property
Property Get Success() As Boolean
    Success = (m_lLastReturnCode <> 0)
End Property
Property Let Default(sDefault As String)
    m_sDefault = sDefault
End Property
Property Get Default() As String
    Default = m_sDefault
End Property
Property Let Path(sPath As String)
    m_sPath = sPath
End Property
Property Get Path() As String
    Path = m_sPath
End Property
Property Let key(sKey As String)
    m_sKey = sKey
End Property
Property Get key() As String
    key = m_sKey
End Property
Property Let section(sSection As String)
    m_sSection = sSection
End Property
Property Get section() As String
    section = m_sSection
End Property
Property Get value() As String
Dim sBuf As String
Dim iSize As String
Dim iRetCode As Integer

    sBuf = Space$(255)
    iSize = Len(sBuf)
    iRetCode = GetPrivateProfileString(m_sSection, m_sKey, m_sDefault, sBuf, iSize, m_sPath)
    If (iSize > 0) Then
        value = Left$(sBuf, iRetCode)
    Else
        value = ""
    End If

End Property
Property Let value(sValue As String)
Dim iPos As Integer
    ' Strip chr$(0):
    iPos = InStr(sValue, Chr$(0))
    Do While iPos <> 0
        sValue = Left$(sValue, (iPos - 1)) & Mid$(sValue, (iPos + 1))
        iPos = InStr(sValue, Chr$(0))
    Loop
    m_lLastReturnCode = WritePrivateProfileString(m_sSection, m_sKey, sValue, m_sPath)
End Property
Public Sub DeleteKey()
    m_lLastReturnCode = WritePrivateProfileString(m_sSection, m_sKey, 0&, m_sPath)
End Sub
Public Sub DeleteSection()
    m_lLastReturnCode = WritePrivateProfileString(m_sSection, 0&, 0&, m_sPath)
End Sub
Property Get INISection() As String
Dim sBuf As String
Dim iSize As String
Dim iRetCode As Integer

    sBuf = Space$(8192)
    iSize = Len(sBuf)
    iRetCode = GetPrivateProfileString(m_sSection, 0&, m_sDefault, sBuf, iSize, m_sPath)
    If (iSize > 0) Then
        INISection = Left$(sBuf, iRetCode)
    Else
        INISection = ""
    End If

End Property
Property Let INISection(sSection As String)
    m_lLastReturnCode = WritePrivateProfileString(m_sSection, 0&, sSection, m_sPath)
End Property
Property Get Sections() As String
Dim sBuf As String
Dim iSize As String
Dim iRetCode As Integer

    sBuf = Space$(8192)
    iSize = Len(sBuf)
    iRetCode = GetPrivateProfileString(0&, 0&, m_sDefault, sBuf, iSize, m_sPath)
    If (iSize > 0) Then
        Sections = Left$(sBuf, iRetCode)
    Else
        Sections = ""
    End If

End Property
Public Sub EnumerateCurrentSection(ByRef sKey() As String, ByRef iCount As Long)
Dim sSection As String
Dim iPos As Long
Dim iNextPos As Long
Dim sCur As String
    
    iCount = 0
    Erase sKey
    sSection = INISection
    If (Len(sSection) > 0) Then
        iPos = 1
        iNextPos = InStr(iPos, sSection, Chr$(0))
        Do While iNextPos <> 0
            sCur = Mid$(sSection, iPos, (iNextPos - iPos))
            If (sCur <> Chr$(0)) Then
                iCount = iCount + 1
                ReDim Preserve sKey(1 To iCount) As String
                sKey(iCount) = Mid$(sSection, iPos, (iNextPos - iPos))
                iPos = iNextPos + 1
                iNextPos = InStr(iPos, sSection, Chr$(0))
            End If
        Loop
    End If
End Sub
Public Sub EnumerateAllSections(ByRef sSections() As String, ByRef iCount As Long)
Dim sIniFile As String
Dim iPos As Long
Dim iNextPos As Long
Dim sCur As String
    
    iCount = 0
    Erase sSections
    sIniFile = Sections
    If (Len(sIniFile) > 0) Then
        iPos = 1
        iNextPos = InStr(iPos, sIniFile, Chr$(0))
        Do While iNextPos <> 0
            If (iNextPos <> iPos) Then
                sCur = Mid$(sIniFile, iPos, (iNextPos - iPos))
                iCount = iCount + 1
                ReDim Preserve sSections(1 To iCount) As String
                sSections(iCount) = sCur
            End If
            iPos = iNextPos + 1
            iNextPos = InStr(iPos, sIniFile, Chr$(0))
        Loop
    End If

End Sub
'Public Sub SaveFormPosition(ByRef frmThis As Object)
'Dim sSaveKey As String
'Dim sSaveDefault As String
'On Error GoTo SaveError
'    sSaveKey = key
'    If Not (frmThis.WindowState = vbMinimized) Then
'        key = "Maximised"
'        value = (frmThis.WindowState = vbMaximized) * -1
'        If (frmThis.WindowState <> vbMaximized) Then
'            key = "Left"
'            value = frmThis.Left
'            key = "Top"
'            value = frmThis.Top
'            key = "Width"
'            value = frmThis.Width
'            key = "Height"
'            value = frmThis.Height
'        End If
'    End If
'    key = sSaveKey
'    Exit Sub
'SaveError:
'    key = sSaveKey
'    m_lLastReturnCode = 0
'    Exit Sub
'End Sub
'Public Sub LoadFormPosition(ByRef frmThis As Object, Optional ByRef lMinWidth = 3000, Optional ByRef lMinHeight = 3000)
'Dim sSaveKey As String
'Dim sSaveDefault As String
'Dim lLeft As Long
'Dim lTOp As Long
'Dim lWidth As Long
'Dim lHeight As Long
'On Error GoTo LoadError
'    sSaveKey = key
'    sSaveDefault = Default
'    Default = "FAIL"
'    key = "Left"
'    lLeft = CLngDefault(value, frmThis.Left)
'    key = "Top"
'    lTOp = CLngDefault(value, frmThis.Top)
'    key = "Width"
'    lWidth = CLngDefault(value, frmThis.Width)
'    If (lWidth < lMinWidth) Then lWidth = lMinWidth
'    key = "Height"
'    lHeight = CLngDefault(value, frmThis.Height)
'    If (lHeight < lMinHeight) Then lHeight = lMinHeight
'    If (lLeft < 4 * screen.TwipsPerPixelX) Then lLeft = 4 * screen.TwipsPerPixelX
'    If (lTOp < 4 * screen.TwipsPerPixelY) Then lTOp = 4 * screen.TwipsPerPixelY
'    If (lLeft + lWidth > screen.Width - 4 * screen.TwipsPerPixelX) Then
'        lLeft = screen.Width - 4 * screen.TwipsPerPixelX - lWidth
'        If (lLeft < 4 * screen.TwipsPerPixelX) Then lLeft = 4 * screen.TwipsPerPixelX
'        If (lLeft + lWidth > screen.Width - 4 * screen.TwipsPerPixelX) Then
'            lWidth = screen.Width - lLeft - 4 * screen.TwipsPerPixelX
'        End If
'    End If
'    If (lTOp + lHeight > screen.Height - 4 * screen.TwipsPerPixelY) Then
'        lTOp = screen.Height - 4 * screen.TwipsPerPixelY - lHeight
'        If (lTOp < 4 * screen.TwipsPerPixelY) Then lTOp = 4 * screen.TwipsPerPixelY
'        If (lTOp + lHeight > screen.Height - 4 * screen.TwipsPerPixelY) Then
'            lHeight = screen.Height - lTOp - 4 * screen.TwipsPerPixelY
'        End If
'    End If
'    If (lWidth >= lMinWidth) And (lHeight >= lMinHeight) Then
'        frmThis.Move lLeft, lTOp, lWidth, lHeight
'    End If
'    key = "Maximised"
'    If (CLngDefault(value, 0) <> 0) Then
'        frmThis.WindowState = vbMaximized
'    End If
'    key = sSaveKey
'    Default = sSaveDefault
'    Exit Sub
'LoadError:
'    key = sSaveKey
'    Default = sSaveDefault
'    m_lLastReturnCode = 0
'    Exit Sub
'End Sub
Public Function CLngDefault(ByVal sString As String, Optional ByVal lDefault As Long = 0) As Long
Dim lR As Long
On Error Resume Next
    lR = CLng(sString)
    If (Err.Number <> 0) Then
        CLngDefault = lDefault
    Else
        CLngDefault = lR
    End If
End Function
Attribute VB_Name = "clsINI_LineItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public section As String
Public key As String
Public value As String
Public Index As Long
Attribute VB_Name = "clsINI_LineItems"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public Items As Collection
Private m_oFSO As FileSystemObject
Private m_lngCount As Long
Private Sub Class_Initialize()
  Set m_oFSO = CreateObject("Scripting.FileSystemObject")
  Set Items = New Collection
  m_lngCount = 0
lbl_Exit:
  Exit Sub
End Sub

Private Sub Class_Terminate()
  Set Items = Nothing
  Set m_oFSO = Nothing
lbl_Exit:
  Exit Sub
End Sub

Public Property Get count() As Long
  count = m_lngCount
lbl_Exit:
  Exit Property
End Property

Public Function getKeyValue(section As String, key As String) As String
Dim oDummyKey As clsINI_LineItem
Dim strReturnVal As String
    
  strReturnVal = vbNullString
  For Each oDummyKey In Items
    If oDummyKey.section = section Then
      If oDummyKey.key = key Then
        strReturnVal = oDummyKey.value
        Exit For 'GKM ***
      End If
    End If
  Next
  getKeyValue = strReturnVal
lbl_Exit:
  Exit Function
End Function

Public Function updateKeyValue(section As String, key As String, value As String) As Long
Dim lngReturnVal As Long
Dim lngIndex As Long
  
  lngReturnVal = 0
  For lngIndex = 1 To Items.count
    If Items.Item(lngIndex).section = section Then
      If Items.Item(lngIndex).key = key Then
        Items.Item(lngIndex).value = value
        lngReturnVal = lngIndex
        Exit For
      End If
    End If
  Next
  updateKeyValue = lngReturnVal
lbl_Exit:
  Exit Function
End Function
'* addKey **************************************************************
'* Takes INI values and creates a clsINI_LineItem key, which is inserted into a
'* collection
'*
'* INPUT: section As String, key As String, value As String
'*
'* RETURNS: Boolean
'*
'***********************************************************************
Public Function addKey(section As String, key As String, value As String) As Boolean
Dim oNextKey As clsINI_LineItem
  
  Set oNextKey = New clsINI_LineItem
  With oNextKey
    .Index = m_lngCount
    .key = key
    .value = value
    .section = section
  End With
  Items.Add oNextKey, m_lngCount & vbNullString
  m_lngCount = m_lngCount + 1
  Set oNextKey = Nothing
  addKey = True
lbl_Exit:
  Exit Function
End Function

'* writeToINI **********************************************************
'* Description
'* Description
'*
'* INPUT: strPath As String
'*
'* RETURNS: Boolean
'*
'***********************************************************************
Public Function writeToINI(strPath As String) As Boolean
Dim lngIndex As Long
   
  modMain.fcnCreateFolder m_oFSO.GetParentFolderName(strPath)
  On Error Resume Next
  Err.Clear
  For lngIndex = 1 To Items.count
    fcnWriteIniValue strPath, Items.Item(lngIndex).section, Items.Item(lngIndex).key, Items.Item(lngIndex).value
  Next
  writeToINI = (Err.Number = 0)
  Err.Clear
  On Error GoTo 0
lbl_Exit:
  Exit Function
End Function

Public Function updateFromINI(strPath As String) As Boolean
'Dim i As Integer
'On Error Resume Next
'Err.Clear
'For i = 1 To Items.count
'  Items.Item(i).value = fcnGetINIValue(strPath, Items.Item(i).section, Items.Item(i).key, Items.Item(i).value)
'Next
                
Dim fileINI As clsINI_File: Set fileINI = New clsINI_File
Dim arrSections() As String, arrKeys() As String
Dim lngSectionCount As Long, lngKeyCount As Long
Dim lngSection As Long, lngKey As Long
Dim strValue As String
        
    fileINI.Path = strPath
    With fileINI
      .EnumerateAllSections arrSections(), lngSectionCount
      For lngSection = 1 To lngSectionCount
        .section = arrSections(lngSection)
        .EnumerateCurrentSection arrKeys(), lngKeyCount
        For lngKey = 1 To lngKeyCount
          'Try to update the key from the INI.  IF the update succeeds something other than 0 is returned.  If it fails,
          'the field in the INI does not exist in the collection, THEN
          strValue = fcnGetINIValue(strPath, arrSections(lngSection), arrKeys(lngKey))
          If updateKeyValue(arrSections(lngSection), arrKeys(lngKey), strValue) = 0 Then
            'Add the key to the collection since it isn't already there.
            addKey arrSections(lngSection), arrKeys(lngKey), strValue
          End If
        Next
      Next
    End With
    Set fileINI = Nothing
    updateFromINI = True
        
'Dim tINlngKey As clsINI_LineItem: Set tINlngKey = New clsINI_LineItem
'Dim keyBase As String: keyBase = "trustedLocation"
'Dim count As Integer: count = 1
'tINlngKey.section = "word trusted locations"
'Do
'  tINlngKey.key = keyBase & count
'  tINlngKey.strValue = cnGetINIValue(strPath, tINlngKey.key, tINlngKey.value)
'  updateFromINI = (Err.Number = 0)
'  Err.Clear
'  On Error GoTo 0
lbl_Exit:
  Exit Function
End Function

Public Function getSection(ByVal section As String) As clsINI_LineItems
Dim oDummyKey As clsINI_LineItem
Dim colReturned As clsINI_LineItems
  Set colReturned = New clsINI_LineItems
  For Each oDummyKey In Items
    If oDummyKey.section = section Then
      colReturned.addKey oDummyKey.section, oDummyKey.key, oDummyKey.value
    End If
  Next
 Set getSection = colReturned
lbl_Exit:
  Exit Function
End Function

Public Function removeSection(ByVal section As String) As clsINI_LineItems
Dim oDummyKey As clsINI_LineItem
Dim colReturned As clsINI_LineItems
  Set colReturned = New clsINI_LineItems
  For Each oDummyKey In Items
    If oDummyKey.section <> section Then
      colReturned.addKey oDummyKey.section, oDummyKey.key, oDummyKey.value
   End If
  Next
  Set removeSection = colReturned
lbl_Exit:
  Exit Function
End Function











Attribute VB_Name = "clsThisApp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private WithEvents m_oThisApp As Application
Attribute m_oThisApp.VB_VarHelpID = -1
Public rngPrevious As Range

Private Sub Class_Initialize()
  'Syncronize class with application.
  Set m_oThisApp = Word.Application
  p_LastDocClosing = False
  cls_Initialize_Reset
lbl_Exit:
  Exit Sub
End Sub

Private Sub m_oThisApp_DocumentOpen(ByVal doc As Document)
  cls_Initialize_Reset
lblbl_Exit:
  Exit Sub
End Sub

Private Sub m_oThisApp_DocumentChange()
  cls_Initialize_Reset
lbl_Exit:
  Exit Sub
End Sub

Private Sub m_oThisApp_DocumentBeforeClose(ByVal doc As Document, Cancel As Boolean)
If Application.Documents.count > 1 Then
  p_LastDocClosing = False
Else
  p_LastDocClosing = True
  cls_Initialize_Reset
End If
lbl_Exit:
  Exit Sub
End Sub

'Private Sub m_oThisApp_WindowSelectionChange(ByVal Sel As Selection)
'  'Not used.
'lbl_Exit:
'  Exit Sub
'End Sub

Private Sub cls_Initialize_Reset()
  On Error GoTo lbl_Exit
  System.Cursor = wdCursorIBeam
  p_oRibbon.InvalidateControl "usao_galSymbols"
  p_oRibbon.InvalidateControl "usao_btnWatermark"
  p_oRibbon.InvalidateControl "usao_dmPersonalTemplates"
  On Error GoTo 0
lbl_Exit:
  Exit Sub
End Sub




Attribute VB_Name = "frmCUText_Addendum"
Attribute VB_Base = "0{2FBAC8EA-D5DA-4698-9327-9F6A61C7A803}{BE24EC88-3318-4FF9-8798-173443B91B73}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Private Sub CommandButton1_Click()
 If OptionButton1.value = True Then
   Frame1.Tag = 1
 ElseIf OptionButton2.value = True Then
   Frame1.Tag = 2
 Else
   Frame1.Tag = 3
End If
  Hide
End Sub

Private Sub UserForm_Initialize()
  Caption = "Clean Up Text"
  OptionButton1.value = True
  TextMark.Text = ""
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then Cancel = True
End Sub
Attribute VB_Name = "frmCleanUpText"
Attribute VB_Base = "0{98E7D198-562C-4863-A2D1-46E99175AEA9}{D77BA439-D2B9-4067-914C-D79CFBA5BC79}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Private oFrmAddendum As frmCUText_Addendum
Private m_lngAdvOption As Long
Private m_strTextMark As String
Private Sub CheckBox2_Click()
  If CheckBox2.value = -1 Then
    TextBox1.Enabled = True
  Else
    TextBox1.Enabled = False
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub CheckBox4_Click()
  If ActiveDocument.Tables.count > 0 Then
    Set oFrmAddendum = frmCUText_Addendum
    Load oFrmAddendum
    oFrmAddendum.Show vbModal
    m_strTextMark = oFrmAddendum.TextMark
    m_lngAdvOption = CLng(oFrmAddendum.Frame1.Tag)
    Unload oFrmAddendum
    Set oFrmAddendum = Nothing
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub CommandButton1_Click()
Dim oRng As Word.Range
Dim bParaAdded As Boolean
Dim lngWrap As Long
Dim lngStoryType As Long

  Hide
  Word.Application.ScreenUpdating = False
  If OptionButton1.value = -1 Then
    Set oRng = Selection.Range
    'Ensure proper paragraph marks
    lngStoryType = oRng.StoryType
    lngWrap = 0
    If oRng.Paragraphs.count > 1 Then
      ValidateParagraphs oRng, lngWrap
      If oRng.End = ActiveDocument.StoryRanges(lngStoryType).End Then
        oRng.Paragraphs.Last.Range.Delete
      End If
    End If
    Set oRng = Nothing
    If Selection.Range.Start = ActiveDocument.StoryRanges(lngStoryType).Start Then
      Selection.InsertBefore Chr(13)
      bParaAdded = True
    ElseIf Selection.Start <> Selection.Paragraphs(1).Range.Start Then
      Selection.MoveStart Unit:=wdLine, count:=-1
      Selection.MoveStart Unit:=wdCharacter, count:=-1
    Else
      Selection.MoveStart Unit:=wdCharacter, count:=-1
    End If
    Set oRng = Selection.Range
    lngWrap = 0
    'Call Processor
    Process oRng, lngWrap, bParaAdded, lngStoryType
  ElseIf OptionButton2.value = -1 Then
    Set oRng = Selection.Range
    oRng.WholeStory
    lngStoryType = oRng.StoryType
    lngWrap = 1
    'Ensure proper paragraph marks
     If oRng.Paragraphs.count > 1 Then
      ValidateParagraphs oRng, lngWrap
      ActiveDocument.StoryRanges(lngStoryType).Paragraphs.Last.Range.Delete
    End If
    ActiveDocument.StoryRanges(lngStoryType).InsertBefore Chr(13)
    lngWrap = 1
    bParaAdded = True
    'Call Processor
    Process oRng, lngWrap, bParaAdded, lngStoryType
  Else
    MakeHFValid
    For Each oRng In ActiveDocument.StoryRanges
      'If oRng.StoryLength >= 2 Then
      lngStoryType = oRng.StoryType
      lngWrap = 1
      Do
        'Ensure proper paragraph marks
        If oRng.Paragraphs.count > 1 Then
          ValidateParagraphs oRng, lngWrap
          oRng.Paragraphs.Last.Range.Delete
        End If
        oRng.InsertBefore Chr(13)
        lngWrap = 1
        bParaAdded = True
        'Call Processor
        Process oRng, lngWrap, bParaAdded, lngStoryType
        Set oRng = oRng.NextStoryRange
      Loop Until oRng Is Nothing
      'End If
    Next
  End If
  'Me.Hide
  Word.Application.ScreenRefresh
  Word.Application.ScreenUpdating = True
lbl_Exit:
  Exit Sub
End Sub
Private Sub CommandButton2_Click()
  Hide
lbl_Exit:
  Exit Sub
End Sub

Private Sub UserForm_Initialize()
  Caption = "Cleanup/Format Text"
  OptionButton2.value = True
  TextBox1.Enabled = False
lbl_Exit:
  Exit Sub
End Sub
Private Sub Process(ByRef oRng As Range, ByVal lngWrap As Integer, _
                    ByVal bParaAdded As Boolean, ByVal lngStoryType As Long)
Dim varTextCharArray As Variant
Dim m_lngIndex As Long
Dim m_lngIndex_B As Long
Dim oRngProcess As Range
Dim oPara As Paragraph

  If CheckBox1.value = -1 Then
    With oRng.Find
      .ClearFormatting
      .Replacement.ClearFormatting
      .Forward = True
      .Wrap = lngWrap
      .MatchWildcards = True
      For m_lngIndex = 1 To 8
        Select Case m_lngIndex
          Case 1
            .Text = "(^13)( {1" & ls & "})" '(^13)( {1,})
            .Replacement.Text = "\1"
          Case 2
            .Text = "(^l)( {1" & ls & "})" '(^l)( {1,})
            .Replacement.Text = "\1"
          Case 3
            .Text = "( {1" & ls & "})(^13)" '({1,})(^13)
            .Replacement.Text = "\2"
          Case 4
            .Text = "( {1" & ls & "})(^l)" '({1,})(^l)
            .Replacement.Text = "\2"
          Case 5
            .Text = "(^13)(^s{1" & ls & "})" '(^13)(^s{1,})
            .Replacement.Text = "\1"
          Case 6
            .Text = "(^l)(^s{1" & ls & "})" '(^l)(^s{1,})
            .Replacement.Text = "\1"
          Case 7
            .Text = "(^s{1" & ls & "})(^13)" '(^s{1,})(^13)
            .Replacement.Text = "\2"
          Case 8
            .Text = "(^s{1" & ls & "})(^l)" '(^s{1,})(^l)
            .Replacement.Text = "\2"
          Case Else
            Exit For
        End Select
        .Execute Replace:=wdReplaceAll
      Next
    End With
  End If
  
  If CheckBox2.value = -1 Then
    varTextCharArray = Split(TextBox1, "|")
    With oRng.Find
      .ClearFormatting
      .Replacement.ClearFormatting
      .Forward = True
      .Wrap = lngWrap
      .MatchWildcards = True
      For m_lngIndex_B = 0 To UBound(varTextCharArray)
        If InStr("*(){}[]!@?", varTextCharArray(m_lngIndex_B)) > 0 Then
          .MatchWildcards = True
          .Text = "(^13)\" & varTextCharArray(m_lngIndex_B) & "{1" & ls & "}"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = "\" & varTextCharArray(m_lngIndex_B) & "{1" & ls & "}(^13)"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = "(^l)\" & varTextCharArray(m_lngIndex_B) & "{1" & ls & "}"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = "\" & varTextCharArray(m_lngIndex_B) & "{1" & ls & "}(^l)"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
        ElseIf InStr("<>", varTextCharArray(m_lngIndex_B)) > 0 Then
          .MatchWildcards = True
          .Text = "(^13)[\" & varTextCharArray(m_lngIndex_B) & "]{1" & ls & "}"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = "[\" & varTextCharArray(m_lngIndex_B) & "]{1" & ls & "}(^13)"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = "(^l)[\" & varTextCharArray(m_lngIndex_B) & "]{1" & ls & "}"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = "[\" & varTextCharArray(m_lngIndex_B) & "]{1" & ls & "}(^l)"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
        Else
          .MatchWildcards = True
          .Text = "(^13)" & varTextCharArray(m_lngIndex_B) & "{1" & ls & "}"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = varTextCharArray(m_lngIndex_B) & "{1" & ls & "}(^13)"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = "(^l)" & varTextCharArray(m_lngIndex_B) & "{1" & ls & "}"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
          .Text = varTextCharArray(m_lngIndex_B) & "{1" & ls & "}(^l)"
          .Replacement.Text = "\1"
          .Execute Replace:=wdReplaceAll
        End If
      Next m_lngIndex_B
    End With
  End If
  
  If CheckBox1.value = -1 Then
    With oRng.Find
      .ClearFormatting
      .Replacement.ClearFormatting
      .Forward = True
      .Wrap = lngWrap
      .MatchWildcards = True
      For m_lngIndex = 1 To 8
        Select Case m_lngIndex
        Case 1
            .Text = "(^13)( {1" & ls & "})" '(^13)( {1,})
            .Replacement.Text = "\1"
          Case 2
            .Text = "(^l)( {1" & ls & "})" '(^l)( {1,})
            .Replacement.Text = "\1"
          Case 3
            .Text = "( {1" & ls & "})(^13)" '({1,})(^13)
            .Replacement.Text = "\2"
          Case 4
            .Text = "( {1" & ls & "})(^l)" '({1,})(^l)
            .Replacement.Text = "\2"
          Case 5
            .Text = "(^13)(^s{1" & ls & "})" '(^13)(^s{1,})
            .Replacement.Text = "\1"
          Case 6
            .Text = "(^l)(^s{1" & ls & "})" '(^l)(^s{1,})
            .Replacement.Text = "\1"
          Case 7
            .Text = "(^s{1" & ls & "})(^13)" '(^s{1,})(^13)
            .Replacement.Text = "\2"
          Case 8
            .Text = "(^s{1" & ls & "})(^l)" '(^s{1,})(^l)
            .Replacement.Text = "\2"
          Case Else
            Exit For
        End Select
        .Execute Replace:=wdReplaceAll
      Next
    End With
  End If
  'Replace line breaks with paragraph formatting
  If CheckBox3.value = -1 Then
    With oRng.Find
      .ClearFormatting
      .Replacement.ClearFormatting
      .Forward = True
      .Wrap = lngWrap
      .MatchWildcards = True
      For m_lngIndex = 1 To 2
        Select Case m_lngIndex
        Case 1
          .Text = "^l{2" & ls & "}"
          .Replacement.Text = "^p"
        Case 2
          .Text = "^l{1" & ls & "}"
          .Replacement.Text = " "
        Case Else
          Exit For
        End Select
        .Execute Replace:=wdReplaceAll
      Next
    End With
  End If
  'Remove carriage returns at end of each line.
  If CheckBox8.value = -1 Then
    With oRng.Find
      .Text = "([!^13])(^13)([!^13])"
      .Replacement.Text = "\1 \3"
      .Forward = True
      .Wrap = lngWrap
      .MatchWildcards = True
      .Execute Replace:=wdReplaceAll
    End With
  End If
  
  'Remove Empty Paragraphs
  If CheckBox4.value = -1 Then
    With oRng.Find
      .Text = "^13{2" & ls & "}"
      .Replacement.Text = "^p"
      .Forward = True
      .Wrap = lngWrap
      .MatchWildcards = True
      .Execute Replace:=wdReplaceAll
    End With
    If m_lngAdvOption = 2 Then
      For Each oPara In oRng.Paragraphs
        If Len(oPara.Range.Text) = 1 Then
          oPara.Range.Delete
        End If
      Next
    Else
    'Call Macro to process empty PMs in tables and nested tables
      ProcessTables oRng, lngStoryType
    End If
    If oRng.Paragraphs.count > 1 Then
      Set oRngProcess = ActiveDocument.StoryRanges(lngStoryType).Paragraphs.First.Range
      If oRngProcess.Text = vbCr Then oRngProcess.Delete
      Set oRngProcess = ActiveDocument.StoryRanges(lngStoryType).Paragraphs.Last.Range
      If oRngProcess.Text = vbCr Then oRngProcess.Delete
    End If
  ElseIf bParaAdded = True Then
    oRng.Paragraphs(1).Range.Delete
  End If
  
  'Clear Formatting
  If CheckBox5.value = -1 Then oRng.Font.Reset
  If CheckBox6.value = -1 Then oRng.ParagraphFormat.Reset
  If CheckBox7.value = -1 Then
    oRng.Style = ActiveDocument.Styles(wdStyleNormal)
  End If
  If oRng.Paragraphs.Last.Range.Characters.count = 1 Then
     On Error Resume Next
     oRng.Paragraphs.Last.Range.Delete
     On Error GoTo 0
  End If
  Selection.Collapse Direction:=wdCollapseStart
lbl_Exit:
  Exit Sub
End Sub
Private Sub ValidateParagraphs(ByVal oRng As Range, lngWrap As Long)
  With oRng.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .Forward = True
    .Wrap = lngWrap
    .Text = "^13"
    .Replacement.Text = "^p"
    .Execute Replace:=wdReplaceAll
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub MakeHFValid()
  Dim lngJunk As Long
  lngJunk = ActiveDocument.Sections(1).Headers(1).Range.StoryType
End Sub
Sub ProcessTables(oRng As Range, lngStoryType As Long)
Dim TopTable As Table
Dim ttCell As Word.Cell
Dim lngLevel As Long
Dim Level2Table As Word.Table

  For Each TopTable In oRng.Tables
    'Call Macro to process empty PMs between top lngLevel tables
    BAITables TopTable, lngStoryType
    
    lngLevel = 1
    'Call Macro to process empty PMs in TopTable cells
    ProcessCells TopTable, lngStoryType
    
    'Process TopTable for nested tables
    For Each ttCell In TopTable.Range.Cells
      If ttCell.Tables.count > 0 Then
        Dim m_lngIndex_B As Integer
        For m_lngIndex_B = 1 To ttCell.Tables.count
          Set Level2Table = ttCell.Tables(m_lngIndex_B)
          lngLevel = 2
          'Process cells in Level2 Tables
          ProcessCells Level2Table, lngStoryType
          'Process deep nested Tables
          ProcessNestedTable lngLevel, Level2Table, TopTable, lngStoryType
        Next
      End If
    Next ttCell
  Next
lbl_Exit:
  Exit Sub
End Sub
Function ProcessNestedTable(NewLevel As Long, _
    tbl As Word.Table, ByRef tblOuter As Word.Table, lngStoryType As Long)

Dim celNested As Word.Cell
Dim tblNested As Word.Table

  For Each celNested In tbl.Range.Cells
    If celNested.Tables.count > 0 Then
      Set tblNested = celNested.Tables(1)
      NewLevel = tblNested.NestingLevel
      Set tblOuter = tblNested
      ProcessCells tblNested, lngStoryType
      ProcessNestedTable NewLevel, tblNested, tblOuter, lngStoryType
    End If
  Next celNested
lbl_Exit:
  Exit Function
End Function
Sub BAITables(oTbl As Table, lngStoryType As Long)

Dim myRange As Range
Dim emptyPara As Boolean

  'Remove empty PMs immediate before, after, and between
  'top lngLevel tables
  Set myRange = oTbl.Range 'tbl.Range
  myRange.Collapse wdCollapseEnd
  If myRange.Paragraphs(1).Range.Text = vbCr Then
    myRange.Collapse wdCollapseEnd
    myRange.Move wdParagraph, 1
    If myRange.Information(wdWithInTable) Then
      'Do nothing.  Issue will be resolve while
      'processing next table.
    Else
      myRange.Move wdParagraph, -1
      myRange.Paragraphs(1).Range.Delete
    End If
  End If
  Set myRange = oTbl.Range
  Do
    myRange.Collapse wdCollapseStart
    myRange.Move wdParagraph, -1
    If myRange.Paragraphs(1).Range.Text = vbCr Then
      myRange.Collapse wdCollapseStart
      If myRange.Start = ActiveDocument.StoryRanges(lngStoryType).Start Then
        myRange.Paragraphs(1).Range.Delete
        emptyPara = False
      Else
        myRange.Move wdParagraph, -1
        If myRange.Information(wdWithInTable) Then
          If m_lngAdvOption = 3 Then
            myRange.Move wdParagraph, 1
            emptyPara = True
            myRange.Text = m_strTextMark '"****"
          End If
        Else
          myRange.Move wdParagraph, 1
          emptyPara = True
          myRange.Paragraphs(1).Range.Delete
        End If
      End If
    Else
      emptyPara = False
    End If
  Loop While emptyPara = True
lbl_Exit:
  Exit Sub
End Sub
Sub ProcessCells(tbl As Table, ByVal lngStoryType As Long)
Dim oCell As Cell
Dim Counter As Integer
Dim oPara As Paragraph
Dim workingRng As Range
Dim prevTab As Range
Dim k As Integer
Dim emptyPara As Boolean

  For Each oCell In tbl.Range.Cells
    If oCell.Tables.count > 1 Then
      'Process PMs before first table
      Set workingRng = oCell.Tables(1).Range
      Do
        workingRng.Collapse wdCollapseStart
        workingRng.Move wdParagraph, -1
        If workingRng.Paragraphs(1).Range.Text = vbCr Then
          workingRng.Paragraphs(1).Range.Delete
          emptyPara = True
        Else
           emptyPara = False
        End If
      Loop While emptyPara = True
      
      For k = 2 To oCell.Tables.count
        Set workingRng = oCell.Tables(k).Range
        'Process PM after last table
        If k = oCell.Tables.count Then
          workingRng.Collapse wdCollapseEnd
          If workingRng.Paragraphs(1).Range.Text = vbCr Then
            workingRng.Paragraphs(1).Range.Delete
          End If
          Set workingRng = oCell.Tables(k).Range
        End If
        'Process PMs preceeding remaining tables
        Set prevTab = oCell.Tables(k - 1).Range
        workingRng.Select
        Do
          workingRng.Collapse wdCollapseStart
          workingRng.Move wdParagraph, -1
          If workingRng.Paragraphs(1).Range.Text = vbCr Then
            workingRng.Collapse wdCollapseStart
            workingRng.Move wdParagraph, -1
            If workingRng.InRange(prevTab) Then
              If m_lngAdvOption = 3 Then
                workingRng.Move wdParagraph, 1
                emptyPara = True
                workingRng.Text = m_strTextMark '"****"
              End If
            Else
              workingRng.Move wdParagraph, 1
              emptyPara = True
              workingRng.Paragraphs(1).Range.Delete
            End If
          Else
            emptyPara = False
          End If
        Loop While emptyPara = True
      Next
    Else
      For Each oPara In oCell.Range.Paragraphs
        If oPara.Range.Characters(1).Text = vbCr Then
          oPara.Range.Delete
        End If
      Next
      If Len(oCell.Range.Text) > 2 And _
           Asc(Right$(oCell.Range.Text, 3)) = 13 Then
        oCell.Range.Characters(Len(oCell.Range.Text) - 2).Delete
      End If
    End If
  Next
lbl_Exit:
  Exit Sub
End Sub

Attribute VB_Name = "frmDateAdd"
Attribute VB_Base = "0{584213C6-BC6B-4B8A-8688-DC739AF05D73}{0FE08EF0-86E2-4E3D-92F0-4CBA7AC27A82}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
'Created by Gregory K. Maxey - http://gregmaxey.mvps.org/index.html
Private m_ClearDaysToAddOption As Boolean
Private m_lngHeight As Long


Private Sub cbNamedRule_Click()
  Me.optFRCP6 = True
  Me.txtDaysToAdd = cbNamedRule
  
End Sub

Private Sub cmdCalEvent_Click()
  Height = 502.2
  frmCET.Caption = "Calendar Event"
  cmdCreate.Caption = "Create Event"
  txtSubj.SetFocus
lbl_Exit:
  Exit Sub
End Sub
Private Sub cmdTask_Click()
  Height = 502.2
  frmCET.Caption = "Task"
  txtSubj.SetFocus
  cmdCreate.Caption = "Create Task"
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmdCloseHelp_Click()
  frmHelp.Left = 307.8
  Width = 306
  Height = m_lngHeight
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmdCreate_Click()
Dim lngReminder As Long
  If cmdCreate.Caption = "Create Event" Then
    modOutlookInterop.fcnCreateCalEvent txtSubj, lbl_CustomDate
  Else
    modOutlookInterop.fcnCreateTask txtSubj, CDate(Me.txtBaseDate), lbl_CustomDate
  End If
  Unload Me
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmdHelp_Click()
  m_lngHeight = Height
  frmHelp.Left = 5.4
  Width = 554
  Height = 504.4
End Sub





Private Sub UserForm_Initialize()

  txtBaseDate = Format(Now, "M/d/yyyy")
  optAdv.value = True
  txtDaysToAdd = 0
  ToggleEnabled False
  Height = 423
  Width = 306
  With Me.cbNamedRule
    .AddItem
    .list(0, 0) = "Civil Motion Answer"
    .list(0, 1) = "30"
    .AddItem
    .list(1, 0) = "Next day"
    .list(1, 1) = "1"
  End With
lbl_Exit:
  Exit Sub
End Sub

Private Sub optBusinessDays_click()
  txtDaysToAdd_Change
  If optBusinessDays Then ToggleEnabled True
lbl_Exit:
  Exit Sub
End Sub

Private Sub optCalendarDays_Click()
  txtDaysToAdd_Change
  If optCalendarDays Then ToggleEnabled True
lbl_Exit:
  Exit Sub
End Sub

Private Sub optFRCP6_Click()
  txtDaysToAdd_Change
  If optFRCP6 Then ToggleEnabled True
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmd_Cancel_Click()
  Unload Me
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmd_OK_Click()
  modMain.Calc_InsertDateAdd txtBaseDate, txtDaysToAdd, optAdv, optBusinessDays, optFRCP6, True
  Unload Me
lbl_Exit:
  Exit Sub
End Sub

Private Sub DTPicker1_Change()
  txtDaysToAdd_Change
lbl_Exit:
  Exit Sub
End Sub

Private Sub optAdv_Change()
  If optAdv Then
    Caption = "DatePlus" & ChrW(8482) & " - Date Advance"
    frmInsert.Caption = "Calculated Advanced Date"
    cmd_OK.Caption = "Insert Advanced Date"
    ToggleLabels "Adv"
  Else
    Caption = "DatePlus" & ChrW(8482) & " - Date Regress"
    frmInsert.Caption = "Calculated Regressed Date"
    cmd_OK.Caption = "Insert Regressed Date"
    ToggleLabels "Back"
  End If
  txtDaysToAdd_Change
lbl_Exit:
  Exit Sub
End Sub
Private Sub sbTickBD_SpinDown()
  If IsDate(txtBaseDate) Then
    txtBaseDate = DateAdd("d", -1, txtBaseDate)
  Else
    txtBaseDate = Format(Now, "MM/dd/yyyy")
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtBaseDate_Change()
  If IsDate(txtBaseDate) Then
    txtDaysToAdd_Change
   cmd_OK.Enabled = True
  Else
   cmd_OK.Enabled = False
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub txtBaseDate_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
  If KeyAscii = 27 Then Unload Me
  If Len(txtDaysToAdd) > 0 Then
    If KeyAscii = 13 Then cmd_OK_Click
  End If
  If Not (KeyAscii > 46 And KeyAscii < 59) And Not (KeyAscii = 44 Or KeyAscii = 45) Then
    Beep
    KeyAscii = 0
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub sbTickBD_SpinUp()
  If IsDate(txtBaseDate) Then
    txtBaseDate = DateAdd("d", 1, txtBaseDate)
  Else
    txtBaseDate = Format(Now, "MM/dd/yyyy")
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub sbDaysToAdd_SpinDown()
  If CLng(txtDaysToAdd) > 0 Then
    txtDaysToAdd = txtDaysToAdd - 1
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub sbDaysToAdd_SpinUp()
  txtDaysToAdd = txtDaysToAdd + 1
lbl_Exit:
  Exit Sub
End Sub

Private Sub txtDaysToAdd_Change()
Dim strCalc As String
Dim oCtr As Control
  If m_ClearDaysToAddOption Then
    For Each oCtr In frmDOS.Controls
      If InStr(oCtr.Name, "opt_DA") Then
        oCtr.value = False
      End If
    Next oCtr
  End If
  m_ClearDaysToAddOption = True
  If Len(txtDaysToAdd) > 0 And txtDaysToAdd <> "0" Then
    strCalc = modMain.Calc_InsertDateAdd(txtBaseDate, txtDaysToAdd, optAdv, optBusinessDays, optFRCP6, False)
    'strCalc = modMain.Calc_InsertDateAdd(DTPicker1, txtDaysToAdd, optAdv, optBusinessDays, optFRCP6, False)
    lbl_CustomDate.Caption = strCalc
    If optAdv Then
      Caption = "DatePlus" & ChrW(8482) & " - Date Advance"
      frmInsert.Caption = "Calculated Advanced Date"
      cmd_OK.Caption = "Insert Advanced Date"
    Else
      Caption = "DatePlus" & ChrW(8482) & " - Date Regress"
      frmInsert.Caption = "Calculated Regressed Date"
      cmd_OK.Caption = "Insert Regressed Date"
    End If
  Else
    Caption = "DatePlus" & ChrW(8482) & " - Start Date"
    frmInsert.Caption = "Date"
    cmd_OK.Caption = "Insert Date"
    lbl_CustomDate.Caption = Format(txtBaseDate, "mmmm d, yyyy")
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub txtDaysToAdd_Enter()
  With txtDaysToAdd
    .SetFocus
    .SelStart = 0
    .SelLength = Len(.Text)
  End With
lbl_Exit:
  Exit Sub
End Sub

Private Sub txtReminder_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
  If Not (KeyAscii > 47 And KeyAscii < 59) Then
    Beep
    KeyAscii = 0
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtDaysToAdd_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
  If KeyAscii = 27 Then Unload Me
  If Len(txtDaysToAdd) > 0 Then
    If KeyAscii = 13 Then cmd_OK_Click
  End If
  If Not (KeyAscii > 47 And KeyAscii < 59) Then
    Beep
    KeyAscii = 0
  End If
lbl_Exit:
  Exit Sub
End Sub

Sub AddDaysToDate(lngDaysToAdd As Long)
 With Selection
   .InsertAfter Format(DateAdd("d", lngDaysToAdd, Now()), "mmmm d, yyyy")
   .Collapse wdCollapseEnd
 End With
 Unload Me
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA3_Change()
  If opt_DA3 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 3
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA7_Change()
  If opt_DA7 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 7
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA10_Change()
  If opt_DA10 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 10
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA14_Change()
  If opt_DA14 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 14
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA21_Change()
  If opt_DA21 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 21
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA30_Change()
  If opt_DA30 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 30
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA35_Change()
  If opt_DA35 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 35
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA60_Change()
  If opt_DA60 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 60
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA70_Change()
 If opt_DA70 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 70
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA100_Change()
 If opt_DA100 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 100
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub opt_DA120_Change()
   If opt_DA120 Then
    m_ClearDaysToAddOption = False
    txtDaysToAdd = 120
  End If
lbl_Exit:
  Exit Sub
End Sub

Sub ToggleLabels(strDir As String)
  Select Case strDir
    Case "Adv"
      opt_DA3.Caption = "+ 3"
      opt_DA7.Caption = "+ 7"
      opt_DA10.Caption = "+ 10"
      opt_DA14.Caption = "+ 14"
      opt_DA21.Caption = "+ 21"
      opt_DA30.Caption = "+ 30"
      opt_DA35.Caption = "+ 35"
      opt_DA60.Caption = "+ 60"
      opt_DA70.Caption = "+ 70"
      opt_DA100.Caption = "+ 100"
      opt_DA120.Caption = "+ 120"
    Case "Back"
      opt_DA3.Caption = "- 3"
      opt_DA7.Caption = "- 7"
      opt_DA10.Caption = "- 10"
      opt_DA14.Caption = "- 14"
      opt_DA21.Caption = "- 21"
      opt_DA30.Caption = "- 30"
      opt_DA35.Caption = "- 35"
      opt_DA60.Caption = "- 60"
      opt_DA70.Caption = "- 70"
      opt_DA100.Caption = "- 100"
      opt_DA120.Caption = "- 120"
  End Select
lbl_Exit:
  Exit Sub
End Sub

Sub ToggleEnabled(ByRef bEnabled As Boolean)
Dim oCtr As Control
  For Each oCtr In frmInsert.Controls
    If Me.frmInsert.Caption <> "Date" Then
      oCtr.Enabled = bEnabled
      cmdHelp.Enabled = True
      cmd_Cancel.Enabled = True
    Else
      oCtr.Enabled = True
    End If
  Next oCtr
  For Each oCtr In frmDOS.Controls
    oCtr.Enabled = bEnabled
  Next oCtr
  frmDOS.Enabled = bEnabled
  txtDaysToAdd_Change
End Sub
Attribute VB_Name = "frmEnv_Label_Help"
Attribute VB_Base = "0{A1A05740-D1B9-4AA9-804E-B92135135641}{89CAACB2-6F8E-49C7-99FC-9308EC40D8E9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub CommandButton1_Click()
  Unload Me
End Sub


Attribute VB_Name = "frmEnvelopesAndLabels"
Attribute VB_Base = "0{6F44885E-3296-48C3-82B7-8708B47CDD82}{C01FAA53-A881-40B1-B0CB-315311B38E68}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Private m_strName As String

Private Sub cbLabelTemplate_Change()
   If Not modMain.fcnMatchedEntry(cbLabelTemplate) Then
     ResetConfiguration
   Else
     cmdAddToDoc.Enabled = True
     cmdPrint.Enabled = True
   End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub chkPreprinted_Change()
  If chkPreprinted = True Then
    chkReturnAddress = False
    chkReturnAddress.Enabled = False
    txtReturnAddress.Text = "Return address is not available in this configuration."
  Else
    chkReturnAddress.Enabled = True
    txtReturnAddress.Text = "Select ""Use Return Address"" to enable field."
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmdHelp_Click()
  frmEnv_Label_Help.Show
lbl_Exit:
  Exit Sub
End Sub

Private Sub UserForm_Initialize()
Dim arrDPList() As String
Dim lngAddressees As Long
  Caption = "Envelopes and Labels"
  With cboDelivery
    .AddItem "Via Courier"
    .AddItem "Via FedEx"
    .AddItem "via UPS"
    .AddItem "Via U.S. Mail"
  End With
  With Me.cbLabelTemplate
    .AddItem "Avery 5160 - 30\Sheet (3 x 10)"
    .AddItem "Avery 5161 - 20\Sheet (2 x 10)"
    .AddItem "Avery 5162 - 14\Sheet (2 x 7)"
    .AddItem "Avery 5163 - 10\Sheet (2 X 5)"
    .AddItem "Avery 5164 - 06\Sheet (2 x 3)"
    .AddItem "Avery 5260 - 30\Sheet (3 x 10)"
    .AddItem "Avery 5261 - 20\Sheet (2 x 10)"
    .AddItem "Avery 5262 - 14\Sheet (2 x 7)"
    .AddItem "Avery 5263 - 10\Sheet (2 x 5)"
    .AddItem "Avery 5371 - 10\Sheet (2 x 5)"
    .AddItem "Avery 5661 - 20\Sheet (2 x 10)"
    .AddItem "Avery 5662 - 14\Sheet (2 x 7)"
    .AddItem "Avery 5667 - 80\Sheet (4 x 20)"
    .AddItem "Avery 5966 - 30\Sheet (2 x 15)"
  End With
  'Check the document to see if addresses have been setup
  If Documents.count >= 1 Then
    lngAddressees = lngAddresseesIntoArray(p_arrEnvLabAddressees())
    If lngAddressees > 0 Then
      txtAddressee = CStr(lngAddressees) & " addresses selected"
    End If
  End If
  optEnvelopes.value = True
lbl_Exit:
  Exit Sub
End Sub

Sub CreateDocOrPrint(Optional bCreateDocument As Boolean = True)
  If Not IsNumeric(txtNumLabels) Then txtNumLabels = 1
  If txtNumLabels = 0 Then txtNumLabels = 1
  'Check to see if they have left anything behind in the text entry window.
  If txtAddressee <> "" Then cmdAdd_Click
  'Is at least one addressee defined?
  If lbAddresseeList.ListCount < 1 Then
    modNotifyError.Notify_ShowError 1, 16, False
    Exit Sub
  End If
  'Envelops?
  If optEnvelopes Then modEnvsAndLbls.EnvAddToDoc True
  'Labels?
  Select Case Me.cbLabelTemplate.ListIndex
    'These are all simple label formats.  Single content/no return address.
    Case 0, 1, 2, 5, 6, 7, 9, 10, 11, 12, 13
      'First Mid statement returns label ID (e.g., 5160).  Second Mid statement retruns number of labels per sheet.
      modEnvsAndLbls.AverySimpleCommonAddToDoc Mid(cbLabelTemplate, 7, 4), Mid(cbLabelTemplate, 14, 2), bCreateDocument
    Case 3, 4, 8
      'First Mid statement returns label ID (e.g., 5160).  Second Mid statement retruns number of labels per sheet.
      modEnvsAndLbls.AveryComplexCommonAddToDoc Mid(cbLabelTemplate, 7, 4), Mid(cbLabelTemplate, 14, 2), bCreateDocument
  End Select
  Unload Me
lbl_Exit:
  Exit Sub
End Sub
Private Sub cbLabelTemplate_Click()
  optEnvelopes.value = False
  chkPreprinted = False
  chkPreprinted.Enabled = True
  ResetConfiguration
    Select Case cbLabelTemplate.ListIndex
    Case 0, 5: ConfigureFor5160
    Case 1, 6, 9: ConfigureFor5161
    Case 2, 7, 10: ConfigureFor5162
    Case 3, 8: ConfigureFor5163
    Case 4: ConfigureFor5164
    Case 11: ConfigureFor5667
    Case 12:: ConfigureFor5667
    Case 13: ConfigureFor5966
  End Select
  cmdPrint.Enabled = True
  cmdAddToDoc.Enabled = True
lbl_Exit:
   Exit Sub
End Sub

Private Sub optEnvelopes_Change()
  If optEnvelopes Then
    ResetConfiguration
    ConfigureForEnvelopes
    cmdAddToDoc.Enabled = True
    cmdPrint.Enabled = True
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub ResetConfiguration()
   'Disable return address, barcode and delivery phrase
   chkReturnAddress = False
   chkReturnAddress.Enabled = False
   txtReturnAddress.Text = "Return address is not available in this configuration."
   txtReturnAddress.Enabled = False
   lblDelivery.Enabled = False
   cboDelivery.Enabled = False
   cboDelivery = ""
   lblStart.Visible = False
   txtStart.Visible = False
   spinStart.Visible = False
   spinStart.Visible = False
   lblDuplicates.Visible = False
   txtNumLabels.Visible = False
   spinNum.Visible = False
   lblItem.Caption = "Define text\addressee:"
   lblList.Caption = "Text\Addressee List:"
   cmdAddToDoc.Enabled = False
   cmdPrint.Enabled = False
End Sub
Private Sub ConfigureForEnvelopes()
  
  chkPreprinted.Enabled = True
  chkPreprinted = True
  frmText.Caption = "Build\Define Individual Addressees"
  cbLabelTemplate.ListIndex = -1
  'chkReturnAddress.Enabled = True
  lblDelivery.Enabled = True
  cboDelivery.Enabled = True
  chkPreprinted = True
  lblItem.Caption = "Define Addressee:"
  lblList.Caption = "Addressee List:"
lbl_Exit:
  Exit Sub
End Sub


Private Sub ConfigureFor5160()
  frmText.Caption = "Build\Define Individual Addressees"
  FinishLabelConfig 30
lbl_Exit:
  Exit Sub
End Sub

Private Sub ConfigureFor5162()
  FinishLabelConfig 14
lbl_Exit:
  Exit Sub
End Sub

Private Sub ConfigureFor5163()
  'Enable return address, barcode and delivery phrase
  chkReturnAddress.Enabled = True
  txtReturnAddress.Text = "Select ""Use Return Address"" to enable field."
  lblDelivery.Enabled = True
  cboDelivery.Enabled = True
  cboDelivery = ""
  FinishLabelConfig 10
lbl_Exit:
  Exit Sub
End Sub

Private Sub ConfigureFor5164()
  'Enable return address, barcode and delivery phrase
  chkReturnAddress.Enabled = True
  txtReturnAddress.Text = "Select ""Use Return Address"" to enable field."
  lblDelivery.Enabled = True
  cboDelivery.Enabled = True
  cboDelivery = ""
  FinishLabelConfig 6
lbl_Exit:
  Exit Sub
End Sub
Private Sub ConfigureFor5161()
  FinishLabelConfig 20
lbl_Exit:
  Exit Sub
End Sub

Private Sub ConfigureFor5662()
  FinishLabelConfig 14
lbl_Exit:
  Exit Sub
End Sub

Private Sub ConfigureFor5667()
  FinishLabelConfig 80
lbl_Exit:
  Exit Sub
End Sub
Private Sub ConfigureFor5966()
  FinishLabelConfig 30
lbl_Exit:
  Exit Sub
End Sub

Private Sub FinishLabelConfig(ByRef lngMax As Long)
  lblStart.Visible = True
  txtStart.Visible = True
  spinStart.Visible = True
  spinStart.Visible = True
  lblDuplicates.Visible = True
  txtNumLabels.Visible = True
  spinNum.Visible = True
  spinStart.min = 1
  spinStart.max = lngMax
  txtStart.value = 1
  txtNumLabels.value = 1
lbl_Exit:
  Exit Sub
End Sub
Private Sub chkBarCode_Change()
  chkReturnAddress_Change
lbl_Exit:
  Exit Sub
End Sub

Private Sub chkReturnAddress_Change()
  If chkReturnAddress Then
    txtReturnAddress.Enabled = True
    txtReturnAddress.Text = vbNullString
  Else
    txtReturnAddress.Enabled = False
    If chkReturnAddress.Enabled Then
      txtReturnAddress.Text = "Select ""Use Return Address"" to enable field."
    End If
  End If
  If optEnvelopes Then
    Select Case True
      Case chkReturnAddress: txtReturnAddress.Enabled = True
      Case Not chkReturnAddress: txtReturnAddress.Enabled = False
    End Select
    Repaint
  End If
lbl_Exit:
  Exit Sub
End Sub

Sub CtrlShowRelocate(ByRef oCtr As Object, bVisible As Boolean, lngTop As Long, lngLeft As Long)
  With oCtr
    .Visible = bVisible
    .Top = lngTop
    .Left = lngLeft
  End With
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmdAddressBook_Click()
Dim strAddressees As String, strTemp As String
Dim lngIndex As Long, lngLBCount As Long

  strAddressees = modOutlookInterop.fcnGetOutlookMailingAddress(0)
  'Here we'll check to see if the listbox already has a valid entry in it, otherwise we'll empty it
  If lbAddresseeList.ListCount = 1 Then
    If lbAddresseeList.list(0) = "" Then
      lbAddresseeList.Clear
    End If
  End If
  'Capture the current number of entries in the listbox
  lngLBCount = lbAddresseeList.ListCount
  'Now we take the information returned from Outlook and load the array and place that information into the listbox
  While Len(strAddressees) > 0
    If InStr(strAddressees, "*") > 0 And Len(strAddressees) > 3 Then
      ReDim Preserve p_arrEnvLabAddressees(lngLBCount)
      'Now combine the individual pieces into an Address
      'Get the Courtesy title
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = strTemp & " "
      'Get the rest of the name
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then
        m_strName = m_strName & strTemp
        'Call the sub routine to check for the existence of a name suffix like Esq., and if it exists, put a comma between the name and the suffix
        modMain.fcnFixSuffix m_strName
      End If
      'Get the Title
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = m_strName & strTemp & Chr(13)
      'Get the Department name
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = m_strName & strTemp & Chr(13)
      'Get the Company Name
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = m_strName & strTemp & Chr(13)
      'Get the Street Address
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = m_strName & strTemp & Chr(13)
      'Get the City
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = m_strName & strTemp & ", "
      'Get the State
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = m_strName & strTemp & "  "
      'Get the postal Code
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If strTemp <> "" Then m_strName = m_strName & strTemp
      'Get the Country
      strTemp = Left(strAddressees, InStr(strAddressees, ";") - 1)
      strAddressees = Right(strAddressees, Len(strAddressees) - InStr(strAddressees, ";"))
      If UCase(strTemp) <> "UNITED STATES OF AMERICA" Then
         m_strName = m_strName & Chr(13) & strTemp
      End If
      'Add the address to the array
      p_arrEnvLabAddressees(lngLBCount) = m_strName
      'Clear the string vars
      m_strName = ""
      strTemp = ""
      'Check the balance of the string
      lngLBCount = lngLBCount + 1
      If Len(strAddressees) < 5 Then
        strAddressees = ""
      Else
        strAddressees = Right(strAddressees, Len(strAddressees) - 3)
      End If
    End If
  Wend
Finish:
  On Error GoTo Err_Scope
  txtAddressee = p_arrEnvLabAddressees(UBound(p_arrEnvLabAddressees))
  On Error GoTo 0
lbl_Exit:
  Exit Sub
Err_Scope:
  txtAddressee = ""
End Sub

Private Sub cmdAdd_Click()
Dim lngIndex As Long
Dim strTemp As String

  'Check out whether there were addresses selected when the dialog box was opened
  If Right(txtAddressee, 18) = "addresses selected" Then
    'Load the listbox with the first line of address of each entry in the array
    For lngIndex = 0 To UBound(p_arrEnvLabAddressees)
      If InStr(p_arrEnvLabAddressees(lngIndex), Chr(13)) > 0 Then
        strTemp = Left(p_arrEnvLabAddressees(lngIndex), InStr(p_arrEnvLabAddressees(lngIndex), Chr(13)) - 1)
      Else
        strTemp = p_arrEnvLabAddressees(lngIndex)
      End If
      lbAddresseeList.AddItem (strTemp)
    Next lngIndex
    'Clear the addressee text box and set the focus and jump out.
    txtAddressee = ""
    txtAddressee.SetFocus
    Exit Sub
  End If
  'Pick up the first line of the addressee
  If txtAddressee <> "First Line will be copied to Header" Then
    If txtAddressee <> "" Then
      ReDim Preserve p_arrEnvLabAddressees(lbAddresseeList.ListCount)
      p_arrEnvLabAddressees(lbAddresseeList.ListCount) = txtAddressee
      If InStr(1, txtAddressee, Chr(13)) <> 0 Then
        lbAddresseeList.AddItem (Left(txtAddressee, InStr(1, txtAddressee, Chr(13)) - 1))
      Else
        lbAddresseeList.AddItem (txtAddressee)
      End If
    End If
  End If
  'Clear out the addressee text box and set the focus back to it
  txtAddressee = ""
  txtAddressee.SetFocus
lbl_Exit:
  Exit Sub
End Sub
Private Sub cmdDelete_Click()
Dim lngIndex As Long, lngNewScope As Long
  'Check if they have choosen an addressee to remove
  If lbAddresseeList.ListIndex < 0 Then
    modNotifyError.Notify_ShowError 1, 17
    Exit Sub
  End If
  'Get rid of the item in the array, then change the list box
  lngNewScope = UBound(p_arrEnvLabAddressees) - 1
  For lngIndex = lbAddresseeList.ListIndex To lngNewScope
    p_arrEnvLabAddressees(lngIndex) = p_arrEnvLabAddressees(lngIndex + 1)
  Next lngIndex
  'Check to make sure they haven't deleted all the addressees
  If lngNewScope > -1 Then
    ReDim Preserve p_arrEnvLabAddressees(lngNewScope)
  Else
    ReDim p_arrEnvLabAddressees(0)
    txtAddressee.SetFocus
  End If
  'Now get rid of it in the list box
  lbAddresseeList.RemoveItem (lbAddresseeList.ListIndex)
lbl_Exit:
  Exit Sub
End Sub



Private Sub cmdAddToDoc_Click()
  CreateDocOrPrint
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmdPrint_Click()
  CreateDocOrPrint False
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmdCancel_Click()
  Unload Me
lbl_Exit:
  Exit Sub
End Sub

Private Sub spinStart_SpinDown()
  txtStart = txtStart - 1
  If txtStart < spinStart.min Then
    txtStart = spinStart.min
    Beep
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub spinStart_SpinUp()
  txtStart = txtStart + 1
  If txtStart > spinStart.max Then
    txtStart = spinStart.max
    Beep
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub spinNum_SpinDown()
  txtNumLabels = txtNumLabels - 1
  If txtNumLabels < spinNum.min Then
    txtNumLabels = spinNum.min
    Beep
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub spinNum_SpinUp()
  txtNumLabels = txtNumLabels + 1
lbl_Exit:
  Exit Sub
End Sub


Attribute VB_Name = "frmHotKeyMenu"
Attribute VB_Base = "0{BCE7BC23-03CB-4208-BB13-A8C61DBABF6A}{756D0A6C-56C4-4FC0-B31E-96890425AE16}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub Label61_Click()
  modKeyBoardShortCuts.NonBreakingSpace
  Unload Me
End Sub
Private Sub lblBullet_LeftIndent_Click()
  modKeyBoardShortCuts.Bullet_LeftIndent
  Unload Me
End Sub

Private Sub lblCancelCitationCharacterStyle_Click()
  modKeyBoardShortCuts.ResetFontFormatting
  Unload Me
End Sub

Private Sub lblCFR_Section_Click()
  modKeyBoardShortCuts.CFR_Section
  Unload Me
End Sub

Private Sub lblCFR_Sections_Click()
  modKeyBoardShortCuts.CFR_Sections
  Unload Me
End Sub

Private Sub lblClosingDoubleQuote_Click()
  modKeyBoardShortCuts.ClosingDoubleQuote
  Unload Me
End Sub

Private Sub lblClosingSingleQuote_Click()
  modKeyBoardShortCuts.ClosingSingleQuote
  Unload Me
End Sub

Private Sub lblDblPilcrow_Click()
  modKeyBoardShortCuts.Dbl_Pilcrows_NBSpace
  Unload Me
End Sub

Private Sub lblDblSectionSymbols_Click()
  modKeyBoardShortCuts.Dbl_Section_Symbol_and_NBSpace
  Unload Me
End Sub

Private Sub lblEm_dash_Click()
  modKeyBoardShortCuts.Em_Dash
  Unload Me
End Sub

Private Sub lblEn_Dash_Click()
  modKeyBoardShortCuts.En_Dash
  Unload Me
End Sub

Private Sub lblF_Appx_Click()
  modKeyBoardShortCuts.F_Appx
  Unload Me
End Sub

Private Sub lblF_Supp_Click()
  modKeyBoardShortCuts.F_Supp
  Unload Me
End Sub

Private Sub lblNBS_Ellipsis_NBS_Click()
  modKeyBoardShortCuts.NBS_Ellipsis_NBS
  Unload Me
End Sub

Private Sub lblOpeningDoubleQuote_Click()
  modKeyBoardShortCuts.OpeningDoubleQuote
  Unload Me
End Sub

Private Sub lblOpeningSingleQuote_Click()
  modKeyBoardShortCuts.OpeningSingleQuote
  Unload Me
End Sub

Private Sub lblPasteUnformattedText_Click()
  modKeyBoardShortCuts.PasteUnformattedText
  Unload Me
End Sub

Private Sub lblPilcrow_Click()
  modKeyBoardShortCuts.Pilcrow_NBSpace
  Unload Me
End Sub

Private Sub lblPrintCurrentPage_Click()
  modKeyBoardShortCuts.PrintCurrentPage
  Unload Me
End Sub

Private Sub lblRevealFormatting_Click()
  modKeyBoardShortCuts.RevealFormatting
  Unload Me
End Sub

Private Sub lblRunShowKeyboardMacro_Click()
  Unload Me
End Sub

Private Sub lblSectionBreak_Click()
  modKeyBoardShortCuts.Section_Symbol_and_NBSpace
  Unload Me
End Sub

Private Sub lblUSC_Section_Click()
  modKeyBoardShortCuts.USC_Section
  Unload Me
End Sub

Private Sub lblUSC_Sections_Click()
  modKeyBoardShortCuts.USC_Sections
  Unload Me
End Sub

Private Sub lblUSCG_Section_Click()
  modKeyBoardShortCuts.USSG_Section
  Unload Me
End Sub

Private Sub lblUSCG_Sections_Click()
  modKeyBoardShortCuts.USSG_Sections
  Unload Me
End Sub

Private Sub UserForm_Initialize()
Dim oCtr As Control
  If Documents.count = 0 Then
    For Each oCtr In Me.Controls
      If TypeName(oCtr) = "Label" Then
        If oCtr.ForeColor = &HFF0000 Then
            oCtr.Enabled = False
        End If
      End If
    Next oCtr
  End If
lbl_Exit:
  Exit Sub
End Sub
Attribute VB_Name = "frmInfo"
Attribute VB_Base = "0{DC1231B9-C1D2-416D-ACF6-A6547A1716C3}{8D93422A-8EA1-41FD-B269-3CB367E05FD0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub CommandButton1_Click()
  Unload Me
lbl_Exit:
  Exit Sub
End Sub
Attribute VB_Name = "frmListFiles"
Attribute VB_Base = "0{7DEE7432-3EC8-45B5-80D3-642D8CDA781E}{7D216F95-DC5F-4B1F-8836-07F7C4F8F86C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit
Private m_oFSO As New FileSystemObject

Private Sub cmdBrowse_Click()
Dim strPath As String
Dim fDialog As FileDialog
  If m_oFSO.FolderExists(txtFolder) Then
    strPath = txtFolder
  Else
    strPath = "N:\"
  End If
  Set fDialog = Application.FileDialog(msoFileDialogFolderPicker)
  With fDialog
    .Title = "Select Folder to list and click OK"
    .InitialFileName = strPath
    .AllowMultiSelect = False
    .InitialView = msoFileDialogViewList
    If .Show <> -1 Then Exit Sub
    txtFolder = fDialog.SelectedItems.Item(1)
  End With
lbl_Exit:
  Set m_oFSO = Nothing
  Set fDialog = Nothing
  Exit Sub
End Sub
Private Sub cmdCL_Click()
Dim oFolder
Dim lngCount As Long
  If cmdCL.Caption = "Create List" Then
    If m_oFSO.FolderExists(Me.txtFolder) Then
      Set oFolder = m_oFSO.GetFolder(Me.txtFolder)
      lngCount = 0
      If optWord Then
        Tag = "Process Word"
      Else
        Tag = "Process Excel"
      End If
      If optNameSize.value = True Then lngCount = lngCount + 1
      If optNSTDM.value = True Then lngCount = lngCount + 2
      If oFolder.Files.count > 200 Or Me.cbIncludeSubs Then
        frmNotify.Left = 5.4
        cmdCL.Caption = "OK"
        frmNotify.ZOrder 0
       Else
        Hide
      End If
    Else
      modNotifyError.Notify_ShowError 1, 9
      With txtFolder
        .SetFocus
        .SelStart = 0
        .SelLength = Len(.Text)
      End With
    End If
  Else
    Hide
  End If
lbl_Exit:
    Set m_oFSO = Nothing
  Set oFolder = Nothing
  Exit Sub
End Sub


Private Sub optWord_Change()
  If optWord Then
    frameData.Enabled = True
    optName.Enabled = True
    optNameSize.Enabled = True
    optNSTDM.Enabled = True
  Else
    frameData.Enabled = False
    optName.Enabled = False
    optNameSize.Enabled = False
    optNSTDM.Enabled = False
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub txtFolder_Change()
  If txtFolder.Text = "" Then
    cmdCL.Enabled = False
  Else
    cmdCL.Enabled = True
  End If
lbl_Exit:
  Exit Sub
End Sub

Private Sub UserForm_Initialize()
  Caption = "File List"
  optWord.value = True
  optNSTDM.value = True
  cbIncludeSubs.value = True
  Me.Width = 236
  If Documents.count > 0 Then
    'Defaule folder is the active document path
    txtFolder = ActiveDocument.Path
  Else
    txtFolder = "N:\"
  End If
  If txtFolder.Text = "" Then cmdCL.Enabled = False
lbl_Exit:
  Exit Sub
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then
    Cancel = True
    Hide
  End If
lbl_Exit:
  Exit Sub
End Sub
Attribute VB_Name = "frmNotify"
Attribute VB_Base = "0{E6BBD822-29DE-4947-976E-52ABB9AA89CF}{EDE7E0A8-8457-4E61-850D-6B6BFB93668C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Sub CB_ErrOK_Click()
  Tag = "1"
  Hide
End Sub
Private Sub CBErrNo_Click()
  Tag = "0"
  Hide
End Sub

Private Sub UserForm_Initialize()
  Caption = "User Notifation and Errors"
  Tag = "0"
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    Cancel = True
    CBErrNo_Click
  End If
End Sub


Attribute VB_Name = "frmPWord"
Attribute VB_Base = "0{5257CE3B-14EC-4899-A415-49EF68AC262E}{C04AA769-2DBA-4781-A110-65BEDC6F8FAE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Private Sub cmd_PasswordCancel_Click()
  frmPWord.TxtPassword = "***Password not provided***"
  Me.Hide
lbl_Exit:
  Exit Sub
End Sub
Private Sub cmd_PasswordOK_Click()
  Me.Hide
lbl_Exit:
  Exit Sub
End Sub
Private Sub TxtPassword_Change()
  With frmPWord
    If .TxtPassword = "" Then
     .cmd_PasswordOK.Enabled = False
    Else
     .cmd_PasswordOK.Enabled = True
    End If
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub UserForm_Initialize()
  frmPWord.cmd_PasswordOK.Enabled = False
lbl_Exit:
  Exit Sub
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then Cancel = True
lbl_Exit:
  Exit Sub
End Sub

Attribute VB_Name = "frmProgressBarContinous"
Attribute VB_Base = "0{36347D0E-4D4C-4840-A45E-820E93B9FB07}{10D9E3BF-5449-4279-B32B-8B6DFCD272A9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Public Function ChangeUp(ByRef lngConf As Long)
On Error Resume Next
With Me
  Select Case lngConf
    Case 1
      .Frame1.BackColor = &HC000&
      .Frame2.BackColor = &HC0FFFF
      .Frame3.BackColor = &HC0FFFF
      .Frame4.BackColor = &HC0FFFF
      .Frame5.BackColor = &HC0FFFF
      .Frame6.BackColor = &HC0FFFF
      .Frame7.BackColor = &HC0FFFF
      .Frame8.BackColor = &HC0FFFF
      .Frame9.BackColor = &HC0FFFF
      .Frame10.BackColor = &HC0FFFF
      .Frame11.BackColor = &HC000&
      .Repaint
    Case 2
      .Frame1.BackColor = &HC0FFFF
      .Frame2.BackColor = &HC000&
      .Frame3.BackColor = &HC0FFFF
      .Frame4.BackColor = &HC0FFFF
      .Frame5.BackColor = &HC0FFFF
      .Frame6.BackColor = &HC0FFFF
      .Frame7.BackColor = &HC0FFFF
      .Frame8.BackColor = &HC0FFFF
      .Frame9.BackColor = &HC0FFFF
      .Frame10.BackColor = &HC000&
      .Frame11.BackColor = &HC0FFFF
      .Repaint
    Case 3
      .Frame1.BackColor = &HC0FFFF
      .Frame2.BackColor = &HC0FFFF
      .Frame3.BackColor = &HC000&
      .Frame4.BackColor = &HC0FFFF
      .Frame5.BackColor = &HC0FFFF
      .Frame6.BackColor = &HC0FFFF
      .Frame7.BackColor = &HC0FFFF
      .Frame8.BackColor = &HC0FFFF
      .Frame9.BackColor = &HC000&
      .Frame10.BackColor = &HC0FFFF
      .Frame11.BackColor = &HC0FFFF
      .Repaint
    Case 4
      .Frame1.BackColor = &HC0FFFF
      .Frame2.BackColor = &HC0FFFF
      .Frame3.BackColor = &HC0FFFF
      .Frame4.BackColor = &HC000&
      .Frame5.BackColor = &HC0FFFF
      .Frame6.BackColor = &HC0FFFF
      .Frame7.BackColor = &HC0FFFF
      .Frame8.BackColor = &HC000&
      .Frame9.BackColor = &HC0FFFF
      .Frame10.BackColor = &HC0FFFF
      .Frame11.BackColor = &HC0FFFF
      .Repaint
    Case 5
      .Frame1.BackColor = &HC0FFFF
      .Frame2.BackColor = &HC0FFFF
      .Frame3.BackColor = &HC0FFFF
      .Frame4.BackColor = &HC0FFFF
      .Frame5.BackColor = &HC000&
      .Frame6.BackColor = &HC0FFFF
      .Frame7.BackColor = &HC000&
      .Frame8.BackColor = &HC0FFFF
      .Frame9.BackColor = &HC0FFFF
      .Frame10.BackColor = &HC0FFFF
      .Frame11.BackColor = &HC0FFFF
      .Repaint
    Case 6
      .Frame1.BackColor = &HC0FFFF
      .Frame2.BackColor = &HC0FFFF
      .Frame3.BackColor = &HC0FFFF
      .Frame4.BackColor = &HC0FFFF
      .Frame5.BackColor = &HC0FFFF
      .Frame6.BackColor = &HC000&
      .Frame7.BackColor = &HC0FFFF
      .Frame8.BackColor = &HC0FFFF
      .Frame9.BackColor = &HC0FFFF
      .Frame10.BackColor = &HC0FFFF
      .Frame11.BackColor = &HC0FFFF
      .Repaint
  End Select
End With
End Function

Attribute VB_Name = "frmStamp"
Attribute VB_Base = "0{BE8CE8AD-5CC3-4DEE-976C-F4635F66B183}{BCC2D568-4285-4F39-9C05-1699FF077EBF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Dim i As Long
Dim oShape As Shape
Dim oSec As section
Private Type CHOOSECOLOR
  lStructSize As Long
  hwndOwner As Long
  hInstance As Long
  rgbResult As Long
  lpCustColors As String
  flags As Long
  lCustData As Long
  lpfnHook As Long
  lpTemplateName As String
End Type
Private Declare Function ChooseColorAPI Lib "comdlg32.dll" Alias _
  "ChooseColorA" (pChoosecolor As CHOOSECOLOR) As Long
Dim CustomColors() As Byte
Dim lngcolor As Long

Private Sub cbStampText_Change()
  Select Case Len(Me.cbStampText.value)
    Case 0, 1, 2, 3, 4
      Me.txtFontSize.value = 84
    Case 5, 6
      Me.txtFontSize.value = 72
      
    Case 7, 8, 9
      Me.txtFontSize.value = 60
    Case Is > 9
      Me.txtFontSize = 48
  End Select
lbl_Exit:
  Exit Sub
End Sub
Private Sub cbStampText_Click()
  Select Case Me.cbStampText.value
    Case "PAID"
      Me.optGreen.value = True
    Case "COPY", "THANK YOU!"
      Me.optBlue.value = True
    Case "PAST DUE"
      Me.optRed.value = "True"
    Case Else
      Me.optBlack.value = "True"
  End Select
lbl_Exit:
  Exit Sub
End Sub

Private Sub cmd_Cancel_Click()
  ActiveDocument.Undo p_lngUndo
  Unload Me
End Sub

Private Sub Frame2_Exit(ByVal Cancel As MSForms.ReturnBoolean)
  txtFontSize_Exit Cancel
lbl_Exit:
  Exit Sub
End Sub
Private Sub optCustom_Change()
  If Me.optCustom.value = False Then
      Me.optCustom.BackColor = &H404040
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub optCustom_click()
  If Me.optCustom.value = True Then
    Dim cc As CHOOSECOLOR
    Dim Custcolor(16) As Long
    Dim lReturn As Long
    cc.lStructSize = Len(cc)
    cc.hwndOwner = Me.ActiveControl.[_GethWnd]
    cc.hInstance = 0
    cc.lpCustColors = StrConv(CustomColors, vbFromUnicode)
    cc.flags = 0
    lReturn = ChooseColorAPI(cc)
    If lReturn <> 0 Then
        lngcolor = cc.rgbResult
        Me.optCustom.BackColor = lngcolor
        CustomColors = StrConv(cc.lpCustColors, vbFromUnicode)
    Else
      Me.optBlack.value = True
    End If
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub chkLine_Change()
  If Me.chkLine.value = -1 Then
    Me.optPoints1.Enabled = True
    Me.optPoints1.value = True
    Me.optPoints2.Enabled = True
    Me.optPoints3.Enabled = True
    AppAdvisory "ADVISORY", "Outlined stamp text may " _
                      & "affect readability in the document", &HFF0000
  Else
    Me.optPoints1.Enabled = False
    Me.optPoints1.value = 0
    Me.optPoints2.Enabled = False
    Me.optPoints3.Enabled = False
    AppAdvisory "Credits", """Document Stamp"" developed and provided by Greg Maxey." _
                & vbCr & "Copyright 2011" & Chr(169), &H0&
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub cmdStamp_Click()
  If optCustom.value = True Then
    InsertWaterMark Me, lngcolor
  Else
    InsertWaterMark Me
  End If
  Me.Hide
lbl_Exit:
  Exit Sub
End Sub
Private Sub SpinButton1_SpinUp()
  With Me.txtTransparency
    Select Case .Text
      Case Is <> "100%"
      .Text = Left(.Text, Len(.Text) - 1) + 1 & "%"
    Case Else
    End Select
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub SpinButton1_SpinDown()
  With Me.txtTransparency
    Select Case .Text
      Case Is <> "0%"
      .Text = Left(.Text, Len(.Text) - 1) - 1 & "%"
    Case Else
    End Select
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub SpinButton2_SpinDown()
  With Me.txtRot
    If .Text - 5 < "-90" Then
      .Text = "-90"
    Else
      .Text = .Text - 5
    End If
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub SpinButton2_SpinUp()
  With Me.txtRot
    If .Text + 5 > "90" Then
      .Text = "90"
    Else
      .Text = .Text + 5
    End If
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub SpinButton3_SpinDown()
  With Me.txtFontSize
    If .Text - 12 < "36" Then
      .Text = "36"
    End If
    Select Case .Text
      Case Is <> "36"
        .Text = .Text - 12
      Case Else
        'Do nothing
    End Select
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub SpinButton3_SpinUp()
  With Me.txtFontSize
    If .Text + 12 > "228" Then
      .Text = "228"
    End If
    Select Case .Text
      Case Is <> "228"
        .Text = .Text + 12
      Case Else
        'Do nothing
    End Select
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtFontSize_Change()
  AppAdvisory "Credits", """Document Stamp"" developed and provided by Greg Maxey." _
                & vbCr & "Copyright 2011" & Chr(169), &H0&
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtFontSize_Exit(ByVal Cancel As MSForms.ReturnBoolean)
  AppAdvisory "Credits", """Document Stamp"" developed and provided by Greg Maxey." _
                & vbCr & "Copyright 2011" & Chr(169), &H0&
  With Me.txtFontSize
    If Not IsNumeric(.Text) Then
      Cancel = True
      .Text = "108"
      Beep
      AppAdvisory "ADVISORY", "You must use the spin button control" _
                  & " or enter a value between 36 and 228", &HFF&
      .SelStart = 0
      .SelLength = Len(.Text)
    End If
    If .Text < 36 Then
      Cancel = True
      .Text = "36"
      Beep
      AppAdvisory "ADVISORY", "You must use the spin button control" _
                  & " or enter a value between 36 and 228", &HFF&
      .SelStart = 0
      .SelLength = Len(.Text)
    End If
    If .Text > 228 Then
      Cancel = True
      .Text = "228"
      Beep
      AppAdvisory "ADVISORY", "You must use the spin button control" _
                  & " or enter a value between 36 and 228", &HFF&
      .SelStart = 0
      .SelLength = Len(.Text)
    End If
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtRot_Change()
  AppAdvisory "Credits", """Document Stamp"" developed and provided by Greg Maxey." _
                & vbCr & "Copyright 2011" & Chr(169), &H0&
  With Me.txtRot
    If Not IsNumeric(.Text) Then
      .Text = "-45"
      Beep
      AppAdvisory "ADVISORY", "You must use the spin button control" _
                  & " or enter a value between 90 and -90", &HFF&
      .SelStart = 0
      .SelLength = Len(.Text)
    End If
    If .Text > 90 Or .Text < -90 Then
      .Text = "-45"
      Beep
      AppAdvisory "ADVISORY", "You must use the spin button control" _
                  & " or enter a value between 90 and -90", &HFF&
      .SelStart = 0
      .SelLength = Len(.Text)
    End If
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtTransparency_Change()
  AppAdvisory "Credits", """Document Stamp"" developed and provided by Greg Maxey." _
                & vbCr & "Copyright 2011" & Chr(169), &H0&
  With Me.txtTransparency
    If Not .Text Like "##%" And Not .Text Like "#%" And Not .Text Like "0%" And Not .Text Like "100%" Then
      .Text = "50%"
      Beep
      AppAdvisory "ADVISORY", "You must use the spin button control" _
                  & " or enter a value between 0 and 100%", &HFF&
      .SelStart = 0
      .SelLength = Len(.Text) - 1
    Else
      Select Case Len(.Text)
        Case 2
          AppAdvisory "ADVISORY", "Transparency setting < 50% may " _
                      & "affect readability in the document", &HFF0000
        Case 3
          If Val(.Text) < 50 Then AppAdvisory "ADVISORY", "Transparency setting < 50% may " _
                      & "affect readability in the document", &HFF0000
      End Select
    End If
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtTransparency_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  If KeyCode = 9 Then
    With Me.txtTransparency
      .SelStart = 0
      .SelLength = Len(.Text) - 1
    End With
  End If
lbl_Exit:
  Exit Sub
End Sub
Private Sub txtTransparency_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
  With Me.txtTransparency
    .SelStart = 0
    .SelLength = Len(.Text) - 1
  End With
lbl_Exit:
  Exit Sub
End Sub
Private Sub UserForm_Initialize()
  Caption = "Document Stamp"
  modDocStamps.fcnRemoveWaterMark
  ReDim CustomColors(0 To 16 * 4 - 1) As Byte
  For i = LBound(CustomColors) To UBound(CustomColors)
    CustomColors(i) = 0
  Next i
  With Me
    .optBlue.BackColor = &HFF8080
    .optRed.BackColor = &H8080FF
    .optGreen.BackColor = &H80FF80
  End With
  With Me.cbStampText
    .AddItem "CONFIDENTIAL"
    .AddItem "Copy"
    .AddItem "Draft"
    .AddItem "Internal Discussion"
    .AddItem "Draft Copy"
    .AddItem "Attorney-Client Communication"
    .AddItem "Attorney Work Product"
    .ListIndex = 0
  End With
  StampSetup
lbl_Exit:
  Exit Sub
End Sub
Sub StampSetup()
  Dim arrFonts() As String
  With Me
    .optPoints1.Enabled = False
    .optPoints1.value = 0
    .optPoints2.Enabled = False
    .optPoints3.Enabled = False
    .optGreen.value = True
  End With
  ReDim arrFonts(Application.FontNames.count - 1)
  For i = 0 To Application.FontNames.count - 1
    arrFonts(i) = Application.FontNames(i + 1)
  Next i
  WordBasic.SortArray arrFonts, 0
  With Me
    With .cbStampText
      .SetFocus
      .SelStart = 0
      .SelLength = Len(.Text)
    End With
    With cbFontName
      .list = arrFonts
      .value = "Times New Roman"
    End With
    .txtTransparency = "75%"
    .txtRot = "-45"
    .txtFontSize = "84"
  End With
lbl_Exit:
  Exit Sub
End Sub
Sub AppAdvisory(ByRef pFrmStr As String, pStr As String, color As Long)
  With Me.Frame5
    .Caption = pFrmStr
    .ForeColor = color
  End With
  With Me.lblAdvisory
    .Caption = pStr
    .ForeColor = color
  End With
lbl_Exit:
  Exit Sub
End Sub


Attribute VB_Name = "frmUSAOAdminForm"
Attribute VB_Base = "0{E66D0A56-EB65-4167-A719-B67043BFE761}{5FCB7663-13AE-47D5-84A6-CE2E9EF03CB9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private m_bReplaceNormalButton As Boolean
Private m_bReplaceQATButton As Boolean

'Start Grey Out Stuff-----------------------Added all grey checks to Sub UserForm_Initialize()to check on start
Private Sub chkTab_Click()
    greyAll (chkTab.value)
End Sub
Private Sub chkShowGroupContent_Click()
    greyGroupContent (chkShowGroupContent.value)
End Sub

Private Sub chkShowGroupDistrictTemplates_Click()
    greyGroupDistrictTemplates (chkShowGroupDistrictTemplates.value)
End Sub

Private Sub chkShowGroupDrives_Click()
    greyGroupDrives (chkShowGroupDrives.value)
End Sub

Private Sub chkShowGroupLinks_Click()
    greyGroupLinks (chkShowGroupLinks.value)
End Sub

Private Sub chkShowGroupTools_Click()
   greyGroupTools (chkShowGroupTools.value)
End Sub

Sub greyAll(bool As Boolean)
    If chkTab.value Then
        txtTabName.Enabled = True
        lblTabName.Enabled = True
        frmDistrictTemplates.Enabled = True
        frmContent.Enabled = True
        frmDrives.Enabled = True
        frmTools.Enabled = True
        frmLinks.Enabled = True
        chkSmallIcons.Enabled = True
    Else
        txtTabName.Enabled = False
        lblTabName.Enabled = False
        frmDistrictTemplates.Enabled = False
        frmContent.Enabled = False
        frmDrives.Enabled = False
        frmTools.Enabled = False
        frmLinks.Enabled = False
        chkSmallIcons.Enabled = False
    End If
    
    greyGroupContent (chkTab.value)
    greyGroupDistrictTemplates (chkTab.value)
    greyGroupDrives (chkTab.value)
    greyGroupLinks (chkTab.value)
    greyGroupTools (chkTab.value)
    
End Sub

Sub greyGroupContent(bool As Boolean)
    If bool Then
        chkUSAOKeyboardShortcuts.Enabled = True
        chkDatePlus.Enabled = True
        chkWatermark.Enabled = True
        chkSymbols.Enabled = True
    Else
        chkUSAOKeyboardShortcuts.Enabled = False
        chkDatePlus.Enabled = False
        chkWatermark.Enabled = False
        chkSymbols.Enabled = False
    End If
    
    If chkTab.value Then
        chkShowGroupContent.Enabled = True
        lblShowGroupContent.Enabled = True
    Else
        chkShowGroupContent.Enabled = False
        lblShowGroupContent.Enabled = False
    End If
End Sub

Sub greyGroupDistrictTemplates(bool As Boolean)
    If bool Then
        chkTemplates.Enabled = True
        chkPleadings.Enabled = True
        chkAppeals.Enabled = True
        chkMemos.Enabled = True
        chkNewsRelease.Enabled = True
        chkLetters.Enabled = True
        chkPersonalTemplates.Enabled = True
        chkEnvelopesAndLabels.Enabled = True
        chkFax.Enabled = True
        frmPersonalTemplatesPath.Enabled = True
        txtPersonalTemplatesPath.Enabled = True
        frmTemplates.Enabled = True
        txtTemplates.Enabled = True
        chkBlankDocument.Enabled = True
    Else
        chkTemplates.Enabled = False
        chkPleadings.Enabled = False
        chkAppeals.Enabled = False
        chkMemos.Enabled = False
        chkNewsRelease.Enabled = False
        chkLetters.Enabled = False
        chkPersonalTemplates.Enabled = False
        chkEnvelopesAndLabels.Enabled = False
        chkFax.Enabled = False
        frmPersonalTemplatesPath.Enabled = False
        txtPersonalTemplatesPath.Enabled = False
        chkBlankDocument.Enabled = False
        frmTemplates.Enabled = False
        txtTemplates.Enabled = False
    End If
    
    If chkTab.value Then
        chkShowGroupDistrictTemplates.Enabled = True
    Else
        chkShowGroupDistrictTemplates.Enabled = False
    End If
End Sub

Sub greyGroupDrives(bool As Boolean)
    If bool Then
        chkDrivesN.Enabled = True
        chkDrivesL.Enabled = True
        chkDrivesM.Enabled = True
        chkDrivesS.Enabled = True
        frmCustomDrive1.Enabled = True
        chkShowCustomDrive1.Enabled = True
        txtCustomDrive1ButtonName.Enabled = True
        lblCustomDrive1ButtonName.Enabled = True
        txtCustomDrive1Path.Enabled = True
        lblCustomDrive1Path.Enabled = True
        frmCustomDrive2.Enabled = True
        chkShowCustomDrive2.Enabled = True
        txtCustomDrive2ButtonName.Enabled = True
        lblCustomDrive2ButtonName.Enabled = True
        txtCustomDrive2Path.Enabled = True
        lblCustomDrive2Path.Enabled = True
    Else
        chkDrivesN.Enabled = False
        chkDrivesL.Enabled = False
        chkDrivesM.Enabled = False
        chkDrivesS.Enabled = False
        frmCustomDrive1.Enabled = False
        chkShowCustomDrive1.Enabled = False
        txtCustomDrive1ButtonName.Enabled = False
        lblCustomDrive1ButtonName.Enabled = False
        txtCustomDrive1Path.Enabled = False
        lblCustomDrive1Path.Enabled = False
        frmCustomDrive2.Enabled = False
        chkShowCustomDrive2.Enabled = False
        txtCustomDrive2ButtonName.Enabled = False
        lblCustomDrive2ButtonName.Enabled = False
        txtCustomDrive2Path.Enabled = False
        lblCustomDrive2Path.Enabled = False
    End If
    
    If chkTab.value Then
        chkShowGroupDrives.Enabled = True
    Else
        chkShowGroupDrives.Enabled = False
    End If
End Sub
Sub greyGroupTools(bool As Boolean)
    If bool Then
        chkOpenWordPerfectFile.Enabled = True
        chkSearchInternet.Enabled = True
        chkPrintFileList.Enabled = True
        chkEmailDocLink.Enabled = True
        chkCalculator.Enabled = True
    Else
        chkOpenWordPerfectFile.Enabled = False
        chkSearchInternet.Enabled = False
        chkPrintFileList.Enabled = False
        chkEmailDocLink.Enabled = False
        chkCalculator.Enabled = False
    End If
    
    If chkTab.value Then
        chkShowGroupTools.Enabled = True
        lblShowGroupTools.Enabled = True
    Else
        chkShowGroupTools.Enabled = False
        lblShowGroupTools.Enabled = False
    End If
End Sub

Sub greyGroupLinks(bool As Boolean)
    If bool Then
        chkDistrictIntranet.Enabled = True
        chkTrainingVideos.Enabled = True
        txtDistIntranetPath.Enabled = True
        lblDistIntranetPath.Enabled = True
        frmLocalITHelp.Enabled = True
        chkITHelp.Enabled = True
        optEmail.Enabled = True
        optForm.Enabled = True
        txtITHelpButtonAddress.Enabled = True
        lblITHelpButtonAddress.Enabled = True
        chkDistrictLinks.Enabled = True
        txtDistrictLinksPath.Enabled = True
        lblDistrictLinksPath.Enabled = True
    Else
        chkDistrictIntranet.Enabled = False
        chkTrainingVideos.Enabled = False
        txtDistIntranetPath.Enabled = False
        lblDistIntranetPath.Enabled = False
        frmLocalITHelp.Enabled = False
        chkITHelp.Enabled = False
        optEmail.Enabled = False
        optForm.Enabled = False
        txtITHelpButtonAddress.Enabled = False
        lblITHelpButtonAddress.Enabled = False
        chkDistrictLinks.Enabled = False
        txtDistrictLinksPath.Enabled = False
        lblDistrictLinksPath.Enabled = False
    End If
    
    If chkTab.value Then
        chkShowGroupLinks.Enabled = True
        lblShowGroupLinks.Enabled = True
    Else
        chkShowGroupLinks.Enabled = False
        lblShowGroupLinks.Enabled = False
    End If
End Sub
'End Grey Out Stuff-----------------------
Private Sub cmdDiscardChanges_Click()
    fcnSetForm p_colUSAOWordSettings
End Sub

Private Sub cmdClose_Click()
  Me.Hide
  Unload Me
End Sub

Private Sub cmdLoadDefaults_Click()
    fcnSetForm fcnGetDefaultINIValues
    UserFormReset
End Sub

Private Sub cmdReplaceNormal_Click()
    
    m_bReplaceNormalButton = Not m_bReplaceNormalButton
    cmdReplaceNormalSet
    
End Sub

Private Sub cmdReplaceNormalSet()
    If m_bReplaceNormalButton Then
        cmdReplaceNormal.Caption = "Cancel Replace Normal.dotm"
        cmdReplaceNormal.BackColor = "&H00C0E0FF"
    Else
        cmdReplaceNormal.Caption = "Replace Normal.dotm"
        cmdReplaceNormal.BackColor = "&H8000000F"
    End If
End Sub



Private Sub cmdReplaceQAT_Click()
    'Insert code to increment variable in ini
    m_bReplaceQATButton = Not m_bReplaceQATButton
    cmdReplaceQATSet
End Sub

Private Sub cmdReplaceQATSet()
    If m_bReplaceQATButton Then
        cmdReplaceQAT.Caption = "Cancel Replace of Quick Access Toolbar"
        cmdReplaceQAT.BackColor = "&H00C0E0FF"
    Else
        cmdReplaceQAT.Caption = "Replace Quick Access Toolbar"
        cmdReplaceQAT.BackColor = "&H8000000F"
    End If
End Sub

Private Sub cmdSave_Click()
Dim oCtr As Control
Dim oFSO As FileSystemObject: Set oFSO = CreateObject("Scripting.FileSystemObject")
Dim oFSOWrite As Object 'FileSystemObject
Dim strAttemptMSG As String: strAttempmsg = vbNullString
Dim strMultiLineTXTBox() As String
Dim strLine As Variant
Dim lngCount As Long
Dim strRemoteINIPath As String
Dim bWriteSuccess As Boolean
  
  For Each oCtr In Controls
    On Error Resume Next
    Select Case TypeName(oCtr)
      Case "CheckBox"
        'Debug.Print oCtr.Tag & " " & CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", oCtr.Tag & "_Visible"))
        p_colUSAOWordSettings.updateKeyValue "word ribbon settings", oCtr.Tag & "_Visible", oCtr.value
      Case "TextBox"
        'Debug.Print oCtr.Tag & " " & wordSettings.getKeyValue("word ribbon settings", oCtr.Tag & "_Label")
        If LCase(oCtr.Name) = LCase("txtTrustedLocations") Then
          Set p_colUSAOWordSettings = p_colUSAOWordSettings.removeSection("word trusted locations")
          strMultiLineTXTBox = Split(oCtr.Text, vbCrLf)
          lngCount = 0
          For Each strLine In strMultiLineTXTBox
            lngCount = lngCount + 1
            strLine = Trim(strLine)
            If strLine <> vbNullString Then
              p_colUSAOWordSettings.addKey "word trusted locations", "trustedLocation" & CStr(lngCount), CStr(strLine)
            End If
          Next
        Else
          p_colUSAOWordSettings.updateKeyValue "word ribbon settings", oCtr.Tag & "_Label", oCtr.Text
        End If
    End Select
    On Error GoTo 0
  Next oCtr
  If optEmail Then
    p_colUSAOWordSettings.updateKeyValue "word ribbon settings", "usao_btnITHelpMailOrWeb", "Email"
  Else
    p_colUSAOWordSettings.updateKeyValue "word ribbon settings", "usao_btnITHelpMailOrWeb", "Web"
  End If
  If m_bReplaceNormalButton Then
     If modNotifyError.Notify_ShowError(2, 10, True) Then
       p_colUSAOWordSettings.updateKeyValue "word file copy triggers", "replace Normal trigger", (CInt(p_colUSAOWordSettings.getKeyValue("word file copy triggers", "replace Normal trigger")) + 1) & vbNullStrin
     Else
       m_bReplaceNormalButton = False
       cmdReplaceNormalSet
    End If
  End If
  If m_bReplaceQATButton Then
    If modNotifyError.Notify_ShowError(2, 11, True) Then
      p_colUSAOWordSettings.updateKeyValue "word file copy triggers", "replace QAT trigger", (CInt(p_colUSAOWordSettings.getKeyValue("word file copy triggers", "replace QAT trigger")) + 1) & vbNullStrin
    Else
      m_bReplaceQATButton = False
      cmdReplaceQATSet
    End If
  End If
  strRemoteINIPath = modINISettings.fcnGetServerINIPath
  If strRemoteINIPath = vbNullString Then
    strAttemptMSG = "Unable to determine the path of the remote INI file.  There is no P Drive mapped and the HOMESERVER varaiable is undefined." & vbCrLf & vbCrLf
  Else
    Err.Clear
    On Error Resume Next
    modMain.fcnCreateFolder oFSO.GetParentFolderName(strRemoteINIPath)
    Set oFSOWrite = oFSO.OpenTextFile(strRemoteINIPath, 2, True)
    oFSOWrite.Close
    If Err.Number = 0 Then
      bWriteSuccess = fcnEraseSectionFromINI(strRemoteINIPath, "word trusted locations")
      bWriteSuccess = bWriteSuccess And p_colUSAOWordSettings.writeToINI(strRemoteINIPath)
      If bWriteSuccess Then
        strAttemptMSG = strAttemptMSG & "The remote INI file at """ & strRemoteINIPath & """ was successfully updated." & _
          vbCrLf & vbCrLf
      Else
       strAttemptMSG = strAttempmsg & "There was an error writing to the remote INI file at """ & strRemoteINIPath & """.  Please verify all settings." & _
          vbCr & vbCr
      End If
      'Add language to write to additional UTIL Servers
    Else
      strAttemptMSG = strAttemptMSG & "An error occured while attempting to write the remote INI File at """ & strRemoteINIPath & """:" & vbCrLf & _
      "Error Number: " & Err.Number & " | " & "Error Desccription: " & Err.Description & vbCr & vbCr
    End If
    On Error GoTo 0
  End If
  Err.Clear
  On Error Resume Next
  modMain.fcnCreateFolder oFSO.GetParentFolderName(p_strUSAOLocalWordINI)
  Set oFSOWrite = oFSO.OpenTextFile(p_strUSAOLocalWordINI, 2, True)
  oFSOWrite.Close
  If Err.Number = 0 Then
    If LCase(Environ("district")) <> "hub" Then
      bWriteSuccess = fcnEraseSectionFromINI(p_strUSAOLocalWordINI, "word trusted locations")
      bWriteSuccess = bWriteSuccess And p_colUSAOWordSettings.writeToINI(p_strUSAOLocalWordINI)
      If bWriteSuccess Then
        strAttemptMSG = strAttemptMSG & "The local INI file at """ & p_strUSAOLocalWordINI & """ was successfully updated." & _
          vbCrLf & vbCrLf
      Else
        strAttemptMSG = strAttempmsg & "There was an error writing to the local INI file at """ & p_strUSAOLocalWordINI & """.  Please verify all settings." & _
           vbCrLf & vbCrLf
      End If
    Else
      strAttemptMSG = strAttemptMSG & "The local INI was not written since you are connected to USACONNECT." & vbCrLf & vbCrLf
    End If
  Else
    strAttemptMSG = strAttemptMSG & "An error occured while attempting to write the local INI File at """ & p_strUSAOLocalWordINI & """:" & vbCrLf & _
    "Error Number: " & Err.Number & " | " & "Error Desccription: " & Err.Description & vbCrLf & vbCrLf
  End If
  Err.Clear
  On Error GoTo 0
  Set oFSOWrite = Nothing
  strAttemptMSG = strAttemptMSG & vbNullString & vbNullString & "You will need to copy the INI file to the corresponding " & _
    "path on any branch office utility servers in order for the users based in that office to see the USATab using the saved settings. "
  modNotifyError.Notify_ShowError 2, 12, False, strAttemptMSG
  Hide
  Unload Me
End Sub

Private Sub UserForm_Initialize()
  MultiPage1.value = 0
  modGlobals_Initialize.fcnInitSequence
  fcnSetForm p_colUSAOWordSettings
  UserFormReset
End Sub

Private Sub UserFormReset()
  greyAll (chkTab.value)
  greyGroupContent (chkShowGroupContent.value)
  greyGroupDistrictTemplates (chkShowGroupDistrictTemplates.value)
  greyGroupDrives (chkShowGroupDrives.value)
  greyGroupLinks (chkShowGroupLinks.value)
  greyGroupTools (chkShowGroupTools.value)
  m_bReplaceNormalButton = False
  cmdReplaceNormalSet
  m_bReplaceQATButton = False
  cmdReplaceQATSet
End Sub

Private Function fcnSetForm(ByRef wordSettings As clsINI_LineItems)
Dim oCtr As Control
  
  For Each oCtr In Me.Controls
    On Error Resume Next
    'Debug.Print TypeName(oCtr)
    Select Case TypeName(oCtr)
      Case "CheckBox"
        'Debug.Print "Checkbox: " & oCtr.Tag & " " & CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", oCtr.Tag & "_Visible"))
        oCtr.value = CBool(wordSettings.getKeyValue("word ribbon settings", oCtr.Tag & "_Visible"))
      Case "TextBox"
        'Debug.Print "TextBox: " & oCtr.Tag & " " & wordSettings.getKeyValue("word ribbon settings", oCtr.Tag & "_Label")
        oCtr.Text = wordSettings.getKeyValue("word ribbon settings", oCtr.Tag & "_Label")
      Case "OptionButton"
        Select Case wordSettings.getKeyValue("word ribbon settings", "usao_btnITHelpMailOrWeb")
          Case "Email"
            optEmail.value = True
            optForm.value = False
          Case Else
            optEmail.value = False
            optForm.value = True
        End Select
    End Select
    On Error GoTo 0
  Next oCtr
  txtTrustedLocations.Text = fcnListTrustedLocations(p_colUSAOWordSettings.getSection("word trusted locations"))
lbl_Exit:
  Exit Function
End Function
Attribute VB_Name = "modBuildDocs"
Option Explicit
'This is an auxiliary moduled containing functions used to create new documents or open files.
Private Declare Function ShellExecute Lib "shell32.dll" _
       Alias "ShellExecuteA" (ByVal hwnd As Long, _
                              ByVal lpOperation As String, _
                              ByVal lpFile As String, _
                              ByVal lpParameters As String, _
                              ByVal lpDirectory As String, _
                              ByVal nShowCmd As Long) As Long

Sub BuildDocFromControlTab(strName As String, ByRef bShowGL)
'* Description:  Evaluates a text string and creates a new Word document or opens the specified file.
'*
'* INPUT: The file name associated with button control on a custom ribbon dynamic menu.
'*
'* RETURNS: N/A
'***********************************************************************
  Select Case LCase(Right(strName, 4))
    'What is the file type?
    Case ".dot", "dotx", "dotm", ".doc", "docx", "docm"
      'Word template or document. 'Creates a new document from the document if not a template.
      Documents.Add Template:=strName, NewTemplate:=False, DocumentType:=0
    Case Else
      'Open using windows default program.
      If OpenWithDefaultProgram(strName) < 32 Then
        'File did not open.
        modNotifyError.Notify_ShowError 1, 13
      End If
  End Select
  If bShowGL Then
    ActiveWindow.View.TableGridlines = True
  End If
lbl_Exit:
  Exit Sub
End Sub

Public Function OpenWithDefaultProgram(ByVal WhichFilePath As String, _
                               Optional sParams As String = "", _
                               Optional sStartIn As String = vbNullString, _
                               Optional lngOpenMode As Long = 1) As Long
'* Description:  Uses the Windows API ShellExecute to open files.
'*
'* INPUT: Required API parameters.
'*
'* RETURNS: A long value.  Values less than 32 indicate success.
'***********************************************************************
  OpenWithDefaultProgram = ShellExecute(0, vbNullString, WhichFilePath, sParams, sStartIn, lngOpenMode)
  
lbl_Exit:
  Exit Function
End Function

Sub BuildDoc(ByRef strSubFolder As String, strName As String, ByRef bShowGL)
  Documents.Add Template:=p_TemplatesPath & strSubFolder & strName, _
            NewTemplate:=False, DocumentType:=0
  If bShowGL Then
     ActiveWindow.View.TableGridlines = True
  End If
lbl_Exit:
  Exit Sub
End Sub

Function BuildAndGetDoc(ByRef strName As String) As Word.Document
'* Description:  Part of the Envelopes and Labels feature. Creates the envelope or label _
   document from a pre-defined template.
'*
'* INPUT: Template name.
'*
'* RETURNS: New Word document.
'***********************************************************************
Dim oFSO As FileSystemObject: Set oFSO = CreateObject("Scripting.FileSystemObject")
 'Create instance of FileSystemObject.
 If oFSO.FileExists(strName) Then
  'Yes, then create document.
  Set BuildAndGetDoc = Documents.Add(Template:=strName, NewTemplate:=False, DocumentType:=0)
 Else
   'No, then notify.
   modNotifyError.Notify_ShowError 1, 14, False, " Supporting file:" & vbCrLf & strName & vbCr & vbCr & "was not found."
 End If
lbl_Exit:
  Exit Function
  Set oFSO = Nothing
End Function

Attribute VB_Name = "modCleanup"
Option Explicit
Private m_bFound As Boolean
Private m_m_lngIndex As Long
Private m_oDoc As Word.Document
Private m_oPara As Word.Paragraph
Public ls As String

Sub CleanUpText()
Dim oFrm As frmCleanUpText
  ls = Application.International(wdListSeparator)
  Set oFrm = New frmCleanUpText
  oFrm.Show
  Unload oFrm
  Set oFrm = Nothing
lbl_Exit:
  Exit Sub
End Sub

Sub DeleteSectionBreaks()
Dim oRng As Range
  Set oRng = ActiveDocument.Range
  With oRng.Find
    Do While .Execute(FindText:="^b")
     oRng.Delete
    Loop
  End With
lbl_Exit:
  Exit Sub
End Sub

Sub PasteUnformatted()
  On Error GoTo ErrHandler
  Selection.PasteSpecial link:=False, DataType:=wdPasteText, Placement:=wdInLine, DisplayAsIcon:=False
  Exit Sub
ErrHandler:
  If Err.Number = 4605 Then
    Notify_ShowError 5, 16
  Else
    Notify_ShowError 11, 15, False, Err.Number
  End If
lbl_Exit:
  Exit Sub
End Sub

Sub ClrTabsAll()
 ActiveDocument.Range.ParagraphFormat.TabStops.ClearAll
  ActiveDocument.DefaultTabStop = InchesToPoints(0.5)
lbl_Exit:
  Exit Sub
End Sub

Sub ClrTabs()
  Selection.ParagraphFormat.TabStops.ClearAll
  ActiveDocument.DefaultTabStop = InchesToPoints(0.5)
lbl_Exit:
  Exit Sub
End Sub

Sub ConvertQuoteFormat(ByRef lngRouter As Long)
Dim oRngStory As Word.Range
Dim bSmartQuoteSetting As Boolean
  'Stores users AutoCorrect "smart quote" options.  True if enabled
  bSmartQuoteSetting = Options.AutoFormatAsYouTypeReplaceQuotes
  If lngRouter = "1" Then
    'Convert to curly
    Options.AutoFormatAsYouTypeReplaceQuotes = True
    For Each oRngStory In ActiveDocument.StoryRanges
      Do
        If oRngStory.StoryLength >= 2 Then
          CurlyQuoteToggle oRngStory
        End If
        Set oRngStory = oRngStory.NextStoryRange
      Loop Until oRngStory Is Nothing
    Next
    If bSmartQuoteSetting = False Then
      If MsgBox("Do you want format new text entered in this document using ""straight qoutes?""", vbQuestion + vbYesNo, "AutoFormat") = vbYes Then
        Options.AutoFormatAsYouTypeReplaceQuotes = True
        bSmartQuoteSetting = Options.AutoFormatAsYouTypeReplaceQuotes
      End If
    End If
  Else
    'Convert to straight
    Options.AutoFormatAsYouTypeReplaceQuotes = False
    For Each oRngStory In ActiveDocument.StoryRanges
      Do
        If oRngStory.StoryLength >= 2 Then
          CurlyQuoteToggle oRngStory
        End If
        Set oRngStory = oRngStory.NextStoryRange
      Loop Until oRngStory Is Nothing
    Next
    If bSmartQuoteSetting = True Then
      If MsgBox("Do you want format new text entered in this document using ""straight qoutes?""", vbQuestion + vbYesNo, "AutoFormat") = vbYes Then
        Options.AutoFormatAsYouTypeReplaceQuotes = False
        bSmartQuoteSetting = Options.AutoFormatAsYouTypeReplaceQuotes
      End If
    End If
  End If
  Options.AutoFormatAsYouTypeReplaceQuotes = bSmartQuoteSetting
lbl_Exit:
  Exit Sub
End Sub

Sub CurlyQuoteToggle(ByVal oRngStory As Word.Range)
  With oRngStory.Find
    'quote marks
    .Text = Chr$(34)
    .Replacement.Text = Chr$(34)
    .Execute Replace:=wdReplaceAll
    'apostrophe
    .Text = Chr$(39)
    .Replacement.Text = Chr$(39)
    .Execute Replace:=wdReplaceAll
  End With
lbl_Exit:
  Exit Sub
End Sub









Attribute VB_Name = "modDocStamps"
Option Explicit
Private m_lngIndex As Long
Public p_lngUndo As Long
Private m_oShpCanvass As Shape

Sub CallStampStamp()
Dim oFrm As frmStamp
  If Documents.count = 0 Then Documents.Add
  Set oFrm = New frmStamp
  oFrm.Show
  Unload oFrm
  Set oFrm = Nothing
lbl_Exit:
  Exit Sub
End Sub

Sub InsertWaterMark(ByRef oForm As frmStamp, Optional lngColorNum As Long)
Dim oHdr As HeaderFooter
Dim strStampText As String, strStampFont As String
Dim bBold As MsoTriState, bITalic As MsoTriState
Dim oRng As Word.Range
Dim bLine As Boolean
Dim sngTrans As Single, sngRot As Single
Dim strTemp As String
Dim lngSize As Long, lngIndex As Long

  Select Case oForm.cbStampText.value
    Case "Attorney-Client Communication"
      strStampText = "Priviliged and Confidential" & vbCr & oForm.cbStampText.value
    Case Else
      strStampText = oForm.cbStampText.value
  End Select
  strStampFont = oForm.cbFontName.value
  bBold = oForm.CheckBox1
  bITalic = oForm.CheckBox2
  bLine = oForm.chkLine
  strTemp = Left(oForm.txtTransparency, Len(oForm.txtTransparency) - 1)
  sngTrans = CSng(strTemp)
  If sngTrans <> 0 Then sngTrans = sngTrans / 100
  lngSize = CLng(oForm.txtFontSize)
  sngRot = CSng(oForm.txtRot)
  If sngRot < 0 Then sngRot = 360 + sngRot
  Application.ScreenUpdating = False
  System.Cursor = wdCursorWait
  For lngIndex = 1 To ActiveDocument.Sections.count
    For m_lngIndex = 1 To 3
      Set oHdr = Nothing
      Set oHdr = ActiveDocument.Sections(lngIndex).Headers(m_lngIndex)
      If oHdr.LinkToPrevious = False Then
        Set oRng = oHdr.Range
        oRng.Collapse wdCollapseEnd
        On Error GoTo lbl_Exit
        Set m_oShpCanvass = oHdr.Shapes.AddTextEffect(msoTextEffect1, strStampText, strStampFont, 1, bBold, bITalic, 0, 0)
        With m_oShpCanvass
          .Name = "Section " & lngIndex & " Header Watermark " & m_lngIndex
          .TextEffect.NormalizedHeight = False
          With .line
            Select Case True
              Case oForm.optPoints1
                .Weight = 1
              Case oForm.optPoints2
                .Weight = 2
              Case oForm.optPoints3
                .Weight = 3
            End Select
            Select Case True
              Case oForm.optBlack
                .ForeColor.RGB = RGB(0, 0, 0)
              Case oForm.optRed
                .ForeColor.RGB = RGB(255, 0, 0)
              Case oForm.optBlue
                .ForeColor.RGB = RGB(0, 0, 255)
              Case oForm.optGreen
                .ForeColor.RGB = RGB(0, 255, 0)
              Case oForm.optCustom
                .ForeColor = lngColorNum
             End Select
            .Visible = bLine
          End With
          With .Fill
            .Visible = True
            .Solid
            Select Case True
              Case oForm.optBlack
                .ForeColor = RGB(0, 0, 0)
              Case oForm.optRed
                .ForeColor.RGB = RGB(255, 0, 0)
              Case oForm.optBlue
                .ForeColor.RGB = RGB(0, 0, 255)
              Case oForm.optGreen
                .ForeColor.RGB = RGB(0, 255, 0)
              Case oForm.optCustom
                .ForeColor = lngColorNum
             End Select
            .Transparency = sngTrans
          End With
          .Rotation = sngRot
          .LockAspectRatio = True
          .Height = lngSize
          With .WrapFormat
            .AllowOverlap = True
            .Side = wdWrapNone
            .Type = 3
          End With
          .RelativeHorizontalPosition = wdRelativeVerticalPositionPage
          .RelativeVerticalPosition = wdRelativeVerticalPositionPage
          .Left = wdShapeCenter
          If m_lngIndex = 2 Then
            .Top = wdShapeCenter '400
          Else
            .Top = wdShapeCenter '250
          End If
        End With
      End If
    Next m_lngIndex
  Next lngIndex
  System.Cursor = wdCursorNormal
  Application.ScreenUpdating = True
lbl_Exit:
  Exit Sub
End Sub
Sub fcnRemoveWaterMark()
Dim oSec As section

  On Error Resume Next
  p_lngUndo = 0
  For Each oSec In ActiveDocument.Sections
  For m_lngIndex = 1 To 3
    For Each m_oShpCanvass In oSec.Headers(m_lngIndex).Shapes
    If InStr(m_oShpCanvass.Name, "Header Watermark") > 1 Then
      m_oShpCanvass.Delete
      p_lngUndo = p_lngUndo + 1
    End If
    Next m_oShpCanvass
  Next m_lngIndex
  Next oSec
  On Error GoTo 0
  Application.ScreenRefresh
lbl_Exit:
  Exit Sub
End Sub


Attribute VB_Name = "modEnvsAndLbls"
Option Explicit
Public p_arrEnvLabAddressees() As String
Public m_oDoc As Word.Document
Private m_lngStartToCount As Long, m_lngLabelsToFill As Long
Private m_lngOverflow As Long
Private m_strPosit As String
Dim m_lngLabelTarget As Long
Dim m_lngAdditionalSheets As Long
Dim m_lngCurrentLabel As Long
Dim m_lngEntries As Long
Dim m_lngIndex As Long, m_lngSheetPosit As Long
Dim m_lngDuplicates As Long

Sub CreateEnvelops_Labels()
Dim oRng As Word.Range
 frmEnvelopesAndLabels.Show
 If Not m_oDoc Is Nothing Then
   m_oDoc.Activate
   Set oRng = m_oDoc.Range
   oRng.Collapse wdCollapseStart
   DoEvents
   oRng.Select
 End If
 Set m_oDoc = Nothing
lbl_Exit:
  Exit Sub
End Sub

Function lngAddresseesIntoArray(ByRef p_arrEnvLabAddressees() As String) As Long
Dim bSelection As Boolean, bWithinTable As Boolean, bAddressesIntoArray As Boolean
Dim oTbl As Word.Table
Dim strTemp As String, strAddress As String
Dim lngAddresseeCount As Long, lngRows As Long, lngColumns As Long
Dim lngRowIndex As Long, lngColumnIndex As Long, lngCurrentColumn As Long

  'This function evaluates the selection, breaks it down into addresses and adds them to an array.
  'Is text selected?
  If Selection.Type <> wdSelectionIP Then bSelection = True
  'Is the IP or Selection in a table range?
  If Selection.Information(wdWithInTable) = True Then bWithinTable = True
  'Nothing to do so get out.
  If bSelection = False And bWithinTable = False Then
    bAddressesIntoArray = False
    GoTo lbl_Exit
  End If
  'If selection, but no table, parse the selection into addresses.
  strTemp = Selection.Text
  If bSelection = True And bWithinTable = False Then
    If InStr(strTemp, Chr(13) & Chr(13) & Chr(13)) > 0 Then
      modNotifyError.Notify_ShowError 1, 18
      GoTo lbl_Exit
    End If
    strTemp = Replace(strTemp, Chr(13) & Chr(13), Chr(13))
    While InStr(strTemp, Chr(13)) > 0
      strAddress = Left(strTemp, InStr(strTemp, Chr(13)) - 1)
      strTemp = Right(strTemp, Len(strTemp) - InStr(strTemp, Chr(13))) ' - 1)
      ReDim Preserve p_arrEnvLabAddressees(lngAddresseeCount)
      p_arrEnvLabAddressees(lngAddresseeCount) = strAddress
      lngAddresseeCount = lngAddresseeCount + 1
    Wend
    If Len(strTemp) > 2 Then
      ReDim Preserve p_arrEnvLabAddressees(lngAddresseeCount)
      p_arrEnvLabAddressees(lngAddresseeCount) = strTemp
      lngAddresseeCount = lngAddresseeCount + 1
    End If
    GoTo lbl_Exit
  End If
  'If no selection, but table, then move through the table and add each address from each cell.
  If bSelection = False And bWithinTable = True Then
    'Build address from all cells in table.
    Set oTbl = Selection.Tables(1)
    lngRows = oTbl.Rows.count
    lngColumns = oTbl.Columns.count
    For lngRowIndex = 1 To lngRows
      For lngColumnIndex = 1 To lngColumns
        strTemp = oTbl.Cell(lngRowIndex, lngColumnIndex).Range.Text
        strTemp = Left(strTemp, Len(strTemp) - 1)
        While Right(strTemp, 1) = Chr(13)
          strTemp = Left(strTemp, Len(strTemp) - 1)
        Wend
        If strTemp <> "" Then
          ReDim Preserve p_arrEnvLabAddressees(lngAddresseeCount)
          p_arrEnvLabAddressees(lngAddresseeCount) = strTemp
          lngAddresseeCount = lngAddresseeCount + 1
        End If
      Next lngColumnIndex
    Next lngRowIndex
  ElseIf bSelection = True And bWithinTable = True Then
    Set oTbl = Selection.Tables(1)
    lngRows = Selection.Information(wdEndOfRangeRowNumber)
    lngColumns = Selection.Information(wdEndOfRangeColumnNumber)
    lngCurrentColumn = Selection.Information(wdStartOfRangeColumnNumber)
    For lngRowIndex = Selection.Information(wdStartOfRangeRowNumber) To lngRows
      If Selection.Type <> wdSelectionIP Then Selection.Collapse
      For lngColumnIndex = lngCurrentColumn To lngColumns
        strTemp = oTbl.Cell(lngRowIndex, lngColumnIndex).Range.Text
        strTemp = Left(strTemp, Len(strTemp) - 1)
        While Right(strTemp, 1) = Chr(13)
          strTemp = Left(strTemp, Len(strTemp) - 1)
        Wend
        If strTemp <> "" Then
          ReDim Preserve p_arrEnvLabAddressees(lngAddresseeCount)
          p_arrEnvLabAddressees(lngAddresseeCount) = strTemp
          lngAddresseeCount = lngAddresseeCount + 1
        End If
      Next lngColumnIndex
    Next lngRowIndex
  End If
lbl_Exit:
  lngAddresseesIntoArray = lngAddresseeCount
  Exit Function
End Function
Sub EnvAddToDoc(bPermanentDoc As Boolean)
Dim m_lngIndex As Long
Dim oRng As Range
Dim oFld As Word.Field
Dim strRA() As String, strRA_PartB As String

  Application.ScreenUpdating = False
  'Start a new document
  If modMain.fcnFileOrDirExists(p_EnvsAndLblsPath & Application.PathSeparator & "Envelope.dotx") Then
    Set m_oDoc = modBuildDocs.BuildAndGetDoc(p_EnvsAndLblsPath & Application.PathSeparator & "Envelope.dotx")
  Else
    GoTo lbl_MissingSupportingFiles
  End If
  'Set header data of first envelope created.
  If frmEnvelopesAndLabels.chkReturnAddress And Not frmEnvelopesAndLabels.txtReturnAddress = vbNullString Then
    'Deduce the return address from text entered.
    strRA = Split(frmEnvelopesAndLabels.txtReturnAddress, Chr(13) & Chr(10))
    Set oRng = m_oDoc.Bookmarks("bmReturnLine1").Range
    oRng.Text = strRA(0)
    m_oDoc.Bookmarks.Add "bmReturnLine1", oRng
    oRng.Style = "RAFirstLine"
    For m_lngIndex = 1 To UBound(strRA)
      strRA_PartB = strRA_PartB & strRA(m_lngIndex) & Chr(11)
    Next m_lngIndex
    If Not strRA_PartB = vbNullString Then
      strRA_PartB = Left(strRA_PartB, Len(strRA_PartB) - 1)
      Set oRng = m_oDoc.Bookmarks("bmReturnLines").Range
      oRng.Text = strRA_PartB
      m_oDoc.Bookmarks.Add "bmReturnLines", oRng
      oRng.Style = "RALines"
    End If
'  ElseIf frmEnvelopesAndLabels.optRtrnAddrBB Then
'    m_oDoc.AttachedTemplate.AutoTextEntries("frmLogo").Insert Where:=m_oDoc.Bookmarks("bmReturnLine1").Range, RichText:=True
'    m_oDoc.AttachedTemplate.AutoTextEntries("frmReturnAddress").Insert Where:=m_oDoc.Bookmarks("bmReturnLines").Range, RichText:=True
  End If
  For m_lngIndex = 0 To UBound(p_arrEnvLabAddressees)
    If m_lngIndex = 0 Then
      m_oDoc.Sections.Last.Range.Frames(1).Range.Text = p_arrEnvLabAddressees(m_lngIndex)
      
      If frmEnvelopesAndLabels.cboDelivery <> "None" And frmEnvelopesAndLabels.cboDelivery <> "" Then
        Set oRng = m_oDoc.Sections.Last.Range.Frames(1).Range
        oRng.Collapse wdCollapseStart
        oRng.InsertBefore frmEnvelopesAndLabels.cboDelivery & vbCr + vbCr
      End If
    Else
      With m_oDoc
        .Sections.Add
        Set oRng = .Sections(m_oDoc.Sections.count - 1).Range
        oRng.MoveEnd wdCharacter, -1
        oRng.Copy
        .Sections.Last.Range.Paste
        .Sections.Last.Range.Frames(1).Range.Text = p_arrEnvLabAddressees(m_lngIndex)
        If frmEnvelopesAndLabels.cboDelivery <> "None" And frmEnvelopesAndLabels.cboDelivery <> "" Then
          Set oRng = m_oDoc.Sections.Last.Range.Frames(1).Range
          oRng.Collapse wdCollapseStart
          oRng.InsertBefore frmEnvelopesAndLabels.cboDelivery & vbCr + vbCr
        End If
      End With
    End If
    DoEvents
  Next m_lngIndex
  If Not bPermanentDoc Then
    m_oDoc.PrintOut
    m_oDoc.Close (wdDoNotSaveChanges)
  End If
lbl_Exit:
  Application.ScreenUpdating = True
  Exit Sub
lbl_MissingSupportingFiles:
  modNotifyError.Notify_ShowError 1, 7
  GoTo lbl_Exit
End Sub


Sub AverySimpleCommonAddToDoc(strNum As String, lngSheetCount As Long, bPermanentDoc As Boolean)
Dim oRng As Word.Range

  Application.ScreenUpdating = False
  If p_EnvsAndLblsPath = vbNullString Then modGlobals_Initialize.fcnInitSequence
  'Create document.
  If modMain.fcnFileOrDirExists(p_EnvsAndLblsPath & Application.PathSeparator & "Avery" & strNum & ".dotx") Then
    Set m_oDoc = modBuildDocs.BuildAndGetDoc(p_EnvsAndLblsPath & Application.PathSeparator & "Avery" & strNum & ".dotx")
  Else
    GoTo lbl_MissingSupportingFiles
  End If
  'Where to start?
  m_strPosit = frmEnvelopesAndLabels.txtStart.value
  m_lngCurrentLabel = 1
  'How many labels required?
  m_lngLabelsToFill = frmEnvelopesAndLabels.lbAddresseeList.ListCount * frmEnvelopesAndLabels.txtNumLabels
  'How many labels are available from start to end of sheet?
  m_lngStartToCount = (lngSheetCount + 1) - CLng(m_strPosit)
  
  'Are there enough labels available on single sheet?
  m_lngAdditionalSheets = 0
  If m_lngStartToCount < m_lngLabelsToFill Then
    'How many required labels will overflow to additional sheet(s)?
    m_lngOverflow = frmEnvelopesAndLabels.lbAddresseeList.ListCount * frmEnvelopesAndLabels.txtNumLabels - m_lngStartToCount
    m_lngAdditionalSheets = m_lngOverflow \ lngSheetCount
    If m_lngOverflow Mod lngSheetCount > 0 Then m_lngAdditionalSheets = m_lngAdditionalSheets + 1
  End If
  m_oDoc.Activate

  'First do the first sheet
  m_lngDuplicates = 0
  For m_lngIndex = CLng(m_strPosit) To lngSheetCount
    On Error GoTo Cleanup
     InsertSimpleLblContent m_oDoc.Tables(m_oDoc.Tables.count), CStr(m_lngIndex), p_arrEnvLabAddressees(m_lngCurrentLabel - 1)
     m_lngDuplicates = m_lngDuplicates + 1
     If m_lngDuplicates = frmEnvelopesAndLabels.txtNumLabels Then
       m_lngCurrentLabel = m_lngCurrentLabel + 1
       m_lngDuplicates = 0
     End If
  Next m_lngIndex
  On Error GoTo 0
  'Now repeat the process for additional sheets.
  If m_lngAdditionalSheets > 0 Then
    For m_lngIndex = 1 To m_lngAdditionalSheets
      Set oRng = m_oDoc.Range
      oRng.Collapse wdCollapseEnd
      oRng.InsertBefore vbCr
      oRng.Collapse wdCollapseEnd
      m_oDoc.AttachedTemplate.AutoTextEntries("zzAvery" & strNum).Insert Where:=oRng, RichText:=True
      For m_lngSheetPosit = 1 To lngSheetCount
        m_lngLabelTarget = m_lngSheetPosit
        m_strPosit = CStr(m_lngLabelTarget)
        On Error GoTo Cleanup
        InsertSimpleLblContent m_oDoc.Tables(m_oDoc.Tables.count), CStr(m_lngLabelTarget), p_arrEnvLabAddressees(m_lngCurrentLabel - 1)
        m_lngDuplicates = m_lngDuplicates + 1
        If m_lngDuplicates = frmEnvelopesAndLabels.txtNumLabels Then
           m_lngCurrentLabel = m_lngCurrentLabel + 1
           m_lngDuplicates = 0
        End If
      Next m_lngSheetPosit
    Next m_lngIndex
  End If
Cleanup:
  On Error GoTo 0
  LabelCleanup lngSheetCount
  Selection.HomeKey Unit:=wdStory
  If Not bPermanentDoc Then
    m_oDoc.PrintOut
    m_oDoc.Close (wdDoNotSaveChanges)
  End If
lbl_Exit:
  Application.ScreenUpdating = True
  Exit Sub
lbl_MissingSupportingFiles:
  modNotifyError.Notify_ShowError 1, 7
  GoTo lbl_Exit
End Sub

Function InsertSimpleLblContent(oTbl As Word.Table, m_strPosit As String, strAddresseePassed As String) As Boolean
Dim oRng As Word.Range
  Set oRng = oTbl.Range
  'Finds the appropriate location on the label strip and inserts the passed address
  With oRng.Find
    .ClearFormatting
    .Text = "<" & m_strPosit & ">"
    .Forward = True
    .Wrap = wdFindContinue
    .Format = False
    .MatchCase = False
    .MatchWholeWord = False
    .MatchWildcards = False
    .MatchSoundsLike = False
    .MatchAllWordForms = False
    If .Execute Then
      oRng.Text = strAddresseePassed
    End If
    Set oRng = oRng.Cells(1).Range
    oRng.Collapse wdCollapseEnd
    oRng.Move wdCharacter, -1
  End With
End Function

Sub AveryComplexCommonAddToDoc(strNum As String, lngSheetCount As Long, bPermanentDoc As Boolean)
Dim oRng As Word.Range

  Application.ScreenUpdating = False
  If p_EnvsAndLblsPath = vbNullString Then modGlobals_Initialize.fcnInitSequence

  'Create document.
  If modMain.fcnFileOrDirExists(p_EnvsAndLblsPath & Application.PathSeparator & "Avery" & strNum & ".dotx") Then
    Set m_oDoc = modBuildDocs.BuildAndGetDoc(p_EnvsAndLblsPath & Application.PathSeparator & "Avery" & strNum & ".dotx")
  Else
   GoTo lbl_MissingSupportingFiles
  End If
  'Where to start?
  m_strPosit = frmEnvelopesAndLabels.txtStart.value
  m_lngCurrentLabel = 1
  'How many labels required?
  m_lngLabelsToFill = frmEnvelopesAndLabels.lbAddresseeList.ListCount * frmEnvelopesAndLabels.txtNumLabels
  'How many labels are available from start to end of sheet?
  m_lngStartToCount = (lngSheetCount + 1) - CLng(m_strPosit)
  
  'Are there enough labels available on single sheet?
  m_lngAdditionalSheets = 0
  If m_lngStartToCount < m_lngLabelsToFill Then
    'How many required labels will overflow to additional sheet(s)?
    m_lngOverflow = frmEnvelopesAndLabels.lbAddresseeList.ListCount * frmEnvelopesAndLabels.txtNumLabels - m_lngStartToCount
    m_lngAdditionalSheets = m_lngOverflow \ lngSheetCount
    If m_lngOverflow Mod lngSheetCount > 0 Then m_lngAdditionalSheets = m_lngAdditionalSheets + 1
  End If
  m_oDoc.Activate
  'First do the first sheet
  m_lngDuplicates = 0
  For m_lngIndex = CLng(m_strPosit) To lngSheetCount
    On Error GoTo Cleanup
     InsertComplexLblContent m_oDoc.Tables(m_oDoc.Tables.count), CStr(m_lngIndex), p_arrEnvLabAddressees(m_lngCurrentLabel - 1)
     m_lngDuplicates = m_lngDuplicates + 1
        If m_lngDuplicates = frmEnvelopesAndLabels.txtNumLabels Then
           m_lngCurrentLabel = m_lngCurrentLabel + 1
           m_lngDuplicates = 0
        End If
  Next m_lngIndex
  On Error GoTo 0
  'Now repeat the process for additional sheets.
  If m_lngAdditionalSheets > 0 Then
    For m_lngIndex = 1 To m_lngAdditionalSheets
      Set oRng = m_oDoc.Range
      oRng.Collapse wdCollapseEnd
      oRng.InsertBefore vbCr
      oRng.Collapse wdCollapseEnd
      m_oDoc.AttachedTemplate.AutoTextEntries("zzAvery" & strNum).Insert Where:=oRng, RichText:=True
      For m_lngSheetPosit = 1 To lngSheetCount
        m_lngLabelTarget = m_lngSheetPosit
        m_strPosit = CStr(m_lngLabelTarget)
        On Error GoTo Cleanup
        InsertComplexLblContent m_oDoc.Tables(m_oDoc.Tables.count), CStr(m_lngLabelTarget), p_arrEnvLabAddressees(m_lngCurrentLabel - 1)
        m_lngDuplicates = m_lngDuplicates + 1
        If m_lngDuplicates = frmEnvelopesAndLabels.txtNumLabels Then
           m_lngCurrentLabel = m_lngCurrentLabel + 1
           m_lngDuplicates = 0
        End If
      Next m_lngSheetPosit
    Next m_lngIndex
  End If
Cleanup:
  On Error GoTo 0
  LabelCleanup lngSheetCount
  Selection.HomeKey Unit:=wdStory
  If Not bPermanentDoc Then
    m_oDoc.PrintOut
    m_oDoc.Close (wdDoNotSaveChanges)
  End If
lbl_Exit:
  Application.ScreenUpdating = True
  Exit Sub
lbl_MissingSupportingFiles:
  modNotifyError.Notify_ShowError 1, 7
  GoTo lbl_Exit
End Sub

Function InsertComplexLblContent(oTbl As Word.Table, strPosit As String, strAddresseePassed As String) As Boolean
'Finds the appropriate location on the label strip and inserts the passed address
Dim oRng As Word.Range
Dim oShp As Word.Shape
Dim oRngShp As Word.Range
Dim strRA() As String, strRA_PartB As String
Dim lngIndex As Long
  
  Set oRng = oTbl.Range
  With oRng.Find
    .Text = "<" & strPosit & ">"
    .Forward = True
    .Wrap = wdFindContinue
    .Format = False
    .MatchCase = False
    .MatchWholeWord = False
    .MatchWildcards = False
    .MatchSoundsLike = False
    .MatchAllWordForms = False
    If .Execute Then
      oRng.Delete
    End If
  End With
  Set oRng = oRng.Cells(1).Range '?????????
  Set oShp = oRng.ShapeRange(1)
  oRng.MoveEnd wdCharacter, -1 '??????????
  Application.ScreenRefresh
  'Fill in the label.
  If frmEnvelopesAndLabels.chkReturnAddress = True And Not frmEnvelopesAndLabels.txtReturnAddress = vbNullString Then
    Set oRng = oRng.Cells(1).Range
    oRng.MoveEnd wdCharacter, -1
    'Deduce the return address from text entered.
    strRA = Split(frmEnvelopesAndLabels.txtReturnAddress, Chr(13) & Chr(10))
      oRng.Text = strRA(0)
      oRng.Collapse wdCollapseEnd
      oRng.Paragraphs(1).Style = "RALine1"
      oRng.InsertBefore vbCr
      oRng.Move wdParagraph, 1
    For lngIndex = 1 To UBound(strRA)
      strRA_PartB = strRA_PartB & strRA(lngIndex) & Chr(11)
    Next lngIndex
    If Not strRA_PartB = vbNullString Then
      strRA_PartB = Left(strRA_PartB, Len(strRA_PartB) - 1)
      oRng.Paragraphs(1).Style = "RALines"
      oRng.Text = strRA_PartB
      oRng.Collapse wdCollapseEnd
      oRng.InsertBefore vbCr
    End If

    Set oRngShp = oShp.TextFrame.TextRange
    oRngShp.Collapse wdCollapseStart
    'Put the delivery phrase in if necessary
    If frmEnvelopesAndLabels.cboDelivery <> "None" And frmEnvelopesAndLabels.cboDelivery <> "" Then

      oRngShp.Paragraphs(1).Style = "Delivery Method"
      oRngShp.Text = (UCase(frmEnvelopesAndLabels.cboDelivery))
      oRng.InsertAfter vbCr
      oRngShp.Collapse wdCollapseEnd
      oRngShp.Paragraphs(1).Style = "Addressee"
    Else

      oRngShp.Paragraphs(1).Style = "Addressee"
    End If
  Else
    Set oRngShp = oShp.TextFrame.TextRange
    oRngShp.Collapse wdCollapseStart
    If frmEnvelopesAndLabels.cboDelivery <> "None" And frmEnvelopesAndLabels.cboDelivery <> "" Then
      oRngShp.Paragraphs(1).Style = "Delivery Method"
      oRngShp.Text = (UCase(frmEnvelopesAndLabels.cboDelivery)) & vbCr
      oRngShp.Collapse wdCollapseEnd
      oRng.Paragraphs(1).Style = "Addressee"
    Else
      oRngShp.Paragraphs(1).Style = "Addressee"
    End If
  End If
  oRngShp.Text = Replace(strAddresseePassed, Chr(13) & Chr(10), Chr(11))
  'Put the bar code in the address box if necessary
  oRngShp.Collapse wdCollapseEnd
lbl_Exit:
  Exit Function
End Function

Sub LabelCleanup(ByRef lngCount)
'Get rid of any leftover label numerical placeholders
Dim m_lngIndex As Long
  For m_lngIndex = 1 To lngCount
    modMain.fcnFindReplace "<" & m_lngIndex & ">", ""
  Next m_lngIndex
lbl_Exit:
  Exit Sub
End Sub

Sub AddPositMarkersToCells()
Dim oTbl As Word.Table, oCell As Cell
Dim lngIndex As Long
  Set oTbl = ActiveDocument.Tables(1)
  For Each oCell In oTbl.Range.Cells
    If oCell.Width > 120 Then
      lngIndex = lngIndex + 1
      oCell.Range.Text = "<" & lngIndex & ">"
  End If
  Next oCell
lbl_Exit:
  Exit Sub
End Sub

Attribute VB_Name = "modFileList"

Option Explicit
Private oFrm As frmListFiles
Private m_oFSO As New FileSystemObject
Private m_arrFiles() As String
Private m_lngIndex As Long
Private m_oTarget As Document
Private m_oRng As Word.Range
Private m_colFolders As New Collection
Dim m_oXL As Object
Dim m_oWB As Object
Dim m_oSheet As Object
Dim m_lngLastRow As Long
Const xlUp As Long = -4162
Dim lngProcess As Long
Sub ListFolder()
Dim oFld As Folder
Dim strPath As String
Dim lngIndex As Long
  
  Set oFrm = New frmListFiles
  oFrm.Show
  strPath = oFrm.txtFolder
  Select Case oFrm.Tag
    Case "Process Word"
    'Prepare document to list results
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    Set m_oTarget = Documents.Add(Template:=ThisDocument.AttachedTemplate.FullName)
    With m_oTarget
      On Error Resume Next
      With .Range
        .InsertAfter strPath & vbCr
        Set m_oRng = .Paragraphs.Last.Previous.Range
        m_oRng.Style = "FolderHeading"
        Set m_oRng = .Paragraphs.Last.Range
        m_oRng.Style = "Column Captions"
        Select Case True
          Case oFrm.optNSTDM
            m_oRng.Text = "Name" & vbTab & "Size" & vbTab & "Type" & vbTab & "Date Modified" & vbCr
          Case oFrm.optNameSize
            m_oRng.Text = "Name" & vbTab & vbTab & vbTab & vbTab & "Size" & vbCr
          Case oFrm.optName
            m_oRng.Text = "Name" & vbCr
        End Select
        m_oTarget.Activate
        Application.ScreenUpdating = True
        Application.ScreenRefresh
        Application.ScreenUpdating = False
        Application.DisplayAlerts = wdAlertsNone
        System.Cursor = wdCursorWait
        Set m_oRng = .Paragraphs.Last.Range
        m_oRng.Style = "FileListing"
        Set oFld = m_oFSO.GetFolder(strPath)
        frmProgressBarContinous.Show
        m_arrFiles = GetFileData(oFld)
        'Add data to list document
        BubbleSortColRowArray m_arrFiles, 0
        RecordResults
        'User option to process sub-folders of batch folder
        If oFrm.cbIncludeSubs.value = True Then
          'Get list of folders
           CollectSubFolders oFld
           If m_colFolders.count > 0 Then
             For lngIndex = 1 To m_colFolders.count
               Set oFld = m_oFSO.GetFolder(m_colFolders(lngIndex))
               ListSubFolder oFld
             Next lngIndex
           End If
         End If
        .Characters.Last.Previous.Delete
      End With
     End With
    Case "Process Excel"
      'Check if Excel is installed and already running.  If not then start Excel
      On Error Resume Next
      Set m_oXL = GetObject(, "Excel.Application")
      If m_oXL Is Nothing Then
        Set m_oXL = CreateObject("Excel.Application")
        If m_oXL Is Nothing Then
          MsgBox "Excel not installed. Please contact your local IT staff."
          Exit Sub
        End If
      End If
      On Error GoTo Err_Handler1
      Set m_oWB = m_oXL.Workbooks.Add
      Set m_oSheet = m_oWB.Sheets(1)
      With m_oSheet
        .Cells(1, 1).value = "File Name"
        .Cells(1, 2).value = "Parent Folder\Path"
        .Cells(1, 3).value = "Size"
        .Cells(1, 4).value = "Type"
        .Cells(1, 5).value = "Date\Time Last Modified"
        .Cells(1, 6).value = "Date\Time Created"
        .Cells(1, 7).value = "Date\Time Last Accessed"
        .Cells(1, 8).value = "Comments"
      End With
    Set oFld = m_oFSO.GetFolder(strPath)
    m_arrFiles = GetFileData(oFld)
    'Add data to list worksheet
    BubbleSortColRowArray m_arrFiles, 0
    ExcelRecordResults
    'User option to process sub-folders of batch folder
    If oFrm.cbIncludeSubs.value = True Then
      'Get list of folders
      CollectSubFolders oFld
      If m_colFolders.count > 0 Then
      For lngIndex = 1 To m_colFolders.count
        Set oFld = m_oFSO.GetFolder(m_colFolders(lngIndex))
          ExcelListSubFolder oFld
        Next lngIndex
      End If
    End If
    m_oXL.Visible = True
    m_oXL.Columns("A:H").EntireColumn.AutoFit
    Set m_oXL = Nothing
    Set m_oWB = Nothing
    Set m_oSheet = Nothing
  End Select
lbl_Exit:
  Unload frmProgressBarContinous
  Unload oFrm
  Application.ScreenUpdating = True
  Application.DisplayAlerts = wdAlertsAll
  Application.ScreenRefresh
  System.Cursor = wdCursorNormal
  Set oFrm = Nothing
  Set m_oTarget = Nothing
  Set m_colFolders = Nothing
  Set m_oXL = Nothing
  Set m_oWB = Nothing
  Set m_oSheet = Nothing
  Exit Sub
Err_Handler1:
  MsgBox Err.Description, vbCritical, "Error: " & Err.Number
  If Not m_oXL Is Nothing Then
    m_oXL.Quit
  End If
  Resume lbl_Exit
End Sub

Sub RecordResults()
Dim bPaginate As Boolean
  bPaginate = Options.Pagination
  Options.Pagination = False
  With m_oTarget.Range
    On Error GoTo Err_EmptyArray
    If m_arrFiles(0, 0) = "There are no files in this folder." Then
      .InsertAfter "There are no files in this folder." & vbCr
      Exit Sub
    End If
    For m_lngIndex = 0 To UBound(m_arrFiles, 2)
      Select Case True
        Case oFrm.optNSTDM
          .InsertAfter m_arrFiles(0, m_lngIndex)
          .InsertAfter vbTab & (m_arrFiles(2, m_lngIndex) \ 1024) & "K"
          .InsertAfter vbTab & m_arrFiles(3, m_lngIndex) & vbTab & m_arrFiles(4, m_lngIndex)
        Case oFrm.optNameSize
          .InsertAfter m_arrFiles(0, m_lngIndex)
          .InsertAfter vbTab & vbTab & vbTab & vbTab & (m_arrFiles(2, m_lngIndex) \ 1024) & "K"
        Case oFrm.optName
          .InsertAfter m_arrFiles(0, m_lngIndex)
      End Select
      .InsertAfter vbCr
      Application.StatusBar = "Listing : " & m_arrFiles(0, m_lngIndex)
      DoEvents
    Next m_lngIndex
  End With
  m_oTarget.Repaginate
  Options.Pagination = bPaginate
  m_oTarget.Activate
lbl_Exit:
  Exit Sub
Err_EmptyArray:
  m_oTarget.Range.InsertAfter "There are no files in this folder." & vbCr
  Resume lbl_Exit
End Sub
 
Function ListSubFolder(ByRef oSubFolder As Folder)
  With m_oTarget.Range
    m_arrFiles = GetFileData(oSubFolder)
    .InsertAfter oSubFolder.Path & vbCr
    Set m_oRng = .Paragraphs.Last.Previous.Range
    m_oRng.Style = "Sub-FolderHeading"
    Set m_oRng = .Paragraphs.Last.Range
    m_oRng.Style = "Column Captions"
    Select Case True
      Case oFrm.optNSTDM
        m_oRng.Text = "Name" & vbTab & "Size" & vbTab & "Type" & vbTab & "Date Modified" & vbCr
      Case oFrm.optNameSize
        m_oRng.Text = "Name" & vbTab & vbTab & vbTab & vbTab & "Size" & vbCr
      Case oFrm.optName
        m_oRng.Text = "Name" & vbCr
    End Select
    Set m_oRng = .Paragraphs.Last.Range
    m_oRng.Style = "FileListing"
    RecordResults
  End With
  Set oSubFolder = Nothing
lbl_Exit:
  Exit Function
End Function

Sub ExcelRecordResults()
Dim lngIndex As Long
  m_lngLastRow = m_oSheet.Cells(m_oSheet.Rows.count, 1).End(xlUp).Row
  With m_oSheet
    On Error GoTo Err_EmptyArray
    If m_arrFiles(0, 0) = "There are no files in this folder." Then
      .Cells(m_lngLastRow + 1, 1).value = "There are no files in this folder"
      .Cells(m_lngLastRow + 1, 2).value = m_arrFiles(0, 1)
      Exit Sub
    End If
    For m_lngIndex = 0 To UBound(m_arrFiles, 2)
      m_lngLastRow = m_oSheet.Cells(m_oSheet.Rows.count, 1).End(xlUp).Row
      For lngIndex = 0 To 6
        m_oSheet.Cells(m_lngLastRow + 1, lngIndex + 1).value = m_arrFiles(lngIndex, m_lngIndex)
      Next lngIndex
      Application.StatusBar = "Listing : " & m_arrFiles(0, m_lngIndex)
      DoEvents
    Next m_lngIndex
  End With
lbl_Exit:
  Exit Sub
Err_EmptyArray:
  m_oSheet.Cells(m_lngLastRow + 1, 1).value = "There are no files in this folder"
  MsgBox Err.Number & " " & Err.Description
  Resume lbl_Exit
End Sub

Function ExcelListSubFolder(ByRef oSubFolder As Folder)
Dim lngIndex As Long
    m_arrFiles = GetFileData(oSubFolder)
    ExcelRecordResults
  Set oSubFolder = Nothing
lbl_Exit:
  Exit Function
End Function
Function GetFileData(ByRef oFolder As Folder) As String()
Dim oFile As file
  m_lngIndex = 0
  ReDim m_arrFiles(6, 0)
  frmProgressBarContinous.Caption = "Processing: " & oFolder.Name & ""
  
  If oFolder.Files.count = 0 Then
    ReDim m_arrFiles(6, 1)
    m_arrFiles(0, 0) = "There are no files in this folder."
    m_arrFiles(0, 1) = oFolder.Path
    GetFileData = m_arrFiles
  Else
    For Each oFile In oFolder.Files
      Select Case lngProcess
        Case 1: frmProgressBarContinous.ChangeUp 1
        Case 10: frmProgressBarContinous.ChangeUp 2
        Case 20: frmProgressBarContinous.ChangeUp 3
        Case 30: frmProgressBarContinous.ChangeUp 4
        Case 40: frmProgressBarContinous.ChangeUp 5
        Case 50: frmProgressBarContinous.ChangeUp 6
        Case 60: lngProcess = 0
      End Select
      lngProcess = lngProcess + 1
      ReDim Preserve m_arrFiles(6, m_lngIndex)
      m_arrFiles(0, m_lngIndex) = oFile.Name
      m_arrFiles(1, m_lngIndex) = oFile.ParentFolder
      m_arrFiles(2, m_lngIndex) = oFile.Size
      m_arrFiles(3, m_lngIndex) = oFile.Type
      m_arrFiles(4, m_lngIndex) = oFile.DateLastModified
      m_arrFiles(5, m_lngIndex) = oFile.DateCreated
      m_arrFiles(6, m_lngIndex) = oFile.DateLastAccessed
      m_lngIndex = m_lngIndex + 1
    Next oFile
    GetFileData = m_arrFiles
  End If
lbl_Exit:
  Exit Function
End Function

Function GetUTPath() As String
Dim fDlg As Dialog
  Set fDlg = Dialogs(wdDialogToolsOptionsFileLocations)
  With fDlg
    .Path = "USER-DOT-PATH"
    .Update
    GetUTPath = .Setting
  End With
lbl_Exit:
  Exit Function
End Function
Sub CollectSubFolders(oFolder As Folder)
Dim oSubFolder As Folder
  For Each oSubFolder In oFolder.SubFolders
    m_colFolders.Add oSubFolder.Path, oSubFolder.Path
    Set oFolder = m_oFSO.GetFolder(oSubFolder.Path)
    CollectSubFolders oSubFolder
  Next
lbl_Exit:
  Exit Sub
End Sub

Public Function BubbleSortColRowArray(varPassed, lngColSortIndex As Long, _
                                      Optional bAscending As Boolean = True, Optional bAlphabet As Boolean = True)
Dim lngRowIndex As Long
Dim varstrTemp
Dim lngColIndex As Long
Dim bReorder As Boolean
  If bAlphabet Then
    Do
      bReorder = True
      For lngRowIndex = LBound(varPassed) To UBound(varPassed, 2) - 1
        'Sort Ascending (1)
        If bAscending Then
          If varPassed(lngColSortIndex, lngRowIndex) > varPassed(lngColSortIndex, lngRowIndex + 1) Then
            bReorder = False
            For lngColIndex = 0 To UBound(varPassed, 1)
              varstrTemp = varPassed(lngColIndex, lngRowIndex)
              varPassed(lngColIndex, lngRowIndex) = varPassed(lngColIndex, lngRowIndex + 1)
              varPassed(lngColIndex, lngRowIndex + 1) = varstrTemp
            Next lngColIndex
          End If
        'Sort Descending (2)
        Else
          If varPassed(lngColSortIndex, lngRowIndex) < varPassed(lngColSortIndex, lngRowIndex + 1) Then
            bReorder = False
            For lngColIndex = 0 To UBound(varPassed, 1)
              varstrTemp = varPassed(lngColIndex, lngRowIndex)
              varPassed(lngColIndex, lngRowIndex) = varPassed(lngColIndex, lngRowIndex + 1)
              varPassed(lngColIndex, lngRowIndex + 1) = varstrTemp
            Next lngColIndex
          End If
        End If
      Next lngRowIndex
    Loop While Not bReorder
  Else
    'Sort the Array Numerically(2)
    '(Substitute CInt with another conversion type (CLng, CDec, etc.) depending on type of numbers in the column)
    On Error GoTo Err_Type
    Do
      bReorder = True
      For lngRowIndex = LBound(varPassed) To UBound(varPassed, 2) - 1
        'Sort Ascending (1)
        If bAscending Then
          If CInt(varPassed(lngColSortIndex, lngRowIndex)) > CInt(varPassed(lngColSortIndex, lngRowIndex + 1)) Then
            bReorder = False
            For lngColIndex = 0 To UBound(varPassed, 1)
              varstrTemp = varPassed(lngColIndex, lngRowIndex)
              varPassed(lngColIndex, lngRowIndex) = varPassed(lngColIndex, lngRowIndex + 1)
              varPassed(lngColIndex, lngRowIndex + 1) = varstrTemp
            Next lngColIndex
          End If
        'Sort Descending (2)
        Else
          If CInt(varPassed(lngColSortIndex, lngRowIndex)) < CInt(varPassed(lngColSortIndex, lngRowIndex + 1)) Then
            bReorder = False
            For lngColIndex = 0 To UBound(varPassed, 1)
              varstrTemp = varPassed(lngColIndex, lngRowIndex)
              varPassed(lngColIndex, lngRowIndex) = varPassed(lngColIndex, lngRowIndex + 1)
              varPassed(lngColIndex, lngRowIndex + 1) = varstrTemp
            Next lngColIndex
          End If
        End If
      Next lngRowIndex
    Loop While Not bReorder
  End If
lbl_Exit:
  BubbleSortColRowArray = varPassed
  Exit Function
Err_Type:
  MsgBox "The sort column is not the correct data type", vbOKOnly, "DATE TYPE MISMATCH"
  Resume lbl_Exit
End Function



Attribute VB_Name = "modGlobals_Initialize"
Option Explicit

Public p_strUSARemoteWordINI As String
Public p_strUSAOLocalWordINI As String
Public p_colUSAOWordSettings As clsINI_LineItems

'Dynamic menu paths
Public p_TemplatesPath As String
Public p_LettersPath As String
Public p_MemosPath As String
Public p_FaxCSPath As String
Public p_NewsReleasePath As String
Public p_PersonalTemplatesPath As String
Public p_AppellatePath As String
Public p_CivilPleadingsPath As String
Public p_CriminalPleadingsPath As String
Public p_EnvsAndLblsPath As String
Public p_DistrictLinksPath As String

Public p_IsUserAdmin As Boolean
Public p_userDistrict As String
Public Const HKEY_LOCAL_MACHINE = &H80000002
Public Const HKEY_CURRENT_USER = &H80000001
Private m_strBaseDrive As String

'* fcnInitSequence ******************************************************
'* Initializes the Ribbon
'*
'* INPUT:
'*
'* RETURNS: Boolean
'*
'***********************************************************************
Public Function fcnInitSequence() As Boolean

    'Sets the location of the Word INI on the P drive
  p_strUSARemoteWordINI = "p:\word\settings\word_settings.ini"
    'Sets the location of the Word INI on the D drive
  p_strUSAOLocalWordINI = "d:\word\settings\word_settings.ini"
   'Sets Boolean p_IsUserAdmin via Active Directory
  p_IsUserAdmin = modMain.fcnIsUserAdmin
    'Sets String p_userDistrict via Active Directory
  p_userDistrict = modMain.fcnGetUserDistrict
  'Checks for presence of remote/local INI file or uses defaults stored in modAdminDefaults
  modINISettings.fcnGetWordSettings
  
  'Does the local base drive exist as defined in the Settings INI file?
  If modMain.fcnFileOrDirExists(p_colUSAOWordSettings.getKeyValue("word base paths", "local base drive") & p_colUSAOWordSettings.getKeyValue("word base paths", "base folder") & p_colUSAOWordSettings.getKeyValue("word base paths", "workgroupTemplates folder")) Then
    'Yes
    m_strBaseDrive = p_colUSAOWordSettings.getKeyValue("word base paths", "local base drive")
  Else
    'No. Use the remote base path defined in the Settings INI file.
    m_strBaseDrive = p_colUSAOWordSettings.getKeyValue("word base paths", "remote base drive")
  End If
   
  'Set Dynamic folder paths based on the Settings INI file.
  p_TemplatesPath = m_strBaseDrive & p_colUSAOWordSettings.getKeyValue("word base paths", "base folder") & p_colUSAOWordSettings.getKeyValue("word base paths", "workgroupTemplates folder")
  p_LettersPath = p_TemplatesPath & p_colUSAOWordSettings.getKeyValue("word base paths", "districtTemplateLettersPath")
  p_MemosPath = p_TemplatesPath & p_colUSAOWordSettings.getKeyValue("word base paths", "districtTemplateMemosPath")
  p_FaxCSPath = p_TemplatesPath & p_colUSAOWordSettings.getKeyValue("word base paths", "districtTemplateFaxPath")
  p_NewsReleasePath = p_TemplatesPath & p_colUSAOWordSettings.getKeyValue("word base paths", "districtTemplateNewsPath")
  p_CivilPleadingsPath = p_TemplatesPath & p_colUSAOWordSettings.getKeyValue("word base paths", "districtTemplatePleadingsCivilPath")
  p_CriminalPleadingsPath = p_TemplatesPath & p_colUSAOWordSettings.getKeyValue("word base paths", "districtTemplatePleadingsCriminalPath")
  p_AppellatePath = p_TemplatesPath & p_colUSAOWordSettings.getKeyValue("word base paths", "districtTemplateAppellatePath")
  p_DistrictLinksPath = p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_dmDistrictLinksPath_Label")
  p_EnvsAndLblsPath = m_strBaseDrive & p_colUSAOWordSettings.getKeyValue("word base paths", "base folder") & _
  p_colUSAOWordSettings.getKeyValue("word support paths", "supportingFiles folder") & _
  p_colUSAOWordSettings.getKeyValue("word support paths", "envelopes and labels folder")
  p_PersonalTemplatesPath = p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_personalTemplatesPath_Label")
  
  'Set Workgroup Templates Path
  If CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_tabUSAO_Visible")) Then
    If Not p_IsUserAdmin Then
      If modMain.fcnFileOrDirExists(p_TemplatesPath) Then
        Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath) = p_TemplatesPath
      End If
    End If
  End If
  
  fcnInitSequence = True
lbl_Exit:
  Exit Function
lbl_Error: '*** Added GKM
  fcnInitSequence = False '*** Added GKM
End Function
Attribute VB_Name = "modINIReadWriteFunctions"
Private Sub Test()
'  Debug.Print 1 & fcnGetINIValue("d:\word\settings\word_settings.ini", "word application settings", "workgroup templates path folder", "test1")
'  Debug.Print 2 & fcnGetINIValue("d:\word\settings\word_settings.in", "word application settings", "workgroup templates path folder", "test2")
'  Debug.Print 3 & fcnGetINIValue("d:\word\settings\word_settings.ini", "word application settings", "invalid Key", "test3")
'  Debug.Print 4 & fcnGetINIValue("d:\word\settings\word_settings.ini", "invalid section", "workgroup templates path folder", "test4")
'  Debug.Print "Write: " & fcnWriteIniValue("d:\word\settings\word_settings.ini", "test section", "test key", "test value")
   Debug.Print "Write: " & fcnWriteIniValue("d:\word\settings\word_settings.ini", "test section", "test key 1", "test 1 value")
   Debug.Print "Write: " & fcnWriteIniValue("d:\word\settings\word_settings.ini", "test section", "test key 2", "test 2 value")
   Debug.Print fcnEraseKeyFromINI("d:\word\settings\word_settings.ini", "test section", "test key 1")
   Debug.Print fcnEraseKeyFromINI("d:\word\settings\word_settings.ini", "test section", "test key 2")
   Debug.Print fcnEraseSectionFromINI("d:\word\settings\word_settings.ini", "test section")
End Sub

Public Function fcnGetINIValue(ByVal strINIPath As String, ByVal strSection As String, _
                               ByVal strKey As String, Optional ByVal strDefValue As String = vbNullString) As String
'Purpose: Retrieve data from an INI File
'Inputs:  Required: Path to INI, Section Name, Key Name
'         Optional: Default Value that is returned if the file, section, key is invalid _
          or the value is empty.  If not used, an empty string is returned in these cases.
'Returns: Value of the key in the INI File or default value as described above.
Dim strReturnedValue As String
  strReturnedValue = Trim(System.PrivateProfileString(strINIPath, strSection, strKey))
  If strReturnedValue = vbNullString Then
    strReturnedValue = strDefValue
  End If
  fcnGetINIValue = strReturnedValue
lbl_Exit:
  Exit Function
End Function

Public Function fcnWriteIniValue(ByVal strINIPath As String, ByVal strSection As String, _
                                 ByVal strKey As String, Optional ByVal strValue As String = vbNullString) As Boolean
'Purpose:  Write data to INI File
'Inputs:   Required: Path to INI, Section Name, Key Name
'          Optional: Value the key should be set to. If not passed, the key is set to an empty string
'Returns: True if write occurs without error.
  'Initialize value.
  fcnWriteIniValue = False
  On Error Resume Next
  System.PrivateProfileString(strINIPath, strSection, strKey) = Trim(strValue)
  If Err.Number = 0 Then
    fcnWriteIniValue = True
  End If
lbl_Exit:
  Exit Function
End Function

Public Function fcnEraseSectionFromINI(ByVal strINIPath As String, ByVal strSection As String) As Boolean
'Purpose:  Deletes as section and all content from the INI file.
'Inputs:   Required: Path to INI, Section Name, Key Name
'Returns:  True if is section is . Have not found a way to validate if erase actually occurs.
Dim fileINI As clsINI_File
  fcnEraseSectionFromINI = False
  Set fileINI = New clsINI_File
  fileINI.Path = strINIPath
  fileINI.section = strSection
  fileINI.DeleteSection
  If fileINI.LastReturnCode > 0 Then
    fcnEraseSectionFromINI = True
  End If
  Set fileINI = Nothing
lbl_Exit:
  Exit Function
End Function

Public Function fcnEraseKeyFromINI(ByVal strINIPath As String, ByVal strSection As String, ByVal strKey As String)
Dim fileINI As clsINI_File
'Purpose:  Deletes as section and all content from the INI file.
'Inputs:   Required: Path to INI, Section Name, Key Name
'Returns:  True. Have not found a way validate attempt to erase non-existent key.

  Set fileINI = New clsINI_File
  fileINI.Path = strINIPath
  fileINI.section = strSection
  fileINI.key = strKey
  fileINI.DeleteKey
  Set fileINI = Nothing
End Function



Attribute VB_Name = "modINISettings"
Option Explicit

'* fcnGetWordSettings ***************************************************
'* Sets a collection to default stored INI file values, then modifies
'* them to match stored INI file if INI file exist
'*
'* INPUT:
'*
'* RETURNS: Boolean
'*
'***********************************************************************
Public Function fcnGetWordSettings() As Boolean
Dim bReturnVal As Boolean
Dim strRemoteINIPath As String

  'Set p_colUSAOWordSettings to the default INI values stored in modAdminDefualts
  Set p_colUSAOWordSettings = A_modAdminDefaults.fcnGetDefaultINIValues
  'Determines whether to use the P drive for users or network path for admins
  If p_IsUserAdmin Then
    strRemoteINIPath = fcnGetServerINIPath
  Else
    strRemoteINIPath = p_strUSARemoteWordINI
  End If
  'Checks to see if INI file exist. If it exist, uses INI file settings
  'First checks for remote INI file, if it exist, tries to copy locally
  If modMain.fcnFileOrDirExists(strRemoteINIPath) Then
    bReturnVal = p_colUSAOWordSettings.updateFromINI(strRemoteINIPath)
    If LCase(Environ("district")) <> "hub" Then
      p_colUSAOWordSettings.writeToINI (p_strUSAOLocalWordINI)
    End If
    'If remote INI file wasn't found, checks for local INI file
  Else
    If (modMain.fcnFileOrDirExists(p_strUSAOLocalWordINI) And (LCase(Environ("district")) <> "hub")) Then
      bReturnVal = p_colUSAOWordSettings.updateFromINI(p_strUSAOLocalWordINI)
    End If
  End If
  fcnGetWordSettings = bReturnVal
lbl_Exit:
  Exit Function
End Function

'* fcnGetServerINIPath *************************************************
'* Checks for existence of mapped P drive. If P is mapped, returns
'* mapped path, else returns standard util server file path name
'*
'* INPUT:
'*
'* RETURNS: String
'*
'***********************************************************************
Public Function fcnGetServerINIPath() As String
Dim oFSO As FileSystemObject: Set oFSO = CreateObject("Scripting.FileSystemObject")
Dim strHomeUtilServer As String
Dim strReturnPath As String: strReturnPath = vbNullString
    
  If oFSO.DriveExists(Mid(p_strUSARemoteWordINI, 1, 2)) Then
    strReturnPath = p_strUSARemoteWordINI
  Else
    strHomeUtilServer = fcnGetHomeUtil
    If strHomeUtilServer <> vbNullString Then
      If modMain.fcnFileOrDirExists("\\" & strHomeUtilServer & "\Apps") Then
        strReturnPath = "\\" & strHomeUtilServer & "\Apps" & Mid(p_strUSARemoteWordINI, 3)
      End If
    End If
  End If
  fcnGetServerINIPath = strReturnPath
lbl_Exit:
  Exit Function
End Function

'* fcnGetHomeUtil *************************************************
'* Returns util server address
'*
'* INPUT:
'*
'* RETURNS: String
'*
'***********************************************************************
Public Function fcnGetHomeUtil() As String
Dim strReturnVar
    
  strReturnVar = Replace(UCase(Environ("homeserver")), "SFILE", "SUTIL")
  If strReturnVar = vbNullString Then
    If p_userDistrict <> vbNullString Then
      strReturnVar = "USA" & p_userDistrict & "SUTIL21"
    End If
  End If
  fcnGetHomeUtil = strReturnVar
lbl_Exit:
  Exit Function
End Function



Attribute VB_Name = "modKeyBoardShortCuts"
Option Explicit
Sub ShowKeyboard()
  frmHotKeyMenu.Show
lbl_Exit:
  Exit Sub
End Sub
Sub ResetFontFormatting()
  Selection.Font.Reset
End Sub
Sub RevealFormatting()
  Application.TaskPanes(wdTaskPaneRevealFormatting).Visible = True
End Sub
Sub Section_Symbol_and_NBSpace()
Attribute Section_Symbol_and_NBSpace.VB_Description = "Section Symbol followed by non breaking space"
Attribute Section_Symbol_and_NBSpace.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.Section_Symbol_and_NBSpace"
  On Error GoTo Err_Handler
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=160, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:="|fffd|" & Chr(160)
  End If
End Sub
Sub Dbl_Section_Symbol_and_NBSpace()
  On Error GoTo Err_Handler
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=160, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:="|fffd||fffd|" & Chr(160)
  End If
End Sub
Sub NonBreakingSpace()
  On Error GoTo Err_Handler
  Selection.InsertSymbol CharacterNumber:=160, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(160)
  End If
End Sub
Sub Pilcrow_NBSpace()
Attribute Pilcrow_NBSpace.VB_Description = "Pilcrow followed by a non breaking space"
Attribute Pilcrow_NBSpace.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.Pilcrow_NBSpace"
  On Error GoTo Err_Handler
  Selection.InsertSymbol CharacterNumber:=182, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=160, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(182) & Chr(160)
  End If
End Sub
Sub Dbl_Pilcrows_NBSpace()
  On Error GoTo Err_Handler
  Selection.InsertSymbol CharacterNumber:=182, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=182, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=160, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(182) & Chr(182) & Chr(160)
  End If
End Sub
Sub NBS_Ellipsis_NBS()
  Selection.TypeText Text:="|fffd|.|fffd|.|fffd|.|fffd|"
End Sub
Sub En_Dash()
  On Error GoTo Err_Handler
  Selection.InsertSymbol CharacterNumber:=8211, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(150)
  End If
End Sub
Sub Em_Dash()
Attribute Em_Dash.VB_Description = "Em Dash"
Attribute Em_Dash.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.Em_Dash"
  On Error GoTo Err_Handler
  Selection.InsertSymbol CharacterNumber:=8212, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(150)
  End If
End Sub
Sub Bullet_LeftIndent()
Attribute Bullet_LeftIndent.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.Bullet_LeftIndent"
    With ListGalleries(wdBulletGallery).ListTemplates(1).ListLevels(1)
        .NumberFormat = ChrW(61623)
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = InchesToPoints(0.25)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = InchesToPoints(0.5)
        .TabPosition = wdUndefined
        .ResetOnHigher = 0
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Symbol"
        End With
        .LinkedStyle = ""
    End With
    ListGalleries(wdBulletGallery).ListTemplates(1).Name = ""
    Selection.Range.ListFormat.ApplyListTemplateWithLevel ListTemplate:= _
        ListGalleries(wdBulletGallery).ListTemplates(1), ContinuePreviousList:= _
        False, ApplyTo:=wdListApplyToWholeList, DefaultListBehavior:= _
        wdWord10ListBehavior
End Sub
Sub F_Appx()
Attribute F_Appx.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.F_Appx"
  Selection.TypeText Text:="F. App|fffd|x "
End Sub
Sub F_Supp()
  Selection.TypeText Text:="F. Supp. 2d "
End Sub
Sub USC_Section()
  Selection.TypeText Text:="U.S.C. "
  Section_Symbol_and_NBSpace
End Sub
Sub USC_Sections()
  On Error GoTo Err_Handler
  Selection.TypeText Text:="U.S.C. "
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=160, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(167) & Chr(167) & Chr(160)
  End If
End Sub
Sub USSG_Section()
  Selection.TypeText Text:="USSG "
  Application.Run MacroName:="modKeyBoardShortCuts.Section_Symbol_and_NBSpace"
End Sub
Sub USSG_Sections()
  On Error GoTo Err_Handler
  Selection.TypeText Text:="USSG "
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(167) & Chr(167)
  End If
End Sub
Sub CFR_Section()
  Selection.TypeText Text:="C.F.R. "
  Application.Run MacroName:="modKeyBoardShortCuts.Section_Symbol_and_NBSpace"
End Sub
Sub CFR_Sections()
  On Error GoTo Err_Handler
  Selection.TypeText Text:="C.F.R. "
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=167, Unicode:=True, Bias:=0
  Selection.InsertSymbol CharacterNumber:=160, Unicode:=True, Bias:=0
  On Error GoTo 0
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    Selection.TypeText Text:=Chr(167) & Chr(167) & Chr(160)
  End If
End Sub
Sub OpeningDoubleQuote()
Attribute OpeningDoubleQuote.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.OpeningDoubleQuote"
  Selection.TypeText Text:=ChrW(8220)
End Sub
Sub ClosingDoubleQuote()
Attribute ClosingDoubleQuote.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.ClosingDoubleQuote"
  Selection.TypeText Text:=ChrW(8221)
End Sub
Sub OpeningSingleQuote()
Attribute OpeningSingleQuote.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.OpeningSingleQuote"
  Selection.TypeText Text:="|fffd|"
End Sub
Sub ClosingSingleQuote()
Attribute ClosingSingleQuote.VB_ProcData.VB_Invoke_Func = "Project.NewMacros.ClosingSingleQuote"
  Selection.TypeText Text:="|fffd|"
End Sub
Sub PrintCurrentPage()
  Application.PrintOut Range:=wdPrintCurrentPage
End Sub
Sub PasteUnformattedText()
  Selection.PasteSpecial link:=False, DataType:=wdPasteText, Placement:= _
        wdInLine, DisplayAsIcon:=False
End Sub







Attribute VB_Name = "modLoadPictureGDI"
Option Explicit
'This module provides a LoadPictureGDI function, which can be used instead of VBA's LoadPicture, _
to load a wide variety of image types from disk - including png.

'The png format is used in Office 2007-2010 to provide images that include an alpha channel for each pixel's transparency

'Author:    Stephen Bullen
'Date:      31 October, 2006
'Email:     stephen@oaltd.co.uk

'Updated :  30 December, 2010
'By :       Rob Bovey
'Reason :   Also working now in the 64 bit version of Office 2010

'Declare a UDT to store a GUID for the IPicture OLE Interface
Private Type GUID
  Data1 As Long
  Data2 As Integer
  Data3 As Integer
  Data4(0 To 7) As Byte
End Type

#If VBA7 Then
  'Declare a UDT to store the bitmap information
  Private Type PICTDESC
    Size As Long
    Type As Long
    hPic As LongPtr
    hPal As LongPtr
  End Type
  'Declare a UDT to store the GDI+ Startup information
  Private Type GdiplusStartupInput
    GdiplusVersion As Long
    DebugEventCallback As LongPtr
    SuppressBackgroundThread As Long
    SuppressExternalCodecs As Long
  End Type
  'Windows API calls into the GDI+ library
  Private Declare PtrSafe Function GdiplusStartup Lib "GDIPlus" (token As LongPtr, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As LongPtr = 0) As Long
  Private Declare PtrSafe Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal filename As LongPtr, bitmap As LongPtr) As Long
  Private Declare PtrSafe Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As LongPtr, hbmReturn As LongPtr, ByVal background As LongPtr) As Long
  Private Declare PtrSafe Function GdipDisposeImage Lib "GDIPlus" (ByVal image As LongPtr) As Long
  Private Declare PtrSafe Sub GdiplusShutdown Lib "GDIPlus" (ByVal token As LongPtr)
  Private Declare PtrSafe Function OleCreatePictureIndirect Lib "oleaut32" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long
#Else
  'Declare a UDT to store the bitmap information
  Private Type PICTDESC
    Size As Long
    Type As Long
    hPic As Long
    hPal As Long
  End Type
  'Declare a UDT to store the GDI+ Startup information
  Private Type GdiplusStartupInput
    GdiplusVersion As Long
    DebugEventCallback As Long
    SuppressBackgroundThread As Long
    SuppressExternalCodecs As Long
  End Type
  'Windows API calls into the GDI+ library
  Private Declare Function GdiplusStartup Lib "GDIPlus" (token As Long, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As Long = 0) As Long
  Private Declare Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal filename As Long, bitmap As Long) As Long
  Private Declare Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As Long, hbmReturn As Long, ByVal background As Long) As Long
  Private Declare Function GdipDisposeImage Lib "GDIPlus" (ByVal image As Long) As Long
  Private Declare Sub GdiplusShutdown Lib "GDIPlus" (ByVal token As Long)
  Private Declare Function OleCreatePictureIndirect Lib "oleaut32" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long
#End If

' Procedure:    LoadPictureGDI
' Purpose:      Loads an image using GDI+
' Returns:      The image as an IPicture Object
Public Function LoadPictureGDI(ByVal sFilename As String) As IPicture
Dim uGdiInput As GdiplusStartupInput
Dim lResult As Long
#If VBA7 Then
  Dim hGdiPlus As LongPtr
  Dim hGdiImage As LongPtr
  Dim hBitmap As LongPtr
#Else
  Dim hGdiPlus As Long
  Dim hGdiImage As Long
  Dim hBitmap As Long
#End If
'Initialize GDI+
uGdiInput.GdiplusVersion = 1
lResult = GdiplusStartup(hGdiPlus, uGdiInput)
If lResult = 0 Then
  'Load the image
  lResult = GdipCreateBitmapFromFile(StrPtr(sFilename), hGdiImage)
  If lResult = 0 Then
    'Create a bitmap handle from the GDI image
    lResult = GdipCreateHBITMAPFromBitmap(hGdiImage, hBitmap, 0)
    'Create the IPicture object from the bitmap handle
    Set LoadPictureGDI = CreateIPicture(hBitmap)
    'Tidy up
    GdipDisposeImage hGdiImage
  End If
  'Shutdown GDI+
  GdiplusShutdown hGdiPlus
End If
End Function
' Procedure:    CreateIPicture
' Purpose:      Converts a image handle into an IPicture object.
' Returns:      The IPicture object
#If VBA7 Then
  Private Function CreateIPicture(ByVal hPic As LongPtr) As IPicture
#Else
  Private Function CreateIPicture(ByVal hPic As Long) As IPicture
#End If
Dim lResult As Long
Dim uPicInfo As PICTDESC
Dim IID_IDispatch As GUID
Dim IPic As IPicture
'OLE Picture types
Const PICTYPE_BITMAP = 1
'Create the Interface GUID (for the IPicture interface)
With IID_IDispatch
  .Data1 = &H7BF80980
  .Data2 = &HBF32
  .Data3 = &H101A
  .Data4(0) = &H8B
  .Data4(1) = &HBB
  .Data4(2) = &H0
  .Data4(3) = &HAA
  .Data4(4) = &H0
  .Data4(5) = &H30
  .Data4(6) = &HC
  .Data4(7) = &HAB
End With
'Fill uPicInfo with necessary parts.
With uPicInfo
  .Size = Len(uPicInfo)
  .Type = PICTYPE_BITMAP
  .hPic = hPic
  .hPal = 0
End With
'Create the Picture object.
lResult = OleCreatePictureIndirect(uPicInfo, IID_IDispatch, True, IPic)
'Return the new Picture object.
Set CreateIPicture = IPic
End Function





Attribute VB_Name = "modMain"
Option Explicit

Public Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
Public Declare Function apiShowWindow Lib "user32" Alias "ShowWindow" (ByVal hwnd As Long, Optional ByVal nCmdShow As Long = 1) As Long

Private Type typHoliday
  bIsHoliday As Boolean
  strDay As String
End Type
 
Sub ShowAddInsInfo()
Dim oFrm As frmInfo
  Set oFrm = New frmInfo
  oFrm.Show
  Set oFrm = Nothing
lbl_Exit:
  Exit Sub
End Sub
Sub ShowAdminSetup()
Dim oFrm As frmUSAOAdminForm
  Set oFrm = New frmUSAOAdminForm
  oFrm.Show
  Unload oFrm
  Set oFrm = Nothing
lbl_Exit:
  Exit Sub
End Sub

Sub InsertDateOffet()
  Dim oFrm As frmDateAdd
  Set oFrm = New frmDateAdd
  oFrm.Show
  Unload oFrm
  Set oFrm = Nothing
lbl_Exit:
  Exit Sub
End Sub
Function Calc_InsertDateAdd(ByRef oDate As Date, ByRef lngDaysToOffset As Long, bAdvance As Boolean, _
                            bBusiness As Boolean, bFRCP6 As Boolean, bInsert As Boolean) As String
Dim oDateStamp As Date
Dim typDay As typHoliday
Dim lngIndex As Long
Dim lngOffset As Long
  
  oDateStamp = Format(oDate, "MMMM, d, yyyy")
  If bAdvance Then
    lngOffset = 1
  Else
    lngOffset = -1
  End If
  Select Case True
    Case bBusiness
    For lngIndex = 1 To lngDaysToOffset
      oDateStamp = DateAdd("d", lngOffset, oDateStamp)
      Do
        typDay = fcnIsHolidayOrWeekend(oDateStamp)
        If typDay.bIsHoliday Then
           oDateStamp = DateAdd("d", lngOffset, oDateStamp)
        End If
      Loop While typDay.bIsHoliday
    Next lngIndex
  Case bFRCP6
    oDateStamp = DateAdd("d", lngDaysToOffset * lngOffset, oDate)
    oDateStamp = Format(oDateStamp, "MMMM, d, yyyy")
    Do
      typDay = fcnIsHolidayOrWeekend(oDateStamp)
      If typDay.bIsHoliday Then
         oDateStamp = DateAdd("d", lngOffset, oDateStamp)
      End If
    Loop While typDay.bIsHoliday
  Case Else
    oDateStamp = DateAdd("d", lngDaysToOffset * lngOffset, oDate)
  End Select
  Calc_InsertDateAdd = Format(oDateStamp, "MMMM d, yyyy")
  If bInsert Then
    If Documents.count = 0 Then Documents.Add
    With Selection
      .InsertAfter Format(oDateStamp, "MMMM d, yyyy") & " "
      .Collapse wdCollapseEnd
    End With
  End If
lbl_Exit:
  Exit Function
End Function


Function fcnFindReplace(strFind As String, strReplace As String, Optional oRngPassed As Range) As Boolean
Dim oRng As Word.Range
  If oRngPassed Is Nothing Then
    Set oRng = ActiveDocument.Range
  Else
    Set oRng = oRngPassed
  End If
  With oRng.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .Text = strFind
    .Replacement.Text = strReplace
    .Forward = True
    .Wrap = wdFindContinue
    .Format = False
    .MatchCase = False
    .MatchWholeWord = False
    .MatchWildcards = False
    .MatchSoundsLike = False
    .MatchAllWordForms = False
    .Execute Replace:=wdReplaceAll
  End With
lbl_Exit:
  Exit Function
End Function
Function fcnFixSuffix(strNamePassed As String) As String
Dim strNew As String
Dim strTest As String
     
  strNew = strNamePassed
  strTest = Right(strNamePassed, 6)
  Select Case strTest
    Case " Ph.D."
      strNew = Left(strNamePassed, Len(strNamePassed) - 6)
      GoTo CorrectName
    Case " PH.D."
      strNew = Left(strNamePassed, Len(strNamePassed) - 6)
      GoTo CorrectName
  End Select
  strTest = Right(strNamePassed, 5)
  Select Case strTest
    Case " Ph.D"
      strNew = Left(strNamePassed, Len(strNamePassed) - 5)
      GoTo CorrectName
    Case " PH.D"
      strNew = Left(strNamePassed, Len(strNamePassed) - 5)
      GoTo CorrectName
    Case " PhD."
      strNew = Left(strNamePassed, Len(strNamePassed) - 5)
      GoTo CorrectName
    Case " PHD."
      strNew = Left(strNamePassed, Len(strNamePassed) - 5)
      GoTo CorrectName
    Case " Esq."
      strNew = Left(strNamePassed, Len(strNamePassed) - 5)
      GoTo CorrectName
  End Select
  strTest = Right(strNamePassed, 4)
  Select Case strTest
    Case " Jr."
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " JR."
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " Sr."
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " SR."
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " PhD"
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " PHD"
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " Esq"
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " ESQ"
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
    Case " III"
      strNew = Left(strNamePassed, Len(strNamePassed) - 4)
      GoTo CorrectName
  End Select
  strTest = Right(strNamePassed, 3)
  Select Case strTest
    Case " Jr"
      strNew = Left(strNamePassed, Len(strNamePassed) - 3)
      GoTo CorrectName
    Case " JR"
      strNew = Left(strNamePassed, Len(strNamePassed) - 3)
      GoTo CorrectName
    Case " Sr"
      strNew = Left(strNamePassed, Len(strNamePassed) - 3)
      GoTo CorrectName
    Case " SR"
      strNew = Left(strNamePassed, Len(strNamePassed) - 3)
      GoTo CorrectName
    Case " II"
      strNew = Left(strNamePassed, Len(strNamePassed) - 3)
      GoTo CorrectName
    Case " IV"
      strNew = Left(strNamePassed, Len(strNamePassed) - 3)
      GoTo CorrectName
  End Select
  If Right(strNamePassed, 1) = " V" Then
    strNew = Left(strNamePassed, Len(strNamePassed) - 2)
    GoTo CorrectName
  End If
  strNamePassed = strNamePassed & Chr(13)
  Exit Function
CorrectName:
  strNamePassed = strNew & "," & strTest & Chr(13)
  Exit Function
End Function

Function GetFileExtension(ByRef strstrFileName As String) As String
  On Error GoTo Err_NoExtension
  GetFileExtension = VBA.Right(strstrFileName, Len(strstrFileName) - (InStrRev(strstrFileName, ".", -1, vbTextCompare)))
  If GetFileExtension = strstrFileName Then
    'There is no extenstion
    GetFileExtension = ""
  End If
  Exit Function
Err_NoExtension:
End Function


Sub InsertSymbols(ByVal Font As String, CN As Long, Optional UNI As Boolean)
  On Error GoTo Err_Handler
  Selection.InsertSymbol Font:=Font, CharacterNumber:=CN, Unicode:=UNI
  On Error GoTo 0
lbl_Exit:
  Exit Sub
Err_Handler:
  If Err.Number = 4605 Then
    If Font = "Wingdings" Or Font = "Wingdings 2" Then
     modNotifyError.Notify_ShowError 1, 20
    Else
      Selection.TypeText Text:=ChrW(CN)
    End If
  End If

End Sub

Public Function fcnFormatFont(oRng As Range, strFontName As String, lngSize As Long, Optional bBold As Boolean = False)
  With oRng.Font
    .Name = strFontName
    .Size = lngSize
    .Bold = bBold
    .Italic = False
    .Underline = wdUnderlineNone
    .UnderlineColor = wdColorAutomatic
    .StrikeThrough = False
    .DoubleStrikeThrough = False
    .Outline = False
    .Emboss = False
    .Shadow = False
    .Hidden = False
    .SmallCaps = False
    .AllCaps = False
    .color = wdColorAutomatic
    .Engrave = False
    .Superscript = False
    .Subscript = False
    .Spacing = 0
    .Scaling = 100
    .Position = 0
    .Kerning = 0
    .Animation = wdAnimationNone
  End With
lbl_Exit:
  Exit Function
End Function

Function fcnSetDocVar(strName As String, strValue As String) As Boolean
Dim lngIndex As Long
Dim oVar As Variable
Dim lngVarIndex As Long
    
  For lngIndex = 1 To ActiveDocument.Variables.count
    Set oVar = ActiveDocument.Variables(lngIndex)
    If oVar.Name = strName Then
      lngVarIndex = lngIndex
      Exit For
    Else
      lngVarIndex = 0
    End If
  Next lngIndex
  If lngVarIndex = 0 Then
    ActiveDocument.Variables.Add Name:=strName, value:=strValue
  Else
    ActiveDocument.Variables(lngVarIndex).value = strValue
  End If
  fcnSetDocVar = True
lbl_Exit:
  Exit Function
End Function

Function fcnFindDeleteRng(strFind As String, Optional oRngPassed As Word.Range) As Range
Dim oRng As Word.Range

  If oRngPassed Is Nothing Then
    Set oRng = ActiveDocument.Range
  Else
    Set oRng = oRngPassed
  End If
  With oRng.Find
    .ClearFormatting
    .Text = strFind
    .Replacement.Text = ""
    .Forward = True
    .Wrap = wdFindContinue
    .Format = False
    .MatchCase = False
    .MatchWholeWord = False
    .MatchWildcards = False
    .MatchSoundsLike = False
    .MatchAllWordForms = False
    If .Execute Then
      Set fcnFindDeleteRng = oRng
      fcnFindDeleteRng.Delete
    End If
  End With
lbl_Exit:
  Exit Function
End Function

Public Function fcnIsHolidayOrWeekend(oDate As Date) As typHoliday
  Select Case True
    Case Weekday(oDate) = 1 Or Weekday(oDate) = 7
      'Plain weekend day.
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Weekend day"
    Case oDate = DateSerial(Year(oDate), 1, 1)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "New Year's Day"
    Case oDate = DateSerial(Year(oDate), 12, 25)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Christmas Day"
    Case oDate = DateSerial(Year(oDate), 7, 4)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Independence Day"
    Case oDate = DateSerial(Year(oDate), 11, 11)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Veterans Day"
    Case oDate = fcn_NthWeekday(Year(oDate), 11, 4, 5)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Thanksgiving Day"
    Case oDate = fcn_NthWeekday(Year(oDate), 10, 2, 2)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Columbus Day"
'    Case oDate = DateAdd("d", 1, fcn_NthWeekday(Year(oDate), 11, 4, 5))
'      fcnIsHolidayOrWeekend.bIsHoliday = True
'      fcnIsHolidayOrWeekend.strDay = "Thanksgiving Recovery Day"
    Case oDate = fcn_NthWeekday(Year(oDate), 1, 3, 2)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Martin Luther King's Birthday"
    Case oDate = fcn_NthWeekday(Year(oDate), 2, 3, 2)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Presidents Day"
    Case oDate = fcn_NthWeekday(Year(oDate), 9, 1, 2)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Labor Day"
    Case oDate = fcn_NthWeekday(Year(oDate), 5, fncNumberOfNamedDaysInMonth(Year(oDate), 5, 2), 2)
      fcnIsHolidayOrWeekend.bIsHoliday = True
      fcnIsHolidayOrWeekend.strDay = "Memorial Day"
    Case Else
      'Is it an observed holiday
      If Weekday(oDate) = 2 Then
        Select Case True
          Case DateAdd("d", -1, oDate) = DateSerial(Year(oDate), 1, 1)
            fcnIsHolidayOrWeekend.bIsHoliday = True
            fcnIsHolidayOrWeekend.strDay = "New Year's Day Observed"
          Case DateAdd("d", -1, oDate) = DateSerial(Year(oDate), 12, 25)
            fcnIsHolidayOrWeekend.bIsHoliday = True
            fcnIsHolidayOrWeekend.strDay = "Christmas Day Observed"
          Case DateAdd("d", -1, oDate) = DateSerial(Year(oDate), 7, 4)
            fcnIsHolidayOrWeekend.bIsHoliday = True
            fcnIsHolidayOrWeekend.strDay = "Indenpence Day Observed"
          Case DateAdd("d", -1, oDate) = DateSerial(Year(oDate), 11, 11)
            fcnIsHolidayOrWeekend.bIsHoliday = True
            fcnIsHolidayOrWeekend.strDay = "Veteren's Day Observed"
          Case Else
            fcnIsHolidayOrWeekend.bIsHoliday = False
            fcnIsHolidayOrWeekend.strDay = "Just and ordinary day"
        End Select
      ElseIf Weekday(oDate) = 6 Then
        Select Case True
          Case oDate = "12/31/" & Year(oDate)
            If DateAdd("d", 1, oDate) = DateSerial(Year(oDate) + 1, 1, 1) Then
              fcnIsHolidayOrWeekend.bIsHoliday = True
              fcnIsHolidayOrWeekend.strDay = "New Year's Day Observed"
            End If
          Case DateAdd("d", 1, oDate) = DateSerial(Year(oDate), 12, 25)
            fcnIsHolidayOrWeekend.bIsHoliday = True
            fcnIsHolidayOrWeekend.strDay = "Christmas Day Observed"
          Case DateAdd("d", 1, oDate) = DateSerial(Year(oDate), 7, 4)
            fcnIsHolidayOrWeekend.bIsHoliday = True
            fcnIsHolidayOrWeekend.strDay = "Indenpence Day Observed"
          Case DateAdd("d", 1, oDate) = DateSerial(Year(oDate), 11, 11)
            fcnIsHolidayOrWeekend.bIsHoliday = True
            fcnIsHolidayOrWeekend.strDay = "Veteren's Day Observed"
          Case Else
            fcnIsHolidayOrWeekend.bIsHoliday = False
            fcnIsHolidayOrWeekend.strDay = "Just and ordinary day"
         End Select
      Else
        fcnIsHolidayOrWeekend.bIsHoliday = False
        fcnIsHolidayOrWeekend.strDay = "Just and ordinary day"
      End If
  End Select
lbl_Exit:
  Exit Function
End Function
Public Function fcn_NthWeekday(lngYear As Long, lngMonth As Long, lngNumber As Long, lngDayOfWeek As Long) As Date
Dim lngIndex As Long
  'Takes as arguments 1) lngYear = A year 2) lngMonth = A month 3) lngNumber = The Nth (e.g., 1st, 2nd, 3rd lngDayOfWeek) _
   lngDayOfWeek = A constant (e.g., 5 or vbThursday)
  'So if we pass 2013, 11, 4, 5 then we expect to return Thanksgiving day 11/28/2013 or the 4th Thursday in November.
  lngIndex = 0
  'Find the date of the first occurence of lngDayOfWeek.
  Do
    lngIndex = lngIndex + 1
  Loop Until Weekday(DateSerial(lngYear, lngMonth, lngIndex)) = lngDayOfWeek
  'So in our example lngIndex will be "7" as the first Thursday in November 2013 falls on the 7th.
  'To those "7" days, we want to add three more weeks or 21 days or (lngNumber - 1) * 7.
  fcn_NthWeekday = DateSerial(lngYear, lngMonth, lngIndex + (lngNumber - 1) * 7)
lbl_Exit:
  Exit Function
End Function


Public Function fncNumberOfNamedDaysInMonth(lngYear As Long, lngMonth As Long, lngDayOfWeek As Long) As Long
Dim lngIndex As Long, lngRange As Long
  On Error GoTo lbl_Exit
  lngRange = Day(DateSerial(lngYear, lngMonth + 1, 0))
  fncNumberOfNamedDaysInMonth = 0
  For lngIndex = 1 To lngRange
    If Weekday(DateSerial(lngYear, lngMonth, lngIndex)) = lngDayOfWeek Then
        fncNumberOfNamedDaysInMonth = fncNumberOfNamedDaysInMonth + 1
    End If
  Next lngIndex
lbl_Exit:
  fncNumberOfNamedDaysInMonth = 0
  Exit Function
End Function
Function fcnFileOrDirExists(PathName As String) As Boolean
'Macro Purpose: Function returns TRUE if the specified file
'or folder exists, false if not.
'PathName: Supports Windows mapped drives
'File usage: Provide full file path and extension
'Folder usage : Provide full folder path
Dim iTemp As Integer
'Ignore errors to allow for error evaluation
On Error Resume Next
iTemp = GetAttr(PathName)
'Check if error exists and set response appropriately
Select Case Err.Number
Case Is = 0
  fcnFileOrDirExists = True
Case Else
  fcnFileOrDirExists = False
End Select
'Resume error checking
On Error GoTo 0
End Function

Function GetDocPath() As String
Dim fDlg As Dialog
Set fDlg = Dialogs(wdDialogToolsOptionsFileLocations)
With fDlg
  .Path = "DOC-PATH"
  .Update
  GetDocPath = .Setting
End With
End Function
Public Function fcnGetDrive(ByRef strTag As String)
  If Len(strTag) = 1 Then
    strTag = strTag & ":"
  Else
    strTag = p_colUSAOWordSettings.getKeyValue("word ribbon settings", strTag & "_Label")
  End If
  If fcnFileOrDirExists(strTag) Then
    modMain.fcnBrowseDrive strTag
  Else
    modNotifyError.Notify_ShowError 1, 1, , strTag
  End If
lbl_Exit:
  Exit Function
End Function

Public Function fcnBrowseDrive(ByVal strAddress As String) As Boolean
  fcnBrowseDrive = Shell("explorer.exe """ & strAddress & """", vbNormalFocus)
lbl_Exit:
  Exit Function
End Function

Sub fcnSearchInternet(ByRef strId)
Dim strAddress As String, strAfterQuery As String, strHome As String
Dim strSearch As String, lngIndex As Integer

    strAfterQuery = vbNullString

  'Basic idea taken from: http://www.vbaexpress.com/kb/getarticle.php?kb_id=309
  Select Case strId
    Case "usao_btnSearchBing"
      strAddress = "http://www.bing.com/search?q="
      strHome = "http://www.bing.com"
    Case "usao_btnSearchGoogle"
      strAddress = "http://www.google.com/search?q="
      strHome = "http://www.google.com"
    Case "usao_btnSearchGoogleScholar"
      strAddress = "http://scholar.google.com/scholar?as_sdt=2,9&q="
      strHome = "http://scholar.google.com/"
    Case "usao_btnSearchLexis"
      strAddress = "http://www.lexisnexis.com/clients/usdoj/sendSearch.asp?source=6312&search="
      strHome = "http://www.lexisnexis.com"
    Case "usao_btnSearchLexisWeb"
      strAddress = "http://www.lexisweb.com/Search.aspx?Query="
      strHome = "http://lexisweb.com/"
    Case "usao_btnSearchWestlaw"
      strAddress = "https://a.next.westlaw.com/Search/Results.html?query="
      strHome = "https://a.next.westlaw.com/Search/Home.html?transitionType=Default&contextData=(sc.Default)"
      strAfterQuery = "&jurisdiction=ALLFEDS&saveJuris=False&contentType=ALL&querySubmissionGuid=0&startIndex=1&searchId=0&simpleSearch=False&transitionType=Search&contextData=(sc.Search)"
    Case "usao_btnSearchYahoo"
      strAddress = "http://search.yahoo.com/?p="
      strHome = "http://search.yahoo.com/"
  End Select
  If Documents.count > 0 Then
    If Selection.Type = wdSelectionIP Then
      'Comment out the following line if retaining a bracket only, _
      and not highlighting an entire word is desired if there is no selection
      Selection.Words(1).Select
    End If
    strSearch = Selection.Text
    For lngIndex = 10 To 13
      strSearch = Replace(strSearch, Chr(lngIndex), " ")
    Next
    strSearch = Trim(strSearch)
    strSearch = Trim(strSearch)
    If strSearch = vbNullString Then
      fcnBrowseTo strHome, True, False
    Else
      If modNotifyError.Notify_ShowError(1, 15, True, "You are about to pass the following search to """ & strHome & """, a web site that is outside the Department of Justice:" & _
          vbCr & vbCr & strSearch & vbCrLf & vbCrLf & "Would you like to continue?") Then
        fcnBrowseTo strAddress & strSearch & strAfterQuery, True, False
      End If
    End If
  Else
    fcnBrowseTo strHome, True, False
  End If
lbl_Exit:
  Exit Sub
End Sub
Public Function fcnEmail(ByVal emailAddress As String, _
                            ByVal subj As String, _
                            ByVal body As String, _
                            Optional ByVal immediateSend As Boolean = False) As Boolean
    fcnEmail = False
    Dim Email_Subject, Email_Send_To, _
        Email_Body As String
    Dim Mail_Object, Mail_Single As Variant
     Email_Send_To = emailAddress
     Email_Subject = subj
     Email_Body = body
    On Error GoTo debugs
    Set Mail_Object = CreateObject("Outlook.Application")
    Set Mail_Single = Mail_Object.CreateItem(0)
    With Mail_Single
     .Subject = Email_Subject
     .To = Email_Send_To
     .body = Email_Body
     .Display
     If (immediateSend = True) Then
        .send
     End If
    End With
    AppActivate (Mail_Single)
    
debugs:
    If Err.Description <> "" Then MsgBox Err.Description
                            
End Function

Public Function fcnBrowseTo(ByVal strAddress As String, _
                           Optional ByVal bMaximized As Boolean = False, _
                           Optional ByVal bFullScreen As Boolean = False) As Boolean
  Dim oIE As Object
      
  Set oIE = CreateObject("InternetExplorer.Application")
  oIE.Navigate (strAddress)
  oIE.Visible = True
  
  If bMaximized Then
    apiShowWindow oIE.hwnd, 3
  Else
    apiShowWindow oIE.hwnd
  End If
  
  oIE.fullScreen = bFullScreen
  On Error Resume Next
    SetForegroundWindow oIE.hwnd
  On Error GoTo 0
  Err.Clear
  Set oIE = Nothing
  fcnBrowseTo = True
lbl_Exit:
  Exit Function
End Function

Sub ShowWindowsCalculator()
  Shell "C:\WINDOWS\System32\calc.exe", vbNormalFocus
lbl_Exit:
  Exit Sub
End Sub

Sub OpenQVPlus()
  Shell "C:\Program Files\Quick View Plus\Program\qvp64.exe", vbNormalFocus
lbl_Exit:
  Exit Sub
End Sub

Public Function fcnIsUserAdmin(Optional ByVal userName As String = vbNullString) As Boolean
Dim oConn As Object: Set oConn = CreateObject("ADODB.Connection")
Dim oCommand As Object: Set oCommand = CreateObject("ADODB.Command")

Dim oRecordSet As Object
Dim strDN As String
Dim strUserType As String
Dim bReturnVal As Boolean
    
  If userName = vbNullString Then userName = LCase(Environ("username"))
  On Error Resume Next
  oConn.Provider = "ADsDSOObject"
  oConn.Open "Active Directory Provider"
  
  Set oCommand.ActiveConnection = oConn
  
  oCommand.Properties("Page Size") = 1000
  'Set to 2 for ADS_SCOPE_SUBTREE
  oCommand.Properties("Searchscope") = 2
  oCommand.CommandText = "SELECT distinguishedName FROM 'LDAP://dc=usa,dc=doj,dc=gov' " & _
       "WHERE objectCategory='user' " & "AND sAMAccountName='" & userName & "'"
  Set oRecordSet = oCommand.Execute
  If Err.Number = 0 Then
    oRecordSet.MoveFirst
    strDN = oRecordSet.Fields("distinguishedName").value
    bReturnVal = (Left(Trim(LCase(Mid(strDN, InStr(1, strDN, "OU=") + Len("OU=")))), 5) = "admin")
  Else
    bReturnVal = False
  End If
  Err.Clear
  On Error GoTo 0
  Set oConn = Nothing
  Set oCommand = Nothing
  Set oRecordSet = Nothing
  fcnIsUserAdmin = bReturnVal
lbl_Exit:
  Exit Function
End Function

Public Function fcnGetUserDistrict(Optional ByVal userName As String = vbNullString) As String
Dim oConn As Object: Set oConn = CreateObject("ADODB.Connection")
Dim oCommand As Object: Set oCommand = CreateObject("ADODB.Command")

Dim oRecordSet As Object
Dim strReturnVal As String: strReturnVal = UCase(Environ("district"))
    
  If strReturnVal = vbNullString Or strReturnVal = "HUB" Or strReturnVal = "TO" Then
       
    If userName = vbNullString Then userName = LCase(Environ("username"))
    On Error Resume Next
    oConn.Provider = "ADsDSOObject"
    oConn.Open "Active Directory Provider"
    
    Set oCommand.ActiveConnection = oConn
    
    oCommand.Properties("Page Size") = 1000
    'Set to 2 for ADS_SCOPE_SUBTREE
    oCommand.Properties("Searchscope") = 2
    oCommand.CommandText = "SELECT department FROM 'LDAP://dc=usa,dc=doj,dc=gov' " & _
         "WHERE objectCategory='user' " & "AND sAMAccountName='" & userName & "'"
    Set oRecordSet = oCommand.Execute
    If Err.Number = 0 Then
      oRecordSet.MoveFirst
      strReturnVal = Trim(UCase(oRecordSet.Fields("department").value))
    Else
      strReturnVal = vbNullString
    End If
    Err.Clear
    On Error GoTo 0
  End If

  Set oConn = Nothing
  Set oCommand = Nothing
  Set oRecordSet = Nothing
  fcnGetUserDistrict = strReturnVal
lbl_Exit:
  Exit Function
End Function
Function fcnCreateFolder(folderSpec)
'Recursive Function to Create a directory structure or single folder.
'Parameters folderSpec   -> Path of folder\folders to create.
'Return     : fcnCreateFolder -> Returns True if the directory structure was successfully created otherwise returns False.
'----------------------------------------------------------------------------------------------------------------------------
Dim objFSO As FileSystemObject
  Set objFSO = CreateObject("Scripting.FileSystemObject")
  fcnCreateFolder = False
  If Not objFSO.FolderExists(folderSpec) Then
    If InStrRev(folderSpec, "\") <> 0 Then
      If Not fcnCreateFolder(Left(folderSpec, InStrRev(folderSpec, "\") - 1)) Then
        Exit Function
      End If
    End If
    On Error Resume Next
    objFSO.CreateFolder folderSpec
    If Err.Number <> 0 Then
      Exit Function
    End If
    On Error GoTo 0
  End If
  fcnCreateFolder = True
  Set objFSO = Nothing
lbl_Exit:
  Exit Function
End Function

Sub SaveToPersonalTemplatePath()
  Dim savePath As String: savePath = p_PersonalTemplatesPath

  ' Add trailing slash
  If Right(savePath, 1) <> "\" Then
      savePath = savePath & "\"
  End If
  
  With Dialogs(wdDialogFileSaveAs)
    .Name = savePath & ActiveDocument.Name
    .Show
  End With
  
  p_oRibbon.InvalidateControl "usao_dmPersonalTemplates"
End Sub
Public Function fcnMatchedEntry(cbo As MSForms.ComboBox) As Boolean
'Evaluates if the value of a passed combobox matches a listed entry.
  fcnMatchedEntry = True
  With cbo
    If .MatchFound = False Then
      fcnMatchedEntry = False
    End If
  End With
End Function
Sub TabNoShow()
  Dim oAI As AddIn
  DoEvents
  For Each oAI In AddIns
    Debug.Print oAI.Name
    If InStr(oAI.Name, "2a_") = 1 Then
      oAI.Installed = False
      DoEvents
      Exit For
    End If
  Next oAI
lbl_Exit:
  Exit Sub
End Sub
Sub DemoHelloWorld()
  MsgBox "Eureka!! " & Environ("username") & " you can now see how all this comes together."
End Sub
Sub TestErrors()
  modNotifyError.Notify_ShowError 1, 19
  modNotifyError.Notify_ShowError 1, 20
  modNotifyError.Notify_ShowError 1, 22

  
End Sub
Attribute VB_Name = "modMakeMultiStepDirectory"
Option Explicit
Option Compare Text
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modMakeMultiStepDirectory
' By Chip Pearson, chip@cpearson.com   www.cpearson.com
' Adapted for USAOTab AddIn by Greg Maxey
' This module contains the MakeMultiStepDirectory function that allows
' you to create an entire series of directories, creating each parent
' directory before each child directory. This works on both UNC
' and Local folder specifications. Examples:
'   MakeMultiStepDirectory "C:\One\Two\Three"
'       This will create    C:\One      then
'                           C:\One\Two  then
'                           C:\One\Two\Three
'
'   MakeMultiStepDirectory "\\BlackCow\MainShare\One\Two\Three
'       This creates    \\BlackCow\MainShare\One        then
'                       \\BlackCow\MainShare\One\Two    then
'                       \\BlackCow\MainShare\One\Two\Three
'
' If any directory already exists, it is skipped until a non-extant
' directory name is encountered.
'
' Return values:
'        ErrSuccess
'           Operation was successful.
'        ErrRelativePath
'           The input PathSpec was not an absolute path.
'        ErrInvalidPathSpecification
'           Invalid path specification.
'        ErrDirectoryCreateError
'           Error creating directory.
'        ErrSpecIsFileName
'           FileSpec is a file name, not a folder name.
'        ErrInvalidCharactersInPath
'           Invalid characters found in PathSpec.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Required Reference:
'   Name: Scripting
'   Description: Microsoft Scripting Runtime
'   Typical Location: C:\Windows\SysWOW64\scrrun.dll
'   GUID:   {420B2830-E718-11CF-893D-00A0C9054228}
'   Major: 1    Minor: 0

Private Declare Function PathIsRelative Lib "Shlwapi" _
    Alias "PathIsRelativeA" (ByVal Path As String) As Long

Public Enum EMakeDirStatus
    ErrSuccess = 0
    ErrRelativePath
    ErrInvalidPathSpecification
    ErrDirectoryCreateError
    ErrSpecIsFileName
    ErrInvalidCharactersInPath
End Enum
Const MAX_PATH = 260

Function MakeMultiStepDirectory(ByVal PathSpec As String) As EMakeDirStatus
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' MakeMultiStepDirectory
' This function creates a series of nested directories. The parent of
' every directory is create before a subdirectory is created, allowing a
' folder path specification of any number of directories (as long as the
' total length is less than MAX_PATH.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim fso As Scripting.FileSystemObject
Dim DD As Scripting.Drive
Dim b As Boolean
Dim Root As String
Dim DirSpec As String
Dim N As Long
Dim M As Long
Dim s As String
Dim Directories() As String
    
Set fso = New Scripting.FileSystemObject
    
' ensure there are no invalid characters in spec.
On Error Resume Next
Err.Clear
s = Dir(PathSpec, vbNormal)
If Err.Number <> 0 Then
    MakeMultiStepDirectory = ErrInvalidCharactersInPath
    Exit Function
End If
On Error GoTo 0

' ensure we have an absolute path
b = CBool(PathIsRelative(PathSpec))
If b = True Then
    MakeMultiStepDirectory = ErrRelativePath
    Exit Function
End If

' if the directory already exists, get out with success.
If fso.FolderExists(PathSpec) = True Then
    MakeMultiStepDirectory = ErrSuccess
    Exit Function
End If

' get rid of trailing slash
If Right(PathSpec, 1) = "\" Then
    PathSpec = Left(PathSpec, Len(PathSpec) - 1)
End If

' ensure we don't have a filename
N = InStrRev(PathSpec, "\")
M = InStrRev(PathSpec, ".")
If (N > 0) And (M > 0) Then
    If M > N Then
        ' period found after last slash
        MakeMultiStepDirectory = ErrSpecIsFileName
        Exit Function
    End If
End If
If Left(PathSpec, 2) = "\\" Then
    ' UNC -> \\Server\Share\Folder...
    N = InStr(3, PathSpec, "\")
    N = InStr(N + 1, PathSpec, "\")
    Root = Left(PathSpec, N - 1)
    DirSpec = Mid(PathSpec, N + 1)
Else
    ' Local or mapped -> C:\Folder....
    N = InStr(1, PathSpec, ":", vbBinaryCompare)
    If N = 0 Then
        MakeMultiStepDirectory = ErrInvalidPathSpecification
        Exit Function
    End If
    Root = Left(PathSpec, N)
    DirSpec = Mid(PathSpec, N + 2)
End If
On Error GoTo lbl_MissingRoot
Set DD = fso.GetDrive(Root)
Directories = Split(DirSpec, "\")
DirSpec = DD.Path
For N = LBound(Directories) To UBound(Directories)
    DirSpec = DirSpec & "\" & Directories(N)
    If fso.FolderExists(DirSpec) = False Then
        On Error Resume Next
        Err.Clear
        fso.CreateFolder (DirSpec)
        If Err.Number <> 0 Then
            MakeMultiStepDirectory = ErrDirectoryCreateError
            Exit Function
        End If
    End If
Next N
MakeMultiStepDirectory = ErrSuccess
lbl_Exit:
  Exit Function
lbl_MissingRoot:
  modNotifyError.Notify_ShowError 1, 19, , Root
  Resume lbl_Exit
End Function

Attribute VB_Name = "modNotifyError"
Option Explicit

Function Notify_ShowError(ByRef LngCaption As Long, lngErr As Long, Optional bYesNo As Boolean, Optional strText As String) As Boolean
Dim strCap As String, strMsg As String, strTemp As String
Dim arrText() As String
Dim lngFontSize As Long

Const cap1 As String = "!!USER NOTIFICATION!!"
Const cap2 As String = "!!ADMINISTRATOR ALERT!!"
  If InStr(strText, "|") > 1 Then arrText = Split(strText, "|")

  Select Case LngCaption
    Case 1: strCap = cap1
    Case 2: strCap = cap2
  End Select
  Select Case lngErr
    Case 1: strMsg = "Drive " & strText & " is not mapped on your system." & vbCr + vbCr _
                   & "This may occur when you are connnected remotely." & vbCr + vbCr _
                   & "Otherwise, please contact your system administrator."
    Case 2: strMsg = "The Active Document has not been saved." & vbCr + vbCr _
                   & "You must save this document to a network drive before you can email a link."
    Case 3: strMsg = "You can not email a link to a document stored on your local hard drive." & vbCr + vbCr _
                   & "Save the document to a network drive and try again."
    Case 4: strMsg = "There is no Active Document." & vbCr + vbCr _
                   & "You must first open a document stored on a network drive to use this feature."
    Case 5: strMsg = "Your ""Personal Templates"" folder is empty." & vbCr + vbCr _
                   & "You can add personal templates to your personal templates folder located at: " & vbCr + vbCr _
                   & Chr(34) + strText + Chr(34)
    Case 6
      strTemp = Replace(Replace(arrText(1), "dm", ""), "_", " ")
      
      strMsg = "The " & Chr(34) + strTemp + Chr(34) & " folder located at: " & vbCr + vbCr _
               & Chr(34) + arrText(0) + Chr(34) + vbCr + vbCr _
               & "is empty." & vbCr + vbCr _
               & "Please contact your district IT unit staff."
    Case 7
      strMsg = "The supporting template file for this envelope and label feature is missing or corrupt." & vbCr + vbCr _
    & "Please contact your supporting IT Unit staff."
    Case 8: strMsg = "The root path " & Chr(34) & strText & Chr(34) & vbCr _
                    & "is missing or invalid." & vbCr + vbCr _
                    & "Please contact your district IT Unit staff."
    Case 9: strMsg = "The folder name you entered is invalid." & vbCr & vbCr _
                   & "Please enter a valid folder or select a folder using the Browse\Select button."
                   
    Case 10: strMsg = "Are you sure you want to update all district user's normal.dotm files?" & vbCr & vbCr & _
         "This will change the variable in the INI file that when read by the 5200 " & _
         "startup script causes the 5200 to replace all district users' existing Normal.dotm ""blank"" document " & _
         "template with the district's baseline normal.dotm ""blank"" template as it is staged at P:\Word\NormalTemplate. " & vbCr & vbCr & _
         "The user's existing normal.dotm file is renamed using the naming convention ""Normal.dotm(1).old, Normal.dotm(2).old, " & _
         "etc.""" & vbCr + vbCr & _
         "The renamed original file can be restored or used to recover customized content as required."
    Case 11: strMsg = "Are you sure you want to update all district user's Quick Access Toolbar file?" & vbCr & vbCr & _
        "This will change the variable in the INI file that when read by the 5200 " & _
        "startup script causes the 5200 to replace all district users' Quick Access Toolbar file (word.officeui)  " & _
        "with the district's baseline QAT file as it is staged at P:\Word\QAT_Ribbon. " & vbCr & vbCr & _
        "The user's existing word.officeui file is renamed using the naming convention ""word.officeui(1).old, word.officeui(2).old, " & _
        "etc.""" & vbCr + vbCr & _
        "The renamed original file can be restored or used to recover customized content as required."
    Case 12: strMsg = strText
    Case 13: strMsg = "File failed to open." & vbCr + vbCr _
                    & "A default application could not be associated with this file." & vbCr + vbCr _
                     & "Contact your system administrator."
    Case 14: strMsg = strText
    Case 15: strMsg = strText
    Case 16: strMsg = "There is no addressee or label text defined." & vbCr + vbCr _
                    & "Please define at least one addressee or text item in the left hand side define field and add it to the right hand side list."
    Case 17: strMsg = "Nothing selected." & vbCr + vbCr _
                    & "Select an item from the right hand side list and try again."
    Case 18: strMsg = "Addressess can't be parsed from the selected text." & vbCr + vbCr _
                    & "To parse addressees from a selection of text the individual addressees must be separated with a single empty paragraph."
    Case 19: strMsg = "The root drive for the personal template folder """ & strText & """ is not available." & vbCr + vbCr _
                    & "Please contact your system administrator for assistance resolving this issue."
    Case 20: strMsg = "This symbol or feature is not available as the selection is located in a plain text content control or ohter restricted selection."
    Case 21: strMsg = "Office customization files are files located in your user profile local and remote profile ""Microsoft"" folders that store customizations that you have made in Word or other office applications." & vbCr + vbCr _
                     & "These includes:" & vbCr + vbCr _
                     & "  -Macros, styles, and page layout settings stored in your Normal.dotm template or other templates in the remote profile ""Office\Templates"" folder." & vbCr _
                     & "  -Auto Correct List files in the remote profile ""Office"" folder." & vbCr _
                     & "  -Building Block templates in the remote profile ""Document Building Blocks"" folder." & vbCr _
                     & "  -officeUI files in the local profile ""Office"" folder." & vbCr + vbCr _
                     & "These files are copied to and overwrite any existing files in your network ""N:\My Office Customizatin Files"" folder.  They can be subsequently copied to the appropriate local\remote user profile folder on a different computer or used to recover lost or damaged files on your current PC." & vbCr + vbCr _
                     & "Click ""OK"" to continue (saving files may take several seconds) or ""CANCEL"" to close this dialog with saving these files."

    
    Case 22: strMsg = "Office customization files have been backed up and saved to your ""N:\My Office Customization Files"" folder."
    
    
  End Select
  
  lngFontSize = 12
  With frmNotify
    .LBL_Err1.TextAlign = fmTextAlignCenter
    .Caption = strCap
    If bYesNo = True Then
      .CB_ErrOK.Caption = "Yes"
      .CB_ErrOK.Left = 100
      .CB_ErrOK.Width = 126
      .CBErrNo.Visible = True
    Else
      .CB_ErrOK.Caption = "OK"
      .CB_ErrOK.Left = 7.2
      .CB_ErrOK.Width = 218
      .CBErrNo.Visible = False
    End If
    Select Case lngErr
      Case 10, 11
        .LBL_Err1.Width = .LBL_Err1.Width + 190
        .LBL_Err1.Height = .LBL_Err1.Height + 100
        .CB_ErrOK.Top = .CB_ErrOK.Top + 100
        .CBErrNo.Top = .CBErrNo.Top + 100
        .Width = .Width + 190
        .Height = .Height + 100
        .CBErrNo.Width = (.Width \ 2) - 24
        .CB_ErrOK.Width = (.Width \ 2) - 16
        .CB_ErrOK.Left = .CBErrNo.Left + .CBErrNo.Width + 14
      Case 12
        .LBL_Err1.Width = .LBL_Err1.Width + 190
        .LBL_Err1.Height = .LBL_Err1.Height + 60
        .CB_ErrOK.Top = .CB_ErrOK.Top + 60
        .Width = .Width + 190
        .Height = .Height + 60
        .CB_ErrOK.Width = .Width - 16
      Case 15
        .LBL_Err1.Width = .LBL_Err1.Width + 50
        .LBL_Err1.Height = .LBL_Err1.Height + 40
        .CB_ErrOK.Top = .CB_ErrOK.Top + 40
        .CBErrNo.Top = .CBErrNo.Top + 40
        .Width = .Width + 50
        .Height = .Height + 40
        .CBErrNo.Width = (.Width \ 2) - 24
        .CB_ErrOK.Width = (.Width \ 2) - 16
        .CB_ErrOK.Left = .CBErrNo.Left + .CBErrNo.Width + 14
      Case 19
        .LBL_Err1.Width = .LBL_Err1.Width + 50
        '.LBL_Err1.Height = .LBL_Err1.Height + 20
        '.CB_ErrOK.Top = .CB_ErrOK.Top + 20
        .Width = .Width + 50
        '.Height = .Height + 20
        .CB_ErrOK.Width = .Width - 16
      Case 21
        With .LBL_Err1
          .Width = .Width + 250
          .Height = .Height + 180
          .TextAlign = fmTextAlignLeft
        End With
        .CB_ErrOK.Top = .CB_ErrOK.Top + 180
        .CBErrNo.Top = .CBErrNo.Top + 180
        .CB_ErrOK.Caption = "OK"
        .CBErrNo.Caption = "CANCEL"
        .Width = .Width + 250
        .Height = .Height + 180
        .CBErrNo.Width = (.Width \ 2) - 24
        .CB_ErrOK.Width = (.Width \ 2) - 16
        .CB_ErrOK.Left = .CBErrNo.Left + .CBErrNo.Width + 14
      End Select
    With .LBL_Err1
      .Caption = strMsg
      .Font.Name = "Tahoma"
      .Font.Size = lngFontSize
      '.Font.Bold = True
      Select Case lngErr
        Case 9999
          .ForeColor = wdColorRed
        Case Else
          .ForeColor = wdColorBlue
      End Select
      
    End With
    Beep
    .Show
    If .Tag = 1 Then
      Notify_ShowError = True
    Else
      Notify_ShowError = False
    End If
    Unload frmNotify
  End With
lbl_Exit:
  Exit Function
End Function

Sub Test()
  If modNotifyError.Notify_ShowError(1, 19) Then 'GKM
    MsgBox "Yes"
  Else
    MsgBox "No"
  End If
End Sub
Attribute VB_Name = "modOfficeBackup"
Option Explicit

Sub UserBackup()
Dim strTemplates As String
Dim strAcl As String
Dim strUI As String
Dim strBB As String
Dim oFSO As FileSystemObject
Dim oFolder As Folder, oSubFolder As Folder
Dim oFile As file
  If modNotifyError.Notify_ShowError(1, 21, True) Then
    'Do the backup folders exist? If not, create them.
    If Not modMain.fcnFileOrDirExists("N:\My MS Office Customization Files") Then fcnCreateFolder "N:\My MS Office Customization Files"
    If Not modMain.fcnFileOrDirExists("N:\My MS Office Customization Files\Templates") Then modMain.fcnCreateFolder "N:\My MS Office Customization Files\Templates"
    If Not modMain.fcnFileOrDirExists("N:\My MS Office Customization Files\Auto Correct List Files") Then modMain.fcnCreateFolder "N:\My MS Office Customization Files\Auto Correct List Files"
    If Not modMain.fcnFileOrDirExists("N:\My MS Office Customization Files\Building Blocks") Then modMain.fcnCreateFolder "N:\My MS Office Customization Files\Building Blocks"
    If Not modMain.fcnFileOrDirExists("N:\My MS Office Customization Files\UI Customization Files") Then modMain.fcnCreateFolder "N:\My MS Office Customization Files\UI Customization Files"
    
    Set oFSO = CreateObject("Scripting.FileSystemObject")
    strTemplates = Environ("appdata") & Application.PathSeparator & "Microsoft\Templates"
    If modMain.fcnFileOrDirExists(strTemplates) Then
      Set oFolder = oFSO.GetFolder(strTemplates)
      For Each oFile In oFolder.Files
        If Not InStr(oFile.Name, "~$") = 1 Then
          oFile.Copy "N:\My MS Office Customization Files\Templates\" & oFile.Name, True
        End If
      Next oFile
    Else
      MsgBox "The source folder was not found."
    End If
    strAcl = Environ("appdata") & Application.PathSeparator & "Microsoft\Office"
    If modMain.fcnFileOrDirExists(strAcl) Then
      Set oFolder = oFSO.GetFolder(strAcl)
      For Each oFile In oFolder.Files
        If oFile.Type = "AutoCorrect List File" Then
          oFile.Copy "N:\My MS Office Customization Files\Auto Correct List Files\" & oFile.Name, True
        End If
      Next oFile
    Else
      MsgBox "The source folder was not found."
    End If
    strBB = Environ("appdata") & Application.PathSeparator & "Microsoft\Document Building Blocks\1033"
    If modMain.fcnFileOrDirExists(strBB) Then
      oFSO.CopyFolder strBB, "N:\My MS Office Customization Files\Building Blocks", True
      Set oFolder = oFSO.GetFolder("N:\My MS Office Customization Files\Building Blocks")
      For Each oFile In oFolder.Files
        If InStr(oFile.Name, "~$") = 1 Then
          oFile.Delete
        End If
      Next oFile
      For Each oSubFolder In oFolder.SubFolders
        For Each oFile In oSubFolder.Files
          If InStr(oFile.Name, "~$") = 1 Then
            oFile.Delete
          End If
        Next oFile
      Next oSubFolder
    Else
      MsgBox "The source folder was not found."
    End If
    strUI = "C:\Users\" & Environ("username") & Application.PathSeparator & "AppData\Local\Microsoft\Office"
    If modMain.fcnFileOrDirExists(strUI) Then
      Set oFolder = oFSO.GetFolder(strUI)
      For Each oFile In oFolder.Files
        If oFile.Type = "OFFICEUI File" Then
          oFile.Copy "N:\My MS Office Customization Files\UI Customization Files\" & oFile.Name, True
        End If
      Next oFile
    Else
      MsgBox "The source folder was not found."
    End If
    modNotifyError.Notify_ShowError 1, 22
  End If
lbl_Exit:
  Set oFile = Nothing
  Set oFolder = Nothing
  Set oFSO = Nothing
End Sub

Attribute VB_Name = "modOutlookInterop"
Option Explicit
'This module contains procedures and functions which are associated with or require interoperability with OUTLOOK

Sub EmailIT_Help(Optional ByVal strAddress As String = vbNullString)
'Intiates a properly addressed OUTLOOK e-mail message with body content.
Dim strBody As String, strSubject As String
  'Get the address from the WordSettings INI file.
  If strAddress = vbNullString Then strAddress = p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_itHelpButtonAddress_Label")
  strSubject = "<Word> I need some help."
  strBody = "<html><body><p></p></body></html>"
  'Is a document open?
  If Documents.count > 0 Then
    'Yes, create message body text.
    strBody = fcnGenDocLinkHTML
    If strBody = vbNullString Then
      'Nothing returned so use a default string value.
      strBody = ActiveDocument.Path & ActiveDocument.Name
    End If
     'Redefine strBody in html format.
     strBody = "<html><body><p>&nbsp;</p><p>Document open at time: " & strBody & "</p>"
  End If
  'Create the e-mail.
  fcnCreateEmail strSubject, strBody, strAddress
lbl_Exit:
  Exit Sub
End Sub

Sub EmailDocLink()
'Creates a new unaddressed e-mail in OUTLOOK containing a link to file stored on a network drive.
Dim strBody As String
  If Documents.count > 0 Then
    If ActiveDocument.Path = vbNullString Then
      modNotifyError.Notify_ShowError 1, 2
      Exit Sub
    Else
      strBody = fcnGenDocLinkHTML
      'Is the document located on a network drive?
      If fcnGenDocLinkHTML <> "" Then
        strBody = "<HTML><Body><p>The following link:</p><p>" & strBody & _
          "</p><p>will only work if the recipient has access to the  place where the document is stored.</p>"
          fcnCreateEmail "Link to " & ActiveDocument.Name, strBody
      Else
        modNotifyError.Notify_ShowError 1, 3
      End If
    End If
  Else
    modNotifyError.Notify_ShowError 1, 4
  End If
lbl_Exit:
  Exit Sub
End Sub
Public Function fcnGenDocLinkHTML() As String
Dim strPathTrue As String
Dim strLinkText As String
Dim strSlash As String: strSlash = "Drive Letter"
  
  If Left(ActiveDocument.Path, 1) = "\" Then
    strPathTrue = ActiveDocument.Path & "\" & ActiveDocument.Name
    strLinkText = ActiveDocument.Path & "\" & ActiveDocument.Name
  ElseIf LCase(Left(ActiveDocument.Path, 5)) = "http:" Then
    strPathTrue = ActiveDocument.Path & "/" & ActiveDocument.Name
    strLinkText = ActiveDocument.Path & "/" & ActiveDocument.Name
  Else
    strPathTrue = GetNetworkPath(Left(ActiveDocument.Path, 2))
    If strPathTrue <> vbNullString Then
      strPathTrue = strPathTrue & Mid(ActiveDocument.Path, 3, 999999) & "\" & ActiveDocument.Name
    End If
    strLinkText = ActiveDocument.Path & "\" & ActiveDocument.Name
  End If
  If strPathTrue <> vbNullString Then
    fcnGenDocLinkHTML = "<a href=""" & strPathTrue & """>" & strLinkText & "</a>"
  End If
lbl_Exit:
  Exit Function
End Function
Public Function fcnCreateEmail(Optional eSubject As String = vbNullString, Optional eBody As String = vbNullString, _
                               Optional eTo As String, Optional eCC As String = vbNullString, _
                               Optional eBCC As String = vbNullString) As Boolean
Dim oOutlookApp As Object 'Outlook.Application
Dim oMailItem As Object 'Outlook.MailItem

  On Error Resume Next
  'Start Outlook if it isn't running
  Set oOutlookApp = GetObject(, "Outlook.Application")
  If Err <> 0 Then
    Set oOutlookApp = CreateObject("Outlook.Application")
  End If
  'Create a new message
  Set oMailItem = oOutlookApp.CreateItem(0) 'Use the constant 0 in place of the Outlook object olMailItem
  With oMailItem
    .BodyFormat = 2 'Use the constant 2 in place of the Outlook object olFormatHTML
    .Subject = eSubject
    .HTMLBody = eBody
    .To = eTo
    .cc = eCC
    .BCC = eBCC
  End With
  oMailItem.Display
  Set oMailItem = Nothing
  Set oOutlookApp = Nothing
  On Error GoTo 0
  fcnCreateEmail = (Err.Number = 0)
lbl_Exit:
  Exit Function
End Function

Public Function fcnCreateCalEvent(ByRef strEvent As String, oDateEvent As Date) As Boolean
'Purpose: Provides the interface between the DatePlus utility "Outlook Event" feature and OUTLOOK.
Dim oOutlookApp As Object 'Outlook.Application
Dim oCalEvent As Object
  On Error Resume Next
  'Start Outlook if it isn't running
  Set oOutlookApp = GetObject(, "Outlook.Application")
  If Err <> 0 Then
    Set oOutlookApp = CreateObject("Outlook.Application")
  End If
  On Error GoTo 0
  Set oCalEvent = oOutlookApp.CreateItem(1)
  With oCalEvent
    .Start = oDateEvent
    .Subject = strEvent
    .ReminderSet = True
    .BusyStatus = 0 '2 'olFree
    .AllDayEvent = True
  End With
  oCalEvent.Display
  Set oCalEvent = Nothing
  Set oOutlookApp = Nothing
  fcnCreateCalEvent = (Err.Number = 0)
  On Error GoTo 0
lbl_Exit:
  Exit Function
End Function

Public Function fcnCreateTask(ByRef strEvent As String, oStartDate As Date, oDateEvent As Date) As Boolean
'Purpose: Provides the interface between the DatePlus utility "Outlook Task" feature and OUTLOOK.
Dim oOutlookApp As Object 'Outlook.Application
Dim oTask As Object 'Outlook.TaskItem
Dim oReminderTime As Date
On Error Resume Next
  'Start Outlook if it isn't running
  Set oOutlookApp = GetObject(, "Outlook.Application")
  If Err <> 0 Then
    Set oOutlookApp = CreateObject("Outlook.Application")
  End If
  On Error GoTo 0
  Set oTask = oOutlookApp.CreateItem(3) 'olTaskItem
  oReminderTime = DateAdd("d", -3, oDateEvent)
  oReminderTime = DateAdd("h", 9, oReminderTime)
  With oTask
    .StartDate = oStartDate
    .DueDate = oDateEvent
    .Subject = strEvent
    .ReminderSet = True
    .ReminderTime = oReminderTime
  End With
  oTask.Display
  Set oTask = Nothing
  Set oOutlookApp = Nothing
  fcnCreateTask = (Err.Number = 0)
  On Error GoTo 0
lbl_Exit:
  Exit Function
End Function

Public Function GetNetworkPath(ByVal DriveName As String) As String
'Convert newwork drive letter passed to a path string.
'Input:  Drive Letter.
'Returns:  string path.
'Original from: http://www.excelfox.com/forum/f13/ _
                vba-return-unc-universal-naming-convention-path-mapped-network-drive-134/
Dim oNetwork As Object, oDrives As Object
Dim lngLoop As Long
Dim strFound As String
  Set oNetwork = CreateObject("WScript.Network")
  Set oDrives = oNetwork.enumnetworkdrives
  strFound = vbNullString
  For lngLoop = 0 To oDrives.count - 1 Step 2
    If UCase(oDrives.Item(lngLoop)) = UCase(DriveName) Then
      strFound = oDrives.Item(lngLoop + 1)
      Exit For
    End If
  Next
  GetNetworkPath = strFound
End Function

Function fcnGetOutlookMailingAddress(ByRef lngSD) As String
Dim strLayout As String
  
  strLayout = "<PR_DISPLAY_NAME_PREFIX>;" & _
              "<PR_DISPLAY_NAME>;" & _
              "<PR_TITLE>;" & _
              "<PR_DEPARTMENT_NAME>;" & _
              "<PR_COMPANY_NAME>;" & _
              "<PR_STREET_ADDRESS>;" & _
              "<PR_LOCALITY>;" & _
              "<PR_STATE_OR_PROVINCE>;" & _
              "<PR_POSTAL_CODE>;" & _
              "<PR_COUNTRY>;" & "*"
  On Error GoTo Err_Canceled
  fcnGetOutlookMailingAddress = Application.GetAddress(Name:="External Addresses", _
    useautotext:=False, AddressProperties:=strLayout, _
    DisplaySelectDialog:=True, SelectDialog:=lngSD, CheckNamesDialog:=True)
lbl_Exit:
  Exit Function
Err_Canceled:
  fcnGetOutlookMailingAddress = vbNullString
  Resume lbl_Exit:
End Function

Attribute VB_Name = "modRibbonFunctions"
Option Explicit

'These are used to parse invalid characters in file names so they can be converted and used in XML.
Private Const CRITICAL_CHARS As String = "$&+,/:;=?@ ""<>#%{}|\^~[]`"
Private Const REPLACEMENT_CODES As String = _
    "%24,%26,%2B,%2C,%2F,%3A,%3B,%3D,%3F,%40,%20,%22,%3C,%3E,%23,%25,%7B,%7D,%7C,%5C,%5E,%7E,%5B,%5D,%60"

Private Const SUPERTIP_TOO_MANY_FILES As String = _
    "The number of individual files or sub-folders in the target folder is exceeds the menu item limit of 1000." & vbCr + vbCr & _
    "Reorganizing your files into additional sub-folders may eliminate this problem."
Private Const MSG_TOO_MANY_FILES As String = _
    "The number of individual files or sub-folders in the target folder is exceeds the menu item limit of 1000.&#13;&#13;" _
  & "Reorganizing your files into additional sub-folders may eliminate this problem."
Private Const SUPERTIP_INVALID As String = _
    "The specific root path is invalid or missing.&#13;&#13;Contact your system administrator for asssistance."

Public Function fcnGenerateContent(ByRef strRootPath As String, ByRef bRefreshButton As Boolean, _
                                  ByRef strDMName As String, Optional strId As String) As String

Dim oFoldersAndFiles As clsFileDictionary
Dim oFolderOrFile As clsFolder_File
Dim lngFileCount As Long, lngMenuCount As Long
Dim strXML As String, strSize As String
Dim bFirstFile As Boolean
  bFirstFile = True
  strXML = vbNullString
  If p_colUSAOWordSettings Is Nothing Then modGlobals_Initialize.fcnInitSequence
  If CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_dmSmallItems_Visible")) Then
    strSize = "normal"
  Else
    strSize = "large"
  End If
  lngFileCount = 0
  lngMenuCount = 0

  'Open the XML string
  strXML = "<menu xmlns=""http://schemas.microsoft.com/office/2009/07/customui"" itemSize=""" & strSize & """>" & vbNewLine
  'Is the root path a valid path?
  If Not modMain.fcnFileOrDirExists(strRootPath) Then 'And Not strDMName = "dmPersonal" Then
    strXML = strXML & XMLBuild(ControlType:="button", _
               Id:="btnInvalidPath_" & "0", _
               image:="missing32", _
               label:="Invalid or missing root path", _
               Action:="modUSAO_RC.ButtonOnAction", _
               Tag:=strDMName & "|" & strRootPath, _
               screentip:="Target folder: " & strRootPath, _
               supertip:=SUPERTIP_INVALID)
    'modNotifyError.Notify_ShowError 1, 8, , strRootPath
    GoTo CloseXMLTag
  Else
    '"Refresh Button" at top of list?
    If bRefreshButton Then
      strXML = strXML & XMLBuild(ControlType:="button", _
                Id:="btnDM_" & strDMName & "-Refresh", _
                label:="Refresh Menu", _
                ImageMso:="RecurrenceEdit", _
                Tag:=strId, _
                Action:="modUSAO_RC.ButtonOnAction", _
                screentip:="Refresh Files in Directory")
      'GKM ***
      If strDMName = "dmPersonal" Then
        strXML = strXML & XMLBuild(ControlType:="button", _
                Id:="btnDM_" & strDMName & "-SaveDoc", _
                label:="Save Current Doc to Personal Templates", _
                ImageMso:="FileSave", _
                Tag:=strId, _
                Action:="modUSAO_RC.ButtonOnAction", _
                getvisible:="modUSAO_RC.GetVisible", _
                screentip:="Save the current document to the user template folder")
      End If
      If Not modMain.fcnFileOrDirExists(strRootPath) Then GoTo CloseXMLTag
    End If
    Set oFoldersAndFiles = New clsFileDictionary
    oFoldersAndFiles.includeFolders = True
    oFoldersAndFiles.Path = strRootPath
    'This is a dynamic menu that creates controls for other dynamic menus is required so "GET" only folders and files in the root folder.
    oFoldersAndFiles.getFolderContent
    'Can the control hold the content?
    If oFoldersAndFiles.count > 999 Then
      MsgBox MSG_TOO_MANY_FILES, vbOKOnly + vbInformation, "Too Many Files"
      strXML = strXML & XMLBuild(ControlType:="button", _
                 Id:="btnNoFiles" & "0", _
                 ImageMso:="MacroSecurity", _
                 label:="Folder content is too large to display", _
                 Action:="modUSAO_RC.ButtonOnAction", _
                 screentip:="Target folder: " & strRootPath, _
                 supertip:=SUPERTIP_TOO_MANY_FILES)
      GoTo CloseXMLTag
    ElseIf oFoldersAndFiles.count > 0 Then
      'Is there any content?
      For Each oFolderOrFile In oFoldersAndFiles.fileList
        'Is it a folder? If yes, then add the folder as a dynamic menu control.
        If Not oFolderOrFile.isFile Then
          If InStr(oFolderOrFile.Name, "$RECYCLE") Then GoTo NextFolder
          If InStr(oFolderOrFile.Name, "System Volume Information") Then GoTo NextFolder
          If InStr(oFolderOrFile.Name, "Temporary Internet Files") Then GoTo NextFolder
          lngMenuCount = lngMenuCount + 1
          'Is a folder icon located in the folder?  Yes, then use it.
          If modMain.fcnFileOrDirExists(oFolderOrFile.Path & "\icon.png") Then
            strXML = strXML & "<menuSeparator id=""div" & oFolderOrFile.Index & """/> " & vbNewLine & _
                       XMLBuild(ControlType:="dynamicMenu", _
                       Id:="dynMenudmSubFolder_" & lngMenuCount, _
                       label:=oFolderOrFile.Name, _
                       GetImage:="modUSAO_RC.GetImage", _
                       Content:="modUSAO_RC.GetContent", _
                       Tag:=Replace(oFolderOrFile.Path, "&", "~~"))
          Else
            'No, then use the default.
            strXML = strXML & "<menuSeparator id=""div" & oFolderOrFile.Index & """/> " & vbNewLine & _
                       XMLBuild(ControlType:="dynamicMenu", _
                       Id:="dynMenudmSubFolder_" & lngMenuCount, _
                       label:=oFolderOrFile.Name, _
                       image:="folder32", _
                       Content:="modUSAO_RC.GetContent", _
                       Tag:=Replace(oFolderOrFile.Path, "&", "~~"))
          End If
        Else
          'It is a file. Check if file is valid file.
          If fcnCheckFileType(oFolderOrFile) Then
            If bFirstFile Then
              bFirstFile = False
              strXML = strXML & "<menuSeparator id=""div" & oFolderOrFile.Index & """/> " & vbNewLine
            End If
            
            'Add the file as a ribbon button control.
            lngFileCount = lngFileCount + 1
            strXML = strXML & XMLBuild(ControlType:="button", _
                       Id:=fcnClearID("btnFileNew" & lngFileCount), _
                       label:=fcnClearNames(oFolderOrFile.Name), _
                       image:=fcnGetIconImage(oFolderOrFile.Name), _
                       Action:="modUSAO_RC.ButtonOnAction", _
                       Tag:=fcnEncodeName(oFolderOrFile.Path), _
                       screentip:="Open or create new file from template", _
                       supertip:=oFolderOrFile.Name)
          End If
        End If
NextFolder:
      Next oFolderOrFile
    End If
    'Create a "No Files" button if no folder or file controls were created.
    If lngFileCount = 0 And lngMenuCount = 0 Then
       strXML = strXML & XMLBuild(ControlType:="button", _
       Id:=fcnClearID(strDMName & "btnNoFolderOrFiles"), _
       label:="No Files or Sub-Folders Found", _
       image:="empty32", _
       Tag:=strRootPath, _
       Action:="modUSAO_RC.ButtonOnAction", _
       screentip:="There are no files or folders in the root folder" & Chr(58) & Chr(58), _
       supertip:=strRootPath)
       'Select Case strDMName
         'Case "dmPersonal"
           'modNotifyError.Notify_ShowError 1, 5, , strRootPath
         'Case "dmTemplates", "dmCivil_Pleadings", "dmCriminal_Pleadings", "dmAppellate", _
              '"dmLetters", "dmNew_Releases", "dmMemos", "dmFax_Coversheets", "dmDistrict_Links"
           'modNotifyError.Notify_ShowError 1, 6, , strRootPath & "|" & strDMName
       'End Select
    End If
  End If
CloseXMLTag:
  strXML = strXML & "</menu>"
  'Temporarily masking line breaks in supertip text.
  strXML = Replace(strXML, "&#13", "*()*")
  'Replace ampersands with XML equivelent.  This allows "&" to display in menu labels.
  strXML = Replace(strXML, "&", "&amp;&amp;")
  'Restore line breaks in supertip text.
  strXML = Replace(strXML, "*()*", "&#13")
  fcnGenerateContent = strXML
lbl_Exit:
  Set oFoldersAndFiles = Nothing
  Set oFolderOrFile = Nothing
  Exit Function
End Function


Public Function XMLBuild(ByVal ControlType As String, ByVal Id As String, _
                         ByVal label As String, Optional ByVal ImageMso As String = "", _
                         Optional ByVal image As String, _
                         Optional ByVal GetImage As String, _
                         Optional ByVal Size As String = "", _
                         Optional ByVal ItemSize As String = "", _
                         Optional ByVal Action As String = "", _
                         Optional ByVal Content As String = "", _
                         Optional ByVal Tag As String = "", _
                         Optional ByVal screentip As String = "", _
                         Optional ByVal supertip As String = "", _
                         Optional ByVal getvisible As String = "", _
                         Optional ByVal bCloseControl = "True") As String
Dim strXMLBuild As String
  
  strXMLBuild = "<" & ControlType & " " & vbNewLine & _
                "    id=""" & Id & """ " & vbNewLine & _
                "    label=""" & label & """ " & vbNewLine
  If ImageMso <> "" Then strXMLBuild = strXMLBuild & "    imageMso=""" & ImageMso & """ " & vbNewLine
  If image <> "" Then strXMLBuild = strXMLBuild & "    image=""" & image & """ " & vbNewLine
  If GetImage <> "" Then strXMLBuild = strXMLBuild & "    getImage=""" & GetImage & """ " & vbNewLine
  If Size <> "" Then strXMLBuild = strXMLBuild & "    size=""" & Size & """ " & vbNewLine
  If ItemSize <> "" Then strXMLBuild = strXMLBuild & "    itemSize=""" & ItemSize & """ " & vbNewLine
  If Action <> "" Then strXMLBuild = strXMLBuild & "    onAction=""" & Action & """ " & vbNewLine
  If Content <> "" Then strXMLBuild = strXMLBuild & "    getContent=""" & Content & """ " & vbNewLine
  If getvisible <> "" Then strXMLBuild = strXMLBuild & "    getVisible=""" & getvisible & """ " & vbNewLine
  If Tag <> "" Then strXMLBuild = strXMLBuild & "    tag=""" & Tag & """ " & vbNewLine
  If screentip <> "" Then strXMLBuild = strXMLBuild & "    screentip=""" & screentip & """ " & vbNewLine
  If supertip <> "" Then strXMLBuild = strXMLBuild & "    supertip=""" & supertip & """ " & vbNewLine
  If bCloseControl Then
    XMLBuild = strXMLBuild & "/>" & vbNewLine
  Else
    XMLBuild = strXMLBuild & ">" & vbNewLine
  End If
lbl_Exit:
  Exit Function
End Function

Sub CreateDynamicMenuContentTextFile()
Dim oFSO As Object, oTextFile As Object
Dim strXML As String

  strXML = fcnGenerateContent(p_TemplatesPath, True, "Templates")
  Debug.Print strXML
  Set oFSO = CreateObject("Scripting.FileSystemObject")
  Set oTextFile = oFSO.CreateTextFile("c:\xmlOut.xml", True)
  oTextFile.Write strXML
  oTextFile.Close
  Set oTextFile = Nothing
  Set oFSO = Nothing
lbl_Exit:
  Exit Sub
End Sub

Public Function fcnClearID(ByVal strId As String) As String
Dim oRegEx As Object
  Set oRegEx = CreateObject("VBScript.RegExp")
  oRegEx.Pattern = "[\'\&\ \\/:\*\?""<>\|,%]"
  oRegEx.Global = True
  fcnClearID = oRegEx.Replace(strId, "")
  Set oRegEx = Nothing
lbl_Exit:
  Exit Function
End Function

Public Function fcnClearNames(ByVal strName As String) As String
Dim oRegEx As Object
  Set oRegEx = CreateObject("VBScript.RegExp")
  oRegEx.Pattern = "[\'\\\/:\*\?""<>\|]" 'Keep "&" in control label.
  oRegEx.Global = True
  fcnClearNames = oRegEx.Replace(strName, "")
  Set oRegEx = Nothing
lbl_Exit:
  Exit Function
End Function

Public Function fcnEncodeName(strDataInput As String) As String
Dim varReplacements As Variant
Dim strNewData As String
Dim m_lngIndex As Long
  varReplacements = Split(REPLACEMENT_CODES, ",")
  strNewData = ""
  For m_lngIndex = 1 To Len(strDataInput)
    If InStr(CRITICAL_CHARS, Mid(strDataInput, m_lngIndex, 1)) > 0 Then
      strNewData = strNewData & varReplacements(InStr(CRITICAL_CHARS, Mid(strDataInput, m_lngIndex, 1)) - 1)
    Else
      strNewData = strNewData & Mid(strDataInput, m_lngIndex, 1)
    End If
  Next
  fcnEncodeName = strNewData
lbl_Exit:
  Exit Function
End Function

Public Function fcnDecodeName(strDataInput As String) As String
Dim varReplacements As Variant
Dim strNewData As String
Dim m_lngIndex As Long
  varReplacements = Split(REPLACEMENT_CODES, ",")
  strNewData = strDataInput
  For m_lngIndex = LBound(varReplacements) To UBound(varReplacements)
    strNewData = Replace(strNewData, varReplacements(m_lngIndex), Mid(CRITICAL_CHARS, m_lngIndex + 1, 1))
  Next
    fcnDecodeName = strNewData
lbl_Exit:
  Exit Function
End Function

Function fcnCheckFileType(ByRef oFile) As Boolean
Dim strExtension As String
  fcnCheckFileType = False
  strExtension = Right(oFile.Name, Len(oFile.Name) - InStrRev(oFile.Name, "."))
  If InStr(oFile.Name, "~") = 1 Then Exit Function
  Select Case LCase(strExtension)
  Case _
    "accdb", _
    "doc", "docm", "docx", "dot", "dotm", "dotx", _
    "frm", _
    "hda", "htm", "html", _
    "mdb", "mht", "msg", _
    "lnk", _
    "oft", _
    "pdf", "pot", "potm", "potx", _
    "ppt", "pptx", "pptm", _
    "pub", _
    "xla", "xlam", "xlm", _
    "xls", "xlsb", "xlsm", "xlsx", _
    "xlt", "xltm", "xltx", "xlw", _
    "url", _
    "website", "wpd", "wcm"
      fcnCheckFileType = True
      Exit Function
  Case Else
   'Do nothing
  End Select
lbl_Exit:
  Exit Function
End Function

Public Function fcnGetIconImage(ByRef strFileName As String) As String
Dim strExtension As String
  
  strExtension = Right(strFileName, Len(strFileName) - InStrRev(strFileName, "."))
  Select Case LCase(strExtension)
    Case "dot", "dotx", "dotm": fcnGetIconImage = "word32"
    Case "doc", "docx", "docm": fcnGetIconImage = "word32"
    Case "hda": fcnGetIconImage = "hotdocs32"
    Case "htm", "html", ".mht": fcnGetIconImage = "ie32"
    Case "mdb", "accdb": fcnGetIconImage = "access32"
    Case "msg": fcnGetIconImage = "msgIcon32"
    Case "oft": fcnGetIconImage = "msgIcon32"
    Case "pdf": fcnGetIconImage = "acrobat32"
    Case "ppt", "pptx", "pptm", "pot", "potm", "potx": fcnGetIconImage = "powerPoint32"
    Case "pub": fcnGetIconImage = "publisher32"
    Case "url", "lnk": fcnGetIconImage = "ie32"
    Case "website": fcnGetIconImage = "ie32"
    Case "wpd", "wcm", "frm": fcnGetIconImage = "wordPerfect32"
    Case "xls", "xlsx", "xlsm", "xlsb", ".xla", "xlam": fcnGetIconImage = "excel32"
    Case "xlt", "xltx", "xltm", ".xlm", ".xlw": fcnGetIconImage = "excel32"
    Case ""
    Case Else:  fcnGetIconImage = "forms32"
  End Select

End Function



Attribute VB_Name = "modSpecFolders"
Option Explicit
#If VBA7 Then
Public Declare PtrSafe Function SHGetSpecialFolderLocation _
                         Lib "shell32" (ByVal hwnd As Long, _
                                        ByVal nFolder As Long, ppidl As Long) As Long

Public Declare PtrSafe Function SHGetPathFromIDList _
                         Lib "shell32" Alias "SHGetPathFromIDListA" _
                             (ByVal pidl As Long, ByVal pszPath As String) As Long

Public Declare PtrSafe Sub CoTaskMemFree Lib "ole32" (ByVal pvoid As Long)
#Else
Public Declare Function SHGetSpecialFolderLocation _
                         Lib "shell32" (ByVal hwnd As Long, _
                                        ByVal nFolder As Long, ppidl As Long) As Long

Public Declare Function SHGetPathFromIDList _
                         Lib "shell32" Alias "SHGetPathFromIDListA" _
                             (ByVal pidl As Long, ByVal pszPath As String) As Long

Public Declare Sub CoTaskMemFree Lib "ole32" (ByVal pvoid As Long)
#End If

Public Const CSIDL_WINDOWS = &H24
Public Const CSIDL_MYPICTURES = &H27
Public Const CSIDL_PERSONAL = &H5
Public Const MAX_PATH = 260
Public Const NOERROR = 0
Public Function SpecFolder(ByVal lngFolder As Long) As String
Dim lngPidlFound As Long
Dim lngFolderFound As Long
Dim lngPidl As Long
Dim strPath As String

  strPath = Space(MAX_PATH)
  lngPidlFound = SHGetSpecialFolderLocation(0, lngFolder, lngPidl)
  If lngPidlFound = NOERROR Then
      lngFolderFound = SHGetPathFromIDList(lngPidl, strPath)
      If lngFolderFound Then
          SpecFolder = Left$(strPath, InStr(1, strPath, vbNullChar) - 1)
      End If
  End If
  CoTaskMemFree lngPidl
lbl_Exit:
  Exit Function
End Function

Attribute VB_Name = "modTrustedLocations"
Option Explicit
Public Function fcnSetTrustedLocations(ByRef colTrustedLocs As clsINI_LineItems) As Boolean
'Sets Word's Trusted Locations as defined in the WordSettingsINI file.
'Input:  A collections of trusted locations.
Dim strPath As String
Dim lngFoundLoc As Long
Dim oTrustedLoc As clsINI_LineItem

  For Each oTrustedLoc In colTrustedLocs.Items
    lngFoundLoc = fcnChkforTrustedLocation(oTrustedLoc.value)
    If lngFoundLoc > -1 Then
      CreateRegKey "Software\Microsoft\Office\" & Application.Version _
                   & "\Word\Security\Trusted Locations\Location" & CStr(lngFoundLoc)
      WriteReg "HKCU\Software\Microsoft\Office\" & Application.Version _
                   & "\Word\Security\Trusted Locations\Location" & CStr(lngFoundLoc) _
                   & "\Path", oTrustedLoc.value, "REG_SZ"
      WriteReg "HKCU\Software\Microsoft\Office\" & Application.Version _
                   & "\Word\Security\Trusted Locations\Location" & CStr(lngFoundLoc) _
                   & "\Description", oTrustedLoc.key & " user setting.", "REG_SZ"
      WriteReg "HKCU\Software\Microsoft\Office\" & Application.Version _
                   & "\Word\Security\Trusted Locations\Location" & CStr(lngFoundLoc) _
                   & "\AllowSubfolders", "1", "REG_DWORD"
    End If
  Next
  Set oTrustedLoc = Nothing
lbl_Exit:
  Exit Function
End Function

Public Function fcnListTrustedLocations(ByRef colTrustedLocs As clsINI_LineItems) As String
'Lists the Trusted Locations defined in the WordSettings INI file.
'Input:  A collections of trusted locations.
'Return: A string output to the list of Trusted Locations text field on the AdminForm
Dim strReturn As String
Dim oTrustedLoc As clsINI_LineItem
  strReturn = vbNullString
  For Each oTrustedLoc In colTrustedLocs.Items
    strReturn = strReturn & oTrustedLoc.value & vbCrLf
  Next
  Set oTrustedLoc = Nothing
  fcnListTrustedLocations = Trim(strReturn)
lbl_Exit:
  Exit Function
End Function

Private Function fcnChkforTrustedLocation(ByRef strPathToCheck As String) As Long
'Returns location -1 if trusted location is found.
'Otherwise, returns first available space for a new trusted location.
Dim lngLocCount As Long
Dim strCurRPath As String
Dim bFound As Boolean
  
  bFound = False
  lngLocCount = 0
  Do While RegKeyExists("Software\Microsoft\Office\" & Application.Version _
                        & "\Word\Security\Trusted Locations\Location" & CStr(lngLocCount), "Path")
    strCurRPath = ReadRegistry("Software\Microsoft\Office\" & Application.Version _
                             & "\Word\Security\Trusted Locations\Location" & CStr(lngLocCount), "Path")
    If LCase(strCurRPath) = LCase(strPathToCheck) Then
      bFound = True
      Exit Do
    End If
    lngLocCount = lngLocCount + 1
  Loop
  If bFound Then
    fcnChkforTrustedLocation = -1
  Else
    fcnChkforTrustedLocation = lngLocCount
  End If
lbl_Exit:
  Exit Function
End Function

Private Function RegKeyExists(ByVal strKeyPath As String, ByVal strValueName As String) As Boolean
'* Moss, Jim
'* Returns true if registry key exists
'* Edited for VBA by JSJB
  If IsNull(ReadRegistry(strKeyPath, strValueName)) Then
    RegKeyExists = False
  Else
    RegKeyExists = True
  End If
lbl_Exit:
  Exit Function
End Function

Private Function ReadRegistry(ByVal strKeyPath As String, ByVal strValueName As String) As Variant
'* Moss, Jim
'* returns value from specified registry key as a string if the value exists, null otherwise
'* Edited for VBA by JSJB

Dim varValue As Variant
Dim oReg As Object
    
  Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
  oReg.GetStringValue HKEY_CURRENT_USER, strKeyPath, strValueName, varValue
  Set oReg = Nothing
  ReadRegistry = varValue
lbl_Exit:
  Exit Function
End Function

Private Function CreateRegKey(strKeyPath As String)
'* Moss, Jim
'* Creates the registry key if the entry does not exist
'* Adapted for VBA by JSJB
Dim oReg As Object
  Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
  oReg.CreateKey HKEY_CURRENT_USER, strKeyPath
  Set oReg = Nothing
lbl_Exit:
  Exit Function
End Function

Private Function WriteReg(ByVal strRegPath As String, ByVal strValue As String, ByVal strRegType As String) As String
'* Tom Cook
'* Write Registry strValue
'* HKEY_CURRENT_USER = HKCU
'* HKEY_LOCAL_MACHINE = HKLM
'* HKEY_CLASSES_ROOT = HKCR
'* HKEY_USERS = HKEY_USERS
'* HKEY_CURRENT_CONFIG = HKEY_CURRENT_CONFIG
'* Returns written or modified key
'* Adapted for VBA by JSJB
'strRegType should be "REG_SZ for string, "REG_DWORD for a Long,
'REG_BINARY for a binary or boolean, and "REG_EXPAND_SZ for an expandable string
Dim oRegistry As Object
Dim strKey As String
    
  Set oRegistry = CreateObject("Wscript.shell")
  strKey = oRegistry.RegWrite(strRegPath, strValue, strRegType)
  WriteReg = strKey
  Set oRegistry = Nothing
lbl_Exit:
  Exit Function
End Function

Attribute VB_Name = "modUSAO_RC"
Option Explicit
Public p_ThisApp As clsThisApp
Public p_LastDocClosing As Boolean
Public p_oRibbon As IRibbonUI
Private m_InitializationError As Boolean '*** Added GKM


Sub Onload(ribbon As IRibbonUI)
Dim bNoTab As Boolean
  m_InitializationError = False
  InitiateAppClass
  Set p_oRibbon = ribbon
  modGlobals_Initialize.fcnInitSequence
  DoEvents
  bNoTab = Not CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_tabUSAO" & "_Visible"))
  If bNoTab Then
    Application.OnTime When:=Now + TimeValue("00:00:01"), Name:="modMain.TabNoShow"
    Exit Sub
  End If
  fcnSetTrustedLocations p_colUSAOWordSettings.getSection("word trusted locations")
lbl_Exit:
  Exit Sub
End Sub

Public Sub InitiateAppClass()
  Set p_ThisApp = Nothing
  Set p_ThisApp = New clsThisApp
lbl_Exit:
  Exit Sub
End Sub

Sub GetContent(Control As IRibbonControl, ByRef Content)
  'Callback for GetContent to return XML used to create dynamicMenu.
  'Passes root path, True for False for "Refresh Button" on menu, and an identifier.
  Select Case Control.Tag
    Case "dmTemplates": Content = modRibbonFunctions.fcnGenerateContent(p_TemplatesPath, False, Control.Tag, Control.Id)
    Case "dmCivil_Pleadings": Content = modRibbonFunctions.fcnGenerateContent(p_CivilPleadingsPath, False, Control.Tag, Control.Id)
    Case "dmCriminal_Pleadings": Content = modRibbonFunctions.fcnGenerateContent(p_CriminalPleadingsPath, False, Control.Tag, Control.Id)
    Case "dmAppellate": Content = modRibbonFunctions.fcnGenerateContent(p_AppellatePath, False, Control.Tag, Control.Id)
    Case "dmLetters": Content = modRibbonFunctions.fcnGenerateContent(p_LettersPath, False, Control.Tag, Control.Id)
    Case "dmMemos": Content = modRibbonFunctions.fcnGenerateContent(p_MemosPath, False, Control.Tag, Control.Id)
    Case "dmNews_Releases": Content = modRibbonFunctions.fcnGenerateContent(p_NewsReleasePath, False, Control.Tag, Control.Id)
    Case "dmFax_Coversheets": Content = modRibbonFunctions.fcnGenerateContent(p_FaxCSPath, False, Control.Tag, Control.Id)
    Case "dmPersonal"
          If Not modMain.fcnFileOrDirExists(p_PersonalTemplatesPath) Then
            modMakeMultiStepDirectory.MakeMultiStepDirectory p_PersonalTemplatesPath
          End If
          Content = modRibbonFunctions.fcnGenerateContent(p_PersonalTemplatesPath, True, Control.Tag, Control.Id)
    Case "dmDistrict_Links": Content = modRibbonFunctions.fcnGenerateContent(p_DistrictLinksPath, False, Control.Tag, Control.Id)
    Case Else
      'In this add-in this condidtion represents a dymnamically created dynamic sub-menu.
      Select Case Left(Control.Id, 7)
        Case "dynMenu"
          Content = modRibbonFunctions.fcnGenerateContent(Replace(Control.Tag, "~~", "&"), False, Control.Tag)
      End Select
  End Select
lbl_Exit:
  Exit Sub
End Sub
Sub GetEnabled(Control As IRibbonControl, ByRef returnedVal)
  Select Case Control.Id
   Case "usao_galSymbols", "usao_btnWatermark"
    If Documents.count > 0 Then
      returnedVal = True
    Else
      returnedVal = False
    End If
'  Case "usao_dmPersonalTemplates"
'    If p_PersTempRootAvail Then
'      returnedVal = True
'    Else
'      returnedVal = False
'    End If
  End Select
lbl_Exit:
  Exit Sub
End Sub

Sub getvisible(Control As IRibbonControl, ByRef returnedVal)
  'Check INI values
  On Error GoTo Err_NoKey
  Select Case Control.Id
   
    Case "usao_grpAdmin"
      'Show the admin button IFF the user is an admin.
      returnedVal = p_IsUserAdmin
    
    Case "usao_btnEnvelopesLabels"
      'Show if not admin, the folder existis, and the button getVisible attribute is true.
      returnedVal = CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", Control.Id & "_Visible")) _
                    And modMain.fcnFileOrDirExists(p_EnvsAndLblsPath) And Not (p_IsUserAdmin)
    Case "usao_tabUSAO"
      'Show if admin, or the tab getVisible attribute is true.
      returnedVal = CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", Control.Id & "_Visible")) Or p_IsUserAdmin
'      '*** Added GKM
'      If m_InitializationError Then
'        returnedVal = False
'      End If
    Case "btnDM_dmPersonal-SaveDoc"
      If Documents.count > 0 Then
        returnedVal = True
      Else
        returnedVal = False
      End If
    Case Else
     'Show if not admin and control getVisible attribute set to True.
     returnedVal = Not (p_IsUserAdmin) And CBool(p_colUSAOWordSettings.getKeyValue("word ribbon settings", Control.Id & "_Visible"))
  End Select
  On Error Resume Next
lbl_Exit:
  Exit Sub
Err_NoKey:
  returnedVal = True
  Resume lbl_Exit
End Sub

Sub GalleryOnAction(Control As IRibbonControl, selectedID As String, selectedIndex As Integer)
  Dim strFontName As String
  Select Case Control.Id
    Case "usao_galSymbols"
      If Documents.count = 0 Then Documents.Add
      strFontName = ActiveDocument.Styles("Normal").Font.Name
      On Error GoTo Err_Restricted
      Select Case selectedIndex
        Case 0
          modMain.InsertSymbols strFontName, 162
        Case 1
          modMain.InsertSymbols "Wingdings", -3842, True
        Case 2
          Selection.FormFields.Add Range:=Selection.Range, Type:=wdFieldFormCheckBox
        Case 3
          modMain.InsertSymbols strFontName, 169
        Case 4
          modMain.InsertSymbols strFontName, 176
        Case 5
          modMain.InsertSymbols strFontName, 8211, True
        Case 6
          modMain.InsertSymbols strFontName, 8364, True
        Case 7
          modMain.InsertSymbols strFontName, 182
        Case 8
          modMain.InsertSymbols strFontName, 174
        Case 9
          modMain.InsertSymbols strFontName, 8226, True
        Case 10
          modMain.InsertSymbols strFontName, 167
        Case 11
          modMain.InsertSymbols strFontName, 167
          modMain.InsertSymbols strFontName, 167
        Case 12
          modMain.InsertSymbols strFontName, 9786, True
        Case 13
          modMain.InsertSymbols strFontName, 9642, True
        Case 14
          modMain.InsertSymbols strFontName, 126
        Case 15
          modMain.InsertSymbols strFontName, 8482, True
        Case 16
          modMain.InsertSymbols "Wingdings 2", -4012, True
        Case 17
          CommandBars.ExecuteMso ("SymbolsDialog")
      End Select
    Case Else
     'Do nothing
  End Select
lbl_Exit:
  Exit Sub
Err_Restricted:
  modNotifyError.Notify_ShowError 1, 20
End Sub

Sub ButtonOnAction(Control As IRibbonControl)
Dim strDummy As String
Dim arrString() As String, strPath As String
  Select Case Control.Id
    'Add-Ins Tab
    Case "usao_btnInfo"
      modMain.fcnBrowseTo "http://usanetsp.usa.doj.gov/word/Pages/MacroDepot.aspx", True, False
    'Templates Group
    Case "usao_btnBlankDocument": Documents.Add
    Case "usao_btnEnvelopesLabels": modEnvsAndLbls.CreateEnvelops_Labels
    Case "btnDM_dmPersonal-SaveDoc": modMain.SaveToPersonalTemplatePath
    'Folders Group
    Case "usao_btnNDrive": modMain.fcnGetDrive Control.Tag
    Case "usao_btnLDrive": modMain.fcnGetDrive Control.Tag
    Case "usao_btnMDrive": modMain.fcnGetDrive Control.Tag
    Case "usao_btnSDrive": modMain.fcnGetDrive Control.Tag
    Case "usao_btnCustomDrive1": modMain.fcnGetDrive Control.Tag
    Case "usao_btnCustomDrive2": modMain.fcnGetDrive Control.Tag
    Case "dmLettersbtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|Letters"
    Case "dmMemosbtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|Memos"
    Case "dmFax_CoversheetsbtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|Fax Coversheets"
    Case "dmNew_ReleasesNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|New Releases"
    Case "dmAppellatebtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|Appellate"
    Case "dmCivil_PleadingsbtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|Civil Pleadings"
    Case "dmCriminal_PleadingsbtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|Criminal Pleading"
    Case "dmDistrict_LinksbtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 6, , Control.Tag & "|District Links"
    Case "dmPersonalbtnNoFolderOrFiles": modNotifyError.Notify_ShowError 1, 5, , Control.Tag
    Case "btnInvalidPath_0"
      arrString = Split(Control.Tag, "|")
      strPath = arrString(1)
      modNotifyError.Notify_ShowError 1, 8, , strPath
    'Content Group
    Case "usao_btnDatePlus": modMain.InsertDateOffet
    Case "usao_btnWatermark": modDocStamps.CallStampStamp
    Case "usao_btnUSAOKeyboardShortcuts": modKeyBoardShortCuts.ShowKeyboard

    'Tools Group
    
        
    'Searches
    Case "usao_btnSearchLexis": modMain.fcnSearchInternet Control.Id
    Case "usao_btnSearchLexisWeb": modMain.fcnSearchInternet Control.Id
    Case "usao_btnSearchWestlaw": modMain.fcnSearchInternet Control.Id
    Case "usao_btnSearchGoogle": modMain.fcnSearchInternet Control.Id
    Case "usao_btnSearchGoogleScholar": modMain.fcnSearchInternet Control.Id
    Case "usao_btnSearchBing": modMain.fcnSearchInternet Control.Id
    Case "usao_btnSearchYahoo": modMain.fcnSearchInternet Control.Id
    
    'Other
    Case "usao_btnCalculator": modMain.ShowWindowsCalculator
    Case "usao_btnPrintFileList": modFileList.ListFolder
    Case "usao_btnEmailDocLink": modOutlookInterop.EmailDocLink
    Case "usao_btnQVP": modMain.OpenQVPlus
    Case "usao_btnOFBU": modOfficeBackup.UserBackup
    
    'Links Group
    Case "usao_btnDistrictIntranet": modMain.fcnBrowseTo p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_districtIntranetButtonAddress_Label"), True, False
    Case "usao_btnLyndaWeb": modMain.fcnBrowseTo "http://www.lynda.com", True, False
    Case "usao_btnLyndaRequest": modMain.fcnEmail "matthew.mills@usdoj.gov", _
            "Lynda Access Request", _
            "I would like to request access to lynda.com.", _
            False
    Case "usao_btnLyndaWord0": modMain.fcnBrowseTo "http://usanetsp.usa.doj.gov/word/Lynda%20Learning/Forms/AllItems.aspx", True, False
    Case "usao_btnLyndaWord1": modMain.fcnBrowseTo "https://www.lynda.com/Word-tutorials/Word-2016-Essential-Training/378044-2.html", True, False
    Case "usao_btnLyndaWord2": modMain.fcnBrowseTo "http://www.lynda.com/Word-tutorials/Applying-themes-Quick-Styles-document/378044/432798-4.html", True, False
    Case "usao_btnLyndaWord3": modMain.fcnBrowseTo "http://www.lynda.com/Word-Online-tutorials/Creating-simple-letter-Mail-Merge/417092/475029-4.html", True, False
    Case "usao_btnLyndaWord4": modMain.fcnBrowseTo "http://www.lynda.com/Word-tutorials/Up-Running-Word-2016/388127-2.html", True, False
    Case "usao_btnLyndaWord5": modMain.fcnBrowseTo "http://www.lynda.com/Word-tutorials/Using-building-blocks/378044/432832-4.html", True, False
    Case "usao_btnLyndaWord6": modMain.fcnBrowseTo "http://www.lynda.com/Office-365-tutorials/Forms-Depth-Word-2016/417091-2.html", True, False
    Case "usao_btnLyndaWord7": modMain.fcnBrowseTo "http://www.lynda.com/Word-Online-tutorials/Mail-Merge-Depth-Word-2016/417092-2.html", True, False
    Case "usao_btnLyndaWord8": modMain.fcnBrowseTo "http://www.lynda.com/Office-tutorials/Office-2016-Office-365-New-Features/378455-2.html", True, False
    Case "customButton": modMain.DemoHelloWorld 'Added for 1a IdQ testing. GKM
    Case "usao_btnITHelp":
      strDummy = p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_itHelpButtonAddress_Label")
      If (LCase(p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_btnITHelpMailOrWeb")) = "email") Or (InStr(1, strDummy, "@") > 0) Then
        modOutlookInterop.EmailIT_Help (strDummy)
      Else
        modMain.fcnBrowseTo strDummy, True, False
      End If
    Case "usao_btnSetup": modMain.ShowAdminSetup
    Case Else
      If Right(Control.Id, 8) = "-Refresh" And Left(Control.Id, 6) = "btnDM_" Then
         p_oRibbon.InvalidateControl Control.Tag
      Else
        'A document or template control
        If Left$(Control.Id, Len("btnFileNew")) = "btnFileNew" Then modBuildDocs.BuildDocFromControlTab fcnDecodeName(Control.Tag), False
      End If
    End Select
lbl_Exit:
  Exit Sub
End Sub

Sub GetSize(Control As IRibbonControl, ByRef returnedVal)
  returnedVal = "large"
lbl_Exit:
  Exit Sub
End Sub

Sub GetImage(Control As IRibbonControl, ByRef returnedVal)
Dim oRng As Word.Range
Dim oImage As Object
  Select Case Control.Id
    Case "Grp2TB1"
      On Error GoTo Err_NoField
      Set oRng = ActiveDocument.Sections(1).Headers(wdHeaderFooterFirstPage).Range
        If InStr(oRng.Fields(1).Code, "LH_Logo") = 0 Then
          returnedVal = "PhotoAlbumInsert"
        Else
          returnedVal = "DeclineInvitation"
        End If
    Case "dmTemplates":  returnedVal = "FileSaveAsWordDotx"
    Case Else
      'It must be a dynamic menu folder.
        Set oImage = modLoadPictureGDI.LoadPictureGDI(Control.Tag & "\icon.png")
        Set returnedVal = oImage
        Set oImage = Nothing
  End Select
lbl_Exit:
  Exit Sub
Err_NoField:
  returnedVal = "PhotoAlbumInsert"
  Resume lbl_Exit
End Sub

Sub GetLabel(ByVal Control As IRibbonControl, ByRef label)
Dim lngTry As Long
  'Check INI values
  On Error GoTo Err_NoKey
Retry:
  label = p_colUSAOWordSettings.getKeyValue("word ribbon settings", Control.Id & "_Label")
  On Error GoTo 0
Err_NoKeyReEntry:
lbl_Exit:
  Exit Sub
Err_NoKey:
  lngTry = lngTry + 1
  If lngTry = 1 Then
    modGlobals_Initialize.fcnInitSequence
    Resume Retry
  Else
    label = "No label"
    Resume lbl_Exit
  End If
End Sub

Sub GetPressed(Control As IRibbonControl, ByRef state)
Dim oRng As Word.Range
  Select Case Control.Id
    Case "Grp2TB1"
      On Error GoTo Err_NoField
      Set oRng = ActiveDocument.Sections(1).Headers(wdHeaderFooterFirstPage).Range
        If InStr(oRng.Fields(1).Code, "LH_Logo") = 0 Then
          state = False
        Else
          state = True
        End If
    Case Else
      'Do nothing
  End Select
lbl_Exit:
  Exit Sub
Err_NoField:
  state = False
  Resume lbl_Exit
End Sub

Sub GetScreenTip(Control As IRibbonControl, ByRef screentip)
  Select Case Control.Id
    Case "usao_btnBlankDocument": screentip = "New Blank Document"
    Case "usao_dmDistrictTemplates": screentip = "District Templates Menu"
    Case "usao_menuPleadings": screentip = "Pleadings Menu"
    Case "usao_dmCivilPleadings":  screentip = "Civil Pleadings"
    Case "usao_dmCriminalPleadings": screentip = "Criminal Pleadings"
    Case "usao_dmAppellate": screentip = "Appellate Menu"
    Case "usao_dmLetters": screentip = "Letters Menu"
    Case "usao_dmMemos": screentip = "Memos Menu"
    Case "usao_dmNewsRelease": screentip = "News Release Menu"
    Case "usao_dmFax": screentip = "Fax Templates Menu"
    Case "usao_dmPersonalTemplates": screentip = "Personal Templates Menu"
    Case "usao_btnEnvelopesLabels": screentip = "Create Envelopes or Labels"
    Case "usao_btnNDrive": screentip = "Open N Drive"
    Case "usao_btnLDrive": screentip = "Open L Drive"
    Case "usao_btnMDrive": screentip = "Open M Drive"
    Case "usao_btnSDrive": screentip = "Open S Drive"
    Case "usao_btnCustomDrive1": screentip = "Open Network Folder"
    Case "usao_btnCustomDrive2": screentip = "Open Network Folder"
    Case "usao_btnUSAOKeyboardShortcuts": screentip = "USAO Keyboard Shortcuts"
    Case "usao_btnDatePlus": screentip = "DatePlus Date Calculator"
    Case "usao_btnWatermark": screentip = "Add Watermark to Document"
    Case "usao_galSymbols": screentip = "Menu of Common Symbols"
    Case "usao_btnQVP": screentip = "Opens Quick View Plus"
    Case "usao_btnOFBU": screentip = "Saves Office Customization files"
    Case "usao_menuSearchInternet": screentip = "Select a Search Engine"
    Case "usao_btnPrintFileList": screentip = "Create File List"
    Case "usao_btnEmailDocLink": screentip = "Email Document Link"
    Case "usao_btnCalculator": screentip = "Displays the Windows Calculator"
    Case "usao_btnDistrictIntranet": screentip = "District Intranet / SharePoint"
    Case "usao_menuTrainingVideos": screentip = "Word Training Videos"
    Case "usao_btnITHelp": screentip = "IT Help"
    Case "usao_dmDistrictLinks": screentip = "District Links"
    Case "usao_btnSetup": screentip = "USATab Administration Form"
    Case "usao_CCMapTool": screentip = "Content Control Mapping Tool Add-in"
    Case Else: screentip = " "
  End Select
lbl_Exit:
  Exit Sub
End Sub

Sub GetSuperTip(Control As IRibbonControl, ByRef supertip)
  Select Case Control.Id
    Case "usao_btnBlankDocument"
      supertip = "Create a new blank document using your default Normal template."
    Case "usao_dmDistrictTemplates"
      supertip = "Lists files available in your district's template folder." & vbCr + vbCr _
               & "Click on a file to use it."
     Case "usao_menuPleadings"
       supertip = "List of  your district's Civil and Criminal pleadings." & vbCr + vbCr _
               & "Click on a file to use it."
    Case "usao_dmCivilPleadings"
      supertip = "Civil Pleadings"
    Case "usao_dmCriminalPleadings"
      supertip = "Criminal Pleadings"
    Case "usao_dmAppellate"
       supertip = "List of your district's Appellate pleadings." & vbCr + vbCr _
               & "Click on a file to use it."
   Case "usao_dmLetters"
      supertip = "List of your district's Letter templates." & vbCr + vbCr _
               & "Click on a file to use it."
    Case "usao_dmMemos"
      supertip = "List of your district's Memorandum templates." & vbCr + vbCr _
               & "Click on a file to use it."
    Case "usao_dmNewsRelease"
      supertip = "List of your district's News Release templates." & vbCr + vbCr _
               & "Click on a file to use it."
    Case "usao_dmFax"
      supertip = "List of your district's Fax templates." & vbCr + vbCr _
               & "Click on a file to use it."
    Case "usao_dmPersonalTemplates"
      supertip = p_colUSAOWordSettings.getKeyValue("word ribbon settings", "usao_personalTemplatesPath_Label")
      If supertip = vbNullString Then
        supertip = "Please contact your district's IT support staff to make this button work."
      Else
       supertip = "This menu lists certain types of files stored in '" & supertip & "'.  " & vbCr + vbCr _
               & "Click on a file to use it.  If you delete or add files to the folder, " _
               & "you can click 'Refresh Menu' to see the updated files." & vbCr + vbCr _
               & "Contact your district IT Unit staff for additional information."
      End If
    Case "usao_btnEnvelopesLabels"
      supertip = "Common envelope and label templates to make mailings easy." & vbCr + vbCr _
                & "Contact your district IT Unit staff if there is a label you would like to see added."
    Case "usao_btnNDrive"
      supertip = "This is where you store most of your documents."
    Case "usao_btnLDrive"
      supertip = "From the L drive you can view yours and others N drives."
    Case "usao_btnMDrive"
       supertip = "Documents scanned at copiers are stored in this folder."
    Case "usao_btnSDrive"
      supertip = "This is the office common space."
    Case "usao_btnCustomDrive1"
      supertip = " "
    Case "usao_btnCustomDrive2"
      supertip = " "
    Case "usao_btnUSAOKeyboardShortcuts"
      supertip = "Lists USAO keyboard shortcuts. Simply click the link to use."
    Case "usao_btnDatePlus"
      supertip = "Set a start date and calculate an upcoming or past date." & vbCr + vbCr _
               & "Then, insert the date in your document or create an Outlook Task or Calendar Event."
    Case "usao_btnWatermark"
      supertip = "Easily insert a watermark."
    Case "usao_galSymbols"
      supertip = "Opens custom symbol gallery."
    Case "usao_btnQVP"
      supertip = "Quick View Plus is an aid for retrieving Word Perfect format text." & vbCr + vbCr _
                & "Open the Word Perfect document using Quick View Plus and then copy and paste text into your Word document."
    Case "usao_menuSearchInternet"
      supertip = "Opens the selected search site.  If text is highlighted, a search is performed using that text."
    Case "usao_btnPrintFileList"
      supertip = "Creates an index or file listing of all the files in a given directory and subdirectories."
    Case "usao_btnEmailDocLink"
      supertip = "Opens a new message in Outlook with a hyperlink to open this document." & vbCr + vbCr _
      & "NOTE: The link will only work if the recipient is a USAO employee AND has access to the network location."
    Case "usao_btnCalculator"
      supertip = "Open the windows built-in calculator."
    Case "usao_btnOFBU"
      supertip = "Saves files located in local and remote user profile folders which store the custimations you have made in Word and other office applications to your network ""N:\My Office Customization Files"" drive." & vbCr + vbCr _
               & "These include: " & vbCr + vbCr _
               & "  -Templates (e.g., Normal.dotm) located in the remote profile templates folder." & vbCr _
               & "  -Auto Correct List files located in the remote profile office folder." & vbCr _
               & "  -Building block templates located in the remote profile document building blocks folder." & vbCr _
               & "  -officeUI files (i.e., files that store your ribbon and QAT customizations) located in the local profile office folder." & vbCr + vbCr _
               & "These files can be subsequently copied to the appropriate local\remote user profile folder on a different computer or used to recover lost or damaged files on your current PC."
    Case "usao_btnDistrictIntranet"
      supertip = " "
    Case "usao_menuTrainingVideos"
      supertip = "Lynda.Com Word Training Videos."
    Case "usao_btnITHelp"
      supertip = "Contact your IT Support Staff for assistance."
    Case "usao_dmDistrictLinks"
      supertip = " "
    Case "usao_btnSetup"
      supertip = "NOTE: Changes made will affect your entire district. Please refer to the USATab Tech Bulletin."
    Case "usao_CCMapTool"
      supertip = "Used to create advanced content controls easily for dates, names, etc that support multiple instances in your document and update in real-time."
    Case Else: supertip = " "
  End Select
lbl_Exit:
  Exit Sub
End Sub























Attribute VB_Name = "modVersioning"
Option Explicit

'Display Version number, lastupdated by, and last save date upon opening 2a
Sub AutoOpen()
    On Error Resume Next
    ActiveDocument.Variables.Add Name:="varVersion", value:="0.0"
        
    MsgBox "USATab Version: " & ActiveDocument.Variables("varVersion") & vbCr + vbCr & "Last Modified by: " & ActiveDocument.BuiltInDocumentProperties("Last author").value & vbCr + vbCr & "Date: " & Format(ActiveDocument.BuiltInDocumentProperties("Last save time").value, "dd MMMM yyyy")
End Sub

'Ask if user wants to update version number upon exiting
Sub AutoClose()
Dim strCurrentVersion As String
Dim strNewVersion As String

  If Not InStr(ActiveDocument.Name, "2a_USAO") = 1 Then Exit Sub
    If MsgBox("Do you want to update the USATab Version number?", vbYesNo, "USATab Version Update?") = vbYes Then
        strCurrentVersion = ActiveDocument.Variables("varVersion")
        'loop until input recieved or canceled
        Do
            strNewVersion = InputBox("Enter new Version Number string", "Enter Version Number", strCurrentVersion)
            strNewVersion = RealInput(strNewVersion)
        If strNewVersion = "Input canceled by user!" Then
            MsgBox "Input canceled by user. Version remains " & strCurrentVersion
            Exit Sub
        End If
        Loop Until strNewVersion <> ""
    ActiveDocument.Variables("varVersion") = strNewVersion
    MsgBox "USATab updated to version " + ActiveDocument.Variables("varVersion")
     
    End If
lbl_Exit:
    Exit Sub
End Sub

'check if input is valid, null, or blank string
Function RealInput(pInput As String) As String
If StrPtr(pInput) = 0 Then
  'MsgBox "Input Canceled by User!"
  RealInput = "Input canceled by user!"
Else
  If pInput = "" Then
    RealInput = ""
    MsgBox "You did not provide an input. Please provide input or click Cancel"
  Else
    RealInput = pInput
  End If
End If
End Function

'Testing Function, deletes a doc variable
Sub DeleteVariable()
Dim varName As String

'enter string for Document Variable to remove
varName = "varVersion"

ActiveDocument.Variables(varName).Delete

MsgBox varName & " document variable probably removed"

End Sub

' InQuest injected base64 decoded content
' Szjej
' Szjej
' Szjej
' *^r&

INQUEST-PP=macro
