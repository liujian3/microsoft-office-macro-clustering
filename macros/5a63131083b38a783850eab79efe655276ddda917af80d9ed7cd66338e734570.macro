Attribute VB_Name = "C_UDF"
Public Const Pattern = "([A-Z]+)_Q([0-9]+)([A-Z]?)"

Public Function ArrayMatch(rng As Range) As Variant
    'Return array so that RegExp is called 3x less for speed
    Dim v(2) As Variant, OBJ As Object
    Set OBJ = Regex(rng.Value, Pattern, True)
    v(0) = WorksheetFunction.Proper(OBJ(0).submatches(0))
    v(1) = CInt(OBJ(0).submatches(1))
    v(2) = LCase(OBJ(0).submatches(2))
    ArrayMatch = v
End Function

Public Function DomainCollection() As Collection
    'Returns a collection of table range and heat map range associated with table
    Dim Coll As New Collection
    Coll.Add Array(Range("Tbl_Report_Risk1"), Range("Img_Risk"))
    Coll.Add Array(Range("Tbl_Report_Risk2"), Range("Img_Risk"))
    
    Coll.Add Array(Range("Tbl_Report_Asset1"), Range("Img_Asset"))
    Coll.Add Array(Range("Tbl_Report_Asset2"), Range("Img_Asset"))
    Coll.Add Array(Range("Tbl_Report_Asset3"), Range("Img_Asset"))
    
    Coll.Add Array(Range("Tbl_Report_Access1"), Range("Img_Access"))
    Coll.Add Array(Range("Tbl_Report_Access2"), Range("Img_Access"))
    Coll.Add Array(Range("Tbl_Report_Access3"), Range("Img_Access"))
    
    Coll.Add Array(Range("Tbl_Report_Threat1"), Range("Img_Threat"))
    Coll.Add Array(Range("Tbl_Report_Threat2"), Range("Img_Threat"))
    Coll.Add Array(Range("Tbl_Report_Threat3"), Range("Img_Threat"))
    
    Coll.Add Array(Range("Tbl_Report_Situation1"), Range("Img_Situation"))
    Coll.Add Array(Range("Tbl_Report_Situation2"), Range("Img_Situation"))
    Coll.Add Array(Range("Tbl_Report_Situation3"), Range("Img_Situation"))

    Coll.Add Array(Range("Tbl_Report_Sharing1"), Range("Img_Sharing"))
    Coll.Add Array(Range("Tbl_Report_Sharing2"), Range("Img_Sharing"))
    
    Coll.Add Array(Range("Tbl_Report_Response1"), Range("Img_Response"))
    Coll.Add Array(Range("Tbl_Report_Response2"), Range("Img_Response"))
    Coll.Add Array(Range("Tbl_Report_Response3"), Range("Img_Response"))
    Coll.Add Array(Range("Tbl_Report_Response4"), Range("Img_Response"))
    Coll.Add Array(Range("Tbl_Report_Response5"), Range("Img_Response"))
    
    Coll.Add Array(Range("Tbl_Report_Dependencies1"), Range("Img_Dependencies"))
    Coll.Add Array(Range("Tbl_Report_Dependencies2"), Range("Img_Dependencies"))
    Coll.Add Array(Range("Tbl_Report_Dependencies3"), Range("Img_Dependencies"))
    
    Coll.Add Array(Range("Tbl_Report_Workforce1"), Range("Img_Workforce"))
    Coll.Add Array(Range("Tbl_Report_Workforce2"), Range("Img_Workforce"))
    Coll.Add Array(Range("Tbl_Report_Workforce3"), Range("Img_Workforce"))
'    Coll.Add Array(Range("Tbl_Report_Workforce4"), Range("Img_Workforce"))
    
    Coll.Add Array(Range("Tbl_Report_Cyber1"), Range("Img_Cyber"))
    Coll.Add Array(Range("Tbl_Report_Cyber2"), Range("Img_Cyber"))
    Coll.Add Array(Range("Tbl_Report_Cyber3"), Range("Img_Cyber"))
    
    Set DomainCollection = Coll
End Function

Private Function Regex(SearchString As String, RegExPattern As String, Optional CaseSensitive As Boolean = False) As Object
'http://www.regular-expressions.info/dotnet.html
'http://www.tmehta.com/regexp/
'http://www.ozgrid.com/forum/showthread.php?t=37624&page=1
'
'Example function call would return "ty1234"
'MsgBox RegEx("qwerty123456uiops123456", "[a-z][A-Z][0-9][0-9][0-9][0-9]", False)
'
    Dim re As Object, REMatches As Object
    Set re = CreateObject("vbscript.regexp")
    With re
        .Multiline = False
        .Global = False
        .IgnoreCase = Not (CaseSensitive)
        .Pattern = RegExPattern
    End With
    Set REMatches = re.Execute(SearchString)
    If REMatches.Count > 0 Then
        Set Regex = REMatches
    Else
        Set Regex = Empty
    End If
End Function

Public Function WS_Unlock_All()
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    ActiveWorkbook.Protect Structure:=False
    For Each ws In ThisWorkbook.Worksheets
        ws.Unprotect
    Next
End Function

Public Function WS_Lock_All()
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Worksheets
        ws.Protect DrawingObjects:=False, Contents:=True, Scenarios:=True, _
                   AllowFormattingCells:=True, AllowFormattingColumns:=True, _
                   AllowFormattingRows:=True, AllowSorting:=True, _
                   AllowFiltering:=True, AllowUsingPivotTables:=True
    Next
    ActiveWorkbook.Protect Structure:=True
End Function
Attribute VB_Name = "InputForm"
Attribute VB_Base = "0{37A1521A-F684-4AE3-992C-4495C9CF2CF6}{19B8ECDD-4473-4315-A2A7-8291891A52AF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public GenerateReport As Boolean

Private Sub CancelReport_Click()
    Unload Me
End Sub

Private Sub ClearFields_Click()
    'Clear all fields in spreadsheet
    Dim Flds As Variant, fld As Variant
    Flds = GetFieldNames
    For Each fld In Flds
        Me.Controls(CStr(fld)).text = ""
        Range(fld).Value = ""
    Next
End Sub

Private Sub SaveContinue_Click()
    'Save values to spreadsheet
    Dim Flds As Variant, fld As Variant
    Flds = GetFieldNames
    For Each fld In Flds
        Range(fld).Value = Me.Controls(CStr(fld)).text
    Next
    GenerateReport = True
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    'Load values from spreadsheet
    Dim Flds As Variant, fld As Variant
    Flds = GetFieldNames
    For Each fld In Flds
        Me.Controls(CStr(fld)).text = Range(fld).Value
    Next
    GenerateReport = False 'by default cancel report
End Sub

Private Function GetFieldNames() As Variant
    'Get all the field names in the tool
    GetFieldNames = Array("OrgName", "StreetAddress", "City", "State", "Zip", _
                          "FirstName", "LastName", "Title", "Phone", "Email")
End Function

Private Sub UserForm_Terminate()
    If GenerateReport = False Then
        Range("CreateReport").Value = False
    Else
        Range("CreateReport").Value = True
    End If
End Sub
Attribute VB_Name = "Module1"
Option Explicit

Public Function clearQuestions()
    Dim ShtName(11) As String
    Dim activeName As String, i As Integer, j As Integer
    Dim newName As String
    Dim r As Range
    Dim t As String
    Dim n As name

    ShtName(1) = "ORG"
    ShtName(2) = "RM"
    ShtName(3) = "ACM"
    ShtName(4) = "IAM"
    ShtName(5) = "TVM"
    ShtName(6) = "SA"
    ShtName(7) = "ISC"
    ShtName(8) = "IR"
    ShtName(9) = "EDM"
    ShtName(10) = "WM"
    ShtName(11) = "CPM"
    
    Application.ScreenUpdating = False
    Call WS_Unlock_All
    For i = 2 To 11
        Worksheets(ShtName(i)).Activate
        For Each n In ActiveWorkbook.Names
            If nameMatchesOldSheetName(n.name, ShtName(i)) Then
                Set r = Range(n.name).Offset(0, 0)
                r.Offset(0, 0) = ""
            End If
        Next n
    Next i
    Application.ScreenUpdating = True

End Function




Attribute VB_Name = "Module2"
Option Explicit

Sub Button1_Click()
    a_loadXML.loadXML
End Sub
Attribute VB_Name = "Module3"

Sub Macro2()
Attribute Macro2.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Macro2 Macro
'

'
    Range("E13").Select
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = 13260
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
End Sub
Sub ResetColor()
Attribute ResetColor.VB_ProcData.VB_Invoke_Func = " \n14"
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorAccent1
        .TintAndShade = 0.799981688894314
        .PatternTintAndShade = 0
    End With
End Sub
Sub Macro4()
Attribute Macro4.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Macro4 Macro
'

'
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorAccent1
        .TintAndShade = 0.799981688894314
        .PatternTintAndShade = 0
    End With
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = 16772300
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    Sheets("ORG").Select
    ActiveWindow.SmallScroll Down:=-9
    Range("C5").Select
    Sheets("RM").Select
    Cells.Select
    Range("C1").Activate
    Cells.FormatConditions.Delete
    Sheets(Array("ASSET", "IAM", "TVM", "SA", "ISC", "IR", _
        "EDM", "WM", "CPM")).Select
    Sheets("ACM").Activate
    Cells.Select
    Range("C1").Activate
    Sheets("ACM").Select
    Cells.Select
    Range("C1").Activate
    Cells.FormatConditions.Delete
    Sheets("IAM").Select
    Cells.FormatConditions.Delete
    Sheets("TVM").Select
    Cells.FormatConditions.Delete
    Sheets("SA").Select
    Cells.FormatConditions.Delete
    Sheets("ISC").Select
    Cells.FormatConditions.Delete
    Sheets("IR").Select
    Cells.FormatConditions.Delete
    Sheets("EDM").Select
    Cells.FormatConditions.Delete
    Sheets("WM").Select
    Cells.FormatConditions.Delete
    Sheets("CPM").Select
    Cells.FormatConditions.Delete
    Sheets("ACM").Select
    Range("D21").Select
    ActiveWindow.SmallScroll Down:=-12
    Sheets("RM").Select
    Range("D21").Select
    Sheets("ACM").Select
    Range("D19").Select
    Sheets("IAM").Select
    Range("D20").Select
    Sheets("TVM").Select
    Range("D23").Select
    Sheets("SA").Select
    Range("D23").Select
    Sheets("ISC").Select
    Range("D22").Select
    Sheets("IR").Select
    Range("D22").Select
    Sheets("EDM").Select
    Range("D22").Select
    Sheets("WM").Select
    Range("D21").Select
    Sheets("CPM").Select
    Range("D17").Select
    Sheets("ORG").Select
    Range("C14").Select
    Sheets("ORG").Select
    Range("C16").Select
    Selection.ClearContents
    Range("C6").Select
    Selection.ClearContents
    Range("C5").Select
    Selection.ClearContents
    Sheets("ORG").Select
    ActiveWindow.SmallScroll Down:=-6
    Range("C5,C14,C16,C18").Select
    Range("C18").Activate
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorAccent1
        .TintAndShade = 0.799981688894314
        .PatternTintAndShade = 0
    End With
    Range("C7").Select
    ActiveWindow.SmallScroll Down:=-9
    Sheets("Home").Select
    ActiveWindow.SmallScroll Down:=-9
    Sheets("ORG").Select
    Range("C5,C14,C16,C18").Select
    Range("C18").Activate
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorAccent1
        .TintAndShade = 0.799981688894314
        .PatternTintAndShade = 0
    End With
    Range("C7").Select
    ActiveWindow.SmallScroll Down:=-3
    ActiveWorkbook.Save
    ActiveWorkbook.Save
    Sheets("Home").Select
    ActiveWorkbook.Save
    Range("C11").Select
    Selection.Hyperlinks(1).Follow NewWindow:=False, AddHistory:=True
    Range("A2").Select
    Selection.Hyperlinks(1).Follow NewWindow:=False, AddHistory:=True
    ActiveWorkbook.Save
End Sub
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_SelectionChange(ByVal Target As Range)

End Sub
Attribute VB_Name = "Sheet10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet13"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet15"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet16"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet17"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet18"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet19"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet20"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet21"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet22"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet23"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet24"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet25"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet26"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet27"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet28"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet29"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet30"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet31"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "a_Import"
Option Explicit

Public Sub XML_Load_s(sXML As String)
    'XML parsing here is really simple; in this case we only need the element and the XML tag
    ' name; no attributes are needed. Therefore, use a regular expression to extract
    ' the tag name for each row.
    
    ' This routine replces b_Export.XML_Load, which operated on a file.
    '
    Dim XML As New DOMDocument60
    Dim node As IXMLDOMNode
    
    Application.ScreenUpdating = False
    C_UDF.WS_Unlock_All
    
    'Clear existing values
    Range("XML_C_FieldValue").ClearContents
    Range("XML_C_FieldValue").Cells(1, 1) = "XML Field Values"

    'Open XML file
    Application.StatusBar = "XML Import: Loading XML..."
    XML.loadXML (sXML)
    
    'Grab introduction organization information in XML
    For Each node In XML.SelectNodes("/form1/data/organization_info/*")
        UpdateRangeWithXMLNode node
    Next
    
    'Grab all fields in main form
    For Each node In XML.SelectNodes("/form1/data/*")
        UpdateRangeWithXMLNode node
    Next

    C_UDF.WS_Lock_All
    
    'Update images and calculations
    UpdateImagesAndCalcs
End Sub

Public Sub XML_Load_un(sXML As String)
    'XML parsing here is really simple; in this case we only need the element and the XML tag
    ' name; no attributes are needed. Therefore, use a regular expression to extract
    ' the tag name for each row.
    
    ' This routine replces b_Export.XML_Load, which operated on a file.
    '
    Dim XML As New DOMDocument60
    Dim node As IXMLDOMNode
    
    Application.ScreenUpdating = False
    C_UDF.WS_Unlock_All
    
    'Clear existing values
    Range("XML_C_FieldValue").ClearContents
    Range("XML_C_FieldValue").Cells(1, 1) = "XML Field Values"

    'Open XML file
    Application.StatusBar = "XML Import: Loading XML..."
    XML.loadXML (sXML)
    
    'Grab introduction organization information in XML
    For Each node In XML.SelectNodes("/form1/data/organization_info/*")
        UpdateRangeWithXMLNode node
    Next
    
    'Grab all fields in main form
    For Each node In XML.SelectNodes("/form1/data/*")
        UpdateRangeWithXMLNode node
    Next

    C_UDF.WS_Lock_All
    
    'Update images and calculations
    UpdateCalcsOnly
End Sub
Private Sub UpdateRangeWithXMLNode(node As Variant)
    Dim name As String, val As String, RowID As Variant
    name = node.BaseName
    val = node.text
    'only import values if there's a match in the tool
    If MatchIndex(name, Range("XML_C_FieldName")) > 0 Then
        RowID = Range("XML_C_FieldName").row + _
            MatchIndex(name, Range("XML_C_FieldName")) - 1
        Range("XML_C_FieldName").Worksheet.Cells(RowID, 3) = val
    ElseIf VBA.Right(name, 6) = "_Notes" And MatchIndex(VBA.Left(name, Len(name) - 6), Range("XML_C_FieldName")) > 0 Then
        RowID = Range("XML_C_FieldName").row + _
            MatchIndex(VBA.Left(name, Len(name) - 6), Range("XML_C_FieldName")) - 1
        Range("XML_C_FieldName").Worksheet.Cells(RowID, 13) = val
    End If
End Sub

Private Sub UpdateImagesAndCalcs()
    Dim ws As Worksheet
    Dim Coll As New Collection
    Dim domain As Variant
    
    Application.ScreenUpdating = False
    
    C_UDF.WS_Unlock_All
    'Calculate all worksheets
    Application.StatusBar = "XML Import: Calculating Worksheets..."
    Application.Calculation = xlCalculationAutomatic
    For Each ws In ThisWorkbook.Worksheets
        ws.Calculate
    Next
    
    'Update images
    Application.StatusBar = "XML Import: Updating Heat Map Images..."
    'Clear images
    ClearAllImagesinWS
    'Add images
    Set Coll = C_UDF.DomainCollection()
    For Each domain In Coll
        'Debug.Print domain(0).Worksheet.name & " - " & domain(0).Address & " ! " & domain(1).Worksheet.name & " - " & domain(1).Address
        UpdateImageInWS domain(0), domain(1)
    Next
    
    'Update Charts
    'UpdatePieCharts
    'UpdatePieLbl_Charts
    Update_Domain_DoughPlots
    Update_Objective_DoughPlots
    
    'Update Pivot Table
    UpdatePivot
    
    C_UDF.WS_Lock_All
    
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Sheets("Domain").Activate
    Sheets("Domain").Range("A32").Select
End Sub

Private Sub UpdateCalcsOnly()
    Dim ws As Worksheet
    Dim Coll As New Collection
    Dim domain As Variant
    
    Application.ScreenUpdating = False
    
    C_UDF.WS_Unlock_All
    'Calculate all worksheets
    Application.StatusBar = "XML Import: Calculating Worksheets..."
    Application.Calculation = xlCalculationAutomatic
    For Each ws In ThisWorkbook.Worksheets
        ws.Calculate
    Next
    
    'Update images
'    Application.StatusBar = "XML Import: Updating Heat Map Images..."
'    'Clear images
'    ClearAllImagesinWS
'    'Add images
'    Set Coll = C_UDF.DomainCollection()
'    For Each domain In Coll
'        Debug.Print domain(0).Worksheet.name & " - " & domain(0).Address & " ! " & domain(1).Worksheet.name & " - " & domain(1).Address
'        UpdateImageInWS domain(0), domain(1)
'    Next
    
    'Update Charts
    'UpdatePieCharts
    'UpdatePieLbl_Charts
'    Update_Domain_DoughPlots
'    Update_Objective_DoughPlots
    
    'Update Pivot Table
    UpdatePivot
    
    C_UDF.WS_Lock_All
    
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Sheets("Domain").Activate
    Sheets("Domain").Range("A32").Select
End Sub


Private Sub UpdatePivot()
    Application.ScreenUpdating = False
    Sheets("Pivot").Activate
    ActiveSheet.PivotTables("Piv_DataGaps").PivotCache.Refresh
    On Error Resume Next
    With ActiveSheet.PivotTables("Piv_DataGaps").PivotFields("XML Field Values")
        .PivotItems("Partially Implemented").Visible = True
        .PivotItems("Not Implemented").Visible = True
    End With
    On Error GoTo 0
End Sub

Private Sub UpdatePieCharts()
    'Update all the colors for the pie charts depending on MIL placement
    Dim Cell As Range
    Dim MILselected As String
    Dim IDselected As Integer, id As Integer
    Dim MILs As Variant, MIL As Variant
    Dim Colors As String, ChartName As ChartObject
    
    Sheets("Domain").Activate
    MILs = Array("MIL0", "MIL1", "MIL2", "MIL3")
    For Each Cell In Range("Chart_Domains")
        MILselected = Cell.Offset(0, 1).Value
        IDselected = CInt(Right(MILselected, 1))
        For Each MIL In MILs
            id = CInt(Right(MIL, 1))
            Set ChartName = Sheets("Domain").ChartObjects(Cell.Value & "_" & CStr(MIL))
            If id <= IDselected Then
                Colors = "Green"
                ChartName.Chart.SeriesCollection(3).Points(1).Format.Fill.ForeColor.RGB = RGB(117, 147, 60)
                ChartName.Chart.SeriesCollection(3).Points(2).Format.Fill.ForeColor.RGB = RGB(117, 147, 60)
            Else
                Colors = "Gray"
                ChartName.Chart.SeriesCollection(3).Points(1).Format.Fill.ForeColor.RGB = RGB(171, 171, 171)
                ChartName.Chart.SeriesCollection(3).Points(2).Format.Fill.ForeColor.RGB = RGB(256, 256, 256)
            End If
        Next
    Next
End Sub

Private Sub UpdatePieLbl_Charts()
'Update all the colors for the pie charts depending on MIL placement
    Dim Cell As Range
    Dim MILselected As String
    Dim IDselected As Integer, id As Integer
    Dim MILs As Variant, MIL As Variant
    Dim Colors As String, ChartName As ChartObject
    
    'update chart coloring
    Sheets("Domain").Activate
    MILs = Array("MIL1", "MIL2", "MIL3")
    For Each Cell In Range("Chart_Domains")
        MILselected = Cell.Offset(0, 1).Value
        IDselected = CInt(Right(MILselected, 1))
        For Each MIL In MILs
            id = CInt(Right(MIL, 1))
            Set ChartName = Sheets("Domain").ChartObjects(Cell.Value & "_" & CStr(MIL) & "_Lbl")
            If id <= IDselected Then
                Colors = "Green"
                ChartName.Chart.SeriesCollection(3).Points(1).Format.Fill.ForeColor.RGB = RGB(117, 147, 60)
                ChartName.Chart.SeriesCollection(3).Points(2).Format.Fill.ForeColor.RGB = RGB(117, 147, 60)
            Else
                Colors = "Gray"
                ChartName.Chart.SeriesCollection(3).Points(1).Format.Fill.ForeColor.RGB = RGB(171, 171, 171)
                ChartName.Chart.SeriesCollection(3).Points(2).Format.Fill.ForeColor.RGB = RGB(256, 256, 256)
            End If
        Next
    Next
    
    'update labels
    Dim lbl As String, Shp As Shape, Lmid As Double, Tval As Double
    'Update zoom or left/top placement will not work correctly
    ActiveWindow.Zoom = 100
    For Each Cell In Range("Lbl_Names")
        lbl = Cell.Offset(0, 1)
        Set Shp = Sheets("Domain").Shapes(Cell.Value)
        Lmid = Shp.Left + Shp.Width / 2
        Tval = Shp.Top
        Shp.TextFrame2.TextRange.Characters.text = lbl
        Shp.Left = Lmid - Shp.Width / 2
        Shp.Top = Tval
    Next
End Sub


Public Sub UpdateNamedRanges()
Dim rng As Variant
For Each rng In Sheets("CPM").Range("G13:G83")
    On Error Resume Next
    If rng.Offset(0, -2).name.name Like "CYBER*" Then
    'ThisWorkbook.Names(rng.Offset(0, -2).name.name & "_notes").Delete
        z_Excel.NamedRange_Add rng.Offset(0, 0), rng.Offset(0, -2).name.name & "_Notes", True
    End If
Next rng
End Sub



Private Sub Update_Domain_DoughPlots()
    'Delete any labels in the doughplots which are equal to zero
    Dim cht As ChartObject, ser As Series, pt As Point
    For Each cht In Sheets("Domain").ChartObjects
        For Each ser In cht.Chart.SeriesCollection
            If ser.ChartType = xlDoughnut Then
                'first turn on labels for all fields in the krispy kreme plots
                ser.ApplyDataLabels xlDataLabelsShowValue
                ser.DataLabels.Format.TextFrame2.TextRange.Font.Bold = True
                ser.DataLabels.Format.TextFrame2.TextRange.Font.Size = 8
                'now delete zero labels
                For Each pt In ser.Points
                    If pt.DataLabel.Caption = 0 Then
                        pt.DataLabel.Delete
                    End If
                Next
            End If
        Next
    Next
End Sub

Private Sub Update_Objective_DoughPlots()
    'Delete any labels in the doughplots which are equal to zero
    Dim cht As ChartObject, ser As Series, pt As Point
    For Each cht In Sheets("Objective").ChartObjects
        For Each ser In cht.Chart.SeriesCollection
            If ser.ChartType = xlDoughnut Then
                'first turn on labels for all fields in the krispy kreme plots
                ser.ApplyDataLabels xlDataLabelsShowValue
                ser.DataLabels.Format.TextFrame2.TextRange.Font.Bold = True
                ser.DataLabels.Format.TextFrame2.TextRange.Font.Size = 11
                'now delete zero labels
                For Each pt In ser.Points
                    If pt.DataLabel.Caption = 0 Then
                        pt.DataLabel.Delete
                    End If
                Next
            End If
        Next
    Next
End Sub

Private Sub ClearAllImagesinWS()

    Dim WSName As Variant, Nm As Variant
    Dim Img As Variant, ws As Worksheet
    WSName = Array("1 Risk", "2 Asset", "3 Access", "4 Threat", _
                   "5 Situation", "6 Sharing", "7 Response", _
                   "8 Dependencies", "9 Workforce", "10 Cyber")
    
    'Delete existing images
    For Each Nm In WSName
    Set ws = Sheets(CStr(Nm))
        ws.Activate
        For Each Img In ws.Shapes
            Img.Delete
        Next
    Next
End Sub

Private Sub UpdateImageInWS(tbl As Variant, ImgRng As Variant)
    'Delete existing heat map images in worksheet, and paste
    ' new heat map into into worksheet.
    
    'Copy Range
    Application.CutCopyMode = False
    Debug.Print " 1- " & tbl.Worksheet.name & " - " & tbl.Address
    Debug.Print " 2- " & ImgRng.Worksheet.name & " - " & ImgRng.Address
    ImgRng.Worksheet.Activate
    ImgRng.CopyPicture
    
    'Paste Range
    tbl.Worksheet.Activate
    tbl.Cells(1, 1).Select
    ActiveSheet.Paste
    Application.CutCopyMode = False
    
    'Reformat Picture
    Dim max_shape As Integer
    max_shape = tbl.Worksheet.Shapes.Count
    With tbl.Worksheet.Shapes(max_shape)
        .Width = Application.InchesToPoints(6.5)
        .Left = tbl.Cells(1, 1).Left
        .Top = tbl.Cells(1, 1).Top
    End With
    'Reformat Cell
    tbl.rows(1).RowHeight = tbl.Worksheet.Shapes(max_shape).Height
    
    'tbl.Worksheet.Range("A1").Select
End Sub

Private Function MatchIndex(SearchString As String, rng As Range) As Long
    'Return the integer max value in a range, or -999 if no match is found
    On Error GoTo NoMatch
    MatchIndex = WorksheetFunction.Match(SearchString, rng, False)
    Exit Function
NoMatch:
    MatchIndex = -999
End Function
Attribute VB_Name = "a_loadXML"
Option Explicit

' GENERATES INTERFACE XML FROM THE SURVEY DATA RESULTS.

Public Function loadXML() As String
    Dim XML As String
    Dim status As String
    status = CheckAll()
    If status = "pass" Then
        XML = exportXML_s()
        Worksheets("REPORTS").Unprotect
        Range("XML_Import_Path").Cells(1, 1) = ""
        Worksheets("REPORTS").Protect
        Call XML_Load_s(XML)
    End If
    loadXML = status
End Function
Public Function loadXML_un() As String
    Dim XML As String
    Dim status As String
    status = CheckAll()
    If status = "pass" Then
        XML = exportXML_s()
        Worksheets("REPORTS").Unprotect
        Range("XML_Import_Path").Cells(1, 1) = ""
        Worksheets("REPORTS").Unprotect
        Call XML_Load_un(XML)
    End If
    loadXML_un = status
End Function

Private Function exportXML_s() As String
        '-----------------------------------------------------------------------------------------------------------
        ' exportXML_s - GENERATES INTERFACE XML FROM THE SURVEY DATA RESULTS
        '               Assumes data is stored as a named range for each field,
        '               each section with a unique prefix such as RISK_ for the risk tab fields.
        '             - Out: xml
        '             - Last Updated: 7/31/31 by DAL
        '-----------------------------------------------------------------------------------------------------------
        
        ' Example of output (with no embedded tabs, spaces, or carriage returns):
        
        ' <?xml version="1.0" encoding="UTF-16"?>
        ' <form1>
        '     <data>
        '         <organization_info>
        '             <INTRO_Q1>Investor-owned</INTRO_Q1>
        '             <INTRO_Q2A>1</INTRO_Q2A>
        '             <INTRO_Q2B>0</INTRO_Q2B>
        '             <INTRO_Q2C>0</INTRO_Q2C>
        '             <INTRO_Q2D>0</INTRO_Q2D>
        '             <INTRO_Q2E>0</INTRO_Q2E>
        '             <INTRO_Q2E_TEXT/>
        '             <INTRO_Q3>Generation</INTRO_Q3>
        '             <INTRO_Q3_TEXT/>
        '         </organization_info>
        '         <RISK_Q1A>Fully Implemented</RISK_Q1A>
        '         <RISK_Q1B>Fully Implemented</RISK_Q1B>
        '         <RISK_Q1C>Fully Implemented</RISK_Q1C>
        '         <CYBER_Q5B>Fully Implemented</CYBER_Q5B>
        '         <CYBER_Q5C>Fully Implemented</CYBER_Q5C>
        '         <CYBER_Q5D>Fully Implemented</CYBER_Q5D>
        '         <CYBER_Q5E>Fully Implemented</CYBER_Q5E>
        '         <CYBER_Q5F>Fully Implemented</CYBER_Q5F>
        '     </data>
        ' </form1>
        '
    Dim XML As String
    XML = ""
    XML = XML & "<?xml version=""1.0"" encoding=""UTF-8""?>"
    XML = XML & "<form1>"
    XML = XML & "<data>"
    XML = XML & "<organization_info>"
    XML = XML & exportXMLforNames_s("INTRO_")
    XML = XML & "</organization_info>"
    XML = XML & exportXMLforNames_s("RISK_")
    XML = XML & exportXMLforNames_s("ASSET_")
    XML = XML & exportXMLforNames_s("ACCESS_")
    XML = XML & exportXMLforNames_s("THREAT_")
    XML = XML & exportXMLforNames_s("SITUATION_")
    XML = XML & exportXMLforNames_s("SHARING_")
    XML = XML & exportXMLforNames_s("RESPONSE_")
    XML = XML & exportXMLforNames_s("DEPENDENCIES_")
    XML = XML & exportXMLforNames_s("WORKFORCE_")
    XML = XML & exportXMLforNames_s("CYBER_")
    XML = XML & "</data>"
    XML = XML & "</form1>"
    
    exportXML_s = XML
End Function



Private Function exportXMLforNames_s(nam_ As String) As String
    Dim n As name
    Dim s As String
    Dim XML As String
    XML = ""
    For Each n In ActiveWorkbook.Names
        If n.name Like nam_ & "*" Then
            s = Range(n.name).Offset(0, 0).Value
            If Len(s) = 0 Then
               ' e.g., <INTRO_Q3_TEXT\> when there is no data.
                XML = XML & "<" & n.name & "/>"
            Else
                If UCase(s) = "TRUE" Then
                    s = "1"
                ElseIf UCase(s) = "FALSE" Then
                    s = "0"
                End If
                ' e.g., <CYBER_Q5F>Fully Implemented</CYBER_Q5F> when there is data.
                XML = XML & "<" & n.name & ">" & s & "</" & n.name & ">"
            End If
        End If
    Next
    exportXMLforNames_s = XML
End Function

Private Function tabs(n As Long) As String
    Dim s As String
    s = ""
    Dim i As Long
    For i = 1 To n
        s = s & "    "
    Next
    tabs = s
End Function
Attribute VB_Name = "b_Export"
Option Explicit
Public Const c_domain1 As Integer = 2
Public Const c_id1 As Integer = 8
Public Const c_text1 As Integer = 9
Public Const c_response1 As Integer = 1
Public Const c_notes1 As Integer = 11


' These are taken from the Word object browswer window.  ' DAL
Global Const wdLineSpaceSingle = 0
Global Const wdOutlineLevelBodyText = 10
Global Const wdFindContinue = 1
Global Const wdNumberFullContext = -4
Global Const wdFieldRef = 3
Global Const wdOrientLandscape = 1
Global Const wdActiveEndSectionNumber = 2
Global Const wdOrientPortrait = 0
Global Const wdPaneNone = 0
Global Const wdNormalView = 1
Global Const wdOutlineView = 2
Global Const wdPrintView = 3
Global Const wdSeekCurrentPageHeader = 9
Global Const wdCharacter = 1
Global Const wdSectionBreakNextPage = 2
Global Const wdPageBreak = 7
Global Const wdWord9TableBehavior = 1
Global Const wdAutoFitFixed = 0
Global Const wdBorderBottom = -3
Global Const wdBorderDiagonalDown = -7
Global Const wdBorderDiagonalUp = -8
Global Const wdBorderHorizontal = -5
Global Const wdBorderLeft = -2
Global Const wdBorderRight = -4
Global Const wdBorderTop = -1
Global Const wdBorderVertical = -6



Enum SaveType
    WordOnly = 1
    PDFOnly = 2
    WordAndPDF = 3
End Enum

Public Sub Template_SelectFile()
    'Create input box for loading Template
    Dim FN As String
    FN = z_Files.SelectExistingFile(WordFiles, "Select Template Output File")
    If FN <> "False" Then Range("Template_Import_Path") = FN
End Sub

Private Function Template_File_Exists() As Boolean
    'QA check- returns TRUE if file exists or FALSE if otherwise with warning
    If z_Files.GetFileInfo(Range("Template_Import_Path"), FileExists) = True Then
        Template_File_Exists = True
    Else
        MsgBox "Error- Word template file doesn't exist!" & vbNewLine & vbNewLine & _
               "The following file was not found on your computer:" & vbNewLine & _
               """" & Range("Template_Import_Path") & """" & vbNewLine & vbNewLine & _
               "Please select a new directory to specify the template location.", _
               vbCritical, "Report not created"
        Template_File_Exists = False
    End If
End Function

Public Sub Print_Word()
    Create_Report WordOnly, False
End Sub
Public Sub Print_PDF()
    Create_Report PDFOnly, False
End Sub

Public Sub Print_Word_PDF()
    Create_Report WordAndPDF, True, True
'    Create_Report WordAndPDF, False
End Sub
Public Sub Print_UserNotes()
    Create_UserNotes
End Sub

Public Sub Print_Word_PDF_CloseFiles()
    Create_Report WordAndPDF, True
End Sub
Private Sub Create_UserNotes()
Dim end_data As Boolean, i As Integer
Dim row_cnt As Integer, this_workbook As String
Dim Excel_filename As String, new_cnt As Integer, timestamp As String, Excel_path As String
Dim domain As String, id As String, text As String, response As String, self_notes As String
this_workbook = ThisWorkbook.name

'Make sure all required data has been filled out.  If so, load it, else issue warning message and exit.
    If loadXML_un() <> "pass" Then Exit Sub
    
Application.ScreenUpdating = False

timestamp = Replace(Time(), ":", "")

row_cnt = 1
end_data = True
new_cnt = 2
'print to new excel file
Excel_path = z_Files.GetFileInfo(ActiveWorkbook.FullName, Pathonly) & "UserNotes_" & _
              z_Files.GetFileInfo(ActiveWorkbook.FullName, NameOnly) & "_" & timestamp & ".xlsx"

Excel_filename = "UserNotes_" & z_Files.GetFileInfo(ActiveWorkbook.FullName, NameOnly) & "_" & timestamp & ".xlsx"
AddNewExcel Excel_filename, Excel_path


Workbooks(this_workbook).Activate

Do While end_data = True
    If Sheet2.Range("Tbl_XML_start").Offset(row_cnt, 0).Value = "" Then
        end_data = False
    Else
        If Sheet2.Range("tbl_XML_start").Offset(row_cnt, 11) <> "" Then
            'If the self evaluation notes are filled in then print.
            domain = Sheet2.Range("tbl_XML_start").Offset(row_cnt, c_domain1)
            id = Sheet2.Range("tbl_XML_start").Offset(row_cnt, c_id1)
            text = Sheet2.Range("tbl_XML_start").Offset(row_cnt, c_text1)
            response = Sheet2.Range("tbl_XML_start").Offset(row_cnt, c_response1)
            self_notes = Sheet2.Range("tbl_XML_start").Offset(row_cnt, c_notes1)
            
            'print
            Workbooks(Excel_filename).Activate
            ActiveWorkbook.Sheets("User Notes").Cells(new_cnt, 1) = domain
            ActiveWorkbook.Sheets("User Notes").Cells(new_cnt, 2) = id
            ActiveWorkbook.Sheets("User Notes").Cells(new_cnt, 3) = text
            ActiveWorkbook.Sheets("User Notes").Cells(new_cnt, 4) = response
            ActiveWorkbook.Sheets("User Notes").Cells(new_cnt, 5) = self_notes
            new_cnt = new_cnt + 1
            Workbooks(this_workbook).Activate
            
        End If
    End If
    row_cnt = row_cnt + 1
Loop

Workbooks(Excel_filename).Activate
For i = 1 To 4
    ActiveWorkbook.Sheets("User Notes").Range("A1:E" & new_cnt - 1).Borders(i).LineStyle = 1
Next i
ActiveWorkbook.Sheets("User Notes").Columns("A:E").EntireColumn.AutoFit
Workbooks(Excel_filename).Save
Workbooks(Excel_filename).Close
Application.ScreenUpdating = True

MsgBox "User Notes spreadsheet has been saved in the same folder in which the Evaluation Toolkit Excel file is saved."
End Sub
Sub AddNewExcel(file_name As String, fullpath)
Dim newbook As Variant
Set newbook = Workbooks.Add
    With newbook
        .SaveAs FileName:=fullpath
    End With
Workbooks(file_name).Activate
ActiveWorkbook.Sheets("Sheet1").name = "User Notes"

Application.DisplayAlerts = False
ActiveWorkbook.Sheets("Sheet2").Delete
ActiveWorkbook.Sheets("Sheet3").Delete
Application.DisplayAlerts = True
ActiveWorkbook.Sheets("User Notes").Cells(1, 1).Value = "Domain"
ActiveWorkbook.Sheets("User Notes").Cells(1, 2).Value = "Objective Number"
ActiveWorkbook.Sheets("User Notes").Cells(1, 3).Value = "Objective Text"
ActiveWorkbook.Sheets("User Notes").Cells(1, 4).Value = "Reponse"
ActiveWorkbook.Sheets("User Notes").Cells(1, 5).Value = "Self-Evaluation Notes"

ActiveWorkbook.Sheets("User Notes").Range("A1:E1").Interior.Color = 12611584
ActiveWorkbook.Sheets("User Notes").Range("A1:E1").Font.Color = RGB(255, 255, 255)
ActiveWorkbook.Sheets("User Notes").Range("A1:E1").Font.Bold = True

End Sub

Private Sub Create_Report(ST As SaveType, CloseFilesAfterCompletion As Boolean, Optional dispMessage As Boolean = False)
    Dim Worddoc As z_Word
    Dim PDFName As String
    Dim timestamp As String

    'Make sure all required data has been filled out.  If so, load it, else issue warning message and exit.
    If loadXML() <> "pass" Then Exit Sub

    'only continue if report QA is TRUE
    If Template_File_Exists = False Then Exit Sub
    
    'Show form input screen
    Range("CreateReport").Value = True
    ShowForm
    If Range("CreateReport").Value = False Then Exit Sub
    
    'Create new report
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = False
    Call WS_Unlock_All
    
    timestamp = Replace(Time(), ":", "")
    
    PDFName = z_Files.GetFileInfo(ActiveWorkbook.FullName, Pathonly) & _
              z_Files.GetFileInfo(ActiveWorkbook.FullName, NameOnly) & "_" & timestamp & ".pdf"
    
   On Error GoTo IsErr
    Set Worddoc = New z_Word
    Application.StatusBar = "Creating report..."
    Worddoc.WordDocument_Add Range("Template_Import_Path")
    Worddoc.WordOptionsManual
''''    Worddoc.Visible True     'debug only
    
    'Print things in report
    PrintIndividualCells Worddoc
    PrintFigures Worddoc
    PrintTables Worddoc
    Worddoc.Format_ESCRMMI_Tbls
    c_Gap.Gap_Tbl Worddoc
        
    Application.StatusBar = "Creating report, final cleanup, and saving..."
    'Report cleanup
    Worddoc.WordOptionsAutomatic
    Worddoc.UpdateAll
    Worddoc.GoToBeginning
'''ws.Cells(10, 1).Value = "Debug 14"
    
    
    'Save settings
    Select Case ST  'save type
        Case WordOnly
            Worddoc.SaveAsWordDoc z_Files.GetFileInfo(ActiveWorkbook.FullName, Pathonly), _
                                  z_Files.GetFileInfo(ActiveWorkbook.FullName, NameOnly) & "_" & timestamp, _
                                    "docx"
        Case PDFOnly
            Worddoc.SaveAsPDF PDFName, Not CloseFilesAfterCompletion
        Case WordAndPDF
            
            Worddoc.SaveAsWordDoc z_Files.GetFileInfo(ActiveWorkbook.FullName, Pathonly), _
                                  z_Files.GetFileInfo(ActiveWorkbook.FullName, NameOnly) & "_" & timestamp, _
                                    "docx"
            Worddoc.SaveAsPDF PDFName, Not CloseFilesAfterCompletion
    End Select
    
    Call WS_Lock_All

    'Word report settings
    
    'Close Word file or make visible
    If ST = WordAndPDF Then
        Worddoc.WordDocument_Close False                    ' DAL: Only leave the PDF file showing.
    ElseIf ST = PDFOnly Or CloseFilesAfterCompletion = True Then
        Worddoc.WordDocument_Close False
    End If

    ThisWorkbook.Activate
    Sheets("Home").Activate
    If (CloseFilesAfterCompletion = False) Or dispMessage Then
        MsgBox "Word and PDF reports have been saved in the same folder in which the Evaluation Toolkit Excel file is saved."
    End If
    Application.StatusBar = False
    
    Exit Sub
        
IsErr:
    On Error Resume Next
            'Worddoc.WordDocument_Close False  ' If err, clean up so word application is not left hanging.
    On Error GoTo 0
End Sub

Private Sub ShowForm()
    With InputForm
        .StartUpPosition = 0
        .Left = Application.Left + (0.5 * Application.Width) - (0.5 * .Width)
        .Top = Application.Top + (0.5 * Application.Height) - (0.5 * .Height)
        .Show
    End With
End Sub

Private Sub PrintIndividualCells(Worddoc As Variant)
    Dim eachName As Excel.name
    Dim SearchString As String, ReplaceString As String
    'Print all individual cells in range
    On Error Resume Next
    For Each eachName In ThisWorkbook.Names
        'only print cells where the range cell count = 1
        If eachName.RefersToRange.Cells.Count = 1 Then
            SearchString = "[" & eachName.name & "]"
            ReplaceString = eachName.RefersToRange.text
            Do While Worddoc.SearchReplaceEverywhere(SearchString, ReplaceString) = True
            Loop
        End If
    Next
    On Error GoTo 0
End Sub

Private Sub PrintTables(Worddoc As Variant)
    'Now paste tables into report
    Dim eachName As Variant
    Dim SearchString As String, ReplaceString As String
    Dim TblRng As Range
    Dim domain As New Collection
    
    Dim wd As New Collection
    Dim w As Worksheet
    For Each w In Worksheets
        wd.Add w.Visible, w.name
        w.Visible = xlSheetVisible
    Next
    
    Set domain = DomainCollection()
    For Each eachName In domain
        Application.StatusBar = "Printing " & CStr(eachName(0).name.name) & " summary table..."
        SearchString = "[" & eachName(0).name.name & "]"
        ReplaceString = ""
        Do While Worddoc.SearchReplaceInWordDoc(SearchString, ReplaceString) = True
            'paste table in place of tag
            Worddoc.Table_PasteFromExcel_ESCRMMI eachName(0), eachName(1)
        Loop
    Next
    
    For Each w In Worksheets
        w.Visible = wd.Item(w.name)
    Next
    Set wd = Nothing

End Sub

Private Sub PrintFigures(Worddoc As Variant)
    Dim FigDict As Variant, Fig As Variant
    Dim SearchString As String, ReplaceString As String
    Set FigDict = CreateObject("Scripting.Dictionary")
        
    'Set all figures to paste
    FigDict.Add "Fig_DONUT_Chart", Sheets("Domain").Shapes("FigDC")
    FigDict.Add "Fig_Risk_Donut", Sheets("Objective").Shapes("Fig_Risk_Donut")
    FigDict.Add "Fig_Asset_Donut", Sheets("Objective").Shapes("Fig_Asset_Donut")
    FigDict.Add "Fig_Access_Donut", Sheets("Objective").Shapes("Fig_Access_Donut")
    FigDict.Add "Fig_Threat_Donut", Sheets("Objective").Shapes("Fig_Threat_Donut")
    FigDict.Add "Fig_Situation_Donut", Sheets("Objective").Shapes("Fig_Situation_Donut")
    FigDict.Add "Fig_Sharing_Donut", Sheets("Objective").Shapes("Fig_Sharing_Donut")
    FigDict.Add "Fig_Response_Donut", Sheets("Objective").Shapes("Fig_Response_Donut")
    FigDict.Add "Fig_Dependencies_Donut", Sheets("Objective").Shapes("Fig_Dependencies_Donut")
    FigDict.Add "Fig_Workforce_Donut", Sheets("Objective").Shapes("Fig_Workforce_Donut")
    FigDict.Add "Fig_Cyber_Donut", Sheets("Objective").Shapes("Fig_Cyber_Donut")
    
    'Print figures in report
    For Each Fig In FigDict.keys
        Application.StatusBar = "Printing figure " & CStr(Fig) & "..."
        SearchString = "[" & Fig & "]"
        ReplaceString = ""
        Do While Worddoc.SearchReplaceInWordDoc(SearchString, ReplaceString) = True
            'paste figure in range
            Worddoc.AddShapeInline FigDict(Fig)
        Loop
    Next
    
    Dim Shp As Variant
    'Make all of them the size of the document
    For Each Shp In Worddoc.ActDoc.InlineShapes
        Shp.LockAspectRatio = True
        Shp.Width = Application.InchesToPoints(6.5)
    Next
End Sub


Attribute VB_Name = "c_Gap"
Public Const R_start As Integer = 11
Public Const GapWS As String = "Pivot"
Public Const C_domain As Integer = 2
Public Const C_status As Integer = 3
Public Const C_MIL As Integer = 4
Public Const C_text As Integer = 5
Public Const C_question As Integer = 6
Public Const C_notes As Integer = 7


Public Sub Gap_Tbl(Worddoc As z_Word)
    'Create a GAP table in the report
    
    Dim Coll As New Collection
    Dim d As Variant
    Dim r As Long
    Dim domain As String, status As String, MIL As String, _
        text As String, question As String, self_notes As String
    Dim ws As Worksheet
    Dim tbl As Variant 'Word.Table
    
    Application.StatusBar = "Generating gap analysis table..."
    
    'Change to draft view (less error prone)
    Worddoc.ViewChange DraftView
    
    'Go to proper location in document
    GapEndTbl Worddoc
    
    'Print header
    print_header Worddoc
    
    'initalize values
    domain = ""
    status = ""
    MIL = ""
    text = ""
    question = ""
    self_notes = ""
    Set ws = Sheets(GapWS)
    
    'Now, iterate over each row in pivot table
    For r = R_start To 65536
        'end of pivot table
        If ws.Cells(r, C_question) = "" Then Exit For
        
        'print subheading if domain changes
        If ws.Cells(r, C_domain) <> "" Then
            domain = ws.Cells(r, C_domain)
            Select Case UCase(domain)
            Case "RISK"
                domain = "Risk Management"
            Case "ASSET"
                domain = "Asset, Change, and Configuration Management"
            Case "ACCESS"
                domain = "Identity and Access Management"
            Case "THREAT"
                domain = "Threat and Vulnerability Management"
            Case "SITUATION"
                domain = "Situational Awareness"
            Case "SHARING"
                domain = "Information Sharing And Communications"
            Case "RESPONSE"
                domain = "Event and Incident Response, Continuity of Operations"
            Case "DEPENDENCIES"
                domain = "Supply Chain and External Dependencies Management"
            Case "WORKFORCE"
                domain = "Workforce Management"
            Case "CYBER"
                domain = "Cybersecurity Program Management"
            End Select

            print_subheading Worddoc, domain
            Application.StatusBar = "Generating gap analysis table... " & domain & " domain"
        End If
        
        'print data table
        status = ws.Cells(r, C_status)
        MIL = ws.Cells(r, C_MIL)
        text = ws.Cells(r, C_text)
        question = ws.Cells(r, C_question)
        If ws.Cells(r, C_notes) <> "(blank)" Then
            self_notes = ws.Cells(r, C_notes)
        Else
            self_notes = ""
        End If
        Print_data Worddoc, status, MIL, text, question, self_notes
    Next r
    
    'Merge cells and format table
    Dim s As String
    s = "Generating gap analysis table... final formatting and merging"
'    Application.StatusBar = s
    Set tbl = Worddoc.ActDoc.Tables(Worddoc.ActDoc.Tables.Count - 1)   'GAP table is 2nd from the end. May need to change!
    Gap_TblFormat tbl, s
    Worddoc.Tbl_MergeBlankCells tbl, s
    Worddoc.ViewChange PrintView
End Sub

Private Function GapEndTbl(Worddoc As z_Word)
    'Go to proper place in word document
    Worddoc.GoToBookmark "GapTbl"
    Worddoc.GoUpOneLine
End Function
Private Function print_header(Worddoc As z_Word) As Boolean
    'Add header row
    Dim Coll As New Collection
    Coll.Add d_cell("Status", 1, "TblHeader", RGB(54, 95, 145))
    Coll.Add d_cell("MIL", 0.5, "TblHeader", RGB(54, 95, 145))
    Coll.Add d_cell("Question", 1, "TblHeader", RGB(54, 95, 145))
    Coll.Add d_cell("Text", 2, "TblHeader", RGB(54, 95, 145))
    Coll.Add d_cell("Self Evaluation Notes", 2, "TblHeader", RGB(54, 95, 145))
    Worddoc.Tbl_AddRow Coll
    GapEndTbl Worddoc
    PrintHeader = True
End Function

Private Function print_subheading(Worddoc As z_Word, domain As String) As Boolean
    'Print subheading column for subheading
    Dim Coll As New Collection
    Coll.Add d_cell(domain, 6.5, "TblSubheader", RGB(79, 129, 189))
    Worddoc.Tbl_AddRow Coll
    GapEndTbl Worddoc
    print_subheading = True
End Function

Private Function Print_data(Worddoc As z_Word, status As String, _
                            MIL As String, text As String, _
                            question As String, self_notes As String) As Boolean
    Dim Coll As New Collection
    If status = "" Then Coll.Add d_cell("", 1, "TblText", RGB(211, 223, 238)) _
        Else: Coll.Add d_cell(status, 1, "TblText", RGB(211, 223, 238))
    If MIL = "" Then Coll.Add d_cell("", 0.5, "TblText", RGB(211, 223, 238)) _
        Else: Coll.Add d_cell(MIL, 0.5, "TblText", RGB(211, 223, 238))
    Coll.Add d_cell(question, 1, "TblText", RGB(211, 223, 238))
    Coll.Add d_cell(text, 2, "TblText", RGB(211, 223, 238))
    Coll.Add d_cell(self_notes, 2, "TblText", RGB(211, 223, 238))
    Worddoc.Tbl_AddRow Coll
    GapEndTbl Worddoc
End Function

Private Function d_cell(text As Variant, Width As Variant, style As String, shade As Variant) As Variant
    'Returns a dictionary with the required inputs used to print a Word cell
    Set d_cell = z_VBA.Dict_CreateEmpty
    d_cell.Add "Text", CStr(text)
    d_cell.Add "Width", CDbl(Width)
    d_cell.Add "Style", CStr(style)
    d_cell.Add "Shade", shade
End Function

Private Function Gap_TblFormat(tbl As Variant, Optional msg As String = "")
    'Add border lines and make header wrap pages
    
    'make header wrap pages
    tbl.rows(1).HeadingFormat = True
    'add page borders
    Dim sides As Variant, side As Variant
    sides = Array(-1, -2, -3, -4, -5, -6)
    Dim iMsg As Integer: iMsg = 0
    On Error Resume Next    ' in case inside horizontal/vertical fail
    For Each side In sides
        iMsg = iMsg + 1
        If msg <> "" Then
            Application.StatusBar = msg + Replace(Space(iMsg Mod 10), " ", ".")
        End If
        With tbl.Range.Cells.Borders(CInt(side))
            .LineStyle = 1  ' wdLineStyleSingle = 1
            .LineWidth = 4  ' wdLineWidth050pt = 4
            .Color = -603914241
        End With
    Next
    On Error GoTo 0
End Function
Attribute VB_Name = "d_Batch"

Public Sub BatchProcess()
    'assumes XML file name is pasted into tool
    a_loadXML.loadXML
    b_Export.Print_Word_PDF_CloseFiles
End Sub
Attribute VB_Name = "e_Intro"


Public Sub ClearIntro()

Worksheets("ORG").Unprotect
Worksheets("ORG").Range("INTRO_Q1").ClearContents
Worksheets("ORG").Range("INTRO_Q2E_TEXT").ClearContents
Worksheets("ORG").Range("INTRO_Q3_TEXT").ClearContents
Worksheets("ORG").Protect
End Sub


Public Sub ResetAnswers()
Dim n As name
Dim ActiveSht As String
ActiveSht = ActiveSheet.name
Worksheets(ActiveSht).Unprotect
For Each n In ActiveWorkbook.Names
    If nameMatchesOldSheetName(n.name, ActiveSht) Then
        Sheets(ActiveSht).Range(n).ClearContents
        Sheets(ActiveSht).Range(n).Interior.Color = 16772300
    End If
Next n
'ActiveSheet.Shapes(1).Left = 812.25
'ActiveSheet.Shapes(1).Top = 108.75

Worksheets(ActiveSht).Protect
End Sub

Public Function CheckAll() As String
Dim ShtName(11) As String
Dim ActiveSht As String, Check As String

Check = "pass"
ShtName(1) = "ORG"
ShtName(2) = "RM"
ShtName(3) = "ACM"
ShtName(4) = "IAM"
ShtName(5) = "TVM"
ShtName(6) = "SA"
ShtName(7) = "ISC"
ShtName(8) = "IR"
ShtName(9) = "EDM"
ShtName(10) = "WM"
ShtName(11) = "CPM"


Application.ScreenUpdating = False
Call WS_Unlock_All
For i = 1 To 11
    Worksheets(ShtName(i)).Activate

    ActiveSht = ActiveSheet.name
    For Each n In ActiveWorkbook.Names
        If nameMatchesOldSheetName(n.name, ActiveSht) And _
           VBA.Right(n.name, 6) <> "_Notes" Then
            If Sheets(ActiveSht).Range(n) = "" Then
                If n.name = "INTRO_Q2E_TEXT" Then
                    Sheets(ActiveSht).Range(n).Interior.Color = 16772300
                ElseIf n.name = "INTRO_Q3_TEXT" Then
                    Sheets(ActiveSht).Range(n).Interior.Color = 16772300
                Else
                    Sheets(ActiveSht).Range(n).Interior.Color = 13260
                    Check = "fail"
                End If
            Else
                If ShtName(i) <> "ORG" And _
                   Sheets(ActiveSht).Range(n) <> "Fully Implemented" And _
                   Sheets(ActiveSht).Range(n) <> "Partially Implemented" And _
                   Sheets(ActiveSht).Range(n) <> "Largely Implemented" And _
                   Sheets(ActiveSht).Range(n) <> "Not Implemented" Then
            
                   Sheets(ActiveSht).Range(n).Interior.Color = 255
                   Check = "fail"
                Else
                    Sheets(ActiveSht).Range(n).Interior.Color = 16772300
                End If
            End If
        End If
    Next n
Next i
Call WS_Lock_All

Sheet1.Activate
If Check = "fail" Then
    MsgBox "You have not completed all responses, the missing responses have been highlighted in red."
End If
CheckAll = Check
Application.ScreenUpdating = True
End Function

Public Sub ClearAll()
Dim ShtName(11) As String, i As Integer

ShtName(1) = "ORG"
ShtName(2) = "RM"
ShtName(3) = "ACM"
ShtName(4) = "IAM"
ShtName(5) = "TVM"
ShtName(6) = "SA"
ShtName(7) = "ISC"
ShtName(8) = "IR"
ShtName(9) = "EDM"
ShtName(10) = "WM"
ShtName(11) = "CPM"

Application.ScreenUpdating = False
Call WS_Unlock_All
For i = 1 To 11
    Worksheets(ShtName(i)).Activate
    If ShtName(i) = "ORG" Then
        ClearIntro
    Else
        ResetAnswers
    End If
Next i
Call WS_Lock_All
Application.ScreenUpdating = True
End Sub


Public Sub FillAll()
Dim ShtName(11) As String

ShtName(1) = "ORG"
ShtName(2) = "RM"
ShtName(3) = "ACM"
ShtName(4) = "IAM"
ShtName(5) = "TVM"
ShtName(6) = "SA"
ShtName(7) = "ISC"
ShtName(8) = "IR"
ShtName(9) = "EDM"
ShtName(10) = "WM"
ShtName(11) = "CPM"

Application.ScreenUpdating = False
Call WS_Unlock_All
For i = 1 To 11
    Worksheets(ShtName(i)).Activate
    InsertAnswers
Next i
Call WS_Lock_All

Sheet1.Activate
Application.ScreenUpdating = True
End Sub

Public Sub InsertAnswers()
Dim n As name
Dim ActiveSht As String

ActiveSht = ActiveSheet.name
For Each n In ActiveWorkbook.Names
    If nameMatchesOldSheetName(n.name, ActiveSht) And _
       VBA.Right(n.name, 6) <> "_Notes" Then
        If Not (n.name Like "INTRO_*") Then
            Sheets(ActiveSht).Range(n) = "Fully Implemented"
        End If
        'Sheets(ActiveSht).Range(n).TintAndShade = 0.799981688894314
    End If
Next n

End Sub

Public Function nameMatchesOldSheetName(n As String, newSName As String) As Boolean
    Dim newNames(11) As String
    Dim oldNames(11) As String
    Dim oldName As String
    Dim b As Boolean
    newNames(1) = "ORG"
    newNames(2) = "RM"
    newNames(3) = "ACM"
    newNames(4) = "IAM"
    newNames(5) = "TVM"
    newNames(6) = "SA"
    newNames(7) = "ISC"
    newNames(8) = "IR"
    newNames(9) = "EDM"
    newNames(10) = "WM"
    newNames(11) = "CPM"
    
    oldNames(1) = "ORG"
    oldNames(2) = "RISK"
    oldNames(3) = "ASSET"
    oldNames(4) = "ACCESS"
    oldNames(5) = "THREAT"
    oldNames(6) = "SITUATION"
    oldNames(7) = "SHARING"
    oldNames(8) = "RESPONSE"
    oldNames(9) = "DEPENDENCIES"
    oldNames(10) = "WORKFORCE"
    oldNames(11) = "CYBER"

    oldName = ""
    For j = 2 To 11
        If newNames(j) = newSName Then
            oldName = oldNames(j)
            Exit For
        End If
    Next
    If oldName = "" Then
        b = False
    Else
        If Left(n, Len(oldName)) = oldName And _
           Not (Right(n, 10) = "_Criterion" Or InStr("12345", Right(n, 1)) > 0) Then
            b = True
        Else
            b = False
        End If
    End If
    nameMatchesOldSheetName = b
End Function

Attribute VB_Name = "z_Excel"
Option Explicit

Enum Tbl_LookupReturn
    '----------------------------------------------------------------
    ' Tbl_LookupReturn    - Used with Function Tbl_Lookup
    '----------------------------------------------------------------
    FirstMatch = 1
    FirstMatchRowInTbl = 2
    AllMatch = 3
    AllMatchRowsInTbl = 4
End Enum

'*********************************************
'*/-----------------------------------------\*
'*|                                         |*
'*|        WORKBOOK FUNCTIONS               |*
'*|                                         |*
'*\-----------------------------------------/*
'*********************************************
Public Function WB_OpenOrSelect(WBDir As String, WBName As String) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' WB_OpenOrSelect    - Opens workbook if not already open, or selects open workbook
    '                    - In : WBDir As String, WBName As String (include extension)
    '                    - Out: selected workbook if avaliable, error if not available
    '                    - Last Updated: 7/4/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    If WB_IsOpen(WBName) = True Then
        Set WB_OpenOrSelect = Workbooks(WBName)
    Else
        If VBA.Right(WBDir, 1) <> "\" Then WBDir = WBDir & "\"
        Set WB_OpenOrSelect = Workbooks.Open(WBDir & WBName)
    End If
IsError:
    WB_OpenOrSelect = CVErr(xlErrNA)
    Debug.Print "Error in WB_OpenOrSelect: " & Err.Number & ": " & Err.Description
End Function

Public Function WB_Path() As String
    'Returns the path of the current workbook as a string
    'Last updated: 2012/02/08 by AJS
    WB_Path = ThisWorkbook.Path
End Function

Public Function WB_IsOpen(WBName As String) As Boolean
    '---------------------------------------------------------------------------------------------------------
    ' WB_IsOpen          - Check to see if workbook is open
    '                    - In : WBName As String (include ".xls" extension)
    '                    - Out: true if worbook is open, false if workbook is not open
    '                    - Last Updated: 3/6/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    Dim wBook As Workbook
    On Error Resume Next
    Set wBook = Workbooks(WBName)
    If wBook Is Nothing Then 'Not open
        Set wBook = Nothing
        WB_IsOpen = False
    Else 'It is open
        WB_IsOpen = True
    End If
End Function

Public Function ColumnLetter(ColumnNumber As Variant) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ColumnLetter  - Returns column letter of input column number, for up to 16348 columns
    '                 Tested 3/25/11 - significantly quicker than function ColumnLetter2; validated same
    '                       results either way
    '                 Alternate methods: ColumnLetter2 = Application.ConvertFormula("R1C" & ColumnNumber, xlR1C1, xlA1)
    '                                    ColumnLetter2 = Mid(ColumnLetter, 2, VBA.Len(ColumnLetter) - 3)
    '                                                    Tested 6/30/11 - Select Case is slightly quicker than using a Nested If function
    '               - In : ColumnNumber As Integer
    '               - Out: ColumnLetter as String
    '               - Last Updated: 6/30/11 by AJS
    '---------------------------------------------------------------------------------------------------------
     On Error GoTo IsError
     Select Case ColumnNumber
        Case Is > 1378
            'special case, the first 26 column set should be subtracted , 26*26 = 676
            ColumnLetter = VBA.Chr(Int((ColumnNumber - 26 - 1) / 676) + 64) & _
                            VBA.Chr(Int(((ColumnNumber - 1 - 26) Mod 676) / 26) + 65) & _
                            VBA.Chr(((ColumnNumber - 1) Mod 26) + 65)
        Case Is > 702   '(703-1377)
            'includes first column, 26*26 + 26=702
            ColumnLetter = VBA.Chr(Int(ColumnNumber / 702) + 64) & _
                            VBA.Chr(Int(((ColumnNumber - 1) Mod 702) / 26) + 65) & _
                            VBA.Chr(((ColumnNumber - 1) Mod 26) + 65)
        Case Is > 26    '(27-702)
            ColumnLetter = VBA.Chr(Int((ColumnNumber - 1) / 26) + 64) & _
                            VBA.Chr(((ColumnNumber - 1) Mod 26) + 65)
        Case Else       '(1-26)
            ColumnLetter = VBA.Chr(ColumnNumber + 64)
    End Select
    Exit Function
IsError:
    ColumnLetter = CVErr(xlErrNA)
    Debug.Print "Error in ColumnLetter: " & Err.Number & ": " & Err.Description
End Function

Public Function Picture_AddFromFile(FN As String, ImageName As String, _
                                    PasteRange As Range, WidthInches As Single, _
                                    WidthHeight As Single) As Variant
    '----------------------------------------------------------------
    ' Picture_AddFromFile   - Adds a picture as a shape to a worksheet
    '                       - In : FN As String, ImageName As String, PasteRange As Range,
    '                               WidthInches As Single, WidthHeight As Single
    '                       - Out: Boolean true if succesfully completed
    '                       - Last Updated: 5/31/11 by AJS
    '----------------------------------------------------------------
    Dim ThisShape As Shape
    On Error GoTo IsError
    Set ThisShape = PasteRange.Worksheet.Shapes.AddPicture(FN, msoFalse, msoTrue, _
                        PasteRange.Left, PasteRange.Top, _
                        Application.InchesToPoints(WidthInches), _
                        Application.InchesToPoints(WidthHeight))
    ThisShape.name = ImageName
    Picture_AddFromFile = True
    Exit Function
IsError:
    Picture_AddFromFile = CVErr(xlErrNA)
    Debug.Print "Error in Picture_AddFromFile: " & Err.Number & ": " & Err.Description
End Function

'*********************************************
'*/-----------------------------------------\*
'*|                                         |*
'*|        CELL COMMENT FUNCTIONS           |*
'*|                                         |*
'*\-----------------------------------------/*
'*********************************************
'Public Function Comment_AddPicture(CommentCell As Range, _
'                                    PictureFN As String, _
'                                    Optional ScaleFactor As Double = 1) As Boolean
'    '-----------------------------------------------------------------------------------------------------------
'    ' Comment_AddPicture - Adds a picture into a comment for an Excel cell; deletes current comment
'    '                    - In : Comment Cell as Range, PictureFN as string, Optional ScaleFactor as Double
'    '                    - Out: Boolean true if picture comment succesfully added
'    '                    - Requires: UserForm "Frm_Image" to be in the workbook in order to determine image
'    '                                   dimensions
'    '                    - Last Updated: 7/4/11 by AJS
'    '-----------------------------------------------------------------------------------------------------------
'
'    'DELETE EXISTING COMMENT
'    On Error Resume Next
'    CommentCell.Comment.Delete
'    On Error GoTo IsError
'
'    'CHECK TO SEE IF FILE EXISTS
'    If z_Files.GetFileInfo(PictureFN, FileExists) = False Then GoTo FileNotFound
'    If FileLen(PictureFN) = 0 Then GoTo FileNotFound
'
'    'LOAD PICTURE INTO COMMENT
'    Frm_Image.Image1.Picture = LoadPicture(PictureFN)
'    CommentCell.AddComment text:=" "
'    CommentCell.Comment.Visible = False
'    CommentCell.Comment.Shape.Fill.ForeColor.RGB = RGB(255, 255, 255)
'    CommentCell.Comment.Shape.Fill.UserPicture PictureFN
'    CommentCell.Comment.Shape.Height = Frm_Image.Image1.Height * ScaleFactor
'    CommentCell.Comment.Shape.Width = Frm_Image.Image1.Width * ScaleFactor
'    Comment_AddPicture = True
'    Exit Function
'FileNotFound:
'    CommentCell.AddComment text:="Image not found:" & vbNewLine & vbNewLine & PictureFN
'    CommentCell.Comment.Visible = False
'    Comment_AddPicture = False
'    Exit Function
'IsError:
'    Comment_AddPicture = False
'    Debug.Print "Error in Comment_AddPicture: " & Err.Number & ": " & Err.Description
'End Function

Public Function Comment_AddText(CommentCell As Range, _
                                    StringText As String, _
                                    Optional CommentHeight As Integer = 100, _
                                    Optional CommentWidth As Integer = 300) As Boolean
    '-----------------------------------------------------------------------------------------------------------
    ' Comment_AddText    - Adds a comment with the text specified by the user; deletes current comment
    '                    - In : CommentCell As Range
    '                           StringText As String
    '                           Optional CommentHeight As Integer = 100
    '                           Optional CommentWidth As Integer = 300
    '                    - Out: Boolean true if comment succesfully added
    '                    - Last Updated: 3/6/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    On Error Resume Next
    CommentCell.Comment.Delete
    On Error GoTo IsError
    CommentCell.AddComment StringText
    CommentCell.Comment.Visible = False
    CommentCell.Comment.Shape.Height = CommentHeight
    CommentCell.Comment.Shape.Width = CommentWidth
    Comment_AddText = True
    Exit Function
IsError:
    Comment_AddText = False
    Debug.Print "Error in Comment_AddText: " & Err.Number & ": " & Err.Description
End Function

'*********************************************
'*/-----------------------------------------\*
'*|                                         |*
'*|   EXCEL RANGE VALIDATION FUNCTIONS      |*
'*|                                         |*
'*\-----------------------------------------/*
'*********************************************

Public Function Validation_DoesItExist(cellRange As Range) As Boolean
    '----------------------------------------------------------------
    ' Validation_DoesItExist    - Tests to determine if validation exists on a range
    '                           - In : CellRange As Range
    '                           - Out: Boolean TRUE if validation exists, FALSE otherwise
    '                           - Last Updated: 7/3/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError
    If IsNumeric(cellRange.Validation.Type) Then Validation_DoesItExist = True
    Exit Function
IsError:
    Validation_DoesItExist = False
End Function

Public Function Validation_AddList(RangeToAddValidation As Range, _
                                    NamedRangeName As String, _
                                    Optional InputTitle As String, _
                                    Optional InputMessage As String) As Variant
    '---------------------------------------------------------------------------------
    ' Validation_AddList    - Adds a validation list to the selected cell
    '                       - In : RangeToAddValidation As Range, NamedRange As Range
    '                       - Out: Boolean true if validation succesfully added
    '                       - Created: 3/6/11 by AJS
    '                       - Modified: 6/1/11 by AJS
    '---------------------------------------------------------------------------------
    On Error Resume Next
    RangeToAddValidation.Validation.Delete
    On Error GoTo IsError
    With RangeToAddValidation.Validation
        .Add Type:=xlValidateList, _
                    AlertStyle:=xlValidAlertStop, _
                    Operator:=xlBetween, _
                    Formula1:="=" & NamedRangeName
        .InputMessage = InputMessage
        .InputTitle = InputTitle
    End With
    Validation_AddList = True
    Exit Function
IsError:
    Validation_AddList = CVErr(xlErrNA)
    Debug.Print "Error in Validation_AddList: " & Err.Number & ": " & Err.Description
End Function

Public Function Validiation_DeleteAll(cellRange As Range) As Variant
    '---------------------------------------------------------------------------------
    ' Validiation_DeleteAll - Deletes all validation in selected range
    '                       - In : CellRange As Range
    '                       - Out: Boolean true if validation succesfully deleted
    '                       - Last Updated: 5/2/11 by AJS
    '---------------------------------------------------------------------------------
    On Error GoTo IsError
    cellRange.Validation.Delete
    Validiation_DeleteAll = True
    Exit Function
IsError:
    Validiation_DeleteAll = CVErr(xlErrNA)
    Debug.Print "Error in Validiation_DeleteAll: " & Err.Number & ": " & Err.Description
End Function

Public Function Validation_WholeNumber(cellRange As Range, _
                                        Min As Long, Max As Long, _
                                        Optional InputTitle As String = "Whole Numbers Only", _
                                        Optional InputInstructions As String = "") As Variant
    '---------------------------------------------------------------------------------
    ' Validation_WholeNumber - Adds validation for any whole number within specified range
    '                        - In : CellRange As Range
    '                               Min As Long
    '                               Max As Long
    '                               InputTitle As String
    '                               InputInstructions As String
    '                        - Out: Boolean true if validation added, error if error
    '                        - Last Updated: 5/2/11 by AJS
    '---------------------------------------------------------------------------------
    On Error GoTo IsError
    With cellRange.Validation
        .Delete
        .Add Type:=xlValidateWholeNumber, AlertStyle:=xlValidAlertStop, _
                    Operator:=xlBetween, Formula1:=Min, Formula2:=Max
        .IgnoreBlank = True
        .InCellDropdown = True
        .InputTitle = InputTitle
        .ErrorTitle = ""
        .InputMessage = InputInstructions
        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With
    Validation_WholeNumber = True
    Exit Function
IsError:
    Validation_WholeNumber = CVErr(xlErrNA)
    Debug.Print "Error in Validation_WholeNumber: " & Err.Number & ": " & Err.Description
End Function

Public Function Validation_FreeText(cellRange As Range, _
                                    InputTitle As String, _
                                    InputInstructions As String) As Variant
    '---------------------------------------------------------------------------------
    ' Validation_FreeText    - Adds validation for any text, but includes input instructions
    '                        - In : CellRange As Range, InputTitle As String, InputInstructions As String
    '                        - Out: Boolean true if validation added
    '                        - Last Updated: 5/2/11 by AJS
    '---------------------------------------------------------------------------------
    On Error GoTo IsError
    With cellRange.Validation
        .Delete
        .Add Type:=xlValidateInputOnly, AlertStyle:=xlValidAlertStop, Operator:=xlBetween
        .IgnoreBlank = True
        .InCellDropdown = True
        .InputTitle = InputTitle
        .ErrorTitle = ""
        .InputMessage = InputInstructions
        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With
    Validation_FreeText = True
    Exit Function
IsError:
    Validation_FreeText = CVErr(xlErrNA)
    Debug.Print "Error in Validation_FreeText: " & Err.Number & ": " & Err.Description
End Function

'*********************************************
'*/-----------------------------------------\*
'*|                                         |*
'*|   EXCEL BORDER CELL FUNCTIONS           |*
'*|                                         |*
'*\-----------------------------------------/*
'*********************************************
Public Function Borders_AddStandard(TableRange As Range) As Variant
    '----------------------------------------------------------------
    ' Borders_AddStandard   - Adds standard thin line borders around range
    '                       - In : TableRange As Range
    '                       - Out: Boolean true if borders succesfully added
    '                       - Last Updated: 3/6/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError
    With TableRange
         'no diagonals
        .Borders(xlDiagonalDown).LineStyle = xlNone
        .Borders(xlDiagonalUp).LineStyle = xlNone
        'left border
        .Borders(xlEdgeLeft).LineStyle = xlContinuous
        .Borders(xlEdgeLeft).Weight = xlThin
        .Borders(xlEdgeLeft).ColorIndex = xlAutomatic
        'top border
        .Borders(xlEdgeTop).LineStyle = xlContinuous
        .Borders(xlEdgeTop).Weight = xlThin
        .Borders(xlEdgeTop).ColorIndex = xlAutomatic
        'bottom border
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
        .Borders(xlEdgeBottom).ColorIndex = xlAutomatic
        'right border
        .Borders(xlEdgeRight).LineStyle = xlContinuous
        .Borders(xlEdgeRight).Weight = xlThin
        .Borders(xlEdgeRight).ColorIndex = xlAutomatic
        'inside vertical
        If .Columns.Count > 1 Then
             .Borders(xlInsideVertical).LineStyle = xlContinuous
             .Borders(xlInsideVertical).Weight = xlThin
             .Borders(xlInsideVertical).ColorIndex = xlAutomatic
        End If
        'inside horizontal
        If .rows.Count > 1 Then
             .Borders(xlInsideHorizontal).LineStyle = xlContinuous
             .Borders(xlInsideHorizontal).Weight = xlThin
             .Borders(xlInsideHorizontal).ColorIndex = xlAutomatic
        End If
    End With
    Borders_AddStandard = True
    Exit Function
IsError:
    Borders_AddStandard = CVErr(xlErrNA)
    Debug.Print "Error in Borders_AddStandard: " & Err.Number & ": " & Err.Description
End Function

Public Function Borders_AddDblOutside(TableRange As Range) As Variant
    '----------------------------------------------------------------
    ' Borders_AddDblOutside - Adds double-line exterior border, and thin-line interior borders
    '                       - In : TableRange As Range
    '                       - Out: Boolean true if borders succesfully added
    '                       - Last Updated: 5/25/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError
    With TableRange
         'no diagonals
        .Borders(xlDiagonalDown).LineStyle = xlNone
        .Borders(xlDiagonalUp).LineStyle = xlNone
        'left border
        .Borders(xlEdgeLeft).LineStyle = xlDouble
        .Borders(xlEdgeLeft).Weight = xlThick
        .Borders(xlEdgeLeft).ColorIndex = xlAutomatic
        'top border
        .Borders(xlEdgeTop).LineStyle = xlDouble
        .Borders(xlEdgeTop).Weight = xlThick
        .Borders(xlEdgeTop).ColorIndex = xlAutomatic
        'bottom border
        .Borders(xlEdgeBottom).LineStyle = xlDouble
        .Borders(xlEdgeBottom).Weight = xlThick
        .Borders(xlEdgeBottom).ColorIndex = xlAutomatic
        'right border
        .Borders(xlEdgeRight).LineStyle = xlDouble
        .Borders(xlEdgeRight).Weight = xlThick
        .Borders(xlEdgeRight).ColorIndex = xlAutomatic
        'inside vertical
        If .Columns.Count > 1 Then
             .Borders(xlInsideVertical).LineStyle = xlContinuous
             .Borders(xlInsideVertical).Weight = xlThin
             .Borders(xlInsideVertical).ColorIndex = xlAutomatic
        End If
        'inside horizontal
        If .rows.Count > 1 Then
            .Borders(xlInsideHorizontal).LineStyle = xlContinuous
            .Borders(xlInsideHorizontal).Weight = xlThin
            .Borders(xlInsideHorizontal).ColorIndex = xlAutomatic
        End If
    End With
    Borders_AddDblOutside = True
    Exit Function
IsError:
    Borders_AddDblOutside = CVErr(xlErrNA)
    Debug.Print "Error in Borders_AddDblOutside: " & Err.Number & ": " & Err.Description
End Function

'************************************************
'*/--------------------------------------------\*
'*|                                            |*
'*|  EXCEL NAMED RANGE MANIPULATION FUNCTIONS  |*
'*|                                            |*
'*\--------------------------------------------/*
'************************************************
Public Function NamedRange_Exists(RngName, Optional WB As Workbook, Optional SN As String) As Boolean
    'Boolean returns TRUE if named range exists, and FALSE if it does not exist
    'Last Updated: 2012-04-20 by AJS
    Dim addr As String
    On Error GoTo NotFound:
    If SN = "" Then
        addr = Range(RngName).Address
        Else: addr = WB.Sheets(SN).Range(RngName).Address: End If
    'If no error then range found
    NamedRange_Exists = True
    Exit Function
NotFound:
    'If error then named range not found
    NamedRange_Exists = False
End Function

Public Function NamedRange_Add(NamedRange As Range, _
                                NamedRangeName As String, _
                                Optional WorkbookRange As Boolean = True) As Variant
    '----------------------------------------------------------------
    ' NamedRange_Add     - Add named range to Worbook or Worksheet
    '                    - In : NamedRange As Range
    '                           NamedRangeName As String
    '                           WorkbookRange As boolean [toggles workbook or worksheet range,
    '                                                       by default true=workbook]
    '                    - Out: Boolean true/false if succesfully completed
    '                    - Last Updated: 3/6/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError
    If WorkbookRange = True Then
        ActiveWorkbook.Names.Add name:=NamedRangeName, _
                RefersTo:="='" & NamedRange.Worksheet.name & "'!" & NamedRange.Address
    Else
        Sheets(NamedRange.Worksheet.name).Names.Add name:=NamedRangeName, _
                RefersTo:="='" & NamedRange.Worksheet.name & "'!" & NamedRange.Address
    End If
    On Error GoTo 0
    NamedRange_Add = True
    Exit Function
IsError:
    NamedRange_Add = CVErr(xlErrNA)
    Debug.Print "Error in NamedRange_Add: " & Err.Number & ": " & Err.Description
End Function

Public Function NamedRange_AddValueIfUnique(Value As String, _
                                            NamedRangeName As String, _
                                            RangeIncludesHeader As Boolean) As Variant
    '----------------------------------------------------------------
    ' NamedRange_AddValueIfUnique   - Adds value to named range if it doesn't already exist
    '                               - In : Value As String
    '                                      NamedRangeName As String
    '                               - Out: Boolean TRUE if value added, FALSE if already exists, error if error
    '                               - Requires: Range_FindMatch
    '                               - Last Updated: 2/1/12 by AJS
    '----------------------------------------------------------------
    Dim NamedRange As Range
    Set NamedRange = Range(NamedRangeName)
    If IsError(Range_FindMatch(Value, NamedRange)) = True Then
        NamedRange.Worksheet.Cells(NamedRange.row + NamedRange.rows.Count, NamedRange.Column) = Value
        NamedRange_Add z_Excel.ExtDown(NamedRange), NamedRangeName
        Range_Sort Range(NamedRangeName), RangeIncludesHeader
        NamedRange_AddValueIfUnique = True
    Else
        NamedRange_AddValueIfUnique = False
    End If
    Exit Function
IsError:
    NamedRange_AddValueIfUnique = CVErr(xlErrNA)
    Debug.Print "Error in NamedRange_AddValueIfUnique: " & Err.Number & ": " & Err.Description
End Function

Public Function NamedRange_Replace(NamedRangeName As String, ReplaceCollection As Collection) As Boolean
    '----------------------------------------------------------------
    ' NamedRange_Replace   - Replace all fields currently listed in named range with new fields in a collection
    '                      - In : NamedRangeName As String, ReplaceCollection as Collection
    '                      - Out: Boolean TRUE if sucesfully completed, FALSE if unsuccesfull
    '                      - Last Updated: 9/28/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError
    Dim FirstCell As String, eachCell As Variant, row As Long
    Dim col As String, ws As String, FirstRow As Long
    'get information on first cell
    ws = Range(NamedRangeName).Worksheet.name
    col = ColumnLetter(Range(NamedRangeName).Column)
    FirstRow = Range(NamedRangeName).row
    'clear existing cells
    For Each eachCell In Range(NamedRangeName)
        eachCell.Value = ""
    Next
    'update with new values
    If ReplaceCollection.Count > 0 Then
        row = FirstRow
        For Each eachCell In ReplaceCollection
            Sheets(ws).Range(col & row) = CStr(eachCell)
            row = row + 1
        Next
        z_Excel.NamedRange_Add ExtDown(Sheets(ws).Range(col & FirstRow)), NamedRangeName
    Else
        z_Excel.NamedRange_Add Sheets(ws).Range(col & FirstRow), NamedRangeName
    End If
    NamedRange_Replace = True
    Exit Function
IsError:
    NamedRange_Replace = False
    Debug.Print "Error in NamedRange_Replace: " & Err.Number & ": " & Err.Description
End Function

'************************************************
'*/--------------------------------------------\*
'*|                                            |*
'*|  EXCEL HYPERLINK FUNCTIONS                 |*
'*|                                            |*
'*\--------------------------------------------/*
'************************************************

Public Function Hyperlink_Add(AnchorRange As Range, _
                                HyperlinkAddress As String, _
                                TextToDisplay As String) As Variant
    '----------------------------------------------------------------
    ' Hyperlink_Add          - Adds a hyperlink to a cell range
    '                        - In : AnchorRange As Range, HyperlinkAddress As String, TextToDisplay As String
    '                        - Out: Boolean true if hyperlink succesfully added
    '                        - Last Updated: 3/6/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError
    AnchorRange.Worksheet.Hyperlinks.Add Anchor:=AnchorRange, _
                                            Address:=HyperlinkAddress, _
                                            TextToDisplay:=TextToDisplay
    Hyperlink_Add = True
    Exit Function
IsError:
    Hyperlink_Add = CVErr(xlErrNA)
    Debug.Print "Error in Hyperlink_Add: " & Err.Number & ": " & Err.Description
End Function


'************************************************
'*/--------------------------------------------\*
'*|                                            |*
'*|  EXCEL LIST BOX ACTIVE OBJECT FUNCTIONS    |*
'*|                                            |*
'*\--------------------------------------------/*
'************************************************
Public Function ListBox_ReturnSelected(List_Box_OLE_Object As Variant) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' ListBox_ReturnSelected    - Returns selected fields from a multiselect list box
    '                           - In : List_Box_OLE_Object as ListBox Object
    '                           - Out: Collection of selected text or empty collection
    '                           - Last Updated: 9/28/11 by AJS
    ' Example function call:
    '       Set NewColl = ListBox_ReturnSelected(Sheet1.OLEObjects("List Box 1"))
    '-----------------------------------------------------------------------------------------------------------
    Dim i As Integer
    Dim ListCount As Integer
    Dim ReturnCol As New Collection
    On Error GoTo IsError
    With List_Box_OLE_Object
        ListCount = .Object.ListCount - 1
        For i = 0 To ListCount
            If .Object.Selected(i) = True Then ReturnCol.Add .Object.List(i)
        Next i
    End With
    Set ListBox_ReturnSelected = ReturnCol
    Exit Function
IsError:
    ListBox_ReturnSelected = CVErr(xlErrNA)
    Debug.Print "Error in ListBox_ReturnSelected: " & Err.Number & ": " & Err.Description
End Function

Public Function ListBox_CenterInRange(rng As Range, LB As Variant, _
                            Optional Buffer As Integer = 5) As Boolean
    'Centers an item in the range of a worksheet
    'Last updated: 2012-04-22 by AJS
    On Error GoTo IsError
    With LB
        .Left = rng.Left + Buffer
        .Width = rng.Width - Buffer * 2
        .Top = rng.Top + Buffer
        .Height = rng.Height - Buffer * 2
    End With
    ListBox_CenterInRange = True
    Exit Function
IsError:
    ListBox_CenterInRange = False
End Function

'************************************************
'*/--------------------------------------------\*
'*|                                            |*
'*|  EXCEL EMBEDDED OBJECT FUNCTIONS           |*
'*|                                            |*
'*\--------------------------------------------/*
'************************************************
Public Function EmbededObject_Add(FullFileName As String, _
                                    SheetRange As Range, _
                                    Optional NameInExcel As String) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' EmbededObject_Add   - embed an object (such as a text file or picture) to a worksheet
    '                     - In : FullFilename As String
    '                             SheetRange As String
    '                             Optional NameInExcel As String
    '                     - Out: Boolean true/false if succesfully completed
    '                     - Last Updated: 4/22/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Dim OBJ As Variant
    On Error GoTo IsError
    
    'CHECK TO SEE IF FILE EXISTS
    If z_Files.GetFileInfo(FullFileName, FileExists) = False Then GoTo FileNotFound
    If FileLen(FullFileName) = 0 Then GoTo FileNotFound

    If SheetRange.Address <> "" Then
        SheetRange.Worksheet.Activate
        SheetRange.Select
    End If
    Set OBJ = ActiveSheet.OLEObjects.Add(FileName:=FullFileName, Link:=False, DisplayAsIcon:=False)
    If NameInExcel <> "" Then OBJ.name = NameInExcel

    EmbededObject_Add = True
    Exit Function
FileNotFound:
    EmbededObject_Add = False
    Exit Function
IsError:
    EmbededObject_Add = CVErr(xlErrNA)
    Debug.Print "Error in EmbededObject_Add: " & Err.Number & ": " & Err.Description
End Function

Public Function EmbededObject_ClearAllInWB() As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' EmbededObject_ClearAllInWB    - embed an object (such as a text file or picture) to a worksheet
    '                               - Out: Boolean true/false if succesfully completed
    '                               - Last Updated: 7/4/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Application.ScreenUpdating = False
    Dim thisObj As Object
    Dim thisWS As Worksheet
    On Error GoTo IsError
    For Each thisWS In ThisWorkbook
        For Each thisObj In thisWS.OLEObjects
            thisObj.Delete
        Next
    Next
    EmbededObject_ClearAllInWB = True
    Exit Function
IsError:
    EmbededObject_ClearAllInWB = CVErr(xlErrNA)
    Debug.Print "Error in EmbededObject_ClearAllInWB: " & Err.Number & ": " & Err.Description
End Function

'****************************************************
'*/------------------------------------------------\*
'*|                                                |*
'*|  TABLE MANIPULATION FUNCTIONS                  |*
'*|    (standard manipulation of data stored       |*
'*|     in an Excel-based table, with              |*
'*|     one header row at top and multiple rows)   |*
'*|                                                |*
'*\------------------------------------------------/*
'****************************************************

Public Function Tbl_Lookup(tbl As Range, _
                           ReturnColumnName As String, _
                           LookupReturn As Tbl_LookupReturn, _
                           ParamArray SearchCriteria() As Variant) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' Tbl_Lookup         - Returns a collection or a single value of matches that equal each SearchCritiera
    '                       This is a substitute to the INDEX/MATCH or SUMPRODUCT method of match multiple criteria
    '                    - In : Tbl As Range [Table Range to Search, Including Headers]
    '                           ReturnColumnName As String [Name of Return Column in Header]
    '                           LookupReturn As Tbl_LookupReturn [FirstMatch, FirstMatchRow, AllMatch, AllMatchRows]
    '                           ParamArray SearchCriteria() As Variant [Match criteria, in this format: Array("Name=Bob","Age=13")]
    '                    - Out: FirstMatch will be string of match
    '                           FirstMatchRow will be the relative row references in the table
    '                           AllMatch will be a collection of ALL matches
    '                           AllMatchRows will be a collection of all relative row references in the table
    '                           IF NO MATCH, WILL RETURN AN ERROR!
    '                    - Last Updated: 7/4/11
    '---------------------------------------------------------------------------------------------------------
    '   EXAMPLE FUNCTION CALLS:
    '   ------------------------
    '    Debug.Print "FirstMatch: " & Tbl_Lookup(Range("Tbl") "Hair Color", FirstMatch, Array("Name=Andy", "Age=2"))
    '    For Each eachItem In Tbl_Lookup(Range("Tbl"), "Hair Color", AllMatch, Array("Name=Andy", "Age=2"))
    '        Debug.Print "AllMatch: " & CStr(eachItem)
    '    Next
    '---------------------------------------------------------------------------------------------------------
    Dim eachItem As Variant, EachRow As Variant
    Dim ColName() As String, MatchCriteria() As String, ColNum() As Integer
    Dim SplitVal2() As String, i As Integer, ReturnCol As Integer
    Dim MatchFound As Boolean
    Dim ReturnCollection As New Collection
                            
    'BREAK UP ALL MATCH CRITERIA
    On Error GoTo IsError
    ReDim ColName(0 To UBound(SearchCriteria(0)))
    ReDim MatchCriteria(0 To UBound(SearchCriteria(0)))
    ReDim ColNum(0 To UBound(SearchCriteria(0)))
    For i = 0 To UBound(SearchCriteria(0))
        SplitVal2 = Split(SearchCriteria(0)(i), "=")
        ColName(i) = SplitVal2(0)
        MatchCriteria(i) = SplitVal2(1)
        ColNum(i) = Range_FindMatch(SplitVal2(0), tbl.rows(1).Cells)
    Next i
    
    'FIND RETURN COLUMN
    ReturnCol = Range_FindMatch(ReturnColumnName, tbl.rows(1).Cells)
    
    'FIND MATCHES IN TABLE
    For Each EachRow In tbl.Columns(1).Cells    'Search each row in table
        MatchFound = True
        For i = 0 To UBound(SearchCriteria(0))  'Search each match criteria
            If MatchCriteria(i) <> EachRow.Offset(0, ColNum(0) - 1).Value Then
                MatchFound = False
                Exit For
            End If
        Next i
        If MatchFound = True Then
            ' FirstMatch = 1, FirstMatchRow = 2, AllMatch = 3, AllMatchRows = 4
            Select Case LookupReturn
                Case 1
                    Tbl_Lookup = EachRow.Offset(0, ReturnCol - 1).Value
                    Exit Function
                Case 2
                    Tbl_Lookup = EachRow.row
                    Exit Function
                Case 3
                    ReturnCollection.Add EachRow.Offset(0, ReturnCol - 1).Value
                Case 4
                    ReturnCollection.Add EachRow.row
            End Select
        End If
    Next
    'return collection or error, depending on if collection is available
    If ReturnCollection.Count > 0 Then
        Set Tbl_Lookup = ReturnCollection
    Else
        Tbl_Lookup = CVErr(xlErrNA)
    End If
    Exit Function
IsError:
    Tbl_Lookup = CVErr(xlErrNA)
    Debug.Print "Error in Tbl_Lookup: " & Err.Number & ": " & Err.Description
End Function

Public Function Tbl_ReturnUniqueList(SearchRange As Range) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Tbl_ReturnUniqueList  - Returns a collection of unique values in the specified range
    '                       - In : SearchRange As Range
    '                       - Out: A string collection of unique values
    '                       - Last Updated: 6/24/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    ' Example call:
    ' Dim ThisCollection as New Collection
    ' Set ThisCollection = Tbl_ReturnUniqueList(SearchRange)
    '-----------------------------------------------------------------------------------------------------------
    Dim eachRng As Range
    Dim UniqueCollection As New Collection
    Dim CollectionItem As Variant
    Dim Unique As Boolean
    
    On Error GoTo IsError
    For Each eachRng In SearchRange
        Unique = True
        For Each CollectionItem In UniqueCollection
            If eachRng.Value = CollectionItem Then
                Unique = False
                Exit For
            End If
        Next
        If Unique = True Then UniqueCollection.Add eachRng.Value
    Next
    Set Tbl_ReturnUniqueList = UniqueCollection
    Exit Function
IsError:
    Tbl_ReturnUniqueList = CVErr(xlErrNA)
    Debug.Print "Error in Tbl_ReturnUniqueList: " & Err.Number & ": " & Err.Description
End Function

Public Function Tbl_GetHeaderColumn(SearchField As String, _
                                    SearchRange As Range, _
                                    Optional ReturnNumeric As Boolean = False) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Tbl_GetHeaderColumn   - Returns the column of the header, either numeric or column letter
    '                       - In : SearchField As String
    '                               SearchRange As Range
    '                               Optional ReturnNumeric As Boolean = False [by default returns Column Letter]
    '                       - Out: Column Letter or Number of match, or error if not found
    '                       - Last Updated: 6/24/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Dim ReturnColumn As Variant
    
    On Error GoTo IsError
    ReturnColumn = SearchRange.Column + _
        WorksheetFunction.Match(SearchField, SearchRange.rows(1).Cells, False) - 1
    If ReturnNumeric = False Then ReturnColumn = z_Excel.ColumnLetter(CLng(ReturnColumn))
    Tbl_GetHeaderColumn = ReturnColumn
    Exit Function
IsError:
    Tbl_GetHeaderColumn = -999
End Function

'****************************************************
'*/------------------------------------------------\*
'*|                                                |*
'*|  EXTEND RANGE FUNCTIONS                        |*
'*|                                                |*
'*\------------------------------------------------/*
'****************************************************
Public Function ExtTbl(rng As Range, _
                       Optional RowOffset As Long = 0, _
                       Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtTbl             - Extends the table down to the first blank at bottom of top right row/column
    '                           will stop at the first blank row
    '                    - In : Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: Tbl_ExtTbl as Range
    '                    - Last Updated: 4/7/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    Set ExtTbl = z_Excel.ExtRight(z_Excel.ExtDown(rng.Offset(RowOffset, ColOffset), 0, 0), 0, 0)
    Exit Function
IsError:
    ExtTbl = CVErr(xlErrNA)
    Debug.Print "Error in ExtTbl: " & Err.Number & ": " & Err.Description
End Function

Public Function ExtDown(rng As Range, _
                        Optional RowOffset As Long = 0, _
                        Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtDown            - Extends the selected range down to the final non-blank row in current table;
    '                           will stop at the first blank row
    '                    - In : Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: Tbl_ExtDown as Range
    '                    - Last Updated: 4/7/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    Set rng = rng.Offset(RowOffset, ColOffset)
    If IsEmpty(rng.Offset(1, 0)) Then
        Set ExtDown = rng
    Else
        Set ExtDown = Range(rng, rng.End(xlDown))
    End If
    Exit Function
IsError:
    ExtDown = CVErr(xlErrNA)
    Debug.Print "Error in ExtDown: " & Err.Number & ": " & Err.Description
End Function

Public Function ExtRight(rng As Range, _
                         Optional RowOffset As Long = 0, _
                         Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtRight           - Extends the selected range down to the final non-blank column in current table;
    '                           will stop at the first blank column
    '                    - In : Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: ExtRight as Range
    '                    - Last Updated: 4/7/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    Set rng = rng.Offset(RowOffset, ColOffset)
    If IsEmpty(rng.Offset(0, 1)) Then
        Set ExtRight = rng
    Else
        Set ExtRight = Range(rng, rng.End(xlToRight))
    End If
    Exit Function
IsError:
    ExtRight = CVErr(xlErrNA)
    Debug.Print "Error in ExtRight: " & Err.Number & ": " & Err.Description
End Function

Public Function ExtDownNonBlank(rng As Range, _
                                Optional RowOffset As Long = 0, _
                                Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtDownNonBlank    - Extends the range down to the first non-blank at bottom-left of selected range;
    '                           will stop at the first blank row where a formula evaluates to a value
    '                    - In : Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: ExtDownNonBlank as Range
    '                    - Created: 5/15/11 by GH
    '                    - Last Updated: 6/1/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    Dim NewRng As Range
    Dim LastRow As Long
    
    On Error GoTo IsError
    Set NewRng = ExtDown(rng, RowOffset, ColOffset)
    For LastRow = NewRng.rows.Count To 1 Step -1
        If Not NewRng.Cells(LastRow, 1) = "" Then Exit For
    Next LastRow
    Set ExtDownNonBlank = NewRng.Resize(LastRow, NewRng.Columns.Count)
    Exit Function
IsError:
    ExtDownNonBlank = CVErr(xlErrNA)
    Debug.Print "Error in ExtDownNonBlank: " & Err.Number & ": " & Err.Description
End Function

Public Function ExtTblNonBlank(rng As Range, _
                               Optional RowOffset As Long = 0, _
                               Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtTblNonBlank     - Extends the range down and right to the first non-blank at bottom-left of selected range;
    '                           will stop at the first blank row where a formula evaluates to a value
    '                    - In : Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: ExtTblNonBlank as Range
    '                    - Created: 5/15/11 by GH
    '                    - Last Updated: 6/1/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    Set ExtTblNonBlank = z_Excel.ExtRight(ExtDownNonBlank(rng.Offset(RowOffset, ColOffset), 0, 0), 0, 0)
    Exit Function
IsError:
    ExtTblNonBlank = CVErr(xlErrNA)
    Debug.Print "Error in ExtTblNonBlank: " & Err.Number & ": " & Err.Description
End Function

Public Function ExtAllTbl(ByRef rng As Range, _
                          Optional RowOffset As Long = 0, _
                          Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtAllTbl          - Extends the selected range right and down to the final non-blank row if
    '                           leftmost column and the final non-blank row in topmost row
    '                    - In : ByRef Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: ExtAllTbl as Range
    '                    - Last Updated: 3/9/11 by AJS (originally from GH)
    '---------------------------------------------------------------------------------------------------------
    Dim RightmostColumn As Long
    Dim BottomRow As Long
    
    On Error GoTo IsError
    Set rng = rng.Offset(RowOffset, ColOffset)
    BottomRow = Application.Max(LastRow(rng.Worksheet, rng.Column), rng.row)
    RightmostColumn = Application.Max(LastColumn(rng.Worksheet, rng.row), rng.Column)
    Set ExtAllTbl = rng.Resize(RowSize:=(BottomRow - rng.rows.Count - rng.row + 2), _
                        ColumnSize:=(RightmostColumn - rng.Columns.Count - rng.Column + 2))
    Exit Function
IsError:
    ExtAllTbl = CVErr(xlErrNA)
    Debug.Print "Error in ExtAllTbl: " & Err.Number & ": " & Err.Description
End Function

Public Function ExtAllDown(ByRef rng As Range, _
                           Optional RowOffset As Long = 0, _
                           Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtAllDown         - Extends the selected range down to the final non-blank row in leftmost column
    '                    - In : ByRef Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: ExtAllDown as Range
    '                    - Last Updated: 3/9/11 by AJS (originally from GH)
    '---------------------------------------------------------------------------------------------------------
    Dim BottomRow As Long
    Set rng = rng.Offset(RowOffset, ColOffset)
    BottomRow = Application.Max(LastRow(rng.Worksheet, rng.Column), rng.row)
    Set ExtAllDown = rng.Resize(RowSize:=(BottomRow - rng.rows.Count - rng.row + 2))
    Exit Function
IsError:
    ExtAllDown = CVErr(xlErrNA)
    Debug.Print "Error in ExtAllDown: " & Err.Number & ": " & Err.Description
End Function

Public Function ExtAllRight(ByRef rng As Range, _
                            Optional RowOffset As Long = 0, _
                            Optional ColOffset As Long = 0) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' ExtAllRight        - Extends the selected range right to the final non-blank row in topmost row
    '                    - In : ByRef Rng As Range, Optional RowOffset As Long = 0, Optional ColOffset As Long = 0
    '                    - Out: ExtAllRight as Range
    '                    - Last Updated: 3/9/11 by AJS (originally from GH)
    '---------------------------------------------------------------------------------------------------------
    Dim RightmostColumn As Long
    Set rng = rng.Offset(RowOffset, ColOffset)
    RightmostColumn = Application.Max(LastColumn(rng.Worksheet, rng.row), rng.Column)
    Set ExtAllRight = rng.Resize(ColumnSize:=(RightmostColumn - rng.Columns.Count - rng.Column + 2))
    Exit Function
IsError:
    ExtAllRight = CVErr(xlErrNA)
    Debug.Print "Error in ExtAllRight: " & Err.Number & ": " & Err.Description
End Function

Private Function LastRow(ByVal OfSheet As Worksheet, Optional ByVal InColumn As Long = 0) As Long
    '---------------------------------------------------------------------------------------------------------
    ' LastRow            - Returns the number of the last used row in the specified sheet [and column]
    '                    - In : ByVal OfSheet As Worksheet, Optional ByVal InColumn As Long = 0
    '                    - Out: LastRow as Range
    '                    - Last Updated: 3/9/11 by AJS (originally from GH)
    '---------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    If InColumn = 0 Then
        LastRow = OfSheet.UsedRange.row + OfSheet.UsedRange.rows.Count - 1
    Else
        LastRow = OfSheet.Cells(Application.rows.Count, InColumn).End(xlUp).row
    End If
    Exit Function
IsError:
    LastRow = CVErr(xlErrNA)
    Debug.Print "Error in LastRow: " & Err.Number & ": " & Err.Description
End Function

Private Function LastColumn(ByVal OfSheet As Worksheet, Optional ByVal InRow As Long = 0) As Integer
    '---------------------------------------------------------------------------------------------------------
    ' LastColumn         - Returns the number of the last used column in the specified sheet [and row]
    '                    - In : ByVal OfSheet As Worksheet, Optional ByVal InRow As Long = 0
    '                    - Out: LastColumn as Range
    '                    - Last Updated: 3/9/11 by AJS (originally from GH)
    '---------------------------------------------------------------------------------------------------------
    Dim i As Integer, letter As String
    On Error GoTo IsError
    If InRow = 0 Then
        i = OfSheet.UsedRange.Columns.Count + 1
        Do
            i = i - 1
            LastColumn = OfSheet.UsedRange.Columns(i).Cells(1, 1).Column
            letter = z_Excel.ColumnLetter(LastColumn)
        Loop Until (Application.WorksheetFunction.CountA(OfSheet.Range(letter & ":" & letter)) > 0 Or i < 2)
    Else
        LastColumn = OfSheet.Cells(InRow, Application.Columns.Count).End(xlToLeft).Column
    End If
    Exit Function
IsError:
    LastColumn = CVErr(xlErrNA)
    Debug.Print "Error in LastColumn: " & Err.Number & ": " & Err.Description
End Function

'****************************************************
'*/------------------------------------------------\*
'*|                                                |*
'*|  TABLE MANIPULATION FUNCTIONS                  |*
'*|    (standard manipulation of data stored       |*
'*|     in an Excel-based table, with              |*
'*|     one header row at top and multiple rows)   |*
'*|                                                |*
'*\------------------------------------------------/*
'****************************************************

Public Function Range_Set(WSName As String, LowCol As Variant, LowRow As Variant, _
                            Optional HighCol As Variant, Optional HighRow As Variant) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Range_Set             - Returns a range set using various permutations of inputs
    '                       -     Range_Set("Home", 2, 3) = 'Home'!$B$3
    '                       -     Range_Set("Home", "B", 3) = 'Home'!$B$3
    '                       -     Range_Set("Home", 2, 3, 4, 5) = 'Home'!$B$3:$D$5
    '                       -     Range_Set("Home", "B", 3, "D", 5) = 'Home'!$B$3:$D$5
    '                       - In : WSName As String, LowCol As Variant, LowRow As Variant,
    '                               Optional HighCol As Variant, Optional HighRow As Variant
    '                       - Out: Range Object if succesful, error if otherwise
    '                       - Last Updated: 8/22/11
    '-----------------------------------------------------------------------------------------------------------
    On Error GoTo IsError:
    If IsMissing(HighRow) And IsMissing(HighCol) Then
        Set Range_Set = Sheets(WSName).Cells(LowRow, LowCol)
    ElseIf IsNumeric(LowCol) And IsNumeric(HighCol) Then
        Set Range_Set = Sheets(WSName).Range( _
                            Sheets(WSName).Cells(LowRow, LowCol), _
                            Sheets(WSName).Cells(HighRow, HighCol))
    Else
        Set Range_Set = Sheets(WSName).Range( _
                            LowCol & LowRow & ":" & _
                            HighCol & HighRow)
    End If
    Exit Function
IsError:
    Range_Set = CVErr(xlErrNA)
    Debug.Print "Error in Range_Set: " & Err.Number & ": " & Err.Description
End Function

Public Function Range_CopyPasteValues(CopyRange As Range, PasteRange As Range) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Range_CopyPasteValues - Copies and pastes values only
    '                       - In : CopyRange As Range
    '                               PasteRange As Range
    '                       - Last Updated: 7/4/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    PasteRange.Value = CopyRange.Value
    Range_CopyPasteValues = True
    Exit Function
IsError:
    Range_CopyPasteValues = CVErr(xlErrNA)
    Debug.Print "Error in Range_CopyPasteValues: " & Err.Number & ": " & Err.Description
End Function

Public Function Range_CopyPasteAll(CopyRange As Range, PasteRange As Range) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Range_CopyPasteAll    - Copies and pastes everything, including formatting
    '                           Known bug- only copies and pastes visible cells
    '                       - In : CopyRange As Range
    '                               PasteRange As Range
    '                       - Last Updated: 7/4/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    CopyRange.Copy
    PasteRange.PasteSpecial (xlPasteAll)
    Application.CutCopyMode = False
    Range_CopyPasteAll = True
    Exit Function
IsError:
    Range_CopyPasteAll = CVErr(xlErrNA)
    Debug.Print "Error in Range_CopyPasteAll: " & Err.Number & ": " & Err.Description
End Function

Public Function Range_Sort(wsRange As Range, RangeIncludesHeader As Boolean) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Range_Sort         - Sorts the selected range, w/ or w/o header
    '                    - In : wsRange As Range, Header As Boolean
    '                    - Last Updated: 3/9/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    Dim HeaderType As Integer
    Select Case RangeIncludesHeader
        Case True
            HeaderType = 1
        Case False
            HeaderType = 2
    End Select
    wsRange.Sort Key1:=wsRange.Cells(1), _
                        Order1:=xlAscending, _
                        Header:=HeaderType, _
                        MatchCase:=False, _
                        Orientation:=xlTopToBottom, _
                        DataOption1:=xlSortNormal
    Range_Sort = True
    Exit Function
IsError:
    Range_Sort = False
    Debug.Print "Error in Range_Sort: " & Err.Number & ": " & Err.Description
End Function

Public Function Range_GetMaxRow(FirstCellInRange As Range) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Range_GetMaxRow      Returns the maximum row down using ExtDown from a Range
    '                      In : FirstCellInRange As Range
    '                      Out: Maximum Row ID or an error
    '                      Last Updated: 8/18/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    On Error GoTo IsError:
    Range_GetMaxRow = FirstCellInRange.row + z_Excel.ExtDown(FirstCellInRange).rows.Count - 1
    Exit Function
IsError:
    Range_GetMaxRow = CVErr(xlErrNA)
    Debug.Print "Error in Function Range_GetMaxRow: " & Err.Number & ": " & Err.Description
End Function

'Public Function Range_ConvertTo1DArray(InputRange As Range) As Variant
'    '-----------------------------------------------------------------------------------------------------------
'    ' Range_ConvertTo1DArray      Converts a range of values into a 1-D array
'    '                             In : InputRange As Range
'    '                             Last Updated: 7/28/11 by AJS
'    '-----------------------------------------------------------------------------------------------------------
'    On Error GoTo IsError
'    Dim eachCell As Range
'    Dim OutputArray() As Variant
'    Dim Counter As Long
'
'    ReDim OutputArray(0 To InputRange.Cells.Count - 1)
'    Counter = 0
'    For Each eachCell In InputRange
'        OutputArray(Counter) = eachCell.Value
'        Counter = Counter + 1
'    Next
'    Range_ConvertTo1DArray = OutputArray
'    Exit Function
'IsError:
'    Range_ConvertTo1DArray = CVErr(xlna)
'    Debug.Print "Error in Range_ConvertTo1DArray: " & Err.Number & ": " & Err.Description
'End Function

'Private Function Range_ConvertToArray(InputRange As Range) As Variant
'    '-----------------------------------------------------------------------------------------------------------
'    ' Range_ConvertToArray      Converts a range of values into an array, size number of rows x number of columns
'    '                           In : InputRange As Range
'    '                           Last Updated: 7/28/11 by AJS
'    '-----------------------------------------------------------------------------------------------------------
'    On Error GoTo IsError
'    Range_ConvertToArray = InputRange.Value2
'    Exit Function
'IsError:
'    Range_ConvertToArray = CVErr(xlna)
'    Debug.Print "Error in Range_ConvertToArray: " & Err.Number & ": " & Err.Description
'End Function

Public Function Range_FindMatch(SearchString As String, SearchRange As Range) As Variant
    '----------------------------------------------------------------
    ' Range_FindMatch       - Searches named range to see if string matches
    '                       - In : SearchString As String, SearchRange As Range
    '                       - Out: Index of matched string, if found, FALSE if not match
    '                       - Last Updated: 3/24/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError
    Range_FindMatch = WorksheetFunction.Match(SearchString, SearchRange, False)
    Exit Function
IsError:
    'Range_FindMatch = CVErr(xlErrNA)
    Range_FindMatch = -999
End Function

Private Function DoesFileExist(FN As String) As Variant
    Dim fso As Object
    On Error GoTo IsError
    Set fso = CreateObject("Scripting.FileSystemObject")
    DoesFileExist = fso.FileExists(FN)
    Exit Function
IsError:
    DoesFileExist = CVErr(xlErrNA)
    Debug.Print "Error in Private Function DoesFileExist: " & Err.Number & ": " & Err.Description
End Function

'****************************************************
'*/------------------------------------------------\*
'*|                                                |*
'*|  ERROR TRAPPING FUNCTIONS                      |*
'*|    (traps errors that would cause runtime      |*
'*|     errors unless otherwise caught, such as    |*
'*|     does a worksheet exist or a chart exist)   |*
'*|                                                |*
'*\------------------------------------------------/*
'****************************************************
Public Function ErrorTrap_WSExists(WSName As String) As Boolean
    '----------------------------------------------------------------
    ' ErrorTrap_WSExists    - Returns TRUE if worksheet exists, FALSE if it doesn't
    '                       - Last Updated: 9/1/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError:
    If Sheets(WSName).name <> "" Then ErrorTrap_WSExists = True
    Exit Function
IsError:
    ErrorTrap_WSExists = False
End Function

Public Function ErrorTrap_ChartExists(ChartName As String) As Boolean
    '----------------------------------------------------------------
    ' ErrorTrap_ChartExists - Returns TRUE if chart exists, FALSE if it doesn't
    '                       - Last Updated: 9/1/11 by AJS
    '----------------------------------------------------------------
    On Error GoTo IsError:
    If Charts(ChartName).name <> "" Then ErrorTrap_ChartExists = True
    Exit Function
IsError:
    ErrorTrap_ChartExists = False
End Function
Attribute VB_Name = "z_Files"
Option Explicit

Enum FileTypes
        '----------------------------------------------------------------
        ' FileTypes    - Used with SelectNewOrExistingFile, SelectExistingFile, GetCustomFilterList
        '----------------------------------------------------------------
        AnyExtension = 0
        ExcelFiles = 1
        ExcelFileOrTemplate = 2
        WordFiles = 3
        WordFileOrTemplate = 4
        TextFiles = 5
        CSVFiles = 6
        Custom = 99
End Enum

Enum GetFileInfo
        '----------------------------------------------------------------
        ' GetFileInfo    - Used with GetFileInfo
        '----------------------------------------------------------------
        Pathonly = 1
        NameAndExtension = 2
        NameOnly = 3
        ExtensionOnly = 4
        ParentFolder = 5
        FileExists = 6
        FolderExists = 7
        DateLastMod = 8
        FileSizeKB = 9
End Enum

Public Function SelectNewOrExistingFile(Optional FileType As FileTypes = 0, Optional MenuTitleName = "Select File", Optional StartingPath = "WBPath", Optional CustomFilter As String = "Any File (*.*), *.*") As Variant
        '-----------------------------------------------------------------------------------------------------------
        ' SelectNewOrExistingFile   - Select a new or an existing file, using custom filters for specific file types if needed
        '                               New Function in Excel 2007; will not work with previous versions of Excel (http://msdn.microsoft.com/en-us/library/bb209903(v=office.12).aspx)
        '                           - In : Optional FileType as FileTypes (defined above, specify file filters, by default any file)
        '                               Optional MenuTitleName = "Select File" (Default)
        '                               Optional Strpath = Workbook Path (Default)
        '                               Optional CustomFilter As String = "Any File (*.*), *.*" (Custom Filter if User-defined)
        '                           - Out: Full Path to selected file, or FALSE if user cancelled
        '                           - Requires: Function ReturnCustomFilterList
        '                           - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        Dim OutputFile As Variant
        On Error GoTo IsError
        CustomFilter = GetCustomFilterList(FileType, CustomFilter)
        If StartingPath = "WBPath" Then StartingPath = CStr(ThisWorkbook.Path)
        Do
                OutputFile = Application.GetSaveAsFilename(StartingPath, CustomFilter, 1, MenuTitleName)
                If GetFileInfo(CStr(OutputFile), FileExists) = False Then
                        Exit Do
                Else
                        If vbYes = MsgBox("File already exists, replace existing file?" & vbNewLine & vbNewLine & OutputFile, vbYesNo, "Replace existing file?") Then Exit Do
                End If
        Loop
        SelectNewOrExistingFile = OutputFile
        Exit Function
IsError:
        SelectNewOrExistingFile = CVErr(xlErrNA)
        Debug.Print "Error in SelectNewOrExistingFile: " & Err.Number & ": " & Err.Description
End Function

Public Function SelectExistingFolder(Optional MenuTitleName As String = "Select Folder", Optional ByVal StartingPath As String = "WBPath") As Variant
        '-----------------------------------------------------------------------------------------------------------
        ' SelectExistingFolder  - Selecting an existing folder
        '                       - In :  Optional MenuTitleName = "Select Folder" (Default)
        '                               Optional Strpath = Workbook Path (Default)
        '                       - Out: Folder Path including final backslash "\"
        '                       - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        Dim fldr As FileDialog
        On Error GoTo IsError
        If StartingPath = "WBPath" Then StartingPath = CStr(ThisWorkbook.Path)
        Set fldr = Application.FileDialog(msoFileDialogFolderPicker)
        With fldr
                .InitialView = msoFileDialogViewDetails
                .Title = MenuTitleName
                .AllowMultiSelect = False
                .InitialFileName = StartingPath
                If .Show <> -1 Then GoTo UserCancelled
                SelectExistingFolder = .SelectedItems(1) & "\"
        End With
        Exit Function
UserCancelled:
        SelectExistingFolder = False
                Exit Function
IsError:
        SelectExistingFolder = CVErr(xlErrNA)
        Debug.Print "Error in SelectExistingFolder: " & Err.Number & ": " & Err.Description
End Function

Public Function SelectExistingFile(Optional FileType As FileTypes = 0, Optional MenuTitleName = "Select File", Optional StartingPath = "WBPath", Optional CustomFilter As String = "Any File (*.*), *.*") As Variant
        '-----------------------------------------------------------------------------------------------------------
        ' SelectExistingFile    - Selecting an exisiting file, using custom filters for pre-defined file types or create a new custom file type
        '                       - In : Optional FileType as FileTypes (defined above, specify file filters, by default any file)
        '                               Optional MenuTitleName = "Select File" (Default)
        '                               Optional Strpath = Workbook Path (Default)
        '                               Optional CustomFilter As String = "Any File (*.*), *.*" (Custom Filter if User-defined)
        '                       - Out: Full Path to selected file, or FALSE if user cancelled
        '                       - Requires: Function ReturnCustomFilterList
        '                       - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        On Error GoTo IsError
        
        CustomFilter = GetCustomFilterList(FileType, CustomFilter)
        If StartingPath = "WBPath" Then StartingPath = CStr(ThisWorkbook.Path)
        ChDir StartingPath
        SelectExistingFile = Application.GetOpenFilename(FileFilter:=CustomFilter, Title:=MenuTitleName, MultiSelect:=False)
        Exit Function
IsError:
        SelectExistingFile = CVErr(xlErrNA)
        Debug.Print "Error in SelectExistingFile: " & Err.Number & ": " & Err.Description
End Function

Private Function GetCustomFilterList(FileTypeNumber As FileTypes, CustomFilter As String) As Variant
        '-----------------------------------------------------------------------------------------------------------
        ' ReturnCustomFilterList    - Returns custom filter lists for each specified type of file
        '                           - In : FileTypeNumber FileType as FileTypes (defined above, specify file filters, by default any file)
        '                                    CustomFilter As String = "Any File (*.*), *.*" (only used if custom filetypes is selected)
        '                           - Out: FilterList as string
        '                           - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        Dim ReturnValue As String
        On Error GoTo IsError
        Select Case FileTypeNumber
                Case 0
                        ReturnValue = "Any File (*.*),*.*"
                Case 1
                        ReturnValue = "Excel File (*.xlsx; *.xlsm; *.xls), *.xlsx; *.xlsm; *.xls"
                Case 2
                        ReturnValue = "Excel File or Excel Template (*.xlsx; *.xlsm; *.xls; *.xlt; *.xltx; *.xltm), *.xlsx; *.xlsm; *.xls; *.xlt; *.xltx; *.xltm"
                Case 3
                        ReturnValue = "Word File (*.docx; *.docm; *.doc), *.docx; *.docm; *.doc"
                Case 4
                        ReturnValue = "Word File or Word Template (*.docx; *.docm; *.doc; *.dotx; *.dotm; *.dot), *.docx; *.docm; *.doc; *.dotx; *.dotm; *.dot"
                Case 5
                        ReturnValue = "Text File (*.txt; *.dat), *.txt; *.dat"
                Case 6
                        ReturnValue = "CSV File (*.csv), *.csv"
                Case 99
                        ReturnValue = CustomFilter
        End Select
        GetCustomFilterList = ReturnValue
        Exit Function
IsError:
        GetCustomFilterList = CVErr(xlErrNA)
        Debug.Print "Error in GetCustomFilterList: " & Err.Number & ": " & Err.Description
End Function

Public Function MakeDirString(PathString As String) As Variant
        '---------------------------------------------------------------------------------------------------------
        ' MakeDirString      - Adds a parenthesis to the end of a path if it doesn't already exist
        '                    - In : PathString As String
        '                    - Out: MakeDirString as string if valid, error if not valid
        '                    - Last Updated: 7/3/11 by AJS
        '---------------------------------------------------------------------------------------------------------
        On Error GoTo IsError
        If Right(PathString, 1) <> "\" Then
                MakeDirString = PathString & "\"
        Else
                MakeDirString = PathString
        End If
        Exit Function
IsError:
        MakeDirString = CVErr(xlErrNA)
        Debug.Print "Error in MakeDirString: " & Err.Number & ": " & Err.Description & vbNewLine & PathString
End Function

Public Function MakeDirFullPath(Path As String) As Boolean
    '-----------------------------------------------------------------------------------------------------------
    ' MakeDirFullPath   - Creates the full path directory if it doesn't already exist, can for example
    '                       create C:\Temp\Temp\Temp if it doesn't alreay dexist
    '                   - In : Path as String
    '                   - Out: TRUE if path exists, FALSE if path doesn't exist
    '                   - Last Updated: 7/2/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Dim UncreatedPaths As Collection, EachPath As Variant
    Set UncreatedPaths = New Collection
    Dim NewPath As String
    
    On Error GoTo IsError
    NewPath = Path
    Do While GetFileInfo(NewPath, FolderExists) = False
        UncreatedPaths.Add NewPath
        NewPath = GetFileInfo(NewPath, ParentFolder)
    Loop
    Do While UncreatedPaths.Count > 0
        MkDir UncreatedPaths(UncreatedPaths.Count)
        UncreatedPaths.Remove UncreatedPaths.Count
    Loop
    MakeDirFullPath = GetFileInfo(Path, FolderExists)
    Exit Function
IsError:
    MakeDirFullPath = GetFileInfo(Path, FolderExists)
    Debug.Print "Error in MakeDirFullPath: " & Err.Number & ": " & Err.Description & vbNewLine & Path
End Function

Public Function MakeDirFullPathIfDoesntExist(Path As String) As Boolean
    '-----------------------------------------------------------------------------------------------------------
    ' MakeDirFullPathIfDoesntExist   - Shortcut to automatically create MakeDirFullPath if path doesn't exist
    '                                - Last Updated: 12/1/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    On Error GoTo IsError:
    If GetFileInfo(Path, FolderExists) = False Then MakeDirFullPath (Path)
    MakeDirFullPathIfDoesntExist = GetFileInfo(Path, FolderExists)
    Exit Function
IsError:
    MakeDirFullPathIfDoesntExist = GetFileInfo(Path, FolderExists)
    Debug.Print "Error in MakeDirFullPathIfDoesntExist: " & Err.Number & ": " & Err.Description & vbNewLine & Path
End Function


Public Function FileListInFolder(ByVal PathName As String, Optional ByVal FileFilter As String = "*.*") As Collection
        '-----------------------------------------------------------------------------------------------------------
        ' FileListInFolder   - Returns a collection of files in a given folder with the specified filter
        '                       Can filter by a certain type of filename, if file filter is set to equal a certain extension
        '                       Replacement for Application.FileSearch, removed from Excel 2007
        '                       Uses MSDOS Dir function: http://www.computerhope.com/dirhlp.htm
        '                    - In : PathName As String, Optional FileFilter As String
        '                    - Out: A string collection of file names in the specified folder
        '                    - Created: Greg Haskins
        '                    - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        Dim sTemp As String, sHldr As String
        Dim RetVal As New Collection
        
        On Error GoTo IsError
        If Right$(PathName, 1) <> "\" Then PathName = PathName & "\"
        sTemp = Dir(PathName & FileFilter)
        If sTemp = "" Then
                Set FileListInFolder = RetVal
                Exit Function
        Else
                RetVal.Add sTemp
        End If
        Do
                sHldr = Dir
                If sHldr = "" Then Exit Do
                'sTemp = sTemp & "|" & sHldr
                RetVal.Add sHldr
        Loop
        'FileList = Split(sTemp, "|")
        Set FileListInFolder = RetVal
        Exit Function
IsError:
        FileListInFolder.Add CVErr(xlErrNA)
        Debug.Print "Error in FileListInFolder: " & Err.Number & ": " & Err.Description & vbNewLine & PathName & FileFilter
End Function

Public Function GetFileInfo(FN As String, FileInfo As GetFileInfo, Optional ShowErrorPopup As Boolean = False) As Variant
        '-----------------------------------------------------------------------------------------------------------
        ' GetFileInfo        - Returns key file information for a file or folder passed to the function, uses the enumeration GetFileInfo
        '                            1: PathOnly            (FN = "C:\USEPA\BMDS212\00Hill.exe", Return = "C:\USEPA\BMDS212\00Hill.exe")
        '                            2: NameAndExtension    (FN = "C:\USEPA\BMDS212\00Hill.exe", Return = "00Hill.exe")
        '                            3: NameOnly            (FN = "C:\USEPA\BMDS212\00Hill.exe", Return = "00Hill")
        '                            4: ExtensionOnly       (FN = "C:\USEPA\BMDS212\00Hill.exe", Return = "exe")
        '                            5: ParentFolder        (FN = "C:\USEPA\BMDS212\",           Return = "C:\USEPA\")
        '                            6: FileExists          (FN = "C:\USEPA\BMDS212\00Hill.exe", Return = TRUE)
        '                            7: FolderExists        (FN = "C:\USEPA\BMDS212\",           Return = TRUE)
        '                            8: DateLastMod         (FN = "C:\USEPA\BMDS212\00Hill.exe", Return = "5/20/2010 1:23:56 AM")
        '                            9: FileSizeKB          (FN = "C:\USEPA\BMDS212\00Hill.exe", Return = 12.8)
        '                       (May also display a popup message if file or folder doesn't exist)
        '                    - In : FN As String, FileInfo As GetFileInfo
        '                    - Out: Depends on the file info type selected, error if error
        '                    - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        Dim fso As Object
        On Error GoTo IsError
        Set fso = CreateObject("Scripting.FileSystemObject")
        Select Case FileInfo
                Case 1
                        GetFileInfo = fso.GetParentFolderName(FN) & "\"
                Case 2
                        GetFileInfo = fso.GetFileName(FN)
                Case 3
                        GetFileInfo = fso.GetBaseName(FN)
                Case 4
                        GetFileInfo = fso.GetExtensionName(FN)
                Case 5
                        GetFileInfo = fso.GetParentFolderName(FN) & "\"
                Case 6
                        GetFileInfo = fso.FileExists(FN)
                        If ShowErrorPopup = True And GetFileInfo = False Then MsgBox "Error- file doesn't exist!" & vbNewLine & vbNewLine & FN, vbCritical, "File does not exist!"
                Case 7
                        GetFileInfo = fso.FolderExists(FN)
                        If ShowErrorPopup = True And GetFileInfo = False Then MsgBox "Error- folder doesn't exist!" & vbNewLine & vbNewLine & FN, vbCritical, "Folder does not exist!"
                Case 8
                        GetFileInfo = CStr(fso.GetFile(FN).DateLastModified)
                Case 9
                        GetFileInfo = FileLen(FN) / 1000
                Case Else
                        GoTo IsError
        End Select
        Exit Function
IsError:
        GetFileInfo = CVErr(xlErrNA)
        Debug.Print "Error in GetFileInfo: " & Err.Number & ": " & Err.Description & vbNewLine & FN
End Function

Private Function DoesFileExist(FN As String) As Variant
        '-----------------------------------------------------------------------------------------------------------
        ' DoesFileExist      - Alternate way to test to see if file exists (instead of GetFileInfo)
        '                    - In : FN as String
        '                    - Out: TRUE/FALSE if filename is valid
        '                    - Last Updated: 7/20/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
    Dim fso As Object
    On Error GoTo IsError
    Set fso = CreateObject("Scripting.FileSystemObject")
    DoesFileExist = fso.FileExists(FN)
    Exit Function
IsError:
    DoesFileExist = CVErr(xlErrNA)
    Debug.Print "Error in Private Function DoesFileExist: " & Err.Number & ": " & Err.Description
End Function

Public Function IsValidFileName(FN As String) As Boolean
        '-----------------------------------------------------------------------------------------------------------
        ' IsValidFileName    - Returns true if filename is valid using the Win32 naming scheme
        '                    - Adapted from: http://www.bytemycode.com/snippets/snippet/334/
        '                    - In : FN as String
        '                    - Out: TRUE/FALSE if filename is valid
        '                    - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        Dim re As Object, REMatches As Object
        On Error GoTo IsError
        Set re = CreateObject("vbscript.regexp")
        
        With re
                .Multiline = False
                .Global = False
                .IgnoreCase = True
                .Pattern = "[\\\/\:\*\?\" & Chr(34) & "\<\>\|]" 'If any of the following characters are found: \ / : * ? " < > |
        End With
        Set REMatches = re.Execute(FN)
        If REMatches.Count > 0 Or FN = "" Then
                MsgBox "Filename not valid: " & vbNewLine & FN, vbCritical, "Filename not valid"
                IsValidFileName = False
        Else
                IsValidFileName = True
        End If
        Exit Function
IsError:
        IsValidFileName = False
        Debug.Print "Error in IsValidFileName: " & Err.Number & ": " & Err.Description & vbNewLine & FN
End Function

Public Function CleanFileName(Str As String) As String
    'Cleans a filename to allow it to be saved.
    'Searches the string for the following characters: \ / : * ? " < > |
    'If any character is found, it is removed from the string
    'Note that this function cannot be used with a full file path, as
    ' forward and backward slashes will be removed.
    '
    'Last Updated: 2012/02/14 by AJS
    
    Dim re As Object: Set re = CreateObject("vbscript.regexp")
    With re
        .Multiline = False
        .Global = True
        .IgnoreCase = True
        .Pattern = "[\\\/\:\*\?\" & Chr(34) & "\<\>\|]" '\ / : * ? " < > |
    End With
    CleanFileName = re.Replace(Str, "")
End Function

Public Function IsFileOpen(FN As String) As Variant
        '-----------------------------------------------------------------------------------------------------------
        ' IsFileOpen    - Returns TRUE if file is currently open, FALSE if it's not open, or error if other error occurs
        '               - Adapted from: http://www.vbaexpress.com/kb/getarticle.php?kb_id=468
        '               - In : FN as String
        '               - Out: TRUE if file is currently open, FALSE if it's not open, or error if other error occurs
        '               - Last Updated: 7/3/11 by AJS
        '-----------------------------------------------------------------------------------------------------------
        Dim iErr As Long, iFilenum As Long
        On Error Resume Next
                Err.Clear
                iFilenum = FreeFile()
                Open FN For Input Lock Read As #iFilenum
                Close iFilenum
                iErr = Err
        On Error GoTo 0
        Select Case iErr
                Case 0:    IsFileOpen = False
                Case 70:   IsFileOpen = True
                Case Else: Error iErr
        End Select
End Function

Public Function Kill2(ByVal PathName As String) As Boolean
        '----------------------------------------------------------------
        ' Kill2             - Deletes file; continues until succesfullly deleted
        '                   - In : ByVal PathName As String
        '                   - Out: Boolean true if file is succesfully removed
        '                   - Last Updated: 7/3/11 by AJS
        '----------------------------------------------------------------
        Dim TimeOut As String
        TimeOut = Now + TimeValue("00:00:10")
        On Error Resume Next
                Do While GetFileInfo(PathName, FileExists) = True
                        Kill PathName
                        If Now > TimeOut Then
                                MsgBox "Error- File deletion has time out, file cannot be deleted:" & vbNewLine & vbNewLine & PathName, vbCritical, "Error in deleting file"
                                GoTo IsError
                        End If
                Loop
        On Error GoTo 0
        Kill2 = True
        Exit Function
IsError:
        Kill2 = False
        Debug.Print "Error in Kill2: " & Err.Number & ": " & Err.Description & vbNewLine & PathName
End Function

Public Function FileCopy2(ByVal SourceFile As String, ByVal DestinationFile As String) As Boolean
        '----------------------------------------------------------------
        ' FileCopy2             - Revised version of FileCopy that will return TRUE when file is actually copied
        '                       - In : SourceFile As String, DestinationFile As String
        '                       - Out: Boolean true if file is succesfully copied; false otherwise
        '                       - Last Updated: 7/3/11 by AJS
        '----------------------------------------------------------------
        Dim TimeOut As String
        TimeOut = Now + TimeValue("00:00:10")
        If GetFileInfo(SourceFile, FileExists) = False Then
                MsgBox "Error- file does not exist and cannot be copied:" & vbNewLine & vbNewLine & SourceFile, vbCritical, "File cannot be copied"
                GoTo IsError
        End If
        If GetFileInfo(DestinationFile, FileExists) = True Then z_Files.Kill2 DestinationFile
        On Error Resume Next
        Do While GetFileInfo(DestinationFile, FileExists) = False
                FileCopy SourceFile, DestinationFile
                If Now > TimeOut Then
                        MsgBox "Error- File copy has timed out, file was probably not succesfully copied (may be open?):" & vbNewLine & vbNewLine & _
                                        "Source: " & SourceFile & vbNewLine & _
                                        "Destination: " & DestinationFile, vbCritical, "Error in copying file"
                        GoTo IsError
                End If
        Loop
        FileCopy2 = True
        Exit Function
IsError:
        FileCopy2 = False
        Debug.Print "Error in FileCopy2: " & Err.Number & ": " & Err.Description & vbNewLine & SourceFile & vbNewLine & DestinationFile
End Function
Attribute VB_Name = "z_VBA"
'*********************************************
'*/-----------------------------------------\*
'*|                                         |*
'*|        DICTIONARY FUNCTIONS             |*
'*|                                         |*
'*\-----------------------------------------/*
'*********************************************

Public Function Dict_CreateEmpty() As Variant
    '---------------------------------------------------------------------------------------------------------
    ' Dict_CreateEmpty   - Creates an empty dictionary
    '                    - In :
    '                    - Out: Dictionary as Variant
    '                    - Last Updated: 8/18/11 by AJS
    '---------------------------------------------------------------------------------------------------------
    Dim TempDict As Variant
    Set TempDict = CreateObject("Scripting.Dictionary")
    TempDict.RemoveAll
    Set Dict_CreateEmpty = TempDict
End Function

Public Function Dict_AddOrUpdate(ThisDict As Variant, key As String, Value As Variant) As Variant
    '---------------------------------------------------------------------------------------------------------
    ' Dict_AddOrUpdate   - Adds a new key or updates existing value in dictionary
    '                    - In :
    '                    - Out: Dictionary as Variant
    '                    - Last Updated: 4/22/12 by AJS
    '---------------------------------------------------------------------------------------------------------
    If ThisDict.exists(key) Then
        If IsObject(Value) Then
            Set ThisDict.Item(key) = Value
        Else
            ThisDict.Item(key) = Value
        End If
    Else
        ThisDict.Add key, Value
    End If
    Set Dict_AddOrUpdate = ThisDict
End Function


Public Function Coll_ReturnUniqueCollFromColl(FullCollection As Collection) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Coll_ReturnUniqueCollFromColl     - Returns a collection of unique values from a full collection
    '                                   - In : FullCollection As Collection
    '                                   - Out: UniqueCollection of values, or error
    '                                   - Last Updated: 8/7/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Dim UniqueCollection As New Collection
    Dim eachItem As Variant, eachUnique As Variant
    Dim MatchFound As Boolean
    On Error GoTo IsError:
        For Each eachItem In FullCollection
            MatchFound = False
            For Each eachUnique In UniqueCollection
                If eachItem = eachUnique Then
                    MatchFound = True
                    Exit For
                End If
            Next
            If MatchFound = False Then UniqueCollection.Add eachItem
        Next
        Set Coll_ReturnUniqueCollFromColl = UniqueCollection
    Exit Function
IsError:
    Coll_ReturnUniqueCollFromColl = CVErr(xlErrNA)
    Debug.Print "Error in Coll_ReturnUniqueCollFromColl: " & Err.Number & ": " & Err.Description
End Function

'*********************************************
'*/-----------------------------------------\*
'*|                                         |*
'*|        COLLECTION FUNCTIONS             |*
'*|                                         |*
'*\-----------------------------------------/*
'*********************************************

Public Function Coll_ReturnStringListFromCollection(FullCollection As Collection) As Variant
    '-----------------------------------------------------------------------------------------------------------
    ' Coll_ReturnStringListFromCollection     - Returns a string list from a collection
    '                                       If 3 or greater: "alpha, beta, and zeta"
    '                                       If 2: "alpha and beta"
    '                                       If 1: "alpha"
    '                                   - In : FullCollection As Collection
    '                                   - Out: List in string, or error
    '                                   - Last Updated: 8/7/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    On Error GoTo IsError
    Dim eachItem As Variant
    Dim FullString As String
    Dim FullArray() As Variant
    Dim Counter As Integer
    
    FullArray = Coll_ToArray(FullCollection)
    
    For Counter = 1 To UBound(FullArray)
        Select Case Counter
            Case 1
                FullString = FullArray(Counter)
            Case UBound(FullArray)
                If Counter = 2 Then
                    FullString = FullString & " and " & FullArray(Counter)
                Else
                    FullString = FullString & ", and " & FullArray(Counter)
                End If
            Case Else
                FullString = FullString & ", " & FullArray(Counter)
        End Select
    Next
    Coll_ReturnStringListFromCollection = FullString
    Exit Function
IsError:
    Coll_ReturnStringListFromCollection = CVErr(xlErrNA)
    Debug.Print "Error in Coll_ReturnStringListFromCollection: " & Err.Number & ": " & Err.Description
End Function

Public Function Coll_ToArray(FullCollection As Collection) As Variant
    Dim eachItem As Variant
    Dim Counter As Integer
    Dim FullArray() As Variant
    On Error GoTo IsError:
    Counter = 1
    For Each eachItem In FullCollection
        ReDim Preserve FullArray(1 To Counter)
        FullArray(Counter) = CStr(eachItem)
        Counter = Counter + 1
    Next
    Coll_ToArray = FullArray
    Exit Function
IsError:
        Coll_ToArray = CVErr(xlErrNA)
        Debug.Print "Error in Coll_ToArray: " & Err.Number & ": " & Err.Description
End Function

Public Function Coll_ExistsInCollection(SearchString As String, Coll As Collection) As Boolean
    '-----------------------------------------------------------------------------------------------------------
    ' Coll_ExistsInCollection     - Returns TRUE if value exists in collection, FALSE if otherwise
    '                             - In : SearchString As String, Coll As Collection
    '                             - Last Updated: 9/28/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Dim eachVal As Variant
    For Each eachVal In Coll
        If SearchString = CStr(eachVal) Then
            Coll_ExistsInCollection = True
            Exit Function
        End If
    Next
    Coll_ExistsInCollection = False
End Function

Public Function Coll_IntList(Min As Integer, Max As Integer) As Collection
    'Creates a collection of integers based on the values specified
    ' Last Updated: 02/1/12 by AJS
    Dim tempColl As New Collection
    Dim i As Long
    For i = Min To Max
        tempColl.Add i
    Next i
    Set Coll_IntList = tempColl
End Function
Public Function Coll_AddIfUnique(Addition As String, Coll As Collection)
    '-----------------------------------------------------------------------------------------------------------
    ' Coll_AddIfUnique     - Adds to collection if value doesn't already exist in collection
    '                      - In : Addition as string, Coll as collection
    '                      - Last Updated: 9/28/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    If Coll_ExistsInCollection(Addition, Coll) = False Then
        Coll.Add Addition
    End If
    Set Coll_AddIfUnique = Coll
End Function

Public Function Coll_Sort(ByVal c As Collection) As Collection
' This routine uses the "heap sort" algorithm to sort a VB collection.
' It returns the sorted collection.
' Author: Christian d'Heureuse (www.source-code.biz)
' http://www.source-code.biz/snippets/vbasic/6.htm
   Dim n As Long: n = c.Count
   If n = 0 Then Set SortCollection = New Collection: Exit Function
   ReDim Index(0 To n - 1) As Long                    ' allocate index array
   Dim i As Long, m As Long
   For i = 0 To n - 1: Index(i) = i + 1: Next         ' fill index array
   For i = n \ 2 - 1 To 0 Step -1                     ' generate ordered heap
      Heapify c, Index, i, n
      Next
   For m = n To 2 Step -1                             ' sort the index array
      Exchange Index, 0, m - 1                        ' move highest element to top
      Heapify c, Index, 0, m - 1
      Next
   Dim c2 As New Collection
   For i = 0 To n - 1: c2.Add c.Item(Index(i)): Next  ' fill output collection
   Set Coll_Sort = c2
   End Function

Private Sub Heapify(ByVal c As Collection, Index() As Long, ByVal i1 As Long, ByVal n As Long)
   ' Heap order rule: a[i] >= a[2*i+1] and a[i] >= a[2*i+2]
   ' http://www.source-code.biz/snippets/vbasic/6.htm
   Dim nDiv2 As Long: nDiv2 = n \ 2
   Dim i As Long: i = i1
   Do While i < nDiv2
      Dim k As Long: k = 2 * i + 1
      If k + 1 < n Then
         If c.Item(Index(k)) < c.Item(Index(k + 1)) Then k = k + 1
         End If
      If c.Item(Index(i)) >= c.Item(Index(k)) Then Exit Do
      Exchange Index, i, k
      i = k
      Loop
   End Sub

Private Sub Exchange(Index() As Long, ByVal i As Long, ByVal j As Long)
   ' http://www.source-code.biz/snippets/vbasic/6.htm
   Dim Temp As Long: Temp = Index(i)
   Index(i) = Index(j)
   Index(j) = Temp
   End Sub

''*********************************************
''*/-----------------------------------------\*
''*|                                         |*
''*|  VBA OBJECT IMPORT/EXPORT FUNCTIONS     |*
''*|                                         |*
''*\-----------------------------------------/*
''*********************************************
'Public Function ExportVBComponent(VBComp As vbide.VBComponent, _
'                                  FolderName As String, _
'                                  Optional FileName As String, _
'                                  Optional ByVal Extension As String, _
'                                  Optional OverwriteExisting As Boolean = True) As Variant
'    '-----------------------------------------------------------------------------------------------------------
'    ' ExportVBComponent   - This function exports the code module of a VBComponent to a text
'    '                       file. If FileName is missing, the code will be exported to
'    '                       a file with the same name as the VBComponent followed by the
'    '                       appropriate extension.
'    '                     - Last Updated: 8/27/11 by AJS, created by GH
'    '-----------------------------------------------------------------------------------------------------------
'    Dim FName As String
'    On Error GoTo IsError
'
'    'get extension (if not passed)
'    If Trim(Extension) = vbNullString Then
'        Extension = z_VBA.GetVBAFileExtension(VBComp:=VBComp)
'    End If
'
'    'get filename and extension
'    If Trim(FileName) = vbNullString Then
'        FName = VBComp.Name & Extension
'    Else
'        FName = FileName
'        FName = FName & "." & Extension
'    End If
'
'    'get full directory for export
'    If VBA.Right(FolderName, 1) = "\" Then
'        FName = FolderName & FName
'    Else
'        FName = FolderName & "\" & FName
'    End If
'
'    'overwrite if needed
'    If VBA.Len(Dir(FName)) > 0 Then
'        If OverwriteExisting = True Then
'            Kill FName
'        Else
'            ExportVBComponent = ""
'            Exit Function
'        End If
'    End If
'
'    'export component; return filename
'    VBComp.Export FileName:=FName
'    ExportVBComponent = FName
'    Exit Function
'IsError:
'    ExportVBComponent = CVErr(xlErrNA)
'    Debug.Print "Error in ExportVBComponent: " & Err.Number & ": " & Err.Description
'End Function
'
'Public Function GetVBAFileExtension(VBComp As vbide.VBComponent) As String
'    '-----------------------------------------------------------------------------------------------------------
'    ' GetVBAFileExtension   - This returns the appropriate file extension based on the Type of
'    '                         the VBComponent.
'    '                       - Last Updated: 8/27/11 by AJS, created by GH
'    '-----------------------------------------------------------------------------------------------------------
'    On Error GoTo IsError:
'    Select Case VBComp.Type
'        Case vbext_ct_ClassModule, vbext_ct_Document
'            GetFileExtension = ".cls"
'        Case vbext_ct_MSForm
'            GetFileExtension = ".frm"
'        Case vbext_ct_StdModule
'            GetFileExtension = ".bas"
'        Case Else
'            GetFileExtension = ".bas"
'    End Select
'IsError:
'    ExportVBComponent = CVErr(xlErrNA)
'    Debug.Print "Error in ExportVBComponent: " & Err.Number & ": " & Err.Description
'End Function
Attribute VB_Name = "z_Word"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'In order to run this VBA Macro, go to Tools->References-> MS Word 11.0 Object Library
'No longer required- uses "late-binding" to Word instead of "early-binding" to
' allow for greater backwards/forwards compatibility, at the cost of speed and ease-of-coding.
Public appWD As Variant 'Word.Application
Public ActDoc As Variant 'Word.Document

Enum ViewType   'used with function ViewChange
    DraftView = 1
    PrintView = 3
End Enum

Function AddTOC(UpperHeadingLvl As Integer, LowerHeadingLvl As Integer) As Boolean
        With ActDoc
                        .TablesOfContents.Add Range:=appWD.Selection.Range, _
                        RightAlignPageNumbers:=True, _
                        UseHeadingStyles:=True, _
                        UpperHeadingLevel:=UpperHeadingLvl, _
                        LowerHeadingLevel:=LowerHeadingLvl, _
                        IncludePageNumbers:=True, _
                        AddedStyles:="", _
                        UseHyperlinks:=True, _
                        HidePageNumbersInWeb:=True, _
                        UseOutlineLevels:=True
                .TablesOfContents(1).TabLeader = 1 'wdTabLeaderDots
                .TablesOfContents.Format = 0 'wdIndexIndent
        End With
        AddTOC = True
End Function

Function UpdateAll() As Boolean
    appWD.DisplayAlerts = 0 'wdAlertsNone = 0
    appWD.Selection.WholeStory
    appWD.Selection.Fields.Update
    appWD.DisplayAlerts = -1 'wdAlertsAll = -1
End Function

Function UpdateTOC() As Boolean
        ActDoc.TablesOfContents(1).Update
        UpdateTOC = True
End Function

Public Sub StandardParagraphFormat()
    Dim wp As Object
    'Standard paragraph formating (change as needed)
    With appWD.Selection.ParagraphFormat
        .LeftIndent = Application.InchesToPoints(0)
        .RightIndent = Application.InchesToPoints(0)
        .SpaceBefore = 0
        .SpaceBeforeAuto = False
        .SpaceAfter = 0
        .SpaceAfterAuto = False
        .LineSpacingRule = wdLineSpaceSingle
'        .Alignment = wdAlignParagraphLeft
        .WidowControl = True
'        .KeepWithNext = False
'        .KeepTogether = False
'        .PageBreakBefore = False
'        .NoLineNumber = False
'        .Hyphenation = True
        .FirstLineIndent = Application.InchesToPoints(0)
        .OutlineLevel = wdOutlineLevelBodyText
        .CharacterUnitLeftIndent = 0
        .CharacterUnitRightIndent = 0
        .CharacterUnitFirstLineIndent = 0
        .LineUnitBefore = 0
        .LineUnitAfter = 0
        .MirrorIndents = False
'        .TextboxTightWrap = wdTightNone
    End With
End Sub

Public Function SearchFoundInWordDoc(SearchTerm As String) As Boolean
    appWD.Selection.Find.ClearFormatting
    With appWD.Selection.Find
        .text = SearchTerm
        .Replacement.text = ""
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    appWD.Selection.Find.Execute
    If appWD.Selection.text = SearchTerm Then
            SearchFoundInWordDoc = True
    Else
            SearchFoundInWordDoc = False
    End If
End Function

Public Function SearchReplaceEverywhere(SearchTerm As String, ReplaceTerm As String) As Boolean
    appWD.Selection.Find.ClearFormatting
    SearchReplaceEverywhere = False
    Dim story As Variant
    For Each story In ActDoc.StoryRanges
        Select Case story.storytype
        Case 1, 5:
        story.Select
        With appWD.Selection.Find
                .text = SearchTerm
                .Replacement.text = ""
                .Forward = True
                .Wrap = 1   'wdFindContinue
                .Format = False
                .MatchCase = False
                .MatchWholeWord = False
                .MatchWildcards = False
                .MatchSoundsLike = False
                .MatchAllWordForms = False
        End With
        appWD.Selection.Find.Execute
        If appWD.Selection.text = SearchTerm Then
            appWD.Selection.text = ReplaceTerm
            SearchReplaceEverywhere = True
        End If
        End Select
    Next
    ActDoc.StoryRanges(1).Select    ' wdMainTextStory = 1
    Me.GoToEnd
End Function

Public Function SearchReplaceInWordDoc(SearchTerm As String, ReplaceTerm As String) As Boolean
    appWD.Selection.Find.ClearFormatting
    SearchReplaceInWordDoc = False
    With appWD.Selection.Find
            .text = SearchTerm
            .Replacement.text = ""
            .Forward = True
            .Wrap = 1   'wdFindContinue
            .Format = False
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
    End With
    appWD.Selection.Find.Execute
    If appWD.Selection.text = SearchTerm Then
        appWD.Selection.text = ReplaceTerm
        SearchReplaceInWordDoc = True
    End If
End Function

Public Sub AddBookmark(BookmarkName As String)
        ActDoc.Bookmarks.Add name:=BookmarkName, Range:=appWD.Selection.Range
End Sub

Public Sub AddCrossReferenceToBookmark(BookmarkName As String, Optional CrossRefText As String)
' DAL '        Dim wdFld As Word.Field
        Dim wdFld As Object   ' DAL
        Dim BMText As String, CRText As String
        BMText = appWD.Documents(ActDoc).Bookmarks(BookmarkName).Range.text
        appWD.Selection.InsertCrossReference "Bookmark", wdNumberFullContext, BookmarkName, True, False, False, " "
        If CRText <> "" Then
                For Each wdFld In appWD.Selection.Range.Paragraphs(1).Range.Fields
                        If wdFld.Type = wdFieldRef Then
                                If InStr(1, wdFld.Code.text, BookmarkName, vbTextCompare) > 0 Then
                                        wdFld.Select
                                        appWD.Selection.Find.Execute FindText:=appWD.Selection.text, replaceWith:=CRText
                                End If
                        End If
                Next
        End If
End Sub

'/-------------------------------------------------------------------------------\
'|   WORD SETUP AND MANIPULATION                                                 |
'|-------------------------------------------------------------------------------|
'|                       |                                                       |
'|                       |                                                       |
'|                       |                                                       |
'\-------------------------------------------------------------------------------/
        Public Sub WordDocument_SelectActive()
' DAL                 Set appWD = Word.Application
                Set appWD = CreateObject("Word.Application")    ' DAL
                Set ActDoc = appWD.ActiveDocument
        End Sub
        
        Public Sub WordDocument_Load(WordFullPath As String, Optional ReadOnlyToggle As Boolean = False)
                Set appWD = CreateObject("Word.Application")
                appWD.Application.DisplayAlerts = False
                appWD.Documents.Open FileName:=WordFullPath, ReadOnlyToggle:=True 'ReadOnly
                Set ActDoc = appWD.ActiveDocument
        End Sub
        
        Public Sub WordDocument_Add(Optional FullTemplatePath As String = "")
                '----------------------------------------------------------------
                ' AddWordDocument       - Creates a word document of the designated type or template
                '                       - In : ByVal XValue As String, XRange As Range, YRange As Range
                '                       - Out: Linear interpolation as string, may include < or > if greater than bounds of range
                '                       - Last Updated: 3/26/11 by AJS
                '----------------------------------------------------------------
                
                'CREATE NEW INSTANCE OF WORD
                Set appWD = CreateObject("Word.Application")
                appWD.Application.DisplayAlerts = False
                
                'CREATE A NEW DOCUMENT AND SAVE
                If FullTemplatePath = "" Then
                        appWD.Documents.Add DocumentType:=0 'wdNewBlankDocument
                Else
                        appWD.Documents.Add DocumentType:=0, Template:=FullTemplatePath
                End If
                Set ActDoc = appWD.ActiveDocument
        End Sub

Public Sub SaveFile()
    appWD.Documents(ActDoc).Save
End Sub

Public Sub SaveAsWordDoc(FileDir As String, FileNameNoExt As String, Optional WordFileExtension As String = "docx")
    Dim FileFormat As Integer
    
    Dim ext As String
    Select Case UCase(WordFileExtension)
        'http://msdn.microsoft.com/en-us/library/bb238158(v=office.12).aspx
        Case "DEFAULT"
            ext = ".doc"
            FileFormat = 16
        Case "DOC", ".DOC", "2003"
            ext = ".doc"
            FileFormat = 0
        Case "DOCX", ".DOCX", "2007", "2010"
            ext = ".docx"
            FileFormat = 12
        Case "DOCM", ".DOCM"
            ext = ".docm"
            FileFormat = 13
        Case Else
            MsgBox "Unknown word file extension- " & WordFileExtension, vbCritical, "Error in Function ""AddWordDocument"""
            Exit Sub
    End Select

    appWD.ActiveDocument.SaveAs FileName:=FileDir & FileNameNoExt & ext, _
            FileFormat:=FileFormat, _
            LockComments:=False, _
            Password:="", _
            AddToRecentFiles:=True, _
            WritePassword:="", _
            ReadOnlyRecommended:=False, _
            EmbedTrueTypeFonts:=False, _
            SaveNativePictureFormat:=False, _
            SaveFormsData:=False, _
            SaveAsAOCELetter:=False
End Sub

Public Sub SaveAsPDF(FN As String, OpenAfterExport As Boolean)
    
    ActDoc.ExportAsFixedFormat _
        OutputFileName:=FN, _
        ExportFormat:=17, _
        OpenAfterExport:=OpenAfterExport, _
        OptimizeFor:=0, _
        Range:=0, _
        From:=1, To:=1, _
        Item:=0, _
        IncludeDocProps:=True, _
        KeepIRM:=True, _
        CreateBookmarks:=0, _
        DocStructureTags:=True, _
        BitmapMissingFonts:=True, _
        UseISO19005_1:=False
        'wdExportFormatPDF = 17
        'wdExportOptimizeForPrint=0
        'wdExportAllDocument=0
        'wdExportDocumentContent=0
        'wdExportCreateNoBookmarks=0
End Sub

Public Sub WordDocument_Close(SaveChg As Boolean)
    appWD.Documents(ActDoc).Close SaveChanges:=SaveChg
    appWD.Quit
End Sub

Public Sub Visible(Visible As Boolean)
    appWD.Visible = Visible
End Sub

Public Sub WordOptionsManual()
    appWD.Options.BackgroundSave = False
    appWD.Options.CheckSpellingAsYouType = False
    appWD.Options.CheckGrammarAsYouType = False
    appWD.Documents(ActDoc).ShowSpellingErrors = False
End Sub

Public Sub WordOptionsAutomatic()
    appWD.Options.BackgroundSave = True
    appWD.Options.CheckSpellingAsYouType = True
    appWD.Options.CheckGrammarAsYouType = True
    appWD.Documents(ActDoc).ShowSpellingErrors = True
End Sub

Function PaperSize(Width As Double, Height As Double)
    appWD.Documents(ActDoc).PageSetup.PageWidth = appWD.InchesToPoints(Width)
    appWD.Documents(ActDoc).PageSetup.PageHeight = appWD.InchesToPoints(Height)
End Function

Public Sub PageLandscape()
    appWD.Documents(ActDoc).Sections(appWD.Selection.Information(wdActiveEndSectionNumber)).PageSetup.Orientation = wdOrientLandscape
End Sub

Public Sub PagePortrait()
    appWD.Documents(ActDoc).PageSetup.Orientation = wdOrientPortrait
End Sub

'   /-------------------------------------------------------------------------------\
'   |   WORD NAVIGATION AND MOVEMENT                                                |
'   |-------------------------------------------------------------------------------|
'   |                       |                                                       |
'   |                       |                                                       |
'   |                       |                                                       |
'   \-------------------------------------------------------------------------------/
        Public Sub GoToHeader()
        'Goes to header from body
                If appWD.ActiveWindow.View.SplitSpecial <> wdPaneNone Then
                        appWD.ActiveWindow.Panes(2).Close
                End If
                If appWD.ActiveWindow.ActivePane.View.Type = wdNormalView Or _
                        appWD.ActiveWindow.ActivePane.View.Type = wdOutlineView Then
                        appWD.ActiveWindow.ActivePane.View.Type = wdPrintView
                End If
                appWD.ActiveWindow.ActivePane.View.SeekView = wdSeekCurrentPageHeader
        End Sub
        
        Public Sub GoToMainTextBody()
        'Returns to body from header
                appWD.ActiveWindow.ActivePane.View.SeekView = 0 'wdSeekMainDocument = 0
        End Sub
        
        Public Sub GoToEnd()
        'Goes to the end of document
                appWD.Selection.EndKey Unit:=6  'wdStory
        End Sub
        
        Public Sub GoToBeginning()
        'Returns to beginning of document
                appWD.Selection.HomeKey Unit:=6 'wdStory
        End Sub

        Public Sub GoToBookmark(BookmarkName As String)
                appWD.Selection.GoTo What:=-1, name:=BookmarkName   'dGoToBookmark = -1
        End Sub
        
        Public Sub DeleteAllBM()
                Dim eachBM As Variant 'Bookmark
                For Each eachBM In appWD.Documents(ActDoc).Bookmarks
                        eachBM.Delete
                Next
        End Sub

'   /-------------------------------------------------------------------------------\
'   |   WORD TEXT EDITING                                                           |
'   |-------------------------------------------------------------------------------|
'   |                       |                                                       |
'   |                       |                                                       |
'   |                       |                                                       |
'   \-------------------------------------------------------------------------------/
        Public Sub PrintText(TextString As String, Optional StyleName As String = "Normal")
                AddBookmark "Temp1"
                appWD.Selection.TypeText text:=TextString
                AddBookmark "Temp2"
                SelectTextBetweenBookmarks "Temp1", "Temp2"
                If StyleName <> "" Then appWD.Selection.style = StyleName
                appWD.Selection.MoveRight Unit:=wdCharacter, Count:=1
        End Sub
        
        Public Sub NextLine()
                'Type new line
                appWD.Selection.TypeParagraph
        End Sub
        
        Public Sub BreakSectionNextPage()
                'Insert page break
                appWD.Selection.InsertBreak Type:=wdSectionBreakNextPage
        End Sub
        
        Public Sub BreakPage()
                'Insert page break
                appWD.Selection.InsertBreak Type:=wdPageBreak
        End Sub
        
        Public Sub PageMargins(LeftMargin As Double, RightMargin As Double, Top As Double, Bottom As Double)
                ActDoc.PageSetup.LeftMargin = appWD.InchesToPoints(LeftMargin)
                ActDoc.PageSetup.RightMargin = appWD.InchesToPoints(RightMargin)
                ActDoc.PageSetup.TopMargin = appWD.InchesToPoints(Top)
                ActDoc.PageSetup.BottomMargin = appWD.InchesToPoints(Bottom)
        End Sub
        
        Public Function SelectTextBetween(SearchText As String, StartField As String, EndField As String) As String
                Dim CropLeft As String
                If InStr(1, SearchText, EndField, vbTextCompare) = 0 Then
                        SelectTextBetween = "ERROR- End field not found (" & """" & EndField & """" & " not not found in " & """" & SearchText & """" & ")"
                        'MsgBox FindTextBetween
                ElseIf InStr(1, SearchText, StartField, vbTextCompare) = 0 Then
                        'MsgBox FindTextBetween
                        SelectTextBetween = "ERROR- Start field not found (" & """" & StartField & """" & " not not found in " & """" & SearchText & """" & ")"
                Else
                        CropLeft = Left(SearchText, InStr(1, SearchText, EndField, vbTextCompare) - 1)
                        SelectTextBetween = Right(CropLeft, Len(CropLeft) - (InStr(1, SearchText, StartField, vbTextCompare) + Len(StartField) - 1))
                End If
        End Function
        
        Public Function SelectTextBetweenBookmarks(BM1 As String, BM2 As String)
                ActDoc.Range( _
                        ActDoc.Bookmarks(BM1).Range.Start, _
                        ActDoc.Bookmarks(BM2).Range.Start).Select
        End Function

        
'   /-------------------------------------------------------------------------------\
'   |   WORD TABLE MANIPULATION                                                     |
'   |-------------------------------------------------------------------------------|
'   |                       |                                                       |
'   |                       |                                                       |
'   |                       |                                                       |
'   \-------------------------------------------------------------------------------/
        Public Sub AddTable(NumCols As Integer, NumRows As Integer)
            ActDoc.Tables.Add Range:=appWD.Selection.Range, _
                NumRows:=NumRows, NumColumns:=NumCols, _
                DefaultTableBehavior:=wdWord9TableBehavior, AutoFitBehavior:=wdAutoFitFixed
        End Sub
        
Public Sub Table_PasteFromExcel_ESCRMMI(PasteRange As Variant, FigPasteRange As Variant)
    'paste table
    With appWD.Selection.Range
        'first paste table
        On Error Resume Next
        PasteRange.Worksheet.Activate
        PasteRange.Copy
        appWD.Selection.PasteExcelTable False, False, False
        Application.CutCopyMode = False
        On Error GoTo 0
        'If .Tables.Count > 0 Then
        '     'format table
        '     With .Tables(1).Range
        '        .ParagraphFormat.SpaceBefore = 0
        '        .ParagraphFormat.SpaceAfter = 0
        '        .ParagraphFormat.LineSpacingRule = 0 'wdLineSpaceSingle = 0
        '    End With
        '    'configure first cell for figure pasting
        '    With .Tables(1).rows(1).Cells(1)
        '        .Range.ParagraphFormat.Alignment = 1 'wdAlignParagraphCenter = 1
        '        .VerticalAlignment = 1 'wdCellAlignVerticalCenter = 1
        '        .TopPadding = 0
        '        .BottomPadding = 0
        '        .LeftPadding = 0
        '        .RightPadding = 0
        '        .Select
        '    End With
        '    'paste figure
        '    On Error Resume Next
        '    FigPasteRange.Worksheet.Activate
        '    FigPasteRange.Copy
        '    Selection.PasteSpecial Link:=False, _
        '           DataType:=9, _
        '           Placement:=0, _
        '           DisplayAsIcon:=False
        '           'wdInLine=0
        '           'wdPasteEnhancedMetafile=9
        '    Application.CutCopyMode = False
        'End If
        On Error GoTo 0
    End With
    ActDoc.UndoClear
    Me.GoToEnd
End Sub

Public Sub Format_ESCRMMI_Tbls()
    'Format all ESCRMMI tables at the end instead of after pasting
    ' in case errors occur during the paste
    Dim tbl As Variant, Counter As Integer, tbls As Integer
    Counter = 0
    tbls = appWD.Documents(ActDoc).Tables.Count
    For Each tbl In appWD.Documents(ActDoc).Tables
        'Format table
        With tbl.Range
            .ParagraphFormat.SpaceBefore = 0
            .ParagraphFormat.SpaceAfter = 0
            .ParagraphFormat.LineSpacingRule = 0 'wdLineSpaceSingle = 0
        End With
        'Configure first cell for figure pasting
        tbl.Select
        With tbl.Range.Cells(1)
            .Range.ParagraphFormat.Alignment = 1 'wdAlignParagraphCenter = 1
            .VerticalAlignment = 1 'wdCellAlignVerticalCenter = 1
            .TopPadding = 0
            .BottomPadding = 0
            .LeftPadding = 0
            .RightPadding = 0
            .Select
        End With
        'HACK: fix right border in all tables; conditional formatting drops it for some reason?
        'tbl.Borders(-4).LineStyle = 1
    Next
End Sub

        
        Public Sub ClearBorders()
                On Error Resume Next
                With appWD.Selection
                        .Borders(wdBorderLeft).Visible = False
                        .Borders(wdBorderRight).Visible = False
                        .Borders(wdBorderTop).Visible = False
                        .Borders(wdBorderBottom).Visible = False
                        .Borders(wdBorderHorizontal).Visible = False
                        .Borders(wdBorderVertical).Visible = False
                End With
                On Error GoTo 0
        End Sub

'   /-------------------------------------------------------------------------------\
'   |   WORD CHARTS AND PICTURES MANIPULATION                                       |
'   |-------------------------------------------------------------------------------|
'   |                       |                                                       |
'   |                       |                                                       |
'   |                       |                                                       |
'   \-------------------------------------------------------------------------------/
Function AddPictureInline(PictureDirectory As String, Optional ScaleFactor As Double = 1, Optional DrawBorder = False)
        With appWD.Documents(ActDoc).InlineShapes.AddPicture(FileName:=PictureDirectory, LinkToFile:=False, SaveWithDocument:=True, Range:=appWD.Selection.Range)
                If DrawBorder = True Then
                        .Line.Visible = msoTrue    'draw border around object
                        .Line.Weight = 1#          'weight of line around object
                End If
'        .ConvertToShape
                .Height = .Height * ScaleFactor
                .Width = .Width * ScaleFactor
        End With
End Function

Function AddPictureShape(PictureDirectory As String, Optional ScaleFactor As Double = 1, Optional DrawBorder = False)
        With appWD.Documents(ActDoc).Shapes.AddPicture(FileName:=PictureDirectory, LinkToFile:=False, SaveWithDocument:=True, Anchor:=appWD.Selection.Range)
                If DrawBorder = True Then
                        .Line.Visible = msoTrue    'draw border around object
                        .Line.Weight = 1#          'weight of line around object
                End If
'        .ConvertToInlineShape
                .Height = .Height * ScaleFactor
                .Width = .Width * ScaleFactor
        End With
End Function

Function AddChartInline(ChartPaste As Variant) 'can be ChartObject or Chart
    Dim WRDRange As Variant 'Word.Range
    ChartPaste.Chart.AutoScaling = False
    On Error Resume Next
    ChartPaste.ChartArea.AutoScaleFont = False
    ChartPaste.Copy
    Set WRDRange = appWD.Selection
    With WRDRange
        .PasteSpecial Link:=False, _
            DataType:=9, _
            DisplayAsIcon:=False, _
            Placement:=0
            'wdPasteEnhancedMetafile=9
        WRDRange.InlineShapes(1).LockAspectRatio = msoTrue
    End With
    On Error GoTo 0
End Function

Function AddShapeInline(Shp As Variant)
    Dim WRDRange As Variant 'Word.Range
    Shp.Copy
    Set WRDRange = appWD.Selection
    With WRDRange
        .PasteSpecial Link:=False, DataType:=9, _
                      DisplayAsIcon:=False, Placement:=0
            'wdPasteEnhancedMetafile=9,  wdInLine = 0
    End With
End Function

'Function AddChartShape(Optional ChartWidthInches As Double, Optional ChartHeightInches As Double)
'        Dim WRDRange As Word.Range
'        ChartPaste.Chart.AutoScaling = False
'        ChartPaste.ChartArea.AutoScaleFont = False
'        ChartPaste.Copy
''       appWD.Selection.PasteSpecial DataType:=wdPasteEnhancedMetafile, Placement:=wdFloatOverText
'        Set WRDRange = app.Selection.Range
'        With WRDPasteRange
'                .Shapes(1).LockAspectRatio = msoTrue
'                If ChartWidthInches <> 0 Then
'                        .Shapes(1).Width = Application.InchesToPoints(ChartWidthInches)
'
'                End If
'                If ChartHeightInches <> 0 Then
'                        .Shapes(1).Height = Application.InchesToPoints(ChartHeightInches)
'                End If
'                .ParagraphFormat.Alignment = wdAlignParagraphCenter
'        End With
'End Function

Public Function Tbl_AddRow(RowColl As Variant) As Integer
    'Add Table row with values and format based on attributes in dictionary.
    'Will either append to existing table or create a new table, depending
    '  on the cursor location in the document. If directly below an existing
    '  table, will be appended. If above line is not a table, will create
    '  a new table.
    'Input should be a collection of dictionaries.
    'Returns the table index in the current document of table
    'Valid attributes in dictionary: Text (text in table)
    '                                Style (style to apply)
    '                                Width (of cell, in inches)
    'Last updated: 2012-04-04 by AJS
    
    Dim TblID As Integer, RowID As Integer, tblCell As Variant 'Cell
    Dim i As Integer, Attr As Variant, tbl As Variant
    
    Set tbl = ActDoc.Tables.Add(appWD.Selection.Range, 1, RowColl.Count)
    TblID = appWD.Documents(ActDoc).Tables.Count
    RowID = tbl.Range.rows.Count
    
    'Now, set values in each cell
    i = 1   'collections begin with item #1
    For Each tblCell In tbl.Range.rows(RowID).Cells
        For Each Attr In RowColl(i)
            tblCell.Range.Select
            Select Case Attr
            Case "Text":
                appWD.Selection.TypeText CStr(RowColl(i)(Attr))
            Case "Style":
                appWD.Selection.style = RowColl(i)(Attr)
            Case "Width":
                tblCell.SetWidth Application.InchesToPoints(RowColl(i)(Attr)), 0 'wdAdjustNone = 0
            Case "Shade":
                tblCell.Shading.BackgroundPatternColor = RowColl(i)(Attr)
            End Select
        Next
        i = i + 1
    Next
    tbl.Range.rows(RowID).AllowBreakAcrossPages = False
    
    Me.GoDownOneLine
    'Returns the Table ID in the document, so that you can
    ' format the table based on some settings as well
    Tbl_AddRow = TblID
End Function

Public Function GoDownOneLine()
    appWD.Selection.MoveDown Unit:=5, Count:=1    'wdLine = 5
End Function
Public Function GoUpOneLine()
    appWD.Selection.MoveUp Unit:=5, Count:=1    'wdLine = 5
End Function

Public Function ViewChange(View As ViewType)
    'Change view to either be in draft view or print view. Draft is
    '   better for VBA manipulation, as less hickups occur without the
    '   page formatting features. Print view is standard view.
    'Last updated: 6/18/12 by AJS
    If appWD.ActiveWindow.View.SplitSpecial = 0 Then  'wdPaneNone = 0
        appWD.ActiveWindow.ActivePane.View.Type = View
    Else
        appWD.ActiveWindow.View.Type = View
    End If
End Function

Public Function Tbl_MergeBlankCells(tbl As Variant, Optional msg As String = "") As Boolean
    'Cycle through all cells in a table and any blank cells should
    '   be merged with cells above them.
    'Requires: Word.Table object with NO merged cells.
    'Last updated: 6/18/12 by AJS
    Dim c As New Collection
    Dim rows As Long, i As Long, j As Long, m As Long, nextrow As Long
    Dim cl As Variant, rng As Variant 'cell, range, respectively
    Dim Rngs As Variant
    Dim blank As String: blank = Chr(13) & Chr(7)   'blank cell case
    Dim makeVis As Boolean
    Dim iMsg As Long: iMsg = 0

    'switch to draft view as less errors occur in this view
    Me.ViewChange DraftView
    makeVis = appWD.Visible
    appWD.Windows(1).WindowState = 2    'wdMinimized = 2
    Me.Visible True
    
    rows = tbl.rows.Count
    'On Error GoTo IsErr
    'cycle through rows
    For i = 1 To tbl.rows.Count
        'cycle through columns
        j = 0
        For Each cl In tbl.rows(i).Cells
            j = j + 1
            'get txt and check if blank
            If cl.Range.text <> blank Then
                iMsg = iMsg + 1
                If msg <> "" Then
                    Application.StatusBar = msg + Replace(Space(iMsg Mod 10), " ", ".")
                End If
                'if it is not blank, then get the number of cells
                '   below that aren't blank and set to m
                m = 0
                Do
                    nextrow = i + m + 1
                    'nested ifs to prevent errors- make sure row exists,
                    '   column exists, check if cell is blank
                    If nextrow <= rows Then
                        If tbl.rows(nextrow).Cells.Count >= j Then
                            If tbl.rows(nextrow).Cells(j).Range.text = blank Then _
                                m = m + 1 Else: Exit Do
                        Else: Exit Do: End If
                    Else: Exit Do: End If
                Loop While 1
                'if at least one cell was blank, select the range of cells to merge and
                '   add to a collection to be merged after cycling through rest of table
                If m > 0 Then
                    cl.Select
                    appWD.Selection.MoveDown Unit:=5, Count:=m, Extend:=1  'wdLine = 5  wdExtend = 1
                    c.Add appWD.Selection.Range
                End If
            End If
        Next
    Next i
    
    'Now, for each range, merge the selection
    For Each rng In c
                iMsg = iMsg + 1
                If msg <> "" Then
                    Application.StatusBar = msg + Replace(Space(iMsg Mod 10), " ", ".")
                End If
        Set Rngs = rng
        Rngs.Select
        appWD.Selection.Cells.Merge
    Next
    Tbl_MergeBlankCells = True
    Me.Visible makeVis
    Exit Function
IsErr:
    Me.Visible makeVis
    Tbl_MergeBlankCells = False
End Function


' InQuest injected base64 decoded content
' zPhw$

INQUEST-PP=macro
