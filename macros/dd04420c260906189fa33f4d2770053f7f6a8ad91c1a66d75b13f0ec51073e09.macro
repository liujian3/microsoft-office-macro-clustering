Attribute VB_Name = "ClsNotFileSystemObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Copyright |fffd|1996-2011 VBnet/Randy Birch, All Rights Reserved.
' Some pages may also contain other copyrights by the author.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Distribution: You can freely use this code in your own
'               applications, but you may not reproduce
'               or publish this code on any web site,
'               online service, or distribute as source
'               on any media without express permission.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Option Explicit

Private Const VBDOT = 46
Private Const MAXDWORD As Long = &HFFFFFFFF
Private Const MAX_PATH As Long = 260
Private Const INVALID_HANDLE_VALUE = -1
Private Const FILE_ATTRIBUTE_DIRECTORY = &H10

Private Type FILETIME
   dwLowDateTime As Long
   dwHighDateTime As Long
End Type

Private Type WIN32_FIND_DATA
   dwFileAttributes As Long
   ftCreationTime As FILETIME
   ftLastAccessTime As FILETIME
   ftLastWriteTime As FILETIME
   nFileSizeHigh As Long
   nFileSizeLow As Long
   dwReserved0 As Long
   dwReserved1 As Long
   cFileName As String * MAX_PATH
   cAlternate As String * 14
End Type

#If VBA7 Then
    Private Declare PtrSafe Function FindClose Lib "kernel32" _
      (ByVal hFindFile As LongPtr) As Boolean
       
    Private Declare PtrSafe Function FindFirstFile Lib "kernel32" _
       Alias "FindFirstFileA" _
      (ByVal lpFileName As String, _
       lpFindFileData As WIN32_FIND_DATA) As LongPtr
       
    Private Declare PtrSafe Function FindNextFile Lib "kernel32" _
       Alias "FindNextFileA" _
      (ByVal hFindFile As LongPtr, _
       lpFindFileData As WIN32_FIND_DATA) As LongPtr
    
    Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As LongPtr
#Else
    Private Declare Function FindClose Lib "kernel32" _
      (ByVal hFindFile As Long) As Boolean
       
    Private Declare Function FindFirstFile Lib "kernel32" _
       Alias "FindFirstFileA" _
      (ByVal lpFileName As String, _
       lpFindFileData As WIN32_FIND_DATA) As Long
       
    Private Declare Function FindNextFile Lib "kernel32" _
       Alias "FindNextFileA" _
      (ByVal hFindFile As Long, _
       lpFindFileData As WIN32_FIND_DATA) As Long
    
    Private Declare Function GetTickCount Lib "kernel32" () As Long
#End If
Private pathList As Collection


Public Function SearchForFiles(rootPath As String, fileMask As String, searchSubfolders As Boolean) As Collection
    Set pathList = New Collection
    SearchFor rootPath, fileMask, searchSubfolders, False
    Set SearchForFiles = pathList
End Function

Public Function SearchForFolders(rootPath As String, fileMask As String, searchSubfolders As Boolean) As Collection
    Set pathList = New Collection
    SearchFor rootPath, fileMask, searchSubfolders, True
    Set SearchForFolders = pathList
End Function

Public Function CheckFileExists(path As String) As Boolean
    Dim fileAttributes As Long
    
    CheckFileExists = False
    If CheckExists(path, fileAttributes) Then
        If Not fileAttributes And FILE_ATTRIBUTE_DIRECTORY Then
            CheckFileExists = True
        End If
    End If
End Function

Public Function CheckFolderExists(ByVal path As String) As Boolean
    Dim fileAttributes As Long
    
    path = UnQualifyPath(path)
    path = ExpandPath(path)
    
    CheckFolderExists = False
    If CheckExists(path, fileAttributes) Then
        If fileAttributes And FILE_ATTRIBUTE_DIRECTORY Then
            CheckFolderExists = True
        End If
    End If
End Function

Private Sub SearchFor(rootPath As String, fileMask As String, searchSubfolders As Boolean, SearchForFolder As Boolean)
    'local working variables
    Dim WFD As WIN32_FIND_DATA
    Dim hFile As LongPtr
    Dim sPath As String
    Dim sRoot As String
    Dim sTmp As String

    sRoot = QualifyPath(rootPath)
    sRoot = ExpandPath(sRoot)
    sPath = sRoot & "*.*"

    'obtain handle to the first match
    hFile = FindFirstFile(sPath, WFD)

    'if valid ...
    If hFile <> INVALID_HANDLE_VALUE Then
        'This is where the method obtains the file
        'list and data for the folder passed.
        GetFilesMatchingName sRoot, fileMask, SearchForFolder
    
        Do
            'if the returned item is a folder...
            If (WFD.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) Then
            '..and the Recurse flag was specified
                If searchSubfolders Then '
                    'and if the folder is not the default
                    'self and parent folders (a . or ..)
                    If Asc(WFD.cFileName) <> VBDOT Then
                        '..then the item is a real folder, which
                        'may contain other sub folders, so assign
                        'the new folder name to FP.sFileRoot and
                        'recursively call this function again with
                        'the amended information.
                        'remove trailing nulls
                        sTmp = sRoot & TrimNull(WFD.cFileName)
                        SearchFor sTmp, fileMask, True, SearchForFolder
                   End If
                End If
            End If
        'continue looping until FindNextFile returns
        '0 (no more matches)
        Loop While FindNextFile(hFile, WFD)
    
        'close the find handle
        hFile = FindClose(hFile)
    End If
End Sub

Private Sub GetFilesMatchingName(rootPath As String, filename As String, SearchForFolder As Boolean)
    'local working variables
    Dim WFD As WIN32_FIND_DATA
    Dim hFile As LongPtr
    Dim sPath As String
    Dim sRoot As String
    Dim sTmp As String
      
    'FP.sFileRoot contains the path to search.
    'FP.sFileNameExt contains the full path and filespec.
    sRoot = QualifyPath(rootPath)
    sPath = sRoot & filename
    
    'obtain handle to the first filespec match
    hFile = FindFirstFile(sPath, WFD)
   
    'if valid ...
    If hFile <> INVALID_HANDLE_VALUE Then
        Do
            'Even though this routine uses file specs,
            '*.* is still valid and will cause the search
            'to return folders as well as files, so a
            'check against folders is still required.
            If SearchForFolder Then
                If Asc(WFD.cFileName) <> VBDOT Then
                    If (WFD.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) = _
                         FILE_ATTRIBUTE_DIRECTORY Then
                        'this is where you add code to store
                        'or display the returned file listing.
                        '
                        'if you want the file name only, save 'sTmp'.
                        'if you want the full path, save 'sRoot & sTmp'
                
                        'remove trailing nulls
                        sTmp = TrimNull(WFD.cFileName)
                        pathList.Add sRoot & sTmp
                    End If
                End If
            Else
                If Not (WFD.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) = _
                     FILE_ATTRIBUTE_DIRECTORY Then
                    'this is where you add code to store
                    'or display the returned file listing.
                    '
                    'if you want the file name only, save 'sTmp'.
                    'if you want the full path, save 'sRoot & sTmp'
            
                    'remove trailing nulls
                    sTmp = TrimNull(WFD.cFileName)
                    pathList.Add sRoot & sTmp
                End If
            End If
        Loop While FindNextFile(hFile, WFD)
        'close the handle
        hFile = FindClose(hFile)
    End If
End Sub

Public Function ExpandPath(ByVal sPath As String) As String
    Dim sParsed As String
    Dim oShell As WshShell
    
    Set oShell = New WshShell
    
    sParsed = oShell.ExpandEnvironmentStrings(sPath)
    'Replacements below are for strings that are not standart environment variables.
    If Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath) <> vbNullString Then
        sParsed = Replace(sParsed, "%workgroupPath%", Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath), Compare:=vbTextCompare)
    End If
    If Application.Options.DefaultFilePath(wdUserTemplatesPath) <> vbNullString Then
        sParsed = Replace(sParsed, "%userPath%", Application.Options.DefaultFilePath(wdUserTemplatesPath), Compare:=vbTextCompare)
    End If
    
    ExpandPath = sParsed
End Function

'++********************************************************************
' Description:  Checks that the given item exists. The item can be
'               a file or a folder.
' Parameters:   sPath => path to the item. This could have wildcards
'               in them. e.g c:/document.doc* fill find document.doc or
'               document.docx
'               fileAttributes => File attributes if the item
'               Full path without wildcards to first found item
' Returns:      True if item exists, false otherwise
'--********************************************************************
Private Function CheckExists(path As String, Optional ByRef fileAttributes As Long = 0, Optional ByRef FullPath As String = "") As Boolean
    Dim hFile As LongPtr
    Dim WFD As WIN32_FIND_DATA
    
    hFile = FindFirstFile(path, WFD)
    
    If hFile <> INVALID_HANDLE_VALUE Then
        fileAttributes = WFD.dwFileAttributes
        CheckExists = True
        FullPath = WFD.cFileName
    Else
        CheckExists = False
    End If
End Function

'++********************************************************************
' Description:  Assures that a passed path ends in a slash
' Parameters:   sPath => path that should be qualified
' Returns:      path with trailing /
'--********************************************************************
Private Function QualifyPath(sPath As String) As String
   If Right$(sPath, 1) <> "\" Then
      QualifyPath = sPath & "\"
   Else
      QualifyPath = sPath
   End If
End Function

'++********************************************************************
' Description:  Assures that a passed path does not end in a slash
' Parameters:   sPath => path that should be UnQualified
' Returns:      path without trailing /
'--********************************************************************
Private Function UnQualifyPath(sPath As String) As String
   If Right$(sPath, 1) = "\" Then
      UnQualifyPath = Left(sPath, Len(sPath) - 1)
   Else
      UnQualifyPath = sPath
   End If
End Function

'++********************************************************************
' Description:  'returns the string up to the first
'               null, if present, or the passed string
' Parameters:   startstr => String that needs to be trimmed
' Returns:      String without null characters
'--********************************************************************
Private Function TrimNull(ByVal startstr As String) As String
   Dim pos As Integer

   pos = InStr(startstr, Chr$(0))

   If pos Then
      TrimNull = Left$(startstr, pos - 1)
      Exit Function
   End If
   TrimNull = startstr
End Function
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
''***********************************************************************************
''* Created by - Brochet ltd
''*              www.brochet.co.uk
''*
''* Module: ThisDocument
''*
''* Holds all the auto macros
''***********************************************************************************

Option Explicit

Const MODULE_NAME As String = "ThisDocument"

'++********************************************************************
' Description:  This function needs to be in a module withou Option Private
'               otherwise the OnTime function can't call it.
'               It would logically fit more into modRibbon, but we can't do that.
' Parameters    none
' Returns:      none
'--********************************************************************
Public Sub InvalidateRibbonAll()
    modRibbon.InvalidateRibbon
End Sub



Private Sub Document_Open()

    'UpdateFields

    ActiveDocument.BuiltInDocumentProperties(wdPropertyCompany) = COMPANY_NAME
    ActiveDocument.BuiltInDocumentProperties(wdPropertyComments) = GLOBAL_VERSION & " - " & GLOBAL_DATE
    

    
End Sub
Attribute VB_Name = "cAddinAPI"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'* Brochet Legal Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Class:       cBrochetAPI
'*
'* Holds:       Class modules for Brochet API
'* How to use it:
'* Private Sub ReformatChartInExcel(ExcelApplication As Object)
'*     Dim clsBrochetAPI As cAddinAPI
'*     Set clsBrochetAPI = New cAddinAPI
'*     clsBrochetAPI.Initialize ExcelApplication
'*     If clsBrochetAPI.isReady Then
'*         Dim params(1) As String
'*         clsBrochetAPI.RunOperation "ShowDialog"
'*     End If
'* End Sub
'***********************************************************************************



Option Explicit

#If VBA7 Then
    Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As LongPtr) 'For 64 Bit Systems
#Else
    Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) 'For 32 Bit Systems
#End If

Private oAPI As Object
Private oCom As COMAddIn
Private bAddinExists As Boolean
Private bAddinTicked As Boolean

Public Property Get AddinExists() As Boolean
    AddinExists = bAddinExists
End Property

Public Property Get AddinTicked() As Boolean
    If Not oCom Is Nothing Then
        AddinTicked = oCom.Connect
    End If
End Property

Private Sub class_initialize()
    For Each oCom In Application.COMAddIns
        bAddinExists = False
        If oCom.ProgID Like "*BrochetWordAddin*" Then  'ProgID = "BrochetPaste" Then
            Set oAPI = oCom.Object
            bAddinExists = True
            Exit For
        End If
    Next oCom
End Sub

Public Sub Initialize(OfficeApplication As Object)
    For Each oCom In OfficeApplication.COMAddIns
        bAddinExists = False
        If oCom.ProgID Like "*BrochetWordAddin*" Then
            Set oAPI = oCom.Object
            bAddinExists = True
            Exit For
        End If
    Next oCom
End Sub

Public Function isReady() As Boolean
    If Not oAPI Is Nothing Then
        isReady = True
    Else
        isReady = False
    End If
End Function

Public Function RunOperation(operation As String, parameter As String) As Boolean
    On Error GoTo ErrorHandler
    If Not oAPI Is Nothing Then
        Dim parameters(1) As String
        parameters(1) = parameter
        RunOperation = oAPI.RunOperation(operation, parameters) = vbOK
    End If
CleanExit:
    Exit Function
ErrorHandler:
    MsgBox "The function is unavailable." & vbCrLf & "Is Main add-in enabled?", vbCritical, "Function unavailable"
    Resume CleanExit
End Function

Public Function GetVersion() As String
    On Error GoTo ErrorHandler
    If Not oAPI Is Nothing Then
        GetVersion = oAPI.GetVersion
    End If
CleanExit:
    Exit Function
ErrorHandler:
    GetVersion = "Cannot get version number!"
    'MsgBox "The function is unavailable." & vbCrLf & "Is Main add-in enabled?", vbCritical, "Function unavailable"
    Resume CleanExit
End Function



Attribute VB_Name = "cUndoRecord"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'* Expense Reduction Analysts Proposal template
'*
'* Module: cUndoRecord
'*
'* Class for working with undostack in word 2010 and 2013. DOes not work in 2007
'* and earlier, but wont crash either
'***********************************************************************************

Option Explicit

#If VBA7 Then
    Private oUndoRecord As UndoRecord
#End If

Private iRecordCount As Integer
Private bCanClose As Boolean

Private Sub class_initialize()
    iRecordCount = 0
    bCanClose = False
End Sub

Public Sub SetName(Value As String)
    #If VBA7 Then
        Set oUndoRecord = Application.UndoRecord
        iRecordCount = iRecordCount + 1
        If Not oUndoRecord.IsRecordingCustomRecord Then
            bCanClose = True
            oUndoRecord.StartCustomRecord Value
        End If
    #End If
End Sub

Public Sub EndRecording()
    #If VBA7 Then
        If Not oUndoRecord Is Nothing Then
            If iRecordCount > 0 Then
                iRecordCount = iRecordCount - 1
                If oUndoRecord.IsRecordingCustomRecord And iRecordCount = 0 And bCanClose Then
                    oUndoRecord.EndCustomRecord
                    bCanClose = False
                    'Set oUndoRecord = Nothing
                End If
            End If
        End If
    #End If
End Sub

Private Sub Class_Terminate()
    iRecordCount = 0
    #If VBA7 Then
        If Not oUndoRecord Is Nothing Then
            If oUndoRecord.IsRecordingCustomRecord And bCanClose Then
                oUndoRecord.EndCustomRecord
                Set oUndoRecord = Nothing
            End If
        End If
    #End If
End Sub
Attribute VB_Name = "clsEventHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Class: clsEventHandler
'*
'* Holds the Word Window events
'***********************************************************************************

Public WithEvents aWordApp As Word.Application
Attribute aWordApp.VB_VarHelpID = -1

'++*******************************************************************
' Description:  Called every time a Word document is opened and, if it's
'               the first, will invalidate the ribbon to re-enable controls
' Parameters:   doc-Document
' Returns:      N/A
'--********************************************************************
Private Sub aWordApp_DocumentOpen(ByVal Doc As Document)

    modRibbon.InvalidateRibbon
    
    modTemplate.CheckTemplate
    
End Sub

'++*******************************************************************
' Description:  Called every time a Word document is closed
' Parameters:   doc-Document being closed
'               cancel- If set to true in the function, document won't
'                   close
' Returns:      N/A
'--********************************************************************
Private Sub aWordApp_DocumentBeforeClose(ByVal Doc As Document, Cancel As Boolean)
    If Documents.count = 1 Then
        'This is the last document being closed
        modRibbon.RibbonInvalidateDelayed
    End If
End Sub

'++*******************************************************************
' Description:  Called every time a Word document created. This will
'               refresh the ribbon
' Parameters:   doc-Document
' Returns:      N/A
'--********************************************************************
Private Sub aWordApp_NewDocument(ByVal Doc As Document)
    modRibbon.InvalidateRibbon
End Sub

'++*******************************************************************
' Description:  Called every time a Word windows became acitve.
'               This will refresh the ribbon
' Parameters:   doc-Document
'               Wn - Window becoming active
' Returns:      N/A
'--********************************************************************
Private Sub aWordApp_WindowActivate(ByVal Doc As Document, ByVal Wn As Window)
    modRibbon.InvalidateRibbon
End Sub


Attribute VB_Name = "frmAttachTmp"
Attribute VB_Base = "0{4A553215-9033-4773-92C6-6788772CE71B}{0657CBC2-9D2D-4638-9948-2998E744AB8A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: frmAttachTmp
'*
'* Displays a dialog box for attaching the correct template
'***********************************************************************************
Option Explicit

Private Const MODULE_NAME As String = "frmAttachTmp"

Public sTemplatePath As String

'++*******************************************************************
' Procedure:    butCancel_Click
' Description:  Cancel Button pressed, close dialog box and new document
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butCancel_Click()
    On Error GoTo butCancel_Click_EH
    
    Unload Me
    Exit Sub
    
butCancel_Click_EH:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "butCancel_Click"
End Sub

'++*******************************************************************
' Procedure:    butOk_Click
' Description:  OK Button pressed, close dialog box and update header
'               if required and insert the new text.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butOk_Click()
    Dim sNewTemplate As String
    Dim sSubDirectory As String
    
    If Me.cmbTempl.ListIndex = -1 Then
        MsgBox "Please make a valid selection from the list.", vbInformation, _
          COMPANY_NAME & " - Re-attach template"
        Exit Sub
    End If
    
    If Me.cmbTempl.List(Me.cmbTempl.ListIndex, 1) <> "" Then
        sNewTemplate = Me.cmbTempl.List(Me.cmbTempl.ListIndex, 1)
    End If
    
    'Attach the selected template to the document
    On Error GoTo butOk_Click_EH
    ActiveDocument.AttachedTemplate = sNewTemplate
                
    Unload Me
    
    modRibbon.InvalidateRibbon
    
butOk_ClickExit:
    Exit Sub
butOk_Click_EH:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "butOK_Click"
    Resume butOk_ClickExit
End Sub

Private Sub togShowFullPath_Change()
            
    If Me.togShowFullPath Then
        Me.cmbTempl.ListWidth = "28 cm"
        Me.cmbTempl.ColumnWidths = "8 cm;20 cm"
        If Me.Left > 300 Then
            Me.Left = 50
        End If
        If Me.Top > 40 Then
            Me.Top = 40
        End If
        Me.cmbTempl.SetFocus
        Me.cmbTempl.DropDown
    Else
        Me.cmbTempl.ListWidth = "8 cm"
        Me.cmbTempl.ColumnWidths = "8 cm;0 cm"
    End If
    
End Sub

Private Sub UserForm_Activate()

    If Me.Left > 300 Then
        Me.Left = 50
    End If
    If Me.Top > 40 Then
        Me.Top = 40
    End If
    
End Sub

'++*******************************************************************
' Procedure:    UserForm_Initialize
' Description:  Initialse the dialog box with the default settings.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub UserForm_Initialize()
    Dim oTmp As Template
    Dim sMenuXml As String
    Dim sText As String
    Dim sFileName As String
    Dim i As Integer
    Dim vArray() As Variant
    Dim irDummy As IRibbonControl
    Dim oFso As FileSystemObject
    
    Me.Caption = COMPANY_NAME & Me.Caption
    
    'Get the current document template options
    Set oTmp = ActiveDocument.AttachedTemplate
    
    lblTemp = oTmp.Name
    lblOriginal = modPrivate.DocVarGet("InitialTemplateName")
    
    'Use the getContent callback for the File New menu to retrieve the xml
    modRibbon.DmBrochetFileNew_getContent irDummy, sMenuXml
    
    Me.cmbTempl.AddItem "{No template/Normal}"
    Me.cmbTempl.List(0, 1) = vbNullString
    
    If sMenuXml <> "" Then
    
        Do
            'Isolate the template pointed to by the tag, xml attribute
            i = InStr(sMenuXml, "tag=""")
            If i = 0 Then
                Exit Do
            End If
            If InStr(sMenuXml, "label=""Refresh List""") < i Then
                'This button is the refresh list button so we're at the end
                Exit Do
            End If
            
            sMenuXml = Mid$(sMenuXml, i + 5)
            i = InStr(sMenuXml, """")
            sText = Left$(sMenuXml, i - 1)
            
            If sText <> "~Refresh~" Then
                'This is NOT the refresh list button which should be ignored
                Set oFso = New FileSystemObject
                sFileName = oFso.GetFileName(sText)
                Me.cmbTempl.AddItem sFileName
                Me.cmbTempl.List(Me.cmbTempl.ListCount - 1, 1) = sText
            End If
        Loop
        
        vArray() = Me.cmbTempl.List() 'Read the combo array into a variant array ready for sorting
        modArrays.ArraySort vArray(), 0, True 'Sort it by the first column
        Me.cmbTempl.List() = vArray() 'Put the sorted array back into the combo
    Else
        'Need to get the list from somewhere else as the
        modError.DisplayMsg "Can't get the list of available templates as the New Document menu has not yet been clicked."
    End If
    
    'Need to point to the Original template
    If lblOriginal <> "" Then
        
        If Me.cmbTempl.ListCount > 0 Then
    
            For i = 1 To Me.cmbTempl.ListCount
            
                If UCase(Me.cmbTempl.List(i - 1)) = UCase(lblOriginal) Then
                    Me.cmbTempl.ListIndex = i - 1
                    Exit For
                End If
            
            Next
        End If
    
    End If
    
End Sub

Attribute VB_Name = "frmDocInfo"
Attribute VB_Base = "0{B20D23F9-5F09-4A51-8137-D523C6D75B3A}{30EC1FF8-8598-4E08-B0B7-4D3569CC8BAF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'* Brochet Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: frmDocInfo
'*
'* Displays a dialog box for document information
'***********************************************************************************

Option Explicit

Const msMODULE As String = "frmDocInfo"
'++*******************************************************************
' Description:  Cancel Button pressed, close dialog box and new document
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************

Private Sub butCancel_Click()
    Unload Me
End Sub



'++*******************************************************************
' Description:  Initialse the dialog box with the default settings
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub UserForm_Initialize()
    Dim VersNo As String
    Dim DocName As String
    Dim GlobalVersNo As String
    Dim GlobalName As String
    Dim sTempName As String
    Dim sInitTempVersion As String
    Dim oTmp As Template
    Dim iVBCount As Integer
    Dim i As Integer
    Dim X As Integer
    Dim templateVersion As String
    Dim templateDate As String
    


    Me.Caption = COMPANY_NAME & " - " & Me.Caption
    
    'Get the Global template information
    lblGlobalTemplateNameTxt = ThisDocument.Name
    lblGlobalTemplateVersionTxt = GLOBAL_VERSION
    lblGlobalTemplateDateTxt = GLOBAL_DATE
    
    'If a document more than one document open see if current doc is using a Brochet template
    If Application.Documents.count > 0 Then
        'If the current document is a template then
        If ActiveDocument.Type = wdTypeTemplate Then
        
                lblTempNametxt = "Active document is a template"
                lblTempInitVersionTxt = "Active document is a template"
                lblTempCurrVersionTxt = "Active document is a template"
                lblTempCurrDateTxt = "Active document is a template"
            
        Else
        
            'Need to see it the attached template is a Brochet template
            sTempName = ActiveDocument.AttachedTemplate
            sInitTempVersion = modPrivate.DocVarGet("InitialTemplateVersion")
            If sInitTempVersion <> "" Then
            
                lblTempNametxt = sTempName
                lblTempInitVersionTxt = sInitTempVersion
                Set oTmp = ActiveDocument.AttachedTemplate
                
                'Call the template to get version date of the tamplate
                templateVersion = modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GetTemplateVersion", "")
                templateDate = modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GetTemplateDate", "")

                If templateVersion <> "" Then
                    lblTempCurrVersionTxt = templateVersion
                Else
                    lblTempCurrVersionTxt = "Unable to get Template version"
                End If
                
                If templateDate <> "" Then
                    lblTempCurrDateTxt = templateDate
                Else
                    lblTempCurrDateTxt = "Unable to get Template date"
                End If
                
            Else
                'lblTempNametxt = "Active document is not using a recognised template"
                lblTempNametxt = sTempName
                lblTempInitVersionTxt = "Active document is not using a recognised template"
                lblTempCurrVersionTxt = ""
                lblTempCurrDateTxt = ""
            
            End If
        End If
    End If
    
    lblChartToolVer = GetAddinVerNumber
        
    MakeAllFramesAndLabelsBrochetBlue
    
    Me.Top = Application.Top + (Application.UsableHeight / 2) - (Me.Height / 2)
    Me.Left = Application.Left + (Application.UsableWidth / 2) - (Me.width / 2)
    
    If Not modGlobal.gbGlobalIsOk Then
        lblRestart.visible = True
    End If
End Sub

Function GetAddinVerNumber() As String

     Dim clsBrochetAPI As cAddinAPI
     Set clsBrochetAPI = New cAddinAPI
     'clsBrochetAPI.Initialize ExcelApplication
     
        If clsBrochetAPI.isReady Then
            Dim params(1) As String
            GetAddinVerNumber = clsBrochetAPI.GetVersion
        Else
           GetAddinVerNumber = "Not Installed!"
        End If


End Function


'++*******************************************************************
' Description:  Changes the colour of text in frame and lable controls
'               to Brochet Blue, which is RGB(0,153,204)
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub MakeAllFramesAndLabelsBrochetBlue()
    Dim cnt As control
    
    For Each cnt In Me.Controls
        If TypeOf cnt Is label Then
            If cnt.Name <> "lblRestart" Then
                cnt.ForeColor = RGB(0, 153, 204)
            End If
        ElseIf TypeOf cnt Is Frame Then
            cnt.ForeColor = RGB(0, 153, 204)
        End If
    Next cnt
End Sub


Attribute VB_Name = "frmNewTable"
Attribute VB_Base = "0{DC8B8B22-D70A-4D61-AAB8-5C169579C136}{BA746418-E223-48CE-9781-65B92B748E64}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: frmNewTable
'*
'* Form and code for the New table
'* TODO this form and modTables will need extensive modifications for each client
'***********************************************************************************

Option Explicit

Const MODULE_NAME As String = "frmNewTable"

'TODO Set these depending on whether you wish them to show in the dialog and to be used
Const bTableSource As Boolean = True
Const bRowShading As Boolean = False

Dim bFormCancel As Boolean

Dim bPortraitPage As Boolean

Dim dTableWidth As Double

'We used to have these as global variables. This
'is slightly more complicated aproach, but les bug prone.
Private bNewTable As Boolean
Private bWidthOnly As Boolean

'Preview
Const PreviewRows = 9
Const PreviewColumns = 7

Dim CurrentTableDesign As tTableDesign

Dim CurrentPreview As tTablePreview

Dim lblPreviewCells(PreviewRows, PreviewColumns) As MSForms.label
Dim lblTableWidthModifiers() As MSForms.OptionButton
Dim lblPreviewHorizontalLines(PreviewRows) As MSForms.label
Dim lblPreviewVerticalLines(PreviewColumns) As MSForms.label


Sub CustomDialogBoxLayout()

'============================================================================
'============================================================================
'    Use this routine to Show/hide any custom design changes to the dialog box

'   This routine runs before the dialog is shown


'============================================================================
'============================================================================

    


End Sub

Function CustomGetTableDesign() As tTableDesign

'============================================================================
'============================================================================
'    Use this function to examine the options selected in the dialog box to define the
'    final TableDesign. This is the Table design that is inserted into the document




'============================================================================
'============================================================================



    
        If obtFinancial Then

            CustomGetTableDesign = TableFinancial
            


        Else
        
            CustomGetTableDesign = TableMain

        End If



End Function


Sub CustomSetCurrentPreview()

'============================================================================
'============================================================================
'    Redefines the Table preview by changing the settings of CurrentPreview




'============================================================================
'============================================================================

    
        With CurrentPreview
    
            .Top = 100
            .Left = 15
            .width = 273 '350 '210 'Make sure this is divisible by PreviewColumns
            .Height = 100 ' 70 'make sure this is divisible by PreviewRows
            .Columns = PreviewColumns '7
            .Rows = PreviewRows '9
            .TextMargin = 15
            .Font = 6
            .Col1SampleText = " Sample "
        End With
    



End Sub


Public Sub SetNewTable(Value As Boolean)
    bNewTable = Value
End Sub

Public Function GetNewTable() As Boolean
    GetNewTable = bNewTable
End Function

Public Sub SetWidthOnly(Value As Boolean)
    bWidthOnly = Value
End Sub

Public Function GetWidthOnly() As Boolean
    GetWidthOnly = bWidthOnly
End Function


Function CalculateMaxColumns(iWidth As Double, ColWidth As Double) As Integer
    'Returns the maximum number of columns

    Dim iCount As Integer

    iCount = Int(iWidth / CentimetersToPoints(ColWidth))
    
    CalculateMaxColumns = iCount

End Function


Sub PreviewArrangeCells(sType As String, PreviewTable As tTablePreview)


Dim tableColOneWidth As Integer
Dim tableColWidth As Integer

Dim tableColOneTextAlign As Integer
Dim tableColTextAlign As Integer

Dim tableColOneText As String
Dim tableColText As String

Dim Row, col As Integer



    Select Case sType
    Case "Even"
        tableColWidth = PreviewTable.width / PreviewTable.Columns
        tableColOneWidth = tableColWidth
        tableColOneTextAlign = 1
        tableColTextAlign = 1
        tableColOneText = PreviewTable.Col1SampleText
        'tableColOneText = " Sample text "
        tableColText = " text "
    Case "Fin"
        tableColWidth = 25
        tableColOneWidth = PreviewTable.width - (tableColWidth * (PreviewTable.Columns - 1))
        tableColOneTextAlign = 1
        tableColTextAlign = 3
        tableColOneText = PreviewTable.Col1SampleText
        tableColText = "123.00"
    Case "ShadeFirstCol"
        tableColWidth = PreviewTable.width / PreviewTable.Columns
        tableColOneWidth = tableColWidth
        tableColOneTextAlign = 1
        tableColTextAlign = 1
        tableColOneText = PreviewTable.Col1SampleText
        'tableColOneText = " Sample text "
        tableColText = " text "
    End Select


    For Row = 0 To PreviewTable.Rows - 1
        For col = 1 To PreviewTable.Columns
        
            If col = 1 Then
                With lblPreviewCells(Row, col - 1)
                    .Left = PreviewTable.Left
                    .width = tableColOneWidth
                    .Caption = tableColOneText
                    .TextAlign = tableColOneTextAlign

                End With
            Else
                With lblPreviewCells(Row, col - 1)
                    .Left = PreviewTable.Left + tableColOneWidth + ((col - 2) * tableColWidth) - col
                    .width = tableColWidth
                    
                    .Caption = tableColText
                    .TextAlign = tableColTextAlign
                End With
            End If
            
        Next
    Next
    
'    For Row = 0 To PreviewTable.Rows - 1
'
'        With lblPreviewHorizontalLines(Row)
'            '.Left = PreviewTable.Left
'            '.Top = PreviewTable.Top + (Row * (PreviewTable.Height / PreviewTable.Rows)) - Row
'            '.Height = 1
'            '.Width = PreviewTable.Width
'        End With
'
'    Next

    For col = 0 To PreviewTable.Columns - 1

        With lblPreviewVerticalLines(col)
            .Left = lblPreviewCells(1, col).Left
            '.Top = PreviewTable.Top
            '.Height = PreviewTable.Height
            '.Width = 1

        End With
    Next

    
End Sub

Sub PreviewUpdate(PreviewTable As tTablePreview)

Dim i As Integer

    If obtEven Then
        PreviewArrangeCells "Even", PreviewTable
    End If

'    If obtFirstColumn Then
'        PreviewArrangeCells "ShadeFirstCol", PreviewTable
'    End If

    If obtFinancial Then
        PreviewArrangeCells "Fin", PreviewTable
    End If
    
    PreviewBlankTable PreviewTable
    
    'These are in order of painting
    PreviewSetVerticalBanding cbxVerticalBanding, PreviewTable
    
    PreviewSetHorizontalBanding cbxHorizontalBanding, PreviewTable
    
    PreviewSetFirstColumn cbxFirstColumn, PreviewTable
    
    PreviewSetLastColumn cbxLastColumn, PreviewTable
    PreviewSetHeading cbxHeading, PreviewTable
    PreviewSetTotal cbxTotal, PreviewTable
    
    
    If cbxTotal Then
        'PreviewColourRowAuto 9, TableMain.TotalCells.BackgroundColour
        PreviewBoldRow PreviewRows, True, PreviewTable
    Else
        PreviewBoldRow PreviewRows, False, PreviewTable
    End If
    
    PreviewSetTitle
    PreviewSetSource
    
    
End Sub

Sub PreviewSetTitle()

    With lblPreviewTitle
        .Font.Bold = ActiveDocument.Styles(CurrentTableDesign.TitleStyle).Font.Bold
        .Font.Size = ActiveDocument.Styles(CurrentTableDesign.TitleStyle).Font.Size
        .ForeColor = GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.TitleStyle))
        .Left = CurrentPreview.Left
    End With
    

End Sub

Sub PreviewSetSource()

    With lblPreviewSource
        .Font.Bold = ActiveDocument.Styles(CurrentTableDesign.SourceStyle).Font.Bold
        .Font.Size = ActiveDocument.Styles(CurrentTableDesign.SourceStyle).Font.Size
        .ForeColor = GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.SourceStyle))
        .Left = CurrentPreview.Left
    End With

End Sub


Sub PreviewBlankTable(PreviewTable As tTablePreview)

    Dim i As Integer
        
        For i = 1 To PreviewRows
            PreviewColourRowAuto i, CurrentTableDesign.PlainGrid.Cells.BackgroundColour, PreviewTable
            PreviewFontColourRowAuto i, GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.PlainGrid.ParagraphStyle)), PreviewTable
        Next
        

        lblPreviewHorizontalLines(0).BorderStyle = CurrentTableDesign.PlainGrid.Cells.TopLine.Style
        lblPreviewHorizontalLines(0).BorderColor = CurrentTableDesign.PlainGrid.Cells.TopLine.Colour
        For i = 1 To PreviewRows - 1
            lblPreviewHorizontalLines(i).BorderStyle = CurrentTableDesign.PlainGrid.Cells.HorizontalLine.Style
            lblPreviewHorizontalLines(i).BorderColor = CurrentTableDesign.PlainGrid.Cells.HorizontalLine.Colour
        Next
        lblPreviewHorizontalLines(PreviewRows).BorderStyle = CurrentTableDesign.PlainGrid.Cells.BottomLine.Style
        lblPreviewHorizontalLines(PreviewRows).BorderColor = CurrentTableDesign.PlainGrid.Cells.BottomLine.Colour
    
        lblPreviewVerticalLines(0).BorderStyle = CurrentTableDesign.PlainGrid.Cells.LeftLine.Style
        lblPreviewVerticalLines(0).BorderColor = CurrentTableDesign.PlainGrid.Cells.LeftLine.Colour
        For i = 1 To PreviewColumns - 1
            lblPreviewVerticalLines(i).BorderStyle = CurrentTableDesign.PlainGrid.Cells.VerticalLine.Style
            lblPreviewVerticalLines(i).BorderColor = CurrentTableDesign.PlainGrid.Cells.VerticalLine.Colour
        Next
        lblPreviewVerticalLines(PreviewColumns).BorderStyle = CurrentTableDesign.PlainGrid.Cells.RightLine.Style
        lblPreviewVerticalLines(PreviewColumns).BorderColor = CurrentTableDesign.PlainGrid.Cells.RightLine.Colour

End Sub
Sub PreviewSetHorizontalBanding(bEnable As Boolean, PreviewTable As tTablePreview)

Dim i As Integer
    If bEnable Then
        For i = 1 To PreviewRows Step 2
            PreviewColourRowAuto i, CurrentTableDesign.BandedRow.BackgroundColour, PreviewTable
        Next

    End If

End Sub
Sub PreviewSetVerticalBanding(bEnable As Boolean, PreviewTable As tTablePreview)

Dim i As Integer
    If bEnable Then
        For i = 1 To PreviewColumns Step 2
            PreviewColourColumnAuto i, CurrentTableDesign.BandedColumn.BackgroundColour, PreviewTable
        Next

    End If

End Sub
Sub PreviewSetFirstColumn(bEnable As Boolean, PreviewTable As tTablePreview)

Dim lColour As Long

    If bEnable Then

        PreviewColourColumnAuto 1, CurrentTableDesign.FirstColumn.Cells.BackgroundColour, PreviewTable

        lColour = GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.FirstColumn.ParagraphStyle))
        
        'PreviewFontColourRowAuto 1, lColour, PreviewTable
        'PreviewFontColour
        'PreviewSetRowLines 0, CurrentTableDesign.HeadingRow.Cells
        PreviewSetColumnLines 0, CurrentTableDesign.FirstColumn.Cells
        
    Else
        'PreviewColourRowAuto 1, CurrentTableDesign.PlainGrid.Cells.BackgroundColour, PreviewTable

        lColour = GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.PlainGrid.ParagraphStyle))
        'PreviewFontColourRowAuto 1, lColour, PreviewTable
        'PreviewSetRowLines 0, CurrentTableDesign.PlainGrid.Cells
        PreviewSetColumnLines 0, CurrentTableDesign.PlainGrid.Cells
    End If



End Sub
Sub PreviewSetLastColumn(bEnable As Boolean, PreviewTable As tTablePreview)


    If bEnable Then

        PreviewColourColumnAuto PreviewColumns, CurrentTableDesign.LastColumn.Cells.BackgroundColour, PreviewTable

    End If

End Sub
Sub PreviewSetHeading(bEnable As Boolean, PreviewTable As tTablePreview)

Dim i As Integer
Dim lColour As Long

    If bEnable Then

        PreviewColourRowAuto 1, CurrentTableDesign.HeadingRow.Cells.BackgroundColour, PreviewTable

        lColour = GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.HeadingRow.ParagraphStyle))
        PreviewFontColourRowAuto 1, lColour, PreviewTable
        PreviewSetRowLines 0, CurrentTableDesign.HeadingRow.Cells
    Else
        'PreviewColourRowAuto 1, CurrentTableDesign.PlainGrid.Cells.BackgroundColour, PreviewTable

        lColour = GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.PlainGrid.ParagraphStyle))
        PreviewFontColourRowAuto 1, lColour, PreviewTable
        PreviewSetRowLines 0, CurrentTableDesign.PlainGrid.Cells
    End If


End Sub

Function GetColourFromStyle(sStyle As Style) As Long


    Dim c As Long
    
    With sStyle.Font.TextColor
        If .ObjectThemeColor = wdNotThemeColor Then
            GetColourFromStyle = Abs(.RGB)
        Else

            GetColourFromStyle = ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(modColorThemes.ThemeColorSchemeIndex(.ObjectThemeColor)).RGB

        End If
    End With


End Function



Sub PreviewSetTotal(bEnable As Boolean, PreviewTable As tTablePreview)
Dim i As Integer

    If bEnable Then

        PreviewColourRowAuto PreviewRows, CurrentTableDesign.TotalRow.Cells.BackgroundColour, PreviewTable

        PreviewFontColourRowAuto PreviewRows, GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.TotalRow.ParagraphStyle)), PreviewTable
        
        PreviewSetRowLines PreviewRows - 1, CurrentTableDesign.TotalRow.Cells
    Else
        'PreviewColourRowAuto PreviewRows, CurrentTableDesign.PlainGrid.Cells.BackgroundColour, PreviewTable

        PreviewFontColourRowAuto PreviewRows, GetColourFromStyle(ActiveDocument.Styles(CurrentTableDesign.PlainGrid.ParagraphStyle)), PreviewTable
        
        'PreviewSetRowLines PreviewRows - 1, CurrentTableDesign.PlainGrid.Cells
        lblPreviewHorizontalLines(PreviewRows - 1).BorderStyle = CurrentTableDesign.PlainGrid.Cells.BottomLine.Style
        lblPreviewHorizontalLines(PreviewRows - 1).BorderColor = CurrentTableDesign.PlainGrid.Cells.BottomLine.Colour
    
    End If
    
    

End Sub

Sub PreviewSetRowLines(RowIndex As Integer, tType As tCellDesign)

        lblPreviewHorizontalLines(RowIndex).BorderStyle = tType.TopLine.Style
        lblPreviewHorizontalLines(RowIndex).BorderColor = tType.TopLine.Colour
        
'            lblPreviewVerticalLines(RowIndex).BorderStyle = tType.LeftLine.Style
'            lblPreviewVerticalLines(RowIndex).BorderColor = tType.LeftLine.Colour
'            For i = 1 To PreviewColumns - 1
'                lblPreviewVerticalLines(i).BorderStyle = tType.VerticalLine.Style
'                lblPreviewVerticalLines(i).BorderColor = tType.Cells.VerticalLine.Colour
'            Next
'            lblPreviewVerticalLines(PreviewColumns).BorderStyle = tType.RightLine.Style
'            lblPreviewVerticalLines(PreviewColumns).BorderColor = tType.RightLine.Colour
        
        lblPreviewHorizontalLines(RowIndex + 1).BorderStyle = tType.BottomLine.Style
        lblPreviewHorizontalLines(RowIndex + 1).BorderColor = tType.BottomLine.Colour

End Sub

Sub PreviewSetColumnLines(ColIndex As Integer, tType As tCellDesign)



        lblPreviewVerticalLines(ColIndex).BorderStyle = tType.LeftLine.Style
        lblPreviewVerticalLines(ColIndex).BorderColor = tType.LeftLine.Colour
        
'            lblPreviewVerticalLines(RowIndex).BorderStyle = tType.LeftLine.Style
'            lblPreviewVerticalLines(RowIndex).BorderColor = tType.LeftLine.Colour
'            For i = 1 To PreviewColumns - 1
'                lblPreviewVerticalLines(i).BorderStyle = tType.VerticalLine.Style
'                lblPreviewVerticalLines(i).BorderColor = tType.Cells.VerticalLine.Colour
'            Next
'            lblPreviewVerticalLines(PreviewColumns).BorderStyle = tType.RightLine.Style
'            lblPreviewVerticalLines(PreviewColumns).BorderColor = tType.RightLine.Colour
        
        lblPreviewVerticalLines(ColIndex + 1).BorderStyle = tType.RightLine.Style
        lblPreviewVerticalLines(ColIndex + 1).BorderColor = tType.RightLine.Colour

End Sub

Sub PreviewSetTableOptions(tDesign As tTableDesign)


    With tDesign.TableDialogDefaultSettings
        cbxFirstColumn = .FirstColumn
        cbxVerticalBanding = .VerticalBanding
        cbxLastColumn = .LastColumn
        cbxHeading = .Heading
        cbxHorizontalBanding = .HorizontalBanding
        cbxTotal = .TotalRow
    End With
        


End Sub



Sub InitialiseAutoPreview(PreviewTable As tTablePreview)

Dim Row, col As Integer

'    With PreviewTable
'        .Top = 100
'        .Left = 15
'        .Width = 273 '350 '210 'Make sure this is divisible by PreviewColumns
'        .Height = 100 ' 70 'make sure this is divisible by PreviewRows
'        .Columns = PreviewColumns '7
'        .Rows = PreviewRows '9
'        .TextMargin = 15
'    End With

    For Row = 0 To PreviewTable.Rows - 1
        For col = 0 To PreviewTable.Columns - 1
        
            Set lblPreviewCells(Row, col) = frmTableType.Controls.Add("Forms.Label.1", "lblCells" & Row & col)
            'Debug.Print "lblTest" & i & j
            With lblPreviewCells(Row, col)
                .Left = PreviewTable.Left + (col * (PreviewTable.width / PreviewTable.Columns))
                .Top = PreviewTable.Top + (Row * (PreviewTable.Height / PreviewTable.Rows)) - Row
                .Height = PreviewTable.Height / PreviewTable.Rows
                .width = PreviewTable.width / PreviewTable.Columns
                .Caption = " Text"
                .TextAlign = fmTextAlignRight
                .BorderStyle = fmBorderStyleNone
                .Font.Size = PreviewTable.Font
            End With
        Next
    Next
    
    'Setup lines=========================================
    
    For Row = 0 To PreviewTable.Rows

        Set lblPreviewHorizontalLines(Row) = frmTableType.Controls.Add("Forms.Label.1", "lblHorizLine" & Row)
        
        With lblPreviewHorizontalLines(Row)
            .Left = PreviewTable.Left
            .Top = PreviewTable.Top + (Row * (PreviewTable.Height / PreviewTable.Rows)) - Row
            .Height = 1
            .width = PreviewTable.width - (1 * PreviewTable.Columns)
            'Debug.Print .Width
            .Caption = ""
            .TextAlign = fmTextAlignRight
            .BorderStyle = fmBorderStyleSingle
            .BorderColor = CurrentTableDesign.PlainGrid.Cells.BottomLine.Colour
            .BackStyle = fmBackStyleTransparent
            .Font.Size = 6
        End With

    Next

    For col = 0 To PreviewTable.Columns

        Set lblPreviewVerticalLines(col) = frmTableType.Controls.Add("Forms.Label.1", "lblVertLine" & col)
        
        With lblPreviewVerticalLines(col)
             .Left = PreviewTable.Left + (col * (PreviewTable.width / PreviewTable.Columns)) - (1 * col)
            .Top = PreviewTable.Top
            .Height = ((PreviewRows - 1) * lblPreviewCells(1, 1).Height) - 1 '- PreviewTable.Top
            .width = 1
            .Caption = ""
            .TextAlign = fmTextAlignRight
            .BorderStyle = fmBorderStyleSingle
            .BorderColor = CurrentTableDesign.PlainGrid.Cells.BottomLine.Colour
            .BackStyle = fmBackStyleTransparent
            .Font.Size = 4
        End With
    Next
    
    lblPreviewHeader.Left = PreviewTable.TextMargin
    lblPreviewHeader.width = frmTableType.width - PreviewTable.TextMargin + 50
    
    lblPreviewFooter.Left = PreviewTable.TextMargin
    lblPreviewFooter.width = frmTableType.width - PreviewTable.TextMargin + 50
    
    lblPreviewTitle.Left = PreviewTable.Left
    lblPreviewSource.Left = PreviewTable.Left
    
End Sub

Sub PreviewColourRowAuto(iRow As Integer, lColour As Long, PreviewTable As tTablePreview)

    Dim col As Integer

    For col = 0 To PreviewTable.Columns - 1
        With lblPreviewCells(iRow - 1, col)
            If lColour > -1 Then
                .BackColor = lColour
            End If
        End With
    Next

End Sub


Sub PreviewFontColourRowAuto(iRow As Integer, lColour As Long, PreviewTable As tTablePreview)

    Dim col As Integer

    For col = 0 To PreviewTable.Columns - 1
        With lblPreviewCells(iRow - 1, col)
            .ForeColor = lColour
        End With
    Next

End Sub
Sub PreviewColourColumnAuto(iCol As Integer, lColour As Long, PreviewTable As tTablePreview)

    Dim Row As Integer

    If lColour <> -1 Then
        For Row = 0 To PreviewTable.Rows - 1
            With lblPreviewCells(Row, iCol - 1)
                .BackColor = lColour
            End With
        Next
    End If
    
End Sub

Sub PreviewBoldRow(iRow As Integer, bSetting As Boolean, PreviewTable As tTablePreview)

    Dim col As Integer

    For col = 0 To PreviewTable.Columns - 1
        With lblPreviewCells(iRow - 1, col)
            .Font.Bold = bSetting
        End With
    Next

End Sub


Private Sub cbxFirstColumn_Click()
    PreviewUpdate CurrentPreview
End Sub

Private Sub cbxHorizontalBanding_Click()
    PreviewUpdate CurrentPreview
End Sub

Private Sub cbxHeading_Click()
    
    PreviewUpdate CurrentPreview
End Sub


Private Sub cbxLastColumn_Click()
    PreviewUpdate CurrentPreview
End Sub

Private Sub cbxVerticalBanding_Click()
    PreviewUpdate CurrentPreview
End Sub

Private Sub cbxTotal_Click()
    PreviewUpdate CurrentPreview
End Sub

Private Sub combxHeadingColour_Change()
    PreviewUpdate CurrentPreview
End Sub



Private Sub optPageWidth_Click()


    With CurrentPreview

        .Left = 15
        .width = 273 '350 '210 'Make sure this is divisible by PreviewColumns
    End With
    
    
    'KillExisitngPreview
    InitialiseAutoPreview CurrentPreview

    PreviewUpdate CurrentPreview

End Sub

Private Sub optParaWidth_Click()

    With CurrentPreview

        .Left = 100
        .width = 189 '350 '210 'Make sure this is divisible by PreviewColumns
        .Font = 5
    End With

    PreviewUpdate CurrentPreview


End Sub





'Private Sub ObtFirstColumn_Click()
'
'    Dim iCols As Integer
'
'    CurrentTableDesign = TableHighlightFirstColumn
'
'    If bNewTable Then
'        'Reset Col Count
'
'        iCols = CalculateMaxColumns(dTableWidth, CurrentTableDesign.FixedColumnWidth)
'        If txtCols.Value > iCols Then
'            txtCols.Value = Format(iCols, "#0")
'        End If
'
'    End If
'
'    EnableDisableControls CurrentTableDesign
'    ShowHideControls CurrentTableDesign
'    SetDefaultValueControls CurrentTableDesign
'    PreviewUpdate CurrentPreview
'
'End Sub

Private Sub txtSource_Change()

    lblPreviewSource = txtSource
    If txtSource = "" Then
        lblPreviewSource = "Source"
    End If
End Sub

Private Sub txtTitle_Change()

    lblPreviewTitle = txtTitle
    If txtTitle = "" Then
        lblPreviewTitle = "Title"
    End If
    

End Sub

Private Sub UserForm_Activate()


    Dim iSecNo As Integer
    Dim tTable As Table
    Dim rRange As Range
    
    If Not modTableStyles.AllStylesExist Then
        modError.DisplayMsg "The document does not contain all of the style required to build a table. Please make sure you have the latest Templates installed", vbCritical
        Unload Me
        Exit Sub
    End If
    
    'Set the version number text in right bottom corner
    Me.lblVers.Caption = Me.lblVers.Caption & TABLETOOL_VERSION
    
    'Need to see which type of section the selection is in
    iSecNo = Selection.Information(wdActiveEndSectionNumber)
    bPortraitPage = (ActiveDocument.Sections(iSecNo).PageSetup.Orientation = wdOrientPortrait)
    
    'Define all the Table design
    modTableDesign.SetupTableDesigns
    
    CurrentTableDesign = TableMain

    dTableWidth = Selection.PageSetup.TextColumns(1).width

    CustomSetCurrentPreview

    InitialiseAutoPreview CurrentPreview
    
    PreviewSetTableOptions TableMain
    
    CustomDialogBoxLayout

    'Hide the third column width options if not needed
    If bNewTable Or bWidthOnly Then
        chkKeep.visible = False
        
'        frmMain.Height = IIf(Me.frmTableType.Height > Me.frmTableOptions.Height, Me.frmTableType.Height, frmTableOptions.Height) + 14
'        butOk.Top = frmMain.Top + frmMain.Height + 6
'        butCancel.Top = butOk.Top
'        frmNewTable.Height = butOk.Top + butOk.Height + 36
    End If

    'Make sure the frames match
    'frmTableType.Height = frmTableOptions.Height


    'Set the Max number of Fin cols
    obtFinancial.Caption = "Financial - right aligned. MAX " & str(CalculateMaxColumns(dTableWidth, TableFinancial.FixedColumnWidth)) & " Columns"
    'obtFirstColumn.Caption = "Highlight First Column. MAX " & str(CalculateMaxColumns(dTableWidth, TableHighlightFirstColumn.FixedColumnWidth)) & " Columns"
    obtEven.Caption = "Plain Table. MAX " & str(CalculateMaxColumns(dTableWidth, TableMain.FixedColumnWidth)) & " Columns"
    
    

    'A new table
    If bNewTable Then
        Me.Caption = COMPANY_NAME & " - " & Me.Caption
        
        txtCols.text = "5"
        txtRows.text = "5"
        
        txtTitle.SetFocus
        
        SetDefaultValueControls CurrentTableDesign
        
    ElseIf bWidthOnly Then
        Me.Caption = COMPANY_NAME & " - " & "Reset Table Width"
        
        DisableHeadingSource
        DisableColumnsRows
        DisableRowFunctions
        
        
        ReadTableOptions Selection.Tables(1)

        'lblRemarks.Caption = "Altering the width of this table will change the column and table widths only. This will not affect cell shading or style"
        
   Else
    
        Me.Caption = COMPANY_NAME & " - " & "Quick Reformat Table and Reset Width"
        'Make various options unavailable
        DisableHeadingSource
        DisableColumnsRows
        DisableRowFunctions

        obtEven.SetFocus
        obtEven.Value = True

        ReadTableOptions Selection.Tables(1)
        
        'lblRemarks.Caption = "Re-formatting this table will re-apply these settings. This will overwrite any cell shading and re-apply relevant styles"
    
        chkKeep.SetFocus
        chkKeep.Value = True
        
    End If
    
    If Not bNewTable Then
        If tTable Is Nothing Then
            Set tTable = Selection.Tables(1)
        End If
        
        On Error Resume Next
        Set rRange = tTable.Range.Previous(wdParagraph)
        If rRange.Style = "Table title" Or rRange.Style Like "Table title (*" Then
            Me.txtTitle = Replace(rRange.text, vbCr, vbNullString)
        End If
        
        Set rRange = tTable.Range.Next(wdParagraph)
        If rRange.Style = "Source" Then
            Me.txtSource = Replace(rRange.text, vbCr, vbNullString)
        End If
        On Error GoTo 0

        If CalculateMaxColumns(dTableWidth, TableFinancial.FixedColumnWidth) < tTable.Columns.count Then
            If obtFinancial.Value = True Then obtEven.Value = True
            obtFinancial.enabled = False
        End If
        
        
    End If
    
    EnableDisableControls CurrentTableDesign
    ShowHideControls CurrentTableDesign
    
    If bWidthOnly Then
        DisableColumnRowOptions
    End If

    PreviewUpdate CurrentPreview
    

End Sub



Sub EnableDisableControls(tDesign As tTableDesign)

    With tDesign.TableDialogEnabledOptions
    
        cbxFirstColumn.enabled = .FirstColumn
        cbxVerticalBanding.enabled = .VerticalBanding
        cbxLastColumn.enabled = .LastColumn
        
        cbxHeading.enabled = .Heading
        cbxHorizontalBanding.enabled = .HorizontalBanding
        cbxTotal.enabled = .TotalRow
        
    End With
        
End Sub

Sub ShowHideControls(tDesign As tTableDesign)

    With tDesign.TableDialogVisibleSettings
    
        cbxFirstColumn.visible = .FirstColumn
        cbxVerticalBanding.visible = .VerticalBanding
        cbxLastColumn.visible = .LastColumn
        
        cbxHeading.visible = .Heading
        cbxHorizontalBanding.visible = .HorizontalBanding
        cbxTotal.visible = .TotalRow
        
    End With
        
End Sub

Sub SetDefaultValueControls(tDesign As tTableDesign)

    With tDesign.TableDialogDefaultSettings
    
        cbxFirstColumn.Value = .FirstColumn
        cbxVerticalBanding.Value = .VerticalBanding
        cbxLastColumn.Value = .LastColumn
        
        cbxHeading.Value = .Heading
        cbxHorizontalBanding.Value = .HorizontalBanding
        cbxTotal.Value = .TotalRow
        
    End With
        
End Sub


Sub DisableHeadingSource()

    txtTitle.enabled = False
    Label2.enabled = False
    Label3.enabled = False
    txtSource.enabled = False
    Me.txtTitle.enabled = False

End Sub

Sub DisableRowFunctions()

    lblRows.enabled = False
    
    cbxHeading.enabled = False

    cbxHorizontalBanding.enabled = False
    cbxTotal.enabled = False

End Sub

Sub DisableColumnsRows()

    Dim tTable As Table

    Set tTable = Selection.Tables(1)
    Me.txtCols = tTable.Columns.count
    Me.txtRows = tTable.Rows.count

    txtCols.enabled = False
    txtRows.enabled = False
    sbtCols.enabled = False
    sbtRows.enabled = False

End Sub

Sub DisableColumnRowOptions()

On Error Resume Next

    cbxFirstColumn.enabled = False
    cbxHeading.enabled = False
    cbxTotal.enabled = False
    obtEven.enabled = False
    'obtFirstColumn.enabled = False
    obtFinancial.enabled = False
    chkKeep.enabled = False

End Sub


Sub ReadTableOptions(tTable As Table)

On Error Resume Next

    Dim tTableOpts As tTableDialogSettings
    

    Me.txtCols = tTable.Columns.count
    Me.txtRows = tTable.Rows.count
    chkKeep.Value = True
        
    If tTable.Title = COMPANY_NAME_NO_SPACE & "Table" Then
    
        tTableOpts = modTables.GetAltText(tTable)
        
        Select Case tTableOpts.ColumnStyle
        Case eColumnTypes.tblcolEven
            obtEven.Value = True
        Case eColumnTypes.tblcolFinancial
            obtFinancial.Value = True
'        Case eColumnTypes.tblcolFirstCol
'            obtFirstColumn.Value = True

        End Select
        
        With tTableOpts
            cbxHeading = .Heading
            cbxHorizontalBanding = .HorizontalBanding
            cbxTotal = .TotalRow
            cbxFirstColumn = .FirstColumn
            cbxVerticalBanding = .VerticalBanding
            cbxLastColumn = .LastColumn
        End With


    End If


End Sub

'++*******************************************************************
' Description:  OK button pressed so insert a new table
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butOk_Click()

    Dim bSmartCut As Boolean
    Dim bTrackChanges As Boolean
    Dim tTable As Table
    Dim dTabWidth As Double
    Dim bColEven As Boolean
    Dim tTableOptions As tTableDialogSettings
    Dim dIndent As Double
    Dim iView As Integer
    Dim SelectedTableDesign As tTableDesign
    Dim bChangeLayout As Boolean
    Dim EmptyPara As Range
    
    Dim NewTableInsertionPoint As Range
    Dim FollowingPara As Range
    
    If obtFinancial Then
        SelectedTableDesign = TableFinancial
    Else
        SelectedTableDesign = TableMain
    End If
    
    If ValidateDialogValues(SelectedTableDesign) = False Then Exit Sub

    Me.Hide
    
    Set EmptyPara = Selection.Range
    EmptyPara.MoveEnd wdCharacter, 1
    
    tTableOptions = StoreDialogSettings

    SelectedTableDesign = CustomGetTableDesign

    'If smart cut and pastes is set to on switch off
    bSmartCut = False
    If Options.SmartCutPaste = True Then
        bSmartCut = True
        Options.SmartCutPaste = False
    End If

    'Switch off track Changes if on
    bTrackChanges = False
    If ActiveDocument.TrackRevisions Then
        bTrackChanges = True
        ActiveDocument.TrackRevisions = False
    End If

    'Change the cursor to Wait
    System.Cursor = wdCursorWait

    'Switch update screen off
    modScreenUpdating.ScreenUpdating_Disable
    iView = 3
    bChangeLayout = True
    If Selection.Tables.count > 0 Then
        If Selection.Tables(1).Rows.count > 10 Then
            iView = ActiveWindow.ActivePane.View.Type
            ActiveWindow.ActivePane.View.Type = wdNormalView
            bChangeLayout = True
        End If
    End If

    'Insert a new Table if New table option selected
    If bNewTable Then

        Set NewTableInsertionPoint = Selection.Range
        With NewTableInsertionPoint

                'Move to the start of the selected paragraph
                If Len(.Paragraphs(1).Range.text) > 1 Then
                    .Paragraphs(1).Range.Select
                    .Collapse wdCollapseStart
                End If
        
                'Make sure not just in front of a table
                If .Tables.count > 0 And .Information(wdEndOfRangeRowNumber) = -1 Then
                    .InsertAfter vbCr
                    .Style = wdStyleNormal
                End If
        
                'Insert the Source if required
                If txtSource <> "" Then
                    'Create the title as a paragraph infront of the current selection
                    .InsertBefore txtSource & vbCr
                    'Create the title as a paragraph infront of the current selection
                    .Style = SelectedTableDesign.SourceStyle
                    .Paragraphs(1).Range.Select
                    .Collapse wdCollapseStart
                End If
        
                If txtTitle <> "" Then
                    'Create the title as a paragraph infront of the current selection
                    .InsertBefore txtTitle & vbCr
                    'Make sure the correct Table title is used
                    .Style = SelectedTableDesign.TitleStyle
                    .Paragraphs(1).Range.Select
                    .Collapse wdCollapseEnd
                End If
        
        
                'If no source then see if the follow on paragraph has space before if not insert a NormalNoSpace
                If txtSource = "" Then
                    Set FollowingPara = NewTableInsertionPoint.Duplicate
                    With FollowingPara
                        .Collapse wdCollapseEnd
                        .Move wdParagraph, 1
                    End With
                    
                        If FollowingPara.Paragraphs(1).SpaceBefore = 0 Then
                            .InsertBefore vbCr
                            .Collapse wdCollapseStart
                            '.Style = "NormalNoSpace"
                            .Paragraphs(1).SpaceAfter = 0
                            .Paragraphs(1).SpaceBefore = 0
                        End If

                End If
        
                'Insert the new table
                modTables.InsertNewTable tTableOptions, SelectedTableDesign, NewTableInsertionPoint
                
        End With

    ElseIf bWidthOnly Then


        Set tTable = Selection.Tables(1)

        If Selection.Tables(1).Rows.WrapAroundText = False Then

            modTables.SetTableWidth tTable, tTableOptions, SelectedTableDesign
            setAltText tTable, tTableOptions

        Else
            MsgBox "The Table is a floating table and the reformatting feature will not work!", vbInformation, "Reformat table"
        End If

    Else
        'RE-Format the table and apply styles
        Set tTable = Selection.Tables(1)

        If Selection.Tables(1).Rows.WrapAroundText = False Then
           
            'Reformat the selected table
            tTableOptions.NewTable = True
            modTables.TableReformat tTable, tTableOptions, SelectedTableDesign, chkKeep
            setAltText tTable, tTableOptions
            
            tTable.Select
            modTables.zPosNegCells
            
        Else
            MsgBox "The Table is a floating table and the reformatting feature will not work!", vbInformation, "Reformat table"
        End If

    End If

    'Switch update screen on
    If bChangeLayout Then
       If Selection.Tables(1).Rows.count > 10 Then
    
           Application.ActiveWindow.ActivePane.View.Type = iView
           modScreenUpdating.ScreenUpdating_Enable
           
       End If
    End If

    'Switch back on Smart cut and paste
    If bSmartCut Then
        Options.SmartCutPaste = True
    End If

    'Switch Track Changes back on
    If bTrackChanges Then
        ActiveDocument.TrackRevisions = True
    End If

    'Delete the last blank para
    If Not EmptyPara.Information(wdWithInTable) Then
        With EmptyPara
            .Collapse wdCollapseEnd
            .MoveStart wdCharacter, -1
            If Asc(.Characters(1)) = 13 Then
                .Delete
            End If
        End With
    End If
    
    
    System.Cursor = wdCursorNormal

    'Unload the files
    Unload Me

    Exit Sub

butOk_Click_EH:
    Const sProcedure As String = "butOk_Click"
    GlobalErrorHandler err.Number, err.Description, MODULE_NAME, sProcedure
    
    Exit Sub
    
FrameError:
    
    'Unload the files
    Unload Me
    Exit Sub
    
End Sub


Function StoreDialogSettings() As tTableDialogSettings


    Dim tSettings As tTableDialogSettings

    With tSettings
        .Columns = txtCols
        .Rows = txtRows
        .Title = txtTitle.text
        .Source = txtSource.text
        
        If obtEven Then .ColumnStyle = tblcolEven
        If obtFinancial Then .ColumnStyle = tblcolFinancial
        'If obtFirstColumn Then .ColumnStyle = tblcolFirstCol

        'If chkKeep Then .ColumnStyle = tblcolNone
        
        .Heading = cbxHeading
        .HorizontalBanding = cbxHorizontalBanding
        .TotalRow = cbxTotal
        
        .FirstColumn = cbxFirstColumn
        .LastColumn = cbxLastColumn
        .VerticalBanding = cbxVerticalBanding
        
        .NewTable = txtCols.enabled
    End With
    
    StoreDialogSettings = tSettings

End Function

Function ValidateDialogValues(tTable As tTableDesign) As Boolean

    ValidateDialogValues = True

    On Error Resume Next

        If txtRows = "" Then
            MsgBox "There is no number in the number of rows!", vbInformation, "Insert new table"
            txtRows.SetFocus
            ValidateDialogValues = False
        End If

        If Val(txtRows) <= 0 Then
            MsgBox "The number of rows is not a valid number!", vbInformation, "Insert new table"
            txtRows.SetFocus
            ValidateDialogValues = False
        End If

        If Val(txtRows) > tTable.MaxRows Then
            MsgBox "The maximum number of rows is " & tTable.MaxRows & "!", vbInformation, "Insert new table"
            txtRows.SetFocus
            ValidateDialogValues = False

        End If

        If txtCols = "" Then
            MsgBox "There is no number in the number of columns!", vbInformation, "Insert new table"
            txtCols.SetFocus
            ValidateDialogValues = False
        End If

        
        Dim iCols As Integer
        iCols = CalculateMaxColumns(dTableWidth, TableFinancial.FixedColumnWidth)
        If obtFinancial And Val(txtCols) > iCols Then
            MsgBox "The maximum number of Financial columns is " & str(iCols), vbInformation, "Insert new table"
            txtCols.Value = iCols
            txtCols.SetFocus
            ValidateDialogValues = False
        
        End If
    
        If Val(txtCols) > tTable.MaxColumns Then
            MsgBox "The maximum number of columns is " & tTable.MaxColumns & "!", vbInformation, "Insert new table"
            txtCols.Value = tTable.MaxColumns
            txtCols.SetFocus
            ValidateDialogValues = False
        
        End If
        
End Function



Sub OptionButton_Click(cControl As control, iImage As Image)
    'cControl.SetFocus
    cControl.Value = True
    
    ClearFrames
    iImage.BorderColor = &HFF&
    
    'Next two lines are necessary to display different border colours for image.
    'It seems that it somehow 'resets' the image so the borders display correctly
    iImage.visible = False    'now button change event has changed the image border, but it looks like before.
    iImage.visible = True     'these two lines fixes that
End Sub




Sub ClearFrames()

    Dim cControl As control

    '&H80000006&
    For Each cControl In frmTableType.Controls
        If cControl.Name Like "img????#*" Then
            'cControl.visible = False
            cControl.BorderColor = &H80000006
        
        End If
    Next


End Sub


'++*******************************************************************
' Procedure:    Numbers_Only
' Author:       Brochet ltd
' Description:  Checks the character and only returns it if it is a number
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Function Numbers_Only(iKey As MSForms.ReturnInteger) As Variant

    If iKey > 47 And iKey < 58 Or iKey = 13 Or iKey = 8 Then
        Numbers_Only = iKey
    Else
        Numbers_Only = 0
    End If

End Function

Private Sub obtEven_Click()
    CurrentTableDesign = TableMain
    EnableDisableControls CurrentTableDesign
    ShowHideControls CurrentTableDesign
    SetDefaultValueControls CurrentTableDesign
    PreviewUpdate CurrentPreview
End Sub

Private Sub obtFinancial_Click()
    
    Dim iCols As Integer
    
    CurrentTableDesign = TableFinancial

    If bNewTable Then
        'Reset Col Count
    
        iCols = CalculateMaxColumns(dTableWidth, TableFinancial.FixedColumnWidth)
        If txtCols.Value > iCols Then
            txtCols.Value = Format(iCols, "#0")
        End If
    
    End If
    
    EnableDisableControls CurrentTableDesign
    ShowHideControls CurrentTableDesign
    SetDefaultValueControls CurrentTableDesign
    
    PreviewUpdate CurrentPreview

End Sub

Private Sub obtKeep_Click()

    CurrentTableDesign = TableMain
    EnableDisableControls CurrentTableDesign
    ShowHideControls CurrentTableDesign
    SetDefaultValueControls CurrentTableDesign
    PreviewUpdate CurrentPreview

End Sub



Sub MoveNextParagraph(rRange As Range)

    rRange.MoveEnd wdParagraph
    rRange.Collapse wdCollapseEnd

End Sub

'++*******************************************************************
' Procedure:    butCancel_Click
' Author:       Brochet ltd
' Description:  Cancel Button pressed, close dialog box and od nothing
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butCancel_Click()

    On Error GoTo butCancel_Click_EH
    
    'Set boolean to True so not display error messages
    bFormCancel = True

    Unload Me
    Exit Sub
    
butCancel_Click_EH:
    Const sProcedure As String = "butCancel_Click"
    GlobalErrorHandler err.Number, err.Description, MODULE_NAME, sProcedure
    
End Sub

'++*******************************************************************
' Procedures:   txtCols_Exit, txtCols_KeyPress
' Author:       Brochet ltd
' Description:  When the contents of txtCols changes:
'               txtCols_KeyPress - checks that only a numeric key is accepted
'               txtCols_Exit - checks that the entry is between 0 and 19
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub txtCols_Exit(ByVal Cancel As MSForms.ReturnBoolean)

Dim iMaxCols As Integer
    
    If bFormCancel = False Then
    
        iMaxCols = CalculateMaxColumns(dTableWidth, CurrentTableDesign.FixedColumnWidth)
    
        If Val(txtCols.Value) > iMaxCols Then
            modError.DisplayMsg "No of Columns must be " & iMaxCols & " or less!", vbCritical
            txtCols.Value = Format(iMaxCols, "#0")
            Cancel = True
        Else
            txtCols.Value = Format(Val(txtCols.Value), "#0")
        End If
    End If

End Sub

Private Sub txtCols_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)

    KeyAscii = Numbers_Only(KeyAscii)

End Sub

Private Sub sbtCols_SpinDown()

    If txtCols.Value > 1 Then
        txtCols.Value = Format(Val(txtCols.Value - 1), "#0")
    Else
        Beep
    End If

End Sub

Private Sub sbtCols_SpinUp()

    If obtFinancial Then
        If txtCols.Value < CalculateMaxColumns(dTableWidth, TableFinancial.FixedColumnWidth) Then
            txtCols.Value = Format(Val(txtCols.Value + 1), "#0")
        Else
            Beep
        End If

    Else
        If txtCols.Value < CalculateMaxColumns(dTableWidth, TableMain.FixedColumnWidth) Then
            txtCols.Value = Format(Val(txtCols.Value + 1), "#0")
        Else
            Beep
        End If
    End If
    

End Sub

'++*******************************************************************
' Procedures:   txtRows_Exit, txtRows_KeyPress
' Author:       Nikki Pike
' Date:         April 2010
' Modified:
' Description:  When the contents of txtRows changes:
'               txtRows_KeyPress - checks that only a numeric key is accepted
'               txtRows_Exit - checks that the entry is between 0 and 1000
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub txtRows_Exit(ByVal Cancel As MSForms.ReturnBoolean)

    If bFormCancel = False Then
        If Val(txtRows.Value) > TABLE_MAX_ROWS Then
            modError.DisplayMsg "No of Rows must be  " & TABLE_MAX_ROWS & " or less!", vbCritical
            Cancel = True
        Else
            txtRows.Value = Format(Val(txtRows.Value), "#0")
        End If
    End If

End Sub

Private Sub txtRows_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)

    KeyAscii = Numbers_Only(KeyAscii)

End Sub

Private Sub sbtRows_SpinDown()

    Dim iMin As Integer
    
    iMin = getMinRows


    If txtRows.Value > 1 Then
        txtRows.Value = Format(Val(txtRows.Value - 1), "#0")
    Else
        Beep
    End If
    
    If txtRows.Value < iMin Then
        txtRows.Value = Format(Val(iMin), "#0")
    End If

End Sub

Private Sub sbtRows_SpinUp()

    If txtRows.Value < TABLE_MAX_ROWS Then
        txtRows.Value = Format(Val(txtRows.Value + 1), "#0")
    Else
        Beep
    End If

End Sub

Function getMinRows() As Integer

    Dim iMinRows As Integer
    
    If cbxTotal Then iMinRows = iMinRows + 1


    getMinRows = iMinRows

End Function


Private Sub UserForm_Initialize()

    Me.Top = Application.Top + (Application.UsableHeight / 2) - (Me.Height / 2)
    Me.Left = Application.Left + (Application.UsableWidth / 2) - (Me.width / 2)

End Sub
Attribute VB_Name = "frmProgress"
Attribute VB_Base = "0{54BEF6CA-28F8-4977-8308-89E8B6B0A2C9}{A123A886-C0BB-4850-AA72-BAC905FCDC19}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'* Expense Reduction Analysts Report template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: frmPlaceholderInsert
'*
'* Progress bar for operations that needs that
'***********************************************************************************

Option Explicit

#If VBA7 Then
    'Find the userform's Window
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    
    'Get the current window style
    Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long) As Long
    
    'Set the new window style
    Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    
    'Get the current window style
    Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long) As Long
    
    'Set the new window style
    Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Const GWL_STYLE = -16
Const WS_SYSMENU = &H80000
Const WS_VISIBLE = &H10000000
Const WS_DLGFRAME = &H400000
Const WS_BORDER = &H800000

Private iStep1 As Long
Private iMax1 As Long
Private iOrder1 As Long
Private iStep2 As Long
Private iMax2 As Long
Private iOrder2 As Long
Private iStep3 As Long
Private iMax3 As Long
Private iOrder3 As Long
Private iStep4 As Long
Private iMax4 As Long
Private iOrder4 As Long
Private iStep5 As Long
Private iMax5 As Long
Private iOrder5 As Long

'++*******************************************************************
' Description:  Initializes the progress bar dialog. Does the following
'               Sets the height of dialog based on number of progressbars requested
'               Sets the label for each bar
'               Sets the maximum value and step for each bar
' Parameters:   sCaption - Caption of the dialog
'               sDesc1 - Text in label below the first progress bar
'               iSteps - Number of steps for progressbar
'               iIncrement - How many steps are done in each increment (e.g. if iSteps is 100 and iIncrement is 5 then the progressbar would fill in 20 increments)
'               Other parameters are optional and are there to specify the same value for next prgressbars
' Returns:      N/A
'--********************************************************************
Public Sub Init(sCaption As String, sDesc1 As String, iSteps1 As Long, iIncrement1 As Long, _
            Optional sDesc2 As String, Optional iSteps2 As Long, Optional iIncrement2 As Long, _
            Optional sDesc3 As String, Optional iSteps3 As Long, Optional iIncrement3 As Long, _
            Optional sDesc4 As String, Optional iSteps4 As Long, Optional iIncrement4 As Long, _
            Optional sDesc5 As String, Optional iSteps5 As Long, Optional iIncrement5 As Long)
    Dim minimumHeight As Double
    
    'I need to get the height of title bar and borders around the dialog, so if I change the height to 0
    'the dialog will resize to it's minimum height. That will not be 0
    'THis way I can get the size of parts of dialog that are not usable
    Me.Height = 0
    minimumHeight = Me.Height
    
    'Set the caption of the dialog
    Me.Caption = sCaption
    
    'Position dialog into centre of current window
    Me.StartUpPosition = 0
    Me.Left = Application.Left + (0.5 * Application.width) - (0.5 * Me.width)
    Me.Top = Application.Top + (0.5 * Application.Height) - (0.5 * Me.Height)
    
    'Set the control for first progressbar
    lblDesc1.Caption = sDesc1
    lblCount1.Caption = iSteps1
    'lblCount1.AutoSize = True
    lblCount1.Left = frmProgressBars.width - 10 - lblCount1.width
    lblCount1.Caption = iSteps1
    lblOrder1.Caption = 0
    lblOrder1.Left = lblCount1.Left - 5 - lblOrder1.width
    'Set the height of dialog as if there is only one progressbar
    Me.Height = 97
    
    'if the parameter for second progressbar is used, set the controls for that as well
    If LenB(sDesc2) > 0 Then
        lblDesc2.Caption = sDesc2
        lblCount2.Caption = iSteps2
        lblCount2.AutoSize = True
        lblCount2.Left = frmProgressBars.width - 15 - lblCount2.width
        lblOrder2.Caption = 0
        lblOrder2.Left = lblCount2.Left - 3 - lblOrder2.width
        'Set the height of dialog as if there are two progressbars
        Me.Height = 148
        lblDesc2.visible = True
        frmBar2.visible = True
        lblOrder2.visible = True
        lblCount2.visible = True
    End If
    
    'if the parameter for third progressbar is used, set the controls for that as well
    If LenB(sDesc3) > 0 Then
        lblDesc3.Caption = sDesc3
        lblCount3.Caption = iSteps3
        lblCount3.AutoSize = True
        lblCount3.Left = frmProgressBars.width - 15 - lblCount3.width
        lblOrder3.Caption = 0 & " of "
        lblOrder3.Left = lblCount3.Left - 3 - lblOrder3.width
        'Set the height of dialog as if there are Three progressbars
        Me.Height = 198
        lblDesc3.visible = True
        frmBar3.visible = True
        lblOrder3.visible = True
        lblCount3.visible = True
    End If
    
    'if the parameter for fourth progressbar is used, set the controls for that as well
    If LenB(sDesc4) > 0 Then
        lblDesc4.Caption = sDesc4
        lblCount4.Caption = iSteps4
        lblCount4.AutoSize = True
        lblCount4.Left = frmProgressBars.width - 15 - lblCount4.width
        lblOrder4.Caption = 0 & " of "
        lblOrder4.Left = lblCount4.Left - 3 - lblOrder4.width
        'Set the height of dialog as if there are four progressbars
        Me.Height = 248
        lblDesc4.visible = True
        frmBar4.visible = True
        lblOrder4.visible = True
        lblCount4.visible = True
    End If
    
    'if the parameter for fifth progressbar is used, set the controls for that as well
    If LenB(sDesc5) > 0 Then
        lblDesc5.Caption = sDesc5
        lblCount5.Caption = iSteps5
        lblCount5.AutoSize = True
        lblCount5.Left = frmProgressBars.width - 15 - lblCount5.width
        lblOrder5.Caption = 0 & " of "
        lblOrder5.Left = lblCount5.Left - 3 - lblOrder5.width
        Me.Height = 298
        lblDesc5.visible = True
        frmBar5.visible = True
        lblOrder5.visible = True
        lblCount5.visible = True
    End If
    
    'Set all progressbars to their starting values
    iStep1 = iIncrement1
    iMax1 = iSteps1
    iOrder1 = 0
    iStep2 = iIncrement2
    iMax2 = iSteps2
    iOrder2 = 0
    iStep3 = iIncrement3
    iMax3 = iSteps3
    iOrder3 = 0
    iStep4 = iIncrement4
    iOrder4 = 0
    iMax4 = iSteps4
    iStep5 = iIncrement5
    iOrder5 = 0
    iMax5 = iSteps5
    
    'Position the controls that shows the brochet logo and text at the bottom of dialog
    imgBrochet.Top = Me.Height - (minimumHeight + imgBrochet.Height)
    lblVers.Top = imgBrochet.Top - 1.5
    lblVers.Caption = lblVers.Caption & " " & GLOBAL_VERSION
    
    frmProgressBars.Height = Me.Height - minimumHeight - frmProgressBars.Top - 10
    RemoveXButton
    
    'Repaint the dialog
    'Me.Repaint
    DoEvents
End Sub

'++*******************************************************************
' Procedure:    Step
' Author:       Brochet ltd
' Description:  Increases the value of given progressbar by one step
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Public Sub Step(Optional iBar As Integer = 1)
    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            SetValue iOrder1 + iStep1, iBar
        Case 2
            SetValue iOrder2 + iStep2, iBar
        Case 3
            SetValue iOrder3 + iStep3, iBar
        Case 4
            SetValue iOrder4 + iStep4, iBar
        Case 5
            SetValue iOrder5 + iStep5, iBar
    End Select
End Sub

'++*******************************************************************
' Procedure:    Finish
' Author:       Brochet ltd
' Description:  Set the value of progressbar to maximum value (finishing it)
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Public Sub Finish(Optional iBar As Integer = 1)
    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            SetValue iMax1, iBar
        Case 2
            SetValue iMax2, iBar
        Case 3
            SetValue iMax3, iBar
        Case 4
            SetValue iMax4, iBar
        Case 5
            SetValue iMax5, iBar
    End Select
End Sub

'++*******************************************************************
' Procedure:    SetValue
' Author:       Brochet ltd
' Description:  Set the value of progressbar to given value
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Public Sub SetValue(iValue As Long, Optional iBar As Integer = 1)
    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            'set the progressbar value
            iOrder1 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder1.Caption = CStr(iOrder1) & " of "
            lblOrder1.Left = lblCount1.Left - 3 - lblOrder1.width
        Case 2
            'set the progressbar value
            iOrder2 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder2.Caption = CStr(iOrder2) & " of "
            lblOrder2.Left = lblCount2.Left - 3 - lblOrder2.width
        Case 3
            'set the progressbar value
            iOrder3 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder3.Caption = CStr(iOrder3) & " of "
            lblOrder3.Left = lblCount3.Left - 3 - lblOrder3.width
        Case 4
            'set the progressbar value
            iOrder4 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder4.Caption = CStr(iOrder4) & " of "
            lblOrder4.Left = lblCount4.Left - 3 - lblOrder4.width
        Case 5
            'set the progressbar value
            iOrder5 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder5.Caption = CStr(iOrder5) & " of "
            lblOrder5.Left = lblCount5.Left - 3 - lblOrder5.width
    End Select
End Sub

'++*******************************************************************
' Procedure:    RedrawBar
' Author:       Brochet ltd
' Description:  The progress bar is in fact a label that changes the width. This will do this
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Private Sub RedrawBar(iBar As Integer)
    Dim maxWidth As Long

    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            maxWidth = frmBar1.width - 1
            If iOrder1 = 0 Then
                lblProgress1.width = 0
            Else
                lblProgress1.width = (maxWidth / iMax1) * (iOrder1 - 1)
            End If
        Case 2
            maxWidth = frmBar2.width - 1
            If iOrder2 = 0 Then
                lblProgress2.width = 0
            Else
                lblProgress2.width = (maxWidth / iMax2) * (iOrder2 - 1)
            End If
        Case 3
            maxWidth = frmBar3.width - 1
            If iOrder3 = 0 Then
                lblProgress3.width = 0
            Else
                lblProgress3.width = (maxWidth / iMax3) * (iOrder3 - 1)
            End If
        Case 4
            maxWidth = frmBar4.width - 1
            If iOrder4 = 0 Then
                lblProgress4.width = 0
            Else
                lblProgress4.width = (maxWidth / iMax4) * (iOrder4 - 1)
            End If
        Case 5
            maxWidth = frmBar5.width - 1
            If iOrder5 = 0 Then
                lblProgress5.width = 0
            Else
                lblProgress5.width = (maxWidth / iMax5) * (iOrder5 - 1)
            End If
    End Select
    Me.Repaint
    DoEvents
End Sub

''++*******************************************************************
'' Procedure:    UserForm_Initialize
'' Author:       Brochet ltd
'' Description:  Event handler for initilization event. Will remove x button for closing from dialog
'' Parameters:   N/A
'' Returns:      N/A
''--********************************************************************
'Private Sub UserForm_Initialize()
'    RemoveXButton
'End Sub

'++*******************************************************************
' Procedure:    RemoveXButton
' Author:       Brochet ltd
' Description:  Event handler for initilization event. Will remove x button for closing from dialog
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Public Sub RemoveXButton()
    Dim HWND As Long
    Dim lStyle As Long
    
    'get the handle of dialog windows
    HWND = getCurrentHWND
    'Get the current style of the windows
    lStyle = GetWindowLong(HWND, GWL_STYLE)
    'And set the new style of the windows using the previous style but without sysmenu
    SetWindowLong HWND, GWL_STYLE, (lStyle And Not WS_SYSMENU)
End Sub


'++*******************************************************************
' Procedure:    getCurrentHWND()
' Author:       Brochet ltd
' Description:  Gets the handle of this dialog
' Parameters:   N/A
' Returns:      Handle of dialog for use in WinAPI functions
'--********************************************************************
Private Function getCurrentHWND() As Long
    Dim sCaption As String
    Dim HWND As Long
    
    sCaption = Me.Caption
    'change the current caption to something vierd, because I will use this to identify the windows
    'and this will be less probable to appear twice
    Me.Caption = sCaption & "aaajshjkhdfskjgfjhfgahsfgsdjhjfgsdhj"
    
    'get the hwnd
    If Val(Application.Version) >= 9 Then
        HWND = FindWindow("ThunderDFrame", Me.Caption)
    Else
        HWND = FindWindow("ThunderXFrame", Me.Caption)
    End If
    
    'Set the original caption back
    Me.Caption = sCaption

    'return the handle
    getCurrentHWND = HWND
End Function

'++*******************************************************************
' Procedure:    CloseMe
' Author:       Brochet ltd
' Description:  Get rid of dialog
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Public Sub CloseMe()
    Unload Me
End Sub

Attribute VB_Name = "modArrays"
'***********************************************************************************
'* Brochet Legal Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modArrays
'*
'* Holds various procs to manipulate arrays
'*
'***********************************************************************************
Option Explicit
Option Compare Text
Option Private Module

Const msMODULE As String = "modArrays"

'++*******************************************************************
' Procedure:    ArrayIsDimed
' Author:       Brochet ltd
' Description:  Checks the incoming array is actaully dimensioned
' Parameters:   ary - the array to check
' Returns:      True is a properly dimensioned array
'--********************************************************************
Function ArrayIsDimed(ary) As Boolean
    'This function will check that an array has been initialised
    Dim i As Integer
    
    On Error Resume Next
    
    i = UBound(ary)
    
    ArrayIsDimed = err = 0
End Function

'++*******************************************************************
' Procedure:    ArrayNoOfDimensions
' Author:       Brochet ltd
' Description:  Returns the number of dimensions in the incoming array
' Parameters:   aArray - Array to check
' Returns:      -1=Array is not an aray or the number of dimensions
'--********************************************************************
Private Function ArrayNoOfDimensions(aArray) As Integer
    Dim i As Integer
    Dim j As Integer
    
    If Not ArrayIsDimed(aArray) Then
        ArrayNoOfDimensions = -1
        Exit Function
    End If
    
    On Error Resume Next
    Do Until err
        ArrayNoOfDimensions = i
        i = i + 1
        j = LBound(aArray, i)
    Loop
    On Error GoTo 0
End Function

'++*******************************************************************
' Procedure:    ArraySort
' Author:       Brochet Ltd
' Description:  Sorts a two dimensional array
' Parameters:   aArrayToSort - Array to sort
'               iCol2Sort - The column to sort (this assumes the incoming
'                 array's 1st dimension is rows and the 2nd columns)
'               bAscending - True if to be sorted ascending
'               TargetListOrComboBox - Listbox or combo box to populate
'                 with sorted array
' Returns:      N/A
'--********************************************************************
Sub ArraySort(aArrayToSort, iCol2Sort As Integer, bAscending As Boolean, Optional TargetListOrComboBox As ListBox)
    Dim b As Variant
    Dim i As Integer
    Dim j As Integer
    Dim s As String
    Dim found As Boolean
    Dim sltn()
    Dim iNoCols As Integer
    
    System.Cursor = wdCursorWait
    
    iNoCols = ArrayNoOfDimensions(aArrayToSort)
    If iNoCols = -1 Then
        Exit Sub
    ElseIf iNoCols <> 2 Then
        modError.DisplayMsg "Only expecting 2 dimensional arrays in 'ArraySort'.", vbExclamation
        Exit Sub
    End If
    
    iNoCols = UBound(aArrayToSort, 2)
    
    Do
        found = False
        For i = 0 To UBound(aArrayToSort, 1) - 1
            If bAscending Then
                found = aArrayToSort(i + 1, iCol2Sort) < aArrayToSort(i, iCol2Sort)
            Else
                found = aArrayToSort(i + 1, iCol2Sort) > aArrayToSort(i, iCol2Sort)
            End If
            
            If found Then
                'Swap this pair
                found = True
                For j = 0 To iNoCols
                    b = aArrayToSort(i, j)
                    aArrayToSort(i, j) = aArrayToSort(i + 1, j)
                    aArrayToSort(i + 1, j) = b
                Next j
                
                i = i - 2
                If i < -1 Then
                    i = -1
                End If
            End If
        Next i
    Loop Until Not found 'Keep looping until there are no more swaps required
    
    If Not TargetListOrComboBox Is Nothing Then
        TargetListOrComboBox.List() = aArrayToSort()
    End If
            
    System.Cursor = wdCursorNormal
End Sub


Attribute VB_Name = "modColorThemes"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modColorThemes
'*
'* Holds the global variables and constants
'***********************************************************************************

Option Explicit
Option Private Module

Public Const COLOR_THEME_DIRS As String = "Document Themes\Theme Colors"

Public gsColorThemePath As String

'++*******************************************************************
' Description:  Checks if the bookmark exists if it does returns the text
'               of the bookmark
' Parameters:   SchemeColor -
'               TintAndShade = between -1 and + 1, 0 is the colour in the
'               scheme + lighter, - darker
' Returns:      The text of the bookmark
'--********************************************************************
Function SchemeColorProperty(SchemeColor As MsoThemeColorIndex, TintAndShade As Double) As String

' Purpose: Convert a Word 2007 Scheme Color Index and TintAndShade
'           value to a hexadecimal string in the format required
'           to set a Color Property

    Const LightnessUnchanged = "FF"
    Const DarknessUnchanged = "FF"
    Const HexadecimalPrefix = "&H"
    Const SchemeColorIdentifier = "D"
    Const UnusedZeroByte = "00"

    Dim LightnessOrDarkness As String

    If TintAndShade >= 0 Then
        LightnessOrDarkness _
                = DarknessUnchanged & _
                  Right$("0" & Hex$((1 - TintAndShade) * &HFF), 2)
    Else
        LightnessOrDarkness _
                = Right$("0" & Hex$((1 + TintAndShade) * &HFF), 2) & _
                  LightnessUnchanged
    End If

    SchemeColorProperty = HexadecimalPrefix & _
                          SchemeColorIdentifier & _
                          Hex$(SchemeColor) & _
                          UnusedZeroByte & _
                          LightnessOrDarkness
End Function

Sub test2()
'Debug.Print RGB(255, 1, 0)
Dim r As Byte
Dim G As Byte
Dim b As Byte

ConvertLongToRGB RGB(255, 1, 0), r, G, b
'Debug.Print R & ", " & G & ", " & B
End Sub

Sub ConvertLongToRGB(ByVal Value As Long, r As Byte, G As Byte, b As Byte)
    r = Value Mod 256
    G = Int(Value / 256) Mod 256
    b = Int(Value / 256 / 256) Mod 256
End Sub

Function TintOrShadeRGB(lRGB As Long, TintOrShade As Double) As Long
Dim r As Byte
Dim G As Byte
Dim b As Byte

ConvertLongToRGB lRGB, r, G, b
If TintOrShade > 0 Then
    If TintOrShade > 1 Then
        TintOrShade = 1
    End If
    r = r + ((255 - r) * TintOrShade)
    G = G + ((255 - G) * TintOrShade)
    b = b + ((255 - b) * TintOrShade)
Else
    TintOrShade = TintOrShade * -1
    If TintOrShade > 1 Then
        TintOrShade = 1
    End If
    r = r * TintOrShade
    G = G * TintOrShade
    b = b * TintOrShade
End If

TintOrShadeRGB = RGB(r, G, b)
End Function


'++*******************************************************************
' Description:  Gets the first item in the sNodeName
' Parameters:   objXML - XML text
'               sNodeName - node name - scheme colour position
' Returns:      Return the colour as Hex string
'--********************************************************************
Function XMLColorNodeValue_getFirst(objXML As MSXML2.DOMDocument60, sNodeName As String) As String

    Dim nodes As IXMLDOMNodeList
    Dim node As IXMLDOMNode
    
    Set nodes = objXML.SelectNodes("//" & sNodeName & "//@val")
    
    If nodes.Length > 0 Then
        Set node = nodes.Item(0) '.SelectSingleNode("//" & nodes.Item(0).nodeName & "//@val")
        XMLColorNodeValue_getFirst = node.NodeValue
    Else
        XMLColorNodeValue_getFirst = ""
    End If
    
End Function

Function XMLGetRGBValue(sXMLPathAndName As String, sColourNode As String) As Long

    Dim strXML As String
    Dim sColourHex As String
    Dim objXML As MSXML2.DOMDocument60

    'Get the text from the xml file with theme
    'strXML = FileImportText(gsColorThemePath & cbxSector.List(cbxSector.ListIndex, 1))
    strXML = FileImportText(sXMLPathAndName)
    If LenB(strXML) <> 0 Then

        'and create dom document from xml string
        Set objXML = New MSXML2.DOMDocument60
        If Not objXML.LoadXML(strXML) Then  'strXML is the string with XML'
            err.Raise objXML.parseError.ErrorCode, , objXML.parseError.reason
        End If

        On Error Resume Next
        'Finds a:accent1 node in xml
        'sColourHex = modColorThemes.XMLColorNodeValue_getFirst(objXML, "a:accent1")
        sColourHex = modColorThemes.XMLColorNodeValue_getFirst(objXML, sColourNode)
        'and gets its value and split it to rgb components
        XMLGetRGBValue = RGB(CLng("&H" & Mid(sColourHex, 1, 2)), CLng("&H" & Mid(sColourHex, 3, 2)), CLng("&H" & Mid(sColourHex, 5, 2)))
    Else
        MsgBox "No Data found in the XML file " & sXMLPathAndName
    End If
End Function

Private Function FileImportText(sPath As String) As String
    Dim fso As FileSystemObject
    
    On Error GoTo ErrorHandler
    
    Set fso = New FileSystemObject
    FileImportText = fso.OpenTextFile(sPath).ReadAll
    
CleanExit:
    Exit Function
ErrorHandler:
    FileImportText = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Procedure:    GetColorThemePath
' Author:       Brochet Ltd
' Description:  Find the path for the colour themes - look in 3 places:
'               1. in the INI file in [ColorThemes], "Path="
'               2. then in the Workgroup path + "Document Themes\Theme Colors"
'               3. then in the User group page + "Document Themes\Theme Colors"
' Parameters:   sIniFileName - Path and Name of INI file
' Returns:      The ColourTheme Path as a string
'--********************************************************************
Function GetColorThemePath(sIniFileName As String, sDefaultColorThemeFileName) As String
    Dim sPath As String
    Dim bPathFound As Boolean
    Dim fso As FileSystemObject

    'First see if there is a path set in the ini file
    bPathFound = False
    sPath = System.PrivateProfileString(sIniFileName, "ColorThemes", "Path")
    Set fso = New FileSystemObject
    If sPath <> "" Then
        If fso.FolderExists(sPath) Then
            If sDefaultColorThemeFileName <> "" Then
                If modPrivate.FileExists(fso.BuildPath(sPath, sDefaultColorThemeFileName)) Then
                    bPathFound = True
                End If
            End If
        End If
    End If
    
    'Secondly check the Workgroup path
    If Not bPathFound Then
        sPath = Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath) & "\" & COLOR_THEME_DIRS
        If fso.FolderExists(sPath) Then
            If sDefaultColorThemeFileName <> "" Then
                If modPrivate.FileExists(fso.BuildPath(sPath, sDefaultColorThemeFileName)) Then
                    bPathFound = True
                End If
            End If
        End If
    End If
    
    'Thirdly check the usergroup path
    If Not bPathFound Then
        sPath = Application.Options.DefaultFilePath(wdUserTemplatesPath) & "\" & COLOR_THEME_DIRS
        If fso.FolderExists(sPath) Then
            If sDefaultColorThemeFileName <> "" Then
                If modPrivate.FileExists(fso.BuildPath(sPath, sDefaultColorThemeFileName)) Then
                    bPathFound = True
                End If
            End If
        End If
    End If
    
    'Return the correct path
    If bPathFound Then GetColorThemePath = sPath
End Function

'Function GetLongRGBfromThemeColour(cColour As WdThemeColorIndex) As Long
'
'
'    Dim tcsThemeColorScheme As ThemeColorScheme
'    Dim tcThemeColor As ThemeColor
'    Set tcsThemeColorScheme = ActiveDocument.them
'    Set tcThemeColor = tcsThemeColorScheme.Colors(msoThemeAccent1)
'
'    GetLongRGBfromThemeColour = tcThemeColor.RGB
'
'End Function
 Function ThemeColorSchemeIndex(ThemeColorIndex As WdThemeColorIndex) As MsoThemeColorSchemeIndex
    Select Case ThemeColorIndex
        Case wdThemeColorMainDark1: ThemeColorSchemeIndex = msoThemeDark1
        Case wdThemeColorMainLight1: ThemeColorSchemeIndex = msoThemeLight1
        Case wdThemeColorMainDark2: ThemeColorSchemeIndex = msoThemeDark2
        Case wdThemeColorMainLight2: ThemeColorSchemeIndex = msoThemeLight2
        Case wdThemeColorAccent1: ThemeColorSchemeIndex = msoThemeAccent1
        Case wdThemeColorAccent2: ThemeColorSchemeIndex = msoThemeAccent2
        Case wdThemeColorAccent3: ThemeColorSchemeIndex = msoThemeAccent3
        Case wdThemeColorAccent4: ThemeColorSchemeIndex = msoThemeAccent4
        Case wdThemeColorAccent5: ThemeColorSchemeIndex = msoThemeAccent5
        Case wdThemeColorAccent6: ThemeColorSchemeIndex = msoThemeAccent6
        Case wdThemeColorHyperlink: ThemeColorSchemeIndex = msoThemeHyperlink
        Case wdThemeColorHyperlinkFollowed: ThemeColorSchemeIndex = msoThemeFollowedHyperlink
        Case wdThemeColorBackground1: ThemeColorSchemeIndex = msoThemeLight1
        Case wdThemeColorText1: ThemeColorSchemeIndex = msoThemeDark1
        Case wdThemeColorBackground2: ThemeColorSchemeIndex = msoThemeLight2
        Case wdThemeColorText2: ThemeColorSchemeIndex = msoThemeDark2
        Case Else: ' This shouldn't really ever happen
    End Select
End Function
Attribute VB_Name = "modError"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modError
'*
'* Holds the error handling routines
'***********************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modError"

Private Const PROJECT_NAME As String = "Insight Global"


'++*******************************************************************
' Description:  This routine displays a message to the user for any
'               VB errors that occur. Hopefully, the user will not see
'               these errors, but if they do, the information will be
'               invaluable to the developer
' Parameters:   lErrCode    => The VB error that occurred (OLE Automation
'                              errors will overflow an integer type)
'               sProcedure  => The name of the procedure where the error
'                              occurred
'               sModule     => The name of the module where the error
'                              occurred
'               sErrDesc    => The description of the VB error
'               sMsg        => User message that can be attached before
'                              standart error message
' Returns:      N/A
'--********************************************************************
Public Sub GlobalErrorHandler(ByVal lErrCode As Long, sErrDesc As String, sModule As String, ByVal sProcedure As String, Optional ByVal sMsg As String = vbNullString, Optional Line As Integer = 0)
    Dim sProcInfo As String
    Dim sErrInfo As String
    Dim sUserMsg As String
    
    On Error GoTo GlobalErrorHandler_EH
    
    sProcInfo = "Module: " & PROJECT_NAME & "." & sModule & vbCr & "Procedure: " & sProcedure & vbCr & IIf(Line = 0, vbCr, "Line: " & Line & vbCr)
    sErrInfo = "VBA Error Number: " & lErrCode & vbCr & "Error Description: " & sErrDesc
    If Len(sMsg) > 0 Then
        sUserMsg = sMsg & vbCr & vbCr
    End If
    sUserMsg = sProcInfo & sUserMsg & sErrInfo
    
    DisplayMsg sUserMsg, vbCritical, , True
    
CleanExit:
    Exit Sub
    
GlobalErrorHandler_EH:
    DisplayMsg "GlobalErrorHandler" & err.Number & " " & err.Description
    Resume CleanExit
End Sub

'++********************************************************************
' Description:  Output standard format error message for any of the
'               template errors.
' Parameters:   vstrProcedureName - Name of proc.
'               vstrMessage - Error message.
'               vlngNumber - Error number.
'               sModule - Module name.
'               iButton - Button type.
'               sExtraInfo - Further user information.
'               bAddStandardContactMsg - Set to true to add standard
'                   message to contact IT Support.
' Returns:      Result
'--********************************************************************
Public Function DisplayMsg(sMsg As String, _
  Optional iButton As VbMsgBoxStyle = vbInformation, _
  Optional sTitleBar As String = COMPANY_NAME, _
  Optional bAddStandardContactMsg As Boolean = False) As VbMsgBoxResult

    If bAddStandardContactMsg Then
        sMsg = sMsg & vbCr & vbCr & modGlobal.gsItSupport
    End If
    
    DisplayMsg = MsgBox(sMsg, iButton, sTitleBar)
                
End Function

Attribute VB_Name = "modEventsInitialise"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modEventsInitialize
'*
'* Initializes event handling
'***********************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "ModEventsInitialize"

Dim objEventHandler As clsEventHandler

'++*******************************************************************
' Procedure:    CreateEventHandler
' Author:       Brochet ltd
' Description:  Creates the EventHandler object
' Parameters:   none
' Returns:      none
'--********************************************************************
Sub CreateEventHandler()
   Set objEventHandler = New clsEventHandler
   
   'Notify the current instance of Word to check for application event procedures
   'inside the event handler object
   Set objEventHandler.aWordApp = Word.Application
End Sub

'++*******************************************************************
' Procedure:    DestroyEventHandler
' Author:       Brochet ltd
' Description:  Destroys the EventHandler object
' Parameters:   none
' Returns:      none
'--********************************************************************
Sub DestroyEventHandler()
   Set objEventHandler = Nothing
End Sub



Attribute VB_Name = "modFields"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPrivate
'*
'* Holds various macro code related to fields
'***********************************************************************************

Option Explicit
Option Private Module 'makes all macros private to this module - NO!!!! It makes it _
                        private to this PROJECT!

Private Const MODULE_NAME As String = "modFields"

'++*******************************************************************
' Description:  Select the whole document and update all the field codes.
' Parameters:   none
' Returns:      N/A
'--********************************************************************
Public Sub UpdateAllFields(Optional bUpdateCharts As Boolean = True)
    Dim tToc As TableOfContents
    Dim rRange As Range
    Dim fField As Field
    Dim progress As frmProgress
    Dim oUndo As cUndoRecord
    Dim oSection As section
    Dim eDisplayAlerts As WdAlertLevel
        
    On Error GoTo ErrorHandler
    
    eDisplayAlerts = Application.DisplayAlerts
    Application.DisplayAlerts = wdAlertsNone
    
    modScreenUpdating.ScreenUpdating_Disable
    Set oUndo = New cUndoRecord
    
    oUndo.SetName "Updating Fields"
    

    
    'First lets see if the user template has a function that handles updateing fields.
    'If that function returns false, that means that global template shouldn't do anything else
    'True means that global's update field functionality should continue.
    'This is usefull if user template needs to update protected fields, as global just ignores those.
    'Default value is true so globals functionality will run if there is no function handling the update field
    'in the user template
    If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("PreUpdateFields", True) Then
        
        
        Set progress = New frmProgress
        If bUpdateCharts Then
            progress.Init "Updating fields and Linked Charts", "Updating fields", ActiveDocument.StoryRanges.count + 1, 1
        Else
            progress.Init "Updating fields", "Updating fields", ActiveDocument.StoryRanges.count + 1, 1
        End If
        progress.Show
        

        
        'Update the field codes in the whole document
        For Each tToc In ActiveDocument.TablesOfContents
            UpdateFieldOrTOC tToc
        Next
        progress.Step
        
        Dim oField As Field
        For Each rRange In ActiveDocument.StoryRanges
            Do
                If bUpdateCharts Then
                    UpdateFieldOrTOC rRange.Fields
                Else
                    UpdateFieldOrTOCNoCharts rRange
                    
                End If
                Set rRange = rRange.NextStoryRange
            Loop Until rRange Is Nothing
            progress.Step
        Next rRange
        
        modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation "PostUpdateFields", True
    End If
    
CleanExit:
    Application.DisplayAlerts = eDisplayAlerts
    progress.CloseMe
    oUndo.EndRecording
    modScreenUpdating.ScreenUpdating_Enable
    Exit Sub
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "UpdateAllFields"
    Resume CleanExit
End Sub

Private Sub UpdateFieldOrTOCNoCharts(rRange As Range)
    On Error GoTo ErrorHandler
    Dim fField As Field
        
    'for some reason this does not update charts
    'This is good but I do not know what else if doesn't do
    For Each fField In rRange.Fields
        fField.Update
    Next
    
CleanExit:
    Exit Sub
ErrorHandler:
    'Error 4065 means that the object is locked. We don't want to update those
    'but we want to send any other error to the caller
    If err.Number = 4605 Then
        Resume CleanExit
    Else
        err.Raise err.Number, err.Source, err.Description, err.HelpFile, err.HelpContext
    End If
End Sub

Private Sub UpdateFieldOrTOC(oField As Object)
    On Error GoTo ErrorHandler
    oField.Update
    
CleanExit:
    Exit Sub
ErrorHandler:
    'Error 4065 means that the object is locked. We don't want to update those
    'but we want to send any other error to the caller
    If err.Number = 4605 Then
        Resume CleanExit
    Else
        err.Raise err.Number, err.Source, err.Description, err.HelpFile, err.HelpContext
    End If
End Sub

'++*******************************************************************
' Description:  Go through each of the Footer and update all the fields.
'               Start at the back and work forward.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Public Sub UpdateFieldsInFooters()
    Dim nSec As Integer
    Dim i As Integer
    
    nSec = ActiveDocument.Sections.count
    For i = nSec To 1 Step -1
        If ActiveDocument.Sections(i).Footers(wdHeaderFooterPrimary).LinkToPrevious = False Or i = 1 Then
            ActiveDocument.Sections(i).Footers(wdHeaderFooterPrimary).Range.Fields.Update
        End If
        If ActiveDocument.Sections(i).Footers(wdHeaderFooterFirstPage).LinkToPrevious = False Or i = 1 Then
            ActiveDocument.Sections(i).Footers(wdHeaderFooterFirstPage).Range.Fields.Update
        End If
    Next
End Sub

'++*******************************************************************
' Description:  Go through each of the Header and update all the fields.
'               Start at the back and work forward.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Public Sub UpdateFieldsInHeaders()
    Dim nSec As Integer
    Dim i As Integer
    Dim sShape As Shape
    
    nSec = ActiveDocument.Sections.count
    For i = nSec To 1 Step -1
        If ActiveDocument.Sections(i).Headers(wdHeaderFooterPrimary).LinkToPrevious = False Or i = 1 Then
            ActiveDocument.Sections(i).Headers(wdHeaderFooterPrimary).Range.Fields.Update
        End If
        If ActiveDocument.Sections(i).Headers(wdHeaderFooterFirstPage).LinkToPrevious = False Or i = 1 Then
            ActiveDocument.Sections(i).Headers(wdHeaderFooterFirstPage).Range.Fields.Update
        End If
    Next
End Sub
Attribute VB_Name = "modGlobal"
'***********************************************************************************
'* Brochet Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Version 1.0 - Date: 18.09.2019 - Author: Alan Cartwright
'*                  Inherited from Brochet
'* Version 1.01 - Date: 27.09.2019 - Author: Alan Cartwright
'*                  Added File Insert
'* Version 1.02 - Date: 27.09.2019 - Author: Alan Cartwright
'*                  Added Additional Table tools, Shade Row etc
'* Version 1.03 - Date: 02.10.2019 - Author: Alan Cartwright
'*                  Fixes to the table tool inc Different sized cells - EqualiseColumns
'* Version 1.04 - Date: 07.10.2019 - Author: Alan Cartwright
'*                  Minor change to table formatting - Line aize to 0.5 pt in 1st Column
'* Version 1.05 - Date: 21.10.2019 - Author: Alan Cartwright
'*                  Check with the template if OK to insert table
'* Version 1.06 - Date: 21.10.2019 - Author: Nikki
'*                  Changed table right padding to 0.1 (was 0.2)
'* Version 1.07 - Date: 08.11.2019 - Author: ARC
'*                  Table Tool - remove manual formatting on table reformat
'* Version 1.08 - Date: 18.11.2019 - Author: ARC
'*                  Table Tool - Financial - Fist col is selected and greyed
'* Version 1.09 - Date: 19.11.2019 - Author: ARC
'*                  Table Tool - Formats fin 1st col correctly
'* Version 1.10 - Date: 19.11.2019 - Author: ARC
'*                  Add Split button Updatefields/UpdateFields and Charts
'* Version 1.11 - Date: 28.11.2019 - Author: ARC
'*                  Coverts Flyer based templates to Commentary
'* Version 1.12 - Date: 29.11.2019 - Author: ARC
'*                  Added wait cursor to screen updating
'* Version 1.13 - Date: 06.12.2019 - Author: ARC
'*                  Prompts to update template if certain styles are missing - modTemplate.CheckTemplate
'*
'*
'*
'* Module: modGlobal
'*
'* Holds various Global variables and constants
'***********************************************************************************

Option Explicit
Option Compare Text

Private Const MODULE_NAME As String = "modGlobal"


Public Const DebugMode As Boolean = False

'INI file constants
Public Const GLOBAL_VERSION  As String = "1.13"
Public Const GLOBAL_DATE As String = "6 December 2019"

Public Const COMPANY_NAME As String = "Insight Investment"
Public Const COMPANY_NAME_SHORT As String = "Insight"
Public Const COMPANY_NAME_NO_SPACE As String = "InsightInvestment"

'INI file constants
Public Const COMPANY_INI_FILE_NAME As String = "Insight.ini"

Public gsItSupport As String 'Holds the name of the entity to contact when there's a problem _
                              with the system. Will be used in error messages
                              
Public gbGlobalIsOk As Boolean

Public gsIniFilePathAndName As String
Public gsTemplatePath As String


Public Const cOrange As Long = 1613567 'RGB(255, 158, 24)
Public Const cOrangeLight As Long = 7652607 'RGB(255,196,116)


Attribute VB_Name = "modGlobalPublic"
'************************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modGlobalPublic
'*
'* Holds code for global calls available from any template, and calling methods
'* from other templates.
'************************************************************************************
Option Explicit

Private Const MODULE_NAME As String = "modGlobalPublic"

#If VBA7 Then
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare PtrSafe Function GetSystemMenu Lib "user32" (ByVal HWND As Long, ByVal bRevert As Long) As Long
    Private Declare PtrSafe Function RemoveMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

    Private Declare PtrSafe Function ExtractIcon Lib "shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
    Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal HWND As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Long) As Long
#Else
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function GetSystemMenu Lib "user32" (ByVal HWND As Long, ByVal bRevert As Long) As Long
    Private Declare Function RemoveMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

    Private Declare Function ExtractIcon Lib "shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
    Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal HWND As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Long) As Long
#End If

' TODO this needs to be module that holds global directive functions in user templates
Private Const MODULE_TO_CALL As String = "ModPublic"

Public Enum EDirectiveReturnType
    ReturnString = 0
    ReturnNumeric = 1
    ReturnBoolean = 2
End Enum

Public Enum ESelectionTests
  EnsureNothingSelected = 1
  NotInTextBox = 2
  NotInHdrOrFtr = 4
  NotInFtOrEndNote = 8
  NotInEndNote = 16
  NotInFootNote = 32
  NotInFrame = 64
  NotInTable = 128
  NotInContentControl = 256
  NotInAny = 511
  MustBeEmptyPara = 512
  MustBeInTable = 1024
  NotInProtectedSection = 2048
  All = 2147483647
End Enum



Private Const WM_SETICON = &H80

'++*******************************************************************
' Description:  Calls the active document's template's 'GlobalDirectives'
'               procedure to retrieve parameters on
'               such things as whether to hide or show the Styles
'               group on the ribbon.
'               NOTE: Only the active document's template is checked
'               for the procedure being called
' Parameters:   sDirectiveName - name of the parameter to return.
' Returns:      The value of the parameter
'--********************************************************************
Public Function GlobalDirectivesReceiveMessage(messageName As String, Optional param1 As Variant, Optional param2 As Variant, _
                            Optional param3 As Variant, Optional param4 As Variant, Optional param5 As Variant, _
                            Optional param6 As Variant, Optional param7 As Variant, Optional param8 As Variant, _
                            Optional param9 As Variant, Optional param10 As Variant, Optional param11 As Variant) As Variant
    On Error GoTo ErrorHandler:
    
    GlobalDirectivesReceiveMessage = Empty
    
    Select Case messageName
    Case "IsOperationOkToDo"
        If Not IsMissing(param1) And Not IsMissing(param2) Then
            If VarType(param1) = vbString And VarType(param2) = vbLong Then
                GlobalDirectivesReceiveMessage = IsOperationOkToDo(CStr(param1), CLng(param2))
            End If
        End If
    Case "GetIniFilePath"
        'Need to reset the global variable
        If gsIniFilePathAndName = Null Or gsIniFilePathAndName = "" Then
            gsIniFilePathAndName = modINI.GetIniFilePath()
        End If
        GlobalDirectivesReceiveMessage = gsIniFilePathAndName
    Case "IsGlobalOK"
        GlobalDirectivesReceiveMessage = modGlobal.gbGlobalIsOk
    Case "UpdateFields"
        If IsMissing(param1) Then
            modFields.UpdateAllFields
        Else
            If VarType(param1) = vbBoolean Then
                modFields.UpdateAllFields CBool(param1)
            End If
        End If
    Case "TurnOffOpenAsReadingPane"
        
        modPrivate.TurnOffOpenAsReadingPane
    Case Else
    End Select
    
CleanExit:
    Exit Function
ErrorHandler:
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  This is a deprecated global directive function.
'               This function will call a function in the template of
'               active document, expecting a string as the return value.
' Parameters:   sDirectiveName - name of the function to call
'               iTypeOfReturn - Type of the returned value.
'                       Can be one of EDirectiveReturnType.
'               defaultValue - If User template doesn't return any value
'                   for whatever reason, this will be used as return value instead.
'
' Returns:      The value of the parameter
'--********************************************************************
Public Function GlobalDirectivesGet(sDirectiveName As String, Optional iTypeOfReturn As EDirectiveReturnType = EDirectiveReturnType.ReturnString, Optional defaultValue As Variant) As Variant
    On Error Resume Next
    GlobalDirectivesGet = Application.Run(MODULE_TO_CALL & ".GlobalDirectives", sDirectiveName)
    
    If err Or IsEmpty(GlobalDirectivesGet) Then
        'Either the routine being missing from the target or the directive has _
         not been set by the target template
        
        'Set either the requested default or type relevant default
        If Not IsMissing(defaultValue) Then
            GlobalDirectivesGet = defaultValue
        Else
            'If no default values have been returned, return the variable type's default
            GlobalDirectivesGet = Choose(iTypeOfReturn + 1, vbNullString, 0, False)
        End If
    Else
        On Error GoTo ErrorHandler
        'Ensure the returned variable is of the right type
        Select Case iTypeOfReturn
            Case ReturnBoolean
                If VarType(GlobalDirectivesGet) <> vbBoolean Then
                    GlobalDirectivesGet = GlobalDirectivesGet = "True"
                End If
            Case ReturnNumeric
                If Not IsNumeric(GlobalDirectivesGet) Then
                    GlobalDirectivesGet = Val(GlobalDirectivesGet)
                End If
            Case ReturnString
                GlobalDirectivesGet = CStr(GlobalDirectivesGet)
        End Select
    End If
    
CleanExit:
    Exit Function
    
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "GlobalDirectivesGet"
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Calls the active document's template's
'               GlobalDirectivesReceiveMessage  procedure to
'               retrieve parameters on
'               such things as whether to hide or show the Styles
'               group on the ribbon, or to invoke a method in the template.
'
'               NOTE: Only the active document's template is checked
'               for the procedure being called
' Parameters:   sDirectiveName - name of the message to send
'               defaultValue - This will be used as return value if the message
'                   can't be properly handled
'               parameters() - List of up to 11 parameters for the called message
' Returns:      The value that the function handling the message returned
'               or default value if message handling function failed
'--********************************************************************
Public Function GlobalDirectivesSendMessageNoConfirmation(sDirectiveName As String, defaultValue As Variant, _
                        Optional param1 As Variant, Optional param2 As Variant, _
                        Optional param3 As Variant, Optional param4 As Variant, Optional param5 As Variant, _
                        Optional param6 As Variant, Optional param7 As Variant, Optional param8 As Variant, _
                        Optional param9 As Variant, Optional param10 As Variant, Optional param11 As Variant) As Variant
                        
    On Error GoTo ErrorHandler
    
    GlobalDirectivesSendMessage sDirectiveName, defaultValue, _
                    param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11
        
    
CleanExit:
    SetVariant GlobalDirectivesSendMessageNoConfirmation, defaultValue
    Exit Function
ErrorHandler:
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Calls the active document's template's
'               GlobalDirectivesReceiveMessage  procedure to
'               retrieve parameters on
'               such things as whether to hide or show the Styles
'               group on the ribbon, or to invoke a method in the template.
'
'               NOTE: Only the active document's template is checked
'               for the procedure being called
' Parameters:   sDirectiveName - name of the message to send
'               retValue - The value that the function handling the message
'                   returns.
'               parameters() - List of up to 11 parameters for the called message
' Returns:      True if the call was succesfull, false otherwise
'--********************************************************************
Public Function GlobalDirectivesSendMessage(sDirectiveName As String, ByRef retValue As Variant, _
                            Optional param1 As Variant, Optional param2 As Variant, _
                            Optional param3 As Variant, Optional param4 As Variant, Optional param5 As Variant, _
                            Optional param6 As Variant, Optional param7 As Variant, Optional param8 As Variant, _
                            Optional param9 As Variant, Optional param10 As Variant, Optional param11 As Variant) As Boolean
    On Error Resume Next
    Dim result As Variant
    
    SetVariant result, Application.Run(MODULE_TO_CALL & ".GlobalDirectivesReceiveMessage", sDirectiveName, _
                                param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11)
    
    If err Or IsEmpty(result) Then
        'If no default values have been returned, return the variable type's default
        GlobalDirectivesSendMessage = False
    Else
        GlobalDirectivesSendMessage = True
        SetVariant retValue, result
    End If
    
CleanExit:
    Exit Function
    
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "GlobalDirectivesGet"
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  When function returns a variant, it's hard to
'               assign the result to a variable, because if its
'               one of the basic type (e.g. integer) we need a simple
'               assigment var = value. But if it's object we need set.
'               This procedure will assign any value in into given variant
' Parameters:   variantToSet - Variant variable we need to change
'               value - What should be new value of variant. Any type
' Returns:      n/a
'--********************************************************************
Private Sub SetVariant(ByRef variantToSet As Variant, Value As Variant)
    If IsObject(Value) Then
        Set variantToSet = Value
    Else
        variantToSet = Value
    End If
End Sub

'*******************************************************************************************************
'* Description: Checks if it's OK to perform an operation for the current selection.
'* Parameters:  sMsgDesc - Description of operation
'*              Series of optional boolean values to control what's tested.
'* Returns:     True if OK to perform operation here. False if not OK.
'*******************************************************************************************************
Public Function IsOperationOkToDo(sMsgDesc As String, pWhatToTest As ESelectionTests) As Boolean
    Dim sMsgCaption As String

    sMsgCaption = COMPANY_NAME & " - " & sMsgDesc

    IsOperationOkToDo = False 'Assume it can't be done here

    If Application.Documents.count = 0 Then
        modError.DisplayMsg sMsgDesc & " can only be performed if a document is opened", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And EnsureNothingSelected) And Selection.Type <> wdSelectionIP Then
        modError.DisplayMsg sMsgDesc & " can only be performed if nothing is selected.", vbInformation, sMsgCaption
    'Check that not in a textbox
    ElseIf (pWhatToTest And NotInTextBox) And Selection.ShapeRange.count > 0 Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a textbox.", vbInformation, sMsgCaption
    'Check not in Header and Footer
    ElseIf (pWhatToTest And NotInHdrOrFtr) And Selection.Information(wdInHeaderFooter) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Header or Footer.", vbInformation, sMsgCaption
    'Check not in Footnote or Endnote
    ElseIf (pWhatToTest And NotInFtOrEndNote) And Selection.Information(wdInFootnoteEndnotePane) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Footnote or EndNote Pane.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInEndNote) And Selection.Information(wdInEndnote) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in an EndNote.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInFootNote) And Selection.Information(wdInFootnote) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a FootNote.", vbInformation, sMsgCaption
        'TODO
'    ElseIf (pWhatToTest And NotInContentControl) And modContentControls.IsSelectionInCC(Selection.Range) Then
'        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Content Control.", vbInformation, sMsgCaption
    'Check to see if the selection includes all or part of a table
    ElseIf (pWhatToTest And NotInTable) And Selection.Information(wdWithInTable) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Table.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And MustBeEmptyPara) And (modPrivate.IsParagraphTrulyEmpty() = False) Then
        modError.DisplayMsg sMsgDesc & " can only be performed when in an empty (blank) paragraph.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInFrame) And Selection.Frames.count > 0 Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a framed paragraph.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And MustBeInTable) And Selection.Tables.count = 0 Then
        modError.DisplayMsg sMsgDesc & " cannot be performed unless a table is selected.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInTable) And _
        (Selection.Tables.count > 0 And (Selection.Information(wdEndOfRangeRowNumber) <> -1 And Not Selection.Type <> wdSelectionIP)) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when the selection contains a table", vbInformation, sMsgCaption
    
    Else
        IsOperationOkToDo = True
    End If
End Function

'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'                                 STILL TO CHECK
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************

'*******************************************************************************************************
'* Description: Diables the close button on a userform. If the userform has a short caption, it may be
'*              safer to change it to something crazy first, so it doeasn't change other window by accident
'* Parameters:  sFormCaption - The Caption of the form
'* Returns:     True if function finished without errors, false otherwise
'*******************************************************************************************************
Private Function DisableCloseButton(sFormCaption As String, Optional sIconPath As String = vbNullString) As Boolean
    Dim lnghWnd As Long
    Dim sThunderVers As String
    Dim lIcon As Long
    Const MF_BYPOSITION = &H400&
    
    On Error GoTo ErrorHandler
    
    'Which type of userform
    If Val(Application.Version) >= 9 Then
       sThunderVers = "ThunderDFrame"
    Else
       sThunderVers = "ThunderXFrame"
    End If

    lnghWnd = FindWindow(sThunderVers, sFormCaption)
    
    RemoveMenu GetSystemMenu(lnghWnd, 0), 6, MF_BYPOSITION 'When using by position, 6 represents the 7th menu item (including separators)
    
    If sIconPath <> vbNullString Then
        lIcon = ExtractIcon(0, sIconPath, 0)
        ' Get the window handle of the userform
        'Set the big (32x32) and small (16x16) icons
        'SendMessage lnghWnd, WM_SETICON, True, lIcon 'Set big (32x32) icon
        SendMessage lnghWnd, WM_SETICON, False, lIcon 'Set small (16x16) icon
    End If
    
    DisableCloseButton = True
    
CleanExit:
    Exit Function
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "DisableCloseButton"
    Resume CleanExit
    DisableCloseButton = False
End Function

Attribute VB_Name = "modINI"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPrivate
'*
'* Holds various macro code related to ini files
'*  - 08/06/2018 - Added iniFilePath parameter to IniFileKeyGet
'*  - 2018 07 23 - Added functions to get values of specific type (int, double, bool, path)
'*  - 2018 07 23 - Added more parameters to function returning specific type, so the caller can get the raw data and read status
'***********************************************************************************

Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modINI"

Public Enum EPathGetOption
    CheckFiles = 1
    CheckFolders = 2
    CheckAnything = 3
End Enum

Public Enum EIniReadStatus
    Success
    InvalidValue
    NoValue
    PathNotValid
    CantReadIni
End Enum

'*******************************************************************************************************
'* Description: Function will check if the INI file exists in one of the predefined locations.
'*                  The locations are as checked in this order: User template folder, Worgroup folder
'*                  Folder with the global template itself
'* Parameters:  N/A
'* Returns:     Path to the ini file if it existst, empty String otherwise
'*******************************************************************************************************
Public Function GetIniFilePath(Optional filename As String = modGlobal.COMPANY_INI_FILE_NAME) As String
    Dim foundPath As String
    
    foundPath = ""
    
    If LookForIniFileInPath("%USERPATH%", foundPath, filename) Then
    ElseIf LookForIniFileInPath("%WORKGROUPPATH%", foundPath, filename) Then
    ElseIf LookForIniFileInPath(ThisDocument.path, foundPath, filename) Then
    End If
    
    'foundPath is still empty if all LookForIniFileInPath above failed
    GetIniFilePath = foundPath
End Function

'*******************************************************************************************************
'* Description: Function will check if the INI file exists in one of the predefined locations.
'*                  The locations are as checked in this order: User template folder, Worgroup folder
'*                  Folder with the global template itself
'* Parameters:  N/A
'* Returns:     Path to the ini file if it existst, empty String otherwise
'*******************************************************************************************************
Private Function LookForIniFileInPath(path As String, ByRef outPath, filename As String) As Boolean
    Dim nfso As ClsNotFileSystemObject
    Set nfso = New ClsNotFileSystemObject
    
    Dim foundFiles As Collection
    
    Set foundFiles = nfso.SearchForFiles(path, COMPANY_INI_FILE_NAME, True)
    
    If foundFiles.count > 0 Then
        outPath = foundFiles(1)
        LookForIniFileInPath = True
    Else
        LookForIniFileInPath = False
    End If
End Function

'++********************************************************************
' Description:  Reads an ini file key checking if there are
'               continuation keys.
' Parameters:   sSection - Name of the ini file section.
'               sKey - Name of the ini file key.
' Returns:      Result from the ini file.
'--********************************************************************
Public Function IniFileKeyGet(iniFilePath As String, sSection As String, sKey As String) As String
    Dim i As Integer
    Dim sKeyValue As String
    Dim sText As String
    
    sText = System.PrivateProfileString(iniFilePath, sSection, sKey)
    
    i = 2
    Do While LenB(sText) > 0
        IniFileKeyGet = IniFileKeyGet & sText
        sText = System.PrivateProfileString(gsIniFilePathAndName, sSection, sKey & i)
        i = i + 1
    Loop
End Function

'++********************************************************************
' Description:  Function will try to read ini setting, and only if the
'               read is succesful it'll change the value passed in in
'               value parameter.
' Parameters:   iniFilePath     - Path to ini file
'               section         - Name of the ini file section.
'               key             - Name of the ini file key.
'               value           - This is byref parameter, so it's value
'                                 can be changed in the function.
'                                 it'll only change if the setting read
'                                 from INI file was succesfull
' Returns:      True if the read was successfull, false otherwise
'--********************************************************************
Public Function TryGetIniFileSetting(iniFilePath, section, key, ByRef Value As String, Optional expand As Boolean = True) As Boolean
    Dim sText As String
        
    TryGetIniFileSetting = False
    sText = System.PrivateProfileString(iniFilePath, section, key)
    
    If LenB(sText) > 0 Then
        If expand Then
            Value = modPrivate.ExpandString(sText)
        Else
            Value = sText
        End If
        
        TryGetIniFileSetting = True
    End If
End Function

'++*******************************************************************
' Description:  Sometimes the settings in ini file hold multiple substring
'               (e.g. list of files) separated with a separator.
'               This function returns values from settings like this
'               in the array of string in byre parameter retArray
' Parameters:   iniFilePath - Full path to ini file
'               iniFileSection - Ini file section for this set.
'               retArray - Array to fill with SUBSTRINGS
'               defaultValue - If ini file setting is not found (or empty)
'                   this value will be used to fill the retArray instead
'               prefix - Prefix that needs to be attached to start of each
'                   substring
'               prefixesToRemove - coma separated list of prefixes that should
'                   be removed from substring if present. This is done before
'                   the prefix is attached
'               separator - separator that separates substring in the setting
' Returns:      Boolean - True if all's OK.
'--********************************************************************
Public Function GetSplitStringIntoArray(iniFilePath As String, iniFileSection As String, key As String, _
                ByRef retArray() As String, Optional defaultValue As String = vbNullString, _
                Optional prefix As String = "", Optional prefixesToRemove As String, _
                Optional separator As String = ",") As Boolean
    Dim sText As String
    
    On Error GoTo ErrorHandler
    sText = Trim$(System.PrivateProfileString(iniFilePath, iniFileSection, key))
    
    If sText = vbNullString Then
        retArray = Split(defaultValue, separator)
    Else
        retArray = Split(sText, separator)
    End If
    
    RemovePrefixes prefixesToRemove, retArray
    AddPrefix prefix, retArray
    TrimArray retArray
    
    GetSplitStringIntoArray = True
CleanExit:
    Exit Function
ErrorHandler:
    GetSplitStringIntoArray = False
    Resume CleanExit
End Function

Private Sub TrimArray(retArray() As String)
    Dim i As Integer
    
    For i = LBound(retArray) To UBound(retArray)
        retArray(i) = Trim$(retArray(i))
    Next i
End Sub

'++*******************************************************************
' Description:  Attaches a given prefix to the beggining of each string
'               in retArray.
' Parameters:   prefix  -   prefix to be attached to each string
'               retArray -  Array of string where each substring needs
'                   to have the prefix. This is out parameter
' Returns:      n/a
'--********************************************************************
Private Sub AddPrefix(prefix As String, ByRef retArray() As String)
    Dim i As Integer
    
    For i = LBound(retArray) To UBound(retArray)
        retArray(i) = prefix & retArray(i)
    Next i
End Sub

'++*******************************************************************
' Description:  Removes any prefix from list of prefixes from
'               each string in given array of strings
' Parameters:   prefixesToRemove - coma separated list of prefixes that should
'                   be removed from substring if present.
'               retArray -  Array of string where each substring needs
'                   to not have the prefix. This is out parameter
'
' Returns:      Boolean - True if all's OK.
'--********************************************************************
Private Sub RemovePrefixes(prefixes As String, ByRef retArray() As String)
    Dim aPrefixesToRemove() As String
    Dim i As Integer
    Dim j As Integer
    
    If LenB(prefixes) > 0 Then
        aPrefixesToRemove = Split(prefixes, ",")
        For i = LBound(aPrefixesToRemove) To UBound(aPrefixesToRemove)
            For j = LBound(retArray) To UBound(retArray)
                If Len(retArray(j)) > Len(aPrefixesToRemove(i)) Then
                    If StrComp(Left(retArray(j), Len(aPrefixesToRemove(i))), aPrefixesToRemove(i), vbTextCompare) = 0 Then
                        retArray(j) = Right(retArray(j), Len(retArray(j)) - Len(aPrefixesToRemove(i)))
                    End If
                End If
            Next
        Next
    End If
End Sub

'++*******************************************************************
' Description:  Will return value from ini file as Integer
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetIntValue(iniFilePath As String, section As String, key As String, _
                        Optional defaultValue As Integer = 0, Optional ByRef rawData As String, _
                        Optional ByRef iniReadStatus As EIniReadStatus) As Integer
    iniReadStatus = Success
    
    On Error GoTo IniError
    
    rawData = System.PrivateProfileString(iniFilePath, section, key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetIntValue = CInt(rawData)
    Else
        GetIntValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetIntValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetIntValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return value from ini file as String
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetStringValue(iniFilePath As String, section As String, key As String, _
                            Optional defaultValue As String = "", Optional ByRef rawData As String, _
                            Optional ByRef iniReadStatus As EIniReadStatus) As String
    iniReadStatus = Success
    
    On Error GoTo IniError
    rawData = System.PrivateProfileString(iniFilePath, section, key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetStringValue = rawData
    Else
        GetStringValue = defaultValue
        iniReadStatus = NoValue
    End If
CleanExit:
    Exit Function
ErrorHandler:
    GetStringValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetStringValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return value from ini file as Integer
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetBoolValue(iniFilePath As String, section As String, key As String, _
                        Optional defaultValue As Boolean = False, Optional ByRef rawData As String, _
                        Optional ByRef iniReadStatus As EIniReadStatus) As Integer
    iniReadStatus = Success
    
    On Error GoTo IniError
    
    rawData = System.PrivateProfileString(iniFilePath, section, key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetBoolValue = CBool(rawData)
    Else
        GetBoolValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetBoolValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetBoolValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return value from ini file as Double
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetDoubleValue(iniFilePath As String, section As String, key As String, _
                        Optional defaultValue As Double = 0#, Optional ByRef rawData As String, _
                        Optional ByRef iniReadStatus As EIniReadStatus) As Integer
    iniReadStatus = Success
    
    On Error GoTo IniError
    rawData = System.PrivateProfileString(iniFilePath, section, key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetDoubleValue = CDbl(rawData)
    Else
        GetDoubleValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetDoubleValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetDoubleValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return Path from ini file as String.
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      Returns path set in ini file, but only if the path exists.
'               otherwise returns default value
'--********************************************************************
Public Function GetPathValue(iniFilePath As String, section As String, key As String, Optional defaultValue As String = "", _
                        Optional pathGetOption As EPathGetOption = EPathGetOption.CheckAnything, _
                        Optional ByRef rawData As String, Optional ByRef iniReadStatus As EIniReadStatus) As String
    
    iniReadStatus = Success
    
    On Error GoTo ErrorHandler
    rawData = modPrivate.ExpandString(System.PrivateProfileString(iniFilePath, section, key))
    
    If LenB(rawData) > 0 Then
        If modPrivate.FolderExists(rawData) And (pathGetOption Or CheckFolders) Then
            GetPathValue = rawData
        ElseIf modPrivate.FileExists(rawData) And (pathGetOption Or CheckFiles) Then
            GetPathValue = rawData
        Else
            GetPathValue = defaultValue
            iniReadStatus = PathNotValid
        End If
    Else
        GetPathValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetPathValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetPathValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++********************************************************************************************************
' Description:  In ini file we may want to use some markup for inserting specific things like
'               paragraph breaks and so on. This will resolve this markups
' Parameters:   sText - String as read from ini file
' Returns:      String where all markup is replaced with what it should be
'--********************************************************************************************************
'TODO check that all required markup is handled
Public Function ResolveINIMarkup(ByVal sText As String) As String
    'TODO currently the string is only expanded (environment variables are expanded), but nothing else
    'Add more markup resolves as needed.
    ResolveINIMarkup = modPrivate.ExpandString(sText)
End Function

'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'                                 STILL TO CHECK
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************

'++*******************************************************************
' Description:  Checks for the existance of critical ini files and
'               structures a return error msg.
' Parameters:   sTags - Tags/Keywords from file's properties.
'               rtn_iIniErrCount - Returned number of missing, critical
'                   ini files. 0=All OK.
'               rtn_sErrNosMsg - Structured start to error message with
'                   right error numbers.
' Returns:      N/A
'--********************************************************************
Sub IniFilesCriticalCheck(sTags As String, rtn_iIniErrCount As Integer, rtn_sErrNosMsg As String)
    Dim sInis() As String
    Dim sGlbPath As String
    Dim sFilenameSuffix As String
    Dim i As Integer
    Dim j As Integer
    
    rtn_sErrNosMsg = vbNullString
    rtn_iIniErrCount = 0
    
    If sTags = vbNullString Then
        'Nothing to do
        Exit Sub
    End If
    
    sInis = Split(sTags, ";")
    GlobalName , sGlbPath, , sFilenameSuffix
    sFilenameSuffix = Space$(1) & sFilenameSuffix & ".ini"
    
    For i = LBound(sInis) To UBound(sInis)
        j = InStrRev(sInis(i), ".")
        If j = 0 Then
            sInis(i) = sInis(i) & "."
            j = InStrRev(sInis(i), ".")
        End If
        sInis(i) = Left$(sInis(i), j - 1) & sFilenameSuffix
        If Not modPrivate.FileExists(sGlbPath & sInis(i)) Then
            'At least one of the critical ini files are missing
            rtn_iIniErrCount = rtn_iIniErrCount + 1
            'rtn_sErrNosMsg = rtn_sErrNosMsg & Switch( _
              sInis(i) = BR_LEGAL_INI_FILE_NAME, 2, _
              sInis(i) = BR_LEGAL_STYLES_INI_FILE_NAME, 3, _
              sInis(i) = BR_LEGAL_ARCHITECTURE_INI_FILE_NAME, 4, _
              sInis(i) = BR_LEGAL_COURT_INI_FILE_NAME, 5) & ", "
            rtn_sErrNosMsg = rtn_sErrNosMsg & "'" & sInis(i) & "', "
        End If
    Next i
    If rtn_iIniErrCount = 1 Then
        rtn_sErrNosMsg = "Missing ini file: " & Left$(rtn_sErrNosMsg, Len(rtn_sErrNosMsg) - 2)
    ElseIf rtn_iIniErrCount > 1 Then
        rtn_sErrNosMsg = Left$(rtn_sErrNosMsg, Len(rtn_sErrNosMsg) - 2)
        i = InStrRev(rtn_sErrNosMsg, ",")
        rtn_sErrNosMsg = Left$(rtn_sErrNosMsg, i - 1) & " and " & Mid$(rtn_sErrNosMsg, i + 2)
        rtn_sErrNosMsg = "Missing ini files: " & rtn_sErrNosMsg
    End If

End Sub

Attribute VB_Name = "modINI2"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPrivate
'*
'* Holds various macro code related to ini files
'***********************************************************************************

Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modINI"

'*******************************************************************************************************
'* Description: Function will check if the INI file exists in one of the predefined locations.
'*                  The locations are as checked in this order: User template folder, Worgroup folder
'*                  Folder with the global template itself
'* Parameters:  N/A
'* Returns:     Path to the ini file if it existst, empty String otherwise
'*******************************************************************************************************
Public Function GetIniFilePath(Optional filename As String = modGlobal.COMPANY_INI_FILE_NAME) As String
    Dim foundPath As String
    
    foundPath = ""
    
    If LookForIniFileInPath("%USERPATH%", foundPath, filename) Then
    ElseIf LookForIniFileInPath("%WORKGROUPPATH%", foundPath, filename) Then
    ElseIf LookForIniFileInPath(ThisDocument.path, foundPath, filename) Then
    End If
    
    'foundPath is still empty if all LookForIniFileInPath above failed
    GetIniFilePath = foundPath
End Function

'*******************************************************************************************************
'* Description: Function will check if the INI file exists in one of the predefined locations.
'*                  The locations are as checked in this order: User template folder, Worgroup folder
'*                  Folder with the global template itself
'* Parameters:  N/A
'* Returns:     Path to the ini file if it existst, empty String otherwise
'*******************************************************************************************************
Private Function LookForIniFileInPath(path As String, ByRef outPath, filename As String) As Boolean
    Dim nfso As ClsNotFileSystemObject
    Set nfso = New ClsNotFileSystemObject
    
    Dim foundFiles As Collection
    
    Set foundFiles = nfso.SearchForFiles(path, COMPANY_INI_FILE_NAME, True)
    
    If foundFiles.count > 0 Then
        outPath = foundFiles(1)
        LookForIniFileInPath = True
    Else
        LookForIniFileInPath = False
    End If
End Function

'++********************************************************************
' Description:  Reads an ini file key checking if there are
'               continuation keys.
' Parameters:   sSection - Name of the ini file section.
'               sKey - Name of the ini file key.
' Returns:      Result from the ini file.
'--********************************************************************
Public Function IniFileKeyGet(sSection As String, sKey As String) As String
    Dim i As Integer
    Dim sKeyValue As String
    Dim sText As String
    
    sText = System.PrivateProfileString(gsIniFilePathAndName, sSection, sKey)
    
    i = 2
    Do While LenB(sText) > 0
        IniFileKeyGet = IniFileKeyGet & sText
        sText = System.PrivateProfileString(gsIniFilePathAndName, sSection, sKey & i)
        i = i + 1
    Loop
End Function

'++********************************************************************
' Description:  Function will try to read ini setting, and only if the
'               read is succesful it'll change the value passed in in
'               value parameter.
' Parameters:   iniFilePath     - Path to ini file
'               section         - Name of the ini file section.
'               key             - Name of the ini file key.
'               value           - This is byref parameter, so it's value
'                                 can be changed in the function.
'                                 it'll only change if the setting read
'                                 from INI file was succesfull
' Returns:      True if the read was successfull, false otherwise
'--********************************************************************
Public Function TryGetIniFileSetting(iniFilePath, section, key, ByRef Value As String, Optional expand As Boolean = True) As Boolean
    Dim sText As String
        
    TryGetIniFileSetting = False
    sText = System.PrivateProfileString(iniFilePath, section, key)
    
    If LenB(sText) > 0 Then
        If expand Then
            Value = modPrivate.ExpandString(sText)
        Else
            Value = sText
        End If
        
        TryGetIniFileSetting = True
    End If
End Function

'++*******************************************************************
' Description:  Sometimes the settings in ini file hold multiple substring
'               (e.g. list of files) separated with a separator.
'               This function returns values from settings like this
'               in the array of string in byre parameter retArray
' Parameters:   iniFilePath - Full path to ini file
'               iniFileSection - Ini file section for this set.
'               retArray - Array to fill with SUBSTRINGS
'               defaultValue - If ini file setting is not found (or empty)
'                   this value will be used to fill the retArray instead
'               prefix - Prefix that needs to be attached to start of each
'                   substring
'               prefixesToRemove - coma separated list of prefixes that should
'                   be removed from substring if present. This is done before
'                   the prefix is attached
'               separator - separator that separates substring in the setting
' Returns:      Boolean - True if all's OK.
'--********************************************************************
Public Function GetSplitStringIntoArray(iniFilePath As String, iniFileSection As String, key As String, _
                ByRef retArray() As String, Optional defaultValue As String = vbNullString, _
                Optional prefix As String = "", Optional prefixesToRemove As String, _
                Optional separator As String = ",") As Boolean
    Dim sText As String
    
    On Error GoTo ErrorHandler
    sText = Trim$(System.PrivateProfileString(iniFilePath, iniFileSection, key))
    
    If sText = vbNullString Then
        retArray = Split(defaultValue, separator)
    Else
        retArray = Split(sText, separator)
    End If
    
    RemovePrefixes prefixesToRemove, retArray
    AddPrefix prefix, retArray
    TrimArray retArray
    
    GetSplitStringIntoArray = True
CleanExit:
    Exit Function
ErrorHandler:
    GetSplitStringIntoArray = False
    Resume CleanExit
End Function

Private Sub TrimArray(retArray() As String)
    Dim i As Integer
    
    For i = LBound(retArray) To UBound(retArray)
        retArray(i) = Trim$(retArray(i))
    Next i
End Sub

'++*******************************************************************
' Description:  Attaches a given prefix to the beggining of each string
'               in retArray.
' Parameters:   prefix  -   prefix to be attached to each string
'               retArray -  Array of string where each substring needs
'                   to have the prefix. This is out parameter
' Returns:      n/a
'--********************************************************************
Private Sub AddPrefix(prefix As String, ByRef retArray() As String)
    Dim i As Integer
    
    For i = LBound(retArray) To UBound(retArray)
        retArray(i) = prefix & retArray(i)
    Next i
End Sub

'++*******************************************************************
' Description:  Removes any prefix from list of prefixes from
'               each string in given array of strings
' Parameters:   prefixesToRemove - coma separated list of prefixes that should
'                   be removed from substring if present.
'               retArray -  Array of string where each substring needs
'                   to not have the prefix. This is out parameter
'
' Returns:      Boolean - True if all's OK.
'--********************************************************************
Private Sub RemovePrefixes(prefixes As String, ByRef retArray() As String)
    Dim aPrefixesToRemove() As String
    Dim i As Integer
    Dim j As Integer
    
    If LenB(prefixes) > 0 Then
        aPrefixesToRemove = Split(prefixes, ",")
        For i = LBound(aPrefixesToRemove) To UBound(aPrefixesToRemove)
            For j = LBound(retArray) To UBound(retArray)
                If Len(retArray(j)) > Len(aPrefixesToRemove(i)) Then
                    If StrComp(Left(retArray(j), Len(aPrefixesToRemove(i))), aPrefixesToRemove(i), vbTextCompare) = 0 Then
                        retArray(j) = Right(retArray(j), Len(retArray(j)) - Len(aPrefixesToRemove(i)))
                    End If
                End If
            Next
        Next
    End If
End Sub
Attribute VB_Name = "modNativeMethods"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Class:       modNativeMethods
'*
'* Holds:       Declaractions of API function usefull for any module
'***********************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modNativeMethods"

#If VBA7 Then
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As LongPtr) 'For 64 Bit Systems
#Else
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) 'For 32 Bit Systems
#End If

Attribute VB_Name = "modPrivate"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPrivate
'*
'* Holds various macro code
'***********************************************************************************

Option Explicit
Option Private Module 'makes all macros private to this module - NO!!!! It makes it _
                        private to this PROJECT!

Private Const MODULE_NAME As String = "modPrivate"

Enum EFileProperty
    filename
    Size
    ItemType
    DateModified
    DateCreated
    DateAccessed
    Attributes
    OfflineStatus
    OfflineAvailability
    PerceivedType
    Owner
    Kind
    DateTaken
    ContributingArtists
    Album
    Year
    Genre
    Conductors
    Tags
    Rating
    Authors
    Title
    Subject
    Categories
    Comments
    Copyright
    Number
    Length
    BitRate
    Protected
    CameraModel
    Dimensions
    CameraMaker
    Company
    FileDescription
    ProgramName
    Duration
    IsOnline
    IsRecurring
    Location
    OptionalAttendeeAddresses
End Enum

'++*******************************************************************
' Description:  Adds or sets the value of a document variable of the
'               passed in name and value.
' Parameters:   sName => The variable name.
'               sValue => The variable value.
' Returns:      N/A
'--********************************************************************
Sub DocVarSet(ByVal sName As String, ByVal sValue As String)
    
    On Error GoTo DocVarSet_EH
    ActiveDocument.Variables.Add Name:=sName, Value:=sValue
    Exit Sub

DocVarSet_EH:
    Select Case err.Number
        Case 5903 'Variable already exists just set the value
            ActiveDocument.Variables(sName).Value = sValue
        Case Else
            Const sProcedure As String = "DocVarSet"
            GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select
End Sub

'++*******************************************************************
' Description:  Returns the value of a document variable of the
'               passed in name.
' Parameters:   sName => The variable name.
' Returns:      String. The value of the variable or Null if it does
'               not exist.
'--********************************************************************
Function DocVarGet(ByVal sName As String) As String
    
    On Error GoTo DocVarGet_EH
    DocVarGet = ActiveDocument.Variables(sName).Value
    Exit Function

DocVarGet_EH:
    Select Case err.Number
      Case 5825 'Variable does not exist
        DocVarGet = vbNullString
      Case Else
        Const sProcedure As String = "DocVarGet"
        GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select

End Function


'*******************************************************************************************************
'* Description: If document is opened in reading mode from Outlook it often causes problems.
'*              So we need to switch that option off, and inform the user.
'* Parameters:  N/A
'* Returns:     N/A
'*******************************************************************************************************
Public Sub TurnOffOpenAsReadingPane()
    On Error GoTo ErrorHandler
    If Options.AllowReadingMode Then
        Options.AllowReadingMode = False
        modError.DisplayMsg "Information: The Word Start-up configuration setting to " & _
        "open email attachments in reading view has been turned off." & vbCr & vbCr & _
        "This is to avoid potential problems when opening documents from emails.", vbInformation
    End If
CleanExit:
    Exit Sub
ErrorHandler:
    Dim sProcedure As String
    sProcedure = "TurnOffOpenAsReadingPane"
    'GlobalErrorHandler Err.Number, sProcedure, MODULE_NAME, Err.Description
    Resume CleanExit
End Sub

'*******************************************************************************************************
'* Description: Checks to see if a file exists
'* Parameters:  sFilePathAndName - Path and file name to check for
'* Returns:     True if exists, False if it does not exist
'*******************************************************************************************************
Public Function FileExists(filePathAndName As String) As Boolean
    Dim nfso As ClsNotFileSystemObject
    
    Set nfso = New ClsNotFileSystemObject
    FileExists = nfso.CheckFileExists(filePathAndName)
End Function

'*******************************************************************************************************
'* Description: Checks to see if a file exists
'* Parameters:  sFilePathAndName - Path and file name to check for
'* Returns:     True if exists, False if it does not exist
'*******************************************************************************************************
Public Function FolderExists(folderPath As String) As Boolean
    Dim nfso As ClsNotFileSystemObject
    
    Set nfso = New ClsNotFileSystemObject
    FolderExists = nfso.CheckFolderExists(folderPath)
End Function

'*******************************************************************************************************
'* Description: Expands the string with environment variables, and other string code we can define in
'*              NotFileSystemObject class
'* Parameters:  String to expand
'* Returns:     Expanded string where all %XXXXX% codes are replaced with their values
'*******************************************************************************************************
Public Function ExpandString(text As String) As String
    Dim nfso As ClsNotFileSystemObject
    
    Set nfso = New ClsNotFileSystemObject
    ExpandString = nfso.ExpandPath(text)
End Function

'*******************************************************************************************************
'* Description: Returns information regarding the Global's path and name.
'* Parameters:  rtnFullPath - If present, is set to the Global's full path and name.
'*              rtnPathOnly - If present, is set to the Global's path only.
'*              rtnFileNameExtension - If present, is set to the Global's file extension.
'*              rtnFileNameExtension - If present, is set to the file name suffix.
'* Returns:     The Global's name.
'*******************************************************************************************************
Public Function GlobalName(Optional ByRef rtnFullPath As String = "", _
                    Optional ByRef rtnPathOnly As String = "", _
                    Optional ByRef rtnFileNameExtension As String = "", _
                    Optional ByRef rtnFileNameSuffix As String = "") As String
  
    Dim sText As String
    Dim i As Integer
    
    GlobalName = ThisDocument.Name
    rtnFullPath = ThisDocument.FullName
    rtnPathOnly = ThisDocument.path
    rtnFileNameExtension = GetExtensionFromFileName(ThisDocument.Name)
    rtnFileNameSuffix = GetExtensionFromFileName(ThisDocument.Name)
End Function

'*******************************************************************************************************
'* Description: Gets file name suffix. File name suffix is the last word in file name. E.G Global EL.dotm
'*              EL is the suffix. In Global.dotm, no suffix exists
'* Parameters:  n/a
'* Returns:     suffix from global template name
'*******************************************************************************************************
Private Function GetFilenameSuffix() As String
    Dim fso As FileSystemObject
    Dim lSpacePosition As Long
        
    Set fso = New FileSystemObject
    GetFilenameSuffix = fso.GetBaseName(ThisDocument.FullName)
    
    lSpacePosition = InStrRev(GetFilenameSuffix, " ")
    If lSpacePosition = 0 Then
        GetFilenameSuffix = vbNullString
    Else
        GetFilenameSuffix = Trim$(Mid$(GetFilenameSuffix, lSpacePosition))
    End If
End Function

'*******************************************************************************************************
'* Description: Get's the parent folder from full path. If the path points to a file, the directory that
'*              contains it will be returned, if path is a folder, parent folder is returned.
'*              This function will not check if the path or returned parent path exists.
'* Parameters:  fullPath - The path (preferably to a file) of which parent folder we want
'* Returns:     Parent path of fullPath, or empty string if error occured
'*******************************************************************************************************
Public Function GetPathFromFullpath(FullPath As String) As String
    Dim fso As FileSystemObject
    
    On Error GoTo ErrorHandler
    
    Set fso = New FileSystemObject
    GetPathFromFullpath = fso.GetParentFolderName(FullPath)
    
CleanExit:
    Exit Function
ErrorHandler:
    GetPathFromFullpath = vbNullString
    Resume CleanExit:
End Function

'*******************************************************************************************************
'* Description: Creates a fullpath from path and file name
'*              This function will not check if the path or returned fullpath exists.
'* Parameters:  path - the folder path containing the file
'*              filename - name of the file
'* Returns:     full path to a file
'*******************************************************************************************************
Public Function JoinPathAndFilename(path As String, filename As String) As String
    Dim oFso As FileSystemObject
    
    On Error GoTo ErrorHandler:
    
    Set oFso = New FileSystemObject
    JoinPathAndFilename = oFso.BuildPath(path, filename)

CleanExit:
    Exit Function
ErrorHandler:
    JoinPathAndFilename = ""
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "JoinPathAndFilename"
    Resume CleanExit
End Function

'*******************************************************************************************************
'* Description: Get's file extension from given file name or file path.
'*              This function will not check if the file exists.
'* Parameters:  FileName - Name of the file, or the path to a file
'* Returns:     File extension of a file, or empty string if error occured
'*******************************************************************************************************
Public Function GetExtensionFromFileName(filename As String) As String
    Dim fso As FileSystemObject
    
    On Error GoTo ErrorHandler
    
    Set fso = New FileSystemObject
    GetExtensionFromFileName = fso.GetExtensionName(filename)
    
CleanExit:
    Exit Function
ErrorHandler:
    GetExtensionFromFileName = vbNullString
    Resume CleanExit:
End Function

'++********************************************************
' Description:  Find minimal value from supplied parameters
' Parameters:   ParamArray nums()   - Any number of parameters of any type. It should only be called with numeric parameters, because it uses < operator
' Returns:      minimal value from supplied parameters
'--**********************************************************
Public Function min(ParamArray nums())
    'there is no type specified, because I wanted it to stay general. THis way it can be used with Integer and floats no problem
    Dim minVal
    Dim X
    
    minVal = nums(1)
    'parameters of cource are not ordered, so I need to go throught all of them
    For Each X In nums
        If X < minVal Then
            minVal = X
        End If
    Next X
    min = minVal
End Function

'++********************************************************
' Description:  Find maximal value from supplied parameters
' Parameters:   ParamArray nums()   - Any number of parameters of any type. It should only be called with numeric parameters, because it uses > operator
' Returns:      maximal value from supplied parameters
'--**********************************************************
Public Function max(ParamArray nums())
    'there is no type specified, because I wanted it to stay general. THis way it can be used with Integer and floats no problem
    Dim maxVal
    Dim X
    
    maxVal = nums(1)
    'parameters of cource are not ordered, so I need to go throught all of them
    For Each X In nums
        If X > maxVal Then
            maxVal = X
        End If
    Next X
    max = maxVal
End Function

'++********************************************************
' Description:  Checks if given document is a template
' Parameters:   Doc - Document to check
' Returns:      True if the document is a template, false otherwise
'--**********************************************************
Public Function IsTemplate(ByVal Doc As Document) As Boolean
  Select Case Doc.SaveFormat
    Case wdFormatTemplate, wdFormatDocument97, _
         wdFormatXMLTemplate, wdFormatXMLTemplateMacroEnabled, _
         wdFormatFlatXMLTemplate, wdFormatFlatXMLTemplateMacroEnabled
      IsTemplate = True
    Case Else
      IsTemplate = False
  End Select
End Function

'++********************************************************
' Description:  there is a document and if there is, if the active
'               document is in protected view. The reason for this is,
'               that if there are no documents, or activeDoc is protected,
'               we have to disable some operations
' Parameters:   n/a
' Returns:      True if the document is there are no documents
'               of if active document is in protected view.
'               False otherwise
'--**********************************************************
Function DocCountZeroOrDocInProtectedView() As Boolean
    Dim sText As String
    
    DocCountZeroOrDocInProtectedView = Documents.count = 0
    
    If Not DocCountZeroOrDocInProtectedView Then
        On Error Resume Next
        sText = ActiveDocument.Name
        If err = 4248 Then 'This command is not available because no document is open.
            DocCountZeroOrDocInProtectedView = True
        End If
        On Error GoTo 0
    End If
End Function

'++*******************************************************************
' Description:  Retrieves any of the file properties from a non open
'                   file.
' Parameters:   sFilePath - Full path and name of file.
'               iPropertyNo - Property number to return.
' Returns:      The requested property's value.
'--********************************************************************
Function FilePropertyGet(sFilePath As String, property As EFileProperty) As String
    Dim oShell As Object
    Dim oDir As Shell32.Folder
    
    Dim sPath As String
    Dim sFile As String
    Dim Doc As Document
    Dim bDocWasSaved As Boolean
    Dim oFso As FileSystemObject
    
    Set oFso = New FileSystemObject
    sPath = oFso.GetParentFolderName(sFilePath)
    sFile = oFso.GetFileName(sFilePath)
    
    'First check the template's not loaded because there's a weird bug that hides _
     a Templates 's Tags/Keywords property if the template is loaded
    Select Case property
    Case EFileProperty.Tags:
        For Each Doc In Documents
            If Doc.AttachedTemplate.Name = sFile Then
                'The template we need is actually loaded so get the property through _
                 the built in properties for the template
                 
                'Now, believe it or not, getting this property from the attached template will _
                 make it dirty so we need to deal with that by remembering its status before _
                 we call for the property
                bDocWasSaved = Doc.AttachedTemplate.Saved
                FilePropertyGet = Doc.AttachedTemplate.BuiltInDocumentProperties(wdPropertyKeywords)
                If Doc.AttachedTemplate.Saved <> bDocWasSaved Then
                    Doc.AttachedTemplate.Saved = bDocWasSaved
                End If
                Exit For
            End If
        Next Doc
        
        If Doc Is Nothing Then
            'If a starter doc has been initiated, it will have left its project "hanging around" in the _
             VBA environment. If that is the situation the above loop will not have found it if all the _
             docs based on that template are now closed. However, this next little to do will find that _
             Template that 's been left hanging around
            'Now, believe it or not, getting this property from the attached template will _
             make it dirty so we need to deal with that by remembering its status before _
             we call for the property
            On Error Resume Next 'In case the above is not the situation
            bDocWasSaved = Templates(sFilePath).Saved
            If err = 0 Then
                'Yep, here it is hanging around!!!
                FilePropertyGet = Templates(sFilePath).BuiltInDocumentProperties(wdPropertyKeywords)
                If Templates(sFilePath).Saved <> bDocWasSaved Then
                    Templates(sFilePath).Saved = bDocWasSaved
                End If
            End If
        End If
    Case Else:
        'If we didn't find the property we wanted above
        Set oShell = CreateObject("Shell.Application")
        Set oDir = oShell.NameSpace(sPath & "\")
        
        FilePropertyGet = oDir.GetDetailsOf(oDir.ParseName(sFile), CInt(property))
        
        Set oDir = Nothing
        Set oShell = Nothing
    End Select
End Function

'++*******************************************************************
' Description:  Resets the document styles, so they are the same as
'               styles in the template
' Parameters:   bAskForConfirmation - If true, yes/no messagebox
'                   will be shown
' Returns:      none
'--********************************************************************
Sub ResetToDefaultStyles(Optional bAskForConfirmation As Boolean = True)
    Dim nAns As VbMsgBoxResult
    
    If Not modPrivate.DocCountZeroOrDocInProtectedView Then
        'Need to see if the current document is not a template
        If ActiveDocument.Type = wdTypeDocument Then
            If bAskForConfirmation Then
                nAns = modError.DisplayMsg("Reset the current document to default styles?", vbQuestion + vbOKCancel, "Reset document to Default styles")
            Else
                nAns = vbOK
            End If
            
            If nAns = vbOK Then
                'Update the styles
                ActiveDocument.UpdateStyles
                On Error Resume Next
                'Remove the bullets
                ActiveDocument.Styles("Normal").LinkToListTemplate ListTemplate:=Nothing
                'Perform any local post update processing if it exists
                modGlobalPublic.GlobalDirectivesSendMessage "RunPostStyleResetProcess", Nothing
                On Error GoTo 0
                
                'Now, just in case there are, for example, some doc template style buttons that _
                 need now to be invalidated, invalidate the whole ribbon
                modRibbon.InvalidateRibbon
            End If
        Else
            modError.DisplayMsg "The document is a template and therefore cannot be reset!", vbExclamation, "Reset to Default Styles"
        End If
    Else
        modError.DisplayMsg "There are no documents open!", vbExclamation, "Reset to Default Styles"
    End If
End Sub

'++*******************************************************************
' Description:  Removes double spaces from document and replaces
'               them with single spaces
' Parameters:   none
' Returns:      none
'--********************************************************************
Public Sub RemoveDoubleSpaces()
    Dim count As Integer
    Dim messageSuffix As String
    Dim Title As String
    Title = "Remove Double Spaces"
    
    count = DoTextReplacementInSelection(" {2,}", " ", Title)
    
    If Selection.Type = wdSelectionIP Then
        messageSuffix = "below the selected point in the document."
    Else
        messageSuffix = "from the selection."
    End If
    
    If count > 0 Then
        modError.DisplayMsg count & " double space" & IIf(count > 1, "s", vbNullString) & " removed " & messageSuffix, , Title
    Else
        modError.DisplayMsg "No double spaces found " & messageSuffix, , Title
    End If
End Sub

'++********************************************************************
' Description:  Removes double pargraph break characters from document
'               and replaces them with single paragraph break
' Parameters:   none
' Returns:      none
'--********************************************************************
Public Sub RemoveDoubleParagraphs()
    Dim count As Integer
    Dim messageSuffix As String
    Dim Title As String
    
    count = DoTextReplacementInSelection("^13{2,}", "^p", "Removing double paragraphs")
    
    If Selection.Type = wdSelectionIP Then
        messageSuffix = "below the selected point in the document."
    Else
        messageSuffix = "from the selection."
    End If
    
    If count > 0 Then
        modError.DisplayMsg count & " double paragraph break" & IIf(count > 1, "s", vbNullString) & " removed " & messageSuffix, , Title
    Else
        modError.DisplayMsg "No double paragraph breaks found " & messageSuffix, , Title
    End If
End Sub

'++********************************************************************
' Description:  Replaces given text with replacement in selected text
'               or in text after current selection if nothing is selected
' Parameters:   text - what we want to replace
'               replacement - what will replace text
'               operation name - Name of the operation for undorecord
' Returns:      Number of replacements done
'--********************************************************************
Private Function DoTextReplacementInSelection(text As String, replacement As String, operationName As String) As Long
    Dim oRange As Range
    Dim count As Long
    
    Set oRange = Selection.Range
    ' wdSelectionIP means that nothing is selected. selection.start=selection.end.
    ' Do the search from selection to the end of the story
    If Selection.Type = wdSelectionIP Then
        oRange.WholeStory
        oRange.Start = Selection.Start
    End If
    
    DoTextReplacementInSelection = DoTextReplacementInRange(text, replacement, oRange, operationName)
End Function

'++********************************************************************
' Description:  Replaces given text with replacement in given range
' Parameters:   text - what we want to replace
'               replacement - what will replace text
'               oRange - Range where the replacement will be done
'               operation name - Name of the operation for undorecord
' Returns:      Number of replacements done
'--********************************************************************
Private Function DoTextReplacementInRange(text As String, replacement As String, oRange As Range, operationName As String)
    Dim oUndoRecord As cUndoRecord
    Dim count As Long
    
    On Error GoTo ErrorHandler
        
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName operationName
'
    ScreenUpdating_Disable
    
    count = Len(oRange.text)
    
    AddSomethingToUndoStack oRange
    
    If oRange.End > oRange.Start Then
        With oRange.Duplicate.Find
            .ClearFormatting
            .ClearAllFuzzyOptions
            .text = text
            .replacement.text = replacement
            .Forward = True
            .Wrap = wdFindStop
            .Format = False
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = True
            .MatchSoundsLike = False
            .MatchAllWordForms = False

            .Execute Replace:=wdReplaceAll
        End With
    End If
    
    count = count - Len(oRange.text)
    'GetSubstringCount(oRange.text, text)
    
    DoTextReplacementInRange = count
CleanExit:
    oUndoRecord.EndRecording
    ScreenUpdating_Enable
    Exit Function
    
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "DoTextReplacementInRange"
    DoTextReplacementInRange = 0
    Resume CleanExit
End Function

'++********************************************************************
' Description:  There is a bug in word where if undostack is empty
'               and we call orange.Finde.Execute, it can crash word
'               so we have to add something into the undostack.
'               This function will add and immediatelly remove space
'               from start of given range.
' Parameters:   oRange - range at the beginning of which the space will
'                   be temporarily created
' Returns:      n/a
'--********************************************************************
Private Sub AddSomethingToUndoStack(oRange As Range)
    Dim myRange As Range
    
    Set myRange = oRange.Duplicate
    myRange.Collapse wdCollapseStart
    myRange.text = " "
    myRange.text = ""
End Sub

'++********************************************************************
' Description:  Gets the number of substring occurences within given string
' Parameters:   text - String to be searched for substrings
'               substring - what we are looking for
' Returns:      Number of substring withing given string
'--********************************************************************
Private Function GetSubstringCount(text As String, substring As String) As Long
    GetSubstringCount = (Len(text) - Len(Replace(text, substring, "", , , vbTextCompare))) / Len(substring)
End Function


'*******************************************************************************************************
'* Description: Checks if the paragraph is truly empty. Having only a column break in the paragraph is
'*              OK. Having a page break is only OK if it's the last para in the doc.
'* Parameters:  N/A
'* Returns:     True=Paragraph can be assumed empty
'*******************************************************************************************************
Public Function IsParagraphTrulyEmpty() As Boolean
    Dim iAscVal As Integer
    
    Select Case Selection.Paragraphs(1).Range.Characters.count
        Case 1
            IsParagraphTrulyEmpty = True
        Case 2
            iAscVal = Asc(Selection.Paragraphs(1).Range.text)
            'Ascii 12=page break, 14=column break
            IsParagraphTrulyEmpty = iAscVal = 12 Or iAscVal = 14
            If IsParagraphTrulyEmpty Then
                If iAscVal = 12 Then
                    'It's a page break
                    'All's well if it's the last para in the document
                    IsParagraphTrulyEmpty = Selection.End = ActiveDocument.Range.End
                End If
            End If
        Case Else
            IsParagraphTrulyEmpty = False
    End Select
End Function

'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'                                 STILL TO CHECK
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************

'++*******************************************************************
' Description:  Checks for the existance of critical ini files and
'               structures a return error msg.
' Parameters:   sTags - Tags/Keywords from file's properties.
'               rtn_iIniErrCount - Returned number of missing, critical
'                   ini files. 0=All OK.
'               rtn_sErrNosMsg - Structured start to error message with
'                   right error numbers.
' Returns:      N/A
'--********************************************************************
Sub IniFilesCriticalCheck(sTags As String, rtn_iIniErrCount As Integer, rtn_sErrNosMsg As String)
    Dim sInis() As String
    Dim sGlbPath As String
    Dim sFilenameSuffix As String
    Dim i As Integer
    Dim j As Integer
    
    rtn_sErrNosMsg = vbNullString
    rtn_iIniErrCount = 0
    
    If sTags = vbNullString Then
        'Nothing to do
        Exit Sub
    End If
    
    sInis = Split(sTags, ";")
    GlobalName , sGlbPath, , sFilenameSuffix
    sFilenameSuffix = Space$(1) & sFilenameSuffix & ".ini"
    
    For i = LBound(sInis) To UBound(sInis)
        j = InStrRev(sInis(i), ".")
        If j = 0 Then
            sInis(i) = sInis(i) & "."
            j = InStrRev(sInis(i), ".")
        End If
        sInis(i) = Left$(sInis(i), j - 1) & sFilenameSuffix
        If Not modPrivate.FileExists(sGlbPath & sInis(i)) Then
            'At least one of the critical ini files are missing
            rtn_iIniErrCount = rtn_iIniErrCount + 1
            'rtn_sErrNosMsg = rtn_sErrNosMsg & Switch( _
              sInis(i) = BR_LEGAL_INI_FILE_NAME, 2, _
              sInis(i) = BR_LEGAL_STYLES_INI_FILE_NAME, 3, _
              sInis(i) = BR_LEGAL_ARCHITECTURE_INI_FILE_NAME, 4, _
              sInis(i) = BR_LEGAL_COURT_INI_FILE_NAME, 5) & ", "
            rtn_sErrNosMsg = rtn_sErrNosMsg & "'" & sInis(i) & "', "
        End If
    Next i
    If rtn_iIniErrCount = 1 Then
        rtn_sErrNosMsg = "Missing ini file: " & Left$(rtn_sErrNosMsg, Len(rtn_sErrNosMsg) - 2)
    ElseIf rtn_iIniErrCount > 1 Then
        rtn_sErrNosMsg = Left$(rtn_sErrNosMsg, Len(rtn_sErrNosMsg) - 2)
        i = InStrRev(rtn_sErrNosMsg, ",")
        rtn_sErrNosMsg = Left$(rtn_sErrNosMsg, i - 1) & " and " & Mid$(rtn_sErrNosMsg, i + 2)
        rtn_sErrNosMsg = "Missing ini files: " & rtn_sErrNosMsg
    End If

End Sub


'++*******************************************************************
' Procedure:    StyleExists
' Description:  Checks for the existence of a given style in the doc.
' Parameters:   sStyleName - Name of style to check.
' Returns:      True if it exists in the active doc.
'--********************************************************************
Function StyleExists(sStyleName As String) As Boolean

    Dim sText As String
    
    On Error Resume Next
    sText = ActiveDocument.Styles(sStyleName).NameLocal
    On Error GoTo 0
    
    StyleExists = sText <> vbNullString
    
End Function
Attribute VB_Name = "modRegistry"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modRegistry
'*
'* Holds various code related to working with registry
'***********************************************************************************
Private Const DEFAULT_REGISTRY_KEY As String = "HKEY_CURRENT_USER\Software\Brochet\" & modGlobal.COMPANY_NAME_NO_SPACE & "\"

Option Explicit
Option Compare Text

Private Const MODULE_NAME As String = "modRegistry"
'++*******************************************************************
' Description:  Gets a registry setting string value
' Parameters:   sSection - Registry section
'               sKey - Registry key
'               sDefault - Default if doesn't exist
' Returns:      The text of the setting
'--********************************************************************
Function RegistrySettingGetString(sSection As String, sKey As String, Optional sDefault As String = vbNullString, _
                        Optional ByVal sFullSection As String = vbNullString) As String
    Dim sPrefix As String
    
    On Error GoTo ErrorHandler
    If sFullSection = vbNullString Then
        sFullSection = DEFAULT_REGISTRY_KEY & sSection
    End If
    
    RegistrySettingGetString = System.PrivateProfileString(vbNullString, sFullSection, sKey)
    If RegistrySettingGetString = vbNullString Then
        RegistrySettingGetString = sDefault
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "RegistrySettingSave"
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Saves a registry setting
' Parameters:   sSection - Registry section
'               sKey - Registry key
'               sValue - Value to which to set the key
' Returns:      N/A
'--********************************************************************
Sub RegistrySettingSave(sSection As String, sKey As String, sValue As String, _
                        Optional ByVal sFullSection As String = vbNullString)
    Dim sPrefix As String
    
    On Error GoTo ErrorHandler:
    
    If sFullSection = vbNullString Then
        sFullSection = DEFAULT_REGISTRY_KEY & sSection
    End If
    System.PrivateProfileString(vbNullString, sFullSection, sKey) = sValue
    
CleanExit:
    Exit Sub
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "RegistrySettingSave"
    Resume CleanExit
End Sub

Attribute VB_Name = "modRibbon"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module:      modRibbon
'*
'* Holds:       Callbacks and support procedures for the ribbon.
'*******************************************************************************************************
Option Explicit
'Option Private Module

Private Const MODULE_NAME As String = "modRibbon"

' This is the prefix for the control id of the 3 insert DYNAMIC menus in the insert group.
' The first menu will be this prefix followed by a '1', the second followed by a '2'
' and the third a '3'. It is needed to invalidate the control after a 'Refresh list'
Const INSERT_MENU_ID_PREFIX As String = "MnBrochetInserts"

Private Enum ENewDocumentCreationError
    none
    FileMissing
    INIMissing
End Enum

Private rxBrochetLegalribbonUI As IRibbonUI

'++********************************************************************
' Procedure:    rxBrochetLegalRibbonUI_onLoad
' Description:  Respond to the load of the ribbon.
' Parameters:   ribbon - Ribbon control
' Returns:      N/A
'--********************************************************************
Private Sub RbnBrochetUI_onLoad(ribbon As IRibbonUI)
    On Error GoTo BrochetLegalRibbonUI_onLoadErr
    
    Set rxBrochetLegalribbonUI = ribbon
    'Replaces AutoExec as it's more reliable
    If Not modGlobal.gbGlobalIsOk Then
        modWordStartup.WordStartup
    End If

rxBrochetLegalRibbonUI_onLoadExit:
    Exit Sub

BrochetLegalRibbonUI_onLoadErr:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "RbnBrochetUI_onLoad", "Initialization of Global template failed "
    Resume rxBrochetLegalRibbonUI_onLoadExit
End Sub

'++********************************************************************
' Description:  Creates the XML code for the New Document menu
' Parameters:   control - the menu ribbon control name
'               returnedVal - return argument
' Returns:      none
'--********************************************************************
Public Sub DmBrochetFileNew_getContent(control As IRibbonControl, ByRef returnedVal)
    returnedVal = modRibbonMenu.NewMenuGenerate(EMenuType.NewDocs)
End Sub

'++********************************************************************
' Description:  Creates the XML code for the New Document menu
' Parameters:   control - the menu ribbon control name
'               returnedVal - return argument
' Returns:      none
'--********************************************************************
Private Sub DmBrochetStarterDocs_getContent(control As IRibbonControl, ByRef returnedVal)
    returnedVal = modRibbonMenu.NewMenuGenerate(EMenuType.StarterDocs)
End Sub
'++********************************************************************
' Description:  Creates the XML code for the New Document menu
' Parameters:   control - the menu ribbon control name
'               returnedVal - return argument
' Returns:      none
'--********************************************************************
Private Sub DmBrochetReportFileInsert_getContent(control As IRibbonControl, ByRef returnedVal)
    returnedVal = modRibbonMenu.NewMenuGenerate(EMenuType.ReportFileInsert)
End Sub


'++********************************************************************
' Description:  Creates the XML code for the New Document menu
' Parameters:   control - the menu ribbon control name
'               returnedVal - return argument
' Returns:      none
'--********************************************************************
Private Sub DmBrochetShortlistFileInsert_getContent(control As IRibbonControl, ByRef returnedVal)
    returnedVal = modRibbonMenu.NewMenuGenerate(EMenuType.ShortlistFileInsert)
End Sub
'++********************************************************************
' Description:  Creates the XML code for the New Document menu
' Parameters:   control - the menu ribbon control name
'               returnedVal - return argument
' Returns:      none
'--********************************************************************
Private Sub DmBrochetLetterFileInsert_getContent(control As IRibbonControl, ByRef returnedVal)
    returnedVal = modRibbonMenu.NewMenuGenerate(EMenuType.LetterFileInsert)
End Sub



'++********************************************************************
' Description:  Sets the enabled status of various ribbon controls
' Parameters:   control - the ribbon control name
'               enabled - The enabled status
' Returns:      none
' TODO:         Make sure that all controls are covered and correct.
'--********************************************************************
Private Sub RbnBrochet_getEnabled(control As IRibbonControl, ByRef enabled)
    Select Case control.ID
        Case "BtnRescueRibbonRefresh":
            enabled = True
        Case "DmBrochetNewDoc", "DmBrochetStarterDoc":
            enabled = modGlobal.gbGlobalIsOk
        Case Else
            enabled = modGlobal.gbGlobalIsOk And Not modPrivate.DocCountZeroOrDocInProtectedView
    End Select
End Sub

'++********************************************************************
' Description:  Sets the enabled status of various ribbon controls
' Parameters:   control - the ribbon control name
'               visible - Visibility of the control
' Returns:      none
' TODO:         Make sure that all controls are covered and correct.
'--********************************************************************
Private Sub RbnBrochet_getVisible(control As IRibbonControl, ByRef visible)
    visible = True
    Select Case control.ID
    ' These are all dummy buttons that are visible in case standard word buttons are hidden.
    ' We can't make idMso buttons disabled, so we have to do it this way
    Case "BtnMsDummyFileSave", "BtnMsDummyFileSaveAs", "BtnMsDummyFilePrintPreview", "BtnMsDummyFileClose", _
            "BtnMsDummyPasteMenu", "BtnMsDummyCut", "BtnMsDummyCopy", "BtnMsDummyFormatPainter", _
            "BtnMsDummyParagraphMarks"
        visible = Not modGlobal.gbGlobalIsOk Or modPrivate.DocCountZeroOrDocInProtectedView
    Case "FileSave", "FileSaveAs", "FilePrintPreview", "FileClose", _
            "PasteMenu", "Cut", "Copy", "FormatPainter", _
            "ParagraphMarks"
        visible = modGlobal.gbGlobalIsOk And Not modPrivate.DocCountZeroOrDocInProtectedView
    Case "FileOpen"
        visible = modGlobal.gbGlobalIsOk
    Case "BtnMsDummyFileOpen"
        visible = Not modGlobal.gbGlobalIsOk
    Case "GrpBrochetUtilities", "GrpBrochetUtilitiesSep1", "BtnResetToDefaultStyles", "BtnAttachTemplate", _
            "BtnRescueRibbonRefresh", "BtnRescueDelDblPara", "BtnRescueDelDblSpace"
        visible = Not StrComp(modRegistry.RegistrySettingGetString("Defaults", "UtilitiesGroupSize"), "small", vbTextCompare) = 0
    Case "GrpBrochetClipboard"
        visible = False
    Case "GrpBrochetTables"
        visible = modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GrpBrochetTables_getVisible", False)
    Case "DmBrochetReportFileInsert"
        'Check TemplateID for visibility
        
        If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GetTemplateID", False) = "RFP" Then
            visible = True
        Else
            visible = False
        End If
    Case "GrpInsertFileMenus"
        If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GetTemplateID", False) = "RFP" Then
            visible = True
        Else
            visible = False
        End If
    Case "DmBrochetShortlistFileInsert"
        'Check TemplateID for visibility
        If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GetTemplateID", False) = "Shortlist" Then
            visible = True
        Else
            visible = False
        End If
    Case "DmBrochetLetterFileInsert"
        'Check TemplateID for visibility
        If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GetTemplateID", False) = "Letter" Then
            visible = True
        Else
            visible = False
        End If
    Case Else
        visible = True
    End Select
End Sub

'++********************************************************************
' Description:  Sets the enabled status of various ribbon controls
' Parameters:   control - the ribbon control name
'               label - Label of the control
' Returns:      none
' TODO:         Make sure that all controls are covered.
'--********************************************************************
Private Sub RbnBrochet_getLabel(control As IRibbonControl, ByRef label)
    ' TODO check that no label needs to change
'    Debug.Print control.ID
    Select Case control.ID
        Case "tabBrochet":
            label = modGlobal.COMPANY_NAME_SHORT
        Case "GrpFile":
            'File group
            label = modGlobal.COMPANY_NAME_SHORT
        Case "DmBrochetStarterDoc":
            'Starter document menu button
            label = "Starter Documents"
        Case "DmBrochetReportFileInsert":
            'label = "Proposal Documents"
            label = modINI.GetStringValue(gsIniFilePathAndName, REPORT_INI_SECTION, "ButtonName", "Insert Files")
        Case "DmBrochetShortlistFileInsert":
            label = modINI.GetStringValue(gsIniFilePathAndName, SHORTLIST_INI_SECTION, "ButtonName", "Shortlist Files")
        Case "DmBrochetLetterFileInsert":
            label = modINI.GetStringValue(gsIniFilePathAndName, LETTER_INI_SECTION, "ButtonName", "Letter Files")
        Case "GrpBrochetUtilities":
            'Utilities group
            label = "Utilities"
    End Select
End Sub

'++********************************************************************
' Description:  Sets the enabled status of various ribbon controls
' Parameters:   control - the menu item ribbon control name
'               screentip - screentip of the control
' Returns:      none
' TODO:         Make sure that all controls are covered.
'--********************************************************************
Private Sub RbnBrochet_getScreentip(control As IRibbonControl, ByRef screentip)

    Select Case control.ID
    Case "DmBrochetStarterDoc"
        screentip = "Starter Documents"
    End Select

End Sub

'++********************************************************************
' Description:  Invalidating the whole ribbon will evoke the the series
'               of calls to the procedure 'RbnBrochet_getEnabled
'               to enable/disable controls on the Global's ribbon.
' Parameters:   sControls - Array of control IDs. If empty, whole ribbon
'                   will be refreshed. If not, Ccntrols with specified
'                   IDs will be refreshed only.
' Returns:      none
'--********************************************************************
Sub InvalidateRibbon(ParamArray sControls())
    Dim i As Integer
    

        
        If Not rxBrochetLegalribbonUI Is Nothing Then
            On Error Resume Next
    
            If UBound(sControls) = -1 Then
                rxBrochetLegalribbonUI.Invalidate
            Else
                For i = LBound(sControls) To UBound(sControls)
                    rxBrochetLegalribbonUI.InvalidateControl sControls(i)
                Next i
            End If
    
            'In case the document template needs to to something special when ribbon invalidates.
            modGlobalPublic.GlobalDirectivesSendMessage "RunPostRibbonInvalidateProcess", Nothing
    
            On Error GoTo 0
        End If

End Sub

'*******************************************************************************************************
'* Description: Invalidates the whole ribbon and is called by an OnTime call from the Before_Close
'*              event.
'* Parameters:  N/A
'* Returns:     N/A
'*******************************************************************************************************
Public Sub RibbonInvalidateDelayed()
    Application.OnTime Now, "ThisDocument.InvalidateRibbonAll"
End Sub

'++********************************************************************
' Description:  Update all field codes by first seeing if the document
'               template contains the macro to run. If not run the standard
'               macro to update all field codes
' Parameters:   control - the menu item ribbon control name
' Returns:      none
'--********************************************************************
Sub BtnBrochetUpdateFieldCodes_onAction(control As IRibbonControl)
    If Documents.count = 0 Then
        modError.DisplayMsg "There are no documents open!", vbInformation, COMPANY_NAME & " - No document open"
        Exit Sub
    End If
    
    Select Case control.ID
    Case "BtnBrochetUpdateFieldCodes", "BtnBrochetUpdateFieldCodesAll"
        modFields.UpdateAllFields False
    Case "BtnBrochetUpdateFieldCodesAndCharts"
        modFields.UpdateAllFields True
    End Select
    'Succeeded so done
    Exit Sub
    
CleanExit:
    Exit Sub
LocalUpdateAllFieldCodes:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "BtnBrochetUpdateFieldCodes_onAction"
    'Template routine not found so run the general purpose one in this Global
    Resume CleanExit
End Sub

'++********************************************************************
' Description:  Callback for the 'Refresh list' button on menus built
'               by this module.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub DynBtnBrochetRefreshListCallback(control As IRibbonControl)
    Dim i As Integer
    Dim sText As String
    Dim sInvalidateControl As String
    
    If IsNumeric(control.Tag) Then
        'Insert menu callback
        i = Val(control.Tag)
        'If Val not set the set to 1 as a default
        If i <= 0 Then
            i = 1
        End If
        sText = GetInsertDocIniSectionName(i)
        MenuXmlTextFileDelete InsertDocs, sText
        'zXmlTextWrite sText, vbNullString, True 'Delete the saved xml file
        sInvalidateControl = INSERT_MENU_ID_PREFIX & i
    ElseIf StrComp(control.Tag, "NewDoc") = 0 Then
        MenuXmlTextFileDelete EMenuType.NewDocs
        sInvalidateControl = modRibbonMenu.NEW_DOC_MENU_ID
    ElseIf StrComp(control.Tag, "StarterDoc") = 0 Then
        MenuXmlTextFileDelete EMenuType.StarterDocs
        sInvalidateControl = modRibbonMenu.STARTER_DOC_MENU_ID
    ElseIf StrComp(control.Tag, "ReportFileInsert") = 0 Then 'QQQ
        MenuXmlTextFileDelete EMenuType.ReportFileInsert
        sInvalidateControl = modRibbonMenu.REPORT_FILE_MENU_ID
    ElseIf StrComp(control.Tag, "ShortlistFileInsert") = 0 Then
        MenuXmlTextFileDelete EMenuType.ShortlistFileInsert
        sInvalidateControl = modRibbonMenu.SHORTLIST_FILE_MENU_ID
    ElseIf StrComp(control.Tag, "LetterFileInsert") = 0 Then
        MenuXmlTextFileDelete EMenuType.LetterFileInsert
        sInvalidateControl = modRibbonMenu.LETTER_FILE_MENU_ID
    ElseIf StrComp(control.Tag, "Inserts menu") = 0 Then
        MenuXmlTextFileDelete EMenuType.InsertDocs
        sInvalidateControl = modRibbonMenu.INSERT_FILE_MENU_ID
    Else
        modError.DisplayMsg "Callback for refreshing the list has an unrecognised control.Tag", vbInformation, "Invalid callback"
    End If
    
    If sInvalidateControl <> vbNullString Then
        InvalidateRibbon sInvalidateControl
    End If
End Sub

'++********************************************************************
' Description:  Will set the pressed property of the button.
'               If text boundaries are displayed in the document,
'               bOnOff is set to true, false otherwise
' Parameters:   control - Ribbon control
'               bOnOff - true = Toggle button toggled on, false = toggled off
' Returns:      N/A
'--********************************************************************
Sub TogTextBoundaries_getPressed(control As IRibbonControl, ByRef bOnOff)
    On Error Resume Next
    If Documents.count = 0 Then
        bOnOff = False
    Else
        bOnOff = ActiveWindow.View.ShowTextBoundaries
    End If
    On Error GoTo 0
End Sub

'++********************************************************************
' Description:  Will enable or disable text boundaries when TogTextBoundaries
'               is clicked, based on the pressed state of the control
' Parameters:   control - Ribbon control
'               bOnOff - true = Toggle button toggled on, false = toggled off
' Returns:      N/A
'--********************************************************************
Sub TogTextBoundaries_onAction(control As IRibbonControl, ByRef bOnOff)
    On Error Resume Next
    ActiveWindow.View.ShowTextBoundaries = bOnOff
    On Error GoTo 0
End Sub

'++********************************************************************
' Description:  Will enable or disable curly quotes when TogCurlyQuotes
'               is clicked, based on the pressed state of the control
' Parameters:   control - Ribbon control
'               bOnOff - true = Toggle button toggled on, false = toggled off
' Returns:      N/A
'--********************************************************************
Sub TogCurlyQuotes_onAction(control As IRibbonControl, ByRef bOnOff)
    Application.Options.AutoFormatAsYouTypeReplaceQuotes = Not Application.Options.AutoFormatAsYouTypeReplaceQuotes
    Application.Options.AutoFormatReplaceQuotes = Application.Options.AutoFormatAsYouTypeReplaceQuotes
    bOnOff = Application.Options.AutoFormatAsYouTypeReplaceQuotes
End Sub

'++********************************************************************
' Description:  Will set the pressed property of the button.
'               If curly quotes are switched on in the document,
'               bOnOff is set to true, false otherwise
' Parameters:   control - Ribbon control
'               bOnOff - true = Toggle button toggled on, false = toggled off
' Returns:      N/A
'--********************************************************************
Sub TogCurlyQuotes_getPressed(control As IRibbonControl, ByRef bOnOff)
    On Error Resume Next 'It has been known to cause issues
    bOnOff = Application.Options.AutoFormatAsYouTypeReplaceQuotes
    On Error GoTo 0
End Sub

'++********************************************************************
' Description:  Handles button callback from new document dynamic menu
'               with the exception of refresh button. Will create new
'               document based of selected template.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub DynBtnNewDoc_onAction(control As IRibbonControl)
    Dim msg As String
    
    Select Case CreateNewDocument(control, msg)
    Case ENewDocumentCreationError.FileMissing:
        'This template file no longer exists since the last rebuild of the menu
        modError.DisplayMsg "This template no longer exists." & vbCrLf & _
                                "It will be removed from the menu.", vbExclamation, _
                                "Missing template"
        modRibbonMenu.MenuXmlTextFileDelete 1 'Delete the saved xml file
        InvalidateRibbon modRibbonMenu.NEW_DOC_MENU_ID
    Case ENewDocumentCreationError.INIMissing:
        modError.DisplayMsg msg & " in system setup." & vbCrLf & vbCrLf & "New document cannot be created.", _
                        vbCritical, , True
    End Select
End Sub

'++********************************************************************
' Description:  Handles button callback from Starter document dynamic menu
'               with the exception of refresh button. Will create new
'               document based of selected template.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub DynBtnStarterDoc_onAction(control As IRibbonControl)
    Dim msg As String
    
    Select Case CreateNewDocument(control, msg)
    Case ENewDocumentCreationError.FileMissing:
        'This template file no longer exists since the last rebuild of the menu
        modError.DisplayMsg "This starter document no longer exists." & vbCrLf & _
                                "It will be removed from the menu.", vbExclamation, _
                                "Missing starter document"
        modRibbonMenu.MenuXmlTextFileDelete 1 'Delete the saved xml file
        InvalidateRibbon modRibbonMenu.NEW_DOC_MENU_ID
    Case ENewDocumentCreationError.INIMissing:
        modError.DisplayMsg msg & " in system setup." & vbCrLf & vbCrLf & "New document cannot be created.", _
                        vbCritical, , True
    End Select
End Sub

'++********************************************************************
' Description:  Handles button callback from Proposal document dynamic menu
'               with the exception of refresh button. Will insert contents
'               from file
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub DynBtnReportFileInsert_onAction(control As IRibbonControl)

    Dim oUndoRecord As cUndoRecord
    Dim rRange As Range

    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "Insert File"
    
    'Need to check that in a valid place in the document
    If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("SelectionOkForFileInsert", False) Then

        If modPrivate.FileExists(control.Tag) Then
            'Add a bookmark to show where the text begins
            Selection.Bookmarks.Add "InsertStart"
            ActiveDocument.Bookmarks("InsertStart").Range.Collapse (wdCollapseStart)
            
            'Insert the file
            Selection.InsertFile control.Tag
            
            Selection.Start = ActiveDocument.Bookmarks("InsertStart").Start
            ActiveDocument.Bookmarks("InsertStart").Delete
            Set rRange = Selection.Range
            rRange.Collapse wdCollapseStart
            ActiveDocument.ActiveWindow.ScrollIntoView rRange

        Else
            MsgBox "The file, " & control.Tag & ",cannot be found!", vbInformation, "Insert content file"
        End If
        
    End If

    oUndoRecord.EndRecording

End Sub

'++********************************************************************
' Description:  Handles button callback from Shortlist document dynamic menu
'               with the exception of refresh button. Will insert contents
'               from file
' Parameters:   control - Ribbon control
' Returns:      N/A
''--********************************************************************
'Sub DynBtnShortlistFileInsert_onAction(control As IRibbonControl)
'
'    Dim oUndoRecord As cUndoRecord
'    Dim rRange As Range
'
'    Set oUndoRecord = New cUndoRecord
'    oUndoRecord.SetName "Insert File"
'
'    'Need to check that in a valid place in the document
'    If modGlobalPublic.IsOperationOkToDo("Inserting a File ", NotInAny) Then
'
'        If modPrivate.FileExists(control.Tag) Then
'            'Add a bookmark to show where the text begins
'            Selection.Bookmarks.Add "InsertStart"
'            ActiveDocument.Bookmarks("InsertStart").Range.Collapse (wdCollapseStart)
'
'            'Insert the file
'            Selection.InsertFile control.Tag
'
'            Selection.Start = ActiveDocument.Bookmarks("InsertStart").Start
'            ActiveDocument.Bookmarks("InsertStart").Delete
'            Set rRange = Selection.Range
'            rRange.Collapse wdCollapseStart
'            ActiveDocument.ActiveWindow.ScrollIntoView rRange
'        Else
'            MsgBox "The file, " & control.Tag & ",cannot be found!", vbInformation, "Insert content file"
'        End If
'
'    End If
'
'    oUndoRecord.EndRecording
'
'End Sub
'
''++********************************************************************
'' Description:  Handles button callback from Letter document dynamic menu
''               with the exception of refresh button. Will insert contents
''               from file
'' Parameters:   control - Ribbon control
'' Returns:      N/A
''--********************************************************************
'Sub DynBtnLetterFileInsert_onAction(control As IRibbonControl)
'
'    Dim oUndoRecord As cUndoRecord
'    Dim rRange As Range
'
'    Set oUndoRecord = New cUndoRecord
'    oUndoRecord.SetName "Insert File"
'
'    'Need to check that in a valid place in the document
'    If modGlobalPublic.IsOperationOkToDo("Inserting a File ", NotInAny) Then
'
'        If modPrivate.FileExists(control.Tag) Then
'            'Add a bookmark to show where the text begins
'            Selection.Bookmarks.Add "InsertStart"
'            ActiveDocument.Bookmarks("InsertStart").Range.Collapse (wdCollapseStart)
'
'            'Insert the file
'            Selection.InsertFile control.Tag
'
'            Selection.Start = ActiveDocument.Bookmarks("InsertStart").Start
'            ActiveDocument.Bookmarks("InsertStart").Delete
'            Set rRange = Selection.Range
'            rRange.Collapse wdCollapseStart
'            ActiveDocument.ActiveWindow.ScrollIntoView rRange
'        Else
'            MsgBox "The file, " & control.Tag & ",cannot be found!", vbInformation, "Insert content file"
'        End If
'
'    End If
'
'    oUndoRecord.EndRecording
'
'End Sub


'++********************************************************************
' Description:  Button callback for reset to default button.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub BtnResetToDefaultStyles_onAction(control As IRibbonControl)
    If Not modPrivate.DocCountZeroOrDocInProtectedView Then
        modPrivate.ResetToDefaultStyles
    Else
        modError.DisplayMsg "There are no documents open!", vbExclamation
    End If
End Sub

'++********************************************************************
' Description:  Button callback for "Attach template" button.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub BtnAttachTemplate_onAction(control As IRibbonControl)
    If Not modPrivate.DocCountZeroOrDocInProtectedView Then
        'Need to see if the current document is not a template
        If ActiveDocument.Type = wdTypeDocument Then
            frmAttachTmp.Show
        Else
            modError.DisplayMsg "This document is a template and therefore does not have a template!", , _
              "Attach new template"
        End If
    Else
        modError.DisplayMsg "There are no documents open!", vbExclamation
    End If
End Sub

'++********************************************************************
' Description:  Button callback for "Delete double paragraph" button.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub BtnRescueDelDblPara_onAction(control As IRibbonControl)
    If Not modPrivate.DocCountZeroOrDocInProtectedView Then
        modPrivate.RemoveDoubleParagraphs
    Else
        modError.DisplayMsg "There are no documents open!", vbExclamation
    End If
End Sub

'++********************************************************************
' Description:  Button callback for "Delete double space" button.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub BtnRescueDelDblSpace_onAction(control As IRibbonControl)
    If Not modPrivate.DocCountZeroOrDocInProtectedView Then
        modPrivate.RemoveDoubleSpaces
    Else
        modError.DisplayMsg "There are no documents open!", vbExclamation
    End If
End Sub

'++********************************************************************
' Description:  Button callback for "Refresh ribbon" button.
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub BtnRescueRibbonRefresh_onAction(control As IRibbonControl)
    InvalidateRibbon
    modError.DisplayMsg "Ribbon refreshed.", , "Ribbon refreshed"
End Sub

'++********************************************************************
' Description:  Callback for "utilities" menu launcher button. Will
'               hide/show buttons in utilities menu
' Parameters:   control - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub GrpBrochetUtilitiesLauncher_onAction(control As IRibbonControl)
    'Remember the setting in registry as this should be persistent across sessions
    If modRegistry.RegistrySettingGetString("Defaults", "UtilitiesGroupSize") = "Large" Then
        modRegistry.RegistrySettingSave "Defaults", "UtilitiesGroupSize", "Small"
    Else
        modRegistry.RegistrySettingSave "Defaults", "UtilitiesGroupSize", "Large"
    End If

    modRibbon.InvalidateRibbon "GrpBrochetUtilities", _
                                 "GrpBrochetUtilitiesSep1", _
                                 "BtnResetToDefaultStyles", _
                                 "BtnAttachTemplate", _
                                 "BtnRescueRibbonRefresh", _
                                 "BtnRescueDelDblPara", _
                                 "BtnRescueDelDblSpace"
End Sub

'++*******************************************************************
' Description:  Callback to display the "about" screen
' Parameters:   control - the menu item ribbon control name
' Returns:      none
'--********************************************************************
Sub BtnAbout_onAction(control As IRibbonControl)
    frmDocInfo.Show
End Sub
'
''*******************************************************************************************************
''* Description: Creates or reformats a table
''* Parameters:  N/A
''* Returns:     N/A
''*******************************************************************************************************
'Sub BtnBrochetTables_onAction(control As IRibbonControl)
'    Dim sText As String
'    Dim oUndoRecord As cUndoRecord
'    Dim oFrm As New frmNewTable
'
'    modScreenUpdating.ScreenUpdating_Disable
'
'    Set oUndoRecord = New cUndoRecord
'
'    Select Case control.ID
'
'        'Insert a new table
'        Case "BtnBrochetInsertTable"
'
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("SelectionOkForTableInsert", False) Then
'                oUndoRecord.SetName "New Table"
'                oFrm.SetNewTable True
'                oFrm.SetWidthOnly False
'                oFrm.Show
'
'            End If
'
'        'Reformat the Whole Table
'        Case "BtnBrochetTableQuickReformat"
'
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformat", False) Then
'                oUndoRecord.SetName "Reformating table"
'                'TablePrepareReformat "QuickReformat"
'                If modTables.IsTableUnified(Selection.Tables(1)) Then
'                    oUndoRecord.SetName "Quick reformat Table"
'                    oFrm.SetNewTable False
'                    oFrm.SetWidthOnly False
'                    oFrm.Show
'                Else
'                    MsgBox "A table cannot be reformatted if it contains merged cells.", vbInformation, "Reformat Table"
'                End If
'            End If
'
'
'        Case "BtnBrochetTableResetWidth"
'
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reset table width"
'                oFrm.SetNewTable False
'                oFrm.SetWidthOnly True
'                oFrm.Show
'            End If
'
'        '+ve/-ve numbers
'        Case "BtnBrochetLegalTablesPosNeg"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "+ve/-ve Number Cells"
'                modTables.zPosNegCells
'            End If
'
'        Case Else
'
'            If Left(control.Tag, 1) = "T" Or Left(control.Tag, 1) = "|" Then
'                If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                    oUndoRecord.SetName "Reformat as Heading"
'                    modTables.TableSelectionReformat control.Tag
'
'                End If
'            Else
'                MsgBox "Callback to 'rxGrpTSUTables_onAction' with id '" & control.ID & "' not recognised.", vbInformation
'            End If
'
'    End Select
'
'    oUndoRecord.EndRecording
'
'    modScreenUpdating.ScreenUpdating_Enable
'End Sub
'
''Callback for rxbtnCellColourGreen onAction
'Sub BtnBrochetTablesSA_onAction(control As IRibbonControl)
'
'
'    On Error GoTo ErrorHandler
'
'    Dim oUndoRecord As cUndoRecord
'
'
'    If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
'
'        Set oUndoRecord = New cUndoRecord
'        oUndoRecord.SetName "Apply SA"
'        System.Cursor = wdCursorWait
'        modScreenUpdating.ScreenUpdating_Disable
'
'
'        Select Case control.Tag
'        Case "TableCellDarkGreen"
'                ShadeCells Selection.Cells, "++", RGB(2, 83, 0), wdWhite
'
'        Case "TableCellGreen"
'                ShadeCells Selection.Cells, "++/-", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent1).RGB, wdWhite
'
'        Case "TableCellBlue"
'                ShadeCells Selection.Cells, "+", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent6).RGB, wdWhite
'
'        Case "TableCellPurple"
'                ShadeCells Selection.Cells, "+/-", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent5).RGB, wdWhite
'
'        Case "TableCellWhite"
'                ShadeCells Selection.Cells, "0", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeLight1).RGB, wdBlack
'
'        Case "TableCellGrey"
'                ShadeCells Selection.Cells, "?", RGB(135, 135, 135), wdWhite
'
'        Case "TableCellYellow"
'                ShadeCells Selection.Cells, "-", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent2).RGB, wdWhite
'
'
'        Case "TableCellOrange"
'                ShadeCells Selection.Cells, "--/+", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent3).RGB, wdWhite
'
'        Case "TableCellBurgundy"
'                ShadeCells Selection.Cells, "--", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent4).RGB, wdWhite
'
'        Case "TableCellBlack"
'                ShadeCells Selection.Cells, "N/A", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeDark1).RGB, wdWhite
'
'        End Select
'
'        System.Cursor = wdCursorNormal
'        oUndoRecord.EndRecording
'        modScreenUpdating.ScreenUpdating_Enable
'    End If
'
'CleanExit:
'
'    Exit Sub
'ErrorHandler:
'    'Error applying style. Do nothing
'    Resume CleanExit
'
'End Sub
'
''Callback for rxbtnCellColourGreen onAction
'Sub BtnBrochetTablesShading_onAction(control As IRibbonControl)
'
'
'    On Error GoTo ErrorHandler
'
'    Dim oUndoRecord As cUndoRecord
'
'
'    If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
'
'        Set oUndoRecord = New cUndoRecord
'        oUndoRecord.SetName "Apply SA"
'        System.Cursor = wdCursorWait
'        modScreenUpdating.ScreenUpdating_Disable
'
'
'        Select Case control.Tag
'        Case "TableCellDarkGreen"
'                OnlyShadeCells Selection.Cells, RGB(2, 83, 0), wdWhite
'
'        Case "TableCellGreen"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent1).RGB, wdWhite
'
'        Case "TableCellBlue"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent6).RGB, wdWhite
'
'        Case "TableCellPurple"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent5).RGB, wdWhite
'
'        Case "TableCellWhite"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeLight1).RGB, wdBlack
'
'        Case "TableCellgrey"
'                OnlyShadeCells Selection.Cells, RGB(135, 135, 135), wdWhite
'
'        Case "TableCellYellow"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent2).RGB, wdWhite
'
'        Case "TableCellOrange"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent3).RGB, wdWhite
'
'        Case "TableCellBurgundy"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent4).RGB, wdWhite
'
'
'        Case "TableCellBlack"
'                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeDark1).RGB, wdWhite
'
'        End Select
'
'        System.Cursor = wdCursorNormal
'        oUndoRecord.EndRecording
'        modScreenUpdating.ScreenUpdating_Enable
'    End If
'
'CleanExit:
'
'    Exit Sub
'ErrorHandler:
'    'Error applying style. Do nothing
'    Resume CleanExit
'
'End Sub
'
'Sub ShadeCells(cCells As Cells, sText As String, lShade As Long, ciTextColour As WdColorIndex)
'
'Dim cCell As Cell
'Dim progress As frmProgress
'
'        cCells.VerticalAlignment = wdCellAlignVerticalCenter
'        cCells.Shading.BackgroundPatternColor = lShade
'
'        If cCells.count > 10 Then
'            Set progress = New frmProgress
'            progress.Init "Updating Cells", "Cell", cCells.count, 1
'            progress.Show
'        End If
'
'
'        For Each cCell In cCells
'            If sText <> "" Then
'                cCell.Range.text = sText
'            End If
'            cCell.Range.Font.ColorIndex = ciTextColour
'            cCell.Range.Paragraphs(1).Alignment = wdAlignParagraphCenter
'            If cCells.count > 10 Then
'                progress.Step
'            End If
'        Next
'
'        progress.CloseMe
'
'End Sub
''
''Sub OnlyShadeCells(cCells As Cells, lShade As Long, ciTextColour As WdColorIndex)
''
''Dim cCell As Cell
''Dim progress As frmProgress
''
''        cCells.VerticalAlignment = wdCellAlignVerticalCenter
''        cCells.Shading.BackgroundPatternColor = lShade
''
''        If cCells.count > 10 Then
''            Set progress = New frmProgress
''            progress.Init "Updating Cells", "Cell", cCells.count, 1
''            progress.Show
''        End If
''
''
''        For Each cCell In cCells
''
''            cCell.Range.Font.ColorIndex = ciTextColour
''            If cCells.count > 10 Then
''                progress.Step
''            End If
''        Next
''
''        progress.CloseMe
''
''End Sub
'''
'''
''''++********************************************************************
'''' Description:  Handles all style button presses on ribbon of this template
'''' Parameters:   control - Ribbon button that was pressed
'''' Returns:      N/A
''''--********************************************************************
'''Private Sub BtnBrochetTablesStyle_onAction(control As IRibbonControl)
'''    On Error GoTo ErrorHandler
'''
'''    Dim oUndoRecord As cUndoRecord
'''
'''    Set oUndoRecord = New cUndoRecord
'''    oUndoRecord.SetName "Changing Style to: " & control.Tag
'''
'''
'''        If IsNumeric(control.Tag) Then
'''            Selection.Style = CInt(control.Tag)
'''        Else
'''            Selection.Style = control.Tag
'''        End If
'''
'''
'''
'''CleanExit:
'''    oUndoRecord.EndRecording
'''    Exit Sub
'''ErrorHandler:
'''    'Error applying style. Do nothing
'''    Resume CleanExit
'''End Sub
'''
'''
'''Sub BtnTableVertAlign_onAction(control As IRibbonControl)
'''
'''
'''    Select Case control.ID
'''    Case "MenuSepTableVertAlignTop"
'''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
'''                Selection.Cells.VerticalAlignment = wdCellAlignVerticalTop
'''
'''            End If
'''    Case "MenuSepTableVertAlignMiddle"
'''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
'''                Selection.Cells.VerticalAlignment = wdCellAlignVerticalCenter
'''            End If
'''
'''    Case "MenuSepTableVertAlignBottom"
'''
'''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
'''                Selection.Cells.VerticalAlignment = wdCellAlignVerticalBottom
'''            End If
'''    End Select
'''
'''
'''End Sub
''''
'''''*******************************************************************************************************
'''''* Description: Applies the Table Style
'''''* Parameters:  N/A
'''''* Returns:     N/A
'''''*******************************************************************************************************
''''Sub BtnBrochetTablesSelectionFormatting_onAction(control As IRibbonControl)
''''    Dim sText As String
''''    Dim oUndoRecord As cUndoRecord
''''    Dim oFrm As New frmNewTable
''''
''''    modScreenUpdating.ScreenUpdating_Disable
''''
''''    Set oUndoRecord = New cUndoRecord
''''
''''    Select Case control.ID
''''
'''''' Buttons
'''''Horizontal Line
''''        Case "rxbtnHorizOn"
''''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
''''                If Selection.Rows.count > 1 Then
''''                    oUndoRecord.SetName "Horizontal Line"
''''                    Selection.Borders(wdBorderHorizontal).lineStyle = wdLineStyleSingle
''''                    Selection.Borders(wdBorderHorizontal).color = cOrange
''''                Else
''''                    MsgBox "Please select at least 2 cells vertically", vbExclamation, "Table Format"
''''                End If
''''
''''            End If
''''
''''        Case "rxbtnHorizOff"
''''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
''''                If Selection.Rows.count > 1 Then
''''                    oUndoRecord.SetName "Clear Horizontal line"
''''                    Selection.Borders(wdBorderHorizontal).lineStyle = wdLineStyleNone
''''                Else
''''                    MsgBox "Please select at least 2 cells vertically", vbExclamation, "Table Format"
''''                End If
''''
''''            End If
''''
''''        Case "rxbtnShadeCell"
''''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
''''                oUndoRecord.SetName "Cell Shading"
''''                Selection.Shading.Texture = wdTextureNone
''''                Selection.Shading.ForegroundPatternColor = wdColorAutomatic
''''                Selection.Shading.BackgroundPatternColor = cOrangeLight 'rgb(255,196,116)
''''
''''            End If
''''
''''        Case "rxbtnClearCell"
''''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
''''                oUndoRecord.SetName "Clear Cell Shading"
''''                Selection.Shading.Texture = wdTextureNone
''''                Selection.Shading.ForegroundPatternColor = wdColorAutomatic
''''                Selection.Shading.BackgroundPatternColor = wdColorWhite
''''
''''            End If
''''
''''        Case "BtnBrochetTableResetWidth"
''''
''''            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
''''                oUndoRecord.SetName "Reset table width"
''''                oFrm.SetNewTable False
''''                oFrm.SetWidthOnly True
''''                oFrm.Show
''''            End If
''''
''''        Case Else
''''            MsgBox "Callback to 'rxGrpTSUTables_onAction' with id '" & control.ID & "' not recognised.", vbInformation
''''
''''    End Select
''''
''''    oUndoRecord.EndRecording
''''
''''    modScreenUpdating.ScreenUpdating_Enable
''''End Sub


'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'                                 STILL TO CHECK
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
Private Function CreateNewDocument(control As IRibbonControl, ByRef msg As String) As ENewDocumentCreationError
    Dim Doc As Document
    Dim sTmpl As String
    Dim iViewType
    Dim sTempFilename As String
    
    Dim sText As String
    Dim vTxt As Variant
    Dim sGlobalDir As String
    Dim i As Integer
    Dim iCnt As Integer
    
    'Check Global has not been corrupted
    If Not modGlobal.gbGlobalIsOk Then
        Exit Function
    End If
        
    'I know it's in the menu so it did exist but does it still?
    If Not modPrivate.FileExists(control.Tag) Then
        CreateNewDocument = FileMissing
        Exit Function
    End If
    
    'Check if there are any essential ini files for this template to work
    sText = modPrivate.FilePropertyGet(control.Tag, 18) '18=Tags
    modPrivate.IniFilesCriticalCheck sText, i, msg
    If msg = vbNullString Then
        'No files missing - continue
        On Error Resume Next
        Set Doc = Documents.Add(control.Tag)
        If err = 5180 Then
            modError.GlobalErrorHandler err.Code, err.Description, MODULE_NAME, "CreateNewDocument", _
                    "This document type cannot be used until this error is resolved.", True
        End If
        On Error GoTo 0
        
        'Now blank the 'Tags' property of the file
        If Not Doc Is Nothing Then
            'Was the doc actually opened? The dialog may have been cancelled
            ActiveDocument.BuiltInDocumentProperties(wdPropertyKeywords) = vbNullString
        End If
        
    Else
        CreateNewDocument = INIMissing
    End If
End Function
Attribute VB_Name = "modRibbonMenu"
'************************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modRibbonMenu
'*
'* Holds procedures for building menu xml for new docs, starter docs and insert menus
'*  -04/06/2018 Changed error message if starter folder is not available.
'************************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modRibbonMenu"
' This is the control id of the dynamic menu control in the ribbon for new documents.
' It is needed to invalidate the control after a 'Refresh list'
Public Const NEW_DOC_MENU_ID As String = "DmBrochetNewDoc"
Public Const STARTER_DOC_MENU_ID As String = "DmBrochetStarterDoc"
Public Const INSERT_FILE_MENU_ID As String = "DmBrochetInsertDoc"
Public Const REPORT_FILE_MENU_ID As String = "DmBrochetReportFileInsert"
Public Const SHORTLIST_FILE_MENU_ID As String = "DmBrochetShortlistFileInsert"
Public Const LETTER_FILE_MENU_ID As String = "DmBrochetLetterFileInsert"

' The section name that holds settings for new doc menu
Public Const NEW_DOC_INI_SECTION As String = "NewDocumentMenu"
Public Const STARTER_DOC_INI_SECTION As String = "StarterDocumentMenu"
Public Const REPORT_INI_SECTION As String = "FileInsert"
Public Const SHORTLIST_INI_SECTION As String = "ShortlistTemplate"
Public Const LETTER_INI_SECTION As String = "LetterTemplate"


' If there's something special to be done when the user clicks the 'Refresh list' button
' in a menu, then set the name of your own callback routine here. If there's nothing
' out of the ordinary to be done, leave blank
Const REFRESH_LIST_CALLBACK As String = vbNullString
' Should be set to the unique name for callbacks and IDs. E.g. The
' callback when a new document item is selected will be built as 'rxBtn' followed by this value and
' Dyna_onAction'. If you entered 'BrochetLegal' here, this button would have an OnAction value of
' rxBtnBrochetLegalDyna_onAction'

Private Const DYNAMIC_MENU_CALLBACK_FUNCTION_PREFIX As String = "DynBtn"

Public Enum EMenuType
    NewDocs
    StarterDocs
    InsertDocs
    ReportFileInsert
    ShortlistFileInsert
    LetterFileInsert
End Enum

'This enumerator is used by the proc that takes ampersands in xml and converts them to the xml coding _
 for an ampersand (&amp;). Not that simple! Some elements need that single ampersand to be converted _
 into a double one as a single one is interpreted and a hotkey prefix. This enumerator tells the proc _
 how many ampersands to create by xml element type
Private Enum xmlElementType
    xLabel = 2
    xScreentip = 2
    xSupertip = 1
    xTag = 1
    xTitle = 2
End Enum

'All the errors that can occur during file/doc/template menu creation
Private Enum EMenuBuildError
    none
    NewDocIniSettingInvalid
    StarterDocIniSettingInvalid
    INIMissing
    ProposalINISettingInvalid
    ShortlistINISettingInvalid
    LetterINISettingInvalid
End Enum

' Array to hold the insert menu names
' Element 0 is the full name of the active doc
' Element 1-3 (if they exist) are the menu, ini file names
Private sInsertMenuNameStore() As String
Private sRefreshListCallBack As String
Private lBtnCount As Long
Private lMenuCount As Long
Private bRemovePrefixNosDirs As Boolean
Private bRemovePrefixNosTmpls As Boolean

'++********************************************************************
' Description:  Main meny build call for the List in New Document menu
' Parameters:   MenuType - Type of the menu. Different menu types are
'                   loaded from different ini sections
'               iInsertMenuNo - If not zero, the insert menu to load.
' Returns:      xml of the menu
'--********************************************************************
Function NewMenuGenerate(menuType As EMenuType, Optional iInsertMenuNo As Integer = 0) As String
    Dim sXmlString As String
    Dim sIniSection As String
    Dim ctCursorWas As WdCursorType
    
    sIniSection = GetDynamicMenuIniSectionName(menuType, iInsertMenuNo)
    
    'Return the saved xml
    sXmlString = MenuXmlTextRead(sIniSection)
    
    If sXmlString = vbNullString Then
        'Previous xml doesn't exist so build a new set
        ctCursorWas = System.Cursor
        System.Cursor = wdCursorWait
        'Build the xml
        sXmlString = MenuBuild(menuType, sIniSection, iInsertMenuNo)
        'Save the xml
        MenuXmlTextWrite sIniSection, sXmlString
        System.Cursor = ctCursorWas
    End If
    
    NewMenuGenerate = sXmlString
End Function

'++********************************************************************
' Description:  Returns the name of section of ini file that should have
'               settings for the given menu type. Section names for
'               New Doc and Starter Doc menu are held in constants
'               on top of this module.
'               Section name for insert menu depends on number of that
'               insert menu
' Parameters:   MenuType - Type of the menu. Different menu types are
'                   loaded from different ini sections
'               iInsertMenuNo - If not zero, the insert menu to load.
' Returns:      INI Section name that should have settings for given section type
'--********************************************************************
Private Function GetDynamicMenuIniSectionName(menuType As EMenuType, Optional insertMenuNo As Integer = 0) As String
    Select Case menuType
    
    Case EMenuType.NewDocs:
        GetDynamicMenuIniSectionName = NEW_DOC_INI_SECTION
    Case EMenuType.StarterDocs:
        GetDynamicMenuIniSectionName = STARTER_DOC_INI_SECTION
    Case EMenuType.ReportFileInsert:
        GetDynamicMenuIniSectionName = REPORT_INI_SECTION
    Case EMenuType.ShortlistFileInsert:
        GetDynamicMenuIniSectionName = SHORTLIST_INI_SECTION
    Case EMenuType.LetterFileInsert:
        GetDynamicMenuIniSectionName = LETTER_INI_SECTION
    Case EMenuType.InsertDocs:
        GetDynamicMenuIniSectionName = "InsertFileMenu" 'GetInsertDocIniSectionName(insertMenuNo)
    End Select
End Function

'++********************************************************************
' Description:  Builds the Ini file Section name for the Insert menus.
' Parameters:   iMenuNo - The Insert menu number (1 to 3)
' Returns:      The relevant Section name for the active document.
'--********************************************************************
Function GetInsertDocIniSectionName(iMenuNo As Integer) As String
    Dim sText As String
    Dim sMenus() As String
    
    sMenus = Split(modGlobalPublic.GlobalDirectivesGet("InsertMenuTypes", EDirectiveReturnType.ReturnString), "|")
    If iMenuNo - 1 > UBound(sMenus, 1) Then
        modError.DisplayMsg "The 'InsertMenuTypes' Global Directive has been modified for this template." & vbCrLf & vbCrLf & _
                "Please save your changes and re-start Word", vbCritical
        GetInsertDocIniSectionName = vbNullString
    Else
        GetInsertDocIniSectionName = "InsertMenu" & "-" & sMenus(iMenuNo - 1)
    End If
End Function

'++********************************************************************
' Description:  Reads all the text in a previously created, xml, menu
'               text file. The purpose of this is to avoid pauses when
'               loading menus.
' Parameters:   sIniFileSection - Ini file section name.
' Returns:      The xml if the file exists or vbNullString if not.
'--********************************************************************
Private Function MenuXmlTextRead(sIniFileSection As String) As String
    Dim oFso As FileSystemObject
    Dim oTxtStr As TextStream
    Dim sFile As String
    
    On Error GoTo ErrorHandler
        
    sFile = modPrivate.ExpandString("%TEMP%" & "\" & sIniFileSection & " BlMenu.xml")
    
    If modPrivate.FileExists(sFile) Then
        'If the file exists, get return its contents
        Set oFso = New FileSystemObject
        Set oTxtStr = oFso.GetFile(sFile).OpenAsTextStream
        
        MenuXmlTextRead = oTxtStr.ReadAll
        
        oTxtStr.Close
        
        Set oTxtStr = Nothing
        Set oFso = Nothing
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    MenuXmlTextRead = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  If the location of the templates has not, for whatever
'               reason, been set in the ini, this routine can be used
'               to return the most reasonable next option.
' Parameters:   N/A
' Returns:      Template directory.
'--********************************************************************
Private Function FindTemplateDirectory() As String
    'Use a static so it rememebers if this has already been run for this Word session
    Static sTemplateDirectory As String
    
    'If not already been set
    If sTemplateDirectory = vbNullString Then
        System.Cursor = wdCursorWait
        'First look for the Workgroup location
        sTemplateDirectory = Application.Options.DefaultFilePath(wdUserTemplatesPath)
        
        'If the Workgroup returns a location check that the WorkGroup location is a valid location
        If Not modPrivate.FolderExists(sTemplateDirectory) Then
            sTemplateDirectory = Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath)
            
            If Not modPrivate.FolderExists(sTemplateDirectory) Then
                sTemplateDirectory = vbNullString
            End If
        End If
        System.Cursor = wdCursorNormal
    End If
    
    FindTemplateDirectory = sTemplateDirectory
End Function


'++********************************************************************
' Description:  Creates a menu, xml text file or deletes it.
' Parameters:   sIniFileSection - Ini file section name.
'               sXml - The xml to save to the file.
'               bDeleteFile - If true will delete the file.
' Returns:      N/A
'--********************************************************************
Private Sub MenuXmlTextWrite(sIniFileSection As String, sXml As String, Optional bDeleteFile As Boolean = False)
    Dim oFso As FileSystemObject
    Dim oTxtStr As TextStream
    
    Dim sFile As String
    
    sFile = Environ("temp") & "\" & sIniFileSection & " BlMenu.xml"
    
    If bDeleteFile Then
        'If a deletion was requested
        On Error Resume Next
        Kill sFile
        On Error GoTo 0
    Else
        'Create a new file
        Set oFso = New FileSystemObject
        Set oTxtStr = oFso.CreateTextFile(sFile, True)
        
        oTxtStr.Write sXml
        
        oTxtStr.Close
        
        Set oTxtStr = Nothing
        Set oFso = Nothing
    End If
End Sub

'++********************************************************************
' Description:  Gets the title of the menu either from ini file,
'               or default value based on menu type if not defined
' Parameters:   iniExists - Specifies if ini file exists. If it does,
'                   Function will try to read the title from it.
'               sIniFileSection - Name of the section in ini file that
'                   should contain the setting for menu title
'               menuType - Type of the menu (new doc, starter doc, insert file)
' Returns:      xml of the menu
'--********************************************************************
Private Function getMenuTitle(iniExists As Boolean, iniFileSection As String, menuType As EMenuType, insertMenuNo As Integer) As String
    Dim menuTitle As String
    
    If iniExists Then
        menuTitle = System.PrivateProfileString(gsIniFilePathAndName, iniFileSection, "MenuName")
    End If
    
    If menuTitle = vbNullString Then
        Select Case menuType
        Case EMenuType.NewDocs:
            menuTitle = "New Document"
        Case EMenuType.StarterDocs:
            menuTitle = "Starter document"
        Case EMenuType.ReportFileInsert:
            menuTitle = "Insert File"
        Case EMenuType.ShortlistFileInsert:
            menuTitle = "Insert File"
        Case EMenuType.LetterFileInsert:
            menuTitle = "Insert File"
        Case EMenuType.InsertDocs:
            menuTitle = "InsertMenu " & insertMenuNo
        End Select
    End If
    
    getMenuTitle = menuTitle
End Function



'++********************************************************************
' Description:  Returns the right coding for an xml element that
'               contains ampersands.
' Parameters:   sXml - Incoming xml.
'               xType - Is either 1 or 2 depending on whether the xnl
'               element requires a single or double '&amp;' coding.
' Returns:      Coded xml
'--********************************************************************
Private Function EncodeAmpersand(sXml As String, xType As xmlElementType) As String
    EncodeAmpersand = Replace(sXml, "&", Choose(xType, "&amp;", "&amp;&amp;"))
End Function


'++*******************************************************************
' Description:  Returns the value of a key for the current attached
'               template. For use with values being evaluated with
'               regard to the 3 insert menus.
' Parameters:   iMenu - Menu number
'               sKey - Key name
' Returns:      Value from ini file for this attached template.
'--********************************************************************
'Private Function IniFileSettingInsertMenu(iMenu As Integer, sKey As String) As String
'    Dim sText As String
'    Dim sAttachedTemplateType As String
'
'    If UBound(sInsertMenuNameStore, 1) >= iMenu Then
'        sText = modINI.IniFileKeyGet("InsertMenu-" & sInsertMenuNameStore(iMenu), sKey)
'        sText = Replace(sText, "<P>", vbCrLf) '"&#13;"
'        IniFileSettingInsertMenu = sText
'    End If
'End Function

'++********************************************************************
' Description:  Builds the xml for a standard menu based on finding
'               documents in a given directory and its sub directories.
' Parameters:   sMenuTitle - Name of the menu being loaded.
'               sIniFileSection - Ini file section from which to get
'               details.
'               iInsertMenuNo - If not zero, the insert menu to load.
' Returns:      xml of the menu
'--********************************************************************
Private Function MenuBuild(menuType As EMenuType, sIniFileSection As String, _
            Optional iInsertMenuNo As Integer = 0) As String
    Dim sMenuTitle As String
    Dim iniExists As Boolean
    Dim menuBuildError As EMenuBuildError
    Dim sXml As String
    Dim sText As String
    Dim prefixes() As String
    Dim includes() As String
    Dim qualifiedIniFileSection As String
    Dim subNameExcludes() As String
    Dim bEmptySubHide As Boolean
    Dim sDocsPath As String
    
    'Statics to ensure warning message output only once
    Static bWarnMsgNoIniFile As Boolean
    Static bWarnMsgInsertMenu(1 To 3) As Boolean
    Dim bList As Boolean

'    Dim bSubExclude As Boolean
'    Dim sOrderFileText As String

    iniExists = modPrivate.FileExists(gsIniFilePathAndName)
    '*************
    '* Root path *
    '*************
    If iniExists = False Then
        menuBuildError = INIMissing
        If Not bWarnMsgNoIniFile Then
            modError.DisplayMsg GetMenuBuildErrorText(menuBuildError, menuType), vbCritical, , True
            bWarnMsgNoIniFile = True
        End If
    ElseIf menuType = EMenuType.NewDocs Or menuType = EMenuType.StarterDocs _
                            Or menuType = EMenuType.ReportFileInsert _
                            Or menuType = EMenuType.ShortlistFileInsert _
                            Or menuType = EMenuType.LetterFileInsert Then
        menuBuildError = GetTemplatesOrStarterDocsPath(sIniFileSection, menuType, sDocsPath)
    Else
        '****************
        '* Insert menus *
        '****************
        If Not iniExists Then
            If Not bWarnMsgInsertMenu(iInsertMenuNo) Then
                modError.DisplayMsg "The path for this menu cannot be deciphered because the main ini file is missing.", _
                            vbExclamation, , True
                bWarnMsgInsertMenu(iInsertMenuNo) = True
            End If
        Else
            'QQQ Not sure about this line of code
            'sDocsPath = IniFileSettingInsertMenu(iInsertMenuNo, "Location")
            sDocsPath = modINI.GetPathValue(modINI.GetIniFilePath, sIniFileSection, "Location")
        End If
    End If
    
    sMenuTitle = getMenuTitle(iniExists, sIniFileSection, menuType, iInsertMenuNo)
    
    'Set refresh list callback proc name
    If REFRESH_LIST_CALLBACK = vbNullString Then
        'Use this modules callback routine
        sRefreshListCallBack = "DynBtnBrochetRefreshListCallback"
    Else
        'Use a specifically set proc for the callback
        sRefreshListCallBack = REFRESH_LIST_CALLBACK
    End If
    
    'Open the XML String
    sXml = "<menu xmlns=""http://schemas.microsoft.com/office/2006/01/customui""> " & _
            "<menuSeparator id=""rxmHdr0"" title=""" & EncodeAmpersand(sMenuTitle, xTitle) & """/>"
    
    If menuBuildError <> EMenuBuildError.none Then
        sXml = sXml & GetErrorMenuXML(menuBuildError, menuType, sIniFileSection, iInsertMenuNo)
    Else
    '    'All's OK to proceed
        '***************************************
        '* Set all the parameters from the ini *
        '***************************************
        'Replace all global sets like %workgroup% etc
        sDocsPath = modPrivate.ExpandString(sDocsPath)
        sDocsPath = RemoveTrailingSlash(sDocsPath)
        
        'Check if directory is valid
        If modPrivate.FolderExists(sDocsPath) Then
            If menuType <> EMenuType.InsertDocs Then
                bRemovePrefixNosDirs = StrComp(modINI.IniFileKeyGet(gsIniFilePathAndName, sIniFileSection, "RemoveLeadingNumbersFromDirectoryNames"), "True", vbTextCompare) = 0
                bRemovePrefixNosTmpls = StrComp(modINI.IniFileKeyGet(gsIniFilePathAndName, sIniFileSection, "RemoveLeadingNumbersFromTemplateNames"), "True", vbTextCompare) = 0
            End If
        
            'Build array of prefixes to use to filter list of templates
            If menuType = InsertDocs Then
                qualifiedIniFileSection = sIniFileSection & iInsertMenuNo
            Else
                qualifiedIniFileSection = sIniFileSection
            End If
        
            If modINI.GetSplitStringIntoArray(gsIniFilePathAndName, qualifiedIniFileSection, "Prefixes", prefixes) Then
                'Build array of extensions to use as filters
                If modINI.GetSplitStringIntoArray(gsIniFilePathAndName, qualifiedIniFileSection, "Include", includes, "", "*.", ".") Then
                    'Get the list of Sub Directories to not include in the list
                    modINI.GetSplitStringIntoArray gsIniFilePathAndName, sIniFileSection, "SubDirectoriesExcludeList", subNameExcludes
        
                    bList = ShouldDisplayMenuAsList(sIniFileSection)
                    bEmptySubHide = ShouldHideEmptySubdirs(sIniFileSection)
        
                    'Kick off the main menu builder
                    sXml = MenuBuildXML(sXml, sDocsPath, includes, prefixes, subNameExcludes, sIniFileSection, bList, bEmptySubHide, menuType)
                End If
            End If
        Else
            sXml = CreateMenuForNonExistentDir(menuType, sIniFileSection, iInsertMenuNo)
        End If
    End If
    
    sXml = addRefreshButtonToMenuXML(sXml, menuType, sIniFileSection)
    sXml = FinalizeMenuXml(sXml)
    
    'Feed the XML content back to the Ribbon
    MenuBuild = sXml
End Function

'++********************************************************************
' Description:  Creates a refresh button for any dynamic menu and attaches it to the given xml fragment
' Parameters:   iniFileSection - sXml xml fragment. The button xml code will be attached to the end  of it
'               menutype - Type of the menu being generated
'               iniFileSection - Ini file section holding settings for the menu
' Returns:      xml fragmen with button xml attached
'--********************************************************************
Private Function addRefreshButtonToMenuXML(sXml As String, menuType As EMenuType, iniFileSection As String) As String
    Dim actionCallbackName As String
    Dim sText As String

    Select Case menuType
    Case EMenuType.NewDocs:
        sText = "NewDoc"
    Case EMenuType.StarterDocs:
        sText = "StarterDoc"
    Case EMenuType.InsertDocs:
        sText = "Inserts menu"
    Case EMenuType.ReportFileInsert:
        sText = "ReportFileInsert" 'QQQ
    Case EMenuType.ShortlistFileInsert:
        sText = "ShortlistFileInsert" 'QQQ
    Case EMenuType.LetterFileInsert:
        sText = "LetterFileInsert" 'QQQ
    End Select
    
    addRefreshButtonToMenuXML = sXml & "<button id=""" & GetActionCallbackName & iniFileSection & "Refresh"" label=""Refresh List"" imageMso=""RecurrenceEdit"" " & _
      "tag=""" & sText & """ onAction=""" & sRefreshListCallBack & """/>"
End Function

'++********************************************************************
' Description:  Closes the dynamic menu xml
' Parameters:   iniFileSection - sXml xml fragment. The closing xml code
'                       will be attached to the end  of it
' Returns:      complete dynamic menu xml code
'--********************************************************************
Private Function FinalizeMenuXml(sXml) As String
    FinalizeMenuXml = sXml & " </menu>"
End Function

'++********************************************************************
' Description:  Indicates if the subdirs should be hidden in the menu
'               if there are no items in the subdir
' Parameters:   iniFileSection - Ini section with the settings for the menu
' Returns:      True if empty subdirs should be hidden
'               False otherwise.
'--********************************************************************
Private Function CreateMenuForNonExistentDir(menuType As EMenuType, iniFileSection As String, insertMenuNo As Integer) As String
    Dim sXml As String
    Dim sText As String
    
    If iniFileSection = "Menu not found!" Then
        sXml = "<menu xmlns=""http://schemas.microsoft.com/office/2009/07/customui""> " & _
          "<button id=""rxmHdr0"" label=""Global Directive changed - Re-start Word""/> "
    Else
        sXml = "<menu xmlns=""http://schemas.microsoft.com/office/2009/07/customui""> " & _
          "<button id=""rxmHdr0"" label=""You may be working offline (Directory error in ini file).""/> "
    End If
    If insertMenuNo Then
        sText = insertMenuNo
    Else
        Select Case menuType
        Case EMenuType.NewDocs:
            sText = "NewDoc"
        Case EMenuType.StarterDocs:
            sText = "StarterDoc"
        Case EMenuType.ReportFileInsert:
            sText = "ReportFileInsert" 'QQQ
        Case EMenuType.ShortlistFileInsert:
            sText = "ShortlistFileInsert" 'QQQ
        Case EMenuType.LetterFileInsert:
            sText = "LetterFileInsert" 'QQQ
        End Select
    End If

    CreateMenuForNonExistentDir = sXml
End Function

'++********************************************************************
' Description:  Indicates if the subdirs should be hidden in the menu
'               if there are no items in the subdir
' Parameters:   iniFileSection - Ini section with the settings for the menu
' Returns:      True if empty subdirs should be hidden
'               False otherwise.
'--********************************************************************
Private Function ShouldHideEmptySubdirs(iniFileSection As String) As Boolean
    ShouldHideEmptySubdirs = Not StrComp(System.PrivateProfileString(gsIniFilePathAndName, iniFileSection, "SubDirectoriesEmptyHide"), False, vbTextCompare) = 0
End Function

'++********************************************************************
' Description:  Menu can display items in subfolders as submenus, or all
'               items in one menu list, where subfolders are separated with separator
'               If ini file setting is "List" the latter option will be used
' Parameters:   iniFileSection - Ini section with the settings for the menu
' Returns:      True, if the menu should be displaysed as one list with separators,
'               False otherwise.
'--********************************************************************
Private Function ShouldDisplayMenuAsList(iniFileSection As String) As Boolean
    ShouldDisplayMenuAsList = StrComp(System.PrivateProfileString(gsIniFilePathAndName, iniFileSection, "Style"), "list", vbTextCompare) = 0
End Function

'++********************************************************************
' Description:  Removes trailing slashes (/) from path if exists
' Parameters:   path string to clear
' Returns:      path without trailing / (e.g. c:/documents// -> c:/documents)
'--********************************************************************
Private Function RemoveTrailingSlash(path As String) As String
    RemoveTrailingSlash = path
    Do Until Right$(RemoveTrailingSlash, 1) <> "\"
        RemoveTrailingSlash = Left$(RemoveTrailingSlash, Len(RemoveTrailingSlash) - 1)
    Loop
End Function

'++********************************************************************
' Description:  If there is an unrecoverable error while creating
'               dropdown menu xml, we want to create alternative
'               dropdown xml with the error message in it.
'               This function builds this xml
' Parameters:   Error - One of EMenuBuildError literals
'               menuType - One of EMenuType literals
' Returns:      xml code for menu of which normal creation failed
'--********************************************************************
Private Function GetErrorMenuXML(error As EMenuBuildError, menuType As EMenuType, _
                sIniFileSection As String, iInsertMenuNumber As Integer) As String
    Dim sXml As String
    Dim sText As String
    Dim sIdentity As String
    
    sIdentity = GetActionCallbackName
    
    sXml = sXml & " <button id=""" & sIdentity & sIniFileSection & "ErrMsg"" " & _
      "label=""" & GetMenuBuildErrorText(error, menuType) & """ imageMso=""HighImportance""/> "
    
    If menuType = NewDocs Or menuType = StarterDocs Then
        sText = sIdentity & sIniFileSection & "Refresh"
    Else
        sText = iInsertMenuNumber
    End If
    
    GetErrorMenuXML = sXml
End Function

'++********************************************************************
' Description:  Get path to templates or starter documents from ini file
' Parameters:   sIniFileSection - Ini file section from which to get
'                   details.
'               menuType - either EMenuType.NewDocs or EMenuType.StarterDocs
'                   Specifies if we are looking for templates or starter
'                   doc path
'               Retpath - Will be set to a path if the path is found.
'                   if not, it'll stay the same as before
' Returns:      One of the values of EMenuBuild error.
'               EmenuBuildError.None if everything is alrigh
'               EMenuBuildError.NewDocIniSettingInvalid if template path can't be read
'               EMenuBuildError.StartedDocIniSettingInvalid if Starter doc path can't be read
'--********************************************************************
Private Function GetTemplatesOrStarterDocsPath(sIniFileSection As String, menuType As EMenuType, ByRef retPath As String) As EMenuBuildError
    'Using static variables so the error message is only shown once in one session
    Static bWarnMsgNewDocMenu As Boolean
    Static bWarnMsgStartDocMenu As Boolean
    Static bWarnMsgProposalMenu As Boolean
    Static bWarnMsgShortlistMenu As Boolean
    Static bWarnMsgLetterMenu As Boolean
    Dim fso As FileSystemObject
    
    ' This is either New Docs or Start Docs menu
    ' First check for an ini file setting
    If modINI.TryGetIniFileSetting(gsIniFilePathAndName, sIniFileSection, "Location", retPath, True) Then
        GetTemplatesOrStarterDocsPath = none
    Else
        'No workgroup found anywhere, we're done, there's nowhere else to look
        If menuType = EMenuType.NewDocs Then
            Set fso = New FileSystemObject
            If StrComp(fso.GetParentFolderName(gsIniFilePathAndName), fso.GetParentFolderName(ThisDocument.FullName)) <> 0 Then
                retPath = fso.GetParentFolderName(gsIniFilePathAndName)
            End If
            If retPath = vbNullString Then
                GetTemplatesOrStarterDocsPath = NewDocIniSettingInvalid
                If Not bWarnMsgNewDocMenu Then
                    bWarnMsgNewDocMenu = True
                    modError.DisplayMsg "The path for the New Documents menu could not be deciphered.", vbCritical, , True
                End If
            End If
        ElseIf menuType = EMenuType.ReportFileInsert Then
            If Not bWarnMsgProposalMenu Then
                bWarnMsgProposalMenu = True
                modError.DisplayMsg "The path for the Inset File Menu menu could not be deciphered.", vbExclamation, , True
            End If
            GetTemplatesOrStarterDocsPath = ProposalINISettingInvalid
        ElseIf menuType = EMenuType.ShortlistFileInsert Then
            If Not bWarnMsgShortlistMenu Then
                bWarnMsgShortlistMenu = True
                modError.DisplayMsg "The path for the Inset File Menu menu could not be deciphered.", vbExclamation, , True
            End If
            GetTemplatesOrStarterDocsPath = ShortlistINISettingInvalid
        ElseIf menuType = EMenuType.LetterFileInsert Then
            If Not bWarnMsgLetterMenu Then
                bWarnMsgLetterMenu = True
                modError.DisplayMsg "The path for the Inset File Menu menu could not be deciphered.", vbExclamation, , True
            End If
            GetTemplatesOrStarterDocsPath = LetterINISettingInvalid
        Else 'menuType = EMenuType.StarterDocs
            If Not bWarnMsgStartDocMenu Then
                bWarnMsgStartDocMenu = True
                modError.DisplayMsg "The path for the Starter Documents menu could not be deciphered.", vbExclamation, , True
            End If
            GetTemplatesOrStarterDocsPath = StarterDocIniSettingInvalid
        End If
    End If
End Function

'++********************************************************************
' Description:  There are errors that can occure while creating dropdown
'               menu for new doc, starter doc or insert file menu.
'               If that happens we want to display the error message inside
'               the menu itself.
'               This function will get the error description for given error
' Parameters:   Error - One of EMenuBuildError literals
'               menuType - One of EMenuType literals
' Returns:      String with the error description
'--********************************************************************
Private Function GetMenuBuildErrorText(error As EMenuBuildError, menuType As EMenuType) As String
    Select Case error
    Case EMenuBuildError.none:
        GetMenuBuildErrorText = ""
    Case EMenuBuildError.NewDocIniSettingInvalid:
        GetMenuBuildErrorText = "New document menu settings are invalid"
    Case EMenuBuildError.StarterDocIniSettingInvalid:
        GetMenuBuildErrorText = "Starter document menu settings are invalid"
    Case EMenuBuildError.INIMissing:
        Select Case menuType
        Case EMenuType.NewDocs:
            GetMenuBuildErrorText = "The ini file "
            If gsIniFilePathAndName <> vbNullString Then
                GetMenuBuildErrorText = GetMenuBuildErrorText & "'" & gsIniFilePathAndName & "'"
            Else
                GetMenuBuildErrorText = GetMenuBuildErrorText & modGlobal.COMPANY_INI_FILE_NAME
            End If
            GetMenuBuildErrorText = GetMenuBuildErrorText & ", which is essential for the running of the templates is missing."
        Case EMenuType.StarterDocs:
            GetMenuBuildErrorText = "The ini file "
            If gsIniFilePathAndName <> vbNullString Then
                GetMenuBuildErrorText = GetMenuBuildErrorText & "'" & gsIniFilePathAndName & "'"
            Else
                GetMenuBuildErrorText = GetMenuBuildErrorText & modGlobal.COMPANY_INI_FILE_NAME
            End If
            GetMenuBuildErrorText = GetMenuBuildErrorText & ", which is essential for the running of the starter documents is missing."
        Case EMenuType.ReportFileInsert:
            GetMenuBuildErrorText = "The ini file "
            If gsIniFilePathAndName <> vbNullString Then
                GetMenuBuildErrorText = GetMenuBuildErrorText & "'" & gsIniFilePathAndName & "'"
            Else
                GetMenuBuildErrorText = GetMenuBuildErrorText & modGlobal.COMPANY_INI_FILE_NAME
            End If
            GetMenuBuildErrorText = GetMenuBuildErrorText & ", which is essential for the running of the starter documents is missing."
        Case EMenuType.ShortlistFileInsert:
            GetMenuBuildErrorText = "The ini file "
            If gsIniFilePathAndName <> vbNullString Then
                GetMenuBuildErrorText = GetMenuBuildErrorText & "'" & gsIniFilePathAndName & "'"
            Else
                GetMenuBuildErrorText = GetMenuBuildErrorText & modGlobal.COMPANY_INI_FILE_NAME
            End If
            GetMenuBuildErrorText = GetMenuBuildErrorText & ", which is essential for the running of the starter documents is missing."
        Case EMenuType.LetterFileInsert:
            GetMenuBuildErrorText = "The ini file "
            If gsIniFilePathAndName <> vbNullString Then
                GetMenuBuildErrorText = GetMenuBuildErrorText & "'" & gsIniFilePathAndName & "'"
            Else
                GetMenuBuildErrorText = GetMenuBuildErrorText & modGlobal.COMPANY_INI_FILE_NAME
            End If
            GetMenuBuildErrorText = GetMenuBuildErrorText & ", which is essential for the running of the starter documents is missing."
        Case EMenuType.InsertDocs:
            GetMenuBuildErrorText = "Menu can't be built as ini file missing"
        End Select
    Case Else:
        GetMenuBuildErrorText = "Unknown error"
    End Select
End Function

'++********************************************************************
' Description:  Creates a name of the callback for menu action
' Parameters:   N/A
' Returns:      Name of the callback for menu action
'--********************************************************************
Private Function GetActionCallbackName() As String
    GetActionCallbackName = "DynBtn" & Replace(modGlobal.COMPANY_NAME_SHORT, " ", vbNullString)
End Function

Private Function GetDynamicButtonActionName(menuType As EMenuType) As String
    Select Case menuType
    Case EMenuType.NewDocs
        GetDynamicButtonActionName = DYNAMIC_MENU_CALLBACK_FUNCTION_PREFIX & "NewDoc_onAction"
    Case EMenuType.StarterDocs
        GetDynamicButtonActionName = DYNAMIC_MENU_CALLBACK_FUNCTION_PREFIX & "StarterDoc_onAction"
    Case EMenuType.ReportFileInsert
        GetDynamicButtonActionName = DYNAMIC_MENU_CALLBACK_FUNCTION_PREFIX & "ReportFileInsert_onAction"
    Case EMenuType.ShortlistFileInsert
        GetDynamicButtonActionName = DYNAMIC_MENU_CALLBACK_FUNCTION_PREFIX & "ShortlistFileInsert_onAction"
    Case EMenuType.LetterFileInsert
        GetDynamicButtonActionName = DYNAMIC_MENU_CALLBACK_FUNCTION_PREFIX & "LetterFileInsert_onAction"
    Case EMenuType.InsertDocs
        GetDynamicButtonActionName = DYNAMIC_MENU_CALLBACK_FUNCTION_PREFIX & "InsertDoc_onAction"
    End Select
End Function

'++********************************************************************
' Procedure:    MenuXmlTextFileDelete
' Description:  Deletes a menu, xml text file.
' Parameters:   i_1NewDocs_2StarterDocs_3InsertDocs - Meny type.
'               sInsertMenuSectionName - If type 3 above, the ini file
'               section name for the menu file to delete.
' Returns:      N/A
'--********************************************************************
Sub MenuXmlTextFileDelete(menuType As EMenuType, Optional sInsertMenuSectionName As String = vbNullString)
    Select Case menuType
    Case EMenuType.NewDocs:
        MenuXmlTextWrite NEW_DOC_INI_SECTION, vbNullString, True
    Case EMenuType.StarterDocs:
        MenuXmlTextWrite STARTER_DOC_INI_SECTION, vbNullString, True
    Case EMenuType.ReportFileInsert:
        MenuXmlTextWrite REPORT_INI_SECTION, vbNullString, True
    Case EMenuType.ShortlistFileInsert:
        MenuXmlTextWrite SHORTLIST_INI_SECTION, vbNullString, True
    Case EMenuType.LetterFileInsert:
        MenuXmlTextWrite LETTER_INI_SECTION, vbNullString, True
    Case EMenuType.InsertDocs:
         MenuXmlTextWrite sInsertMenuSectionName, vbNullString, True
    End Select
End Sub

'++********************************************************************
' Description:  Builds xml for all files in the passed directory if
'               they pass all the criteria. Will use the order file if
'               it exists for this file set.
' Parameters:   objTemplateFolder - Folder.
'               vInclude - Array of extensions to include.
'               vPrefixes - Array of filename prefixes to include.
'               sIdSuffix - Suffix to use for the buttons so they are
'                   unique.
'               sIniFileSection - Ini file section so the right xml
'                   structure can be built for the type of button.
'               lFilesFound - Returned number of files found in this
'                   directory.
' Returns:      Relevant xml
'--********************************************************************
Private Function MenuBuildFileSelect(folderPath As String, includes() As String, prefixes() As String, _
                    sIdSuffix As String, sIniFileSection As String, lFilesFound As Long, menuType As EMenuType) As String
    Dim fFile As File
    Dim sText As String
    Dim sXml As String
    Dim bOrderExists As Boolean
    Dim sLabel As String
    Dim orderFile As Integer
    Dim nfso As ClsNotFileSystemObject
    Dim fso As FileSystemObject
    Dim fileCollection As Collection
    Dim sFilePath As String
    Dim i As Integer
        
    If modPrivate.FileExists(modPrivate.JoinPathAndFilename(folderPath, "Menu Order.txt")) Then
        'Use the order from the Menu Order.txt file
        orderFile = FreeFile
        Open folderPath & "Menu Order.txt" For Input As #orderFile
        
        Do
            Line Input #orderFile, sText
            If Dir$(folderPath & sText) <> vbNullString Then
                If zVetFileNameOk(sText, includes, prefixes, sLabel) Then
                    sText = zMenuButtonXml(sIniFileSection, sLabel, modPrivate.JoinPathAndFilename(folderPath, sText), sIdSuffix, menuType)
                    'File OK so up the counter
                    
                    If sText = vbNullString Then
                        Close #orderFile
                        Exit Function
                    End If
                    
                    sXml = sXml & sText
                    
                    lBtnCount = lBtnCount + 1
                    lFilesFound = lFilesFound + 1
                End If
            End If
        Loop Until EOF(orderFile)
        Close #orderFile
    Else
        Set nfso = New ClsNotFileSystemObject
        Set fso = New FileSystemObject
        Set fileCollection = nfso.SearchForFiles(folderPath, "*.*", False)
        'Use the standard order i.e. as the file appears in the directory (alphabetical)
        For i = 1 To fileCollection.count
            sFilePath = fileCollection(i)
            If zVetFileNameOk(fso.GetFileName(sFilePath), includes, prefixes, sLabel) Then
                sText = zMenuButtonXml(sIniFileSection, sLabel, sFilePath, sIdSuffix, menuType)
                                
                If sText <> vbNullString Then
                    sXml = sXml & sText
                    
                    lBtnCount = lBtnCount + 1
                    lFilesFound = lFilesFound + 1
                End If
            End If
        Next
    End If
    
    MenuBuildFileSelect = sXml
End Function

'++********************************************************************
' Description:  Builds the xml for a standard menu based on finding
'               documents in a given directory and its sub directories.
' Parameters:   sDocsPath - Path to use.
'               vInclude - Array of file extensions to include.
'               vPrefixes - Array of filename prefixes to include.
'               sIniFileSection - Ini file section for this menu.
'               bList - If true, sub-directory separators will be in
'                   the form of a 'menuSeparator'. If false, it will be
'                   in the form of a sub menu.
'               bSubHide - If true, if sub-directory is empty then don't
'                   show them in the list
' Returns:      xml of the menu
'--********************************************************************
Private Function MenuBuildXML(sXml As String, sDocsPath As String, includes() As String, prefixes() As String, _
                    subDirNamesExcludes() As String, iniFileSection As String, bList As Boolean, _
                    bSubHide As Boolean, menuType As EMenuType, Optional ByRef lSubFileCount As Long = 0, _
                    Optional menuLevel As Integer = 1) As String
    Dim fldFolder As Folder
    Dim sFolder As String
    Dim lFilesFound As Long
    Dim sNewXml As String
    
    Dim sText As String
    Dim nfso As ClsNotFileSystemObject
            
    'If there are files in this folder, include them if they pass all the rules
    sXml = sXml & MenuBuildFileSelect(sDocsPath, includes, prefixes, _
      "MD", iniFileSection, lFilesFound, menuType)
      lSubFileCount = lFilesFound
    
    If lSubFileCount > 0 Then
        'I'm doin it this waird way because I don't want HasValidDescendant to run unless necessary
    ElseIf bSubHide = False Or HasValidDescendant(sDocsPath, includes, prefixes) Then
        'There are no items and the directory should be shown in the menu
        lSubFileCount = 1
        If bList Then
            'List type entry so needs at least one button
            sXml = " <button id=""rxBtnEmptyDirMsg" & lBtnCount & """ " & _
              "label=""Directory is empty"" enabled=""false"" imageMso=""BlackAndWhiteDontShow""/> "
            lBtnCount = lBtnCount + 1
        End If
    End If
    
    If menuLevel < 5 Then
        sXml = MenuBuildAddSubfolders(sXml, sDocsPath, bList, includes, prefixes, _
                        subDirNamesExcludes, iniFileSection, bSubHide, menuType, menuLevel)
    End If
    
    MenuBuildXML = sXml
End Function

'++********************************************************************
' Description:  Checks if there is a valid file in some subfolder of
'               given folder
' Parameters:   sDocsPath - Path to use.
'               vInclude - Array of file extensions to include.
'               vPrefixes - Array of filename prefixes to include.
' Returns:      True if any qualifiying file exists, false otherwise
'--********************************************************************
Private Function HasValidDescendant(sPath As String, includes() As String, prefixes() As String) As Boolean
    Dim nfso As ClsNotFileSystemObject
    Dim include As String
    Dim prefix As String
    Dim i As Integer
    Dim j As Integer
    
    Set nfso = New ClsNotFileSystemObject
    
    For i = LBound(includes) To UBound(includes)
        include = includes(i)
        For j = LBound(prefixes) To UBound(prefixes)
            prefix = prefixes(j)
            If nfso.SearchForFiles(sPath, prefix & include, True).count > 0 Then
                HasValidDescendant = True
                Exit Function
            End If
        Next j
    Next i
    HasValidDescendant = False
End Function

'++********************************************************************
' Description:  Returns the item matching to given value from a collection
'               if it exists, or empty string if it doesn't
' Parameters:   sText - Text we want to fing in the collection
'               oCollection - Collection with string values
' Returns:      item matching to given value from a collection
'               if it exists, or empty string if it doesn't
'--********************************************************************
Private Function GetMatchingItemFromStringCollection(sText As String, oCollection As Collection) As String
    Dim i As Integer
    
    On Error GoTo ErrorHandler
        
    For i = 1 To oCollection.count
        If StrComp(sText, oCollection(i), vbTextCompare) = 0 Then
            GetMatchingItemFromStringCollection = oCollection(i)
            Exit For
        End If
    Next
    
CleanExit:
    Exit Function
ErrorHandler:
    GetMatchingItemFromStringCollection = ""
    Resume CleanExit
End Function

'++********************************************************************
' Description:  Removes numbers from the start of string
' Parameters:   sDirOrFileName - Text that can start with numeric chars
'                   This can be any text in fact, not just dir of filename
' Returns:      Modified or unmodified name as necesary.
'--********************************************************************
Private Function RemovePrefixNumber(sDirOrFileName As String) As String
    Dim sText As String
    
    sText = sDirOrFileName
    
    Do Until Not sText Like "#*"
        sText = Trim$(Mid$(sText, 2))
        If sText = vbNullString Then
            sText = sDirOrFileName
            Exit Do
        End If
    Loop
    
    RemovePrefixNumber = sText
End Function

'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'                                 STILL TO CHECK
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************

Private Function MenuBuildAddSubfolders(sXml As String, folderPath As String, bList As Boolean, _
                    includes() As String, prefixes() As String, subDirNamesExcludes() As String, _
                    iniFileSection As String, bSubHide As Boolean, menuType As EMenuType, menuLevel As Integer) As String
    Dim nfso As ClsNotFileSystemObject
    Dim fso As FileSystemObject
    Dim folderCollection As Collection
    Dim fileInput As Integer
    Dim sFolder As String
    Dim sText As String
    Dim sNewXml As String
    Dim sFolderMenuLabel As String
    Dim i As Integer
    Dim mySubfileCount As Long
    Dim lSubFileCount As Long
    
    Set nfso = New ClsNotFileSystemObject
    Set folderCollection = nfso.SearchForFolders(folderPath, "*", False)
    
    If folderCollection.count > 0 Then
        If modPrivate.FileExists(modPrivate.JoinPathAndFilename(folderPath, "Menu Order.txt")) Then
            'Use the order from the Menu Order.txt file
            fileInput = FreeFile
            Open modPrivate.JoinPathAndFilename(folderPath, "Menu Order.txt") For Input As #fileInput
                
            Do
                Line Input #fileInput, sText
                
                sText = folderPath & sText
                sFolder = GetMatchingItemFromStringCollection(sText, folderCollection)
                
                If Not sFolder = vbNullString Then
                    If bList Then
                        sNewXml = "<menuSeparator id=""rxmSD" & lMenuCount & _
                          """ title=""" & EncodeAmpersand(sText, xTitle) & """/>"
                    Else
                        sNewXml = "<menu id=""rxmsp" & lMenuCount & """ label=""" & _
                          EncodeAmpersand(sText, xLabel) & """ imageMso=""FileOpen"" >"
                    End If
                
                    lMenuCount = lMenuCount + 1
                    
                    'Recursively call this routine
                    lSubFileCount = 0
                    sNewXml = MenuBuildXML(sNewXml, folderPath, includes, prefixes, subDirNamesExcludes, iniFileSection, _
                                                    bList, bSubHide, menuType, lSubFileCount) & IIf(bList, vbNullString, "</menu>")
                    
                    If lSubFileCount > 0 Or bSubHide = False Then
                        sXml = sXml & sNewXml
                    End If
                End If
            Loop Until EOF(fileInput)
            
            Close #fileInput
        Else
            Set fso = New FileSystemObject
            'Simply loop through the folders alphabetically
            For i = 1 To folderCollection.count
                sFolder = folderCollection(i)
                'Ignore 'Document Themes'
                If zVetDirectoryNameOk(fso.GetBaseName(sFolder), subDirNamesExcludes, sFolderMenuLabel) Then
                    lSubFileCount = 0
                    
                    If bList Then
                        sNewXml = "<menuSeparator id=""rxmSD" & lMenuCount & _
                          """ title=""" & EncodeAmpersand(sFolderMenuLabel, xTitle) & """/>"
                    Else
                        sNewXml = "<menu id=""rxmsp" & lMenuCount & """ label=""" & _
                          EncodeAmpersand(sFolderMenuLabel, xLabel) & """ imageMso=""FileOpen"" >"
                    End If
                
                    lMenuCount = lMenuCount + 1
                    
                    lSubFileCount = 0
                    sNewXml = MenuBuildXML(sNewXml, sFolder, includes, prefixes, subDirNamesExcludes, iniFileSection, bList, _
                                bSubHide, menuType, lSubFileCount, menuLevel + 1)
                    
                    If Not bList Then
                        sNewXml = FinalizeMenuXml(sNewXml)
                    End If
                    
                    If lSubFileCount > 0 Or bSubHide = False Then
                        sXml = sXml & sNewXml
                    End If
                End If
            Next
        End If
    End If
    
    MenuBuildAddSubfolders = sXml
End Function

'++********************************************************************
' Description:  Checks that the file is both a valid template and that
'               it fits all the filtering of its name.
' Parameters:   sFileName - Incoming file name (no path).
'               sInclude - Mask for the extention (dot, dotm, or *).
'               vPrefixes - Array of prefixes for which to filter.
'               returnLabel - Returned version of the file name for
'               using as a label for the menu item.
' Returns:      True=Template passed all tests.
'--********************************************************************
Function zVetFileNameOk(sFileName As String, vInclude As Variant, _
  prefixes() As String, returnLabel As String) As Boolean
    
    Dim iPass As Integer
    Dim i As Integer
    Dim j As Integer

    returnLabel = sFileName
    If Left(returnLabel, 1) <> "~" And Not returnLabel Like "*-Code.dotm" Then
        'Also exclude template code servers (*-Code.dotm)
    
        'Filename is of the valid type. Now test for extensions
        For iPass = 1 To 2
            'Perform 2 passes, the first one with the name as it's passed to the function and the _
             second pass deals with the removal of numeric prefixes if relevant
        
            If iPass = 2 Then
                If bRemovePrefixNosTmpls Then
                    'Has the removal of numbering been requested
                    If returnLabel Like "#*" Then
                        'Has been requested so remove the numbers if there are any
                        returnLabel = RemovePrefixNumber(returnLabel)
                    Else
                        'No numeric prefix anyway
                        Exit For
                    End If
                Else
                    zVetFileNameOk = False
                    Exit For
                End If
            End If
            
            For i = 0 To UBound(vInclude, 1)
                If returnLabel Like vInclude(i) Then
                    'Filename is of the valid type. Now test for prefixes
                    If UBound(prefixes) - LBound(prefixes) + 1 > 0 Then
                        For j = LBound(prefixes) To UBound(prefixes)
                            If returnLabel Like prefixes(j) & "*" Then
                                zVetFileNameOk = True
                                returnLabel = Left$(returnLabel, InStrRev(returnLabel, ".") - 1)
                                If iPass = 1 And bRemovePrefixNosTmpls Then
                                    returnLabel = RemovePrefixNumber(returnLabel)
                                End If
                                Exit Function
                            End If
                        Next j
                    Else
                        zVetFileNameOk = True
                        If bRemovePrefixNosTmpls Then
                            returnLabel = RemovePrefixNumber(returnLabel)
                        End If
                        returnLabel = Left$(returnLabel, InStrRev(returnLabel, ".") - 1)
                        Exit Function
                    End If
                End If
            Next i
        Next iPass
    End If
    
    'Not one we want
    zVetFileNameOk = False
End Function

'++********************************************************************
' Description:  Builds the relevant button xml for dynamic menus.
' Parameters:   sIniFileSection - Ini file section name.
'               sLabel - Label to use.
'               sFilePath - Full path and file name of target.
' Returns:      Relevant xml
'--********************************************************************
Private Function zMenuButtonXml(sIniFileSection As String, _
  sLabel As String, sFilePath As String, rxBtnSuffix As String, menuType As EMenuType) As String
    
    Dim sIcon As String
    Dim sText As String
    Dim iRed As Integer
    Dim iAmber As Integer
    Dim i As Integer
    Dim sErrNosMsg As String
    
    Select Case menuType
    
        Case EMenuType.NewDocs
            'Check for the presence of any critical ini files
            sText = modPrivate.FilePropertyGet(sFilePath, 18) '18=Tags or Keywords
            
            'There's a W10 bug where you cannot retrieve file properties if the template whose _
             file properties you are trying to retrive is loaded - weird eh? So, we need to _
             check if the reason we have no tags is because there's a document loaded using _
             the template.
            If sText = vbNullString Then
                On Error Resume Next 'In case it is not loaded and it is true there are no tags
                'If the template is loaded, this next statement will retrieve the tags property
                sText = Templates(sFilePath).BuiltInDocumentProperties(wdPropertyKeywords)
                On Error GoTo 0
            End If
            
            zMenuButtonXml = "<button id=""rxBtn" & rxBtnSuffix & sIniFileSection & lBtnCount & _
              """ label=""" & EncodeAmpersand(sLabel, xLabel) & """ imageMso=""FileNew"" tag=""" & _
              zTagBuild(1, sFilePath) & """ onAction=""" & GetDynamicButtonActionName(menuType) & _
              """ screentip=""" & EncodeAmpersand(sLabel & " (" & modPrivate.FilePropertyGet(sFilePath, 3), xScreentip) & ")"" " & _
              "supertip=""" & EncodeAmpersand(sFilePath, xSupertip) & """/>" & vbCrLf
    
        Case EMenuType.StarterDocs
            sText = System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "UseTrafficLights")
            If sText = "Yes" Or sText = "True" Then
                'Traffic light icons are required
                iRed = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightRed"))
                iAmber = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightAmber"))
                If iRed <= iAmber Then
                    modError.DisplayMsg "The value in the ini file for the key 'TrafficLightRed' should be " & _
                      "a larger number than that for the key 'TrafficLightAmber'." & vbCr & vbCr & _
                      "Please amend the ini file.", vbExclamation, , True
                    Exit Function
                End If
                sText = modPrivate.FilePropertyGet(sFilePath, EFileProperty.DateModified) 'Date modified
                i = DateDiff("d", CVDate(sText), Date)
                'Assing the relevant colour icon
                If i >= iRed Then
                    sIcon = "image=""NewDocRed"""
                ElseIf i >= iAmber Then
                    sIcon = "image=""NewDocAmber"""
                Else
                    sIcon = "image=""NewDocGreen"""
                End If
            End If
            If sIcon = vbNullString Then
                sIcon = "imageMso=""FileNew"""
            End If
            zMenuButtonXml = "<button id=""rxBtn" & rxBtnSuffix & sIniFileSection & lBtnCount & _
              """ label=""" & EncodeAmpersand(sLabel, xLabel) & """ " & sIcon & " tag=""" & _
              zTagBuild(2, sFilePath) & """ onAction=""" & GetDynamicButtonActionName(menuType) & """ " & _
              "screentip=""" & EncodeAmpersand(sLabel & " (" & modPrivate.FilePropertyGet(sFilePath, 3), xScreentip) & ")"" " & _
              zFileCommentsGet(sFilePath) & "/>" & vbCrLf
        Case EMenuType.ReportFileInsert
            sText = System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "UseTrafficLights")
            If sText = "Yes" Or sText = "True" Then
                'Traffic light icons are required
                iRed = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightRed"))
                iAmber = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightAmber"))
                If iRed <= iAmber Then
                    modError.DisplayMsg "The value in the ini file for the key 'TrafficLightRed' should be " & _
                      "a larger number than that for the key 'TrafficLightAmber'." & vbCr & vbCr & _
                      "Please amend the ini file.", vbExclamation, , True
                    Exit Function
                End If
                sText = modPrivate.FilePropertyGet(sFilePath, EFileProperty.DateModified) 'Date modified
                i = DateDiff("d", CVDate(sText), Date)
                'Assing the relevant colour icon
                If i >= iRed Then
                    sIcon = "image=""NewDocRed"""
                ElseIf i >= iAmber Then
                    sIcon = "image=""NewDocAmber"""
                Else
                    sIcon = "image=""NewDocGreen"""
                End If
            End If
            If sIcon = vbNullString Then
                sIcon = "imageMso=""FileNew"""
            End If
            zMenuButtonXml = "<button id=""rxBtn" & rxBtnSuffix & sIniFileSection & lBtnCount & _
              """ label=""" & EncodeAmpersand(sLabel, xLabel) & """ " & sIcon & " tag=""" & _
              zTagBuild(2, sFilePath) & """ onAction=""" & GetDynamicButtonActionName(menuType) & """ " & _
              "screentip=""" & EncodeAmpersand(sLabel & " (" & modPrivate.FilePropertyGet(sFilePath, 3), xScreentip) & ")"" " & _
              zFileCommentsGet(sFilePath) & "/>" & vbCrLf
        Case EMenuType.ShortlistFileInsert
            sText = System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "UseTrafficLights")
            If sText = "Yes" Or sText = "True" Then
                'Traffic light icons are required
                iRed = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightRed"))
                iAmber = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightAmber"))
                If iRed <= iAmber Then
                    modError.DisplayMsg "The value in the ini file for the key 'TrafficLightRed' should be " & _
                      "a larger number than that for the key 'TrafficLightAmber'." & vbCr & vbCr & _
                      "Please amend the ini file.", vbExclamation, , True
                    Exit Function
                End If
                sText = modPrivate.FilePropertyGet(sFilePath, EFileProperty.DateModified) 'Date modified
                i = DateDiff("d", CVDate(sText), Date)
                'Assing the relevant colour icon
                If i >= iRed Then
                    sIcon = "image=""NewDocRed"""
                ElseIf i >= iAmber Then
                    sIcon = "image=""NewDocAmber"""
                Else
                    sIcon = "image=""NewDocGreen"""
                End If
            End If
            If sIcon = vbNullString Then
                sIcon = "imageMso=""FileNew"""
            End If
            zMenuButtonXml = "<button id=""rxBtn" & rxBtnSuffix & sIniFileSection & lBtnCount & _
              """ label=""" & EncodeAmpersand(sLabel, xLabel) & """ " & sIcon & " tag=""" & _
              zTagBuild(2, sFilePath) & """ onAction=""" & GetDynamicButtonActionName(menuType) & """ " & _
              "screentip=""" & EncodeAmpersand(sLabel & " (" & modPrivate.FilePropertyGet(sFilePath, 3), xScreentip) & ")"" " & _
              zFileCommentsGet(sFilePath) & "/>" & vbCrLf
        Case EMenuType.LetterFileInsert
            sText = System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "UseTrafficLights")
            If sText = "Yes" Or sText = "True" Then
                'Traffic light icons are required
                iRed = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightRed"))
                iAmber = Val(System.PrivateProfileString(gsIniFilePathAndName, sIniFileSection, "TrafficLightAmber"))
                If iRed <= iAmber Then
                    modError.DisplayMsg "The value in the ini file for the key 'TrafficLightRed' should be " & _
                      "a larger number than that for the key 'TrafficLightAmber'." & vbCr & vbCr & _
                      "Please amend the ini file.", vbExclamation, , True
                    Exit Function
                End If
                sText = modPrivate.FilePropertyGet(sFilePath, EFileProperty.DateModified) 'Date modified
                i = DateDiff("d", CVDate(sText), Date)
                'Assing the relevant colour icon
                If i >= iRed Then
                    sIcon = "image=""NewDocRed"""
                ElseIf i >= iAmber Then
                    sIcon = "image=""NewDocAmber"""
                Else
                    sIcon = "image=""NewDocGreen"""
                End If
            End If
            If sIcon = vbNullString Then
                sIcon = "imageMso=""FileNew"""
            End If
            zMenuButtonXml = "<button id=""rxBtn" & rxBtnSuffix & sIniFileSection & lBtnCount & _
              """ label=""" & EncodeAmpersand(sLabel, xLabel) & """ " & sIcon & " tag=""" & _
              zTagBuild(2, sFilePath) & """ onAction=""" & GetDynamicButtonActionName(menuType) & """ " & _
              "screentip=""" & EncodeAmpersand(sLabel & " (" & modPrivate.FilePropertyGet(sFilePath, 3), xScreentip) & ")"" " & _
              zFileCommentsGet(sFilePath) & "/>" & vbCrLf
        Case Else
            If sIniFileSection Like "InsertMenu-*" Then
                'The hyphen before the lBtnCount is important as it allows the sIniFileSection to be _
                 deciphered in proc 'rxBtn & sIdentity & InsertMenu_onAction'
                zMenuButtonXml = "<button id=""rxBtn" & rxBtnSuffix & sIniFileSection & "-" & lBtnCount & _
                  """ label=""" & EncodeAmpersand(sLabel, xLabel) & """ imageMso=""FileNew"" tag=""" & _
                  EncodeAmpersand(sFilePath, xTag) & """ onAction=""" & GetDynamicButtonActionName(menuType) & """ " & _
                  "screentip=""" & EncodeAmpersand(sLabel & " (" & modPrivate.FilePropertyGet(sFilePath, 3), xScreentip) & ")"" " & _
                  zFileCommentsGet(sFilePath) & "/>" & vbCrLf
            Else
                modError.DisplayMsg "Section '" & sIniFileSection & "' unknown.", vbExclamation, , True
            End If
    End Select
End Function

'++********************************************************************
' Description:  Checks that the subDirectory is not an exclude name.
' Parameters:   sDirName - Incoming sub dir name (no path).
'               vExcludeArray - Array of name to exclude for which to
'                   filter.
'               sReturnLabel - Form of the directory to use in the case
'                   that any preceeding numbers were stripped from the
'                   name.
' Returns:      True=Sub Name passed all tests.
'--********************************************************************
Private Function zVetDirectoryNameOk(sDirName As String, vExcludeArray As Variant, returnLabel As String) As Boolean
    Dim i As Integer
    Dim j As Integer

    If sDirName = "Document Themes" Then
        zVetDirectoryNameOk = False
    Else
        'Filename is of the valid type. Now test for extensions
        zVetDirectoryNameOk = True
        
        If IsArray(vExcludeArray) Then
        
            For i = 0 To UBound(vExcludeArray)
                If sDirName Like vExcludeArray(i) Then
                    zVetDirectoryNameOk = False
                    Exit For
                End If
                If bRemovePrefixNosDirs Then
                    'Also check the name without the numeric prefix if required
                    If RemovePrefixNumber(sDirName) Like vExcludeArray(i) Then
                        zVetDirectoryNameOk = False
                        Exit For
                    End If
                End If
            
            Next i
            
        End If
        returnLabel = sDirName
        If bRemovePrefixNosDirs Then
            returnLabel = RemovePrefixNumber(returnLabel)
        End If
    End If
End Function

'++*******************************************************************
' Description:  Builds the tag for a New or Starter doc button in the
'               ribbon. It will be multi-part for an iManage system or
'               basic, single part tag for non iManage.
' Parameters:   sFilePath - Full path and filename of the template or
'               starter doc.
' Returns:      Returned tag.
'--********************************************************************
Private Function zTagBuild(i_1NewDocs_2StarterDocs As Integer, ByVal sFilePathAndName As String) As String
    'Not iManage sytem so single part tag
    zTagBuild = EncodeAmpersand(sFilePathAndName, xTag)
End Function

'++********************************************************************
' Procedure:    zFileCommentsGet
' Description:  Builds the supertip xml for the passed file.
' Parameters:   sFile - Full path and filename of the file.
' Returns:      Relevant xml
'--********************************************************************
Private Function zFileCommentsGet(sFile As String) As String

    Dim sText As String

    sText = modPrivate.FilePropertyGet(sFile, 24) '24=Comments
    If sText <> vbNullString Then
        sText = EncodeAmpersand(sText, xSupertip)
        zFileCommentsGet = "supertip=""" & Replace(sText, "<P>", "&#13;&#13;") & """"
    End If

End Function
Attribute VB_Name = "modScreenUpdating"
'***********************************************************************************
'* Expense Reduction Analysts Report template
'*
'* Module: modScreenUpdating
'*
'* Module is designed to work as class with static methods. It holds function, that makes disabling and enabling
'* screen updating more reliable and easier.
'* Functions in this module will allow to disable and enable screen updating in nested procedures
'* without accidentaly enabling screen updating in higher level
'***********************************************************************************

Option Explicit
Option Private Module

Private Const msMODULE As String = "modMacros"

'indicates how many times must ScreenUpdating_Enable be called before the screen updating is really enabled
Private giCounter As Integer

'With disabling screen update, the track changes should be disabled as well, but when screen updating is enabled, return to original setting
Private mbTrackChanges As Boolean
Private mbTrackChangesKnown As Boolean

'++*******************************************************************
' Procedure:    ScreenUpdating_Disable
' Author:       Brochet ltd
' Description:  Disables screenupdating, and Increment giCounter
'               should be called in pair with ScreenUpdating_Enable
' Parameters:   nothing
' Returns:      nothing
'--********************************************************************
Public Sub ScreenUpdating_Disable()
    If giCounter = 0 Then
        mbTrackChanges = ActiveDocument.TrackRevisions
        mbTrackChangesKnown = True
    End If
    giCounter = giCounter + 1
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    Options.Pagination = False
    ActiveDocument.TrackRevisions = False
End Sub

'++*******************************************************************
' Procedure:    ScreenUpdating_Enable
' Author:       Brochet ltd
' Description:  Decrement giCounter if it is larger than 0. If giCounter is 0 after decrementation, enables screen updating
'               should be called in pair with ScreenUpdating_Disable
' Parameters:   nothing
' Returns:      nothing
'--********************************************************************
Public Sub ScreenUpdating_Enable()
    'giCounter should never be smaller than 0
    giCounter = max(giCounter - 1, 0)
    If giCounter = 0 Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
        If mbTrackChangesKnown Then
            ActiveDocument.TrackRevisions = mbTrackChanges
        End If
        Options.Pagination = True
    End If
    
End Sub

'++*******************************************************************
' Procedure:    ScreenUpdating_Reset
' Author:       Brochet ltd
' Description:  Resets giCounter, and enables screen refreshing.
'               Should only be used on higher level.
' Parameters:   nothing
' Returns:      nothing
'--********************************************************************
Public Sub ScreenUpdating_Reset()
    giCounter = 0
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    If mbTrackChangesKnown Then
        ActiveDocument.TrackRevisions = mbTrackChanges
    End If
    Options.Pagination = True

End Sub

Attribute VB_Name = "modTableDeclarations"
'***********************************************************************************
'* Brochet Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modTablesDeclarations
'*
'*
'* Version 2.1 -    Date: 18.09.2019 - Alan Cartwright
'*                  This is the first versioned version
'*                  Table Reformat - clears manual foramtting
'*                  Table reformat - resizes table to Column text width
'*
'***********************************************************************************
Option Explicit
'Option Private Module

Const msMODULE As String = "modTableDeclarations"

Public Const TABLETOOL_VERSION As String = "2.1"


Public Const cTableShadeLtGreen As Long = 14283748 'rgb(228,243,217)

Public Const TABLE_MAX_ROWS As Integer = 100 'need to remove these

Public Enum eColumnTypes
    tblcolNone = 1
    tblcolEven = 2
    tblcolFinancial = 4
    tblcolFixed = 8
    tblcolFirstCol = 16
End Enum

Public Type tTableDialogSettings
    Columns As Integer
    Rows As Integer
    
    Title As String
    Source As String

    ColumnStyle As eColumnTypes
    
    Heading As Boolean
    FirstColumn As Boolean
    LastColumn As Boolean
    HorizontalBanding As Boolean
    VerticalBanding As Boolean
    TotalRow As Boolean
    
    NewTable As Boolean
    
End Type


Type tTablePreview
    Top As Single
    width As Single
    Left As Single
    Columns As Single
    Rows As Single
    Height As Single
    TextMargin As Single
    Font As Single
    Col1SampleText As String
End Type

Public Type tTablePadding
    Top As Double
    Bottom As Double
    Left As Double
    Right As Double
End Type

Public Type tLine
    Style As WdLineStyle
    width As WdLineWidth
    Colour As WdColorIndex
End Type

Public Type tCellDesign
    BackgroundColour As Long
    TopLine As tLine
    RightLine As tLine
    BottomLine As tLine
    LeftLine As tLine
    HorizontalLine As tLine
    VerticalLine As tLine
    VerticalAlignment As WdCellVerticalAlignment
End Type

Public Type tOptionDesign
    Cells As tCellDesign
    ParagraphStyle As String ' Initially set to all cells in the table
    ParagraphStyleHeading As String
    AllowBreakAcrossPages As Boolean
End Type

Public Type tTableIndentModifier
    Caption As String
    LeftIndent As Double
    TableWidth As Double ' if 0 then assumes 100%
End Type

Public Type tTableDesign
    DisplayName As String
    TitleStyle As String
    SourceStyle As String
    
    TableDialogVisibleSettings As tTableDialogSettings ' Set the default setting in the dialog
    TableDialogEnabledOptions As tTableDialogSettings 'Enable Disable dialog features
    TableDialogDefaultSettings As tTableDialogSettings ' Set the default setting in the dialog
    
    PlainGrid As tOptionDesign ' Set to all cells
    
    HeadingRow As tOptionDesign
    FirstColumn As tOptionDesign
    LastColumn As tOptionDesign
    TotalRow As tOptionDesign
    
    Padding As tTablePadding
    
    BandedRow As tCellDesign
    BandedColumn As tCellDesign
    
    FixedColumnWidth As Double 'For use in Financial type columns
    LeftIndent As Double
    TableWidth As Double ' if 0 then assumes 100%
    
    MaxRows As Integer
    MaxColumns As Integer
End Type

Public TableMain As tTableDesign
'Public TableHighlightFirstColumn As tTableDesign
Public TableFinancial As tTableDesign
Attribute VB_Name = "modTableDesign"
'***********************************************************************************
'* Brochet Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modTables
'*
'* Holds various macro code related to tables
'***********************************************************************************
Option Explicit
Option Private Module

Const msMODULE As String = "modTableDesign"

Private Const cLineColour As Long = 0
Private Const cCellShade As Long = 16777215 'rgb(255,255,255)
Private Const cDarkGreen As Long = 3298304 'rgb(0,84,50)
Private Const cLightGreen As Long = 11855562 'rgb(202,230,180)


Sub SetupTableDesigns()

    'TableMain defines the base definition for all table definitions
    'You only need to apply the differences to the other table definitions
    
    SetupTableMain
    
    'SetupTableHighlightFirstColumn

    SetupTableFinancial

    'Set LineStyle to -1 to NOT apply a line style (Leave as is)
    'Set .Cells.BackgroundColour = -1 to NOT apply a shade

End Sub

Sub SetupTableMain()

    With TableMain
        .DisplayName = "Text Tables"
        
        .TitleStyle = "Table title"
        .SourceStyle = "Source"
        
        .FixedColumnWidth = 1
        
        .LeftIndent = 0
        
        .TableWidth = 0
        
        .MaxRows = 100
        .MaxColumns = 30
        
        With .PlainGrid
            .ParagraphStyle = STYLE_TABLE_TEXT
            .ParagraphStyleHeading = ""
            
            .AllowBreakAcrossPages = False
        
            With .Cells
                .BackgroundColour = cCellShade
                
                '.TopLine.Colour = ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeDark1).RGB
                .TopLine.Colour = cLineColour
                .TopLine.Style = wdLineStyleNone
                .TopLine.width = wdLineWidth150pt
                
                .RightLine.Colour = cLineColour
                .RightLine.Style = wdLineStyleNone
                .RightLine.width = wdLineWidth150pt
            
                .BottomLine.Colour = cLightGreen
                .BottomLine.Style = wdLineStyleSingle
                .BottomLine.width = wdLineWidth050pt
            
                .LeftLine.Colour = cLineColour
                .LeftLine.Style = wdLineStyleNone
                .LeftLine.width = wdLineWidth150pt

                .HorizontalLine.Colour = cLightGreen
                .HorizontalLine.Style = wdLineStyleSingle
                .HorizontalLine.width = wdLineWidth050pt
            
                .VerticalLine.Colour = cLineColour
                .VerticalLine.Style = wdLineStyleNone
                .VerticalLine.width = wdLineWidth150pt
            End With
        End With
        
        With .HeadingRow
            .ParagraphStyle = STYLE_TABLE_HEADING
            .ParagraphStyleHeading = ""
            
            .AllowBreakAcrossPages = False
            
            
        
            With .Cells
                .BackgroundColour = -1 'cCellShade
                .VerticalAlignment = wdCellAlignVerticalBottom
                
                .TopLine.Colour = cLineColour
                .TopLine.Style = wdLineStyleNone
                .TopLine.width = wdLineWidth100pt
                
                .RightLine.Colour = cLineColour
                .RightLine.Style = wdLineStyleNone
                .RightLine.width = wdLineWidth100pt
            
                .BottomLine.Colour = cDarkGreen
                .BottomLine.Style = wdLineStyleSingle
                .BottomLine.width = wdLineWidth100pt
            
                .LeftLine.Colour = cLineColour
                .LeftLine.Style = wdLineStyleNone
                .LeftLine.width = wdLineWidth100pt
                
                .HorizontalLine.Colour = cLineColour
                .HorizontalLine.Style = wdLineStyleNone
                .HorizontalLine.width = wdLineWidth100pt
            
                .VerticalLine.Colour = cLineColour
                .VerticalLine.Style = wdLineStyleNone
                .VerticalLine.width = wdLineWidth100pt
                
            End With
        End With

        With .FirstColumn
            .ParagraphStyle = STYLE_TABLE_HEADING
            .ParagraphStyleHeading = ""
        
            With .Cells
                .BackgroundColour = -1 ' -1 means Do not apply any shading this allows the Banded rows to show through
                
                .TopLine.Colour = cLineColour
                .TopLine.Style = wdLineStyleNone
                .TopLine.width = wdLineWidth150pt
                
                .RightLine.Colour = cDarkGreen
                .RightLine.Style = wdLineStyleSingle
                .RightLine.width = wdLineWidth100pt
            
                .BottomLine.Colour = cLightGreen
                .BottomLine.Style = wdLineStyleSingle
                .BottomLine.width = wdLineWidth050pt

            
                .LeftLine.Colour = cLineColour
                .LeftLine.Style = wdLineStyleNone
                .LeftLine.width = wdLineWidth150pt

                .HorizontalLine.Colour = cLightGreen
                .HorizontalLine.Style = wdLineStyleSingle
                .HorizontalLine.width = wdLineWidth050pt
            
                .VerticalLine.Colour = cLineColour
                .VerticalLine.Style = wdLineStyleNone
                .VerticalLine.width = wdLineWidth150pt
                
            End With
        End With
        
        With .LastColumn
            .ParagraphStyle = STYLE_TABLE_HEADING
            .ParagraphStyleHeading = ""
        
            With .Cells
                .BackgroundColour = cCellShade
                
                .TopLine.Colour = cLineColour
                .TopLine.Style = wdLineStyleSingle
                .TopLine.width = wdLineWidth050pt
                
                .RightLine.Colour = cLineColour
                .RightLine.Style = wdLineStyleSingle
                .RightLine.width = wdLineWidth050pt
            
                .BottomLine.Colour = cLineColour
                .BottomLine.Style = wdLineStyleSingle
                .BottomLine.width = wdLineWidth050pt
            
                .LeftLine.Colour = cLineColour
                .LeftLine.Style = wdLineStyleSingle
                .LeftLine.width = wdLineWidth050pt
                
                .HorizontalLine.Colour = cLineColour
                .HorizontalLine.Style = wdLineStyleSingle
                .HorizontalLine.width = wdLineWidth050pt
            
                .VerticalLine.Colour = cLineColour
                .VerticalLine.Style = wdLineStyleSingle
                .VerticalLine.width = wdLineWidth050pt
                
            End With
        End With

        With .TotalRow
            .ParagraphStyle = STYLE_TABLE_TEXT_BOLD
            .ParagraphStyleHeading = STYLE_TABLE_TEXT_BOLD
        
            .AllowBreakAcrossPages = False
        
            With .Cells
                .BackgroundColour = cTableShadeLtGreen
                
                .TopLine.Colour = cLightGreen
                .TopLine.Style = wdLineStyleSingle
                .TopLine.width = wdLineWidth050pt
                
                .RightLine.Colour = cLineColour
                .RightLine.Style = wdLineStyleNone
                .RightLine.width = wdLineWidth050pt
            
                .BottomLine.Colour = cLightGreen
                .BottomLine.Style = wdLineStyleSingle
                .BottomLine.width = wdLineWidth050pt
                
                
                .LeftLine.Colour = cLineColour
                .LeftLine.Style = wdLineStyleNone
                .LeftLine.width = wdLineWidth050pt
                
                .HorizontalLine.Colour = cLineColour
                .HorizontalLine.Style = wdLineStyleNone
                .HorizontalLine.width = wdLineWidth050pt
            
                .VerticalLine.Colour = cLineColour
                .VerticalLine.Style = wdLineStyleNone
                .VerticalLine.width = wdLineWidth050pt
                
            End With
        End With


        With .BandedRow
            .BackgroundColour = cCellShade
            .TopLine.Style = -1
            .RightLine.Style = -1
            .BottomLine.Style = -1
            .LeftLine.Style = -1
            .HorizontalLine.Style = -1
            .VerticalLine.Style = -1
        End With
        
        With .BandedColumn
            .BackgroundColour = cCellShade
            .TopLine.Style = -1
            .RightLine.Style = -1
            .BottomLine.Style = -1
            .LeftLine.Style = -1
            .HorizontalLine.Style = -1
            .VerticalLine.Style = -1
        End With
        
        With .Padding
            .Bottom = 0
            .Left = 0
            .Right = 0.1
            .Top = 0
        End With
        
        With .TableDialogEnabledOptions
            .FirstColumn = True
            .VerticalBanding = False
            .LastColumn = False
            .Heading = True
            .HorizontalBanding = False
            .TotalRow = True
        End With
        
        
        With .TableDialogDefaultSettings
            .FirstColumn = False
            .VerticalBanding = False
            .LastColumn = False
            .Heading = True
            .HorizontalBanding = False
            .TotalRow = False
        End With

        With .TableDialogVisibleSettings
            .FirstColumn = True
            .VerticalBanding = False
            .LastColumn = False
            .Heading = True
            .HorizontalBanding = False
            .TotalRow = True
        End With
        
    End With
    

End Sub


'Sub SetupTableHighlightFirstColumn()
'
'    TableHighlightFirstColumn = TableMain
'
'    With TableHighlightFirstColumn
'
'        .DisplayName = "Highlight First Column"
'
'        .PlainGrid.ParagraphStyle = STYLE_TABLE_TEXT_INDENTED
'        .PlainGrid.ParagraphStyleHeading = STYLE_TABLE_TEXT
'
'        .HeadingRow.ParagraphStyle = STYLE_TABLE_HEADING
'        .HeadingRow.ParagraphStyleHeading = STYLE_TABLE_HEADING
'
'        .FirstColumn.ParagraphStyleHeading = STYLE_TABLE_HEADING_INDENTED
'        .FirstColumn.ParagraphStyle = STYLE_TABLE_HEADING_INDENTED
'
'        .TotalRow.ParagraphStyle = STYLE_TABLE_NUMB_BOLD
'        .TotalRow.ParagraphStyleHeading = STYLE_TABLE_HEADING
'
'
'
'        With .PlainGrid
'
'            With .Cells
'
'                .TopLine.Colour = cLineColour
'                .TopLine.Style = wdLineStyleSingle
'                .TopLine.width = wdLineWidth025pt
'
'            End With
'        End With
'
'
'        With .FirstColumn
''            .ParagraphStyle = STYLE_TABLE_HEADING_INDENTED
''            .ParagraphStyleHeading = STYLE_TABLE_HEADING_INDENTED
'
'            With .Cells
'                .BackgroundColour = cGFDarkGrey ' -1 means Do not apply any shading this allows the Banded rows to show through
'
'                .TopLine.Colour = cLineColour
'                .TopLine.Style = wdLineStyleSingle
'                .TopLine.width = wdLineWidth025pt
'
'                .RightLine.Colour = cLineColour
'                .RightLine.Style = wdLineStyleNone
'                .RightLine.width = wdLineWidth150pt
'
'                .TopLine.Colour = cLineColour
'                .TopLine.Style = wdLineStyleSingle
'                .TopLine.width = wdLineWidth025pt
'
'
'                .LeftLine.Colour = cLineColour
'                .LeftLine.Style = wdLineStyleNone
'                .LeftLine.width = wdLineWidth150pt
'
'                .HorizontalLine.Colour = RGB(255, 255, 255)
'                .HorizontalLine.Style = wdLineStyleSingle
'                .HorizontalLine.width = wdLineWidth025pt
'
'                .VerticalLine.Colour = cLineColour
'                .VerticalLine.Style = wdLineStyleNone
'                .VerticalLine.width = wdLineWidth150pt
'
'            End With
'        End With
'
'
'
'        With .TableDialogEnabledOptions
'            .FirstColumn = True
'            .VerticalBanding = False
'            .LastColumn = False
'            .Heading = False
'            .HorizontalBanding = False
'            .TotalRow = False
'        End With
'
'        With .TableDialogDefaultSettings
'            .FirstColumn = True
'            .VerticalBanding = False
'            .LastColumn = False
'            .Heading = False
'            .HorizontalBanding = False
'            .TotalRow = False
'        End With
'
'        With .TableDialogVisibleSettings
'            .FirstColumn = True
'            .VerticalBanding = False
'            .LastColumn = False
'            .Heading = True
'            .HorizontalBanding = False
'            .TotalRow = True
'        End With
'
'
'    End With
'
'End Sub


Sub SetupTableFinancial()


    TableFinancial = TableMain
    

    With TableFinancial
    
        .DisplayName = "Financial Table"
    
        .PlainGrid.ParagraphStyle = STYLE_TABLE_NUMB
        .PlainGrid.ParagraphStyleHeading = STYLE_TABLE_TEXT
        
        .HeadingRow.ParagraphStyle = STYLE_TABLE_HEADING_RIGHT
        .HeadingRow.ParagraphStyleHeading = STYLE_TABLE_HEADING
        
        .FirstColumn.ParagraphStyleHeading = STYLE_TABLE_TEXT
        .FirstColumn.ParagraphStyle = STYLE_TABLE_TEXT
        
        .TotalRow.ParagraphStyle = STYLE_TABLE_NUMB_BOLD
        .TotalRow.ParagraphStyleHeading = STYLE_TABLE_HEADING
        
        .FixedColumnWidth = 2#
        
        With .FirstColumn
            .ParagraphStyle = STYLE_TABLE_TEXT
            .ParagraphStyleHeading = ""
        
            With .Cells
                
                .RightLine.Colour = cDarkGreen
                .RightLine.Style = wdLineStyleNone
                .RightLine.width = wdLineWidth050pt
            
            End With
        End With
        
        With .TotalRow
            .ParagraphStyle = STYLE_TABLE_NUMB_BOLD
            .ParagraphStyleHeading = STYLE_TABLE_TEXT_BOLD
        End With
        
   
        With .TableDialogEnabledOptions
            .FirstColumn = False
            .VerticalBanding = False
            .LastColumn = False
            .Heading = True
            .HorizontalBanding = False
            .TotalRow = True
        End With
        
        With .TableDialogDefaultSettings
            .FirstColumn = True
            .VerticalBanding = False
            .LastColumn = False
            .Heading = True
            .HorizontalBanding = False
            .TotalRow = True
        End With
        
        With .TableDialogVisibleSettings
            .FirstColumn = True
            .VerticalBanding = False
            .LastColumn = False
            .Heading = True
            .HorizontalBanding = False
            .TotalRow = True
        End With
        
        
    End With

End Sub



Sub ApplyDesignToCells(cCells As Cells, sDesign As tCellDesign)

On Error Resume Next

    With cCells
        
        If sDesign.BackgroundColour <> -1 Then
            With .Shading
                .Texture = wdTextureNone
                .BackgroundPatternColor = sDesign.BackgroundColour
            End With
        End If
        
        If sDesign.LeftLine.Style <> -1 Then
            With .Borders(wdBorderLeft)
                .lineStyle = sDesign.LeftLine.Style
                .LineWidth = sDesign.LeftLine.width
                .color = sDesign.LeftLine.Colour
            End With
        End If
        
        If sDesign.RightLine.Style <> -1 Then
            With .Borders(wdBorderRight)
                .lineStyle = sDesign.RightLine.Style
                .LineWidth = sDesign.RightLine.width
                .color = sDesign.RightLine.Colour
            End With
        End If
        
        If sDesign.TopLine.Style <> -1 Then
            With .Borders(wdBorderTop)
                .lineStyle = sDesign.TopLine.Style
                .LineWidth = sDesign.TopLine.width
                .color = sDesign.TopLine.Colour
            End With
        End If
        
        If sDesign.BottomLine.Style <> -1 Then
            With .Borders(wdBorderBottom)
                .lineStyle = sDesign.BottomLine.Style
                .LineWidth = sDesign.BottomLine.width
                .color = sDesign.BottomLine.Colour
            End With
        End If

        If sDesign.HorizontalLine.Style <> -1 Then
            With .Borders(wdBorderHorizontal)
                .lineStyle = sDesign.HorizontalLine.Style
                .LineWidth = sDesign.HorizontalLine.width
                .color = sDesign.HorizontalLine.Colour
            End With
        End If
        
        If sDesign.VerticalLine.Style <> -1 Then
            With .Borders(wdBorderVertical)
                .lineStyle = sDesign.VerticalLine.Style
                .LineWidth = sDesign.VerticalLine.width
                .color = sDesign.VerticalLine.Colour
            End With
        End If
        
        If sDesign.VerticalAlignment >= 0 Then
            .VerticalAlignment = sDesign.VerticalAlignment
        End If
    End With


End Sub

Sub ApplyDesignToIndividualCell(cCell As Cell, sDesign As tCellDesign, Optional bFirst As Boolean = False, Optional bLast As Boolean = False)

'This is for when you cannot access the Column range directly

'bFirst - treat as first cell in a theoretical range
'bLast - treat as Last cell in a theoretical range
'Both false then internal cell in theorectical range

On Error Resume Next

    With cCell
        
    If bFirst Then
                
        'Set top as top
        'set bottom as horizontal
        
        If sDesign.TopLine.Style <> -1 Then
            With .Borders(wdBorderTop)
                .lineStyle = sDesign.TopLine.Style
                .LineWidth = sDesign.TopLine.width
                .color = sDesign.TopLine.Colour
            End With
        End If
        
        If sDesign.HorizontalLine.Style <> -1 Then
            With .Borders(wdBorderBottom)
                .lineStyle = sDesign.HorizontalLine.Style
                .LineWidth = sDesign.HorizontalLine.width
                .color = sDesign.HorizontalLine.Colour
            End With
        End If
    
    ElseIf bLast Then
    
        'Set top as top
        'set bottom as horizontal
        
        If sDesign.HorizontalLine.Style <> -1 Then
            With .Borders(wdBorderTop)
                .lineStyle = sDesign.HorizontalLine.Style
                .LineWidth = sDesign.HorizontalLine.width
                .color = sDesign.HorizontalLine.Colour
            End With
        End If
        
        If sDesign.BottomLine.Style <> -1 Then
            With .Borders(wdBorderBottom)
                .lineStyle = sDesign.BottomLine.Style
                .LineWidth = sDesign.BottomLine.width
                .color = sDesign.BottomLine.Colour
            End With
        End If
    Else
    
        'set top and bottom as horizontal
    
        If sDesign.HorizontalLine.Style <> -1 Then
            With .Borders(wdBorderTop)
                .lineStyle = sDesign.HorizontalLine.Style
                .LineWidth = sDesign.HorizontalLine.width
                .color = sDesign.HorizontalLine.Colour
            End With
            With .Borders(wdBorderBottom)
                .lineStyle = sDesign.HorizontalLine.Style
                .LineWidth = sDesign.HorizontalLine.width
                .color = sDesign.HorizontalLine.Colour
            End With
        End If
    
    
    End If
        
        
        '///////////////////
        If sDesign.VerticalAlignment >= 0 Then
            .VerticalAlignment = sDesign.VerticalAlignment
        End If
        
        
        If sDesign.BackgroundColour <> -1 Then
            With .Shading
                .Texture = wdTextureNone
                .BackgroundPatternColor = sDesign.BackgroundColour
            End With
        End If
        
        If sDesign.LeftLine.Style <> -1 Then
            With .Borders(wdBorderLeft)
                .lineStyle = sDesign.LeftLine.Style
                .LineWidth = sDesign.LeftLine.width
                .color = sDesign.LeftLine.Colour
            End With
        End If
        
        If sDesign.RightLine.Style <> -1 Then
            With .Borders(wdBorderRight)
                .lineStyle = sDesign.RightLine.Style
                .LineWidth = sDesign.RightLine.width
                .color = sDesign.RightLine.Colour
            End With
        End If

        
    End With




End Sub
Attribute VB_Name = "modTableRibbon"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module:      modTableRibbon
'*
'* Holds:       Callbacks and support procedures for the ribbon. Table Funcitons only
'*******************************************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modTableRibbon"


'*******************************************************************************************************
'* Description: Creates or reformats a table
'* Parameters:  N/A
'* Returns:     N/A
'*******************************************************************************************************
Sub BtnBrochetTables_onAction(control As IRibbonControl)
    Dim sText As String
    Dim oUndoRecord As cUndoRecord
    Dim oFrm As New frmNewTable
    
    modScreenUpdating.ScreenUpdating_Disable
    
    Set oUndoRecord = New cUndoRecord
    
    Select Case control.ID
    
        'Insert a new table
        Case "BtnBrochetTableInsertTable"
    
            If modGlobalPublic.IsOperationOkToDo("Insert Table", MustBeEmptyPara + NotInAny + NotInProtectedSection) = "True" Then
                If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("isOkToInsertTable", False) Then
                    'isOkToInsertTable
                    oUndoRecord.SetName "New Table"
                    oFrm.SetNewTable True
                    oFrm.SetWidthOnly False
                    oFrm.Show
                End If
            End If
            
        'Reformat the Whole Table
        Case "BtnBrochetTableQuickReformat"

            If Selection.Tables.count > 0 Then
                If modTables.IsTableUnified(Selection.Tables(1), True, False) Then
                
                    If modGlobalPublic.IsOperationOkToDo("Modify Table", MustBeInTable + NotInProtectedSection) Then

                        oUndoRecord.SetName "Quick reformat Table"
                        oFrm.SetNewTable False
                        oFrm.SetWidthOnly False
                        oFrm.Show
                        
                    End If
                Else
                    modError.DisplayMsg "A table cannot be reformatted if it contains vertically merged cells.", vbInformation, "Reformat Table"
                End If
            Else
                modError.DisplayMsg "No table has been selected. Please select a table.", vbInformation, "Reformat Table"
            End If
            
        Case "BtnBrochetTableResetWidth"
            
            If Selection.Tables.count > 0 Then
            
                If modGlobalPublic.IsOperationOkToDo("Modify Table", MustBeInTable + NotInProtectedSection) Then
                    oUndoRecord.SetName "Reset table width"
                    oFrm.SetNewTable False
                    oFrm.SetWidthOnly True
                    oFrm.Show
                End If
            
            Else
                modError.DisplayMsg "No table has been selected. Please select a table.", vbInformation, "Reset table width"
            End If
            
            'TODO
'            If modTemplateReplacement.IsOperationOkToDo("Modify Table Table", MustBeInTable + NotInProtectedSection) Then
'                oUndoRecord.SetName "Reset table width"
'                'oFrm.TableFormMode = WidthReformat
'                Set oFrm.tTable = Selection.Tables(1)
'                oFrm.Show
'            End If

            
        '+ve/-ve numbers
        Case "BtnBrochetLegalTablesPosNeg"
            If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
                oUndoRecord.SetName "+ve/-ve Number Cells"
                modTables.zPosNegCells
            End If
            
            
        Case "BtnTableShadeRow"
            If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
                oUndoRecord.SetName "Shade Row"
                modTables.ShadeRow
            End If
            
        Case "BtnShadeCells"
            If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
                oUndoRecord.SetName "Shade Cells"
                modTables.ShadeCells
            End If
            
        Case "BtnTableHighlightCells"
            If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
                oUndoRecord.SetName "Highlight Cells"
                modTables.HighlightCells
            End If
            
            
        Case Else
        
            If Left(control.Tag, 1) = "T" Or Left(control.Tag, 1) = "|" Then
     
                If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
                    oUndoRecord.SetName "Reformat as Heading"
                    modTables.TableSelectionReformat control.Tag

                End If
            Else
                MsgBox "Callback to 'rxGrpTSUTables_onAction' with id '" & control.ID & "' not recognised.", vbInformation
            End If
        
    End Select
    
    oUndoRecord.EndRecording
    
    modScreenUpdating.ScreenUpdating_Enable
End Sub



'Callback for rxbtnCellColourGreen onAction
Sub BtnBrochetTablesSA_onAction(control As IRibbonControl)
    
    
    On Error GoTo ErrorHandler
    
    Dim oUndoRecord As cUndoRecord
    

    If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
    
        Set oUndoRecord = New cUndoRecord
        oUndoRecord.SetName "Apply SA"
        System.Cursor = wdCursorWait
        modScreenUpdating.ScreenUpdating_Disable
        
        
        Select Case control.Tag
        Case "TableCellGreen"
                ShadeCells Selection.Cells, "++", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent1).RGB, wdBlack
    
        Case "TableCellYellow"
                ShadeCells Selection.Cells, "+", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent2).RGB, wdBlack
    
        Case "TableCellWhite"
                ShadeCells Selection.Cells, "0", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeLight1).RGB, wdBlack
    
        Case "TableCellBlue"
                ShadeCells Selection.Cells, "?", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent6).RGB, wdWhite
    
        Case "TableCellOrange"
                ShadeCells Selection.Cells, "+/-", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent3).RGB, wdWhite
    
        Case "TableCellBergundy"
                ShadeCells Selection.Cells, "-", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent4).RGB, wdWhite
    
        Case "TableCellPurple"
                ShadeCells Selection.Cells, "--", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent5).RGB, wdWhite
    
        Case "TableCellBlack"
                ShadeCells Selection.Cells, "N/A", ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeDark1).RGB, wdWhite
        
        End Select
        
        System.Cursor = wdCursorNormal
        oUndoRecord.EndRecording
        modScreenUpdating.ScreenUpdating_Enable
    End If
    
CleanExit:

    Exit Sub
ErrorHandler:
    'Error applying style. Do nothing
    Resume CleanExit

End Sub

'Callback for rxbtnCellColourGreen onAction
Sub BtnBrochetTablesShading_onAction(control As IRibbonControl)
    
    
    On Error GoTo ErrorHandler
    
    Dim oUndoRecord As cUndoRecord
    

    If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
    
        Set oUndoRecord = New cUndoRecord
        oUndoRecord.SetName "Apply SA"
        System.Cursor = wdCursorWait
        modScreenUpdating.ScreenUpdating_Disable
        
        
        Select Case control.Tag
        Case "TableCellGreen"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent1).RGB, wdBlack
    
        Case "TableCellYellow"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent2).RGB, wdBlack
    
        Case "TableCellWhite"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeLight1).RGB, wdBlack
    
        Case "TableCellBlue"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent6).RGB, wdWhite
    
        Case "TableCellOrange"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent3).RGB, wdWhite
    
        Case "TableCellBergundy"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent4).RGB, wdWhite
    
        Case "TableCellPurple"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeAccent5).RGB, wdWhite
    
        Case "TableCellBlack"
                OnlyShadeCells Selection.Cells, ActiveDocument.DocumentTheme.ThemeColorScheme.Colors(msoThemeDark1).RGB, wdWhite
        
        End Select
        
        System.Cursor = wdCursorNormal
        oUndoRecord.EndRecording
        modScreenUpdating.ScreenUpdating_Enable
    End If
    
CleanExit:

    Exit Sub
ErrorHandler:
    'Error applying style. Do nothing
    Resume CleanExit

End Sub

Sub ShadeCells(cCells As Cells, sText As String, lShade As Long, ciTextColour As WdColorIndex)

Dim cCell As Cell
Dim progress As frmProgress

        cCells.VerticalAlignment = wdCellAlignVerticalCenter
        cCells.Shading.BackgroundPatternColor = lShade
        
        If cCells.count > 10 Then
            Set progress = New frmProgress
            progress.Init "Updating Cells", "Cell", cCells.count, 1
            progress.Show
        End If


        For Each cCell In cCells
            If sText <> "" Then
                cCell.Range.text = sText
            End If
            cCell.Range.Font.ColorIndex = ciTextColour
            cCell.Range.Paragraphs(1).Alignment = wdAlignParagraphCenter
            If cCells.count > 10 Then
                progress.Step
            End If
        Next

        progress.CloseMe

End Sub

Sub OnlyShadeCells(cCells As Cells, lShade As Long, ciTextColour As WdColorIndex)

Dim cCell As Cell
Dim progress As frmProgress

        cCells.VerticalAlignment = wdCellAlignVerticalCenter
        cCells.Shading.BackgroundPatternColor = lShade
        
        If cCells.count > 10 Then
            Set progress = New frmProgress
            progress.Init "Updating Cells", "Cell", cCells.count, 1
            progress.Show
        End If


        For Each cCell In cCells

            cCell.Range.Font.ColorIndex = ciTextColour
            If cCells.count > 10 Then
                progress.Step
            End If
        Next

        progress.CloseMe

End Sub


'++********************************************************************
' Description:  Handles all style button presses on ribbon of this template
' Parameters:   control - Ribbon button that was pressed
' Returns:      N/A
'--********************************************************************
Private Sub BtnBrochetTablesStyle_onAction(control As IRibbonControl)
    On Error GoTo ErrorHandler
    
    Dim oUndoRecord As cUndoRecord
    
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "Changing Style to: " & control.Tag
    

        If IsNumeric(control.Tag) Then
            Selection.Style = CInt(control.Tag)
        Else
            Selection.Style = control.Tag
        End If


    
CleanExit:
    oUndoRecord.EndRecording
    Exit Sub
ErrorHandler:
    'Error applying style. Do nothing
    Resume CleanExit
End Sub


Sub BtnTableVertAlign_onAction(control As IRibbonControl)


    If modGlobalPublic.IsOperationOkToDo("Modify Selected cells", MustBeInTable + NotInProtectedSection) Then
        Select Case control.ID
        Case "MenuSepTableVertAlignTop"
                
                    Selection.Cells.VerticalAlignment = wdCellAlignVerticalTop
    
    
        Case "MenuSepTableVertAlignMiddle"
    
                    Selection.Cells.VerticalAlignment = wdCellAlignVerticalCenter
    
        
        Case "MenuSepTableVertAlignBottom"
    
                    Selection.Cells.VerticalAlignment = wdCellAlignVerticalBottom
    
        End Select
   End If

End Sub

'*******************************************************************************************************
'* Description: Applies the Table Style
'* Parameters:  N/A
'* Returns:     N/A
'*******************************************************************************************************
Sub BtnBrochetTablesSelectionFormatting_onAction(control As IRibbonControl)
    Dim sText As String
    Dim oUndoRecord As cUndoRecord
    Dim oFrm As New frmNewTable
    
    modScreenUpdating.ScreenUpdating_Disable
    
    Set oUndoRecord = New cUndoRecord
    
    Select Case control.ID
    
'' Buttons
'Horizontal Line
        Case "rxbtnHorizOn"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
'                If Selection.Rows.count > 1 Then
'                    oUndoRecord.SetName "Horizontal Line"
'                    Selection.Borders(wdBorderHorizontal).lineStyle = wdLineStyleSingle
'                    Selection.Borders(wdBorderHorizontal).color = cOrange
'                Else
'                    MsgBox "Please select at least 2 cells vertically", vbExclamation, "Table Format"
'                End If
'
'            End If
        
        Case "rxbtnHorizOff"
            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
                If Selection.Rows.count > 1 Then
                    oUndoRecord.SetName "Clear Horizontal line"
                    Selection.Borders(wdBorderHorizontal).lineStyle = wdLineStyleNone
                Else
                    MsgBox "Please select at least 2 cells vertically", vbExclamation, "Table Format"
                End If

            End If
        
        Case "rxbtnShadeCell"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
'                oUndoRecord.SetName "Cell Shading"
'                Selection.Shading.Texture = wdTextureNone
'                Selection.Shading.ForegroundPatternColor = wdColorAutomatic
'                Selection.Shading.BackgroundPatternColor = cOrangeLight 'rgb(255,196,116)
'
'            End If
        
        Case "rxbtnClearCell"
            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
                oUndoRecord.SetName "Clear Cell Shading"
                Selection.Shading.Texture = wdTextureNone
                Selection.Shading.ForegroundPatternColor = wdColorAutomatic
                Selection.Shading.BackgroundPatternColor = wdColorWhite

            End If
        
        Case "BtnBrochetTableResetWidth"
            
            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", ReturnBoolean) Then
                oUndoRecord.SetName "Reset table width"
                oFrm.SetNewTable False
                oFrm.SetWidthOnly True
                oFrm.Show
            End If
            
        Case Else
            MsgBox "Callback to 'rxGrpTSUTables_onAction' with id '" & control.ID & "' not recognised.", vbInformation
            
    End Select
    
    oUndoRecord.EndRecording
    
    modScreenUpdating.ScreenUpdating_Enable
End Sub


'*******************************************************************************************************
'* Description: Creates or reformats a table
'* Parameters:  N/A
'* Returns:     N/A
'*******************************************************************************************************
'Sub BtnBrochetTables_onAction(control As IRibbonControl)
'    Dim sText As String
'    Dim oUndoRecord As cUndoRecord
'    Dim oFrm As frmNewTable
'    Dim allBordersOptions As cAllBordersOptions
'
'    modScreenUpdating.ScreenUpdating_Disable
'
'    Set oUndoRecord = New cUndoRecord
'    Set oFrm = New frmNewTable
'
'    Select Case control.ID
'
'        'Insert a new table
'        Case "BtnBrochetInsertTable"
'
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("SelectionOkForTableInsert", False) Then
'                oUndoRecord.SetName "New Table"
'                oFrm.TableFormMode = NewTable
'                oFrm.Show
'            End If
'
'        'Reformat the Whole Table
'        Case "BtnBrochetTableQuickReformat"
'            If Selection.Tables.count > 0 Then
'                If modTables.IsTableUnified(Selection.Tables(1), True, False) Then
'                    If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformat", False, Selection.Tables(1)) Then
'                        oUndoRecord.SetName "Reformating table"
'                        oFrm.TableFormMode = FullReformat
'                        Set oFrm.tTable = Selection.Tables(1)
'                        oFrm.Show
'                    End If
'                Else
'                    modError.DisplayMsg "A table cannot be reformatted if it contains vertically merged cells.", vbInformation, "Reformat Table"
'                End If
'            End If
'
'        'Reformat the Heading rows
'        Case "BtnBrochetTableHeading"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Heading"
'                modTables.TableSelectionReformat modColorThemes.SchemeColorProperty(modTables.TITLE_SHADING_INDEX - 1, modTables.TITLE_SHADING_TINT), True, _
'                                                New cAllBordersOptions, modTables.TABLE_STYLE_HEADING, FormatNone
'            End If
'
'        Case "BtnBrochetTableSubHeading"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Subheading"
'                modTables.TableSelectionReformat modColorThemes.SchemeColorProperty(modTables.LIGHT_BLUE_SHADING_INDEX - 1, modTables.LIGHT_BLUE_SHADING_TINT), True, _
'                                                New cAllBordersOptions, modTables.TABLE_STYLE_BOLD, FormatNone
'            End If
'        'Reformat the Total row
'        Case "BtnBrochetTableTotalRow"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Total row"
'                Set allBordersOptions = New cAllBordersOptions
'                allBordersOptions.TopBorderOptions.LineColour = modColorThemes.SchemeColorProperty(modTables.TOTAL_BORDER_COLOR_INDEX - 1, modTables.TOTAL_BORDER_COLOR_TINT)
'                allBordersOptions.TopBorderOptions.LineType = wdLineStyleSingle
'                allBordersOptions.TopBorderOptions.LineWidth = wdLineWidth225pt
'                modTables.TableSelectionReformat -1, True, allBordersOptions, modTables.TABLE_STYLE_TOTAL, FormatTotalRow
'            End If
'        Case "BtnBrochetTableTextNoBorders"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Table Text"
'                modTables.TableSelectionReformat -1, True, New cAllBordersOptions, modTables.TABLE_STYLE_TEXT
'            End If
'
'        Case "BtnBrochetTableHeadingSmall"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Heading"
'                modTables.TableSelectionReformat modColorThemes.SchemeColorProperty(modTables.TITLE_SHADING_INDEX - 1, modTables.TITLE_SHADING_TINT), True, _
'                                                New cAllBordersOptions, modTables.TABLE_STYLE_HEADING, FormatNone, True
'            End If
'        Case "BtnBrochetTableSubHeadingSmall"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Subheading"
'                modTables.TableSelectionReformat modColorThemes.SchemeColorProperty(modTables.LIGHT_BLUE_SHADING_INDEX - 1, modTables.LIGHT_BLUE_SHADING_TINT), True, _
'                                                New cAllBordersOptions, modTables.TABLE_STYLE_BOLD, FormatNone, True
'            End If
'        'Reformat the Total row
'        Case "BtnBrochetTableTotalRowSmall"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Total row"
'                Set allBordersOptions = New cAllBordersOptions
'                allBordersOptions.TopBorderOptions.LineColour = modColorThemes.SchemeColorProperty(modTables.TOTAL_BORDER_COLOR_INDEX - 1, modTables.TOTAL_BORDER_COLOR_TINT)
'                allBordersOptions.TopBorderOptions.LineType = wdLineStyleSingle
'                allBordersOptions.TopBorderOptions.LineWidth = wdLineWidth225pt
'                modTables.TableSelectionReformat -1, True, allBordersOptions, modTables.TABLE_STYLE_TOTAL, FormatTotalRow, True
'            End If
'        Case "BtnBrochetTableTextNoBordersSmall"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Reformat as Table Text"
'                modTables.TableSelectionReformat -1, True, New cAllBordersOptions, modTables.TABLE_STYLE_TEXT, FormatNone, True
'            End If
'
'        Case "BtnBrochetTableDarkShading"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Set Dark blue shading"
'                modTables.TableSelectionReformat modColorThemes.SchemeColorProperty(modTables.TITLE_SHADING_INDEX - 1, modTables.TITLE_SHADING_TINT), True
'            End If
'        Case "BtnBrochetTableLightShading"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Set light blue shading"
'                modTables.TableSelectionReformat modColorThemes.SchemeColorProperty(modTables.LIGHT_BLUE_SHADING_INDEX - 1, modTables.LIGHT_BLUE_SHADING_TINT), True
'            End If
'        Case "BtnBrochetTableGreyShading"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Set light grey shading"
'                modTables.TableSelectionReformat modColorThemes.SchemeColorProperty(modTables.LIGHT_GREY_SHADING_INDEX - 1, modTables.LIGHT_GREY_SHADING_TINT), True
'            End If
'        Case "BtnBrochetTableRemoveShading"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Remove all shading"
'                modTables.TableSelectionReformat -1, True
'            End If
'        Case "BtnBrochetTableResetWidth"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformat", False, Selection.Tables(1)) Then
'                oUndoRecord.SetName "Reset table width"
'                oFrm.TableFormMode = WidthReformat
'                Set oFrm.tTable = Selection.Tables(1)
'                oFrm.Show
'            End If
'                'Insert margins around text
'        Case "BtnBrochetTablesPadding"
'
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Add table cell margins"
'                modTables.TableParaMargins
'            End If
'
'        Case "BtnBrochetTableAlternatingShading"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Add table cell margins"
'                modTables.SetAlternatingRows Selection.Rows
'            End If
'
'        '+ve/-ve numbers
'        Case "BtnBrochetTablesPosNeg"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "+ve/-ve Number Cells"
'                modTables.ApplyFinancialStylesToRange Selection.Range, False
'            End If
'
'        'Selection Borders settings
'        'Grey Borders
'        Case "BtnBrochetTablesBordersInner"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting Grey Inner Borders"
'                modTables.SetSelectionBorders InnerBorders, modColorThemes.SchemeColorProperty(BORDER_COLOR_INDEX - 1, BORDER_COLOR_TINT)
'            End If
'        Case "BtnBrochetTablesBordersOuter"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting Grey Outer Borders"
'                modTables.SetSelectionBorders OuterBorders, modColorThemes.SchemeColorProperty(BORDER_COLOR_INDEX - 1, BORDER_COLOR_TINT)
'            End If
'        Case "BtnBrochetTablesBordersAll"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting Grey Borders"
'                modTables.SetSelectionBorders AllBorders, modColorThemes.SchemeColorProperty(BORDER_COLOR_INDEX - 1, BORDER_COLOR_TINT)
'            End If
'        Case "BtnBrochetTablesBordersBottom"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting Grey Bottom Border"
'                modTables.SetSelectionBorders BottomBorder, modColorThemes.SchemeColorProperty(BORDER_COLOR_INDEX - 1, BORDER_COLOR_TINT)
'            End If
'        'White Borders
'        Case "BtnBrochetTablesBordersWhiteInner"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting White Inner Borders"
'                modTables.SetSelectionBorders InnerBorders, RGB(255, 255, 255)
'            End If
'        Case "BtnBrochetTablesBordersWhiteOuter"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting White Outer Borders"
'                modTables.SetSelectionBorders OuterBorders, RGB(255, 255, 255)
'            End If
'        Case "BtnBrochetTablesBordersWhiteAll"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting White Borders"
'                modTables.SetSelectionBorders AllBorders, RGB(255, 255, 255)
'            End If
'        Case "BtnBrochetTablesBordersWhiteBottom"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Setting White Bottom Border"
'                modTables.SetSelectionBorders BottomBorder, RGB(255, 255, 255)
'            End If
'        'No Borders
'        Case "BtnBrochetTablesBordersNoneInner"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Removing Inner Borders"
'                modTables.SetSelectionBorders InnerBorders, 0, wdLineStyleNone
'            End If
'        Case "BtnBrochetTablesBordersNoneOuter"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Removing Outer Borders"
'                modTables.SetSelectionBorders OuterBorders, 0, wdLineStyleNone
'            End If
'        Case "BtnBrochetTablesBordersNoneAll"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Removing All Borders"
'                modTables.SetSelectionBorders AllBorders, 0, wdLineStyleNone
'            End If
'        Case "BtnBrochetTablesBordersNoneBottom"
'            If modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("TableOkToReformatSelectedCells", False) Then
'                oUndoRecord.SetName "Removing Bottom Border"
'                modTables.SetSelectionBorders BottomBorder, 0, wdLineStyleNone
'            End If
'        Case Else
'            MsgBox "Callback to 'BtnBrochetTables_onAction' with id '" & control.ID & "' not recognised.", vbInformation
'
'    End Select
'
'    oUndoRecord.EndRecording
'
'    modScreenUpdating.ScreenUpdating_Enable
'End Sub

'++********************************************************************
' Description:  Sets the enabled status of various ribbon controls
' Parameters:   control - the ribbon control name
'               visible - Visibility of the control
' Returns:      none
' TODO:         Make sure that all controls are covered and correct.
'--********************************************************************
 Sub RbnBrochetTable_getVisible(control As IRibbonControl, ByRef visible)
    visible = True
    Select Case control.ID
    Case "GrpBrochetTables"
        visible = modGlobalPublic.GlobalDirectivesSendMessageNoConfirmation("GrpBrochetTables_getVisible", False)

    Case Else
        visible = False
    End Select
End Sub

 Sub RbnBrochetTable_getEnabled(control As IRibbonControl, ByRef enabled)

    'TODO
    enabled = modGlobal.gbGlobalIsOk And Not modPrivate.DocCountZeroOrDocInProtectedView

End Sub

Attribute VB_Name = "modTableStyles"
'***********************************************************************************
'* Brochet Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modTableStyles
'*
'* Holds various macro code related to tables
'***********************************************************************************
Option Explicit
Option Private Module

Const msMODULE As String = "modTableStyles"


Public Const STYLE_TABLE_TEXT As String = "Table text"
Public Const STYLE_TABLE_TEXT_BOLD As String = "Table text bold"
'Public Const STYLE_TABLE_TEXT_INDENTED As String = "Table text indented"
Public Const STYLE_TABLE_HEADING As String = "Table heading"
'Public Const STYLE_TABLE_HEADING_INDENTED As String = "Table heading indented"
Public Const STYLE_TABLE_NUMB As String = "Table numb"
Public Const STYLE_TABLE_NUMB_BOLD As String = "Table numb bold"
Public Const STYLE_TABLE_HEADING_RIGHT As String = "Table heading right"

'Public Const STYLE_TABLE_TOTAL As String = "Table Total"



 Function AllStylesExist() As Boolean

    SetupTableDesigns
    
    If Not CheckStylesExist(TableMain) Then GoTo Missing
    If Not CheckStylesExist(TableFinancial) Then GoTo Missing
    'If Not CheckStylesExist(TableHighlightFirstColumn) Then GoTo Missing
    
    AllStylesExist = True
    Exit Function

Missing:

    AllStylesExist = False

End Function

Private Function CheckStylesExist(Design As tTableDesign) As Boolean

        With Design
    
            
            If Not TestStyle(.TitleStyle) Then GoTo Missing
            If Not TestStyle(.SourceStyle) Then GoTo Missing
            
            With .PlainGrid
                If Not TestStyle(.ParagraphStyle) Then GoTo Missing
                If Not TestStyle(.ParagraphStyleHeading) Then GoTo Missing

            End With
            
            With .HeadingRow
                If Not TestStyle(.ParagraphStyle) Then GoTo Missing
                If Not TestStyle(.ParagraphStyleHeading) Then GoTo Missing

            End With
    
            With .FirstColumn
                If Not TestStyle(.ParagraphStyle) Then GoTo Missing
                If Not TestStyle(.ParagraphStyleHeading) Then GoTo Missing

            End With
            
            With .LastColumn
                If Not TestStyle(.ParagraphStyle) Then GoTo Missing
                If Not TestStyle(.ParagraphStyleHeading) Then GoTo Missing

            End With
    
            With .TotalRow
                If Not TestStyle(.ParagraphStyle) Then GoTo Missing
                If Not TestStyle(.ParagraphStyleHeading) Then GoTo Missing

            End With
    
        End With

    CheckStylesExist = True
    Exit Function

Missing:

    CheckStylesExist = False


End Function


Private Function TestStyle(Style As String) As Boolean

    If Style = "" Then
        TestStyle = True
    Else
        TestStyle = TableStyleExists(Style)
    End If
    
End Function

'++*******************************************************************
' Procedure:    StyleExists
' Description:  Checks for the existence of a given style in the doc.
' Parameters:   sStyleName - Name of style to check.
' Returns:      True if it exists in the active doc.
'--********************************************************************
Function TableStyleExists(sStyleName As String) As Boolean

    Dim sText As String
    
    On Error Resume Next
    sText = ActiveDocument.Styles(sStyleName).NameLocal
    On Error GoTo 0
    
    TableStyleExists = sText <> vbNullString
    
End Function

 Function DebugCheckStylesExist(Design As tTableDesign) As Boolean

    On Error GoTo err

    With Design
        Debug.Print ""
        Debug.Print "======================================"
        Debug.Print .DisplayName
        Debug.Print "======================================"
        
        Debug.Print DebugTestStyle(.TitleStyle)
        Debug.Print DebugTestStyle(.SourceStyle)
        
        With .PlainGrid

            Debug.Print DebugTestStyle(.ParagraphStyle)
            Debug.Print DebugTestStyle(.ParagraphStyleHeading)
        End With
        
        With .HeadingRow
            Debug.Print DebugTestStyle(.ParagraphStyle)
            Debug.Print DebugTestStyle(.ParagraphStyleHeading)
        End With

        With .FirstColumn
            Debug.Print DebugTestStyle(.ParagraphStyle)
            Debug.Print DebugTestStyle(.ParagraphStyleHeading)
        End With
        
        With .LastColumn

            Debug.Print DebugTestStyle(.ParagraphStyle)
            Debug.Print DebugTestStyle(.ParagraphStyleHeading)
        End With

        With .TotalRow
            Debug.Print DebugTestStyle(.ParagraphStyle)
            Debug.Print DebugTestStyle(.ParagraphStyleHeading)
        End With

    End With

err:

End Function


 Sub DebugCheckAllStylesExist()

    SetupTableDesigns

    DebugCheckStylesExist TableMain
    DebugCheckStylesExist TableFinancial
    'DebugCheckStylesExist TableHighlightFirstColumn


End Sub

Private Function DebugTestStyle(Style As String) As String

    If Style <> "" Then
        DebugTestStyle = Style & " = " & StyleExists(Style)
    End If

End Function

Attribute VB_Name = "modTables"
'***********************************************************************************
'* Brochet Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modTables
'*
'* Holds various macro code related to tables
'***********************************************************************************
Option Explicit
Option Private Module



Const msMODULE As String = "modTables"


'++*******************************************************************
' Description:  Will check if the given table is unified (no merged cells)
' Parameters:   oTable - Table to be checked
'               checkRows - if true - Will check vertical merging
'               checkColumns - if true -  Will check horizontal merging
' Returns:      True if the table is unified, false otherwise
'--********************************************************************
Public Function IsTableUnified(oTable As Table, Optional checkRows As Boolean = True, Optional checkColumns As Boolean = True) As Boolean
    On Error GoTo ErrorHandler
    Dim oRow As Row
    Dim oCollumn As Column
    
    If checkRows Then
        For Each oRow In oTable.Rows
        Next
    End If
    
    If checkColumns Then
        For Each oCollumn In oTable.Columns
        Next
    End If
    
    IsTableUnified = True
    
CleanExit:
    Exit Function
ErrorHandler:
    IsTableUnified = False
    Resume CleanExit
End Function


'++*******************************************************************
' Description:  Will check if the selection is in a valid table
' Parameters:
' Returns:      True if the table is unified, false otherwise
'--********************************************************************
Function isSelectedTableOk() As Boolean

    If Selection.Range.Tables.count = 1 Then
        If Selection.Range.Tables(1).Title = "" Or Selection.Range.Tables(1).Title = COMPANY_NAME_NO_SPACE & "Table" Then

            isSelectedTableOk = True
            'if selection.Range.t
            If Selection.Tables(1).NestingLevel > 1 Then 'This only finds nested tables when the cursor is in it
                isSelectedTableOk = False
            End If
        Else
            isSelectedTableOk = False
        End If
    Else
        isSelectedTableOk = False
    End If


End Function


'++*******************************************************************
' Description:  Inserts a table at the current location
' Parameters:   iCols = Number of columns in the new table
'               iRows = Number of rows in the new table
'               iTableOpt = Enumerated options
' Returns:      n/a
'--********************************************************************
Sub InsertNewTable(tTableOpts As tTableDialogSettings, tDesign As tTableDesign, rRange As Range)

    Dim dTabWidth As Double
    Dim tTable As Table
    Dim sText As String
    
    'Set the new table width
    
    If Selection.PageSetup.TextColumns.count = 1 Then
        dTabWidth = rRange.PageSetup.PageWidth - rRange.PageSetup.LeftMargin - rRange.PageSetup.RightMargin
    Else
        dTabWidth = rRange.PageSetup.TextColumns(1).width
    End If

    'Add the table
    ActiveDocument.Tables.Add Range:=rRange, NumRows:=tTableOpts.Rows, NumColumns:=tTableOpts.Columns, DefaultTableBehavior:=wdWord8TableBehavior
    
    Set tTable = rRange.Tables(1)
    'Apply the formation to the new table
    
    TableReformat tTable, tTableOpts, tDesign

    setAltText tTable, tTableOpts
    
    'Now move to the second cell
    tTable.Cell(1, 1).Select
    rRange.Collapse wdCollapseStart

End Sub

'++*******************************************************************
' Description:  Inserts a table at the current location
' Parameters:   tTable = table object
'               dTableWidth = Width of table
'               iTableOpts = Integer containing the enumerated options for the table

' Returns:      n/a
'--********************************************************************
Sub TableReformat(tTable As Table, tTableOpts As tTableDialogSettings, tDesign As tTableDesign, Optional bDoNotResize As Boolean = False)

    Dim iRows As Integer
    Dim iLastRow As Integer
    Dim iCols As Integer
    Dim i As Integer
    Dim cCell As Cell
    Dim cColumn As Column
    Dim rRow As Row
    Dim lClr As Long
    Dim dTableColWidth As Double
    Dim dTableWidth As Double
    Dim iColumnWidth As Single
    
    'Used to defines optional styles
    'such as financial, font size font colour
    'This is added to every style name
    Dim sStyleSuffix As String

    'On Error GoTo err

    'Get the number of rows and columns
    iRows = tTable.Rows.count
    iCols = tTable.Columns.count


    SetPadding tTable, tDesign


    FormatTableOptions tTable, tTableOpts, tDesign
    
    If Not bDoNotResize Then
    
    
        tTable.PreferredWidthType = wdPreferredWidthPoints

        dTableWidth = GetTextColumnWidth
                
                
        If IsColumnRangeAccessible(tTable) = False Then
            If modError.DisplayMsg("Some of the cells have a different width to the other cells in the column. If you proceed with " & _
                        "adjusting the column widths then you will lose this cell formatting" & vbCr & vbCr & _
                        "Do you wish to proceed?", vbQuestion + vbYesNo) = VbMsgBoxResult.vbNo Then
                Exit Sub
            Else
                EqualiseColumns tTable
                
            End If
        End If
        
        Select Case tTableOpts.ColumnStyle
        Case eColumnTypes.tblcolFinancial

                For i = 2 To iCols
                    Set cColumn = tTable.Columns(i)
                    cColumn.width = CentimetersToPoints(TableFinancial.FixedColumnWidth)
                Next
                
                tTable.Columns(1).width = dTableWidth - ((iCols - 1) * CentimetersToPoints(TableFinancial.FixedColumnWidth))
    
        Case eColumnTypes.tblcolEven
        
                iColumnWidth = dTableWidth / iCols
                For i = 1 To iCols
                    Set cColumn = tTable.Columns(i)
                    cColumn.width = iColumnWidth
                Next

        Case eColumnTypes.tblcolFirstCol
    
                iColumnWidth = dTableWidth / iCols
                For i = 1 To iCols
                    Set cColumn = tTable.Columns(i)
                    cColumn.width = iColumnWidth
                Next
                
        End Select

    End If

clean:
    Exit Sub
err:
    Resume clean
    

End Sub

Sub FormatTableOptions(tTable As Table, tTableOpts As tTableDialogSettings, tDesign As tTableDesign)

            SetTableWidth tTable, tTableOpts, tDesign
    
            ApplyDesignToCells tTable.Range.Cells, tDesign.PlainGrid.Cells

            FormatAllCells tTable, tTableOpts, tDesign
            
            FormatVerticalBandedRows tTable, tTableOpts, tDesign
            FormatHorizontalBandedRows tTable, tTableOpts, tDesign
            FormatFirstColumn tTable, tTableOpts, tDesign, False
            FormatLastColumn tTable, tTableOpts, tDesign
            
            FormatHeadingRow tTable, tTableOpts, tDesign
            FormatTotalRow tTable, tTableOpts, tDesign

End Sub


Sub SetTableWidth(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign)

    
    tTable.PreferredWidthType = wdPreferredWidthPoints

    If TableDesign.LeftIndent = 0 Then
        
        If tTable.PreferredWidth = 9999999 Then
        'Need to set columns individuallt and proportionally
            tTable.PreferredWidthType = wdPreferredWidthPercent
            DoEvents
            tTable.PreferredWidthType = wdPreferredWidthPoints
            'Debug.Print tTable.PreferredWidth, tTable.Range.PageSetup.TextColumns(1).width
            
        End If

        tTable.PreferredWidth = tTable.Range.PageSetup.TextColumns(1).width
        
        tTable.Rows.LeftIndent = 0

    Else
        If tTable.Rows.LeftIndent <> TableDesign.LeftIndent Then
            tTable.Rows.LeftIndent = CentimetersToPoints(TableDesign.LeftIndent)
            tTable.PreferredWidth = tTable.Range.PageSetup.TextColumns(1).width - CentimetersToPoints(TableDesign.LeftIndent)

        End If
    End If


End Sub

Function GetTableWidth(tTable As Table) As Single

    Dim col As Column
    Dim width As Single
    Dim i As Integer
    
    tTable.PreferredWidthType = wdPreferredWidthPoints

    If tTable.PreferredWidth = 9999999 Then
        'Sum the columns
        If IsColumnRangeAccessible(tTable) Then
            For Each col In tTable.Columns
                width = width + col.PreferredWidth
            Next
        Else
            For i = 1 To tTable.Columns.count
                width = width + tTable.Cell(1, i).PreferredWidth
            Next
        End If
        GetTableWidth = width
    Else
        GetTableWidth = tTable.PreferredWidth
    End If


End Function

Function GetTextColumnWidth() As Long
'returns the width of the text column the seelction is in

    Dim iSecNo As Integer
    Dim iCol As Integer
    Dim x1 As Long
    Dim x2 As Long
    Dim rRange As Range
   
    '!!!!!!!!!!!!!!!Assumes single column or evenly spaced columns
    
    With Selection

'        If .PageSetup.TextColumns.count > 1 Then
'            If .PageSetup.TextColumns.EvenlySpaced Then
'                GetTextColumnWidth = .PageSetup.TextColumns(1).width
'            Else
''                Set rRange = .Range.Paragraphs(1).Range
''                rRange.Collapse wdCollapseStart
''                x1 = rRange.Information(wdHorizontalPositionRelativeToPage)
''                Set rRange = .Range.Paragraphs(1).Range
''                rRange.Collapse wdCollapseEnd
''                x2 = rRange.Information(wdHorizontalPositionRelativeToPage)
''                GetTextColumnWidth = x2 - x1
''                'iCol = rRange.Information(wdStartOfRangeColumnNumber)
'            End If
'        Else
'
            GetTextColumnWidth = .PageSetup.TextColumns(1).width
        
'        End If
        
        
        
    End With
    

End Function


Sub FormatHeadingRow(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign)


    If tTableOpts.Heading Then
        Dim iRow As Integer
        Dim rHeadingRows As Range
        Set rHeadingRows = tTable.Rows(1).Range
        
        
        ApplyDesignToCells rHeadingRows.Cells, TableDesign.HeadingRow.Cells
        
            tTable.Rows(1).Range.Style = TableDesign.HeadingRow.ParagraphStyle
            tTable.Rows(1).HeadingFormat = True

        If TableDesign.HeadingRow.ParagraphStyleHeading <> "" Then

            tTable.Cell(1, 1).Range.Style = TableDesign.HeadingRow.ParagraphStyleHeading
        End If
    End If
    

End Sub
Sub FormatFirstColumn(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign, Optional bForceFormatting As Boolean = False)


'    If (tTableOpts.FirstColumn And TableDesign.TableDialogEnabledOptions.FirstColumn = True) Or bForceFormatting Then
    If tTableOpts.FirstColumn Or bForceFormatting Then
        Dim iCol As Integer
        Dim iRow As Integer
        Dim rFirstColumn As Range
        Dim csCells As Cells
        Dim csCell As Cell
        Dim cCell As Cell
        Dim i As Integer
        'Set rFirstColumn = tTable.Columns(
        iCol = 1
        
        If IsColumnRangeAccessible(tTable) Then
            Set csCells = tTable.Columns(1).Cells
            ApplyDesignToCells csCells, TableDesign.FirstColumn.Cells
            
            For Each cCell In csCells
                cCell.Range.Style = TableDesign.FirstColumn.ParagraphStyle
            Next
        Else
            'Cannot access columns so do them cell by cell
            Set csCell = tTable.Cell(1, 1)
            ApplyDesignToIndividualCell csCell, TableDesign.FirstColumn.Cells, True
            csCell.Range.Style = TableDesign.FirstColumn.ParagraphStyle
            For i = 2 To tTable.Rows.count
                Set csCell = tTable.Cell(i, 1)
                ApplyDesignToIndividualCell csCell, TableDesign.FirstColumn.Cells
                csCell.Range.Style = TableDesign.FirstColumn.ParagraphStyle
            Next
            Set csCell = tTable.Cell(i + 1, 1)
            ApplyDesignToIndividualCell csCell, TableDesign.FirstColumn.Cells, False, True
            csCell.Range.Style = TableDesign.FirstColumn.ParagraphStyle
        End If
        
        If TableDesign.FirstColumn.ParagraphStyleHeading <> "" Then
            tTable.Cell(1, 1).Range.Style = TableDesign.FirstColumn.ParagraphStyleHeading
        End If
        
    End If
    

End Sub

Function IsColumnRangeAccessible(tTable As Table) As Boolean

    On Error GoTo err
    Dim iIndex As Integer
    
    iIndex = tTable.Columns(1).Index
    
    IsColumnRangeAccessible = True
    Exit Function
err:
    
    IsColumnRangeAccessible = False

End Function

Sub FormatLastColumn(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign)


    If tTableOpts.LastColumn Then
        Dim iCol As Integer
        Dim iRow As Integer
        Dim csCells As Cells
        Dim cCell As Cell
        'Dim rLastColumn As Range
        
        If IsColumnRangeAccessible(tTable) Then
        
            iCol = tTable.Columns.count
            
            Set csCells = tTable.Columns(iCol).Cells
            ApplyDesignToCells csCells, TableDesign.LastColumn.Cells
            
            For Each cCell In csCells
                cCell.Range.Style = TableDesign.LastColumn.ParagraphStyle
            Next
        Else
            modError.DisplayMsg "The formatting of the last column is not available when there are individually sized cells"
        End If
        
        If TableDesign.LastColumn.ParagraphStyleHeading <> "" Then
            tTable.Cell(1, iCol).Range.Style = TableDesign.LastColumn.ParagraphStyleHeading
        End If
    End If

End Sub

Sub FormatAllCells(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign)


    If tTableOpts.NewTable Then
        ClearFormattingInTable tTable
        tTable.Range.Style = TableDesign.PlainGrid.ParagraphStyle
        tTable.Rows.AllowBreakAcrossPages = TableDesign.PlainGrid.AllowBreakAcrossPages
    End If
    

End Sub

Sub ClearFormattingInTable(tTable As Table)

    On Error Resume Next

        tTable.Range.Select
        Selection.ClearCharacterDirectFormatting
        Selection.ClearParagraphAllFormatting

End Sub

Sub FormatTotalRow(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign)

    If tTableOpts.TotalRow Then
        ApplyDesignToCells tTable.Rows(tTable.Rows.count).Cells, TableDesign.TotalRow.Cells
        tTable.Rows(tTable.Rows.count).Range.Style = TableDesign.TotalRow.ParagraphStyle
        If TableDesign.TotalRow.ParagraphStyleHeading <> "" Then
            tTable.Cell(tTable.Rows.count, 1).Range.Style = TableDesign.TotalRow.ParagraphStyleHeading
        End If
    End If
    

End Sub

Sub FormatHorizontalBandedRows(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign)


    Dim iStartRow As Integer
    Dim iRow As Integer
    
    If tTableOpts.HorizontalBanding Then
            iStartRow = 1

        For iRow = iStartRow To tTable.Rows.count Step 2
            ApplyDesignToCells tTable.Rows(iRow).Cells, TableDesign.BandedRow
        Next
    End If
    

End Sub
Sub FormatVerticalBandedRows(tTable As Table, tTableOpts As tTableDialogSettings, TableDesign As tTableDesign)


    Dim iStartCol As Integer
    Dim iCol As Integer
    Dim iStartRow As Integer
    'TODO
    If tTableOpts.VerticalBanding Then
        If IsColumnRangeAccessible(tTable) Then
            iStartCol = 1
            For iCol = iStartCol To tTable.Columns.count Step 2
                ApplyDesignToCells tTable.Columns(iCol).Cells, TableDesign.BandedColumn
            Next
        Else
            modError.DisplayMsg "The formatting of vertically banded rows is not available when there are individually sized cells"
        End If
    End If
    

End Sub

Sub FormatBandedCells(cCells As Cells, TableDesign As tTableDesign)


    Dim iStartRow As Integer
    Dim iRow As Integer
    
    Dim cTemp As Cell

    For Each cTemp In cCells
        If Not cTemp.RowIndex Mod 2 = 0 Then
            ApplyDesignToCells cTemp.Range.Cells, TableDesign.BandedRow
        End If
    Next

    

End Sub



'Sub SetTableWidth(tTable As Table)
'    'Set to 100%
'
'    On Error GoTo err
'
'    tTable.PreferredWidthType = wdPreferredWidthPercent
'    tTable.PreferredWidth = 100
'
'
'clean:
'
'
'Exit Sub
'err:
'
'Resume clean
'
'End Sub


'++*******************************************************************
' Procedure:    TableSelectionReformat
' Description:  Inserts a table at the current location
' Parameters:   sReformatOptions = treformatting options picked up from
'               tag in the control
' Returns:      n/a
'--********************************************************************
Sub TableSelectionReformat(sReformatOptions As String)

    Dim cCell As Cell
    Dim iRows As Integer
    Dim iCols As Integer
    Dim sParagraphStyle As String
    Dim sBorders As String
    Dim sCellFormat As String
    Dim sTextSize As String
    Dim sTotal As String
    Dim iCount As Integer
    Dim iStartRowNo As Integer
    Dim sSectionType As String
    Dim iRowStartNo As Integer
    Dim lClr As Long
    'Dim tTableDesign As tTableDesign
    
    'Break down the formating information into the components
    iCount = Len(sReformatOptions) - Len(Replace(sReformatOptions, "|", ""))
    sParagraphStyle = Split(sReformatOptions, "|")(0)
    If iCount >= 1 Then
        sBorders = Split(sReformatOptions, "|")(1)
    End If
    If iCount >= 2 Then
        sCellFormat = Split(sReformatOptions, "|")(2)
    End If
    
    'Dsiable screen updating
    modScreenUpdating.ScreenUpdating_Disable

    iRows = Selection.Rows.count
    iCols = Selection.Columns.count

    Dim cCells As Cells
    'Set cCells = Selection.Range.Cells
    Set cCells = Selection.Cells

    modTableDesign.SetupTableDesigns
    
    Select Case sBorders

        Case Is = "Borders"
            ApplyDesignToCells cCells, TableMain.PlainGrid.Cells
                        
        Case Is = "Padding"
            SetPadding Selection.Tables(1), TableMain
            
        Case Is = "Convert"
            SetPadding Selection.Tables(1), TableMain
            ApplyDesignToCells cCells, TableMain.PlainGrid.Cells
            
    End Select


    
    Select Case sCellFormat
        Case "TableBanded"
            FormatBandedCells cCells, TableMain
        Case "TableBlank"
            ApplyDesignToCells cCells, TableMain.PlainGrid.Cells
        Case "White"
            ApplyDesignToCells cCells, TableMain.PlainGrid.Cells
'        Case "DarkGrey"
'            ApplyDesignToCells cCells, TableHighlightFirstColumn.FirstColumn.Cells
        Case "LightGrey"
            ApplyDesignToCells cCells, TableMain.PlainGrid.Cells
            ShadeCell cCells, RGB(230, 236, 241) ' TODO - I have no reference for this
        
        Case "TableTotal"
            ApplyDesignToCells cCells, TableFinancial.TotalRow.Cells
            
        Case "TableHeading"
            ApplyDesignToCells cCells, TableMain.HeadingRow.Cells
            
        Case "TableBody"
            ApplyDesignToCells cCells, TableMain.PlainGrid.Cells
            
            
    End Select

    'Apply the style and shading
    Dim cTemp As Cell
    If LenB(sParagraphStyle) <> 0 Then
        For Each cTemp In cCells
            cTemp.Range.Style = sParagraphStyle
        Next
    End If

    modScreenUpdating.ScreenUpdating_Enable

End Sub



Sub SetPadding(tTable As Table, tDesign As tTableDesign)

        With tTable
            .TopPadding = CentimetersToPoints(tDesign.Padding.Top)
            .BottomPadding = CentimetersToPoints(tDesign.Padding.Bottom)
            .LeftPadding = CentimetersToPoints(tDesign.Padding.Left)
            .RightPadding = CentimetersToPoints(tDesign.Padding.Right)
            .Spacing = 0
            .AllowPageBreaks = True
            .AllowAutoFit = False
            .ApplyStyleFirstColumn = False

        End With

End Sub
''
''Clears All borders in a table and adds top and/or bottom orange if chosen
''
'Sub SetBorders(sRange As Range, bTop As Boolean, bBottom As Boolean)
'
'
'        With sRange.Cells
'            .Borders(wdBorderLeft).lineStyle = wdLineStyleNone
'            .Borders(wdBorderRight).lineStyle = wdLineStyleNone
'            .Borders.Shadow = False
'
'            If bTop Then
'                With .Borders(wdBorderTop)
'                    .lineStyle = wdLineStyleSingle
'                    .color = cOrange
'                End With
'            Else
'                .Borders(wdBorderTop).lineStyle = wdLineStyleNone
'            End If
'
'            If bBottom Then
'                With .Borders(wdBorderBottom)
'                    .lineStyle = wdLineStyleSingle
'                    .color = cOrange
'                End With
'            Else
'                .Borders(wdBorderBottom).lineStyle = wdLineStyleNone
'            End If
'
'            On Error Resume Next
'            SetBorder .Borders(wdBorderVertical), wdLineStyleNone, 0
'            err.Clear
'            SetBorder .Borders(wdBorderHorizontal), wdLineStyleSingle, cOrange
'        End With
'
'        err.Clear
'
'End Sub

Private Sub SetBorder(oBorder As Border, lineStyle As WdLineStyle, color As Double)
    On Error GoTo ErrorHandler
    With oBorder
         .lineStyle = lineStyle
         If lineStyle <> wdLineStyleNone Then
            .color = color
        End If
    End With
    
CleanExit:
    Exit Sub
ErrorHandler:
    Resume CleanExit:
End Sub

'++*******************************************************************
' Procedure:    ResetTableWidth
' Description:  Resets the width of the table to the passed values
' Parameters:   tTable = table object
'               dTableWidth = Width of table
'               dTableLeftIndent = Left indent of table
' Returns:      Parent table
'--********************************************************************
'Sub ResetTableWidth(tTable As Table, dTableWidth As Double, dIndent As Double)
'
'    'Dim tTable As Table
'    'Dim dTabWidth As Double
'
'    'Set an object to point to the current table
'    Set tTable = Selection.Tables(1)
'
'    If Selection.Tables(1).Rows.WrapAroundText = False Then
'
'        'Disable screen updating
'        modScreenUpdating.ScreenUpdating_Disable
'
''        If Selection.PageSetup.TextColumns.Count = 1 Then
''            dTabWidth = Selection.PageSetup.PageWidth - Selection.PageSetup.LeftMargin - Selection.PageSetup.RightMargin + CentimetersToPoints(TAB_ADDITIONAL_WIDTH)
''        Else
''            dTabWidth = Selection.PageSetup.TextColumns(1).Width + CentimetersToPoints(TAB_ADDITIONAL_WIDTH)
''        End If
'        If dTableWidth > 0 Then tTable.PreferredWidth = dTableWidth
'
'        tTable.Rows.LeftIndent = CentimetersToPoints(dIndent)
'
'        If dTableWidth > 0 Then tTable.PreferredWidth = dTableWidth
'
'        'Disable screen updating
'        modScreenUpdating.ScreenUpdating_Enable
'    Else
'        MsgBox "The Table is a floating table and the reformatting feature will not work!", vbInformation, "Reformat table"
'    End If
'
'End Sub


'++*******************************************************************
' Procedure:    GetParentCellWidth
' Description:  Get the parent cell width of a table in a table
' Parameters:   N/A
' Returns:      The width of the cell in points
'--********************************************************************
Function GetParentCellWidth() As Double

    Dim tTable As Table
    Dim tParentTable As Table
    Dim cCell As Cell
    Dim bResult As Boolean
    Dim rCellRange As Range

    Set tTable = Selection.Tables(1)
    'Get the parent table
    Set tParentTable = GetParentTable(1, tTable)
    
    'Now cycle through all the cell to find the one which contains the currently selected table
    If Not tParentTable Is Nothing Then
        'tParentTable.Select
        'MsgBox "No of columns = " & tParentTable.Columns.Count
        For Each cCell In tParentTable.Range.Cells
            If cCell.Range.Tables.count > 0 Then
                Set rCellRange = cCell.Range
                bResult = tTable.Range.InRange(rCellRange)
                If bResult Then
                    GetParentCellWidth = cCell.width
                    Exit For
                End If
            End If
        Next
    End If

End Function

'++*******************************************************************
' Procedure:    GetParentTable
' Modified:
' Description:  Returns the parent table if their is one
' Parameters:   nLevel = level of parent table to find
' Returns:      Parent table
'--********************************************************************
Function GetParentTable(nLevel As Integer, tSelectedTable As Table) As Table

    Dim oSelectionTable As Table
    Dim nNestingLevel As Integer
    Dim oRange As Range
    
    If tSelectedTable Is Nothing Then
        MsgBox "No table passed to function"
    Else
        If tSelectedTable.NestingLevel > nLevel Then
            'Select the first cell in the table and then move a character at a time to the left until in the parent table
            nNestingLevel = tSelectedTable.NestingLevel
            Set oRange = tSelectedTable.Range.Cells(1).Range.Characters(1)
            
            Do While nNestingLevel > nLevel
                oRange.MoveStart Unit:=wdCharacter, count:=-1
                nNestingLevel = oRange.Tables(1).NestingLevel
            Loop
            
            Set GetParentTable = oRange.Tables(1)
        End If
    
    End If

End Function

'++*******************************************************************
' Procedure:    InsertTextIntoCell
' Modified:
' Description:  Returns the parent table if their is one
' Parameters:   nLevel = level of parent table to find
' Returns:      Parent table
'--********************************************************************
Sub InsertTextIntoCell(tTable As Table, iRow As Integer, iCol As Integer, sText As String)

    Dim rRange As Range
    On Error GoTo InsertTextIntoCell_Error
    Set rRange = tTable.Cell(iRow, iCol).Range
    rRange.End = rRange.End - 1
    rRange.text = sText

InsertTextIntoCell_Error:

End Sub

Sub setAltText(tTable As Table, tTableOpts As tTableDialogSettings)
    
    Dim sText As String
    'Mark the table using Alternative text so can set options when reformat
    
    'MAKE SURE THESE ARE UNIQUE!!!!!
    
    tTable.Title = COMPANY_NAME_NO_SPACE & "Table"
    

    sText = "Standard" ' ERA has single size table

    With tTableOpts
    
  
    
        Select Case .ColumnStyle
        Case eColumnTypes.tblcolEven
            sText = sText & "|Even"
        Case eColumnTypes.tblcolFinancial
            sText = sText & "|Financial"
        Case eColumnTypes.tblcolFirstCol
            sText = sText & "|ShadeFirstCol"
        Case eColumnTypes.tblcolNone
            sText = sText & "|None"
        End Select
        
        If .Heading Then
            sText = sText & "|" & "HeadingRow"
        Else
            sText = sText & "|NoHeading"
        End If
        
        If .HorizontalBanding Then
            sText = sText & "|BandedRow"
        Else
            sText = sText & "|NoBandedRow"
        End If
        
        If .TotalRow Then
            sText = sText & "|Total"
        Else
            sText = sText & "|NoTotal"
        End If
        
        If .FirstColumn Then
            sText = sText & "|FirstColumn"
        Else
            sText = sText & "|NoFirstColumn"
        End If
        
        If .VerticalBanding Then
            sText = sText & "|BandedColumn"
        Else
            sText = sText & "|NoBandedColumn"
        End If
        
        If .LastColumn Then
            sText = sText & "|LastColumn"
        Else
            sText = sText & "|NoLastColumn"
        End If
        
        sText = sText & "|NormalFont"

    End With
    tTable.Descr = sText

End Sub

Function GetAltText(tTable As Table) As tTableDialogSettings

    Dim tTableOpts As tTableDialogSettings


    Dim sDesc As String
    
    sDesc = tTable.Descr

    With tTableOpts
        .Rows = tTable.Rows.count
        .Columns = tTable.Columns.count
        
        If InStr(1, sDesc, "Financial") Then .ColumnStyle = tblcolFinancial
        If InStr(1, sDesc, "ShadeFirstCol") Then .ColumnStyle = tblcolFirstCol
        If InStr(1, sDesc, "Even") Then .ColumnStyle = tblcolEven
        
        .Heading = IIf(InStr(1, sDesc, "NoHeading"), False, True)
        .HorizontalBanding = IIf(InStr(1, sDesc, "NoBandedRow"), False, True)
        .TotalRow = IIf(InStr(1, sDesc, "NoTotal"), False, True)
        
        .FirstColumn = IIf(InStr(1, sDesc, "NoFirstColumn"), False, True)
        .VerticalBanding = IIf(InStr(1, sDesc, "NoBandedColumn"), False, True)
        .LastColumn = IIf(InStr(1, sDesc, "NoLastColumn"), False, True)
    End With
        

    GetAltText = tTableOpts
    


End Function



Sub ShadeCell(cCells As Cells, lColour As Long)


    cCells.Shading.BackgroundPatternColor = lColour



End Sub


'++*******************************************************************
' Description:  Applies a 'Neg' Style to (negative) numbers
'--********************************************************************
Public Sub zPosNegCells()
    Dim sText As String
    Dim cCell As Cell
    Dim pPara As Paragraph
    Dim rRange As Range
    Dim bTotalRow As Boolean
    Dim bTblHasTotals As Boolean
    Dim sStyle As String
    
    bTblHasTotals = InStr(Selection.Tables(1).Descr, "|Total")
    For Each cCell In Selection.Cells
        bTotalRow = cCell.RowIndex = Selection.Tables(1).Rows.count And bTblHasTotals = True
        For Each pPara In cCell.Range.Paragraphs
            If Not Right(pPara.Style, 3) = "Neg" Then
            
                Set rRange = pPara.Range
                rRange.End = rRange.End - 1
                If Len(rRange) > 0 Then
                    If Right$(rRange.text, 1) = ")" Then
                        sStyle = pPara.Style & " Neg"
                        If StyleExists(sStyle) Then pPara.Style = sStyle
                    End If
                End If
            End If
        Next
    Next
End Sub


Function AppendixExistsBefore(rRange) As Boolean

    Dim rSearch As Range
    Dim ccControl As ContentControl
    
    Set rSearch = rRange.Duplicate
    rSearch.Collapse WdCollapseDirection.wdCollapseStart
    rSearch.Start = 1
    
    AppendixExistsBefore = False
    
    For Each ccControl In rSearch.ContentControls
        If ccControl.Tag = "Section Group" Then
            If InStr(1, ccControl.Title, "Append") Then
                AppendixExistsBefore = True
                Exit For
            End If
        End If
    Next
    
    

End Function


Sub ShadeRow()

    Dim cTemp As Cell
    Dim cRow As Row
    On Error Resume Next
    
    For Each cRow In Selection.Range.Rows
        With cRow
            If .Shading.BackgroundPatternColor = cTableShadeLtGreen Then
                .Shading.BackgroundPatternColor = wdColorWhite
            Else
                .Shading.BackgroundPatternColor = cTableShadeLtGreen
            End If
            
        End With
        
    Next

End Sub


Sub ShadeCells()

    Dim cCell As Cell
    On Error Resume Next
    For Each cCell In Selection.Cells
        With cCell
            If .Shading.BackgroundPatternColor = cTableShadeLtGreen Then
                .Shading.BackgroundPatternColor = wdColorWhite
            Else
                .Shading.BackgroundPatternColor = cTableShadeLtGreen
            End If
            
        End With
        
    Next


End Sub


Sub HighlightCells()

    Dim cCell As Cell

    On Error Resume Next

    For Each cCell In Selection.Cells
        With cCell
            .Borders.OutsideLineStyle = wdLineStyleSingle
            .Borders.OutsideLineWidth = wdLineWidth150pt
            .Borders.OutsideColor = RGB(245, 156, 0) 'wdColorGold

        End With
        
    Next

End Sub

Sub EqualiseColumns(tTable As Table)
    'set all cells to 2cm width
    'It is expected that there will be additional formatiing after this.
    'This routine just removes any individual cell widths so VBA can access the Columns range
    
    Dim cCell As Cell
    
    For Each cCell In tTable.Range.Cells
        With cCell
            .PreferredWidthType = wdPreferredWidthPoints
            .PreferredWidth = CentimetersToPoints(2)
            .width = CentimetersToPoints(2)
        End With
    Next


End Sub
Attribute VB_Name = "modTemplate"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modTemplate
'*
'* Holds code that needs to run when template is loaded.
'***********************************************************************************
Option Explicit
Option Private Module

Public Sub CheckTemplate()
'Converts Flyer to Commentary
'Checks the attached template of the document
'and changes it to Commentary if it is based on the original flyer

'This is run on Global Startup
'   and when opening a document

    Dim strPath As String
    Dim sText() As String
    Dim iArrayCount As Integer
    Dim sTemplate As String
    Dim sNewTemplate As String
    
    On Error GoTo err
    
    strPath = Dialogs(wdDialogToolsTemplates).Template

    If Not strPath = "" Then
        sText = Split(strPath, "\")
        iArrayCount = UBound(sText)
        
        sTemplate = sText(iArrayCount)

        Select Case sTemplate
        Case "Insight Flyer.dotm"
            'Attach template Commentary
            sNewTemplate = ExpandString(gsTemplatePath) & "\Insight Commentary.dotm"

            If FileExists(sNewTemplate) Then
                ActiveDocument.AttachedTemplate = sNewTemplate
            Else
                err.Raise 513
            End If
        Case "Insight Commentary.dotm"
            If Not modPrivate.StyleExists("Header AllCaps") Then
                modError.DisplayMsg "This document is based on an old template" & vbCrLf & vbCrLf & _
                    "Please click on the Reset styles icon in the Utilities group on the Insight ribbon to re-attach the latest template"
            End If
        Case "Insight RFP.dotm"
            If Not modPrivate.StyleExists("Header White AllCaps") Then
                modError.DisplayMsg "This document is based on an old template" & vbCrLf & vbCrLf & _
                    "Please click on the Reset styles icon in the Utilities group on the Insight ribbon to re-attach the latest template"
            End If
        End Select
    End If

clean:
    
    Exit Sub
    
err:
    
    modError.DisplayMsg "There was a a problem attching this old document to 'Insight Commentary' template" & vbCrLf & vbCrLf & _
                    "Please click on the paperclip icon in the Utilities group on the Insight ribbon to re-attach the correct template"
    Resume clean

End Sub
    
Attribute VB_Name = "modWordStartup"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modWordStartup
'*
'* Holds code that needs to run when template is loaded.
'***********************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modWordStartup"

'*******************************************************************************************************
'* Description: To be run when the template is loaded. This is called from ribbon initilization.
'* Parameters:  N/A
'* Returns:     N/A
'*******************************************************************************************************
Public Sub WordStartup()
    Dim sText As String
    
    ' Set the Global is not corrupt variable. This is not set to true enywhere else, and if it's value defaults to false
    ' we can be sure, that the state of the template has been lost, or there was a good reason to disable template functionality
    modGlobal.gbGlobalIsOk = True
    
    'Temporary message until main ini found
    gsItSupport = "Please inform IT Support."
    
    'Set event handler for Word.Application
    modEventsInitialise.CreateEventHandler
    
    gsIniFilePathAndName = modINI.GetIniFilePath()
    
    RemoveOldMenuXMLFiles
    
    If LenB(gsIniFilePathAndName) = 0 Then
        modError.DisplayMsg "The main system ini file '" & modGlobal.COMPANY_INI_FILE_NAME & "' cannot be found", vbCritical, , True
    Else
        modINI.TryGetIniFileSetting gsIniFilePathAndName, "CompanyDetails", "ITSupport", gsItSupport

        ' Check the NewDocumentMenu directory
        sText = System.PrivateProfileString(gsIniFilePathAndName, "NewDocumentMenu", "Location")
        
        If modPrivate.FolderExists(sText) Then
            modGlobal.gsTemplatePath = sText
        Else
            modError.DisplayMsg "The menu directory is set in the ini file to use the location '" & sText & _
                               "' for templates but that location does not exist.", vbCritical, , True
            modGlobal.gsTemplatePath = vbNullString
        End If
    End If
    
    modPrivate.TurnOffOpenAsReadingPane
    modRibbon.InvalidateRibbon
    If Application.Documents.count = 1 Then
        modTemplate.CheckTemplate
    End If
End Sub

Private Sub RemoveOldMenuXMLFiles()
    Dim nfso As ClsNotFileSystemObject
    Dim xmlFiles As Collection
    Dim i As Integer
    
    Set nfso = New ClsNotFileSystemObject
    Set xmlFiles = nfso.SearchForFiles("%TEMP%", "*BlMenu.xml", False)
    'Delete any saved, menu, xml text files so that they are re-created afresh
    
    For i = 1 To xmlFiles.count
        'If there are any menu xml files, delete them
        Kill xmlFiles(i)
    Next
End Sub


' InQuest injected base64 decoded content
' Szjej
' Szjej
' ^Z'm
' ~`ZrD
' '!zg
' bzWN
' zjej
' zjej
' zjej
' jTbm
' 't(Z
' QbzWB
' !.+-	
' )^"{
' )^"{
' Szjej
' zj/y(Zv)
' jw"jT
' (^r@%
' jZ N

INQUEST-PP=macro
