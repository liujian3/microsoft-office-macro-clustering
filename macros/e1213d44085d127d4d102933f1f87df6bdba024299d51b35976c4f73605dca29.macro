Attribute VB_Name = "Animation"
Option Explicit ' Generate errors if declarations are not explicit

Private Enum EAnimationState
    NotRunning = 0
    Running = 1
End Enum
Private m_AnimationState As EAnimationState

Property Get IsRunning() As Boolean
    If (m_AnimationState = EAnimationState.Running) Then
        IsRunning = True
    Else
        IsRunning = False
    End If
End Property

Public Function IsParticleSizeAnimationSheet() As Boolean
    If (Range("A1").Text = "ParticleSizeAnimation") Then IsParticleSizeAnimationSheet = True Else IsParticleSizeAnimationSheet = False
End Function

Public Function IsRingAnimationSheet() As Boolean
    If (Range("A1").Text = "RingAnimation") Then IsRingAnimationSheet = True Else IsRingAnimationSheet = False
End Function

Public Sub CreateParticleAnimationSheet()

    Dim m_Animation As CAnimation
    Set m_Animation = New CAnimation
    
    Dim file_spec As CFileSpec
    Set file_spec = New CFileSpec
    Call file_spec.ConfigureDataSource(DmsFile, ParticleSizeData)
    Call m_Animation.SetFileSpec(file_spec)
    
    ' Template parameters
    Dim template As CTemplateSpec
    Set template = New CTemplateSpec
    Call template.SetAsParticleSize
    Call m_Animation.SetTemplateSpec(template)
    
    m_Animation.CreateAnimationSheet (file_spec.IsAlreadyWeighted)
    
        
End Sub

Public Sub CreateRingAnimationSheet()

    Dim m_Animation As CAnimation
    Set m_Animation = New CAnimation
    
    Dim file_spec As CFileSpec
    Set file_spec = New CFileSpec
    Call file_spec.ConfigureDataSource(DmsFile, RingCurrentData)
    Call m_Animation.SetFileSpec(file_spec)
    
    ' Template parameters
    Dim template As CTemplateSpec
    Set template = New CTemplateSpec
    Call template.SetAsRingCurrent
    Call m_Animation.SetTemplateSpec(template)
        
    m_Animation.CreateAnimationSheet (False)
End Sub

Public Sub CreateDmeAnimationSheet()
    Dim m_Animation As CAnimation
    Set m_Animation = New CAnimation
    
    Dim file_spec As CFileSpec
    Set file_spec = New CFileSpec
    Call file_spec.ConfigureDataSource(DmeFile, RingCurrentData)
    Call m_Animation.SetFileSpec(file_spec)

    ' Template parameters
    Dim template As CTemplateSpec
    Set template = New CTemplateSpec
    Call template.SetAsRingCurrent
    Call m_Animation.SetTemplateSpec(template)

    m_Animation.CreateAnimationSheet (False)
End Sub

Public Sub StopAnimation()
    If (Cells(1, 1) <> "ParticleSizeAnimation" And Cells(1, 1) <> "RingAnimation") Then
        Call MsgBox("Starting and Stopping animations can only be done from an animation sheet", vbCritical, Globals.AddInName)
        Exit Sub
    End If
    If (IsRunning) Then
        m_AnimationState = EAnimationState.NotRunning
    End If
End Sub

Public Sub PlayAnimation()

    If (Cells(1, 1) <> "ParticleSizeAnimation" And Cells(1, 1) <> "RingAnimation") Then
        Call MsgBox("Starting and Stopping animations can only be done from an animation sheet", vbCritical, Globals.AddInName)
        Exit Sub
    End If
    If (IsRunning) Then
        Exit Sub
    Else
        m_AnimationState = EAnimationState.Running
    End If
    
    ChangeInfoTextOnPlay
        
    On Error GoTo errorhandler
    
    'this one runs at whatever speed you specify
    'the time interval (s) between rows of data is the timeStep in A21
    'if the computer can't keep up, it advances more than one row at a time
    'you have to stop it with escape.
        
    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = True ' VISTA
    
    Dim Speed As Double, Interval As Double, Length As Long, starttime As Double, stoptime As Double
    Dim temp As Long
    Speed = ActiveSheet.Range("speed").Value
    If (Speed < 1) Then Speed = 1
    Interval = ActiveSheet.Range("interval").Value
    If (Interval = 0) Then Interval = 0.1
    Length = ActiveSheet.Range("length").Value
    starttime = Timer() - ActiveSheet.Range("step").Value * (Interval / Speed)
    stoptime = starttime + (Interval / Speed) * Length
    Do While Timer() < stoptime
        temp = Int((Timer() - starttime) / (Interval / Speed))
        ActiveSheet.Range("step").Value = temp
        
        DoEvents
        
        If (m_AnimationState = EAnimationState.NotRunning) Then GoTo errorhandler

        If (temp > Length - 26) Then ' 26 is the number of timeslices in the animation
            ChangeInfoTextOnStop
            m_AnimationState = EAnimationState.NotRunning
            Exit Sub
        End If
    Loop

errorhandler:

    m_AnimationState = EAnimationState.NotRunning
    ChangeInfoTextOnStop
    
End Sub

Private Sub ChangeInfoTextOnPlay()
    ActiveSheet.ChartObjects("Chart3D").Activate
    'ActiveChart.Shapes("InfoBox").Select
    'Selection.Characters.Text = "Dynamic Spectrum Viewer RUNNING"
    'Selection.AutoScaleFont = False
    'With Selection.Characters(Start:=1, Length:=31).Font
     '   .Name = "Times New Roman"
      '  .FontStyle = "Bold"
      '  .Size = 12
       ' .ColorIndex = 3
    'End With
    Range("A1").Select ' Need to make sure that the chart is not selected or it won't update
End Sub

Private Sub ChangeInfoTextOnStop()
    On Error Resume Next
    ActiveSheet.ChartObjects("Chart3D").Activate
    'ActiveChart.Shapes("InfoBox").Select
    'Selection.Characters.Text = "Dynamic Spectrum Viewer"
    'Selection.AutoScaleFont = False
    'With Selection.Characters(Start:=1, Length:=23).Font
     '   .Name = "Times New Roman"
       ' .FontStyle = "Bold"
       ' .Size = 8
       ' .ColorIndex = 1
    'End With
    Range("A1").Select ' Need to make sure that the chart is not selected or it won't update
End Sub

Attribute VB_Name = "AnimationControl"
Attribute VB_Base = "0{EDBADF72-503F-4FBD-B046-3A06A16F7044}{10D0D23F-A647-4979-AF86-AB2E68994561}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

Public OkWasPressed As Boolean  ' Used to notify the client that the user wants to proceed

'****************************************************************
' Don't proceed if the user hits cancel
'****************************************************************
Private Sub CancelButton_Click()
    OkWasPressed = False
    Unload Me
End Sub

'****************************************************************
' Initialise the dialog
'****************************************************************
Private Sub Userform_Initialize()
    OkWasPressed = False
    ParticleSize = True
    RingCurrent = False
End Sub

'****************************************************************
' The user has hit the OK button...
'****************************************************************
Private Sub CreateButton_Click()
    ' If we've managed to get this far, then accept the user selection and unload the dialog.
    OkWasPressed = True
    Unload Me
End Sub

Public Sub DoModal()

    If (Globals.AutomatedTest = False) Then
        Me.Show
    Else
        Load Me
        ParticleSize = Test.AnimationControl.ParticleSize
        RingCurrent = Test.AnimationControl.RingCurrent
      
        Call CreateButton_Click
    End If

End Sub
Attribute VB_Name = "CAnalogOutput"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

Private m_ModeSpec() As SModeSpec
Private m_NumModes As Integer

Private m_SizeClass() As Single ' Array which spans only the display range as specified in MinDp and MaxDp
Private m_NumSizeClasses As Integer ' The number of elements of m_SizeClass()
Private m_FirstValidSizeIdx As Integer ' in the particle size vector returned from the inversion routine
Private m_NumDataCols As Integer
Private m_NumSizeClassesPerDecade As Integer

Private Type SAnalogOutputSpec
    mode_type As EModeType
    mindp As Double
    maxdp As Double
    mode_idx As Integer
    num_modes As Integer
    par_idx As EParameterType
    weight_idx As EAoWtType
    denfac() As Double
    power() As Double
    simpson() As Double
End Type

Private m_AnalogOutputSpec(4) As SAnalogOutputSpec

Property Get NumModes() As Integer
    NumModes = m_NumModes
End Property
Property Get NumSizeClasses() As Integer
    NumSizeClasses = m_NumSizeClasses
End Property
Property Get NumSizeClassesPerDecade() As Integer
    NumSizeClassesPerDecade = m_NumSizeClassesPerDecade
End Property
Property Get FirstValidSizeIndex() As Integer
    FirstValidSizeIndex = m_FirstValidSizeIdx
End Property
Property Get SizeClass(size_idx As Integer) As Single
    If (size_idx < 0 Or size_idx >= NumSizeClasses) Then SizeClass = 0 Else SizeClass = m_SizeClass(size_idx)
End Property
Property Get GetModeSpec(mode_idx As Integer) As SModeSpec
    GetModeSpec = m_ModeSpec(mode_idx)
End Property


Public Sub SetModeSpec(num_modes As Integer, mode_spec() As SModeSpec)
    m_NumModes = num_modes
    ReDim m_ModeSpec(m_NumModes) As SModeSpec
    
    Dim i As Integer
    For i = 0 To m_NumModes
        m_ModeSpec(i).density = mode_spec(i).density
        m_ModeSpec(i).Modename = mode_spec(i).Modename
        m_ModeSpec(i).power = mode_spec(i).power
    Next i
End Sub

Public Sub CreateSizeClasses(num_data_cols As Integer, num_size_classes_per_decade As Integer, min_dp As Single, max_dp As Single, log_min_dp As Single)
    
    m_NumDataCols = num_data_cols
    m_NumSizeClassesPerDecade = num_size_classes_per_decade
    Dim increment As Single, size_class As Single
    ReDim m_SizeClass(m_NumDataCols - 1) As Single

    m_NumSizeClasses = 1
    m_FirstValidSizeIdx = 0
    increment = 1 / m_NumSizeClassesPerDecade
    Dim i As Integer
    For i = 0 To m_NumDataCols - 1
        size_class = 10 ^ (log_min_dp + i * increment)
        
        If (size_class <= min_dp) Then
            m_SizeClass(0) = size_class
            m_FirstValidSizeIdx = i
        ElseIf (size_class <= max_dp) Then
            m_SizeClass(m_NumSizeClasses) = size_class
            m_NumSizeClasses = m_NumSizeClasses + 1
        ElseIf (size_class > max_dp) Then
            If (m_SizeClass(m_NumSizeClasses - 1) < max_dp) Then
                m_SizeClass(m_NumSizeClasses) = size_class
                m_NumSizeClasses = m_NumSizeClasses + 1
            End If
        End If
    Next i
End Sub

Public Sub SetAnalogOutputSpec(ch_num As Integer, min_dp As String, max_dp As String, wt_type As EAoWtType, df As Double, p As Double)

    If (IsNumeric(min_dp)) Then ' No log normal calculations are wanted
        
        m_AnalogOutputSpec(ch_num - 1).mode_type = eSize
        m_AnalogOutputSpec(ch_num - 1).mindp = CDbl(min_dp)
        m_AnalogOutputSpec(ch_num - 1).maxdp = CDbl(max_dp)
        
        m_AnalogOutputSpec(ch_num - 1).num_modes = 1
        ReDim m_AnalogOutputSpec(ch_num - 1).denfac(m_AnalogOutputSpec(ch_num - 1).num_modes - 1)
        ReDim m_AnalogOutputSpec(ch_num - 1).power(m_AnalogOutputSpec(ch_num - 1).num_modes - 1)
        If (wt_type = EAoWtType.eNone) Then
            m_AnalogOutputSpec(ch_num - 1).weight_idx = eNone
            m_AnalogOutputSpec(ch_num - 1).denfac(0) = 1
            m_AnalogOutputSpec(ch_num - 1).power(0) = 0
        ElseIf (wt_type = EAoWtType.eCustom) Then
            m_AnalogOutputSpec(ch_num - 1).weight_idx = eCustom
            m_AnalogOutputSpec(ch_num - 1).denfac(0) = df
            m_AnalogOutputSpec(ch_num - 1).power(0) = p
        End If
        
        Call CreateSimpsonArray(m_AnalogOutputSpec(ch_num - 1))
    
    Else
        m_AnalogOutputSpec(ch_num - 1).mode_type = eMode
        
        Dim i As Integer
        m_AnalogOutputSpec(ch_num - 1).mode_idx = -1 ' Default is COMBINED
        m_AnalogOutputSpec(ch_num - 1).num_modes = m_NumModes
        For i = 0 To m_NumModes - 1
            If (m_ModeSpec(i).Modename = min_dp) Then
                m_AnalogOutputSpec(ch_num - 1).mode_idx = i
                m_AnalogOutputSpec(ch_num - 1).num_modes = 1
            End If
        Next i
               
        If (max_dp = "Concentration") Then
            m_AnalogOutputSpec(ch_num - 1).par_idx = eConcentration
        ElseIf (max_dp = "CMD") Then
            m_AnalogOutputSpec(ch_num - 1).par_idx = eCMD
        Else
            m_AnalogOutputSpec(ch_num - 1).par_idx = eGSD
        End If
        
        ReDim m_AnalogOutputSpec(ch_num - 1).denfac(m_AnalogOutputSpec(ch_num - 1).num_modes - 1)
        ReDim m_AnalogOutputSpec(ch_num - 1).power(m_AnalogOutputSpec(ch_num - 1).num_modes - 1)
        If (wt_type = EAoWtType.eNone) Then
            m_AnalogOutputSpec(ch_num - 1).weight_idx = eNone
            For i = 0 To m_AnalogOutputSpec(ch_num - 1).num_modes - 1
                m_AnalogOutputSpec(ch_num - 1).denfac(i) = 1
                m_AnalogOutputSpec(ch_num - 1).power(i) = 0
            Next i
        ElseIf (wt_type = EAoWtType.eCustom) Then
            If (m_AnalogOutputSpec(ch_num - 1).mode_idx = -1) Then ' COMBINED
                m_AnalogOutputSpec(ch_num - 1).weight_idx = eDMD
                For i = 0 To m_AnalogOutputSpec(ch_num - 1).num_modes - 1
                    m_AnalogOutputSpec(ch_num - 1).denfac(i) = m_ModeSpec(i).density
                    m_AnalogOutputSpec(ch_num - 1).power(i) = m_ModeSpec(i).power
                Next i
            Else
                m_AnalogOutputSpec(ch_num - 1).weight_idx = eCustom
                For i = 0 To m_AnalogOutputSpec(ch_num - 1).num_modes - 1
                    m_AnalogOutputSpec(ch_num - 1).denfac(i) = df
                    m_AnalogOutputSpec(ch_num - 1).power(i) = p
                Next i
            End If
        ElseIf (wt_type = EAoWtType.eDMD) Then
            m_AnalogOutputSpec(ch_num - 1).weight_idx = eDMD
            For i = 0 To m_AnalogOutputSpec(ch_num - 1).num_modes - 1
                m_AnalogOutputSpec(ch_num - 1).denfac(i) = m_ModeSpec(m_AnalogOutputSpec(ch_num - 1).mode_idx).density
                m_AnalogOutputSpec(ch_num - 1).power(i) = m_ModeSpec(m_AnalogOutputSpec(ch_num - 1).mode_idx).power
            Next i
        End If
    End If
End Sub

Private Sub CreateSimpsonArray(ByRef analog_output As SAnalogOutputSpec)
    
    ReDim analog_output.simpson(m_NumSizeClasses) As Double
    Dim Test(4) As Integer
    Dim test_number As Integer
    Dim temp1 As Double, temp2 As Double
    Dim delta1 As Double, delta2 As Double
    
    Dim size_class_lo As Single, size_class_hi As Single
    
    ' Need the next size class beyond the maximum size class to find the correct Simpson integration weighting
    Dim log_last_size_class As Single, size_class_extra As Single
    log_last_size_class = Log10(CDbl(m_SizeClass(m_NumSizeClasses - 1)))
    size_class_extra = 10 ^ (log_last_size_class + 1 / m_NumSizeClassesPerDecade)
    
    Dim size_class_idx As Integer
    For size_class_idx = 0 To m_NumSizeClasses - 1
        
        size_class_lo = m_SizeClass(size_class_idx)
        If (size_class_idx = m_NumSizeClasses - 1) Then
            size_class_hi = size_class_extra
        Else
            size_class_hi = m_SizeClass(size_class_idx + 1)
        End If
        
        If (size_class_lo >= analog_output.mindp) Then Test(0) = 1 Else Test(0) = 0
        If (size_class_hi >= analog_output.mindp) Then Test(1) = 1 Else Test(1) = 0
        If (size_class_lo < analog_output.maxdp) Then Test(2) = 1 Else Test(2) = 0
        If (size_class_hi < analog_output.maxdp) Then Test(3) = 1 Else Test(3) = 0
        test_number = Test(0) * 1 + Test(1) * 2 + Test(2) * 4 + Test(3) * 8
        
        If (test_number = 3) Then ' Case 3 (default)
            ' sum_array unchanged
            delta1 = 0
            delta2 = 0
        ElseIf (test_number = 6) Then ' Case 6
            temp1 = 0.5 * Log10(analog_output.maxdp / analog_output.mindp)
            temp2 = Log10((analog_output.maxdp * analog_output.mindp) / (size_class_lo * size_class_lo)) / Log10(size_class_hi / size_class_lo)
            delta1 = temp1 * (2 - temp2)
            delta2 = temp1 * temp2
        ElseIf (test_number = 7) Then
            temp1 = 0.5 * Log10(analog_output.maxdp / size_class_lo)
            temp2 = Log10(analog_output.maxdp / size_class_lo) / Log10(size_class_hi / size_class_lo)
            delta1 = temp1 * (2 - temp2)
            delta2 = temp1 * temp2
        ElseIf (test_number = 12) Then
            ' sum_array unchanged
            delta1 = 0
            delta2 = 0
        ElseIf (test_number = 14) Then
            temp1 = 0.5 * Log10(size_class_hi / analog_output.mindp)
            temp2 = Log10(analog_output.mindp / size_class_lo) / Log10(size_class_hi / size_class_lo)
            delta1 = temp1 * (1 - temp2)
            delta2 = temp1 * (1 + temp2)
        ElseIf (test_number = 15) Then
            delta1 = 1 / (2 * m_NumSizeClassesPerDecade)
            delta2 = delta1
        End If

        analog_output.simpson(size_class_idx) = analog_output.simpson(size_class_idx) + delta1
        analog_output.simpson(size_class_idx + 1) = analog_output.simpson(size_class_idx + 1) + delta2
       
    Next size_class_idx
    
    If (analog_output.weight_idx > eNone) Then
        For size_class_idx = 0 To m_NumSizeClasses - 1
            analog_output.simpson(size_class_idx) = analog_output.simpson(size_class_idx) * analog_output.denfac(0) * (m_SizeClass(size_class_idx) ^ analog_output.power(0))
        Next size_class_idx
    End If
    
End Sub

Private Function Log10(x As Double) As Double
    Log10 = Log(x) / Log(10#)
End Function
    
Public Function CalculateOutput(ch_num As Integer, ByRef particle_size() As Single, ByRef mode_data() As SLogNormalOutput) As Double

    If (m_AnalogOutputSpec(ch_num - 1).mode_type = eSize) Then
        Dim size_class_idx As Integer
        Dim total As Double
        total = 0
        For size_class_idx = 0 To m_NumSizeClasses - 1
            total = total + particle_size(size_class_idx + m_FirstValidSizeIdx) * m_AnalogOutputSpec(ch_num - 1).simpson(size_class_idx)
        Next size_class_idx
        
        CalculateOutput = total
    
    Else
        
        Dim mode_idx As Integer, par_idx As EParameterType
        Dim df As Double, power As Double
        mode_idx = m_AnalogOutputSpec(ch_num - 1).mode_idx
        par_idx = m_AnalogOutputSpec(ch_num - 1).par_idx
        df = m_AnalogOutputSpec(ch_num - 1).denfac(0)
        power = m_AnalogOutputSpec(ch_num - 1).power(0)
                
        Dim log_gsd As Double, CMD As Double, weighted_cmd As Double, conc As Double, combined_conc As Double
        
        If (m_AnalogOutputSpec(ch_num - 1).mode_idx = -1) Then ' COMBINED
            Dim m As Integer
            combined_conc = 0
            For m = 0 To m_AnalogOutputSpec(ch_num - 1).num_modes - 1
                df = m_AnalogOutputSpec(ch_num - 1).denfac(m)
                power = m_AnalogOutputSpec(ch_num - 1).power(m)
                conc = mode_data(m).data(eConcentration)
                CMD = mode_data(m).data(eCMD)
                log_gsd = Log(mode_data(m).data(eGSD))
                weighted_cmd = CMD * Exp(power * 0.5 * log_gsd * log_gsd)
                combined_conc = combined_conc + (conc * (weighted_cmd ^ power) * df)
            Next m
            CalculateOutput = combined_conc
            
        Else ' Not COMBINED
            If (m_AnalogOutputSpec(ch_num - 1).weight_idx = eNone) Then
                CalculateOutput = mode_data(mode_idx).data(par_idx)
            Else ' CUSTOM and DMD
                If (par_idx = eCMD) Then
                    CMD = mode_data(mode_idx).data(eCMD)
                    log_gsd = Log(mode_data(mode_idx).data(eGSD))
                    CalculateOutput = CMD * Exp(power * 0.5 * log_gsd * log_gsd)
                
                ElseIf (par_idx = eConcentration) Then
                    conc = mode_data(mode_idx).data(eConcentration)
                    CMD = mode_data(mode_idx).data(eCMD)
                    log_gsd = Log(mode_data(mode_idx).data(eGSD))
                    weighted_cmd = CMD * Exp(power * 0.5 * log_gsd * log_gsd)
                    CalculateOutput = conc * (weighted_cmd ^ power) * df
               
                ElseIf (par_idx = eGSD) Then
                    CalculateOutput = mode_data(mode_idx).data(eGSD)
                End If
            End If
        End If
     
    End If
End Function

Attribute VB_Name = "CAnimation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

Private m_AnalogRange As String         ' The range of the header for analog data in the DMS file
Private m_DataRange As String           ' The range of the header for DMS data (particle sise or ring currents)
Private m_TemplateSheetName As String   ' The worksheet name of the animation template in the DMS Viewer file

Private Const c_NumSeries As Long = 26  ' Number of series (timeslices) used in the animation charts
Private m_DataSheetName As String       ' The name of the DMS data sheet
Private m_WorkBookName As String        ' The name of the DMS workbook
Private m_AnimationSheetName As String  ' The name of the animation sheet with a number at the end

Private m_FileSpec As CFileSpec
Private m_Template As CTemplateSpec

' A structure containing information on a named cell
Private Type SName
    Name As String  ' An Excel name
    r1c1 As String  ' The R1C1 style reference for the Excel name
    a1 As String    ' The A1 style reference for the Excel name
End Type

' Array of enumerated names with cell references that will be associated with the animation sheet
Private Const c_NumAnimationNames As Integer = 5
Private m_AnimationNames(c_NumAnimationNames) As SName
Private Enum EAnimationNames
    eDelay = 0
    eInterval = 1
    eLength = 2
    eSpeed = 3
    eStep = 4
End Enum

' Array of enumerated names with cell references that will be associated with the DMS data sheet
Private Const c_NumDmsNames As Integer = 6
Private m_DmsNames(c_NumDmsNames) As SName
Private Enum EDmsNames
    eSync1 = 0
    eSync2 = 1
    eSync3 = 2
    eSync4 = 3
    eTimestamp = 4
    eSpecdata = 5
End Enum

' Names in the animation sheet
Property Let Delay(rc_address As String)
    m_AnimationNames(EAnimationNames.eDelay) = InitNames("delay", rc_address)
End Property
Property Let Interval(rc_address As String)
    m_AnimationNames(EAnimationNames.eInterval) = InitNames("interval", rc_address)
End Property
Property Let Length(rc_address As String)
    m_AnimationNames(EAnimationNames.eLength) = InitNames("length", rc_address)
End Property
Property Let Speed(rc_address As String)
    m_AnimationNames(EAnimationNames.eSpeed) = InitNames("speed", rc_address)
End Property
Property Let Step(rc_address As String)
    m_AnimationNames(EAnimationNames.eStep) = InitNames("step", rc_address)
End Property

' Names in the DMS data sheet
Property Let Sync1(rc_address As String)
    m_DmsNames(EDmsNames.eSync1) = InitNames("sync1", rc_address)
End Property
Property Let Sync2(rc_address As String)
    m_DmsNames(EDmsNames.eSync2) = InitNames("sync2", rc_address)
End Property
Property Let Sync3(rc_address As String)
    m_DmsNames(EDmsNames.eSync3) = InitNames("sync3", rc_address)
End Property
Property Let Sync4(rc_address As String)
    m_DmsNames(EDmsNames.eSync4) = InitNames("sync4", rc_address)
End Property
Property Let timestamp(rc_address As String)
    m_DmsNames(EDmsNames.eTimestamp) = InitNames("timestamp", rc_address)
End Property
Property Let Specdata(rc_address As String)
    m_DmsNames(EDmsNames.eSpecdata) = InitNames("specdata", rc_address)
End Property

' Other properties required to run the CreateAnimationSheet routine
Property Let AnalogRange(Range As String)
    m_AnalogRange = Range
End Property
Property Let DataRange(Range As String)
    m_DataRange = Range
End Property
Property Let TemplateSheet(Name As String)
    m_TemplateSheetName = Name
End Property

'****************************************************************
' Return a SName structure initialised with name text and cell
' addresses, both in A1 and R1C1 format
'****************************************************************
Private Function InitNames(Name As String, rc As String) As SName
    InitNames.Name = Name
    InitNames.r1c1 = rc
    InitNames.a1 = Globals.R1C1toA1(rc)
End Function

'****************************************************************
' Remove all names in the m_AnimationNames and m_DmsNames arrays
' from the global workspace. Although these names refer to cells
' in the DMS worksheet, they are nevertheless local to the
' animation sheet, and should not be seen from the DMS worksheet.
'****************************************************************
Private Sub RemoveGlobalNames()
    On Error Resume Next
    Dim n As Integer
        For n = 0 To c_NumAnimationNames - 1
        names(m_AnimationNames(n).Name).Delete
    Next

    For n = 0 To c_NumDmsNames - 1
        names(m_DmsNames(n).Name).Delete
    Next
End Sub

Public Sub SetFileSpec(file_spec As CFileSpec)
    Set m_FileSpec = file_spec
    
    ' Names that apply to the data sheet
    AnalogRange = file_spec.TimePlusA2dHeaderRange
    DataRange = file_spec.DataHeaderRange
    Sync1 = file_spec.Sync1Cell
    Sync2 = file_spec.Sync2Cell
    Sync3 = file_spec.Sync3Cell
    Sync4 = file_spec.Sync4Cell
    timestamp = file_spec.TimestampCell
    Specdata = file_spec.DataCell
End Sub

Public Sub SetTemplateSpec(template As CTemplateSpec)
    Set m_Template = template
    
    ' Names that apply to the template sheet
    Delay = template.Delay
    Interval = template.Interval
    Length = template.Length
    Speed = template.Speed
    Step = template.Step
    TemplateSheet = template.SheetName
End Sub

Private Sub WhiteOutWeightingControls()
    Range("A18:C22").Select
    Selection.Font.ColorIndex = 2
    Range("B23").Select
End Sub


'****************************************************************
' This function is invoked after AnalogRange, DataRange and TemplateSheet
' have been initialised by the client code. Also, the names should have
' been initialised with valid cell references.
'****************************************************************
Public Sub CreateAnimationSheet(spectrum_is_already_weighted As Boolean)
    
    m_WorkBookName = ActiveWorkbook.Name
    m_DataSheetName = ActiveSheet.Name
                  
    m_AnimationSheetName = Globals.TemporaryInsertedSheetName

    Call RemoveGlobalNames
    
    Dim number_of_sheets As Integer
    number_of_sheets = Sheets.Count
                
    ' Add a new sheet using the template
    Dim filepath As String
    filepath = Globals.InstallationDirectory & Globals.TemplatesFileName
    
    Dim Wb1 As Workbook
    Set Wb1 = Workbooks.Add(template:=filepath)
    Sheets(m_TemplateSheetName).Select
    Sheets(m_TemplateSheetName).Copy After:=Workbooks(m_WorkBookName).Sheets(number_of_sheets)
            
    Workbooks(m_WorkBookName).Activate
    Sheets(m_TemplateSheetName).Name = m_AnimationSheetName
    Sheets(m_AnimationSheetName).Select
    
    If (spectrum_is_already_weighted) Then
        WhiteOutWeightingControls
        Range("B23").FormulaR1C1 = m_FileSpec.GetWeightingUnits
    End If
    
    If (m_FileSpec.RealTime = True) Then
        Sheets(m_AnimationSheetName).Range(m_Template.TimeColumn).Select ' new in 6.5
        Selection.NumberFormat = "hh:mm:ss.0"
    End If
    
    ' Remove unwanted columns from the particle size animation sheet
    If (m_FileSpec.SourceDataType = ParticleSizeData) Then
        Dim first_col_to_delete As Long, last_col_to_delete As Long
        first_col_to_delete = m_FileSpec.NumSizeClasses + m_Template.DataStartCol
        last_col_to_delete = m_Template.MaxDataCols + m_Template.DataStartCol - 1
        Range(Cells(1, first_col_to_delete), Cells(1, last_col_to_delete)).EntireColumn.Delete
        ActiveSheet.UsedRange ' Resets last cell
    End If
    
   
    'Application.DisplayAlerts = False
    Dim n As Integer
    For n = 0 To c_NumAnimationNames - 1
        Worksheets(m_AnimationSheetName).names(m_AnimationNames(n).Name).Delete
        Worksheets(m_AnimationSheetName).names.Add Name:=m_AnimationSheetName & "!" & m_AnimationNames(n).Name, _
            RefersToR1C1:="=" & m_AnimationSheetName & "!" & m_AnimationNames(n).r1c1
    Next
    
    For n = 0 To c_NumDmsNames - 1
        Worksheets(m_AnimationSheetName).names(m_DmsNames(n).Name).Delete
        Worksheets(m_AnimationSheetName).names.Add Name:=m_AnimationSheetName & "!" & m_DmsNames(n).Name, _
            RefersToR1C1:="=" & m_DataSheetName & "!" & m_DmsNames(n).r1c1
    Next
        
    Dim new_ref As String
    new_ref = R1C1toA1(m_DmsNames(EDmsNames.eTimestamp).r1c1, 1, 0)
    'Range(m_AnimationNames(EAnimationNames.eInterval).a1).Formula = "=MAX(" & m_DataSheetName & "!" & new_ref & "-timestamp, 0.1)" ' Sample interval
    Range(m_AnimationNames(EAnimationNames.eInterval).a1).Value = m_FileSpec.SampleInterval
    
    new_ref = R1C1toA1(m_AnimationNames(EAnimationNames.eDelay).r1c1, -1, 0)
    Range(m_AnimationNames(EAnimationNames.eDelay).a1).formula = "=INT(" & new_ref & "/interval + 0.5)" ' DSamples samples
    'Application.DisplayAlerts = True
    
    ' Assign the x-axis for the 3D Chart
    ActiveSheet.ChartObjects("Chart3D").Activate
    ActiveChart.ChartArea.Select
    Dim series As Integer
    For series = 1 To c_NumSeries
        ActiveChart.SeriesCollection(series).XValues = "=" & m_DataSheetName & "!" & m_DataRange
    Next series
    
    If (Globals.ExcelVersion >= 12) Then
        ActiveSheet.ChartObjects("Chart3D").Activate
        ActiveChart.Axes(xlCategory).TickLabels.Offset = 500
        ActiveChart.Axes(xlCategory, xlPrimary).TickLabels.Orientation = xlTickLabelOrientationHorizontal
        ActiveChart.Axes(xlSeriesAxis, xlPrimary).TickLabels.Orientation = xlTickLabelOrientationHorizontal
    End If
    
    ' Assign the macro for the "Play" button and format the chart
    'ActiveSheet.ChartObjects("Chart3D").Activate
    'ActiveChart.Shapes("chartbutton").Select
    'Selection.OnAction = "Animation.PlayAnimation"
    
    If (m_FileSpec.RealTime = True) Then

        ActiveChart.PlotArea.Select
        ActiveChart.Axes(xlSeries).Select
        Selection.TickLabels.NumberFormat = "hh:mm:ss.0" ' decimal place added in 6.5
    End If
    ActiveWindow.visible = False
    Windows(m_WorkBookName).Activate
    Range("BB18").Select

    ' Put the number of data rows into the controls
    Range(m_AnimationNames(EAnimationNames.eLength).a1).Value = m_FileSpec.NumDataRows
    
    'Application.ReferenceStyle = xlR1C1
    Application.ReferenceStyle = xlA1 ' Needed to make the scrollbar link to the right cell
    
    Range("BC22").Select
    ' Add analog inputs to the chart
    Sheets(m_DataSheetName).Select
    Range(m_AnalogRange).Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Copy
    Range("A1").Select
    Sheets(m_AnimationSheetName).Select
    ActiveSheet.ChartObjects("SyncChart").Activate
    ActiveChart.PlotArea.Select
    ActiveChart.ChartType = xlXYScatterLinesNoMarkers
    ActiveChart.SeriesCollection.Paste Rowcol:=xlColumns, SeriesLabels:=True, _
        CategoryLabels:=True, Replace:=False, NewSeries:=True
    If (m_FileSpec.RealTime = True) Then
        ActiveChart.Axes(xlCategory).Select
        Selection.TickLabels.NumberFormat = "hh:mm:ss"
    End If
    With ActiveChart.Axes(xlCategory)
        .MinimumScale = m_FileSpec.MinTime
        .MaximumScale = m_FileSpec.MaxTime
    End With
    
   
    Dim i As Integer 'v7.20 - change "karaoke lines" to red dots
    For i = 1 To 4
     ActiveChart.SeriesCollection(i).Select
        If (Globals.ExcelVersion >= 12) Then
            Selection.Format.Line.visible = msoFalse
        Else
            Selection.Border.LineStyle = xlLineStyleNone
        End If
        With Selection
           .MarkerStyle = xlMarkerStyleCircle
           .MarkerSize = 3
        End With
        If (Globals.ExcelVersion >= 12) Then
            With Selection.Format.Fill
             .visible = msoTrue
             .Transparency = 0
             .Solid
             .ForeColor.RGB = RGB(255, 0, 0)
             .BackColor.RGB = RGB(255, 0, 0)
            End With
        Else
             With Selection
              .MarkerForegroundColor = RGB(255, 0, 0)
              .MarkerBackgroundColor = RGB(255, 0, 0)
             End With
        End If
    Next

    
    ' Create weighting multipliers
    If (m_FileSpec.SourceDataType = ParticleSizeData) Then
        Range("L40").Select
        Dim temp_formula As String, first_cell As String
        first_cell = Globals.R1C1toA1("R" & CStr(m_FileSpec.DataStartRow - 1) & "C" & CStr(m_FileSpec.DataStartCol))
        first_cell = Replace(first_cell, "$", "")
        temp_formula = "=" & m_Template.ConstantCell & "*(" & Globals.TemporaryWorkSheetName & _
            "!" & first_cell & ")^" & m_Template.WeightingCell
        Range("L40").formula = temp_formula
        Selection.AutoFill destination:=Range(Cells(40, m_Template.DataStartCol), Cells(40, m_Template.DataStartCol + m_FileSpec.NumSizeClasses - 1))
    End If
    
    If (m_FileSpec.SourceFileType = DmeFile) Then ' v6.9
        ActiveSheet.ChartObjects("Chart3D").Activate
        ActiveChart.Axes(xlSeries).AxisTitle.Select
        Selection.Characters.Text = "Samples"
    End If
    
    
    Range("A1").Select
    
    Wb1.Close SaveChanges:=False
    Call RemoveGlobalNames
End Sub


Attribute VB_Name = "CBitMap"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

Private Const c_NumColours As Integer = 30       ' The number of colours that will be used in the bitmap
Private Const c_SizeOfFileHeader As Integer = 14 ' Fixed number of bytes in a bitmap header
Private Const c_SizeOfInfoHeader As Integer = 40 ' Fixed number of bytes in the info portion of the bitmap file
Private Const c_SizeOfQuad As Integer = 4        ' The number of bytes in an RGBQUAD structure

Private Type BITMAPFILEHEADER   ' Structure for a portion of the bitmap header
    bfType As Integer           ' This has been translated from the VisualC++ documentation
    bfSize As Long              ' ...but beware...some of the elements in VC++ are unsigned,
    bfReserved1 As Integer      ' but Basic has no equivalent of unsigned integer types, so
    bfReserved2 As Integer      ' signed values of the same byte length have been used instead.
    bfOffBits As Long
End Type

Private Type BITMAPINFOHEADER   ' Structure for a portion of the bitmap header (see comments above)
    biSize As Long
    biWidth As Long
    biHeight As Long
    biPlanes As Integer
    biBitCount  As Integer
    biCompression As Long
    biSizeImage As Long
    biXPelsPerMeter As Long
    biYPelsPerMeter As Long
    biClrUsed As Long
    biClrImportant As Long
End Type

Private Type RGBQUAD            ' Structure for a bitmap pixel. NOTE that even though the order of the colours
    rgbBlue As Byte             ' in the structure name is RGB, the order of the elements in the structure is BGR!!
    rgbGreen As Byte
    rgbRed As Byte
    rgbReserved As Byte
End Type

Private m_Colours(c_NumColours - 1) As RGBQUAD  ' Array of colours specified as pixels, zero based indexing, max index is 29
Private m_NumRows As Long       ' The number of bitmap rows
Private m_NumCols As Long       ' The number of bitmap columns, including any padding that's added
Private m_NumPixels As Long     ' The number of bitmap pixels (m_NumRows * m_NumCols)
Private m_NumUnpaddedCols As Long ' The number of bitmap columns, without any additional padding
Private m_ScanIdx As Long       ' Zero based index locating a pixel in a row of the bitmap
Private m_MinValue As Single    ' Clip used for the lower limit of the input value
Private m_MaxValue As Single    ' Clip used for the upper limit of the input value
Private m_Pixels() As Byte      ' Dynamic array of pixels that forms the bitmap
Private m_PixelIdx As Long      ' Zero based index into the m_Pixels array
'****************************************************************
' Returns the number of colours used in the bitmap
'****************************************************************
Property Get NumColours() As Integer
    NumColours = c_NumColours
End Property

'****************************************************************
' Return a RGBQUAD structure initialised with Blue, Green, Red colour values.
' Each colour value lies between 0-255
'****************************************************************
Private Function InitColours(b As Byte, g As Byte, r As Byte) As RGBQUAD
InitColours.rgbBlue = b
InitColours.rgbGreen = g
InitColours.rgbRed = r
InitColours.rgbReserved = 0
End Function

'****************************************************************
' Initialise the 30 colours in the bitmap by populating the m_Colours array
' Call this once immediately following object construction
'****************************************************************
Public Sub Initialise()
    m_MinValue = 3
    m_MaxValue = 6

    ' VB starts indexing arrays at zero offset.
    ' The array declaration involves the maximum index, not the number of elements!
    m_Colours(0) = InitColours(104, 0, 82)
    m_Colours(1) = InitColours(150, 0, 86)
    m_Colours(2) = InitColours(170, 50, 90)
    m_Colours(3) = InitColours(168, 80, 80)
    m_Colours(4) = InitColours(216, 0, 0)
    m_Colours(5) = InitColours(255, 0, 0)
    m_Colours(6) = InitColours(220, 106, 37)
    m_Colours(7) = InitColours(206, 167, 0)
    m_Colours(8) = InitColours(230, 208, 0)
    m_Colours(9) = InitColours(234, 240, 0)
    m_Colours(10) = InitColours(175, 234, 21)
    m_Colours(11) = InitColours(135, 193, 56)
    m_Colours(12) = InitColours(0, 196, 0)
    m_Colours(13) = InitColours(0, 232, 0)
    m_Colours(14) = InitColours(0, 255, 0)
    m_Colours(15) = InitColours(40, 255, 150)
    m_Colours(16) = InitColours(51, 255, 204)
    m_Colours(17) = InitColours(0, 255, 255)
    m_Colours(18) = InitColours(0, 221, 255)
    m_Colours(19) = InitColours(0, 187, 255)
    m_Colours(20) = InitColours(0, 153, 255)
    m_Colours(21) = InitColours(0, 96, 255)
    m_Colours(22) = InitColours(0, 0, 255)
    m_Colours(23) = InitColours(0, 0, 240)
    m_Colours(24) = InitColours(89, 62, 230)
    m_Colours(25) = InitColours(98, 84, 240)
    m_Colours(26) = InitColours(107, 107, 255)
    m_Colours(27) = InitColours(145, 145, 255)
    m_Colours(28) = InitColours(213, 213, 255)
    m_Colours(29) = InitColours(254, 243, 255)
End Sub

'****************************************************************
' Provides clip limits for the bitmap values. Call this once before
' setting the bits with SetBits.
' Returns 1 if successful, 0 otherwise.
'****************************************************************
Public Function SetMinMax(min_value As Double, max_value As Double) As Long
    If (min_value < max_value) Then
        m_MinValue = min_value
        m_MaxValue = max_value
        SetMinMax = 1
    Else
        SetMinMax = 0
    End If
End Function

Private Function getMaxDisplayCols() As Long
    Const SM_CXSCREEN As Integer = 0
    'Const SM_CYSCREEN As Integer = 1
    getMaxDisplayCols = GetSystemMetrics32(SM_CXSCREEN)
    'getMaxDisplayRows = GetSystemMetrics32(SM_CYSCREEN)
End Function

'****************************************************************
' Determine the size of the bitmap, accounting for column padding.
' Call this once before setting the bits with SetBits.
' Returns 1 whatever happens.
'****************************************************************
Public Function SetSize(nrows As Long, ncols As Long) As Long
    
    m_NumRows = nrows                       ' Setting the number of rows is easy!

    Dim max_cols As Long, col_decimation As Long
        
    max_cols = getMaxDisplayCols()
    
    If (ncols > 2 * max_cols) Then
        If (ncols Mod max_cols = 0) Then
            col_decimation = ncols / max_cols
            ncols = max_cols
        Else
            col_decimation = WorksheetFunction.RoundUp(ncols / max_cols, 0)  ' Always round up.
            ncols = WorksheetFunction.RoundUp(ncols / col_decimation, 0) ' Always round up to take account of the fractional row
        End If
    Else
        col_decimation = 1
    End If
    
    Select Case (ncols Mod 4)               ' Allocating the number of columns is harder...
        Case Is = 0: m_NumCols = ncols      ' because the m_NumCols must be an integer multiple of 4.
        Case Is = 1: m_NumCols = ncols + 3  ' So all this stuff increments the number of columns appropriately.
        Case Is = 2: m_NumCols = ncols + 2  ' This is the column padding that the bitmap will have.
        Case Is = 3: m_NumCols = ncols + 1
    End Select
    
    m_NumUnpaddedCols = ncols               ' We need to know the number of unpadded columns...
    m_NumPixels = m_NumRows * m_NumCols     ' ...because we'll fill the remaining padded columns with colour too.
    ReDim m_Pixels(m_NumPixels - 1) As Byte ' Dynamically allocate enough space for the bitmap pixel array
    m_PixelIdx = 0                          ' Initialise the index into the pixel array
    m_ScanIdx = 0                           ' and the scan line index (scans move along a row)
    
    SetSize = col_decimation
End Function

'****************************************************************
' Populate the m_Pixels array with colours. This should be called once for each pixel value in the bitmap,
' starting scanning at the bottom left and populating the lower row first. Then, the next row up, until finally
' the top row of the bitmap, finishing at the top right. This routine should be called exactly the number of
' times corresponding to the values passed to the SetSize function, e.g. if you call SetSize with 4 rows and 5 cols,
' then call SetBits 20 times.
' Returns the index of the colour array that was used.
'****************************************************************
Public Function SetBits(inval As Double) As Boolean

    If (m_PixelIdx >= m_NumPixels) Then ' This shouldn't happen
        'Dim msg As String
        'msg = "Too many calls to DmsSetBits. m_Idx=" & CStr(m_PixelIdx)
        'MsgBox msg
        
        SetBits = False
        Exit Function
    End If
    
    Dim clipped_value As Single     ' The clipped version of inval
    If inval < m_MinValue Then
        clipped_value = m_MinValue
    ElseIf inval > m_MaxValue Then
        clipped_value = m_MaxValue
    Else
        clipped_value = inval
    End If
        
    ' Convert the clipped_value relative to m_MinValue and m_MaxValue into a colour index, by linear interpolation
    ' When clipped_value = m_MinValue, colour_idx = 0
    ' When clipped_value = m_MaxValue, colour_idx = (c_NumColours - 1)
    Dim colour_idx  As Byte  ' colour_idx is the zero based index into the colour array.
    colour_idx = Int(((c_NumColours - 1) * (clipped_value - m_MinValue) / (m_MaxValue - m_MinValue) + 0.5))
    
    If (colour_idx > c_NumColours - 1) Then     ' Shouldn't need to do this clip, but just to make sure...
        colour_idx = c_NumColours - 1
    End If
            
    m_Pixels(m_PixelIdx) = colour_idx           ' Assign the colour index to the pixel array
    m_PixelIdx = m_PixelIdx + 1                 ' and advance the pixel index

    If (m_ScanIdx = m_NumUnpaddedCols - 1) Then ' When we've inserted all the data for a given row...
        m_ScanIdx = m_ScanIdx + 1               ' keep increasing the scan index
        Do While (m_ScanIdx < m_NumCols)        ' until we get to the end of that row (due to padding)
            m_Pixels(m_PixelIdx) = colour_idx   ' and copy the last colour index we used into the padding pixels
            m_PixelIdx = m_PixelIdx + 1         ' then advance the pixel index
            m_ScanIdx = m_ScanIdx + 1           ' and scan index.
        Loop
        m_ScanIdx = 0                           ' When we reach the end of the padded row, reset the scan index
    Else
        m_ScanIdx = m_ScanIdx + 1               ' We haven't got to the end of the row yet, so just advance the scan index
    End If
    
    SetBits = True ' indicates success

End Function

'****************************************************************
' Delete a file (if it exists) using the FileSystemObject
'****************************************************************
Private Sub Delete(filename As String)
    On Error Resume Next ' In case the file doesn't exist
    Dim fs As Object
    Set fs = CreateObject("Scripting.FileSystemObject")
    fs.DeleteFile (filename)
End Sub

'****************************************************************
' Write the bitmap to a file. This should be called once, following
' completion of the SetBits calls. The VC++ documentation was used to
' translate this code from a C equivalent.
' Returns 1 whatever happens.
'****************************************************************
Public Function WriteToFile(filename As String) As Boolean

    On Error Resume Next
    Delete (filename) ' Delete existing file if it exists
    Open filename For Binary As #1

    Dim dwDibSize As Long
    dwDibSize = c_SizeOfInfoHeader + c_NumColours * c_SizeOfQuad + m_NumPixels

    'First, create a BITMAPFILEHEADER with the correct data.
    Dim BFH As BITMAPFILEHEADER
    BFH.bfType = 19778 ' 'MB'
    BFH.bfSize = c_SizeOfFileHeader + dwDibSize
    BFH.bfOffBits = c_SizeOfFileHeader + c_SizeOfInfoHeader + c_NumColours * c_SizeOfQuad

    ' Then create a BITMAPINFOHEADER with correct data
    Dim BIH As BITMAPINFOHEADER
    BIH.biSize = c_SizeOfInfoHeader
    BIH.biWidth = m_NumCols
    BIH.biHeight = m_NumRows
    BIH.biPlanes = 1
    BIH.biBitCount = 8
    BIH.biCompression = 0
    BIH.biSizeImage = 0
    BIH.biXPelsPerMeter = 0
    BIH.biYPelsPerMeter = 0
    BIH.biClrUsed = c_NumColours
    BIH.biClrImportant = 0

    'Write the BITMAPFILEHEADER, BITMAPINFOHEADER, colour array and pixel array.
    Put #1, , BFH
    Put #1, , BIH
    Put #1, , m_Colours
    Put #1, , m_Pixels
    Close #1
    
    WriteToFile = True
End Function


Attribute VB_Name = "CDmsChart"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

' NOTE: CStr must not be used to convert floating point numbers into strings that are used in ActiveCell.FormulaR1C1
' Use Str instead. CStr must be used for integers, however. (See Excel 2002 VBA, page 453)

' Members that are initialised externally by the user
Private m_LowerTimeWindow As Double
Private m_UpperTimeWindow As Double
Private m_AnalogSignalNumber As Integer
Private m_LogMinCSD As Double
Private m_LogMaxCSD As Double

Private m_DataSheetName As String       ' The name of the DMS data sheet
Private m_ChartSheetName As String      ' The name that the DMS contour chart will take

Private m_LabelChoice(9) As Boolean     ' Options to place labels on the primary y-axis
Private m_LabelArray(50) As Long        ' Array of labels used in the main chart
Private m_NumLabels As Integer          ' The number of labels that we want
Private Const m_Y1Scaling As Integer = 1000 ' Scaling applied to Y1 chart so that it can be applied programmatically with adequate resolution as a long

Private m_BitMapLegendFile As String    ' The name of the file used to store the bitmap of the legend
Private m_BitMapFile As String          ' The name of the file used to store the contour chart bitmap
Private m_LowerSelectionRow As Long     ' The row in the plot data corresponding to m_LowerTimeWindow
Private m_UpperSelectionRow As Long     ' The row in the plot file corresponding to m_UpperTimeWindow
Private m_FirstParticleIdx As Integer   ' The zero based index (relative to c_ParticleSizeDataStartColumn) for first "valid" particle size
Private m_MinScaleOnPrimaryAxis As Double ' Used for scaling the particle size axis (primary y-axis)
Private m_MaxScaleOnPrimaryAxis As Double ' Used for scaling the particle size axis (primary y-axis)
Private m_BitMap As CBitMap             ' The embedded bitmap object used in this class
Private m_Data As CFileSpec

Public Sub SetTimeRange(ByVal lower As Double, ByVal upper As Double)
    If (lower < upper) Then
        m_LowerTimeWindow = lower
        m_UpperTimeWindow = upper
    Else
        MsgBox ("Lower time must be less than upper time")
    End If
End Sub

Public Sub SetLogCSDRange(ByVal min As Double, ByVal max As Double)
    If (min < max) Then
        m_LogMinCSD = min
        m_LogMaxCSD = max
    Else
        MsgBox ("Lower LogCSD must be less than upper LogCSD")
    End If
End Sub

Public Sub SetAnalogSignalNumber(signal_number As Integer)
    m_AnalogSignalNumber = signal_number
End Sub

Public Sub SetFileSpec(dms_file As CFileSpec)
    Set m_Data = dms_file
End Sub

'****************************************************************
' The main subroutine called by the class to generate the contour chart
'****************************************************************
Public Sub BitmapChart()
    
    m_DataSheetName = ActiveSheet.Name                  'Remember the current active sheet
        
    '****************************
    ' Initialise the internal class states
    '****************************
    ' These values don't change:
    m_BitMapFile = Globals.UserTempDirectory & "ContourPlot.bmp"   ' The bitmap file name of the DMS data
    m_BitMapLegendFile = Globals.InstallTempDirectory & "Legend.bmp"  ' The legend file name for the colours
    
    ' States that may be recalculated later in this class
    m_FirstParticleIdx = -1     ' The index in the particle size array 1 before the first "valid" particle size (zero offset)
    
    ' Secondary x-axis
    m_LowerSelectionRow = 2     ' The row in the plot data corresponding to m_LowerTimeWindow
    m_UpperSelectionRow = 200   ' The row in the plot file corresponding to m_UpperTimeWindow
    
    ' Primary y-axis
    m_NumLabels = 0           ' The number of primary axis labels used
    m_MinScaleOnPrimaryAxis = m_Data.LogMinDp   ' Used for particle size axis
    m_MaxScaleOnPrimaryAxis = m_Data.LogMaxDp   ' Used for particle size axis
    
    ' An array of booleans that indicate what labels are used in each decade of the primary y-axis
    m_LabelChoice(0) = True     ' 1
    m_LabelChoice(1) = True     ' 2
    m_LabelChoice(2) = False    ' 3
    m_LabelChoice(3) = False    ' 4
    m_LabelChoice(4) = True     ' 5
    m_LabelChoice(5) = False    ' 6
    m_LabelChoice(6) = False    ' 7
    m_LabelChoice(7) = False    ' 8
    m_LabelChoice(8) = False    ' 9

    LocateTimeWindowSelection
    
    ' Create and initialise the bitmap object
    Set m_BitMap = New CBitMap
    m_BitMap.Initialise
        
    ' Locate the largest DMS chart number in the activeworkbook sheets
    m_ChartSheetName = Globals.TemporaryInsertedSheetName
                   
    CreateControls  ' Populate the PlotSheet with control data
        
    ' Call all the functions required to generate the chart...
    CreateLegend
    CreateTheChart
    
End Sub

'****************************************************************
' Create the data used to control the appearance of the chart
'****************************************************************
Private Function CreateControls() As Integer
            
    '****************************************************************
    ' Label Controls...on BE..BI columns
    '****************************************************************
    Dim min_valid_particle_size As Double, max_valid_particle_size As Double
    min_valid_particle_size = m_Data.MinDpDisplay
    max_valid_particle_size = m_Data.MaxDpDisplay
        
    ' Locate the first valid particle size and index (relative to the first particle position)
    Dim particle_size As Single, start_value As Single ' The particle size related to the m_FirstParticleIdx
    Dim i As Integer
    m_FirstParticleIdx = -1
    
    For i = 0 To m_Data.NumSizeClasses - 1 ' Iterate over all the particle size columns
        particle_size = Worksheets(m_DataSheetName).Cells(m_Data.DataStartRow - 1, m_Data.DataStartCol + i) ' There's an offset to reach the particle size data
        If (particle_size > min_valid_particle_size) Then
            m_FirstParticleIdx = i - 1 ' Select the index before the minimum
            start_value = Worksheets(m_DataSheetName).Cells(m_Data.DataStartRow - 1, m_Data.DataStartCol + m_FirstParticleIdx)
            Exit For
        End If
    Next i
    If (m_FirstParticleIdx < 0) Then m_FirstParticleIdx = 0
              
    m_MinScaleOnPrimaryAxis = Log(start_value) / Log(10#)   ' Update the primary y-axis scale based on the first valid particle size
    
    ' Locate the correct decade for the first entry
    Dim decade As Long, increment As Long
    decade = Int(m_MinScaleOnPrimaryAxis + 0.000001) ' Round down. Int() seems wrong...Int(1) = 0???
    increment = 10 ^ decade                          ' This is the increment within the decade
    m_LabelArray(0) = Int(start_value / increment) + 1  ' Find the first label after the start value
        
    Dim nlabels As Integer, idx As Integer
    nlabels = 1
    Do ' Complete the other label entries in that column
        Do
            m_LabelArray(nlabels) = m_LabelArray(nlabels - 1) + increment
            nlabels = nlabels + 1
        Loop Until m_LabelArray(nlabels - 1) >= 10 * increment
        increment = increment * 10
        idx = 0
    Loop Until m_LabelArray(nlabels - 1) >= max_valid_particle_size
    
    m_NumLabels = nlabels ' The number of valid labels that we could use in the chart
    
End Function

'****************************************************************
' Locate the rows that relate to the user's selected time window
'****************************************************************
Private Function LocateTimeWindowSelection() As Integer

    Sheets(m_DataSheetName).Select ' Make sure that your looking at the right sheet
    
    ' Locate the lower rows for the required m_LowerTimeWindow
    Dim row As Long
    row = m_Data.DataStartRow - 1 ' Start just before the first time index
    Do
        row = row + 1
        If (row >= m_Data.NumRowsInSheet) Then   ' Stop if we get to the end of the sheet
            Exit Do
        End If
    Loop Until Cells(row, 1) > m_LowerTimeWindow  ' Loop until the next row exceeds the m_LowerTimeWindow
    If (row > m_Data.DataStartRow) Then
        row = row - 1
    End If
    m_LowerSelectionRow = row           ' Update the m_LowerSelectionRow with the row we got to
    m_LowerTimeWindow = Cells(row, 1)   ' Converting to integer makes the chart x axis look better

    Do                                  ' Repeat the search for the m_UpperTimeWindow...
        row = row + 1                   ' ...starting at the next row after the m_LowerSelectionRow
        If (row >= m_Data.NumRowsInSheet) Then   ' Stop if we get to the end of the sheet
            Exit Do
        End If
            
    Loop Until Cells(row, 1) > m_UpperTimeWindow  ' Loop until the current row exceeds the m_UpperTimeWindow
    m_UpperSelectionRow = row           ' Update the m_UpperSelectionRow with the row we got to
    m_UpperTimeWindow = Cells(row, 1)   ' Also update the m_UpperTimeWindow in case we've reached the end of the sheet.
End Function

'****************************************************************
' Create the bitmap that will be used for the legend.
'****************************************************************
Private Function CreateLegendBitMap() As Integer

    Dim result As Boolean, xlcol As Long, xlrow As Long, c As Long
    
    c = 10 * m_BitMap.NumColours    ' Create 10x number of columns to stop Excel doing legend colour interpolation
    result = m_BitMap.SetMinMax(m_LogMinCSD, m_LogMaxCSD) ' Provide clips for the bitmap's values
    result = m_BitMap.SetSize(1, c) ' Define the number of rows and columns in the bitmap
    
    Dim gradient As Double, crossing As Double
    ' The first point in the legend corresponds to m_LogMinCSD and the last corresponds to m_LogMaxCSD
    gradient = (m_LogMaxCSD - m_LogMinCSD) / (c - 1)
    crossing = (m_LogMinCSD - gradient) ' Assuming x=1 and y=m_LogMinCSD
    For xlcol = 1 To c                  ' Iterate through each column...
        result = m_BitMap.SetBits(gradient * xlcol + crossing)
    Next xlcol
    result = m_BitMap.WriteToFile(m_BitMapLegendFile)

End Function

'****************************************************************
' Create the legend on a new chart sheet
'****************************************************************
Private Sub CreateLegend()

    CreateLegendBitMap                  ' Create the bitmap first
    
    Dim colour_increment As Double  ' This is the increment between each point in the legend
    colour_increment = (m_LogMaxCSD - m_LogMinCSD) / 10 ' m_BitMap.NumColours
        
    Dim temp As Double
    Dim i As Integer
    Dim xarray As Variant
    Dim yarray As Variant
    Dim xdata() As Single, ydata() As Single
    Dim big As Double
    ReDim xdata(10) ' m_BitMap.NumColours)
    ReDim ydata(10) ' m_BitMap.NumColours)
    
    Dim strarray() As String
    ReDim strarray(10)
    
    temp = m_LogMinCSD
    For i = 0 To 10 ' m_BitMap.NumColours ' There is one more row in the legend than bitmap colours
        big = (10 ^ temp)   ' because the colours represent the space between each row point
        xdata(i) = CSng(big)
        ydata(i) = 0
        If ((i Mod 2) = 0) Then ' Use only the even indices
            strarray(i) = Format(xdata(i), "#.#E+")
        End If
        temp = temp + colour_increment
    Next i
         
    xarray = Array(strarray)
    yarray = Array(ydata)
        
    Charts.Add After:=Worksheets(Globals.TemporaryWorkSheetName) ' Worksheets.Count)
    ActiveChart.Name = m_ChartSheetName
    ActiveChart.ChartType = xlLine
    Dim num_series As Long
    num_series = ActiveChart.SeriesCollection.Count
    Dim ser As Integer
    For ser = 1 To num_series
        ActiveChart.SeriesCollection(1).Delete ' The chart sometimes has data from a previous selection, so delete it
    Next ser
    
    With ActiveChart
        Dim new_series As series
        Set new_series = .SeriesCollection.NewSeries
        new_series.values = yarray  ' There's a limit of ~250 'characters' for this
        new_series.XValues = xarray ' There's a limit of ~250 'characters' for this
    End With

    ActiveChart.Location Where:=xlLocationAsNewSheet
    With ActiveChart
        .HasAxis(xlCategory, xlPrimary) = True
        .HasAxis(xlValue, xlPrimary) = False
        .HasTitle = True
        .ChartTitle.Characters.Text = m_Data.WeightingText ' "dN/dlog(dp) / cc"
        .ChartTitle.Select
    End With
    Selection.AutoScaleFont = True
       
    With Selection.Font                             ' Modify the title properties
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .Background = xlAutomatic
    End With

    ActiveChart.Axes(xlCategory, xlPrimary).CategoryType = xlAutomatic ' Remove gridlines
    With ActiveChart.Axes(xlCategory)
        .HasMajorGridlines = False
        .HasMinorGridlines = False
    End With
    With ActiveChart.Axes(xlValue)
        .HasMajorGridlines = False
        .HasMinorGridlines = False
    End With
    ActiveChart.HasLegend = False
    ActiveChart.PlotArea.Select
    With Selection.Border
        .ColorIndex = 16
        .Weight = xlThin
        .LineStyle = xlContinuous
    End With
    Selection.Fill.UserPicture PictureFile:=m_BitMapLegendFile  ' Use the legend bitmap as the picture
    Selection.Fill.visible = True
    ActiveChart.Axes(xlCategory).Select
    'With ActiveChart.Axes(xlCategory)
    '    .CrossesAt = 1
    '    .TickLabelSpacing = 10
    '    .TickMarkSpacing = 1
    '    .AxisBetweenCategories = True
    '    .ReversePlotOrder = False
    'End With
    ActiveChart.PlotArea.Select                     ' Resize the legend and reposition it
    Selection.Width = 200
    If (Globals.ExcelVersion <= 11) Then Selection.Height = 30
    If (Globals.ExcelVersion >= 12) Then Selection.Height = 50
    
    Selection.Left = 500
    Selection.Top = 0

    ActiveChart.Axes(xlCategory).Select
    Selection.TickLabels.NumberFormat = "0.0E+00"   ' Format the ticklabels
    Selection.TickLabels.AutoScaleFont = True
    With Selection.Border                           ' Change the border properties
        .Weight = xlHairline
        .LineStyle = xlAutomatic
    End With
    With Selection
        .MajorTickMark = xlNone
        .MinorTickMark = xlNone
        .TickLabelPosition = xlNextToAxis
    End With
    With Selection.TickLabels.Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .Background = xlAutomatic
    End With
    
    ActiveChart.SeriesCollection(1).Select          ' Select the first series in the legend chart
    With Selection.Border
        .Weight = xlThin
        .LineStyle = xlNone                         ' Make the line invisible
    End With
       
    ActiveChart.ChartTitle.Select                   ' Move the legend title underneath the legend
    Selection.Left = 573
    
    If (Globals.ExcelVersion <= 11) Then Selection.Top = 32
    If (Globals.ExcelVersion >= 12) Then Selection.Top = 50
    ActiveChart.HasLegend = False ' VISTA??

    ' Put the data sheet name and date on the header at the left
    ' NOTE: A PRINTER MUST BE INSTALLED FIRST, OTHERWISE THE ActiveChart.PageSetup PROPERTIES WILL FAIL
    On Error GoTo Problem
    ActiveChart.ChartArea.Select
    With ActiveChart.PageSetup
        .LeftFooter = "Source sheet: " & Globals.OriginalWorksheetName & Chr(10) & _
                      "Source file: &Z&F" & Chr(10) & _
                      "Printed on &D, &T"
                      
        .LeftMargin = Application.InchesToPoints(0.75)
        .RightMargin = Application.InchesToPoints(0.75)
        .TopMargin = Application.InchesToPoints(1)
        .BottomMargin = Application.InchesToPoints(1)
        .HeaderMargin = Application.InchesToPoints(0.5)
        .FooterMargin = Application.InchesToPoints(0.5)
        .ChartSize = xlFullPage
        .Orientation = xlLandscape
    End With

Problem:
    ActiveChart.ChartArea.Select
End Sub

'****************************************************************
' Create the bitmap that will be used for the DMS contour chart
'****************************************************************
Private Sub CreateDmsBitMap()
    Sheets(m_DataSheetName).Select ' Make sure that your looking at the right sheet
    
    ' Locate the row and column range of the valid DMS data in the PlotData sheet
    Dim c1 As Long, c2 As Long, r1 As Long, r2 As Long, dp_idx As Integer
    c1 = m_Data.DataStartCol + m_FirstParticleIdx
    c2 = m_Data.DataStartCol + m_Data.NumSizeClasses - 1
    r1 = m_LowerSelectionRow
    r2 = m_UpperSelectionRow
    
    Dim low As String
    low = CStr(m_LowerSelectionRow)

    Dim result As Boolean, xlcol As Long, xlrow As Long, dms_data As Single, map_data As Double, row_decimation As Long
    result = m_BitMap.SetMinMax(m_LogMinCSD, m_LogMaxCSD) ' Provide clips for the bitmap's values
    row_decimation = m_BitMap.SetSize((c2 - c1 + 1), (r2 - r1 + 1)) ' Define the number of rows and columns in the bitmap. NOTE REVERSION OF ROWS AND COLUMNS
    Dim sum As Double, decimation_count As Long
    
    For xlcol = c1 To c2        ' Iterate through the columns
        dp_idx = xlcol - m_Data.DataStartCol
        decimation_count = 0
        For xlrow = r1 To r2    ' Iterate through the rows first
            'result = DmsSetBits(xlcol * 3 / 39 + 3 - 6 / 39) ' Horizontal test
            'result = DmsSetBits(xlrow * 3 / (r2 - r1 + 1) + 3 - 6 / (r2 - r1 + 1)) ' Vertical test
            dms_data = Cells(xlrow, xlcol) * m_Data.WeightingValue(dp_idx)
            
            If (dms_data < (10 ^ m_LogMinCSD)) Then
                map_data = m_LogMinCSD
            ElseIf (dms_data > (10 ^ m_LogMaxCSD)) Then
                map_data = m_LogMaxCSD
            Else
                map_data = Log(dms_data) / Log(10#)
            End If

            sum = sum + map_data
            decimation_count = decimation_count + 1
            If (decimation_count = row_decimation) Then
                result = m_BitMap.SetBits(sum / decimation_count) ' Populate the bitmap
                decimation_count = 0
                sum = 0
                If (result = False) Then GoTo Terminate
            End If
        Next xlrow
        
        ' Cater for the bit of the chart at the end that doesn't fit into an exact decimation_count
        If (decimation_count > 0) Then
            result = m_BitMap.SetBits(sum / decimation_count) ' Populate the bitmap
            decimation_count = 0
            sum = 0
            If (result = False) Then GoTo Terminate
        End If
    Next xlcol

Terminate:
    m_BitMap.WriteToFile (m_BitMapFile) ' ... and save to file
    If (result = False) Then
        Call MsgBox("The bitmap may be incomplete. Please check that the requested time range is charted.", vbOKOnly + vbExclamation, "Warning")
    End If
End Sub

'****************************************************************
' Create the contour chart on the same sheet as the legend
'****************************************************************
Private Sub CreateTheChart()
    
    CreateDmsBitMap ' Create the bitmap first

    Sheets(m_ChartSheetName).Select ' Make sure that your looking at the right sheet
    
    Dim i As Integer
    Dim xarray As Variant
    Dim yarray As Variant
    Dim xflt() As Long, yflt() As Long
    ReDim xflt(m_NumLabels)
    ReDim yflt(m_NumLabels)
    For i = 0 To m_NumLabels - 1
        xflt(i) = 0
        yflt(i) = CLng(m_Y1Scaling * Log(m_LabelArray(i)) / Log(10#))
    Next i
       
    xarray = Array(xflt)
    yarray = Array(yflt)
    
    ' Add a chart by plotting the label data from the PlotData sheet on the primary axes
    Charts.Add
    ActiveChart.ChartType = xlXYScatterLinesNoMarkers
    With ActiveChart
        Dim new_series As series
        Set new_series = .SeriesCollection.NewSeries
        new_series.values = yarray
        new_series.XValues = xarray
    End With
    
    If (Globals.ExcelVersion <= 11) Then ActiveChart.Location Where:=xlLocationAsObject, Name:=m_ChartSheetName
    
    With ActiveChart
        .HasTitle = False
        .Axes(xlCategory, xlPrimary).HasTitle = False
        .Axes(xlValue, xlPrimary).HasTitle = False
    End With
    With ActiveChart.Axes(xlCategory)
        .HasMajorGridlines = False
        .HasMinorGridlines = False
    End With
    With ActiveChart.Axes(xlValue)
        .HasMajorGridlines = False
        .HasMinorGridlines = False
    End With
    ActiveChart.HasLegend = False
    'ActiveWindow.visible = False
    
    ' Copy the analog data series
    Dim str As String
    
    If (Globals.ExcelVersion <= 11) Then Sheets(m_DataSheetName).Select
    
    ' Add the analog signal to the chart if it's been selected:
    Select Case m_AnalogSignalNumber
        Case Is = -1: str = "R" & CStr(m_LowerSelectionRow) & "C2:R" & CStr(m_UpperSelectionRow) & "C2"
        Case Is = 0: str = "R" & CStr(m_LowerSelectionRow) & "C2:R" & CStr(m_UpperSelectionRow) & "C2"
        Case Is = 1: str = "R" & CStr(m_LowerSelectionRow) & "C3:R" & CStr(m_UpperSelectionRow) & "C3"
        Case Is = 2: str = "R" & CStr(m_LowerSelectionRow) & "C4:R" & CStr(m_UpperSelectionRow) & "C4"
        Case Is = 3: str = "R" & CStr(m_LowerSelectionRow) & "C5:R" & CStr(m_UpperSelectionRow) & "C5"
    End Select
    
    ' Paste the analog data series data onto the chart
    If (Globals.ExcelVersion <= 11) Then
        Sheets(m_ChartSheetName).Select
        ActiveSheet.ChartObjects("Chart 1").Activate
        ActiveChart.SeriesCollection.Add Source:=m_DataSheetName & "!" & str
    Else
        ActiveChart.SeriesCollection.NewSeries
    End If
    
    ActiveChart.SeriesCollection(2).Name = "=""AnalogInput"""
    ActiveChart.SeriesCollection(2).XValues = "=" & m_DataSheetName & "!R" & CStr(m_LowerSelectionRow) & "C1:R" & CStr(m_UpperSelectionRow) & "C1"
    ActiveChart.SeriesCollection(2).values = "=" & m_DataSheetName & "!" & str
    
    ' Format the analog data series
    ActiveChart.SeriesCollection(2).Select
    Application.CutCopyMode = False
    With Selection.Border
        .ColorIndex = 2
        .Weight = xlMedium
        .LineStyle = xlContinuous
    End With
    With Selection
        .MarkerBackgroundColorIndex = xlNone
        .MarkerForegroundColorIndex = xlNone
        .MarkerStyle = xlNone
        .Smooth = False
        .MarkerSize = 3
        .Shadow = False
    End With
    
    ' Construct secondary X and Y axes
    ActiveChart.SeriesCollection(2).AxisGroup = 2

    ActiveChart.PlotArea.Select
    With ActiveChart
        .HasAxis(xlCategory, xlPrimary) = True
        .HasAxis(xlValue, xlPrimary) = True
        .HasAxis(xlCategory, xlSecondary) = True
        .HasAxis(xlValue, xlSecondary) = True
    End With
    'ActiveChart.Axes(xlCategory, xlPrimary).CategoryType = xlAutomatic
    'ActiveChart.Axes(xlCategory, xlSecondary).CategoryType = xlAutomatic
       
    ' Y1 axis (left axis) formatting
    ActiveChart.SeriesCollection(1).Select
    ActiveChart.Axes(xlValue).Select
    With Selection.Border
        .ColorIndex = 57
        .Weight = xlHairline
        .LineStyle = xlContinuous
    End With
    With Selection
        .MajorTickMark = xlNone
        .MinorTickMark = xlNone
        .TickLabelPosition = xlNone
    End With
    With ActiveChart.Axes(xlValue)
        .MinimumScale = m_MinScaleOnPrimaryAxis * m_Y1Scaling
        .MaximumScale = m_MaxScaleOnPrimaryAxis * m_Y1Scaling
        .MinorUnitIsAuto = True
        .MajorUnitIsAuto = True
        .Crosses = xlMaximum
        .ReversePlotOrder = False
        .ScaleType = xlLinear
        .DisplayUnit = xlNone
    End With
    Selection.TickLabels.AutoScaleFont = True
    With Selection.TickLabels.Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .Background = xlAutomatic
    End With
    
    ' Y2 axis (right axis) formatting
    ActiveChart.Axes(xlValue, xlSecondary).Select
    With ActiveChart.Axes(xlValue, xlSecondary)
        .MinimumScale = 0
        .MaximumScaleIsAuto = True
        .MinorUnitIsAuto = True
        .MajorUnitIsAuto = True
        .CrossesAt = 0
        .ReversePlotOrder = False
        .ScaleType = xlLinear
        .DisplayUnit = xlNone
        '.MaximumScale = 150
        '.MinorUnit = 5
        '.MajorUnit = 25
        '.Crosses = xlCustom
        '.CrossesAt = 0
    End With
    Selection.TickLabels.AutoScaleFont = True
    With Selection.TickLabels.Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .Background = xlAutomatic
    End With

    ' X2 Axis (lower axis) formatting
    ActiveChart.SeriesCollection(2).Select
    ActiveChart.Axes(xlCategory, xlSecondary).Select
    With ActiveChart.Axes(xlCategory, xlSecondary)
        '.MinimumScaleIsAuto = True
        .MinimumScale = m_LowerTimeWindow       ' Set the min and max scales
        .MaximumScale = m_UpperTimeWindow
        .MinorUnitIsAuto = True
        '.MajorUnit = 25
        .Crosses = xlMaximum
        .ReversePlotOrder = False
        '.ScaleType = xlLinear
        .DisplayUnit = xlNone
    End With
    Selection.TickLabels.AutoScaleFont = True
    With Selection.TickLabels.Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .Background = xlAutomatic
    End With
   
    If (m_Data.RealTime = True) Then
        Selection.TickLabels.NumberFormat = "hh:mm:ss"
    Else
        Selection.TickLabels.NumberFormat = "General"
    End If
            
    ' X1 axis (upper axis) formatting
    ActiveChart.Axes(xlCategory).Select
    With Selection.Border
        .Weight = xlHairline
        .LineStyle = xlAutomatic
    End With
    With Selection
        .MajorTickMark = xlNone
        .MinorTickMark = xlNone
        .TickLabelPosition = xlNone
    End With
    Selection.TickLabels.AutoScaleFont = True
    With Selection.TickLabels.Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .Background = xlAutomatic
    End With
  
    ActiveChart.PlotArea.Select
    With Selection.Border
        .ColorIndex = 16
        .Weight = xlThin
        .LineStyle = xlContinuous
    End With
    
    Selection.Fill.UserPicture PictureFile:=m_BitMapFile    ' Fill the plot areas with the bitmap
    Selection.Fill.visible = True
    
    ' Put data labels on Y1 axis (left axis)
    ActiveChart.SeriesCollection(1).Select
    With Selection.Border
        .Weight = xlThin
        .LineStyle = xlNone
    End With
    With Selection
        .MarkerBackgroundColorIndex = xlNone
        .MarkerForegroundColorIndex = 1
        .MarkerStyle = xlPlus
        .Smooth = False
        .MarkerSize = 4
        .Shadow = False
    End With
    ActiveChart.SeriesCollection(1).ApplyDataLabels AutoText:=True, LegendKey:=False
    
    CreatePrimaryAxisLabels
    TitlePrimaryAxis
    TitleSecondaryAxis

    ' If we don't want to see the analog input, just make it invisible and delete the secondary axis and title
    If (m_AnalogSignalNumber < 0) Then
        ActiveChart.PlotArea.Select
        ActiveChart.Axes(xlValue, xlSecondary).Select
        Selection.Delete
        ActiveChart.Axes(xlValue, xlSecondary).AxisTitle.Select
        Selection.Delete
        
        ActiveChart.SeriesCollection(2).Select
        Selection.Format.Line.visible = msoFalse
    End If
        
    If (Globals.ExcelVersion >= 12) Then ActiveChart.Location Where:=XlChartLocation.xlLocationAsObject, Name:=m_ChartSheetName

    RelocateChart
End Sub
'****************************************************************
' Create axis labels for the primary axis
'****************************************************************
Private Sub CreatePrimaryAxisLabels()

    'Sheets(m_ChartSheetName).Select ' Make sure that your looking at the right sheet
    ActiveChart.SeriesCollection(1).Select
    ActiveChart.SeriesCollection(1).ApplyDataLabels AutoText:=True, LegendKey:=False
    
    ActiveChart.SeriesCollection(1).DataLabels.Select
    Selection.AutoScaleFont = True
    With Selection.Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .Background = xlAutomatic
    End With
    With Selection
        .HorizontalAlignment = xlRight
        .VerticalAlignment = xlCenter
        .ReadingOrder = xlContext
        .Position = xlLabelPositionLeft
        .Orientation = xlHorizontal
    End With

    ' Apply the label text from the PlotData sheet
    Dim l As Integer, idx As Integer
    l = 0
    With ActiveChart.SeriesCollection(1)
        idx = m_LabelArray(0) - 1

        For l = 0 To m_NumLabels - 1
              .Points(l + 1).DataLabel.Select
              If (m_LabelChoice(idx) = True) Then
                  Selection.Text = CStr(m_LabelArray(l))
              Else
                  Selection.Text = ""
              End If
              idx = (idx + 1) Mod 9
        Next l
    End With
    ActiveChart.ChartArea.Select
End Sub

'****************************************************************
' Give the primary axis a title
'****************************************************************
Private Sub TitlePrimaryAxis()

    'ActiveSheet.ChartObjects("Chart 1").Activate
    ActiveChart.ChartArea.Select
    With ActiveChart
        .Axes(xlValue, xlPrimary).HasTitle = True
        Dim xaxis_title As String
        xaxis_title = "Particle diameter" & Chr(10) & "(nm)"
        If (Globals.ExcelVersion >= 12) Then ' Need to add a couple of CR/LF to stand the x-axis title off from the axis, otherwise it appears buried inside it.
            xaxis_title = xaxis_title & Chr(10) & Chr(10)
        End If
        .Axes(xlValue, xlPrimary).AxisTitle.Characters.Text = xaxis_title
    End With
    ActiveChart.Axes(xlValue, xlPrimary).AxisTitle.Select
    Selection.AutoScaleFont = False
    With Selection.Characters(Start:=1, Length:=22).Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        '.ColorIndex = xlAutomatic
    End With
    
    ' Move the title so that it doesn't cover the chart after the above formatting
    If (Globals.ExcelVersion <= 11) Then
        ActiveChart.ChartArea.Select
        ActiveChart.Axes(xlValue).AxisTitle.Select
        Selection.Left = 1
        Selection.Top = 63
    End If
End Sub

'****************************************************************
' Give the primary axis a title
'****************************************************************
Private Sub TitleSecondaryAxis()

    'ActiveSheet.ChartObjects("Chart 1").Activate
    ActiveChart.ChartArea.Select
    With ActiveChart
        .Axes(xlValue, xlSecondary).HasTitle = True
        .Axes(xlValue, xlSecondary).AxisTitle.Characters.Text = Worksheets(m_DataSheetName).Cells(6, m_AnalogSignalNumber + 2).Value
    End With
    ActiveChart.Axes(xlValue, xlSecondary).AxisTitle.Select
    Selection.AutoScaleFont = False
    With Selection.Characters(Start:=1, Length:=100).Font
        .Name = "Arial"
        .FontStyle = "Regular"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        '.ColorIndex = xlAutomatic
    End With
End Sub

'****************************************************************
' Move the contour chart to the top part of the page and scale
' so that it fits across a landscape setup.
'****************************************************************
Private Sub RelocateChart()
    Sheets(m_ChartSheetName).Select

    Dim num_shapes As Integer
    num_shapes = ActiveSheet.Shapes.Count
    ActiveSheet.Shapes(num_shapes).Left = 20
    ActiveSheet.Shapes(num_shapes).Width = 680

    'ActiveSheet.ChartObjects("Chart 1").Activate
    'ActiveChart.ChartArea.Select
    'ActiveSheet.Shapes("Chart 1").IncrementLeft -179.5
    'ActiveSheet.Shapes("Chart 1").IncrementTop -48.67
    'ActiveSheet.Shapes("Chart 1").ScaleWidth 1.98, msoFalse, msoScaleFromTopLeft
    'ActiveSheet.Shapes("Chart 1").ScaleHeight 0.74, msoFalse, msoScaleFromTopLeft
End Sub
Attribute VB_Name = "CFileSpec"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'****************************************************************
' Encapsulates the DMS file specification
'****************************************************************
Option Explicit

'Private m_UiVersion As Single
Private m_RealTimeFormat As String

' Specific file specification
Private Const m_NumRings As Long = 22     ' Fixed number of rings
Private m_SizeClassStartCol As Long ' The column where the inverted DMS data starts in the DMS data sheet
Private m_RingCurrentStartCol As Long          ' The column where the ring currents start in the DMS data sheet

' Generic cell ranges for which accessors are required
Private m_TimePlusA2dHeaderRange As String
Private m_A2dHeaderRange As String
Private m_Sync1Cell As String
Private m_Sync2Cell As String
Private m_Sync3Cell As String
Private m_Sync4Cell As String
Private m_TimestampCell As String
Private m_DataCell As String
Private m_MatrixFilenameCell As String
Private m_CalibrationExpiry As String

Private Const m_TotalNperCcCol As Long = 6
Private Const m_DilutionRatioCol As Long = 11
Private Const m_SampleFlowCol As Long = 12

Private m_DataStartRow As Long                 ' The row where the DMS data starts
Private m_DataStartCol As Long
Private m_DataHeaderRange As String
Private m_NumDataCols As Long
Private m_NumDataRows As Long                  ' Extent of the DMS data, not including the header
Private m_NumRowsInSheet As Long               ' Extent of the DMS data, including the header
Private m_NumColsInSheet As Long

Private m_SampleInterval As Double             ' DeltaTime (Secs) between data samples (t2-t1)
Private m_NumAverageSamples As Long            ' = (t2-t1)*10 ... The number of DMS file samples per analyser sample rate
Private m_MinTime As Double                    ' Smallest time in the data
Private m_MaxTime As Double                    ' Largest time in the data
Private m_RealTime As Boolean                  ' True if the first column of the DMS file contains absolute date format

' Specific parameters found the header region of the DMS file
Private Const m_SampleFlowSetpointCell As String = "R4C6"
Private Const m_MinDpDisplayCell As String = "R4C10"
Private Const m_MaxDpDisplayCell As String = "R4C11"
Private Const m_LogMinDpCell As String = "R4C12"
Private Const m_NumSizeClassesPerDecadeCell As String = "R4C13"

Private m_DilutionCorrectionEnabled As Boolean
Private m_NumModes As Long
Private m_NumSizeClasses As Long               ' Variable number of inverted data columns
Private m_NumSizeClassesPerDecade As Integer

Private m_FirstDilCol ' for v5 DMS files
Private Const m_ExtraColsV5 = 6

Private m_ModeSpec() As Globals.SModeSpec

Private m_SampleFlowSetpoint As Double
Private m_LogMinDp As Double                   ' Smallest particle size in the data file
Private m_LogMaxDp As Double                   ' Largest particle size in the data file
Private m_MinDpDisplay As Single               ' Lower limit for charting
Private m_MaxDpDisplay As Single               ' Upper limit for charting

Private m_WeightingMessage As String    ' The text stored in D1 to indicate that we've already weighted this DMS file

' Parameters calculated from other sources
Private m_WeightingText As String
Private m_WeightingValue() As Single

' Allows us to distinguish between different source file types
Public Enum ESourceFileType
    DmsFile = 0
    DmeFile = 1
End Enum
Private m_SourceFileType As ESourceFileType

' Allows us to distinguish between source data in the DMS file
Public Enum ESourceDataType
    ParticleSizeData = 0
    RingCurrentData = 1
End Enum
Private m_SourceDataType As ESourceDataType

' Used to decide whether the DMS file contains relative time or absolute (realtime)
' Relative times are imported as scientific, absolute times are imported as custom formats beginning with m, d, h, etc
Private Enum ECellFormatType
    Number = 0
    Date = 1
End Enum

' Members used internally...that have no accessors
Private Const m_NumColsBetweenSizeClassesAndRingCurrents As Integer = 4
Private Const m_DmeDataStartRow As Long = 2
Private Const m_DmsDataStartRow As Long = 7
Private m_RingCurrentDataCell As String
Private m_LogMinDpDisplay As Single            ' Lower limit for charting
Private m_LogMaxDpDisplay As Single            ' Upper limit for charting
Private m_SizeClassHeaderRange As String
Private m_RingCurrentHeaderRange As String
Private m_MinDp As Single                      ' Smallest particle size in the data file
Private m_MaxDp As Single                      ' Largest particle size in the data file

' A whole bunch of accessor functions that allow clients to get the values of the parameters
Property Get NumRings()
    NumRings = m_NumRings
End Property
Property Get NumModes()
    NumModes = m_NumModes
End Property

Property Get FirstDilCol()
    FirstDilCol = m_FirstDilCol
End Property

Property Get ExtraColsV5()
ExtraColsV5 = m_ExtraColsV5
End Property

Property Get ModeSpec() As Globals.SModeSpec()
    ModeSpec = m_ModeSpec
End Property
Property Get ModeDensity(idx As Integer)
    If (idx < 0 Or idx >= m_NumModes) Then ModeDensity = 0 Else ModeDensity = m_ModeSpec(idx).density
End Property
Property Get ModePower(idx As Integer)
    If (idx < 0 Or idx >= m_NumModes) Then ModePower = 0 Else ModePower = m_ModeSpec(idx).power
End Property
Property Get Modename(idx As Integer)
    If (idx < 0 Or idx >= m_NumModes) Then Modename = "" Else Modename = m_ModeSpec(idx).Modename
End Property

Property Get IsAlreadyWeighted()
    Dim weighting_message As String
    Dim retval As Variant

    weighting_message = UCase(ActiveSheet.Cells(1, 4))
    retval = InStr(weighting_message, "WEIGHTED")
    Select Case retval
        Case Null
            IsAlreadyWeighted = False
        Case 0
            IsAlreadyWeighted = False
        Case Else
            IsAlreadyWeighted = True
    End Select
End Property

Public Sub SetWeightingMessage(weighting_message As String)
    Cells(1, 4) = weighting_message
    m_WeightingMessage = weighting_message
End Sub

Public Function GetWeightingUnits() As String
    'Spectrum weighted by mass: Power=3, Shape factor=0.523598775666667, Density=1000, Units=dMdlogDp ug/cc
    'Spectrum weighted by volume: Power=3, Density factor=5.24e-16, Units=dMdlogDp ug/cc
    
    Dim weighting_message As String
    Dim i As Integer
    i = InStr(weighting_message, ":")
    weighting_message = Right(m_WeightingMessage, Len(m_WeightingMessage) - i)
    
    Dim the_split() As String, the_item() As String
    the_split = Split(weighting_message, ",")
    
    Dim token_idx As Integer, num_items As Integer
    num_items = UBound(the_split)
    Dim power As String, density As String, shape_factor As String, density_factor As String
    
    For token_idx = 0 To num_items
        
        i = InStr(the_split(token_idx), "=")
        the_item = Split(the_split(token_idx), "=")
   
        If (the_item(0) = " Power") Then
            power = the_item(1)
        ElseIf (the_item(0) = " Shape factor") Then
            shape_factor = the_item(1)
        ElseIf (the_item(0) = " Density factor") Then
            density_factor = the_item(1)
        ElseIf (the_item(0) = " Density") Then
            density = the_item(1)
        ElseIf (the_item(0) = " Units") Then
            GetWeightingUnits = the_item(1)
        End If
        
    Next token_idx
    
End Function
Public Function GetWeightingMessage() As String
    GetWeightingMessage = m_WeightingMessage
End Function

Property Get SizeClassStartCol()
    SizeClassStartCol = m_SizeClassStartCol
End Property
Property Get RingCurrentStartCol()
    RingCurrentStartCol = m_RingCurrentStartCol
End Property
Property Get DilutionCorrectionEnabled()
    DilutionCorrectionEnabled = m_DilutionCorrectionEnabled
End Property

Property Get TimePlusA2dHeaderRange()
    TimePlusA2dHeaderRange = m_TimePlusA2dHeaderRange
End Property
Property Get A2dHeaderRange()
    A2dHeaderRange = m_A2dHeaderRange
End Property
Property Get Sync1Cell()
    Sync1Cell = m_Sync1Cell
End Property
Property Get Sync2Cell()
    Sync2Cell = m_Sync2Cell
End Property
Property Get Sync3Cell()
    Sync3Cell = m_Sync3Cell
End Property
Property Get Sync4Cell()
    Sync4Cell = m_Sync4Cell
End Property
Property Get TimestampCell()
    TimestampCell = m_TimestampCell
End Property
Property Get DataCell()
    DataCell = m_DataCell
End Property
Property Get MatrixFilenameCell()
    MatrixFilenameCell = m_MatrixFilenameCell
End Property
Property Get CalibrationExpiry()
    CalibrationExpiry = m_CalibrationExpiry
End Property
Property Get TotalNperCcCol()
    TotalNperCcCol = m_TotalNperCcCol
End Property
Property Get DilutionRatioCol()
    DilutionRatioCol = m_DilutionRatioCol
End Property
Property Get SampleFlowCol()
    SampleFlowCol = m_SampleFlowCol
End Property

Property Get DataStartRow()
    DataStartRow = m_DataStartRow
End Property
Property Get DataStartCol()
    DataStartCol = m_DataStartCol
End Property
Property Get DataHeaderRange()
    DataHeaderRange = m_DataHeaderRange
End Property
Property Get NumDataCols()
    NumDataCols = m_NumDataCols
End Property
Property Get NumDataRows() As Long
    NumDataRows = m_NumDataRows
End Property
Property Get NumRowsInSheet() As Long
    NumRowsInSheet = m_NumRowsInSheet
End Property
Property Get NumColsInSheet() As Long
    NumColsInSheet = m_NumColsInSheet
End Property

Property Get SampleInterval() As Double
    SampleInterval = m_SampleInterval
End Property
Property Get NumAverageSamples() As Long
    NumAverageSamples = m_NumAverageSamples
End Property
Property Get MinTime() As Double
    MinTime = m_MinTime
End Property
Property Get MaxTime() As Double
    MaxTime = m_MaxTime
End Property
Property Get RealTime() As Boolean
    RealTime = m_RealTime
End Property
Property Get RealTimeFormat()
    RealTimeFormat = m_RealTimeFormat
End Property

Property Get SampleFlowSetpoint() As Double
    SampleFlowSetpoint = m_SampleFlowSetpoint
End Property
Property Get LogMinDp() As Double
    LogMinDp = m_LogMinDp
End Property
Property Get LogMaxDp() As Double
    LogMaxDp = m_LogMaxDp
End Property
Property Get MinDpDisplay()
    MinDpDisplay = m_MinDpDisplay
End Property
Property Get MaxDpDisplay()
    MaxDpDisplay = m_MaxDpDisplay
End Property
Property Get NumSizeClasses()
    NumSizeClasses = m_NumSizeClasses
End Property
Property Get NumSizeClassesPerDecade()
    NumSizeClassesPerDecade = m_NumSizeClassesPerDecade
End Property

Property Get WeightingText() As String
    WeightingText = m_WeightingText
End Property
Property Get WeightingValue(i As Integer) As Double
    WeightingValue = m_WeightingValue(i)
End Property

Property Get SourceFileType()
    SourceFileType = m_SourceFileType
End Property
Property Get SourceDataType()
    SourceDataType = m_SourceDataType
End Property

Public Sub ConfigureDataSource(filetype As ESourceFileType, datatype As ESourceDataType)
    m_SourceFileType = filetype
    m_SourceDataType = datatype
    
    Select Case filetype
        Case ESourceFileType.DmeFile
            
            If (datatype = ParticleSizeData) Then
                MsgBox ("Internal error: Particle size template is incompatible with DME files!")
                Exit Sub
            End If
            
            Call InitialiseDmeParameters
            
            m_TimePlusA2dHeaderRange = "A1:E1"
            m_A2dHeaderRange = "B1:E1"
            m_Sync1Cell = "R2C2"
            m_Sync2Cell = "R2C3"
            m_Sync3Cell = "R2C4"
            m_Sync4Cell = "R2C5"
            m_TimestampCell = "R2C1"
            
            m_DataStartRow = m_DmeDataStartRow
            
            m_DataStartCol = m_RingCurrentStartCol
            m_DataCell = "R2C6"
            m_DataHeaderRange = "R1C6:R1C27"
            m_NumDataCols = m_NumRings

        Case ESourceFileType.DmsFile
        
            m_TimePlusA2dHeaderRange = "A6:E6"
            m_A2dHeaderRange = "B6:E6"
            m_Sync1Cell = "R" & CStr(m_DmsDataStartRow) & "C" & "2"
            m_Sync2Cell = "R" & CStr(m_DmsDataStartRow) & "C" & "3"
            m_Sync3Cell = "R" & CStr(m_DmsDataStartRow) & "C" & "4"
            m_Sync4Cell = "R" & CStr(m_DmsDataStartRow) & "C" & "5"
            m_TimestampCell = "R" & CStr(m_DmsDataStartRow) & "C" & "1"
    
            m_DataStartRow = m_DmsDataStartRow
            Call InitialiseDmsParameters
            If (datatype = ParticleSizeData) Then
                m_DataStartCol = m_SizeClassStartCol
                m_DataCell = "R" & CStr(m_DmsDataStartRow) & "C" & CStr(m_SizeClassStartCol)
                m_DataHeaderRange = m_SizeClassHeaderRange
                m_NumDataCols = m_NumSizeClasses
                
            ElseIf (datatype = RingCurrentData) Then
                m_DataStartCol = m_RingCurrentStartCol
                m_DataCell = m_RingCurrentDataCell
                m_DataHeaderRange = m_RingCurrentHeaderRange
                m_NumDataCols = m_NumRings
            End If
            
    End Select
    
End Sub

Private Sub InitialiseDmsParameters()
    
    If (Len(Cells(5, 8).Text) > 0) Then
        m_SampleInterval = Cells(5, 8)
        m_RealTimeFormat = Cells(5, 9)
        m_NumAverageSamples = m_SampleInterval * 10
    
        If (Len(m_RealTimeFormat) > 0) Then
            m_RealTime = True
        Else
             m_RealTime = False
        End If
    Else
        m_RealTime = Globals.IsRealTimeFormat() ' Is the timestamp relative or absoluate time?
        m_NumAverageSamples = GetNumAverageSamples()
        m_SampleInterval = m_NumAverageSamples / 10
    End If
    m_WeightingMessage = Cells(1, 4)
        
    If (m_SampleInterval <= 0) Then
        MsgBox ("Sample Interval must be greater than 0!")
    End If
    
    If (InStr(Cells(5, 5), "enabled") > 0) Then
        m_DilutionCorrectionEnabled = True
    Else
        m_DilutionCorrectionEnabled = False
    End If
    
    m_SizeClassStartCol = 12
    Do
        m_SizeClassStartCol = m_SizeClassStartCol + 1
    Loop Until IsNumeric(Cells(m_DmsDataStartRow - 1, m_SizeClassStartCol))
    m_NumModes = (m_SizeClassStartCol - 13) / 3

    ReDim m_ModeSpec(m_NumModes) As SModeSpec

    Dim mode_strings() As String
    If (m_NumModes = 1) Then
        mode_strings = Split(Cells(3, 16))
        m_ModeSpec(0).Modename = mode_strings(0)
        m_ModeSpec(0).density = Cells(4, 16)
        m_ModeSpec(0).power = Cells(4, 17)
        m_MatrixFilenameCell = "R3C18"
        m_CalibrationExpiry = Cells(4, 19)
    End If
    If (m_NumModes = 2) Then
        mode_strings = Split(Cells(3, 16))
        m_ModeSpec(0).Modename = mode_strings(0)
        m_ModeSpec(0).density = Cells(4, 16)
        m_ModeSpec(0).power = Cells(4, 17)
        
        mode_strings = Split(Cells(3, 18))
        m_ModeSpec(1).Modename = mode_strings(0)
        m_ModeSpec(1).density = Cells(4, 18)
        m_ModeSpec(1).power = Cells(4, 19)
        m_MatrixFilenameCell = "R3C20"
        m_CalibrationExpiry = Cells(4, 21)
    End If
    If (m_NumModes = 3) Then
        mode_strings = Split(Cells(3, 16))
        m_ModeSpec(0).Modename = mode_strings(0)
        m_ModeSpec(0).density = Cells(4, 16)
        m_ModeSpec(0).power = Cells(4, 17)
        
        mode_strings = Split(Cells(3, 18))
        m_ModeSpec(1).Modename = mode_strings(0)
        m_ModeSpec(1).density = Cells(4, 18)
        m_ModeSpec(1).power = Cells(4, 19)
        
        mode_strings = Split(Cells(3, 20))
        m_ModeSpec(2).Modename = mode_strings(0)
        m_ModeSpec(2).density = Cells(4, 20)
        m_ModeSpec(2).power = Cells(4, 21)
        m_MatrixFilenameCell = "R3C22"
        m_CalibrationExpiry = Cells(4, 23)
    End If
    
    m_NumSizeClasses = 0
    Do
        m_NumSizeClasses = m_NumSizeClasses + 1
    Loop Until Not IsNumeric(Cells(m_DmsDataStartRow - 1, m_SizeClassStartCol + m_NumSizeClasses))

    'ReDim m_WeightingValue(m_NumSizeClasses) As Single
    'Call CalculateWeighting(1, 0, 1, "dN/dlogdp /cc")

    m_SampleFlowSetpoint = Range(Globals.R1C1toA1(m_SampleFlowSetpointCell)).Value
    m_MinDpDisplay = Range(Globals.R1C1toA1(m_MinDpDisplayCell)).Value
    m_MaxDpDisplay = Range(Globals.R1C1toA1(m_MaxDpDisplayCell)).Value
    
    If (IsNumeric(Range(Globals.R1C1toA1(m_LogMinDpCell)).Value)) Then
        m_LogMinDp = Range(Globals.R1C1toA1(m_LogMinDpCell)).Value
    Else
        m_LogMinDp = 0.5
    End If
    
    m_NumSizeClassesPerDecade = Range(Globals.R1C1toA1(m_NumSizeClassesPerDecadeCell)).Value
    If (m_NumSizeClassesPerDecade = 0) Then m_NumSizeClassesPerDecade = 16
    
    m_MinDp = Cells(m_DmsDataStartRow - 1, m_SizeClassStartCol)
    m_MaxDp = Cells(m_DmsDataStartRow - 1, m_SizeClassStartCol + m_NumSizeClasses - 1)
    m_LogMaxDp = Log(m_MaxDp) / Log(10#)
    
    If (m_MinDpDisplay < m_MinDp) Then m_MinDpDisplay = m_MinDp
    If (m_MaxDpDisplay > m_MaxDp) Then m_MaxDpDisplay = m_MaxDp
    
    m_LogMinDpDisplay = Log(m_MinDpDisplay) / Log(10#)
    m_LogMaxDpDisplay = Log(m_MaxDpDisplay) / Log(10#)
    
    ' Get extent of the DMS data rows
    Range("A" & CStr(m_DmsDataStartRow)).Select
    m_NumDataRows = Globals.GetRowsExtent()
    m_NumRowsInSheet = m_NumDataRows + m_DmsDataStartRow - 1
    
    Range("A" & CStr(m_DmsDataStartRow - 1)).Select
    m_NumColsInSheet = Globals.GetColumnsExtent()

    m_MinTime = Cells(m_DmsDataStartRow, 1)
    m_MaxTime = Cells(m_NumRowsInSheet, 1)
        
    m_SizeClassHeaderRange = "R" & CStr(m_DmsDataStartRow - 1) & "C" & CStr(m_SizeClassStartCol) & ":" & _
                           "R" & CStr(m_DmsDataStartRow - 1) & "C" & CStr(m_SizeClassStartCol + m_NumSizeClasses - 1)

    m_RingCurrentStartCol = m_SizeClassStartCol + m_NumSizeClasses + m_NumColsBetweenSizeClassesAndRingCurrents
    m_RingCurrentHeaderRange = "R" & CStr(m_DmsDataStartRow - 1) & "C" & CStr(m_RingCurrentStartCol) & ":" & _
                             "R" & CStr(m_DmsDataStartRow - 1) & "C" & CStr(m_RingCurrentStartCol + m_NumRings - 1)

    m_RingCurrentDataCell = "R" & CStr(m_DmsDataStartRow) & "C" & CStr(m_RingCurrentStartCol)
    m_FirstDilCol = m_RingCurrentStartCol + m_NumRings + 1
    

End Sub

Private Function GetNumAverageSamples() As Long

    Dim timestring1, ms1, ts1 As String
    Dim timestring2, ms2, ts2 As String
    
    If (Globals.IsRealTimeFormat() = True) Then
        If InStr(ActiveSheet.Range("A7").NumberFormat, ":") Then
            GetNumAverageSamples = CLng((CDbl(ActiveSheet.Range("A8").Value - CDbl(ActiveSheet.Range("A7"))) / (1 / 864000)))
        Else
            timestring1 = ActiveSheet.Range("A7").Value
            timestring2 = ActiveSheet.Range("A8").Value
            If (Left(Right(timestring1, 2), 1) <> Application.International(xlDecimalSeparator)) Then ' There is no fractional part to this timestamp
                GetNumAverageSamples = CLng((CDbl(TimeValue(timestring2)) - CDbl(TimeValue(timestring1))) / (1 / 864000))
            Else ' There is a fractional part to this timestamp
                ms1 = Right(timestring1, 1)
                ms2 = Right(timestring2, 1)
                ts1 = Left(timestring1, Len(timestring1) - 2)
                ts2 = Left(timestring2, Len(timestring2) - 2)
                GetNumAverageSamples = CLng((CDbl(TimeValue(ts2)) + CDbl(ms2) - CDbl(TimeValue(ts1)) - CDbl(ms1)) / (1 / 864000))
            End If
        End If
    Else
        GetNumAverageSamples = CLng(((ActiveSheet.Range("A8").Value) - (ActiveSheet.Range("A7").Value)) * 10)
    End If
End Function

Private Sub InitialiseDmeParameters()
    ' DMS files do not contain absolute time or relative time, but some PIC clock count.
    m_RealTime = False
    m_SampleInterval = Cells(m_DmeDataStartRow + 1, 1) - Cells(m_DmeDataStartRow, 1)
    
    If (m_SampleInterval <= 0) Then MsgBox ("Sample Interval must be greater than 0!")
    
    ' Get extent of the DME data rows
    Range("A" & CStr(m_DmeDataStartRow)).Select
    m_NumDataRows = GetRowsExtent()
    m_NumRowsInSheet = m_NumDataRows + m_DmeDataStartRow - 1
    
    m_MinTime = Cells(m_DmeDataStartRow, 1)
    m_MaxTime = Cells(m_NumRowsInSheet, 1)
    
    m_RingCurrentStartCol = 6
End Sub

' The weighting is dependant on the size classes either in the DMS file (if no weighting inversion matrix is used) or in the inversion matrix.
' For this reasons, there are weighting methods in each of CInversionMatrix module (here) and CFileSpec module. Only the CFileSpec module needs a WeightingText property
' as this is used in the CDmsChart module when creating a contour plot.

' Calculate the weighting values to be applied to particle size
' The equation used here is (constant * particle_size/1000)^power * density_multiplier
Public Sub CalculateWeighting(constant As Single, power As Single, density_multiplier As Single, Text As String)
    Dim i As Integer
    ReDim m_WeightingValue(m_NumSizeClasses) As Single
    For i = 0 To m_NumSizeClasses - 1
        m_WeightingValue(i) = constant * ((Cells(m_DataStartRow - 1, m_SizeClassStartCol + i) / 1000#) ^ power) * density_multiplier
    Next i
    
    m_WeightingText = Text
End Sub

' Returns Number (meaning that the cell contains relative time), or Date (meaning that the cell contains realtime)
' Numbers are formatted as General, 0.00, #0.0, 0.00E+00, |fffd|
' Dates are formatted as ddmmyyyy hh, etc
Private Function GetFormat(cell As String) As ECellFormatType
    Dim strTest As String
    strTest = Range(cell).NumberFormat

    If (strTest = "General") Then
        GetFormat = Number
    ElseIf (Left(strTest, 1) = "0") Then
        GetFormat = Number
    ElseIf (Left(strTest, 1) = "#") Then
        GetFormat = Number
    Else: GetFormat = Date
    End If
End Function

Attribute VB_Name = "CInversion"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim WithEvents inversion_matrix As CInversionMatrix
Attribute inversion_matrix.VB_VarHelpID = -1
Dim progress_form As ProgressControl

Private m_InvertSheetName As String

'****************************************************************
' This function is invoked when the user hits the "Re-invert" button.
' It inverts DMS data using a new inversion matrix, but the same
' inversion algorithm that was used to acquire the original data.
'****************************************************************
Public Sub Invert(ByRef inv_dlg As InversionControl, ByRef file_spec As CFileSpec)
                 
    Call Globals.SetTemporarySheets("Inv")
    m_InvertSheetName = Globals.TemporaryInsertedSheetName
    
    ' The inversion_matrix object encapsulates the least squares operations
    Set inversion_matrix = New CInversionMatrix
    If (inversion_matrix.Init(inv_dlg, file_spec) = False) Then GoTo InversionProblem

    Call file_spec.CalculateWeighting(inv_dlg.tbWeightingConstant, inv_dlg.WeightingPower, inv_dlg.DensityMultiplier, inv_dlg.tbWeightingText)
    Call inversion_matrix.CalculateWeighting(inv_dlg.tbWeightingConstant, inv_dlg.WeightingPower, inv_dlg.DensityMultiplier)
    
    ' Copy sheets and rename
    Sheets(ActiveSheet.Name).Copy After:=Sheets(Sheets.Count)
    Sheets(ActiveSheet.Name).Name = m_InvertSheetName
        
    Dim cols_to_add As Integer, col As Integer
    
    ' Adapt columns of particle size data
    cols_to_add = inversion_matrix.m_AnalogOutputs.NumSizeClasses - file_spec.NumSizeClasses
    If (cols_to_add > 0) Then
        Range(Cells(6, file_spec.DataStartCol + 1), Cells(file_spec.NumRowsInSheet, file_spec.DataStartCol + 1)).Select
        For col = 1 To cols_to_add
            Selection.Insert Shift:=xlToRight
        Next col
    ElseIf (cols_to_add < 0) Then
        ' Remove unwanted columns from the DMS sheet.
        ' Starting at any column will do as long as it's in the particle size area
        Dim first_col_to_delete As Long, last_col_to_delete As Long
        first_col_to_delete = file_spec.DataStartCol + 1
        last_col_to_delete = file_spec.DataStartCol - cols_to_add - 1
        
        Range(Cells(6, first_col_to_delete), Cells(file_spec.NumRowsInSheet, last_col_to_delete)).Delete (xlShiftToLeft)
    End If
    
    ' Insert the new size class data
    For col = 0 To inversion_matrix.m_AnalogOutputs.NumSizeClasses - 1
        Cells(file_spec.DataStartRow - 1, file_spec.DataStartCol + col) = inversion_matrix.m_AnalogOutputs.SizeClass(col)
    Next col
    ' format size class data
    Range(Cells(file_spec.DataStartRow - 1, file_spec.DataStartCol), Cells(file_spec.DataStartRow - 1, file_spec.DataStartCol + inversion_matrix.m_AnalogOutputs.NumSizeClasses - 1)).Select
    Selection.NumberFormat = "0" + Globals.DecimalSeparator + "00"
    
    ' Replace the inversion matrix parameters in the DMS file
    Cells(4, 12) = inversion_matrix.m_LogMinDp
    Cells(4, 13) = inversion_matrix.m_AnalogOutputs.NumSizeClassesPerDecade
    Cells(4, 14) = inversion_matrix.m_MatrixVersion
    Cells(4, 15) = inversion_matrix.m_MaxSvdIterations
    
    Dim m As Integer
    For m = 0 To inversion_matrix.m_AnalogOutputs.NumModes - 1
        Cells(3, 16 + m * 2) = inversion_matrix.m_AnalogOutputs.GetModeSpec(m).Modename & " Mode Density"
        Cells(4, 16 + m * 2) = inversion_matrix.m_AnalogOutputs.GetModeSpec(m).density
        Cells(3, 16 + m * 2 + 1) = inversion_matrix.m_AnalogOutputs.GetModeSpec(m).Modename & " Mode Power"
        Cells(4, 16 + m * 2 + 1) = inversion_matrix.m_AnalogOutputs.GetModeSpec(m).power
    Next m
    If (Len(inversion_matrix.m_MatrixFileName) > 0) Then
        Cells(3, 16 + m * 2) = "Matrix File Path"
        Cells(4, 16 + m * 2) = inversion_matrix.m_MatrixFileName
    End If
    Cells(3, 17 + m * 2) = "Calibration Expiry Date"
    Cells(4, 17 + m * 2) = file_spec.CalibrationExpiry()
    Dim j As Integer
    For j = 1 To 4 ' clear now unused cells
    Cells(3, j + 17 + m * 2) = ""
    Cells(4, j + 17 + m * 2) = ""
    Next
    
    ' now delete any existing summary calculation data
    
    Dim first_moment_col As Integer, last_moment_col As Integer
    If (file_spec.NumModes > 0) Then
        Dim test_string As String
        test_string = file_spec.Modename(0) & " mode surface area (|fffd|m^2/cc)"
        Dim test_range As Range
        Set test_range = Rows("6:6")
        On Error Resume Next
        first_moment_col = WorksheetFunction.Match(test_string, test_range, 0)
        If Err.Number <> 0 Then ' test_string not found
            Err.Clear
        Else
            Dim jj As Integer
            For jj = 1 To file_spec.NumModes
            Columns(first_moment_col + (jj - 1) * 2).Clear
            Columns(first_moment_col + (jj - 1) * 2 + 1).Clear
            Next
        End If
        End If
    
    ' Copy AO string to the relevant cells
    Cells(5, 1) = inv_dlg.CreateAoString(1)
    Cells(5, 2) = inv_dlg.CreateAoString(2)
    Cells(5, 3) = inv_dlg.CreateAoString(3)
    Cells(5, 4) = inv_dlg.CreateAoString(4)
    
    ' Copy AO string to the AO header
    Cells(6, 7) = Cells(5, 1)
    Cells(6, 8) = Cells(5, 2)
    Cells(6, 9) = Cells(5, 3)
    Cells(6, 10) = Cells(5, 4)
    
    Cells(1, 4) = inv_dlg.CreateWeightingMessageString()
    Cells(6, 6) = "Total " & inv_dlg.GetSpectralWeightingUnits()

    ' Adapt columns of mode data
    cols_to_add = (inversion_matrix.m_AnalogOutputs.NumModes - file_spec.NumModes) * 3
    If (cols_to_add > 0) Then
        Range(Cells(6, 13), Cells(file_spec.NumRowsInSheet, 13)).Select
        For col = 1 To cols_to_add
            Selection.Insert Shift:=xlToRight
        Next col
    ElseIf (cols_to_add < 0) Then
        Range(Cells(6, 13), Cells(file_spec.NumRowsInSheet, 13 - cols_to_add - 1)).Delete (xlShiftToLeft)
    End If
    
    For col = 0 To (inversion_matrix.m_AnalogOutputs.NumModes - 1)
        Cells(6, col * 3 + 13) = inversion_matrix.m_AnalogOutputs.GetModeSpec(col).Modename & " Mode CMD"
        Cells(6, col * 3 + 14) = inversion_matrix.m_AnalogOutputs.GetModeSpec(col).Modename & " Mode Concentration"
        Cells(6, col * 3 + 15) = inversion_matrix.m_AnalogOutputs.GetModeSpec(col).Modename & " Mode GSD"
    Next

    Call file_spec.ConfigureDataSource(DmsFile, ParticleSizeData)
    
    Set progress_form = New ProgressControl
    progress_form.Show vbModeless
                                                                   
    ' Invert with the matrix selection
    DoEvents
    Call inversion_matrix.Process(file_spec)
    
    ' Update dilution correction
    If (inv_dlg.ApplyDilutionCorrection = False) Then
        Cells(5, 5) = "Dilution correction disabled"
    Else
        Call ApplyDilutionCorrection(file_spec)
        Cells(5, 5) = "Dilution correction enabled"
    End If

NormalTerminate:
    Call inversion_matrix.Terminate
    Unload progress_form
     
    Call Globals.ResetTemporarySheets
    MsgBox Prompt:="ReInversion complete", Buttons:=vbInformation, title:=Globals.AddInName
    Exit Sub

InversionProblem:
    Call inversion_matrix.Terminate
    
    Call Globals.ResetTemporarySheets
    Call MsgBox("ReInversion terminated prematurely!", vbExclamation, Globals.AddInName)
    Exit Sub
   
End Sub

Private Sub ApplyDilutionCorrection(ByRef file_spec As CFileSpec)
'xlPasteAll changed to xlPasteValues by JPRS in v6.3
    ' Apply dilution factor...
    Cells(file_spec.DataStartRow, file_spec.DilutionRatioCol).Select ' Dilution factor K7
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Copy
    
    '...to the particle size data
    Range(Cells(file_spec.DataStartRow, file_spec.DataStartCol), Cells(file_spec.DataStartRow, file_spec.DataStartCol + file_spec.NumSizeClasses - 1)).Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlMultiply, SkipBlanks:=False, Transpose:=False
    
    ' Apply dilution factor...
    Cells(file_spec.DataStartRow, file_spec.DilutionRatioCol).Select ' Dilution factor K7
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Copy
    
    '... to the total n/cc data and analog outputs
    'Range(Cells(file_spec.DataStartRow, file_spec.TotalNperCcCol), Cells(file_spec.DataStartRow, file_spec.TotalNperCcCol + 4)).Select
    'Cells(file_spec.DataStartRow, file_spec.TotalNperCcCol).Select ' Total N/CC F7
    'Range(Selection, Selection.End(xlDown)).Select
    'Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlMultiply, SkipBlanks:=False, Transpose:=False

    '... to the total n/cc data
    Cells(file_spec.DataStartRow, file_spec.TotalNperCcCol).Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlMultiply, SkipBlanks:=False, Transpose:=False

    '... to concentration configured analogue outputs only
    Dim output_idx As Integer
    For output_idx = 1 To 4
        If (Left(Cells(5, output_idx).Value, 4) = "Conc") Then
            Cells(file_spec.DataStartRow, file_spec.DilutionRatioCol).Select ' Dilution factor K7
            Range(Selection, Selection.End(xlDown)).Select
            Selection.Copy
            Cells(file_spec.DataStartRow, file_spec.TotalNperCcCol + output_idx).Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlMultiply, SkipBlanks:=False, Transpose:=False
        End If
    Next
    
    ' dump LN params to output sheet
    Dim mode_idx As Integer
    For mode_idx = 0 To (file_spec.NumModes - 1)
        ' Apply dilution factor...
        Cells(file_spec.DataStartRow, file_spec.DilutionRatioCol).Select ' Dilution factor K7
        Range(Selection, Selection.End(xlDown)).Select
        Selection.Copy
        
        '... to the amplitude mode data (middle column of 3)
        Cells(file_spec.DataStartRow, mode_idx * 3 + 14).Select
        Range(Selection, Selection.End(xlDown)).Select
        Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlMultiply, SkipBlanks:=False, Transpose:=False
    Next

End Sub

Private Sub inversion_matrix_InversionProgress(Progress As Integer, Diagnostic As Long)
    If ((Progress >= 0) And (Progress <= 100)) Then
      
        progress_form.Text = CStr(Progress) & "%" ' & CStr(diagnostic)
    End If
    DoEvents
End Sub

Attribute VB_Name = "CInversionMatrix"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

#If VBA7 Then
Private Declare PtrSafe Function LogNormalInvert Lib "CamDMSjsi.dll" (ByRef rings As Single, ByRef params As Single, ByRef evidence As Single) As Integer
Private Declare PtrSafe Function SetNoise Lib "CamDMSjsi.dll" (ByRef Noise As Single) As Integer
Private Declare PtrSafe Function SetSpectralResolution Lib "CamDMSjsi.dll" (ByVal perdecade As Integer) As Integer
Private Declare PtrSafe Function LNSpectrum Lib "CamDMSjsi.dll" (spectrum As Single, ByVal GMD As Single, ByVal GSD As Single) As Integer
Private Declare PtrSafe Function Initialise Lib "CamDMSjsi.dll" (ByVal filename As String, ByRef gainRange As Byte, ByVal samplerate As Long) As Integer
Private Declare PtrSafe Function SetExclusions Lib "CamDMSjsi.dll" (ByRef ingore As Byte) As Integer
Private Declare PtrSafe Function RegularInvert Lib "CamDMSjsi.dll" (ByRef RingCurrent As Single, ByRef spectrum As Single) As Integer
Private Declare PtrSafe Function FreeMemory Lib "CamDMSjsi.dll" () As Integer
#Else
Private Declare Function LogNormalInvert Lib "CamDMSjsi.dll" (ByRef rings As Single, ByRef params As Single, ByRef evidence As Single) As Integer
Private Declare Function SetNoise Lib "CamDMSjsi.dll" (ByRef Noise As Single) As Integer
Private Declare Function SetSpectralResolution Lib "CamDMSjsi.dll" (ByVal perdecade As Integer) As Integer
Private Declare Function LNSpectrum Lib "CamDMSjsi.dll" (spectrum As Single, ByVal GMD As Single, ByVal GSD As Single) As Integer
Private Declare Function Initialise Lib "CamDMSjsi.dll" (ByVal filename As String, ByRef gainRange As Byte, ByVal samplerate As Long) As Integer
Private Declare Function SetExclusions Lib "CamDMSjsi.dll" (ByRef ingore As Byte) As Integer
Private Declare Function RegularInvert Lib "CamDMSjsi.dll" (ByRef RingCurrent As Single, ByRef spectrum As Single) As Integer
Private Declare Function FreeMemory Lib "CamDMSjsi.dll" () As Integer
#End If

Public Event InversionProgress(Progress As Integer, Diagnostic As Long)

Private m_NumRows As Integer ' The number of data rows in the dmx file
Private m_NumCols As Integer ' The number of size classes used in the dmx file
Private m_NumModes As Integer

Public m_LogMinDp As Single ' log on the first particle size in the dmx file. Overwritten after we know what the display sizes should be
Public m_MatrixVersion As Integer ' from the dmx file. This gets written to the DMS file
Public m_MaxSvdIterations As Long ' from the dmx file. This gets written to the DMS file
Public m_MatrixFileName As String ' The name of the dmx file
Private m_GainRange(6) As Byte

Private m_DesiredSampleFlow As Single
Private m_MinDp As Single ' Speficies the min particle size to display
Private m_MaxDp As Single ' Speficies the max particle size to display
Private m_NumRings As Long

Private Enum eProcessMode
    ReInverting = 0
    NotReInverting = 1
End Enum

Private m_ProcessMode As eProcessMode

Public m_AnalogOutputs As CAnalogOutput

' The weighting is dependant on the size classes either in the DMS file (if no weighting inversion matrix is used) or in the inversion matrix.
' For this reasons, there are weighting methods in each of CInversionMatrix module (here) and CFileSpec module. Only the CFileSpec module needs a WeightingText property
' as this is used in the CDmsChart module when creating a contour plot.
Private m_WeightingValue() As Single
Property Get WeightingValue(i As Integer) As Double
    WeightingValue = m_WeightingValue(i)
End Property
' Calculate the weighting values to be applied to particle size
' The equation used here is (constant * particle_size/1000)^power * density_multiplier
Public Sub CalculateWeighting(constant As Single, power As Single, density_multiplier As Single)
    Dim i As Integer
    ReDim m_WeightingValue(m_NumCols) As Single
    For i = 0 To m_AnalogOutputs.NumSizeClasses - 1
        m_WeightingValue(i) = constant * ((m_AnalogOutputs.SizeClass(i) / 1000#) ^ power) * density_multiplier
    Next i
End Sub

'****************************************************************
' Load the inversion matrix into memory, and identify some important
' parameters on the way.
'****************************************************************
Public Function Init(ByRef inv_dlg As InversionControl, ByRef file_spec As CFileSpec) As Boolean

    Set m_AnalogOutputs = New CAnalogOutput

    If (Len(inv_dlg.InversionMatrixSelection) > 0) Then
        m_ProcessMode = eProcessMode.ReInverting
        Init = LoadMatrix(inv_dlg, file_spec)
    Else
        m_ProcessMode = eProcessMode.NotReInverting
        Init = LoadNothing(inv_dlg, file_spec)
    End If
        
End Function

Private Function LoadMatrix(ByRef inv_dlg As InversionControl, ByRef file_spec As CFileSpec) As Boolean

    m_NumRings = file_spec.NumRings
                   
    m_MatrixFileName = inv_dlg.InversionMatrixSelection

    'Open Matrix File as a spread sheet and place after data
    Workbooks.OpenText filename:=m_MatrixFileName, startrow:=1, datatype:=xlDelimited, Tab:=True, DecimalSeparator:=".", ThousandsSeparator:=","

    Dim i As Integer
    Dim mode_spec() As SModeSpec
    If (Right(m_MatrixFileName, 3) Like "dmx") Then
        Range("A3").Select
        m_NumRows = Globals.GetRowsExtent()
        m_NumCols = Globals.GetColumnsExtent()
        m_NumModes = 0
    Else
        If (Range("B1") <> "v3.0") Then
            ActiveWorkbook.Close SaveChanges:=False
            Call MsgBox("DMD file is not version 3.0", vbOKOnly)
            LoadMatrix = False
            Exit Function
        End If

        m_NumModes = Range("C1").Value
        m_NumRows = Range("D1").Value
        m_NumCols = Range("E1").Value

        ReDim mode_spec(m_NumModes) As SModeSpec
    
        ' get info specific to each aerosol mode for weighting from DMD file
        For i = 0 To (m_NumModes - 1)
            mode_spec(i).density = ActiveSheet.Cells(3 + i, 13)
            mode_spec(i).power = ActiveSheet.Cells(3 + i, 14)
            mode_spec(i).Modename = ActiveSheet.Cells(3 + i, 15)
        Next
    End If
            
    Dim num_size_classes_per_decade As Integer
    
    If (Range("F2").Value > 0) Then m_DesiredSampleFlow = Range("F2").Value Else m_DesiredSampleFlow = 8
    If (Range("J2").Value > 0) Then m_MinDp = Range("J2").Value Else m_MinDp = 5
    If (Range("K2").Value > 0) Then m_MaxDp = Range("K2").Value Else m_MaxDp = 1000
    If (Range("L2").Value > 0) Then m_LogMinDp = Range("L2").Value Else m_LogMinDp = 0.5
    If (Range("M2").Value > 0) Then num_size_classes_per_decade = Range("M2").Value Else num_size_classes_per_decade = 16
    If (Range("N2").Value > 0) Then m_MatrixVersion = Range("N2").Value Else m_MatrixVersion = 1
    If (Range("O2").Value > 0) Then m_MaxSvdIterations = Range("O2").Value Else m_MaxSvdIterations = 50
       
    Call m_AnalogOutputs.SetModeSpec(m_NumModes, mode_spec)
    Call m_AnalogOutputs.CreateSizeClasses(m_NumCols, num_size_classes_per_decade, m_MinDp, m_MaxDp, m_LogMinDp)
    
    Call m_AnalogOutputs.SetAnalogOutputSpec(1, inv_dlg.MinDp1, inv_dlg.MaxDp1, inv_dlg.Weighting1.ListIndex, inv_dlg.DensityFactor1, inv_dlg.Power1)
    Call m_AnalogOutputs.SetAnalogOutputSpec(2, inv_dlg.MinDp2, inv_dlg.MaxDp2, inv_dlg.Weighting2.ListIndex, inv_dlg.DensityFactor2, inv_dlg.Power2)
    Call m_AnalogOutputs.SetAnalogOutputSpec(3, inv_dlg.MinDp3, inv_dlg.MaxDp3, inv_dlg.Weighting3.ListIndex, inv_dlg.DensityFactor3, inv_dlg.Power3)
    Call m_AnalogOutputs.SetAnalogOutputSpec(4, inv_dlg.MinDp4, inv_dlg.MaxDp4, inv_dlg.Weighting4.ListIndex, inv_dlg.DensityFactor4, inv_dlg.Power4)

    m_LogMinDp = Log(m_AnalogOutputs.SizeClass(0)) / Log(10#)
    
    Application.DisplayAlerts = False
    ActiveWorkbook.Close SaveChanges:=False
    Application.DisplayAlerts = True
      
    Dim retcode As Long
    retcode = Initialise(m_MatrixFileName, m_GainRange(0), file_spec.NumAverageSamples)
    
    If (retcode = 0) Then
        LoadMatrix = True
    ElseIf (retcode = 3) Then ' error of 3 indicates DMD file does not contain that gainrange (e.g. if medium selected on 2 range instrument)
        Call MsgBox("Gain selection not supported by DMD file", vbOKOnly, "Cambustion DMS LN Fit")
        retcode = FreeMemory()
        LoadMatrix = False
        Exit Function
    Else
        MsgBox ("Unable to initialise inversion" & Chr$(10) & "Error code = " & CStr(retcode))
        LoadMatrix = False
    End If
    
    ' if we've chosen noise from file (nff) set gain to dummy value, default noise will be manually overwritten later.
    Dim byt As Integer, pair As Integer, gr As Integer
    If (Globals.nffFlag = True) Then
        For i = 0 To 5
            m_GainRange(i) = 255
        Next
    Else ' otherewise put selected gain range in DMS format
        For i = 0 To 5
            m_GainRange(i) = 0
        Next
        For i = 0 To m_NumRings - 1
            byt = Int(i / 4#)
            pair = i Mod 4
            gr = Globals.DMSCustomGainRange(i)
            If gr = 2 Then gr = 3
            m_GainRange(byt) = m_GainRange(byt) Or (gr * 2 ^ (2 * pair))
        Next
    End If

    ' have we selected noise from file? if so call DLL to set it manually now
    If Globals.nffFlag Then
        retcode = SetNoise(Globals.DMSNoise(0))
        If (retcode <> 0) Then
            MsgBox ("SetNoise failed:" & Chr$(10) & "Error code = " & CStr(retcode))
            LoadMatrix = False
            Exit Function
        End If
    End If

    ' put excluded rings in correct format for DLL
    Dim exclusion_array(22) As Byte
    For i = 0 To m_NumRings - 1
        If inv_dlg.ExclusionArray.item(i + 1) Then exclusion_array(i) = 1 Else exclusion_array(i) = 0
    Next

    ' inform DLL of excluded rings
    retcode = SetExclusions(exclusion_array(0))
    If (retcode <> 0) Then
        MsgBox ("SetExclusions failed:" & Chr$(10) & "Error code = " & CStr(retcode))
        LoadMatrix = False
        Exit Function
    End If

End Function

Private Function LoadNothing(ByRef inv_dlg As InversionControl, ByRef file_spec As CFileSpec) As Boolean

    m_NumRings = file_spec.NumRings
                   
    m_MatrixFileName = ""

    m_NumModes = file_spec.NumModes
    m_NumRows = 0
    m_NumCols = file_spec.NumDataCols

    m_DesiredSampleFlow = file_spec.SampleFlowSetpoint
    m_MinDp = file_spec.MinDpDisplay
    m_MaxDp = file_spec.MaxDpDisplay
    m_LogMinDp = file_spec.LogMinDp
    Dim num_size_classes_per_decade As Integer
    num_size_classes_per_decade = file_spec.NumSizeClassesPerDecade
       
    Call m_AnalogOutputs.SetModeSpec(m_NumModes, file_spec.ModeSpec)
    Call m_AnalogOutputs.CreateSizeClasses(m_NumCols, num_size_classes_per_decade, m_MinDp, m_MaxDp, m_LogMinDp)
    
    Call m_AnalogOutputs.SetAnalogOutputSpec(1, inv_dlg.MinDp1, inv_dlg.MaxDp1, inv_dlg.Weighting1.ListIndex, inv_dlg.DensityFactor1, inv_dlg.Power1)
    Call m_AnalogOutputs.SetAnalogOutputSpec(2, inv_dlg.MinDp2, inv_dlg.MaxDp2, inv_dlg.Weighting2.ListIndex, inv_dlg.DensityFactor2, inv_dlg.Power2)
    Call m_AnalogOutputs.SetAnalogOutputSpec(3, inv_dlg.MinDp3, inv_dlg.MaxDp3, inv_dlg.Weighting3.ListIndex, inv_dlg.DensityFactor3, inv_dlg.Power3)
    Call m_AnalogOutputs.SetAnalogOutputSpec(4, inv_dlg.MinDp4, inv_dlg.MaxDp4, inv_dlg.Weighting4.ListIndex, inv_dlg.DensityFactor4, inv_dlg.Power4)

    m_LogMinDp = Log(m_AnalogOutputs.SizeClass(0)) / Log(10#)

    LoadNothing = True
    
End Function

Public Sub Process(ByRef file_spec As CFileSpec)
    If (m_ProcessMode = eProcessMode.ReInverting) Then
        Call ReInvert(file_spec)
    Else
        Call ReInvertNothing(file_spec)
    End If
End Sub

'****************************************************************
' This function assumes that the DMS file is already open and is
' the active sheet in the workbook.
'****************************************************************
Private Sub ReInvert(ByRef file_spec As CFileSpec)
    
    Dim ring_index As Long, size_index As Integer, retcode As Long
    Dim row As Long, col As Integer, percent_complete As Integer
    Dim diagnostic1 As Long, diagnostic2 As Long
    
    ' Create sufficient local memory for the inversion input and output
    Dim ring_current() As Single, spectrum() As Single
    ReDim ring_current(m_NumRings) As Single
    ReDim spectrum(m_NumCols) As Single

    Dim mode_idx As Integer
    Dim params() As Single, evidence() As Single
    ReDim evidence(2 ^ m_NumModes) As Single
    ReDim params(3 * m_NumModes) As Single
    
    Dim log_normal_output() As SLogNormalOutput
    ReDim log_normal_output(m_NumModes) As SLogNormalOutput
 
    On Error Resume Next ' The only way to avoid the overrun error with using a DLL
    'See http://groups.google.co.uk/group/microsoft.public.excel.programming/browse_frm/thread/3c07aaea70c47c91/5a01a3f7506502c4?lnk=st&q=%22Runtime+error+6%3A%22+VBA&rnum=4&hl=en#5a01a3f7506502c4

    ' Iterate through the DMS file doing the inversion
    row = file_spec.DataStartRow
    Do Until IsEmpty(Cells(row, 1))
        ' Get the value of the ring currents
        For ring_index = 0 To m_NumRings - 1
            ring_current(ring_index) = Cells(row, (file_spec.RingCurrentStartCol + ring_index)).Value
        Next ring_index
        
        retcode = RegularInvert(ring_current(0), spectrum(0))
        
        Dim sample_flow_ratio As Double
        sample_flow_ratio = 1
        If (Cells(row, 12) > 0) Then sample_flow_ratio = m_DesiredSampleFlow / Cells(row, 12)
     
        If (m_NumModes > 0) Then
            retcode = LogNormalInvert(ring_current(0), params(0), evidence(0))
                        
            ' dump LN params to output sheet
            For mode_idx = 0 To (m_NumModes - 1)
                log_normal_output(mode_idx).data(eCMD) = params(mode_idx * 3)  ' CMD
                log_normal_output(mode_idx).data(eConcentration) = params(mode_idx * 3 + 2) * sample_flow_ratio ' Amplitude
                log_normal_output(mode_idx).data(eGSD) = params(mode_idx * 3 + 1) ' GSD
                
                Cells(row, mode_idx * 3 + 13).Value = log_normal_output(mode_idx).data(eCMD)
                Cells(row, mode_idx * 3 + 14).Value = log_normal_output(mode_idx).data(eConcentration)
                Cells(row, mode_idx * 3 + 15).Value = log_normal_output(mode_idx).data(eGSD)
            Next
        End If

        ' Write back out the particle size spectrum
        Dim concentration As Double, total_concentration As Double
        total_concentration = 0
        
        For size_index = 0 To m_AnalogOutputs.NumSizeClasses - 1
            concentration = spectrum(m_AnalogOutputs.FirstValidSizeIndex + size_index) * sample_flow_ratio * m_WeightingValue(size_index)
            total_concentration = total_concentration + concentration
            Cells(row, (file_spec.SizeClassStartCol + size_index)).Value = concentration
        Next size_index
        Cells(row, file_spec.TotalNperCcCol) = total_concentration / m_AnalogOutputs.NumSizeClassesPerDecade
        
        Cells(row, file_spec.TotalNperCcCol + 1) = m_AnalogOutputs.CalculateOutput(1, spectrum, log_normal_output)
        Cells(row, file_spec.TotalNperCcCol + 2) = m_AnalogOutputs.CalculateOutput(2, spectrum, log_normal_output)
        Cells(row, file_spec.TotalNperCcCol + 3) = m_AnalogOutputs.CalculateOutput(3, spectrum, log_normal_output)
        Cells(row, file_spec.TotalNperCcCol + 4) = m_AnalogOutputs.CalculateOutput(4, spectrum, log_normal_output)
        
        row = row + 1
        
        percent_complete = (row - file_spec.DataStartRow) * 100 / file_spec.NumDataRows
        If ((percent_complete Mod 5) = 0) Then RaiseEvent InversionProgress(percent_complete, diagnostic1)
    Loop
        
End Sub

'****************************************************************
' Free up memory used in the least squares DLL
'****************************************************************
Public Sub Terminate()
    Dim retcode As Long
    retcode = FreeMemory()
End Sub

'****************************************************************
' This function assumes that the DMS file is already open and is
' the active sheet in the workbook.
'****************************************************************
Private Sub ReInvertNothing(ByRef file_spec As CFileSpec)
    
    Dim mode_idx As Integer
    Dim size_index As Integer
    Dim row As Long, col As Integer, percent_complete As Integer
    Dim diagnostic1 As Long
    
    Dim spectrum() As Single
    ReDim spectrum(file_spec.NumSizeClasses) As Single
    
    Dim log_normal_output() As SLogNormalOutput
    ReDim log_normal_output(m_NumModes) As SLogNormalOutput

    ' Iterate through the DMS file doing the inversion
    row = file_spec.DataStartRow
    Do Until IsEmpty(Cells(row, 1))
        
        Dim sample_flow_ratio As Double
        sample_flow_ratio = 1
        If (Cells(row, 12) > 0) Then sample_flow_ratio = m_DesiredSampleFlow / Cells(row, 12)
     
        If (m_NumModes > 0) Then
            ' dump LN params to output sheet
            For mode_idx = 0 To (m_NumModes - 1)
                log_normal_output(mode_idx).data(eCMD) = Cells(row, mode_idx * 3 + 13).Value
                log_normal_output(mode_idx).data(eConcentration) = Cells(row, mode_idx * 3 + 14).Value
                log_normal_output(mode_idx).data(eGSD) = Cells(row, mode_idx * 3 + 15).Value
            Next
        End If
        
        ' Write back out the particle size spectrum
        Dim concentration As Double, total_concentration As Double
        total_concentration = 0
        
        For size_index = 0 To m_AnalogOutputs.NumSizeClasses - 1
            spectrum(size_index) = Cells(row, file_spec.SizeClassStartCol + size_index)
            concentration = spectrum(size_index) * file_spec.WeightingValue(size_index)
            total_concentration = total_concentration + concentration
            Cells(row, (file_spec.SizeClassStartCol + size_index)).Value = concentration
        Next size_index
        Cells(row, file_spec.TotalNperCcCol) = total_concentration / m_AnalogOutputs.NumSizeClassesPerDecade
        
        Cells(row, file_spec.TotalNperCcCol + 1) = m_AnalogOutputs.CalculateOutput(1, spectrum, log_normal_output)
        Cells(row, file_spec.TotalNperCcCol + 2) = m_AnalogOutputs.CalculateOutput(2, spectrum, log_normal_output)
        Cells(row, file_spec.TotalNperCcCol + 3) = m_AnalogOutputs.CalculateOutput(3, spectrum, log_normal_output)
        Cells(row, file_spec.TotalNperCcCol + 4) = m_AnalogOutputs.CalculateOutput(4, spectrum, log_normal_output)
        
        row = row + 1
        
        percent_complete = (row - file_spec.DataStartRow) * 100 / file_spec.NumDataRows
        If ((percent_complete Mod 5) = 0) Then RaiseEvent InversionProgress(percent_complete, diagnostic1)
    Loop
        
End Sub

Attribute VB_Name = "CTemplateSpec"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Named ranges in the particle size template
Private m_Delay As String
Private m_Interval As String
Private m_Length As String
Private m_Speed As String
Private m_Step As String
Private m_TimeColumn As String

Private m_SheetName As String

Private Const m_DataStartCol As Long = 12 ' First Dp data column
Private Const m_MaxDataCols As Long = 225 ' Number of Dp cols in the template

Private Const m_WeightingCell As String = "$B$18"
Private Const m_ConstantCell As String = "$B$25"

'Public Enum ETemplateSheetType
'    ParticleSize = 0
'    RingCurrent = 1
'    Summary = 2
'End Enum
'Private m_SheetType As ETemplateSheetType

Property Get Delay()
    Delay = m_Delay
End Property
Property Get Interval()
    Interval = m_Interval
End Property
Property Get Length()
    Length = m_Length
End Property
Property Get Speed()
    Speed = m_Speed
End Property
Property Get Step()
    Step = m_Step
End Property
Property Get TimeColumn()
    TimeColumn = m_TimeColumn
End Property

Property Get SheetName()
    SheetName = m_SheetName
End Property
'Property Get SheetType()
'    SheetType = m_SheetType
'End Property

Property Get DataStartCol()
    DataStartCol = m_DataStartCol
End Property
Property Get MaxDataCols()
    MaxDataCols = m_MaxDataCols
End Property

Property Get WeightingCell()
    WeightingCell = m_WeightingCell
End Property
Property Get ConstantCell()
    ConstantCell = m_ConstantCell
End Property

Public Sub SetAsParticleSize()
    'm_SheetType = ETemplateSheetType.ParticleSize
    m_SheetName = "ParticleSizeAnimation"
    
    m_Delay = "R7C2"
    m_Interval = "R10C2"
    m_Length = "R16C2"
    m_Speed = "R1C9"
    m_Step = "R13C2"
    m_TimeColumn = "K:K"
End Sub

Public Sub SetAsRingCurrent()
    'm_SheetType = ETemplateSheetType.RingCurrent
    m_SheetName = "RingAnimation"
    
    m_Delay = "R7C2"
    m_Interval = "R10C2"
    m_Length = "R16C2"
    m_Speed = "R1C5"
    m_Step = "R13C2"
    m_TimeColumn = "G:G"
End Sub

Attribute VB_Name = "CalcNoise"
Attribute VB_Base = "0{AACF61A7-1C12-4D6B-A9DB-422F4C989AEC}{8DD3B162-DFC5-4B9D-91E5-AE5FB43C6784}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

Public NoiseCancelled As Boolean
Public NoiseOK As Boolean

Private Sub CancelButton_Click()
    NoiseCancelled = True
    NoiseOK = False
End Sub

Private Sub OKbutton_Click()
    NoiseCancelled = False
    NoiseOK = True
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    NoiseCancelled = True
    NoiseOK = False
    Cancel = True
End Sub

Attribute VB_Name = "CustomGainRange"
Attribute VB_Base = "0{42A02813-CF00-481C-8843-B5CE32AA8708}{050359B5-C951-48E7-A99F-5B97268388B2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

' display the custom gain range dialogue; populate radio buttons
Public Sub drawcustomgainrange()

    Dim ring As Integer
    Dim grange As Integer

    For ring = 0 To 21
    
        Dim RingBorderHandle As Control
        Set RingBorderHandle = Me.Controls.Add("Forms.Label.1", "RingBorder" & ring)

        With RingBorderHandle
            If ring < 11 Then
                .Left = 1 + 50 * (ring + 1)
                .Top = 7
            Else
                .Left = 1 + 50 * (ring - 10)
                .Top = 81
            End If
            .Width = 45
            .Height = 66
            .SpecialEffect = 2
        End With

        Dim RingLabelHandle As Control
        Set RingLabelHandle = Me.Controls.Add("Forms.Label.1", "RingLabel" & ring)
        With RingLabelHandle
            If ring < 11 Then
                .Left = 10 + 50 * (ring + 1)
                .Top = 10
            Else
                .Left = 10 + 50 * (ring - 10)
                .Top = 84
            End If
            .Width = 30
            If ring < 9 Then .Caption = "Ring 0" & ring + 1
            If ring >= 9 Then .Caption = "Ring " & ring + 1
            .visible = True
        End With

        For grange = 0 To 2
            Dim RadioHandle As Control
            Set RadioHandle = Me.Controls.Add("Forms.OptionButton.1", "RingRadio" & grange & ring, True)

            With RadioHandle
                .GroupName = "RingFrame" & ring

                If ring < 11 Then
                    .Left = 17 + 50 * (ring + 1)
                    .Top = 8 + 15 * (grange + 1)
                Else
                    .Left = 17 + 50 * (ring - 10)
                    .Top = 82 + 15 * (grange + 1)
                End If
                If Globals.DMSCustomGainRange(ring) = grange Then .Value = True
                .Width = 20
                .visible = True
            End With
        Next
    Next

End Sub

Private Sub Cancel_Click()
    Dim ring As Integer
    Dim grange As Integer

    For ring = 0 To 21
        For grange = 0 To 2
            Me.Controls.Remove "RingRadio" & grange & ring
        Next
        Me.Controls.Remove "RingLabel" & ring
        Me.Controls.Remove "RingBorder" & ring
    Next
    Me.Hide
End Sub

Private Sub OK_Click()
    Dim ring As Integer
    Dim grange As Integer

    For ring = 0 To 21
        For grange = 0 To 2
            If Me.Controls("RingRadio" & grange & ring) Then Globals.DMSCustomGainRange(ring) = grange
            Me.Controls.Remove "RingRadio" & grange & ring
        Next
        Me.Controls.Remove "RingLabel" & ring
        Me.Controls.Remove "RingBorder" & ring
    Next

    Globals.nffFlag = False
    Me.Hide

End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Cancel = True
    Dim ring As Integer
    Dim grange As Integer

    For ring = 0 To 21
        For grange = 0 To 2
            Me.Controls.Remove "RingRadio" & grange & ring
        Next
        Me.Controls.Remove "RingLabel" & ring
        Me.Controls.Remove "RingBorder" & ring
    Next
    Me.Hide
End Sub
Attribute VB_Name = "DmsChartControl"
Attribute VB_Base = "0{C1E5D68B-6393-4461-9D70-FC44C4980CCC}{FB6EF19B-B1A5-40DF-90A9-6C8EDADE3D54}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit ' Generate errors if declarations are not explicit

Public OkWasPressed As Boolean  ' Used to notify the client that the user wants to proceed

'Public m_UsersLowerTime As Double
'Public m_UsersUpperTime As Double
Public m_AnalogSignalNumber As Integer

Public Enum EWeightingType
    eNumber = 0
    eLength = 1
    eArea = 2
    eVolume = 3
End Enum
Public WeightingType As EWeightingType
Public DensityMultiplier As Single

Private m_MinDmsTime As Double
Private m_MaxDmsTime As Double
Private m_RealTime As Boolean
Public AlreadyWeighted As Boolean

Private Const c_Delta As Double = 0.00001157407407 ' 1 second expressed as a Date value, fraction of a day
Private Const AutoIncrementDecades As Integer = 5 ' The number of decades that separate the lower from upper CSD by default.

Private Sub EnableAnalogPlot_Click()
    PlotAnalog1.Enabled = EnableAnalogPlot.Value
    PlotAnalog2.Enabled = EnableAnalogPlot.Value
    PlotAnalog3.Enabled = EnableAnalogPlot.Value
    PlotAnalog4.Enabled = EnableAnalogPlot.Value
    
    ' Analog channel to plot with the contour chart
    If (EnableAnalogPlot.Value) Then
        If PlotAnalog1.Value Then
            m_AnalogSignalNumber = 0
        ElseIf PlotAnalog2.Value Then
            m_AnalogSignalNumber = 1
        ElseIf PlotAnalog3.Value Then
            m_AnalogSignalNumber = 2
        ElseIf PlotAnalog4.Value Then
            m_AnalogSignalNumber = 3
        End If
    Else
        m_AnalogSignalNumber = -1
    End If
End Sub

Private Sub tbDensity_Change()
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
        tbWeightingConstant = 1
    End If
End Sub

Private Sub tbDensityFactor_Change()
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
        tbWeightingConstant = 1
    End If
End Sub

Private Sub NumberWeighting_Click()
    tbWeightingConstant = 1
    WeightingPower = 0
    WeightingType = eNumber
    
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = False
    rbDensity.Enabled = False
    rbDensityFactor.Enabled = False
    tbWeightingConstant.Enabled = True
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dN/dlogdp /cc"
    End If
End Sub

Private Sub LengthWeighting_Click()
    tbWeightingConstant = 1 / 1#
    WeightingPower = 1
    WeightingType = eLength
    tbWeightingConstant.Enabled = True
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = False
    rbDensity.Enabled = False
    rbDensityFactor.Enabled = False
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dl/dlogdp |fffd|m/cc"
    End If
End Sub

Private Sub AreaWeighting_Click()
    tbWeightingConstant = CStr(3.141592654 / 1#)
    WeightingPower = 2
    WeightingType = eArea
    tbWeightingConstant.Enabled = True
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = False
    rbDensity.Enabled = False
    rbDensityFactor.Enabled = False

    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dA/dlogdp |fffd|m^2/cc"
    End If
End Sub

Private Sub rbDensity_Click()
    tbDensity.Enabled = True
    tbDensityFactor.Enabled = False
    tbWeightingConstant.Enabled = True
    tbWeightingText = "dMdlogDp |fffd|g/cc"
End Sub

Private Sub rbDensityFactor_Click()
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = True
    tbWeightingConstant.Enabled = False
    tbWeightingText = "dMdlogDp |fffd|g/cc"
End Sub

Private Sub VolumeWeighting_Click()
    tbWeightingConstant = CStr(3.141592654 / 6#)
    WeightingPower = 3
    WeightingType = eVolume
    
    rbDensity.Enabled = True
    rbDensityFactor.Enabled = True
    If (rbDensity) Then tbDensity.Enabled = True
    If (rbDensity) Then tbWeightingConstant.Enabled = True
    If (rbDensityFactor) Then tbDensityFactor.Enabled = True
    If (rbDensityFactor) Then tbWeightingConstant.Enabled = False
       
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dv/dlogdp |fffd|m^3/cc"
    End If
End Sub


'****************************************************************
' Initialise with default data
'****************************************************************
Public Sub SetWeightings(weighting_message As String)
    'Spectrum weighted by mass: Power=3, Shape factor=0.523598775666667, Density=1000, Units=dMdlogDp ug/cc
    'Spectrum weighted by volume: Power=3, Density factor=5.24e-16, Units=dMdlogDp ug/cc
    
    Dim weighted_by As String
    Dim i As Integer
    i = InStr(weighting_message, ":")
    weighted_by = Mid(weighting_message, 22, i - 22)
    
    If (weighted_by = "length") Then
        LengthWeighting = True
        Call LengthWeighting_Click
    ElseIf (weighted_by = "area") Then
        AreaWeighting = True
        Call AreaWeighting_Click
    ElseIf (weighted_by = "volume") Then
        VolumeWeighting = True
        Call VolumeWeighting_Click
    ElseIf (weighted_by = "mass") Then
        VolumeWeighting = True
        Call VolumeWeighting_Click
    Else
        NumberWeighting = True
        Call NumberWeighting_Click
    End If
    
    weighting_message = Right(weighting_message, Len(weighting_message) - i)
    
    Dim the_split() As String, the_item() As String
    the_split = Split(weighting_message, ",")
    
    Dim token_idx As Integer, num_items As Integer
    num_items = UBound(the_split)
    Dim power As String, density As String
    For token_idx = 0 To num_items
        
        i = InStr(the_split(token_idx), "=")
        the_item = Split(the_split(token_idx), "=")
   
        If (the_item(0) = " Power") Then
            power = the_item(1)
            WeightingPower = power
        ElseIf (the_item(0) = " Shape factor") Then
            tbWeightingConstant = the_item(1)
            rbDensity = False
            rbDensityFactor = False
        ElseIf (the_item(0) = " Density factor") Then
            tbDensityFactor = the_item(1)
            rbDensity = False
            rbDensityFactor = True
        ElseIf (the_item(0) = " Density") Then
            tbDensity = the_item(1)
            rbDensity = True
            rbDensityFactor = False
        ElseIf (the_item(0) = " Units") Then
            tbWeightingText = the_item(1)
        
        End If
        
    Next token_idx
    
End Sub

'****************************************************************
' Initialise the dialog during creation
'****************************************************************
Private Sub Userform_Initialize()
    OkWasPressed = False
    NumberWeighting = True
    tbDensity.Text = ""
    DensityMultiplier = 1

    EnableAnalogPlot.Value = False
    EnableAnalogPlot_Click
    
    AlreadyWeighted = False
    
    Call NumberWeighting_Click
End Sub

'****************************************************************
' Initialise the dialog after it's created, but before display
'****************************************************************
Public Sub Initialise(min_time As Double, max_time As Double, real_time As Boolean, weighting_message As String)
    
    If (Len(weighting_message) > 1) Then
        SetWeightings (weighting_message)
        AlreadyWeighted = True
        Frame1.Enabled = False
        Frame2.Enabled = False
       
        NumberWeighting.Enabled = False
        LengthWeighting.Enabled = False
        AreaWeighting.Enabled = False
        VolumeWeighting.Enabled = False
        
        tbWeightingText.Enabled = False
        tbWeightingText.BackColor = &H8000000F
        
        WeightingPower.Enabled = False
        WeightingPower.BackColor = &H8000000F
        
        tbWeightingConstant.Enabled = False
        tbWeightingConstant.BackColor = &H8000000F
        
        tbDensity.Enabled = False
        tbDensity.BackColor = &H8000000F
        
        tbDensityFactor.Enabled = False
        tbDensityFactor.BackColor = &H8000000F
        
        rbDensity.Enabled = False
        rbDensityFactor.Enabled = False
       
    Else
        AlreadyWeighted = False
    End If
    
    m_MinDmsTime = min_time
    m_MaxDmsTime = max_time
    m_RealTime = real_time
    
    If (m_RealTime = True) Then
        'LowerTime = Format(m_MinDmsTime, "dd/mm/yyyy hh:mm:ss")
        m_MinDmsTime = m_MinDmsTime + c_Delta
        m_MaxDmsTime = m_MaxDmsTime - c_Delta
        
        LowerTime = CStr(CDate(m_MinDmsTime))
        UpperTime = CStr(CDate(m_MaxDmsTime))
        LowerTimeLabel.visible = False
        UpperTimeLabel.visible = False
    Else
        LowerTime = CStr(m_MinDmsTime)
        UpperTime = CStr(m_MaxDmsTime)
        LowerTimeLabel.visible = True
        UpperTimeLabel.visible = True
    End If
    
    If (LowerTime <= 0) Then
        LowerTime = 0
    End If
    
    LowerCSD = 3
    UpperCSD = CStr(LowerCSD + AutoIncrementDecades)

End Sub

'****************************************************************
' Dynamically update the UpperCSD as LowerCSD is entered
'****************************************************************
Private Sub LowerCSD_Change()
    If IsNumeric(LowerCSD) Then
        UpperCSD = CStr(LowerCSD + AutoIncrementDecades)
    End If
End Sub

'****************************************************************
' The user has hit the OK button...
'****************************************************************
Private Sub CreateButton_Click()
    
    If (IsNumeric(tbDensity) And rbDensity) Then
        DensityMultiplier = CStr(tbDensity * 1000000000# / (1000000# ^ WeightingPower))
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        DensityMultiplier = CStr(tbDensityFactor) * 1000# ^ CStr(WeightingPower)
    Else
        DensityMultiplier = 1
    End If

    ' CSD values must be numbers
    If Not IsNumeric(LowerCSD) Then
        MsgBox "Please enter a positive lower CSD", vbExclamation
        Exit Sub
    End If
    
    ' CSD values must be numbers
    If Not IsNumeric(UpperCSD) Then
        MsgBox "Please enter a positive upper CSD", vbExclamation
        Exit Sub
    End If
    
    ' LowerCSD must be smaller than UpperCSD
    Dim lower As Double, upper As Double
    
    lower = CDbl(LowerCSD)
    upper = CDbl(UpperCSD)
    If (lower > upper) Then
        OkWasPressed = False
        MsgBox "Upper CSD must exceed lower CSD ", vbExclamation
        Exit Sub
    End If

    If (m_RealTime = True) Then
        On Error GoTo Problem
        lower = CDbl(CDate(LowerTime))
        upper = CDbl(CDate(UpperTime))
        On Error Resume Next
    Else
        ' Time values must be numbers
        If Not IsNumeric(LowerTime) Then
            MsgBox "Please enter a positive lower time", vbExclamation
            Exit Sub
        End If
    
        ' Time values must be numbers
        If Not IsNumeric(UpperTime) Then
            MsgBox "Please enter a positive upper time", vbExclamation
            Exit Sub
        End If
        lower = CDbl(LowerTime.Value)
        upper = CDbl(UpperTime.Value)
    End If
    
    ' Times must lie within the extent of the DMS data
    If (lower < m_MinDmsTime - c_Delta) Then
        MsgBox "Minimum time in the DMS data is " & CStr(m_MinDmsTime) & " secs", vbExclamation
        LowerTime = CDbl(m_MinDmsTime)
        Exit Sub
    End If
        
    If (upper > m_MaxDmsTime + c_Delta) Then
        MsgBox "Maximum time in the DMS data is " & CStr(m_MaxDmsTime) & " secs", vbExclamation
        UpperTime = CDbl(m_MaxDmsTime)
        Exit Sub
    End If

    ' LowerTime must be smaller than UpperTime
    lower = CDbl(LowerTime.Value)
    upper = CDbl(UpperTime.Value)
    If (lower > upper) Then
        OkWasPressed = False
        MsgBox "Upper time must exceed lower time ", vbExclamation
        Exit Sub
    End If
    
    LowerTime.Value = CStr(CDbl(lower))
    UpperTime.Value = CStr(CDbl(upper))
    
    ' If we've managed to get this far, then accept the user selection and unload the dialog.
    OkWasPressed = True
    Unload Me
    Exit Sub

Problem:
    MsgBox "Bad date/time format", vbExclamation

End Sub

'****************************************************************
' Don't proceed if the user hits cancel
'****************************************************************
Private Sub CancelButton_Click()
    OkWasPressed = False
    Unload Me
End Sub

Public Sub DoModal()

    If (Globals.AutomatedTest = False) Then
        Me.Show
    Else
        Load Me
        
        LowerTime = Test.ContourPlotControl.TimeLo
        UpperTime = Test.ContourPlotControl.TimeHi
        LowerCSD = Test.ContourPlotControl.CsdLo
        UpperCSD = Test.ContourPlotControl.CsdHi
        'tbDensity = test.ContourPlotControl.tbDensity
        
        If Test.ContourPlotControl.WeightingType = eNumber Then
            NumberWeighting_Click
        ElseIf Test.ContourPlotControl.WeightingType = eLength Then
            LengthWeighting_Click
        ElseIf Test.ContourPlotControl.WeightingType = eArea Then
            AreaWeighting_Click
        ElseIf Test.ContourPlotControl.WeightingType = eVolume Then
            VolumeWeighting_Click
        End If
        
        Call CreateButton_Click
    End If

End Sub
Attribute VB_Name = "Environment"
Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function GetEnvironmentVariable Lib "kernel32" _
Alias "GetEnvironmentVariableA" _
(ByVal lpName As String, _
ByVal lpBuffer As String, _
ByVal nSize As Long) As Long

Private Declare PtrSafe Function SetEnvironmentVariable Lib "kernel32" _
Alias "SetEnvironmentVariableA" _
(ByVal lpName As String, _
ByVal lpValue As String) As Long

Public Declare PtrSafe Function GetSystemMetrics32 Lib "user32" _
Alias "GetSystemMetrics" _
(ByVal nIndex As Long) As Long

#Else
Private Declare Function GetEnvironmentVariable Lib "kernel32" _
Alias "GetEnvironmentVariableA" _
(ByVal lpName As String, _
ByVal lpBuffer As String, _
ByVal nSize As Long) As Long

Private Declare Function SetEnvironmentVariable Lib "kernel32" _
Alias "SetEnvironmentVariableA" _
(ByVal lpName As String, _
ByVal lpValue As String) As Long

Public Declare Function GetSystemMetrics32 Lib "user32" _
Alias "GetSystemMetrics" _
(ByVal nIndex As Long) As Long
#End If


'Sub xx()
'   SetEnvironmentVariable "Rob", "Nuzie!"
'   MsgBox Environ("Rob")
'   MsgBox GetEnvironmentVar("Rob")
'End Sub

Public Function GetEnvironmentVar(Name As String) As String
    GetEnvironmentVar = String(255, 0)
    GetEnvironmentVariable Name, GetEnvironmentVar, Len(GetEnvironmentVar)
    GetEnvironmentVar = TrimNull(GetEnvironmentVar)
End Function

Private Function TrimNull(item As String)
    Dim iPos As Long
    iPos = InStr(item, vbNullChar)
    TrimNull = IIf(iPos > 0, Left$(item, iPos - 1), item)
End Function


Attribute VB_Name = "FileIO"
Option Explicit

' returns the entire contents of a text file as a string
Function ReadTextFileContents(filename As String) As String
    Dim fnum As Integer, isOpen As Boolean
    On Error GoTo Error_Handler
    ' get the next free file number
    fnum = FreeFile()
    Open filename For Input As #fnum
    ' if execution flow got here, the file has been open without error
    isOpen = True
    ' read the entire contents in one single operation
    ReadTextFileContents = Input(LOF(fnum), fnum)
    ' intentionally flow into the error handler to close the file
Error_Handler:
    ' raise the error (if any), but first close the file
    If isOpen Then Close #fnum
    If Err Then Err.Raise Err.Number, , Err.Description
End Function

' writes the contents of a string to a file, optionally in Append mode
Sub WriteTextFileContents(Text As String, filename As String, _
    Optional AppendMode As Boolean)
        Dim fnum As Integer, isOpen As Boolean
        On Error GoTo Error_Handler
        ' get the next free file number
        fnum = FreeFile()
        If AppendMode Then
            Open filename For Append As #fnum
        Else
            Open filename For Output As #fnum
        End If
        ' if execution flow got here, the file has been open correctly
        isOpen = True
        ' print to the file in one single operation
        Print #fnum, Text
        ' intentionally flow into the error handler to close the file
Error_Handler:
        ' raise the error (if any), but first close the file
        If isOpen Then Close #fnum
        If Err Then Err.Raise Err.Number, , Err.Description
End Sub

' returns the contents of a text file as an array of strings
' NOTE: requires the ReadTextFileContents routine
Function GetTextFileLines(filename As String, Optional DropEmpty As Boolean, _
    Optional Limit As Long) As String()
        Dim FileText As String, items() As String, i As Long
        ' read the file's contents, exit if any error
        FileText = ReadTextFileContents(filename)
        ' this is necessary, because Split() only accepts 1-char delimiters
        FileText = Replace(FileText, vbCrLf, vbCr)
        ' split the file in individual lines of text
        items() = Split(FileText, vbCr, Limit)
        ' drop empty lines, if requested
        If DropEmpty Then
            ' fill empty lines with something that other items
            ' surely don't contain
            For i = 0 To UBound(items)
                If Len(items(i)) = 0 Then items(i) = vbCrLf
            Next
            ' use the Filter() function to quickly drop empty lines
            items() = Filter(items(), vbCrLf, False)
        End If
        GetTextFileLines = items()
End Function

' returns the contents of a delimited text file as an array of strings arrays
' NOTE: requires the ReadTextFileContents and GetTextFileLines routines
Function ImportDelimitedFile(filename As String, _
    Optional delimiter As String = vbTab) As Variant()
        Dim lines() As String, i As Long
        ' get all lines in the file, skipping over blank ones
        lines() = GetTextFileLines(filename, True, -1)
        ' create a string array out of each line of text
        ' and store it into a Variant element
        ReDim values(0 To UBound(lines)) As Variant
        For i = 0 To UBound(lines)
            values(i) = Split(lines(i), delimiter, -1)
        Next
        ImportDelimitedFile = values()
End Function


Attribute VB_Name = "Globals"
'****************************************************************
' Global data and functions used in the classes and modules in this addin.
'****************************************************************
Option Explicit

Public Const AddInName As String = "DMS Utilities"

' To Change the version number in this add-in, in VBA open the "Immediate" window and type ThisWorkbook.IsAddin = false
' In the Excel workbook which is now visible for what was the add-in, go to File->Info->Properties->Advanced
' Change the Comments to "Version whatever"
' Back in the VBA "Immediate" window type ThisWorkbook.IsAddin = True
' Save the add-in.

' Remember that the string literal is used for setting DLL paths too, so it needs changing in several places!
' (Like in the CInversionMatrix class and InversionControl form)
' Public Const InstallationDirectory As String = "C:\Cambustion\DmsUtilities\"
'Public TempDirectory As String ' = "C:\Cambustion\DmsUtilities\Temp\"
Public Const TemplatesFileName As String = "DmsTemplates.xls"

' Options
'Private m_OptionsFile As String '= "C:\Cambustion\DmsUtilities\DmsOptions.txt"
'Public ColourDmsFileCells As Boolean

Public OriginalWorksheetName As String      ' We change the worksheet name so that problem names don't affect the algorithms
Private OriginalInsertedSheetName As String ' As well are providing a store for the original sheetname, it's also used in creating a footer for the contour plot sheet
Public Const TemporaryWorkSheetName As String = "DmsData"
Public Const TemporaryInsertedSheetName As String = "DmsInsert"

' These IDs are used in DmsVersionOK() to determine which file version we are dealing with
Private Const m_DmsFileIDVersion1 As String = "v1.00" ' The string in the top left cell of the DMS sheet
Private Const m_DmsFileIDVersion2 As String = "v2.00" ' Includes dilution ratio column and Log (MinDp), SizeClasses/Decade, MatrixVersion, MaxSvdIterations
Private Const m_DmsFileIDVersion3 As String = "v3.00" ' Includes instrument ID
Private Const m_DmsFileIDVersion4 As String = "v4.00" ' Major update
Private Const m_DmsFileIDVersion5 As String = "v5.00" ' 1st and 2nd dilution factors sp & feedback added
Public DmsFileVersion As Integer ' The integer value of the DMS file version

'LogNormal stuff used to communicate values between dialogs
Public DMSNoise(21) As Single
Public DMSCustomGainRange(21) As Integer
Public nffFlag As Boolean    ' are we using noise from file?
Public cgrFlag As Boolean    ' are we using a custom gain range?

Private Const c_MaxSheetnameLength As Integer = 31 ' Cant have a sheetname longer than this apparently
Public Const AutomatedTest As Boolean = False

Public Type SModeSpec
    density As Single
    power As Single
    Modename As String
End Type

Public Enum EParameterType
    eConcentration = 0
    eCMD = 1
    eGSD = 2
End Enum
Public Enum EModeType
    eSize = 0
    eMode = 1
End Enum
Public Enum EAoWtType
    eNone = 0
    eCustom = 1
    eDMD = 2
End Enum

Public Type SLogNormalOutput
    data(3) As Double ' Indexed by EParameterType
    'Concentration As Double
    'CMD As Double
    'GSD As Double
End Type
Property Get ExcelSheetNameMaxLength() As Integer
    ExcelSheetNameMaxLength = c_MaxSheetnameLength
End Property
Property Get DecimalSeparator() As String
    DecimalSeparator = Application.International(xlDecimalSeparator)
End Property

Property Get ExcelVersion() As Integer
    ExcelVersion = CInt(Val(Application.Version)) ' Val inserted in 6.3
End Property

'Public Sub ReadOptions()
'
'Dim install_dir As String
'install_dir = InstallationDirectory
'
'    m_OptionsFile = install_dir & "DmsOptions.txt"
'    TempDirectory = install_dir & "Temp\"
'
'    If (Dir(m_OptionsFile) = "") Then ' Options file doesn't exist, so create default options
'        ColourDmsFileCells = True
'        SaveOptions
'    Else
'        Dim values() As Variant, i As Long
'        values() = FileIO.ImportDelimitedFile(m_OptionsFile, ",")
'        Dim option_name As String, option_value As String
'        For i = 0 To UBound(values)
'            option_name = values(i)(0)
'            option_value = values(i)(1)
'
'            If (option_name = "ColourDmsFileCells") Then ColourDmsFileCells = CBool(option_value)
'
'        Next i
'    End If
'End Sub
'
'Public Sub SaveOptions()
'    Dim Text As String
'    Text = "ColourDmsFileCells," & CStr(ColourDmsFileCells)
'    Call FileIO.WriteTextFileContents(Text, m_OptionsFile, False)
'End Sub

Public Function UserTempDirectory() As String
    Dim user_temp_dir As String
    user_temp_dir = Environment.GetEnvironmentVar("TEMP")
    UserTempDirectory = user_temp_dir & "\"
End Function
Public Function InstallTempDirectory() As String
    Dim install_dir As String
    install_dir = InstallationDirectory
    InstallTempDirectory = install_dir & "Temp\"
End Function
Public Function InstallationDirectory() As String
    InstallationDirectory = Registry.QueryValue("Software\Cambustion\DMSUtilities", "InstallDir")
End Function
Public Function ColourDmsFileCells() As Boolean
    Dim registry_string As String
    registry_string = Registry.QueryValue("Software\Cambustion\DMSUtilities", "ColourDmsFileCells")
    If (registry_string = "1") Then
        ColourDmsFileCells = True
    Else
        ColourDmsFileCells = False
    End If
End Function
Public Function SaveAsMacroWorkbook() As Boolean
    Dim registry_string As String
    registry_string = Registry.QueryValue("Software\Cambustion\DMSUtilities", "SaveAsMacroWorkbook")
    If (registry_string = "1") Then
        SaveAsMacroWorkbook = True
    Else
        SaveAsMacroWorkbook = False
    End If
End Function
Public Function AllowUserScreenUpdateCtrl() As Boolean
    Dim registry_string As String
    registry_string = Registry.QueryValue("Software\Cambustion\DMSUtilities", "AllowUserScreenUpdateCtrl")
    If (registry_string = "1") Then
        AllowUserScreenUpdateCtrl = True
    Else
        AllowUserScreenUpdateCtrl = False
    End If
End Function
'****************************************************************
' Enable/Disable screen and calculations, and control cursor icon
' at the start and end of long tasks
'****************************************************************
Public Sub EnteringLongTask(enable As Boolean)
    If (Not AllowUserScreenUpdateCtrl) Then
        If (enable = True) Then
            Application.ScreenUpdating = False ' Don't update the screen until the entire operation is complete
            Application.Calculation = xlCalculationManual ' Must be automatic or the sheet won't update for the bitmap
            Application.Cursor = xlWait
        Else
            Application.Calculation = xlCalculationAutomatic ' Must be automatic or the sheet won't update for the bitmap
            Application.ScreenUpdating = True ' Don't update the screen until the entire operation is complete
            Application.Cursor = xlDefault
            Application.ReferenceStyle = xlA1
        End If
    End If
End Sub

'****************************************************************
' Prepare the sheets for macro activity.
'****************************************************************
Public Sub SetTemporarySheets(keyword As String)
    EnteringLongTask (True)
    OriginalWorksheetName = ActiveSheet.Name
    OriginalInsertedSheetName = GetNextSheetName(OriginalWorksheetName & keyword)
    If (Len(OriginalInsertedSheetName) > c_MaxSheetnameLength) Then
        Call MsgBox("The data sheet name is too long and the result sheet will not be renamed automatically." & Chr$(10) _
            & "Please rename it manually when the calculation is complete.", vbExclamation, AddInName)
    End If
    
    ActiveSheet.Name = TemporaryWorkSheetName
End Sub

'****************************************************************
' Restore the sheets to their state before macro activity.
'****************************************************************
Public Sub ResetTemporarySheets()
    EnteringLongTask (False)
    
    On Error GoTo Problem
    Sheets(TemporaryWorkSheetName).Name = OriginalWorksheetName
    Sheets(TemporaryInsertedSheetName).Name = OriginalInsertedSheetName
Problem:

End Sub

'****************************************************************
' Use the template to interrogate the sheetnames in the current
' workbook and come up with a new sheet name that is numerically
' higher than the others.
'****************************************************************
Public Function GetNextSheetName(template As String) As String

    ' Locate the largest chart number in the activeworkbook sheets
    Dim i As Integer, n As Integer, max_n As Integer
    Dim SheetName As String
    max_n = 0
    For i = 1 To Sheets.Count                   ' Iterate through all sheets in the workbook
        SheetName = Sheets(i).Name              ' Selecting each sheet name in turn
        If SheetName Like (template & "*") Then ' Find a match with the template
            If IsNumeric(Right(SheetName, 1)) Then  ' If the last character in the name is a number
                n = Val(Right(SheetName, 1))        ' remember the number
            End If
            If IsNumeric(Right(SheetName, 2)) Then  ' If the last two characters in the deletion list is a number
                n = Val(Right(SheetName, 2))        ' update n with that number
            End If
            If (n > max_n) Then                 ' Remember the biggest number across all sheets
                max_n = n
            End If
        End If
    Next i
    GetNextSheetName = template & CStr(max_n + 1) ' so just select the next chart name
End Function

'****************************************************************
' Convert an A1 reference to an R1C1 reference.
' Simplest call is like A1toR1C1("F25") will return "R25C6"
'****************************************************************
Public Function A1toR1C1(myRef As String, Optional absRow As Boolean = True, _
        Optional absCol As Boolean = True, Optional relTo As String = "A1") As String
    A1toR1C1 = CStr(Range(myRef).Address(absRow, absCol, xlR1C1, False, Range(relTo)))
End Function

'****************************************************************
' Convert an R1C1 reference to an A1 reference.
' A1toR1C1("A4")                        ===> R4C1
' A1toR1C1("A4",False,False)            ===> R[3]C
' A1toR1C1("A4", False, False, "J10")   ===> R[-6]C[-9]
' A1toR1C1("A4", True, False, "J10")    ===> R4C[-9]
'****************************************************************
Public Function R1C1toA1(str As String, Optional row_offset As Integer = 0, Optional col_offset As Integer = 0)
    Dim row As Integer, col As Integer
    row = Val(Mid(str, 2)) + row_offset
    col = Val(Mid(str, InStr(str, "C") + 1)) + col_offset
    R1C1toA1 = Cells(row, col).Address(RowAbsolute:=True, ColumnAbsolute:=True, ReferenceStyle:=xlA1)
End Function

'****************************************************************
' Returns whether the user has selected a worksheet
'****************************************************************
Public Function WorksheetOK() As Boolean
    
    WorksheetOK = True
    
    If (Workbooks.Count = 0) Then
        Call MsgBox("This macro must be invoked from a DMS worksheet", vbExclamation, AddInName)
        WorksheetOK = False
        Exit Function
    End If
    
    ' Check that the DMS sheet name is not already set to the TemporaryWorkSheetName
    If (ActiveSheet.Name = TemporaryWorkSheetName) Then
        Call MsgBox(TemporaryWorkSheetName & " is not allowed as a DMS sheet name", vbExclamation, AddInName)
        WorksheetOK = False
        Exit Function
    End If
    
    ' Check if the macro is being invoked from an xlWorkSheet and exit if not
    If Sheets(ActiveSheet.Name).Type <> xlWorksheet Then
        Call MsgBox("This macro must be invoked from a DMS worksheet", vbExclamation, AddInName)
        WorksheetOK = False
        Exit Function
    Else
    End If
    
    ' Check if we can parse the time column and format it if required
    If (IsRealTimeFormat = True) Then
        If (ActiveSheet.Range("A7").NumberFormat = "General") Then
            Dim answer As VbMsgBoxResult
            answer = MsgBox(Prompt:="This sheet contains a real-time format that has not been recognised by Excel." & Chr$(10) _
                    & "Do you want to re-format the time column?", Buttons:=vbYesNo + vbQuestion, title:=AddInName)
            If (answer = vbNo) Then
                WorksheetOK = False
                Exit Function
            Else
                
                Range("A7").Select
                Range(Selection, Selection.End(xlDown)).Select
                Selection.NumberFormat = Globals.GetLocalRealtimeFormat

                WorksheetOK = False
            End If
        End If
    End If

End Function
        
Public Function DmsVersion() As Integer

Dim version_detected As String
    version_detected = Cells(1, 2)
    DmsFileVersion = 0
    
    If version_detected = m_DmsFileIDVersion1 Then
        DmsFileVersion = 1
    ElseIf version_detected = m_DmsFileIDVersion2 Then
        DmsFileVersion = 2
    ElseIf version_detected = m_DmsFileIDVersion3 Then
        DmsFileVersion = 3
    ElseIf version_detected = m_DmsFileIDVersion4 Then
        DmsFileVersion = 4
    ElseIf version_detected = m_DmsFileIDVersion5 Then
        DmsFileVersion = 5
        End If
        
DmsVersion = DmsFileVersion

End Function

Public Function UIVersion() As Double

If DmsVersion() < 5 Then
UIVersion = 0#
Exit Function
End If

Dim version_detected As String
    version_detected = Cells(2, 2)
        
UIVersion = Val(Right(version_detected, 4))

End Function
'****************************************************************
' Returns whether the user has invoked a macro from the correct
' version of a DMS worksheet
'****************************************************************
Public Function DmsVersionOK() As Boolean
    
    DmsFileVersion = DmsVersion()
    
    If DmsFileVersion = 0 Then
        MsgBox ("Cannot recognise this as a valid DMS data file")
        DmsVersionOK = False
        Exit Function
    End If

    If DmsFileVersion > 3 Then
        DmsVersionOK = True
    Else
        Dim answer As VbMsgBoxResult
        answer = MsgBox(Prompt:="DMS data file version " & CStr(DmsFileVersion) & " detected:" & Chr$(10) _
            & "Do you want to convert the file to " & m_DmsFileIDVersion4 & "?", _
            Buttons:=vbYesNo + vbQuestion, title:=AddInName)
        If (answer = vbNo) Then
            DmsVersionOK = False
        Else
            If (DmsFileVersion = 1) Then
                ConvertDmsVersion1To4
            ElseIf (DmsFileVersion = 2) Then
                ConvertDmsVersion2To4
            ElseIf (DmsFileVersion = 3) Then
                ConvertDmsVersion3To4
            End If
            DmsVersionOK = True
        End If
    End If
End Function

'****************************************************************
' Returns whether the user has invoked a macro from a DME file
'****************************************************************
Public Function IsDmeFile() As Boolean
    If (Cells(1, 1) = "Timestamp") Then IsDmeFile = True Else IsDmeFile = False
End Function

'****************************************************************
' Check whether the sheet already exists in the current workbook
'****************************************************************
Public Function SheetAlreadyExists(targetsheet As String) As Boolean
    Dim sheet As Variant
    For Each sheet In Sheets
        If (sheet.Name = targetsheet) Then
            SheetAlreadyExists = True
            Exit Function
        End If
    Next sheet
    SheetAlreadyExists = False
End Function

'****************************************************************
' Check if the data sheet already exists and delete it if it does
' If the "issue_warning" flag is set then the user is prompted
' before any sheet deletions are done.
'****************************************************************
Public Function DeleteExistingSheetRequest(targetsheet As String, Optional issue_warning As Boolean = True)
    Dim sheet As Variant
    For Each sheet In Sheets
        If (sheet.Name = targetsheet) Then
            Dim answer As VbMsgBoxResult
            answer = vbYes
            If (issue_warning = True) Then
                answer = MsgBox(Prompt:=targetsheet & " already exists. Delete?", Buttons:=vbYesNo + vbQuestion, title:=AddInName)
            End If
            
            If (answer = vbNo) Then
                DeleteExistingSheetRequest = vbNo
            Else
                Application.DisplayAlerts = False
                Sheets(targetsheet).Select
                ActiveWindow.SelectedSheets.Delete
                'Worksheets(targetsheet).Delete
                Application.DisplayAlerts = True
                DeleteExistingSheetRequest = vbYes
            End If
            Exit Function
        End If
    Next sheet
    DeleteExistingSheetRequest = vbYes
End Function

'****************************************************************
' Use selecting to the end of a column to calculate the number of
' rows in a region. The first cell in the region must already be selected.
' If r1 and r2 are passed, they return the start and end rows in the selection.
'****************************************************************
Public Function GetRowsExtent(Optional ByRef r1 As Long, Optional ByRef r2 As Long) As Long
    
    ActiveSheet.UsedRange ' Resets last cell
            
    Dim r As Range ' , r1 As Long, r2 As Long
    Dim r_original As Range
    Set r_original = ActiveWindow.RangeSelection ' remember original selection
    Range(Selection, Selection.End(xlDown)).Select
    Set r = ActiveWindow.RangeSelection
    r1 = r.Rows.row
    r2 = r.Rows(r.Rows.Count).row
    GetRowsExtent = r.Rows.Count
    Range(r_original.Address).Select ' Restore original selection
End Function

'****************************************************************
' Use selecting to the end of a row to calculate the number of
' columns in a region. The first cell in the region must already be selected.
' If c1 and c2 are passed, they return the start and end columns in the selection.
'****************************************************************
Public Function GetColumnsExtent(Optional ByRef c1 As Long, Optional ByRef c2 As Long) As Long
    ActiveSheet.UsedRange ' Resets last cell
    
    Dim r_original As Range
    Set r_original = ActiveWindow.RangeSelection ' remember original selection
    Dim r As Range
    Range(Selection, Selection.End(xlToRight)).Select
    Set r = ActiveWindow.RangeSelection
    c1 = r.Columns.Column
    c2 = r.Columns(r.Columns.Count).Column
    GetColumnsExtent = r.Columns.Count
    Range(r_original.Address).Select ' Restore original selection
End Function

'****************************************************************
' Returns a single filename using a Windows dialog file selector
'****************************************************************
Public Function GetSomeFileName(file_filter As String, Optional multi_select As Boolean = False) As Variant
    On Error Resume Next
    Dim TheFiles() As String
    
    Dim SelectedFile As Variant
    SelectedFile = Application.GetOpenFilename(FileFilter:=file_filter, MultiSelect:=multi_select)

    If (SelectedFile <> False) Then
            
        If (multi_select = True) Then
            ' Display paths of each file selected
            Dim cnt As Long
            ReDim TheFiles(UBound(SelectedFile)) As String
            For cnt = 1 To UBound(SelectedFile)
                TheFiles(cnt) = SelectedFile(cnt)
            Next cnt
        Else
            ReDim TheFiles(1) As String
            TheFiles(1) = SelectedFile
        End If
        GetSomeFileName = TheFiles
    End If
    
    Exit Function
    
Problem:
    MsgBox "This was not a valid file type: " & file_filter, vbExclamation, AddInName
    GetSomeFileName = ""
End Function

Public Function IsRealTimeFormat() As Boolean
    Dim dot, colon As String
    Dim timestring As String
    ' get internationalisation symbols
    dot = Application.International(xlDecimalSeparator)
    colon = ":"    ' Application.International(xlTimeSeparator)
    
    IsRealTimeFormat = False
    If (ActiveSheet.Range("A7").NumberFormat = "General") Then
        ' Excel hasn't recognised the cell as a datetime format, because it can't be interpreted as US mm/dd/yyyy
        timestring = ActiveSheet.Range("A7").Value
        If InStr(timestring, colon) Then IsRealTimeFormat = True
    ElseIf (InStr(ActiveSheet.Range("A7").NumberFormat, colon)) Then
        ' Excel has already recognised the cell as a datetime format
        IsRealTimeFormat = True
    Else
        If InStr(ActiveSheet.Range("a7").NumberFormat, colon) Then IsRealTimeFormat = True
    End If
End Function

' Date formats in VBA are always written in terms of permutations of dmy and h:m:s.0
' In other words VBA always uses American English to code date formats. These get magically
' transformed into the local format in Excel, eg TT.MM.JJJJ hh:mm:ss,0
Public Function GetLocalRealtimeFormat() As String
    
    Dim yr As String, mth As String, dy As String
    
    yr = "y" ' Application.International(xlYearCode) & Application.International(xlYearCode)
    If (Application.International(xl4DigitYears)) Then yr = yr & yr
    mth = "m" ' Application.International(xlMonthCode)
    If (Application.International(xlMonthLeadingZero)) Then mth = mth & mth
    dy = "d" ' Application.International(xlDayCode)
    If (Application.International(xlDayLeadingZero)) Then dy = dy & dy
    
    Dim the_date As String, ds As String
    ds = "/" ' Application.International(xlDateSeparator)
    If (Application.International(xlDateOrder) = 0) Then the_date = mth & ds & dy & ds & yr
    If (Application.International(xlDateOrder) = 1) Then the_date = dy & ds & mth & ds & yr
    If (Application.International(xlDateOrder) = 2) Then the_date = yr & ds & mth & ds & dy
   
    Dim hr As String, min As String, sec As String
    
    hr = "h" ' Application.International(xlHourCode)
    If (Application.International(xlTimeLeadingZero)) Then hr = hr & hr
    min = "m" ' Application.International(xlMinuteCode)
    If (Application.International(xlTimeLeadingZero)) Then min = min & min
    sec = "s" ' Application.International(xlSecondCode)
    If (Application.International(xlTimeLeadingZero)) Then sec = sec & sec
  
    Dim the_time As String, ts As String, dec_sep
    ts = ":" ' Application.International(xlTimeSeparator)
    dec_sep = "." ' Application.International(xlDecimalSeparator)

    the_time = hr & ts & min & ts & sec & dec_sep & "0"
    GetLocalRealtimeFormat = the_date & " " & the_time ' "dd/mm/yyyy hh:mm:ss.0" ' target_realtime_format '
End Function

'****************************************************************
' Interpret the sample flow from the first comment in the DMS file
'****************************************************************
Private Function ParseSampleFlow() As Double
    Dim size_class_start_col As Integer
    size_class_start_col = 1
    Do
        size_class_start_col = size_class_start_col + 1
    Loop Until IsNumeric(Cells(6, size_class_start_col))
    
    Dim comments_start_col As Integer
    comments_start_col = size_class_start_col
    Do
        comments_start_col = comments_start_col + 1
    Loop Until Not IsNumeric(Cells(6, comments_start_col))

    Dim comment As String
    comment = Cells(7, comments_start_col + 1)
    
    Dim words() As String
    words() = Split(comment)
    Dim idx As Long
    ParseSampleFlow = 8
    For idx = 0 To UBound(words) - 1
        If (words(idx) Like "Flow*") Then
            If (Globals.DecimalSeparator = ",") Then
                words(idx + 1) = Replace(words(idx + 1), ".", ",")
            ElseIf (Globals.DecimalSeparator = ".") Then
                 words(idx + 1) = Replace(words(idx + 1), ",", ".")
            End If
           
            ParseSampleFlow = CStr(words(idx + 1))
        End If
    Next idx
End Function

'****************************************************************
' Convert from a version 1 file to the current DMS format
'****************************************************************
Private Function ConvertDmsVersion1To4()
    Range("B1").Select
    ActiveCell.FormulaR1C1 = m_DmsFileIDVersion4
    Range("D1").Select
    ActiveCell.FormulaR1C1 = "Converted from v1.00"
    
    ' Get sample flow
    Dim sf As Double
    sf = ParseSampleFlow()
    
    Range("K6").Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Insert Shift:=xlToRight
    Selection.Insert Shift:=xlToRight
    
    ' Include dilution ratio
    Range("K6").Select
    ActiveCell.FormulaR1C1 = "DilutionRatio"
    Range("K7").Select
    ActiveCell.FormulaR1C1 = "1"
    Range("K8").Select
    ActiveCell.FormulaR1C1 = "1"
        
    ' Include sample flow
    Range("L6").Select
    ActiveCell.FormulaR1C1 = "SampleFlow"
    Range("L7").Select
    ActiveCell.FormulaR1C1 = sf
    Range("L8").Select
    ActiveCell.FormulaR1C1 = sf
    
    Dim destination As String
    Dim first_excel_row As Long, last_excel_row As Long
    Range("A6").Select
    Call GetRowsExtent(first_excel_row, last_excel_row)
    
    destination = "K7:L" & CStr(last_excel_row)
    Range("K7:L8").Select
    Selection.AutoFill destination:=Range(destination)
    
    ' Other stuff
    Range("L3:L4").Select
    Selection.Insert Shift:=xlToRight
    Selection.Insert Shift:=xlToRight
    Selection.Insert Shift:=xlToRight
    Selection.Insert Shift:=xlToRight
    
    Range("L3").Select
    ActiveCell.FormulaR1C1 = "Log(MinDp)"
    Range("M3").Select
    ActiveCell.FormulaR1C1 = "SizeClasses/Decade"
    Range("N3").Select
    ActiveCell.FormulaR1C1 = "MatrixVersion"
    Range("O3").Select
    ActiveCell.FormulaR1C1 = "MaxSvdIterations"
    
    Range("L4").Select
    ActiveCell.FormulaR1C1 = "=LOG(R[2]C[1],10)"
    Range("M4").Select
    ActiveCell.FormulaR1C1 = "16"
    Range("N4").Select
    ActiveCell.FormulaR1C1 = "1"
    Range("O4").Select
    ActiveCell.FormulaR1C1 = "50"
    
    Call UpdateAoStrings
End Function

'****************************************************************
' Convert from a version 2 file to the current DMS format
'****************************************************************
Private Function ConvertDmsVersion2To4()
    Range("B1").Select
    ActiveCell.FormulaR1C1 = m_DmsFileIDVersion4
    Range("D1").Select
    ActiveCell.FormulaR1C1 = "Converted from v2.00"
    
    ' Include sample flow
    Dim sf As Double
    sf = ParseSampleFlow()
    
    Range("L6").Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Insert Shift:=xlToRight
    
    Range("L6").Select
    ActiveCell.FormulaR1C1 = "SampleFlow"
    Range("L7").Select
    ActiveCell.FormulaR1C1 = sf
    Range("L8").Select
    ActiveCell.FormulaR1C1 = sf
    
    Dim destination As String
    Dim first_excel_row As Long, last_excel_row As Long
    Range("A6").Select
    Call GetRowsExtent(first_excel_row, last_excel_row)
    
    destination = "L7:L" & CStr(last_excel_row)
    Range("L7:L8").Select
    Selection.AutoFill destination:=Range(destination)
    
    ' Other stuff
    'Range("O3:O4").Select
    'Selection.Insert Shift:=xlToRight
    
    'Range("O3").Select
    'ActiveCell.FormulaR1C1 = "MaxSVDIterations"
    'Range("O4").Select
    'ActiveCell.FormulaR1C1 = "100"
    
    Call UpdateAoStrings
End Function

'****************************************************************
' Convert from a version 3 file to the current DMS format
'****************************************************************
Private Function ConvertDmsVersion3To4()
    Range("B1").Select
    ActiveCell.FormulaR1C1 = m_DmsFileIDVersion4
    Range("D1").Select
    ActiveCell.FormulaR1C1 = "Converted from v3.00"
    
    ' Include sample flow
    Dim sf As Double
    sf = ParseSampleFlow()

    Range("L6").Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Insert Shift:=xlToRight
        
    Range("L6").Select
    ActiveCell.FormulaR1C1 = "SampleFlow"
    Range("L7").Select
    ActiveCell.FormulaR1C1 = sf
    Range("L8").Select
    ActiveCell.FormulaR1C1 = sf
    
    Dim destination As String
    Dim first_excel_row As Long, last_excel_row As Long
    Range("A6").Select
    Call GetRowsExtent(first_excel_row, last_excel_row)
    
    destination = "L7:L" & CStr(last_excel_row)
    Range("L7:L8").Select
    Selection.AutoFill destination:=Range(destination)
    
    Call UpdateAoStrings
End Function

Private Sub UpdateAoStrings()
    ' Update analog output strings
    Dim ao_string As String
    ao_string = Cells(5, 1)
    ao_string = Replace(ao_string, "Total: n/cc", "Concentration")
    If (InStr(ao_string, "weighted") = 0) Then ao_string = ao_string & " weighted by number (n/cc)"
    Cells(5, 1) = ao_string
    
    ao_string = Cells(5, 2)
    ao_string = Replace(ao_string, "Total: n/cc", "Concentration")
    If (InStr(ao_string, "weighted") = 0) Then ao_string = ao_string & " weighted by number (n/cc)"
    Cells(5, 2) = ao_string
    
    ao_string = Cells(5, 3)
    ao_string = Replace(ao_string, "Total: n/cc", "Concentration")
    If (InStr(ao_string, "weighted") = 0) Then ao_string = ao_string & " weighted by number (n/cc)"
    Cells(5, 3) = ao_string
    
    ao_string = Cells(5, 4)
    ao_string = Replace(ao_string, "Total: n/cc", "Concentration")
    If (InStr(ao_string, "weighted") = 0) Then ao_string = ao_string & " weighted by number (n/cc)"
    Cells(5, 4) = ao_string
End Sub

'Private Function ReadTextFileContents(filename As String)
'    Dim fnum As Integer, is_open As Boolean
'    On Error GoTo Problem
'    fnum = FreeFile()
'    Open filename For Input As #fnum
'    is_open = True
'    ReadTextFileContents = Input(LOF(fnum), fnum)
'Problem:
'    If (is_open) Then Close #fnum
'    If Err Then Err.Raise Err.Number, , Err.Description
'End Function

'Private Function ImportDelimitedFile(filename As String, Optional delimiter As String = vbTab) As Variant
'    Dim lines() As String, i As Long
'    lines() = Split(ReadTextFileContents(filename), vbCrLf)
'    For i = 0 To UBound(lines)
'        If (Len(lines(i)) = 0) Then lines(i) = vbNullChar
'    Next i
'    lines() = Filter(lines(), vbNullChar, False)
'    Dim values() As Variant
'    ReDim values(0 To UBound(lines)) As Variant
'    For i = 0 To UBound(lines)
'        values(i) = Split(lines(i), delimiter)
'    Next i
'    ImportDelimitedFile = values()
'End Function
'Public Sub ReadDefaultFile()
    'Dim values() As Variant, i As Long
    'values() = ImportDelimitedFile(InstallationDirectory & DefaultsFileName)
    'DecimalSeparator = values(0)(0)
'End Sub

'Public Function GetMultipleFileNames(file_type As String, file_ext As String, Optional multi_select As Boolean = False) As Variant
'    Dim fd As FileDialog
'    Dim ff As FileDialogFilters
'    Dim TheFiles() As String
'
'    ' Set up file | Open dialog
'    Set fd = Application.FileDialog(msoFileDialogFilePicker)
'    With fd
'        ' Clear default filters and create DMS file filter
'        Set ff = .Filters
'        With ff
'            .Clear
'            .Add file_type, file_ext
'        End With
            
'        .AllowMultiSelect = multi_select ' Allow multiple file selection
    
'        If .Show = False Then Exit Function ' Show the dialog, but exit if cancel is pressed
    
        ' Display paths of each file selected
'        Dim cnt As Long
'        ReDim TheFiles(.SelectedItems.count) As String
'        For cnt = 1 To .SelectedItems.count
'            TheFiles(cnt) = .SelectedItems(cnt)
'        Next cnt
'
'    End With
'    Set fd = Nothing
'    GetMultipleFileNames = TheFiles
'End Function

Attribute VB_Name = "Import"
Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function Version Lib "CamDMSjsi.dll" (ByVal SourceFile As String, ByRef NumSplitFiles As Long, ByRef DecimalDelimiter As Long) As Long
Private Declare PtrSafe Function SplitFile Lib "CamDMSjsi.dll" (ByVal SourceFile As String, ByRef NumSplitFiles As Long, ByRef DecimalDelimiter As Long) As Long
Private Declare PtrSafe Function DeleteSplitFile Lib "CamDMSjsi.dll" (ByVal SourceFile As String) As Long
Private Declare PtrSafe Function GetDecimalSeparatorCode Lib "CamDMSjsi.dll" (ByVal SourceFile As String) As Long
#Else
Private Declare Function Version Lib "CamDMSjsi.dll" (ByVal SourceFile As String, ByRef NumSplitFiles As Long, ByRef DecimalDelimiter As Long) As Long
Private Declare Function SplitFile Lib "CamDMSjsi.dll" (ByVal SourceFile As String, ByRef NumSplitFiles As Long, ByRef DecimalDelimiter As Long) As Long
Private Declare Function DeleteSplitFile Lib "CamDMSjsi.dll" (ByVal SourceFile As String) As Long
Private Declare Function GetDecimalSeparatorCode Lib "CamDMSjsi.dll" (ByVal SourceFile As String) As Long
#End If

Public Type SDateParse
    density As Single
    power As Single
    Modename As String
End Type

' Called from Excel's overridden File->Open command, toolbar, or CtrlO
' This bypasses Excel's normal file import wizard
Public Sub OpenIt()
    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = False
    
    'Globals.ReadOptions

    Dim file_paths As Variant
    Dim file_path As String
    Dim decimal_separator As Integer
    
    'If (Application.Version = "9.0") Then
        file_paths = Globals.GetSomeFileName("All files (*.*), *.*", True)
    '    ImportSplitFiles (file_path)
    'Else
    '    file_path = GetMultipleFileNames("All files", "*.*", True)
        If (IsEmpty(file_paths)) Then Exit Sub
        
        Dim lo As Integer, hi As Integer
        lo = LBound(file_paths)
        hi = UBound(file_paths)
        Dim i As Integer
        
        For i = lo + 1 To hi
            file_path = file_paths(i)
             ' Deal with a non DMS file first
            If (LCase(Right(file_path, 3)) <> "dms") Then
            Workbooks.OpenText filename:=file_path
            Else
            decimal_separator = GetDecimalSeparatorCode(file_path)
            Call ImportSplitFiles(file_path, decimal_separator)
            End If
        Next i
    'End If
    
    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = True
End Sub

' Called from the DmsSplitter application after creating a new Excel application
' file_path is passed from DmsSplitter as the target DMS file
Public Sub OpenFromExplorer(file_path As String, decimal_separator As Integer)
    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = False
    'Globals.ReadOptions
    
    If (file_path <> "") Then
        Dim str As String
        str = Replace(file_path, """", "") ' Remove quotes if necessary
        Call ImportSplitFiles(str, decimal_separator)
    End If
    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = True
End Sub

Private Sub ImportSplitFiles(imported_file_path As String, decimal_separator As Integer)
        
    If (imported_file_path = "") Then
        Exit Sub
    End If
    
    ' Deal with a non DMS file first
    If (LCase(Right(imported_file_path, 3)) <> "dms") Then
        Workbooks.OpenText filename:=imported_file_path
        GoTo Finished
    End If
    
    ' Handle a file with a DMS extension
    Dim xl_file_path As String
    Dim default_dropdown_extn As Integer

    If (Globals.ExcelVersion < 12) Then
        xl_file_path = ChangeExtension(imported_file_path, "xls")
        default_dropdown_extn = 1
    Else
        If SaveAsMacroWorkbook() Then
            xl_file_path = ChangeExtension(imported_file_path, "xlsm")
            default_dropdown_extn = 3
        Else
            xl_file_path = ChangeExtension(imported_file_path, "xlsx")
            default_dropdown_extn = 2
        End If
    End If
    
    ' Make sure our file->open and file->save dialogs start in the right place
    Dim current_directory As String
    current_directory = GetDirectoryFromPath(imported_file_path)
    Application.DefaultFilePath = current_directory
    
    ' If the XLS file derived from the DMS data doesn't already exist, we can create it now
    If (Dir(xl_file_path) = "") Then
        Call WriteDmsDataToExcelFile(imported_file_path, xl_file_path, decimal_separator)
        GoTo Finished
    End If
    
    ' The XLS file already exists, so we need to get the user to decide what to do about it
    Dim import_dms_file As ImportDmsFile
    Set import_dms_file = New ImportDmsFile
    import_dms_file.Show
    If (import_dms_file.OkWasPressed = False) Then GoTo Finished
    
    ' The user wants to ignore the DMS file and select an existing XLS file
    If (import_dms_file.OpenExistingFile.Value = True) Then
        ' Ask the user which file to open
        Dim new_open_file_name As Variant
        ChangeDirectory (GetDirectoryFromPath(imported_file_path))
        new_open_file_name = Application.GetOpenFilename(FileFilter:="Excel 97-2003 Workbooks (*.xls), *.xls,Excel 2007+ Workbooks (*.xlsx), *.xlsx, Excel 2007+ Macro Workbooks (*.xlsm), *.xlsm", FilterIndex:=default_dropdown_extn, title:="Open an Excel file already generated from the DMS file")

        If (new_open_file_name <> False) Then
            Workbooks.OpenText filename:=new_open_file_name
        End If
 
    ' The user wants to create a new XLS file using the DMS data
    ElseIf (import_dms_file.CreateNewFile = True) Then
        ' Get the user to name the new file
        'Dim initial_file_name As String
        'initial_file_name = FilenameExt(xl_file_path)
        Dim new_saveas_variant As Variant
        ChangeDirectory (GetDirectoryFromPath(imported_file_path))
        new_saveas_variant = Application.GetSaveAsFilename(InitialFileName:="", FileFilter:="Excel 97-2003 Workbooks (*.xls), *.xls,Excel 2007+ Workbooks (*.xlsx), *.xlsx, Excel 2007+ Macro Workbooks (*.xlsm), *.xlsm", FilterIndex:=default_dropdown_extn, title:="Generate another Excel file from the selected DMS file")
    
        If (new_saveas_variant <> False) Then
            Dim new_save_as_filename As String
            new_save_as_filename = new_saveas_variant
            Call WriteDmsDataToExcelFile(imported_file_path, new_save_as_filename, decimal_separator)
        End If
        
    ElseIf (import_dms_file.OverWrite = True) Then
        If (MsgBox("Are you sure you wish to overwrite the existing Excel file? Any post-processing will be lost!", vbQuestion + vbYesNo) = vbNo) Then
            GoTo Finished
        Else
            Kill xl_file_path
            Call WriteDmsDataToExcelFile(imported_file_path, xl_file_path, decimal_separator)
        End If
    Else
        ' We shouldn't reach here unless there are other options that we haven't catered for
        MsgBox ("Internal error: Unknown option selected in Public Sub ImportSplitFiles")
    End If
    
Finished:
End Sub
        
' Write to an XLS file by creating a new workbook of the same name with one worksheet in it.
Private Sub WriteDmsDataToExcelFile(dms_file_path As String, xl_file_path As String, decimal_separator_code As Integer)
    
    Dim xl_file_name As String
    xl_file_name = FilenameNoExt(xl_file_path)
   ' If (Len(xl_file_name) > 29) Then 'Allow 2 characters for the splitfile number appendage
   '     MsgBox ("Excel file name is too long: please ensure that the filename constains no more than 29 characters.")
   '    Exit Sub
   'End If
        
    'Workbooks.Add template:=xlWorksheet
    ' Save immediately so that the workbook has a valid name that we can refer to
    'ActiveWorkbook.SaveAs xl_file_path
    
    ' Split the single DMS file into several files with 32K lines max
    'Dim number_of_split_files As Long, error_code As Long, decimal_separator_code As Long
    'error_code = SplitFile(dms_file_path, number_of_split_files, decimal_separator_code) ' Located in Dms500.dll
    
    ' Perform error handling
    'If (error_code = -1) Then
    '    MsgBox ("File format error: please check that this file really exists and that it really contains ASCII DMS data!!")
    '    Exit Sub
    'End If
    'If (number_of_split_files <= 0) Then
    '    MsgBox ("Internal error: DMS SplitFile function")
    '    Exit Sub
    'End If
    
    ' Read in all the split files into sheets in a single Excel workbook
    Dim xl_file_name_with_ext As String, dms_file_name As String, decimal_separator As String, thousands_separator As String
    xl_file_name_with_ext = FilenameExt(xl_file_path)
    dms_file_name = FilenameNoExt(dms_file_path)
    
    If (decimal_separator_code = 0) Then
        decimal_separator = ","
        thousands_separator = "."
    Else
        decimal_separator = "."
        thousands_separator = ","
    End If
    
    'Dim filenum As Long
    'Dim splitfilename As String, splitfilepath As String
    'If (number_of_split_files = 1) Then ' Don't append _1 to a single file
    '    splitfilename = dms_file_name & "1"
    '    splitfilepath = Globals.UserTempDirectory & splitfilename & ".txt"
    '    Workbooks.OpenText filename:=splitfilepath, DecimalSeparator:=decimal_separator, ThousandsSeparator:=thousands_separator
    '    Sheets(splitfilename).Move After:=Workbooks(xl_file_name_with_ext).Sheets(1)
    '    ActiveSheet.Name = xl_file_name
    '    DeleteSplitFile (splitfilepath)
    'Else
    '    For filenum = number_of_split_files To 1 Step -1
    '        splitfilename = dms_file_name & CStr(filenum)
    '        splitfilepath = Globals.UserTempDirectory & splitfilename & ".txt"
    '        Workbooks.OpenText filename:=splitfilepath, DecimalSeparator:=decimal_separator, ThousandsSeparator:=thousands_separator
    '        Sheets(splitfilename).Move After:=Workbooks(xl_file_name_with_ext).Sheets(1)
    '        ActiveSheet.Name = xl_file_name & "_" & CStr(filenum)
    '        DeleteSplitFile (splitfilepath)
    '    Next filenum
    'End If
    
    Workbooks.OpenText filename:=dms_file_path, DecimalSeparator:=decimal_separator, ThousandsSeparator:=thousands_separator
    
    If (Right(xl_file_path, 1) = "x") Then
        ActiveWorkbook.SaveAs xl_file_path, FileFormat:=51
    ElseIf (Right(xl_file_path, 1) = "m") Then
        ActiveWorkbook.SaveAs xl_file_path, FileFormat:=52
    Else
        ActiveWorkbook.SaveAs xl_file_path, FileFormat:=xlWorkbookNormal
    End If
    
    Dim ao_string As String
    If (Globals.DecimalSeparator = ",") Then
        ao_string = Cells(5, 1)
        Cells(5, 1) = Replace(ao_string, ".", ",")
        ao_string = Cells(5, 2)
        Cells(5, 2) = Replace(ao_string, ".", ",")
        ao_string = Cells(5, 3)
        Cells(5, 3) = Replace(ao_string, ".", ",")
        ao_string = Cells(5, 4)
        Cells(5, 4) = Replace(ao_string, ".", ",")
    Else
        ao_string = Cells(5, 1)
        Cells(5, 1) = Replace(ao_string, ",", ".")
        ao_string = Cells(5, 2)
        Cells(5, 2) = Replace(ao_string, ",", ".")
        ao_string = Cells(5, 3)
        Cells(5, 3) = Replace(ao_string, ",", ".")
        ao_string = Cells(5, 4)
        Cells(5, 4) = Replace(ao_string, ",", ".")
    End If
    
    If (Globals.IsRealTimeFormat()) Then
        FormatForeignRealTimeTimestamps
        ' format in number format to make easy to read
    End If
    
    Call Globals.DeleteExistingSheetRequest("Sheet1", False)
    
    Call ColourDmsFile(Globals.ColourDmsFileCells)
    
    ActiveWorkbook.Sheets(1).Name = Left(xl_file_name, 26)
    
    ActiveWorkbook.Save ' Save again so that the workbook is saved if the user terminates
        
End Sub

Private Sub FormatForeignRealTimeTimestamps()
    Dim r As Long, r1 As Long, r2 As Long, num_rows As Long
    
    num_rows = Globals.GetRowsExtent(r1, r2)
    
    Dim real_time_format As String
    real_time_format = Cells(5, 9).Text
    
    If (Len(real_time_format) > 0) Then
    
        Dim rt_structure As String
        rt_structure = Text2Structure(real_time_format)
    
        If (ActiveSheet.Range("A7").NumberFormat = "General") Then
            For r = 7 To r2
                Cells(r, 1) = Text2Dbl(Cells(r, 1), rt_structure)
            Next r
        End If
    Else
    
        MsgBox Prompt:="Real-time stamp generated by User Interface version prior to 4.06." & Chr(10) & _
        "Subsequent calculations involving time-intervals may be incorrect." & Chr(10) & _
        "See known issues page of help file for more information.", Buttons:=vbOKOnly + vbInformation
    
        Dim original_timestamp As String, local_timestamp As String
        Dim original_date_separator As String, local_date_separator As String
        Dim original_decimal_separator As String, local_decimal_separator As String
        Dim original_number_format As String
        
        original_number_format = ActiveSheet.Range("A7").NumberFormat
        If (InStr(original_number_format, ":")) Then
            ActiveSheet.Range("A7").NumberFormat = Globals.GetLocalRealtimeFormat
        End If
        
        original_timestamp = Cells(7, 1).Text
        ActiveSheet.Range("A7").NumberFormat = original_number_format
        
        If (InStr(Left(original_timestamp, 10), Application.International(xlDateSeparator)) = 0) Then ' There's no correct date separator
            If (Application.International(xlDateSeparator) = "/") Then ' Date separator should be /
                local_date_separator = "/"
                local_decimal_separator = "."
                original_date_separator = "."
                original_decimal_separator = ","
            Else
                local_date_separator = "."
                local_decimal_separator = ","
                original_date_separator = "/"
                original_decimal_separator = "."
            End If
            
            For r = 7 To r2
                original_timestamp = Cells(r, 1)
                local_timestamp = Replace(original_timestamp, original_date_separator, local_date_separator, 1, 10)
                local_timestamp = Replace(local_timestamp, original_decimal_separator, local_decimal_separator) ' Replace fractional timestamp , with .
                Cells(r, 1) = local_timestamp
            Next r
        End If
        
        ' This is for a real time format that hasn't already been recognised as such by Excel
        If (ActiveSheet.Range("A7").NumberFormat = "General") Then
            Range("A7").Select
            
            Dim timestring, sub_sec, super_sec As String
            Dim row As Long
            For row = 7 To r2
                timestring = ActiveSheet.Cells(row, 1).Value
                sub_sec = Right(timestring, 1)
                super_sec = Left(timestring, Len(timestring) - 2)
                    
                Dim time_value As Double
                time_value = CDbl(DateValue(super_sec)) + CDbl(TimeValue(super_sec)) + CDbl(sub_sec) / 864000
                ActiveSheet.Cells(row, 1).Value = time_value
            Next row
        End If

    End If
    
    Range("A7").Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.NumberFormat = Globals.GetLocalRealtimeFormat

End Sub

Private Function RemoveDuplicates(str As String) As String
    Dim i As Long, tempstr As String
    Dim char_found As Boolean
    Dim j As Integer
    For i = 1 To Len(str)
        char_found = False
        For j = 1 To Len(tempstr)
            If (Mid(str, i, 1) = Mid(tempstr, j, 1)) Then char_found = True
        Next
        If (char_found = False) Then tempstr = tempstr & Mid(str, i, 1)
    Next
    RemoveDuplicates = tempstr
End Function

Private Function GetDateSeparator(txt As String) As String
    Dim c As String
    GetDateSeparator = ""
    Dim i As Integer
    For i = 1 To Len(txt)
        c = Mid(txt, i, 1)
        If (c <> "d" And c <> "m" And c <> "y") Then
            GetDateSeparator = c
            Exit Function
        End If
    Next
End Function

Private Function Text2Structure(txt As String)
    Dim s() As String
    txt = LCase(txt)
    s = Split(txt, " ")

    Dim the_date As String: the_date = s(0)
    Dim date_separator As String: date_separator = GetDateSeparator(the_date)
    the_date = Replace(the_date, ".", "")
    the_date = Replace(the_date, "-", "")
    the_date = Replace(the_date, "/", "")
    the_date = RemoveDuplicates(the_date)

    Text2Structure = date_separator & the_date ' eg "/dmy"
End Function

Private Function Text2Dbl(txt As String, date_structure As String) As Double

    Dim date_separator As String: date_separator = Left(date_structure, 1)
    Dim date_order As String: date_order = Mid(date_structure, 2, 3)
    
    Dim s() As String
    s = Split(txt, " ")
    Dim the_date As String: the_date = s(0)
    Dim date_parts() As String
    date_parts = Split(the_date, date_separator)
    Dim i As Integer
    Dim the_day As Integer, the_month As Integer, the_year As Integer
    For i = 1 To 3
        If (Mid(date_order, i, 1) = "d") Then
            the_day = CInt(date_parts(i - 1))
        ElseIf (Mid(date_order, i, 1) = "m") Then
            the_month = CInt(date_parts(i - 1))
        ElseIf (Mid(date_order, i, 1) = "y") Then
            the_year = CInt(date_parts(i - 1))
        End If
    Next i
    
    Dim date_dbl As Variant
    date_dbl = DateSerial(the_year, the_month, the_day)
     
    Dim the_time As String: the_time = s(1)
    Dim time_parts() As String
    time_parts = Split(the_time, ":")
    Dim the_hour As Integer, the_minute As Integer, the_second As Integer, the_subsecond As Integer
    the_hour = CInt(time_parts(0))
    the_minute = CInt(time_parts(1))
    
    If (IsNumeric(Left(time_parts(2), 2))) Then
        the_second = CInt(Left(time_parts(2), 2))
    Else
        the_second = CInt(Left(time_parts(2), 1))
    End If
    
    Dim dec_separator As String
    If (UBound(s) = 2) Then
        dec_separator = Mid(s(2), Len(s(2)) - 1, 1)
        If (dec_separator = "." Or dec_separator = ",") Then
            the_subsecond = CInt(Right(s(2), 1))
        Else
            the_subsecond = 0
        End If
    Else
        dec_separator = Mid(time_parts(2), Len(time_parts(2)) - 1, 1)
        If (dec_separator = "." Or dec_separator = ",") Then
            the_subsecond = CInt(Right(the_time, 1))
        Else
            the_subsecond = 0
        End If
    End If
    
    Dim time_dbl As Variant
    time_dbl = TimeSerial(the_hour, the_minute, the_second)
    
    Text2Dbl = date_dbl + time_dbl + the_subsecond / 864000
    
End Function

Public Sub ColourDmsFile(enable As Boolean)

    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = False
    
    Dim DmsFileVersion As Integer
    Dim UI As Double
    DmsFileVersion = DmsVersion()
    UI = UIVersion()
    
    ' Always format row 6:
    Rows("6:6").Select
    With Selection
        .HorizontalAlignment = xlGeneral
        .VerticalAlignment = xlBottom
        .WrapText = True
        .Orientation = 90
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .MergeCells = False
    End With
    
    Dim fs As CFileSpec
    Set fs = New CFileSpec
    Call fs.ConfigureDataSource(DmsFile, ParticleSizeData)
    
    If (enable = False) Then
    
        Cells.Select
        Selection.Borders(xlDiagonalDown).LineStyle = xlNone
        Selection.Borders(xlDiagonalUp).LineStyle = xlNone
        Selection.Borders(xlEdgeLeft).LineStyle = xlNone
        Selection.Borders(xlEdgeTop).LineStyle = xlNone
        Selection.Borders(xlEdgeBottom).LineStyle = xlNone
        Selection.Borders(xlEdgeRight).LineStyle = xlNone
        Selection.Borders(xlInsideVertical).LineStyle = xlNone
        Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
    Else
    

        
        Call ColourThisRange(Range("A6"), 15)        ' Grey timestamp
        If Not (Globals.IsRealTimeFormat() Or fs.RealTime) Then
            Range("A7").Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.0"
        End If
        Call ColourThisRange(Range("B6:E6"), 32)     ' Brown AI
        Call ColourThisRange(Range("F6"), 3)         ' Red Total
        Call ColourThisRange(Range("G6:J6"), 39)     ' Turquoise AO
        Call ColourThisRange(Range("K6:L6"), 14)     ' Khaki DIL + Sampleflow
        Range("K7").Select
        Range(Selection, Selection.End(xlDown)).Select
        Selection.NumberFormat = "0.0"
        Range("L7").Select
        Range(Selection, Selection.End(xlDown)).Select
        Selection.NumberFormat = "0.00"
        
        If (DmsFileVersion > 4) Then
        
            Call ColourThisRange(Range(Cells(6, fs.FirstDilCol), Cells(6, fs.FirstDilCol + fs.ExtraColsV5)), 14) ' Khaki 1/2 DIL + Line params
            Range(Cells(6, fs.FirstDilCol), Cells(6, fs.FirstDilCol + fs.ExtraColsV5)).Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.0"
            
              'v7.24 - dynamic dynamic range indicator colouring
            
            If (UI >= 6.02) Then
                Call ColourThisRange(Cells(6, fs.FirstDilCol + fs.ExtraColsV5 + 1), 14) ' Khaki
                Cells(7, fs.FirstDilCol + fs.ExtraColsV5 + 1).Select
                Range(Selection, Selection.End(xlDown)).Select
                Selection.NumberFormat = "0.0"
                Selection.FormatConditions.Add Type:=xlCellValue, Operator:=xlNotBetween, _
                Formula1:="2.5", Formula2:="7.5"
                Selection.FormatConditions(1).Font.ColorIndex = 3
                Selection.FormatConditions.Add Type:=xlCellValue, Operator:=xlBetween, _
                Formula1:="5", Formula2:="7.5"
                Selection.FormatConditions(2).Font.ColorIndex = 45
                Selection.FormatConditions.Add Type:=xlCellValue, Operator:=xlBetween, _
                Formula1:="2.5", Formula2:="5"
                Selection.FormatConditions(3).Font.ColorIndex = 10
            End If
        
        End If
        
        If (fs.NumModes >= 1) Then
            Call ColourThisRange(Range("M6:O6"), 6)     ' Yellow
            Range("M7").Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.0"
            Range("O7").Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.00"
        End If
        If (fs.NumModes >= 2) Then
            Call ColourThisRange(Range("P6:R6"), 4)     ' Green
            Range("P7").Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.0"
            Range("R7").Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.00"
        End If
        If (fs.NumModes >= 3) Then
            Call ColourThisRange(Range("S6:U6"), 12)    ' Orange
            Range("S7").Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.0"
            Range("U7").Select
            Range(Selection, Selection.End(xlDown)).Select
            Selection.NumberFormat = "0.00"
        End If
        
        Call ColourThisRange(Range(Cells(fs.DataStartRow - 1, fs.DataStartCol), Cells(fs.DataStartRow - 1, fs.DataStartCol + fs.NumDataCols - 1)), 3) ' Red
        
    End If
    
    Cells(fs.DataStartRow, fs.DataStartCol + fs.NumDataCols + 3).Select 'v7.24, autofit errors
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Columns.AutoFit
    
    'v7.24 concatenate errors
    Cells(fs.DataStartRow, fs.DataStartCol + fs.NumDataCols + 3).Select
    Range(Selection, Selection.End(xlDown)).Select
    Dim ErrorList() As Variant
    Dim SubErrorList() As String
    Dim FinalErrorList() As String
    Dim WarningsPresent As Boolean
    WarningsPresent = False
    ReDim FinalErrorList(0)
    Dim s, t As Variant
    ErrorList() = Selection
    For Each s In ErrorList
        SubErrorList = Split(CStr(s), "*")
        For Each t In SubErrorList
            If InStr(CStr(t), "until stable") = 0 Then ' dont add stabilisation messages
                If (UBound(Filter(FinalErrorList, Trim(CStr(t)))) < 0) Then 'don't add if already there
                    ReDim Preserve FinalErrorList(LBound(FinalErrorList) To UBound(FinalErrorList) + 1)
                    FinalErrorList(UBound(FinalErrorList)) = Trim(CStr(t))
                    WarningsPresent = True
                End If
            End If
        Next
    Next
    If WarningsPresent Then
        Range("F1").Value = "Warnings: "
        Range("F1").Font.Color = RGB(255, 0, 0)
        Range("G1").Value = Mid(Join(FinalErrorList, " * "), 4) ' mid needed to remove inital blank error
    Else
        Range("F1").Value = "No Warnings"
        Range("F1").Font.Color = RGB(0, 128, 0)
    End If
    
    Range("A1").Activate
    Range("A1").Select

    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = True
End Sub
    
Public Sub ColourThisRange(rng As Range, color_idx As Integer)
    rng.Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = xlMedium ' xlThin
        .ColorIndex = color_idx
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = color_idx
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = color_idx
    End With
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = color_idx
    End With
    
    If (rng.Columns.Count > 1) Then
        With Selection.Borders(xlInsideVertical)
            .LineStyle = xlContinuous
            .Weight = xlMedium
            .ColorIndex = color_idx
        End With
    End If
    
    With Selection.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = color_idx
    End With
End Sub

' Returns just the name of the file without extension or any directory information
Private Function FilenameNoExt(path As String) As String
    Dim filename_with_extension As String
    filename_with_extension = FilenameExt(path)
    FilenameNoExt = Left(filename_with_extension, InStrRev(filename_with_extension, ".") - 1)
End Function

' Returns just the name of the file with extension but no directory information
Private Function FilenameExt(path As String) As String
    FilenameExt = Right(path, Len(path) - InStrRev(path, "\"))
End Function

' Returns just the name of the file with extension but no directory information
Private Function GetDirectoryFromPath(path As String) As String
    GetDirectoryFromPath = Left(path, InStrRev(path, "\"))
End Function

' Returns just the name of the file with extension but no directory information
Private Function ChangeExtension(path As String, new_extension As String) As String
    ChangeExtension = Left(path, InStrRev(path, ".")) & new_extension
End Function

Private Sub ChangeDirectory(path As String)
    If Left(path, 1) = "\" Then Exit Sub ' coping with UNC network addresses is hard
    ChDrive (Left(path, 1))
    ChDir (path)
End Sub
Attribute VB_Name = "ImportDmsFile"
Attribute VB_Base = "0{098D9664-972A-4E16-98DB-8E50A60FCC07}{30C810BD-C94C-4CD0-879B-7B008DBD344F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit ' Generate errors if declarations are not explicit

Public OkWasPressed As Boolean  ' Used to notify the client that the user wants to proceed

'****************************************************************
' Initialise the dialog during creation
'****************************************************************
Private Sub Userform_Initialize()
    OkWasPressed = False
End Sub

'****************************************************************
' The user has hit the OK button...
'****************************************************************
Private Sub OKbutton_Click()
    OkWasPressed = True
    Unload Me
End Sub

'****************************************************************
' Don't proceed if the user hits cancel
'****************************************************************
Private Sub CancelButton_Click()
    OkWasPressed = False
    Unload Me
End Sub

Attribute VB_Name = "Install"
Option Explicit ' Generate errors if declarations are not explicit

Private Const c_DmsButtonStyle As Integer = msoButtonIcon ' msoButtonIconAndCaption '

'****************************************************************
' Install the toolbar. This is called when the Workbook_AddinInstall()
' function is invoked when the user selects Tools->Addins and checks DmsUtilities
'****************************************************************
Public Sub InstallDmsUtilities()
    'On Error GoTo Problem
    
    Dim animation_picture As IPictureDisp, contour_picture As IPictureDisp
    'Set animation_picture = stdole.StdFunctions.LoadPicture(Application.TemplatesPath & "\AnimationIcon.gif")
    'Set contour_picture = LoadPicture(Globals.InstallationDirectory & "ContourIcon.gif")
    
    Dim cmdbar As CommandBar
    Set cmdbar = Application.CommandBars.Add ' Add a toolbar
        cmdbar.Name = "Dms"                  ' with the name "Dms"

    Dim btnForm As CommandBarButton
    With cmdbar.Controls
        Set btnForm = .Add(msoControlButton) 'Add a button
    End With

    With btnForm                             'Set the new button's properties
        .Style = c_DmsButtonStyle
        .Caption = "Contour"
        '.Picture = contour_picture
        .FaceId = 2479 ' Camera ' 1763 ' Rosette ' 417  ' Painter's pallette ' 17 Bar chart icon '.FaceId = 281 ' Video camera icon
        .OnAction = "Main.ContourPlotEntry"        ' The global function to call when the button is hit
        .TooltipText = "Create a contour plot from a DMS data file"
    End With
  
    ' Add an animation sheet button
    Dim btnAnimationPopup As CommandBarPopup
    With cmdbar.Controls
        Set btnAnimationPopup = .Add(msoControlPopup) 'Add a button
    End With

    With btnAnimationPopup
        .Caption = "Animation"
        '.FaceId = 281 ' Video camera ' 17 ' Bar chart icon
        '.OnAction = "Main.AnimationEntry" ' "CreateAnimationSheet"
        .TooltipText = "Animation controls"
        
        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "New animation"
            .FaceId = 583
            .OnAction = "Main.AnimationEntry"
            .TooltipText = "Create an animation worksheet"
        End With
        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "Start"
            .FaceId = 1100
            .OnAction = "Animation.PlayAnimation"
            .TooltipText = "Start the animation"
        End With
        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "Stop"
            .FaceId = 358
            .OnAction = "Animation.StopAnimation"
            .TooltipText = "Stop the animation"
        End With
    End With

    ' Add a reinvert button
    With cmdbar.Controls
        Set btnForm = .Add(msoControlButton) 'Add a button
    End With
    With btnForm                             'Set the new button's properties
        .Style = c_DmsButtonStyle
        .Caption = "ReInvert"
        .FaceId = 2588 ' Block / Block '
        .OnAction = "Main.InversionEntry"
        .TooltipText = "Re-invert the DMS ring currents using a different inversion matrix"
    End With

    ' Add a summary button
    Dim btnPopup As CommandBarPopup
    With cmdbar.Controls
        Set btnPopup = .Add(msoControlPopup)  'Add a popup
    End With
    With btnPopup                             'Set the new button's properties
        '.Style = c_DmsButtonStyle
        .Caption = "Summary"
        '.FaceId = 226 ' Sigma
        '.OnAction = "Main.SummaryEntry"
        .TooltipText = "Generate summary data"

        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "New Sheet"
            .FaceId = 583 ' 226 ' Sigma
            .OnAction = "Main.SummaryEntry"
        End With
        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "Add Time Interval"
            .FaceId = 437
            .OnAction = "Summary.AddRow"
        End With
        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "Add Size Range"
            .FaceId = 438
            .OnAction = "Summary.AddCol"
        End With
        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "Size Spectral Density Chart"
            .FaceId = 422
            .OnAction = "Summary.ChartSizeSpectralDensity"
        End With
        Set btnForm = .Controls.Add(msoControlButton)
        With btnForm
            .Caption = "Cumulative Concentration Chart"
            .FaceId = 422
            .OnAction = "Summary.ChartCumulativeConcentration"
        End With
        
    End With

    ' Add a hammer button
    'With cmdbar.Controls
    '    Set btnForm = .Add(msoControlButton) 'Add a button
    'End With
    'With btnForm                             'Set the new button's properties
    '    .Style = c_DmsButtonStyle
    '    .Caption = "Format real-time column"
    '    .FaceId = 2112  ' Hammer and nail
    '    .OnAction = "Globals.FormatFractionalRealtime"
    '    .TooltipText = "Format fractional real-time"
    'End With
    
       ' Add a lognormal button
    With cmdbar.Controls
        Set btnForm = .Add(msoControlButton) 'Add a button
    End With
    With btnForm                             'Set the new button's properties
        .Style = c_DmsButtonStyle
        .Caption = "Reconstruct Lognormal"
        .FaceId = 273 ' Bell
        .OnAction = "Reconstruct.LN_reconstruct"
        .TooltipText = "Reconstruct Lognormal"
    End With
    
    ' Add a help button
    With cmdbar.Controls
        Set btnForm = .Add(msoControlButton) 'Add a button
    End With
    With btnForm                             'Set the new button's properties
        .Style = c_DmsButtonStyle
        .Caption = "Help"
        .FaceId = 983 ' 49 ' Question Mark
        .OnAction = "Main.DmsHelp"
        .TooltipText = "Dms Utilities Help"
    End With
  
    ' Made visible in the form terminate event
    cmdbar.visible = True
    
    'MsgBox ("Installation complete")
    'MsgBox "Microsoft Excel is using " & Application.OperatingSystem
    Exit Sub

Problem:
    MsgBox ("Installation failed")
End Sub


Attribute VB_Name = "InversionControl"
Attribute VB_Base = "0{26449EA2-F76E-4085-8E5A-28F27F411050}{43D086FB-15C9-4964-B27D-20AC558C209E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit ' Generate errors if declarations are not explicit
Option Compare Text

#If VBA7 Then
Private Declare PtrSafe Function VersionNumber Lib "CamDMSjsi.dll" () As Long
#Else
Private Declare Function VersionNumber Lib "CamDMSjsi.dll" () As Long
#End If


Public OkWasPressed As Boolean  ' Used to notify the client that the user wants to proceed
Public ExclusionArray As Collection

Private Enum EInvFileType
    eDmxFile = 0
    eDmdFile = 1
End Enum

Private m_ParameterOptions(3) As String

Private Const c_NONE As String = "None"
Private Const c_CUSTOM As String = "Custom"
Private Const c_SIZE As String = "Size"
Private Const c_MODE As String = "Mode"
Private Const c_COMBINED As String = "Combined"

' Information read from the DMD file
Private m_Modenames() As String
Private m_Densities() As Double
Private m_Indices() As Double
Private m_NumModes As Integer
Private m_DmdWeightingTxt As String
Private m_DmdWeightingUnits As String

'Weighting
Public WeightingType As EWeightingType
Public DensityMultiplier As Single

Public Function GetSpectralWeightingUnits()
    Dim i As Integer
    i = InStr(tbWeightingText, " ")
    If (i > 0) Then
        GetSpectralWeightingUnits = "(" & Right$(tbWeightingText, Len(tbWeightingText) - i) & ")"
    End If
End Function

Private Sub Cancel_Click()
    OkWasPressed = False
    Unload Me
End Sub

' Weighting ================>>>>>>>>>>>>>>>>>>
Private Sub tbDensity_Change()
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
        tbWeightingConstant = 1
    'Else
    '    ' Restore whatever the previous text was
    '    If (WeightingType = eNumber) Then
    '        Call NumberWeighting_Click
    '    ElseIf (WeightingType = eLength) Then
    '       Call LengthWeighting_Click
    '    ElseIf (WeightingType = eArea) Then
    '       Call AreaWeighting_Click
    '   ElseIf (WeightingType = eVolume) Then
    '       Call VolumeWeighting_Click
    '   End If
    End If
End Sub
Private Sub tbDensityFactor_Change()
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
        tbWeightingConstant = 1
    'Else
        ' Restore whatever the previous text was
     '   If (WeightingType = eNumber) Then
      '      Call NumberWeighting_Click
       ' ElseIf (WeightingType = eLength) Then
        '    Call LengthWeighting_Click
        'ElseIf (WeightingType = eArea) Then
         '   Call AreaWeighting_Click
        'ElseIf (WeightingType = eVolume) Then
         '   Call VolumeWeighting_Click
        'End If
    End If
End Sub

Private Sub NumberWeighting_Click()
    tbWeightingConstant = 1
    WeightingPower = 0
    WeightingType = eNumber
    tbWeightingConstant.Enabled = True
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = False
    rbDensity.Enabled = False
    rbDensityFactor.Enabled = False
    
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dN/dlogdp /cc"
    End If
End Sub

Private Sub LengthWeighting_Click()
    tbWeightingConstant = 1 / 1#
    WeightingPower = 1
    WeightingType = eLength
    tbWeightingConstant.Enabled = True
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = False
    rbDensity.Enabled = False
    rbDensityFactor.Enabled = False
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dl/dlogdp |fffd|m/cc"
    End If
End Sub

Private Sub AreaWeighting_Click()
    tbWeightingConstant = CStr(3.141592654 / 1#)
    WeightingPower = 2
    WeightingType = eArea
    tbWeightingConstant.Enabled = True
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = False
    rbDensity.Enabled = False
    rbDensityFactor.Enabled = False

    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dA/dlogdp |fffd|m^2/cc"
    End If
End Sub

Private Sub rbDensity_Click()
    tbDensity.Enabled = True
    tbDensityFactor.Enabled = False
    tbWeightingConstant.Enabled = True
    tbWeightingText = "dMdlogDp |fffd|g/cc"
End Sub

Private Sub rbDensityFactor_Click()
    tbDensity.Enabled = False
    tbDensityFactor.Enabled = True
    tbWeightingConstant.Enabled = False
    tbWeightingText = "dMdlogDp |fffd|g/cc"
End Sub

Private Sub VolumeWeighting_Click()
    tbWeightingConstant = CStr(3.141592654 / 6#)
    WeightingPower = 3
    WeightingType = eVolume
    
    rbDensity.Enabled = True
    rbDensityFactor.Enabled = True
    If (rbDensity) Then tbDensity.Enabled = True
    If (rbDensity) Then tbWeightingConstant.Enabled = True
    If (rbDensityFactor) Then tbDensityFactor.Enabled = True
    If (rbDensityFactor) Then tbWeightingConstant.Enabled = False
       
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp |fffd|g/cc"
    Else
        tbWeightingText = "dv/dlogdp |fffd|m^3/cc"
    End If
End Sub
' <<<<<<<<<<<<<<<<<<<<<<<<<<==================

'******************************************************************************************************************
' Return the AO controls for a given channel
Private Sub GetAoControls(ch_num As Integer, ByRef modesel As MSForms.ComboBox, _
        spin1 As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spin2 As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, txtbx3 As MSForms.TextBox, txtbx4 As MSForms.TextBox)
        
    If (ch_num = 1) Then
        Set modesel = ModeSelect1
        Set spin1 = SpinMode1
        Set txtbx1 = MinDp1
        Set Label1 = Label11
        Set spin2 = SpinParameter1
        Set txtbx2 = MaxDp1
        Set Label2 = Label12
        Set weighting = Weighting1
        Set txtbx3 = DensityFactor1
        Set txtbx4 = Power1
    ElseIf (ch_num = 2) Then
        Set modesel = ModeSelect2
        Set spin1 = SpinMode2
        Set txtbx1 = MinDp2
        Set Label1 = Label21
        Set spin2 = SpinParameter2
        Set txtbx2 = MaxDp2
        Set Label2 = Label22
        Set weighting = Weighting2
        Set txtbx3 = DensityFactor2
        Set txtbx4 = Power2
    ElseIf (ch_num = 3) Then
        Set modesel = ModeSelect3
        Set spin1 = SpinMode3
        Set txtbx1 = MinDp3
        Set Label1 = Label31
        Set spin2 = SpinParameter3
        Set txtbx2 = MaxDp3
        Set Label2 = Label32
        Set weighting = Weighting3
        Set txtbx3 = DensityFactor3
        Set txtbx4 = Power3
    ElseIf (ch_num = 4) Then
        Set modesel = ModeSelect4
        Set spin1 = SpinMode4
        Set txtbx1 = MinDp4
        Set Label1 = Label41
        Set spin2 = SpinParameter4
        Set txtbx2 = MaxDp4
        Set Label2 = Label42
        Set weighting = Weighting4
        Set txtbx3 = DensityFactor4
        Set txtbx4 = Power4
    End If
    
End Sub

'******************************************************************************************************************
' Event handlers for the spin button for the first text box
'******************************************************************************************************************
Private Sub SpinMode1_Change()
    Call SpinModeChange(1, m_Modenames)
End Sub
Private Sub SpinMode2_Change()
    Call SpinModeChange(2, m_Modenames)
End Sub
Private Sub SpinMode3_Change()
    Call SpinModeChange(3, m_Modenames)
End Sub
Private Sub SpinMode4_Change()
    Call SpinModeChange(4, m_Modenames)
End Sub
Private Sub SpinModeChange(ch_num As Integer, option_list() As String)
    
    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)

    If (modesel.ListCount = 0) Then Exit Sub
    
    Call TxtBxControl(txtbx1, False)
    txtbx1.Text = option_list(spinmode.Value)

    If (spinmode.Value = spinmode.max) Then 'c_COMBINED option
        spinpar.Value = eConcentration
        spinpar.Enabled = False
        Call SpinParameterChange(spinpar, txtbx2, m_ParameterOptions)
        
        Call UpdateWeightingOptions(weighting, c_NONE, m_DmdWeightingTxt)
        weighting.ListIndex = 0
        Call WeightingChange(ch_num)
    Else ' All mode selections except c_COMBINED
        spinpar.Enabled = True
        Dim idx As Integer
        idx = weighting.ListIndex
        Call UpdateWeightingOptions(weighting, c_NONE, c_CUSTOM, m_DmdWeightingTxt)
        weighting.ListIndex = idx
        Call WeightingChange(ch_num)
    End If
    
End Sub

'******************************************************************************************************************
' Event handlers for the spin button for the second text box
'******************************************************************************************************************
Private Sub SpinParameter1_Change()
    Call SpinParameterChange(SpinParameter1, MaxDp1, m_ParameterOptions)
End Sub
Private Sub SpinParameter2_Change()
    Call SpinParameterChange(SpinParameter2, MaxDp2, m_ParameterOptions)
End Sub
Private Sub SpinParameter3_Change()
    Call SpinParameterChange(SpinParameter3, MaxDp3, m_ParameterOptions)
End Sub
Private Sub SpinParameter4_Change()
    Call SpinParameterChange(SpinParameter4, MaxDp4, m_ParameterOptions)
End Sub
Private Sub SpinParameterChange(spin As MSForms.SpinButton, txtbx As MSForms.TextBox, option_list() As String)
    Call TxtBxControl(txtbx, False)
    txtbx.Text = option_list(spin.Value)
End Sub

'******************************************************************************************************************
' Event handlers for the SIZE/MODE combo dropdown
'******************************************************************************************************************
Private Sub ModeSelect1_Change()
    Call ModeSelectChange(1)
End Sub
Private Sub ModeSelect2_Change()
    Call ModeSelectChange(2)
End Sub
Private Sub ModeSelect3_Change()
    Call ModeSelectChange(3)
End Sub
Private Sub ModeSelect4_Change()
    Call ModeSelectChange(4)
End Sub
Private Sub ModeSelectChange(ch_num As Integer)

    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)

    If (modesel.ListCount = 0) Then Exit Sub
    
    If (modesel.ListIndex = eSize) Then
        spinmode.Value = 0
        spinmode.visible = False
        spinpar.visible = False
        spinpar.Value = 0
        Call TxtBxControl(txtbx1, True)
        txtbx1.Text = ""
        Label1 = "Min Dp"
        Call TxtBxControl(txtbx2, True)
        txtbx2.Text = ""
        Label2 = "Max Dp"
        Call UpdateWeightingOptions(weighting, c_NONE, c_CUSTOM)
        weighting.ListIndex = 0
        Call WeightingChange(ch_num)

    Else
        spinmode.visible = True
        spinmode.Enabled = True
        spinmode.min = 0
        spinmode.max = UBound(m_Modenames)
        spinmode.Value = 0
        spinpar.visible = True
        spinpar.Enabled = True
        spinpar.Value = 0
        spinpar.min = 0
        spinpar.max = 2
        txtbx1.Text = m_Modenames(spinmode.Value)
        Call TxtBxControl(txtbx1, False)
        txtbx2.Text = m_ParameterOptions(spinpar.Value)
        Call TxtBxControl(txtbx2, False)
        Label1 = "Mode select"
        Label2 = "Parameter"
        Call UpdateWeightingOptions(weighting, c_NONE, c_CUSTOM, m_DmdWeightingTxt)
        weighting.ListIndex = 0
        Call WeightingChange(ch_num)
    End If
End Sub
'******************************************************************************************************************
' Event handlers for the Weighting combo dropdown
'******************************************************************************************************************
Private Sub Weighting1_Change()
    Call WeightingChange(1)
End Sub
Private Sub Weighting2_Change()
    Call WeightingChange(2)
End Sub
Private Sub Weighting3_Change()
    Call WeightingChange(3)
End Sub
Private Sub Weighting4_Change()
    Call WeightingChange(4)
End Sub

Private Sub WeightingChange(ch_num As Integer)
    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)
    
    If (weighting.ListCount = 0) Then Exit Sub
    
    If (weighting.Text = c_NONE) Then
        Call TxtBxControl(denfac, False, False)
        Call TxtBxControl(power, False, False)
    ElseIf (weighting.Text = c_CUSTOM) Then
        Call TxtBxControl(denfac, True, True)
        Call TxtBxControl(power, True, True)
    Else
        If (spinmode.Value = spinmode.max) Then ' COMBINED option is active
            Call TxtBxControl(denfac, False, False)
            Call TxtBxControl(power, False, False)
        Else
            denfac = CStr(m_Densities(spinmode.Value)) ' Only available in "Mode"
            Call TxtBxControl(denfac, False, True)
            power = CStr(m_Indices(spinmode.Value))
            Call TxtBxControl(power, False, True)
        End If
    End If
End Sub
Private Sub UpdateWeightingOptions(weighting_combo As MSForms.ComboBox, opt1 As String, opt2 As String, Optional opt3 As String = "")
    weighting_combo.Clear
    weighting_combo.AddItem opt1
    weighting_combo.AddItem opt2
    If (opt3 <> "") Then weighting_combo.AddItem opt3
End Sub

'****************************************************************
' Initialise the dialog
'****************************************************************
Private Sub Userform_Initialize()
    OkWasPressed = False

    InversionMatrixSelection = ""
    'ReInvert.Enabled = False
    
    Globals.nffFlag = False
    Globals.cgrFlag = False

    Dim i As Integer
    For i = 0 To 21
        Globals.DMSCustomGainRange(i) = 2
    Next

    ResetGainRadios
    EnableGainRadios (False)

    Diagnostic.visible = False
    
    On Error Resume Next
    DllVersion.Caption = "DLL Version: 1"
    DllVersion.Caption = "DLL Version: " & CStr(VersionNumber())
           
    m_ParameterOptions(0) = "Concentration"
    m_ParameterOptions(1) = "CMD"
    m_ParameterOptions(2) = "GSD"
    
    EnableRingExclusion (False)

    'Call DisableAoControls(1)
    'Call DisableAoControls(2)
    'Call DisableAoControls(3)
    'Call DisableAoControls(4)
    
    GetModeInfoFromDmsFile

    Call EnableAoControls(1)
    Call EnableAoControls(2)
    Call EnableAoControls(3)
    Call EnableAoControls(4)
    
    Call InitialiseAoControls(1, eDmdFile)
    Call InitialiseAoControls(2, eDmdFile)
    Call InitialiseAoControls(3, eDmdFile)
    Call InitialiseAoControls(4, eDmdFile)
    
    If (ParseAoString(1, Cells(5, 1), eDmdFile) = False) Then
        Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
        Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
    End If
    
    If (ParseAoString(2, Cells(5, 2), eDmdFile) = False) Then
        Call MsgBox("Unable to correctly interpret AO channel 2 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
        Call ParseAoString(2, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
    End If
    
    If (ParseAoString(3, Cells(5, 3), eDmdFile) = False) Then
        Call MsgBox("Unable to correctly interpret AO channel 3 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
        Call ParseAoString(3, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
    End If
    
    If (ParseAoString(4, Cells(5, 4), eDmdFile) = False) Then
        Call MsgBox("Unable to correctly interpret AO channel 4 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
        Call ParseAoString(4, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
    End If

    ' Weighting
    NumberWeighting = True
    tbDensity.Text = ""
    DensityMultiplier = 1
    Call NumberWeighting_Click

    SelectInverstionMatrix.SetFocus
Problem:

End Sub

Private Sub DisableAoControls(ch_num As Integer)

    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)

    Call ComboControl(modesel, False)
    
    spinmode.Enabled = False
    Call TxtBxControl(txtbx1, False)
    
    spinpar.Enabled = False
    Call TxtBxControl(txtbx2, False)
    
    Call ComboControl(weighting, False)
     
    denfac = 1
    Call TxtBxControl(denfac, False)
    power = 0
    Call TxtBxControl(power, False)
End Sub

Private Sub EnableAoControls(ch_num As Integer)
    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)

    modesel.Clear
    modesel.AddItem c_SIZE
    modesel.AddItem c_MODE
    modesel.ListIndex = 0
    Call ComboControl(modesel, False, True)
  
    Call TxtBxControl(txtbx1, False)
       
    spinpar.min = 0
    spinpar.max = 2
    spinpar.Value = 0
    
    txtbx2.Text = m_ParameterOptions(spinpar.Value)
    Call TxtBxControl(txtbx2, False)
 
    weighting.Clear
    weighting.AddItem c_NONE
    weighting.AddItem c_CUSTOM
    Call ComboControl(weighting, False, True)
     
    Call TxtBxControl(denfac, False)
    denfac = 1
    Call TxtBxControl(power, False)
    power = 0
  
End Sub

Private Sub EnableRingExclusion(enable As Boolean)
    RingExclusion.Enabled = enable
    Ring1.Enabled = enable
    Ring2.Enabled = enable
    Ring3.Enabled = enable
    Ring4.Enabled = enable
    Ring5.Enabled = enable
    Ring6.Enabled = enable
    Ring7.Enabled = enable
    Ring8.Enabled = enable
    Ring9.Enabled = enable
    Ring10.Enabled = enable
    Ring11.Enabled = enable
    Ring12.Enabled = enable
    Ring13.Enabled = enable
    Ring14.Enabled = enable
    Ring15.Enabled = enable
    Ring16.Enabled = enable
    Ring17.Enabled = enable
    Ring18.Enabled = enable
    Ring19.Enabled = enable
    Ring20.Enabled = enable
    Ring21.Enabled = enable
    Ring22.Enabled = enable
    
    ApplyDilutionCorrection.Enabled = enable
    If (enable) Then ApplyDilutionCorrection = True
    
End Sub

Private Function ParseAoString(ch_num As Integer, ao_string As String, inv_file_type As EInvFileType) As Boolean

    On Error GoTo Problem
   
    Dim parameter_str As String, mode_select_str() As String, weighting_str() As String
    Dim error_str As String
       
    ' Split the AO string into the 3 main component string arrays
    Dim num_total_words As Integer
    'Dim total_words() As String
    'total_words() = Split(ao_string)
    Dim total_words_incl_spaces() As String
    total_words_incl_spaces() = Split(ao_string)
    
    ReDim total_words(LBound(total_words_incl_spaces) To UBound(total_words_incl_spaces))
    Dim i As Integer, j As Integer
    For i = LBound(total_words_incl_spaces) To UBound(total_words_incl_spaces)
        If total_words_incl_spaces(i) <> "" Then
            total_words(j) = total_words_incl_spaces(i)
            j = j + 1
        End If
    Next i
    ReDim Preserve total_words(LBound(total_words_incl_spaces) To j)
    
    num_total_words = UBound(total_words) + 1
    
    If (num_total_words < 6 Or num_total_words > 14) Then
        error_str = "Incorrect number of words in the analog output string"
        GoTo Problem
    End If
        
    parameter_str = total_words(0)
    
    Dim item_idx As Integer, item_found As Boolean
    item_found = False
    For item_idx = 0 To num_total_words
        If (total_words(item_idx) = "weighted") Then
            item_found = True
            Exit For
        End If
    Next item_idx
    
    If (item_found = False) Then
        error_str = "No weighting text found in analog output string"
        GoTo Problem
    End If
    
    Dim num_weighting_words As Integer, idx As Integer
    num_weighting_words = num_total_words - item_idx
    ReDim weighting_str(num_weighting_words - 1)
    For idx = 0 To num_weighting_words - 1
        weighting_str(idx) = total_words(item_idx + idx)
    Next idx
    
    Dim num_mode_select_words As Integer
    num_mode_select_words = num_total_words - num_weighting_words - 1
    ReDim mode_select_str(num_mode_select_words - 1)
    For idx = 0 To num_mode_select_words - 1
        mode_select_str(idx) = total_words(1 + idx)
    Next idx
            
    ' Try to set the mode and parameter text boxes accordingly
    If (ParseMinMaxDp(ch_num, mode_select_str, parameter_str, inv_file_type) = False) Then GoTo Problem
    If (ParseWeighting(ch_num, weighting_str) = False) Then GoTo Problem
   
    ParseAoString = True
           
    Exit Function
    
Problem:
    'MsgBox (error_str & ": " & ao_string)
    
    ParseAoString = False

End Function

Private Function ParseMinMaxDp(ch_num As Integer, mode_str() As String, par As String, inv_file_type As EInvFileType) As Boolean
    
    On Error GoTo Problem
    ParseMinMaxDp = True
    
    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)
    
    If (UBound(mode_str) = 2) Then ' There are 3 items in the mode string array
        modesel.ListIndex = eSize
        txtbx1 = CStr(Replace(mode_str(0), "nm", ""))
        txtbx2 = CStr(Replace(mode_str(2), "nm", ""))
    ElseIf (inv_file_type = eDmxFile) Then
        modesel.ListIndex = eSize
        txtbx1.Text = ""
        txtbx2.Text = ""
    Else ' eDmdFile
        modesel.ListIndex = eMode
        Dim i As Integer, idx_found As Integer, item_found As Boolean
        item_found = False
        idx_found = 0
        For i = 0 To m_NumModes ' Includes COMBINED
            If (m_Modenames(i) = CapitaliseFirstLetter(mode_str(0))) Then
                item_found = True
                idx_found = i
            End If
        Next i
        If (item_found = True) Then
            txtbx1.Text = CapitaliseFirstLetter(mode_str(0))
            spinmode.Value = idx_found
        Else
            txtbx1.Text = m_Modenames(0)
            spinmode.Value = 0
        End If
        txtbx2.Text = par
   End If
   Exit Function
   
Problem:
    ParseMinMaxDp = False
End Function

Private Function ParseWeighting(ch_num As Integer, weighting_str() As String) As Boolean
    
    On Error GoTo Problem
    ParseWeighting = True
    
    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)
    
    Dim wt_type As EAoWtType
    Dim df As Single, p As Single
    Dim combined_mode As Boolean
    If (spinmode.Value = spinmode.max) Then combined_mode = True Else combined_mode = False
    
    If (weighting_str(2) = "number") Then
        wt_type = eNone
        df = 1
        p = 0
    ElseIf (weighting_str(2) = "density") Then
        wt_type = eCustom
        If (Not IsNumeric(weighting_str(4))) Then
            Call MsgBox("Incorrect format for AO " & CStr(ch_num) & " in the DMS file", vbCritical)
            Exit Function
        End If
        df = CSng(weighting_str(4))
        p = CSng(weighting_str(9))
    Else ' Only allow the "other" weighting if it also exists in the DMD file
        Dim weighting_text As String
        weighting_text = weighting_str(2)
        If (weighting_text Like m_DmdWeightingTxt) Then wt_type = eDMD: df = 0: p = 0 Else wt_type = eNone: df = 1: p = 0
    End If
        
    If (combined_mode = False Or wt_type = eNone) Then
        weighting.ListIndex = wt_type
    Else
        weighting.ListIndex = weighting.ListCount - 1
    End If
        
    If (wt_type = eNone Or combined_mode = True) Then
        Call TxtBxControl(denfac, False, False)
        Call TxtBxControl(power, False, False)
    ElseIf (wt_type = eCustom) Then
        denfac = CStr(df)
        Call TxtBxControl(denfac, True)
        power = CStr(p)
        Call TxtBxControl(power, True)
    ElseIf (wt_type = eDMD) Then
        Call TxtBxControl(denfac, False, True)
        Call TxtBxControl(power, False, True)
    End If
    Exit Function
    
Problem:
    ParseWeighting = False
End Function

Private Function CapitaliseFirstLetter(str As String) As String
    If (Len(str) >= 1) Then
        CapitaliseFirstLetter = UCase(Left$(str, 1)) & LCase(Right$(str, Len(str) - 1))
    Else
        CapitaliseFirstLetter = ""
    End If
End Function

'****************************************************************
' The user has hit the OK button...
'****************************************************************
Private Sub ReInvert_Click()
    
    If (IsNumeric(tbDensity) And rbDensity) Then
        DensityMultiplier = CStr(tbDensity * 1000000000# / (1000000# ^ WeightingPower))
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        DensityMultiplier = CStr(tbDensityFactor) * 1000# ^ CStr(WeightingPower)
    Else
        DensityMultiplier = 1
    End If
    
    Dim error_str As String
    
    'If (InversionMatrixSelection = "") Then error_str = "You must specify a DMX file before reinverting": GoTo Problem
    If (CheckAoControl(1) = False) Then error_str = "AO channel 1 has incomplete specification": GoTo Problem
    If (CheckAoControl(2) = False) Then error_str = "AO channel 2 has incomplete specification": GoTo Problem
    If (CheckAoControl(3) = False) Then error_str = "AO channel 3 has incomplete specification": GoTo Problem
    If (CheckAoControl(4) = False) Then error_str = "AO channel 4 has incomplete specification": GoTo Problem
       
    Set ExclusionArray = New Collection
    
    ExclusionArray.Add (Ring1.Value)
    ExclusionArray.Add (Ring2.Value)
    ExclusionArray.Add (Ring3.Value)
    ExclusionArray.Add (Ring4.Value)
    ExclusionArray.Add (Ring5.Value)
    ExclusionArray.Add (Ring6.Value)
    ExclusionArray.Add (Ring7.Value)
    ExclusionArray.Add (Ring8.Value)
    ExclusionArray.Add (Ring9.Value)
    ExclusionArray.Add (Ring10.Value)
    ExclusionArray.Add (Ring11.Value)
    ExclusionArray.Add (Ring12.Value)
    ExclusionArray.Add (Ring13.Value)
    ExclusionArray.Add (Ring14.Value)
    ExclusionArray.Add (Ring15.Value)
    ExclusionArray.Add (Ring16.Value)
    ExclusionArray.Add (Ring17.Value)
    ExclusionArray.Add (Ring18.Value)
    ExclusionArray.Add (Ring19.Value)
    ExclusionArray.Add (Ring20.Value)
    ExclusionArray.Add (Ring21.Value)
    ExclusionArray.Add (Ring22.Value)

    ' Copy AO string to the relevant cells
    'Cells(5, 1) = CreateAoString(1)
    'Cells(5, 2) = CreateAoString(2)
    'Cells(5, 3) = CreateAoString(3)
    'Cells(5, 4) = CreateAoString(4)
    
    ' Copy AO string to the AO header
    'Cells(6, 7) = Cells(5, 1)
    'Cells(6, 8) = Cells(5, 2)
    'Cells(6, 9) = Cells(5, 3)
    'Cells(6, 10) = Cells(5, 4)
    
    'Cells(1, 4) = CreateJonnyMessageString()
    
    OkWasPressed = True
    Me.Hide
    DoEvents
    Exit Sub
    
Problem:
    Call MsgBox(error_str, vbExclamation)
    OkWasPressed = False
   
End Sub

Private Function CheckAoControl(ch_num As Integer) As Boolean

    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)

    If (modesel.Text = "") Then CheckAoControl = False: Exit Function
    If (txtbx1.Text = "") Then CheckAoControl = False: Exit Function
    If (txtbx2.Text = "") Then CheckAoControl = False: Exit Function
    If (weighting.Text = "") Then CheckAoControl = False: Exit Function
    
    If (weighting.Text <> c_NONE And txtbx1.Text <> c_COMBINED) Then
        If (Not IsNumeric(denfac.Text)) Then CheckAoControl = False: Exit Function
        If (Not IsNumeric(power.Text)) Then CheckAoControl = False: Exit Function
    End If
    
    CheckAoControl = True
End Function

Public Function CreateAoString(ch_num As Integer) As String
    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)

    Dim ao_string As String
    
    If (modesel.ListIndex = eSize) Then
        ao_string = "Concentration " & txtbx1 & "nm to " & txtbx2 & "nm"
        If (weighting.Text = c_NONE) Then
            ao_string = ao_string + " weighted by number (n/cc)"
        ElseIf (weighting.Text = c_CUSTOM) Then
            ao_string = ao_string + " weighted by density factor " & denfac & " & Dp to the " & power
        End If
    Else
        ao_string = txtbx2 & " " & LCase$(txtbx1)
        If (txtbx1.Text = c_COMBINED) Then ao_string = ao_string & " weighted by " Else ao_string = ao_string & " mode weighted by "

        If (weighting.Text = c_NONE) Then
            ao_string = ao_string & "number (n/cc)"
        ElseIf (weighting.Text = c_CUSTOM) Then
            ao_string = ao_string & "density factor " & CStr(denfac) & " & Dp to the " & CStr(power)
        Else
            ao_string = ao_string & LCase$(m_DmdWeightingTxt) & " " & m_DmdWeightingUnits
        End If
    End If
    
    CreateAoString = ao_string

End Function

Public Function CreateWeightingMessageString() As String
    If (IsNumeric(tbDensity) And rbDensity) Then
        tbWeightingText = "dMdlogDp ug/cc"
        DensityMultiplier = CStr(tbDensity * 1000000000# / (1000000# ^ WeightingPower))
    ElseIf (IsNumeric(tbDensityFactor) And rbDensityFactor) Then
        tbWeightingText = "dMdlogDp ug/cc"
        DensityMultiplier = CStr(tbDensityFactor) * 1000# ^ CStr(WeightingPower)
        tbWeightingConstant = 1
    Else
        DensityMultiplier = 1
        ' Restore whatever the previous text was
        If (WeightingType = eNumber) Then
            Call NumberWeighting_Click
        ElseIf (WeightingType = eLength) Then
            Call LengthWeighting_Click
        ElseIf (WeightingType = eArea) Then
            Call AreaWeighting_Click
        ElseIf (WeightingType = eVolume) Then
            Call VolumeWeighting_Click
        End If
    End If

    Dim wm_string As String
    wm_string = "Spectrum weighted by "
    
    If (NumberWeighting) Then ' Don|fffd|t write anything in cell D1 if the weighting is set to Number (0)
        'wm_string = jm_string + "number:"
        CreateWeightingMessageString = ""
        Exit Function
    ElseIf (LengthWeighting) Then
        wm_string = wm_string + "length:"
    ElseIf (AreaWeighting) Then
        wm_string = wm_string + "area:"
    ElseIf (VolumeWeighting) Then
        If (rbDensity And IsNumeric(tbDensity)) Then
            wm_string = wm_string + "mass:"
        ElseIf (rbDensityFactor And IsNumeric(tbDensityFactor)) Then
            wm_string = wm_string + "mass:"
        Else
            wm_string = wm_string + "volume:"
        End If
    End If
    
    If (Len(WeightingPower) = 0) Then
        wm_string = wm_string + " Power=0,"
    Else
        wm_string = wm_string + " Power=" + CStr(WeightingPower) + ","
    End If
    
    If (rbDensityFactor = False) Then
        If (Len(tbWeightingConstant) = 0) Then
            wm_string = wm_string + " Shape factor=0,"
        Else
            wm_string = wm_string + " Shape factor=" + CStr(tbWeightingConstant) + ","
        End If
    End If
    
    If (rbDensity) Then
        If (Len(tbDensity) = 0) Then
            wm_string = wm_string + " Density=0,"
        Else
            wm_string = wm_string + " Density=" + CStr(tbDensity) + ","
        End If
    ElseIf (rbDensityFactor) Then
        If (Len(tbDensityFactor) = 0) Then
            wm_string = wm_string + " Density factor=0,"
        Else
            wm_string = wm_string + " Density factor=" + CStr(tbDensityFactor) + ","
        End If
    
    End If
     
    wm_string = wm_string + " Units=" + tbWeightingText
        
    CreateWeightingMessageString = wm_string

End Function

Private Sub SelectInverstionMatrix_Click()
    
    Dim fn As Variant
    fn = Globals.GetSomeFileName("DMD Files (*.dmd), *.dmd, DMX Files (*.dmx), *.dmx")
    If (IsEmpty(fn)) Then Exit Sub

    InversionMatrixSelection = fn(1) 'CStr(temp(1))
    'InversionMatrixSelection = Globals.GetSingleFileName("DMX files,*.dmx", "DMD files,*.dmd")
    
    ' if dilution correction is turned on in DMS file turn it on by default here
    If (InStr(ActiveSheet.Range("e5"), "enabled") > 0) Then
        ApplyDilutionCorrection = True
    Else
        ApplyDilutionCorrection = False
    End If
    
    If (Right(InversionMatrixSelection, 3) Like "dmd") Then
        If (GetModeInfoFromDmdFile(InversionMatrixSelection) = False) Then GoTo Problem
    End If

    Call EnableAoControls(1)
    Call EnableAoControls(2)
    Call EnableAoControls(3)
    Call EnableAoControls(4)
    
    'Dim par As String, mode() As String, weight() As String
    If (Right(InversionMatrixSelection, 3) Like "dmx") Then
        
        EnableGainRadios (False)
        
        Call InitialiseAoControls(1, eDmxFile)
        Call InitialiseAoControls(2, eDmxFile)
        Call InitialiseAoControls(3, eDmxFile)
        Call InitialiseAoControls(4, eDmxFile)
        
        'If (ParseAoString(1, Cells(5, 1), eDmxFile) = False) Then GoTo Problem
        If (ParseAoString(1, Cells(5, 1), eDmxFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmxFile)
        End If
        'If (ParseAoString(2, Cells(5, 2), eDmxFile) = False) Then GoTo Problem
        If (ParseAoString(2, Cells(5, 2), eDmxFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmxFile)
        End If
        'If (ParseAoString(3, Cells(5, 3), eDmxFile) = False) Then GoTo Problem
        If (ParseAoString(3, Cells(5, 3), eDmxFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmxFile)
        End If
        'If (ParseAoString(4, Cells(5, 4), eDmxFile) = False) Then GoTo Problem
        If (ParseAoString(4, Cells(5, 4), eDmxFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmxFile)
        End If
      
        
    Else ' Log normal inversion options
                
        EnableGainRadios (True)
                
        Call InitialiseAoControls(1, eDmdFile)
        Call InitialiseAoControls(2, eDmdFile)
        Call InitialiseAoControls(3, eDmdFile)
        Call InitialiseAoControls(4, eDmdFile)
        
        'If (ParseAoString(1, Cells(5, 1), eDmdFile) = False) Then GoTo Problem
        If (ParseAoString(1, Cells(5, 1), eDmdFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
        End If
        'If (ParseAoString(2, Cells(5, 2), eDmdFile) = False) Then GoTo Problem
        If (ParseAoString(2, Cells(5, 2), eDmdFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
        End If
        'If (ParseAoString(3, Cells(5, 3), eDmdFile) = False) Then GoTo Problem
        If (ParseAoString(3, Cells(5, 3), eDmdFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
        End If
        'If (ParseAoString(4, Cells(5, 4), eDmdFile) = False) Then GoTo Problem
        If (ParseAoString(4, Cells(5, 4), eDmdFile) = False) Then
            'Call MsgBox("Unable to correctly interpret AO channel 1 text: setting to default", vbOKOnly + vbCritical, "AO channel text error")
            Call ParseAoString(1, "Concentration 5.00nm to 1000.00nm weighted by number (n/cc)", eDmdFile)
        End If
    End If
    
    'ReInvert.Enabled = True
    EnableRingExclusion (True)

    Exit Sub

Problem:
    Unload Me
    Call MsgBox("ReInversion terminated prematurely!", vbExclamation, Globals.AddInName)
    Exit Sub
   
End Sub

Private Sub InitialiseAoControls(ch_num As Integer, inv_file_type As EInvFileType)

    Dim modesel As MSForms.ComboBox, _
        spinmode As MSForms.SpinButton, txtbx1 As MSForms.TextBox, Label1 As MSForms.Label, _
        spinpar As MSForms.SpinButton, txtbx2 As MSForms.TextBox, Label2 As MSForms.Label, _
        weighting As MSForms.ComboBox, denfac As MSForms.TextBox, power As MSForms.TextBox

    Call GetAoControls(ch_num, modesel, spinmode, txtbx1, Label1, spinpar, txtbx2, Label2, weighting, denfac, power)
    
    If (inv_file_type = eDmxFile) Then
        Call ComboControl(modesel, False, True)
        
        spinmode.visible = False
        Call TxtBxControl(txtbx1, True)
        Label1 = "Min Dp"
        
        spinpar.visible = False
        Call TxtBxControl(txtbx2, True)
        Label2 = "Max Dp"
        
        weighting.Clear
        weighting.AddItem "None"
        weighting.AddItem "Custom"
        Call ComboControl(weighting, True, True)
        
        Call TxtBxControl(denfac, True)
        Call TxtBxControl(power, True)

    Else ' DMD file or no file type
        
        spinmode.min = 0
        spinmode.max = UBound(m_Modenames)
        
        Call ComboControl(modesel, True, True)
        Call ComboControl(weighting, True, True)
        Call ModeSelectChange(ch_num)
        Call WeightingChange(ch_num)
        
    End If
End Sub

Public Sub DoModal()

    If (Globals.AutomatedTest = False) Then
        Me.Show
    Else
        Load Me
        InversionMatrixSelection = Test.InversionMatrixSelection

        Call ReInvert_Click
    End If

End Sub

Private Sub TxtBxControl(txtbx As MSForms.TextBox, enable As Boolean, Optional visible As Boolean = True)
    txtbx.Enabled = True ' enable
    txtbx.visible = visible
    If (enable = True) Then txtbx.BackColor = &H80000005 Else txtbx.BackColor = &H8000000F
End Sub
Private Sub ComboControl(combo As MSForms.ComboBox, enable As Boolean, Optional visible As Boolean = True) ', Optional list_idx As Integer = 0)
    combo.Enabled = enable
    combo.visible = visible
    If (enable = True) Then combo.BackColor = &H80000005 Else combo.BackColor = &H8000000F
End Sub

'****************************************************************
' Look inside the DMD file and identify some important parameters
'****************************************************************
Private Function GetModeInfoFromDmdFile(dmd_file As String) As Boolean
                   
    'Open Matrix File as a spread sheet and place after data
    Workbooks.OpenText filename:=dmd_file, startrow:=1, datatype:=xlDelimited, Tab:=True, _
        DecimalSeparator:=".", ThousandsSeparator:=","
    
    If (Range("B1") <> "v3.0") Then
        ActiveWorkbook.Close SaveChanges:=False
        Call MsgBox("DMD file is not version 3.0", vbOKOnly)
        GetModeInfoFromDmdFile = False
        Exit Function
    End If
    
    m_NumModes = Range("C1").Value
    m_DmdWeightingTxt = Range("I1").Value
    Dim i As Integer
    i = InStr(m_DmdWeightingTxt, "/")
    If (i > 0) Then
        m_DmdWeightingUnits = "(" & Right$(m_DmdWeightingTxt, Len(m_DmdWeightingTxt) - i) & ")"
        m_DmdWeightingTxt = Left$(m_DmdWeightingTxt, i - 1)
    End If
    
    ReDim m_Densities(m_NumModes - 1) As Double
    ReDim m_Indices(m_NumModes - 1) As Double
    ReDim m_Modenames(m_NumModes) As String
    
    ' get info specific to each aerosol mode for weighting from DMD file
    For i = 0 To (m_NumModes - 1)
        m_Densities(i) = ActiveSheet.Cells(3 + i, 13)
        m_Indices(i) = ActiveSheet.Cells(3 + i, 14)
        m_Modenames(i) = ActiveSheet.Cells(3 + i, 15)
    Next
    
    m_Modenames(i) = c_COMBINED
    
    Application.DisplayAlerts = False
    ActiveWorkbook.Close SaveChanges:=False
    Application.DisplayAlerts = True
    
    GetModeInfoFromDmdFile = True

End Function

Private Function GetModeInfoFromDmsFile() As Boolean
                   
    Dim file_spec As CFileSpec
    Set file_spec = New CFileSpec
    Call file_spec.ConfigureDataSource(DmsFile, ESourceDataType.ParticleSizeData)

    m_NumModes = file_spec.NumModes
    m_DmdWeightingTxt = "Mass"
    m_DmdWeightingUnits = ""
    
    ReDim m_Densities(m_NumModes - 1) As Double
    ReDim m_Indices(m_NumModes - 1) As Double
    ReDim m_Modenames(m_NumModes) As String
    
    ' Get info specific to each aerosol mode for weighting
    Dim i As Integer
    For i = 0 To (m_NumModes - 1)
        m_Densities(i) = Cells(4, 16 + i * 2)
        m_Indices(i) = Cells(4, 17 + i * 2)
        m_Modenames(i) = GetModeNameFromModeString(Cells(6, 13 + i * 3))
    Next
    
    m_Modenames(i) = c_COMBINED
        
    GetModeInfoFromDmsFile = True
End Function

'****************************************************************
' Get noise from a DMS or DME file
'****************************************************************
Private Function GetNoise(noisefilename As String) As Boolean

    'Dim noisefilename As String
    Dim i As Integer
    Dim ringspec As Range
    Dim startcol As Integer
    Dim startrow As Integer
    Dim endrow As Integer
    Dim nf As Workbook
    Dim RealTime As Boolean
    Dim timestring, ms1, ts1 As String
    Dim timestring2, ms2, ts2 As String
    Dim colon As String
    colon = ":"    ' Application.International(xlTimeSeparator)
    CalcNoise.NoiseOK = False
    CalcNoise.NoiseCancelled = False

    ' open special status window
    CalcNoise.Statusbar.Caption = "Opening File..."
    CalcNoise.OKbutton.Enabled = False
    CalcNoise.Noisedisp.Clear

    CalcNoise.Show vbModeless
    DoEvents

    ' open noise file
    Set nf = Workbooks.Open(filename:=noisefilename, Format:=1)
    If Err Then
        MsgBox ("Cannot open DMS/DME file")
        Err = 0
        GetNoise = False
        CalcNoise.Hide
        Exit Function
    End If

    ' get samplerate of noise file if a DMS file (DME file always 10 Hz)
    nf.Sheets(1).Activate
    If (Right$(noisefilename, 3) Like "dms") Then

        If ActiveSheet.Range("a7").NumberFormat = "General" Then
            timestring = ActiveSheet.Range("A7").Value
            If InStr(timestring, colon) Then RealTime = True
        Else
            If InStr(ActiveSheet.Range("a7").NumberFormat, colon) Then RealTime = True
        End If

        Dim samplerate As Double
        If RealTime Then
            If InStr(ActiveSheet.Range("a7").NumberFormat, colon) Then
                samplerate = CLng((CDbl(ActiveSheet.Range("a8").Value - CDbl(ActiveSheet.Range("a7"))) / (1 / 864000)))
            Else
                timestring2 = ActiveSheet.Range("a8").Value
                If Left(Right(timestring, 2), 1) <> "." Then
                    samplerate = CLng((CDbl(TimeValue(timestring2)) - CDbl(TimeValue(timestring))) / (1 / 864000))

                Else
                    ms1 = Right(timestring, 1)
                    ms2 = Right(timestring2, 1)
                    ts1 = Left(timestring, Len(timestring) - 2)
                    ts2 = Left(timestring2, Len(timestring2) - 2)
                    samplerate = CLng((CDbl(TimeValue(ts2)) + CDbl(ms2) - CDbl(TimeValue(ts1)) - CDbl(ms1)) / (1 / 864000))
                End If
            End If
        Else
            samplerate = CLng(((ActiveSheet.Range("A8").Value) - (ActiveSheet.Range("A7").Value)) * 10)
        End If

        ' if samplerate <> 10 Hz then give error
        If samplerate <> 1 Then
            nf.Close SaveChanges:=False
            Dim dummy As VbMsgBoxResult
            dummy = MsgBox("DMS Noise file was not sampled at 10 Hz", vbOKOnly, "Cambustion DMS LN Fit")
            GetNoise = False
            CalcNoise.Hide
            Exit Function
        End If
    End If

    Set ringspec = ActiveSheet.Range("A1:DD8").Find("Ring 1")
    startcol = ringspec.Column
    startrow = ringspec.row + 1
    endrow = nf.Sheets(1).UsedRange.Rows.Count
    CalcNoise.Statusbar.Caption = "Calculating..."

    ' loop over the rings
    For i = 0 To 21
        DoEvents
        If CalcNoise.NoiseCancelled Then
            GetNoise = False
            nf.Close SaveChanges:=False
            CalcNoise.Hide
            Exit Function
        End If
        ' caluclate ring noise from file (standard deviation)
        Globals.DMSNoise(i) = Application.WorksheetFunction.StDev(nf.Sheets(1).Range(Cells(startrow, startcol + i), Cells(endrow, startcol + i)))
        ' display noise in status window
        CalcNoise.Noisedisp.AddItem ("Ring " & i + 1 & ": " & Globals.DMSNoise(i))
    Next

    DoEvents
    nf.Close SaveChanges:=False
    CalcNoise.Statusbar.Caption = "Done"
    CalcNoise.OKbutton.Enabled = True

    Do
        DoEvents
    Loop Until (CalcNoise.NoiseOK Or CalcNoise.NoiseCancelled)

    CalcNoise.Hide
    GetNoise = CalcNoise.NoiseOK

End Function

'******************************************************************************************************************
' Make sure wholesale gain range radio buttons agree with custom gain range radio buttons - if all custom are set to one range, set main dialogue gain range to that range, if not set to custom
'******************************************************************************************************************
Private Sub ResetGainRadios()

    Dim highset As Boolean
    Dim medset As Boolean
    Dim lowset As Boolean
    Dim i As Integer

    If Globals.nffFlag Then
        NoiseFromFile = True
        Exit Sub
    End If

    Select Case Globals.DMSCustomGainRange(0)
    Case 2
        highset = True
    Case 1
        medset = True
    Case 0
        lowset = True
    End Select

    For i = 1 To 21
        If Not (lowset And (Globals.DMSCustomGainRange(i) = 0)) Then lowset = False
        If Not (medset And (Globals.DMSCustomGainRange(i) = 1)) Then medset = False
        If Not (highset And (Globals.DMSCustomGainRange(i) = 2)) Then highset = False
    Next

    If lowset Then LowGainset = True
    If medset Then MediumGainset = True
    If highset Then HighGainset = True
    If Not (lowset Or medset Or highset) Then
        CustomGainset = True
        Globals.cgrFlag = True
    End If

End Sub

'******************************************************************************************************************
' GAIN SELECTION OPTIONS
'******************************************************************************************************************
Private Sub EnableGainRadios(enable As Boolean)
        LowGainset.Enabled = enable
        MediumGainset.Enabled = enable
        HighGainset.Enabled = enable
        CustomGainset.Enabled = enable
        NoiseFromFile.Enabled = enable
End Sub

Private Sub CustomGainSet_Click()
    If Globals.cgrFlag Then Exit Sub
    CustomGainRange.drawcustomgainrange    ' populate window
    CustomGainRange.Show
    ResetGainRadios    ' update main dialogue radio buttons
End Sub

Private Sub Highgainset_Click()
    Dim i As Integer
    For i = 0 To 21
        Globals.DMSCustomGainRange(i) = 2
    Next
    Globals.nffFlag = False
    Globals.cgrFlag = False
End Sub

Private Sub Lowgainset_Click()
    Dim i As Integer
    For i = 0 To 21
        Globals.DMSCustomGainRange(i) = 0
    Next
    Globals.nffFlag = False
    Globals.cgrFlag = False
End Sub

Private Sub Mediumgainset_Click()
    Dim i As Integer
    For i = 0 To 21
        Globals.DMSCustomGainRange(i) = 1
    Next
    Globals.nffFlag = False
    Globals.cgrFlag = False
End Sub

Private Sub Noisefromfile_Click()

    If Globals.nffFlag Then Exit Sub
    
    Dim status As Boolean
    Dim temp As Variant
    temp = Globals.GetSomeFileName("DMS Files (10 Hz sample rate only) (*.dms), *.dms, DME Files (*.dme), *.dme")
    If (Not IsEmpty(temp)) Then
        Dim noisefilename As String
        noisefilename = CStr(temp(1))
    
        Me.Hide
        status = GetNoise(noisefilename)
        Me.Show
    Else
        status = False
    End If
    
    NoiseFromFile.Value = status
    Globals.nffFlag = status
    If status Then Globals.cgrFlag = False
    ResetGainRadios
    
End Sub

Private Function GetModeNameFromModeString(mode_string As String) As String
    Dim split_array() As String
    split_array = Split(mode_string)
    GetModeNameFromModeString = split_array(0)
End Function
Attribute VB_Name = "Main"
Option Explicit ' Generate errors if declarations are not explicit


'****************************************************************
' This function is invoked when the user hits the "Summary" button
' It inserts a summary worksheet into the user's workbook and
' links the controls on the sheet to the users DMS data
'****************************************************************
Public Sub DmsHelp()
    
    On Error GoTo Problem
    Dim filepath As String
    Dim retval As Double
    filepath = Globals.InstallationDirectory & "hh.exe " & Globals.InstallationDirectory & "DmsHelp.chm"
    retval = Shell(filepath, vbMaximizedFocus)
    Exit Sub
    
Problem:
    If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = True
    Call MsgBox("Unable to carry out this function", vbExclamation, Globals.AddInName)
End Sub

'****************************************************************
' This function is invoked when the user hits the "Contour" button
' It processes the DMS data on the current Excel sheet and constructs
' a contour chart with a legend from it.
'****************************************************************
Public Sub ContourPlotEntry()

    On Error GoTo Problem
    
    If (Globals.WorksheetOK() = False) Then Exit Sub
    If (Globals.DmsVersionOK() = False) Then Exit Sub

    ' This is the main dialog control form for the contour plot
    Dim dms_control_form As DmsChartControl
    Set dms_control_form = New DmsChartControl
    
    Dim data_file As CFileSpec
    Set data_file = New CFileSpec
    Call data_file.ConfigureDataSource(ESourceFileType.DmsFile, ESourceDataType.ParticleSizeData)
    If data_file.IsAlreadyWeighted Then
        Call dms_control_form.Initialise(data_file.MinTime, data_file.MaxTime, data_file.RealTime, data_file.GetWeightingMessage)
    Else
        Call dms_control_form.Initialise(data_file.MinTime, data_file.MaxTime, data_file.RealTime, "")
    End If
    dms_control_form.DoModal
        
    If dms_control_form.OkWasPressed Then   ' Don't do anything unless the user hit the OK button
        
        If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = False  ' Don't update the screen until the entire operation is complete
        Call Globals.SetTemporarySheets("Cont")
        
        Dim chart As CDmsChart              ' Make a CDmsChart object that will generate the Excel chart
        Set chart = New CDmsChart
            
        If (data_file.IsAlreadyWeighted) Then
            Call data_file.CalculateWeighting(1, 0, 0, dms_control_form.tbWeightingText) ' Don't do any further weighting
        Else
            Call data_file.CalculateWeighting(dms_control_form.tbWeightingConstant, dms_control_form.WeightingPower, _
                dms_control_form.DensityMultiplier, dms_control_form.tbWeightingText) ' Weighting parameters
        End If
        
        Call chart.SetTimeRange(dms_control_form.LowerTime.Value, dms_control_form.UpperTime.Value) ' Time window limits
        Call chart.SetLogCSDRange(dms_control_form.LowerCSD.Value, dms_control_form.UpperCSD.Value) ' Concentration spectral density limits
        Call chart.SetAnalogSignalNumber(dms_control_form.m_AnalogSignalNumber) ' Which analog signal do we want superimposed on the chart
        Call chart.SetFileSpec(data_file) ' Enable the chart to know about the structure of the data file
        Call chart.BitmapChart ' Processes the DMS data and construct the chart with a legend
        
        Call Globals.ResetTemporarySheets
        
    End If
    Exit Sub
    
Problem:
    Call Globals.ResetTemporarySheets
    Call MsgBox("Unable to carry out this function", vbExclamation, Globals.AddInName)
End Sub

'****************************************************************
' This function is invoked when the user hits the "Animation" button
' It inserts an animation worksheet into the user's workbook and
' links the controls on the animation sheet to the users DMS data
'****************************************************************
Public Sub AnimationEntry()
    
    If (Globals.WorksheetOK() = False) Then Exit Sub
    
    On Error GoTo Problem
    If (Globals.IsDmeFile() = True) Then
        Dim answer As VbMsgBoxResult
        answer = MsgBox("DME file detected. Proceed with ring current animation?", vbYesNo, Globals.AddInName)
        If (answer = vbNo) Then Exit Sub
                        
        Call Globals.SetTemporarySheets("Anim")
        
        Call Animation.CreateDmeAnimationSheet
        
        Call Globals.ResetTemporarySheets
        Exit Sub
    End If
    
    If (Globals.DmsVersionOK() = False) Then Exit Sub

    Dim animation_control_form As AnimationControl
    Set animation_control_form = New AnimationControl
    animation_control_form.DoModal

    If animation_control_form.OkWasPressed Then   ' Don't do anything unless the user hit the OK button
        Call Globals.SetTemporarySheets("Anim")
        
        If (animation_control_form.ParticleSize = True) Then
            Call Animation.CreateParticleAnimationSheet
        ElseIf (animation_control_form.RingCurrent = True) Then
            Call Animation.CreateRingAnimationSheet
        End If
        
        Call Globals.ResetTemporarySheets
        If (animation_control_form.ParticleSize = True) Then
        ' update scrollbar
        
        'Clean up if data isn't full up, from v7.23
    
        If (Range("K27") = " ") Then
        ActiveSheet.ChartObjects("SyncChart").Activate
        ActiveChart.SeriesCollection(1).Delete 'remove "Karaoke lines" if less than one screenful
        ActiveChart.SeriesCollection(1).Delete
        ActiveChart.SeriesCollection(1).Delete
        ActiveChart.SeriesCollection(1).Delete
        Range("A1").Activate
        ActiveSheet.OLEObjects("CommandButton1").Delete ' remove animation tools
        ActiveSheet.OLEObjects("CommandButton2").Delete
        ActiveSheet.OLEObjects("CommandButton3").Delete
        ActiveSheet.OLEObjects("CommandButton4").Delete
        ActiveSheet.OLEObjects("CommandButton5").Delete
        ActiveSheet.OLEObjects("ScrollBar1").Delete
        ActiveSheet.OLEObjects("SpinButton1").Delete
        
        If (Globals.ExcelVersion >= 12) Then
        ActiveSheet.Spinners("Spinner 1").Delete ' please don't ask me why this is necessary, bug in Excel which changes the names of objects in 2003?
        Else
        ActiveSheet.Spinners("Spinner 2").Delete
        End If
    
        ActiveSheet.ChartObjects("Chart3D").Activate
        ActiveChart.Shapes("Text Box 6").Delete
        ActiveChart.Shapes("Text Box 9").Delete
        ActiveChart.Shapes("Text Box 6").Delete
        ActiveChart.Shapes("Text Box 9").Delete
        Else
        
        ActiveSheet.ScrollBar1.max = Range("B15").Value
        Range("B1").Value = Range("B2").Value
        
        End If
        Range("A1").Activate
        
        End If
        
    End If
    
    Exit Sub
    
Problem:
    Call Globals.ResetTemporarySheets
    Call MsgBox("Unable to carry out this function", vbExclamation, Globals.AddInName)
End Sub

'****************************************************************
' This function is invoked when the user hits the "Summary" button
' It inserts a summary worksheet into the user's workbook and
' links the controls on the sheet to the users DMS data
'****************************************************************
Public Sub SummaryEntry()
    
    On Error GoTo Problem
    Dim m_FileSpec As CFileSpec
    Set m_FileSpec = New CFileSpec
    Call m_FileSpec.ConfigureDataSource(ESourceFileType.DmsFile, ESourceDataType.ParticleSizeData)
    If (m_FileSpec.IsAlreadyWeighted) Then
        MsgBox "This spectrum has been weighted. Please generate the summary sheet from the original spectrum."
        Exit Sub
    End If
    
    If (Globals.WorksheetOK() = False) Then Exit Sub
    If (Globals.DmsVersionOK() = False) Then Exit Sub

    Call Globals.SetTemporarySheets("Sum")
    Call Summary.CreateSummarySheet
    Call Globals.ResetTemporarySheets
    
    Exit Sub
    
Problem:
    Call Globals.ResetTemporarySheets
    Call MsgBox("Unable to carry out this function", vbExclamation, Globals.AddInName)
End Sub

'****************************************************************
' This function is invoked when the user hits the "Re-invert" button.
' It inverts DMS data using a new inversion matrix, but the same
' inversion algorithm that was used to acquire the original data.
' All the work is done inside a CInversion because the progress
' bar is updated using an event, and events can only be handled from inside
' class modules!
'****************************************************************
Public Sub InversionEntry()

    On Error GoTo Problem
    If (Globals.WorksheetOK() = False) Then Exit Sub
    If (Globals.DmsVersionOK() = False) Then Exit Sub

    Dim m_DataForm As InversionControl
    Dim m_FileSpec As CFileSpec

    Set m_FileSpec = New CFileSpec
    Call m_FileSpec.ConfigureDataSource(ESourceFileType.DmsFile, ESourceDataType.ParticleSizeData)
    If (m_FileSpec.IsAlreadyWeighted) Then
        MsgBox "This DMS file has already been weighted."
        Exit Sub
    End If
    
    ' The main dialog for inversion...
    Set m_DataForm = New InversionControl
    
    'If (m_FileSpec.DilutionCorrectionEnabled) Then
    '    m_DataForm.ApplyDilutionCorrection = True
    'Else
    '    m_DataForm.ApplyDilutionCorrection = False
    'End If
        
    m_DataForm.DoModal
    
    If (m_DataForm.OkWasPressed = False) Then
        Unload m_DataForm
        Exit Sub ' Don't do anything unless the user hit the OK button
    End If

    'Call m_FileSpec.CalculateWeighting(m_DataForm.tbWeightingConstant, m_DataForm.WeightingPower, _
    '    m_DataForm.DensityMultiplier, m_DataForm.tbWeightingText)

    Dim inv As CInversion
    Set inv = New CInversion
    Call inv.Invert(m_DataForm, m_FileSpec)
    
    Unload m_DataForm
    
    'Globals.ReadOptions
    Call Import.ColourDmsFile(Globals.ColourDmsFileCells)

    Exit Sub
        
Problem:
    Unload m_DataForm
    Call Globals.ResetTemporarySheets
    Call MsgBox("Unable to carry out this function", vbExclamation, Globals.AddInName)
End Sub

Attribute VB_Name = "ProgressControl"
Attribute VB_Base = "0{C9FAD9BA-F7EC-476F-994C-80D61970266E}{C7CBE6B3-F0EB-4C28-AA13-F44B93FFB2F8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Attribute VB_Name = "Reconstruct"
' J.P.R. Symonds for Cambustion 2009

Public Modename(3) As String
Public no_modes As Integer
Public start_of_spectrum As Integer

Public Sub LN_reconstruct()
Attribute LN_reconstruct.VB_Description = "Macro recorded 20/03/2009 by  Dr Jonathan Symonds"
Attribute LN_reconstruct.VB_ProcData.VB_Invoke_Func = " \n14"

On Error GoTo Problem

' is this a version 4 DMS file?
If DmsVersion() < 4 Then
MsgBox "DMS file older than Version 4, no lognormal data", vbOKOnly, "Cambustion DMS"
Exit Sub
End If


' find how many modes there are

startofLN_col = 13
ActiveSheet.Select
Set spec = Range("6:6").Find("GSD", SearchDirection:=xlPrevious)
If spec Is Nothing Then
MsgBox "No lognormal data in DMS file", vbOKOnly, "Cambustion DMS"
Exit Sub
End If
start_of_spectrum = spec.Column + 1
no_modes = (start_of_spectrum - startofLN_col) / 3

'name them and write it to the dialogue box

For i = 1 To no_modes
Modename(i) = Cells(6, startofLN_col - 3 + i * 3).Value
Modename(i) = Replace(Modename(i), " CMD", "")
Select Case i
    Case 1
    ReproduceDLG.mode1.Enabled = True
    ReproduceDLG.mode1.Caption = Modename(i)
    Case 2
    ReproduceDLG.mode2.Enabled = True
    ReproduceDLG.mode2.Caption = Modename(i)
    Case 3
    ReproduceDLG.mode3.Enabled = True
    ReproduceDLG.mode3.Caption = Modename(i)
End Select
Next

ReproduceDLG.Show

'clean up dialog
ReproduceDLG.mode1.Caption = "Mode 1"
ReproduceDLG.mode1.Caption = "Mode 2"
ReproduceDLG.mode1.Caption = "Mode 3"
ReproduceDLG.mode1.Enabled = False
ReproduceDLG.mode2.Enabled = False
ReproduceDLG.mode3.Enabled = False
ReproduceDLG.mode1.Value = False
ReproduceDLG.mode2.Value = False
ReproduceDLG.mode3.Value = False

Exit Sub

Problem:
    Call MsgBox("Unable to carry out this function", vbExclamation, Globals.AddInName)

End Sub

Public Sub Calc_ln()

Dim mode_on As Boolean
Dim progress_bar As ProgressControl
Dim percent_complete As Integer

'copy the sheet
Dim original As Worksheet
Set original = ActiveSheet
ActiveSheet.Select
ActiveSheet.Copy Before:=Sheets(1)
Sheets(1).Select
Err = 0

    On Error Resume Next
    Index = 1
    flag = False

Do Until flag

        Sheets(1).Name = original.Name & " LN" & Index

        If Err = 0 Then
            flag = True
        Else
            Err = 0
            Index = Index + 1
        End If

        If Index > 40 Then
            Application.DisplayAlerts = False
            Sheets(1).Delete
            Application.DisplayAlerts = True
            MsgBox "Cannot create new worksheet(s) for data. Likely that original worksheet name is too long to append more charcters to.", vbOKOnly, title:="Cambustion DMS"
            End
        End If
        
Loop
On Error GoTo 0
Range("D1").Value = "Lognormal Reconstruction of"
endrow = Sheets(1).UsedRange.Rows.Count
startrow = 7
startofLN_col = 13
endcolumn = Range("6:6").Find("Comment").Column - 1

If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual
Set progress_form = New ProgressControl
    progress_form.Show vbModeless

'clear the spectral data
For i = startrow To endrow
For j = start_of_spectrum To endcolumn
Cells(i, j).Value = 0
Next
percent_complete = (i - startrow) * (100 / (no_modes + 1)) / (endrow - startrow)
        If ((percent_complete Mod 5) = 0) Then
        If ((percent_complete >= 0) And (percent_complete <= 100)) Then
        'progress_form.Bar.Value = percent_complete
        progress_form.Text = CStr(percent_complete) + " %"
        DoEvents
        End If
        End If
Next

'reproduce the lognormal
Dim mode_used_count As Integer

mode_used = 0

For m = 1 To no_modes
Select Case m
    Case 1
    mode_on = ReproduceDLG.mode1.Value
    Case 2
    mode_on = ReproduceDLG.mode2.Value
    Case 3
    mode_on = ReproduceDLG.mode3.Value
End Select

If mode_on Then
mode_used_count = mode_used_count + 1
Range("D1").Value = Range("d1").Value + " " + Modename(m) + " &"
For i = startrow To endrow
CMD = Cells(i, startofLN_col - 3 + m * 3).Value
amp = Cells(i, startofLN_col - 2 + m * 3).Value
GSD = Cells(i, startofLN_col - 1 + m * 3).Value
For j = start_of_spectrum To endcolumn
If amp > 0 Then Cells(i, j).Value = Cells(i, j).Value + amp * Application.WorksheetFunction.NormDist(Log10(Cells(6, j).Value), Log10(CMD), Log10(GSD), False)
Next
percent_complete = (m * 100 / (no_modes + 1)) + ((i - startrow) * (100 / (no_modes + 1)) / (endrow - startrow))
        If ((percent_complete Mod 5) = 0) Then
        If ((percent_complete >= 0) And (percent_complete <= 100)) Then
        'progress_form.Bar.Value = percent_complete
        progress_form.Text = CStr(percent_complete) + " %"
        DoEvents
        End If
        End If
        
Next
End If
Next
Range("D1").Value = Mid(Range("d1").Value, 1, Len(Range("d1").Value) - 2)

'v 7.24 - recolour spectrum

Dim recolour As Integer
If mode_used_count > 0 Then
recolour = 7 'magenta
If mode_used_count = 1 Then
    If ReproduceDLG.mode1.Value Then recolour = 6 'yellow
    If ReproduceDLG.mode2.Value Then recolour = 4 'green
    If ReproduceDLG.mode2.Value Then recolour = 12 'orange
End If
Call Import.ColourThisRange(Range(Cells(startrow - 1, start_of_spectrum), Cells(endrow, endcolumn)), recolour)
End If


progress_form.Hide
If (Not Globals.AllowUserScreenUpdateCtrl) Then Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
MsgBox "Finished Lognormal Reconstruction", vbOKOnly, "Cambustion DMS"


End Sub

Static Function Log10(x)
    Log10 = Log(x) / Log(10)
End Function
Attribute VB_Name = "Registry"
 Option Explicit

Public Const REG_SZ As Long = 1
Public Const REG_DWORD As Long = 4

Public Const HKEY_CLASSES_ROOT = &H80000000
Public Const HKEY_CURRENT_USER = &H80000001
Public Const HKEY_LOCAL_MACHINE = &H80000002
Public Const HKEY_USERS = &H80000003

Public Const ERROR_NONE = 0
Public Const ERROR_BADDB = 1
Public Const ERROR_BADKEY = 2
Public Const ERROR_CANTOPEN = 3
Public Const ERROR_CANTREAD = 4
Public Const ERROR_CANTWRITE = 5
Public Const ERROR_OUTOFMEMORY = 6
Public Const ERROR_ARENA_TRASHED = 7
Public Const ERROR_ACCESS_DENIED = 8
Public Const ERROR_INVALID_PARAMETERS = 87
Public Const ERROR_NO_MORE_ITEMS = 259

Public Const KEY_QUERY_VALUE = &H1
Public Const KEY_SET_VALUE = &H2
Public Const KEY_ALL_ACCESS = &H3F

Public Const REG_OPTION_NON_VOLATILE = 0

#If VBA7 Then
Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, ByVal lpSecurityAttributes As Long, phkResult As Long, lpdwDisposition As Long) As Long
Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Declare PtrSafe Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As String, lpcbData As Long) As Long
Declare PtrSafe Function RegQueryValueExLong Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Long, lpcbData As Long) As Long
Declare PtrSafe Function RegQueryValueExNULL Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As Long, lpcbData As Long) As Long
Declare PtrSafe Function RegSetValueExString Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As String, ByVal cbData As Long) As Long
Declare PtrSafe Function RegSetValueExLong Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, ByVal cbData As Long) As Long
#Else
Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, ByVal lpSecurityAttributes As Long, phkResult As Long, lpdwDisposition As Long) As Long
Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Declare Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As String, lpcbData As Long) As Long
Declare Function RegQueryValueExLong Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Long, lpcbData As Long) As Long
Declare Function RegQueryValueExNULL Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As Long, lpcbData As Long) As Long
Declare Function RegSetValueExString Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As String, ByVal cbData As Long) As Long
Declare Function RegSetValueExLong Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, ByVal cbData As Long) As Long
#End If


   Public Sub CreateNewKey(sNewKeyName As String, lPredefinedKey As Long)
       Dim hNewKey As Long         'handle to the new key
       Dim lRetVal As Long         'result of the RegCreateKeyEx function

       lRetVal = RegCreateKeyEx(lPredefinedKey, sNewKeyName, 0&, _
                 vbNullString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, _
                 0&, hNewKey, lRetVal)
       RegCloseKey (hNewKey)
   End Sub
            
   Public Function QueryValue(sKeyName As String, sValueName As String) As String
       Dim lRetVal As Long      'result of the API functions
       Dim hKey As Long         'handle of opened key
       Dim vValue As Variant    'setting of queried value

       lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sKeyName, 0, KEY_QUERY_VALUE, hKey)
       lRetVal = QueryValueEx(hKey, sValueName, vValue)
       QueryValue = vValue
       RegCloseKey (hKey)
   End Function
        
    Public Sub SetKeyValue(sKeyName As String, sValueName As String, vValueSetting As Variant, lValueType As Long)
       Dim lRetVal As Long         'result of the SetValueEx function
       Dim hKey As Long         'handle of open key

       'open the specified key
       lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sKeyName, 0, KEY_SET_VALUE, hKey)
       lRetVal = SetValueEx(hKey, sValueName, lValueType, vValueSetting)
       RegCloseKey (hKey)
   End Sub
                   
                   
 Public Function SetValueEx(ByVal hKey As Long, sValueName As String, _
   lType As Long, vValue As Variant) As Long
       Dim lValue As Long
       Dim sValue As String
       Select Case lType
           Case REG_SZ
               sValue = vValue & Chr$(0)
               SetValueEx = RegSetValueExString(hKey, sValueName, 0&, _
                                              lType, sValue, Len(sValue))
           Case REG_DWORD
               lValue = vValue
               SetValueEx = RegSetValueExLong(hKey, sValueName, 0&, _
   lType, lValue, 4)
           End Select
   End Function

   Public Function QueryValueEx(ByVal lhKey As Long, ByVal szValueName As String, vValue As Variant) As Long
       Dim cch As Long
       Dim lrc As Long
       Dim lType As Long
       Dim lValue As Long
       Dim sValue As String

       On Error GoTo QueryValueExError

       ' Determine the size and type of data to be read
       lrc = RegQueryValueExNULL(lhKey, szValueName, 0&, lType, 0&, cch)
       If lrc <> ERROR_NONE Then Error 5

       Select Case lType
           ' For strings
           Case REG_SZ:
               sValue = String(cch, 0)

   lrc = RegQueryValueExString(lhKey, szValueName, 0&, lType, _
   sValue, cch)
               If lrc = ERROR_NONE Then
                   vValue = Left$(sValue, cch - 1)
               Else
                   vValue = Empty
               End If
           ' For DWORDS
           Case REG_DWORD:
   lrc = RegQueryValueExLong(lhKey, szValueName, 0&, lType, _
   lValue, cch)
               If lrc = ERROR_NONE Then vValue = lValue
           Case Else
               'all other data types not supported
               lrc = -1
       End Select

QueryValueExExit:
       QueryValueEx = lrc
       Exit Function

QueryValueExError:
       Resume QueryValueExExit
   End Function


Attribute VB_Name = "ReproduceDLG"
Attribute VB_Base = "0{0CEDDD39-CAC2-4463-98DC-E0E2036A9E02}{CD7B3E89-90AE-4483-8052-F3CA3135D4DE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Private Sub Cancel_Click()

ReproduceDLG.Hide

End Sub

Private Sub OK_Click()

ReproduceDLG.Hide
Call Reconstruct.Calc_ln

End Sub


Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Summary"
Option Explicit ' Generate errors if declarations are not explicit

Private m_WorkBookName As String
Private m_DataSheetName As String
Private m_TemplateSheetName As String
Private m_SummarySheetName As String

Private Const m_CellMinParticleSize As String = "E7"
Private Const m_CellMaxParticleSize As String = "E8"
Private Const m_CellMinTime As String = "A11"
Private Const m_CellMaxTime As String = "B11"

Private Const LMStartCol As Integer = 19 '
Private Const LMMaxCols As Integer = 15 '

'Private Const WSStartCol As Integer = 36 ' Assuming 3 lognormal modes. Each mode will push this 5 cells to the right.
Private Const WSMaxCols As Integer = 90 '
Private Const m_SummarySheetIdentifier As String = "DMS Summary Data"

'****************************************************************
' This function is invoked after AnalogRange, DataRange and TemplateSheet
' have been initialised by the client code. Also, the names should have
' been initialised with valid cell references.
'****************************************************************
Private Function GetCell(search_sheetname As String, search_str As String, search_range_str As String, Optional report_failed_search As Boolean = True) As Integer

    Dim search_rng As Range
    Set search_rng = Range("'" & search_sheetname & "'!" & search_range_str)

    On Error Resume Next
    Dim idx As Integer
    idx = Application.WorksheetFunction.Match(search_str, search_rng, 0)
    
    If Err.Number <> 0 Then ' search_string not found
        If (report_failed_search) Then
            MsgBox search_str & " not found."
        End If
        idx = -1
    End If
    Err.Clear
    GetCell = idx
End Function

Public Sub CreateSummarySheet()
    
    m_WorkBookName = ActiveWorkbook.Name
    m_DataSheetName = ActiveSheet.Name
    m_TemplateSheetName = "Summary"
        
    Dim file_spec As CFileSpec
    Set file_spec = New CFileSpec
    Call file_spec.ConfigureDataSource(DmsFile, ParticleSizeData)
    
    '====================>>>>>>>>>>>>>>>>
    ' Include moments in the DMS file, but only if they're not already there
    Dim first_moment_col As Integer, last_moment_col As Integer
    If (file_spec.NumModes > 0) Then
        Dim test_string As String
        test_string = file_spec.Modename(0) & " mode surface area (|fffd|m^2/cc)"
        Dim test_range As Range
        Set test_range = Rows("6:6")
        On Error Resume Next
        first_moment_col = WorksheetFunction.Match(test_string, test_range, 0)
        If Err.Number <> 0 Then ' test_string not found
            Err.Clear
    
            If (file_spec.NumModes > 0) Then
                'find _enough_ blank columns
                Dim jj, columns_needed As Integer
                columns_needed = file_spec.NumModes * 2
                first_moment_col = file_spec.NumColsInSheet + 1
                For jj = (file_spec.NumColsInSheet + 1) To (file_spec.NumColsInSheet + 100) ' got to stop somewhere...
                    If (WorksheetFunction.CountA(Range(Columns(jj), Columns(jj + columns_needed - 1))) = 0) Then
                        first_moment_col = jj
                        Exit For
                    End If
                Next
                last_moment_col = first_moment_col + 1
                Cells(file_spec.DataStartRow - 1, first_moment_col) = file_spec.Modename(0) & " mode surface area (|fffd|m^2/cc)"
                Cells(file_spec.DataStartRow, first_moment_col).FormulaR1C1 = "=PI()*0.000001*RC14*(RC13*EXP((2/2)*(LN(RC15))^2))^2"
                
                Cells(file_spec.DataStartRow - 1, first_moment_col + 1) = file_spec.Modename(0) & " mode mass (|fffd|g/cc)"
                Cells(file_spec.DataStartRow, first_moment_col + 1).FormulaR1C1 = "=R4C16*RC14*(RC13*EXP((R4C17/2)*(LN(RC15))^2))^R4C17"
            End If
            If (file_spec.NumModes > 1) Then
                last_moment_col = first_moment_col + 3
                Cells(file_spec.DataStartRow - 1, first_moment_col + 2) = file_spec.Modename(1) & " mode surface area (|fffd|m^2/cc)"
                Cells(file_spec.DataStartRow, first_moment_col + 2).FormulaR1C1 = "=PI()*0.000001*RC17*(RC16*EXP((2/2)*(LN(RC18))^2))^2"
                
                Cells(file_spec.DataStartRow - 1, first_moment_col + 3) = file_spec.Modename(1) & " mode mass (|fffd|g/cc)"
                Cells(file_spec.DataStartRow, first_moment_col + 3).FormulaR1C1 = "=R4C18*RC17*(RC16*EXP((R4C19/2)*(LN(RC18))^2))^R4C19"
            End If
            If (file_spec.NumModes > 2) Then
                last_moment_col = first_moment_col + 5
                Cells(file_spec.DataStartRow - 1, first_moment_col + 4) = file_spec.Modename(2) & " mode surface area (|fffd|m^2/cc)"
                Cells(file_spec.DataStartRow, first_moment_col + 4).FormulaR1C1 = "=PI()*0.000001*RC20*(RC19*EXP((2/2)*(LN(RC21))^2))^2"
                
                Cells(file_spec.DataStartRow - 1, first_moment_col + 5) = file_spec.Modename(2) & " mode mass (|fffd|g/cc)"
                Cells(file_spec.DataStartRow, first_moment_col + 5).FormulaR1C1 = "=R4C20*RC20*(RC19*EXP((R4C21/2)*(LN(RC21))^2))^R4C21"
            End If
            
            Range(Cells(file_spec.DataStartRow, first_moment_col), Cells(file_spec.DataStartRow, last_moment_col)).Select
            Selection.AutoFill destination:=Range(Cells(file_spec.DataStartRow, first_moment_col), Cells(file_spec.NumRowsInSheet, last_moment_col)), Type:=xlFillDefault
        
            ' Replace the formulas with values
            Application.Calculate
            Range(Selection, Selection.End(xlDown)).Select
            Selection.Copy
            Selection.PasteSpecial Paste:=xlPasteValuesAndNumberFormats, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
            Range(Cells(file_spec.DataStartRow, first_moment_col), Cells(file_spec.DataStartRow, first_moment_col)).Select
            Application.CutCopyMode = False
        
        End If
    End If
    '<<<<<<<<<<<<<<<<<<<<<<====================
    
    Dim number_of_sheets As Integer
    number_of_sheets = Sheets.Count

    m_SummarySheetName = Globals.TemporaryInsertedSheetName

    ' Add a new sheet using the template
    Dim filepath As String
    filepath = Globals.InstallationDirectory & Globals.TemplatesFileName
    
    Dim Wb1 As Workbook
    Set Wb1 = Workbooks.Add(template:=filepath)
    Sheets(m_TemplateSheetName).Select
    Sheets(m_TemplateSheetName).Copy After:=Workbooks(m_WorkBookName).Sheets(number_of_sheets)
    Wb1.Close SaveChanges:=False
            
    Workbooks(m_WorkBookName).Activate
    Sheets(m_TemplateSheetName).Name = m_SummarySheetName
    Sheets(m_SummarySheetName).Select
       
    Worksheets(m_SummarySheetName).names("datacell").Delete
    Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & _
        "!datacell", RefersTo:="=" & m_DataSheetName & "!" & Globals.R1C1toA1("R" & CStr(file_spec.DataStartRow) & "C" & CStr(file_spec.DataStartCol))
    
    Worksheets(m_SummarySheetName).names("timestamp").Delete
    Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & _
        "!timestamp", RefersTo:="=" & m_DataSheetName & "!$A$" & CStr(file_spec.DataStartRow) & ":$A$" & CStr(file_spec.NumRowsInSheet)
    
    Worksheets(m_SummarySheetName).names("numsize").Delete
    Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & _
        "!numsize", RefersTo:="=" & str(file_spec.NumSizeClasses)
    
    Worksheets(m_SummarySheetName).names("minldp").Delete
    Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & _
        "!minldp", RefersTo:="=" & str(file_spec.LogMinDp)
    
    Worksheets(m_SummarySheetName).names("nperdec").Delete
    Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & _
        "!nperdec", RefersTo:="=" & str(file_spec.NumSizeClassesPerDecade)
    
    Worksheets(m_SummarySheetName).names("tsam").Delete
    If (file_spec.RealTime = True) Then
        Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & _
            "!tsam", RefersTo:="=" & str(file_spec.SampleInterval / 86400)
    Else
        Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & _
            "!tsam", RefersTo:="=" & str(file_spec.SampleInterval)
    End If
    
    'Dim moment_column As Integer
    'moment_column = file_spec.NumColsInSheet + 1 '
    
    Worksheets(m_SummarySheetName).names("firstmode").Delete
    Worksheets(m_SummarySheetName).names("mass_factors").Delete
    Worksheets(m_SummarySheetName).names("moments").Delete
    If (file_spec.NumModes > 0) Then
        Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & "!firstmode", _
            RefersTo:="=" & m_DataSheetName & "!" & Globals.R1C1toA1("R7C13")
        Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & "!mass_factors", _
            RefersTo:="=" & m_DataSheetName & "!" & Globals.R1C1toA1("R4C16")
        Worksheets(m_SummarySheetName).names.Add Name:=m_SummarySheetName & "!moments", _
            RefersTo:="=" & m_DataSheetName & "!" & Globals.R1C1toA1("R" & CStr(file_spec.DataStartRow) & "C" & CStr(first_moment_col))
    End If
    
    
    Dim ws_start_col As Integer
    ws_start_col = LMStartCol + LMMaxCols + 2
    
    ' Remove unwanted columns from the Cumulative Weighted Spectrum
    Dim first_col_to_delete As Long, last_col_to_delete As Long
    first_col_to_delete = ws_start_col + WSMaxCols + 2 + file_spec.NumSizeClasses
    last_col_to_delete = ws_start_col + 2 + 2 * WSMaxCols
    
    If (last_col_to_delete >= first_col_to_delete) Then
        Range(Cells(1, first_col_to_delete), Cells(1, last_col_to_delete)).EntireColumn.Delete
    End If
    
    ' Remove unwanted columns from the Weighted Spectrum
    first_col_to_delete = ws_start_col + file_spec.NumSizeClasses
    last_col_to_delete = ws_start_col + WSMaxCols - 1
    If (last_col_to_delete >= first_col_to_delete) Then
        Range(Cells(1, first_col_to_delete), Cells(1, last_col_to_delete)).EntireColumn.Delete
    End If
    Cells(10, first_col_to_delete).FormulaR1C1 = "=RC[-1]*10^(1/nperdec)"

    ' Remove unwanted columns from the lognormal modes columns
    first_col_to_delete = LMStartCol + file_spec.NumModes * 5
    last_col_to_delete = LMStartCol + LMMaxCols - 1
    If (last_col_to_delete >= first_col_to_delete) Then
        Range(Cells(1, first_col_to_delete), Cells(1, last_col_to_delete)).EntireColumn.Delete
    End If

    ActiveSheet.UsedRange ' Resets last cell
    
    ' Copy the time range from the DMS sheet into the summary sheet
    ' The lower range must be copied explicitly from the data sheet or else floating point rounding may
    ' make the min time different (less than) the original time. This is important because of the
    ' MATCH that KSR does in column Q of the summary sheet
    Range(m_CellMinTime).Value = Range(m_DataSheetName & "!$A$" & CStr(file_spec.DataStartRow)) ' str(file_spec.MinTime)
    Range(m_CellMaxTime).Value = str(file_spec.MaxTime)
    
    If (file_spec.RealTime = True) Then
        Range(m_CellMinTime & ":" & m_CellMaxTime).Select
        Selection.NumberFormat = "dd/mm/yy hh:mm:ss"
    End If
    
    ' Copy the size range from the DMS sheet into the summary sheet
    Range(m_CellMinParticleSize).Value = str(file_spec.MinDpDisplay)
    Range(m_CellMaxParticleSize).Value = str(file_spec.MaxDpDisplay)
    
    Range("A12").Select
End Sub

Public Sub AddCol()

    If Sheets(ActiveSheet.Name).Type <> xlWorksheet Then
        MsgBox ("The active sheet must contain DMS Summary Data")
        Exit Sub
    End If
    
    If (Range("A1").Text <> m_SummarySheetIdentifier) Then
        MsgBox ("The active sheet must contain DMS Summary Data")
        Exit Sub
    End If
    
    Globals.EnteringLongTask (True)
    
    On Error GoTo Problem
    Columns("D:G").Select
    Selection.Insert Shift:=xlToRight
    Columns("H:K").Select
    Selection.Copy
    Columns("D:G").Select
    ActiveSheet.Paste
    Application.CutCopyMode = False
    Range(m_CellMinParticleSize).Select
    
    Globals.EnteringLongTask (False)
    Exit Sub
    
Problem:
    Globals.EnteringLongTask (False)
    MsgBox ("Excel can't insert any more columns")
End Sub

Public Sub AddRow()
    If Sheets(ActiveSheet.Name).Type <> xlWorksheet Then
        MsgBox ("The active sheet must contain DMS Summary Data")
        Exit Sub
    End If

    If (Range("A1").Text <> m_SummarySheetIdentifier) Then
        MsgBox ("The active sheet must contain DMS Summary Data")
        Exit Sub
    End If
    
    Globals.EnteringLongTask (True)
    
    Dim r1 As Long, r2 As Long, number_of_sheets As Integer
    Range("A10").Select
    Call Globals.GetRowsExtent(r1, r2)
    
    Rows(CStr(r2) & ":" & CStr(r2)).Select
    Selection.Copy
    Rows(CStr(r2 + 1) & ":" & CStr(r2 + 1)).Select
    ActiveSheet.Paste
    Application.CutCopyMode = False
    
    Globals.EnteringLongTask (False)
End Sub

Public Sub ChartSizeSpectralDensity()
    AddChart (0)
End Sub
Public Sub ChartCumulativeConcentration()
    AddChart (1)
End Sub


Private Sub AddChart(chart_type As Integer)

    If Sheets(ActiveSheet.Name).Type <> xlWorksheet Then
        MsgBox ("The active sheet must contain DMS Summary Data")
        Exit Sub
    End If
    
    If (Range("A1").Text <> m_SummarySheetIdentifier) Then
        MsgBox ("The active sheet must contain DMS Summary Data")
        Exit Sub
    End If
    
    'On Error GoTo Problem
        
    Globals.SetTemporarySheets ("Chrt")
        
    Dim summary_sheet_name As Variant
    summary_sheet_name = ActiveSheet.Name

    Dim row6 As Range
    Set row6 = Rows(6)
    Dim ws_start_col As Integer
    ws_start_col = WorksheetFunction.Match("Weighted Spectrum", row6, 0)
    
    ' Find the starting cell for the weighted spectrum
    Range(Cells(6, ws_start_col), Cells(6, ws_start_col)).Select
    Dim ws_offset As Integer
    ws_offset = -1
    Do
        ws_offset = ws_offset + 1
    Loop Until InStr(1, Cells(6, ws_start_col + ws_offset), "Spectrum", vbTextCompare)
    
    Dim start_col As Long
    start_col = ws_start_col + ws_offset

    ' Locate the last weighted spectrum cell
    Dim num_size_classes As Long, this_col As Long, next_col As Long
    num_size_classes = 0
    Do
        num_size_classes = num_size_classes + 1
        next_col = start_col + num_size_classes
        this_col = next_col - 1
    Loop Until (Cells(10, next_col) < Cells(10, this_col))
    num_size_classes = num_size_classes - 1

    Dim r1 As Long, r2 As Long, num_series As Long
    Range("A10").Select
    Call Globals.GetRowsExtent(r1, r2)
    num_series = r2 - r1
    Range("B3").Select
    
    Dim title As String, ylabel_formula As String
    Dim top_left As String, bottom_right As String
    If (chart_type = 0) Then
        title = "Size Spectral Density"
        ylabel_formula = summary_sheet_name & "!R7C" & CStr(start_col)
        top_left = Globals.R1C1toA1("R10C" & CStr(start_col))
        bottom_right = Globals.R1C1toA1("R" & CStr(r2) & "C" & CStr(start_col + num_size_classes - 1))
    Else
        title = "Cumulative Concentration"
        ylabel_formula = summary_sheet_name & "!R7C" & CStr(start_col + num_size_classes + 2)
        top_left = Globals.R1C1toA1("R10C" & CStr(start_col + num_size_classes + 2))
        bottom_right = Globals.R1C1toA1("R" & CStr(r2) & "C" & CStr(start_col + 2 * num_size_classes + 1))
    End If

    Charts.Add
    ActiveChart.ChartType = xlXYScatterLinesNoMarkers
    ActiveChart.SetSourceData Source:=Sheets(summary_sheet_name).Range(top_left & ":" & bottom_right), PlotBy:=xlRows
    ActiveChart.Location Where:=xlLocationAsNewSheet
    With ActiveChart
        .HasTitle = True
        .ChartTitle.Characters.Text = title
        .Axes(xlCategory, xlPrimary).HasTitle = True
        .Axes(xlCategory, xlPrimary).AxisTitle.Characters.Text = "Dp (nm)"
        .Axes(xlValue, xlPrimary).HasTitle = False
        AddYAxisLabel (ylabel_formula)
    End With

    ActiveChart.Axes(xlCategory).HasMajorGridlines = True
    ActiveChart.Axes(xlCategory).MajorGridlines.Select
    With Selection.Border
        .ColorIndex = 57
        .Weight = xlHairline
        .LineStyle = xlDot
    End With
    ActiveChart.Axes(xlCategory).HasMinorGridlines = True
    ActiveChart.Axes(xlCategory).MinorGridlines.Select
    With Selection.Border
        .ColorIndex = 57
        .Weight = xlHairline
        .LineStyle = xlDot
    End With

    ActiveChart.Axes(xlValue).HasMajorGridlines = True
    ActiveChart.Axes(xlValue).MajorGridlines.Select
    With Selection.Border
        .ColorIndex = 57
        .Weight = xlHairline
        .LineStyle = xlDot
    End With
    
    ActiveChart.Axes(xlValue).HasMinorGridlines = False
    
    ActiveChart.HasLegend = True
    ActiveChart.Legend.Select
    Selection.Position = xlRight
    Dim series As Long
    Dim series_name As String
    For series = 1 To num_series
        On Error Resume Next
        series_name = "='" & summary_sheet_name & "'!" & Sheets(summary_sheet_name).Cells(series + 10, 3).AddressLocal(ReferenceStyle:=xlR1C1) 'v6.8
        On Error Resume Next
        ActiveChart.SeriesCollection(series).Name = series_name
        If Err.Number = 1004 Then
            series_name = "='" & summary_sheet_name & "'!" & Sheets(summary_sheet_name).Cells(series + 10, 3).Address(ReferenceStyle:=xlR1C1)
            ActiveChart.SeriesCollection(series).Name = series_name
        ElseIf (Err.Number <> 0) Then
            MsgBox ("Error #" & Err.Number)
            Exit Sub
        End If
        On Error GoTo 0
    Next series

    ActiveChart.Axes(xlCategory).Select
    With ActiveChart.Axes(xlCategory)
        .MinimumScaleIsAuto = True
        .MaximumScaleIsAuto = True
        .MinorUnitIsAuto = True
        .MajorUnitIsAuto = True
        .Crosses = xlAutomatic
        .ReversePlotOrder = False
        .ScaleType = xlLogarithmic
        .DisplayUnit = xlNone
        .TickLabels.NumberFormat = "0"
    End With
    ActiveChart.Legend.Select
    
    ActiveSheet.Name = Globals.TemporaryInsertedSheetName
    
    Globals.ResetTemporarySheets
    Exit Sub
    
Problem:
    Globals.ResetTemporarySheets
    Call MsgBox("Unable to carry out this function", vbExclamation, Globals.AddInName)
    
End Sub

Private Sub AddYAxisLabel(formula As String)
    
    If (Globals.ExcelVersion <= 11) Then
        ActiveChart.Shapes.AddTextbox(msoTextOrientationHorizontal, 8.14, 12.8, 45.92, 19.2).Select
    ElseIf (Globals.ExcelVersion >= 12) Then
        ActiveChart.Shapes.AddTextbox(msoTextOrientationHorizontal, 8.14, 12.8, 100, 19.2).Select
    End If
    Application.ReferenceStyle = xlR1C1
    Selection.formula = formula
    
    Selection.AutoScaleFont = True
    With Selection.Font
        .Name = "Arial"
        .FontStyle = "Bold"
        .Size = 10
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        If (Globals.ExcelVersion <= 11) Then .Background = xlTransparent
    End With
    With Selection
        .HorizontalAlignment = xlLeft
        .VerticalAlignment = xlTop
        If (Globals.ExcelVersion <= 11) Then .ReadingOrder = xlContext
        .Orientation = xlHorizontal
        .AutoSize = True
    End With
End Sub

Private Sub EdgeRight()

    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    Selection.Borders(xlEdgeLeft).LineStyle = xlNone

End Sub

Private Sub EdgeLeft()

    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    Selection.Borders(xlEdgeRight).LineStyle = xlNone

End Sub

Attribute VB_Name = "Test"
Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function CompareFiles Lib "CamDMSjsi.dll" (ByVal File1 As String, ByVal File2 As String, ByRef FileSizesAgree As Long, ByRef NumFileDiffs As Long) As Long
#Else
Private Declare Function CompareFiles Lib "CamDMSjsi.dll" (ByVal File1 As String, ByVal File2 As String, ByRef FileSizesAgree As Long, ByRef NumFileDiffs As Long) As Long
#End If

Public Type SAnimationControl
    ParticleSize As Boolean
    RingCurrent As Boolean
End Type
Public AnimationControl As SAnimationControl

Public Type SContourPlotControl
    TimeLo As Single
    TimeHi As Single
    CsdLo As Single
    CsdHi As Single
    WeightingType As EWeightingType
    density As Single
End Type
Public ContourPlotControl As SContourPlotControl

Public InversionMatrixSelection As String

Private Const m_DmsSourceDataFile As String = "Test\SourceData\Version 2 32pd.xls"
Private Const m_DmeSourceDataFile As String = "Test\SourceData\psnorm10s.dme"
Private Const m_DmxSourceDataFile As String = "Test\SourceData\m2ba1.dmx"

Private Const m_AnswersDirectory As String = "Test\"
Private Const m_ResultsFile As String = "Temp\TestResults.txt"

Public Sub RunAllTests()
    Call ContourPlot
    Call ParticleSizeAnimation
    Call RingCurrentAnimation
    Call DmeAnimation
    Call Inversion
    Call Summary
End Sub

Public Sub ContourPlot()
    
    Workbooks.Open filename:=m_DmsSourceDataFile
    
    ContourPlotControl.TimeLo = 1
    ContourPlotControl.TimeHi = 8
    ContourPlotControl.CsdLo = 2
    ContourPlotControl.CsdHi = 7
    ContourPlotControl.WeightingType = eNumber
    
    Call Main.ContourPlotEntry
    ActiveWorkbook.Close SaveChanges:=False
    
    Dim error_code As Long, file_sizes_agree As Long, num_file_diffs As Long
    
    error_code = CompareFiles(m_AnswersDirectory & "Contour\ContourPlot.bmp", _
                              Globals.UserTempDirectory & "ContourPlot.bmp", _
                              file_sizes_agree, num_file_diffs)
                              
    If (error_code = 1) Then
        MsgBox ("CompareFiles can't the first file")
    ElseIf (error_code = 2) Then
        MsgBox ("CompareFiles can't the second file")
    ElseIf (file_sizes_agree = 0) Then
        MsgBox ("ContourPlot: file sizes differ. Num diffs=" & CStr(num_file_diffs))
    ElseIf (num_file_diffs <> 0) Then
        MsgBox ("ContourPlot: file sizes OK, but num diffs=" & CStr(num_file_diffs))
    Else
        MsgBox "ContourPlot: Success"
    End If

End Sub

Public Sub ParticleSizeAnimation()
    
    Workbooks.Open filename:=m_DmsSourceDataFile
    
    AnimationControl.ParticleSize = True
    AnimationControl.RingCurrent = False
    Call Main.AnimationEntry
    
    Application.DisplayAlerts = False
    ActiveWorkbook.SaveAs filename:=m_ResultsFile, FileFormat:=xlText, CreateBackup:=False
    Application.DisplayAlerts = True

    ActiveWorkbook.Close SaveChanges:=False
    
    ' Error detection
    Dim error_code As Long, file_sizes_agree As Long, num_file_diffs As Long
    
    error_code = CompareFiles(m_AnswersDirectory & "Animation\ParticleSize.txt", _
                              m_ResultsFile, file_sizes_agree, num_file_diffs)
                              
    If (error_code = 1) Then
        MsgBox ("CompareFiles can't the first file")
    ElseIf (error_code = 2) Then
        MsgBox ("CompareFiles can't the second file")
    ElseIf (file_sizes_agree = 0) Then
        MsgBox ("Particle Size Animation: file sizes differ. Num diffs=" & CStr(num_file_diffs))
    ElseIf (num_file_diffs <> 0) Then
        MsgBox ("Particle Size Animation: file sizes OK, but num diffs=" & CStr(num_file_diffs))
    Else
        MsgBox "Particle Size Animation: Success"
    End If

End Sub

Public Sub RingCurrentAnimation()
    
    Workbooks.Open filename:=m_DmsSourceDataFile
    
    AnimationControl.ParticleSize = False
    AnimationControl.RingCurrent = True
    Call Main.AnimationEntry
    
    Application.DisplayAlerts = False
    ActiveWorkbook.SaveAs filename:=m_ResultsFile, FileFormat:=xlText, CreateBackup:=False
    Application.DisplayAlerts = True

    ActiveWorkbook.Close SaveChanges:=False
    
    ' Error detection
    Dim error_code As Long, file_sizes_agree As Long, num_file_diffs As Long
    
    error_code = CompareFiles(m_AnswersDirectory & "Animation\RingCurrents.txt", _
                              m_ResultsFile, file_sizes_agree, num_file_diffs)
                              
    If (error_code = 1) Then
        MsgBox ("CompareFiles can't the first file")
    ElseIf (error_code = 2) Then
        MsgBox ("CompareFiles can't the second file")
    ElseIf (file_sizes_agree = 0) Then
        MsgBox ("Ring Current Animation: file sizes differ. Num diffs=" & CStr(num_file_diffs))
    ElseIf (num_file_diffs <> 0) Then
        MsgBox ("Ring Current Animation: file sizes OK, but num diffs=" & CStr(num_file_diffs))
    Else
        MsgBox "Ring Current Animation: Success"
    End If

End Sub

Public Sub DmeAnimation()
    
    Workbooks.Open filename:=m_DmeSourceDataFile
    
    Call Main.AnimationEntry
    
    Application.DisplayAlerts = False
    ActiveWorkbook.SaveAs filename:=m_ResultsFile, FileFormat:=xlText, CreateBackup:=False
    Application.DisplayAlerts = True

    ActiveWorkbook.Close SaveChanges:=False
    
    ' Error detection
    Dim error_code As Long, file_sizes_agree As Long, num_file_diffs As Long
    
    error_code = CompareFiles(m_AnswersDirectory & "Animation\Dme_psnorm10s.txt", _
                              m_ResultsFile, file_sizes_agree, num_file_diffs)
                              
    If (error_code = 1) Then
        MsgBox ("CompareFiles can't the first file")
    ElseIf (error_code = 2) Then
        MsgBox ("CompareFiles can't the second file")
    ElseIf (file_sizes_agree = 0) Then
        MsgBox ("DME Animation: file sizes differ. Num diffs=" & CStr(num_file_diffs))
    ElseIf (num_file_diffs <> 0) Then
        MsgBox ("DME Animation: file sizes OK, but num diffs=" & CStr(num_file_diffs))
    Else
        MsgBox "DME Animation: Success"
    End If

End Sub

Public Sub Inversion()
    
    Workbooks.Open filename:=m_DmsSourceDataFile
    
    InversionMatrixSelection = m_DmxSourceDataFile
    Call Main.InversionEntry
    
    Application.DisplayAlerts = False
    ActiveWorkbook.SaveAs filename:=m_ResultsFile, FileFormat:=xlText, CreateBackup:=False
    Application.DisplayAlerts = True

    ActiveWorkbook.Close SaveChanges:=False
    
    ' Error detection
    Dim error_code As Long, file_sizes_agree As Long, num_file_diffs As Long
    
    error_code = CompareFiles(m_AnswersDirectory & "Inversion\InversionAnswer.txt", _
                              m_ResultsFile, file_sizes_agree, num_file_diffs)
                              
    If (error_code = 1) Then
        MsgBox ("CompareFiles can't the first file")
    ElseIf (error_code = 2) Then
        MsgBox ("CompareFiles can't the second file")
    ElseIf (file_sizes_agree = 0) Then
        MsgBox ("Inversion: file sizes differ. Num diffs=" & CStr(num_file_diffs))
    ElseIf (num_file_diffs <> 0) Then
        MsgBox ("Inversion: file sizes OK, but num diffs=" & CStr(num_file_diffs))
    Else
        MsgBox "Inversion: Success"
    End If

End Sub

Public Sub Summary()
    
    Workbooks.Open filename:=m_DmsSourceDataFile
    
    Call Main.SummaryEntry
    
    Application.DisplayAlerts = False
    ActiveWorkbook.SaveAs filename:=m_ResultsFile, FileFormat:=xlText, CreateBackup:=False
    Application.DisplayAlerts = True

    ActiveWorkbook.Close SaveChanges:=False
    
    ' Error detection
    Dim error_code As Long, file_sizes_agree As Long, num_file_diffs As Long
    
    error_code = CompareFiles(m_AnswersDirectory & "Summary\SummaryAnswer.txt", _
                              m_ResultsFile, file_sizes_agree, num_file_diffs)
                              
    If (error_code = 1) Then
        MsgBox ("CompareFiles can't the first file")
    ElseIf (error_code = 2) Then
        MsgBox ("CompareFiles can't the second file")
    ElseIf (file_sizes_agree = 0) Then
        MsgBox ("Summary: file sizes differ. Num diffs=" & CStr(num_file_diffs))
    ElseIf (num_file_diffs <> 0) Then
        MsgBox ("Summary: file sizes OK, but num diffs=" & CStr(num_file_diffs))
    Else
        MsgBox "Summary: Success"
    End If

End Sub

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_AddinInstall()
    On Error Resume Next
    
    'Set the commandbar object
    Dim cmdbar As CommandBar
    Set cmdbar = Application.CommandBars

    ' Check if the data sheet already exists and delete it if it does
    For Each cmdbar In Application.CommandBars
        If (cmdbar.Name = "Dms") Then
            Exit Sub
        End If
    Next cmdbar
    
    Install.InstallDmsUtilities
    'MsgBox ("Installation complete")

End Sub

' Reset overriding the File->Open commands
Private Sub Workbook_AddinUninstall()
    On Error Resume Next
    Application.CommandBars("Dms").Delete
    'Application.CommandBars("Worksheet Menu Bar").Controls("File").Controls("Open").OnAction = ""    '(or Reset method)
    'Application.CommandBars("Standard").Controls("Open").OnAction = ""

    Dim menu_File As CommandBarPopup
    Set menu_File = Application.CommandBars("Worksheet Menu Bar").FindControl(ID:=30002)
    
    Dim menu_FileOpenCtrl As CommandBarControl
    Set menu_FileOpenCtrl = menu_File.CommandBar.FindControl(ID:=23)
    menu_FileOpenCtrl.Reset
    
    Dim toolbar_FileOpenCtrl As CommandBarControl
    Set toolbar_FileOpenCtrl = Application.CommandBars("Standard").FindControl(ID:=23)
    toolbar_FileOpenCtrl.Reset
    
    Application.OnKey "^o"

    'MsgBox ("Deinstallation complete")
End Sub

' Override the File->Open commands
Private Sub Workbook_Open()
    'On Error Resume Next
    'Application.CommandBars("Worksheet Menu Bar").Controls("File").Controls("Open...").OnAction = "DmsUtilities.xla!Import.OpenIt"
    'Application.CommandBars("Standard").Controls("Open").OnAction = "DmsUtilities.xla!Import.OpenIt"
    'Application.OnKey "^o", "DmsUtilities.xla!Import.OpenIt"

    'Application.CommandBars("Worksheet Menu Bar").Controls("File").Controls("Open").OnAction = "DmsUtilities.xla!Import.OpenIt"
    'Application.CommandBars("Standard").Controls("Open").OnAction = "DmsUtilities.xla!Import.OpenIt"
    'Application.OnKey "^o", "DmsUtilities.xla!Import.OpenIt"
    
    'Dim cmdbar As CommandBar
    'Set cmdbar = Application.CommandBars
    ' Check if the DmsUtilities are already loaded
    'Dim DmsLoaded As Boolean
    'DmsLoaded = False
    'For Each cmdbar In Application.CommandBars
    '    If (cmdbar.name = "Dms") Then
    '        DmsLoaded = True
    '        Exit For
    '    End If
    'Next cmdbar
    'If DmsLoaded = False Then
    '    Exit Sub
    'End If
    
    'MsgBox ("Workbook_Open...")
    
    On Error GoTo Problem1
    Dim menu_File As CommandBarPopup
    Set menu_File = Application.CommandBars("Worksheet Menu Bar").FindControl(ID:=30002)
    
    Dim menu_FileOpenCtrl As CommandBarControl
    Set menu_FileOpenCtrl = menu_File.CommandBar.FindControl(ID:=23)
    menu_FileOpenCtrl.OnAction = "DmsUtilities.xla!Import.OpenIt"

    'MsgBox ("Test2...")
    On Error GoTo Problem2
    Dim toolbar_FileOpenCtrl As CommandBarControl
    Set toolbar_FileOpenCtrl = Application.CommandBars("Standard").FindControl(ID:=23)
    toolbar_FileOpenCtrl.OnAction = "DmsUtilities.xla!Import.OpenIt"
       
    'MsgBox ("Test3...")
    On Error GoTo Problem3
    Application.OnKey "^o", "DmsUtilities.xla!Import.OpenIt"
    Exit Sub
        
    'MsgBox ("Tests complete")
Problem1:
    MsgBox ("Worksheet Menu access failed")
    Exit Sub
Problem2:
    MsgBox ("Standard Bar access failed")
    Exit Sub
Problem3:
    MsgBox ("Ctrl O access failed")
    Exit Sub

End Sub

'Private Sub Workbook_Activate(ByVal Sh As Object)
'    If (Globals.IsRealTimeFormat() = True) Then
'        Dim answer As VbMsgBoxResult
'        answer = MsgBox(Prompt:="Format real-time column?", Buttons:=vbYesNo + vbQuestion, title:=AddInName)
'        If (answer = vbYes) Then
'            Call Globals.FormatFractionalRealtime
'        End If
'    End If
'End Sub


' InQuest injected base64 decoded content
' ^u(^z
' ZrH+
' z{Gy
' ,RzW
' y*^r

INQUEST-PP=macro
