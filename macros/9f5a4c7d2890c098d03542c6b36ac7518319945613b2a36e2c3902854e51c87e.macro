Attribute VB_Name = "CCountry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mtISO                 As String
Private mlKolli               As Long
Private mlGesamtMenge         As Long
Private mlKartons             As Long

',--------------------------------------------------------------------------------------
'| Module     : Function GetCountryISO
'| ReturnType : String
'| DateTime   : 20.10.2015 13:39
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetCountryISO() As String
    GetCountryISO = mtISO
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function GetGesamtMenge
'| ReturnType : Long
'| DateTime   : 20.10.2015 13:39
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetGesamtMenge() As Long
    GetGesamtMenge = mlGesamtMenge
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function GetKarton
'| ReturnType : Long
'| DateTime   : 20.10.2015 13:39
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetKarton() As Long
    GetKarton = DivideValue(mlGesamtMenge, mlKolli, False)
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function GetKolli
'| ReturnType : Long
'| DateTime   : 20.10.2015 13:39
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetKolli() As Long
    GetKolli = mlKolli
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function SetGesamtMenge
'| ReturnType : Long
'| DateTime   : 20.10.2015 13:39
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function SetGesamtMenge(lGes As Long) As Long
    mlGesamtMenge = lGes
    mlKartons = DivideValue(mlGesamtMenge, mlKolli, False)
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function SetKolli
'| ReturnType : Long
'| DateTime   : 20.10.2015 13:40
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function SetKolli(lKolli As Long) As Long
    mlKolli = lKolli
    mlKartons = DivideValue(mlGesamtMenge, mlKolli, False)
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub Init
'| DateTime   : 20.10.2015 13:27
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Sub Init(tCountryISO As String, lKolli As Long, lGesamtMenge As Long)
    mtISO = tCountryISO
    mlKolli = lKolli
    mlGesamtMenge = lGesamtMenge
    
    mlKartons = DivideValue(mlGesamtMenge, mlKolli, False)
End Sub
Attribute VB_Name = "InsertPlainText"
Option Explicit

'#### 180829 AG Anpassungen f|fffd|r 64 Bit
#If VBA7 Then
    Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
    Private Declare PtrSafe Function CloseClipboard Lib "user32" () As LongPtr
    Private Declare PtrSafe Function GetClipboardData Lib "user32" (ByVal wFormat As LongPtr) As LongPtr
    Private Declare PtrSafe Function lstrcpyn Lib "kernel32" Alias "lstrcpynA" (ByVal lpString1 As LongPtr, ByVal lpString2 As LongPtr, ByVal iMaxLength As Long) As LongPtr
#Else
    Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Function CloseClipboard Lib "user32" () As Long
    Private Declare Function GetClipboardData Lib "user32" (ByVal wFormat As Long) As Long
    Private Declare Function lstrcpyn Lib "kernel32" Alias "lstrcpynA" (ByVal lpString1 As Long, ByVal lpString2 As Long, ByVal lMaxLength As Long) As Long
#End If
 
Private Const CF_TEXT = 1
Private Const MAX_SIZE = 23167       '<---- Experimentell herausgefunden!

Sub EditUndo()
    If mbBuildDoc Then
        ThisDocument.Undo (1)
    End If
End Sub

Sub EditPaste()
    Call InsertPlainText
End Sub

Sub EditPasteSPecial()
    Call InsertPlainText
End Sub

Public Sub InsertPlainText()
    Dim oRng                  As Word.Range
    Dim lStart                As Long
    Dim lEnd                  As Long
    Dim lSelectionStart       As Long
    Dim tNewText              As String
    Dim tText                 As String
    Dim tOldText              As String
    Dim tBookmarkName         As String
    
    On Error GoTo exitInsertPlainText
    
    tNewText = GetClipBoardText()
    tNewText = MaxReplace(tNewText, vbCrLf, Chr(11))
    tNewText = MaxReplace(tNewText, vbCr, Chr(11))
    tNewText = MaxReplace(tNewText, vbLf, Chr(11))
    
    tBookmarkName = GetBookMarkName()
    
    With ThisDocument
        If .Bookmarks.Exists(tBookmarkName) And FieldExists(ThisDocument, tBookmarkName) Then
            tOldText = .FormFields(tBookmarkName).result
        
            If Len(tNewText) > .FormFields(tBookmarkName).TextInput.Width Then
                'MsgBox "Eingabe ist zu lang"
                tNewText = Left(tNewText, .FormFields(tBookmarkName).TextInput.Width)
            End If
            
            lStart = .Windows(1).Selection.Range.Start - .FormFields(tBookmarkName).Range.Start + 1
            lEnd = .Windows(1).Selection.Range.End - .FormFields(tBookmarkName).Range.Start + 1
                
            If Len(tOldText) = lEnd - lStart Then
                '#### Text |fffd|berschreiben
                tText = tNewText
            Else
                lSelectionStart = .Windows(1).Selection.Range.Start - (.FormFields(tBookmarkName).Range.Start + 13)
                tText = Left(tOldText, lSelectionStart) & _
                            tNewText & _
                            Mid(tOldText, lSelectionStart + 1, .FormFields(tBookmarkName).Range.End - .Windows(1).Selection.Range.End)
            End If
            '#### |fffd|bernahme eines begrenzten Textes
            tText = Left(tText, IIf(.FormFields(tBookmarkName).TextInput.Width > 0, .FormFields(tBookmarkName).TextInput.Width, MAX_SIZE))
            
            
            Call SetFieldResult(.FormFields(tBookmarkName), tText)
            Set oRng = .Bookmarks(tBookmarkName).Range
            Call oRng.Collapse(wdCollapseEnd)
            .Windows(1).Selection.Start = oRng.End - 1
        Else
            Call .Windows(1).Selection.TypeText(tNewText)
        End If
        Call .Windows(1).Selection.Collapse
    End With
        Set oRng = Nothing
    Exit Sub
    
exitInsertPlainText:
    Call ErrorMessage
    Set oRng = Nothing
End Sub

Function GetClipBoardText() As String
    '#### 180823 AG Anpassungen f|fffd|r 64 Bit
    '#### 180829 KR/AG Korrekturen 64bit
#If VBA7 Then
    Dim hClipMemory             As LongPtr
    Dim lpClipMemory            As LongPtr
#Else
    Dim hClipMemory             As Long
    Dim lpClipMemory            As Long
#End If
     
    Dim tString                 As String
    Dim bString()               As Byte
    
    If OpenClipboard(0&) = 0 Then
        GetClipBoardText = vbNullString
        Exit Function
    End If
    
    hClipMemory = GetClipboardData(CF_TEXT)
    If IsNull(hClipMemory) Then
        GetClipBoardText = vbNullString
        Exit Function
    End If
    
    lpClipMemory = GlobalLock(hClipMemory)
    If IsNull(lpClipMemory) Then
        GetClipBoardText = vbNullString
        Exit Function
    End If
    
    ReDim bString(0 To MAX_SIZE) As Byte
    Call lstrcpyn(VarPtr(bString(0)), lpClipMemory, MAX_SIZE - 1)
    Call GlobalUnlock(hClipMemory)
    Call CloseClipboard
    
    tString = StrConv(bString, vbUnicode)
    tString = Left(tString, InStr(tString, vbNullChar) - 1)
    
    GetClipBoardText = tString
End Function

Attribute VB_Name = "MAufrufDialog"
Option Explicit

Sub OnEntryCountries()
    Dim tArrData()              As String
    tArrData = Split(PropItem("bbLaender"), gctDATA_SEPARATOR)
    Call frmDropDown.DropdownFormularInit(tArrData(), "Herkunftsl|fffd|nder", "Bitte w|fffd|hlen!")
End Sub

Sub OnEntryVPHartware()
    Dim tArrData()              As String
    tArrData = Split(PropItem("bbVPHartware"), gctDATA_SEPARATOR)
    Call frmDropDown.DropdownFormularInit(tArrData(), "Verpackung", "Bitte w|fffd|hlen!")
End Sub

Sub OnEntryVPTextil()
    Dim tArrData()              As String
    tArrData = Split(PropItem("bbVPTextil"), gctDATA_SEPARATOR)
    Call frmDropDown.DropdownFormularInit(tArrData(), "Verpackung", "Bitte w|fffd|hlen!")
End Sub

Sub OnEntryHarbours()
    Dim tArrData()              As String
    tArrData = Split(PropItem("bbHaefen"), gctDATA_SEPARATOR)
    Call frmDropDown.DropdownFormularInit(tArrData(), "Abgangsh|fffd|fen", "Bitte w|fffd|hlen!")
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub OnEntryInspectionCenter
'| DateTime   : 20.10.2015 15:26
'| Author     : Grube
'| Purpose    :
'|              170711 AG Umstellung auf Properties
'|              180320 AG gctDATA_SEPARATOR eingesetzt, f|fffd|r FH wurde der Leereintrag gelassen
'`--------------------------------------------------------------------------------------
'
Sub OnEntryInspectionCenter()
    Dim tArrData()              As String
    tArrData = Split(PropItem("bbInspectionCenter"), gctDATA_SEPARATOR)
    Call frmDropDown.DropdownFormularInit(tArrData(), "Inspection Center", "")
'    Dim tInspectionCenter(4)    As String
'    tInspectionCenter(0) = "leer"
'    tInspectionCenter(1) = "IC Shenzhen"
'    tInspectionCenter(2) = "IC Xiamen"
'    tInspectionCenter(3) = "IC Shanghai"
'    tInspectionCenter(4) = "IC Qingdao"
'    Call frmDropDown.DropdownFormularInit(tInspectionCenter(), "Inspection Center", "")
End Sub

Attribute VB_Name = "MCalculate"
Option Explicit
  
'---------------------------------------------------------------------------------------
' Procedure   : Sub CalcPreisMitGP
' DateTime    : 19/02/2016
' Author      : Reiser
' Purpose     : Berechnung von Preis mit GP
' Remarks     :
'---------------------------------------------------------------------------------------
'
Sub CalcPreisMitGP()

    On Error GoTo CalcPreisMitGPError

    Dim tPreisNetto                     As String
    Dim tKostenGP                       As String
    Dim curPreisNetto                   As Currency
    Dim curKostenGP                     As Currency
    Dim curPreisMitGP                   As Currency
    Dim lErrNumber                      As Long
    Dim tErrSource                      As String
    Dim tErrDescription                 As String

    If ThisDocument.Bookmarks.Exists("ff_Preis_Netto") Then
        tPreisNetto = ThisDocument.FormFields("ff_Preis_Netto").result
        tKostenGP = ThisDocument.FormFields("ff_Kosten_GP").result
        If tKostenGP = "" Then
            tKostenGP = 0
        End If
        If tPreisNetto = "" Then
            ThisDocument.FormFields("ff_Preis_Mit_GP").result = ""
            GoTo CalcPreisMitGPExit
        End If

        If GetDecimalSeperator() = "," Then
            curPreisNetto = CCur(tPreisNetto)
            curKostenGP = CCur(tKostenGP)
            curPreisMitGP = curPreisNetto + curKostenGP
            ThisDocument.FormFields("ff_Preis_Mit_GP").result = Format_3NK(CStr(curPreisMitGP))
        Else
            curPreisNetto = CCur(Replace(tPreisNetto, ",", "."))
            curKostenGP = CCur(Replace(tKostenGP, ",", "."))
            curPreisMitGP = curPreisNetto + curKostenGP
            ThisDocument.FormFields("ff_Preis_Mit_GP").result = Format_3NK(Replace(CStr(curPreisMitGP), ".", ","))
        End If
    End If

CalcPreisMitGPExit:
    On Error GoTo 0
    Exit Sub

CalcPreisMitGPError:
    lErrNumber = Err.number
    tErrSource = Err.Source
    tErrDescription = Err.Description

    On Error GoTo 0
    Call Err.Raise(lErrNumber, tErrSource, tErrDescription & "-->CalcPreisMitGPError (Modul MCalculate)")
    GoTo CalcPreisMitGPExit

End Sub

'---------------------------------------------------------------------------------------
' Procedure   : Sub CalcSumme
' DateTime    : 19/02/2016
' Author      : Reiser
' Purpose     : Berechnung von Summe
' Remarks     :
'---------------------------------------------------------------------------------------
'
Sub CalcSumme(tISO As String)

    On Error GoTo CalcSummeExit

    Dim tPreis                          As String
    Dim tVerpack                        As String
    Dim curPreis                        As Currency
    Dim curVerpack                      As Currency
    Dim curSumme                        As Currency
    Dim lErrNumber                      As Long
    Dim tErrSource                      As String
    Dim tErrDescription                 As String

    If ThisDocument.Bookmarks.Exists("ff_Preis" & tISO) Then
        tPreis = ThisDocument.FormFields("ff_Preis" & tISO).result
        tVerpack = ThisDocument.FormFields("ff_Verpack" & tISO).result
        If tVerpack = "" Then
            tVerpack = 0
        End If
        If tPreis = "" Then
            ThisDocument.FormFields("ff_Summe" & tISO).result = ""
            GoTo CalcSummeExit
        End If
        If GetDecimalSeperator() = "," Then
            curPreis = CCur(tPreis)
            curVerpack = CCur(tVerpack)
            curSumme = curPreis + curVerpack

            ThisDocument.FormFields("ff_Summe" & tISO).result = Format_3NK(CStr(curSumme))

        Else
            curPreis = CCur(Replace(tPreis, ",", "."))
            curVerpack = CCur(Replace(tVerpack, ",", "."))
            curSumme = curPreis + curVerpack

            ThisDocument.FormFields("ff_Summe" & tISO).result = Format_3NK(Replace(CStr(curSumme), ".", ","))
        End If
    End If

CalcSummeExit:
    On Error GoTo 0
    Exit Sub

CalcSummeError:
    lErrNumber = Err.number
    tErrSource = Err.Source
    tErrDescription = Err.Description

    On Error GoTo 0
    Call Err.Raise(lErrNumber, tErrSource, tErrDescription & "-->CalcSumme (Modul MCalculate)")
    GoTo CalcSummeExit

End Sub
  
'------------------------------------------------------------------------------
' Procedure : CalcKumMengen
' Author    : Grube
' Date      : 27.08.2015
' Purpose   : Zentrale Funktion zur Durchf|fffd|hrung der Berechnungen
'------------------------------------------------------------------------------
'
Sub CalcKumMengen(ffield As FormField, tBookmarkName As String, bIsGesField As Boolean, bIsKolliField As Boolean)
    Dim tFieldVal             As String
        
    ThisDocument.Application.ScreenUpdating = False
    Call DocUnlock(ThisDocument)
  
    '#### Berechnung der Liefermengen
    tFieldVal = MakeNumeric(ffield.result)
    Call CalCulateLieferMengen(tBookmarkName, Val(tFieldVal), bIsGesField, bIsKolliField)
  
    '#### Berechnung der Kartonmengen je Bestimmungsort
'    Call CalculatePackageSums
  
    '#### Berechnung der L|fffd|nderbl|fffd|cke
'    Call CalcLaenderbloecke
  
    ffield.Select
    
    If (bIsGesField Or _
        bIsKolliField) Then
        If tFieldVal <> "" Then
            ffield.result = FormatWithThousandsSeparator(Val(tFieldVal), "#,##0") '#AR
        End If
    End If

    Call DocLock(ThisDocument)
    ThisDocument.Application.ScreenUpdating = True
End Sub
  
'------------------------------------------------------------------------------
' Procedure : FillDeliveryByCountryCol
' Author    : Thomas Lutzeier
' Date      : 01.04.2015
' Purpose   : Erzeugt eine Collection mit den DeliveryByCountry-Daten
'             'tMode: new = Initialisierung, old = Werte auslesen
'------------------------------------------------------------------------------
'
Sub FillDeliveryByCountryCol(tMode As String)
    Dim objCCountry           As CCountry
    Dim tDocISO               As String
    Dim lMenge                As Long
    Dim lKolli                As Long
    Dim lIndex                As Long
      
    Set mDictDeliveryByCountry = New Scripting.Dictionary
      
    If tMode = "new" Then
        For lIndex = 0 To UBound(mtCurrentUpperCountries)
            Set objCCountry = New CCountry
            Call objCCountry.Init(mtCurrentUpperCountries(lIndex), 0, 0)
            Call mDictDeliveryByCountry.Add(objCCountry.GetCountryISO(), objCCountry)
        Next
        Exit Sub
    End If
  
    '### Liefermengen-Daten auslesen:
    For lIndex = 0 To UBound(mtCurrentUpperCountries)
        tDocISO = mtCurrentUpperCountries(lIndex)
        If tDocISO <> vbNullString And tDocISO <> "OS" Then
            lMenge = GetField(ThisDocument, "ff_L_Ges_Menge_" & tDocISO, vbLong, 0, , True) '# Anzahl Kartons
            lKolli = GetField(ThisDocument, "ff_L_Kolli_" & tDocISO, vbLong, 0, , True)     '# Verpackungseinheit
            Set objCCountry = New CCountry
            Call objCCountry.Init(mtCurrentUpperCountries(lIndex), lKolli, lMenge)
            Call mDictDeliveryByCountry.Add(tDocISO, objCCountry)
        End If
    Next lIndex
    Set objCCountry = Nothing
End Sub
  
'---------------------------------------------------------------------------------------
' Procedure : CalCulateLieferMengen
' Author    : Grube
' Date      : 27.08.2015
' Purpose   : Berechnet die Liefermengen nach |fffd|nderung von
'             Kolli oder Gesamtmenge
'---------------------------------------------------------------------------------------
'
Sub CalCulateLieferMengen(tBookmarkName As String, tFieldValue As Long, bIsGesField As Boolean, bIsKolliField As Boolean)
    Dim oCountry              As CCountry
    Dim lGesamtMenge          As Long
    Dim lKartonGesamt         As Long
    Dim lKarton               As Long
    Dim lIndex                As Long
    Dim lPosUnderscore        As Long
    Dim tCountry              As String
    Dim dTestVarGes           As Double
    Dim dTestVarKarton        As Double
    Dim bGesTooBig            As Boolean
    Dim bKartonTooBig         As Boolean
  
    '#### Gilt nur f|fffd|r Felder aus den Liefermengen
    If Not (bIsGesField Or _
            bIsKolliField) Then
        Exit Sub
    End If
    lPosUnderscore = InStrRev(tBookmarkName, "_") + 1
    tCountry = Mid$(tBookmarkName, lPosUnderscore)
    '#### Collection mit den Liefermengen der L|fffd|nder wiederherstellen
    If mDictDeliveryByCountry Is Nothing Then
        FillDeliveryByCountryCol ("old")
    End If
  
    '#### Keine Berechnung bei ung|fffd|ltigem Land
    If Not mDictDeliveryByCountry.Exists(tCountry) Then
        Exit Sub
    End If
    Set oCountry = New CCountry
    '#### Berechnung der Kartonanzahl
    Set oCountry = mDictDeliveryByCountry.Item(tCountry)
    With oCountry
        If bIsGesField Then
            .SetGesamtMenge (tFieldValue)
        Else
            .SetKolli (tFieldValue)
        End If
        lKarton = .GetKarton()
        '#### 160605 AG Nullen werden unterdr|fffd|ckt
        Call UpdateBookmark("ff_L_Karton_" & tCountry, IIf(lKarton > 0, FormatWithThousandsSeparator(lKarton, "#,##0"), ""))
        'Call UpdateBookmark("ff_L_Karton_" & tCountry, FormatWithThousandsSeparator(lKarton, "#,##0"))
    End With
  
    '#### Berechnung der Gesamtanzahl der Kartons
    dTestVarGes = 0
    dTestVarKarton = 0
    bGesTooBig = False
    bKartonTooBig = False
    For lIndex = 0 To mDictDeliveryByCountry.Count - 1
        Set oCountry = mDictDeliveryByCountry.Items(lIndex)
        If Not bGesTooBig Then
            dTestVarGes = dTestVarGes + oCountry.GetGesamtMenge()
            If dTestVarGes > 2100000000 Then
                Call MsgOutput("Too large amounts were entered." & vbLf & _
                             "The sum can not be processed any more" & vbLf & _
                             "and is set to 0." & vbLf & vbLf & _
                             "Please specify smaller values.", vbNullString, vbInformation)
'                Call MsgOutput("Es wurden zu gro|fffd|e Gesamtmengen eingegeben." & vbCrLf & _
'                            "Die Summe kann leider nicht weiterverarbeitet" & vbCrLf & _
'                            "werden und wird auf 0 gesetzt." & vbCrLf & vbCrLf & _
'                            "Bitte geben Sie kleinere Werte an.", vbNullString, vbInformation)
                lGesamtMenge = 0
                bGesTooBig = True
            Else
                lGesamtMenge = lGesamtMenge + oCountry.GetGesamtMenge()
            End If
        End If
        
        If Not bKartonTooBig Then
            dTestVarKarton = dTestVarKarton + oCountry.GetKarton()
            If dTestVarKarton > 2100000000 Then
                                Call MsgOutput("Too large carton quantities were entered." & vbLf & _
                             "The sum can not be processed any more" & vbLf & _
                             "and is set to 0." & vbLf & vbLf & _
                             "Please specify smaller values.", vbNullString, vbInformation)
'                Call MsgOutput("Es wurden zu gro|fffd|e Kartonmengen eingegeben." & vbCrLf & _
'                            "Die Summe kann leider nicht weiterverarbeitet" & vbCrLf & _
'                            "werden und wird auf 0 gesetzt." & vbCrLf & vbCrLf & _
'                            "Bitte geben Sie kleinere Werte an.", vbNullString, vbInformation)
                lKartonGesamt = 0
                bKartonTooBig = True
            Else
                lKartonGesamt = lKartonGesamt + oCountry.GetKarton()
            End If
        End If
    Next
  
  
    '#### Update der Bookmarks
    Call UpdateBookmark("ff_L_Ges_Menge_GES", FormatWithThousandsSeparator(lGesamtMenge, "#,##0"))
    Call UpdateBookmark("ff_L_Karton_GES", FormatWithThousandsSeparator(lKartonGesamt, "#,##0"))
    Set oCountry = Nothing
End Sub
  
'---------------------------------------------------------------------------------------
' Procedure : CalculatePackageSums
' Author    : Thomas Lutzeier
' Date      : 02.04.2015
' Purpose   : Berechnet die Kartonanzahlen pro Bestimmungsort neu
'---------------------------------------------------------------------------------------
'
'Sub CalculatePackageSums()
'    Dim lPackageSum           As Long
'    Dim oCountry              As CCountry
'
'    '#### Z|fffd|hlt die Anzahl Kartons f|fffd|r einen L|fffd|nderblock
'    lPackageSum = CountQuantitiesCountryBlock(COUNTRYDEST1, "Kartons")
'    Set oCountry = New CCountry
'    '### Spezieller Anteil f|fffd|r FR
'    Set oCountry = mDictDeliveryByCountry.Item("FR")
'    lPackageSum = lPackageSum + oCountry.GetKarton() * ffVal("ff_PROBEST_FR_1") / 100
'    Call UpdateBookmark("bmMenge1", FormatWithThousandsSeparator(lPackageSum, "#,##0"))
'
'    lPackageSum = CountQuantitiesCountryBlock(COUNTRYDEST2, "Kartons")
'    '### Spezieller Anteil f|fffd|r FR und IT
'    Set oCountry = mDictDeliveryByCountry.Item("FR")
'    lPackageSum = lPackageSum + oCountry.GetKarton() * (100 - ffVal("ff_PROBEST_FR_1")) / 100
'    Set oCountry = mDictDeliveryByCountry.Item("IT")
'    lPackageSum = lPackageSum + oCountry.GetKarton() * ffVal("ff_PROBEST_IT_1") / 100
'    Call UpdateBookmark("bmMenge2", FormatWithThousandsSeparator(lPackageSum, "#,##0"))
'
'    lPackageSum = CountQuantitiesCountryBlock(COUNTRYDEST3, "Kartons")
'    '### Spezieller Anteil f|fffd|r IT
'    Set oCountry = mDictDeliveryByCountry.Item("IT")
'    lPackageSum = lPackageSum + oCountry.GetKarton() * (100 - ffVal("ff_PROBEST_IT_1")) / 100
'    Call UpdateBookmark("bmMenge3", FormatWithThousandsSeparator(lPackageSum, "#,##0"))
'    Set oCountry = Nothing
'End Sub
  
  
'---------------------------------------------------------------------------------------
' Procedure : ChangeL|fffd|nderbl|fffd|cke
' Author    : Thomas Lutzeier
' Date      : 04.04.2015
' Purpose   : Ver|fffd|ndert das Outfit des Abschnitts L|fffd|nderbl|fffd|cke
'             und berechnet die Werte neu
'---------------------------------------------------------------------------------------
'
Sub ChangeLaenderbloecke()
'    Call Storetxt
    ThisDocument.Application.ScreenUpdating = False
    Call ThisDocument.Unprotect(gctPW)
      
  
    Select Case ThisDocument.FormFields("cboLaenderbloecke").result
        Case "Bitte ausw|fffd|hlen!"
            Call HandleCol("Delete")
            Call UpdateBookmark("bmLB", PropItem("LB1"), True)
        Case "LB 1/2/3/4/5/7"
            Call HandleCol("Delete")
            Call UpdateBookmark("bmLB", PropItem("LB1"), True)
        Case "LB 1-7 (LB 6: GB, IE)"
            Call HandleCol("Add")
            Call UpdateBookmark("bmLB", PropItem("LB2"), True)
        Case "LB 1-7 (LB 6: GB, IE, CY)"
            Call HandleCol("Add")
            Call UpdateBookmark("bmLB", PropItem("LB3"), True)
    End Select
  
    '#### Neuberechnung der Werte
    Call CalcLaenderbloecke
  
    Call ThisDocument.Protect(wdAllowOnlyFormFields, True, gctPW)
    ThisDocument.Application.ScreenUpdating = True
End Sub
  
'---------------------------------------------------------------------------------------
' Procedure : HandleCol
' Author    : Thomas Lutzeier
' Date      : 04.04.2015
' Purpose   : Aus-/Einblenden einer Spalte
'---------------------------------------------------------------------------------------
'
Sub HandleCol(tMethod)
    If tMethod = "Delete" Then
        If ThisDocument.Bookmarks.Exists("bmLB6Col") Then
            ThisDocument.Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bmLB6Col"
            ThisDocument.Windows(1).Selection.Find.ClearFormatting
            ThisDocument.Windows(1).Selection.Find.Text = ""
            ThisDocument.Bookmarks("bmLB6Col").Delete
            ThisDocument.Windows(1).Selection.Columns.Delete
        End If
        Exit Sub
    End If
    If tMethod = "Add" Then
        If Not ThisDocument.Bookmarks.Exists("bmLB6Col") Then
            ThisDocument.Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bmLB5Col"
            ThisDocument.Windows(1).Selection.Find.ClearFormatting
            ThisDocument.Windows(1).Selection.Find.Text = ""
            ThisDocument.Windows(1).Selection.InsertColumnsRight
            With ThisDocument.Bookmarks
                .Add Range:=Selection.Range, Name:="bmLB6Col"
                .DefaultSorting = wdSortByName
                .ShowHidden = True
            End With
            ThisDocument.Windows(1).Selection.MoveUp Unit:=wdLine, Count:=1
            ThisDocument.Windows(1).Selection.MoveDown Unit:=wdLine, Count:=1
            ThisDocument.Windows(1).Selection.TypeText Text:="LB6"
            ThisDocument.Windows(1).Selection.MoveDown Unit:=wdLine, Count:=1
            With ThisDocument.Bookmarks
                .Add Range:=Selection.Range, Name:="bmLB6Menge"
                .DefaultSorting = wdSortByName
                .ShowHidden = True
            End With
            ThisDocument.Windows(1).Selection.MoveDown Unit:=wdLine, Count:=1
            With ThisDocument.Bookmarks
                .Add Range:=Selection.Range, Name:="bmLB6Kartons"
                .DefaultSorting = wdSortByName
                .ShowHidden = True
            End With
        End If
        Exit Sub
    End If
  
End Sub
  
'---------------------------------------------------------------------------------------
' Procedure : CalcL|fffd|nderbl|fffd|cke
' Author    : Thomas Lutzeier
' Date      : 06.04.2015
' Purpose   :
'---------------------------------------------------------------------------------------
'
Sub CalcLaenderbloecke()
    Dim lTemp                 As Long
  
    Select Case ThisDocument.FormFields("cboLaenderbloecke").result
    Case "Bitte ausw|fffd|hlen!"
        Call UpdateBookmark("bmLB1Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB2Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB3Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB4Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB5Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB7Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Menge"), "#,##0"))
  
        Call UpdateBookmark("bmLB1Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB2Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB3Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB4Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB5Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB7Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Kartons"), "#,##0"))
    Case "LB 1/2/3/4/5/7"
        Call UpdateBookmark("bmLB1Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB2Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB3Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB4Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB5Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB7Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Menge"), "#,##0"))
  
        Call UpdateBookmark("bmLB1Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB2Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB3Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB4Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB5Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB7Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Kartons"), "#,##0"))
    Case "LB 1-7 (LB 6: GB, IE)"
        lTemp = CountQuantitiesCountryBlock(LB6A, "Menge")
        Call UpdateBookmark("bmLB1Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB2Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB3Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Menge") - lTemp, "#,##0"))
        Call UpdateBookmark("bmLB4Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB5Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB6Menge", FormatWithThousandsSeparator(lTemp, "#,##0"))
        Call UpdateBookmark("bmLB7Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Menge"), "#,##0"))
        lTemp = CountQuantitiesCountryBlock(LB6A, "Kartons")
        Call UpdateBookmark("bmLB1Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB2Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB3Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Kartons") - lTemp, "#,##0"))
        Call UpdateBookmark("bmLB4Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB5Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB6Kartons", FormatWithThousandsSeparator(lTemp, "#,##0"))
        Call UpdateBookmark("bmLB7Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Kartons"), "#,##0"))
    Case "LB 1-7 (LB 6: GB, IE, CY)"
        Call UpdateBookmark("bmLB1Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB2Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB3Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Menge") - CountQuantitiesCountryBlock(LB6A, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB4Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB5Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB6Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB6A, "Menge") + CountQuantitiesCountryBlock(LB6B, "Menge"), "#,##0"))
        Call UpdateBookmark("bmLB7Menge", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Menge") - CountQuantitiesCountryBlock(LB6B, "Menge"), "#,##0"))
  
        Call UpdateBookmark("bmLB1Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB1, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB2Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB2, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB3Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB3, "Kartons") - CountQuantitiesCountryBlock(LB6A, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB4Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB4, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB5Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB5, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB6Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB6A, "Kartons") + CountQuantitiesCountryBlock(LB6B, "Kartons"), "#,##0"))
        Call UpdateBookmark("bmLB7Kartons", FormatWithThousandsSeparator(CountQuantitiesCountryBlock(LB7, "Kartons") - CountQuantitiesCountryBlock(LB6B, "Kartons"), "#,##0"))
    End Select
End Sub
  
'------------------------------------------------------------------------------
' Procedure : CountQuantitiesCountryBlock
' Author    : Thomas Lutzeier
' Date      : 03.04.2015
' Purpose   : Z|fffd|hlt die Anzahl Kartons f|fffd|r einen L|fffd|nderblock
'             tCountries enth|fffd|lt die L|fffd|nder, tZiel Menge oder Kartons
'------------------------------------------------------------------------------
'
Function CountQuantitiesCountryBlock(tCountries As String, tZiel As String) As Long
    Dim tCountriesLinked()    As String
    Dim lIndex                As Long
    Dim objCCountry               As CCountry
  
    tCountriesLinked = Split(tCountries)
    For lIndex = 0 To UBound(tCountriesLinked)
        Set objCCountry = mDictDeliveryByCountry.Item(tCountriesLinked(lIndex))
        If tZiel = "Menge" Then
            CountQuantitiesCountryBlock = CountQuantitiesCountryBlock + objCCountry.GetGesamtMenge()
        Else
            CountQuantitiesCountryBlock = CountQuantitiesCountryBlock + objCCountry.GetKarton()
        End If
    Next lIndex
    Set objCCountry = Nothing
End Function
  
'------------------------------------------------------------------------------
' Function  : MarkChanges
' Author    : Bauer/Grube
' Date      : 26.10.2015
' Purpose   : Markiert die Checkboxen und die FormField
'------------------------------------------------------------------------------
'
Sub MarkChanges(ffield As FormField, tBookmarkName As String)
    Dim lIndex                    As Long
 
    '#### Nur, wenn Ver|fffd|nderungsmodus ON
    Select Case tBookmarkName
    Case "txtFirmenname"
        '                 ThisDocument.FormFields("chkAndere").Result = True
        '                 ThisDocument.FormFields("chkAndere").Select
    Case "ff_Preis_Mit_GP", "ff_Preis_Netto", "ff_Kosten_GP"
        ThisDocument.FormFields("chkPreis").CheckBox.Value = True
    Case "ff_Ean_Code"
        ThisDocument.FormFields("chkEAN").CheckBox.Value = True
    Case "ff_Intrastat_Nr"
        ThisDocument.FormFields("chkIntrastat").CheckBox.Value = True
    Case "ff_LT_Zentral_KW", "ff_LT_Zentral_J"
        ThisDocument.FormFields("chkLiefertermin").CheckBox.Value = True
    Case "ff_Prod_Staette", "ff_Prod_Staette_ID"
        ThisDocument.FormFields("chkProd").CheckBox.Value = True
    Case "ff_Dimensions"
        ThisDocument.FormFields("chkMa|fffd|e").CheckBox.Value = True
    Case "ff_Gewicht"
        ThisDocument.FormFields("chkGewicht").CheckBox.Value = True
    Case "ff_Qualitaet"
        ThisDocument.FormFields("chkQualit|fffd|t").CheckBox.Value = True
    Case "ff_Artikel_Name", "ff_B_Kolli_Gewicht", "ff_Farbe", "ff_Material", _
         "ff_Garantie1", "ff_Garantie2", "ff_Sonst_Merkmale", "ff_Zertifizierungen", _
         "dd_Batterie", "dd_Gefahrgut", "dd_Sich_Datenblatt", "dd_Verpackung", "ff_Verpackung_Zusatz"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "txtDisplayTyp"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "ff_Anzahl"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "txtMarke"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "dd_Ursprung"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "cboLand"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "txtMaterialSt|fffd|rke"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "ff_Anlieferung_OS"
        ThisDocument.FormFields("chkAndere").CheckBox.Value = True
    Case "ff_KW1"
        ThisDocument.FormFields("chkLiefertermin").CheckBox.Value = True
    Case "ff_KW2"
        ThisDocument.FormFields("chkLiefertermin").CheckBox.Value = True
    Case "ff_JJ1"
        ThisDocument.FormFields("chkLiefertermin").CheckBox.Value = True
    Case "ff_JJ2"
        ThisDocument.FormFields("chkLiefertermin").CheckBox.Value = True
    Case Else
        '#### In allen anderen F|fffd|llen
        If InStr(1, tBookmarkName, "ff_Preis") > 0 Then
            ThisDocument.FormFields("chkPreis").CheckBox.Value = True
        End If
            '####Felder, die Checkbox "Sortierung" betreffen
        If (Mid$(tBookmarkName, 1, 11) = "bm_Country_") Then
            ThisDocument.FormFields("chkSortierung").CheckBox.Value = True
            Exit Sub
        End If
        If (Mid$(tBookmarkName, 1, 7) = "ff_Sort") Then
            ThisDocument.FormFields("chkSortierung").CheckBox.Value = True
            Exit Sub
        End If
        '#### Liefertermin und L|fffd|ndermengen
        For lIndex = 0 To UBound(mtCurrentUpperCountries)
            Select Case tBookmarkName
            Case "ff_L_Termin_Jahr_" & mtCurrentUpperCountries(lIndex)
                ThisDocument.FormFields("chkLiefertermin").CheckBox.Value = True
            Case "ff_L_Termin_Monat_" & mtCurrentUpperCountries(lIndex)
                ThisDocument.FormFields("chkLiefertermin").CheckBox.Value = True
            Case "ff_L_Kolli_" & mtCurrentUpperCountries(lIndex)
                If FormatWithThousandsSeparator(ffield.result, "#,##0") <> mtContenttxt Then
                    ThisDocument.FormFields("chkL|fffd|ndermengen").CheckBox.Value = True
                End If
            Case "ff_L_Ges_Menge_" & mtCurrentUpperCountries(lIndex)
                If FormatWithThousandsSeparator(ffield.result, "#,##0") <> mtContenttxt Then
                    ThisDocument.FormFields("chkL|fffd|ndermengen").CheckBox.Value = True
                End If
            End Select
        Next
    End Select
End Sub


Attribute VB_Name = "MCheckSpelling"
Option Explicit

'#### 161010 AG Feld wird |fffd|bergeben
Public Sub CheckSpelling(oBookmark As Word.Bookmark)
    Dim rngField                As Word.Range
    Dim rngWord                 As Word.Range
    
    If Val(Application.Version) < 15 Then
        '#### 170117 AG Dokument zuerst freigeben (Word 2007 liefert sonst Fehler)
        Call DocUnlock(ThisDocument)
    End If
    Set rngField = oBookmark.Range.Fields(1).result
    rngField.Font.Underline = wdUnderlineNone
    rngField.Font.UnderlineColor = wdColorAutomatic
    With oBookmark.Application
        For Each rngWord In rngField.Words
           If Right$(rngWord, 1) = " " Then
                Call rngWord.MoveEnd(wdCharacter, -1)
            End If
            If Not .CheckSpelling(rngWord) Then
                rngWord.Font.Underline = wdUnderlineWavy
                rngWord.Font.UnderlineColor = wdColorRed
            End If
        Next rngWord
    End With
    If Val(Application.Version) < 15 Then
        '#### 170111 AG Dokument zuerst freigeben (Word 2007 liefert sonst Fehler)
        Call DocLock(ThisDocument)
    End If
    Set rngWord = Nothing
    Set rngField = Nothing
End Sub
Attribute VB_Name = "MDocCompare"
Option Explicit

Public Enum E_OLDFILE
    OLDFILE_THIS = 1
    OLDFILE_OTHER = 2
End Enum

',--------------------------------------------------------------------------------------
'| Module     : Sub DocCompare
'| ReturnType : -
'| DateTime   : 08.03.2017 13:39
'| Author     : Grube/Kremm
'| Purpose    : Dokumentenvergleich durchf|fffd|hren
'|              170412 AG Makro im Vergleichsdokument |fffd|berfl|fffd|ssig
'|              170516 AG Dokumentenvergleich f|fffd|r XMLImporter |fffd|berarbeitet
'|              170522 AG algemeine Speicherroutine CallSaveAs aufrufen
'|              170628 AG DisplayAlerts -Wert merken und wieder verwenden
'|              170628 AK Laut NN werden die Makros im Vergleichsdokument vielleicht doch ben|fffd|tigt!
'|              170720 AG Abbruch, sofern kein Dokument ausgew|fffd|hlt wurde (Exit Sub)
'|              170727 AG Anh|fffd|ngen des Erstellungsdatums im Format _JJJJMMTT
'`--------------------------------------------------------------------------------------
'
Public Sub DocCompare()
    Dim tPath                           As String
    Dim oDocCompare                     As Word.Document
    Dim eAlertLevelSave                 As WdAlertLevel
    
    If Not mbIsIntPC Then Exit Sub
    With ThisDocument
        tPath = SelectOpenFile(ThisDocument, "Vergleichsdatei ausw|fffd|hlen [" & PropGetNormalProp(ThisDocument, "ProgVersion") & "]", .Path, "Microsoft Office Dokumente (*.docx;*.docm)", "*.docx;*.docm")

        '#### Vergleich durchf|fffd|hren:
        Set oDocCompare = DocCompareImpl(tPath, OLDFILE_OTHER)
        If oDocCompare Is Nothing Then Exit Sub
        '#### Vergleichsdokument speichern:
        eAlertLevelSave = .Application.DisplayAlerts
        .Application.DisplayAlerts = wdAlertsNone
        Call CallSaveAs(oDocCompare, tFileName:=GetAddOnFileName(.Path & "\" & .Name, "_|fffd|nderungsprotokoll_" & Format$(Now, "YYYYMMdd"), ".docx"), lWordFileFormat:=WdSaveFormat.wdFormatDocumentDefault)
        'Call CallSaveAs(oDocCompare, tFileName:=GetAddOnFileName(.Path & "\" & .Name, "_|fffd|nderungsprotokoll", ".docx"), lWordFileFormat:=WdSaveFormat.wdFormatDocumentDefault)
        'Call oDocCompare.SaveAs2(GetAddOnFileName(ThisDocument.Path & "\" & ThisDocument.Name, "_|fffd|nderungsprotokoll", ".docx"), wdFormatDocumentDefault)
        .Application.DisplayAlerts = eAlertLevelSave
        .Saved = True
    End With
    Call oDocCompare.Activate
    oDocCompare.Saved = True
        
    Set oDocCompare = Nothing
End Sub

',--------------------------------------------------------------------------------------
'| Module     : Function DocCompareImpl
'| ReturnType : -
'| DateTime   : 16.05.2017 13:39
'| Author     : Grube/Kremm
'| Purpose    : 170516 AG Implementierung f|fffd|r XMLImporter
'|              170629 AK Parameter f|fffd|r die Umschaltung hinzugef|fffd|gt, welches Dokument
'|                        als das Alte, und weches als das Neue angesehen wird
'`--------------------------------------------------------------------------------------
'
Public Function DocCompareImpl(tWithFile As String, eOldFile As E_OLDFILE) As Word.Document
    Dim oDocOther               As Word.Document
    Dim oDocCompare             As Word.Document

    
    '#### Opens the other document to compare with:
    Set oDocOther = ThisDocument.Application.Documents.Open(tWithFile, True)
    '#### 170720 AG wurde Dokument ausgew|fffd|hlt?
    If Not oDocOther Is Nothing Then
        '#### Unlocks the other an this document:
        Call DocUnlock(oDocOther)
        Call DocUnlock(ThisDocument)
        On Error Resume Next
        DoEvents
        '#### Switches the compare logic, based on if this document is assumed to be the
        '#### original document, or the other document is assumed to be the original document:
        If eOldFile = OLDFILE_THIS Then
            Set oDocCompare = ThisDocument.Application.CompareDocuments(ThisDocument, oDocOther, wdCompareDestinationNew, wdGranularityWordLevel, False, False, False, True, False, False, False, True, False, True, "Vergleichsfunktion", True)
        Else
            Set oDocCompare = ThisDocument.Application.CompareDocuments(oDocOther, ThisDocument, wdCompareDestinationNew, wdGranularityWordLevel, False, False, False, True, False, False, False, True, False, True, "Vergleichsfunktion", True)
        End If
        '#### Locks this document:
        Call DocLock(ThisDocument)
         
        '#### Close the other document without saving changes:
        oDocOther.Saved = True
        Call oDocOther.Close(False)
        '#### Locks the comparison result document:
        'Call DocLock(oDocCompare)
    End If
    '#### Return the comparison result document:
    Set DocCompareImpl = oDocCompare
    Set oDocCompare = Nothing
    Set oDocOther = Nothing
End Function




Attribute VB_Name = "MEnterKey"
Option Explicit

'---------------------------------------------------------------------------------------
' Procedure : EnterKeyMacro
' Author    : Thomas Lutzeier
' Date      : 29.01.2015
' Purpose   : Bewegt die Einf|fffd|gemarke ins n|fffd|chste Formularfeld
'---------------------------------------------------------------------------------------
'
Public Sub EnterKeyMacro()
'    Dim tmyformfield          As String
'    Dim tBookmarkName         As String
'    Dim tExitMacro            As String
'    Dim bCalc                 As Boolean
'
'    On Error GoTo Err_EnterKeyMacro
'
'    tBookmarkName = ThisDocument.Windows(1).Selection.Bookmarks(Selection.Bookmarks.Count).Name
'    tExitMacro = ThisDocument.FormFields(tBookmarkName).ExitMacro
'    bCalc = ThisDocument.FormFields(tBookmarkName).CalculateOnExit
'
    '#### Check auf Schutz
    If ThisDocument.ProtectionType = wdAllowOnlyFormFields And _
      ThisDocument.Windows(1).Selection.Sections(1).ProtectedForForms = True Then
        SendKeys "{TAB}"
'        '### Bookmark Name ermitteln
'        tBookmarkName = ThisDocument.Windows(1).Selection.Bookmarks(Selection.Bookmarks.Count).Name
'        '### Verlassen Makro ausf|fffd|hren
'        If tExitMacro <> "" Then ThisDocument.Application.Run tExitMacro
'        '### Felder aktualisieren
'        If bCalc Then ThisDocument.Fields.Update
'
'        '### zum n|fffd|chsten Formularfeld bzw. zum Ersten
'        If ThisDocument.FormFields(tBookmarkName).Name <> _
'           ThisDocument.FormFields(ThisDocument.FormFields.Count) _
'           .Name Then
'            ThisDocument.FormFields(tBookmarkName).Next.Select
'        Else
'            ThisDocument.FormFields(1).Select
'        End If
    Else
        '### Falls nicht gesch|fffd|tzt -> Tab Stop
        ' insert a tab stop character.
       ThisDocument.Windows(1).Selection.TypeText Chr(13)
    End If
'Err_EnterKeyMacro:
End Sub
Attribute VB_Name = "MFormProcedures"
Option Explicit


'---------------------------------------------------------------------------------------
' Procedure : ReplaceArtNr
' Author    : Thomas Lutzeier
' Date      : 11.01.2015
' Purpose   : Ersetzt die Artikelnummer in der Kopfzeile
'---------------------------------------------------------------------------------------
'
Sub ReplaceArtNr()
    Dim tBookmarkName         As String
    Dim objField              As FormField
    Dim lBookmarkNr           As Long

    If ThisDocument.Windows(1).Selection.Bookmarks.Count > 0 Then
        lBookmarkNr = ThisDocument.Windows(1).Selection.Bookmarks.Count
        tBookmarkName = ThisDocument.Windows(1).Selection.Bookmarks(lBookmarkNr).Name
        Set objField = ThisDocument.FormFields(tBookmarkName)
    End If

    If objField.result <> "" Then
        Call DocUnlock(ThisDocument)
        Call UpdateBookmark("txtArtNr", objField.result)
        Call DocLock(ThisDocument)
    End If
    Set objField = Nothing
End Sub

'---------------------------------------------------------------------------------------
' Procedure : ReplaceKaufgegenstand
' Author    : Thomas Lutzeier
' Date      : 11.01.2015
' Purpose   : Ersetzt die Artikelnummer in der Kopfzeile
'---------------------------------------------------------------------------------------
'
Sub ReplaceKaufgegenstand()
    Dim tArtikel              As String
    Dim tNewResult            As String
    Dim tMarke                As String
    
    Call Checktxt

    With ThisDocument
       If .Bookmarks.Exists("ff_Artikel_Name") Then
           tArtikel = .FormFields("ff_Artikel_Name").result
       Else
           tArtikel = ""
       End If
      
       If .Bookmarks.Exists("ff_Marke_Name") Then
           tMarke = .FormFields("ff_Marke_Name").result
       Else
           tMarke = ""
       End If
    End With

    tNewResult = "Kaufgegenstand " & IIf(tMarke <> "", "'" & tMarke & "' ", "") & tArtikel

    If tNewResult <> "" Then
        Call DocUnlock(ThisDocument)
        Call UpdateBookmark("bmKaufgegenstand", tNewResult)
        Call DocLock(ThisDocument)
    End If
End Sub

Attribute VB_Name = "MGlobalFunctions"
Option Explicit
Option Private Module

',------------------------------------------------------------------------------------
'| Procedure  : Function MsgOutput
'| ReturnType : String
'| DateTime   : 05.09.2017 09:45
'| Author     : Grube
'| Purpose    : allgemeiner Aufruf der Meldungsroutine
'|              w|fffd|hrend des XML-Imports erfolgen nur Protokollierungen
'`------------------------------------------------------------------------------------
'
Public Function MsgOutput(tMessage As String, tFieldName As String, Button As VbMsgBoxStyle, Optional tHeader As String = "Information") As VbMsgBoxResult
    Dim tFieldOutput            As String
    Dim tLogFileName            As String
    If Len(tFieldName) > 0 Then
        tFieldOutput = "Fieldname: '" & tFieldName & "'"
    End If
    MsgOutput = vbOK
    Select Case mbOpenMode
        Case E_AB_OPENMODE.NORMAL
            MsgOutput = MsgBox(tMessage & vbLf & vbLf & tFieldOutput, Button, tHeader)
        Case E_AB_OPENMODE.XMLIMPORT
            With ThisDocument
                tLogFileName = .Path & "\" & Left(.Name, InStrRev(.Name, ".") - 1) & ".log"
            End With
            Call DebLog(tFieldOutput & " " & Replace(tMessage, vbLf, vbNullString), tLogFileName, False)
            'Call MsgBox("XML!!! " & tMessage & tFieldOutput, Button, tHeader)
    End Select
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function CallSaveAs
'| ReturnType : String
'| DateTime   : 22.05.2017 09:45
'| Author     : Grube
'| Purpose    : allgemeiner Aufruf der SaveAs2-Routine
'`------------------------------------------------------------------------------------
'
Public Sub CallSaveAs(oDoc As Word.Document, tFileName As String, lWordFileFormat As Long)
    '#### Konstante f|fffd|r Word 2007, weil in der Office-2007 Version die Word-Konstante nicht definiert ist
    Const CONST_WordCompatibilityMode_2007 As Long = 12
    If Val(Application.Version) < 15 Then
        '#### 170522 AG Speicherung nach dem alten Verfahren
        Call oDoc.SaveAs(FileName:=tFileName, FileFormat:=lWordFileFormat)
    Else
        '#### 170519 AG Speicherung mit 2007-Kompatibilit|fffd|t
        Call oDoc.SaveAs2(FileName:=tFileName, FileFormat:=lWordFileFormat, CompatibilityMode:=CONST_WordCompatibilityMode_2007)
    End If
    'Call .SaveAs(TEMP_DIR & "\Compare_" & tArtNumber & "_" & tFileName, wdFormatXMLDocumentMacroEnabled)
End Sub

',------------------------------------------------------------------------------------
'| Procedure  : Function GetAddOnFileName
'| ReturnType : String
'| DateTime   : 20.03.2017 09:45
'| Author     : Grube
'| Purpose    : holt den Pfad mit Zusatz f|fffd|r die Dateibezeichnung
'`------------------------------------------------------------------------------------
'
Function GetAddOnFileName(tPath As String, tAddOn As String, tExtension As String) As String
    Dim lPos As Long
    lPos = InStrRev(tPath, ".") - 1
    If lPos > 0 Then
        GetAddOnFileName = Left$(tPath, lPos) & tAddOn & tExtension
    Else
        GetAddOnFileName = tPath & tAddOn & tExtension
    End If
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function Round2
'| ReturnType : Boolean
'| DateTime   : 26.01.2017 09:25
'| Author     : Grube
'| Purpose    : korrigierte Rundungsroutine, die auch z.B. 2.5 aufrunden kann
'|              2.Parameter gibt den Faktor f|fffd|r die Stellen der Rundung an z.B. 10 f|fffd|r 2 NK
'`------------------------------------------------------------------------------------
'
Function Round2(ByVal dValue As Double, Optional ByVal dFactor As Double = 1) As Double
    Static bReduce              As Boolean
    Dim dFactorValue            As Double
    Dim dResult                 As Double
   
    dFactorValue = dValue * dFactor
    dResult = Fix(dFactorValue + 0.5 * Sgn(dValue))
    ' Handle rounding of .5 in a special manner.
    bReduce = Not bReduce
    Round2 = dResult / dFactor
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function CheckInspectionCenter
'| ReturnType : Boolean
'| DateTime   : 05.07.2016 09:25
'| Author     : Grube
'| Purpose    : Freischaltung des InspectionCenter-Feldes, wenn Herkunftsland (China, Volksrepublik)
'| Remarks    : Liefert als Funktionswert, ob das InspectionCenter-Feld editierbar ist oder nicht
'`------------------------------------------------------------------------------------
'
Public Function CheckInspectionCenter(ByVal oDoc As Word.Document, ByVal oDependedField As Object) As Boolean
    Dim oEnableField            As Word.FormField
    Dim bRtn                    As Boolean
    Dim tArrData()              As String
    bRtn = False
    '#### Inspection Center
    If mDictFormFields.Exists("dd_Inspection_Center") And oDependedField.Name = "dd_Hkl" Then
        Set oEnableField = oDoc.FormFields("dd_Inspection_Center")
        If oDependedField.result = "China, Volksrepublik" Then
            oEnableField.Enabled = True
        Else
            tArrData = Split(PropItem("bbInspectionCenter"), gctDATA_SEPARATOR)
            oEnableField.result = tArrData(0)
            oEnableField.Enabled = False
        End If
        bRtn = oEnableField.Enabled
    End If
    Set oEnableField = Nothing
    CheckInspectionCenter = bRtn
End Function

Public Sub FillFormFieldsForCalc()
    Dim lKey                    As Long
    Dim lIndex                  As Long
    Dim lSortRowsCount          As Long
    Dim tDocISO                 As String
    Dim vKey                    As Variant
    Dim oFormField              As cFormField
     
    Set mDictFieldsForCalc = New Scripting.Dictionary
    
    '#### 161214 AG ggf. Nettogewicht aus Sortierungstabelle aktualisieren
    With ThisDocument
        If .Bookmarks.Exists("bmSortierung") And .Bookmarks.Exists("ff_Sort_Gewicht_1") Then
            lSortRowsCount = .Bookmarks("bmSortierung").Range.Tables(1).Rows.Count - 2
        End If
    End With
    
    With mDictFieldsForCalc

        '        '#### Berechnung der Prozentwerte (nur OWIM)
        '        lKey = lKey + 1
        '        Call .Add(CStr(lKey), "ff_PROBEST_FR_2")
        '        lKey = lKey + 1
        '        Call .Add(CStr(lKey), "ff_PROBEST_IT_2")

        If lSortRowsCount > 0 Then
            For lIndex = 1 To lSortRowsCount
                lKey = lKey + 1
                Call .Add(CStr(lKey), "ff_Sort_Gewicht_" & lIndex)
            Next lIndex
        End If
        
        '#### Berechnung der Preise
        For lIndex = 0 To UBound(mtCurrentUpperCountries)
            tDocISO = mtCurrentUpperCountries(lIndex)
            If tDocISO <> vbNullString Then
                lKey = lKey + 1
                Call .Add(CStr(lKey), "ff_Preis_" & tDocISO)
'                lKey = lKey + 1
'                Call .Add(CStr(lKey), "ff_Verpack_" & tDocISO)
            End If
        Next lIndex

        lKey = lKey + 1
        Call .Add(CStr(lKey), "ff_Preis_Netto")
        lKey = lKey + 1
        Call .Add(CStr(lKey), "ff_Kosten_GP")

        '#### Berechnung der Liefermengen
        For lIndex = 0 To UBound(mtCurrentUpperCountries)
            tDocISO = mtCurrentUpperCountries(lIndex)
            If tDocISO <> vbNullString Then
'                lKey = lKey + 1
'                Call .Add(CStr(lKey), "ff_L_Kolli_" & tDocISO)
                lKey = lKey + 1
                Call .Add(CStr(lKey), "ff_L_Ges_Menge_" & tDocISO)
            End If
        Next lIndex
        '#### alle Auswahllistenfelder hinzu
        For Each vKey In mDictFormFields
            Set oFormField = mDictFormFields.Item(vKey)
            If oFormField.GetIsCatalog() Then
                lKey = lKey + 1
                Call .Add(CStr(lKey), oFormField.GetFormFieldName())
            End If
            Set oFormField = Nothing
        Next vKey
    End With
End Sub


',------------------------------------------------------------------------------------
'| Procedure  : Function FieldExists
'| ReturnType : Boolean
'| DateTime   : 28.02.2011 09:48
'| Author     : Kremm
'| Purpose    : Gibt zur|fffd|ck, ob ein Formularfeld mit dem |fffd|bergebenen Namen in dem
'|              |fffd|bergebenen Dokument existiert.
'| Remarks    :
'`------------------------------------------------------------------------------------
'
Public Function FieldExists(doc As Word.Document, tFieldName As String) As Boolean
    On Error GoTo NotFound
    Call doc.FormFields.Item(tFieldName)
    FieldExists = True
    Exit Function
NotFound:
    FieldExists = False
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function MaxReplace
'| ReturnType : Boolean
'| DateTime   : 09.02.2016 09:25
'| Author     : Grube
'| Purpose    : String Replace bei mehr als 254 Zeichen im String
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Public Function MaxReplace(tHoleText As String, tSearch As String, tReplaceTo As String) As String
    Dim lLen                  As Long
    Dim lLenSearch            As Long
    Dim lOffset               As Long
    Dim lIndex                As Long
    Dim lSearchIndex          As Long
    Dim tLocalText            As String
    Dim tPart                 As String
    lLen = Len(tHoleText)
    lLenSearch = Len(tSearch) - 1
    
    lOffset = 254
    lIndex = 1
    Do While lIndex >= 1 And lIndex <= lLen
        lOffset = 254
        tPart = Mid$(tHoleText, lIndex, lOffset)
        For lSearchIndex = 1 To lLenSearch
            If Right$(tPart, lSearchIndex) = Left$(tSearch, lSearchIndex) Then
                lOffset = lOffset - lSearchIndex
                tPart = Left$(tPart, lOffset)
                Exit For
            End If
        Next lSearchIndex
        
        tLocalText = tLocalText & Replace(tPart, tSearch, tReplaceTo)
        lIndex = lIndex + lOffset
    Loop
    
    MaxReplace = tLocalText
End Function


'---------------------------------------------------------------------------------------
' Procedure   : Function GetDecimalSeperator
' Return Type : String
' DateTime    : 19.02.2016
' Author      : Reiser
' Purpose     : Funktion liefert Dezimaltrennzeichen gem|fffd||fffd| Regionaleinstellung zur|fffd|ck
'---------------------------------------------------------------------------------------
'
Public Function GetDecimalSeperator() As String
    Dim tNumber                         As String
    tNumber = Format(1.1, "0.0")
    GetDecimalSeperator = Mid(tNumber, 2, 1)
End Function

'---------------------------------------------------------------------------------------
' Procedure   : Function FormatWithThousandsSeparator
' Return Type : String
' DateTime    : 22/02/2016
' Author      : Reiser
' Purpose     : Formatiert den Zahlenenwert unabh|fffd|ngig von der eingestellten Region
'               mit Punkt als Tausendertrennzeichen
' Remarks     : |fffd|ber Format-Befehl nicht m|fffd|glich
'---------------------------------------------------------------------------------------
'
Public Function FormatWithThousandsSeparator(vNumberValue As Variant, Optional tDummy As String = "") As String
 
    Dim i                               As Long
    Dim tNumberValue                    As String
    Dim tNumberValueNeu                 As String
    Dim tCharacter                      As String
    Dim iCounter                        As Integer
 
    tNumberValue = CStr(vNumberValue)
    If InStr(tNumberValue, ",") = 0 Then
        '#### Zun|fffd|chst alle nicht numerischen Character aus string entfernen
        tNumberValue = MakeNumeric(tNumberValue)
        iCounter = 1
        For i = Len(tNumberValue) To 1 Step -1
            tCharacter = Mid(tNumberValue, i, 1)
            If Asc(tCharacter) >= 48 And Asc(tCharacter) <= 57 And iCounter < 3 Then
                '### Ziffer direkt |fffd|bertragen
                iCounter = iCounter + 1
            ElseIf Asc(tCharacter) >= 48 And Asc(tCharacter) <= 57 And iCounter = 3 Then
                '### Vor jeder dritten Ziffer von hinten Punkt einf|fffd|gen
                tCharacter = "." & tCharacter
                iCounter = 1
            Else
                '### Fehler
                Call Err.Raise(vbObjectError + 1, "FormatWithThousandsSeparator", "Ung|fffd|ltiges Zeichen.")
            End If
            tNumberValueNeu = tCharacter & tNumberValueNeu
        Next i
    Else
        Call Err.Raise(vbObjectError + 1, "FormatWithThousandsSeparator", "Komma nicht zul|fffd|ssig.")
    End If
    If Left(tNumberValueNeu, 1) = "." Then
        tNumberValueNeu = Mid(tNumberValueNeu, 2)
    End If
    FormatWithThousandsSeparator = tNumberValueNeu
 
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function Format_3NK
'| ReturnType : Boolean
'| DateTime   : 18.01.2016 09:25
'| Author     : Reiser
'| Purpose    : Formatierung mit 3 (oder n) Nachkommastellen
'| Remarks    : Da Regionale Sparcheinstellung keinen Einfluss haben darf kann man di
'|              Format-Funktion nicht verwenden.
'`------------------------------------------------------------------------------------
'
Public Function Format_3NK(tNumberValue As String, Optional lDecimalPlaces As Long = 3) As String
    '    Dim lComma                As Long
    '    lComma = InStr(tNumberValue, ",")
    '    If lComma > 0 And Len(tNumberValue) > lComma + lDecimalPlaces Then
    '        '#### String einfach abschneiden
    '        Format_3NK = Left$(tNumberValue, lComma + lDecimalPlaces)
    '    Else
    '        Format_3NK = Format$(tNumberValue, "0.000")
    '    End If

    Dim lComma                          As Long
    'Dim lDecimalsDigits                 As Long
    Dim tCleanNumberValue               As String
    Dim tFormattedNumber                As String
    Dim lPosition                       As Long
    Dim tChar                           As String
    Dim bCommaFound                     As Boolean
    Dim tBeforeComma                       As String
    Dim tAfterComma                       As String

    tFormattedNumber = ""
    If tNumberValue <> "" Then
        tCleanNumberValue = ""
        bCommaFound = False
        '### Alle Zeichen entfernen, die nicht Ziffer oder , sind
        For lPosition = 1 To Len(tNumberValue)
            tChar = Mid(tNumberValue, lPosition, 1)
            If (Asc(tChar) >= 48 And Asc(tChar) <= 57) Then
                tCleanNumberValue = tCleanNumberValue & tChar
            ElseIf tChar = "," And bCommaFound = False Then
                '### Nur erstes enthaltenes Komma |fffd|bernehmen
                tCleanNumberValue = tCleanNumberValue & tChar
                bCommaFound = True
            End If
        Next lPosition
        
        '### Bei Vorkommastellen f|fffd|hrende Nullen entfernen
        lComma = InStr(tCleanNumberValue, ",")
        If lComma > 0 Then
            '### Bei Kommazahl: Bei Vorkommaanteil f|fffd|hrende 0 abschneiden
            '### und bei Nachkommateil auf lDecimalPlaces k|fffd|rzen bzw. erweitern
            tBeforeComma = Split(tCleanNumberValue, ",")(0)
            tAfterComma = Split(tCleanNumberValue, ",")(1)
            tBeforeComma = Val(tBeforeComma)
            If Len(tAfterComma) >= lDecimalPlaces Then
             tAfterComma = Left(tAfterComma, lDecimalPlaces)
            Else
                tAfterComma = tAfterComma & String(lDecimalPlaces - Len(tAfterComma), "0")
            End If
            tFormattedNumber = tBeforeComma & "," & tAfterComma
        Else
            '### Bei Ganzzahl: f|fffd|hrende 0 abschneiden und "," sowie lDecimalPlaces * "0" anh|fffd|ngen
            tFormattedNumber = Val(tCleanNumberValue) & "," & String(lDecimalPlaces, "0")
        End If
        

'        '### Auff|fffd|llen der Nachkommastellen
'        lComma = InStrRev(tCleanNumberValue, ",")
'        If lComma = 0 Then
'            tFormattedNumber = tCleanNumberValue & "," & String(lDecimalPlaces, "0")
'        Else
'            lDecimalsDigits = Len(tCleanNumberValue) - lComma
'            If lDecimalsDigits < lDecimalPlaces Then
'                tFormattedNumber = tCleanNumberValue & String(lDecimalPlaces - lDecimalsDigits, "0")
'            Else
'                '#### |fffd|berz|fffd|hlige Nachkommastellen abschneiden
'                tFormattedNumber = Left$(tCleanNumberValue, lComma + lDecimalPlaces)
'            End If
'        End If
'
'        '#### Bei f|fffd|hrendem Komma 0 davorsetzen
'        If Left(tFormattedNumber, 1) = "," Then
'            tFormattedNumber = "0" & tFormattedNumber
'        End If
    End If
    Format_3NK = tFormattedNumber
End Function
',------------------------------------------------------------------------------------
'| Procedure  : Function IsArrayValid
'| ReturnType : Boolean
'| DateTime   : 22.10.2015 09:25
'| Author     : Grube
'| Purpose    : Array|fffd|berpr|fffd|fung
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Public Function IsArrayValid(vArray As Variant) As Boolean
    Dim lDummy                As Long

    On Error GoTo NoArray
    lDummy = LBound(vArray)
    IsArrayValid = True
    Exit Function
NoArray:
    IsArrayValid = False
End Function


',------------------------------------------------------------------------------------
'| Procedure  : Function CDblGer
'| ReturnType : Double
'| DateTime   : 04.03.2011 12:20
'| Author     : Kremm
'| Purpose    : Wandelt eine |fffd|bergebene Dezimalzahl, welche das |fffd|bergebene Zeichen
'|              als Dezimaltrenner verwendet, in eine Double-Zahl um.
'| Remarks    : Aufgrund der Beschr|fffd|nkung des Wertebereichs von Long, k|fffd|nnen nur
'|              maximal 9 Nachkommastellen unterst|fffd|tzt werden.
'|              D.h.: Es werden alle Stellen nach der 9. Nachkommastelle abgeschnitten.
'`------------------------------------------------------------------------------------
'
Public Function CDblGer(ByVal tValue As String, Optional tDecSep As String = ",") As Double
    Dim tPart1                As String
    Dim tPart2                As String
    Dim dValue                As Double
 
    If Len(tValue) = 0 Then
        '#### Nichts drin -> Gebe 0 zur|fffd|ck.
        dValue = 0
    ElseIf InStr(tValue, tDecSep) = 0 Then
        '#### Keine Dezimalzahl -> Gebe Ganzzahl zur|fffd|ck:
        dValue = CLng(tValue)
    Else
        '#### Verarbeite Dezimalzahl:
        tPart1 = Trim(Left(tValue, InStr(tValue, tDecSep) - 1))
        tPart2 = Trim(Mid(tValue, InStr(tValue, tDecSep) + 1, 9))   '### Maximal 9 Nachkommastellen!
        dValue = CLng(tPart1) + (CLng(tPart2) / (10 ^ Len(tPart2)))
    End If
 
    CDblGer = dValue
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function DivideValue
'| ReturnType : Boolean
'| DateTime   : 25.08.2015 09:25
'| Author     : Grube
'| Purpose    : Dividierfunktion mit Meldung
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Public Function DivideValue(lTotalQuantity As Long, lKolliQuantity As Long, Optional bMessage As Boolean = True) As Long
    'Call Log("Divide (init" & mbInitDocument & ")")
    DivideValue = 0
    If lKolliQuantity > 0 Then
        If lTotalQuantity Mod lKolliQuantity > 0 Then
            If bMessage And Not mbInitDocument Then
                Call MsgOutput("Input not allowed. Please enter only divisible numbers.", vbNullString, vbInformation)
            End If
        Else
            DivideValue = lTotalQuantity / lKolliQuantity
        End If
    Else
        If bMessage And Not mbInitDocument Then
            Call MsgOutput("Input not allowed. Division by 0 is not permitted.", vbNullString, vbInformation)
        End If
    End If
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Sub ManageKeyBinding
'| ReturnType : Boolean
'| DateTime   : 16.07.2015 09:25
'| Author     : Grube
'| Purpose    : Setzen oder L|fffd|schen eines KeyBindings
'| Remarks    : bRemove = True entfernt Binding (Voreinstellung FALSE)
'|              170313 AG Umbau f|fffd|r DocCompare
'`------------------------------------------------------------------------------------
'
Public Sub ManageKeyBinding(Optional bRemove As Boolean = False)
    Dim bSaved                As Boolean
    With ThisDocument
        .Application.CustomizationContext = ThisDocument
        '#### Speicherstatus merken
        bSaved = .Saved
        Call DocUnlock(ThisDocument)
    
        '#### in jedem Fall KeyBindings entfernen
        Call .Application.KeyBindings.ClearAll
    
        If Not bRemove Then
            Call .Application.KeyBindings.Add(wdKeyCategoryMacro, "DocCompare", BuildKeyCode(Arg1:=WdKey.wdKeyAlt, Arg2:=WdKey.wdKeyF1))
            Call .Application.KeyBindings.Add(wdKeyCategoryMacro, "EnterKeyMacro", BuildKeyCode(wdKeyReturn))
            Call .Application.KeyBindings.Add(wdKeyCategoryMacro, "InsertPlainText", BuildKeyCode(WdKey.wdKeyControl, WdKey.wdKeyV))
            Call .Application.KeyBindings.Add(wdKeyCategoryDisable, "", BuildKeyCode(WdKey.wdKeyControl, WdKey.wdKeyZ))
        End If
        .AttachedTemplate.Saved = True
        Call DocLock(ThisDocument)
        .Saved = bSaved
    End With
End Sub
',--------------------------------------------------------------------------------------
'| Procedure  : Sub DocLock
'| DateTime   : 20.10.2015 14:02
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Sub DocLock(oDoc As Word.Document)
    If Not mbBuildDoc Then
        With oDoc
            If .ProtectionType = wdNoProtection Then
                Call .Protect(Type:=wdAllowOnlyFormFields, NoReset:=True, Password:=gctPW)
                Log ("     DocLock (Dokument wurde verschl|fffd|sselt)")
            End If
        End With
    End If
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub DocUnlock
'| DateTime   : 20.10.2015 14:02
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Sub DocUnlock(oDoc As Word.Document)
   Dim tPWD                     As String
   
   With oDoc
   
        On Error GoTo Password_Old
        If .ProtectionType <> wdNoProtection Then
            tPWD = gctPW
            .Application.DisplayAlerts = False
            Call .Unprotect(tPWD)
            .Application.DisplayAlerts = True
        End If
        GoTo DocUnlock_Exit
Password_Old:
        If .ProtectionType <> wdNoProtection Then
            tPWD = "lidlnfm11"
            Call .Unprotect(tPWD)
        End If
DocUnlock_Exit:

    End With
End Sub


',------------------------------------------------------------------------------------
'| Procedure  : Function GetDateiEndung
'| ReturnType : Boolean
'| DateTime   : 11.06.2015 09:25
'| Author     : Grube
'| Purpose    : Ermitteln der Endung einer Datei
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Public Function GetDateiEndung(ByVal tDateiName As String) As String
    Dim lWortlaenge                     As Long
    Dim lStellePunkt                    As Long
     
    lWortlaenge = Len(tDateiName)                                 ' Anzahl Zeichen des Dateinamens
    lStellePunkt = InStrRev(tDateiName, ".")                        ' Anzahl Zeichen vor dem letzten Punkt
    GetDateiEndung = Right(tDateiName, lWortlaenge - lStellePunkt)  ' Dateiendung wird extrahiert
End Function
 

',------------------------------------------------------------------------------------
'| Procedure  : Sub RefreshBuildDoc
'| ReturnType : -
'| DateTime   : 26.08.2015 12:27
'| Author     : Grube
'| Purpose    : Setzen der bBuildDoc-Variable
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Public Sub RefreshBuildDoc()
    Dim bOldBuildDoc As Boolean
    bOldBuildDoc = mbBuildDoc
    mbBuildDoc = (CLng(PropGetNormalProp(ThisDocument, "BuildDoc")) = 1)
    Log ("RefreshBuildDoc: bOldBuildDoc:" & bOldBuildDoc & " -> mbBuildDoc:" & mbBuildDoc)
End Sub

 
',------------------------------------------------------------------------------------
'| Procedure  : Sub Refresh_Globals
'| ReturnType : -
'| DateTime   : 31.08.2015 12:27
'| Author     : Grube
'| Purpose    : Re-Initialisierung der globalen Variablen bei Laufzeit
'| Remarks    : betrifft die dynamischen Variablen (Dictionary und L|fffd|nderliste)
'`------------------------------------------------------------------------------------
'
Public Sub Refresh_Globals()
    Dim tCountryList          As String
    tCountryList = PropGetNormalProp(ThisDocument, "CountryList")
    mtCurrentUpperCountries = Split(tCountryList, ";")
    'tCurrentLowerCountries = Split(LCase$(tCountryList))
    'Call MsgBox("#" & tCountryList & "#")

    '#### FormFields merken
    Call GetFormFieldValues(ThisDocument)
End Sub

 
',------------------------------------------------------------------------------------
'| Procedure  : Function Init_Globals
'| ReturnType : Boolean
'| DateTime   : 08.06.2015 12:27
'| Author     : Grube
'| Purpose    : Initialisierung der globalen Variablen
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Public Sub Init_Globals()
    Dim tComputername         As String
    mbInitDocument = True
    
    ' ### Voreinstellungen
    mbIsIntPC = False
    InitLog
    Call RefreshBuildDoc
    mbDEBUG = (CLng(PropGetNormalProp(ThisDocument, "Debug")) = 1)
    
    Call Refresh_Globals
    
    '#### Schalter Protokollierung bei |fffd|nderungen
    tComputername = UCase(Environ("COMPUTERNAME"))
    
    '#### 170316 AG ENT-f|fffd|r PTAVMs hinzu
    If tComputername Like "INT-*" Then
        mbIsIntPC = True
    ElseIf tComputername Like "TINT-*" Then
        mbIsIntPC = True
    ElseIf tComputername Like "ENT*" Then
        mbIsIntPC = True
    Else
        mbIsIntPC = False
    End If
         
    If mbDEBUG Then
        mbIsIntPC = False
        Call MsgOutput("Attention! it is now a PC other than an INT-PC specified !!! " _
                & vbLf & vbLf & "mbIsIntPC: " & mbIsIntPC, vbNullString, vbInformation)
    End If
    
    '### Formfields einf|fffd|rben
    Call ShadeFormFields(ThisDocument)
    
    Call Log("init Globals (init" & mbInitDocument & ")")
End Sub

',------------------------------------------------------------------------------------
'| Procedure  : ShadeFormFields
'| DateTime   : 22.12.2015 12:27
'| Author     : Kremm
'| Purpose    : F|fffd|rbt alle Formfields ein
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Private Sub ShadeFormFields(oDoc As Word.Document)
    Dim oFormField As Word.FormField

    For Each oFormField In oDoc.FormFields
        oFormField.Range.Font.Shading.Texture = wdTexture20Percent
    Next oFormField
End Sub
 
',------------------------------------------------------------------------------------
'| Procedure  : Function isINT_PC
'| ReturnType : Boolean
'| DateTime   : 08.06.2015 12:27
'| Author     : Grube
'| Purpose    : Gibt zur|fffd|ck, ob ein INT-PC verwendet wird
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Function isINT_PC() As Boolean
    isINT_PC = mbIsIntPC
End Function
 
 
',------------------------------------------------------------------------------------
'| Procedure  : Function isInCollection
'| ReturnType : Boolean
'| DateTime   : 09.06.2010 08:57
'| Author     : Kremm
'| Purpose    : Gibt zur|fffd|ck, ob sich in der angegebenen Collection der angegebene Wert
'|              befindet.
'| Remarks    : Diese Pr|fffd|fung ist sehr performant, selbst bei gro|fffd|en Collections.
'`------------------------------------------------------------------------------------
'
Public Function isInCollection(coll As Collection, key As String) As Boolean
    On Error GoTo NotFound
    Call coll.Item(key)
    isInCollection = True
    Exit Function
NotFound:
    isInCollection = False
End Function
 
'---------------------------------------------------------------------------------------
' Procedure : DocumentProtectUnprotect
' Author    : Grube
' Date      : 21.10.2015
' Purpose   : |fffd|ndert den Dokumentschutz gesch|fffd|tzt/ungesch|fffd|tzt
'---------------------------------------------------------------------------------------
'
Sub DocumentProtectUnprotect()
    'In diesem Beispiel wird das aktive Dokument mit
    'dem Dokumentschutz f|fffd|r Formulare versehen, ohne
    'den Inhalt der Formularfelder zur|fffd|ckzusetzen.
    Dim tInfo As String
    With ThisDocument
        If .ProtectionType = wdNoProtection Then
            tInfo = "Doc wurde verschl|fffd|sselt"
            Call DocLock(ThisDocument)
            'Call .Protect(Type:=wdAllowOnlyFormFields, NoReset:=True, Password:=gctPW)
        Else
            tInfo = "Doc wurde freigegeben!"
            'If ThisDocument.ProtectionType <> wdNoProtection Then
            Call DocUnlock(ThisDocument)
            'Call .Unprotect(Password:=gctPW)
            'End If
        End If
    End With
    Log ("In DocumentProtectUnprotect " & tInfo)
End Sub
 
'---------------------------------------------------------------------------------------
' Procedure : UpdateBookmark
' Author    : Grube
' Date      : 21.10.2015
' Purpose   : Ersetzt den Textinhalt einer Bookmark
'---------------------------------------------------------------------------------------
'
Sub UpdateBookmark(tBookmarkName As String, tNewTxt As String, Optional bXML As Boolean)
    Dim rngBookmark                As Range
    Dim rngDuplicate As Range
    
    With ThisDocument
        If .Bookmarks.Exists(tBookmarkName) Then
            Set rngBookmark = .Bookmarks(tBookmarkName).Range
            If bXML Then
                Set rngDuplicate = rngBookmark.Duplicate
                Call rngDuplicate.Collapse(wdCollapseEnd)
                Call rngDuplicate.InsertAfter(Chr(0))
                Call rngDuplicate.Collapse(wdCollapseEnd)
                Call rngBookmark.Delete
                Call rngBookmark.InsertXML(tNewTxt)
                Call rngBookmark.MoveEndUntil(Chr(0))
                Call rngBookmark.MoveEnd(wdCharacter, -1)
                Call rngDuplicate.MoveStart(wdCharacter, -1)
                Call rngDuplicate.Delete
                Set rngDuplicate = Nothing
            Else
                rngBookmark.Text = tNewTxt
            End If
            Call .Bookmarks.Add(tBookmarkName, rngBookmark)
        End If
    End With
    Set rngBookmark = Nothing
    Set rngDuplicate = Nothing
End Sub
 
',------------------------------------------------------------------------------------
'| Procedure  : Function GetField
'| ReturnType : Variant
'| DateTime   : 28.02.2011 09:49
'| Author     : Kremm
'| Purpose    : Gibt den Wert aus einem Formularfeld zur|fffd|ck.
'| Remarks    : Es wird versucht, den Wert aus dem dem Feld mit dem |fffd|bergebenen Namen
'|              zu holen, und in den, mit varType |fffd|bergebenen Typ umgewandelt.
'|              - Sollte das Feld nicht vorhanden sein, dann wird der Wert aus
'|                vDafault zur|fffd|ckgegeben. Es wird eine Fehlermeldung angezeigt, au|fffd|er
'|                wenn bNoNotFoundError auf True gesetzt wird.
'|              - Sollte das Feld leer sein, dann wird der Wert aus vDafault zur|fffd|ck-
'|                gegeben. Es wird eine Fehlermeldung angezeigt, au|fffd|er wenn
'|                bNoNullError auf True gesetzt wird.
'|              - Sollte das Feld Daten beinhalten, die nicht zum in varType
'|                |fffd|bergebenen Typ passen, dass wird der Wert aus vDefault
'|                zur|fffd|ckgegeben. Es wird eine Fehlermeldung angezeigt, au|fffd|er wenn
'|                bNoTypeError auf True gesetzt wird.
'`------------------------------------------------------------------------------------
'
Function GetField(doc As Word.Document, tFieldName As String, varType As VbVarType, vDefault As Variant, Optional bNoNotFoundError As Boolean = False, Optional bNoNullError As Boolean = False, Optional bNoTypeError As Boolean = False) As Variant
    Dim tValue                As String
 
    '#### Inhalt des Feldes auslesen und aufbereiten:
    On Error GoTo NotFound
    If FieldExists(doc, tFieldName) Then
        tValue = doc.FormFields(tFieldName).Range.Text
    End If
    tValue = Replace(tValue, ChrW(8194), " ")   '#### En-Space in normales Leerzeichen umwandeln
    tValue = Trim(tValue)
    On Error GoTo 0
 
    If Len(tValue) > 0 Then
        Select Case varType
        Case vbInteger:
            tValue = Replace(tValue, ".", vbNullString)    '### Tausender-Zeichen entfernen
            If IsNumeric(tValue) Then
                GetField = CInt(tValue)
            Else
                GoTo TypeError
            End If
        Case vbLong:
            tValue = Replace(tValue, ".", vbNullString)    '### Tausender-Zeichen entfernen
            If IsNumeric(tValue) Then
                GetField = CLng(tValue)
            Else
                GoTo TypeError
            End If
        Case vbDouble:
            tValue = Replace(tValue, ".", vbNullString)    '### Tausender-Zeichen entfernen
            If IsNumeric(tValue) Then
                GetField = CDblGer(tValue)
            Else
                GoTo TypeError
            End If
        Case vbDate:
            If IsDate(tValue) Then
                GetField = CDate(tValue)
            Else
                GoTo TypeError
            End If
        Case Else:
            GetField = CStr(tValue)
        End Select
    ElseIf Not bNoNullError Then
        Call MsgOutput("Error:" & vbLf & vbLf & "Tncorrect oc " & vbLf & "The form field does not contain any data.", tFieldName, vbCritical)
        GetField = vDefault
    Else
        GetField = vDefault
    End If
    Exit Function
 
NotFound:
    If Not bNoNotFoundError Then
        Call MsgOutput("Error:" & vbLf & vbLf & "incorrect oc " & vbLf & "The form field does not exist.", tFieldName, vbCritical)
    End If
    GetField = vDefault
    Exit Function
 
TypeError:
    If Not bNoTypeError Then
        Call MsgOutput("Error:" & vbLf & vbLf & "incorrect oc " & vbLf & "The form field contains invalid data.", tFieldName, vbCritical)
    End If
    GetField = vDefault
    Exit Function
End Function
 
'------------------------------------------------------------------------------
' Function  : GetBookMarkName
' Author    : Thomas Lutzeier
' Date      : 08.04.2015
' Purpose   : Ermittelt den Namen der aktuellen Bookmark
'------------------------------------------------------------------------------
'
Function GetBookMarkName() As String
    With ThisDocument.Windows(1).Selection
        If .Bookmarks.Count > 0 Then
            GetBookMarkName = .Bookmarks(.Bookmarks.Count).Name
        Else
            GetBookMarkName = ""
        End If
    End With
End Function
 
'---------------------------------------------------------------------------------------
' Procedure : IsInDoc
' Author    : Thomas Lutzeier
' Date      : 06.05.2015
' Purpose   : Boolean, ob in Wort in einem Dokument ist
'---------------------------------------------------------------------------------------
'
Function IsInDoc(oDoc As Word.Document, tText As String) As Boolean
    Dim oRng                    As Word.Range
  
    Set oRng = oDoc.Content
    oRng.Find.Execute FindText:=tText, Forward:=True
    If oRng.Find.Found = True Then
        IsInDoc = True
    Else
        IsInDoc = False
    End If
    Set oRng = Nothing
End Function
  
',--------------------------------------------------------------------------------------
'| Procedure  : Sub ShowLayoutView
'| DateTime   : 20.10.2015 15:30
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
'Sub ShowLayoutView()
'    ActiveWindow.WindowState = wdWindowStateMaximize
'    ActiveWindow.ActivePane.View.ShowAll = Not ActiveWindow.ActivePane.View. _
'                                           ShowAll
'    If ActiveWindow.View.SplitSpecial = wdPaneNone Then
'        ActiveWindow.ActivePane.View.Type = wdPageView
'    Else
'        ActiveWindow.View.Type = wdPageView
'    End If
'End Sub
'---------------------------------------------------------------------------------------
' Procedure : GetIANFromFileName
' Author    : Grube
' Date      : 26.08.2016
' Purpose   : Pr|fffd|fen,ob IAN im Dokumentnamen enthalten ist
'             161202 AG mit tIAN_ETA erweitert
'---------------------------------------------------------------------------------------
'
Public Function GetIANFromFileName(tFilePath As String, ByRef tIAN_ETA As String) As String
    Dim lIndex                As Long
    Dim lCountUnderscore      As Long
    Dim lPosEnd               As Long
    Dim tFileDesc             As String
    Dim tReturn               As String
    Dim tPart                 As String
    Dim tZeichen              As String
      
    tReturn = ""
    If Len(tFilePath) > 0 Then
        lIndex = InStr(1, StrReverse(tFilePath), "\")
        If lIndex > 0 Then
            tFileDesc = Right(tFilePath, lIndex - 1)
        Else
            tFileDesc = tFilePath
        End If
        
        If Len(tFileDesc) > 0 Then
            lPosEnd = InStr(1, LCase(tFileDesc), ".docm") - 1
            '### Speichern der IAN im Dateinamen
            For lIndex = 1 To Len(tFileDesc)
                tPart = Left$(tFileDesc, lIndex)
                If lIndex < 5 And IsNumeric(tPart) And Right(tPart, 1) <> "." Then
                    tReturn = tPart
                    tIAN_ETA = tReturn
                Else
                    tZeichen = Mid$(tFileDesc, lIndex, 1)
                    If tZeichen = "_" Then
                        lCountUnderscore = lCountUnderscore + 1
                    End If
                    If lCountUnderscore > 2 Or lIndex = lPosEnd Then
                        Exit For
                    End If
                    tIAN_ETA = tIAN_ETA & tZeichen
                End If
            Next lIndex
            If lCountUnderscore < 3 Then
                tIAN_ETA = Left$(tFileDesc, lPosEnd)
            End If
        End If
    End If
    GetIANFromFileName = tReturn
End Function
 
',--------------------------------------------------------------------------------------
'| Module     : Function IsVBProjectUnlocked
'| ReturnType : Boolean
'| DateTime   : 20.10.2015 15:30
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function IsVBProjectUnlocked() As Boolean
    On Error GoTo MiscError
    IsVBProjectUnlocked = (ThisDocument.VBProject.Protection = vbext_pp_none)
    Exit Function
MiscError:
    IsVBProjectUnlocked = False
End Function

Public Sub ErrorMessage()
    Dim bDebugSave            As Boolean
    Dim tAusgabe              As String
    bDebugSave = mbDEBUG
    '#### Debugflag in jedem Fall setzen f|fffd|r Logdatei
    mbDEBUG = True
    tAusgabe = "An error has occurred. Please contact the responsible department at Lidl."
    Call MsgOutput(tAusgabe, vbNullString, vbInformation, "Problem")
    'Call Log(tAusgabe & Err.Description, getFilePath(ThisDocument.Path, "lidlerror.txt"))
    mbDEBUG = bDebugSave
End Sub

Public Function Max(val1 As Variant, val2 As Variant) As Variant
    If val1 > val2 Then
        Max = val1
    Else
        Max = val2
    End If
End Function
  
Public Function Min(val1 As Variant, val2 As Variant) As Variant
    If val1 < val2 Then
        Min = val1
    Else
        Min = val2
    End If
End Function
  
 


Attribute VB_Name = "MGlobals"
Option Explicit

Enum E_AB_OPENMODE
    NORMAL = 1                  '#### AB wird normal ge|fffd|ffnet
    XMLIMPORT = 2               '#### ge|fffd|ffnet per XML-Import
End Enum
'#### 170905 AG OpenMode hinzu, damit beim XML-Import keine Meldungen ausgegeben werden
Public mbOpenMode               As E_AB_OPENMODE            '#### OpenMode wird global gespeichert

Public mbDEBUG                  As Boolean                  '#### Schalter zum debuggen (f|fffd|r Meldungen)
Public mbBuildDoc               As Boolean                  '#### Schalter f|fffd|r Speicherung Initial = 1 (auch in den Dokument-Properties)
Public mbIsIntPC                As Boolean                  '#### Schalter f|fffd|r INT-PC
Public mbInitDocument           As Boolean                  '#### Schalter f|fffd|r neues Dokument
Public mbTurnToRed              As Boolean                  '#### Schalter f|fffd|r Protokollierung |fffd|nderungen
Public mbCheckFieldsOnSave      As Boolean                  '#### Schalter f|fffd|r Validierungen beim Speichern
Public gbLockDocumentBeforeSave As Boolean                  '#### Schalter f|fffd|r das DocumentBeforeSave Event
 
'#### L|fffd|nderangaben (Gro|fffd|schrift)
Public mtCurrentUpperCountries() As String

'#### L|fffd|nderzuordnung Bestimmungsort
Public Const COUNTRYDEST1 = "DE OS NL BE FI SE DK GB IE"
Public Const COUNTRYDEST2 = "ES PT"
Public Const COUNTRYDEST3 = "AT GR PL CZ SK HU SI CY BG RO HR CH"

'#### L|fffd|nderbl|fffd|cke
Public Const LB1 = "DE AT CH OS"
Public Const LB2 = "FR"
Public Const LB3 = "GB IE FI SE DK BE NL"
Public Const LB4 = "PL HU SI CZ SK"
Public Const LB5 = "ES IT PT"
Public Const LB6A = "GB IE"
Public Const LB6B = "CY"
Public Const LB7 = "HR RO BG GR CY"

Public Const gctPW = "ABAdmin2016!"

Public Const gctSOFT_CR_LF      As String = ""             '#### ASCII-Code 11
                                                            '#### 180319 AG Daten-Separator f|fffd|r MAKRO und ABs
Public Const gctDATA_SEPARATOR  As String = "|"             '#### Separator f|fffd|r Daten (z.B. Incoterm-Combobox)

Public Const gctTEMPLATE        As String = "*_Template_*_*_*.docm"

Public mDictDeliveryByCountry   As Scripting.Dictionary
Public mDictFormFields          As Scripting.Dictionary
Public mDictFieldsForCalc       As Scripting.Dictionary

Public mFrmProgress             As |fffd|LCL_FProgressNew_x32_64 '#### 180823 AG Anpassungen f|fffd|r 64 Bit
Public mbFrmProgressLoaded      As Boolean

Attribute VB_Name = "MHandleQuali"
Option Explicit

Sub AddColQuali()
    '#### DUMMY!
End Sub

Sub AddRowQuali()
    '#### DUMMY!
End Sub

Sub SubstractColQuali()
    '#### DUMMY!
End Sub

Sub SubstractRowQuali()
    '#### DUMMY!
End Sub
Attribute VB_Name = "MHandleSort"
Option Explicit
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub AddCol
'| DateTime   : 16.07.2018 14:49
'| Author     : Grube
'| Purpose    : F|fffd|gt eine neue Spalte in den Tabellen hinzu
'|              180716 AG Columnanzahlwerte angepasst wg. LSV-Column
'`--------------------------------------------------------------------------------------
'
Sub AddCol()
    Dim oRng                  As Range
    Dim tFFName               As String
    Dim lIndex                As Long
    Dim lRowCount             As Long
    Dim lColCount             As Long
    Dim lActiveTable          As Long
    Dim lFixedCols            As Long
    On Error GoTo exitAddCol
    
    With ThisDocument
        If .Bookmarks.Exists("bmSortierung") Then
            lFixedCols = IIf(.Bookmarks.Exists("ff_Sort_Ma|fffd|e_1"), 5, 3)
            lColCount = .Bookmarks("bmSortierung").Range.Tables(1).Columns.Count
            If .Bookmarks.Exists("ff_Sort_Ma|fffd|e_1") And lColCount >= 11 Then
                Call MsgOutput("The number of allowed sorting columns is limited to 5!", vbNullString, vbInformation)
                Exit Sub
            ElseIf (Not .Bookmarks.Exists("ff_Sort_Ma|fffd|e_1")) And lColCount >= 9 Then
                Call MsgOutput("The number of allowed sorting columns is limited to 5!", vbNullString, vbInformation)
                Exit Sub
            End If
        End If
    
        
        .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
        '#### Aktive Tabelle und Anzahl Zeilen und Spalten
        Call SetSortTableRowColCount(lActiveTable, lRowCount, lColCount)
     
         
        .Application.ScreenUpdating = False
        Call DocumentProtectUnprotect
        '#### Letzte Spalte markieren und splitten
        Set oRng = .Range
        oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(2, lColCount).Range.Start, _
                        End:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
        oRng.Select
        .Windows(1).Selection.Cut
         
        Set oRng = .Range
        oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(2, lColCount).Range.Start, _
                        End:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
        oRng.Select
        .Windows(1).Selection.Cells.Split NumRows:=1, NumColumns:=2, MergeBeforeSplit:=False
        Set oRng = .Range
        oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(2, lColCount).Range.Start, _
                        End:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
        oRng.Select
        .Windows(1).Selection.Paste
        
        '#### Neue letzte Spalte, FormFields einf|fffd|gen
        '###  Start
        Set oRng = .Range
        oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(2, lColCount + 1).Range.Start, _
                        End:=oRng.Tables(lActiveTable).Cell(2, lColCount + 1).Range.End
        oRng.Select
        .Windows(1).Selection.MoveLeft Unit:=wdCharacter, Count:=1
     
        '### Schleife alle Felder
        tFFName = "bm_Country_" & lColCount - 3 + 1
        Call InsertFormField(tFFName, 255, "alphanumeric")
        
        For lIndex = 3 To lRowCount
            Set oRng = .Range
            oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(lIndex, lColCount + 1).Range.Start, _
                            End:=oRng.Tables(lActiveTable).Cell(lIndex, lColCount + 1).Range.End
            oRng.Select
            .Windows(1).Selection.MoveLeft Unit:=wdCharacter, Count:=1
     
            tFFName = "ff_Sortierung_" & lIndex - 2 & "_" & lColCount - 3 + 1
            Call InsertFormField(tFFName, 10, "alphanumeric")
     
        Next
        
        If lColCount > lFixedCols + 1 Then
            '#### Spaltenbreiten
            Set oRng = .Range
            oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(2, lFixedCols + 2).Range.Start, _
                            End:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount + 1).Range.End
            oRng.Select
            If .Windows(1).Selection.Cells.Count > 3 Then
                .Windows(1).Selection.Cells.DistributeWidth
            End If
        End If
        '#### Ende
        .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
        Set oRng = Nothing
        Call DocumentProtectUnprotect
        .Application.ScreenUpdating = True
    End With
    Exit Sub
    
exitAddCol:
    Call ErrorMessage
        Call DocumentProtectUnprotect
    ThisDocument.Application.ScreenUpdating = True
 Exit Sub
 
End Sub
 
Sub InsertFormField(tFFName As String, lFFLength As Long, tEditType As String)
    Dim oField             As FormField
 
    Set oField = ThisDocument.Windows(1).Selection.FormFields.Add(Range:=Selection.Range, Type:=wdFieldFormTextInput)
 
    oField.Name = tFFName
    oField.EntryMacro = "Storetxt"
    oField.ExitMacro = "Checktxt"
    oField.Enabled = True
    oField.OwnHelp = False
    oField.HelpText = ""
    oField.OwnStatus = False
    oField.StatusText = ""
    If tEditType = "alphanumeric" Then
        oField.TextInput.EditType Type:=wdRegularText, Default:="", Format:=""
    Else
        oField.TextInput.EditType Type:=wdNumberText
    End If
    If lFFLength <> 100 Then
        oField.TextInput.Width = lFFLength
    End If
    
    '### Formfields einf|fffd|rben
    oField.Range.Font.Shading.Texture = wdTexture20Percent
    
    Set oField = Nothing
End Sub
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub SubstractCol
'| DateTime   : 16.07.2018 14:50
'| Author     : Grube
'| Purpose    : Entfernt eine Zeile bei allen "Sortierungs"-Tabellen
'|              180716 AG Columnanzahlwerte angepasst wg. LSV-Column
'`--------------------------------------------------------------------------------------
'
Sub SubstractCol()
    Dim oRng As Range
    Dim lIndex As Long
    
    Dim lRowCount             As Long
    Dim lColCount             As Long
    Dim lActiveTable          As Long
    Dim lFixedCols            As Long
    
    With ThisDocument
       .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
       
       lFixedCols = IIf(.Bookmarks.Exists("ff_Sort_Ma|fffd|e_1"), 5, 3)
           
       '#### Aktive Tabelle und Anzahl Zeilen und Spalten
       Call SetSortTableRowColCount(lActiveTable, lRowCount, lColCount)
       '#### Abbruch, wenn nur eine Spalte
       'If lColCount <= 6 Then
       If lColCount <= lFixedCols + 2 Then
           Call MsgOutput("No further column can be deleted!", vbNullString, vbInformation)
           Exit Sub
       End If
    
       .Application.ScreenUpdating = False
       Call DocumentProtectUnprotect
    
       '#### Letzte Spalte markieren und mergen
       Set oRng = .Range
       oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(2, lColCount).Range.Start, _
                       End:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
       oRng.Select
       .Windows(1).Selection.Cut
       For lIndex = 2 To lRowCount
           Set oRng = .Range
           oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(lIndex, lColCount - 1).Range.Start, _
                           End:=oRng.Tables(lActiveTable).Cell(lIndex, lColCount).Range.End
           oRng.Select
           'If lColCount > 4 Then
           If lColCount > lFixedCols Then
               .Windows(1).Selection.Cells.Merge
           End If
       Next
       '#### Spaltenbreiten
       'If lColCount > 5 Then
       If lColCount > lFixedCols + 1 Then
           Set oRng = .Range
            oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(2, lFixedCols + 2).Range.Start, _
                           End:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount - 1).Range.End
           oRng.Select
           'If .Windows(1).Selection.Cells.Count > 3 Then
           If .Windows(1).Selection.Columns.Count > 1 Then
               .Windows(1).Selection.Cells.DistributeWidth
           End If
       End If
       '#### Ende
       .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
       Set oRng = Nothing
       Call DocumentProtectUnprotect
       .Application.ScreenUpdating = True
    End With
End Sub
 
 
'#### 180716 AG Gewicht L|fffd|nge auf 13
Sub AddRow()
    Dim tFFName               As String
    Dim oRng                  As Range
    Dim lIndex                As Long
    Dim lRowCount             As Long
    Dim lColCount             As Long
    Dim lActiveTable          As Long
    Dim lFixedCols            As Long
    
    With ThisDocument
    
       lFixedCols = IIf(.Bookmarks.Exists("ff_Sort_Ma|fffd|e_1"), 5, 3)
       
       .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
       '#### Aktive Tabelle und Anzahl Zeilen und Spalten
       Call SetSortTableRowColCount(lActiveTable, lRowCount, lColCount)
    
       .Application.ScreenUpdating = False
       Call DocumentProtectUnprotect
    
       '#### Letzte Zelle markieren
       Set oRng = .Range
       oRng.SetRange Start:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.Start, _
                       End:=oRng.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
       oRng.Select
    
       .Windows(1).Selection.MoveRight Unit:=wdCell
    
       Call .Windows(1).Selection.MoveRight(Unit:=wdCell)
       tFFName = "ff_Sort_Style_" & lRowCount - 1
       Call InsertFormField(tFFName, 255, "alphanumeric")
       If lFixedCols = 5 Then
           Call .Windows(1).Selection.MoveRight(Unit:=wdCell)
           tFFName = "ff_Sort_Ma|fffd|e_" & lRowCount - 1
           Call InsertFormField(tFFName, 255, "alphanumeric")
       End If
    
       '#### 180713 AG neues LSV-Feld (L|fffd|nge 50)
        Call .Windows(1).Selection.MoveRight(Unit:=wdCell)
        tFFName = "ff_Sort_LSV_" & lRowCount - 1
        Call InsertFormField(tFFName, 150, "alphanumeric")
       
        Call .Windows(1).Selection.MoveRight(Unit:=wdCell)
        '#### 180611 AG Umbennenung der Spalte zu GTIN, L|fffd|nge auf 60
        '#### 180713 AG GTIN L|fffd|nge auf 13
        tFFName = "ff_Sort_EAN_" & lRowCount - 1
        Call InsertFormField(tFFName, 13, "alphanumeric")

       
       If lFixedCols = 5 Then
           Call .Windows(1).Selection.MoveRight(Unit:=wdCell)
           tFFName = "ff_Sort_Gewicht_" & lRowCount - 1
           Call InsertFormField(tFFName, 13, "alphanumeric")
       End If
    
    
       For lIndex = 1 To lColCount - (lFixedCols + 1)
           Call .Windows(1).Selection.MoveRight(Unit:=wdCell)
           tFFName = "ff_Sortierung_" & lRowCount - 1 & "_" & lIndex
           Call InsertFormField(tFFName, 10, "alphanumeric")
       Next
       '#### Ende
       .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
       
       Call SetSortTableRowColCount(lActiveTable, lRowCount, lColCount)
    
       oRng.SetRange Start:=.Tables(lActiveTable).Cell(lRowCount, 1).Range.Start, _
                           End:=.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
       Call ModFormFieldValues(oRng, True)
       Set oRng = Nothing
       
       Call DocumentProtectUnprotect
       .Application.ScreenUpdating = True
    End With
End Sub
 
Sub SubstractRow()
    Dim oRng                  As Range
    Dim lRowCount             As Long
    Dim lColCount             As Long
    Dim lActiveTable          As Long
    
    With ThisDocument
       .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
       '#### Aktive Tabelle und Anzahl Zeilen und Spalten
       Call SetSortTableRowColCount(lActiveTable, lRowCount, lColCount)
    
       If lRowCount = 4 Then
           Call MsgOutput("No further row can be deleted!", vbNullString, vbInformation)
           Exit Sub
       End If
    
       .Application.ScreenUpdating = False
       Call DocumentProtectUnprotect
       Set oRng = .Range
       
       oRng.SetRange Start:=.Tables(lActiveTable).Cell(lRowCount, 1).Range.Start, _
                           End:=.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
       Call ModFormFieldValues(oRng, False)
       
       '#### Letzte Zelle markieren
       oRng.SetRange Start:=.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.Start, _
                       End:=.Tables(lActiveTable).Cell(lRowCount, lColCount).Range.End
       oRng.Select
    
       .Windows(1).Selection.Rows.Delete
    
       '#### Ende
       .Windows(1).Selection.GoTo What:=wdGoToBookmark, Name:="bm_Country_1"
       Set oRng = Nothing
       Call DocumentProtectUnprotect
       .Application.ScreenUpdating = True
    End With
End Sub
 
Sub SetSortTableRowColCount(ByRef lActiveTable As Long, ByRef lRowCount As Long, ByRef lColCount As Long)
    Dim lIndex                As Long
    With ThisDocument
        For lIndex = 1 To .Tables.Count
            If .Tables(lIndex).Range.IsEqual(.Bookmarks("bmSortierung").Range.Tables(1).Range) Then
                lActiveTable = lIndex
                Exit For
            End If
        Next lIndex
        lRowCount = .Tables(lActiveTable).Rows.Count
        lColCount = .Tables(lActiveTable).Columns.Count
    End With
End Sub
 
 


Attribute VB_Name = "MHandleVBO"
Option Explicit

Private mObjTable                As Word.Table

'------------------------------------------------------------------------------
' Procedure : AddRowVBO
' Author    : Grube
' Date      : 05.03.2018
' Purpose   : neue Zeile hinzuf|fffd|gen
'             180405 AG keine f|fffd|hrende 0 mehr
'             180425 AG L|fffd|nge von StyleNr und Groesse auf 50
'             181211 AG L|fffd|nge von Stylebezeichnung auf 120
'------------------------------------------------------------------------------
'
Sub AddRowVBO()
    Dim oRow                  As Word.Row
    Dim tNumber               As String
    
    With ThisDocument
        If .Bookmarks.Exists("bm_VBO_Table") Then
            Word.System.Cursor = wdCursorWait
            Set mObjTable = .Bookmarks("bm_VBO_Table").Range.Tables(1)
            .Application.ScreenUpdating = False
            Call DocumentProtectUnprotect
            Set oRow = mObjTable.Rows.Add
            mObjTable.Cell(mObjTable.Rows.Count, 1).Borders(wdBorderTop) = wdLineStyleNone
            tNumber = CStr(mObjTable.Rows.Count - 1)
            With oRow
                Call SetField(ThisDocument, .Cells(2).Range, "ff_VBO_Style_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=50)
                Call SetField(ThisDocument, .Cells(3).Range, "ff_VBO_StyleBez_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=120)
                Call SetField(ThisDocument, .Cells(4).Range, "ff_VBO_Groesse_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=50)
                Call SetField(ThisDocument, .Cells(5).Range, "ff_VBO_LSV_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=150)
                Call SetField(ThisDocument, .Cells(6).Range, "ff_VBO_Menge_OSDE_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(7).Range, "ff_VBO_Menge_OSBE_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(8).Range, "ff_VBO_Menge_OSNL_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(9).Range, "ff_VBO_Menge_OSCZ_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(10).Range, "ff_VBO_Menge_OSES_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(11).Range, "ff_VBO_Menge_OSGB_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(12).Range, "ff_VBO_Menge_OSFR_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(13).Range, "ff_VBO_Menge_OSPL_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
                Call SetField(ThisDocument, .Cells(14).Range, "ff_VBO_Menge_OSSK_" & tNumber, tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7)
            End With
            Set oRow = Nothing
            Call DocumentProtectUnprotect
            .Application.ScreenUpdating = True
            Word.System.Cursor = wdCursorNormal
        End If
    End With
End Sub
    
'------------------------------------------------------------------------------
' Procedure : SubstractRowVBO
' Author    : Grube
' Date      : 05.03.2018
' Purpose   : letzte Zeile entfernen
'------------------------------------------------------------------------------
'
Sub SubstractRowVBO()
    With ThisDocument
        If .Bookmarks.Exists("bm_VBO_Table") Then
            Word.System.Cursor = wdCursorWait
            .Application.ScreenUpdating = False
            Call DocumentProtectUnprotect
            Set mObjTable = .Bookmarks("bm_VBO_Table").Range.Tables(1)
            If mObjTable.Rows.Count > 2 Then
                Call mObjTable.Rows(mObjTable.Rows.Count).Delete
            Else
                Call MsgOutput("The number of allowed rows is limited to 1!", vbNullString, vbInformation)
            End If
            Call DocumentProtectUnprotect
            .Application.ScreenUpdating = True
            Word.System.Cursor = wdCursorWait
        End If
    End With
End Sub


Private Sub SetText(oCell As Word.Cell, tText As String, Optional lColor As Long = -1, Optional bAlignLeft As Boolean = False)
    oCell.Range.ParagraphFormat.Alignment = IIf(bAlignLeft, wdAlignParagraphLeft, wdAlignParagraphCenter)
    If lColor <> -1 Then
        oCell.Range.Font.ColorIndex = wdRed
    End If
    
    oCell.Range.Text = tText
End Sub

Private Sub SetField(oDoc As Word.Document, oRange As Word.Range, tFieldName As String, Optional tDefaultText As String = "", _
                     Optional tCalcText As String = "", Optional tEntryMacro As String = "", Optional tExitMacro As String = "", _
                     Optional bEditable As Boolean = True, Optional lLength As Long = 10, Optional tFormat As String = vbNullString, _
                     Optional bCalcOnExit As Boolean = False, Optional lParagraphAlign As Long = wdAlignParagraphCenter)
    Dim oField              As Word.FormField
    Call oRange.MoveEnd(wdCharacter, -1)
    oRange.ParagraphFormat.Alignment = lParagraphAlign
    Set oField = oDoc.FormFields.Add(Range:=oRange, Type:=wdFieldFormTextInput)
    With oField
        .Name = tFieldName
        .TextInput.Width = lLength
        .EntryMacro = tEntryMacro
        .ExitMacro = tExitMacro
        .Enabled = bEditable
        .OwnHelp = False
        .HelpText = ""
        .OwnStatus = False
        .StatusText = ""
        .CalculateOnExit = bCalcOnExit
        If Len(tCalcText) > 0 Then
            Call .TextInput.EditType(wdCalculationText, tCalcText, tFormat, False)
        Else
            Call .TextInput.EditType(wdRegularText, tDefaultText, "")
        End If
    End With 'oField
    'oRange.Select
    'Call oDoc.Windows(1).Selection.MoveLeft(Unit:=wdCharacter, Count:=1)
    'Call oDoc.Windows(1).Selection.Collapse
    Set oField = Nothing
End Sub

Private Sub SetButton(oDoc As Word.Document, oRange As Word.Range, tFieldName As String, Optional tDefaultText As String = "", _
                     Optional tCalcText As String = "", Optional tEntryMacro As String = "", Optional tExitMacro As String = "", _
                     Optional bEditable As Boolean = True, Optional lLength As Long = 10, Optional tFormat As String = vbNullString)
    Dim oField              As Word.Field
    ' http://www.vbarchiv.net/tipps/details.php?id=2405&print=1
    
    Call oRange.MoveEnd(wdCharacter, -1)
    oRange.ParagraphFormat.Alignment = wdAlignParagraphCenter
    Set oField = oDoc.Fields.Add(Range:=oRange, Type:=wdFieldMacroButton, Text:=" no + ", PreserveFormatting:=False)
    With oField
        .Code.Borders(wdBorderLeft) = wdLineStyleSingle
        .Code.Shading.BackgroundPatternColor = wdColorGray10
        '.Code.Text = "MACROBUTTON " & "Test "
        
        '.ob
        '.result.Borders(wdBorderLeft) = wdLineStyleSingle
        '.InlineShape.Borders(wdBorderBorder) = wdLineStyleSingle
        
        
        '.Name = tFieldName
        '.EntryMacro = tEntryMacro
        '.ExitMacro = tExitMacro
        '.Enabled = bEditable
        '.OwnHelp = False
        '.HelpText = ""
        '.OwnStatus = False
        '.StatusText = ""
        '.CalculateOnExit = True
'        If Len(tCalcText) > 0 Then
'            Call .TextInput.EditType(wdCalculationText, tCalcText, tFormat, False)
'        Else
'            Call .TextInput.EditType(wdRegularText, tDefaultText, "")
'        End If
'        .TextInput.Width = lLength
    End With 'oField
    'oRange.Select
    'Call oDoc.Windows(1).Selection.MoveLeft(Unit:=wdCharacter, Count:=1)
    'Call oDoc.Windows(1).Selection.Collapse
    Set oField = Nothing
End Sub


Sub CreateTable(oDoc As Word.Document)
    Dim tFontSize               As String
    Dim oRng                    As Word.Range
    Dim lTabRowCount            As Long
    Dim lTabColCount            As Long
    
    tFontSize = "8"
    lTabRowCount = 4
    lTabColCount = 12
    Set oRng = oDoc.Range

    Set mObjTable = oRng.Tables.Add(Range:=oDoc.Windows(1).Selection.Range, NumRows:=lTabRowCount, NumColumns:=lTabColCount, _
                                        DefaultTableBehavior:=wdWord8TableBehavior + wdStyleTypeTable)
                                        
   ' Call SetBookmark(oDoc, mObjTable.Rows(1).Cells(1).Range, "bm_Temp_000")
    
     With mObjTable
        .Range.Font.Name = "Calibri"
        .Range.Font.Size = tFontSize
        .Borders(wdBorderBottom).LineStyle = wdLineStyleSingle
        .Borders(wdBorderTop).LineStyle = wdLineStyleSingle
        .Borders(wdBorderLeft).LineStyle = wdLineStyleSingle
        .Borders(wdBorderRight).LineStyle = wdLineStyleSingle
        '#### Einzug f|fffd|r Tabelle
        '.Rows.LeftIndent = oDoc.Application.CentimetersToPoints(1.15)
        '#### kein Seitenumbruch innerhalb der Tabelle
        .Rows.AllowBreakAcrossPages = False
        '#### Kennzeichen 'automat. Gr|fffd||fffd|en|fffd|nderung zulassen' entfernen
        .AllowAutoFit = False
        '#### erste Zeile formatieren
        .Rows(1).Shading.ForegroundPatternColor = wdColorAutomatic
        .Rows(1).Shading.BackgroundPatternColor = wdColorGray10
        .Rows(1).Range.Font.Bold = True
        '#### kein Seitenumbruch innerhalb der Tabelle
        .Rows(1).Range.ParagraphFormat.KeepTogether = True
        .Rows(1).Range.ParagraphFormat.KeepWithNext = True
        
        .Cell(1, 1).Shading.BackgroundPatternColor = wdColorWhite
        .Cell(1, 1).Borders(wdBorderBottom) = wdLineStyleNone
        .Cell(2, 1).Borders(wdBorderBottom) = wdLineStyleNone
        .Cell(3, 1).Borders(wdBorderBottom) = wdLineStyleNone
        .Columns(1).Borders(wdBorderLeft).LineStyle = wdLineStyleNone
        .Columns(1).Borders(wdBorderTop).LineStyle = wdLineStyleNone
        .Columns(1).Borders(wdBorderBottom).LineStyle = wdLineStyleNone
        
        '#### Spaltenbreite festlegen
        Call SetWidth
        '#### Text setzen
        Call SetText(.Cell(1, 2), "Style_Nr")
        Call SetText(.Cell(1, 3), "Style_Bezeichung")
        Call SetText(.Cell(1, 4), "Gr|fffd||fffd|e")
        Call SetText(.Cell(1, 5), "LSV")
        Call SetText(.Cell(1, 6), "OSDE")
        Call SetText(.Cell(1, 7), "OSBE")
        Call SetText(.Cell(1, 8), "OSNL")
        Call SetText(.Cell(1, 9), "OSCZ")
        Call SetText(.Cell(1, 10), "OSES")
        Call SetText(.Cell(1, 11), "OSGB")
        Call SetText(.Cell(1, 12), "OSFR")
        
        Call SetField(oDoc, .Rows(2).Cells(2).Range, "ff_Preis_DE", tEntryMacro:="Storetxt", tExitMacro:="Checktxt")
        Call SetButton(oDoc, .Rows(3).Cells(3).Range, "", "+", tEntryMacro:="AddRowVBO", tExitMacro:="")
    End With
    
End Sub

Sub SetWidth()
    If ThisDocument.Bookmarks.Exists("bm_VBO_Table") Then
        Word.System.Cursor = wdCursorWait
        Set mObjTable = ThisDocument.Bookmarks("bm_VBO_Table").Range.Tables(1)
        With mObjTable
            .Rows.LeftIndent = ThisDocument.Application.CentimetersToPoints(0.31)
            '#### Spaltenbreite festlegen
            .Columns(1).Width = ThisDocument.Application.InchesToPoints(0.3)
            .Columns(2).Width = ThisDocument.Application.InchesToPoints(0.66)
            .Columns(3).Width = ThisDocument.Application.InchesToPoints(1.05)
            .Columns(4).Width = ThisDocument.Application.InchesToPoints(0.37)
            .Columns(5).Width = ThisDocument.Application.InchesToPoints(0.66)
            .Columns(6).Width = ThisDocument.Application.InchesToPoints(0.58)
            .Columns(7).Width = ThisDocument.Application.InchesToPoints(0.58)
            .Columns(8).Width = ThisDocument.Application.InchesToPoints(0.58)
            .Columns(9).Width = ThisDocument.Application.InchesToPoints(0.58)
            .Columns(10).Width = ThisDocument.Application.InchesToPoints(0.58)
            .Columns(11).Width = ThisDocument.Application.InchesToPoints(0.58)
            .Columns(12).Width = ThisDocument.Application.InchesToPoints(0.58)
        End With
    End If
End Sub

'Sub CHARGETEST()
'    Dim oRng                    As Word.Range
'    With ThisDocument
'        If .Bookmarks.Exists("bm_IAN_CHARGE") Then
'                Word.System.Cursor = wdCursorWait
'                Set mObjTable = .Bookmarks("bm_IAN_CHARGE").Range.Tables(1)
'
'                mObjTable.TopPadding = 0
'                mObjTable.BottomPadding = 0
'                mObjTable.LeftPadding = 3
'                mObjTable.RightPadding = 4
'                mObjTable.Style.ParagraphFormat.SpaceAfter = 0
'                mObjTable.Style.Font.Size = 16
'                mObjTable.Style.Font.Bold = True
'                mObjTable.Borders(wdBorderLeft).LineWidth = wdLineWidth025pt
'                mObjTable.Borders(wdBorderRight).LineWidth = wdLineWidth025pt
'                mObjTable.Borders(wdBorderTop).LineWidth = wdLineWidth025pt
'                mObjTable.Borders(wdBorderBottom).LineWidth = wdLineWidth025pt
'                mObjTable.Cell(3, 1).Borders(wdBorderTop) = wdLineWidth025pt
'                mObjTable.Rows.Height = 22.68       ' H|fffd|he 0,8 cm
'                mObjTable.Rows(3).Height = 16.992   ' H|fffd|he 0,6 cm
'                mObjTable.Rows(1).Cells(1).Width = .Application.InchesToPoints(0.4)
'                mObjTable.Rows(1).Cells(2).Width = .Application.InchesToPoints(1.45)
'                mObjTable.Rows(1).Cells(2).Range.ParagraphFormat.Alignment = wdAlignParagraphRight
'                mObjTable.Rows(2).Cells(1).Width = .Application.InchesToPoints(0.8)
'                mObjTable.Rows(2).Cells(2).Width = .Application.InchesToPoints(1.05)
'                mObjTable.Rows(2).Cells(2).Range.ParagraphFormat.Alignment = wdAlignParagraphRight
'                mObjTable.Rows(3).Cells(1).Width = .Application.InchesToPoints(1.85)
'                mObjTable.Rows(3).Range.Style.Font.Size = 11
'                mObjTable.Cell(1, 1).VerticalAlignment = wdCellAlignVerticalCenter
'                mObjTable.Cell(1, 2).VerticalAlignment = wdCellAlignVerticalCenter
'                mObjTable.Cell(2, 1).VerticalAlignment = wdCellAlignVerticalCenter
'                mObjTable.Cell(2, 2).VerticalAlignment = wdCellAlignVerticalCenter
'                mObjTable.PreferredWidth = .Application.InchesToPoints(1.85)
'
'                Call SetText(mObjTable.Rows(1).Cells(1), "IAN:", bAlignLeft:=True)
'                Set oRng = mObjTable.Cell(1, 2).Range
'                Call SetField(ThisDocument, oRng, "ff_Einkaeufer", tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=3, lParagraphAlign:=wdAlignParagraphRight)
'                Set oRng = mObjTable.Cell(1, 2).Range
'                Call oRng.Collapse(wdCollapseEnd)
'                Call oRng.Move(unit:=wdCharacter, Count:=-1)
'
'                Call oRng.InsertBefore("  ")
''                'Call oRng.Move(unit:=wdCharacter, Count:=-1)
'
'                Call oRng.Collapse(wdCollapseEnd)
'                Call SetField(ThisDocument, oRng, "ff_Interne_Art_Nr", tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=7, lParagraphAlign:=wdAlignParagraphRight)
'
'                Call SetText(mObjTable.Rows(2).Cells(1), "CHARGE:", bAlignLeft:=True)
'                Call SetField(ThisDocument, mObjTable.Rows(2).Cells(2).Range, "ff_Charge_Nr", tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=5, lParagraphAlign:=wdAlignParagraphRight)
'
'                Set oRng = mObjTable.Cell(3, 1).Range
'                oRng.Font.Size = 11
'                Call SetText(mObjTable.Cell(3, 1), "fr|fffd|hester LT Land:  ", bAlignLeft:=True)
'
'                Call oRng.Collapse(wdCollapseEnd)
'                Call oRng.Move(unit:=wdCharacter, Count:=-1)
'                Call SetField(ThisDocument, oRng, "ff_Head_LT_Week", tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=2)
'                Set oRng = mObjTable.Cell(3, 1).Range
'                Call oRng.Collapse(wdCollapseEnd)
'                Call oRng.Move(unit:=wdCharacter, Count:=-1)
'                Call oRng.InsertBefore(" /  ")
'                Call oRng.Collapse(wdCollapseEnd)
'                Call SetField(ThisDocument, oRng, "ff_Head_LT_Year", tEntryMacro:="Storetxt", tExitMacro:="Checktxt", lLength:=2)
'                Set oRng = Nothing
'        End If
'    End With
'End Sub

Attribute VB_Name = "MModForm"
Option Explicit

Public mtContenttxt           As String

'------------------------------------------------------------------------------
' Procedure : SetFieldResult
' Author    : Grube
' Date      : 09.02.2016
' Purpose   : Setzen des Feldtextes - auch bei langen Strings
'------------------------------------------------------------------------------
'
Sub SetFieldResult(oField As Word.FormField, tResult As String)
    Dim oFormField              As cFormField
    '#### 180427 AG f|fffd|r neu angelegte Zeilen (z.B. VBO-Tabelle) Dictionary neu f|fffd|llen
    If Not mDictFormFields.Exists(oField.Name) Then
        Call GetFormFieldValues(ThisDocument)
    End If
    Set oFormField = mDictFormFields.Item(oField.Name)
    '#### 171108 AG f|fffd|r automatische XML-Bef|fffd|llung erg|fffd|nzt
    oFormField.SetFormFieldValueNew (tResult)
    If Len(tResult) > 254 Then
        oField.Range.Fields(1).result.Text = tResult
    Else
        oField.result = tResult
    End If
    Set oFormField = Nothing
End Sub


'------------------------------------------------------------------------------
' Procedure : SetEdited
' Author    : Grube
' Date      : 22.10.2015
' Purpose   : Setzen eines Edited Flag, um alle |fffd|nderungen zu erfassen
'             (Checkbox manuell zur|fffd|cksetzen)
'------------------------------------------------------------------------------
'
Sub SetEdited()
    Dim tBookmarkName         As String
    Dim tFieldContent         As String
    Dim oField                As FormField
    Dim oFormField            As cFormField

    With ThisDocument
        tBookmarkName = GetBookMarkName()
        If Not (Len(tBookmarkName) > 0 And .Bookmarks.Exists(tBookmarkName) And FieldExists(ThisDocument, tBookmarkName)) Then Exit Sub
        Set oField = .FormFields(tBookmarkName)
        tFieldContent = oField.result
    End With
    If mDictFormFields.Exists(tBookmarkName) Then
        Set oFormField = mDictFormFields.Item(tBookmarkName)
        Call oFormField.SetFormFieldEdited(True)
    End If
    Set oField = Nothing
    Set oFormField = Nothing
End Sub


',--------------------------------------------------------------------------------------
'| Module     : Procedure Checktxt
'| DateTime   : 30.12.2015 10:15
'| Author     : Grube / M. Bauer
'| Purpose    : Zentrale Routine zur Ablaufsteuerung der FormFields
'`--------------------------------------------------------------------------------------
Sub Checktxt()
    Dim oField                As FormField
    Dim oEnableField          As FormField
    Dim tBookmarkName         As String
    Dim tFieldContent         As String
    Dim bIsGesField           As Boolean
    Dim bIsKolliField         As Boolean
    Dim tKolliValue           As String
    Dim tTotalValue           As String
    Dim tKolliName            As String
    Dim tTotalName            As String
    
    
    On Error GoTo Err_Checktxt
    
    With ThisDocument
        '### Verhindert ein Runterspringen in ein vorheriges FormField, nach dem Klick in ein weit entferntes FormField
        .Parent.ScreenUpdating = False
        
        tBookmarkName = GetBookMarkName()
        If Not (Len(tBookmarkName) > 0 And .Bookmarks.Exists(tBookmarkName) And FieldExists(ThisDocument, tBookmarkName)) Then GoTo EarlyExit
        
        If tBookmarkName <> "bm_PreisKomplex" Then
        
            '#### Reanimation, wenn Makro deinitialisiert wurde
            If Not IsArrayValid(mtCurrentUpperCountries) Then
                Call Refresh_Globals
            Else
                '#### neu laden, wenn direkt nach Erzeugung editiert wird.
                If UBound(mtCurrentUpperCountries) < 1 Then
                    Call Refresh_Globals
                End If
            End If
            
            '#### Reanimation, wenn Makro deinitialisiert wurde
             If mDictFormFields Is Nothing Then
                Call GetFormFieldValues(ThisDocument)
            End If
            
            Set oField = .FormFields(tBookmarkName)
        
            '#### harte Returns (nicht erlaubt) durch Soft Linefeeds ersetzen
            If InStr(oField.result, Chr(13)) > 0 Then
                Call SetFieldResult(oField, MaxReplace(oField.result, Chr(13), Chr(11)))
            End If
            If mDictFormFields.Exists(tBookmarkName) Then
                If mDictFormFields.Item(tBookmarkName).GetIsCatalog() And mDictFormFields.Item(tBookmarkName).GetFormFieldValueNew() <> oField.result Then
                    '#### 171109 AG Katalogfelder mit aktuellem Wert versorgen
                    Call mDictFormFields.Item(tBookmarkName).SetFormFieldValueNew(oField.result)
                End If
            End If
            
            '#### Behandlung f|fffd|r L|fffd|ndermengen
            bIsGesField = (Mid$(oField.Name, 1, 15) = "ff_L_Ges_Menge_")
            '#### 180307 AG VBO-Feldvalidierung hinzu
            bIsKolliField = (Mid$(oField.Name, 1, 11) = "ff_L_Kolli_") Or (Left$(tBookmarkName, 12) = "ff_VBO_Menge")
        
        
            '#### Pr|fffd|fen, ob valider Wert
            If check_Bookmark_Value(tBookmarkName, oField.result, bIsGesField, bIsKolliField) = False Then
                Call SetFieldResult(oField, mtContenttxt)
                GoTo EarlyExit
            End If
            
            tFieldContent = oField.result
            '#### Exit, wenn keine |fffd|nderung oder wenn ung|fffd|ltiger Wert
            If tFieldContent = mtContenttxt Then GoTo EarlyExit
            '#### 161010 AG Rechtschreibpr|fffd|fung nur f|fffd|r Textfelder, wenn nicht numerisch
            If Not (Left$(oField.Name, 3) = "dd_") And oField.TextInput.Type = wdRegularText Then
                Call CheckSpelling(.Bookmarks(oField.Name))
            End If
            If bIsKolliField Or _
                bIsGesField Then
                
                If bIsGesField = True Then
                    tKolliName = "ff_L_Kolli_" & Mid(tBookmarkName, Len("ff_L_Ges_Menge_") + 1)
                    If .Bookmarks.Exists(tKolliName) Then
                        tKolliValue = .FormFields(tKolliName).result
                        
                        If tKolliValue <> "" And tFieldContent <> "" Then
                            If DivideValue(CLng(MakeNumeric(tFieldContent)), CLng(MakeNumeric(tKolliValue))) = 0 Then
                                .FormFields(tBookmarkName).result = mtContenttxt
                                GoTo EarlyExit
                            End If
                        End If
                    End If
                Else
                    tTotalName = "ff_L_Ges_Menge_" & Mid(tBookmarkName, Len("ff_L_Kolli_") + 1)
                    If .Bookmarks.Exists(tTotalName) Then
                        tTotalValue = .FormFields(tTotalName).result
                        
                        If tTotalValue <> "" And tFieldContent <> "" Then
                            If DivideValue(CLng(MakeNumeric(tTotalValue)), CLng(MakeNumeric(tFieldContent))) = 0 Then
                                .FormFields(tBookmarkName).result = mtContenttxt
                                GoTo EarlyExit
                            End If
                        End If
                    End If
                End If
                
                Call CalcKumMengen(oField, tBookmarkName, bIsGesField, bIsKolliField)
            End If
            
            '#### Neue Berechnung von Preis mit GP
            If tBookmarkName = "ff_Preis_Netto" Or tBookmarkName = "ff_Kosten_GP" Then
                Call CalcPreisMitGP
            ElseIf Left(tBookmarkName, 9) = "ff_Preis_" Then
                Call CalcSumme(Mid(tBookmarkName, 9))
            ElseIf Left(tBookmarkName, 11) = "ff_Verpack_" Then
                Call CalcSumme(Mid(tBookmarkName, 11))
            End If
            
            '#### Inspection Center
            Call CheckInspectionCenter(ThisDocument, oField)
         
            '#### Checkboxen ankreuzen und Felder rot
            If mbTurnToRed Then
                Call MarkChanges(oField, tBookmarkName)
            End If
        End If
    End With
EarlyExit:
    With ThisDocument
        Call DocLock(ThisDocument)
        .Parent.ScreenUpdating = True
    End With
    
    Set oField = Nothing
    Set oEnableField = Nothing
    Exit Sub
    
Err_Checktxt:
    Call ErrorMessage
    With ThisDocument
        Call DocLock(ThisDocument)
        .Parent.ScreenUpdating = True
    End With
    Exit Sub
    Resume
End Sub

'------------------------------------------------------------------------------
' Procedure : Storetxt
' Author    : Grube
' Date      : 24.05.2018
' Purpose   : Speichert den Inhalt einer Textmarke beim Hingehen
'             180524 AG Checkboxen (chkOK und chkNotOk) l|fffd|sen sich gegenseitig aus
'------------------------------------------------------------------------------
'
Sub Storetxt()
    Dim tBookmarkName         As String
    
    On Error GoTo Err_Storetxt
    tBookmarkName = GetBookMarkName()
    With ThisDocument
        If .Windows(1).Selection.Bookmarks.Count > 0 And FieldExists(ThisDocument, tBookmarkName) Then
            mtContenttxt = .FormFields(tBookmarkName).result
        Else
            mtContenttxt = ""
        End If
        Select Case tBookmarkName
            Case "chkOk":
                If mtContenttxt = "1" Then
                    .FormFields("chkNotOk").CheckBox.Value = "0"
                Else
                    .FormFields("chkNotOk").CheckBox.Value = "1"
                End If
         Case "chkNotOk":
                If mtContenttxt = "1" Then
                    .FormFields("chkOk").CheckBox.Value = "0"
                Else
                    .FormFields("chkOk").CheckBox.Value = "1"
                End If
        End Select
    End With
    Exit Sub
Err_Storetxt:
    Call ErrorMessage
    Exit Sub
End Sub


'---------------------------------------------------------------------------------------
' Procedure : SpecBMContent
' Author    : Thomas Lutzeier
' Date      : 04.04.2015
' Purpose   : Spezielle Vorbelegung einzelner Felder
'---------------------------------------------------------------------------------------
'
Function SpecBMContent(tBookmarkName As String) As String
    SpecBMContent = mtContenttxt
    Select Case tBookmarkName
    Case "dd_Ursprung"
        SpecBMContent = "nein"
    Case "dd_Hkl"
        SpecBMContent = "Bitte ausw|fffd|hlen!"
    Case "dd_Verpackung"
        SpecBMContent = "Bitte ausw|fffd|hlen!"
    Case "dd_Umverpackung"
        SpecBMContent = "Bitte ausw|fffd|hlen!"
    Case "dd_Sortenrein"
        SpecBMContent = "Bitte ausw|fffd|hlen!"
    Case "dd_Batterie"
        SpecBMContent = "Bitte ausw|fffd|hlen!"
    Case "dd_Sich_Datenblatt"
        SpecBMContent = "Bitte ausw|fffd|hlen!"
    Case "dd_Gefahrgut"
        SpecBMContent = "Bitte ausw|fffd|hlen!"
    End Select
End Function

'------------------------------------------------------------------------------
' Function  : check_Bookmark_Value
' Author    : Grube
' Date      : 26.10.2015
' Purpose   : Validierung des Inhalts einer speziellen Bookmark
'------------------------------------------------------------------------------
'
Function check_Bookmark_Value(tBookmarkName As String, tFieldResult As String, bIsGesField As Boolean, bIsKolliField As Boolean) As Boolean

    '#### Pr|fffd|fungen anhand des tBookmarkName
    Select Case tBookmarkName
            '#### Kontrolle auf Numerisch und Sonderzeichen (wie z.B. Leerzeichen)
            '             "ff_B_Kolli_Gewicht" entfernt AG 160229
        Case "ff_Anzahl", _
             "ff_PaymentFH", _
             "ff_LT_Zentral_J", "ff_LT_Zentral_J2", _
             "ff_LT_Zentral_KW", "ff_LT_Zentral_KW2", _
             "ff_Head_LT_Week", "ff_Head_LT_Year":
            check_Bookmark_Value = IsPositivNumeric(tBookmarkName, tFieldResult, False)
            '#### Leer und Sonderzeichen entfernen
            ThisDocument.FormFields(tBookmarkName).result = MakeNumeric(tFieldResult)
            GoTo Check_Bookmark_Value_False

        Case "ff_Pal_1", "ff_Pal_2", "ff_Pal_3", _
             "ff_Interne_Art_Nr", "ff_Charge_Nr":
            check_Bookmark_Value = IsPositivNumeric(tBookmarkName, tFieldResult)
            GoTo Check_Bookmark_Value_False

        Case "ff_Kosten_GP":
            '#### Bei Einfacher Preistabelle ist auch bei Verpackung die Eingabe von 0 zul|fffd|ssig
            If InStr(tFieldResult, ".") > 0 Then
                Call MsgOutput("The use of point is not allowed. " & vbLf & "Please use a comma as a decimal separator.", tBookmarkName, vbExclamation, "wrong input")
                'Call MsgOutput("Die Verwendung von Punkt ist nicht erlaubt." & vbCrLf & "Bitte verwenden sie ein Komma als Dezimaltrennzeichen.", tBookmarkName, vbExclamation, "Falsche Eingabe")
                GoTo Check_Bookmark_Value_False
            Else
                check_Bookmark_Value = IsPositivNumeric(tBMName:=tBookmarkName, tValue:=tFieldResult, bAllowZero:=True)
                If check_Bookmark_Value = True And tFieldResult <> "" Then
                    ThisDocument.FormFields(tBookmarkName).result = Format_3NK(tFieldResult)
                End If
                GoTo Check_Bookmark_Value_False
            End If
            
        Case "ff_Einkaeufer"
            If Not isOnlyText(tFieldResult) Then
                Call MsgOutput("Only letters are allowed.", vbNullString, vbInformation)
                GoTo Check_Bookmark_Value_False
            End If
    End Select

    '#### Pr|fffd|fung bei Liefermengenfelder
    If bIsKolliField Or _
       bIsGesField Then
        check_Bookmark_Value = IsPositivNumeric(tBookmarkName, tFieldResult, False, False)
        GoTo Check_Bookmark_Value_False
    End If

    '#### Bei Komplexer Preistabelle ist auch bei Verpackung die Eingabe von 0 zul|fffd|ssig
    If Left$(tBookmarkName, 11) = "ff_Verpack_" Then
        If InStr(tFieldResult, ".") > 0 Then
            Call MsgOutput("The use of point is not allowed. " & vbLf & "Please use a comma as a decimal separator.", tBookmarkName, vbExclamation, "wrong input")
            'MsgBox "Die Verwendung von Punkt ist nicht erlaubt." & vbLf & "Bitte verwenden sie ein Komma als Dezimaltrennzeichen.", vbExclamation, "Falsche Eingabe"
            GoTo Check_Bookmark_Value_False
        Else
            check_Bookmark_Value = IsPositivNumeric(tBMName:=tBookmarkName, tValue:=tFieldResult, bAllowZero:=True, bAllowDecimals:=True)
            If check_Bookmark_Value = True And tFieldResult <> "" Then
                ThisDocument.FormFields(tBookmarkName).result = Format_3NK(tFieldResult)
            End If
            GoTo Check_Bookmark_Value_False
        End If
    End If

    '#### Pr|fffd|fung f|fffd|r alle Preisfelder (au|fffd|er ff_Preis_Einheit und ff_Preis_Mit_GP)
    If Left$(tBookmarkName, 8) = "ff_Preis" And tBookmarkName <> "ff_Preis_Einheit" And tBookmarkName <> "ff_Preis_Mit_GP" Then
        If InStr(tFieldResult, ".") > 0 Then
            Call MsgOutput("The use of point is not allowed. " & vbLf & "Please use a comma as a decimal separator.", tBookmarkName, vbExclamation, "wrong input")
            'MsgBox "Die Verwendung von Punkt ist nicht erlaubt." & vbCrLf & "Bitte verwenden sie ein Komma als Dezimaltrennzeichen.", vbExclamation, "Falsche Eingabe"
        Else
            check_Bookmark_Value = IsPositivNumeric(tBookmarkName, tFieldResult, False)
            If check_Bookmark_Value = True And tFieldResult <> "" Then
                ThisDocument.FormFields(tBookmarkName).result = Format_3NK(tFieldResult)
            End If
        End If
        GoTo Check_Bookmark_Value_False
    End If

    '#### Pr|fffd|fungen f|fffd|r spezielle FormFields
    '#### 180611 AG Pr|fffd|fung auf ehem. EAN-Feld raus (es erfolgte auch Umbennenung zu GTIN)
    If Left$(tBookmarkName, 14) = "ff_Sortierung_" Then
        '#### Keine 0 Erlaubt
        check_Bookmark_Value = IsPositivNumeric(tBookmarkName, tFieldResult, False)
        '#### Leer und Sonderzeichen entfernen
        ThisDocument.FormFields(tBookmarkName).result = MakeNumeric(tFieldResult)
        GoTo Check_Bookmark_Value_False
    End If

    '#### 161212 AG Nettogewicht: Kontrolle auf Zahlenwerte
    If Left$(tBookmarkName, 16) = "ff_Sort_Gewicht_" Then
        check_Bookmark_Value = IsPositivNumeric(tBookmarkName, tFieldResult)
        GoTo Check_Bookmark_Value_False
    End If
    
    '#### 180713 AG GTIN (EAN) Felder werden auf Zahlen gepr|fffd|ft, auch Eingabe eines Punktes '.' ist ung|fffd|ltig
    If Left$(tBookmarkName, 12) = "ff_Sort_EAN_" Then
        If InStr(tFieldResult, ".") > 0 Then
            Call MsgOutput("Your input is not allowed. No point allowed!", tBookmarkName, vbExclamation, "wrong input")
        Else
            '#### Keine 0 Erlaubt
            check_Bookmark_Value = IsPositivNumeric(tBookmarkName, tFieldResult, True, False)
            '#### Leer und Sonderzeichen entfernen
            ThisDocument.FormFields(tBookmarkName).result = MakeNumeric(tFieldResult)
        End If
        GoTo Check_Bookmark_Value_False
    End If

Check_Bookmark_Value_Exit:
    check_Bookmark_Value = True

    Exit Function

Check_Bookmark_Value_False:
    '    ffield.Result = "0"
End Function

'------------------------------------------------------------------------------
' Function  : IsPositivNumeric
' Author    : M. Bauer
' Date      : 21.12.2015
' Purpose   : Checkt Text auf positiv numerisch -> MsgBox
'             Optionaler Parameter bAllowZero: Zulassen von 0
'             Optionaler Parameter bAllowDecimals: Zulassen von Komma
'------------------------------------------------------------------------------
'
Function IsPositivNumeric(tBMName As String, tValue As String, Optional bAllowZero As Boolean = True, _
                          Optional bAllowDecimals As Boolean = True) As Boolean
 
    On Error GoTo IsPositivNumeric_Error
 
    Dim i                               As Integer
    Dim tChar                           As String
 
    IsPositivNumeric = False
 
    '    If tValue <> "" Then
    '        If Not IsNumeric(tValue) Then
    '            MsgBox "Der eingegebene Wert ist ung|fffd|ltig.", vbOKOnly
    '            Exit Function
    '        End If
    '        If bAllowZero = True Then
    '            If CDbl(tValue) < 0 Then
    '                MsgBox "Der eingegebene Wert ist ung|fffd|ltig.", vbOKOnly
    '                Exit Function
    '            End If
    '        Else
    '            If CDbl(tValue) <= 0 Then
    '                MsgBox "Der eingegebene Wert ist ung|fffd|ltig.", vbOKOnly
    '                Exit Function
    '            End If
    '        End If
    '    End If
 
 
    If tValue <> "" Then
        For i = 1 To Len(tValue)
            tChar = Mid(tValue, i, 1)
            If (Asc(tChar) >= 48 And Asc(tChar) <= 57) Or tChar = "." Or tChar = "," Or tChar = " " Then
                '### Ziffer 0-9 bzw Punkt,Komma zul|fffd|ssig wenn nicht bereits durch vorige Pr|fffd|fung durchgefallen
                '### Leerzeichen und ggff , ist zwar auch nicht zul|fffd|ssig wird aber sp|fffd|ter separat gepr|fffd|ft
            Else
                Call MsgOutput("Your input is not allowed. Invalid character.", tBMName, vbInformation)
                Exit Function
            End If
        Next i
        
        If bAllowZero = False Then
            '#### 161220 AG Pr|fffd|fung auf Leerstring hinzu mit entsprechender Meldung
            If MaxReplace(tValue, Space(1), vbNullString) = vbNullString Then
                Call MsgOutput("Your input is not allowed. " & vbLf & "no input of spaces allowed!", tBMName, vbInformation)
                Exit Function
            ElseIf Val(MakeNumeric(tValue)) = 0 Then
                Call MsgOutput("Your input is not allowed. No 0-values allowed!", tBMName, vbInformation)
                Exit Function
            End If
        End If
 
        If Left(tValue, 1) = "-" Then
            Call MsgOutput("Your input is not allowed. No negative values allowed!", tBMName, vbInformation)
            Exit Function
        End If
 
        If bAllowDecimals = False Then
            If InStr(1, tValue, ",") > 0 Then
                Call MsgOutput("Your input is not allowed. No comma allowed!", tBMName, vbInformation)
                Exit Function
            End If
        End If
    End If
 
    IsPositivNumeric = True
 
IsPositivNumeric_Exit:
    Exit Function
IsPositivNumeric_Error:
    Exit Function
 
End Function

Function isOnlyText(tValue As String) As Boolean
    Dim tChar As String
    Dim bOK As Boolean
    Dim lAsciiChar As Long
    Dim l As Long
    bOK = True
    If tValue <> "" Then
            For l = 1 To Len(tValue)
                tChar = Mid(tValue, l, 1)
                lAsciiChar = Asc(tChar)
                '### Gro|fffd|-/Kleinbuchstabe und Umlaute
                If (lAsciiChar > 64 And lAsciiChar < 91) Or (lAsciiChar > 96 And lAsciiChar < 123) _
                 Or lAsciiChar = 196 Or lAsciiChar = 214 Or lAsciiChar = 220 Or lAsciiChar = 228 _
                 Or lAsciiChar = 246 Or lAsciiChar = 252 Then
                    '### Zeichen ist Gro|fffd|-/ Kleinbuchstabe oder Umlaute
                Else
                    bOK = False
                    GoTo isOnlytextEarlyExit
                End If
            Next
    End If
isOnlytextEarlyExit:
    isOnlyText = bOK
End Function


'---------------------------------------------------------------------------------------
' Procedure : ReplaceIncoterm
' Author    : Thomas Lutzeier
' Date      : 11.01.2015
' Purpose   : Ersetzt den Incoterm im Abschnitt Preis
'---------------------------------------------------------------------------------------
'
Sub ReplaceIncoterm()
    Dim tBookmarkName         As String
    Dim oField                As FormField
    Dim lBookmarkNr           As Long
  
    With ThisDocument
        If .Windows(1).Selection.Bookmarks.Count > 0 Then
            lBookmarkNr = .Windows(1).Selection.Bookmarks.Count
            tBookmarkName = .Windows(1).Selection.Bookmarks(lBookmarkNr).Name
            Set oField = .FormFields(tBookmarkName)
        End If
        .Application.ScreenUpdating = False
        If oField.result <> "" And oField.result <> "Bitte ausw|fffd|hlen!" Then
            Call DocumentProtectUnprotect
            If .Bookmarks.Exists("bmIncoterm") Then
                Call UpdateBookmark("bmIncoterm", oField.result)
            Else
                Call UpdateBookmark("bmIncoterm2", oField.result)
            End If
            oField.Select
            Call DocumentProtectUnprotect
        End If
    End With    'ThisDocument
    Set oField = Nothing
    
    Call Checktxt
    ThisDocument.Application.ScreenUpdating = True
End Sub
',------------------------------------------------------------------------------------
'| Procedure  : Sub ChangeUebername
'| ReturnType : keiner
'| DateTime   : 15.06.2015 12:27
'| Author     : Grube
'| Purpose    : Funktion wird bei |fffd|bernahme nach L|fffd|nderblock|fffd|nderungen aufgerufen.
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Sub ChangeUebername()
      
    Select Case ThisDocument.FormFields("cboLaenderbloecke").result
    Case "Bitte ausw|fffd|hlen!"
        Call MsgOutput("Please select a country block! " & vbLf & vbLf _
            & "No calculation is performed", vbNullString, vbInformation)
    Case Else
        ChangeLaenderbloecke
    End Select
      
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub ReplaceHafen
'| DateTime   : 20.10.2015 14:55
'| Author     :
'| Purpose    : Achtung: Wird in Frei-Haus nur als Dummy-Funktion gebraucht
'`--------------------------------------------------------------------------------------
'
Sub ReplaceHafen()
'    Dim tBookmarkName         As String
'    Dim oField                As FormField
'    Dim lBookmarkNr           As Long
'
'    tBookmarkName = "dd_Hafen"
'    With ThisDocument
'        If .Bookmarks.Exists(tBookmarkName) Then
'        '#### 161201 AG Funktion vereinfacht
'        'If ThisDocument.Windows(1).Selection.Bookmarks.Count > 0 Then
'            'lBookmarkNr = ThisDocument.Windows(1).Selection.Bookmarks.Count
'            'tBookmarkName = ThisDocument.Windows(1).Selection.Bookmarks(lBookmarkNr).Name
'
'            Set oField = .FormFields(tBookmarkName)
'            Application.ScreenUpdating = False
'            If oField.result <> "" And oField.result <> "Bitte ausw|fffd|hlen!" Then
'                Call DocumentProtectUnprotect
'
'                If .Bookmarks.Exists("bm_Hafen") Then
'                    Call UpdateBookmark("bm_Hafen", oField.result)
'                End If
'
'                oField.Select
'                Call DocumentProtectUnprotect
'            End If
'        End If
'    End With
'    Set oField = Nothing
'
'    Call Checktxt
'    Application.ScreenUpdating = True
End Sub

Sub ChangeBMQualityImpl(bShoesOC As Boolean)
    '#### DUMMY!
End Sub

Sub ChangeBMPreis()
    If ThisDocument.Bookmarks.Exists("bmPreisEinfach") Then
        Call ChangeBMPreisImpl("PreisKomplex")
    Else
        Call ChangeBMPreisImpl("PreisEinfach")
    End If
End Sub

'------------------------------------------------------------------------------
' Procedure : ChangeBMPreis
' Author    : Grube
' Date      : 24.06.2015
' Purpose   : Wechselt zwischen einfacher und erweiterter Preistabelle mit Propertydaten
'------------------------------------------------------------------------------
'
Sub ChangeBMPreisImpl(tPropName As String)
    Dim tBookmarkName  As String
    Dim oRng           As Range
    Dim oClipboard     As MSForms.DataObject
    
    With ThisDocument
        
        '#### 171108 AK/AG Pr|fffd|fen, ob eine |fffd|nderung notwendig ist:
        If .Bookmarks.Exists("bm_Preis") And tPropName = "PreisEinfach" Then
            '### Preistabelle bereits "einfach" -> nichts zu tun!
            Exit Sub
        ElseIf .Bookmarks.Exists("bm_PreisKomplex") And tPropName = "PreisKomplex" Then
            '### Preistabelle bereits "komplex" -> nichts zu tun!
            Exit Sub
        End If
     
        Call DocumentProtectUnprotect
        If .Bookmarks.Exists("bmPreisEinfach") Then
            tBookmarkName = "bmPreisEinfach"
        Else
            tBookmarkName = "bm_PreisKomplex"
            '#### Felder wieder entfernen
            If .Bookmarks.Exists("bm_PreisKomplex") Then
                Set oRng = .Bookmarks("bm_PreisKomplex").Range
                If Not oRng Is Nothing Then
                    Call ModFormFieldValues(oRng, False)
                End If
            End If
        End If
        
        If .Bookmarks.Exists(tBookmarkName) Then
            Call .Windows(1).Selection.GoTo(What:=wdGoToBookmark, Name:=tBookmarkName)
            Call .Windows(1).Selection.Cut
        End If
        PropInsertInToDocument tPropName, .Windows(1).Selection.Range, True
        '#### neue Felder m|fffd|ssen nach dem Aufklappen (PreisKomplex) hinzu
        If .Bookmarks.Exists("bm_PreisKomplex") Then
            Set oRng = .Bookmarks("bm_PreisKomplex").Range
            If Not oRng Is Nothing Then
                Call ModFormFieldValues(oRng, True)
            End If
        End If
                      
        If .Bookmarks.Exists("txtIncoterm") And FieldExists(ThisDocument, "txtIncoterm") Then
            If .FormFields("txtIncoterm").result <> "" Then
                Call UpdateBookmark("bmIncoterm", .FormFields("txtIncoterm").result)
            End If
        End If
        Call DocumentProtectUnprotect
    End With 'ThisDocument
    Call Storetxt
    Set oRng = Nothing
    Set oClipboard = Nothing
End Sub

Function bmVal(tBMName As String) As Double
    With ThisDocument
        If .Bookmarks.Exists(tBMName) Then
            bmVal = Val(MakeNumeric(.Bookmarks(tBMName).Range.Text))
        End If
    End With
End Function

Function ffVal(tBMName As String) As Double
    With ThisDocument
        If .Bookmarks.Exists(tBMName) And FieldExists(ThisDocument, tBMName) Then
            ffVal = Val(MakeNumeric(.FormFields(tBMName).result))
        End If
    End With
End Function
Function MakeNumeric(Text As String) As String
    Dim lX                    As Long
    For lX = 1 To Len(Text)
        If IsNumeric(Mid(Text, lX, 1)) Then MakeNumeric = MakeNumeric & Mid(Text, lX, 1)
    Next lX
End Function

Public Function RoundUp(number As Double, significant As Integer) As Double
    RoundUp = Round(number, significant)
    If RoundUp < number Then
        RoundUp = RoundUp + (1 / (10 * significant))
    End If
End Function


Attribute VB_Name = "MModSave"
'---------------------------------------------------------------------------------------
' Module    : Modul MModSave
' Date      : 25.02.2016 20:47
' Author    : Reiser
' Purpose   : Dieses Modul enth|fffd|lt Prozeduren, die bei der Pr|fffd|fung bestimmeter Felder vor dem
'             Speichern ben|fffd|tigt werden. (HINTERGRUND: Unter bestimmten Bedingungen
'             wird das Exit-Makro von Formfeldern nicht ausgef|fffd|hrt (z.B. wenn man in
'             einen gesch|fffd|tzten Bereich klickt))
'---------------------------------------------------------------------------------------
'
'
Option Explicit

'#### 180829 AG Anpassungen f|fffd|r 64 Bit
#If VBA7 Then
    Private Declare PtrSafe Function EnableWindow Lib "user32" (ByVal hwnd As LongPtr, ByVal fEnable As Long) As Long
#Else
    Declare Function EnableWindow Lib "user32.dll" (ByVal hwnd As Long, ByVal fEnable As Long) As Long
#End If
'
'---------------------------------------------------------------------------------------
' Procedure   : Sub CheckFieldsOnSave
' Return Type :
' DateTime    : 25.02.2016
' Author      : Reiser
' Purpose     : Werte in FormFields validieren und ggf. Berechnungen durchf|fffd|hren
' Remarks     :
'---------------------------------------------------------------------------------------
'
Public Sub CheckFieldsOnSave(ByRef bCancel As Boolean)
    Dim bIsCatalog              As Boolean
    Dim tCatalogText            As String
    Dim tExitMacro              As String
    Dim oField                  As Word.FormField
    Dim vKey                    As Variant
    Dim colBookmarks            As Collection
    Dim oBookmark               As cFormField
    Dim bHasError               As Boolean
    Dim bCancelChecks           As Boolean
    Dim lCount                  As Long
     
    On Error GoTo Err_CheckFieldsOnSave
     
    With ThisDocument
        Call EnableWindow(GetHwnd(.Application), 0)
        .Application.StatusBar = "Bitte warten...Felder werden gepr|fffd|ft"
        Word.System.Cursor = wdCursorWait
        DoEvents
        '#### Abschalten der Bildschirmaktualisierung
        .Application.ScreenUpdating = False
    
        '### Alle (relevanten) Formfields ermitteln
        .Application.StatusBar = "Bitte warten...alle (relevanten) Formfields werden ermittelt"
        Call FillFormFieldsForCalc
    
        '### Collection zum Speichern der Ergebnisse der berechneten
        '### Bookmarks initialisieren
        Set colBookmarks = New Collection
    
        Set oBookmark = New cFormField
        Call oBookmark.Init("ff_L_Ges_Menge_GES", "")
        Call oBookmark.SetFormFieldValueNew("0")
        Call colBookmarks.Add(oBookmark, "ff_L_Ges_Menge_GES")
    
        Set oBookmark = New cFormField
        Call oBookmark.Init("ff_L_Karton_GES", "")
        Call oBookmark.SetFormFieldValueNew("0")
        Call colBookmarks.Add(oBookmark, "ff_L_Karton_GES")
        '#### 161201 AG Aktualisierung des Abgangshafens
        Call ReplaceHafen
        '### Alle (relevanten) Formfields durchlaufen
        .Application.StatusBar = "Bitte warten...alle (relevanten) Formfields werden durchlaufen"
        DoEvents
        bHasError = False
        bCancelChecks = False
        '### Dokumentschutz aufheben zur Aktualisierung der Bookmarks
        Call DocUnlock(ThisDocument)
        
        For Each vKey In mDictFieldsForCalc
            If Not mFrmProgress Is Nothing Then Call mFrmProgress.SetProgress1(0, lCount / mDictFieldsForCalc.Count * 100)
            lCount = lCount + 1
            If .Bookmarks.Exists(mDictFieldsForCalc(vKey)) Then
                Set oField = .FormFields(mDictFieldsForCalc(vKey))
                tCatalogText = vbNullString
                bIsCatalog = False
                '#### 170419 AG Auswahllisten bearbeiten
                If mDictFormFields.Exists(mDictFieldsForCalc(vKey)) Then
                    Set oBookmark = mDictFormFields.Item(mDictFieldsForCalc(vKey))
                    If oBookmark.GetIsCatalog() Then
                        bIsCatalog = True
                        tCatalogText = oBookmark.GetFormFieldValueNew()
                    End If
                    Set oBookmark = Nothing
                End If
                 
                '#### 171109 AG |fffd|nderungen nur wenn n|fffd|tig durchf|fffd|hren
                If Len(tCatalogText) > 0 And oField.result <> tCatalogText Then
                    Call SetFieldResult(oField, tCatalogText)
                Else
                    '#### 170516 AG Katalogfelder werden nicht mit Checktext gepr|fffd|ft
                    If Not bIsCatalog Then
                        '### Verlassen Makro ermitteln und entsprechende Prozedur ausf|fffd|hren
                        tExitMacro = oField.ExitMacro
                        Select Case tExitMacro
                            Case "Checktxt"
                                Call ChecktxtForField(mDictFieldsForCalc(vKey), colBookmarks, bHasError, bCancelChecks)
                                If bCancelChecks = True Then
                                    Exit For
                                End If
                            Case Else
                                Call Err.Raise(vbObjectError + 1, "CheckFieldsOnSave", _
                                               "Exit Makro " & tExitMacro & " wird nicht behandelt.")
                        End Select
                    End If      ' Not bIsCatalog
                End If
            End If
        Next vKey
        Call ReplaceKaufgegenstand
        '### Dokumentschutz aufheben zur Aktualisierung der Bookmarks
        Call DocUnlock(ThisDocument)
        
        '### Bookmarks f|fffd|r Kartonzahlen und aggregierten Kartonzahlen und Gesamtmengen aktualisieren
        .Application.StatusBar = "Bitte warten...berechnete Werte werden aktualisiert"
        DoEvents
        For Each oBookmark In colBookmarks
            If .Bookmarks.Exists(oBookmark.GetFormFieldName) Then
                Call UpdateBookmark(oBookmark.GetFormFieldName, oBookmark.GetFormFieldValueNew)
                'Debug.Print oBookmark.GetFormFieldName & vbTab & oBookmark.GetFormFieldValueNew
            End If
        Next oBookmark
    
    '    '### Berechnung der Kartonmengen je Bestimmungsort
    '    .Application.StatusBar = "Bitte warten...Berechnung der Kartonmengen je Bestimmungsort"
    '    Call CalculatePackageSums
    '
    '    '### Berechnung der L|fffd|nderbl|fffd|cke
    '    .Application.StatusBar = "Bitte warten...Berechnung der L|fffd|nderbl|fffd|cke"
    '    Call CalcLaenderbloecke
        Call EnableWindow(GetHwnd(.Application), 1)
    End With
Exit_CheckFieldsOnSave:
    If bHasError = True Then
        bCancel = True
    Else
        bCancel = False
    End If
    With ThisDocument
        '### Dokument wieder sch|fffd|tzen
        Call DocLock(ThisDocument)
        
        '### Felder aktualisieren
        .Fields.Update
        
        '#### Einschalten der Bildschirmaktualisierung
        .Application.ScreenUpdating = True
        
        .Application.StatusBar = " "
    End With
    Word.System.Cursor = wdCursorNormal
    Set oField = Nothing
    Set oBookmark = Nothing
    Set colBookmarks = Nothing
    Exit Sub

Err_CheckFieldsOnSave:
    With ThisDocument
        '### Dokument wieder sch|fffd|tzen
        Call DocLock(ThisDocument)
        
        '#### Einschalten der Bildschirmaktualisierung
        Word.System.Cursor = wdCursorNormal
        .Application.ScreenUpdating = True
    
        bCancel = True
        .Application.StatusBar = " "
    End With
    Call ErrorMessage
    Resume Exit_CheckFieldsOnSave
End Sub


'---------------------------------------------------------------------------------------
' Procedure   : Sub ChecktxtForField
' Return Type : -
' DateTime    : 25.02.2016
' Author      : Reiser
' Purpose     : Pr|fffd|ft die Eingaben von Feld tBookmarkName vor dem Speichern
' Remarks     :
'---------------------------------------------------------------------------------------
'
Sub ChecktxtForField(tBookmarkName As String, colBookmarks As Collection, bHasError As Boolean, bCancelChecks As Boolean)
    Dim oField                          As FormField
    Dim oEnableField                    As FormField
    'Dim tBookmarkName         As String
    Dim tFieldContent                   As String
    Dim tProbest                        As String
    Dim tarrProbest()                   As String
    Dim bIsGesField                     As Boolean
    Dim bIsKolliField                   As Boolean
    Dim iCount                          As Integer
    Dim iCountSecondary                 As Integer
    Dim iCheck100                       As Integer
    Dim tVerpackValue                   As String
    Dim tVerpackName                    As String
    Dim tKolliValue                     As String
    Dim tTotalValue                     As String
    Dim tKolliName                      As String
    Dim lPosUnderscore                  As Long
    Dim tCountry                        As String
    Dim dTestVarGes                     As Double
    Dim dTestVarKarton                  As Double
    Dim bGesTooBig                      As Boolean
    Dim bKartonTooBig                   As Boolean
    Dim oBookmark                       As cFormField
    Dim lIndex                          As Long
    Dim objCCountry                     As CCountry
    Dim lGesamtMenge                    As Long
    Dim lKartonGesamt                   As Long


    On Error GoTo Err_ChecktxtForField
    With ThisDocument
        '### Verhindert ein Runterspringen in ein vorheriges FormField, nach dem Klick in ein weit entferntes FormField
        '.Parent.ScreenUpdating = False

        'tBookmarkName = GetBookMarkName()
        If Not (Len(tBookmarkName) > 0 And .Bookmarks.Exists(tBookmarkName) And FieldExists(ThisDocument, tBookmarkName)) Then GoTo EarlyExit

        If tBookmarkName <> "bm_PreisKomplex" Then

            '#### Reanimation, wenn Makro deinitialisiert wurde
            If Not IsArrayValid(mtCurrentUpperCountries) Then
                Call Refresh_Globals
            Else
                '#### neu laden, wenn direkt nach Erzeugung editiert wird.
                '#### 170517 AG Korrektur, da bei LExI nur 1 Element existiert
                If UBound(mtCurrentUpperCountries) < 0 Then
                    Call Refresh_Globals
                End If
            End If

            '#### Reanimation, wenn Makro deinitialisiert wurde
            If mDictFormFields Is Nothing Then
                Call GetFormFieldValues(ThisDocument)
            End If

            Set oField = .FormFields(tBookmarkName)

            '#### harte Returns (nicht erlaubt) durch Soft Linefeeds ersetzen
            If InStr(oField.result, Chr(13)) > 0 Then
                Call SetFieldResult(oField, MaxReplace(oField.result, Chr(13), Chr(11)))
            End If

            '#### Behandlung f|fffd|r L|fffd|ndermengen
            bIsGesField = (Mid$(oField.Name, 1, 15) = "ff_L_Ges_Menge_")
            bIsKolliField = (Mid$(oField.Name, 1, 11) = "ff_L_Kolli_")

            '#### Pr|fffd|fen, ob valider Wert
            If check_Bookmark_Value(tBookmarkName, oField.result, bIsGesField, bIsKolliField) = False Then
                Call SetFieldResult(oField, "")
                mtContenttxt = ""
                bHasError = True
                '                ThisDocument.Application.ScreenUpdating = True
                '                If MsgBox("M|fffd|chen Sie die Pr|fffd|fung fortsetzen?", vbQuestion + vbYesNo) = vbYes Then
                '                    ThisDocument.Application.ScreenUpdating = False
                '                Else
                '                    ThisDocument.Application.ScreenUpdating = False
                bCancelChecks = True
                oField.Select
                'GoTo EarlyExit
                '                End If
                '
            End If

            tFieldContent = oField.result

            '#### Exit, wenn keine |fffd|nderung oder wenn ung|fffd|ltiger Wert
            'If tFieldContent = mtContenttxt Then GoTo EarlyExit

            If bIsGesField Then

                '#### Anhand von Bookmark Name das Land ermiteln
                lPosUnderscore = InStrRev(tBookmarkName, "_") + 1
                tCountry = Mid$(tBookmarkName, lPosUnderscore)

                '#### Pr|fffd|fung auf g|fffd|ltige Eingabe in Gesamtmenge Felder wurde bereits oben durchgef|fffd|hrt
                tTotalValue = tFieldContent
                '### Bei Gesamtfeld Wert von zugeh|fffd|rigem Kolifeld ermitteln
                tKolliName = "ff_L_Kolli_" & Mid(tBookmarkName, Len("ff_L_Ges_Menge_") + 1)
                If .Bookmarks.Exists(tKolliName) Then

                    tKolliValue = .FormFields(tKolliName).result

                    '#### Pr|fffd|fen, ob Koli validen Wert hat
                    If check_Bookmark_Value(tKolliName, tKolliValue, False, True) = False Then
                        Call SetFieldResult(.FormFields(tKolliName), "")
                        mtContenttxt = ""
                        tKolliValue = ""
                        bHasError = True
                        '                ThisDocument.Application.ScreenUpdating = True
                        '                If MsgBox("M|fffd|chen Sie die Pr|fffd|fung fortsetzen?", vbQuestion + vbYesNo) = vbYes Then
                        '                    ThisDocument.Application.ScreenUpdating = False
                        '                Else
                        '                    ThisDocument.Application.ScreenUpdating = False
                        bCancelChecks = True
                        .FormFields(tKolliName).Select
                        'GoTo EarlyExit
                        '                End If
                        '
                    End If

                    '#### Pr|fffd|fen, ob Division m|fffd|glich
                    If tKolliValue <> "" And tFieldContent <> "" Then
                        If DivideValue(CLng(MakeNumeric(tFieldContent)), CLng(MakeNumeric(tKolliValue))) = 0 Then
                            .FormFields(tBookmarkName).result = ""
                            tFieldContent = ""
                            mtContenttxt = ""
                            tTotalValue = ""
                            bHasError = True
                            bCancelChecks = True
                            .FormFields(tBookmarkName).Select
                            'GoTo EarlyExit
                            '                                End If
                        End If
                    End If

                    '#### Wenn beide Eingaben OK dann Kartonanzahl berechnen
                    tKolliValue = MakeNumeric(tKolliValue)
                    tTotalValue = MakeNumeric(tTotalValue)
                    Call CalCulateLieferMengenOnSave(tCountry, Val(tKolliValue), Val(tTotalValue), colBookmarks)

                    '#### Wert als Ganzzahl mit Tausendertrennzeichen formatieren
                    If tKolliValue <> "" Then
                        .FormFields(tKolliName).result = FormatWithThousandsSeparator(Val(tKolliValue), "#,##0")
                    End If

                    If tTotalValue <> "" Then
                        oField.result = FormatWithThousandsSeparator(Val(tTotalValue), "#,##0")
                    End If
                End If
            End If

            '#### Berechnung der Gesamtanzahl der Kartons

            '#### Collection mit den Liefermengen der L|fffd|nder wiederherstellen
            If mDictDeliveryByCountry Is Nothing Then
                Call FillDeliveryByCountryCol("old")
            End If

            dTestVarGes = 0
            dTestVarKarton = 0
            bGesTooBig = False
            bKartonTooBig = False
            For lIndex = 0 To mDictDeliveryByCountry.Count - 1
                Set objCCountry = mDictDeliveryByCountry.Items(lIndex)
                If Not bGesTooBig Then
                    dTestVarGes = dTestVarGes + objCCountry.GetGesamtMenge()
                    If dTestVarGes > 2100000000 Then
                        Call MsgOutput("Too large amounts were entered." & vbLf & _
                             "The sum can not be processed any more" & vbLf & _
                             "and is set to 0." & vbLf & vbLf & _
                             "Please specify smaller values.", vbNullString, vbInformation)
                        lGesamtMenge = 0
                        bGesTooBig = True
                    Else
                        lGesamtMenge = lGesamtMenge + objCCountry.GetGesamtMenge()
                    End If
                End If

                If Not bKartonTooBig Then
                    dTestVarKarton = dTestVarKarton + objCCountry.GetKarton()
                    If dTestVarKarton > 2100000000 Then
                        Call MsgOutput("Too large carton quantities were entered." & vbLf & _
                             "The sum can not be processed any more" & vbLf & _
                             "and is set to 0." & vbLf & vbLf & _
                             "Please specify smaller values.", vbNullString, vbInformation)
                        lKartonGesamt = 0
                        bKartonTooBig = True
                    Else
                        lKartonGesamt = lKartonGesamt + objCCountry.GetKarton()
                    End If
                End If
            Next


            On Error Resume Next

            'Debug.Print "ff_L_Ges_Menge_GES" & vbTab & FormatWithThousandsSeparator(lGesamtMenge, "#,##0")
            Set oBookmark = colBookmarks("ff_L_Ges_Menge_GES")
            Call oBookmark.SetFormFieldValueNew(FormatWithThousandsSeparator(lGesamtMenge, "#,##0"))

            'Debug.Print "ff_L_Karton_GES" & vbTab & FormatWithThousandsSeparator(lKartonGesamt, "#,##0")
            Set oBookmark = colBookmarks("ff_L_Karton_GES")
            Call oBookmark.SetFormFieldValueNew(FormatWithThousandsSeparator(lKartonGesamt, "#,##0"))

            On Error GoTo Err_ChecktxtForField


            '#### Neue Berechnung von Preis mit GP
            If tBookmarkName = "ff_Preis_Netto" Then
                '### Bei Preisfeld Wert von zugeh|fffd|rigem Verpackungsfeld ermitteln
                tVerpackName = "ff_Kosten_GP"
                If .Bookmarks.Exists(tVerpackName) Then
                    tVerpackValue = .FormFields(tVerpackName).result

                    '#### Pr|fffd|fen, ob Verpackung validen Wert hat
                    If check_Bookmark_Value(tVerpackName, tVerpackValue, False, False) = False Then
                        Call SetFieldResult(.FormFields(tVerpackName), "")
                        mtContenttxt = ""
                        bHasError = True
                        bCancelChecks = True
                        .FormFields(tVerpackName).Select
                        '                        GoTo EarlyExit
                    End If

                    '#### Wenn beide Eingaben OK dann Preis mit Verpackung berechnen
                    Call CalcPreisMitGP
                End If
            ElseIf Left(tBookmarkName, 9) = "ff_Preis_" Then
                '### Bei Preisfeld Wert von zugeh|fffd|rigem Verpackungsfeld ermitteln
                tVerpackName = "ff_Verpack" & Mid(tBookmarkName, 9)
                If .Bookmarks.Exists(tVerpackName) Then
                    tVerpackValue = .FormFields(tVerpackName).result

                    '#### Pr|fffd|fen, ob Verpackung validen Wert hat
                    If check_Bookmark_Value(tVerpackName, tVerpackValue, False, False) = False Then
                        Call SetFieldResult(.FormFields(tVerpackName), "")
                        mtContenttxt = ""
                        bHasError = True
                        bCancelChecks = True
                        .FormFields(tVerpackName).Select
                        '                        GoTo EarlyExit
                    End If

                    '#### Wenn beide Eingaben OK dann Preis mit Verpackung berechnen
                    Call CalcSumme(Mid(tBookmarkName, 9))
                End If


                'Call CalcSumme(Mid(tBookmarkName, 9))
                '            ElseIf Left(tBookmarkName, 11) = "ff_Verpack_" Then
                '                Call CalcSumme(Mid(tBookmarkName, 11))
            End If

            '#### Inspection Center
            Call CheckInspectionCenter(ThisDocument, oField)

            '#### Lieferbedingungen aktualisieren
            If Mid(oField.Name, 1, 11) = "ff_PROBEST_" Then

                tProbest = PropGetNormalProp(ThisDocument, "ProbestFields")
                tarrProbest = Split(tProbest, ";")

                For iCount = 0 To UBound(tarrProbest)
                    If mDictFormFields.Exists(tarrProbest(iCount)) And Right(tarrProbest(iCount), 1) = "1" Then
                        iCheck100 = 0
                        For iCountSecondary = 0 To UBound(tarrProbest)
                            If Left(tarrProbest(iCount), Len(tarrProbest(iCount)) - 1) = Left(tarrProbest(iCountSecondary), Len(tarrProbest(iCountSecondary)) - 1) _
                               And Right(tarrProbest(iCountSecondary), 1) <> "1" Then

                                If iCheck100 + .FormFields(tarrProbest(iCountSecondary)).result > 100 Then
                                    Call MsgOutput("The added percentages must not exceed 100%.", vbNullString, vbInformation)
                                    .FormFields(tarrProbest(iCountSecondary)).result = 100 - iCheck100
                                    iCheck100 = 100
                                Else
                                    iCheck100 = .FormFields(tarrProbest(iCountSecondary)).result + iCheck100
                                End If
                            End If
                        Next iCountSecondary

                        .FormFields(tarrProbest(iCount)).result = 100 - iCheck100
                    End If
                Next iCount
            End If

            '#### Spezielle Vorbelegung einzelner Felder, /// FRAGE: wird Routine gebraucht?
            'mtContenttxt = SpecBMContent(tBookmarkName)

            '#### Checkboxen ankreuzen und Felder rot (Reiser 25.02.2016: auskommentiert da sonst beim Speichern immer gesetzt, da alle Felder durchlaufen werden)
            '            If mbTurnToRed Then
            '                Call MarkChanges(oField, tBookmarkName)
            '            End If
        End If
    End With
EarlyExit:
    Set oField = Nothing
    Set oEnableField = Nothing
    Exit Sub

Err_ChecktxtForField:
    Set oField = Nothing
    Set oEnableField = Nothing

    bHasError = True
    Call ErrorMessage
    Exit Sub
    Resume
End Sub

'
'---------------------------------------------------------------------------------------
' Procedure   : Sub CalCulateLieferMengenOnSave
' Return Type : -
' DateTime    : 25.02.2016
' Author      : Reiser
' Purpose     : Berechnet die Liefermengen von allen L|fffd|ndern vor dem Speichern:
'               - Kartons pro Land
'               - Gesamtmengen |fffd|ber alle L|fffd|nder (Mengen und Kartons)
' Remarks     :
'---------------------------------------------------------------------------------------
'
Sub CalCulateLieferMengenOnSave(tCountry As String, lKoliValue As Long, lGesValue As Long, colBookmarks As Collection)

    On Error GoTo CalCulateLieferMengenOnSaveError

    Dim objCCountry                     As CCountry
    Dim lKarton                         As Long
    Dim oBookmark                       As cFormField
    Dim lErrNumber                      As Long
    Dim tErrDescription                 As String
    Dim tErrSource                      As String

    '#### Collection mit den Liefermengen der L|fffd|nder wiederherstellen
    If mDictDeliveryByCountry Is Nothing Then
        Call FillDeliveryByCountryCol("old")
    End If

    '#### Keine Berechnung bei ung|fffd|ltigem Land
    If Not mDictDeliveryByCountry.Exists(tCountry) Then
        Exit Sub
    End If

    '#### Berechnung der Kartonanzahl
    Set objCCountry = mDictDeliveryByCountry.Item(tCountry)
    With objCCountry
        If lGesValue > 0 And lKoliValue > 0 Then
            Call .SetGesamtMenge(lGesValue)
            Call .SetKolli(lKoliValue)
            lKarton = .GetKarton()
        Else
            Call .SetGesamtMenge(lGesValue)
            Call .SetKolli(lKoliValue)
            lKarton = 0
        End If

        '### Update des Bookmarks
        On Error Resume Next
        'Debug.Print "ff_L_Karton_" & tCountry & vbTab & FormatWithThousandsSeparator(lKarton, "#,##0")
        Set oBookmark = New cFormField
        Call oBookmark.Init("ff_L_Karton_" & tCountry, "")
        '#### 160605 AG Nullen werden unterdr|fffd|ckt
        Call oBookmark.SetFormFieldValueNew(IIf(lKarton > 0, FormatWithThousandsSeparator(lKarton, "#,##0"), ""))
        'Call oBookmark.SetFormFieldValueNew(FormatWithThousandsSeparator(lKarton, "#,##0"))
        Call colBookmarks.Add(oBookmark, "ff_L_Karton_" & tCountry)
        On Error GoTo CalCulateLieferMengenOnSaveError
    End With

CalCulateLieferMengenOnSaveExit:
    Set objCCountry = Nothing
    Set oBookmark = Nothing
    On Error GoTo 0
    Exit Sub

CalCulateLieferMengenOnSaveError:
    lErrNumber = Err.number
    tErrDescription = Err.Description
    tErrSource = Err.Source
    On Error GoTo 0
    Call MsgOutput(lErrNumber & tErrSource & tErrDescription & "->CalCulateLieferMengen (MCalculate)", vbNullString, vbCritical)
    Call Err.Raise(lErrNumber, tErrSource, tErrDescription & "->CalCulateLieferMengen (MCalculate)")
    GoTo CalCulateLieferMengenOnSaveExit
End Sub

Attribute VB_Name = "MPropSave"
Option Explicit

',--------------------------------------------------------------------------------------
'| Module     : Function Dummydata
'| ReturnType : String
'| DateTime   : 20.10.2015 14:58
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function Dummydata() As String
    Dim lIndex As Long
    Dim lHelpIndex As Long
    Dim tOutput As String
    
    For lHelpIndex = 1 To 9999
        For lIndex = 1 To 9
            tOutput = tOutput & CStr(lIndex)
        Next lIndex
    Next lHelpIndex
    
    Dummydata = tOutput
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub PropAdd
'| DateTime   : 20.10.2015 14:58
'| Author     :
'| Purpose    : F|fffd|gt eine neues Property hinzu
'|              170628 AK Optionaler Parameter zur Angabe des Dokumentes hinzugef|fffd|gt
'`--------------------------------------------------------------------------------------
'
Public Sub PropAdd(tToken As String, tValue As String, Optional oDocument As Word.Document = Nothing)
    Dim lPropCount As Long
    Dim lIndex As Long
    
    If oDocument Is Nothing Then Set oDocument = ThisDocument
    
    lPropCount = Int(Len(tValue) / 255) + 1
    With oDocument.CustomDocumentProperties
        Call .Add(tToken & "_Count", False, msoPropertyTypeNumber, lPropCount)
        For lIndex = 1 To lPropCount
            Call .Add(tToken & "_" & CStr(lIndex), False, msoPropertyTypeString, Mid(tValue, (lIndex - 1) * 255 + 1, 255))
        Next lIndex
    End With
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub PropDelete
'| DateTime   : 20.10.2015 14:58
'| Author     :
'| Purpose    : L|fffd|scht ein vorhandenes Property
'|              170628 AK Optionaler Parameter zur Angabe des Dokumentes hinzugef|fffd|gt
'`--------------------------------------------------------------------------------------
'
Public Sub PropDelete(tToken As String, Optional oDocument As Word.Document = Nothing)
    Dim lPropCount As Long
    Dim lIndex As Long
    
    If oDocument Is Nothing Then Set oDocument = ThisDocument
    
    With oDocument.CustomDocumentProperties
        If PropExists(tToken & "_Count", oDocument) Then
            lPropCount = CLng(.Item(tToken & "_Count").Value)
        End If
        For lIndex = 1 To lPropCount
            If PropExists(tToken & "_" & CStr(lIndex), oDocument) Then
            .Item(tToken & "_" & CStr(lIndex)).Delete
            End If
        Next lIndex
        If PropExists(tToken & "_Count", oDocument) Then
            .Item(tToken & "_Count").Delete
        End If
    End With
End Sub

',--------------------------------------------------------------------------------------
'| Module     : Function PropItem
'| ReturnType : String
'| DateTime   : 20.10.2015 14:58
'| Author     :
'| Purpose    : Gibt den Inhalt eines vorhandenen Propertys zur|fffd|ck
'|              170628 AK Optionaler Parameter zur Angabe des Dokumentes hinzugef|fffd|gt
'`--------------------------------------------------------------------------------------
'
Public Function PropItem(tToken As String, Optional oDocument As Word.Document = Nothing) As String
    Dim lPropCount As Long
    Dim lIndex As Long
    Dim tValue As String
    
    If oDocument Is Nothing Then Set oDocument = ThisDocument
    
    With oDocument.CustomDocumentProperties
        lPropCount = CLng(.Item(tToken & "_Count").Value)
        For lIndex = 1 To lPropCount
            tValue = tValue & .Item(tToken & "_" & CStr(lIndex))
        Next lIndex
    End With
    
    PropItem = tValue
End Function


',--------------------------------------------------------------------------------------
'| Module     : Function PropExists
'| ReturnType : Boolean
'| DateTime   : 20.10.2015 14:58
'| Author     :
'| Purpose    : Pr|fffd|ft, ob ein bestimmtes Property vorhanden ist
'|              170628 AK Optionaler Parameter zur Angabe des Dokumentes hinzugef|fffd|gt
'`--------------------------------------------------------------------------------------
'
Function PropExists(tToken As String, Optional oDocument As Word.Document = Nothing) As Boolean
    Dim vProp As Variant
    
    If oDocument Is Nothing Then Set oDocument = ThisDocument
    
    On Error GoTo NotFound
    Set vProp = oDocument.CustomDocumentProperties.Item(tToken)
    PropExists = True
    Set vProp = Nothing
    Exit Function
    
NotFound:
    PropExists = False
    Set vProp = Nothing
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub PropInsertInToDocument
'| DateTime   : 20.10.2015 14:59
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Sub PropInsertInToDocument(ByVal tPropName As String, ByVal rngBookmark As Word.Range, ByVal bXML As Boolean, Optional bStayAtInsertPosition As Boolean)
    Dim tNewTxt As String
    'Dim rngDuplicate As Word.Range
    
    tNewTxt = PropItem(tPropName)
    If bXML Then
'        Set rngDuplicate = rngBookmark.Duplicate
'        Call rngDuplicate.Collapse(wdCollapseEnd)
'        Call rngDuplicate.InsertAfter(Chr(0))
'        Call rngDuplicate.Collapse(wdCollapseEnd)
'        Call rngBookmark.Delete
        Call rngBookmark.InsertXML(tNewTxt)
'        Call rngBookmark.MoveEndUntil(Chr(0))
'        Call rngBookmark.MoveEnd(wdCharacter, -1)
'        Call rngDuplicate.MoveStart(wdCharacter, -1)
'        Call rngDuplicate.Delete
'        Set rngDuplicate = Nothing
    Else
        rngBookmark.Text = tNewTxt
    End If
    
    If bStayAtInsertPosition = False Then
        rngBookmark.Document.ActiveWindow.Selection.EndKey Unit:=wdStory
        rngBookmark.Document.ActiveWindow.Selection.TypeParagraph
    End If
    
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub PropIncrementVersion
'| DateTime   : 20.10.2015 14:59
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Sub PropIncrementVersion(oDoc As Word.Document, bExtern As Boolean)
    Dim tActVersion As String
    Dim tArray() As String
    Dim tToken As String
    Dim lIndex As Long
    If bExtern Then
        tToken = "Version"
    Else
        tToken = "IntDocVersion"
    End If
    If PropExists(tToken) Then
        tActVersion = oDoc.CustomDocumentProperties.Item(tToken)
        tArray = Split(tActVersion, ".")
        tActVersion = vbNullString
        
        If UBound(tArray) = 2 Then
            lIndex = 2
        Else
            lIndex = 1
            
        End If
        tArray(lIndex) = CStr(Val(tArray(lIndex)) + 1)
        For lIndex = 0 To UBound(tArray)
            If (Len(tActVersion) > 0) Then
                tActVersion = tActVersion & "."
            End If
            tActVersion = tActVersion & tArray(lIndex)
        Next
        oDoc.CustomDocumentProperties.Item(tToken).Delete
    Else
        tActVersion = "1.0.0"
    End If
    
    Call oDoc.CustomDocumentProperties.Add(tToken, False, msoPropertyTypeString, tActVersion)
    
End Sub

',--------------------------------------------------------------------------------------
'| Module     : Function PropGetNormalProp
'| ReturnType : String
'| DateTime   : 20.10.2015 15:00
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function PropGetNormalProp(oDoc As Word.Document, tToken As String) As String
    PropGetNormalProp = vbNullString
    If PropExists(tToken) Then
        PropGetNormalProp = oDoc.CustomDocumentProperties.Item(tToken)
    End If
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub PropSetNormalProp
'| DateTime   : 20.10.2015 15:00
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Sub PropSetNormalProp(oDoc As Word.Document, tToken As String, tPropText As String)
    With oDoc.CustomDocumentProperties
        If PropExists(tToken) Then
            .Item(tToken).Delete
        End If
        Call .Add(tToken, False, msoPropertyTypeString, tPropText)
    End With
End Sub
Attribute VB_Name = "MProtocol"
Option Explicit


',------------------------------------------------------------------------------------
'| Procedure  : Sub DoProtocol
'| ReturnType : -
'| DateTime   : 13.10.2015 08:25
'| Author     : Grube
'| Purpose    : Protokollierung in Tabellenform
'| Remarks    : keine
'`------------------------------------------------------------------------------------
'
Public Sub DoProtocol(oDoc As Word.Document)
    Dim oField                As Word.FormField
    Dim oFormField            As cFormField
    Dim oTable                As Word.Table
    Dim bIsEdited             As Boolean
    Dim lRowIndex             As Long
    Dim tDatumText            As String
    Dim tLeftHeader           As String
    Dim tRightHeader          As String
    Dim bProtocolExists       As Boolean
    Dim lFormFieldsCount      As Integer
    Dim lCount                As Integer
 
    On Error GoTo exitDoProtocol

    With ThisDocument
     
        Set oFormField = New cFormField
    
        .Application.ScreenUpdating = False
        Call DocUnlock(ThisDocument)
    
        bProtocolExists = (CLng(PropGetNormalProp(ThisDocument, "Protokollierung")) = 1)
    
        If bProtocolExists = True Then
           '#### Textende
            .Windows(1).Selection.EndKey Unit:=wdStory
            .Windows(1).Selection.TypeParagraph
            .Windows(1).Selection.TypeParagraph
        Else
            .Windows(1).Selection.EndKey Unit:=wdStory
            .Windows(1).Selection.InsertBreak WdBreakType.wdPageBreak
            .Windows(1).Selection.Style = oDoc.Styles("Protokoll")
            .Windows(1).Selection.TypeParagraph
            Call PropSetNormalProp(ThisDocument, "Protokollierung", "1")
        End If
    End With
    
    lRowIndex = 1
    lFormFieldsCount = oDoc.FormFields.Count
    tDatumText = "|fffd|nderungsdatum: " & Format$(Now, "dd.MM.YYYY hh:mm")
    For Each oField In oDoc.FormFields
        lCount = lCount + 1
        If mbFrmProgressLoaded Then
            Call mFrmProgress.SetProgress1(lCount / lFormFieldsCount * 100)
            Call mFrmProgress.SetProgress2(50 * Abs(mbCheckFieldsOnSave))
            DoEvents
        End If
        If mDictFormFields.Exists(oField.Name) Then
            Set oFormField = mDictFormFields.Item(oField.Name)
            bIsEdited = (oFormField.GetFormFieldValueOld() <> oField.result) Or oFormField.GetFormFieldEdited()

            If bIsEdited Then
                If lRowIndex > 1 Then
                    oTable.Rows.Add
                    oTable.Rows.Add
                    oTable.Rows.Add
                    tRightHeader = Right(oField.Name, Len(oField.Name) - 3)
                    tLeftHeader = "Feld:"
                Else
                    Set oTable = oDoc.Range.Tables.Add(Range:=Selection.Range, NumRows:=3, NumColumns:=2, DefaultTableBehavior:=wdWord8TableBehavior + wdStyleTypeTable)
                    oTable.Borders(wdBorderBottom).LineStyle = wdLineStyleSingle
                    oTable.Borders(wdBorderTop).LineStyle = wdLineStyleSingle
                    oTable.Borders(wdBorderLeft).LineStyle = wdLineStyleSingle
                    oTable.Borders(wdBorderRight).LineStyle = wdLineStyleSingle
                    '#### Kennzeichen 'automat. Gr|fffd||fffd|en|fffd|nderung zulassen' entfernen
                    oTable.AllowAutoFit = False
                    oTable.Columns(1).Width = 65
                    oTable.Columns(2).Width = 435
                    'oTable.Style = wdStyleTableLightGrid
                    tRightHeader = tDatumText & vbCrLf + Right(oField.Name, Len(oField.Name) - 3)
                    tLeftHeader = vbCrLf & "Feld:"
                End If
                oTable.Cell(lRowIndex, 1).Range = tLeftHeader
                oTable.Cell(lRowIndex, 1).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                oTable.Cell(lRowIndex, 1).Range.Bold = True
                oTable.Rows(lRowIndex).Shading.Texture = wdTextureNone
                oTable.Rows(lRowIndex).Shading.ForegroundPatternColor = wdColorAutomatic
                oTable.Rows(lRowIndex).Shading.BackgroundPatternColor = wdColorGray10
                oTable.Cell(lRowIndex + 1, 1).Range = "alter Wert"
                oTable.Cell(lRowIndex + 2, 1).Range = "neuer Wert"

                oTable.Cell(lRowIndex, 2).Range = tRightHeader
                oTable.Cell(lRowIndex, 2).Range.Bold = True
                oTable.Cell(lRowIndex + 1, 2).Range.ParagraphFormat.TabStops.ClearAll
                oTable.Cell(lRowIndex + 2, 2).Range.ParagraphFormat.TabStops.ClearAll
                oTable.Cell(lRowIndex + 1, 2).Range = oFormField.GetFormFieldValueOld()
                oTable.Cell(lRowIndex + 2, 2).Range = oField.result & IIf(oFormField.GetFormFieldEdited(), " manuelle |fffd|nderung", vbNullString)

                lRowIndex = lRowIndex + 3
                '#### Grundeinstellung zur|fffd|ckschreiben
                Call mDictFormFields.Item(oField.Name).SetFormFieldValueOld(oField.result)
            End If
        End If
    Next

    Call DocLock(ThisDocument)

    ThisDocument.Application.ScreenUpdating = True
    Log ("DoProtocol Ende:" & ThisDocument.Saved)
    Set oFormField = Nothing
    Set oField = Nothing
    Set oTable = Nothing
    Exit Sub

exitDoProtocol:
    Call ErrorMessage
    Call DocLock(ThisDocument)
    Set oFormField = Nothing
    Set oField = Nothing
    Set oTable = Nothing
    Exit Sub

End Sub


',--------------------------------------------------------------------------------------
'| Procedure  : Sub ModFormFieldValues
'| DateTime   : 20.10.2015 15:00
'| Author     : M. Bauer
'| Purpose    : Neue Felder der Protokollierungsroutine hinzuf|fffd|gen, alte mit Startwert > 0 f|fffd|r Protokollierung merken
'`--------------------------------------------------------------------------------------
'
Public Sub ModFormFieldValues(rngFields As Range, bAdd As Boolean)
    Dim oField                 As Word.FormField
    Dim oFormField             As cFormField
    Dim bExists                As Boolean
    
    On Error GoTo exitModFormFieldValues
    
    Set oFormField = New cFormField
    If Not mDictFormFields Is Nothing Then
    
        If mDictFormFields.Count > 0 Then
            If IsObjectValid(rngFields) Then
                For Each oField In rngFields.FormFields
                    Set oFormField = New cFormField
                    ' #### Alle FormFields adden oder removen
                    bExists = mDictFormFields.Exists(oField.Name)
                    
                    If bAdd Then
                        If Not bExists Then
                            Call oFormField.Init(oField.Name, oField.result)
                            Call mDictFormFields.Add(oField.Name, oFormField)
                        End If
                    Else
                        If bExists Then
                            Call mDictFormFields.Remove(oField.Name)
                        End If
                    End If
                Next
            End If
        End If
    End If
    Set oField = Nothing
    Set oFormField = Nothing
    Exit Sub
    
exitModFormFieldValues:
    Call ErrorMessage
    Set oField = Nothing
    Set oFormField = Nothing
    Exit Sub

End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub GetFormFieldValues
'| DateTime   : 20.10.2015 15:02
'| Author     :
'| Purpose    : F|fffd|gt alle Textmarken dem zentralen Protokollierungsspeicher hinzu
'`--------------------------------------------------------------------------------------
'
Public Sub GetFormFieldValues(doc As Word.Document)
    Dim oField               As Word.FormField
    Dim oFormField           As cFormField
    
    ThisDocument.Application.ScreenUpdating = False
    Set mDictFormFields = New Scripting.Dictionary
    
    For Each oField In doc.FormFields
        Set oFormField = New cFormField
        ' #### Alle FormFields speichern
        If Not mDictFormFields.Exists(oField.Name) Then
            Call oFormField.Init(oField.Name, oField.result)
            Call mDictFormFields.Add(oField.Name, oFormField)
        End If
    Next
    ThisDocument.Application.ScreenUpdating = True
    Set oFormField = Nothing
    Set oField = Nothing
End Sub

Attribute VB_Name = "MUtility"
Option Explicit

Public gtLogFile                As String
Public gtComputerName           As String

',------------------------------------------------------------------------------------
'| Procedure  : Function FileExists
'| ReturnType : Boolean
'| DateTime   : 21.04.2009 11:04
'| Author     : Kremm
'| Purpose    : Pr|fffd|ft, ob die |fffd|bergebene Datei existiert.
'| Remarks    : Die Pr|fffd|fung findet auf die Dateitabelle des Dateisystems statt, d.h.
'|              eine Datei kann bei ihrer Erstellung vorhanden sein (Ergebnis: TRUE),
'|              obwohl sie noch geschrieben wird.
'`------------------------------------------------------------------------------------
'
Public Function FileExists(ByVal tFileName As String) As Boolean
    On Error GoTo NotFound
    FileExists = (GetAttr(tFileName) And vbDirectory) <> vbDirectory
    Exit Function
NotFound:
    FileExists = False
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function FolderExists
'| ReturnType : Boolean
'| DateTime   : 21.04.2009 11:04
'| Author     : Kremm
'| Purpose    : Pr|fffd|ft, ob das |fffd|bergebene verzeichnis existiert.
'| Remarks    :
'`------------------------------------------------------------------------------------
'
Public Function FolderExists(ByVal tDirName As String) As Boolean
    On Error GoTo NotFound
    FolderExists = (GetAttr(tDirName) And vbDirectory) = vbDirectory
    Exit Function
NotFound:
    FolderExists = False
End Function

Public Function GetPath(tFilePath As String) As String
    If InStr(tFilePath, "\") > 0 Then
        GetPath = Left(tFilePath, InStrRev(tFilePath, "\") - 1)
    Else
        GetPath = tFilePath
    End If
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function InitLog
'| ReturnType : Boolean
'| DateTime   : 20.01.2011 15:00
'| Author     : Grube
'| Purpose    : Initialisierung der Protokollroutine
'| Remarks    :
'`------------------------------------------------------------------------------------
'
Sub InitLog()
    gtComputerName = UCase(Environ("COMPUTERNAME"))
    If mbDEBUG Then
        Dim tL_Tmp As String
        
        gtLogFile = GetFilePath(ThisDocument.Path, "MyLog.log")
        If FileExists(gtLogFile) Then
            tL_Tmp = Left$(gtLogFile, Len(gtLogFile) - 4) & ".bak"
            If FileExists(tL_Tmp) Then
               Kill tL_Tmp
            End If
            MoveFile gtLogFile, tL_Tmp
        End If
    End If
End Sub

Public Static Sub Log(ByVal tPAusgabe As String, Optional ByVal tPLogFile As String)
    If mbDEBUG Then
         Call LogIntern(tPAusgabe, tPLogFile)
    End If
End Sub

Public Static Sub DebLog(ByVal tPAusgabe As String, Optional ByVal tPLogFile As String, Optional bAddTimeAndComputer As Boolean = True)
    Dim tTime                   As String
    If bAddTimeAndComputer Then
        tTime = Format(Now, "dd.mm.yyyy hh:mm") & " " & gtComputerName & " "
    End If
    '### Systemzeit ermitteln:
    Call LogIntern(tTime & tPAusgabe, tPLogFile)
End Sub

',------------------------------------------------------------------------------------
'| Procedure  : Function Log
'| ReturnType : Boolean
'| DateTime   : 20.01.2011 15:00
'| Author     : Grube
'| Purpose    : Protokollroutine
'| Remarks    :
'`------------------------------------------------------------------------------------
'
Private Sub LogIntern(ByVal tPAusgabe As String, Optional ByVal tPLogFile As String)
    Dim oFile As TextStream
    Dim oFSO As FileSystemObject
    'Dim lIndex As Long
    
    If Len(tPLogFile) <= 0 Then
         If Len(gtLogFile) <= 0 Then
            gtLogFile = GetFilePath(ThisDocument.Path, "MyLog.log")
         End If
        tPLogFile = gtLogFile
    End If
    
    Set oFSO = CreateObject("Scripting.FileSystemObject")
    If FileExists(tPLogFile) Then
        Set oFile = oFSO.OpenTextFile(tPLogFile, ForAppending, True)
    Else
        Set oFile = oFSO.CreateTextFile(tPLogFile, True)
        
    End If
    'If Len(tP_Ausgabe) > 255 Then
    '    For lIndex = 1 To Len(tP_Ausgabe) Step 255
    '        Call oFile.Write(Mid$(tP_Ausgabe, lIndex, 255))
            
    '    Next
    'Else
        oFile.WriteLine (tPAusgabe)
    'End If
    oFile.Close
    Set oFile = Nothing
    Set oFSO = Nothing
End Sub

',------------------------------------------------------------------------------------
'| Procedure  : Function GetFilePath
'| ReturnType : Boolean
'| DateTime   : 20.01.2011 15:00
'| Author     : Grube
'| Purpose    : Gibt einen kompletten Dateipfad zur|fffd|ck.
'| Remarks    : Vor der Kombination wird eine |fffd|berpr|fffd|fung bzgl Anzahl der Backslashes durchgef|fffd|hrt
'`------------------------------------------------------------------------------------
'
Public Function GetFilePath(ByVal tDir As String, ByVal tFileName As String) As String
    Dim tFilePath                       As String
    If Len(tDir) > 0 Then
        tFilePath = tDir
        If Right(tDir, 1) <> "\" Then
            tFilePath = tFilePath & "\"
        End If
    End If
    tFilePath = tFilePath & tFileName
    GetFilePath = tFilePath
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function MoveFile
'| ReturnType : Variant
'| DateTime   : 21.04.2009 10:53
'| Author     : Kremm
'| Purpose    : Verschiebt eine Datei. Das m|fffd|glicherweise vorhandene Ziel wird dabei
'|              gel|fffd|scht.
'| Remarks    : Sollte der Quell-Datei nicht vorhanden oder ge|fffd|ffnet sein, dann wird
'|              so lange probiert, bis die Datei kopiert werden kann.
'`------------------------------------------------------------------------------------
'
Public Function MoveFile(ByVal tSource As String, ByVal tDestination As String)
    On Error Resume Next
    Call Kill(tDestination)
    Call Err.Clear
    Do
        Call Err.Clear
        Call FileCopy(tSource, tDestination)
        If Err.number = 0 Then Exit Do
    Loop
    On Error GoTo 0
    Call Kill(tSource)
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function FixRelativePath
'| ReturnType : String
'| DateTime   : 07.11.2016 16:38
'| Author     : Kremm
'| Purpose    : Fixes relative paths by prepending the path of this document to the
'|              filename.
'| Remarks    : Detects absolute paths with drive letters and UNC paths
'`------------------------------------------------------------------------------------
'
'#### 161108 AG |fffd|nderung von A.K. |fffd|bernommen
Public Function FixRelativePath(ByVal tFileName As String) As String
    tFileName = Trim(tFileName)
    
    '#### Bail out, if no filename provided:
    If Len(tFileName) = 0 Then
        FixRelativePath = vbNullString
        Exit Function
    End If
    
    '##### Directly return absolute paths:
    If tFileName Like "?:\*" Or Left(tFileName, 2) = "\\" Then
        FixRelativePath = tFileName
        Exit Function
    End If
    
    '#### Remove trailing backslash:
    If Left(tFileName, 1) = "\" Then
        tFileName = Mid(tFileName, 2)
    End If
    
    '#### Remove trailing ".\":
    If Left(tFileName, 2) = ".\" Then
        tFileName = Mid(tFileName, 3)
    End If

    '#### Prepend path of this document:
    FixRelativePath = ThisDocument.Path & "\" & tFileName
End Function

Public Property Get TEMP_DIR() As String
    TEMP_DIR = Environ("TEMP")
End Property

Attribute VB_Name = "MXMLImporter"
Option Explicit

Private Const SOFT_LF                   As String = ""
Private Const MAX_LONG                  As Long = 2147483647

Private Type T_COMPARE_MOD
    bEnabled                            As Boolean
    bError                              As Boolean
    tWithFile                           As String
    tResultFile                         As String
    eFileFormat                         As WdSaveFormat
End Type

'#### 180829 AG 64 Bit Umstellung
#If VBA7 Then
    Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
    Private Declare Sub Sleep Lib "kernel32" (ByVal Milliseconds As Long)
#End If

Public Sub ImportXML()
    Dim tXMLFile                        As String
    Dim oFormField                      As cFormField
    Dim oDoc                            As MSXML2.DOMDocument60
    Dim elmRoot                         As MSXML2.IXMLDOMElement
    Dim elmSettings                     As MSXML2.IXMLDOMElement
    Dim elmCheckboxes                   As MSXML2.IXMLDOMElement
    Dim elmFields                       As MSXML2.IXMLDOMElement
    Dim elmSetting                      As MSXML2.IXMLDOMElement
    Dim elmCheckbox                     As MSXML2.IXMLDOMElement
    Dim elmField                        As MSXML2.IXMLDOMElement
    Dim elmCompare                      As MSXML2.IXMLDOMElement
    Dim tAttributeName                  As String
    Dim tAttributeValue                 As String
    Dim bCancelSave                     As Boolean
    Dim tVersion                        As String
    Dim tFileName                       As String
    Dim tFilePath                       As String
    Dim tArtNumber                      As String
    Dim tCheckboxName                   As String
    Dim tCheckboxValue                  As String
    Dim bIsTextileOC                    As Boolean
    Dim bIsLExIOC                       As Boolean
    Dim bIsFHOC                         As Boolean
    Dim tyComapareMod                   As T_COMPARE_MOD
    Dim eAlertLevelSave                 As WdAlertLevel
    
    bIsTextileOC = (PropGetNormalProp(ThisDocument, "Warengruppe") = "Textil")
    bIsLExIOC = (PropGetNormalProp(ThisDocument, "ABContractType") = "LExI")
    bIsFHOC = (PropGetNormalProp(ThisDocument, "ABContractType") = "FH")
    Set oFormField = New cFormField
    
    '#### Search for XML file, and exit if not found (manual operation):
    With ThisDocument
        eAlertLevelSave = .Application.DisplayAlerts
        tXMLFile = .Path & "\" & Left(.Name, InStrRev(.Name, ".") - 1) & ".xml"
    End With
    
    '#### 180615 AG XML-Import blockiert
    If Not FileExists(tXMLFile) Then
        Exit Sub
    Else
        Call MsgBox("This document should not be used" & vbLf & _
                    "in combination with an XML-file." & vbLf & vbLf & _
                     "Please use the CBX-import-macro.", vbExclamation, "No XML Import")
        Exit Sub
    End If
    mbOpenMode = XMLIMPORT
    ThisDocument.Windows(1).Visible = False

    Set oDoc = New MSXML2.DOMDocument60
    If Not oDoc.Load(tXMLFile) Then
        Call WriteToLog("ERROR: Could not parse XML file '" & tXMLFile & "' (line " & oDoc.parseError.Line & "/linepos " & oDoc.parseError.linepos & "): " & oDoc.parseError.reason)
        GoTo CloseDocument
    End If

    Set elmRoot = oDoc.DocumentElement

    '#### Some basic sanity checks:
    If elmRoot.nodeName <> "oc" Then
        Call WriteToLog("ERROR: The name of the root element must be 'oc'")
        GoTo CloseDocument
    End If
    If elmRoot.getElementsByTagName("settings").Length <> 1 Then
        Call WriteToLog("ERROR: Root element 'oc' needs exactly one child element 'settings'")
        GoTo CloseDocument
    End If
    If elmRoot.getElementsByTagName("checkboxes").Length <> 1 Then
        Call WriteToLog("ERROR: Root element 'oc' needs exactly one child element 'checkboxes'")
        GoTo CloseDocument
    End If
    If elmRoot.getElementsByTagName("fields").Length <> 1 Then
        Call WriteToLog("ERROR: Root element 'oc' needs exactly one child element 'fields'")
        GoTo CloseDocument
    End If
    If elmRoot.getElementsByTagName("compare").Length > 1 Then
        Call WriteToLog("ERROR: There is only one element 'compare' allowed in the Root element 'oc'")
        GoTo CloseDocument
    End If

    '#### Compare function:
    If elmRoot.getElementsByTagName("compare").Length = 1 Then
        Set elmCompare = elmRoot.getElementsByTagName("compare")(0)
        tyComapareMod = ConfigCompare(elmCompare)
        If tyComapareMod.bError Then GoTo CloseDocument
    Else
        tyComapareMod.bEnabled = False
    End If

    '#### Get elements:
    Set elmSettings = elmRoot.getElementsByTagName("settings")(0)
    Set elmCheckboxes = elmRoot.getElementsByTagName("checkboxes")(0)
    Set elmFields = elmRoot.getElementsByTagName("fields")(0)

    '#### Execute settings:
    For Each elmSetting In elmSettings.getElementsByTagName("setting")
        tAttributeName = elmSetting.getAttribute("name")
        If tAttributeName = "bmPrice" And Not bIsLExIOC Then
            If Not ConfigPricetable(elmSetting) Then
                GoTo CloseDocument
            End If
        ElseIf tAttributeName = "isShoesOC" And bIsTextileOC And Not bIsFHOC Then
            If Not ConfigShoesOC(elmSetting) Then
                GoTo CloseDocument
            End If
        ElseIf tAttributeName = "tblShoes" And bIsTextileOC And Not bIsFHOC Then
            If Not ConfigShoes(elmSetting) Then
                GoTo CloseDocument
            End If
        ElseIf tAttributeName = "bmSortierung" Then
            If Not ConfigSorting(elmSetting) Then
                GoTo CloseDocument
            End If
        ElseIf tAttributeName = "imgSignature" Then
            If Not InsertSignature(elmSetting) Then
                GoTo CloseDocument
            End If
        Else
            Call WriteToLog("ERROR: Unknown setting: " & tAttributeName)
            GoTo CloseDocument
        End If
    Next elmSetting

    '#### Set checkboxes:
    For Each elmCheckbox In elmCheckboxes.getElementsByTagName("checkbox")
        If IsNull(elmCheckbox.getAttribute("name")) Then
            Call WriteToLog("ERROR: Checkbox needs attribute 'name'")
            GoTo CloseDocument
        End If
        tCheckboxName = elmCheckbox.getAttribute("name")
        If mDictFormFields.Exists(tCheckboxName) Then
            Set oFormField = mDictFormFields.Item(tCheckboxName)
        Else
            Set oFormField = Nothing
        End If
        If Not ThisDocument.Bookmarks.Exists(tCheckboxName) Then
            Call WriteToLog("ERROR: Unknown checkbox: '" & tCheckboxName & "'")
            GoTo CloseDocument
        End If
        tCheckboxValue = elmCheckbox.Text
        If Not IsBoolean(tCheckboxValue) Then
            Call WriteToLog("ERROR: Value of checkbox must be boolean")
            GoTo CloseDocument
        End If
        '#### 171109 AG |fffd|nderungen nur wenn n|fffd|tig durchf|fffd|hren, defaultwert immer setzen
        If Not oFormField Is Nothing Then
            Call oFormField.SetFormFieldValueNew(tCheckboxValue)
            If ThisDocument.FormFields(tCheckboxName).CheckBox.Value <> CBool(tCheckboxValue) Then
                ThisDocument.FormFields(tCheckboxName).CheckBox.Value = CBool(tCheckboxValue)
            End If
        End If
        
    Next elmCheckbox

    '#### Fill fields:
    For Each elmField In elmFields.getElementsByTagName("field")
        If IsNull(elmField.getAttribute("name")) Then
            Call WriteToLog("ERROR: Field needs attribute 'name'")
            GoTo CloseDocument
        End If
        tAttributeName = elmField.getAttribute("name")
        tAttributeValue = elmField.Text
        If mDictFormFields.Exists(tAttributeName) Then
            Set oFormField = mDictFormFields.Item(tAttributeName)
        Else
            Set oFormField = Nothing
        End If
         
        '#### 171109 AG |fffd|nderungen nur wenn n|fffd|tig durchf|fffd|hren, defaultwert immer setzen
        If Not oFormField Is Nothing Then
            oFormField.SetFormFieldValueNew (tAttributeValue)
            
            If ThisDocument.FormFields(tAttributeName).result <> tAttributeValue Then
                If Not SetFieldValue(tAttributeName, tAttributeValue) Then
                    GoTo CloseDocument
                End If
            End If
        End If
    Next elmField

    '#### Calculate fields:
    '#### 170522 AG auskommentiert, weil Aufruf in CheckFieldsOnSave enthalten
    'Call ReplaceKaufgegenstand
    Call CheckFieldsOnSave(bCancelSave)
    If bCancelSave Then GoTo CloseDocument

    '#### Save Document:
    With ThisDocument
        tVersion = PropGetNormalProp(ThisDocument, "Version")
        Call DocUnlock(ThisDocument)
        Call UpdateBookmark("ff_AB_Version", tVersion, False)
        Call DocLock(ThisDocument)
        tFileName = Replace(.CustomDocumentProperties.Item("ABFileName"), "_Template", "")
        tFileName = Replace(tFileName, ".docm", "_" & Replace(tVersion, ".", "_") & ".docm")
        tArtNumber = CStr(.FormFields("ff_Interne_Art_Nr").result)
        gbLockDocumentBeforeSave = True
        If tyComapareMod.bEnabled Then
            tFilePath = TEMP_DIR & "\Compare_" & tArtNumber & "_" & tFileName
            If FileExists(tFilePath) Then Call Kill(tFilePath)
            '#### 170522 AG algemeine Speicherroutine aufrufen
            '#### 170531 AG Konvertierungsmeldung unterdr|fffd|cken
            .Application.DisplayAlerts = wdAlertsNone
                                                     
            Call CallSaveAs(ThisDocument, tFileName:=tFilePath, lWordFileFormat:=WdSaveFormat.wdFormatXMLDocumentMacroEnabled)
            .Application.DisplayAlerts = eAlertLevelSave
            'Call .SaveAs(TEMP_DIR & "\Compare_" & tArtNumber & "_" & tFileName, wdFormatXMLDocumentMacroEnabled)
            Call RunCompare(tyComapareMod)
        Else
            tFileName = Replace(.CustomDocumentProperties.Item("ABFileName"), "_Template", "")
            tFileName = Replace(tFileName, ".docm", "_" & Replace(tVersion, ".", "_") & ".docm")
            tArtNumber = CStr(.FormFields("ff_Interne_Art_Nr").result)
            '#### 170522 AG algemeine Speicherroutine aufrufen
            '#### 170531 AG Konvertierungsmeldung unterdr|fffd|cken
            .Application.DisplayAlerts = wdAlertsNone
            Call CallSaveAs(ThisDocument, tFileName:=.Path & "\" & tArtNumber & "_" & tFileName, lWordFileFormat:=WdSaveFormat.wdFormatXMLDocumentMacroEnabled)
            .Application.DisplayAlerts = eAlertLevelSave
            'Call .SaveAs(ThisDocument.Path & "\" & tArtNumber & "_" & tFileName, wdFormatXMLDocumentMacroEnabled)
        End If
    End With

CloseDocument:
    If Val(Application.Version) < 15 Then
        '#### Laufzeitprobleme nur bei Office 2007
        Call Sleep(1000)
        '#### 170524 AG Close wg. Kennwort-Problem hinzu
        Call ThisDocument.Close(False)
    End If
    '#### Quit Word in any case
    '#### (no problem, because this function is normally only used on servers!)
    Call Application.Quit(False)
    Set oFormField = Nothing
    Set oDoc = Nothing
    End
End Sub

Private Function ConfigCompare(elm As MSXML2.IXMLDOMElement) As T_COMPARE_MOD
    Dim tWith                           As String
    Dim tResult                         As String
    Dim lExtensionPos                   As Long
    Dim eFileFormat                     As WdSaveFormat
 
    '#### Checks:
    If IsNull(elm.getAttribute("with")) Then
        Call WriteToLog("ERROR: Setting 'compare' requires attribute 'with'")
        ConfigCompare.bError = True
        Exit Function
    ElseIf IsNull(elm.getAttribute("result")) Then
        Call WriteToLog("ERROR: Setting 'compare' requires attribute 'result'")
        ConfigCompare.bError = True
        Exit Function
    End If

    tWith = FixRelativePath(elm.getAttribute("with"))
    tResult = FixRelativePath(elm.getAttribute("result"))

    '#### Check file / paths:
    If Not FileExists(tWith) Then
        Call WriteToLog("ERROR: File to compare with not found: '" & tWith & "'")
        ConfigCompare.bError = True
        Exit Function
    ElseIf Not FolderExists(GetPath(tResult)) Then
        Call WriteToLog("ERROR: Path for comparison result not found: '" & tResult & "'")
        ConfigCompare.bError = True
        Exit Function
    End If
    '#### Detect file format for comparison result:
    lExtensionPos = InStrRev(tResult, ".")
    If lExtensionPos = 0 Then
        '### File name has no extension!
        Call WriteToLog("ERROR: Filename for comparison result does not have an extension: '" & tResult & "'")
        ConfigCompare.bError = True
        Exit Function
    ElseIf Mid(UCase(tResult), lExtensionPos) = ".DOCX" Then
        eFileFormat = wdFormatXMLDocument
    Else
        '### File name has unsupported extension!
        Call WriteToLog("ERROR: The extension of the result file name must be .docx")
        ConfigCompare.bError = True
        Exit Function
    End If
 
    ConfigCompare.bEnabled = True
    ConfigCompare.bError = False
    ConfigCompare.tWithFile = tWith
    ConfigCompare.tResultFile = tResult
    ConfigCompare.eFileFormat = eFileFormat
End Function

Private Function ConfigPricetable(elm As MSXML2.IXMLDOMElement) As Boolean
    '#### Checks:
    If IsNull(elm.getAttribute("value")) Then
        Call WriteToLog("ERROR: Setting 'bmPrice' requires attribute 'value'")
        ConfigPricetable = False
        Exit Function
    End If

    Select Case elm.getAttribute("value")
        Case "complex":
            Call ChangeBMPreisImpl("PreisKomplex")
        Case "simple":
            Call ChangeBMPreisImpl("PreisEinfach")
        Case Else:
            Call WriteToLog("ERROR: Unknown value at setting 'bmPrice': '" & elm.getAttribute("value") & "'")
            ConfigPricetable = False
            Exit Function
    End Select

    ConfigPricetable = True
End Function

Private Function ConfigShoesOC(elm As MSXML2.IXMLDOMElement) As Boolean
    '#### Checks:
    If IsNull(elm.getAttribute("value")) Then
        Call WriteToLog("ERROR: Setting 'isShoesOC' requires attribute 'value'")
        ConfigShoesOC = False
        Exit Function
    End If

    Select Case elm.getAttribute("value")
        Case "true":
            '#### 171109 AG nur wenn Qualit|fffd|tstabelle sichtbar ist...
            If ThisDocument.Bookmarks.Exists("bm_Qualitaet") Then
                Call ChangeBMQualityImpl(True)
            Else
                Call ChangeBMQualityImpl(False)
            End If
        Case "false":
            Call ChangeBMQualityImpl(False)
        Case Else:
            Call WriteToLog("ERROR: Unknown value at setting 'isShoesOC': '" & elm.getAttribute("value") & "'")
            ConfigShoesOC = False
            Exit Function
    End Select

    ConfigShoesOC = True
End Function

'#### 161024 AG |fffd|nderungen von A.K. |fffd|bernommen
Private Function ConfigShoes(elm As MSXML2.IXMLDOMElement) As Boolean
    Dim lRows                           As Long
    Dim lColumns                        As Long
    Dim lRowsCurrent                    As Long
    Dim lColumnsCurrent                 As Long
    Dim i                               As Long

    '#### Checks:
    If Not ThisDocument.Bookmarks.Exists("bm_Qualitaet") Then
        Call WriteToLog("ERROR: Setting 'tblShoes' is only allowed when setting 'isShoesOC' is true")
        ConfigShoes = False
        Exit Function
    End If
    If IsNull(elm.getAttribute("rows")) Or IsNull(elm.getAttribute("columns")) Then
        Call WriteToLog("ERROR: Setting 'tblShoes' requires the attributes 'rows' and 'columns'")
        ConfigShoes = False
        Exit Function
    End If
    If Not IsNumeric(elm.getAttribute("rows")) Then
        Call WriteToLog("ERROR: Attribute 'rows' on setting 'tblShoes' must be numeric")
        ConfigShoes = False
        Exit Function
    End If
    If Not IsNumeric(elm.getAttribute("columns")) Then
        Call WriteToLog("ERROR: Attribute 'columns' on setting 'tblShoes' must be numeric")
        ConfigShoes = False
        Exit Function
    End If
    lRows = CLng(elm.getAttribute("rows"))
    lColumns = CLng(elm.getAttribute("columns"))
    If lRows < 1 Then
        Call WriteToLog("ERROR: Attribute 'rows' on setting 'tblShoes' must be >= 1")
        ConfigShoes = False
        Exit Function
    End If
    If lColumns < 1 Then
        Call WriteToLog("ERROR: Attribute 'columns' on setting 'tblShoes' must be >= 1")
        ConfigShoes = False
        Exit Function
    End If

    '#### Count number of (data-)rows and (data-)collumns already in table:
    With ThisDocument
        '### Probe count of columns:
        For i = 1 To MAX_LONG
            If .Bookmarks.Exists("ff_Quali_0_" & CStr(i)) Then
                lColumnsCurrent = i
            Else
                Exit For
            End If
        Next i
        '### Probe count of rows:
        For i = 0 To MAX_LONG
            If .Bookmarks.Exists("ff_Quali_" & CStr(i) & "_1") Then
                lRowsCurrent = i
            Else
                Exit For
            End If
        Next i
    End With

    '#### Add / Remove columns:
    If lColumnsCurrent < lColumns Then
        For i = lColumnsCurrent + 1 To lColumns
            Call MHandleQuali.AddColQuali
        Next i
    ElseIf lColumnsCurrent > lColumns Then
        For i = lColumnsCurrent - 1 To lColumns Step -1
            Call MHandleQuali.SubstractColQuali
        Next i
    End If

    '#### Add / Remove rows:
    If lRowsCurrent < lRows Then
        For i = lRowsCurrent + 1 To lRows
            Call MHandleQuali.AddRowQuali
        Next i
    ElseIf lRows > lRowsCurrent Then
        For i = lRowsCurrent - 1 To lRows Step -1
            Call MHandleQuali.SubstractRowQuali
        Next i
    End If

    ConfigShoes = True
End Function

Private Function ConfigSorting(elm As MSXML2.IXMLDOMElement) As Boolean
    Dim lRows                           As Long
    Dim lColumns                        As Long
    Dim lRowsCurrent                    As Long
    Dim lColumnsCurrent                 As Long
    Dim i                               As Long

    '#### Checks:
    If IsNull(elm.getAttribute("rows")) Or IsNull(elm.getAttribute("columns")) Then
        Call WriteToLog("ERROR: Setting 'bmSortierung' requires the attributes 'rows' and 'columns'")
        ConfigSorting = False
        Exit Function
    End If
    If Not IsNumeric(elm.getAttribute("rows")) Then
        Call WriteToLog("ERROR: Attribute 'rows' on setting 'bmSortierung' must be numeric")
        ConfigSorting = False
        Exit Function
    End If
    If Not IsNumeric(elm.getAttribute("columns")) Then
        Call WriteToLog("ERROR: Attribute 'columns' on setting 'bmSortierung' must be numeric")
        ConfigSorting = False
        Exit Function
    End If
    lRows = CLng(elm.getAttribute("rows"))
    lColumns = CLng(elm.getAttribute("columns"))
    If lRows < 1 Then
        Call WriteToLog("ERROR: Attribute 'rows' on setting 'bmSortierung' must be >= 1")
        ConfigSorting = False
        Exit Function
    End If
    If lColumns < 1 Or lColumns > 5 Then
        Call WriteToLog("ERROR: Attribute 'columns' on setting 'bmSortierung' must be >= 1 and <= 5")
        ConfigSorting = False
        Exit Function
    End If

    '#### Count number of (data-)rows and (data-)collumns allready in table:
    With ThisDocument
        lColumnsCurrent = .Bookmarks("bmSortierung").Range.Tables(1).Columns.Count
        lRowsCurrent = .Bookmarks("bmSortierung").Range.Tables(1).Rows.Count
        '### Substract header rows:
        lRowsCurrent = lRowsCurrent - 2
        '### Substract header columns:
        If .Bookmarks.Exists("ff_Sort_Gewicht_1") Then
            lColumnsCurrent = lColumnsCurrent - 5
        Else
            lColumnsCurrent = lColumnsCurrent - 3
        End If
    End With

    '#### Add / Remove columns:
    If lColumnsCurrent < lColumns Then
        For i = lColumnsCurrent + 1 To lColumns
            Call MHandleSort.AddCol
        Next i
    ElseIf lColumnsCurrent > lColumns Then
        For i = lColumnsCurrent - 1 To lColumns Step -1
            Call MHandleSort.SubstractCol
        Next i
    End If

    '#### Add / Remove rows:
    If lRowsCurrent < lRows Then
        For i = lRowsCurrent + 1 To lRows
            Call MHandleSort.AddRow
        Next i
    ElseIf lRows > lRowsCurrent Then
        For i = lRowsCurrent - 1 To lRows Step -1
            Call MHandleSort.SubstractRow
        Next i
    End If

    ConfigSorting = True
End Function

Private Function SetFieldValue(tFieldName As String, ByVal tValue As String) As Boolean

    '#### Abort, if field does not exist:
    If Not ThisDocument.Bookmarks.Exists(tFieldName) Then
        Call WriteToLog("ERROR: Unknown field: '" & tFieldName & "'")
        SetFieldValue = False
        Exit Function
    End If

    '#### Convert newlines
    tValue = Replace(tValue, vbCrLf, SOFT_LF)
    tValue = Replace(tValue, vbCr, SOFT_LF)
    tValue = Replace(tValue, vbLf, SOFT_LF)

    '#### Handle special case of Inspection Center:
    If tFieldName = "dd_Inspection_Center" Then
        If Not CheckInspectionCenter(ThisDocument, ThisDocument.FormFields("dd_Hkl")) Then
            SetFieldValue = True
            Exit Function
        End If
    End If

    '#### Set field value:
    If Len(tValue) > 0 Then
        Call SetFieldResult(ThisDocument.FormFields(tFieldName), tValue)
    End If

    SetFieldValue = True
End Function

Public Function InsertSignature(elm As MSXML2.IXMLDOMElement) As Boolean
    Dim tFileName                       As String
    Dim shp                             As Word.InlineShape
    Dim doc                             As Word.Document
    Dim sWidth                          As Single
    Dim sHeight                         As Single

    '#### Checks:
    If IsNull(elm.getAttribute("file")) Then
        Call WriteToLog("ERROR: Setting 'imgSignature' requires the attribute 'file'")
        InsertSignature = False
        Exit Function
    End If
    '#### 161108 AG |fffd|nderung von A.K. |fffd|bernommen
    tFileName = FixRelativePath(elm.getAttribute("file"))
    If Not FileExists(tFileName) Then
        Call WriteToLog("ERROR: Signature image file does not exist: " & tFileName)
        InsertSignature = False
        Exit Function
    End If

    On Error GoTo MiscError

    Set shp = ThisDocument.Sections(ThisDocument.Sections.Count - 1).Range.InlineShapes(1)
    sWidth = shp.Width
    sHeight = shp.Height
    Set doc = shp.OLEFormat.Object
    Call doc.Range.Delete
    Call doc.Range.InlineShapes.AddPicture(tFileName, False, True)
    '#### Close Document to remove instance from memory:
    Call doc.Close(True)
    shp.Width = sWidth
    shp.Height = sHeight

    InsertSignature = True
    Set shp = Nothing
    Set doc = Nothing
    Exit Function

MiscError:
    Call WriteToLog("VBA Error " & CStr(Err.number) & ": " & Err.Description)
    InsertSignature = False
End Function

Private Sub RunCompare(tyCompare As T_COMPARE_MOD)
    Dim oDocCompare                     As Word.Document
    Dim eAlertLevelSave                 As WdAlertLevel

    '#### Execute comparisation:
    Set oDocCompare = DocCompareImpl(tyCompare.tWithFile, OLDFILE_THIS)
    On Error GoTo SaveError
    With ThisDocument
        '### Disable alerts:
        eAlertLevelSave = ThisDocument.Application.DisplayAlerts
        .Application.DisplayAlerts = wdAlertsNone
        '### Save:
        If FileExists(tyCompare.tResultFile) Then Call Kill(tyCompare.tResultFile)  '## <- Delete file, if exists
        Call CallSaveAs(oDocCompare, tFileName:=tyCompare.tResultFile, lWordFileFormat:=tyCompare.eFileFormat)
        'Call oDocCompare.SaveAs2(tyCompare.tResultFile, wdFormatXMLDocument)
        '### Enable alerts:
        .Application.DisplayAlerts = eAlertLevelSave
        '### Close comparion result:
        oDocCompare.Saved = True
        Call oDocCompare.Close(False)
    End With
    On Error GoTo 0

    Set oDocCompare = Nothing
    Exit Sub

SaveError:
    '### Close comparion result:
    oDocCompare.Saved = True
    Call oDocCompare.Close(False)
    Set oDocCompare = Nothing
    ThisDocument.Application.DisplayAlerts = eAlertLevelSave
    Call WriteToLog("Could not save comparison result. Error " & CStr(Err.number) & ": " & Err.Description)
End Sub

Private Sub WriteToLog(tMessage As String)
    Dim tLogFileName                    As String
    Dim iFileNr                         As Integer

    With ThisDocument
        tLogFileName = .Path & "\" & Left(.Name, InStrRev(.Name, ".") - 1) & ".log"
    End With

    iFileNr = FreeFile()
    Open tLogFileName For Append As #iFileNr
    Print #iFileNr, tMessage
    Close #iFileNr
End Sub

Private Function IsBoolean(vValue As Variant) As Boolean
    Dim bDummy                          As Boolean

    On Error GoTo NotBoolean
    bDummy = CBool(vValue)
    IsBoolean = True
    Exit Function
NotBoolean:
    IsBoolean = False
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub ExportFieldNames
'| DateTime   : 31.05.2017 14:40
'| Author     : Kremm/Grube
'| Purpose    : 170531 AG Umbau auf Erzeugung einer Datei im UTF-8-Format
'|              170702 AG Eintrag f|fffd|r Sortierungs- und Qualit|fffd|tstabelle dynamisch ggf. als Kommentar vorgeben
'`--------------------------------------------------------------------------------------
'
Public Sub ExportFieldNames()
    Dim oField                  As FormField
    Dim tName                   As String
    Dim tResult                 As String
    Dim oStream                 As Object
    
    Set oStream = CreateObject("ADODB.Stream")
    With oStream
        .Type = 2
        .Charset = "utf-8"
        Call .Open
        Call .WriteText("<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>" & vbCrLf)
        
        Call .WriteText("<oc>" & vbCrLf)
        Call .WriteText(vbTab & "<settings>" & vbCrLf)
        If PropGetNormalProp(ThisDocument, "ABContractType") <> "LExI" Then
            Call .WriteText(vbTab & vbTab & "<setting name=""bmPrice"" value=""simple"" />" & vbCrLf)
        End If
        If PropGetNormalProp(ThisDocument, "Warengruppe") = "Textil" And PropGetNormalProp(ThisDocument, "ABContractType") <> "FH" Then
            Call .WriteText(vbTab & vbTab & "<setting name=""isShoesOC"" value=""true"" />" & vbCrLf)
            If ThisDocument.Bookmarks.Exists("bmQualityButton") Then
                Call .WriteText(vbTab & vbTab & "<setting name=""tblShoes"" rows=""2"" columns=""6"" />" & vbCrLf)
            Else
                Call .WriteText(vbTab & vbTab & "<!--setting name=""tblShoes"" rows=""2"" columns=""6"" /!-->" & vbCrLf)
            End If
        End If
        If ThisDocument.Bookmarks.Exists("bmSortierung") Then
            Call .WriteText(vbTab & vbTab & "<setting name=""bmSortierung"" rows=""3"" columns=""5"" />" & vbCrLf)
        Else
            Call .WriteText(vbTab & vbTab & "<!--setting name=""bmSortierung"" rows=""3"" columns=""5"" /!-->" & vbCrLf)
        End If
        Call .WriteText(vbTab & vbTab & "<setting name=""imgSignature"" file=""Signature.gif"" />" & vbCrLf)
        Call .WriteText(vbTab & "</settings>" & vbCrLf)
    
        Call .WriteText(vbTab & "<!--compare with=""Other_OC.docm"" result=""Result.docx"" /!-->" & vbCrLf)
    
        Call .WriteText(vbTab & "<checkboxes>" & vbCrLf)
        For Each oField In ThisDocument.FormFields
            If oField.Type = wdFieldFormCheckBox Then
                tName = oField.Name
                tName = Replace(tName, "&", "&amp;")
                tName = Replace(tName, "<", "&lt;")
                tName = Replace(tName, ">", "&gt;")
                tName = Replace(tName, """", "&quot;")
                tName = Replace(tName, "'", "&apos;")
    
                If oField.CheckBox.Value Then
                    tResult = "true"
                Else
                    tResult = "false"
                End If
    
                Call .WriteText(vbTab & vbTab & "<checkbox name=""" & tName & """>" & tResult & "</checkbox>" & vbCrLf)
            End If
        Next oField
        Call .WriteText(vbTab & "</checkboxes>" & vbCrLf)
    
        Call .WriteText(vbTab & "<fields>" & vbCrLf)
        For Each oField In ThisDocument.FormFields
            If oField.Type <> wdFieldFormCheckBox Then
                tName = oField.Name
                tName = Replace(tName, "&", "&amp;")
                tName = Replace(tName, "<", "&lt;")
                tName = Replace(tName, ">", "&gt;")
                tName = Replace(tName, """", "&quot;")
                tName = Replace(tName, "'", "&apos;")
    
                tResult = oField.result
                tResult = Replace(tResult, "&", "&amp;")
                tResult = Replace(tResult, "<", "&lt;")
                tResult = Replace(tResult, ">", "&gt;")
                tResult = Replace(tResult, """", "&quot;")
                tResult = Replace(tResult, "'", "&apos;")
                tResult = Replace(tResult, gctSOFT_CR_LF, "&#10;")
    
                Call .WriteText(vbTab & vbTab & "<field name=""" & tName & """>" & tResult & "</field>" & vbCrLf)
            End If
        Next oField
        Call .WriteText(vbTab & "</fields>" & vbCrLf)
    
        Call .WriteText("</oc>" & vbCrLf)
        
        Call .SaveToFile(ThisDocument.Path & "\" & Left(ThisDocument.Name, InStrRev(ThisDocument.Name, ".") - 1) & ".xml.old", 2)
        Call .Close
    End With
    Set oField = Nothing
    Set oStream = Nothing
End Sub


Attribute VB_Name = "ThisApplication"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
 
Public WithEvents moApplication As Word.Application
Attribute moApplication.VB_VarHelpID = -1
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub moApplication_DocumentBeforeClose
'| DateTime   : 20.10.2015 13:44
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub moApplication_DocumentBeforeClose(ByVal oDoc As Document, bCancel As Boolean)
    bCancel = False
    If Not ThisDocument Is oDoc Then Exit Sub
    If Not oDoc.Saved Then
        If MsgOutput("Do you want to save the changes," & vbLf & _
                  "before the window is closed?", vbNullString, vbQuestion + vbYesNo, "Question") = vbYes Then
            Call moApplication_DocumentBeforeSave(oDoc, False, False)
            If Not oDoc.Saved Then
                If MsgOutput("Failed to save document." & vbLf & vbLf & _
                          "Do you still want to close the window?", vbNullString, vbQuestion + vbYesNo, "Question") = vbYes Then
                    oDoc.Saved = True
                    bCancel = False
                Else
                    bCancel = True
                End If
            End If
        Else
            oDoc.Saved = True
        End If
    End If
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub moApplication_DocumentBeforePrint
'| DateTime   : 13.04.2016 13:44
'| Author     : Kremm / Grube
'| Purpose    : Schachteinstellungen des Druckers in jedem Fall verwenden
'`--------------------------------------------------------------------------------------
'
Private Sub moApplication_DocumentBeforePrint(ByVal oDoc As Document, Cancel As Boolean)
    Dim bSaved                As Boolean
    bSaved = oDoc.Saved
    Call DocUnlock(oDoc)
    With oDoc.PageSetup
        .FirstPageTray = wdPrinterDefaultBin
        .OtherPagesTray = wdPrinterDefaultBin
    End With
    Call DocLock(oDoc)
    oDoc.Saved = bSaved
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub moApplication_DocumentBeforeSave
'| DateTime   : 16.02.2017 13:45
'| Author     : Grube
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub moApplication_DocumentBeforeSave(ByVal oDoc As Document, SaveAsUI As Boolean, bCancel As Boolean)
    Dim tFileName                       As String
    Dim tIAN_ETA                        As String
    Dim tVersion                        As String
    Static bLock                        As Boolean
    Dim bCancelSave                     As Boolean
        
    If gbLockDocumentBeforeSave Then Exit Sub
    
    bCancelSave = True
    Log ("DocumentBeforeSave: mbBuildDoc:" & mbBuildDoc & " ProtectionType: " & ThisDocument.ProtectionType)
    If Not ThisDocument Is oDoc Then Exit Sub
    If bLock Then Exit Sub
        If (IsVBProjectUnlocked() Or mbBuildDoc) Then
            If mbBuildDoc Then
                Call RefreshBuildDoc
            End If
            Exit Sub
        End If
    '#### Initialisierung Fortschrittsbalken
    If mbTurnToRed Or mbCheckFieldsOnSave Then
        '#### 180823 AG Anpassungen f|fffd|r 64 Bit
        Set mFrmProgress = New |fffd|LCL_FProgressNew_x32_64
        mbFrmProgressLoaded = True
        Call mFrmProgress.SetCaption("Speicherung ...")
        Call mFrmProgress.Show(vbModeless)
        Call mFrmProgress.SetProgress1(0)
        Call mFrmProgress.SetInfo1("Bitte warten. Pr|fffd|fung der Felder l|fffd|uft ...")
        DoEvents
    End If
    Call CheckFieldsOnSave(bCancelSave)

    If bCancelSave = True Then
        'MsgBox "Speichern wurde abgebrochen."
        oDoc.Saved = False
        bCancel = True
    Else
        Call DocUnlock(ThisDocument)
        tVersion = PropGetNormalProp(oDoc, "Version")
        '#### 160826 AG wenn IAN im Namen enthalten ist, so wird der Dokumentname verwendet
        If Len(GetIANFromFileName(oDoc.Name, tIAN_ETA)) > 2 Then
            tFileName = oDoc.Name
        Else
            tIAN_ETA = CStr(ThisDocument.FormFields("ff_Interne_Art_Nr").result) & "_AB_ETA"
            tFileName = Replace(Replace(oDoc.CustomDocumentProperties.Item("ABFileName"), "_Template", ""), "AB_", "AB_ETA_")
            tFileName = Replace(tFileName, ".docm", "_" & Replace(tVersion, ".", "_") & ".docm")
            tFileName = CStr(ThisDocument.FormFields("ff_Interne_Art_Nr").result) & "_" & tFileName
        End If
        tFileName = GetAddOnFileName(tFileName, vbNullString, ".docm")
        Call UpdateBookmark("ff_AB_Version", tVersion, False)
        
        If SaveAsUI Or oDoc.Name Like gctTEMPLATE Then
            If mbFrmProgressLoaded Then
                Call mFrmProgress.Hide
            End If
            tFileName = SelectSaveFile(Application, "Datei speichern unter", oDoc.Path & "\" & tFileName, "Microsoft Word Dateien (*.docm)", "*.docm")
            If SaveAsUI Then
                '#### 170216 AG SendKeys nur bei Speichern unter durchf|fffd|hren
                '#### 170320 AG Wegen Bug: immer NUMLOCK mit auf den Weg geben, sonst wird die Taste blinkerm|fffd||fffd|ig an- und abgeschaltet
                Call SendKeys("{NUMLOCK}{ESC}", True)
                DoEvents
            End If
            '#### 161202 AG INT-ETA Kombination mit speichern
            Call GetIANFromFileName(tFileName, tIAN_ETA)
            Call UpdateBookmark("ff_IAN_ETA", tIAN_ETA, False)
            Call DocLock(ThisDocument)
        
            If Len(tFileName) > 0 Then
                Call PropIncrementVersion(oDoc, False)
                '### Protokollierung f|fffd|r nicht INT-PC
                If mbTurnToRed Then
                    If mbFrmProgressLoaded Then
                        Call mFrmProgress.Show(vbModeless)
                        Call mFrmProgress.SetShowDoubleProgress(True)
                        'Call mFrmProgress.SetInfo1("Bitte warten. Protokoll wird generiert.")
                        Call mFrmProgress.SetInfo2("Bitte warten. Protokoll wird generiert.")
                        'Call mFrmProgress.SetProgress1(0)
                        Call mFrmProgress.SetProgress2(50 * Abs(mbCheckFieldsOnSave))
                        DoEvents
                    End If
                    Call DoProtocol(ThisDocument)
                End If
                ThisDocument.Application.DisplayAlerts = wdAlertsNone
                bLock = True
                '#### 170522 AG algemeine Speicherroutine aufrufen
                Call CallSaveAs(oDoc, tFileName:=tFileName, lWordFileFormat:=WdSaveFormat.wdFormatXMLDocumentMacroEnabled)
                'Call oDoc.SaveAs(tFileName, WdSaveFormat.wdFormatXMLDocumentMacroEnabled)
                bLock = False
                ThisDocument.Application.DisplayAlerts = wdAlertsAll
            End If
        Else
            Call UpdateBookmark("ff_IAN_ETA", tIAN_ETA, False)
            Call DocLock(ThisDocument)
            Call PropIncrementVersion(oDoc, False)
            '### Protokollierung f|fffd|r nicht INT-PC
            If mbTurnToRed Then
                If mbFrmProgressLoaded Then
                    Call mFrmProgress.Show(vbModeless)
                        Call mFrmProgress.SetShowDoubleProgress(True)
                        'Call mFrmProgress.SetInfo1("Bitte warten. Protokoll wird generiert.")
                        Call mFrmProgress.SetInfo2("Bitte warten. Protokoll wird generiert.")
                        'Call mFrmProgress.SetProgress1(0)
                        Call mFrmProgress.SetProgress2(50 * Abs(mbCheckFieldsOnSave))
                        DoEvents
                End If
                Call DoProtocol(ThisDocument)
            End If
            ThisDocument.Application.DisplayAlerts = wdAlertsNone
            bLock = True
            '#### 170522 AG algemeine Speicherroutine aufrufen
            Call CallSaveAs(oDoc, tFileName:=GetAddOnFileName(oDoc.Path & "\" & oDoc.Name, vbNullString, ".docm"), lWordFileFormat:=WdSaveFormat.wdFormatXMLDocumentMacroEnabled)
            'Call oDoc.SaveAs(GetAddOnFileName(oDoc.Path & "\" & oDoc.Name, vbNullString, ".docm"), WdSaveFormat.wdFormatXMLDocumentMacroEnabled)
            bLock = False
            ThisDocument.Application.DisplayAlerts = wdAlertsAll
        End If
        oDoc.Saved = True
        bCancel = True
    End If
    '#### Schlie|fffd|en Formular mit Fortschrittsbalken
    If mbFrmProgressLoaded Then
        Call mFrmProgress.Hide
        Unload mFrmProgress
        Set mFrmProgress = Nothing
        mbFrmProgressLoaded = False
    End If
End Sub
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "1Normal.ThisDocument"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = True
Attribute VB_Customizable = True
Option Explicit

Private moAppClass As New ThisApplication

',--------------------------------------------------------------------------------------
'| Module     : Sub Document_New
'| ReturnType : -
'| DateTime   : 10.11.2015 13:39
'| Author     : Grube
'| Purpose    : Dokument |fffd|ber neu ge|fffd|ffnet
'`--------------------------------------------------------------------------------------
'
Private Sub Document_New()
    Call MsgOutput("This feature is not available!", vbNullString, vbCritical)
    Call ThisDocument.Close(False)
    
    Call DocOpen(True)
End Sub

',--------------------------------------------------------------------------------------
'| Module     : Sub Document_Open
'| ReturnType : -
'| DateTime   : 10.11.2015 13:39
'| Author     : Grube
'| Purpose    : Dokument |fffd|ber |fffd|ffnen ge|fffd|ffnet
'`--------------------------------------------------------------------------------------
'
Private Sub Document_Open()
    Dim bCloseDoc       As Boolean
    Dim tErrorText      As String
    
On Error GoTo Open_Error
    '#### Einmaliger Click f|fffd|r Buttons
    ThisDocument.Application.Options.ButtonFieldClicks = 1
        
    Call DocOpen(False)
    Call MXMLImporter.ImportXML
    Exit Sub
Open_Error:
    
    If Err.number = 4605 Then
        bCloseDoc = True
        tErrorText = "This document can not be used with the current Office settings." & vbLf & vbLf & _
                     "Please disable the following Word option:" & vbLf & _
                     ">> Open e-mail attachments and other non-editable files in read mode <<" & vbLf & vbLf & _
                     "Note:" & vbLf & _
                     "The above setting is located under File-> Options on the General tab." & vbLf & "##########" & vbLf & _
                     "Dieses Dokument kann nicht mit den aktuellen Office-Einstellungen verwendet werden." & vbLf & vbLf & _
                     "Bitte deaktivieren Sie die folgende Word-Option: " & vbLf & _
                     ">>E-Mail-Anlagen und andere nicht bearbeitbare Dateien im Lesemodus |fffd|ffnen<<" & vbLf & vbLf & _
                     "Hinweis: " & vbLf & _
                     "Die o.g. Einstellung befindet sich unter Datei->Optionen im Register Allgemein."
    Else
        tErrorText = "Problem when opening the document:" & vbLf & vbLf & "Number:" & Err.number & vbLf & "Error description:"
    End If
    Call MsgOutput(tErrorText, vbNullString, vbCritical)
    
    If bCloseDoc Then
        Call ThisDocument.Close(False)
    End If
End Sub

',--------------------------------------------------------------------------------------
'| Module     : Sub DocOpen
'| ReturnType : -
'| DateTime   : 10.11.2015 13:39
'| Author     : Grube
'| Purpose    : allgemeine |fffd|ffnen -Routine
'`--------------------------------------------------------------------------------------
'
Private Sub DocOpen(bNew As Boolean)
    mbOpenMode = E_AB_OPENMODE.NORMAL
    With ThisDocument
        Init_Globals
        
        Set moAppClass.moApplication = Word.Application
        
        If bNew Then
            Call FillDeliveryByCountryCol("new")
        Else
            '#### Collection mit den Daten der Liefermengen
            If .Bookmarks.Exists("ff_L_Kolli_DE") Then
                Call FillDeliveryByCountryCol("old")
            End If
        End If
        
        '#### Schalter Protokollierung bei |fffd|nderungen
    '    If isINT_PC() Then
    '        mbTurnToRed = False
    '    Else
    '        mbTurnToRed = True
    '    End If
    '    '#### Schalter Validierung beim Speichern
    '    If isINT_PC() Then
    '        mbCheckFieldsOnSave = False
    '    Else
    '        mbCheckFieldsOnSave = True
    '    End If
        '#### Schalter Validierung beim Speichern (in jedem Fall aktivieren)
        mbCheckFieldsOnSave = True
        ' #### Autospeicherung deaktivieren
        Options.SaveInterval = 0
        
        If mbDEBUG Then
            'MsgBox ("Document_Open " & " bTurnToRed " & bTurnToRed)
            Log "Document_Open " & " bTurnToRed " & mbTurnToRed & " ProtectionType: " & .ProtectionType
        End If
      
        '#### Seitenlayoutansicht, Dokumentstrukturansicht
        .Windows(1).DocumentMap = True
      
      
        '#### Positionierung auf das FormField Eink|fffd|ufer
        If .Bookmarks.Exists("ff_Einkaeufer") = True Then    'pr|fffd|fen, ob Textmarke vorhanden
            .Bookmarks("ff_Einkaeufer").Select    'Textmarke (Textfeld) markieren
            Call Storetxt
        End If
        .Application.ScreenUpdating = True
      
        '#### Einmaliger Click f|fffd|r Buttons
        .Application.Options.ButtonFieldClicks = 1
      
        ' Bind the Enter key to the EnterKeyMacro.
    'Call MsgBox(mbBuildDoc)
        Call ManageKeyBinding(mbBuildDoc)
        ' #### Speicherfrage beim Schlie|fffd|en vermeiden
        
        .Saved = True
        mbInitDocument = False
    End With
End Sub

',--------------------------------------------------------------------------------------
'| Module     : Sub Document_Close
'| ReturnType : -
'| DateTime   : 10.11.2015 13:39
'| Author     : Grube
'| Purpose    : Schliessen des Dokumentes
'`--------------------------------------------------------------------------------------
'
Private Sub Document_Close()
    '    CustomizationContext = ThisDocument
    '    FindKey(KeyCode:=BuildKeyCode(wdKeyReturn)).Disable

    If mbDEBUG Then
        'MsgBox ("Document_Close " & " bTurnToRed " & bTurnToRed)
        Log "Document_Close " & " mbTurnToRed " & mbTurnToRed & " ProtectionType: " & ThisDocument.ProtectionType
    End If

    On Error GoTo Document_Close_Error
    
    
    ThisDocument.AttachedTemplate.Saved = True
    Call ManageKeyBinding(True)
    Set moAppClass.moApplication = Nothing
    Exit Sub

Document_Close_Error:
    Select Case Err.number
        Case 4605:
            '#### 161018 AG Folgefehler 4605 ausschalten "E-Mail-Anlagen und andere nicht bearbeitbare Dateien im Lesemodus |fffd|ffnen"
        Case Else:
            Call Err.Raise(number:=Err.number)
     End Select
End Sub
Attribute VB_Name = "cFormField"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mbFormFieldEdited     As Boolean
Private mtFormFieldName       As String
Private mtFormFieldValueOld   As String
Private mtFormFieldValueNew   As String
Private mtCatalogValue        As String     ' f|fffd|r die Verwendung einer Listenauswahl
Private mbIsCatalog           As Boolean    ' f|fffd|r die Verwendung einer Listenauswahl

',--------------------------------------------------------------------------------------
'| Module     : Function GetFormFieldName
'| ReturnType : String
'| DateTime   : 20.10.2015 13:41
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetFormFieldName() As String
    GetFormFieldName = mtFormFieldName
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function GetFormFieldValueNew
'| ReturnType : String
'| DateTime   : 20.10.2015 13:41
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetFormFieldValueNew() As String
    If mbIsCatalog Then
        GetFormFieldValueNew = mtCatalogValue
    Else
        GetFormFieldValueNew = mtFormFieldValueNew
    End If
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function GetFormFieldValueOld
'| ReturnType : String
'| DateTime   : 20.10.2015 13:41
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetFormFieldValueOld() As String
    GetFormFieldValueOld = mtFormFieldValueOld
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function GetFormFieldEdited
'| ReturnType : Boolean
'| DateTime   : 20.10.2015 13:41
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetFormFieldEdited() As Boolean
    GetFormFieldEdited = mbFormFieldEdited
End Function

',--------------------------------------------------------------------------------------
'| Module     : Function GetIsCatalog
'| ReturnType : Boolean
'| DateTime   : 20.10.2015 13:41
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function GetIsCatalog() As Boolean
    GetIsCatalog = mbIsCatalog
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub SetFormFieldValueNew
'| DateTime   : 20.10.2015 15:24
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function SetFormFieldValueNew(tValue As String)
    If mbIsCatalog Then
        mtCatalogValue = tValue
    Else
        mtFormFieldValueNew = tValue
    End If
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub SetEdited
'| DateTime   : 20.10.2015 15:24
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Sub SetFormFieldEdited(bValue As Boolean)
    mbFormFieldEdited = bValue
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub SetFormFieldValueOld
'| DateTime   : 20.10.2015 15:24
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function SetFormFieldValueOld(tValue As String)
    mtFormFieldValueOld = tValue
End Function

',--------------------------------------------------------------------------------------
'| Procedure  : Sub Init
'| DateTime   : 17.05.2017 13:40
'| Author     : Grube
'| Purpose    : Initialisierung
'|              170517 AG Anpassung auf Katalogfelder
'`--------------------------------------------------------------------------------------
'
Public Sub Init(tName As String, tValue As String)
    mtFormFieldName = tName
    mtFormFieldValueOld = tValue
    mbIsCatalog = Left$(tName, 2) = "dd"
    '#### 171108 AG f|fffd|r automatische XML-Bef|fffd|llung erg|fffd|nzt
    Call SetFormFieldValueNew(tValue)
End Sub

',--------------------------------------------------------------------------------------
'| Procedure  : Sub InitCatalogValue
'| DateTime   : 19.04.2017 15:24
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Public Function InitCatalogValue(tValue As String)
    mtCatalogValue = tValue
End Function

Attribute VB_Name = "frmDropDown"
Attribute VB_Base = "0{2D41598F-A2C7-4CA3-A047-52892B930CB2}{348E41EC-D0A4-46A3-A8A5-7C697A8837E3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private WithEvents cmdCancel  As MSForms.CommandButton
Attribute cmdCancel.VB_VarHelpID = -1
Private WithEvents cmdOK      As MSForms.CommandButton
Attribute cmdOK.VB_VarHelpID = -1
Private WithEvents cbbFeld    As MSForms.ComboBox
Attribute cbbFeld.VB_VarHelpID = -1
 
Private mtEintraege()         As String
Private mtAufforderung        As String
Private mtTitel               As String
 
Private mvFldName             As Variant
Private mvFldValue            As Variant
Private mtFldStatus           As String
Private mtFldHelp             As String
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub cbbFeld_Change
'| DateTime   : 20.10.2015 13:25
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub cbbFeld_Change()
    With ThisDocument
        .FormFields(mvFldName).result = cbbFeld.Value
        If mDictFormFields.Exists(mvFldName) Then
            Call mDictFormFields.Item(mvFldName).InitCatalogValue(CStr(cbbFeld.Value))
        End If
        Call CheckInspectionCenter(ThisDocument, .FormFields(mvFldName))
    End With
    Application.ScreenRefresh
End Sub
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub cmdCancel_Click
'| DateTime   : 20.10.2015 13:26
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub cmdCancel_Click()
    If Not mvFldValue = "" Then
        ThisDocument.FormFields(mvFldName).result = mvFldValue
    End If
    '#### 170112 AG Feld in jedem Fall verlassen
    Call SendKeys("{NUMLOCK}{ENTER}")
    Unload Me
End Sub
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub cmdOK_Click
'| DateTime   : 20.10.2015 13:26
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub cmdOK_Click()
    Call SendKeys("{NUMLOCK}{ENTER}")
    Unload Me
End Sub
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub DropdownFormularInit
'| DateTime   : 20.10.2015 13:09
'| Author     :
'| Purpose    :
'|              180319 AG Flag for EmptyEntry
'`--------------------------------------------------------------------------------------
'
Sub DropdownFormularInit(tArray() As String, ByVal tTitel_Param As String, ByVal tAufforderung As String, Optional bEmptyEntry As Boolean = True)
    Dim lIndex                  As Long
    Dim lMaxEntry               As Long
    
    lMaxEntry = UBound(tArray)
    If bEmptyEntry Then
        lMaxEntry = lMaxEntry + 1
    End If
    ReDim mtEintraege(lMaxEntry)
    For lIndex = 0 To UBound(tArray)
        mtEintraege(lIndex) = tArray(lIndex)
    Next
    If bEmptyEntry Then
        '#### 170726 AG definierten Wert setzen
        mtEintraege(lIndex) = vbNullString
    End If
    mtAufforderung = tAufforderung
    mtTitel = tTitel_Param
    Me.Show
End Sub


',--------------------------------------------------------------------------------------
'| Procedure  : Sub DropDownSchaltflaechenHinzufuegen
'| DateTime   : 20.10.2015 13:26
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub DropDownSchaltflaechenHinzufuegen()
    Dim oName                 As MSForms.Label
 
    Dim lBreite               As Long
    Dim lRechts               As Long
 
    Set oName = Me.Controls.Add("Forms.Label.1", , True)
    With oName
        .Top = 4
        .Left = 9
        .Height = 12
        .Width = 240
        .Caption = mtAufforderung
    End With
 
 
    Set cbbFeld = Me.Controls.Add("Forms.ComboBox.1", "cbbFeld", True)
    With cbbFeld
        .Top = 18
        .Left = 9
        .Height = 18
        .Width = 300
        .Style = fmStyleDropDownList
    End With
 
    lBreite = 60
    lRechts = Me.Width - lBreite - 12
 
    Set cmdOK = Me.Controls.Add("Forms.CommandButton.1", , True)
    With cmdOK
        .Top = 48
        .Left = lRechts
        .Height = 18
        .Width = lBreite
        .Font.Size = 8
 
        .Caption = "Ok"
        .Accelerator = "O"
        .Default = True
    End With
    lRechts = lRechts - lBreite - 6
 
    Set cmdCancel = Me.Controls.Add("Forms.CommandButton.1", , True)
    With cmdCancel
        .Top = 48
        .Left = lRechts
        .Height = 18
        .Width = lBreite
        .Font.Size = 8
        .Caption = "Abbrechen"
        .Accelerator = "A"
        .Cancel = True
    End With
    lRechts = lRechts - lBreite - 6
    Set oName = Nothing
End Sub
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub UserForm_QueryClose
'| DateTime   : 20.10.2015 13:26
'| Author     :
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then cmdCancel_Click
End Sub
 
',--------------------------------------------------------------------------------------
'| Procedure  : Sub UserForm_Activate
'| DateTime   : 18.11.2015 11:25
'| Author     : Grube
'| Purpose    :
'`--------------------------------------------------------------------------------------
'
Private Sub UserForm_Activate()
    Dim oRng                  As Word.Range
    Dim oBookmark             As Word.Bookmark
    
    Me.Caption = mtTitel
    Me.Height = 96
    Me.Width = 320
    Set oRng = ThisDocument.Windows(1).Selection.Range
    For Each oBookmark In oRng.Bookmarks
        If Left$(oBookmark.Name, 2) = "dd" Then
            mvFldName = oBookmark.Name
        End If
    Next oBookmark
    
    If Len(mvFldName) > 0 Then
        With ThisDocument.FormFields(mvFldName)
            If .DropDown.Valid Then
                If .DropDown.ListEntries.Count > 0 Then
                    mvFldValue = .result
                End If
            Else
                mvFldValue = .result
            End If
            If .OwnStatus Then mtFldStatus = .StatusText
            If .OwnHelp Then mtFldHelp = .HelpText
        End With
    Else
        Call MsgOutput("The field name could not be determined from the " & oRng.Bookmarks.Count & " selected fields.", vbNullString, vbCritical, "frmDropDown")
        'Call MsgOutput("Der Feldname konnte nicht aus den " & oRng.Bookmarks.Count & " selektierten Feldern ermittelt werden.", vbNullString, vbCritical, "frmDropDown")
    End If
    Call DropDownSchaltflaechenHinzufuegen
    cbbFeld.List = mtEintraege()
    Set oRng = Nothing
    Set oBookmark = Nothing
End Sub
  
 


Attribute VB_Name = "|fffd|LCL_FProgressNew_x32_64"
Attribute VB_Base = "0{AE090ED5-8B94-4720-AADD-68A867591BA5}{CA897127-22E5-467C-94B2-87A643B670B3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



',---------------------------------------------------------------------------------------
'| Module   : Modul |fffd|LCL_FProgressNew_x32_64
'| DateTime : 20.04.2006 09:40
'| Author   : Kremm
'| Purpose  : Stellt einen Prozentbalken dar
'|            180829 AG Anpassungen f|fffd|r 32/64 Bit
'`---------------------------------------------------------------------------------------
'
Option Explicit
#If VBA7 Then
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As LongPtr, ByVal nIndex As Long) As Long

#Else

Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long

#End If

Private Const GWL_STYLE                 As Long = (-16)
Private Const WS_SYSMENU                As Long = &H80000

Private Sub UserForm_Initialize()
    Dim lColor As Long

    Call NoCloseButton(Me)
    
    lColor = RGB(10, 99, 50)
    frmProgress1.BorderColor = lColor
    frmProgress2.BorderColor = lColor
    lblProgress1.BackColor = lColor
    lblProgress2.BackColor = lColor

    Call SetInfo1(vbNullString)
    Call SetInfo1(vbNullString)
    Call SetProgress1(0)
    Call SetProgress2(0)
    Call SetShowDoubleProgress(False)
    
    Call UserForm_Resize
End Sub

Private Sub UserForm_Resize()
    lblInfo1.Width = Me.InsideWidth - lblInfo1.Left * 2
    lblInfo2.Width = Me.InsideWidth - lblInfo2.Left * 2
    frmProgress1.Width = Me.InsideWidth - frmProgress1.Left * 2
    frmProgress2.Width = Me.InsideWidth - frmProgress2.Left * 2
End Sub

Public Sub SetCaption(ByVal tCaption As String, ParamArray vParameters() As Variant)
    Me.Caption = SPrintF(tCaption, Join(vParameters, vbNullChar))
    Call NoCloseButton(Me)
End Sub

Public Sub SetInfo1(ByVal tInfo As String, ParamArray vParameters() As Variant)
    lblInfo1.Caption = SPrintF(tInfo, Join(vParameters, vbNullChar))
    Call Me.Repaint
End Sub

Public Sub SetInfo2(ByVal tInfo As String, ParamArray vParameters() As Variant)
    lblInfo2.Caption = SPrintF(tInfo, Join(vParameters, vbNullChar))
    Call Me.Repaint
End Sub

Public Sub SetProgress1(Optional dFactor As Double = 0, Optional iPercent As Integer = 0)
    If dFactor = 0 Then dFactor = iPercent / 100
    If iPercent = 0 Then iPercent = Round(dFactor * 100)
    lblProgress1.Width = frmProgress1.Width * dFactor
    lblProgress1.Caption = CStr(iPercent) & " %"
    Call Me.Repaint
End Sub

Public Sub SetProgress2(Optional dFactor As Double = 0, Optional iPercent As Integer = 0)
    If dFactor = 0 Then dFactor = iPercent / 100
    If iPercent = 0 Then iPercent = Round(dFactor * 100)
    lblProgress2.Width = frmProgress2.Width * dFactor
    lblProgress2.Caption = CStr(iPercent) & " %"
    Call Me.Repaint
End Sub

Public Sub SetShowDoubleProgress(bSHow As Boolean)
    If Not bSHow Then
        lblInfo1.Font.Bold = False
        lblInfo2.Visible = False
        frmProgress2.Visible = False
        frmProgress1.Top = 24
        Me.Height = 70.25
    Else
        lblInfo1.Font.Bold = True
        lblInfo2.Visible = True
        frmProgress2.Visible = True
        frmProgress1.Top = 42
        Me.Height = 106.25
    End If
End Sub

#If VBA7 Then

Private Sub NoCloseButton(obj As Object)
    Dim hwnd                            As LongPtr
    Dim lStyle                          As Long

    On Error GoTo MiscError

    hwnd = GetHwnd(obj)
    lStyle = GetWindowLong(hwnd, GWL_STYLE)

    Call SetWindowLong(hwnd, GWL_STYLE, lStyle And Not WS_SYSMENU)

    Exit Sub
MiscError:
    Exit Sub
End Sub

Private Function GetHwnd(obj As Object) As LongPtr
    If Int(Val(Application.Version)) < 9 Then
        GetHwnd = FindWindow("ThunderXFrame", obj.Caption)
    Else
        GetHwnd = FindWindow("ThunderDFrame", obj.Caption)
    End If
End Function

#Else

Private Sub NoCloseButton(obj As Object)
    Dim hwnd                            As Long
    Dim lStyle                          As Long

    On Error GoTo MiscError

    hwnd = GetHwnd(obj)
    lStyle = GetWindowLong(hwnd, GWL_STYLE)

    Call SetWindowLong(hwnd, GWL_STYLE, lStyle And Not WS_SYSMENU)

    Exit Sub
MiscError:
    Exit Sub
End Sub

Private Function GetHwnd(obj As Object) As Long
    If Int(Val(Application.Version)) < 9 Then
        GetHwnd = FindWindow("ThunderXFrame", obj.Caption)
    Else
        GetHwnd = FindWindow("ThunderDFrame", obj.Caption)
    End If
End Function



#End If

Private Function SPrintF(ByVal tString As String, tParameters As String) As String
    Dim vParameters() As String
    Dim i As Long

    '#### Parameter ersetzen:
    vParameters = Split(tParameters, vbNullChar)
    For i = LBound(vParameters) To UBound(vParameters)
        tString = Replace(tString, "%" & CStr(i), CStr(vParameters(i)))
    Next i

    '#### Sonderzeichen ersetzen:
    tString = Replace(tString, "\\", vbNullChar)
    tString = Replace(tString, "\n", vbLf)
    tString = Replace(tString, "\r", vbCr)
    tString = Replace(tString, "\t", vbTab)
    SPrintF = Replace(tString, vbNullChar, "\")
End Function
Attribute VB_Name = "|fffd|LCL_MWinApiDialogs_x32"
',---------------------------------------------------------------------------------------
'| Module   : Modul MWinApiDialogs
'| DateTime : 20.04.2006 09:40
'| Author   : Kremm
'| Purpose  : Stellt einige Standard-Dialoge aus der Windows-API zur Verf|fffd|gung
'|            180829 AG Anpassungen f|fffd|r Office 2007
'`---------------------------------------------------------------------------------------
'
Option Explicit
Option Private Module

#If VBA7 Then
#Else

'#### Findet Fenster nach Fenster-Klasse und Fenster-Namen
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

'#### Datei-|fffd|ffnen-/Speichern-Dialog
Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long

Type OPENFILENAME
    lStructSize As Long
    hwndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
    pvReserved As Long
    dwReserved As Long
    FlagsEx As Long
End Type

'Private Const OFN_EX_NOPLACESBAR        As Long = &H1
'Private Const OFN_READONLY              As Long = &H1
'Private Const OFN_OVERWRITEPROMPT       As Long = &H2
Private Const OFN_HIDEREADONLY          As Long = &H4
'Private Const OFN_NOCHANGEDIR           As Long = &H8
'Private Const OFN_SHOWHELP              As Long = &H10
'Private Const OFN_ENABLEHOOK            As Long = &H20
'Private Const OFN_ENABLETEMPLATE        As Long = &H40
'Private Const OFN_ENABLETEMPLATEHANDLE  As Long = &H80
'Private Const OFN_NOVALIDATE            As Long = &H100
Private Const OFN_ALLOWMULTISELECT      As Long = &H200
'Private Const OFN_EXTENSIONDIFFERENT    As Long = &H400
Private Const OFN_PATHMUSTEXIST         As Long = &H800
Private Const OFN_FILEMUSTEXIST         As Long = &H1000
'Private Const OFN_CREATEPROMPT          As Long = &H2000
'Private Const OFN_SHAREAWARE            As Long = &H4000
'Private Const OFN_NOREADONLYRETURN      As Long = &H8000
'Private Const OFN_NOTESTFILECREATE      As Long = &H10000
'Private Const OFN_NONETWORKBUTTON       As Long = &H20000
'Private Const OFN_NOLONGNAMES           As Long = &H40000
Private Const OFN_EXPLORER              As Long = &H80000
'Private Const OFN_NODEREFERENCELINKS    As Long = &H100000
'Private Const OFN_LONGNAMES             As Long = &H200000
'Private Const OFN_ENABLEINCLUDENOTIFY   As Long = &H400000
'Private Const OFN_ENABLESIZING          As Long = &H800000
'Private Const OFN_USEMONIKERS           As Long = &H1000000
'Private Const OFN_DONTADDTORECENT       As Long = &H2000000
'Private Const OFN_FORCESHOWHIDDEN       As Long = &H10000000

'#### Farbauswahl-Dialog
Private Declare Function ChooseColorAPI Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As ChooseColorArguments) As Long

Private Type ChooseColorArguments
    lStructSize                         As Long
    hwndOwner                           As Long
    hInstance                           As Long
    rgbResult                           As Long
    lpCustColors                        As String
    flags                               As Long
    lCustData                           As Long
    lpfnHook                            As Long
    lpTemplateName                      As String
End Type

Private CustomColors()                  As Byte

'#### Ordnerauswahl-Dialog
Private Declare Function SHBrowseForFolder Lib "shell32.dll" (ByRef lpBI As SelectFolderArguments) As Long
Private Declare Function SHGetPathFromIDList Lib "shell32" (ByVal pidList As Long, ByVal lpBuffer As String) As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare Function ILCreateFromPath Lib "shell32" Alias "#157" (ByVal sPath As String) As Long

Private Type SelectFolderArguments
    hwndOwner                           As Long
    pidlRoot                            As Long
    pszDisplayName                      As String
    lpszTitle                           As String
    ulFlags                             As Long
    lpfn                                As Long
    lParam                              As Long
    iImage                              As Long
End Type

Private Const BIF_RETURNONLYFSDIRS      As Long = 1
Private Const BIF_DONTGOBELOWDOMAIN     As Long = 2
'Private Const BIF_NEWDIALOGSTYLE        As Long = &H40
'Private Const BIF_STATUSTEXT            As Long = &H4
Private Const BIF_VALIDATE              As Long = &H20

Private Const BFFM_INITIALIZED          As Long = 1
Private Const BFFM_SETSELECTIONA        As Long = (&H400 + 102)

Private Const MAX_PATH = 260

Private Function ProcAddr(addr As Long) As Long
    ProcAddr = addr
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function GetHWnd
'| ReturnType : Long
'| DateTime   : 20.04.2006 09:41
'| Author     : Kremm
'| Purpose    : Findet das Window-Handle jedes Fensters.
'`------------------------------------------------------------------------------------
'
Public Function GetHwnd(obj As Object) As Long
    Dim lVersion                        As Long
    Dim tClassName                      As String
    Dim tWindowName                     As String

    lVersion = Int(Val(Application.Version))

    If TypeOf obj Is Application Then
        tWindowName = obj.Caption
        tClassName = "xlMain"
    ElseIf TypeOf obj Is UserForm Then
        tWindowName = obj.Caption
        If lVersion > 8 Then
            tClassName = "ThunderDFrame"
        Else
            tClassName = "ThunderXFrame"
        End If
    Else
        GetHwnd = 0
        Exit Function
    End If
    GetHwnd = FindWindow(tClassName, tWindowName)
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectOpenFile
'| ReturnType : String
'| DateTime   : 20.04.2006 09:41
'| Author     : Kremm
'| Purpose    : Zeigt den Datei-|fffd|ffnen-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectOpenFile(owner As Object, tCaption As String, ByVal tSuggestion As String, ParamArray vFilter()) As String
    Dim args                            As OPENFILENAME
    Dim lReturn                         As Long
    Dim tFilter                         As String
    Dim i                               As Long
    Dim tSuggestionFile                 As String
    Dim tSuggestionPath                 As String

    tSuggestionFile = GetFile(tSuggestion)
    tSuggestionPath = GetFolder(tSuggestion)

    If Not IsMissing(vFilter) Then
        For i = LBound(vFilter) To UBound(vFilter)
            tFilter = tFilter & CStr(vFilter(i)) & vbNullChar
        Next i
    Else
        tFilter = "Alle Dateien (*.*)" & vbNullChar & "*.*" & vbNullChar
    End If

    With args
        .lStructSize = LenB(args)
        .hwndOwner = GetHwnd(owner)
        .lpstrFilter = tFilter
        .nFilterIndex = 1
        '.hInstance = Application.HinstancePtr
        .nMaxFile = 1024
        .lpstrFile = tSuggestionFile & String(.nMaxFile + 2 - Len(tSuggestionFile), vbNullChar)      '#### Maximal 1024 Zeichen + zwei 0-Bytes am Ende
        .nMaxFileTitle = .nMaxFile
        .lpstrFileTitle = .lpstrFile
        .lpstrInitialDir = tSuggestionPath & vbNullChar
        .lpstrTitle = tCaption
        .flags = OFN_PATHMUSTEXIST Or OFN_FILEMUSTEXIST Or OFN_EXPLORER Or OFN_HIDEREADONLY
    End With

    lReturn = GetOpenFileName(args)
    If lReturn = 0 Then
        SelectOpenFile = vbNullString
    Else
        SelectOpenFile = Left$(args.lpstrFile, InStr(args.lpstrFile, vbNullChar) - 1)
    End If

    DoEvents
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectOpenFiles
'| ReturnType : String
'| DateTime   : 20.04.2006 09:41
'| Author     : Kremm
'| Purpose    : Zeigt den Datei-|fffd|ffnen-Dialog an, und unterst|fffd|tzt Mehrfachauswahl
'`------------------------------------------------------------------------------------
'
Public Function SelectOpenFiles(owner As Object, tCaption As String, tSuggestion As String, ParamArray vFilter()) As String()
    Dim args                            As OPENFILENAME
    Dim lReturn                         As Long
    Dim tFilter                         As String
    Dim i                               As Long
    Dim temp()                          As String
    Dim baseDir                         As String
    Dim result()                        As String

    If Not IsMissing(vFilter) Then
        For i = LBound(vFilter) To UBound(vFilter)
            tFilter = tFilter & vFilter(i) & Chr(0)
        Next i
    Else
        tFilter = "Alle Dateien (*.*)" & Chr(0) & "*.*" & Chr(0)
    End If

    With args
        .lStructSize = Len(args)
        .hwndOwner = GetHwnd(owner)
        .lpstrFilter = tFilter
        .nFilterIndex = 1
        .hInstance = 0
        .lpstrFile = GetFile(tSuggestion) & String(1026 - Len(GetFile(tSuggestion)), Chr(0))    '#### Maximal 1024 Zeilen + zwei 0-Bytes am Ende
        .nMaxFile = Len(args.lpstrFile) - 2
        .lpstrFileTitle = args.lpstrFile
        .nMaxFileTitle = args.nMaxFile
        .lpstrInitialDir = GetFolder(tSuggestion) & Chr(0)
        .lpstrTitle = tCaption
        .flags = OFN_PATHMUSTEXIST Or OFN_FILEMUSTEXIST Or OFN_ALLOWMULTISELECT Or OFN_EXPLORER Or OFN_HIDEREADONLY
    End With

    lReturn = GetOpenFileName(args)
    If lReturn = 0 Then
        ReDim result(0 To 0)
    ElseIf lReturn = 1 Then
        args.lpstrFile = Left(args.lpstrFile, InStr(args.lpstrFile, Chr(0) & Chr(0)) - 1)
        If InStr(args.lpstrFile, Chr(0)) > 0 Then
            temp = Split(args.lpstrFile, Chr(0))
            baseDir = temp(0)
            ReDim result(LBound(temp) To UBound(temp) - 1)
            For i = LBound(temp) To UBound(temp) - 1
                result(i) = baseDir & "\" & temp(i + 1)
            Next i
        Else
            ReDim result(0 To 0)
            result(0) = args.lpstrFile
        End If
    Else
        args.lpstrFile = Left(args.lpstrFile, InStr(args.lpstrFile, Chr(0) & Chr(0)))
        result = Split(args.lpstrFile, Chr(0))
    End If
    SelectOpenFiles = result

    DoEvents
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectSaveFile
'| ReturnType : String
'| DateTime   : 20.04.2006 09:40
'| Author     : Kremm
'| Purpose    : Zeigt den Datei-Speichern-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectSaveFile(owner As Object, tCaption As String, tSuggestion As String, ParamArray vFilter() As Variant) As String
    Dim args                            As OPENFILENAME
    Dim lReturn                         As Long
    Dim tFilter                         As String
    Dim i                               As Long
    Dim tSuggestionFile                 As String
    Dim tSuggestionPath                 As String

    tSuggestionFile = GetFile(tSuggestion)
    tSuggestionPath = GetFolder(tSuggestion)

    If Not IsMissing(vFilter) Then
        For i = LBound(vFilter) To UBound(vFilter)
            tFilter = tFilter & CStr(vFilter(i)) & vbNullChar
        Next i
    Else
        tFilter = "Alle Dateien (*.*)" & vbNullChar & "*.*" & vbNullChar
    End If

    With args
        .lStructSize = LenB(args)
        .hwndOwner = GetHwnd(owner)
        .lpstrFilter = tFilter
        .nFilterIndex = 1
        '.hInstance = Application.HinstancePtr
        .nMaxFile = 1024
        .lpstrFile = tSuggestionFile & String(.nMaxFile + 2 - Len(tSuggestionFile), vbNullChar)      '#### Maximal 1024 Zeichen + zwei 0-Bytes am Ende
        .nMaxFileTitle = .nMaxFile
        .lpstrFileTitle = .lpstrFile
        .lpstrInitialDir = tSuggestionPath & vbNullChar
        .lpstrTitle = tCaption
        .flags = OFN_PATHMUSTEXIST Or OFN_EXPLORER Or OFN_HIDEREADONLY
    End With

    lReturn = GetSaveFileName(args)
    If lReturn = 0 Then
        SelectSaveFile = vbNullString
    Else
        SelectSaveFile = Left$(args.lpstrFile, InStr(args.lpstrFile, vbNullChar) - 1)
    End If

    DoEvents
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectColor
'| ReturnType : Long
'| DateTime   : 20.04.2006 09:40
'| Author     : Kremm
'| Purpose    : Zeigt den Farbauswahl-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectColor(owner As Object) As Long
    Dim args                            As ChooseColorArguments

    args.lStructSize = Len(args)
    args.hwndOwner = GetHwnd(owner)
    args.hInstance = 0
    args.lpCustColors = StrConv(CustomColors, vbUnicode)
    args.flags = 0
    If ChooseColorAPI(args) <> 0 Then
        SelectColor = args.rgbResult
    End If
End Function

'---------------------------------------------------------------------------------------
' Procedure : SelectFolderNew
' Date      : 10.04.2014 16:08
' Author    : Lutzeier
' Purpose   :
'---------------------------------------------------------------------------------------
'
Public Function SelectFolderNew(sTitle As String, Optional sPath As String = vbNullString) As String
    Dim dlgFolder             As FileDialog
    Dim sItem                 As String
 
    Set dlgFolder = Application.FileDialog(msoFileDialogFolderPicker)
 
    With dlgFolder
        .AllowMultiSelect = False
        .Title = IIf(Len(sTitle) > 0, sTitle, "")
        .InitialFileName = IIf(Len(sPath) > 0, sPath & "\*.*", "")
        If .Show <> -1 Then GoTo NextCode
        sItem = .SelectedItems(1)
    End With
NextCode:
    SelectFolderNew = sItem
    Set dlgFolder = Nothing
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectFolder
'| ReturnType : String
'| DateTime   : 20.04.2006 09:40
'| Author     : Kremm
'| Purpose    : Zeigt den Ordnerauswahl-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectFolder(owner As Object, Optional dlgTitle As String = vbNullString, Optional defaultPath As String = vbNullString) As String
    Dim args                            As SelectFolderArguments
    Dim lpIDList                        As Long
    Dim sBuffer                         As String

    args.hwndOwner = GetHwnd(owner)
    args.lpszTitle = dlgTitle & Chr(0)
    args.ulFlags = BIF_RETURNONLYFSDIRS + BIF_DONTGOBELOWDOMAIN + BIF_VALIDATE
    args.lpfn = ProcAddr(AddressOf SelectFolderCallback)
    If Len(defaultPath) > 0 Then
        args.lParam = PathToPIDL(defaultPath)
    End If

    lpIDList = SHBrowseForFolder(args)

    If lpIDList Then
        sBuffer = Space$(MAX_PATH)
        Call SHGetPathFromIDList(lpIDList, sBuffer)
        sBuffer = Left$(sBuffer, InStr(sBuffer, vbNullChar) - 1)
        SelectFolder = sBuffer
    Else
        SelectFolder = vbNullString
    End If
End Function

Private Function SelectFolderCallback(ByVal hwnd As Long, ByVal uMsg As Long, ByVal lParam As Long, ByVal lpData As Long) As Long
    If uMsg = BFFM_INITIALIZED Then    '#### Dialog wurde initialisiert
        '#### Standard-Pfad im Dialog selektieren (Pointer in lpData):
        Call SendMessage(hwnd, BFFM_SETSELECTIONA, False, ByVal lpData)
    End If
End Function

Private Function PathToPIDL(ByVal sPath As String) As Long
    Dim lRet                            As Long

    lRet = ILCreateFromPath(sPath)
    If lRet = 0 Then
        sPath = StrConv(sPath, VbStrConv.vbUnicode)
        lRet = ILCreateFromPath(sPath)
    End If

    PathToPIDL = lRet
End Function

Private Function GetFile(tFileName As String) As String
    If InStr(tFileName, "\") > 0 Then
        GetFile = Mid$(tFileName, InStrRev(tFileName, "\") + 1)
    Else
        GetFile = tFileName
    End If
End Function

Private Function GetFolder(tFileName As String) As String
    If InStr(tFileName, "\") > 0 Then
        GetFolder = Left$(tFileName, InStrRev(tFileName, "\") - 1)
    Else
        GetFolder = tFileName
    End If
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function MsgBoxEx
'| ReturnType : VbMsgBoxResult
'| DateTime   :
'| Author     : Kremm
'| Purpose    : Ersatz f|fffd|r die eingebaute MsgBox-Funktion. Kann genau wie diese
'|              verwendet werden. Zeigt bei einigen VbMsgBoxStyles vor dem Nachrichten-
'|              Text automatisch eine passende |fffd|berschrift an. F|fffd|r den Titel der MsgBox
'|              wird automatisch der Projektname verwendet.
'| Remarks    :
'               180820 AG auskommentiert weil Setup(LI) unbekannt
'`------------------------------------------------------------------------------------
'
'Public Function MsgBoxEx(ByVal tMessage As String, eStyle As VbMsgBoxStyle, ParamArray vParameters() As Variant) As VbMsgBoxResult
'    Dim i                               As Long
'    Dim hWndParent                      As Long
'
'    '#### Stil auswerten:
'    If (eStyle And vbInformation) = vbInformation Then
'        '### Keine |fffd|berschrift!
'    ElseIf (eStyle And vbQuestion) = vbQuestion Then
'        '### Keine |fffd|berschrift!
'    ElseIf (eStyle And vbExclamation) = vbExclamation Then
'        tMessage = Language("Basic", "Warning", Setup(LI)) & vbCr & vbCr & tMessage
'    ElseIf (eStyle And vbCritical) = vbCritical Then
'        tMessage = Language("Basic", "Error", Setup(LI)) & vbCr & vbCr & tMessage
'    End If
'
'    '#### Parameter ersetzen:
'    For i = LBound(vParameters) To UBound(vParameters)
'        tMessage = Replace(tMessage, "%" & CStr(i), CStr(vParameters(i)))
'    Next i
'
'    '#### Sonderzeichen ersetzen:
'    tMessage = Replace(tMessage, "\\", vbNullChar)
'    tMessage = Replace(tMessage, "\n", vbLf)
'    tMessage = Replace(tMessage, "\r", vbCr)
'    tMessage = Replace(tMessage, "\t", vbTab)
'    tMessage = Replace(tMessage, vbNullChar, "\")
'
'    '#### Das gerade aktive Fenster ist der Parent:
'    hWndParent = GetActiveWindow()
'
'    '#### MessageBox anzeigen:
'    MsgBoxEx = MessageBox(hWndParent, StrPtr(tMessage), StrPtr(ThisWorkbook.Name), eStyle)
'End Function

#End If
Attribute VB_Name = "|fffd|LCL_MWinApiDialogs_x64"
',---------------------------------------------------------------------------------------
'| Module   : Modul MWinApiDialogs
'| DateTime : 20.04.2006 09:40
'| Author   : Kremm
'| Purpose  : Stellt einige Standard-Dialoge aus der Windows-API zur Verf|fffd|gung
'|            180829 AG Anpassungen f|fffd|r Office 2007
'`---------------------------------------------------------------------------------------
'
Option Explicit
Option Private Module

#If VBA7 Then

'#### Findet Fenster nach Fenster-Klasse und Fenster-Namen
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr

'#### Datei-|fffd|ffnen-/Speichern-Dialog
Private Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long

Type OPENFILENAME
    lStructSize As Long
    hwndOwner As LongPtr
    hInstance As LongPtr
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As LongPtr
    lpfnHook As LongPtr
    lpTemplateName As String
    pvReserved As LongPtr
    dwReserved As Long
    FlagsEx As Long
End Type

'Private Const OFN_EX_NOPLACESBAR        As Long = &H1
'Private Const OFN_READONLY              As Long = &H1
'Private Const OFN_OVERWRITEPROMPT       As Long = &H2
Private Const OFN_HIDEREADONLY          As Long = &H4
'Private Const OFN_NOCHANGEDIR           As Long = &H8
'Private Const OFN_SHOWHELP              As Long = &H10
'Private Const OFN_ENABLEHOOK            As Long = &H20
'Private Const OFN_ENABLETEMPLATE        As Long = &H40
'Private Const OFN_ENABLETEMPLATEHANDLE  As Long = &H80
'Private Const OFN_NOVALIDATE            As Long = &H100
Private Const OFN_ALLOWMULTISELECT      As Long = &H200
'Private Const OFN_EXTENSIONDIFFERENT    As Long = &H400
Private Const OFN_PATHMUSTEXIST         As Long = &H800
Private Const OFN_FILEMUSTEXIST         As Long = &H1000
'Private Const OFN_CREATEPROMPT          As Long = &H2000
'Private Const OFN_SHAREAWARE            As Long = &H4000
'Private Const OFN_NOREADONLYRETURN      As Long = &H8000
'Private Const OFN_NOTESTFILECREATE      As Long = &H10000
'Private Const OFN_NONETWORKBUTTON       As Long = &H20000
'Private Const OFN_NOLONGNAMES           As Long = &H40000
Private Const OFN_EXPLORER              As Long = &H80000
'Private Const OFN_NODEREFERENCELINKS    As Long = &H100000
'Private Const OFN_LONGNAMES             As Long = &H200000
'Private Const OFN_ENABLEINCLUDENOTIFY   As Long = &H400000
'Private Const OFN_ENABLESIZING          As Long = &H800000
'Private Const OFN_USEMONIKERS           As Long = &H1000000
'Private Const OFN_DONTADDTORECENT       As Long = &H2000000
'Private Const OFN_FORCESHOWHIDDEN       As Long = &H10000000

'#### Farbauswahl-Dialog
Private Declare PtrSafe Function ChooseColorAPI Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As ChooseColorArguments) As Long

Private Type ChooseColorArguments
    lStructSize                         As Long
    hwndOwner                           As LongPtr
    hInstance                           As Long
    rgbResult                           As Long
    lpCustColors                        As String
    flags                               As Long
    lCustData                           As Long
    lpfnHook                            As Long
    lpTemplateName                      As String
End Type

Private CustomColors()                  As Byte

'#### Ordnerauswahl-Dialog
Private Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" (ByRef lpBI As SelectFolderArguments) As Long
Private Declare PtrSafe Function SHGetPathFromIDList Lib "shell32" (ByVal pidList As Long, ByVal lpBuffer As String) As Long
Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare PtrSafe Function ILCreateFromPath Lib "shell32" Alias "#157" (ByVal sPath As String) As Long

Private Type SelectFolderArguments
    hwndOwner                           As LongPtr
    pidlRoot                            As Long
    pszDisplayName                      As String
    lpszTitle                           As String
    ulFlags                             As Long
    lpfn                                As LongPtr
    lParam                              As Long
    iImage                              As Long
End Type

Private Const BIF_RETURNONLYFSDIRS      As Long = 1
Private Const BIF_DONTGOBELOWDOMAIN     As Long = 2
'Private Const BIF_NEWDIALOGSTYLE        As Long = &H40
'Private Const BIF_STATUSTEXT            As Long = &H4
Private Const BIF_VALIDATE              As Long = &H20

Private Const BFFM_INITIALIZED          As Long = 1
Private Const BFFM_SETSELECTIONA        As Long = (&H400 + 102)

Private Const MAX_PATH = 260

Private Function ProcAddr(addr As LongPtr) As LongPtr
    ProcAddr = addr
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function GetHWnd
'| ReturnType : Long
'| DateTime   : 20.04.2006 09:41
'| Author     : Kremm
'| Purpose    : Findet das Window-Handle jedes Fensters.
'`------------------------------------------------------------------------------------
'
Public Function GetHwnd(obj As Object) As LongPtr
    Dim lVersion                        As Long
    Dim tClassName                      As String
    Dim tWindowName                     As String

    lVersion = Int(Val(Application.Version))

    If TypeOf obj Is Application Then
        tWindowName = obj.Caption
        tClassName = "xlMain"
    ElseIf TypeOf obj Is UserForm Then
        tWindowName = obj.Caption
        If lVersion > 8 Then
            tClassName = "ThunderDFrame"
        Else
            tClassName = "ThunderXFrame"
        End If
    Else
        GetHwnd = 0
        Exit Function
    End If
    GetHwnd = FindWindow(tClassName, tWindowName)
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectOpenFile
'| ReturnType : String
'| DateTime   : 20.04.2006 09:41
'| Author     : Kremm
'| Purpose    : Zeigt den Datei-|fffd|ffnen-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectOpenFile(owner As Object, tCaption As String, ByVal tSuggestion As String, ParamArray vFilter()) As String
    Dim args                            As OPENFILENAME
    Dim lReturn                         As Long
    Dim tFilter                         As String
    Dim i                               As Long
    Dim tSuggestionFile                 As String
    Dim tSuggestionPath                 As String

    tSuggestionFile = GetFile(tSuggestion)
    tSuggestionPath = GetFolder(tSuggestion)

    If Not IsMissing(vFilter) Then
        For i = LBound(vFilter) To UBound(vFilter)
            tFilter = tFilter & CStr(vFilter(i)) & vbNullChar
        Next i
    Else
        tFilter = "Alle Dateien (*.*)" & vbNullChar & "*.*" & vbNullChar
    End If

    With args
        .lStructSize = LenB(args)
        .hwndOwner = GetHwnd(owner)
        .lpstrFilter = tFilter
        .nFilterIndex = 1
        '.hInstance = Application.HinstancePtr
        .nMaxFile = 1024
        .lpstrFile = tSuggestionFile & String(.nMaxFile + 2 - Len(tSuggestionFile), vbNullChar)      '#### Maximal 1024 Zeichen + zwei 0-Bytes am Ende
        .nMaxFileTitle = .nMaxFile
        .lpstrFileTitle = .lpstrFile
        .lpstrInitialDir = tSuggestionPath & vbNullChar
        .lpstrTitle = tCaption
        .flags = OFN_PATHMUSTEXIST Or OFN_FILEMUSTEXIST Or OFN_EXPLORER Or OFN_HIDEREADONLY
    End With

    lReturn = GetOpenFileName(args)
    If lReturn = 0 Then
        SelectOpenFile = vbNullString
    Else
        SelectOpenFile = Left$(args.lpstrFile, InStr(args.lpstrFile, vbNullChar) - 1)
    End If

    DoEvents
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectOpenFiles
'| ReturnType : String
'| DateTime   : 20.04.2006 09:41
'| Author     : Kremm
'| Purpose    : Zeigt den Datei-|fffd|ffnen-Dialog an, und unterst|fffd|tzt Mehrfachauswahl
'`------------------------------------------------------------------------------------
'
Public Function SelectOpenFiles(owner As Object, tCaption As String, tSuggestion As String, ParamArray vFilter()) As String()
    Dim args                            As OPENFILENAME
    Dim lReturn                         As Long
    Dim tFilter                         As String
    Dim i                               As Long
    Dim temp()                          As String
    Dim baseDir                         As String
    Dim result()                        As String

    If Not IsMissing(vFilter) Then
        For i = LBound(vFilter) To UBound(vFilter)
            tFilter = tFilter & vFilter(i) & Chr(0)
        Next i
    Else
        tFilter = "Alle Dateien (*.*)" & Chr(0) & "*.*" & Chr(0)
    End If

    With args
        .lStructSize = Len(args)
        .hwndOwner = GetHwnd(owner)
        .lpstrFilter = tFilter
        .nFilterIndex = 1
        .hInstance = 0
        .lpstrFile = GetFile(tSuggestion) & String(1026 - Len(GetFile(tSuggestion)), Chr(0))    '#### Maximal 1024 Zeilen + zwei 0-Bytes am Ende
        .nMaxFile = Len(args.lpstrFile) - 2
        .lpstrFileTitle = args.lpstrFile
        .nMaxFileTitle = args.nMaxFile
        .lpstrInitialDir = GetFolder(tSuggestion) & Chr(0)
        .lpstrTitle = tCaption
        .flags = OFN_PATHMUSTEXIST Or OFN_FILEMUSTEXIST Or OFN_ALLOWMULTISELECT Or OFN_EXPLORER Or OFN_HIDEREADONLY
    End With

    lReturn = GetOpenFileName(args)
    If lReturn = 0 Then
        ReDim result(0 To 0)
    ElseIf lReturn = 1 Then
        args.lpstrFile = Left(args.lpstrFile, InStr(args.lpstrFile, Chr(0) & Chr(0)) - 1)
        If InStr(args.lpstrFile, Chr(0)) > 0 Then
            temp = Split(args.lpstrFile, Chr(0))
            baseDir = temp(0)
            ReDim result(LBound(temp) To UBound(temp) - 1)
            For i = LBound(temp) To UBound(temp) - 1
                result(i) = baseDir & "\" & temp(i + 1)
            Next i
        Else
            ReDim result(0 To 0)
            result(0) = args.lpstrFile
        End If
    Else
        args.lpstrFile = Left(args.lpstrFile, InStr(args.lpstrFile, Chr(0) & Chr(0)))
        result = Split(args.lpstrFile, Chr(0))
    End If
    SelectOpenFiles = result

    DoEvents
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectSaveFile
'| ReturnType : String
'| DateTime   : 20.04.2006 09:40
'| Author     : Kremm
'| Purpose    : Zeigt den Datei-Speichern-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectSaveFile(owner As Object, tCaption As String, tSuggestion As String, ParamArray vFilter() As Variant) As String
    Dim args                            As OPENFILENAME
    Dim lReturn                         As Long
    Dim tFilter                         As String
    Dim i                               As Long
    Dim tSuggestionFile                 As String
    Dim tSuggestionPath                 As String

    tSuggestionFile = GetFile(tSuggestion)
    tSuggestionPath = GetFolder(tSuggestion)

    If Not IsMissing(vFilter) Then
        For i = LBound(vFilter) To UBound(vFilter)
            tFilter = tFilter & CStr(vFilter(i)) & vbNullChar
        Next i
    Else
        tFilter = "Alle Dateien (*.*)" & vbNullChar & "*.*" & vbNullChar
    End If

    With args
        .lStructSize = LenB(args)
        .hwndOwner = GetHwnd(owner)
        .lpstrFilter = tFilter
        .nFilterIndex = 1
        '.hInstance = Application.HinstancePtr
        .nMaxFile = 1024
        .lpstrFile = tSuggestionFile & String(.nMaxFile + 2 - Len(tSuggestionFile), vbNullChar)      '#### Maximal 1024 Zeichen + zwei 0-Bytes am Ende
        .nMaxFileTitle = .nMaxFile
        .lpstrFileTitle = .lpstrFile
        .lpstrInitialDir = tSuggestionPath & vbNullChar
        .lpstrTitle = tCaption
        .flags = OFN_PATHMUSTEXIST Or OFN_EXPLORER Or OFN_HIDEREADONLY
    End With

    lReturn = GetSaveFileName(args)
    If lReturn = 0 Then
        SelectSaveFile = vbNullString
    Else
        SelectSaveFile = Left$(args.lpstrFile, InStr(args.lpstrFile, vbNullChar) - 1)
    End If

    DoEvents
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectColor
'| ReturnType : Long
'| DateTime   : 20.04.2006 09:40
'| Author     : Kremm
'| Purpose    : Zeigt den Farbauswahl-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectColor(owner As Object) As Long
    Dim args                            As ChooseColorArguments

    args.lStructSize = Len(args)
    args.hwndOwner = GetHwnd(owner)
    args.hInstance = 0
    args.lpCustColors = StrConv(CustomColors, vbUnicode)
    args.flags = 0
    If ChooseColorAPI(args) <> 0 Then
        SelectColor = args.rgbResult
    End If
End Function

'---------------------------------------------------------------------------------------
' Procedure : SelectFolderNew
' Date      : 10.04.2014 16:08
' Author    : Lutzeier
' Purpose   :
'---------------------------------------------------------------------------------------
'
Public Function SelectFolderNew(sTitle As String, Optional sPath As String = vbNullString) As String
    Dim dlgFolder             As FileDialog
    Dim sItem                 As String
 
    Set dlgFolder = Application.FileDialog(msoFileDialogFolderPicker)
 
    With dlgFolder
        .AllowMultiSelect = False
        .Title = IIf(Len(sTitle) > 0, sTitle, "")
        .InitialFileName = IIf(Len(sPath) > 0, sPath & "\*.*", "")
        If .Show <> -1 Then GoTo NextCode
        sItem = .SelectedItems(1)
    End With
NextCode:
    SelectFolderNew = sItem
    Set dlgFolder = Nothing
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function SelectFolder
'| ReturnType : String
'| DateTime   : 20.04.2006 09:40
'| Author     : Kremm
'| Purpose    : Zeigt den Ordnerauswahl-Dialog an
'`------------------------------------------------------------------------------------
'
Public Function SelectFolder(owner As Object, Optional dlgTitle As String = vbNullString, Optional defaultPath As String = vbNullString) As String
    Dim args                            As SelectFolderArguments
    Dim lpIDList                        As Long
    Dim sBuffer                         As String

    args.hwndOwner = GetHwnd(owner)
    args.lpszTitle = dlgTitle & Chr(0)
    args.ulFlags = BIF_RETURNONLYFSDIRS + BIF_DONTGOBELOWDOMAIN + BIF_VALIDATE
    args.lpfn = ProcAddr(AddressOf SelectFolderCallback)
    If Len(defaultPath) > 0 Then
        args.lParam = PathToPIDL(defaultPath)
    End If

    lpIDList = SHBrowseForFolder(args)

    If lpIDList Then
        sBuffer = Space$(MAX_PATH)
        Call SHGetPathFromIDList(lpIDList, sBuffer)
        sBuffer = Left$(sBuffer, InStr(sBuffer, vbNullChar) - 1)
        SelectFolder = sBuffer
    Else
        SelectFolder = vbNullString
    End If
End Function

Private Function SelectFolderCallback(ByVal hwnd As Long, ByVal uMsg As Long, ByVal lParam As Long, ByVal lpData As Long) As Long
    If uMsg = BFFM_INITIALIZED Then    '#### Dialog wurde initialisiert
        '#### Standard-Pfad im Dialog selektieren (Pointer in lpData):
        Call SendMessage(hwnd, BFFM_SETSELECTIONA, False, ByVal lpData)
    End If
End Function

Private Function PathToPIDL(ByVal sPath As String) As Long
    Dim lRet                            As Long

    lRet = ILCreateFromPath(sPath)
    If lRet = 0 Then
        sPath = StrConv(sPath, VbStrConv.vbUnicode)
        lRet = ILCreateFromPath(sPath)
    End If

    PathToPIDL = lRet
End Function

Private Function GetFile(tFileName As String) As String
    If InStr(tFileName, "\") > 0 Then
        GetFile = Mid$(tFileName, InStrRev(tFileName, "\") + 1)
    Else
        GetFile = tFileName
    End If
End Function

Private Function GetFolder(tFileName As String) As String
    If InStr(tFileName, "\") > 0 Then
        GetFolder = Left$(tFileName, InStrRev(tFileName, "\") - 1)
    Else
        GetFolder = tFileName
    End If
End Function

',------------------------------------------------------------------------------------
'| Procedure  : Function MsgBoxEx
'| ReturnType : VbMsgBoxResult
'| DateTime   :
'| Author     : Kremm
'| Purpose    : Ersatz f|fffd|r die eingebaute MsgBox-Funktion. Kann genau wie diese
'|              verwendet werden. Zeigt bei einigen VbMsgBoxStyles vor dem Nachrichten-
'|              Text automatisch eine passende |fffd|berschrift an. F|fffd|r den Titel der MsgBox
'|              wird automatisch der Projektname verwendet.
'| Remarks    :
'               180820 AG auskommentiert weil Setup(LI) unbekannt
'`------------------------------------------------------------------------------------
'
'Public Function MsgBoxEx(ByVal tMessage As String, eStyle As VbMsgBoxStyle, ParamArray vParameters() As Variant) As VbMsgBoxResult
'    Dim i                               As Long
'    Dim hWndParent                      As LongPtr
'
'    '#### Stil auswerten:
'    If (eStyle And vbInformation) = vbInformation Then
'        '### Keine |fffd|berschrift!
'    ElseIf (eStyle And vbQuestion) = vbQuestion Then
'        '### Keine |fffd|berschrift!
'    ElseIf (eStyle And vbExclamation) = vbExclamation Then
'        tMessage = Language("Basic", "Warning", Setup(LI)) & vbCr & vbCr & tMessage
'    ElseIf (eStyle And vbCritical) = vbCritical Then
'        tMessage = Language("Basic", "Error", Setup(LI)) & vbCr & vbCr & tMessage
'    End If
'
'    '#### Parameter ersetzen:
'    For i = LBound(vParameters) To UBound(vParameters)
'        tMessage = Replace(tMessage, "%" & CStr(i), CStr(vParameters(i)))
'    Next i
'
'    '#### Sonderzeichen ersetzen:
'    tMessage = Replace(tMessage, "\\", vbNullChar)
'    tMessage = Replace(tMessage, "\n", vbLf)
'    tMessage = Replace(tMessage, "\r", vbCr)
'    tMessage = Replace(tMessage, "\t", vbTab)
'    tMessage = Replace(tMessage, vbNullChar, "\")
'
'    '#### Das gerade aktive Fenster ist der Parent:
'    hWndParent = GetActiveWindow()
'
'    '#### MessageBox anzeigen:
'    MsgBoxEx = MessageBox(hWndParent, StrPtr(tMessage), StrPtr(ThisWorkbook.Name), eStyle)
'End Function

#End If

' InQuest injected base64 decoded content
' z{Li
' j{"r

INQUEST-PP=macro
